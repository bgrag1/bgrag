[
    {
        "cve_id": "CVE-2018-21027",
        "func_name": "gpg/boa/escape_pathname",
        "description": "Boa through 0.94.14rc21 allows remote attackers to trigger an out-of-memory (OOM) condition because malloc is mishandled.",
        "git_url": "https://github.com/gpg/boa/commit/e139b87835994d007fbd64eead6c1455d7b8cf4e",
        "commit_title": "misc oom and possible memory leak fix",
        "commit_text": "",
        "func_before": "static char *escape_pathname(const char *inp)\n{\n    const unsigned char *s;\n    char *escaped, *d;\n\n    if (!inp) {\n        return NULL;\n    }\n    escaped = malloc (4 * strlen(inp) + 1);\n    if (!escaped) {\n    \tperror(\"malloc\");\n\treturn NULL;\n    }\n    for (d = escaped, s = (const unsigned char *)inp; *s; s++) {\n        if (needs_escape (*s)) {\n            snprintf (d, 5, \"\\\\x%02x\", *s);\n            d += strlen (d);\n        } else {\n            *d++ = *s;\n        }\n    }\n    *d++ = '\\0';\n    return escaped;\n}",
        "func": "static char *escape_pathname(const char *inp)\n{\n    const unsigned char *s;\n    char *escaped, *d;\n\n    if (!inp) {\n        return NULL;\n    }\n    escaped = malloc (4 * strlen(inp) + 1);\n    if (!escaped) {\n\t\tperror(\"malloc\");\n\t\treturn NULL;\n    }\n    for (d = escaped, s = (const unsigned char *)inp; *s; s++) {\n        if (needs_escape (*s)) {\n            snprintf (d, 5, \"\\\\x%02x\", *s);\n            d += strlen (d);\n        } else {\n            *d++ = *s;\n        }\n    }\n    *d++ = '\\0';\n    return escaped;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,8 +8,8 @@\n     }\n     escaped = malloc (4 * strlen(inp) + 1);\n     if (!escaped) {\n-    \tperror(\"malloc\");\n-\treturn NULL;\n+\t\tperror(\"malloc\");\n+\t\treturn NULL;\n     }\n     for (d = escaped, s = (const unsigned char *)inp; *s; s++) {\n         if (needs_escape (*s)) {",
        "diff_line_info": {
            "deleted_lines": [
                "    \tperror(\"malloc\");",
                "\treturn NULL;"
            ],
            "added_lines": [
                "\t\tperror(\"malloc\");",
                "\t\treturn NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-21027",
        "func_name": "gpg/boa/strstr",
        "description": "Boa through 0.94.14rc21 allows remote attackers to trigger an out-of-memory (OOM) condition because malloc is mishandled.",
        "git_url": "https://github.com/gpg/boa/commit/e139b87835994d007fbd64eead6c1455d7b8cf4e",
        "commit_title": "misc oom and possible memory leak fix",
        "commit_text": "",
        "func_before": "char *strstr(char *s1, char *s2)\n{                               /* from libiberty */\n    char *p;\n    int len = strlen(s2);\n\n    if (*s2 == '\\0')            /* everything matches empty string */\n        return s1;\n    for (p = s1; (p = strchr(p, *s2)) != NULL; p = strchr(p + 1, *s2)) {\n        if (strncmp(p, s2, len) == 0)\n            return (p);\n    }\n    return NULL;\n}",
        "func": "char *strstr(char *s1, char *s2)\n{                               /* from libiberty */\n    char *p;\n    int len = strlen(s2);\n\n    if (*s2 == '\\0')            /* everything matches empty string */\n        return s1;\n    for (p = s1; (p = strchr(p, *s2)) != NULL; p++) {\n        if (strncmp(p, s2, len) == 0)\n            return (p);\n    }\n    return NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n \n     if (*s2 == '\\0')            /* everything matches empty string */\n         return s1;\n-    for (p = s1; (p = strchr(p, *s2)) != NULL; p = strchr(p + 1, *s2)) {\n+    for (p = s1; (p = strchr(p, *s2)) != NULL; p++) {\n         if (strncmp(p, s2, len) == 0)\n             return (p);\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    for (p = s1; (p = strchr(p, *s2)) != NULL; p = strchr(p + 1, *s2)) {"
            ],
            "added_lines": [
                "    for (p = s1; (p = strchr(p, *s2)) != NULL; p++) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-21027",
        "func_name": "gpg/boa/scandir",
        "description": "Boa through 0.94.14rc21 allows remote attackers to trigger an out-of-memory (OOM) condition because malloc is mishandled.",
        "git_url": "https://github.com/gpg/boa/commit/e139b87835994d007fbd64eead6c1455d7b8cf4e",
        "commit_title": "misc oom and possible memory leak fix",
        "commit_text": "",
        "func_before": "int\nscandir(const char *dir, struct dirent ***namelist,\n        int (*select) (const struct dirent *),\n        int (*compar) (const struct dirent **, const struct dirent **))\n{\n    DIR *d = opendir(dir);\n    struct dirent *current;\n    struct dirent **names;\n    int count = 0;\n    int pos = 0;\n    int result = -1;\n\n    if (NULL == d)\n        return -1;\n\n    while (NULL != readdir(d))\n        count++;\n\n    names = malloc(sizeof (struct dirent *) * count);\n\n    closedir(d);\n    d = opendir(dir);\n    if (NULL == d)\n        return -1;\n\n    while (NULL != (current = readdir(d))) {\n        if (NULL == select || select(current)) {\n            struct dirent *copyentry = malloc(current->d_reclen);\n\n            memcpy(copyentry, current, current->d_reclen);\n\n            names[pos] = copyentry;\n            pos++;\n        }\n    }\n    result = closedir(d);\n\n    if (pos != count)\n        names = realloc(names, sizeof (struct dirent *) * pos);\n\n    *namelist = names;\n\n    return pos;\n}",
        "func": "int\nscandir(const char *dir, struct dirent ***namelist,\n        int (*select) (const struct dirent *),\n        int (*compar) (const struct dirent **, const struct dirent **))\n{\n    DIR *d = opendir(dir);\n    struct dirent *current;\n    struct dirent **names;\n    int count = 0;\n    int pos = 0;\n    int result = -1;\n\n    if (NULL == d)\n        return -1;\n\n    while (NULL != readdir(d))\n        count++;\n\t\n\tclosedir(d);\n\t\n    names = malloc(sizeof (struct dirent *) * count);\n\tif (!names) \n\t\treturn -1;\n\n    d = opendir(dir);\n    if (NULL == d) {\n\t\tfree(names);\n        return -1;\n    }\n\n    while (NULL != (current = readdir(d))) {\n        if (NULL == select || select(current)) {\n            struct dirent *copyentry = malloc(current->d_reclen);\n\t\t\t/* FIXME: OOM, silently skip it?*/\n\t\t\tif (!copyentry)\n\t\t\t\tcontinue;\n\t\t\t\n            memcpy(copyentry, current, current->d_reclen);\n\n            names[pos] = copyentry;\n            pos++;\n        }\n    }\n    result = closedir(d);\n\n    if (pos != count)\n        names = realloc(names, sizeof (struct dirent *) * pos);\n\n    *namelist = names;\n\n    return pos;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,18 +15,26 @@\n \n     while (NULL != readdir(d))\n         count++;\n+\t\n+\tclosedir(d);\n+\t\n+    names = malloc(sizeof (struct dirent *) * count);\n+\tif (!names) \n+\t\treturn -1;\n \n-    names = malloc(sizeof (struct dirent *) * count);\n-\n-    closedir(d);\n     d = opendir(dir);\n-    if (NULL == d)\n+    if (NULL == d) {\n+\t\tfree(names);\n         return -1;\n+    }\n \n     while (NULL != (current = readdir(d))) {\n         if (NULL == select || select(current)) {\n             struct dirent *copyentry = malloc(current->d_reclen);\n-\n+\t\t\t/* FIXME: OOM, silently skip it?*/\n+\t\t\tif (!copyentry)\n+\t\t\t\tcontinue;\n+\t\t\t\n             memcpy(copyentry, current, current->d_reclen);\n \n             names[pos] = copyentry;",
        "diff_line_info": {
            "deleted_lines": [
                "    names = malloc(sizeof (struct dirent *) * count);",
                "",
                "    closedir(d);",
                "    if (NULL == d)",
                ""
            ],
            "added_lines": [
                "\t",
                "\tclosedir(d);",
                "\t",
                "    names = malloc(sizeof (struct dirent *) * count);",
                "\tif (!names) ",
                "\t\treturn -1;",
                "    if (NULL == d) {",
                "\t\tfree(names);",
                "    }",
                "\t\t\t/* FIXME: OOM, silently skip it?*/",
                "\t\t\tif (!copyentry)",
                "\t\t\t\tcontinue;",
                "\t\t\t"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-21027",
        "func_name": "gpg/boa/main",
        "description": "Boa through 0.94.14rc21 allows remote attackers to trigger an out-of-memory (OOM) condition because malloc is mishandled.",
        "git_url": "https://github.com/gpg/boa/commit/e139b87835994d007fbd64eead6c1455d7b8cf4e",
        "commit_title": "misc oom and possible memory leak fix",
        "commit_text": "",
        "func_before": "int main(int argc, char *argv[])\n{\n    char buff[1024];\n    int fd, nr, nw;\n    if (argc < 2) {\n        fprintf(stderr,\n                \"usage: %s output-filename\\n\"\n                \"       %s |output-command\\n\"\n                \"       %s :host:port\\n\", argv[0], argv[0], argv[0]);\n        return 1;\n    }\n    fd = open_gen_fd(argv[1]);\n    if (fd < 0) {\n        perror(\"open_gen_fd\");\n        exit(EXIT_FAILURE);\n    }\n    while ((nr = read(0, buff, sizeof (buff))) != 0) {\n        if (nr < 0) {\n            if (errno == EINTR)\n                continue;\n            perror(\"read\");\n            exit(EXIT_FAILURE);\n        }\n        nw = write(fd, buff, nr);\n        if (nw < 0) {\n            perror(\"write\");\n            exit(EXIT_FAILURE);\n        }\n    }\n    return 0;\n}",
        "func": "int main(int argc, char *argv[])\n{\n    char buff[1024];\n    int fd, nr, nw;\n    if (argc < 2) {\n        fprintf(stderr,\n                \"usage: %s output-filename\\n\"\n                \"       %s |output-command\\n\"\n                \"       %s :host:port\\n\", argv[0], argv[0], argv[0]);\n        return 1;\n    }\n    fd = open_gen_fd(argv[1]);\n    if (fd < 0) {\n        perror(\"open_gen_fd\");\n        exit(EXIT_FAILURE);\n    }\n    while ((nr = read(0, buff, sizeof (buff))) != 0) {\n        if (nr < 0) {\n            if (errno == EINTR)\n                continue;\n            perror(\"read\");\n            exit(EXIT_FAILURE);\n        }\n        nw = write(fd, buff, nr);\n        if (nw < 0) {\n            perror(\"write\");\n            exit(EXIT_FAILURE);\n        }\n    }\n\tclose(fd);\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -27,5 +27,6 @@\n             exit(EXIT_FAILURE);\n         }\n     }\n+\tclose(fd);\n     return 0;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tclose(fd);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-21027",
        "func_name": "gpg/boa/main",
        "description": "Boa through 0.94.14rc21 allows remote attackers to trigger an out-of-memory (OOM) condition because malloc is mishandled.",
        "git_url": "https://github.com/gpg/boa/commit/e139b87835994d007fbd64eead6c1455d7b8cf4e",
        "commit_title": "misc oom and possible memory leak fix",
        "commit_text": "",
        "func_before": "int main(int argc, char *argv[])\n{\n    time_t timep;\n    struct tm *timeptr;\n    char *now;\n\n    if (argc < 3) {\n        send_error(1);\n        return -1;\n    } else if (argc > 3) {\n        send_error(5);\n        return -1;\n    }\n\n    build_needs_escape();\n\n    if (argv[2] == NULL)\n        index_directory(argv[1], argv[1]);\n    else\n        index_directory(argv[1], argv[2]);\n\n    time(&timep);\n#ifdef USE_LOCALTIME\n    timeptr = localtime(&timep);\n#else\n    timeptr = gmtime(&timep);\n#endif\n    now = strdup(asctime(timeptr));\n    now[strlen(now) - 1] = '\\0';\n#ifdef USE_LOCALTIME\n    printf(\"</table>\\n<hr noshade>\\nIndex generated %s %s\\n\"\n           \"<!-- This program is part of the Boa Webserver Copyright (C) 1991-2002 http://www.boa.org -->\\n\"\n           \"</body>\\n</html>\\n\", now, TIMEZONE(timeptr));\n#else\n    printf(\"</table>\\n<hr noshade>\\nIndex generated %s UTC\\n\"\n           \"<!-- This program is part of the Boa Webserver Copyright (C) 1991-2002 http://www.boa.org -->\\n\"\n           \"</body>\\n</html>\\n\", now);\n#endif\n\n    return 0;\n}",
        "func": "int main(int argc, char *argv[])\n{\n    time_t timep;\n    struct tm *timeptr;\n    char *now;\n\n    if (argc < 3) {\n        send_error(1);\n        return -1;\n    } else if (argc > 3) {\n        send_error(5);\n        return -1;\n    }\n\n    build_needs_escape();\n\n    if (argv[2] == NULL)\n        index_directory(argv[1], argv[1]);\n    else\n        index_directory(argv[1], argv[2]);\n\n    time(&timep);\n#ifdef USE_LOCALTIME\n    timeptr = localtime(&timep);\n#else\n    timeptr = gmtime(&timep);\n#endif\n    now = strdup(asctime(timeptr));\n\tif (!now) {\n\t\treturn -1;\n\t}\n    now[strlen(now) - 1] = '\\0';\n#ifdef USE_LOCALTIME\n    printf(\"</table>\\n<hr noshade>\\nIndex generated %s %s\\n\"\n           \"<!-- This program is part of the Boa Webserver Copyright (C) 1991-2002 http://www.boa.org -->\\n\"\n           \"</body>\\n</html>\\n\", now, TIMEZONE(timeptr));\n#else\n    printf(\"</table>\\n<hr noshade>\\nIndex generated %s UTC\\n\"\n           \"<!-- This program is part of the Boa Webserver Copyright (C) 1991-2002 http://www.boa.org -->\\n\"\n           \"</body>\\n</html>\\n\", now);\n#endif\n\tfree(now);\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,6 +26,9 @@\n     timeptr = gmtime(&timep);\n #endif\n     now = strdup(asctime(timeptr));\n+\tif (!now) {\n+\t\treturn -1;\n+\t}\n     now[strlen(now) - 1] = '\\0';\n #ifdef USE_LOCALTIME\n     printf(\"</table>\\n<hr noshade>\\nIndex generated %s %s\\n\"\n@@ -36,6 +39,6 @@\n            \"<!-- This program is part of the Boa Webserver Copyright (C) 1991-2002 http://www.boa.org -->\\n\"\n            \"</body>\\n</html>\\n\", now);\n #endif\n-\n+\tfree(now);\n     return 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                ""
            ],
            "added_lines": [
                "\tif (!now) {",
                "\t\treturn -1;",
                "\t}",
                "\tfree(now);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18198",
        "func_name": "torvalds/linux/fib6_rule_suppress",
        "description": "In the Linux kernel before 5.3.4, a reference count usage error in the fib6_rule_suppress() function in the fib6 suppression feature of net/ipv6/fib6_rules.c, when handling the FIB_LOOKUP_NOREF flag, can be exploited by a local attacker to corrupt memory, aka CID-ca7a03c41753.",
        "git_url": "https://github.com/torvalds/linux/commit/ca7a03c4175366a92cee0ccc4fec0038c3266e26",
        "commit_title": "ipv6: do not free rt if FIB_LOOKUP_NOREF is set on suppress rule",
        "commit_text": " Commit 7d9e5f422150 removed references from certain dsts, but accounting for this never translated down into the fib6 suppression code. This bug was triggered by WireGuard users who use wg-quick(8), which uses the \"suppress-prefix\" directive to ip-rule(8) for routing all of their internet traffic without routing loops. The test case added here causes the reference underflow by causing packets to evaluate a suppress rule. ",
        "func_before": "static bool fib6_rule_suppress(struct fib_rule *rule, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct rt6_info *rt = res->rt6;\n\tstruct net_device *dev = NULL;\n\n\tif (!rt)\n\t\treturn false;\n\n\tif (rt->rt6i_idev)\n\t\tdev = rt->rt6i_idev->dev;\n\n\t/* do not accept result if the route does\n\t * not meet the required prefix length\n\t */\n\tif (rt->rt6i_dst.plen <= rule->suppress_prefixlen)\n\t\tgoto suppress_route;\n\n\t/* do not accept result if the route uses a device\n\t * belonging to a forbidden interface group\n\t */\n\tif (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup)\n\t\tgoto suppress_route;\n\n\treturn false;\n\nsuppress_route:\n\tip6_rt_put(rt);\n\treturn true;\n}",
        "func": "static bool fib6_rule_suppress(struct fib_rule *rule, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct rt6_info *rt = res->rt6;\n\tstruct net_device *dev = NULL;\n\n\tif (!rt)\n\t\treturn false;\n\n\tif (rt->rt6i_idev)\n\t\tdev = rt->rt6i_idev->dev;\n\n\t/* do not accept result if the route does\n\t * not meet the required prefix length\n\t */\n\tif (rt->rt6i_dst.plen <= rule->suppress_prefixlen)\n\t\tgoto suppress_route;\n\n\t/* do not accept result if the route uses a device\n\t * belonging to a forbidden interface group\n\t */\n\tif (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup)\n\t\tgoto suppress_route;\n\n\treturn false;\n\nsuppress_route:\n\tif (!(arg->flags & FIB_LOOKUP_NOREF))\n\t\tip6_rt_put(rt);\n\treturn true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,6 +25,7 @@\n \treturn false;\n \n suppress_route:\n-\tip6_rt_put(rt);\n+\tif (!(arg->flags & FIB_LOOKUP_NOREF))\n+\t\tip6_rt_put(rt);\n \treturn true;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tip6_rt_put(rt);"
            ],
            "added_lines": [
                "\tif (!(arg->flags & FIB_LOOKUP_NOREF))",
                "\t\tip6_rt_put(rt);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-6384",
        "func_name": "atheme/login_user",
        "description": "Memory leak in the login_user function in saslserv/main.c in saslserv/main.so in Atheme 7.2.7 allows a remote unauthenticated attacker to consume memory and cause a denial of service. This is fixed in 7.2.8.",
        "git_url": "https://github.com/atheme/atheme/commit/a80355d2971f6453ef9c6c9507e8f0d16e55dd0f",
        "commit_title": "saslserv/main: free sasl_sourceinfo_t after use",
        "commit_text": "",
        "func_before": "static myuser_t *login_user(sasl_session_t *p)\n{\n\tmyuser_t *source_mu, *target_mu;\n\thook_user_login_check_t req;\n\n\t/* source_mu is the user whose credentials we verified (\"authentication id\") */\n\t/* target_mu is the user who will be ultimately logged in (\"authorization id\") */\n\n\tsource_mu = myuser_find_by_nick(p->username);\n\tif(source_mu == NULL)\n\t\treturn NULL;\n\n\treq.si = sasl_sourceinfo_create(p);\n\treq.mu = source_mu;\n\treq.allowed = true;\n\thook_call_user_can_login(&req);\n\tif (!req.allowed)\n\t{\n\t\tsasl_logcommand(p, source_mu, CMDLOG_LOGIN, \"failed LOGIN to \\2%s\\2 (denied by hook)\", entity(source_mu)->name);\n\t\treturn NULL;\n\t}\n\n\tif(p->authzid && *p->authzid)\n\t{\n\t\ttarget_mu = myuser_find_by_nick(p->authzid);\n\t\tif(target_mu == NULL)\n\t\t\treturn NULL;\n\t}\n\telse\n\t{\n\t\ttarget_mu = source_mu;\n\t\tif(p->authzid != NULL)\n\t\t\tfree(p->authzid);\n\t\tp->authzid = sstrdup(p->username);\n\t}\n\n\tif(metadata_find(source_mu, \"private:freeze:freezer\"))\n\t{\n\t\tsasl_logcommand(p, source_mu, CMDLOG_LOGIN, \"failed LOGIN to \\2%s\\2 (frozen)\", entity(source_mu)->name);\n\t\treturn NULL;\n\t}\n\n\tif(target_mu != source_mu)\n\t{\n\t\tif(!may_impersonate(source_mu, target_mu))\n\t\t{\n\t\t\tsasl_logcommand(p, source_mu, CMDLOG_LOGIN, \"denied IMPERSONATE by \\2%s\\2 to \\2%s\\2\", entity(source_mu)->name, entity(target_mu)->name);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tsasl_logcommand(p, source_mu, CMDLOG_LOGIN, \"allowed IMPERSONATE by \\2%s\\2 to \\2%s\\2\", entity(source_mu)->name, entity(target_mu)->name);\n\n\t\treq.mu = target_mu;\n\t\treq.allowed = true;\n\t\thook_call_user_can_login(&req);\n\t\tif (!req.allowed)\n\t\t{\n\t\t\tsasl_logcommand(p, source_mu, CMDLOG_LOGIN, \"failed LOGIN to \\2%s\\2 (denied by hook)\", entity(target_mu)->name);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif(metadata_find(target_mu, \"private:freeze:freezer\"))\n\t\t{\n\t\t\tsasl_logcommand(p, target_mu, CMDLOG_LOGIN, \"failed LOGIN to \\2%s\\2 (frozen)\", entity(target_mu)->name);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif(MOWGLI_LIST_LENGTH(&target_mu->logins) >= me.maxlogins)\n\t{\n\t\tsasl_logcommand(p, target_mu, CMDLOG_LOGIN, \"failed LOGIN to \\2%s\\2 (too many logins)\", entity(target_mu)->name);\n\t\treturn NULL;\n\t}\n\n\t/* Log it with the full n!u@h later */\n\tp->flags |= ASASL_NEED_LOG;\n\n\t/* We just did SASL authentication for a user.  With IRCds which do not\n\t * have unique UIDs for users, we will likely be expecting the login\n\t * data to be bursted.  As a result, we should give the core a heads'\n\t * up that this is going to happen so that hooks will be properly\n\t * fired...\n\t */\n\tif(ircd->flags & IRCD_SASL_USE_PUID)\n\t{\n\t\ttarget_mu->flags &= ~MU_NOBURSTLOGIN;\n\t\ttarget_mu->flags |= MU_PENDINGLOGIN;\n\t}\n\n\treturn target_mu;\n}",
        "func": "static myuser_t *login_user(sasl_session_t *p)\n{\n\tmyuser_t *source_mu, *target_mu;\n\thook_user_login_check_t req;\n\n\t/* source_mu is the user whose credentials we verified (\"authentication id\") */\n\t/* target_mu is the user who will be ultimately logged in (\"authorization id\") */\n\n\tsource_mu = myuser_find_by_nick(p->username);\n\tif(source_mu == NULL)\n\t\treturn NULL;\n\n\treq.si = sasl_sourceinfo_create(p);\n\treq.mu = source_mu;\n\treq.allowed = true;\n\thook_call_user_can_login(&req);\n\tobject_unref(req.si);\n\tif (!req.allowed)\n\t{\n\t\tsasl_logcommand(p, source_mu, CMDLOG_LOGIN, \"failed LOGIN to \\2%s\\2 (denied by hook)\", entity(source_mu)->name);\n\t\treturn NULL;\n\t}\n\n\tif(p->authzid && *p->authzid)\n\t{\n\t\ttarget_mu = myuser_find_by_nick(p->authzid);\n\t\tif(target_mu == NULL)\n\t\t\treturn NULL;\n\t}\n\telse\n\t{\n\t\ttarget_mu = source_mu;\n\t\tif(p->authzid != NULL)\n\t\t\tfree(p->authzid);\n\t\tp->authzid = sstrdup(p->username);\n\t}\n\n\tif(metadata_find(source_mu, \"private:freeze:freezer\"))\n\t{\n\t\tsasl_logcommand(p, source_mu, CMDLOG_LOGIN, \"failed LOGIN to \\2%s\\2 (frozen)\", entity(source_mu)->name);\n\t\treturn NULL;\n\t}\n\n\tif(target_mu != source_mu)\n\t{\n\t\tif(!may_impersonate(source_mu, target_mu))\n\t\t{\n\t\t\tsasl_logcommand(p, source_mu, CMDLOG_LOGIN, \"denied IMPERSONATE by \\2%s\\2 to \\2%s\\2\", entity(source_mu)->name, entity(target_mu)->name);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tsasl_logcommand(p, source_mu, CMDLOG_LOGIN, \"allowed IMPERSONATE by \\2%s\\2 to \\2%s\\2\", entity(source_mu)->name, entity(target_mu)->name);\n\n\t\treq.mu = target_mu;\n\t\treq.allowed = true;\n\t\thook_call_user_can_login(&req);\n\t\tif (!req.allowed)\n\t\t{\n\t\t\tsasl_logcommand(p, source_mu, CMDLOG_LOGIN, \"failed LOGIN to \\2%s\\2 (denied by hook)\", entity(target_mu)->name);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif(metadata_find(target_mu, \"private:freeze:freezer\"))\n\t\t{\n\t\t\tsasl_logcommand(p, target_mu, CMDLOG_LOGIN, \"failed LOGIN to \\2%s\\2 (frozen)\", entity(target_mu)->name);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif(MOWGLI_LIST_LENGTH(&target_mu->logins) >= me.maxlogins)\n\t{\n\t\tsasl_logcommand(p, target_mu, CMDLOG_LOGIN, \"failed LOGIN to \\2%s\\2 (too many logins)\", entity(target_mu)->name);\n\t\treturn NULL;\n\t}\n\n\t/* Log it with the full n!u@h later */\n\tp->flags |= ASASL_NEED_LOG;\n\n\t/* We just did SASL authentication for a user.  With IRCds which do not\n\t * have unique UIDs for users, we will likely be expecting the login\n\t * data to be bursted.  As a result, we should give the core a heads'\n\t * up that this is going to happen so that hooks will be properly\n\t * fired...\n\t */\n\tif(ircd->flags & IRCD_SASL_USE_PUID)\n\t{\n\t\ttarget_mu->flags &= ~MU_NOBURSTLOGIN;\n\t\ttarget_mu->flags |= MU_PENDINGLOGIN;\n\t}\n\n\treturn target_mu;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,7 @@\n \treq.mu = source_mu;\n \treq.allowed = true;\n \thook_call_user_can_login(&req);\n+\tobject_unref(req.si);\n \tif (!req.allowed)\n \t{\n \t\tsasl_logcommand(p, source_mu, CMDLOG_LOGIN, \"failed LOGIN to \\2%s\\2 (denied by hook)\", entity(source_mu)->name);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tobject_unref(req.si);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-0813",
        "func_name": "android/SampleTable::setSyncSampleParams",
        "description": "A denial of service vulnerability in the Android media framework (libstagefright). Product: Android. Versions: 7.0, 7.1.1, 7.1.2. Android ID: A-36531046.",
        "git_url": "https://android.googlesource.com/platform/frameworks/av/+/7fa3f552a6f34ed05c15e64ea30b8eed53f77a41",
        "commit_title": "Fix 'potential memory leak' compiler warning.",
        "commit_text": " This CL fixes the following compiler warning:  frameworks/av/media/libstagefright/SampleTable.cpp:569:9: warning:  Memory allocated by 'new[]' should be deallocated by 'delete[]', not  'delete'.  Bug: 33137046 Test: Compiled with change; no warning generated.  (cherry picked from commit 158c197b668ad684f92829db6a31bee3aec794ba) (cherry picked from commit 37c428cd521351837fccb6864f509f996820b234) ",
        "func_before": "status_t SampleTable::setSyncSampleParams(off64_t data_offset, size_t data_size) {\n    if (mSyncSampleOffset >= 0 || data_size < 8) {\n        return ERROR_MALFORMED;\n    }\n\n    uint8_t header[8];\n    if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n        return ERROR_IO;\n    }\n\n    if (U32_AT(header) != 0) {\n        // Expected version = 0, flags = 0.\n        return ERROR_MALFORMED;\n    }\n\n    uint32_t numSyncSamples = U32_AT(&header[4]);\n\n    if (numSyncSamples < 2) {\n        ALOGV(\"Table of sync samples is empty or has only a single entry!\");\n    }\n\n    uint64_t allocSize = (uint64_t)numSyncSamples * sizeof(uint32_t);\n    if (allocSize > kMaxTotalSize) {\n        ALOGE(\"Sync sample table size too large.\");\n        return ERROR_OUT_OF_RANGE;\n    }\n\n    mTotalSize += allocSize;\n    if (mTotalSize > kMaxTotalSize) {\n        ALOGE(\"Sync sample table size would make sample table too large.\\n\"\n              \"    Requested sync sample table size = %llu\\n\"\n              \"    Eventual sample table size >= %llu\\n\"\n              \"    Allowed sample table size = %llu\\n\",\n              (unsigned long long)allocSize,\n              (unsigned long long)mTotalSize,\n              (unsigned long long)kMaxTotalSize);\n        return ERROR_OUT_OF_RANGE;\n    }\n\n    mSyncSamples = new (std::nothrow) uint32_t[numSyncSamples];\n    if (!mSyncSamples) {\n        ALOGE(\"Cannot allocate sync sample table with %llu entries.\",\n                (unsigned long long)numSyncSamples);\n        return ERROR_OUT_OF_RANGE;\n    }\n\n    if (mDataSource->readAt(data_offset + 8, mSyncSamples,\n            (size_t)allocSize) != (ssize_t)allocSize) {\n        delete mSyncSamples;\n        mSyncSamples = NULL;\n        return ERROR_IO;\n    }\n\n    for (size_t i = 0; i < numSyncSamples; ++i) {\n        if (mSyncSamples[i] == 0) {\n            ALOGE(\"b/32423862, unexpected zero value in stss\");\n            continue;\n        }\n        mSyncSamples[i] = ntohl(mSyncSamples[i]) - 1;\n    }\n\n    mSyncSampleOffset = data_offset;\n    mNumSyncSamples = numSyncSamples;\n\n    return OK;\n}",
        "func": "status_t SampleTable::setSyncSampleParams(off64_t data_offset, size_t data_size) {\n    if (mSyncSampleOffset >= 0 || data_size < 8) {\n        return ERROR_MALFORMED;\n    }\n\n    uint8_t header[8];\n    if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n        return ERROR_IO;\n    }\n\n    if (U32_AT(header) != 0) {\n        // Expected version = 0, flags = 0.\n        return ERROR_MALFORMED;\n    }\n\n    uint32_t numSyncSamples = U32_AT(&header[4]);\n\n    if (numSyncSamples < 2) {\n        ALOGV(\"Table of sync samples is empty or has only a single entry!\");\n    }\n\n    uint64_t allocSize = (uint64_t)numSyncSamples * sizeof(uint32_t);\n    if (allocSize > kMaxTotalSize) {\n        ALOGE(\"Sync sample table size too large.\");\n        return ERROR_OUT_OF_RANGE;\n    }\n\n    mTotalSize += allocSize;\n    if (mTotalSize > kMaxTotalSize) {\n        ALOGE(\"Sync sample table size would make sample table too large.\\n\"\n              \"    Requested sync sample table size = %llu\\n\"\n              \"    Eventual sample table size >= %llu\\n\"\n              \"    Allowed sample table size = %llu\\n\",\n              (unsigned long long)allocSize,\n              (unsigned long long)mTotalSize,\n              (unsigned long long)kMaxTotalSize);\n        return ERROR_OUT_OF_RANGE;\n    }\n\n    mSyncSamples = new (std::nothrow) uint32_t[numSyncSamples];\n    if (!mSyncSamples) {\n        ALOGE(\"Cannot allocate sync sample table with %llu entries.\",\n                (unsigned long long)numSyncSamples);\n        return ERROR_OUT_OF_RANGE;\n    }\n\n    if (mDataSource->readAt(data_offset + 8, mSyncSamples,\n            (size_t)allocSize) != (ssize_t)allocSize) {\n        delete[] mSyncSamples;\n        mSyncSamples = NULL;\n        return ERROR_IO;\n    }\n\n    for (size_t i = 0; i < numSyncSamples; ++i) {\n        if (mSyncSamples[i] == 0) {\n            ALOGE(\"b/32423862, unexpected zero value in stss\");\n            continue;\n        }\n        mSyncSamples[i] = ntohl(mSyncSamples[i]) - 1;\n    }\n\n    mSyncSampleOffset = data_offset;\n    mNumSyncSamples = numSyncSamples;\n\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -47,7 +47,7 @@\n \n     if (mDataSource->readAt(data_offset + 8, mSyncSamples,\n             (size_t)allocSize) != (ssize_t)allocSize) {\n-        delete mSyncSamples;\n+        delete[] mSyncSamples;\n         mSyncSamples = NULL;\n         return ERROR_IO;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "        delete mSyncSamples;"
            ],
            "added_lines": [
                "        delete[] mSyncSamples;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-0818",
        "func_name": "android/MyOpusExtractor::readNextPacket",
        "description": "A vulnerability in the Android media framework (n/a). Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0. Android ID: A-63581671.",
        "git_url": "https://android.googlesource.com/platform/frameworks/av/+/d07f5c14e811951ff9b411ceb84e7288e0d04aaf",
        "commit_title": "Fix memory leak in OggExtractor",
        "commit_text": " Test: added a temporal log and run poc Bug: 63581671 (cherry picked from commit 63079e7c8e12cda4eb124fbe565213d30b9ea34c) ",
        "func_before": "status_t MyOpusExtractor::readNextPacket(MediaBuffer **out) {\n    if (mOffset <= mFirstDataOffset && mStartGranulePosition < 0) {\n        // The first sample might not start at time 0; find out where by subtracting\n        // the number of samples on the first page from the granule position\n        // (position of last complete sample) of the first page. This happens\n        // the first time before we attempt to read a packet from the first page.\n        MediaBuffer *mBuf;\n        uint32_t numSamples = 0;\n        uint64_t curGranulePosition = 0;\n        while (true) {\n            status_t err = _readNextPacket(&mBuf, /* calcVorbisTimestamp = */false);\n            if (err != OK && err != ERROR_END_OF_STREAM) {\n                return err;\n            }\n            // First two pages are header pages.\n            if (err == ERROR_END_OF_STREAM || mCurrentPage.mPageNo > 2) {\n                break;\n            }\n            curGranulePosition = mCurrentPage.mGranulePosition;\n            numSamples += getNumSamplesInPacket(mBuf);\n            mBuf->release();\n            mBuf = NULL;\n        }\n\n        if (curGranulePosition > numSamples) {\n            mStartGranulePosition = curGranulePosition - numSamples;\n        } else {\n            mStartGranulePosition = 0;\n        }\n        seekToOffset(0);\n    }\n\n    status_t err = _readNextPacket(out, /* calcVorbisTimestamp = */false);\n    if (err != OK) {\n        return err;\n    }\n\n    int32_t currentPageSamples;\n    // Calculate timestamps by accumulating durations starting from the first sample of a page;\n    // We assume that we only seek to page boundaries.\n    if ((*out)->meta_data()->findInt32(kKeyValidSamples, &currentPageSamples)) {\n        // first packet in page\n        if (mOffset == mFirstDataOffset) {\n            currentPageSamples -= mStartGranulePosition;\n            (*out)->meta_data()->setInt32(kKeyValidSamples, currentPageSamples);\n        }\n        mCurGranulePosition = mCurrentPage.mGranulePosition - currentPageSamples;\n    }\n\n    int64_t timeUs = getTimeUsOfGranule(mCurGranulePosition);\n    (*out)->meta_data()->setInt64(kKeyTime, timeUs);\n\n    uint32_t frames = getNumSamplesInPacket(*out);\n    mCurGranulePosition += frames;\n    return OK;\n}",
        "func": "status_t MyOpusExtractor::readNextPacket(MediaBuffer **out) {\n    if (mOffset <= mFirstDataOffset && mStartGranulePosition < 0) {\n        // The first sample might not start at time 0; find out where by subtracting\n        // the number of samples on the first page from the granule position\n        // (position of last complete sample) of the first page. This happens\n        // the first time before we attempt to read a packet from the first page.\n        MediaBuffer *mBuf;\n        uint32_t numSamples = 0;\n        uint64_t curGranulePosition = 0;\n        while (true) {\n            status_t err = _readNextPacket(&mBuf, /* calcVorbisTimestamp = */false);\n            if (err != OK && err != ERROR_END_OF_STREAM) {\n                return err;\n            }\n            // First two pages are header pages.\n            if (err == ERROR_END_OF_STREAM || mCurrentPage.mPageNo > 2) {\n                if (mBuf != NULL) {\n                    mBuf->release();\n                    mBuf = NULL;\n                }\n                break;\n            }\n            curGranulePosition = mCurrentPage.mGranulePosition;\n            numSamples += getNumSamplesInPacket(mBuf);\n            mBuf->release();\n            mBuf = NULL;\n        }\n\n        if (curGranulePosition > numSamples) {\n            mStartGranulePosition = curGranulePosition - numSamples;\n        } else {\n            mStartGranulePosition = 0;\n        }\n        seekToOffset(0);\n    }\n\n    status_t err = _readNextPacket(out, /* calcVorbisTimestamp = */false);\n    if (err != OK) {\n        return err;\n    }\n\n    int32_t currentPageSamples;\n    // Calculate timestamps by accumulating durations starting from the first sample of a page;\n    // We assume that we only seek to page boundaries.\n    if ((*out)->meta_data()->findInt32(kKeyValidSamples, &currentPageSamples)) {\n        // first packet in page\n        if (mOffset == mFirstDataOffset) {\n            currentPageSamples -= mStartGranulePosition;\n            (*out)->meta_data()->setInt32(kKeyValidSamples, currentPageSamples);\n        }\n        mCurGranulePosition = mCurrentPage.mGranulePosition - currentPageSamples;\n    }\n\n    int64_t timeUs = getTimeUsOfGranule(mCurGranulePosition);\n    (*out)->meta_data()->setInt64(kKeyTime, timeUs);\n\n    uint32_t frames = getNumSamplesInPacket(*out);\n    mCurGranulePosition += frames;\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,10 @@\n             }\n             // First two pages are header pages.\n             if (err == ERROR_END_OF_STREAM || mCurrentPage.mPageNo > 2) {\n+                if (mBuf != NULL) {\n+                    mBuf->release();\n+                    mBuf = NULL;\n+                }\n                 break;\n             }\n             curGranulePosition = mCurrentPage.mGranulePosition;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "                if (mBuf != NULL) {",
                "                    mBuf->release();",
                "                    mBuf = NULL;",
                "                }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-15033",
        "func_name": "ImageMagick/ReadYUVImage",
        "description": "ImageMagick version 7.0.7-2 contains a memory leak in ReadYUVImage in coders/yuv.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/ef8f40689ac452398026c07da41656a7c87e4683",
        "commit_title": "fix multiple memory leak in ReadYUVImage",
        "commit_text": "",
        "func_before": "static Image *ReadYUVImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *chroma_image,\n    *image,\n    *resize_image;\n\n  InterlaceType\n    interlace;\n\n  MagickBooleanType\n    status;\n\n  register const Quantum\n    *chroma_pixels;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  ssize_t\n    count,\n    horizontal_factor,\n    vertical_factor,\n    y;\n\n  size_t\n    length,\n    quantum;\n\n  unsigned char\n    *scanline;\n\n  /*\n    Allocate image structure.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(OptionError,\"MustSpecifyImageSize\");\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  quantum=(ssize_t) (image->depth <= 8 ? 1 : 2);\n  interlace=image_info->interlace;\n  horizontal_factor=2;\n  vertical_factor=2;\n  if (image_info->sampling_factor != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(image_info->sampling_factor,&geometry_info);\n      horizontal_factor=(ssize_t) geometry_info.rho;\n      vertical_factor=(ssize_t) geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        vertical_factor=horizontal_factor;\n      if ((horizontal_factor != 1) && (horizontal_factor != 2) &&\n          (vertical_factor != 1) && (vertical_factor != 2))\n        ThrowReaderException(CorruptImageError,\"UnexpectedSamplingFactor\");\n    }\n  if ((interlace == UndefinedInterlace) ||\n      ((interlace == NoInterlace) && (vertical_factor == 2)))\n    {\n      interlace=NoInterlace;    /* CCIR 4:2:2 */\n      if (vertical_factor == 2)\n        interlace=PlaneInterlace; /* CCIR 4:1:1 */\n    }\n  if (interlace != PartitionInterlace)\n    {\n      /*\n        Open image file.\n      */\n      status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        {\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n      if (DiscardBlobBytes(image,(MagickSizeType) image->offset) == MagickFalse)\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n    }\n  /*\n    Allocate memory for a scanline.\n  */\n  if (interlace == NoInterlace)\n    scanline=(unsigned char *) AcquireQuantumMemory((size_t) (2UL*\n      image->columns+2UL),(size_t) quantum*sizeof(*scanline));\n  else\n    scanline=(unsigned char *) AcquireQuantumMemory(image->columns,\n      (size_t) quantum*sizeof(*scanline));\n  if (scanline == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  status=MagickTrue;\n  do\n  {\n    chroma_image=CloneImage(image,(image->columns+horizontal_factor-1)/\n      horizontal_factor,(image->rows+vertical_factor-1)/vertical_factor,\n      MagickTrue,exception);\n    if (chroma_image == (Image *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    /*\n      Convert raster image to pixel packets.\n    */\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      break;\n    if (interlace == PartitionInterlace)\n      {\n        AppendImageFormat(\"Y\",image->filename);\n        status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n        if (status == MagickFalse)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n      }\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      register Quantum\n        *chroma_pixels;\n\n      if (interlace == NoInterlace)\n        {\n          if ((y > 0) || (GetPreviousImageInList(image) == (Image *) NULL))\n            {\n              length=2*quantum*image->columns;\n              count=ReadBlob(image,length,scanline);\n              if (count != (ssize_t) length)\n                {\n                  status=MagickFalse;\n                  ThrowFileException(exception,CorruptImageError,\n                    \"UnexpectedEndOfFile\",image->filename);\n                  break;\n                }\n            }\n          p=scanline;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          chroma_pixels=QueueAuthenticPixels(chroma_image,0,y,\n            chroma_image->columns,1,exception);\n          if (chroma_pixels == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x+=2)\n          {\n            SetPixelRed(chroma_image,0,chroma_pixels);\n            if (quantum == 1)\n              SetPixelGreen(chroma_image,ScaleCharToQuantum(*p++),\n                chroma_pixels);\n            else\n              {\n                SetPixelGreen(chroma_image,ScaleShortToQuantum(((*p) << 8) |\n                  *(p+1)),chroma_pixels);\n                p+=2;\n              }\n            if (quantum == 1)\n              SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            else\n              {\n                SetPixelRed(image,ScaleShortToQuantum(((*p) << 8) | *(p+1)),q);\n                p+=2;\n              }\n            SetPixelGreen(image,0,q);\n            SetPixelBlue(image,0,q);\n            q+=GetPixelChannels(image);\n            SetPixelGreen(image,0,q);\n            SetPixelBlue(image,0,q);\n            if (quantum == 1)\n              SetPixelBlue(chroma_image,ScaleCharToQuantum(*p++),chroma_pixels);\n            else\n              {\n                SetPixelBlue(chroma_image,ScaleShortToQuantum(((*p) << 8) |\n                  *(p+1)),chroma_pixels);\n                p+=2;\n              }\n            if (quantum == 1)\n              SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            else\n              {\n                SetPixelRed(image,ScaleShortToQuantum(((*p) << 8) | *(p+1)),q);\n                p+=2;\n              }\n            chroma_pixels+=GetPixelChannels(chroma_image);\n            q+=GetPixelChannels(image);\n          }\n        }\n      else\n        {\n          if ((y > 0) || (GetPreviousImageInList(image) == (Image *) NULL))\n            {\n              length=quantum*image->columns;\n              count=ReadBlob(image,length,scanline);\n              if (count != (ssize_t) length)\n                {\n                  status=MagickFalse;\n                  ThrowFileException(exception,CorruptImageError,\n                    \"UnexpectedEndOfFile\",image->filename);\n                  break;\n                }\n            }\n          p=scanline;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (quantum == 1)\n              SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            else\n              {\n                SetPixelRed(image,ScaleShortToQuantum(((*p) << 8) | *(p+1)),q);\n                p+=2;\n              }\n            SetPixelGreen(image,0,q);\n            SetPixelBlue(image,0,q);\n            q+=GetPixelChannels(image);\n          }\n        }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (interlace == NoInterlace)\n        if (SyncAuthenticPixels(chroma_image,exception) == MagickFalse)\n          break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (interlace == PartitionInterlace)\n      {\n        (void) CloseBlob(image);\n        AppendImageFormat(\"U\",image->filename);\n        status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n        if (status == MagickFalse)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n      }\n    if (interlace != NoInterlace)\n      {\n        for (y=0; y < (ssize_t) chroma_image->rows; y++)\n        {\n          length=quantum*chroma_image->columns;\n          count=ReadBlob(image,length,scanline);\n          if (count != (ssize_t) length)\n            {\n              status=MagickFalse;\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          p=scanline;\n          q=QueueAuthenticPixels(chroma_image,0,y,chroma_image->columns,1,\n            exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) chroma_image->columns; x++)\n          {\n            SetPixelRed(chroma_image,0,q);\n            if (quantum == 1)\n              SetPixelGreen(chroma_image,ScaleCharToQuantum(*p++),q);\n            else\n              {\n                SetPixelGreen(chroma_image,ScaleShortToQuantum(((*p) << 8) |\n                  *(p+1)),q);\n                p+=2;\n              }\n            SetPixelBlue(chroma_image,0,q);\n            q+=GetPixelChannels(chroma_image);\n          }\n          if (SyncAuthenticPixels(chroma_image,exception) == MagickFalse)\n            break;\n        }\n      if (interlace == PartitionInterlace)\n        {\n          (void) CloseBlob(image);\n          AppendImageFormat(\"V\",image->filename);\n          status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n          if (status == MagickFalse)\n            {\n              image=DestroyImageList(image);\n              return((Image *) NULL);\n            }\n        }\n      for (y=0; y < (ssize_t) chroma_image->rows; y++)\n      {\n        length=quantum*chroma_image->columns;\n        count=ReadBlob(image,length,scanline);\n        if (count != (ssize_t) length)\n          {\n            status=MagickFalse;\n            ThrowFileException(exception,CorruptImageError,\n              \"UnexpectedEndOfFile\",image->filename);\n            break;\n          }\n        p=scanline;\n        q=GetAuthenticPixels(chroma_image,0,y,chroma_image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) chroma_image->columns; x++)\n        {\n          if (quantum == 1)\n            SetPixelBlue(chroma_image,ScaleCharToQuantum(*p++),q);\n          else\n            {\n              SetPixelBlue(chroma_image,ScaleShortToQuantum(((*p) << 8) |\n                *(p+1)),q);\n              p+=2;\n            }\n          q+=GetPixelChannels(chroma_image);\n        }\n        if (SyncAuthenticPixels(chroma_image,exception) == MagickFalse)\n          break;\n      }\n    }\n    /*\n      Scale image.\n    */\n    resize_image=ResizeImage(chroma_image,image->columns,image->rows,\n      TriangleFilter,exception);\n    chroma_image=DestroyImage(chroma_image);\n    if (resize_image == (Image *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n      chroma_pixels=GetVirtualPixels(resize_image,0,y,resize_image->columns,1,\n        exception);\n      if ((q == (Quantum *) NULL) ||\n          (chroma_pixels == (const Quantum *) NULL))\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        SetPixelGreen(image,GetPixelGreen(resize_image,chroma_pixels),q);\n        SetPixelBlue(image,GetPixelBlue(resize_image,chroma_pixels),q);\n        chroma_pixels+=GetPixelChannels(resize_image);\n        q+=GetPixelChannels(image);\n      }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n    }\n    resize_image=DestroyImage(resize_image);\n    if (SetImageColorspace(image,YCbCrColorspace,exception) == MagickFalse)\n      break;\n    if (interlace == PartitionInterlace)\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (interlace == NoInterlace)\n      count=ReadBlob(image,(size_t) (2*quantum*image->columns),scanline);\n    else\n      count=ReadBlob(image,(size_t) quantum*image->columns,scanline);\n    if (count != 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (count != 0);\n  scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadYUVImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *chroma_image,\n    *image,\n    *resize_image;\n\n  InterlaceType\n    interlace;\n\n  MagickBooleanType\n    status;\n\n  register const Quantum\n    *chroma_pixels;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  ssize_t\n    count,\n    horizontal_factor,\n    vertical_factor,\n    y;\n\n  size_t\n    length,\n    quantum;\n\n  unsigned char\n    *scanline;\n\n  /*\n    Allocate image structure.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(OptionError,\"MustSpecifyImageSize\");\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  quantum=(ssize_t) (image->depth <= 8 ? 1 : 2);\n  interlace=image_info->interlace;\n  horizontal_factor=2;\n  vertical_factor=2;\n  if (image_info->sampling_factor != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseGeometry(image_info->sampling_factor,&geometry_info);\n      horizontal_factor=(ssize_t) geometry_info.rho;\n      vertical_factor=(ssize_t) geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        vertical_factor=horizontal_factor;\n      if ((horizontal_factor != 1) && (horizontal_factor != 2) &&\n          (vertical_factor != 1) && (vertical_factor != 2))\n        ThrowReaderException(CorruptImageError,\"UnexpectedSamplingFactor\");\n    }\n  if ((interlace == UndefinedInterlace) ||\n      ((interlace == NoInterlace) && (vertical_factor == 2)))\n    {\n      interlace=NoInterlace;    /* CCIR 4:2:2 */\n      if (vertical_factor == 2)\n        interlace=PlaneInterlace; /* CCIR 4:1:1 */\n    }\n  if (interlace != PartitionInterlace)\n    {\n      /*\n        Open image file.\n      */\n      status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n      if (status == MagickFalse)\n        {\n          image=DestroyImageList(image);\n          return((Image *) NULL);\n        }\n      if (DiscardBlobBytes(image,(MagickSizeType) image->offset) == MagickFalse)\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n    }\n  /*\n    Allocate memory for a scanline.\n  */\n  if (interlace == NoInterlace)\n    scanline=(unsigned char *) AcquireQuantumMemory((size_t) (2UL*\n      image->columns+2UL),(size_t) quantum*sizeof(*scanline));\n  else\n    scanline=(unsigned char *) AcquireQuantumMemory(image->columns,\n      (size_t) quantum*sizeof(*scanline));\n  if (scanline == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  status=MagickTrue;\n  do\n  {\n    chroma_image=CloneImage(image,(image->columns+horizontal_factor-1)/\n      horizontal_factor,(image->rows+vertical_factor-1)/vertical_factor,\n      MagickTrue,exception);\n    if (chroma_image == (Image *) NULL)\n      {\n        scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    /*\n      Convert raster image to pixel packets.\n    */\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      break;\n    if (interlace == PartitionInterlace)\n      {\n        AppendImageFormat(\"Y\",image->filename);\n        status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n        if (status == MagickFalse)\n          {\n            scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n      }\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      register Quantum\n        *chroma_pixels;\n\n      if (interlace == NoInterlace)\n        {\n          if ((y > 0) || (GetPreviousImageInList(image) == (Image *) NULL))\n            {\n              length=2*quantum*image->columns;\n              count=ReadBlob(image,length,scanline);\n              if (count != (ssize_t) length)\n                {\n                  status=MagickFalse;\n                  ThrowFileException(exception,CorruptImageError,\n                    \"UnexpectedEndOfFile\",image->filename);\n                  break;\n                }\n            }\n          p=scanline;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          chroma_pixels=QueueAuthenticPixels(chroma_image,0,y,\n            chroma_image->columns,1,exception);\n          if (chroma_pixels == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x+=2)\n          {\n            SetPixelRed(chroma_image,0,chroma_pixels);\n            if (quantum == 1)\n              SetPixelGreen(chroma_image,ScaleCharToQuantum(*p++),\n                chroma_pixels);\n            else\n              {\n                SetPixelGreen(chroma_image,ScaleShortToQuantum(((*p) << 8) |\n                  *(p+1)),chroma_pixels);\n                p+=2;\n              }\n            if (quantum == 1)\n              SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            else\n              {\n                SetPixelRed(image,ScaleShortToQuantum(((*p) << 8) | *(p+1)),q);\n                p+=2;\n              }\n            SetPixelGreen(image,0,q);\n            SetPixelBlue(image,0,q);\n            q+=GetPixelChannels(image);\n            SetPixelGreen(image,0,q);\n            SetPixelBlue(image,0,q);\n            if (quantum == 1)\n              SetPixelBlue(chroma_image,ScaleCharToQuantum(*p++),chroma_pixels);\n            else\n              {\n                SetPixelBlue(chroma_image,ScaleShortToQuantum(((*p) << 8) |\n                  *(p+1)),chroma_pixels);\n                p+=2;\n              }\n            if (quantum == 1)\n              SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            else\n              {\n                SetPixelRed(image,ScaleShortToQuantum(((*p) << 8) | *(p+1)),q);\n                p+=2;\n              }\n            chroma_pixels+=GetPixelChannels(chroma_image);\n            q+=GetPixelChannels(image);\n          }\n        }\n      else\n        {\n          if ((y > 0) || (GetPreviousImageInList(image) == (Image *) NULL))\n            {\n              length=quantum*image->columns;\n              count=ReadBlob(image,length,scanline);\n              if (count != (ssize_t) length)\n                {\n                  status=MagickFalse;\n                  ThrowFileException(exception,CorruptImageError,\n                    \"UnexpectedEndOfFile\",image->filename);\n                  break;\n                }\n            }\n          p=scanline;\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (quantum == 1)\n              SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n            else\n              {\n                SetPixelRed(image,ScaleShortToQuantum(((*p) << 8) | *(p+1)),q);\n                p+=2;\n              }\n            SetPixelGreen(image,0,q);\n            SetPixelBlue(image,0,q);\n            q+=GetPixelChannels(image);\n          }\n        }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (interlace == NoInterlace)\n        if (SyncAuthenticPixels(chroma_image,exception) == MagickFalse)\n          break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (interlace == PartitionInterlace)\n      {\n        (void) CloseBlob(image);\n        AppendImageFormat(\"U\",image->filename);\n        status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n        if (status == MagickFalse)\n          {\n            scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n      }\n    if (interlace != NoInterlace)\n      {\n        for (y=0; y < (ssize_t) chroma_image->rows; y++)\n        {\n          length=quantum*chroma_image->columns;\n          count=ReadBlob(image,length,scanline);\n          if (count != (ssize_t) length)\n            {\n              status=MagickFalse;\n              ThrowFileException(exception,CorruptImageError,\n                \"UnexpectedEndOfFile\",image->filename);\n              break;\n            }\n          p=scanline;\n          q=QueueAuthenticPixels(chroma_image,0,y,chroma_image->columns,1,\n            exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) chroma_image->columns; x++)\n          {\n            SetPixelRed(chroma_image,0,q);\n            if (quantum == 1)\n              SetPixelGreen(chroma_image,ScaleCharToQuantum(*p++),q);\n            else\n              {\n                SetPixelGreen(chroma_image,ScaleShortToQuantum(((*p) << 8) |\n                  *(p+1)),q);\n                p+=2;\n              }\n            SetPixelBlue(chroma_image,0,q);\n            q+=GetPixelChannels(chroma_image);\n          }\n          if (SyncAuthenticPixels(chroma_image,exception) == MagickFalse)\n            break;\n        }\n      if (interlace == PartitionInterlace)\n        {\n          (void) CloseBlob(image);\n          AppendImageFormat(\"V\",image->filename);\n          status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n          if (status == MagickFalse)\n            {\n              scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n              image=DestroyImageList(image);\n              return((Image *) NULL);\n            }\n        }\n      for (y=0; y < (ssize_t) chroma_image->rows; y++)\n      {\n        length=quantum*chroma_image->columns;\n        count=ReadBlob(image,length,scanline);\n        if (count != (ssize_t) length)\n          {\n            status=MagickFalse;\n            ThrowFileException(exception,CorruptImageError,\n              \"UnexpectedEndOfFile\",image->filename);\n            break;\n          }\n        p=scanline;\n        q=GetAuthenticPixels(chroma_image,0,y,chroma_image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) chroma_image->columns; x++)\n        {\n          if (quantum == 1)\n            SetPixelBlue(chroma_image,ScaleCharToQuantum(*p++),q);\n          else\n            {\n              SetPixelBlue(chroma_image,ScaleShortToQuantum(((*p) << 8) |\n                *(p+1)),q);\n              p+=2;\n            }\n          q+=GetPixelChannels(chroma_image);\n        }\n        if (SyncAuthenticPixels(chroma_image,exception) == MagickFalse)\n          break;\n      }\n    }\n    /*\n      Scale image.\n    */\n    resize_image=ResizeImage(chroma_image,image->columns,image->rows,\n      TriangleFilter,exception);\n    chroma_image=DestroyImage(chroma_image);\n    if (resize_image == (Image *) NULL)\n      {\n        scanline=(unsigned char *) RelinquishMagickMemory(scanline);   \n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n      chroma_pixels=GetVirtualPixels(resize_image,0,y,resize_image->columns,1,\n        exception);\n      if ((q == (Quantum *) NULL) ||\n          (chroma_pixels == (const Quantum *) NULL))\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        SetPixelGreen(image,GetPixelGreen(resize_image,chroma_pixels),q);\n        SetPixelBlue(image,GetPixelBlue(resize_image,chroma_pixels),q);\n        chroma_pixels+=GetPixelChannels(resize_image);\n        q+=GetPixelChannels(image);\n      }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n    }\n    resize_image=DestroyImage(resize_image);\n    if (SetImageColorspace(image,YCbCrColorspace,exception) == MagickFalse)\n      break;\n    if (interlace == PartitionInterlace)\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (interlace == NoInterlace)\n      count=ReadBlob(image,(size_t) (2*quantum*image->columns),scanline);\n    else\n      count=ReadBlob(image,(size_t) quantum*image->columns,scanline);\n    if (count != 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (count != 0);\n  scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -113,7 +113,10 @@\n       horizontal_factor,(image->rows+vertical_factor-1)/vertical_factor,\n       MagickTrue,exception);\n     if (chroma_image == (Image *) NULL)\n-      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+      {\n+        scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n+        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+      }\n     /*\n       Convert raster image to pixel packets.\n     */\n@@ -129,6 +132,7 @@\n         status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n         if (status == MagickFalse)\n           {\n+            scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n             image=DestroyImageList(image);\n             return((Image *) NULL);\n           }\n@@ -255,6 +259,7 @@\n         status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n         if (status == MagickFalse)\n           {\n+            scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n             image=DestroyImageList(image);\n             return((Image *) NULL);\n           }\n@@ -301,6 +306,7 @@\n           status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n           if (status == MagickFalse)\n             {\n+              scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n               image=DestroyImageList(image);\n               return((Image *) NULL);\n             }\n@@ -344,7 +350,10 @@\n       TriangleFilter,exception);\n     chroma_image=DestroyImage(chroma_image);\n     if (resize_image == (Image *) NULL)\n-      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+      {\n+        scanline=(unsigned char *) RelinquishMagickMemory(scanline);   \n+        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+      }\n     for (y=0; y < (ssize_t) image->rows; y++)\n     {\n       q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n@@ -393,6 +402,7 @@\n         AcquireNextImage(image_info,image,exception);\n         if (GetNextImageInList(image) == (Image *) NULL)\n           {\n+            scanline=(unsigned char *) RelinquishMagickMemory(scanline); \n             image=DestroyImageList(image);\n             return((Image *) NULL);\n           }",
        "diff_line_info": {
            "deleted_lines": [
                "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"
            ],
            "added_lines": [
                "      {",
                "        scanline=(unsigned char *) RelinquishMagickMemory(scanline); ",
                "        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "      }",
                "            scanline=(unsigned char *) RelinquishMagickMemory(scanline); ",
                "            scanline=(unsigned char *) RelinquishMagickMemory(scanline); ",
                "              scanline=(unsigned char *) RelinquishMagickMemory(scanline); ",
                "      {",
                "        scanline=(unsigned char *) RelinquishMagickMemory(scanline);   ",
                "        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "      }",
                "            scanline=(unsigned char *) RelinquishMagickMemory(scanline); "
            ]
        }
    },
    {
        "cve_id": "CVE-2017-15217",
        "func_name": "ImageMagick/ReadSGIImage",
        "description": "ImageMagick 7.0.7-2 has a memory leak in ReadSGIImage in coders/sgi.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/8fa3c10977f668c92688272a4802f4477df61076",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/759",
        "commit_text": "",
        "func_before": "static Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  SGIInfo\n    iris_info;\n\n  size_t\n    bytes_per_pixel,\n    quantum;\n\n  ssize_t\n    count,\n    y,\n    z;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SGI raster header.\n  */\n  iris_info.magic=ReadBlobMSBShort(image);\n  do\n  {\n    /*\n      Verify SGI identifier.\n    */\n    if (iris_info.magic != 0x01DA)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.storage=(unsigned char) ReadBlobByte(image);\n    switch (iris_info.storage)\n    {\n      case 0x00: image->compression=NoCompression; break;\n      case 0x01: image->compression=RLECompression; break;\n      default:\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n    iris_info.bytes_per_pixel=(unsigned char) ReadBlobByte(image);\n    if ((iris_info.bytes_per_pixel == 0) || (iris_info.bytes_per_pixel > 2))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.dimension=ReadBlobMSBShort(image);\n    if ((iris_info.dimension == 0) || (iris_info.dimension > 3)) \n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.columns=ReadBlobMSBShort(image);\n    iris_info.rows=ReadBlobMSBShort(image);\n    iris_info.depth=ReadBlobMSBShort(image);\n    if ((iris_info.depth == 0) || (iris_info.depth > 4))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.minimum_value=ReadBlobMSBLong(image);\n    iris_info.maximum_value=ReadBlobMSBLong(image);\n    iris_info.sans=ReadBlobMSBLong(image);\n    count=ReadBlob(image,sizeof(iris_info.name),(unsigned char *)\n      iris_info.name);\n    if ((size_t) count != sizeof(iris_info.name))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.name[sizeof(iris_info.name)-1]='\\0';\n    if (*iris_info.name != '\\0')\n      (void) SetImageProperty(image,\"label\",iris_info.name,exception);\n    iris_info.pixel_format=ReadBlobMSBLong(image);\n    if (iris_info.pixel_format != 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    count=ReadBlob(image,sizeof(iris_info.filler),iris_info.filler);\n    if ((size_t) count != sizeof(iris_info.filler))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->columns=iris_info.columns;\n    image->rows=iris_info.rows;\n    image->alpha_trait=iris_info.depth == 4 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n    image->depth=(size_t) MagickMin(iris_info.depth,MAGICKCORE_QUANTUM_DEPTH);\n    if (iris_info.pixel_format == 0)\n      image->depth=(size_t) MagickMin((size_t) 8*iris_info.bytes_per_pixel,\n        MAGICKCORE_QUANTUM_DEPTH);\n    if (iris_info.depth < 3)\n      {\n        image->storage_class=PseudoClass;\n        image->colors=(size_t) (iris_info.bytes_per_pixel > 1 ? 65535 : 256);\n      }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Allocate SGI pixels.\n    */\n    bytes_per_pixel=(size_t) iris_info.bytes_per_pixel;\n    number_pixels=(MagickSizeType) iris_info.columns*iris_info.rows;\n    if ((4*bytes_per_pixel*number_pixels) != ((MagickSizeType) (size_t)\n        (4*bytes_per_pixel*number_pixels)))\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixel_info=AcquireVirtualMemory(iris_info.columns,iris_info.rows*4*\n      bytes_per_pixel*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    if ((int) iris_info.storage != 0x01)\n      {\n        unsigned char\n          *scanline;\n\n        /*\n          Read standard image format.\n        */\n        scanline=(unsigned char *) AcquireQuantumMemory(iris_info.columns,\n          bytes_per_pixel*sizeof(*scanline));\n        if (scanline == (unsigned char *) NULL)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        for (z=0; z < (ssize_t) iris_info.depth; z++)\n        {\n          p=pixels+bytes_per_pixel*z;\n          for (y=0; y < (ssize_t) iris_info.rows; y++)\n          {\n            count=ReadBlob(image,bytes_per_pixel*iris_info.columns,scanline);\n            if (EOFBlob(image) != MagickFalse)\n              break;\n            if (bytes_per_pixel == 2)\n              for (x=0; x < (ssize_t) iris_info.columns; x++)\n              {\n                *p=scanline[2*x];\n                *(p+1)=scanline[2*x+1];\n                p+=8;\n              }\n            else\n              for (x=0; x < (ssize_t) iris_info.columns; x++)\n              {\n                *p=scanline[x];\n                p+=4;\n              }\n          }\n        }\n        scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n      }\n    else\n      {\n        MemoryInfo\n          *packet_info;\n\n        size_t\n          *runlength;\n\n        ssize_t\n          offset,\n          *offsets;\n\n        unsigned char\n          *packets;\n\n        unsigned int\n          data_order;\n\n        /*\n          Read runlength-encoded image format.\n        */\n        offsets=(ssize_t *) AcquireQuantumMemory((size_t) iris_info.rows,\n          iris_info.depth*sizeof(*offsets));\n        runlength=(size_t *) AcquireQuantumMemory(iris_info.rows,\n          iris_info.depth*sizeof(*runlength));\n        packet_info=AcquireVirtualMemory((size_t) iris_info.columns+10UL,4UL*\n          sizeof(*packets));\n        if ((offsets == (ssize_t *) NULL) ||\n            (runlength == (size_t *) NULL) ||\n            (packet_info == (MemoryInfo *) NULL))\n          {\n            offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n            runlength=(size_t *) RelinquishMagickMemory(runlength);\n            if (packet_info != (MemoryInfo *) NULL)\n              packet_info=RelinquishVirtualMemory(packet_info);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        packets=(unsigned char *) GetVirtualMemoryBlob(packet_info);\n        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)\n          offsets[i]=(ssize_t) ReadBlobMSBSignedLong(image);\n        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)\n        {\n          runlength[i]=ReadBlobMSBLong(image);\n          if (runlength[i] > (4*(size_t) iris_info.columns+10))\n            {\n              packet_info=RelinquishVirtualMemory(packet_info);\n              runlength=(size_t *) RelinquishMagickMemory(runlength);\n              offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            }\n        }\n        /*\n          Check data order.\n        */\n        offset=0;\n        data_order=0;\n        for (y=0; ((y < (ssize_t) iris_info.rows) && (data_order == 0)); y++)\n          for (z=0; ((z < (ssize_t) iris_info.depth) && (data_order == 0)); z++)\n          {\n            if (offsets[y+z*iris_info.rows] < offset)\n              data_order=1;\n            offset=offsets[y+z*iris_info.rows];\n          }\n        offset=(ssize_t) TellBlob(image);\n        if (data_order == 1)\n          {\n            for (z=0; z < (ssize_t) iris_info.depth; z++)\n            {\n              p=pixels;\n              for (y=0; y < (ssize_t) iris_info.rows; y++)\n              {\n                if (offset != offsets[y+z*iris_info.rows])\n                  {\n                    offset=offsets[y+z*iris_info.rows];\n                    offset=(ssize_t) SeekBlob(image,(MagickOffsetType) offset,\n                      SEEK_SET);\n                  }\n                count=ReadBlob(image,(size_t) runlength[y+z*iris_info.rows],\n                  packets);\n                if (EOFBlob(image) != MagickFalse)\n                  break;\n                offset+=(ssize_t) runlength[y+z*iris_info.rows];\n                status=SGIDecode(bytes_per_pixel,(ssize_t)\n                  (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,\n                  (ssize_t) iris_info.columns,p+bytes_per_pixel*z);\n                if (status == MagickFalse)\n                  {\n                    packet_info=RelinquishVirtualMemory(packet_info);\n                    runlength=(size_t *) RelinquishMagickMemory(runlength);\n                    offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n                    pixel_info=RelinquishVirtualMemory(pixel_info);\n                    ThrowReaderException(CorruptImageError,\n                      \"ImproperImageHeader\");\n                  }\n                p+=(iris_info.columns*4*bytes_per_pixel);\n              }\n            }\n          }\n        else\n          {\n            MagickOffsetType\n              position;\n\n            position=TellBlob(image);\n            p=pixels;\n            for (y=0; y < (ssize_t) iris_info.rows; y++)\n            {\n              for (z=0; z < (ssize_t) iris_info.depth; z++)\n              {\n                if (offset != offsets[y+z*iris_info.rows])\n                  {\n                    offset=offsets[y+z*iris_info.rows];\n                    offset=(ssize_t) SeekBlob(image,(MagickOffsetType) offset,\n                      SEEK_SET);\n                  }\n                count=ReadBlob(image,(size_t) runlength[y+z*iris_info.rows],\n                  packets);\n                if (EOFBlob(image) != MagickFalse)\n                  break;\n                offset+=(ssize_t) runlength[y+z*iris_info.rows];\n                status=SGIDecode(bytes_per_pixel,(ssize_t)\n                  (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,\n                  (ssize_t) iris_info.columns,p+bytes_per_pixel*z);\n                if (status == MagickFalse)\n                  {\n                    packet_info=RelinquishVirtualMemory(packet_info);\n                    runlength=(size_t *) RelinquishMagickMemory(runlength);\n                    offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n                    pixel_info=RelinquishVirtualMemory(pixel_info);\n                    ThrowReaderException(CorruptImageError,\n                      \"ImproperImageHeader\");\n                  }\n              }\n              p+=(iris_info.columns*4*bytes_per_pixel);\n            }\n            offset=(ssize_t) SeekBlob(image,position,SEEK_SET);\n          }\n        packet_info=RelinquishVirtualMemory(packet_info);\n        runlength=(size_t *) RelinquishMagickMemory(runlength);\n        offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n      }\n    /*\n      Convert SGI raster image to pixel packets.\n    */\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Convert SGI image to DirectClass pixel packets.\n        */\n        if (bytes_per_pixel == 2)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=pixels+(image->rows-y-1)*8*image->columns;\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelRed(image,ScaleShortToQuantum((unsigned short)\n                  ((*(p+0) << 8) | (*(p+1)))),q);\n                SetPixelGreen(image,ScaleShortToQuantum((unsigned short)\n                  ((*(p+2) << 8) | (*(p+3)))),q);\n                SetPixelBlue(image,ScaleShortToQuantum((unsigned short)\n                  ((*(p+4) << 8) | (*(p+5)))),q);\n                SetPixelAlpha(image,OpaqueAlpha,q);\n                if (image->alpha_trait != UndefinedPixelTrait)\n                  SetPixelAlpha(image,ScaleShortToQuantum((unsigned short)\n                    ((*(p+6) << 8) | (*(p+7)))),q);\n                p+=8;\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=pixels+(image->rows-y-1)*4*image->columns;\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(image,ScaleCharToQuantum(*p),q);\n              SetPixelGreen(image,ScaleCharToQuantum(*(p+1)),q);\n              SetPixelBlue(image,ScaleCharToQuantum(*(p+2)),q);\n              SetPixelAlpha(image,OpaqueAlpha,q);\n              if (image->alpha_trait != UndefinedPixelTrait)\n                SetPixelAlpha(image,ScaleCharToQuantum(*(p+3)),q);\n              p+=4;\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n      }\n    else\n      {\n        /*\n          Create grayscale map.\n        */\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Convert SGI image to PseudoClass pixel packets.\n        */\n        if (bytes_per_pixel == 2)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=pixels+(image->rows-y-1)*8*image->columns;\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                quantum=(*p << 8);\n                quantum|=(*(p+1));\n                SetPixelIndex(image,(Quantum) quantum,q);\n                p+=8;\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=pixels+(image->rows-y-1)*4*image->columns;\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(image,*p,q);\n              p+=4;\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        (void) SyncImage(image,exception);\n      }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    iris_info.magic=ReadBlobMSBShort(image);\n    if (iris_info.magic == 0x01DA)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (iris_info.magic == 0x01DA);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  SGIInfo\n    iris_info;\n\n  size_t\n    bytes_per_pixel,\n    quantum;\n\n  ssize_t\n    count,\n    y,\n    z;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SGI raster header.\n  */\n  iris_info.magic=ReadBlobMSBShort(image);\n  do\n  {\n    /*\n      Verify SGI identifier.\n    */\n    if (iris_info.magic != 0x01DA)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.storage=(unsigned char) ReadBlobByte(image);\n    switch (iris_info.storage)\n    {\n      case 0x00: image->compression=NoCompression; break;\n      case 0x01: image->compression=RLECompression; break;\n      default:\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n    iris_info.bytes_per_pixel=(unsigned char) ReadBlobByte(image);\n    if ((iris_info.bytes_per_pixel == 0) || (iris_info.bytes_per_pixel > 2))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.dimension=ReadBlobMSBShort(image);\n    if ((iris_info.dimension == 0) || (iris_info.dimension > 3)) \n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.columns=ReadBlobMSBShort(image);\n    iris_info.rows=ReadBlobMSBShort(image);\n    iris_info.depth=ReadBlobMSBShort(image);\n    if ((iris_info.depth == 0) || (iris_info.depth > 4))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.minimum_value=ReadBlobMSBLong(image);\n    iris_info.maximum_value=ReadBlobMSBLong(image);\n    iris_info.sans=ReadBlobMSBLong(image);\n    count=ReadBlob(image,sizeof(iris_info.name),(unsigned char *)\n      iris_info.name);\n    if ((size_t) count != sizeof(iris_info.name))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.name[sizeof(iris_info.name)-1]='\\0';\n    if (*iris_info.name != '\\0')\n      (void) SetImageProperty(image,\"label\",iris_info.name,exception);\n    iris_info.pixel_format=ReadBlobMSBLong(image);\n    if (iris_info.pixel_format != 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    count=ReadBlob(image,sizeof(iris_info.filler),iris_info.filler);\n    if ((size_t) count != sizeof(iris_info.filler))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->columns=iris_info.columns;\n    image->rows=iris_info.rows;\n    image->alpha_trait=iris_info.depth == 4 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n    image->depth=(size_t) MagickMin(iris_info.depth,MAGICKCORE_QUANTUM_DEPTH);\n    if (iris_info.pixel_format == 0)\n      image->depth=(size_t) MagickMin((size_t) 8*iris_info.bytes_per_pixel,\n        MAGICKCORE_QUANTUM_DEPTH);\n    if (iris_info.depth < 3)\n      {\n        image->storage_class=PseudoClass;\n        image->colors=(size_t) (iris_info.bytes_per_pixel > 1 ? 65535 : 256);\n      }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Allocate SGI pixels.\n    */\n    bytes_per_pixel=(size_t) iris_info.bytes_per_pixel;\n    number_pixels=(MagickSizeType) iris_info.columns*iris_info.rows;\n    if ((4*bytes_per_pixel*number_pixels) != ((MagickSizeType) (size_t)\n        (4*bytes_per_pixel*number_pixels)))\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixel_info=AcquireVirtualMemory(iris_info.columns,iris_info.rows*4*\n      bytes_per_pixel*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    if ((int) iris_info.storage != 0x01)\n      {\n        unsigned char\n          *scanline;\n\n        /*\n          Read standard image format.\n        */\n        scanline=(unsigned char *) AcquireQuantumMemory(iris_info.columns,\n          bytes_per_pixel*sizeof(*scanline));\n        if (scanline == (unsigned char *) NULL)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        for (z=0; z < (ssize_t) iris_info.depth; z++)\n        {\n          p=pixels+bytes_per_pixel*z;\n          for (y=0; y < (ssize_t) iris_info.rows; y++)\n          {\n            count=ReadBlob(image,bytes_per_pixel*iris_info.columns,scanline);\n            if (EOFBlob(image) != MagickFalse)\n              break;\n            if (bytes_per_pixel == 2)\n              for (x=0; x < (ssize_t) iris_info.columns; x++)\n              {\n                *p=scanline[2*x];\n                *(p+1)=scanline[2*x+1];\n                p+=8;\n              }\n            else\n              for (x=0; x < (ssize_t) iris_info.columns; x++)\n              {\n                *p=scanline[x];\n                p+=4;\n              }\n          }\n        }\n        scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n      }\n    else\n      {\n        MemoryInfo\n          *packet_info;\n\n        size_t\n          *runlength;\n\n        ssize_t\n          offset,\n          *offsets;\n\n        unsigned char\n          *packets;\n\n        unsigned int\n          data_order;\n\n        /*\n          Read runlength-encoded image format.\n        */\n        offsets=(ssize_t *) AcquireQuantumMemory((size_t) iris_info.rows,\n          iris_info.depth*sizeof(*offsets));\n        runlength=(size_t *) AcquireQuantumMemory(iris_info.rows,\n          iris_info.depth*sizeof(*runlength));\n        packet_info=AcquireVirtualMemory((size_t) iris_info.columns+10UL,4UL*\n          sizeof(*packets));\n        if ((offsets == (ssize_t *) NULL) ||\n            (runlength == (size_t *) NULL) ||\n            (packet_info == (MemoryInfo *) NULL))\n          {\n            offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n            runlength=(size_t *) RelinquishMagickMemory(runlength);\n            if (packet_info != (MemoryInfo *) NULL)\n              packet_info=RelinquishVirtualMemory(packet_info);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        packets=(unsigned char *) GetVirtualMemoryBlob(packet_info);\n        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)\n          offsets[i]=(ssize_t) ReadBlobMSBSignedLong(image);\n        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)\n        {\n          runlength[i]=ReadBlobMSBLong(image);\n          if (runlength[i] > (4*(size_t) iris_info.columns+10))\n            {\n              packet_info=RelinquishVirtualMemory(packet_info);\n              runlength=(size_t *) RelinquishMagickMemory(runlength);\n              offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            }\n        }\n        /*\n          Check data order.\n        */\n        offset=0;\n        data_order=0;\n        for (y=0; ((y < (ssize_t) iris_info.rows) && (data_order == 0)); y++)\n          for (z=0; ((z < (ssize_t) iris_info.depth) && (data_order == 0)); z++)\n          {\n            if (offsets[y+z*iris_info.rows] < offset)\n              data_order=1;\n            offset=offsets[y+z*iris_info.rows];\n          }\n        offset=(ssize_t) TellBlob(image);\n        if (data_order == 1)\n          {\n            for (z=0; z < (ssize_t) iris_info.depth; z++)\n            {\n              p=pixels;\n              for (y=0; y < (ssize_t) iris_info.rows; y++)\n              {\n                if (offset != offsets[y+z*iris_info.rows])\n                  {\n                    offset=offsets[y+z*iris_info.rows];\n                    offset=(ssize_t) SeekBlob(image,(MagickOffsetType) offset,\n                      SEEK_SET);\n                  }\n                count=ReadBlob(image,(size_t) runlength[y+z*iris_info.rows],\n                  packets);\n                if (EOFBlob(image) != MagickFalse)\n                  break;\n                offset+=(ssize_t) runlength[y+z*iris_info.rows];\n                status=SGIDecode(bytes_per_pixel,(ssize_t)\n                  (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,\n                  (ssize_t) iris_info.columns,p+bytes_per_pixel*z);\n                if (status == MagickFalse)\n                  {\n                    packet_info=RelinquishVirtualMemory(packet_info);\n                    runlength=(size_t *) RelinquishMagickMemory(runlength);\n                    offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n                    pixel_info=RelinquishVirtualMemory(pixel_info);\n                    ThrowReaderException(CorruptImageError,\n                      \"ImproperImageHeader\");\n                  }\n                p+=(iris_info.columns*4*bytes_per_pixel);\n              }\n            }\n          }\n        else\n          {\n            MagickOffsetType\n              position;\n\n            position=TellBlob(image);\n            p=pixels;\n            for (y=0; y < (ssize_t) iris_info.rows; y++)\n            {\n              for (z=0; z < (ssize_t) iris_info.depth; z++)\n              {\n                if (offset != offsets[y+z*iris_info.rows])\n                  {\n                    offset=offsets[y+z*iris_info.rows];\n                    offset=(ssize_t) SeekBlob(image,(MagickOffsetType) offset,\n                      SEEK_SET);\n                  }\n                count=ReadBlob(image,(size_t) runlength[y+z*iris_info.rows],\n                  packets);\n                if (EOFBlob(image) != MagickFalse)\n                  break;\n                offset+=(ssize_t) runlength[y+z*iris_info.rows];\n                status=SGIDecode(bytes_per_pixel,(ssize_t)\n                  (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,\n                  (ssize_t) iris_info.columns,p+bytes_per_pixel*z);\n                if (status == MagickFalse)\n                  {\n                    packet_info=RelinquishVirtualMemory(packet_info);\n                    runlength=(size_t *) RelinquishMagickMemory(runlength);\n                    offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n                    pixel_info=RelinquishVirtualMemory(pixel_info);\n                    ThrowReaderException(CorruptImageError,\n                      \"ImproperImageHeader\");\n                  }\n              }\n              p+=(iris_info.columns*4*bytes_per_pixel);\n            }\n            offset=(ssize_t) SeekBlob(image,position,SEEK_SET);\n          }\n        packet_info=RelinquishVirtualMemory(packet_info);\n        runlength=(size_t *) RelinquishMagickMemory(runlength);\n        offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n      }\n    /*\n      Convert SGI raster image to pixel packets.\n    */\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Convert SGI image to DirectClass pixel packets.\n        */\n        if (bytes_per_pixel == 2)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=pixels+(image->rows-y-1)*8*image->columns;\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelRed(image,ScaleShortToQuantum((unsigned short)\n                  ((*(p+0) << 8) | (*(p+1)))),q);\n                SetPixelGreen(image,ScaleShortToQuantum((unsigned short)\n                  ((*(p+2) << 8) | (*(p+3)))),q);\n                SetPixelBlue(image,ScaleShortToQuantum((unsigned short)\n                  ((*(p+4) << 8) | (*(p+5)))),q);\n                SetPixelAlpha(image,OpaqueAlpha,q);\n                if (image->alpha_trait != UndefinedPixelTrait)\n                  SetPixelAlpha(image,ScaleShortToQuantum((unsigned short)\n                    ((*(p+6) << 8) | (*(p+7)))),q);\n                p+=8;\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=pixels+(image->rows-y-1)*4*image->columns;\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(image,ScaleCharToQuantum(*p),q);\n              SetPixelGreen(image,ScaleCharToQuantum(*(p+1)),q);\n              SetPixelBlue(image,ScaleCharToQuantum(*(p+2)),q);\n              SetPixelAlpha(image,OpaqueAlpha,q);\n              if (image->alpha_trait != UndefinedPixelTrait)\n                SetPixelAlpha(image,ScaleCharToQuantum(*(p+3)),q);\n              p+=4;\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                  image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n      }\n    else\n      {\n        /*\n          Create grayscale map.\n        */\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        /*\n          Convert SGI image to PseudoClass pixel packets.\n        */\n        if (bytes_per_pixel == 2)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=pixels+(image->rows-y-1)*8*image->columns;\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                quantum=(*p << 8);\n                quantum|=(*(p+1));\n                SetPixelIndex(image,(Quantum) quantum,q);\n                p+=8;\n                q+=GetPixelChannels(image);\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=pixels+(image->rows-y-1)*4*image->columns;\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(image,*p,q);\n              p+=4;\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        (void) SyncImage(image,exception);\n      }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    iris_info.magic=ReadBlobMSBShort(image);\n    if (iris_info.magic == 0x01DA)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (iris_info.magic == 0x01DA);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -392,7 +392,10 @@\n           Create grayscale map.\n         */\n         if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n-          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+          {\n+            pixel_info=RelinquishVirtualMemory(pixel_info);\n+            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+          }\n         /*\n           Convert SGI image to PseudoClass pixel packets.\n         */",
        "diff_line_info": {
            "deleted_lines": [
                "          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"
            ],
            "added_lines": [
                "          {",
                "            pixel_info=RelinquishVirtualMemory(pixel_info);",
                "            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "          }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-15189",
        "func_name": "wireshark/dissect_docsis",
        "description": "In Wireshark 2.4.0 to 2.4.1, the DOCSIS dissector could go into an infinite loop. This was addressed in plugins/docsis/packet-docsis.c by adding decrements.",
        "git_url": "https://github.com/wireshark/wireshark/commit/625bab309d9dd21db2d8ae2aa3511810d32842a8",
        "commit_title": "Docsis: fix an infinite loop",
        "commit_text": " Add missing decrement of concatlen based on master-2.2 version.  Bug: 14080",
        "func_before": "static int\ndissect_docsis (tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void* data _U_)\n{\n  guint8 fc = 0;\n  guint8 fctype = 0;\n  guint8 fcparm = 0;\n  guint8 exthdr = 0;\n  guint16 mac_parm = 0;\n  guint8 hdrlen = DOCSIS_MIN_HEADER_LEN;\n  guint16 len_sid = 0;\n  tvbuff_t *next_tvb = NULL;\n  tvbuff_t *mgt_tvb = NULL;\n  gint pdulen = 0;\n  guint16 payload_length = 0;\n  guint16 framelen = 0;\n  gboolean save_fragmented;\n\n  proto_item *ti;\n  proto_tree *docsis_tree;\n\n  /* concatlen and concatpos are declared static to allow for recursive calls to\n   * the dissect_docsis routine when dissecting Concatenated frames\n   */\n  static guint16 concatlen;\n  static guint16 concatpos;\n\n  /* Extract Frame Control parts */\n  fc = tvb_get_guint8 (tvb, 0); /* Frame Control Byte */\n  fctype = (fc >> 6) & 0x03;    /* Frame Control Type:  2 MSB Bits */\n  fcparm = (fc >> 1) & 0x1F;    /* Frame Control Parameter: Next 5 Bits */\n  exthdr = (fc & 0x01);         /* Extended Header Bit: LSB */\n\n  /* Extract the MAC Parm; MAC Parm and SID offsets; change for a Queue Depth Request */\n  if (fcparm == FCPARM_QUEUE_DEPTH_REQ_FRM) {\n    mac_parm = tvb_get_ntohs (tvb, 1);\n    len_sid = tvb_get_ntohs (tvb, 3);\n    hdrlen = DOCSIS_MIN_HEADER_LEN + 1; // 7-byte header for this message type\n  } else {\n    mac_parm = tvb_get_guint8 (tvb, 1);\n    len_sid = tvb_get_ntohs (tvb, 2);\n  }\n\n  /* Set Header Length based on presence of Extended header */\n  if (exthdr == EXT_HDR_ON) {\n    hdrlen += mac_parm;\n  }\n\n  /* Captured Payload Length is based on the length of the header */\n  payload_length = tvb_captured_length_remaining (tvb, hdrlen);\n\n  /* If this is a Request Frame, then pdulen is 0 and framelen is 6 */\n  if ((fctype == FCTYPE_MACSPC) && (fcparm == FCPARM_RQST_FRM || fcparm == FCPARM_QUEUE_DEPTH_REQ_FRM))\n  {\n    pdulen = 0;\n    if (fcparm == FCPARM_QUEUE_DEPTH_REQ_FRM)\n      framelen = DOCSIS_MIN_HEADER_LEN + 1;\n    else\n      framelen = DOCSIS_MIN_HEADER_LEN;\n  } else {\n    framelen = DOCSIS_MIN_HEADER_LEN + len_sid;\n    pdulen = len_sid - (mac_parm + 2);\n  }\n\n  /* Make entries in Protocol column and Info column on summary display */\n  col_set_str (pinfo->cinfo, COL_PROTOCOL, \"DOCSIS\");\n\n  switch (fctype)\n  {\n    case FCTYPE_PACKET:\n      col_set_str (pinfo->cinfo, COL_INFO, \"Packet PDU\");\n      break;\n    case FCTYPE_RESERVED:\n      col_set_str (pinfo->cinfo, COL_INFO, \"Reserved PDU\");\n      break;\n    case FCTYPE_ISOLAT:\n      col_set_str (pinfo->cinfo, COL_INFO, \"Isolation PDU\");\n      break;\n    case FCTYPE_MACSPC:\n      if (fcparm == FCPARM_RQST_FRM)\n        col_add_fstr (pinfo->cinfo, COL_INFO,\n                      \"Request Frame SID = %u Mini Slots = %u\", len_sid,\n                      mac_parm);\n      else if (fcparm == FCPARM_QUEUE_DEPTH_REQ_FRM)\n        col_add_fstr (pinfo->cinfo, COL_INFO,\n                      \"Request Frame SID = %u Bytes Requested = %u\", len_sid,\n                      mac_parm);\n      else if (fcparm == FCPARM_FRAG_HDR)\n        col_set_str (pinfo->cinfo, COL_INFO, \"Fragmented Frame\");\n      else\n        col_set_str (pinfo->cinfo, COL_INFO, \"Mac Specific\");\n      break;\n  }  /* switch fctype */\n\n  ti = proto_tree_add_item(tree, proto_docsis, tvb, 0, hdrlen, ENC_NA);\n  docsis_tree = proto_item_add_subtree (ti, ett_docsis);\n\n  /* add an item to the subtree, see section 1.6 for more information */\n\n  /* Add in FC Byte fields */\n  proto_tree_add_item (docsis_tree, hf_docsis_fctype, tvb, 0, 1, ENC_BIG_ENDIAN);\n\n  switch (fctype)\n  {\n    case FCTYPE_PACKET:\n    {\n      proto_item_append_text (ti, \" Packet PDU\");\n      proto_tree_add_item (docsis_tree, hf_docsis_fcparm, tvb, 0, 1, ENC_BIG_ENDIAN);\n      proto_tree_add_item (docsis_tree, hf_docsis_exthdr, tvb, 0, 1, ENC_BIG_ENDIAN);\n      /* Dissect Length field for a PDU */\n      dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length);\n      /* Dissect Header Check Sequence field for a PDU */\n      dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);\n      if (pdulen > 0)\n      {\n        next_tvb =  tvb_new_subset_remaining(tvb, hdrlen);\n        call_dissector (eth_withoutfcs_handle, next_tvb, pinfo, docsis_tree);\n      }\n      if (concatlen > 0)\n      {\n        concatlen = concatlen - framelen;\n        concatpos += framelen;\n      }\n      break;\n    }\n    case FCTYPE_RESERVED:\n    {\n      proto_item_append_text (ti, \" Reserved PDU\");\n      proto_tree_add_item (docsis_tree, hf_docsis_fcparm, tvb, 0, 1, ENC_BIG_ENDIAN);\n      proto_tree_add_item (docsis_tree, hf_docsis_exthdr, tvb, 0, 1, ENC_BIG_ENDIAN);\n      /* Dissect Length field for a PDU */\n      dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length);\n      /* Dissect Header Check Sequence field for a PDU */\n      dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);\n\n      if (concatlen > 0)\n      {\n        concatlen = concatlen - framelen;\n        concatpos += framelen;\n      }\n\n      /* Don't do anything for a Reserved Frame */\n      next_tvb =  tvb_new_subset_remaining(tvb, hdrlen);\n      call_data_dissector(next_tvb, pinfo, tree);\n      break;\n    }\n    case FCTYPE_ISOLAT:\n    {\n      proto_item_append_text (ti, \" Isolation PDU\");\n      proto_tree_add_item (docsis_tree, hf_docsis_fcparm, tvb, 0, 1, ENC_BIG_ENDIAN);\n      proto_tree_add_item (docsis_tree, hf_docsis_exthdr, tvb, 0, 1, ENC_BIG_ENDIAN);\n      /* Dissect Length field for a PDU */\n      dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length);\n      /* Dissect Header Check Sequence field for a PDU */\n      dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);\n      if (pdulen > 0)\n      {\n        next_tvb =  tvb_new_subset_remaining(tvb, hdrlen);\n        call_dissector (eth_withoutfcs_handle, next_tvb, pinfo, docsis_tree);\n      }\n      if (concatlen > 0)\n      {\n        concatlen = concatlen - framelen;\n        concatpos += framelen;\n      }\n      break;\n    }\n    case FCTYPE_MACSPC:\n    {\n      proto_item_append_text (ti, \" MAC-Specific PDU\");\n      proto_tree_add_item (docsis_tree, hf_docsis_machdr_fcparm, tvb, 0, 1, ENC_BIG_ENDIAN);\n      proto_tree_add_item (docsis_tree, hf_docsis_exthdr, tvb, 0, 1, ENC_BIG_ENDIAN);\n      switch(fcparm)\n      {\n        case FCPARM_TIMING_HDR:\n          // no break\n        case FCPARM_MAC_MGMT_HDR:\n        {\n          /* Dissect Length field for a PDU */\n          dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length);\n          /* Dissect Header Check Sequence field for a PDU */\n          dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);\n\n          /* Pass off to the DOCSIS Management dissector/s */\n          mgt_tvb = tvb_new_subset_remaining(tvb, hdrlen);\n          call_dissector (docsis_mgmt_handle, mgt_tvb, pinfo, docsis_tree);\n          break;\n        }\n        case FCPARM_RQST_FRM:\n        {\n          /* Decode for a Request Frame.  No extended header */\n          proto_tree_add_uint (docsis_tree, hf_docsis_mini_slots, tvb, 1, 1, mac_parm);\n          proto_tree_add_uint (docsis_tree, hf_docsis_sid, tvb, 2, 2, len_sid);\n          /* Dissect Header Check Sequence field for a PDU */\n          dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);\n\n          if (concatlen > 0)\n          {\n            concatlen = concatlen - framelen;\n            concatpos += framelen;\n          }\n\n          /* Don't do anything for a Request Frame, there is no data following it*/\n          break;\n        }\n        case FCPARM_FRAG_HDR:\n        {\n          /* Check if this is a fragmentation header */\n          save_fragmented = pinfo->fragmented;\n          pinfo->fragmented = TRUE;\n\n          /* Dissect Length field for a PDU */\n          dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length);\n          /* Dissect Header Check Sequence field for a PDU */\n          dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);\n\n          /* Grab the Fragment FCS */\n          guint32 sent_fcs = tvb_get_ntohl(tvb, (hdrlen + len_sid - 4));\n          guint32 fcs = crc32_802_tvb(tvb, tvb_captured_length(tvb) - 4);\n\n          /* Only defragment valid frames with a good FCS */\n          if (sent_fcs == fcs)\n          {\n            fragment_item *frag_msg = NULL;\n            frag_msg = fragment_add_seq_check(&docsis_reassembly_table,\n                                              tvb, hdrlen, pinfo,\n                                              frag_sid, NULL, /* ID for fragments belonging together */\n                                              frag_seq, /* Fragment Sequence Number */\n                                              (len_sid - 4), /* fragment length - to the end */\n                                              !(frag_flags & FRAG_LAST)); /* More fragments? */\n\n            next_tvb = process_reassembled_data(tvb, hdrlen, pinfo,\n                                                \"Reassembled Message\", frag_msg, &docsis_frag_items,\n                                                NULL, docsis_tree);\n\n            if (frag_flags == FRAG_LAST)\n              pinfo->fragmented = FALSE;\n            else\n              pinfo->fragmented = TRUE;\n\n            if (frag_msg) { /* Reassembled */\n              proto_item_append_text (ti, \" (Message Reassembled)\");\n            } else { /* Not last packet of reassembled Short Message */\n              proto_item_append_text (ti, \" (Message fragment %u)\", frag_seq);\n\n            }\n\n            if(next_tvb)\n            {\n              /* By default assume an Ethernet payload */\n              call_dissector (eth_withoutfcs_handle, next_tvb, pinfo, docsis_tree);\n            } else {\n              /* Otherwise treat as Data */\n              tvbuff_t *payload_tvb = tvb_new_subset_length_caplen(tvb, hdrlen, (len_sid - 4), -1);\n              call_data_dissector(payload_tvb, pinfo, docsis_tree);\n            }\n          } else {\n            /* Report frames with a bad FCS */\n            expert_add_info(pinfo, ti, &ei_docsis_frag_fcs_bad);\n          }\n\n          /* Add the Fragment FCS to the end of the parent tree */\n          proto_tree_add_checksum(docsis_tree, tvb, (hdrlen + len_sid - 4), hf_docsis_frag_fcs, hf_docsis_frag_fcs_status, &ei_docsis_frag_fcs_bad, pinfo, fcs, ENC_BIG_ENDIAN, PROTO_CHECKSUM_VERIFY);\n\n          pinfo->fragmented = save_fragmented;\n          break;\n        }\n        case FCPARM_QUEUE_DEPTH_REQ_FRM:\n        {\n          /* Decode for a Queue-depth Based Request */\n          proto_tree_add_uint (docsis_tree, hf_docsis_requested_size, tvb, 1, 2, mac_parm);\n          proto_tree_add_uint (docsis_tree, hf_docsis_sid, tvb, 3, 2, len_sid);\n          /* Dissect Header Check Sequence field for a PDU */\n          dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);\n\n          if (concatlen > 0)\n          {\n            concatlen = concatlen - framelen;\n            concatpos += framelen;\n          }\n\n          /* No PDU Payload for this frame */\n          break;\n        }\n        case FCPARM_CONCAT_HDR:\n        {\n          /* Decode for a Concatenated Header; ONLY for DOCSIS versions < 3.1.  No Extended Header */\n          proto_item_append_text (ti, \" (Concatenated Header)\");\n          proto_tree_add_item (docsis_tree, hf_docsis_concat_cnt, tvb, 1, 1, ENC_BIG_ENDIAN);\n          proto_tree_add_item (docsis_tree, hf_docsis_len, tvb, 2, 2, ENC_BIG_ENDIAN);\n          /* Dissect Header Check Sequence field for a PDU */\n          dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);\n\n          /* If this is a concatenated frame setup the length of the concatenated\n           * frame and set the position to the first byte of the first frame\n           */\n          concatlen = len_sid;\n          concatpos = DOCSIS_MIN_HEADER_LEN;\n\n          /* Call the docsis dissector on the same frame\n           * to dissect DOCSIS frames within the concatenated\n           * frame.  concatpos and concatlen are declared\n           * static and are decremented and incremented\n           * respectively when the inner\n           * docsis frames are dissected. */\n          while (concatlen > 0)\n          {\n            next_tvb = tvb_new_subset_length_caplen (tvb, concatpos, -1, concatlen);\n            call_dissector (docsis_handle, next_tvb, pinfo, docsis_tree);\n          }\n          concatlen = 0;\n          concatpos = 0;\n          break;\n        }\n        default:\n            /* Unknown parameter, stop dissection */\n          concatlen = 0;\n          break;\n      } /* switch fcparm */\n      break;\n    }\n  } /* switch fctype*/\n\n  return tvb_captured_length(tvb);\n}",
        "func": "static int\ndissect_docsis (tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void* data _U_)\n{\n  guint8 fc = 0;\n  guint8 fctype = 0;\n  guint8 fcparm = 0;\n  guint8 exthdr = 0;\n  guint16 mac_parm = 0;\n  guint8 hdrlen = DOCSIS_MIN_HEADER_LEN;\n  guint16 len_sid = 0;\n  tvbuff_t *next_tvb = NULL;\n  tvbuff_t *mgt_tvb = NULL;\n  gint pdulen = 0;\n  guint16 payload_length = 0;\n  guint16 framelen = 0;\n  gboolean save_fragmented;\n\n  proto_item *ti;\n  proto_tree *docsis_tree;\n\n  /* concatlen and concatpos are declared static to allow for recursive calls to\n   * the dissect_docsis routine when dissecting Concatenated frames\n   */\n  static guint16 concatlen;\n  static guint16 concatpos;\n\n  /* Extract Frame Control parts */\n  fc = tvb_get_guint8 (tvb, 0); /* Frame Control Byte */\n  fctype = (fc >> 6) & 0x03;    /* Frame Control Type:  2 MSB Bits */\n  fcparm = (fc >> 1) & 0x1F;    /* Frame Control Parameter: Next 5 Bits */\n  exthdr = (fc & 0x01);         /* Extended Header Bit: LSB */\n\n  /* Extract the MAC Parm; MAC Parm and SID offsets; change for a Queue Depth Request */\n  if (fcparm == FCPARM_QUEUE_DEPTH_REQ_FRM) {\n    mac_parm = tvb_get_ntohs (tvb, 1);\n    len_sid = tvb_get_ntohs (tvb, 3);\n    hdrlen = DOCSIS_MIN_HEADER_LEN + 1; // 7-byte header for this message type\n  } else {\n    mac_parm = tvb_get_guint8 (tvb, 1);\n    len_sid = tvb_get_ntohs (tvb, 2);\n  }\n\n  /* Set Header Length based on presence of Extended header */\n  if (exthdr == EXT_HDR_ON) {\n    hdrlen += mac_parm;\n  }\n\n  /* Captured Payload Length is based on the length of the header */\n  payload_length = tvb_captured_length_remaining (tvb, hdrlen);\n\n  /* If this is a Request Frame, then pdulen is 0 and framelen is 6 */\n  if ((fctype == FCTYPE_MACSPC) && (fcparm == FCPARM_RQST_FRM || fcparm == FCPARM_QUEUE_DEPTH_REQ_FRM))\n  {\n    pdulen = 0;\n    if (fcparm == FCPARM_QUEUE_DEPTH_REQ_FRM)\n      framelen = DOCSIS_MIN_HEADER_LEN + 1;\n    else\n      framelen = DOCSIS_MIN_HEADER_LEN;\n  } else {\n    framelen = DOCSIS_MIN_HEADER_LEN + len_sid;\n    pdulen = len_sid - (mac_parm + 2);\n  }\n\n  /* Make entries in Protocol column and Info column on summary display */\n  col_set_str (pinfo->cinfo, COL_PROTOCOL, \"DOCSIS\");\n\n  switch (fctype)\n  {\n    case FCTYPE_PACKET:\n      col_set_str (pinfo->cinfo, COL_INFO, \"Packet PDU\");\n      break;\n    case FCTYPE_RESERVED:\n      col_set_str (pinfo->cinfo, COL_INFO, \"Reserved PDU\");\n      break;\n    case FCTYPE_ISOLAT:\n      col_set_str (pinfo->cinfo, COL_INFO, \"Isolation PDU\");\n      break;\n    case FCTYPE_MACSPC:\n      if (fcparm == FCPARM_RQST_FRM)\n        col_add_fstr (pinfo->cinfo, COL_INFO,\n                      \"Request Frame SID = %u Mini Slots = %u\", len_sid,\n                      mac_parm);\n      else if (fcparm == FCPARM_QUEUE_DEPTH_REQ_FRM)\n        col_add_fstr (pinfo->cinfo, COL_INFO,\n                      \"Request Frame SID = %u Bytes Requested = %u\", len_sid,\n                      mac_parm);\n      else if (fcparm == FCPARM_FRAG_HDR)\n        col_set_str (pinfo->cinfo, COL_INFO, \"Fragmented Frame\");\n      else\n        col_set_str (pinfo->cinfo, COL_INFO, \"Mac Specific\");\n      break;\n  }  /* switch fctype */\n\n  ti = proto_tree_add_item(tree, proto_docsis, tvb, 0, hdrlen, ENC_NA);\n  docsis_tree = proto_item_add_subtree (ti, ett_docsis);\n\n  /* add an item to the subtree, see section 1.6 for more information */\n\n  /* Add in FC Byte fields */\n  proto_tree_add_item (docsis_tree, hf_docsis_fctype, tvb, 0, 1, ENC_BIG_ENDIAN);\n\n  switch (fctype)\n  {\n    case FCTYPE_PACKET:\n    {\n      proto_item_append_text (ti, \" Packet PDU\");\n      proto_tree_add_item (docsis_tree, hf_docsis_fcparm, tvb, 0, 1, ENC_BIG_ENDIAN);\n      proto_tree_add_item (docsis_tree, hf_docsis_exthdr, tvb, 0, 1, ENC_BIG_ENDIAN);\n      /* Dissect Length field for a PDU */\n      dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length);\n      /* Dissect Header Check Sequence field for a PDU */\n      dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);\n      if (pdulen > 0)\n      {\n        next_tvb =  tvb_new_subset_remaining(tvb, hdrlen);\n        call_dissector (eth_withoutfcs_handle, next_tvb, pinfo, docsis_tree);\n      }\n      if (concatlen > 0)\n      {\n        concatlen = concatlen - framelen;\n        concatpos += framelen;\n      }\n      break;\n    }\n    case FCTYPE_RESERVED:\n    {\n      proto_item_append_text (ti, \" Reserved PDU\");\n      proto_tree_add_item (docsis_tree, hf_docsis_fcparm, tvb, 0, 1, ENC_BIG_ENDIAN);\n      proto_tree_add_item (docsis_tree, hf_docsis_exthdr, tvb, 0, 1, ENC_BIG_ENDIAN);\n      /* Dissect Length field for a PDU */\n      dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length);\n      /* Dissect Header Check Sequence field for a PDU */\n      dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);\n\n      if (concatlen > 0)\n      {\n        concatlen = concatlen - framelen;\n        concatpos += framelen;\n      }\n\n      /* Don't do anything for a Reserved Frame */\n      next_tvb =  tvb_new_subset_remaining(tvb, hdrlen);\n      call_data_dissector(next_tvb, pinfo, tree);\n      break;\n    }\n    case FCTYPE_ISOLAT:\n    {\n      proto_item_append_text (ti, \" Isolation PDU\");\n      proto_tree_add_item (docsis_tree, hf_docsis_fcparm, tvb, 0, 1, ENC_BIG_ENDIAN);\n      proto_tree_add_item (docsis_tree, hf_docsis_exthdr, tvb, 0, 1, ENC_BIG_ENDIAN);\n      /* Dissect Length field for a PDU */\n      dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length);\n      /* Dissect Header Check Sequence field for a PDU */\n      dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);\n      if (pdulen > 0)\n      {\n        next_tvb =  tvb_new_subset_remaining(tvb, hdrlen);\n        call_dissector (eth_withoutfcs_handle, next_tvb, pinfo, docsis_tree);\n      }\n      if (concatlen > 0)\n      {\n        concatlen = concatlen - framelen;\n        concatpos += framelen;\n      }\n      break;\n    }\n    case FCTYPE_MACSPC:\n    {\n      proto_item_append_text (ti, \" MAC-Specific PDU\");\n      proto_tree_add_item (docsis_tree, hf_docsis_machdr_fcparm, tvb, 0, 1, ENC_BIG_ENDIAN);\n      proto_tree_add_item (docsis_tree, hf_docsis_exthdr, tvb, 0, 1, ENC_BIG_ENDIAN);\n      switch(fcparm)\n      {\n        case FCPARM_TIMING_HDR:\n          // no break\n        case FCPARM_MAC_MGMT_HDR:\n        {\n          /* Dissect Length field for a PDU */\n          dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length);\n          /* Dissect Header Check Sequence field for a PDU */\n          dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);\n\n          /* Pass off to the DOCSIS Management dissector/s */\n          mgt_tvb = tvb_new_subset_remaining(tvb, hdrlen);\n          call_dissector (docsis_mgmt_handle, mgt_tvb, pinfo, docsis_tree);\n\n          if (concatlen > 0)\n          {\n            concatlen = concatlen - framelen;\n            concatpos += framelen;\n          }\n\n          break;\n        }\n        case FCPARM_RQST_FRM:\n        {\n          /* Decode for a Request Frame.  No extended header */\n          proto_tree_add_uint (docsis_tree, hf_docsis_mini_slots, tvb, 1, 1, mac_parm);\n          proto_tree_add_uint (docsis_tree, hf_docsis_sid, tvb, 2, 2, len_sid);\n          /* Dissect Header Check Sequence field for a PDU */\n          dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);\n\n          if (concatlen > 0)\n          {\n            concatlen = concatlen - framelen;\n            concatpos += framelen;\n          }\n\n          /* Don't do anything for a Request Frame, there is no data following it*/\n          break;\n        }\n        case FCPARM_FRAG_HDR:\n        {\n          /* Check if this is a fragmentation header */\n          save_fragmented = pinfo->fragmented;\n          pinfo->fragmented = TRUE;\n\n          /* Dissect Length field for a PDU */\n          dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length);\n          /* Dissect Header Check Sequence field for a PDU */\n          dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);\n\n          /* Grab the Fragment FCS */\n          guint32 sent_fcs = tvb_get_ntohl(tvb, (hdrlen + len_sid - 4));\n          guint32 fcs = crc32_802_tvb(tvb, tvb_captured_length(tvb) - 4);\n\n          /* Only defragment valid frames with a good FCS */\n          if (sent_fcs == fcs)\n          {\n            fragment_item *frag_msg = NULL;\n            frag_msg = fragment_add_seq_check(&docsis_reassembly_table,\n                                              tvb, hdrlen, pinfo,\n                                              frag_sid, NULL, /* ID for fragments belonging together */\n                                              frag_seq, /* Fragment Sequence Number */\n                                              (len_sid - 4), /* fragment length - to the end */\n                                              !(frag_flags & FRAG_LAST)); /* More fragments? */\n\n            next_tvb = process_reassembled_data(tvb, hdrlen, pinfo,\n                                                \"Reassembled Message\", frag_msg, &docsis_frag_items,\n                                                NULL, docsis_tree);\n\n            if (frag_flags == FRAG_LAST)\n              pinfo->fragmented = FALSE;\n            else\n              pinfo->fragmented = TRUE;\n\n            if (frag_msg) { /* Reassembled */\n              proto_item_append_text (ti, \" (Message Reassembled)\");\n            } else { /* Not last packet of reassembled Short Message */\n              proto_item_append_text (ti, \" (Message fragment %u)\", frag_seq);\n\n            }\n\n            if(next_tvb)\n            {\n              /* By default assume an Ethernet payload */\n              call_dissector (eth_withoutfcs_handle, next_tvb, pinfo, docsis_tree);\n            } else {\n              /* Otherwise treat as Data */\n              tvbuff_t *payload_tvb = tvb_new_subset_length_caplen(tvb, hdrlen, (len_sid - 4), -1);\n              call_data_dissector(payload_tvb, pinfo, docsis_tree);\n            }\n          } else {\n            /* Report frames with a bad FCS */\n            expert_add_info(pinfo, ti, &ei_docsis_frag_fcs_bad);\n          }\n\n          /* Add the Fragment FCS to the end of the parent tree */\n          proto_tree_add_checksum(docsis_tree, tvb, (hdrlen + len_sid - 4), hf_docsis_frag_fcs, hf_docsis_frag_fcs_status, &ei_docsis_frag_fcs_bad, pinfo, fcs, ENC_BIG_ENDIAN, PROTO_CHECKSUM_VERIFY);\n\n          pinfo->fragmented = save_fragmented;\n\n          if (concatlen > 0)\n          {\n            concatlen = concatlen - framelen;\n            concatpos += framelen;\n          }\n\n          break;\n        }\n        case FCPARM_QUEUE_DEPTH_REQ_FRM:\n        {\n          /* Decode for a Queue-depth Based Request */\n          proto_tree_add_uint (docsis_tree, hf_docsis_requested_size, tvb, 1, 2, mac_parm);\n          proto_tree_add_uint (docsis_tree, hf_docsis_sid, tvb, 3, 2, len_sid);\n          /* Dissect Header Check Sequence field for a PDU */\n          dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);\n\n          if (concatlen > 0)\n          {\n            concatlen = concatlen - framelen;\n            concatpos += framelen;\n          }\n\n          /* No PDU Payload for this frame */\n          break;\n        }\n        case FCPARM_CONCAT_HDR:\n        {\n          /* Decode for a Concatenated Header; ONLY for DOCSIS versions < 3.1.  No Extended Header */\n          proto_item_append_text (ti, \" (Concatenated Header)\");\n          proto_tree_add_item (docsis_tree, hf_docsis_concat_cnt, tvb, 1, 1, ENC_BIG_ENDIAN);\n          proto_tree_add_item (docsis_tree, hf_docsis_len, tvb, 2, 2, ENC_BIG_ENDIAN);\n          /* Dissect Header Check Sequence field for a PDU */\n          dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen);\n\n          /* If this is a concatenated frame setup the length of the concatenated\n           * frame and set the position to the first byte of the first frame\n           */\n          concatlen = len_sid;\n          concatpos = DOCSIS_MIN_HEADER_LEN;\n\n          /* Call the docsis dissector on the same frame\n           * to dissect DOCSIS frames within the concatenated\n           * frame.  concatpos and concatlen are declared\n           * static and are decremented and incremented\n           * respectively when the inner\n           * docsis frames are dissected. */\n          while (concatlen > 0)\n          {\n            next_tvb = tvb_new_subset_length_caplen (tvb, concatpos, -1, concatlen);\n            call_dissector (docsis_handle, next_tvb, pinfo, docsis_tree);\n          }\n          concatlen = 0;\n          concatpos = 0;\n          break;\n        }\n        default:\n            /* Unknown parameter, stop dissection */\n          concatlen = 0;\n          break;\n      } /* switch fcparm */\n      break;\n    }\n  } /* switch fctype*/\n\n  return tvb_captured_length(tvb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -183,6 +183,13 @@\n           /* Pass off to the DOCSIS Management dissector/s */\n           mgt_tvb = tvb_new_subset_remaining(tvb, hdrlen);\n           call_dissector (docsis_mgmt_handle, mgt_tvb, pinfo, docsis_tree);\n+\n+          if (concatlen > 0)\n+          {\n+            concatlen = concatlen - framelen;\n+            concatpos += framelen;\n+          }\n+\n           break;\n         }\n         case FCPARM_RQST_FRM:\n@@ -262,6 +269,13 @@\n           proto_tree_add_checksum(docsis_tree, tvb, (hdrlen + len_sid - 4), hf_docsis_frag_fcs, hf_docsis_frag_fcs_status, &ei_docsis_frag_fcs_bad, pinfo, fcs, ENC_BIG_ENDIAN, PROTO_CHECKSUM_VERIFY);\n \n           pinfo->fragmented = save_fragmented;\n+\n+          if (concatlen > 0)\n+          {\n+            concatlen = concatlen - framelen;\n+            concatpos += framelen;\n+          }\n+\n           break;\n         }\n         case FCPARM_QUEUE_DEPTH_REQ_FRM:",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "          if (concatlen > 0)",
                "          {",
                "            concatlen = concatlen - framelen;",
                "            concatpos += framelen;",
                "          }",
                "",
                "",
                "          if (concatlen > 0)",
                "          {",
                "            concatlen = concatlen - framelen;",
                "            concatpos += framelen;",
                "          }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2017-15225",
        "func_name": "binutils-gdb/_bfd_dwarf2_cleanup_debug_info",
        "description": "_bfd_dwarf2_cleanup_debug_info in dwarf2.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (memory leak) via a crafted ELF file.",
        "git_url": "https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=b55ec8b676ed05d93ee49d6c79ae0403616c4fb0",
        "commit_title": "",
        "commit_text": "PR22212, memory leak in nm  \tPR 22212 \t* dwarf2.c (_bfd_dwarf2_cleanup_debug_info): Free \tfuncinfo_hash_table and varinfo_hash_table. ",
        "func_before": "void\n_bfd_dwarf2_cleanup_debug_info (bfd *abfd, void **pinfo)\n{\n  struct dwarf2_debug *stash = (struct dwarf2_debug *) *pinfo;\n  struct comp_unit *each;\n\n  if (abfd == NULL || stash == NULL)\n    return;\n\n  for (each = stash->all_comp_units; each; each = each->next_unit)\n    {\n      struct abbrev_info **abbrevs = each->abbrevs;\n      struct funcinfo *function_table = each->function_table;\n      struct varinfo *variable_table = each->variable_table;\n      size_t i;\n\n      for (i = 0; i < ABBREV_HASH_SIZE; i++)\n\t{\n\t  struct abbrev_info *abbrev = abbrevs[i];\n\n\t  while (abbrev)\n\t    {\n\t      free (abbrev->attrs);\n\t      abbrev = abbrev->next;\n\t    }\n\t}\n\n      if (each->line_table)\n\t{\n\t  free (each->line_table->dirs);\n\t  free (each->line_table->files);\n\t}\n\n      while (function_table)\n\t{\n\t  if (function_table->file)\n\t    {\n\t      free (function_table->file);\n\t      function_table->file = NULL;\n\t    }\n\n\t  if (function_table->caller_file)\n\t    {\n\t      free (function_table->caller_file);\n\t      function_table->caller_file = NULL;\n\t    }\n\t  function_table = function_table->prev_func;\n\t}\n\n      if (each->lookup_funcinfo_table)\n\t{\n\t  free (each->lookup_funcinfo_table);\n\t  each->lookup_funcinfo_table = NULL;\n\t}\n\n      while (variable_table)\n\t{\n\t  if (variable_table->file)\n\t    {\n\t      free (variable_table->file);\n\t      variable_table->file = NULL;\n\t    }\n\n\t  variable_table = variable_table->prev_var;\n\t}\n    }\n\n  if (stash->dwarf_abbrev_buffer)\n    free (stash->dwarf_abbrev_buffer);\n  if (stash->dwarf_line_buffer)\n    free (stash->dwarf_line_buffer);\n  if (stash->dwarf_str_buffer)\n    free (stash->dwarf_str_buffer);\n  if (stash->dwarf_line_str_buffer)\n    free (stash->dwarf_line_str_buffer);\n  if (stash->dwarf_ranges_buffer)\n    free (stash->dwarf_ranges_buffer);\n  if (stash->info_ptr_memory)\n    free (stash->info_ptr_memory);\n  if (stash->close_on_cleanup)\n    bfd_close (stash->bfd_ptr);\n  if (stash->alt_dwarf_str_buffer)\n    free (stash->alt_dwarf_str_buffer);\n  if (stash->alt_dwarf_info_buffer)\n    free (stash->alt_dwarf_info_buffer);\n  if (stash->sec_vma)\n    free (stash->sec_vma);\n  if (stash->adjusted_sections)\n    free (stash->adjusted_sections);\n  if (stash->alt_bfd_ptr)\n    bfd_close (stash->alt_bfd_ptr);\n}",
        "func": "void\n_bfd_dwarf2_cleanup_debug_info (bfd *abfd, void **pinfo)\n{\n  struct dwarf2_debug *stash = (struct dwarf2_debug *) *pinfo;\n  struct comp_unit *each;\n\n  if (abfd == NULL || stash == NULL)\n    return;\n\n  for (each = stash->all_comp_units; each; each = each->next_unit)\n    {\n      struct abbrev_info **abbrevs = each->abbrevs;\n      struct funcinfo *function_table = each->function_table;\n      struct varinfo *variable_table = each->variable_table;\n      size_t i;\n\n      for (i = 0; i < ABBREV_HASH_SIZE; i++)\n\t{\n\t  struct abbrev_info *abbrev = abbrevs[i];\n\n\t  while (abbrev)\n\t    {\n\t      free (abbrev->attrs);\n\t      abbrev = abbrev->next;\n\t    }\n\t}\n\n      if (each->line_table)\n\t{\n\t  free (each->line_table->dirs);\n\t  free (each->line_table->files);\n\t}\n\n      while (function_table)\n\t{\n\t  if (function_table->file)\n\t    {\n\t      free (function_table->file);\n\t      function_table->file = NULL;\n\t    }\n\n\t  if (function_table->caller_file)\n\t    {\n\t      free (function_table->caller_file);\n\t      function_table->caller_file = NULL;\n\t    }\n\t  function_table = function_table->prev_func;\n\t}\n\n      if (each->lookup_funcinfo_table)\n\t{\n\t  free (each->lookup_funcinfo_table);\n\t  each->lookup_funcinfo_table = NULL;\n\t}\n\n      while (variable_table)\n\t{\n\t  if (variable_table->file)\n\t    {\n\t      free (variable_table->file);\n\t      variable_table->file = NULL;\n\t    }\n\n\t  variable_table = variable_table->prev_var;\n\t}\n    }\n\n  if (stash->funcinfo_hash_table)\n    bfd_hash_table_free (&stash->funcinfo_hash_table->base);\n  if (stash->varinfo_hash_table)\n    bfd_hash_table_free (&stash->varinfo_hash_table->base);\n  if (stash->dwarf_abbrev_buffer)\n    free (stash->dwarf_abbrev_buffer);\n  if (stash->dwarf_line_buffer)\n    free (stash->dwarf_line_buffer);\n  if (stash->dwarf_str_buffer)\n    free (stash->dwarf_str_buffer);\n  if (stash->dwarf_line_str_buffer)\n    free (stash->dwarf_line_str_buffer);\n  if (stash->dwarf_ranges_buffer)\n    free (stash->dwarf_ranges_buffer);\n  if (stash->info_ptr_memory)\n    free (stash->info_ptr_memory);\n  if (stash->close_on_cleanup)\n    bfd_close (stash->bfd_ptr);\n  if (stash->alt_dwarf_str_buffer)\n    free (stash->alt_dwarf_str_buffer);\n  if (stash->alt_dwarf_info_buffer)\n    free (stash->alt_dwarf_info_buffer);\n  if (stash->sec_vma)\n    free (stash->sec_vma);\n  if (stash->adjusted_sections)\n    free (stash->adjusted_sections);\n  if (stash->alt_bfd_ptr)\n    bfd_close (stash->alt_bfd_ptr);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -65,6 +65,10 @@\n \t}\n     }\n \n+  if (stash->funcinfo_hash_table)\n+    bfd_hash_table_free (&stash->funcinfo_hash_table->base);\n+  if (stash->varinfo_hash_table)\n+    bfd_hash_table_free (&stash->varinfo_hash_table->base);\n   if (stash->dwarf_abbrev_buffer)\n     free (stash->dwarf_abbrev_buffer);\n   if (stash->dwarf_line_buffer)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  if (stash->funcinfo_hash_table)",
                "    bfd_hash_table_free (&stash->funcinfo_hash_table->base);",
                "  if (stash->varinfo_hash_table)",
                "    bfd_hash_table_free (&stash->varinfo_hash_table->base);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-15593",
        "func_name": "xen-project/xen/_put_page_type",
        "description": "An issue was discovered in Xen through 4.9.x allowing x86 PV guest OS users to cause a denial of service (memory leak) because reference counts are mishandled.",
        "git_url": "https://github.com/xen-project/xen/commit/6410733a8a0dff2fe581338ff631670cf91889db",
        "commit_title": "x86: don't allow page_unlock() to drop the last type reference",
        "commit_text": " Only _put_page_type() does the necessary cleanup, and hence not all domain pages can be released during guest cleanup (leaving around zombie domains) if we get this wrong.  This is XSA-242. ",
        "func_before": "static int _put_page_type(struct page_info *page, bool preemptible,\n                          struct page_info *ptpg)\n{\n    unsigned long nx, x, y = page->u.inuse.type_info;\n    int rc = 0;\n\n    for ( ; ; )\n    {\n        x  = y;\n        nx = x - 1;\n\n        ASSERT((x & PGT_count_mask) != 0);\n\n        if ( unlikely((nx & PGT_count_mask) == 0) )\n        {\n            if ( unlikely((nx & PGT_type_mask) <= PGT_l4_page_table) &&\n                 likely(nx & (PGT_validated|PGT_partial)) )\n            {\n                /*\n                 * Page-table pages must be unvalidated when count is zero. The\n                 * 'free' is safe because the refcnt is non-zero and validated\n                 * bit is clear => other ops will spin or fail.\n                 */\n                nx = x & ~(PGT_validated|PGT_partial);\n                if ( unlikely((y = cmpxchg(&page->u.inuse.type_info,\n                                           x, nx)) != x) )\n                    continue;\n                /* We cleared the 'valid bit' so we do the clean up. */\n                rc = _put_final_page_type(page, x, preemptible, ptpg);\n                ptpg = NULL;\n                if ( x & PGT_partial )\n                    put_page(page);\n                break;\n            }\n\n            if ( ptpg && PGT_type_equal(x, ptpg->u.inuse.type_info) )\n            {\n                /*\n                 * set_tlbflush_timestamp() accesses the same union\n                 * linear_pt_count lives in. Unvalidated page table pages,\n                 * however, should occur during domain destruction only\n                 * anyway.  Updating of linear_pt_count luckily is not\n                 * necessary anymore for a dying domain.\n                 */\n                ASSERT(page_get_owner(page)->is_dying);\n                ASSERT(page->linear_pt_count < 0);\n                ASSERT(ptpg->linear_pt_count > 0);\n                ptpg = NULL;\n            }\n\n            set_tlbflush_timestamp(page);\n        }\n\n        if ( likely((y = cmpxchg(&page->u.inuse.type_info, x, nx)) == x) )\n            break;\n\n        if ( preemptible && hypercall_preempt_check() )\n            return -EINTR;\n    }\n\n    if ( ptpg && PGT_type_equal(x, ptpg->u.inuse.type_info) )\n    {\n        ASSERT(!rc);\n        dec_linear_uses(page);\n        dec_linear_entries(ptpg);\n    }\n\n    return rc;\n}",
        "func": "static int _put_page_type(struct page_info *page, bool preemptible,\n                          struct page_info *ptpg)\n{\n    unsigned long nx, x, y = page->u.inuse.type_info;\n    int rc = 0;\n\n    for ( ; ; )\n    {\n        x  = y;\n        nx = x - 1;\n\n        ASSERT((x & PGT_count_mask) != 0);\n\n        if ( unlikely((nx & PGT_count_mask) == 0) )\n        {\n            if ( unlikely((nx & PGT_type_mask) <= PGT_l4_page_table) &&\n                 likely(nx & (PGT_validated|PGT_partial)) )\n            {\n                /*\n                 * Page-table pages must be unvalidated when count is zero. The\n                 * 'free' is safe because the refcnt is non-zero and validated\n                 * bit is clear => other ops will spin or fail.\n                 */\n                nx = x & ~(PGT_validated|PGT_partial);\n                if ( unlikely((y = cmpxchg(&page->u.inuse.type_info,\n                                           x, nx)) != x) )\n                    continue;\n                /* We cleared the 'valid bit' so we do the clean up. */\n                rc = _put_final_page_type(page, x, preemptible, ptpg);\n                ptpg = NULL;\n                if ( x & PGT_partial )\n                    put_page(page);\n                break;\n            }\n\n            if ( ptpg && PGT_type_equal(x, ptpg->u.inuse.type_info) )\n            {\n                /*\n                 * set_tlbflush_timestamp() accesses the same union\n                 * linear_pt_count lives in. Unvalidated page table pages,\n                 * however, should occur during domain destruction only\n                 * anyway.  Updating of linear_pt_count luckily is not\n                 * necessary anymore for a dying domain.\n                 */\n                ASSERT(page_get_owner(page)->is_dying);\n                ASSERT(page->linear_pt_count < 0);\n                ASSERT(ptpg->linear_pt_count > 0);\n                ptpg = NULL;\n            }\n\n            set_tlbflush_timestamp(page);\n        }\n        else if ( unlikely((nx & (PGT_locked | PGT_count_mask)) ==\n                           (PGT_locked | 1)) )\n        {\n            /*\n             * We must not drop the second to last reference when the page is\n             * locked, as page_unlock() doesn't do any cleanup of the type.\n             */\n            cpu_relax();\n            y = page->u.inuse.type_info;\n            continue;\n        }\n\n        if ( likely((y = cmpxchg(&page->u.inuse.type_info, x, nx)) == x) )\n            break;\n\n        if ( preemptible && hypercall_preempt_check() )\n            return -EINTR;\n    }\n\n    if ( ptpg && PGT_type_equal(x, ptpg->u.inuse.type_info) )\n    {\n        ASSERT(!rc);\n        dec_linear_uses(page);\n        dec_linear_entries(ptpg);\n    }\n\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -50,6 +50,17 @@\n \n             set_tlbflush_timestamp(page);\n         }\n+        else if ( unlikely((nx & (PGT_locked | PGT_count_mask)) ==\n+                           (PGT_locked | 1)) )\n+        {\n+            /*\n+             * We must not drop the second to last reference when the page is\n+             * locked, as page_unlock() doesn't do any cleanup of the type.\n+             */\n+            cpu_relax();\n+            y = page->u.inuse.type_info;\n+            continue;\n+        }\n \n         if ( likely((y = cmpxchg(&page->u.inuse.type_info, x, nx)) == x) )\n             break;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        else if ( unlikely((nx & (PGT_locked | PGT_count_mask)) ==",
                "                           (PGT_locked | 1)) )",
                "        {",
                "            /*",
                "             * We must not drop the second to last reference when the page is",
                "             * locked, as page_unlock() doesn't do any cleanup of the type.",
                "             */",
                "            cpu_relax();",
                "            y = page->u.inuse.type_info;",
                "            continue;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-15593",
        "func_name": "xen-project/xen/page_unlock",
        "description": "An issue was discovered in Xen through 4.9.x allowing x86 PV guest OS users to cause a denial of service (memory leak) because reference counts are mishandled.",
        "git_url": "https://github.com/xen-project/xen/commit/6410733a8a0dff2fe581338ff631670cf91889db",
        "commit_title": "x86: don't allow page_unlock() to drop the last type reference",
        "commit_text": " Only _put_page_type() does the necessary cleanup, and hence not all domain pages can be released during guest cleanup (leaving around zombie domains) if we get this wrong.  This is XSA-242. ",
        "func_before": "void page_unlock(struct page_info *page)\n{\n    unsigned long x, nx, y = page->u.inuse.type_info;\n\n    do {\n        x = y;\n        nx = x - (1 | PGT_locked);\n    } while ( (y = cmpxchg(&page->u.inuse.type_info, x, nx)) != x );\n}",
        "func": "void page_unlock(struct page_info *page)\n{\n    unsigned long x, nx, y = page->u.inuse.type_info;\n\n    do {\n        x = y;\n        ASSERT((x & PGT_count_mask) && (x & PGT_locked));\n\n        nx = x - (1 | PGT_locked);\n        /* We must not drop the last reference here. */\n        ASSERT(nx & PGT_count_mask);\n    } while ( (y = cmpxchg(&page->u.inuse.type_info, x, nx)) != x );\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,10 @@\n \n     do {\n         x = y;\n+        ASSERT((x & PGT_count_mask) && (x & PGT_locked));\n+\n         nx = x - (1 | PGT_locked);\n+        /* We must not drop the last reference here. */\n+        ASSERT(nx & PGT_count_mask);\n     } while ( (y = cmpxchg(&page->u.inuse.type_info, x, nx)) != x );\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        ASSERT((x & PGT_count_mask) && (x & PGT_locked));",
                "",
                "        /* We must not drop the last reference here. */",
                "        ASSERT(nx & PGT_count_mask);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14326",
        "func_name": "ImageMagick/ReadMATImage",
        "description": "In ImageMagick 7.0.7-1 Q16, a memory leak vulnerability was found in the function ReadMATImage in coders/mat.c, which allows attackers to cause a denial of service via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/a542c9f9a53327b623333150874d4e5a5b3bcbd0",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/740",
        "commit_text": "",
        "func_before": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n  image2 = (Image *) NULL;\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if (MATLAB_HDR.DataType!=miMATRIX)\n      {\n        clone_info=DestroyImageInfo(clone_info);\n        continue;  /* skip another objects. */\n      }\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default:\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          if (tmp == image2)\n            image2=(Image *) NULL;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if ((image != image2) && (image2 != (Image *) NULL))\n    image2=DestroyImage(image2);\n  if (image == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  return(image); \n}",
        "func": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n  image2 = (Image *) NULL;\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if (MATLAB_HDR.DataType!=miMATRIX)\n      {\n        clone_info=DestroyImageInfo(clone_info);\n        continue;  /* skip another objects. */\n      }\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3)\n           {\n             if (clone_info != (ImageInfo *) NULL)\n               clone_info=DestroyImageInfo(clone_info);\n             if ((image != image2) && (image2 != (Image *) NULL))\n               image2=DestroyImage(image2);\n             ThrowReaderException(CoderError,\n               \"MultidimensionalMatricesAreNotSupported\");\n           }\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           {\n             if (clone_info != (ImageInfo *) NULL)\n               clone_info=DestroyImageInfo(clone_info);\n             if ((image != image2) && (image2 != (Image *) NULL))\n               image2=DestroyImage(image2);\n             ThrowReaderException(CoderError,\n               \"MultidimensionalMatricesAreNotSupported\");\n           }\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           {\n             if (clone_info != (ImageInfo *) NULL)\n               clone_info=DestroyImageInfo(clone_info);\n             if ((image != image2) && (image2 != (Image *) NULL))\n               image2=DestroyImage(image2);\n             ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n           }\n         break;\n      default:\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          if (tmp == image2)\n            image2=(Image *) NULL;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if ((image != image2) && (image2 != (Image *) NULL))\n    image2=DestroyImage(image2);\n  if (image == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  return(image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -153,14 +153,35 @@\n       case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n            Unknown6 = ReadBlobXXXLong(image2);\n            (void) Unknown6;\n-         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n+         if(z!=3)\n+           {\n+             if (clone_info != (ImageInfo *) NULL)\n+               clone_info=DestroyImageInfo(clone_info);\n+             if ((image != image2) && (image2 != (Image *) NULL))\n+               image2=DestroyImage(image2);\n+             ThrowReaderException(CoderError,\n+               \"MultidimensionalMatricesAreNotSupported\");\n+           }\n          break;\n       case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n          if(z!=3 && z!=1)\n-           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n+           {\n+             if (clone_info != (ImageInfo *) NULL)\n+               clone_info=DestroyImageInfo(clone_info);\n+             if ((image != image2) && (image2 != (Image *) NULL))\n+               image2=DestroyImage(image2);\n+             ThrowReaderException(CoderError,\n+               \"MultidimensionalMatricesAreNotSupported\");\n+           }\n          Frames = ReadBlobXXXLong(image2);\n          if (Frames == 0)\n-           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+           {\n+             if (clone_info != (ImageInfo *) NULL)\n+               clone_info=DestroyImageInfo(clone_info);\n+             if ((image != image2) && (image2 != (Image *) NULL))\n+               image2=DestroyImage(image2);\n+             ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+           }\n          break;\n       default:\n         if (clone_info != (ImageInfo *) NULL)\n@@ -539,5 +560,5 @@\n     image2=DestroyImage(image2);\n   if (image == (Image *) NULL)\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n-  return(image); \n+  return(image);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");",
                "           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");",
                "           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "  return(image); "
            ],
            "added_lines": [
                "         if(z!=3)",
                "           {",
                "             if (clone_info != (ImageInfo *) NULL)",
                "               clone_info=DestroyImageInfo(clone_info);",
                "             if ((image != image2) && (image2 != (Image *) NULL))",
                "               image2=DestroyImage(image2);",
                "             ThrowReaderException(CoderError,",
                "               \"MultidimensionalMatricesAreNotSupported\");",
                "           }",
                "           {",
                "             if (clone_info != (ImageInfo *) NULL)",
                "               clone_info=DestroyImageInfo(clone_info);",
                "             if ((image != image2) && (image2 != (Image *) NULL))",
                "               image2=DestroyImage(image2);",
                "             ThrowReaderException(CoderError,",
                "               \"MultidimensionalMatricesAreNotSupported\");",
                "           }",
                "           {",
                "             if (clone_info != (ImageInfo *) NULL)",
                "               clone_info=DestroyImageInfo(clone_info);",
                "             if ((image != image2) && (image2 != (Image *) NULL))",
                "               image2=DestroyImage(image2);",
                "             ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "           }",
                "  return(image);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14431",
        "func_name": "xen-project/xen/iommu_domain_destroy",
        "description": "Memory leak in Xen 3.3 through 4.8.x allows guest OS users to cause a denial of service (ARM or x86 AMD host OS memory consumption) by continually rebooting, because certain cleanup is skipped if no pass-through device was ever assigned, aka XSA-207.",
        "git_url": "https://github.com/xen-project/xen/commit/93e1435290867703c50acad1f54b9208df473562",
        "commit_title": "IOMMU: always call teardown callback",
        "commit_text": " There is a possible scenario when (d)->need_iommu remains unset during guest domain execution. For example, when no devices were assigned to it. Taking into account that teardown callback is not called when (d)->need_iommu is unset we might have unreleased resourses after destroying domain.  So, always call teardown callback to roll back actions that were performed in init callback.  This is XSA-207. ",
        "func_before": "void iommu_domain_destroy(struct domain *d)\n{\n    if ( !iommu_enabled || !dom_iommu(d)->platform_ops )\n        return;\n\n    if ( need_iommu(d) )\n        iommu_teardown(d);\n\n    arch_iommu_domain_destroy(d);\n}",
        "func": "void iommu_domain_destroy(struct domain *d)\n{\n    if ( !iommu_enabled || !dom_iommu(d)->platform_ops )\n        return;\n\n    iommu_teardown(d);\n\n    arch_iommu_domain_destroy(d);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,8 +3,7 @@\n     if ( !iommu_enabled || !dom_iommu(d)->platform_ops )\n         return;\n \n-    if ( need_iommu(d) )\n-        iommu_teardown(d);\n+    iommu_teardown(d);\n \n     arch_iommu_domain_destroy(d);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    if ( need_iommu(d) )",
                "        iommu_teardown(d);"
            ],
            "added_lines": [
                "    iommu_teardown(d);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14533",
        "func_name": "ImageMagick/ReadMATImage",
        "description": "ImageMagick 7.0.6-6 has a memory leak in ReadMATImage in coders/mat.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/bdfc5538051ad0d1c2083ba2a29180ff6abea907",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/648",
        "commit_text": "",
        "func_before": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default:\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if (image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  else\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n  return (image);\n}",
        "func": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if (MATLAB_HDR.DataType!=miMATRIX)\n      {\n        clone_info=DestroyImageInfo(clone_info);\n        continue;  /* skip another objects. */\n      }\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default:\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if (image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  else\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n  return (image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -122,7 +122,11 @@\n     }\n #endif\n \n-    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n+    if (MATLAB_HDR.DataType!=miMATRIX)\n+      {\n+        clone_info=DestroyImageInfo(clone_info);\n+        continue;  /* skip another objects. */\n+      }\n \n     MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n     MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);",
        "diff_line_info": {
            "deleted_lines": [
                "    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */"
            ],
            "added_lines": [
                "    if (MATLAB_HDR.DataType!=miMATRIX)",
                "      {",
                "        clone_info=DestroyImageInfo(clone_info);",
                "        continue;  /* skip another objects. */",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14684",
        "func_name": "ImageMagick/ReadVIPSImage",
        "description": "In ImageMagick 7.0.7-4 Q16, a memory leak vulnerability was found in the function ReadVIPSImage in coders/vips.c, which allows attackers to cause a denial of service (memory consumption in ResizeMagickMemory in MagickCore/memory.c) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/a25142f284384a10306f14393d9bfd7af95ddfff",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/770",
        "commit_text": "",
        "func_before": "static Image *ReadVIPSImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    buffer[MaxTextExtent],\n    *metadata;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    n;\n\n  unsigned int\n    channels,\n    marker;\n\n  VIPSBandFormat\n    format;\n\n  VIPSCoding\n    coding;\n\n  VIPSType\n    type;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  marker=ReadBlobLSBLong(image);\n  if (marker == VIPS_MAGIC_LSB)\n    image->endian=LSBEndian;\n  else if (marker == VIPS_MAGIC_MSB)\n    image->endian=MSBEndian;\n  else\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  image->columns=(size_t) ReadBlobLong(image);\n  image->rows=(size_t) ReadBlobLong(image);\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  channels=ReadBlobLong(image);\n  (void) ReadBlobLong(image); /* Legacy */\n  format=(VIPSBandFormat) ReadBlobLong(image);\n  switch(format)\n  {\n    case VIPSBandFormatUCHAR:\n    case VIPSBandFormatCHAR:\n      image->depth=8;\n      break;\n    case VIPSBandFormatUSHORT:\n    case VIPSBandFormatSHORT:\n      image->depth=16;\n      break;\n    case VIPSBandFormatUINT:\n    case VIPSBandFormatINT:\n    case VIPSBandFormatFLOAT:\n      image->depth=32;\n      break;\n    case VIPSBandFormatDOUBLE:\n      image->depth=64;\n      break;\n    default:\n    case VIPSBandFormatCOMPLEX:\n    case VIPSBandFormatDPCOMPLEX:\n    case VIPSBandFormatNOTSET:\n      ThrowReaderException(CoderError,\"Unsupported band format\");\n  }\n  coding=(VIPSCoding) ReadBlobLong(image);\n  type=(VIPSType) ReadBlobLong(image);\n  switch(type)\n  {\n    case VIPSTypeCMYK:\n      SetImageColorspace(image,CMYKColorspace);\n      if (channels == 5)\n        image->matte=MagickTrue;\n      break;\n    case VIPSTypeB_W:\n    case VIPSTypeGREY16:\n      SetImageColorspace(image,GRAYColorspace);\n      if (channels == 2)\n        image->matte=MagickTrue;\n      break;\n    case VIPSTypeRGB:\n    case VIPSTypeRGB16:\n      SetImageColorspace(image,RGBColorspace);\n      if (channels == 4)\n        image->matte=MagickTrue;\n      break;\n    case VIPSTypesRGB:\n      SetImageColorspace(image,sRGBColorspace);\n      if (channels == 4)\n        image->matte=MagickTrue;\n      break;\n    default:\n    case VIPSTypeFOURIER:\n    case VIPSTypeHISTOGRAM:\n    case VIPSTypeLAB:\n    case VIPSTypeLABS:\n    case VIPSTypeLABQ:\n    case VIPSTypeLCH:\n    case VIPSTypeMULTIBAND:\n    case VIPSTypeUCS:\n    case VIPSTypeXYZ:\n    case VIPSTypeYXY:\n      ThrowReaderException(CoderError,\"Unsupported colorspace\");\n  }\n  image->units=PixelsPerCentimeterResolution;\n  image->x_resolution=ReadBlobFloat(image)*10;\n  image->y_resolution=ReadBlobFloat(image)*10;\n  /*\n    Legacy, offsets, future\n  */\n  (void) ReadBlobLongLong(image);\n  (void) ReadBlobLongLong(image);\n  (void) ReadBlobLongLong(image);\n  if (image_info->ping != MagickFalse)\n    return(image);\n  if (IsSupportedCombination(format,type) == MagickFalse)\n    ThrowReaderException(CoderError,\n      \"Unsupported combination of band format and colorspace\");\n  if (channels == 0 || channels > 5)\n    ThrowReaderException(CoderError,\"Unsupported number of channels\");\n  if (coding == VIPSCodingNONE)\n    status=ReadVIPSPixelsNONE(image,format,type,channels,exception);\n  else\n    ThrowReaderException(CoderError,\"Unsupported coding\");\n  metadata=(char *) NULL;\n  while ((n=ReadBlob(image,MaxTextExtent-1,(unsigned char *) buffer)) != 0)\n  {\n    buffer[n]='\\0';\n    if (metadata == (char *) NULL)\n      metadata=ConstantString(buffer);\n    else\n      (void) ConcatenateString(&metadata,buffer);\n  }\n  if (metadata != (char *) NULL)\n    SetImageProperty(image,\"vips:metadata\",metadata);\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return((Image *) NULL);\n  return(image);\n}",
        "func": "static Image *ReadVIPSImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    buffer[MaxTextExtent],\n    *metadata;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    n;\n\n  unsigned int\n    channels,\n    marker;\n\n  VIPSBandFormat\n    format;\n\n  VIPSCoding\n    coding;\n\n  VIPSType\n    type;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  marker=ReadBlobLSBLong(image);\n  if (marker == VIPS_MAGIC_LSB)\n    image->endian=LSBEndian;\n  else if (marker == VIPS_MAGIC_MSB)\n    image->endian=MSBEndian;\n  else\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  image->columns=(size_t) ReadBlobLong(image);\n  image->rows=(size_t) ReadBlobLong(image);\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  channels=ReadBlobLong(image);\n  (void) ReadBlobLong(image); /* Legacy */\n  format=(VIPSBandFormat) ReadBlobLong(image);\n  switch(format)\n  {\n    case VIPSBandFormatUCHAR:\n    case VIPSBandFormatCHAR:\n      image->depth=8;\n      break;\n    case VIPSBandFormatUSHORT:\n    case VIPSBandFormatSHORT:\n      image->depth=16;\n      break;\n    case VIPSBandFormatUINT:\n    case VIPSBandFormatINT:\n    case VIPSBandFormatFLOAT:\n      image->depth=32;\n      break;\n    case VIPSBandFormatDOUBLE:\n      image->depth=64;\n      break;\n    default:\n    case VIPSBandFormatCOMPLEX:\n    case VIPSBandFormatDPCOMPLEX:\n    case VIPSBandFormatNOTSET:\n      ThrowReaderException(CoderError,\"Unsupported band format\");\n  }\n  coding=(VIPSCoding) ReadBlobLong(image);\n  type=(VIPSType) ReadBlobLong(image);\n  switch(type)\n  {\n    case VIPSTypeCMYK:\n      SetImageColorspace(image,CMYKColorspace);\n      if (channels == 5)\n        image->matte=MagickTrue;\n      break;\n    case VIPSTypeB_W:\n    case VIPSTypeGREY16:\n      SetImageColorspace(image,GRAYColorspace);\n      if (channels == 2)\n        image->matte=MagickTrue;\n      break;\n    case VIPSTypeRGB:\n    case VIPSTypeRGB16:\n      SetImageColorspace(image,RGBColorspace);\n      if (channels == 4)\n        image->matte=MagickTrue;\n      break;\n    case VIPSTypesRGB:\n      SetImageColorspace(image,sRGBColorspace);\n      if (channels == 4)\n        image->matte=MagickTrue;\n      break;\n    default:\n    case VIPSTypeFOURIER:\n    case VIPSTypeHISTOGRAM:\n    case VIPSTypeLAB:\n    case VIPSTypeLABS:\n    case VIPSTypeLABQ:\n    case VIPSTypeLCH:\n    case VIPSTypeMULTIBAND:\n    case VIPSTypeUCS:\n    case VIPSTypeXYZ:\n    case VIPSTypeYXY:\n      ThrowReaderException(CoderError,\"Unsupported colorspace\");\n  }\n  image->units=PixelsPerCentimeterResolution;\n  image->x_resolution=ReadBlobFloat(image)*10;\n  image->y_resolution=ReadBlobFloat(image)*10;\n  /*\n    Legacy, offsets, future\n  */\n  (void) ReadBlobLongLong(image);\n  (void) ReadBlobLongLong(image);\n  (void) ReadBlobLongLong(image);\n  if (image_info->ping != MagickFalse)\n    return(image);\n  if (IsSupportedCombination(format,type) == MagickFalse)\n    ThrowReaderException(CoderError,\n      \"Unsupported combination of band format and colorspace\");\n  if (channels == 0 || channels > 5)\n    ThrowReaderException(CoderError,\"Unsupported number of channels\");\n  if (coding == VIPSCodingNONE)\n    status=ReadVIPSPixelsNONE(image,format,type,channels,exception);\n  else\n    ThrowReaderException(CoderError,\"Unsupported coding\");\n  metadata=(char *) NULL;\n  while ((n=ReadBlob(image,MaxTextExtent-1,(unsigned char *) buffer)) != 0)\n  {\n    buffer[n]='\\0';\n    if (metadata == (char *) NULL)\n      metadata=ConstantString(buffer);\n    else\n      (void) ConcatenateString(&metadata,buffer);\n  }\n  if (metadata != (char *) NULL)\n    {\n      SetImageProperty(image,\"vips:metadata\",metadata);\n      metadata=(char *) RelinquishMagickMemory(metadata);\n    }\n  (void) CloseBlob(image);\n  if (status == MagickFalse)\n    return((Image *) NULL);\n  return(image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -153,7 +153,10 @@\n       (void) ConcatenateString(&metadata,buffer);\n   }\n   if (metadata != (char *) NULL)\n-    SetImageProperty(image,\"vips:metadata\",metadata);\n+    {\n+      SetImageProperty(image,\"vips:metadata\",metadata);\n+      metadata=(char *) RelinquishMagickMemory(metadata);\n+    }\n   (void) CloseBlob(image);\n   if (status == MagickFalse)\n     return((Image *) NULL);",
        "diff_line_info": {
            "deleted_lines": [
                "    SetImageProperty(image,\"vips:metadata\",metadata);"
            ],
            "added_lines": [
                "    {",
                "      SetImageProperty(image,\"vips:metadata\",metadata);",
                "      metadata=(char *) RelinquishMagickMemory(metadata);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-20622",
        "func_name": "jasper-software/jasper/jpc_dec_decodepkt",
        "description": "JasPer 2.0.14 has a memory leak in base/jas_malloc.c in libjasper.a when \"--output-format jp2\" is used.",
        "git_url": "https://github.com/jasper-software/jasper/commit/aa8516b28344aa1263ee538bb7366c4679a0e1a5",
        "commit_title": "jpc_t2dec: fix various memory leaks in jpc_dec_decodepkt()",
        "commit_text": " Fixes CVE-2018-20622  Closes https://github.com/jasper-maint/jasper/issues/12 Closes https://github.com/mdadams/jasper/issues/193",
        "func_before": "static int jpc_dec_decodepkt(jpc_dec_t *dec, jas_stream_t *pkthdrstream, jas_stream_t *in, int compno, int rlvlno,\n  int prcno, int lyrno)\n{\n\tjpc_bitstream_t *inb;\n\tjpc_dec_tcomp_t *tcomp;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tjpc_dec_cblk_t *cblk;\n\tint n;\n\tint m;\n\tint i;\n\tjpc_tagtreenode_t *leaf;\n\tint included;\n\tint ret;\n\tint numnewpasses;\n\tjpc_dec_seg_t *seg;\n\tint len;\n\tint present;\n\tint savenumnewpasses;\n\tint mycounter;\n\tjpc_ms_t *ms;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_ccp_t *ccp;\n\tjpc_dec_cp_t *cp;\n\tint bandno;\n\tjpc_dec_prc_t *prc;\n\tint usedcblkcnt;\n\tint cblkno;\n\tuint_fast32_t bodylen;\n\tbool discard;\n\tint passno;\n\tint maxpasses;\n\tint hdrlen;\n\tint hdroffstart;\n\tint hdroffend;\n\n\t/* Avoid compiler warning about possible use of uninitialized\n\t  variable. */\n\tbodylen = 0;\n\n\tdiscard = (lyrno >= dec->maxlyrs);\n\n\ttile = dec->curtile;\n\tcp = tile->cp;\n\tccp = &cp->ccps[compno];\n\n\t/*\n\t * Decode the packet header.\n\t */\n\n\t/* Decode the SOP marker segment if present. */\n\tif (cp->csty & JPC_COD_SOP) {\n\t\tif (jpc_dec_lookahead(in) == JPC_MS_SOP) {\n\t\t\tif (!(ms = jpc_getms(in, dec->cstate))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (jpc_ms_gettype(ms) != JPC_MS_SOP) {\n\t\t\t\tjpc_ms_destroy(ms);\n\t\t\t\tjas_eprintf(\"missing SOP marker segment\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tjpc_ms_destroy(ms);\n\t\t}\n\t}\n\nhdroffstart = jas_stream_getrwcount(pkthdrstream);\n\n\tif (!(inb = jpc_bitstream_sopen(pkthdrstream, \"r\"))) {\n\t\treturn -1;\n\t}\n\n\tif ((present = jpc_bitstream_getbit(inb)) < 0) {\n\t\treturn 1;\n\t}\n\tJAS_DBGLOG(10, (\"\\n\", present));\n\tJAS_DBGLOG(10, (\"present=%d \", present));\n\n\t/* Is the packet non-empty? */\n\tif (present) {\n\t\t/* The packet is non-empty. */\n\t\ttcomp = &tile->tcomps[compno];\n\t\trlvl = &tcomp->rlvls[rlvlno];\n\t\tbodylen = 0;\n\t\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t\t  ++bandno, ++band) {\n\t\t\tif (!band->data) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprc = &band->prcs[prcno];\n\t\t\tif (!prc->cblks) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tusedcblkcnt = 0;\n\t\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno < prc->numcblks;\n\t\t\t  ++cblkno, ++cblk) {\n\t\t\t\t++usedcblkcnt;\n\t\t\t\tif (!cblk->numpasses) {\n\t\t\t\t\tleaf = jpc_tagtree_getleaf(prc->incltagtree, usedcblkcnt - 1);\n\t\t\t\t\tif ((included = jpc_tagtree_decode(prc->incltagtree, leaf, lyrno + 1, inb)) < 0) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((included = jpc_bitstream_getbit(inb)) < 0) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tJAS_DBGLOG(10, (\"\\n\"));\n\t\t\t\tJAS_DBGLOG(10, (\"included=%d \", included));\n\t\t\t\tif (!included) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!cblk->numpasses) {\n\t\t\t\t\ti = 1;\n\t\t\t\t\tleaf = jpc_tagtree_getleaf(prc->numimsbstagtree, usedcblkcnt - 1);\n\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\tif ((ret = jpc_tagtree_decode(prc->numimsbstagtree, leaf, i, inb)) < 0) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ret) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++i;\n\t\t\t\t\t}\n\t\t\t\t\tcblk->numimsbs = i - 1;\n\t\t\t\t\tcblk->firstpassno = cblk->numimsbs * 3;\n\t\t\t\t}\n\t\t\t\tif ((numnewpasses = jpc_getnumnewpasses(inb)) < 0) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tJAS_DBGLOG(10, (\"numnewpasses=%d \", numnewpasses));\n\t\t\t\tseg = cblk->curseg;\n\t\t\t\tsavenumnewpasses = numnewpasses;\n\t\t\t\tmycounter = 0;\n\t\t\t\tif (numnewpasses > 0) {\n\t\t\t\t\tif ((m = jpc_getcommacode(inb)) < 0) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tcblk->numlenbits += m;\n\t\t\t\t\tJAS_DBGLOG(10, (\"increment=%d \", m));\n\t\t\t\t\twhile (numnewpasses > 0) {\n\t\t\t\t\t\tpassno = cblk->firstpassno + cblk->numpasses + mycounter;\n\t/* XXX - the maxpasses is not set precisely but this doesn't matter... */\n\t\t\t\t\t\tmaxpasses = JPC_SEGPASSCNT(passno, cblk->firstpassno, 10000, (ccp->cblkctx & JPC_COX_LAZY) != 0, (ccp->cblkctx & JPC_COX_TERMALL) != 0);\n\t\t\t\t\t\tif (!discard && !seg) {\n\t\t\t\t\t\t\tif (!(seg = jpc_seg_alloc())) {\n\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tjpc_seglist_insert(&cblk->segs, cblk->segs.tail, seg);\n\t\t\t\t\t\t\tif (!cblk->curseg) {\n\t\t\t\t\t\t\t\tcblk->curseg = seg;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tseg->passno = passno;\n\t\t\t\t\t\t\tseg->type = JPC_SEGTYPE(seg->passno, cblk->firstpassno, (ccp->cblkctx & JPC_COX_LAZY) != 0);\n\t\t\t\t\t\t\tseg->maxpasses = maxpasses;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn = JAS_MIN(numnewpasses, maxpasses);\n\t\t\t\t\t\tmycounter += n;\n\t\t\t\t\t\tnumnewpasses -= n;\n\t\t\t\t\t\tif ((len = jpc_bitstream_getbits(inb, cblk->numlenbits + jpc_floorlog2(n))) < 0) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tJAS_DBGLOG(10, (\"len=%d \", len));\n\t\t\t\t\t\tif (!discard) {\n\t\t\t\t\t\t\tseg->lyrno = lyrno;\n\t\t\t\t\t\t\tseg->numpasses += n;\n\t\t\t\t\t\t\tseg->cnt = len;\n\t\t\t\t\t\t\tseg = seg->next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbodylen += len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcblk->numpasses += savenumnewpasses;\n\t\t\t}\n\t\t}\n\n\t\tjpc_bitstream_inalign(inb, 0, 0);\n\n\t} else {\n\t\tif (jpc_bitstream_inalign(inb, 0x7f, 0)) {\n\t\t\tjas_eprintf(\"alignment failed\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tjpc_bitstream_close(inb);\n\n\thdroffend = jas_stream_getrwcount(pkthdrstream);\n\thdrlen = hdroffend - hdroffstart;\n\tif (jas_getdbglevel() >= 5) {\n\t\tjas_eprintf(\"hdrlen=%lu bodylen=%lu \\n\", (unsigned long) hdrlen,\n\t\t  (unsigned long) bodylen);\n\t}\n\n\tif (cp->csty & JPC_COD_EPH) {\n\t\tif (jpc_dec_lookahead(pkthdrstream) == JPC_MS_EPH) {\n\t\t\tif (!(ms = jpc_getms(pkthdrstream, dec->cstate))) {\n\t\t\t\tjas_eprintf(\"cannot get (EPH) marker segment\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (jpc_ms_gettype(ms) != JPC_MS_EPH) {\n\t\t\t\tjpc_ms_destroy(ms);\n\t\t\t\tjas_eprintf(\"missing EPH marker segment\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tjpc_ms_destroy(ms);\n\t\t}\n\t}\n\n\t/* decode the packet body. */\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjas_eprintf(\"packet body offset=%06ld\\n\", (long) jas_stream_getrwcount(in));\n\t}\n\n\tif (!discard) {\n\t\ttcomp = &tile->tcomps[compno];\n\t\trlvl = &tcomp->rlvls[rlvlno];\n\t\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t\t  ++bandno, ++band) {\n\t\t\tif (!band->data) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprc = &band->prcs[prcno];\n\t\t\tif (!prc->cblks) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno < prc->numcblks;\n\t\t\t  ++cblkno, ++cblk) {\n\t\t\t\tseg = cblk->curseg;\n\t\t\t\twhile (seg) {\n\t\t\t\t\tif (!seg->stream) {\n\t\t\t\t\t\tif (!(seg->stream = jas_stream_memopen(0, 0))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#if 0\njas_eprintf(\"lyrno=%02d, compno=%02d, lvlno=%02d, prcno=%02d, bandno=%02d, cblkno=%02d, passno=%02d numpasses=%02d cnt=%d numbps=%d, numimsbs=%d\\n\", lyrno, compno, rlvlno, prcno, band - rlvl->bands, cblk - prc->cblks, seg->passno, seg->numpasses, seg->cnt, band->numbps, cblk->numimsbs);\n#endif\n\t\t\t\t\tif (seg->cnt > 0) {\n\t\t\t\t\t\tif (jpc_getdata(in, seg->stream, seg->cnt) < 0) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tseg->cnt = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (seg->numpasses >= seg->maxpasses) {\n\t\t\t\t\t\tcblk->curseg = seg->next;\n\t\t\t\t\t}\n\t\t\t\t\tseg = seg->next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (jas_stream_gobble(in, bodylen) != JAS_CAST(int, bodylen)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
        "func": "static int jpc_dec_decodepkt(jpc_dec_t *dec, jas_stream_t *pkthdrstream, jas_stream_t *in, int compno, int rlvlno,\n  int prcno, int lyrno)\n{\n\tjpc_bitstream_t *inb;\n\tjpc_dec_tcomp_t *tcomp;\n\tjpc_dec_rlvl_t *rlvl;\n\tjpc_dec_band_t *band;\n\tjpc_dec_cblk_t *cblk;\n\tint n;\n\tint m;\n\tint i;\n\tjpc_tagtreenode_t *leaf;\n\tint included;\n\tint ret;\n\tint numnewpasses;\n\tjpc_dec_seg_t *seg;\n\tint len;\n\tint present;\n\tint savenumnewpasses;\n\tint mycounter;\n\tjpc_ms_t *ms;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_ccp_t *ccp;\n\tjpc_dec_cp_t *cp;\n\tint bandno;\n\tjpc_dec_prc_t *prc;\n\tint usedcblkcnt;\n\tint cblkno;\n\tuint_fast32_t bodylen;\n\tbool discard;\n\tint passno;\n\tint maxpasses;\n\tint hdrlen;\n\tint hdroffstart;\n\tint hdroffend;\n\n\t/* Avoid compiler warning about possible use of uninitialized\n\t  variable. */\n\tbodylen = 0;\n\n\tdiscard = (lyrno >= dec->maxlyrs);\n\n\ttile = dec->curtile;\n\tcp = tile->cp;\n\tccp = &cp->ccps[compno];\n\n\t/*\n\t * Decode the packet header.\n\t */\n\n\t/* Decode the SOP marker segment if present. */\n\tif (cp->csty & JPC_COD_SOP) {\n\t\tif (jpc_dec_lookahead(in) == JPC_MS_SOP) {\n\t\t\tif (!(ms = jpc_getms(in, dec->cstate))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (jpc_ms_gettype(ms) != JPC_MS_SOP) {\n\t\t\t\tjpc_ms_destroy(ms);\n\t\t\t\tjas_eprintf(\"missing SOP marker segment\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tjpc_ms_destroy(ms);\n\t\t}\n\t}\n\nhdroffstart = jas_stream_getrwcount(pkthdrstream);\n\n\tif (!(inb = jpc_bitstream_sopen(pkthdrstream, \"r\"))) {\n\t\treturn -1;\n\t}\n\n\tif ((present = jpc_bitstream_getbit(inb)) < 0) {\n\t\tjpc_bitstream_close(inb);\n\t\treturn 1;\n\t}\n\tJAS_DBGLOG(10, (\"\\n\", present));\n\tJAS_DBGLOG(10, (\"present=%d \", present));\n\n\t/* Is the packet non-empty? */\n\tif (present) {\n\t\t/* The packet is non-empty. */\n\t\ttcomp = &tile->tcomps[compno];\n\t\trlvl = &tcomp->rlvls[rlvlno];\n\t\tbodylen = 0;\n\t\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t\t  ++bandno, ++band) {\n\t\t\tif (!band->data) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprc = &band->prcs[prcno];\n\t\t\tif (!prc->cblks) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tusedcblkcnt = 0;\n\t\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno < prc->numcblks;\n\t\t\t  ++cblkno, ++cblk) {\n\t\t\t\t++usedcblkcnt;\n\t\t\t\tif (!cblk->numpasses) {\n\t\t\t\t\tleaf = jpc_tagtree_getleaf(prc->incltagtree, usedcblkcnt - 1);\n\t\t\t\t\tif ((included = jpc_tagtree_decode(prc->incltagtree, leaf, lyrno + 1, inb)) < 0) {\n\t\t\t\t\t\tjpc_bitstream_close(inb);\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ((included = jpc_bitstream_getbit(inb)) < 0) {\n\t\t\t\t\t\tjpc_bitstream_close(inb);\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tJAS_DBGLOG(10, (\"\\n\"));\n\t\t\t\tJAS_DBGLOG(10, (\"included=%d \", included));\n\t\t\t\tif (!included) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!cblk->numpasses) {\n\t\t\t\t\ti = 1;\n\t\t\t\t\tleaf = jpc_tagtree_getleaf(prc->numimsbstagtree, usedcblkcnt - 1);\n\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\tif ((ret = jpc_tagtree_decode(prc->numimsbstagtree, leaf, i, inb)) < 0) {\n\t\t\t\t\t\t\tjpc_bitstream_close(inb);\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ret) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++i;\n\t\t\t\t\t}\n\t\t\t\t\tcblk->numimsbs = i - 1;\n\t\t\t\t\tcblk->firstpassno = cblk->numimsbs * 3;\n\t\t\t\t}\n\t\t\t\tif ((numnewpasses = jpc_getnumnewpasses(inb)) < 0) {\n\t\t\t\t\tjpc_bitstream_close(inb);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tJAS_DBGLOG(10, (\"numnewpasses=%d \", numnewpasses));\n\t\t\t\tseg = cblk->curseg;\n\t\t\t\tsavenumnewpasses = numnewpasses;\n\t\t\t\tmycounter = 0;\n\t\t\t\tif (numnewpasses > 0) {\n\t\t\t\t\tif ((m = jpc_getcommacode(inb)) < 0) {\n\t\t\t\t\t\tjpc_bitstream_close(inb);\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tcblk->numlenbits += m;\n\t\t\t\t\tJAS_DBGLOG(10, (\"increment=%d \", m));\n\t\t\t\t\twhile (numnewpasses > 0) {\n\t\t\t\t\t\tpassno = cblk->firstpassno + cblk->numpasses + mycounter;\n\t/* XXX - the maxpasses is not set precisely but this doesn't matter... */\n\t\t\t\t\t\tmaxpasses = JPC_SEGPASSCNT(passno, cblk->firstpassno, 10000, (ccp->cblkctx & JPC_COX_LAZY) != 0, (ccp->cblkctx & JPC_COX_TERMALL) != 0);\n\t\t\t\t\t\tif (!discard && !seg) {\n\t\t\t\t\t\t\tif (!(seg = jpc_seg_alloc())) {\n\t\t\t\t\t\t\t\tjpc_bitstream_close(inb);\n\t\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tjpc_seglist_insert(&cblk->segs, cblk->segs.tail, seg);\n\t\t\t\t\t\t\tif (!cblk->curseg) {\n\t\t\t\t\t\t\t\tcblk->curseg = seg;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tseg->passno = passno;\n\t\t\t\t\t\t\tseg->type = JPC_SEGTYPE(seg->passno, cblk->firstpassno, (ccp->cblkctx & JPC_COX_LAZY) != 0);\n\t\t\t\t\t\t\tseg->maxpasses = maxpasses;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn = JAS_MIN(numnewpasses, maxpasses);\n\t\t\t\t\t\tmycounter += n;\n\t\t\t\t\t\tnumnewpasses -= n;\n\t\t\t\t\t\tif ((len = jpc_bitstream_getbits(inb, cblk->numlenbits + jpc_floorlog2(n))) < 0) {\n\t\t\t\t\t\t\tjpc_bitstream_close(inb);\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tJAS_DBGLOG(10, (\"len=%d \", len));\n\t\t\t\t\t\tif (!discard) {\n\t\t\t\t\t\t\tseg->lyrno = lyrno;\n\t\t\t\t\t\t\tseg->numpasses += n;\n\t\t\t\t\t\t\tseg->cnt = len;\n\t\t\t\t\t\t\tseg = seg->next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbodylen += len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcblk->numpasses += savenumnewpasses;\n\t\t\t}\n\t\t}\n\n\t\tjpc_bitstream_inalign(inb, 0, 0);\n\n\t} else {\n\t\tif (jpc_bitstream_inalign(inb, 0x7f, 0)) {\n\t\t\tjas_eprintf(\"alignment failed\\n\");\n\t\t\tjpc_bitstream_close(inb);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tjpc_bitstream_close(inb);\n\n\thdroffend = jas_stream_getrwcount(pkthdrstream);\n\thdrlen = hdroffend - hdroffstart;\n\tif (jas_getdbglevel() >= 5) {\n\t\tjas_eprintf(\"hdrlen=%lu bodylen=%lu \\n\", (unsigned long) hdrlen,\n\t\t  (unsigned long) bodylen);\n\t}\n\n\tif (cp->csty & JPC_COD_EPH) {\n\t\tif (jpc_dec_lookahead(pkthdrstream) == JPC_MS_EPH) {\n\t\t\tif (!(ms = jpc_getms(pkthdrstream, dec->cstate))) {\n\t\t\t\tjas_eprintf(\"cannot get (EPH) marker segment\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (jpc_ms_gettype(ms) != JPC_MS_EPH) {\n\t\t\t\tjpc_ms_destroy(ms);\n\t\t\t\tjas_eprintf(\"missing EPH marker segment\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tjpc_ms_destroy(ms);\n\t\t}\n\t}\n\n\t/* decode the packet body. */\n\n\tif (jas_getdbglevel() >= 1) {\n\t\tjas_eprintf(\"packet body offset=%06ld\\n\", (long) jas_stream_getrwcount(in));\n\t}\n\n\tif (!discard) {\n\t\ttcomp = &tile->tcomps[compno];\n\t\trlvl = &tcomp->rlvls[rlvlno];\n\t\tfor (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands;\n\t\t  ++bandno, ++band) {\n\t\t\tif (!band->data) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tprc = &band->prcs[prcno];\n\t\t\tif (!prc->cblks) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (cblkno = 0, cblk = prc->cblks; cblkno < prc->numcblks;\n\t\t\t  ++cblkno, ++cblk) {\n\t\t\t\tseg = cblk->curseg;\n\t\t\t\twhile (seg) {\n\t\t\t\t\tif (!seg->stream) {\n\t\t\t\t\t\tif (!(seg->stream = jas_stream_memopen(0, 0))) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#if 0\njas_eprintf(\"lyrno=%02d, compno=%02d, lvlno=%02d, prcno=%02d, bandno=%02d, cblkno=%02d, passno=%02d numpasses=%02d cnt=%d numbps=%d, numimsbs=%d\\n\", lyrno, compno, rlvlno, prcno, band - rlvl->bands, cblk - prc->cblks, seg->passno, seg->numpasses, seg->cnt, band->numbps, cblk->numimsbs);\n#endif\n\t\t\t\t\tif (seg->cnt > 0) {\n\t\t\t\t\t\tif (jpc_getdata(in, seg->stream, seg->cnt) < 0) {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tseg->cnt = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (seg->numpasses >= seg->maxpasses) {\n\t\t\t\t\t\tcblk->curseg = seg->next;\n\t\t\t\t\t}\n\t\t\t\t\tseg = seg->next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (jas_stream_gobble(in, bodylen) != JAS_CAST(int, bodylen)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -70,6 +70,7 @@\n \t}\n \n \tif ((present = jpc_bitstream_getbit(inb)) < 0) {\n+\t\tjpc_bitstream_close(inb);\n \t\treturn 1;\n \t}\n \tJAS_DBGLOG(10, (\"\\n\", present));\n@@ -97,10 +98,12 @@\n \t\t\t\tif (!cblk->numpasses) {\n \t\t\t\t\tleaf = jpc_tagtree_getleaf(prc->incltagtree, usedcblkcnt - 1);\n \t\t\t\t\tif ((included = jpc_tagtree_decode(prc->incltagtree, leaf, lyrno + 1, inb)) < 0) {\n+\t\t\t\t\t\tjpc_bitstream_close(inb);\n \t\t\t\t\t\treturn -1;\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tif ((included = jpc_bitstream_getbit(inb)) < 0) {\n+\t\t\t\t\t\tjpc_bitstream_close(inb);\n \t\t\t\t\t\treturn -1;\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -114,6 +117,7 @@\n \t\t\t\t\tleaf = jpc_tagtree_getleaf(prc->numimsbstagtree, usedcblkcnt - 1);\n \t\t\t\t\tfor (;;) {\n \t\t\t\t\t\tif ((ret = jpc_tagtree_decode(prc->numimsbstagtree, leaf, i, inb)) < 0) {\n+\t\t\t\t\t\t\tjpc_bitstream_close(inb);\n \t\t\t\t\t\t\treturn -1;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tif (ret) {\n@@ -125,6 +129,7 @@\n \t\t\t\t\tcblk->firstpassno = cblk->numimsbs * 3;\n \t\t\t\t}\n \t\t\t\tif ((numnewpasses = jpc_getnumnewpasses(inb)) < 0) {\n+\t\t\t\t\tjpc_bitstream_close(inb);\n \t\t\t\t\treturn -1;\n \t\t\t\t}\n \t\t\t\tJAS_DBGLOG(10, (\"numnewpasses=%d \", numnewpasses));\n@@ -133,6 +138,7 @@\n \t\t\t\tmycounter = 0;\n \t\t\t\tif (numnewpasses > 0) {\n \t\t\t\t\tif ((m = jpc_getcommacode(inb)) < 0) {\n+\t\t\t\t\t\tjpc_bitstream_close(inb);\n \t\t\t\t\t\treturn -1;\n \t\t\t\t\t}\n \t\t\t\t\tcblk->numlenbits += m;\n@@ -143,6 +149,7 @@\n \t\t\t\t\t\tmaxpasses = JPC_SEGPASSCNT(passno, cblk->firstpassno, 10000, (ccp->cblkctx & JPC_COX_LAZY) != 0, (ccp->cblkctx & JPC_COX_TERMALL) != 0);\n \t\t\t\t\t\tif (!discard && !seg) {\n \t\t\t\t\t\t\tif (!(seg = jpc_seg_alloc())) {\n+\t\t\t\t\t\t\t\tjpc_bitstream_close(inb);\n \t\t\t\t\t\t\t\treturn -1;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tjpc_seglist_insert(&cblk->segs, cblk->segs.tail, seg);\n@@ -157,6 +164,7 @@\n \t\t\t\t\t\tmycounter += n;\n \t\t\t\t\t\tnumnewpasses -= n;\n \t\t\t\t\t\tif ((len = jpc_bitstream_getbits(inb, cblk->numlenbits + jpc_floorlog2(n))) < 0) {\n+\t\t\t\t\t\t\tjpc_bitstream_close(inb);\n \t\t\t\t\t\t\treturn -1;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tJAS_DBGLOG(10, (\"len=%d \", len));\n@@ -178,6 +186,7 @@\n \t} else {\n \t\tif (jpc_bitstream_inalign(inb, 0x7f, 0)) {\n \t\t\tjas_eprintf(\"alignment failed\\n\");\n+\t\t\tjpc_bitstream_close(inb);\n \t\t\treturn -1;\n \t\t}\n \t}",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tjpc_bitstream_close(inb);",
                "\t\t\t\t\t\tjpc_bitstream_close(inb);",
                "\t\t\t\t\t\tjpc_bitstream_close(inb);",
                "\t\t\t\t\t\t\tjpc_bitstream_close(inb);",
                "\t\t\t\t\tjpc_bitstream_close(inb);",
                "\t\t\t\t\t\tjpc_bitstream_close(inb);",
                "\t\t\t\t\t\t\t\tjpc_bitstream_close(inb);",
                "\t\t\t\t\t\t\tjpc_bitstream_close(inb);",
                "\t\t\tjpc_bitstream_close(inb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-3821",
        "func_name": "ceph/civetweb/worker_thread_run",
        "description": "A flaw was found in the way civetweb frontend was handling requests for ceph RGW server with SSL enabled. An unauthenticated attacker could create multiple connections to ceph RADOS gateway to exhaust file descriptors for ceph-radosgw service resulting in a remote denial of service.",
        "git_url": "https://github.com/ceph/civetweb/commit/8fba7751f61a20158fedc3fc69684e9fe8cd0dce",
        "commit_title": "Fix file descriptor leak.",
        "commit_text": " If the openssl initial negotiation fails, then the rest of what sslize does doesn't happen.  One of the last things sslize does is to close the socket at the end of the session. That needs to happen even if there's no session. ",
        "func_before": "static void *\nworker_thread_run(struct worker_thread_args *thread_args)\n{\n\tstruct mg_context *ctx = thread_args->ctx;\n\tstruct mg_connection *conn;\n\tstruct mg_workerTLS tls;\n#if defined(MG_LEGACY_INTERFACE)\n\tuint32_t addr;\n#endif\n\n\tmg_set_thread_name(\"worker\");\n\n\ttls.is_master = 0;\n\ttls.thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);\n#if defined(_WIN32) && !defined(__SYMBIAN32__)\n\ttls.pthread_cond_helper_mutex = CreateEvent(NULL, FALSE, FALSE, NULL);\n#endif\n\n\t/* Initialize thread local storage before calling any callback */\n\tpthread_setspecific(sTlsKey, &tls);\n\n\tif (ctx->callbacks.init_thread) {\n\t\t/* call init_thread for a worker thread (type 1) */\n\t\tctx->callbacks.init_thread(ctx, 1);\n\t}\n\n\t/* Connection structure has been pre-allocated */\n\tif (((int)thread_args->index < 0)\n\t    || ((unsigned)thread_args->index\n\t        >= (unsigned)ctx->cfg_worker_threads)) {\n\t\tmg_cry(fc(ctx),\n\t\t       \"Internal error: Invalid worker index %i\",\n\t\t       (int)thread_args->index);\n\t\treturn NULL;\n\t}\n\tconn = ctx->worker_connections + thread_args->index;\n\n\t/* Request buffers are not pre-allocated. They are private to the\n\t * request and do not contain any state information that might be\n\t * of interest to anyone observing a server status.  */\n\tconn->buf = (char *)mg_malloc_ctx(ctx->max_request_size, conn->ctx);\n\tif (conn->buf == NULL) {\n\t\tmg_cry(fc(ctx),\n\t\t       \"Out of memory: Cannot allocate buffer for worker %i\",\n\t\t       (int)thread_args->index);\n\t\treturn NULL;\n\t}\n\tconn->buf_size = (int)ctx->max_request_size;\n\n\tconn->ctx = ctx;\n\tconn->thread_index = thread_args->index;\n\tconn->request_info.user_data = ctx->user_data;\n\t/* Allocate a mutex for this connection to allow communication both\n\t * within the request handler and from elsewhere in the application\n\t */\n\t(void)pthread_mutex_init(&conn->mutex, &pthread_mutex_attr);\n\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 1; /* not consumed */\n#endif\n\n\t/* Call consume_socket() even when ctx->stop_flag > 0, to let it\n\t * signal sq_empty condvar to wake up the master waiting in\n\t * produce_socket() */\n\twhile (consume_socket(ctx, &conn->client, conn->thread_index)) {\n\t\tconn->conn_birth_time = time(NULL);\n\n/* Fill in IP, port info early so even if SSL setup below fails,\n * error handler would have the corresponding info.\n * Thanks to Johannes Winkelmann for the patch.\n */\n#if defined(USE_IPV6)\n\t\tif (conn->client.rsa.sa.sa_family == AF_INET6) {\n\t\t\tconn->request_info.remote_port =\n\t\t\t    ntohs(conn->client.rsa.sin6.sin6_port);\n\t\t} else\n#endif\n\t\t{\n\t\t\tconn->request_info.remote_port =\n\t\t\t    ntohs(conn->client.rsa.sin.sin_port);\n\t\t}\n\n\t\tsockaddr_to_string(conn->request_info.remote_addr,\n\t\t                   sizeof(conn->request_info.remote_addr),\n\t\t                   &conn->client.rsa);\n\n\t\tDEBUG_TRACE(\"Start processing connection from %s\",\n\t\t            conn->request_info.remote_addr);\n\n#if defined(MG_LEGACY_INTERFACE)\n\t\t/* This legacy interface only works for the IPv4 case */\n\t\taddr = ntohl(conn->client.rsa.sin.sin_addr.s_addr);\n\t\tmemcpy(&conn->request_info.remote_ip, &addr, 4);\n#endif\n\n\t\tconn->request_info.is_ssl = conn->client.is_ssl;\n\n\t\tif (conn->client.is_ssl) {\n#ifndef NO_SSL\n\t\t\t/* HTTPS connection */\n\t\t\tif (sslize(conn,\n\t\t\t           conn->ctx->ssl_ctx,\n\t\t\t           SSL_accept,\n\t\t\t           &(conn->ctx->stop_flag))) {\n\t\t\t\t/* Get SSL client certificate information (if set) */\n\t\t\t\tssl_get_client_cert_info(conn);\n\n\t\t\t\t/* process HTTPS connection */\n\t\t\t\tprocess_new_connection(conn);\n\n\t\t\t\t/* Free client certificate info */\n\t\t\t\tif (conn->request_info.client_cert) {\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->subject));\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->issuer));\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->serial));\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->finger));\n\t\t\t\t\tconn->request_info.client_cert->subject = 0;\n\t\t\t\t\tconn->request_info.client_cert->issuer = 0;\n\t\t\t\t\tconn->request_info.client_cert->serial = 0;\n\t\t\t\t\tconn->request_info.client_cert->finger = 0;\n\t\t\t\t\tmg_free(conn->request_info.client_cert);\n\t\t\t\t\tconn->request_info.client_cert = 0;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\t/* process HTTP connection */\n\t\t\tprocess_new_connection(conn);\n\t\t}\n\n\t\tDEBUG_TRACE(\"%s\", \"Connection closed\");\n\t}\n\n\n\tpthread_setspecific(sTlsKey, NULL);\n#if defined(_WIN32) && !defined(__SYMBIAN32__)\n\tCloseHandle(tls.pthread_cond_helper_mutex);\n#endif\n\tpthread_mutex_destroy(&conn->mutex);\n\n\t/* Free the request buffer. */\n\tconn->buf_size = 0;\n\tmg_free(conn->buf);\n\tconn->buf = NULL;\n\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 9; /* done */\n#endif\n\n\tDEBUG_TRACE(\"%s\", \"exiting\");\n\treturn NULL;\n}",
        "func": "static void *\nworker_thread_run(struct worker_thread_args *thread_args)\n{\n\tstruct mg_context *ctx = thread_args->ctx;\n\tstruct mg_connection *conn;\n\tstruct mg_workerTLS tls;\n#if defined(MG_LEGACY_INTERFACE)\n\tuint32_t addr;\n#endif\n\n\tmg_set_thread_name(\"worker\");\n\n\ttls.is_master = 0;\n\ttls.thread_idx = (unsigned)mg_atomic_inc(&thread_idx_max);\n#if defined(_WIN32) && !defined(__SYMBIAN32__)\n\ttls.pthread_cond_helper_mutex = CreateEvent(NULL, FALSE, FALSE, NULL);\n#endif\n\n\t/* Initialize thread local storage before calling any callback */\n\tpthread_setspecific(sTlsKey, &tls);\n\n\tif (ctx->callbacks.init_thread) {\n\t\t/* call init_thread for a worker thread (type 1) */\n\t\tctx->callbacks.init_thread(ctx, 1);\n\t}\n\n\t/* Connection structure has been pre-allocated */\n\tif (((int)thread_args->index < 0)\n\t    || ((unsigned)thread_args->index\n\t        >= (unsigned)ctx->cfg_worker_threads)) {\n\t\tmg_cry(fc(ctx),\n\t\t       \"Internal error: Invalid worker index %i\",\n\t\t       (int)thread_args->index);\n\t\treturn NULL;\n\t}\n\tconn = ctx->worker_connections + thread_args->index;\n\n\t/* Request buffers are not pre-allocated. They are private to the\n\t * request and do not contain any state information that might be\n\t * of interest to anyone observing a server status.  */\n\tconn->buf = (char *)mg_malloc_ctx(ctx->max_request_size, conn->ctx);\n\tif (conn->buf == NULL) {\n\t\tmg_cry(fc(ctx),\n\t\t       \"Out of memory: Cannot allocate buffer for worker %i\",\n\t\t       (int)thread_args->index);\n\t\treturn NULL;\n\t}\n\tconn->buf_size = (int)ctx->max_request_size;\n\n\tconn->ctx = ctx;\n\tconn->thread_index = thread_args->index;\n\tconn->request_info.user_data = ctx->user_data;\n\t/* Allocate a mutex for this connection to allow communication both\n\t * within the request handler and from elsewhere in the application\n\t */\n\t(void)pthread_mutex_init(&conn->mutex, &pthread_mutex_attr);\n\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 1; /* not consumed */\n#endif\n\n\t/* Call consume_socket() even when ctx->stop_flag > 0, to let it\n\t * signal sq_empty condvar to wake up the master waiting in\n\t * produce_socket() */\n\twhile (consume_socket(ctx, &conn->client, conn->thread_index)) {\n\t\tconn->conn_birth_time = time(NULL);\n\n/* Fill in IP, port info early so even if SSL setup below fails,\n * error handler would have the corresponding info.\n * Thanks to Johannes Winkelmann for the patch.\n */\n#if defined(USE_IPV6)\n\t\tif (conn->client.rsa.sa.sa_family == AF_INET6) {\n\t\t\tconn->request_info.remote_port =\n\t\t\t    ntohs(conn->client.rsa.sin6.sin6_port);\n\t\t} else\n#endif\n\t\t{\n\t\t\tconn->request_info.remote_port =\n\t\t\t    ntohs(conn->client.rsa.sin.sin_port);\n\t\t}\n\n\t\tsockaddr_to_string(conn->request_info.remote_addr,\n\t\t                   sizeof(conn->request_info.remote_addr),\n\t\t                   &conn->client.rsa);\n\n\t\tDEBUG_TRACE(\"Start processing connection from %s\",\n\t\t            conn->request_info.remote_addr);\n\n#if defined(MG_LEGACY_INTERFACE)\n\t\t/* This legacy interface only works for the IPv4 case */\n\t\taddr = ntohl(conn->client.rsa.sin.sin_addr.s_addr);\n\t\tmemcpy(&conn->request_info.remote_ip, &addr, 4);\n#endif\n\n\t\tconn->request_info.is_ssl = conn->client.is_ssl;\n\n\t\tif (conn->client.is_ssl) {\n#ifndef NO_SSL\n\t\t\t/* HTTPS connection */\n\t\t\tif (sslize(conn,\n\t\t\t           conn->ctx->ssl_ctx,\n\t\t\t           SSL_accept,\n\t\t\t           &(conn->ctx->stop_flag))) {\n\t\t\t\t/* Get SSL client certificate information (if set) */\n\t\t\t\tssl_get_client_cert_info(conn);\n\n\t\t\t\t/* process HTTPS connection */\n\t\t\t\tprocess_new_connection(conn);\n\n\t\t\t\t/* Free client certificate info */\n\t\t\t\tif (conn->request_info.client_cert) {\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->subject));\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->issuer));\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->serial));\n\t\t\t\t\tmg_free((void *)(conn->request_info.client_cert->finger));\n\t\t\t\t\tconn->request_info.client_cert->subject = 0;\n\t\t\t\t\tconn->request_info.client_cert->issuer = 0;\n\t\t\t\t\tconn->request_info.client_cert->serial = 0;\n\t\t\t\t\tconn->request_info.client_cert->finger = 0;\n\t\t\t\t\tmg_free(conn->request_info.client_cert);\n\t\t\t\t\tconn->request_info.client_cert = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tclose_connection(conn);\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\t/* process HTTP connection */\n\t\t\tprocess_new_connection(conn);\n\t\t}\n\n\t\tDEBUG_TRACE(\"%s\", \"Connection closed\");\n\t}\n\n\n\tpthread_setspecific(sTlsKey, NULL);\n#if defined(_WIN32) && !defined(__SYMBIAN32__)\n\tCloseHandle(tls.pthread_cond_helper_mutex);\n#endif\n\tpthread_mutex_destroy(&conn->mutex);\n\n\t/* Free the request buffer. */\n\tconn->buf_size = 0;\n\tmg_free(conn->buf);\n\tconn->buf = NULL;\n\n#if defined(USE_SERVER_STATS)\n\tconn->conn_state = 9; /* done */\n#endif\n\n\tDEBUG_TRACE(\"%s\", \"exiting\");\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -122,6 +122,9 @@\n \t\t\t\t\tconn->request_info.client_cert = 0;\n \t\t\t\t}\n \t\t\t}\n+\t\t\telse {\n+\t\t\t\tclose_connection(conn);\n+\t\t\t}\n #endif\n \t\t} else {\n \t\t\t/* process HTTP connection */",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\telse {",
                "\t\t\t\tclose_connection(conn);",
                "\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-17680",
        "func_name": "ImageMagick/ReadXPMImage",
        "description": "In ImageMagick 7.0.7-12 Q16, a memory leak vulnerability was found in the function ReadXPMImage in coders/xpm.c, which allows attackers to cause a denial of service via a crafted xpm image file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/7b97357e7f8d6ae848a4c699fe17db6fcf4bd7a9",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/873",
        "commit_text": "",
        "func_before": "static Image *ReadXPMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    *grey,\n    key[MagickPathExtent],\n    target[MagickPathExtent],\n    *xpm_buffer;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    active,\n    status;\n\n  register char\n    *next,\n    *p,\n    *q;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *r;\n\n  size_t\n    length;\n\n  SplayTreeInfo\n    *xpm_colors;\n\n  ssize_t\n    count,\n    j,\n    y;\n\n  unsigned long\n    colors,\n    columns,\n    rows,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read XPM file.\n  */\n  length=MagickPathExtent;\n  xpm_buffer=(char *) AcquireQuantumMemory((size_t) length,sizeof(*xpm_buffer));\n  if (xpm_buffer == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  *xpm_buffer='\\0';\n  p=xpm_buffer;\n  while (ReadBlobString(image,p) != (char *) NULL)\n  {\n    if ((*p == '#') && ((p == xpm_buffer) || (*(p-1) == '\\n')))\n      continue;\n    if ((*p == '}') && (*(p+1) == ';'))\n      break;\n    p+=strlen(p);\n    if ((size_t) (p-xpm_buffer+MagickPathExtent) < length)\n      continue;\n    length<<=1;\n    xpm_buffer=(char *) ResizeQuantumMemory(xpm_buffer,length+MagickPathExtent,\n      sizeof(*xpm_buffer));\n    if (xpm_buffer == (char *) NULL)\n      break;\n    p=xpm_buffer+strlen(xpm_buffer);\n  }\n  if (xpm_buffer == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  /*\n    Remove comments.\n  */\n  count=0;\n  width=0;\n  for (p=xpm_buffer; *p != '\\0'; p++)\n  {\n    if (*p != '\"')\n      continue;\n    count=(ssize_t) sscanf(p+1,\"%lu %lu %lu %lu\",&columns,&rows,&colors,&width);\n    image->columns=columns;\n    image->rows=rows;\n    image->colors=colors;\n    if (count == 4)\n      break;\n  }\n  if ((count != 4) || (width == 0) || (width > 3) ||\n      (image->columns == 0) || (image->rows == 0) ||\n      (image->colors == 0) || (image->colors > MaxColormapSize))\n    {\n      xpm_buffer=DestroyString(xpm_buffer);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  /*\n    Remove unquoted characters.\n  */\n  active=MagickFalse;\n  for (q=xpm_buffer; *p != '\\0'; )\n  {\n    if (*p++ == '\"')\n      {\n        if (active != MagickFalse)\n          *q++='\\n';\n        active=active != MagickFalse ? MagickFalse : MagickTrue;\n      }\n    if (active != MagickFalse)\n      *q++=(*p);\n  }\n  *q='\\0';\n  /*\n    Initialize image structure.\n  */\n  xpm_colors=NewSplayTree(CompareXPMColor,RelinquishMagickMemory,\n    (void *(*)(void *)) NULL);\n  if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n    {\n      xpm_buffer=DestroyString(xpm_buffer);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  /*\n    Read image colormap.\n  */\n  image->depth=1;\n  next=NextXPMLine(xpm_buffer);\n  for (j=0; (j < (ssize_t) image->colors) && (next != (char *) NULL); j++)\n  {\n    p=next;\n    next=NextXPMLine(p);\n    (void) CopyXPMColor(key,p,MagickMin((size_t) width,MagickPathExtent-1));\n    status=AddValueToSplayTree(xpm_colors,ConstantString(key),(void *) j);\n    /*\n      Parse color.\n    */\n    (void) CopyMagickString(target,\"gray\",MagickPathExtent);\n    q=ParseXPMColor(p+width,MagickTrue);\n    if (q != (char *) NULL)\n      {\n        while ((isspace((int) ((unsigned char) *q)) == 0) && (*q != '\\0'))\n          q++;\n        if ((next-q) < 0)\n          break;\n        if (next != (char *) NULL)\n          (void) CopyXPMColor(target,q,MagickMin((size_t) (next-q),\n            MagickPathExtent-1));\n        else\n          (void) CopyMagickString(target,q,MagickPathExtent);\n        q=ParseXPMColor(target,MagickFalse);\n        if (q != (char *) NULL)\n          *q='\\0';\n      }\n    StripString(target);\n    grey=strstr(target,\"grey\");\n    if (grey != (char *) NULL)\n      grey[2]='a';\n    if (LocaleCompare(target,\"none\") == 0)\n      {\n        image->storage_class=DirectClass;\n        image->alpha_trait=BlendPixelTrait;\n      }\n    status=QueryColorCompliance(target,XPMCompliance,&image->colormap[j],\n      exception);\n    if (status == MagickFalse)\n      break;\n    if (image->depth < image->colormap[j].depth)\n      image->depth=image->colormap[j].depth;\n  }\n  if (j < (ssize_t) image->colors)\n    {\n      xpm_colors=DestroySplayTree(xpm_colors);\n      xpm_buffer=DestroyString(xpm_buffer);\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n  j=0;\n  if (image_info->ping == MagickFalse)\n    {\n      /*\n        Read image pixels.\n      */\n      status=SetImageExtent(image,image->columns,image->rows,exception);\n      if (status == MagickFalse)\n        return(DestroyImageList(image));\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        p=NextXPMLine(p);\n        if (p == (char *) NULL)\n          break;\n        r=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (r == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          ssize_t count=CopyXPMColor(key,p,MagickMin(width,MagickPathExtent-1));\n          if (count != (ssize_t) width)\n            break;\n          j=(ssize_t) GetValueFromSplayTree(xpm_colors,key);\n          if (image->storage_class == PseudoClass)\n            SetPixelIndex(image,(Quantum) j,r);\n          SetPixelViaPixelInfo(image,image->colormap+j,r);\n          p+=count;\n          r+=GetPixelChannels(image);\n        }\n        if (x < (ssize_t) image->columns)\n          break;\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n      if (y < (ssize_t) image->rows)\n        {\n          xpm_colors=DestroySplayTree(xpm_colors);\n          xpm_buffer=DestroyString(xpm_buffer);\n          ThrowReaderException(CorruptImageError,\"NotEnoughPixelData\");\n        }\n    }\n  /*\n    Relinquish resources.\n  */\n  xpm_buffer=DestroyString(xpm_buffer);\n  xpm_colors=DestroySplayTree(xpm_colors);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadXPMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    *grey,\n    key[MagickPathExtent],\n    target[MagickPathExtent],\n    *xpm_buffer;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    active,\n    status;\n\n  register char\n    *next,\n    *p,\n    *q;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *r;\n\n  size_t\n    length;\n\n  SplayTreeInfo\n    *xpm_colors;\n\n  ssize_t\n    count,\n    j,\n    y;\n\n  unsigned long\n    colors,\n    columns,\n    rows,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read XPM file.\n  */\n  length=MagickPathExtent;\n  xpm_buffer=(char *) AcquireQuantumMemory((size_t) length,sizeof(*xpm_buffer));\n  if (xpm_buffer == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  *xpm_buffer='\\0';\n  p=xpm_buffer;\n  while (ReadBlobString(image,p) != (char *) NULL)\n  {\n    if ((*p == '#') && ((p == xpm_buffer) || (*(p-1) == '\\n')))\n      continue;\n    if ((*p == '}') && (*(p+1) == ';'))\n      break;\n    p+=strlen(p);\n    if ((size_t) (p-xpm_buffer+MagickPathExtent) < length)\n      continue;\n    length<<=1;\n    xpm_buffer=(char *) ResizeQuantumMemory(xpm_buffer,length+MagickPathExtent,\n      sizeof(*xpm_buffer));\n    if (xpm_buffer == (char *) NULL)\n      break;\n    p=xpm_buffer+strlen(xpm_buffer);\n  }\n  if (xpm_buffer == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  /*\n    Remove comments.\n  */\n  count=0;\n  width=0;\n  for (p=xpm_buffer; *p != '\\0'; p++)\n  {\n    if (*p != '\"')\n      continue;\n    count=(ssize_t) sscanf(p+1,\"%lu %lu %lu %lu\",&columns,&rows,&colors,&width);\n    image->columns=columns;\n    image->rows=rows;\n    image->colors=colors;\n    if (count == 4)\n      break;\n  }\n  if ((count != 4) || (width == 0) || (width > 3) ||\n      (image->columns == 0) || (image->rows == 0) ||\n      (image->colors == 0) || (image->colors > MaxColormapSize))\n    {\n      xpm_buffer=DestroyString(xpm_buffer);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  /*\n    Remove unquoted characters.\n  */\n  active=MagickFalse;\n  for (q=xpm_buffer; *p != '\\0'; )\n  {\n    if (*p++ == '\"')\n      {\n        if (active != MagickFalse)\n          *q++='\\n';\n        active=active != MagickFalse ? MagickFalse : MagickTrue;\n      }\n    if (active != MagickFalse)\n      *q++=(*p);\n  }\n  *q='\\0';\n  /*\n    Initialize image structure.\n  */\n  xpm_colors=NewSplayTree(CompareXPMColor,RelinquishMagickMemory,\n    (void *(*)(void *)) NULL);\n  if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n    {\n      xpm_buffer=DestroyString(xpm_buffer);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  /*\n    Read image colormap.\n  */\n  image->depth=1;\n  next=NextXPMLine(xpm_buffer);\n  for (j=0; (j < (ssize_t) image->colors) && (next != (char *) NULL); j++)\n  {\n    p=next;\n    next=NextXPMLine(p);\n    (void) CopyXPMColor(key,p,MagickMin((size_t) width,MagickPathExtent-1));\n    status=AddValueToSplayTree(xpm_colors,ConstantString(key),(void *) j);\n    /*\n      Parse color.\n    */\n    (void) CopyMagickString(target,\"gray\",MagickPathExtent);\n    q=ParseXPMColor(p+width,MagickTrue);\n    if (q != (char *) NULL)\n      {\n        while ((isspace((int) ((unsigned char) *q)) == 0) && (*q != '\\0'))\n          q++;\n        if ((next-q) < 0)\n          break;\n        if (next != (char *) NULL)\n          (void) CopyXPMColor(target,q,MagickMin((size_t) (next-q),\n            MagickPathExtent-1));\n        else\n          (void) CopyMagickString(target,q,MagickPathExtent);\n        q=ParseXPMColor(target,MagickFalse);\n        if (q != (char *) NULL)\n          *q='\\0';\n      }\n    StripString(target);\n    grey=strstr(target,\"grey\");\n    if (grey != (char *) NULL)\n      grey[2]='a';\n    if (LocaleCompare(target,\"none\") == 0)\n      {\n        image->storage_class=DirectClass;\n        image->alpha_trait=BlendPixelTrait;\n      }\n    status=QueryColorCompliance(target,XPMCompliance,&image->colormap[j],\n      exception);\n    if (status == MagickFalse)\n      break;\n    if (image->depth < image->colormap[j].depth)\n      image->depth=image->colormap[j].depth;\n  }\n  if (j < (ssize_t) image->colors)\n    {\n      xpm_colors=DestroySplayTree(xpm_colors);\n      xpm_buffer=DestroyString(xpm_buffer);\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n  j=0;\n  if (image_info->ping == MagickFalse)\n    {\n      /*\n        Read image pixels.\n      */\n      status=SetImageExtent(image,image->columns,image->rows,exception);\n      if (status == MagickFalse)\n        {\n          xpm_colors=DestroySplayTree(xpm_colors);\n          xpm_buffer=DestroyString(xpm_buffer);\n          return(DestroyImageList(image));\n        }\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        p=NextXPMLine(p);\n        if (p == (char *) NULL)\n          break;\n        r=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (r == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          ssize_t count=CopyXPMColor(key,p,MagickMin(width,MagickPathExtent-1));\n          if (count != (ssize_t) width)\n            break;\n          j=(ssize_t) GetValueFromSplayTree(xpm_colors,key);\n          if (image->storage_class == PseudoClass)\n            SetPixelIndex(image,(Quantum) j,r);\n          SetPixelViaPixelInfo(image,image->colormap+j,r);\n          p+=count;\n          r+=GetPixelChannels(image);\n        }\n        if (x < (ssize_t) image->columns)\n          break;\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n      if (y < (ssize_t) image->rows)\n        {\n          xpm_colors=DestroySplayTree(xpm_colors);\n          xpm_buffer=DestroyString(xpm_buffer);\n          ThrowReaderException(CorruptImageError,\"NotEnoughPixelData\");\n        }\n    }\n  /*\n    Relinquish resources.\n  */\n  xpm_buffer=DestroyString(xpm_buffer);\n  xpm_colors=DestroySplayTree(xpm_colors);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -195,7 +195,11 @@\n       */\n       status=SetImageExtent(image,image->columns,image->rows,exception);\n       if (status == MagickFalse)\n-        return(DestroyImageList(image));\n+        {\n+          xpm_colors=DestroySplayTree(xpm_colors);\n+          xpm_buffer=DestroyString(xpm_buffer);\n+          return(DestroyImageList(image));\n+        }\n       for (y=0; y < (ssize_t) image->rows; y++)\n       {\n         p=NextXPMLine(p);",
        "diff_line_info": {
            "deleted_lines": [
                "        return(DestroyImageList(image));"
            ],
            "added_lines": [
                "        {",
                "          xpm_colors=DestroySplayTree(xpm_colors);",
                "          xpm_buffer=DestroyString(xpm_buffer);",
                "          return(DestroyImageList(image));",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-17881",
        "func_name": "ImageMagick/ReadMATImage",
        "description": "In ImageMagick 7.0.7-12 Q16, a memory leak vulnerability was found in the function ReadMATImage in coders/mat.c, which allows attackers to cause a denial of service via a crafted MAT image file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/aa601d79a630f6de0694fadbeee31456a357fa73",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/878",
        "commit_text": "",
        "func_before": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n  image2 = (Image *) NULL;\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if (MATLAB_HDR.DataType!=miMATRIX)\n      {\n        clone_info=DestroyImageInfo(clone_info);\n        continue;  /* skip another objects. */\n      }\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3)\n           {\n             if (clone_info != (ImageInfo *) NULL)\n               clone_info=DestroyImageInfo(clone_info);\n             if ((image != image2) && (image2 != (Image *) NULL))\n               image2=DestroyImage(image2);\n             ThrowReaderException(CoderError,\n               \"MultidimensionalMatricesAreNotSupported\");\n           }\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           {\n             if (clone_info != (ImageInfo *) NULL)\n               clone_info=DestroyImageInfo(clone_info);\n             if ((image != image2) && (image2 != (Image *) NULL))\n               image2=DestroyImage(image2);\n             ThrowReaderException(CoderError,\n               \"MultidimensionalMatricesAreNotSupported\");\n           }\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           {\n             if (clone_info != (ImageInfo *) NULL)\n               clone_info=DestroyImageInfo(clone_info);\n             if ((image != image2) && (image2 != (Image *) NULL))\n               image2=DestroyImage(image2);\n             ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n           }\n         break;\n      default:\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          if (tmp == image2)\n            image2=(Image *) NULL;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if ((image != image2) && (image2 != (Image *) NULL))\n    image2=DestroyImage(image2);\n  if (image == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  return(image);\n}",
        "func": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n  image2 = (Image *) NULL;\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if (MATLAB_HDR.DataType!=miMATRIX)\n      {\n        clone_info=DestroyImageInfo(clone_info);\n        continue;  /* skip another objects. */\n      }\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3)\n           {\n             if (clone_info != (ImageInfo *) NULL)\n               clone_info=DestroyImageInfo(clone_info);\n             if ((image != image2) && (image2 != (Image *) NULL))\n               image2=DestroyImage(image2);\n             ThrowReaderException(CoderError,\n               \"MultidimensionalMatricesAreNotSupported\");\n           }\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           {\n             if (clone_info != (ImageInfo *) NULL)\n               clone_info=DestroyImageInfo(clone_info);\n             if ((image != image2) && (image2 != (Image *) NULL))\n               image2=DestroyImage(image2);\n             ThrowReaderException(CoderError,\n               \"MultidimensionalMatricesAreNotSupported\");\n           }\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           {\n             if (clone_info != (ImageInfo *) NULL)\n               clone_info=DestroyImageInfo(clone_info);\n             if ((image != image2) && (image2 != (Image *) NULL))\n               image2=DestroyImage(image2);\n             ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n           }\n         break;\n      default:\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      {\n        if ((image2 != (Image*) NULL) && (image2 != (Image *) image))\n          {\n            CloseBlob(image2);\n            DeleteImageFromList(&image2);\n          }\n        if (clone_info != (ImageInfo *) NULL)\n          DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n      }\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          if (tmp == image2)\n            image2=(Image *) NULL;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if ((image != image2) && (image2 != (Image *) NULL))\n    image2=DestroyImage(image2);\n  if (image == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  return(image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -207,7 +207,16 @@\n         MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n         MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n         MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n-      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n+      {\n+        if ((image2 != (Image*) NULL) && (image2 != (Image *) image))\n+          {\n+            CloseBlob(image2);\n+            DeleteImageFromList(&image2);\n+          }\n+        if (clone_info != (ImageInfo *) NULL)\n+          DestroyImageInfo(clone_info);\n+        ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n+      }\n \n     switch (MATLAB_HDR.NameFlag)\n     {",
        "diff_line_info": {
            "deleted_lines": [
                "      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");"
            ],
            "added_lines": [
                "      {",
                "        if ((image2 != (Image*) NULL) && (image2 != (Image *) image))",
                "          {",
                "            CloseBlob(image2);",
                "            DeleteImageFromList(&image2);",
                "          }",
                "        if (clone_info != (ImageInfo *) NULL)",
                "          DestroyImageInfo(clone_info);",
                "        ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-17882",
        "func_name": "ImageMagick/ReadXPMImage",
        "description": "In ImageMagick 7.0.7-12 Q16, a memory leak vulnerability was found in the function ReadXPMImage in coders/xpm.c, which allows attackers to cause a denial of service via a crafted XPM image file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/903f14eb94521aa6dca9d9ac55d3d9a6c7676a63",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/880",
        "commit_text": "",
        "func_before": "static Image *ReadXPMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    *grey,\n    key[MagickPathExtent],\n    target[MagickPathExtent],\n    *xpm_buffer;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    active,\n    status;\n\n  register char\n    *next,\n    *p,\n    *q;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *r;\n\n  size_t\n    length;\n\n  SplayTreeInfo\n    *xpm_colors;\n\n  ssize_t\n    count,\n    j,\n    y;\n\n  unsigned long\n    colors,\n    columns,\n    rows,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read XPM file.\n  */\n  length=MagickPathExtent;\n  xpm_buffer=(char *) AcquireQuantumMemory((size_t) length,sizeof(*xpm_buffer));\n  if (xpm_buffer == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  *xpm_buffer='\\0';\n  p=xpm_buffer;\n  while (ReadBlobString(image,p) != (char *) NULL)\n  {\n    if ((*p == '#') && ((p == xpm_buffer) || (*(p-1) == '\\n')))\n      continue;\n    if ((*p == '}') && (*(p+1) == ';'))\n      break;\n    p+=strlen(p);\n    if ((size_t) (p-xpm_buffer+MagickPathExtent) < length)\n      continue;\n    length<<=1;\n    xpm_buffer=(char *) ResizeQuantumMemory(xpm_buffer,length+MagickPathExtent,\n      sizeof(*xpm_buffer));\n    if (xpm_buffer == (char *) NULL)\n      break;\n    p=xpm_buffer+strlen(xpm_buffer);\n  }\n  if (xpm_buffer == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  /*\n    Remove comments.\n  */\n  count=0;\n  width=0;\n  for (p=xpm_buffer; *p != '\\0'; p++)\n  {\n    if (*p != '\"')\n      continue;\n    count=(ssize_t) sscanf(p+1,\"%lu %lu %lu %lu\",&columns,&rows,&colors,&width);\n    image->columns=columns;\n    image->rows=rows;\n    image->colors=colors;\n    if (count == 4)\n      break;\n  }\n  if ((count != 4) || (width == 0) || (width > 3) ||\n      (image->columns == 0) || (image->rows == 0) ||\n      (image->colors == 0) || (image->colors > MaxColormapSize))\n    {\n      xpm_buffer=DestroyString(xpm_buffer);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  /*\n    Remove unquoted characters.\n  */\n  active=MagickFalse;\n  for (q=xpm_buffer; *p != '\\0'; )\n  {\n    if (*p++ == '\"')\n      {\n        if (active != MagickFalse)\n          *q++='\\n';\n        active=active != MagickFalse ? MagickFalse : MagickTrue;\n      }\n    if (active != MagickFalse)\n      *q++=(*p);\n  }\n  *q='\\0';\n  /*\n    Initialize image structure.\n  */\n  xpm_colors=NewSplayTree(CompareXPMColor,RelinquishMagickMemory,\n    (void *(*)(void *)) NULL);\n  if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n    {\n      xpm_buffer=DestroyString(xpm_buffer);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  /*\n    Read image colormap.\n  */\n  image->depth=1;\n  next=NextXPMLine(xpm_buffer);\n  for (j=0; (j < (ssize_t) image->colors) && (next != (char *) NULL); j++)\n  {\n    p=next;\n    next=NextXPMLine(p);\n    (void) CopyXPMColor(key,p,MagickMin((size_t) width,MagickPathExtent-1));\n    status=AddValueToSplayTree(xpm_colors,ConstantString(key),(void *) j);\n    /*\n      Parse color.\n    */\n    (void) CopyMagickString(target,\"gray\",MagickPathExtent);\n    q=ParseXPMColor(p+width,MagickTrue);\n    if (q != (char *) NULL)\n      {\n        while ((isspace((int) ((unsigned char) *q)) == 0) && (*q != '\\0'))\n          q++;\n        if ((next-q) < 0)\n          break;\n        if (next != (char *) NULL)\n          (void) CopyXPMColor(target,q,MagickMin((size_t) (next-q),\n            MagickPathExtent-1));\n        else\n          (void) CopyMagickString(target,q,MagickPathExtent);\n        q=ParseXPMColor(target,MagickFalse);\n        if (q != (char *) NULL)\n          *q='\\0';\n      }\n    StripString(target);\n    grey=strstr(target,\"grey\");\n    if (grey != (char *) NULL)\n      grey[2]='a';\n    if (LocaleCompare(target,\"none\") == 0)\n      {\n        image->storage_class=DirectClass;\n        image->alpha_trait=BlendPixelTrait;\n      }\n    status=QueryColorCompliance(target,XPMCompliance,&image->colormap[j],\n      exception);\n    if (status == MagickFalse)\n      break;\n    if (image->depth < image->colormap[j].depth)\n      image->depth=image->colormap[j].depth;\n  }\n  if (j < (ssize_t) image->colors)\n    {\n      xpm_colors=DestroySplayTree(xpm_colors);\n      xpm_buffer=DestroyString(xpm_buffer);\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n  j=0;\n  if (image_info->ping == MagickFalse)\n    {\n      /*\n        Read image pixels.\n      */\n      status=SetImageExtent(image,image->columns,image->rows,exception);\n      if (status == MagickFalse)\n        {\n          xpm_colors=DestroySplayTree(xpm_colors);\n          xpm_buffer=DestroyString(xpm_buffer);\n          return(DestroyImageList(image));\n        }\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        p=NextXPMLine(p);\n        if (p == (char *) NULL)\n          break;\n        r=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (r == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          ssize_t count=CopyXPMColor(key,p,MagickMin(width,MagickPathExtent-1));\n          if (count != (ssize_t) width)\n            break;\n          j=(ssize_t) GetValueFromSplayTree(xpm_colors,key);\n          if (image->storage_class == PseudoClass)\n            SetPixelIndex(image,(Quantum) j,r);\n          SetPixelViaPixelInfo(image,image->colormap+j,r);\n          p+=count;\n          r+=GetPixelChannels(image);\n        }\n        if (x < (ssize_t) image->columns)\n          break;\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n      if (y < (ssize_t) image->rows)\n        {\n          xpm_colors=DestroySplayTree(xpm_colors);\n          xpm_buffer=DestroyString(xpm_buffer);\n          ThrowReaderException(CorruptImageError,\"NotEnoughPixelData\");\n        }\n    }\n  /*\n    Relinquish resources.\n  */\n  xpm_buffer=DestroyString(xpm_buffer);\n  xpm_colors=DestroySplayTree(xpm_colors);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadXPMImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    *grey,\n    key[MagickPathExtent],\n    target[MagickPathExtent],\n    *xpm_buffer;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    active,\n    status;\n\n  register char\n    *next,\n    *p,\n    *q;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *r;\n\n  size_t\n    length;\n\n  SplayTreeInfo\n    *xpm_colors;\n\n  ssize_t\n    count,\n    j,\n    y;\n\n  unsigned long\n    colors,\n    columns,\n    rows,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read XPM file.\n  */\n  length=MagickPathExtent;\n  xpm_buffer=(char *) AcquireQuantumMemory((size_t) length,sizeof(*xpm_buffer));\n  if (xpm_buffer == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  *xpm_buffer='\\0';\n  p=xpm_buffer;\n  while (ReadBlobString(image,p) != (char *) NULL)\n  {\n    if ((*p == '#') && ((p == xpm_buffer) || (*(p-1) == '\\n')))\n      continue;\n    if ((*p == '}') && (*(p+1) == ';'))\n      break;\n    p+=strlen(p);\n    if ((size_t) (p-xpm_buffer+MagickPathExtent) < length)\n      continue;\n    length<<=1;\n    xpm_buffer=(char *) ResizeQuantumMemory(xpm_buffer,length+MagickPathExtent,\n      sizeof(*xpm_buffer));\n    if (xpm_buffer == (char *) NULL)\n      break;\n    p=xpm_buffer+strlen(xpm_buffer);\n  }\n  if (xpm_buffer == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  /*\n    Remove comments.\n  */\n  count=0;\n  width=0;\n  for (p=xpm_buffer; *p != '\\0'; p++)\n  {\n    if (*p != '\"')\n      continue;\n    count=(ssize_t) sscanf(p+1,\"%lu %lu %lu %lu\",&columns,&rows,&colors,&width);\n    image->columns=columns;\n    image->rows=rows;\n    image->colors=colors;\n    if (count == 4)\n      break;\n  }\n  if ((count != 4) || (width == 0) || (width > 3) ||\n      (image->columns == 0) || (image->rows == 0) ||\n      (image->colors == 0) || (image->colors > MaxColormapSize))\n    {\n      xpm_buffer=DestroyString(xpm_buffer);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  /*\n    Remove unquoted characters.\n  */\n  active=MagickFalse;\n  for (q=xpm_buffer; *p != '\\0'; )\n  {\n    if (*p++ == '\"')\n      {\n        if (active != MagickFalse)\n          *q++='\\n';\n        active=active != MagickFalse ? MagickFalse : MagickTrue;\n      }\n    if (active != MagickFalse)\n      *q++=(*p);\n  }\n  *q='\\0';\n  /*\n    Initialize image structure.\n  */\n  xpm_colors=NewSplayTree(CompareXPMColor,RelinquishMagickMemory,\n    (void *(*)(void *)) NULL);\n  if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n    {\n      xpm_colors=DestroySplayTree(xpm_colors);\n      xpm_buffer=DestroyString(xpm_buffer);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  /*\n    Read image colormap.\n  */\n  image->depth=1;\n  next=NextXPMLine(xpm_buffer);\n  for (j=0; (j < (ssize_t) image->colors) && (next != (char *) NULL); j++)\n  {\n    p=next;\n    next=NextXPMLine(p);\n    (void) CopyXPMColor(key,p,MagickMin((size_t) width,MagickPathExtent-1));\n    status=AddValueToSplayTree(xpm_colors,ConstantString(key),(void *) j);\n    /*\n      Parse color.\n    */\n    (void) CopyMagickString(target,\"gray\",MagickPathExtent);\n    q=ParseXPMColor(p+width,MagickTrue);\n    if (q != (char *) NULL)\n      {\n        while ((isspace((int) ((unsigned char) *q)) == 0) && (*q != '\\0'))\n          q++;\n        if ((next-q) < 0)\n          break;\n        if (next != (char *) NULL)\n          (void) CopyXPMColor(target,q,MagickMin((size_t) (next-q),\n            MagickPathExtent-1));\n        else\n          (void) CopyMagickString(target,q,MagickPathExtent);\n        q=ParseXPMColor(target,MagickFalse);\n        if (q != (char *) NULL)\n          *q='\\0';\n      }\n    StripString(target);\n    grey=strstr(target,\"grey\");\n    if (grey != (char *) NULL)\n      grey[2]='a';\n    if (LocaleCompare(target,\"none\") == 0)\n      {\n        image->storage_class=DirectClass;\n        image->alpha_trait=BlendPixelTrait;\n      }\n    status=QueryColorCompliance(target,XPMCompliance,&image->colormap[j],\n      exception);\n    if (status == MagickFalse)\n      break;\n    if (image->depth < image->colormap[j].depth)\n      image->depth=image->colormap[j].depth;\n  }\n  if (j < (ssize_t) image->colors)\n    {\n      xpm_colors=DestroySplayTree(xpm_colors);\n      xpm_buffer=DestroyString(xpm_buffer);\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n  j=0;\n  if (image_info->ping == MagickFalse)\n    {\n      /*\n        Read image pixels.\n      */\n      status=SetImageExtent(image,image->columns,image->rows,exception);\n      if (status == MagickFalse)\n        {\n          xpm_colors=DestroySplayTree(xpm_colors);\n          xpm_buffer=DestroyString(xpm_buffer);\n          return(DestroyImageList(image));\n        }\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        p=NextXPMLine(p);\n        if (p == (char *) NULL)\n          break;\n        r=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (r == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          ssize_t count=CopyXPMColor(key,p,MagickMin(width,MagickPathExtent-1));\n          if (count != (ssize_t) width)\n            break;\n          j=(ssize_t) GetValueFromSplayTree(xpm_colors,key);\n          if (image->storage_class == PseudoClass)\n            SetPixelIndex(image,(Quantum) j,r);\n          SetPixelViaPixelInfo(image,image->colormap+j,r);\n          p+=count;\n          r+=GetPixelChannels(image);\n        }\n        if (x < (ssize_t) image->columns)\n          break;\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n      if (y < (ssize_t) image->rows)\n        {\n          xpm_colors=DestroySplayTree(xpm_colors);\n          xpm_buffer=DestroyString(xpm_buffer);\n          ThrowReaderException(CorruptImageError,\"NotEnoughPixelData\");\n        }\n    }\n  /*\n    Relinquish resources.\n  */\n  xpm_buffer=DestroyString(xpm_buffer);\n  xpm_colors=DestroySplayTree(xpm_colors);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -131,6 +131,7 @@\n     (void *(*)(void *)) NULL);\n   if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n     {\n+      xpm_colors=DestroySplayTree(xpm_colors);\n       xpm_buffer=DestroyString(xpm_buffer);\n       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      xpm_colors=DestroySplayTree(xpm_colors);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-17883",
        "func_name": "ImageMagick/ReadPGXImage",
        "description": "In ImageMagick 7.0.7-12 Q16, a memory leak vulnerability was found in the function ReadPGXImage in coders/pgx.c, which allows attackers to cause a denial of service via a crafted PGX image file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/b0a7241df0f889cc3158ba82774ff21fa1da87ec",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/877",
        "commit_text": "",
        "func_before": "static Image *ReadPGXImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent],\n    endian[MagickPathExtent],\n    sans[MagickPathExtent],\n    sign[MagickPathExtent];\n\n  const unsigned char\n    *pixels;\n\n  Image\n    *image;\n\n  int\n    height,\n    precision,\n    width;\n\n  QuantumInfo\n    *quantum_info;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (ReadBlobString(image,buffer) == (char *) NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  count=(ssize_t) sscanf(buffer,\"PG%[ \\t]%2s%[ \\t+-]%d%[ \\t]%d%[ \\t]%d\",sans,\n    endian,sign,&precision,sans,&width,sans,&height);\n  image->depth=(size_t) precision;\n  if (LocaleCompare(endian,\"ML\") == 0)\n    image->endian=MSBEndian;\n  image->columns=(size_t) width;\n  image->rows=(size_t) height;\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Convert PGX image.\n  */\n  (void) SetImageColorspace(image,GRAYColorspace,exception);\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  length=GetQuantumExtent(image,quantum_info,GrayQuantum);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    pixels=(const unsigned char *) ReadBlobStream(image,length,\n      GetQuantumPixels(quantum_info),&count);\n    if (count != (ssize_t) length)\n      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n    (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n      GrayQuantum,pixels,exception);\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,image->rows) == MagickFalse)\n      break;\n  }\n  SetQuantumImageType(image,GrayQuantum);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadPGXImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent],\n    endian[MagickPathExtent],\n    sans[MagickPathExtent],\n    sign[MagickPathExtent];\n\n  const unsigned char\n    *pixels;\n\n  Image\n    *image;\n\n  int\n    height,\n    precision,\n    width;\n\n  QuantumInfo\n    *quantum_info;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (ReadBlobString(image,buffer) == (char *) NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  count=(ssize_t) sscanf(buffer,\"PG%[ \\t]%2s%[ \\t+-]%d%[ \\t]%d%[ \\t]%d\",sans,\n    endian,sign,&precision,sans,&width,sans,&height);\n  image->depth=(size_t) precision;\n  if (LocaleCompare(endian,\"ML\") == 0)\n    image->endian=MSBEndian;\n  image->columns=(size_t) width;\n  image->rows=(size_t) height;\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Convert PGX image.\n  */\n  (void) SetImageColorspace(image,GRAYColorspace,exception);\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  length=GetQuantumExtent(image,quantum_info,GrayQuantum);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    pixels=(const unsigned char *) ReadBlobStream(image,length,\n      GetQuantumPixels(quantum_info),&count);\n    if (count != (ssize_t) length)\n      break;\n    status=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n      GrayQuantum,pixels,exception);\n    if (status == MagickFalse)\n      break;\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,image->rows) == MagickFalse)\n      break;\n  }\n  SetQuantumImageType(image,GrayQuantum);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -85,9 +85,11 @@\n     pixels=(const unsigned char *) ReadBlobStream(image,length,\n       GetQuantumPixels(quantum_info),&count);\n     if (count != (ssize_t) length)\n-      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n-    (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n+      break;\n+    status=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n       GrayQuantum,pixels,exception);\n+    if (status == MagickFalse)\n+      break;\n     if (SyncAuthenticPixels(image,exception) == MagickFalse)\n       break;\n     if (SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,image->rows) == MagickFalse)",
        "diff_line_info": {
            "deleted_lines": [
                "      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");",
                "    (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,"
            ],
            "added_lines": [
                "      break;",
                "    status=ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,",
                "    if (status == MagickFalse)",
                "      break;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-17885",
        "func_name": "ImageMagick/ReadPICTImage",
        "description": "In ImageMagick 7.0.7-12 Q16, a memory leak vulnerability was found in the function ReadPICTImage in coders/pict.c, which allows attackers to cause a denial of service via a crafted PICT image file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/2ba085736fd49ad89c1937d1ee2b80ae4e11ab97",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/879",
        "commit_text": "",
        "func_before": "static Image *ReadPICTImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    geometry[MagickPathExtent],\n    header_ole[4];\n\n  Image\n    *image;\n\n  int\n    c,\n    code;\n\n  MagickBooleanType\n    jpeg,\n    status;\n\n  PICTRectangle\n    frame;\n\n  PICTPixmap\n    pixmap;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    extent,\n    length;\n\n  ssize_t\n    count,\n    flags,\n    j,\n    version,\n    y;\n\n  StringInfo\n    *profile;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read PICT header.\n  */\n  pixmap.bits_per_pixel=0;\n  pixmap.component_count=0;\n  /*\n    Skip header : 512 for standard PICT and 4, ie \"PICT\" for OLE2.\n  */\n  header_ole[0]=ReadBlobByte(image);\n  header_ole[1]=ReadBlobByte(image);\n  header_ole[2]=ReadBlobByte(image);\n  header_ole[3]=ReadBlobByte(image);\n  if (!((header_ole[0] == 0x50) && (header_ole[1] == 0x49) &&\n      (header_ole[2] == 0x43) && (header_ole[3] == 0x54 )))\n    for (i=0; i < 508; i++)\n      if (ReadBlobByte(image) == EOF)\n        break;\n  (void) ReadBlobMSBShort(image);  /* skip picture size */\n  if (ReadRectangle(image,&frame) == MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  while ((c=ReadBlobByte(image)) == 0) ;\n  if (c != 0x11)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  version=ReadBlobByte(image);\n  if (version == 2)\n    {\n      c=ReadBlobByte(image);\n      if (c != 0xff)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  else\n    if (version != 1)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((frame.left < 0) || (frame.right < 0) || (frame.top < 0) ||\n      (frame.bottom < 0) || (frame.left >= frame.right) ||\n      (frame.top >= frame.bottom))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Create black canvas.\n  */\n  flags=0;\n  image->depth=8;\n  image->columns=1UL*(frame.right-frame.left);\n  image->rows=1UL*(frame.bottom-frame.top);\n  image->resolution.x=DefaultResolution;\n  image->resolution.y=DefaultResolution;\n  image->units=UndefinedResolution;\n  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n    if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Interpret PICT opcodes.\n  */\n  jpeg=MagickFalse;\n  for (code=0; EOFBlob(image) == MagickFalse; )\n  {\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if ((version == 1) || ((TellBlob(image) % 2) != 0))\n      code=ReadBlobByte(image);\n    if (version == 2)\n      code=ReadBlobMSBSignedShort(image);\n    if (code < 0)\n      break;\n    if (code > 0xa1)\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"%04X:\",code);\n      }\n    else\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  %04X %s: %s\",code,codes[code].name,codes[code].description);\n        switch (code)\n        {\n          case 0x01:\n          {\n            /*\n              Clipping rectangle.\n            */\n            length=ReadBlobMSBShort(image);\n            if (length != 0x000a)\n              {\n                for (i=0; i < (ssize_t) (length-2); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n                break;\n              }\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            if (((frame.left & 0x8000) != 0) || ((frame.top & 0x8000) != 0))\n              break;\n            image->columns=1UL*(frame.right-frame.left);\n            image->rows=1UL*(frame.bottom-frame.top);\n            status=SetImageExtent(image,image->columns,image->rows,exception);\n            if (status == MagickFalse)\n              return(DestroyImageList(image));\n            (void) SetImageBackgroundColor(image,exception);\n            break;\n          }\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          {\n            ssize_t\n              pattern;\n\n            size_t\n              height,\n              width;\n\n            /*\n              Skip pattern definition.\n            */\n            pattern=1L*ReadBlobMSBShort(image);\n            for (i=0; i < 8; i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            if (pattern == 2)\n              {\n                for (i=0; i < 5; i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n                break;\n              }\n            if (pattern != 1)\n              ThrowReaderException(CorruptImageError,\"UnknownPatternType\");\n            length=ReadBlobMSBShort(image);\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            if (ReadPixmap(image,&pixmap) == MagickFalse)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            image->depth=1UL*pixmap.component_size;\n            image->resolution.x=1.0*pixmap.horizontal_resolution;\n            image->resolution.y=1.0*pixmap.vertical_resolution;\n            image->units=PixelsPerInchResolution;\n            (void) ReadBlobMSBLong(image);\n            flags=1L*ReadBlobMSBShort(image);\n            length=ReadBlobMSBShort(image);\n            for (i=0; i <= (ssize_t) length; i++)\n              (void) ReadBlobMSBLong(image);\n            width=1UL*(frame.bottom-frame.top);\n            height=1UL*(frame.right-frame.left);\n            if (pixmap.bits_per_pixel <= 8)\n              length&=0x7fff;\n            if (pixmap.bits_per_pixel == 16)\n              width<<=1;\n            if (length == 0)\n              length=width;\n            if (length < 8)\n              {\n                for (i=0; i < (ssize_t) (length*height); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n              }\n            else\n              for (i=0; i < (int) height; i++)\n                if (length > 200)\n                  {\n                    for (j=0; j < (ssize_t) ReadBlobMSBShort(image); j++)\n                      if (ReadBlobByte(image) == EOF)\n                        break;\n                  }\n                else\n                  for (j=0; j < (ssize_t) ReadBlobByte(image); j++)\n                    if (ReadBlobByte(image) == EOF)\n                      break;\n            break;\n          }\n          case 0x1b:\n          {\n            /*\n              Initialize image background color.\n            */\n            image->background_color.red=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            image->background_color.green=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            image->background_color.blue=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            break;\n          }\n          case 0x70:\n          case 0x71:\n          case 0x72:\n          case 0x73:\n          case 0x74:\n          case 0x75:\n          case 0x76:\n          case 0x77:\n          {\n            /*\n              Skip polygon or region.\n            */\n            length=ReadBlobMSBShort(image);\n            for (i=0; i < (ssize_t) (length-2); i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            break;\n          }\n          case 0x90:\n          case 0x91:\n          case 0x98:\n          case 0x99:\n          case 0x9a:\n          case 0x9b:\n          {\n            Image\n              *tile_image;\n\n            PICTRectangle\n              source,\n              destination;\n\n            register unsigned char\n              *p;\n\n            size_t\n              j;\n\n            ssize_t\n              bytes_per_line;\n\n            unsigned char\n              *pixels;\n\n            /*\n              Pixmap clipped by a rectangle.\n            */\n            bytes_per_line=0;\n            if ((code != 0x9a) && (code != 0x9b))\n              bytes_per_line=1L*ReadBlobMSBShort(image);\n            else\n              {\n                (void) ReadBlobMSBShort(image);\n                (void) ReadBlobMSBShort(image);\n                (void) ReadBlobMSBShort(image);\n              }\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            /*\n              Initialize tile image.\n            */\n            tile_image=CloneImage(image,1UL*(frame.right-frame.left),\n              1UL*(frame.bottom-frame.top),MagickTrue,exception);\n            if (tile_image == (Image *) NULL)\n              return((Image *) NULL);\n            if ((code == 0x9a) || (code == 0x9b) ||\n                ((bytes_per_line & 0x8000) != 0))\n              {\n                if (ReadPixmap(image,&pixmap) == MagickFalse)\n                  {\n                    tile_image=DestroyImage(tile_image);\n                    ThrowReaderException(CorruptImageError,\n                      \"ImproperImageHeader\");\n                  }\n                tile_image->depth=1UL*pixmap.component_size;\n                tile_image->alpha_trait=pixmap.component_count == 4 ?\n                  BlendPixelTrait : UndefinedPixelTrait;\n                tile_image->resolution.x=(double) pixmap.horizontal_resolution;\n                tile_image->resolution.y=(double) pixmap.vertical_resolution;\n                tile_image->units=PixelsPerInchResolution;\n                if (tile_image->alpha_trait != UndefinedPixelTrait)\n                  image->alpha_trait=tile_image->alpha_trait;\n              }\n            if ((code != 0x9a) && (code != 0x9b))\n              {\n                /*\n                  Initialize colormap.\n                */\n                tile_image->colors=2;\n                if ((bytes_per_line & 0x8000) != 0)\n                  {\n                    (void) ReadBlobMSBLong(image);\n                    flags=1L*ReadBlobMSBShort(image);\n                    tile_image->colors=1UL*ReadBlobMSBShort(image)+1;\n                  }\n                status=AcquireImageColormap(tile_image,tile_image->colors,\n                  exception);\n                if (status == MagickFalse)\n                  {\n                    tile_image=DestroyImage(tile_image);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                if ((bytes_per_line & 0x8000) != 0)\n                  {\n                    for (i=0; i < (ssize_t) tile_image->colors; i++)\n                    {\n                      j=ReadBlobMSBShort(image) % tile_image->colors;\n                      if ((flags & 0x8000) != 0)\n                        j=(size_t) i;\n                      tile_image->colormap[j].red=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                      tile_image->colormap[j].green=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                      tile_image->colormap[j].blue=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                    }\n                  }\n                else\n                  {\n                    for (i=0; i < (ssize_t) tile_image->colors; i++)\n                    {\n                      tile_image->colormap[i].red=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].red);\n                      tile_image->colormap[i].green=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].green);\n                      tile_image->colormap[i].blue=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].blue);\n                    }\n                  }\n              }\n            if (ReadRectangle(image,&source) == MagickFalse)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              }\n            if (ReadRectangle(image,&destination) == MagickFalse)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              }\n            (void) ReadBlobMSBShort(image);\n            if ((code == 0x91) || (code == 0x99) || (code == 0x9b))\n              {\n                /*\n                  Skip region.\n                */\n                length=ReadBlobMSBShort(image);\n                for (i=0; i < (ssize_t) (length-2); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n              }\n            if ((code != 0x9a) && (code != 0x9b) &&\n                (bytes_per_line & 0x8000) == 0)\n              pixels=DecodeImage(image,tile_image,1UL*bytes_per_line,1,&extent,\n                exception);\n            else\n              pixels=DecodeImage(image,tile_image,1UL*bytes_per_line,1U*\n                pixmap.bits_per_pixel,&extent,exception);\n            if (pixels == (unsigned char *) NULL)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n            /*\n              Convert PICT tile image to pixel packets.\n            */\n            p=pixels;\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              if (p > (pixels+extent+image->columns))\n                {\n                  tile_image=DestroyImage(tile_image);\n                  ThrowReaderException(CorruptImageError,\"NotEnoughPixelData\");\n                }\n              q=QueueAuthenticPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                if (tile_image->storage_class == PseudoClass)\n                  {\n                    index=ConstrainColormapIndex(tile_image,*p,exception);\n                    SetPixelIndex(tile_image,index,q);\n                    SetPixelRed(tile_image,\n                      tile_image->colormap[(ssize_t) index].red,q);\n                    SetPixelGreen(tile_image,\n                      tile_image->colormap[(ssize_t) index].green,q);\n                    SetPixelBlue(tile_image,\n                      tile_image->colormap[(ssize_t) index].blue,q);\n                  }\n                else\n                  {\n                    if (pixmap.bits_per_pixel == 16)\n                      {\n                        i=(*p++);\n                        j=(*p);\n                        SetPixelRed(tile_image,ScaleCharToQuantum(\n                          (unsigned char) ((i & 0x7c) << 1)),q);\n                        SetPixelGreen(tile_image,ScaleCharToQuantum(\n                          (unsigned char) (((i & 0x03) << 6) |\n                          ((j & 0xe0) >> 2))),q);\n                        SetPixelBlue(tile_image,ScaleCharToQuantum(\n                          (unsigned char) ((j & 0x1f) << 3)),q);\n                      }\n                    else\n                      if (tile_image->alpha_trait == UndefinedPixelTrait)\n                        {\n                          if (p > (pixels+extent+2*image->columns))\n                            {\n                              tile_image=DestroyImage(tile_image);\n                              ThrowReaderException(CorruptImageError,\n                                \"NotEnoughPixelData\");\n                            }\n                          SetPixelRed(tile_image,ScaleCharToQuantum(*p),q);\n                          SetPixelGreen(tile_image,ScaleCharToQuantum(\n                            *(p+tile_image->columns)),q);\n                          SetPixelBlue(tile_image,ScaleCharToQuantum(\n                            *(p+2*tile_image->columns)),q);\n                        }\n                      else\n                        {\n                          if (p > (pixels+extent+3*image->columns))\n                            {\n                              tile_image=DestroyImage(tile_image);\n                              ThrowReaderException(CorruptImageError,\n                                \"NotEnoughPixelData\");\n                            }\n                          SetPixelAlpha(tile_image,ScaleCharToQuantum(*p),q);\n                          SetPixelRed(tile_image,ScaleCharToQuantum(\n                            *(p+tile_image->columns)),q);\n                          SetPixelGreen(tile_image,ScaleCharToQuantum(\n                            *(p+2*tile_image->columns)),q);\n                          SetPixelBlue(tile_image,ScaleCharToQuantum(\n                            *(p+3*tile_image->columns)),q);\n                        }\n                  }\n                p++;\n                q+=GetPixelChannels(tile_image);\n              }\n              if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n                break;\n              if ((tile_image->storage_class == DirectClass) &&\n                  (pixmap.bits_per_pixel != 16))\n                {\n                  p+=(pixmap.component_count-1)*tile_image->columns;\n                  if (p < pixels)\n                    break;\n                }\n              status=SetImageProgress(image,LoadImageTag,y,tile_image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            if (jpeg == MagickFalse)\n              if ((code == 0x9a) || (code == 0x9b) ||\n                  ((bytes_per_line & 0x8000) != 0))\n                (void) CompositeImage(image,tile_image,CopyCompositeOp,\n                  MagickTrue,destination.left,destination.top,exception);\n            tile_image=DestroyImage(tile_image);\n            break;\n          }\n          case 0xa1:\n          {\n            unsigned char\n              *info;\n\n            size_t\n              type;\n\n            /*\n              Comment.\n            */\n            type=ReadBlobMSBShort(image);\n            length=ReadBlobMSBShort(image);\n            if (length == 0)\n              break;\n            (void) ReadBlobMSBLong(image);\n            length-=MagickMin(length,4);\n            if (length == 0)\n              break;\n            info=(unsigned char *) AcquireQuantumMemory(length,sizeof(*info));\n            if (info == (unsigned char *) NULL)\n              break;\n            count=ReadBlob(image,length,info);\n            if (count != (ssize_t) length)\n              {\n                info=(unsigned char *) RelinquishMagickMemory(info);\n                ThrowReaderException(ResourceLimitError,\n                  \"UnableToReadImageData\");\n              }\n            switch (type)\n            {\n              case 0xe0:\n              {\n                profile=BlobToStringInfo((const void *) NULL,length);\n                SetStringInfoDatum(profile,info);\n                status=SetImageProfile(image,\"icc\",profile,exception);\n                profile=DestroyStringInfo(profile);\n                if (status == MagickFalse)\n                  {\n                    info=(unsigned char *) RelinquishMagickMemory(info);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                break;\n              }\n              case 0x1f2:\n              {\n                profile=BlobToStringInfo((const void *) NULL,length);\n                SetStringInfoDatum(profile,info);\n                status=SetImageProfile(image,\"iptc\",profile,exception);\n                if (status == MagickFalse)\n                  {\n                    info=(unsigned char *) RelinquishMagickMemory(info);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                profile=DestroyStringInfo(profile);\n                break;\n              }\n              default:\n                break;\n            }\n            info=(unsigned char *) RelinquishMagickMemory(info);\n            break;\n          }\n          default:\n          {\n            /*\n              Skip to next op code.\n            */\n            if (codes[code].length == -1)\n              (void) ReadBlobMSBShort(image);\n            else\n              for (i=0; i < (ssize_t) codes[code].length; i++)\n                if (ReadBlobByte(image) == EOF)\n                  break;\n          }\n        }\n      }\n    if (code == 0xc00)\n      {\n        /*\n          Skip header.\n        */\n        for (i=0; i < 24; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n    if (((code >= 0xb0) && (code <= 0xcf)) ||\n        ((code >= 0x8000) && (code <= 0x80ff)))\n      continue;\n    if (code == 0x8200)\n      {\n        FILE\n          *file;\n\n        Image\n          *tile_image;\n\n        ImageInfo\n          *read_info;\n\n        int\n          unique_file;\n\n        /*\n          Embedded JPEG.\n        */\n        jpeg=MagickTrue;\n        read_info=CloneImageInfo(image_info);\n        SetImageInfoBlob(read_info,(void *) NULL,0);\n        file=(FILE *) NULL;\n        unique_file=AcquireUniqueFileResource(read_info->filename);\n        if (unique_file != -1)\n          file=fdopen(unique_file,\"wb\");\n        if ((unique_file == -1) || (file == (FILE *) NULL))\n          {\n            (void) RelinquishUniqueFileResource(read_info->filename);\n            (void) CopyMagickString(image->filename,read_info->filename,\n              MagickPathExtent);\n            ThrowFileException(exception,FileOpenError,\n              \"UnableToCreateTemporaryFile\",image->filename);\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        length=ReadBlobMSBLong(image);\n        if (length > 154)\n          {\n            for (i=0; i < 6; i++)\n              (void) ReadBlobMSBLong(image);\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              {\n                (void) fclose(file);\n                (void) RelinquishUniqueFileResource(read_info->filename);\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              }\n            for (i=0; i < 122; i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            for (i=0; i < (ssize_t) (length-154); i++)\n            {\n              c=ReadBlobByte(image);\n              if (c == EOF)\n                break;\n              (void) fputc(c,file);\n            }\n          }\n        (void) fclose(file);\n        (void) close(unique_file);\n        tile_image=ReadImage(read_info,exception);\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        read_info=DestroyImageInfo(read_info);\n        if (tile_image == (Image *) NULL)\n          continue;\n        (void) FormatLocaleString(geometry,MagickPathExtent,\"%.20gx%.20g\",\n          (double) MagickMax(image->columns,tile_image->columns),\n          (double) MagickMax(image->rows,tile_image->rows));\n        (void) SetImageExtent(image,\n          MagickMax(image->columns,tile_image->columns),\n          MagickMax(image->rows,tile_image->rows),exception);\n        (void) TransformImageColorspace(image,tile_image->colorspace,exception);\n        (void) CompositeImage(image,tile_image,CopyCompositeOp,MagickTrue,\n          frame.left,frame.right,exception);\n        image->compression=tile_image->compression;\n        tile_image=DestroyImage(tile_image);\n        continue;\n      }\n    if ((code == 0xff) || (code == 0xffff))\n      break;\n    if (((code >= 0xd0) && (code <= 0xfe)) ||\n        ((code >= 0x8100) && (code <= 0xffff)))\n      {\n        /*\n          Skip reserved.\n        */\n        length=ReadBlobMSBShort(image);\n        for (i=0; i < (ssize_t) length; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n    if ((code >= 0x100) && (code <= 0x7fff))\n      {\n        /*\n          Skip reserved.\n        */\n        length=(size_t) ((code >> 7) & 0xff);\n        for (i=0; i < (ssize_t) length; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadPICTImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    geometry[MagickPathExtent],\n    header_ole[4];\n\n  Image\n    *image;\n\n  int\n    c,\n    code;\n\n  MagickBooleanType\n    jpeg,\n    status;\n\n  PICTRectangle\n    frame;\n\n  PICTPixmap\n    pixmap;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    extent,\n    length;\n\n  ssize_t\n    count,\n    flags,\n    j,\n    version,\n    y;\n\n  StringInfo\n    *profile;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read PICT header.\n  */\n  pixmap.bits_per_pixel=0;\n  pixmap.component_count=0;\n  /*\n    Skip header : 512 for standard PICT and 4, ie \"PICT\" for OLE2.\n  */\n  header_ole[0]=ReadBlobByte(image);\n  header_ole[1]=ReadBlobByte(image);\n  header_ole[2]=ReadBlobByte(image);\n  header_ole[3]=ReadBlobByte(image);\n  if (!((header_ole[0] == 0x50) && (header_ole[1] == 0x49) &&\n      (header_ole[2] == 0x43) && (header_ole[3] == 0x54 )))\n    for (i=0; i < 508; i++)\n      if (ReadBlobByte(image) == EOF)\n        break;\n  (void) ReadBlobMSBShort(image);  /* skip picture size */\n  if (ReadRectangle(image,&frame) == MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  while ((c=ReadBlobByte(image)) == 0) ;\n  if (c != 0x11)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  version=ReadBlobByte(image);\n  if (version == 2)\n    {\n      c=ReadBlobByte(image);\n      if (c != 0xff)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  else\n    if (version != 1)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((frame.left < 0) || (frame.right < 0) || (frame.top < 0) ||\n      (frame.bottom < 0) || (frame.left >= frame.right) ||\n      (frame.top >= frame.bottom))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Create black canvas.\n  */\n  flags=0;\n  image->depth=8;\n  image->columns=1UL*(frame.right-frame.left);\n  image->rows=1UL*(frame.bottom-frame.top);\n  image->resolution.x=DefaultResolution;\n  image->resolution.y=DefaultResolution;\n  image->units=UndefinedResolution;\n  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n    if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Interpret PICT opcodes.\n  */\n  jpeg=MagickFalse;\n  for (code=0; EOFBlob(image) == MagickFalse; )\n  {\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if ((version == 1) || ((TellBlob(image) % 2) != 0))\n      code=ReadBlobByte(image);\n    if (version == 2)\n      code=ReadBlobMSBSignedShort(image);\n    if (code < 0)\n      break;\n    if (code > 0xa1)\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"%04X:\",code);\n      }\n    else\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  %04X %s: %s\",code,codes[code].name,codes[code].description);\n        switch (code)\n        {\n          case 0x01:\n          {\n            /*\n              Clipping rectangle.\n            */\n            length=ReadBlobMSBShort(image);\n            if (length != 0x000a)\n              {\n                for (i=0; i < (ssize_t) (length-2); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n                break;\n              }\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            if (((frame.left & 0x8000) != 0) || ((frame.top & 0x8000) != 0))\n              break;\n            image->columns=1UL*(frame.right-frame.left);\n            image->rows=1UL*(frame.bottom-frame.top);\n            status=SetImageExtent(image,image->columns,image->rows,exception);\n            if (status == MagickFalse)\n              return(DestroyImageList(image));\n            (void) SetImageBackgroundColor(image,exception);\n            break;\n          }\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          {\n            ssize_t\n              pattern;\n\n            size_t\n              height,\n              width;\n\n            /*\n              Skip pattern definition.\n            */\n            pattern=1L*ReadBlobMSBShort(image);\n            for (i=0; i < 8; i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            if (pattern == 2)\n              {\n                for (i=0; i < 5; i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n                break;\n              }\n            if (pattern != 1)\n              ThrowReaderException(CorruptImageError,\"UnknownPatternType\");\n            length=ReadBlobMSBShort(image);\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            if (ReadPixmap(image,&pixmap) == MagickFalse)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            image->depth=1UL*pixmap.component_size;\n            image->resolution.x=1.0*pixmap.horizontal_resolution;\n            image->resolution.y=1.0*pixmap.vertical_resolution;\n            image->units=PixelsPerInchResolution;\n            (void) ReadBlobMSBLong(image);\n            flags=1L*ReadBlobMSBShort(image);\n            length=ReadBlobMSBShort(image);\n            for (i=0; i <= (ssize_t) length; i++)\n              (void) ReadBlobMSBLong(image);\n            width=1UL*(frame.bottom-frame.top);\n            height=1UL*(frame.right-frame.left);\n            if (pixmap.bits_per_pixel <= 8)\n              length&=0x7fff;\n            if (pixmap.bits_per_pixel == 16)\n              width<<=1;\n            if (length == 0)\n              length=width;\n            if (length < 8)\n              {\n                for (i=0; i < (ssize_t) (length*height); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n              }\n            else\n              for (i=0; i < (int) height; i++)\n                if (length > 200)\n                  {\n                    for (j=0; j < (ssize_t) ReadBlobMSBShort(image); j++)\n                      if (ReadBlobByte(image) == EOF)\n                        break;\n                  }\n                else\n                  for (j=0; j < (ssize_t) ReadBlobByte(image); j++)\n                    if (ReadBlobByte(image) == EOF)\n                      break;\n            break;\n          }\n          case 0x1b:\n          {\n            /*\n              Initialize image background color.\n            */\n            image->background_color.red=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            image->background_color.green=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            image->background_color.blue=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            break;\n          }\n          case 0x70:\n          case 0x71:\n          case 0x72:\n          case 0x73:\n          case 0x74:\n          case 0x75:\n          case 0x76:\n          case 0x77:\n          {\n            /*\n              Skip polygon or region.\n            */\n            length=ReadBlobMSBShort(image);\n            for (i=0; i < (ssize_t) (length-2); i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            break;\n          }\n          case 0x90:\n          case 0x91:\n          case 0x98:\n          case 0x99:\n          case 0x9a:\n          case 0x9b:\n          {\n            Image\n              *tile_image;\n\n            PICTRectangle\n              source,\n              destination;\n\n            register unsigned char\n              *p;\n\n            size_t\n              j;\n\n            ssize_t\n              bytes_per_line;\n\n            unsigned char\n              *pixels;\n\n            /*\n              Pixmap clipped by a rectangle.\n            */\n            bytes_per_line=0;\n            if ((code != 0x9a) && (code != 0x9b))\n              bytes_per_line=1L*ReadBlobMSBShort(image);\n            else\n              {\n                (void) ReadBlobMSBShort(image);\n                (void) ReadBlobMSBShort(image);\n                (void) ReadBlobMSBShort(image);\n              }\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            /*\n              Initialize tile image.\n            */\n            tile_image=CloneImage(image,1UL*(frame.right-frame.left),\n              1UL*(frame.bottom-frame.top),MagickTrue,exception);\n            if (tile_image == (Image *) NULL)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            if ((code == 0x9a) || (code == 0x9b) ||\n                ((bytes_per_line & 0x8000) != 0))\n              {\n                if (ReadPixmap(image,&pixmap) == MagickFalse)\n                  {\n                    tile_image=DestroyImage(tile_image);\n                    ThrowReaderException(CorruptImageError,\n                      \"ImproperImageHeader\");\n                  }\n                tile_image->depth=1UL*pixmap.component_size;\n                tile_image->alpha_trait=pixmap.component_count == 4 ?\n                  BlendPixelTrait : UndefinedPixelTrait;\n                tile_image->resolution.x=(double) pixmap.horizontal_resolution;\n                tile_image->resolution.y=(double) pixmap.vertical_resolution;\n                tile_image->units=PixelsPerInchResolution;\n                if (tile_image->alpha_trait != UndefinedPixelTrait)\n                  image->alpha_trait=tile_image->alpha_trait;\n              }\n            if ((code != 0x9a) && (code != 0x9b))\n              {\n                /*\n                  Initialize colormap.\n                */\n                tile_image->colors=2;\n                if ((bytes_per_line & 0x8000) != 0)\n                  {\n                    (void) ReadBlobMSBLong(image);\n                    flags=1L*ReadBlobMSBShort(image);\n                    tile_image->colors=1UL*ReadBlobMSBShort(image)+1;\n                  }\n                status=AcquireImageColormap(tile_image,tile_image->colors,\n                  exception);\n                if (status == MagickFalse)\n                  {\n                    tile_image=DestroyImage(tile_image);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                if ((bytes_per_line & 0x8000) != 0)\n                  {\n                    for (i=0; i < (ssize_t) tile_image->colors; i++)\n                    {\n                      j=ReadBlobMSBShort(image) % tile_image->colors;\n                      if ((flags & 0x8000) != 0)\n                        j=(size_t) i;\n                      tile_image->colormap[j].red=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                      tile_image->colormap[j].green=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                      tile_image->colormap[j].blue=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                    }\n                  }\n                else\n                  {\n                    for (i=0; i < (ssize_t) tile_image->colors; i++)\n                    {\n                      tile_image->colormap[i].red=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].red);\n                      tile_image->colormap[i].green=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].green);\n                      tile_image->colormap[i].blue=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].blue);\n                    }\n                  }\n              }\n            if (ReadRectangle(image,&source) == MagickFalse)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              }\n            if (ReadRectangle(image,&destination) == MagickFalse)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              }\n            (void) ReadBlobMSBShort(image);\n            if ((code == 0x91) || (code == 0x99) || (code == 0x9b))\n              {\n                /*\n                  Skip region.\n                */\n                length=ReadBlobMSBShort(image);\n                for (i=0; i < (ssize_t) (length-2); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n              }\n            if ((code != 0x9a) && (code != 0x9b) &&\n                (bytes_per_line & 0x8000) == 0)\n              pixels=DecodeImage(image,tile_image,1UL*bytes_per_line,1,&extent,\n                exception);\n            else\n              pixels=DecodeImage(image,tile_image,1UL*bytes_per_line,1U*\n                pixmap.bits_per_pixel,&extent,exception);\n            if (pixels == (unsigned char *) NULL)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n            /*\n              Convert PICT tile image to pixel packets.\n            */\n            p=pixels;\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              if (p > (pixels+extent+image->columns))\n                {\n                  tile_image=DestroyImage(tile_image);\n                  ThrowReaderException(CorruptImageError,\"NotEnoughPixelData\");\n                }\n              q=QueueAuthenticPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                if (tile_image->storage_class == PseudoClass)\n                  {\n                    index=ConstrainColormapIndex(tile_image,*p,exception);\n                    SetPixelIndex(tile_image,index,q);\n                    SetPixelRed(tile_image,\n                      tile_image->colormap[(ssize_t) index].red,q);\n                    SetPixelGreen(tile_image,\n                      tile_image->colormap[(ssize_t) index].green,q);\n                    SetPixelBlue(tile_image,\n                      tile_image->colormap[(ssize_t) index].blue,q);\n                  }\n                else\n                  {\n                    if (pixmap.bits_per_pixel == 16)\n                      {\n                        i=(*p++);\n                        j=(*p);\n                        SetPixelRed(tile_image,ScaleCharToQuantum(\n                          (unsigned char) ((i & 0x7c) << 1)),q);\n                        SetPixelGreen(tile_image,ScaleCharToQuantum(\n                          (unsigned char) (((i & 0x03) << 6) |\n                          ((j & 0xe0) >> 2))),q);\n                        SetPixelBlue(tile_image,ScaleCharToQuantum(\n                          (unsigned char) ((j & 0x1f) << 3)),q);\n                      }\n                    else\n                      if (tile_image->alpha_trait == UndefinedPixelTrait)\n                        {\n                          if (p > (pixels+extent+2*image->columns))\n                            {\n                              tile_image=DestroyImage(tile_image);\n                              ThrowReaderException(CorruptImageError,\n                                \"NotEnoughPixelData\");\n                            }\n                          SetPixelRed(tile_image,ScaleCharToQuantum(*p),q);\n                          SetPixelGreen(tile_image,ScaleCharToQuantum(\n                            *(p+tile_image->columns)),q);\n                          SetPixelBlue(tile_image,ScaleCharToQuantum(\n                            *(p+2*tile_image->columns)),q);\n                        }\n                      else\n                        {\n                          if (p > (pixels+extent+3*image->columns))\n                            {\n                              tile_image=DestroyImage(tile_image);\n                              ThrowReaderException(CorruptImageError,\n                                \"NotEnoughPixelData\");\n                            }\n                          SetPixelAlpha(tile_image,ScaleCharToQuantum(*p),q);\n                          SetPixelRed(tile_image,ScaleCharToQuantum(\n                            *(p+tile_image->columns)),q);\n                          SetPixelGreen(tile_image,ScaleCharToQuantum(\n                            *(p+2*tile_image->columns)),q);\n                          SetPixelBlue(tile_image,ScaleCharToQuantum(\n                            *(p+3*tile_image->columns)),q);\n                        }\n                  }\n                p++;\n                q+=GetPixelChannels(tile_image);\n              }\n              if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n                break;\n              if ((tile_image->storage_class == DirectClass) &&\n                  (pixmap.bits_per_pixel != 16))\n                {\n                  p+=(pixmap.component_count-1)*tile_image->columns;\n                  if (p < pixels)\n                    break;\n                }\n              status=SetImageProgress(image,LoadImageTag,y,tile_image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            if (jpeg == MagickFalse)\n              if ((code == 0x9a) || (code == 0x9b) ||\n                  ((bytes_per_line & 0x8000) != 0))\n                (void) CompositeImage(image,tile_image,CopyCompositeOp,\n                  MagickTrue,destination.left,destination.top,exception);\n            tile_image=DestroyImage(tile_image);\n            break;\n          }\n          case 0xa1:\n          {\n            unsigned char\n              *info;\n\n            size_t\n              type;\n\n            /*\n              Comment.\n            */\n            type=ReadBlobMSBShort(image);\n            length=ReadBlobMSBShort(image);\n            if (length == 0)\n              break;\n            (void) ReadBlobMSBLong(image);\n            length-=MagickMin(length,4);\n            if (length == 0)\n              break;\n            info=(unsigned char *) AcquireQuantumMemory(length,sizeof(*info));\n            if (info == (unsigned char *) NULL)\n              break;\n            count=ReadBlob(image,length,info);\n            if (count != (ssize_t) length)\n              {\n                info=(unsigned char *) RelinquishMagickMemory(info);\n                ThrowReaderException(ResourceLimitError,\n                  \"UnableToReadImageData\");\n              }\n            switch (type)\n            {\n              case 0xe0:\n              {\n                profile=BlobToStringInfo((const void *) NULL,length);\n                SetStringInfoDatum(profile,info);\n                status=SetImageProfile(image,\"icc\",profile,exception);\n                profile=DestroyStringInfo(profile);\n                if (status == MagickFalse)\n                  {\n                    info=(unsigned char *) RelinquishMagickMemory(info);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                break;\n              }\n              case 0x1f2:\n              {\n                profile=BlobToStringInfo((const void *) NULL,length);\n                SetStringInfoDatum(profile,info);\n                status=SetImageProfile(image,\"iptc\",profile,exception);\n                if (status == MagickFalse)\n                  {\n                    info=(unsigned char *) RelinquishMagickMemory(info);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                profile=DestroyStringInfo(profile);\n                break;\n              }\n              default:\n                break;\n            }\n            info=(unsigned char *) RelinquishMagickMemory(info);\n            break;\n          }\n          default:\n          {\n            /*\n              Skip to next op code.\n            */\n            if (codes[code].length == -1)\n              (void) ReadBlobMSBShort(image);\n            else\n              for (i=0; i < (ssize_t) codes[code].length; i++)\n                if (ReadBlobByte(image) == EOF)\n                  break;\n          }\n        }\n      }\n    if (code == 0xc00)\n      {\n        /*\n          Skip header.\n        */\n        for (i=0; i < 24; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n    if (((code >= 0xb0) && (code <= 0xcf)) ||\n        ((code >= 0x8000) && (code <= 0x80ff)))\n      continue;\n    if (code == 0x8200)\n      {\n        FILE\n          *file;\n\n        Image\n          *tile_image;\n\n        ImageInfo\n          *read_info;\n\n        int\n          unique_file;\n\n        /*\n          Embedded JPEG.\n        */\n        jpeg=MagickTrue;\n        read_info=CloneImageInfo(image_info);\n        SetImageInfoBlob(read_info,(void *) NULL,0);\n        file=(FILE *) NULL;\n        unique_file=AcquireUniqueFileResource(read_info->filename);\n        if (unique_file != -1)\n          file=fdopen(unique_file,\"wb\");\n        if ((unique_file == -1) || (file == (FILE *) NULL))\n          {\n            (void) RelinquishUniqueFileResource(read_info->filename);\n            (void) CopyMagickString(image->filename,read_info->filename,\n              MagickPathExtent);\n            ThrowFileException(exception,FileOpenError,\n              \"UnableToCreateTemporaryFile\",image->filename);\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        length=ReadBlobMSBLong(image);\n        if (length > 154)\n          {\n            for (i=0; i < 6; i++)\n              (void) ReadBlobMSBLong(image);\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              {\n                (void) fclose(file);\n                (void) RelinquishUniqueFileResource(read_info->filename);\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              }\n            for (i=0; i < 122; i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            for (i=0; i < (ssize_t) (length-154); i++)\n            {\n              c=ReadBlobByte(image);\n              if (c == EOF)\n                break;\n              (void) fputc(c,file);\n            }\n          }\n        (void) fclose(file);\n        (void) close(unique_file);\n        tile_image=ReadImage(read_info,exception);\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        read_info=DestroyImageInfo(read_info);\n        if (tile_image == (Image *) NULL)\n          continue;\n        (void) FormatLocaleString(geometry,MagickPathExtent,\"%.20gx%.20g\",\n          (double) MagickMax(image->columns,tile_image->columns),\n          (double) MagickMax(image->rows,tile_image->rows));\n        (void) SetImageExtent(image,\n          MagickMax(image->columns,tile_image->columns),\n          MagickMax(image->rows,tile_image->rows),exception);\n        (void) TransformImageColorspace(image,tile_image->colorspace,exception);\n        (void) CompositeImage(image,tile_image,CopyCompositeOp,MagickTrue,\n          frame.left,frame.right,exception);\n        image->compression=tile_image->compression;\n        tile_image=DestroyImage(tile_image);\n        continue;\n      }\n    if ((code == 0xff) || (code == 0xffff))\n      break;\n    if (((code >= 0xd0) && (code <= 0xfe)) ||\n        ((code >= 0x8100) && (code <= 0xffff)))\n      {\n        /*\n          Skip reserved.\n        */\n        length=ReadBlobMSBShort(image);\n        for (i=0; i < (ssize_t) length; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n    if ((code >= 0x100) && (code <= 0x7fff))\n      {\n        /*\n          Skip reserved.\n        */\n        length=(size_t) ((code >> 7) & 0xff);\n        for (i=0; i < (ssize_t) length; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -317,7 +317,7 @@\n             tile_image=CloneImage(image,1UL*(frame.right-frame.left),\n               1UL*(frame.bottom-frame.top),MagickTrue,exception);\n             if (tile_image == (Image *) NULL)\n-              return((Image *) NULL);\n+              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n             if ((code == 0x9a) || (code == 0x9b) ||\n                 ((bytes_per_line & 0x8000) != 0))\n               {",
        "diff_line_info": {
            "deleted_lines": [
                "              return((Image *) NULL);"
            ],
            "added_lines": [
                "              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-17886",
        "func_name": "ImageMagick/ReadPSDChannelZip",
        "description": "In ImageMagick 7.0.7-12 Q16, a memory leak vulnerability was found in the function ReadPSDChannelZip in coders/psd.c, which allows attackers to cause a denial of service via a crafted psd image file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/8204599ef0e85324876459e5d45db00660920482",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/874",
        "commit_text": "",
        "func_before": "static MagickBooleanType ReadPSDChannelZip(Image *image,const size_t channels,\n  const ssize_t type,const PSDCompressionType compression,\n  const size_t compact_size,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  register unsigned char\n    *p;\n\n  size_t\n    count,\n    length,\n    packet_size,\n    row_size;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *compact_pixels,\n    *pixels;\n\n  z_stream\n    stream;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is ZIP compressed\");\n\n  compact_pixels=(unsigned char *) AcquireQuantumMemory(compact_size,\n    sizeof(*compact_pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n\n  packet_size=GetPSDPacketSize(image);\n  row_size=image->columns*packet_size;\n  count=image->rows*row_size;\n\n  pixels=(unsigned char *) AcquireQuantumMemory(count,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    {\n      compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  if (ReadBlob(image,compact_size,compact_pixels) != (ssize_t) compact_size)\n    {\n      compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n      ThrowBinaryException(CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n    }\n\n  ResetMagickMemory(&stream,0,sizeof(stream));\n  stream.data_type=Z_BINARY;\n  stream.next_in=(Bytef *)compact_pixels;\n  stream.avail_in=(uInt) compact_size;\n  stream.next_out=(Bytef *)pixels;\n  stream.avail_out=(uInt) count;\n\n  if (inflateInit(&stream) == Z_OK)\n    {\n      int\n        ret;\n\n      while (stream.avail_out > 0)\n      {\n        ret=inflate(&stream,Z_SYNC_FLUSH);\n        if ((ret != Z_OK) && (ret != Z_STREAM_END))\n          break;\n        if (ret == Z_STREAM_END)\n          {\n            (void) inflateEnd(&stream);\n            compact_pixels=(unsigned char *) RelinquishMagickMemory(\n              compact_pixels);\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            return(MagickFalse);\n          }\n      }\n      (void) inflateEnd(&stream);\n    }\n\n  if (compression == ZipWithPrediction)\n  {\n     p=pixels;\n     while (count > 0)\n     {\n       length=image->columns;\n       while (--length)\n       {\n         if (packet_size == 2)\n           {\n             p[2]+=p[0]+((p[1]+p[3]) >> 8);\n             p[3]+=p[1];\n           }\n         else\n          *(p+1)+=*p;\n         p+=packet_size;\n       }\n       p+=packet_size;\n       count-=row_size;\n     }\n  }\n\n  status=MagickTrue;\n  p=pixels;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=ReadPSDChannelPixels(image,channels,y,type,p,exception);\n    if (status == MagickFalse)\n      break;\n\n    p+=row_size;\n  }\n\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}",
        "func": "static MagickBooleanType ReadPSDChannelZip(Image *image,const size_t channels,\n  const ssize_t type,const PSDCompressionType compression,\n  const size_t compact_size,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  register unsigned char\n    *p;\n\n  size_t\n    count,\n    length,\n    packet_size,\n    row_size;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *compact_pixels,\n    *pixels;\n\n  z_stream\n    stream;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is ZIP compressed\");\n\n  compact_pixels=(unsigned char *) AcquireQuantumMemory(compact_size,\n    sizeof(*compact_pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n\n  packet_size=GetPSDPacketSize(image);\n  row_size=image->columns*packet_size;\n  count=image->rows*row_size;\n\n  pixels=(unsigned char *) AcquireQuantumMemory(count,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    {\n      compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  if (ReadBlob(image,compact_size,compact_pixels) != (ssize_t) compact_size)\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n      ThrowBinaryException(CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n    }\n\n  ResetMagickMemory(&stream,0,sizeof(stream));\n  stream.data_type=Z_BINARY;\n  stream.next_in=(Bytef *)compact_pixels;\n  stream.avail_in=(uInt) compact_size;\n  stream.next_out=(Bytef *)pixels;\n  stream.avail_out=(uInt) count;\n\n  if (inflateInit(&stream) == Z_OK)\n    {\n      int\n        ret;\n\n      while (stream.avail_out > 0)\n      {\n        ret=inflate(&stream,Z_SYNC_FLUSH);\n        if ((ret != Z_OK) && (ret != Z_STREAM_END))\n          break;\n        if (ret == Z_STREAM_END)\n          {\n            (void) inflateEnd(&stream);\n            compact_pixels=(unsigned char *) RelinquishMagickMemory(\n              compact_pixels);\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            return(MagickFalse);\n          }\n      }\n      (void) inflateEnd(&stream);\n    }\n\n  if (compression == ZipWithPrediction)\n  {\n     p=pixels;\n     while (count > 0)\n     {\n       length=image->columns;\n       while (--length)\n       {\n         if (packet_size == 2)\n           {\n             p[2]+=p[0]+((p[1]+p[3]) >> 8);\n             p[3]+=p[1];\n           }\n         else\n          *(p+1)+=*p;\n         p+=packet_size;\n       }\n       p+=packet_size;\n       count-=row_size;\n     }\n  }\n\n  status=MagickTrue;\n  p=pixels;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=ReadPSDChannelPixels(image,channels,y,type,p,exception);\n    if (status == MagickFalse)\n      break;\n\n    p+=row_size;\n  }\n\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -47,6 +47,7 @@\n     }\n   if (ReadBlob(image,compact_size,compact_pixels) != (ssize_t) compact_size)\n     {\n+      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n       compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n       ThrowBinaryException(CorruptImageError,\"UnexpectedEndOfFile\",\n         image->filename);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      pixels=(unsigned char *) RelinquishMagickMemory(pixels);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-17887",
        "func_name": "ImageMagick/GetImagePixelCache",
        "description": "In ImageMagick 7.0.7-16 Q16, a memory leak vulnerability was found in the function GetImagePixelCache in magick/cache.c, which allows attackers to cause a denial of service via a crafted MNG image file that is processed by ReadOneMNGImage.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/dddce3e790b5b0f5dad91a7960de67af5bdea789",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/903",
        "commit_text": "",
        "func_before": "static Cache GetImagePixelCache(Image *image,const MagickBooleanType clone,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickBooleanType\n    destroy,\n    status;\n\n  static MagickSizeType\n    cache_timelimit = MagickResourceInfinity,\n    cpu_throttle = MagickResourceInfinity,\n    cycles = 0;\n\n  status=MagickTrue;\n  if (cpu_throttle == MagickResourceInfinity)\n    cpu_throttle=GetMagickResourceLimit(ThrottleResource);\n  if ((cpu_throttle != 0) && ((cycles++ % 32) == 0))\n    MagickDelay(cpu_throttle);\n  if (cache_epoch == 0)\n    {\n      /*\n        Set the expire time in seconds.\n      */\n      cache_epoch=time((time_t *) NULL);\n      cache_timelimit=GetMagickResourceLimit(TimeResource);\n    }\n  if ((cache_timelimit != MagickResourceInfinity) &&\n      ((MagickSizeType) (time((time_t *) NULL)-cache_epoch) >= cache_timelimit))\n    {\n#if defined(ECANCELED)\n      errno=ECANCELED;\n#endif\n      ThrowFatalException(ResourceLimitFatalError,\"TimeLimitExceeded\");\n    }\n  LockSemaphoreInfo(image->semaphore);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n#if defined(MAGICKCORE_OPENCL_SUPPORT)\n  CopyOpenCLBuffer(cache_info);\n#endif\n  destroy=MagickFalse;\n  if ((cache_info->reference_count > 1) || (cache_info->mode == ReadMode))\n    {\n      LockSemaphoreInfo(cache_info->semaphore);\n      if ((cache_info->reference_count > 1) || (cache_info->mode == ReadMode))\n        {\n          CacheInfo\n            *clone_info;\n\n          Image\n            clone_image;\n\n          /*\n            Clone pixel cache.\n          */\n          clone_image=(*image);\n          clone_image.semaphore=AllocateSemaphoreInfo();\n          clone_image.reference_count=1;\n          clone_image.cache=ClonePixelCache(cache_info);\n          clone_info=(CacheInfo *) clone_image.cache;\n          status=OpenPixelCache(&clone_image,IOMode,exception);\n          if (status != MagickFalse)\n            {\n              if (clone != MagickFalse)\n                status=ClonePixelCacheRepository(clone_info,cache_info,\n                  exception);\n              if (status != MagickFalse)\n                {\n                  destroy=MagickTrue;\n                  image->cache=clone_image.cache;\n                }\n            }\n          DestroySemaphoreInfo(&clone_image.semaphore);\n        }\n      UnlockSemaphoreInfo(cache_info->semaphore);\n    }\n  if (destroy != MagickFalse)\n    cache_info=(CacheInfo *) DestroyPixelCache(cache_info);\n  if (status != MagickFalse)\n    {\n      /*\n        Ensure the image matches the pixel cache morphology.\n      */\n      image->type=UndefinedType;\n      if (ValidatePixelCacheMorphology(image) == MagickFalse)\n        {\n          status=OpenPixelCache(image,IOMode,exception);\n          cache_info=(CacheInfo *) image->cache;\n          if (cache_info->type == DiskCache)\n            (void) ClosePixelCacheOnDisk(cache_info);\n        }\n    }\n  UnlockSemaphoreInfo(image->semaphore);\n  if (status == MagickFalse)\n    return((Cache) NULL);\n  return(image->cache);\n}",
        "func": "static Cache GetImagePixelCache(Image *image,const MagickBooleanType clone,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickBooleanType\n    destroy,\n    status;\n\n  static MagickSizeType\n    cache_timelimit = MagickResourceInfinity,\n    cpu_throttle = MagickResourceInfinity,\n    cycles = 0;\n\n  status=MagickTrue;\n  if (cpu_throttle == MagickResourceInfinity)\n    cpu_throttle=GetMagickResourceLimit(ThrottleResource);\n  if ((cpu_throttle != 0) && ((cycles++ % 32) == 0))\n    MagickDelay(cpu_throttle);\n  if (cache_epoch == 0)\n    {\n      /*\n        Set the expire time in seconds.\n      */\n      cache_epoch=time((time_t *) NULL);\n      cache_timelimit=GetMagickResourceLimit(TimeResource);\n    }\n  if ((cache_timelimit != MagickResourceInfinity) &&\n      ((MagickSizeType) (time((time_t *) NULL)-cache_epoch) >= cache_timelimit))\n    {\n#if defined(ECANCELED)\n      errno=ECANCELED;\n#endif\n      ThrowFatalException(ResourceLimitFatalError,\"TimeLimitExceeded\");\n    }\n  LockSemaphoreInfo(image->semaphore);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n#if defined(MAGICKCORE_OPENCL_SUPPORT)\n  CopyOpenCLBuffer(cache_info);\n#endif\n  destroy=MagickFalse;\n  if ((cache_info->reference_count > 1) || (cache_info->mode == ReadMode))\n    {\n      LockSemaphoreInfo(cache_info->semaphore);\n      if ((cache_info->reference_count > 1) || (cache_info->mode == ReadMode))\n        {\n          CacheInfo\n            *clone_info;\n\n          Image\n            clone_image;\n\n          /*\n            Clone pixel cache.\n          */\n          clone_image=(*image);\n          clone_image.semaphore=AllocateSemaphoreInfo();\n          clone_image.reference_count=1;\n          clone_image.cache=ClonePixelCache(cache_info);\n          clone_info=(CacheInfo *) clone_image.cache;\n          status=OpenPixelCache(&clone_image,IOMode,exception);\n          if (status == MagickFalse)\n            clone_info=(CacheInfo *) DestroyPixelCache(clone_info);\n          else\n            {\n              if (clone != MagickFalse)\n                status=ClonePixelCacheRepository(clone_info,cache_info,\n                  exception);\n              if (status != MagickFalse)\n                {\n                  destroy=MagickTrue;\n                  image->cache=clone_info;\n                }\n            }\n          DestroySemaphoreInfo(&clone_image.semaphore);\n        }\n      UnlockSemaphoreInfo(cache_info->semaphore);\n    }\n  if (destroy != MagickFalse)\n    cache_info=(CacheInfo *) DestroyPixelCache(cache_info);\n  if (status != MagickFalse)\n    {\n      /*\n        Ensure the image matches the pixel cache morphology.\n      */\n      image->type=UndefinedType;\n      if (ValidatePixelCacheMorphology(image) == MagickFalse)\n        {\n          status=OpenPixelCache(image,IOMode,exception);\n          cache_info=(CacheInfo *) image->cache;\n          if (cache_info->type == DiskCache)\n            (void) ClosePixelCacheOnDisk(cache_info);\n        }\n    }\n  UnlockSemaphoreInfo(image->semaphore);\n  if (status == MagickFalse)\n    return((Cache) NULL);\n  return(image->cache);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -61,7 +61,9 @@\n           clone_image.cache=ClonePixelCache(cache_info);\n           clone_info=(CacheInfo *) clone_image.cache;\n           status=OpenPixelCache(&clone_image,IOMode,exception);\n-          if (status != MagickFalse)\n+          if (status == MagickFalse)\n+            clone_info=(CacheInfo *) DestroyPixelCache(clone_info);\n+          else\n             {\n               if (clone != MagickFalse)\n                 status=ClonePixelCacheRepository(clone_info,cache_info,\n@@ -69,7 +71,7 @@\n               if (status != MagickFalse)\n                 {\n                   destroy=MagickTrue;\n-                  image->cache=clone_image.cache;\n+                  image->cache=clone_info;\n                 }\n             }\n           DestroySemaphoreInfo(&clone_image.semaphore);",
        "diff_line_info": {
            "deleted_lines": [
                "          if (status != MagickFalse)",
                "                  image->cache=clone_image.cache;"
            ],
            "added_lines": [
                "          if (status == MagickFalse)",
                "            clone_info=(CacheInfo *) DestroyPixelCache(clone_info);",
                "          else",
                "                  image->cache=clone_info;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-17934",
        "func_name": "ImageMagick/WriteMSLImage",
        "description": "ImageMagick 7.0.7-17 Q16 x86_64 has memory leaks in coders/msl.c, related to MSLPopImage and ProcessMSLScript, and associated with mishandling of MSLPushImage calls.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/08278c7cf1c0b4f1da4cdcfaa857ff6b2373a1b2",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/920",
        "commit_text": "",
        "func_before": "static MagickBooleanType WriteMSLImage(const ImageInfo *image_info,Image *image)\n{\n  Image\n    *msl_image;\n\n  MagickBooleanType\n    status;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  msl_image=CloneImage(image,0,0,MagickTrue,&image->exception);\n  status=ProcessMSLScript(image_info,&msl_image,&image->exception);\n  if (msl_image != (Image *) NULL)\n    msl_image=DestroyImage(msl_image);\n  return(status);\n}",
        "func": "static MagickBooleanType WriteMSLImage(const ImageInfo *image_info,Image *image)\n{\n  Image\n    *msl_image;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  msl_image=CloneImage(image,0,0,MagickTrue,&image->exception);\n  return(ProcessMSLScript(image_info,&msl_image,&image->exception));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,9 +2,6 @@\n {\n   Image\n     *msl_image;\n-\n-  MagickBooleanType\n-    status;\n \n   assert(image_info != (const ImageInfo *) NULL);\n   assert(image_info->signature == MagickCoreSignature);\n@@ -13,8 +10,5 @@\n   if (image->debug != MagickFalse)\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n   msl_image=CloneImage(image,0,0,MagickTrue,&image->exception);\n-  status=ProcessMSLScript(image_info,&msl_image,&image->exception);\n-  if (msl_image != (Image *) NULL)\n-    msl_image=DestroyImage(msl_image);\n-  return(status);\n+  return(ProcessMSLScript(image_info,&msl_image,&image->exception));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "  MagickBooleanType",
                "    status;",
                "  status=ProcessMSLScript(image_info,&msl_image,&image->exception);",
                "  if (msl_image != (Image *) NULL)",
                "    msl_image=DestroyImage(msl_image);",
                "  return(status);"
            ],
            "added_lines": [
                "  return(ProcessMSLScript(image_info,&msl_image,&image->exception));"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-17934",
        "func_name": "ImageMagick/ProcessMSLScript",
        "description": "ImageMagick 7.0.7-17 Q16 x86_64 has memory leaks in coders/msl.c, related to MSLPopImage and ProcessMSLScript, and associated with mishandling of MSLPushImage calls.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/08278c7cf1c0b4f1da4cdcfaa857ff6b2373a1b2",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/920",
        "commit_text": "",
        "func_before": "static MagickBooleanType ProcessMSLScript(const ImageInfo *image_info,\n  Image **image,ExceptionInfo *exception)\n{\n  char\n    message[MaxTextExtent];\n\n  Image\n    *msl_image;\n\n  int\n    status;\n\n  ssize_t\n    n;\n\n  MSLInfo\n    msl_info;\n\n  xmlSAXHandler\n    sax_modules;\n\n  xmlSAXHandlerPtr\n    sax_handler;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(image != (Image **) NULL);\n  msl_image=AcquireImage(image_info);\n  status=OpenBlob(image_info,msl_image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        msl_image->filename);\n      msl_image=DestroyImageList(msl_image);\n      return(MagickFalse);\n    }\n  msl_image->columns=1;\n  msl_image->rows=1;\n  /*\n    Parse MSL file.\n  */\n  (void) ResetMagickMemory(&msl_info,0,sizeof(msl_info));\n  msl_info.exception=exception;\n  msl_info.image_info=(ImageInfo **) AcquireMagickMemory(\n    sizeof(*msl_info.image_info));\n  msl_info.draw_info=(DrawInfo **) AcquireMagickMemory(\n    sizeof(*msl_info.draw_info));\n  /* top of the stack is the MSL file itself */\n  msl_info.image=(Image **) AcquireMagickMemory(sizeof(*msl_info.image));\n  msl_info.attributes=(Image **) AcquireMagickMemory(\n    sizeof(*msl_info.attributes));\n  msl_info.group_info=(MSLGroupInfo *) AcquireMagickMemory(\n    sizeof(*msl_info.group_info));\n  if ((msl_info.image_info == (ImageInfo **) NULL) ||\n      (msl_info.image == (Image **) NULL) ||\n      (msl_info.attributes == (Image **) NULL) ||\n      (msl_info.group_info == (MSLGroupInfo *) NULL))\n    ThrowFatalException(ResourceLimitFatalError,\"UnableToInterpretMSLImage\");\n  *msl_info.image_info=CloneImageInfo(image_info);\n  *msl_info.draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  *msl_info.attributes=AcquireImage(image_info);\n  msl_info.group_info[0].numImages=0;\n  /* the first slot is used to point to the MSL file image */\n  *msl_info.image=msl_image;\n  if (*image != (Image *) NULL)\n    MSLPushImage(&msl_info,*image);\n  (void) xmlSubstituteEntitiesDefault(1);\n  (void) ResetMagickMemory(&sax_modules,0,sizeof(sax_modules));\n  sax_modules.internalSubset=MSLInternalSubset;\n  sax_modules.isStandalone=MSLIsStandalone;\n  sax_modules.hasInternalSubset=MSLHasInternalSubset;\n  sax_modules.hasExternalSubset=MSLHasExternalSubset;\n  sax_modules.resolveEntity=MSLResolveEntity;\n  sax_modules.getEntity=MSLGetEntity;\n  sax_modules.entityDecl=MSLEntityDeclaration;\n  sax_modules.notationDecl=MSLNotationDeclaration;\n  sax_modules.attributeDecl=MSLAttributeDeclaration;\n  sax_modules.elementDecl=MSLElementDeclaration;\n  sax_modules.unparsedEntityDecl=MSLUnparsedEntityDeclaration;\n  sax_modules.setDocumentLocator=MSLSetDocumentLocator;\n  sax_modules.startDocument=MSLStartDocument;\n  sax_modules.endDocument=MSLEndDocument;\n  sax_modules.startElement=MSLStartElement;\n  sax_modules.endElement=MSLEndElement;\n  sax_modules.reference=MSLReference;\n  sax_modules.characters=MSLCharacters;\n  sax_modules.ignorableWhitespace=MSLIgnorableWhitespace;\n  sax_modules.processingInstruction=MSLProcessingInstructions;\n  sax_modules.comment=MSLComment;\n  sax_modules.warning=MSLWarning;\n  sax_modules.error=MSLError;\n  sax_modules.fatalError=MSLError;\n  sax_modules.getParameterEntity=MSLGetParameterEntity;\n  sax_modules.cdataBlock=MSLCDataBlock;\n  sax_modules.externalSubset=MSLExternalSubset;\n  sax_handler=(&sax_modules);\n  msl_info.parser=xmlCreatePushParserCtxt(sax_handler,&msl_info,(char *) NULL,0,\n    msl_image->filename);\n  while (ReadBlobString(msl_image,message) != (char *) NULL)\n  {\n    n=(ssize_t) strlen(message);\n    if (n == 0)\n      continue;\n    status=xmlParseChunk(msl_info.parser,message,(int) n,MagickFalse);\n    if (status != 0)\n      break;\n    (void) xmlParseChunk(msl_info.parser,\" \",1,MagickFalse);\n    if (msl_info.exception->severity >= ErrorException)\n      break;\n  }\n  if (msl_info.exception->severity == UndefinedException)\n    (void) xmlParseChunk(msl_info.parser,\" \",1,MagickTrue);\n  /*\n    Free resources.\n  */\n  xmlFreeParserCtxt(msl_info.parser);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"end SAX\");\n  msl_info.group_info=(MSLGroupInfo *) RelinquishMagickMemory(\n    msl_info.group_info);\n  if (*image == (Image *) NULL)\n    *image=(*msl_info.image);\n  *msl_info.image_info=DestroyImageInfo(*msl_info.image_info);\n  msl_info.image_info=(ImageInfo **) RelinquishMagickMemory(\n    msl_info.image_info);\n  *msl_info.draw_info=DestroyDrawInfo(*msl_info.draw_info);\n  msl_info.draw_info=(DrawInfo **) RelinquishMagickMemory(msl_info.draw_info);\n  msl_info.image=(Image **) RelinquishMagickMemory(msl_info.image);\n  *msl_info.attributes=DestroyImage(*msl_info.attributes);\n  msl_info.attributes=(Image **) RelinquishMagickMemory(msl_info.attributes);\n  msl_info.group_info=(MSLGroupInfo *) RelinquishMagickMemory(\n    msl_info.group_info);\n  if ((*msl_info.image)->exception.severity != UndefinedException)\n    return(MagickFalse);\n  return(MagickTrue);\n}",
        "func": "static MagickBooleanType ProcessMSLScript(const ImageInfo *image_info,\n  Image **image,ExceptionInfo *exception)\n{\n  char\n    message[MaxTextExtent];\n\n  Image\n    *msl_image;\n\n  int\n    status;\n\n  ssize_t\n    n;\n\n  MSLInfo\n    msl_info;\n\n  xmlSAXHandler\n    sax_modules;\n\n  xmlSAXHandlerPtr\n    sax_handler;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(image != (Image **) NULL);\n  msl_image=AcquireImage(image_info);\n  status=OpenBlob(image_info,msl_image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        msl_image->filename);\n      msl_image=DestroyImageList(msl_image);\n      return(MagickFalse);\n    }\n  msl_image->columns=1;\n  msl_image->rows=1;\n  /*\n    Parse MSL file.\n  */\n  (void) ResetMagickMemory(&msl_info,0,sizeof(msl_info));\n  msl_info.exception=exception;\n  msl_info.image_info=(ImageInfo **) AcquireMagickMemory(\n    sizeof(*msl_info.image_info));\n  msl_info.draw_info=(DrawInfo **) AcquireMagickMemory(\n    sizeof(*msl_info.draw_info));\n  /* top of the stack is the MSL file itself */\n  msl_info.image=(Image **) AcquireMagickMemory(sizeof(*msl_info.image));\n  msl_info.attributes=(Image **) AcquireMagickMemory(\n    sizeof(*msl_info.attributes));\n  msl_info.group_info=(MSLGroupInfo *) AcquireMagickMemory(\n    sizeof(*msl_info.group_info));\n  if ((msl_info.image_info == (ImageInfo **) NULL) ||\n      (msl_info.image == (Image **) NULL) ||\n      (msl_info.attributes == (Image **) NULL) ||\n      (msl_info.group_info == (MSLGroupInfo *) NULL))\n    ThrowFatalException(ResourceLimitFatalError,\"UnableToInterpretMSLImage\");\n  *msl_info.image_info=CloneImageInfo(image_info);\n  *msl_info.draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  *msl_info.attributes=AcquireImage(image_info);\n  msl_info.group_info[0].numImages=0;\n  /* the first slot is used to point to the MSL file image */\n  *msl_info.image=msl_image;\n  if (*image != (Image *) NULL)\n    MSLPushImage(&msl_info,*image);\n  (void) xmlSubstituteEntitiesDefault(1);\n  (void) ResetMagickMemory(&sax_modules,0,sizeof(sax_modules));\n  sax_modules.internalSubset=MSLInternalSubset;\n  sax_modules.isStandalone=MSLIsStandalone;\n  sax_modules.hasInternalSubset=MSLHasInternalSubset;\n  sax_modules.hasExternalSubset=MSLHasExternalSubset;\n  sax_modules.resolveEntity=MSLResolveEntity;\n  sax_modules.getEntity=MSLGetEntity;\n  sax_modules.entityDecl=MSLEntityDeclaration;\n  sax_modules.notationDecl=MSLNotationDeclaration;\n  sax_modules.attributeDecl=MSLAttributeDeclaration;\n  sax_modules.elementDecl=MSLElementDeclaration;\n  sax_modules.unparsedEntityDecl=MSLUnparsedEntityDeclaration;\n  sax_modules.setDocumentLocator=MSLSetDocumentLocator;\n  sax_modules.startDocument=MSLStartDocument;\n  sax_modules.endDocument=MSLEndDocument;\n  sax_modules.startElement=MSLStartElement;\n  sax_modules.endElement=MSLEndElement;\n  sax_modules.reference=MSLReference;\n  sax_modules.characters=MSLCharacters;\n  sax_modules.ignorableWhitespace=MSLIgnorableWhitespace;\n  sax_modules.processingInstruction=MSLProcessingInstructions;\n  sax_modules.comment=MSLComment;\n  sax_modules.warning=MSLWarning;\n  sax_modules.error=MSLError;\n  sax_modules.fatalError=MSLError;\n  sax_modules.getParameterEntity=MSLGetParameterEntity;\n  sax_modules.cdataBlock=MSLCDataBlock;\n  sax_modules.externalSubset=MSLExternalSubset;\n  sax_handler=(&sax_modules);\n  msl_info.parser=xmlCreatePushParserCtxt(sax_handler,&msl_info,(char *) NULL,0,\n    msl_image->filename);\n  while (ReadBlobString(msl_image,message) != (char *) NULL)\n  {\n    n=(ssize_t) strlen(message);\n    if (n == 0)\n      continue;\n    status=xmlParseChunk(msl_info.parser,message,(int) n,MagickFalse);\n    if (status != 0)\n      break;\n    (void) xmlParseChunk(msl_info.parser,\" \",1,MagickFalse);\n    if (msl_info.exception->severity >= ErrorException)\n      break;\n  }\n  if (msl_info.exception->severity == UndefinedException)\n    (void) xmlParseChunk(msl_info.parser,\" \",1,MagickTrue);\n  /*\n    Free resources.\n  */\n  xmlFreeParserCtxt(msl_info.parser);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"end SAX\");\n  if (*image == (Image *) NULL)\n    *image=CloneImage(*msl_info.image,0,0,MagickTrue,exception);\n  while (msl_info.n >= 0)\n  {\n    msl_info.image[msl_info.n]=DestroyImage(msl_info.image[msl_info.n]);\n    msl_info.attributes[msl_info.n]=DestroyImage(\n      msl_info.attributes[msl_info.n]);\n    msl_info.draw_info[msl_info.n]=DestroyDrawInfo(\n      msl_info.draw_info[msl_info.n]);\n    msl_info.image_info[msl_info.n]=DestroyImageInfo(\n      msl_info.image_info[msl_info.n]);\n    msl_info.n--;\n  } \n  msl_info.draw_info=(DrawInfo **) RelinquishMagickMemory(msl_info.draw_info);\n  msl_info.image=(Image **) RelinquishMagickMemory(msl_info.image);\n  msl_info.attributes=(Image **) RelinquishMagickMemory(msl_info.attributes);\n  msl_info.image_info=(ImageInfo **) RelinquishMagickMemory(\n    msl_info.image_info);\n  msl_info.group_info=(MSLGroupInfo *) RelinquishMagickMemory(\n    msl_info.group_info);\n  if ((*msl_info.image)->exception.severity != UndefinedException)\n    return(MagickFalse);\n  return(MagickTrue);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -121,18 +121,24 @@\n   */\n   xmlFreeParserCtxt(msl_info.parser);\n   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"end SAX\");\n-  msl_info.group_info=(MSLGroupInfo *) RelinquishMagickMemory(\n-    msl_info.group_info);\n   if (*image == (Image *) NULL)\n-    *image=(*msl_info.image);\n-  *msl_info.image_info=DestroyImageInfo(*msl_info.image_info);\n+    *image=CloneImage(*msl_info.image,0,0,MagickTrue,exception);\n+  while (msl_info.n >= 0)\n+  {\n+    msl_info.image[msl_info.n]=DestroyImage(msl_info.image[msl_info.n]);\n+    msl_info.attributes[msl_info.n]=DestroyImage(\n+      msl_info.attributes[msl_info.n]);\n+    msl_info.draw_info[msl_info.n]=DestroyDrawInfo(\n+      msl_info.draw_info[msl_info.n]);\n+    msl_info.image_info[msl_info.n]=DestroyImageInfo(\n+      msl_info.image_info[msl_info.n]);\n+    msl_info.n--;\n+  } \n+  msl_info.draw_info=(DrawInfo **) RelinquishMagickMemory(msl_info.draw_info);\n+  msl_info.image=(Image **) RelinquishMagickMemory(msl_info.image);\n+  msl_info.attributes=(Image **) RelinquishMagickMemory(msl_info.attributes);\n   msl_info.image_info=(ImageInfo **) RelinquishMagickMemory(\n     msl_info.image_info);\n-  *msl_info.draw_info=DestroyDrawInfo(*msl_info.draw_info);\n-  msl_info.draw_info=(DrawInfo **) RelinquishMagickMemory(msl_info.draw_info);\n-  msl_info.image=(Image **) RelinquishMagickMemory(msl_info.image);\n-  *msl_info.attributes=DestroyImage(*msl_info.attributes);\n-  msl_info.attributes=(Image **) RelinquishMagickMemory(msl_info.attributes);\n   msl_info.group_info=(MSLGroupInfo *) RelinquishMagickMemory(\n     msl_info.group_info);\n   if ((*msl_info.image)->exception.severity != UndefinedException)",
        "diff_line_info": {
            "deleted_lines": [
                "  msl_info.group_info=(MSLGroupInfo *) RelinquishMagickMemory(",
                "    msl_info.group_info);",
                "    *image=(*msl_info.image);",
                "  *msl_info.image_info=DestroyImageInfo(*msl_info.image_info);",
                "  *msl_info.draw_info=DestroyDrawInfo(*msl_info.draw_info);",
                "  msl_info.draw_info=(DrawInfo **) RelinquishMagickMemory(msl_info.draw_info);",
                "  msl_info.image=(Image **) RelinquishMagickMemory(msl_info.image);",
                "  *msl_info.attributes=DestroyImage(*msl_info.attributes);",
                "  msl_info.attributes=(Image **) RelinquishMagickMemory(msl_info.attributes);"
            ],
            "added_lines": [
                "    *image=CloneImage(*msl_info.image,0,0,MagickTrue,exception);",
                "  while (msl_info.n >= 0)",
                "  {",
                "    msl_info.image[msl_info.n]=DestroyImage(msl_info.image[msl_info.n]);",
                "    msl_info.attributes[msl_info.n]=DestroyImage(",
                "      msl_info.attributes[msl_info.n]);",
                "    msl_info.draw_info[msl_info.n]=DestroyDrawInfo(",
                "      msl_info.draw_info[msl_info.n]);",
                "    msl_info.image_info[msl_info.n]=DestroyImageInfo(",
                "      msl_info.image_info[msl_info.n]);",
                "    msl_info.n--;",
                "  } ",
                "  msl_info.draw_info=(DrawInfo **) RelinquishMagickMemory(msl_info.draw_info);",
                "  msl_info.image=(Image **) RelinquishMagickMemory(msl_info.image);",
                "  msl_info.attributes=(Image **) RelinquishMagickMemory(msl_info.attributes);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-17934",
        "func_name": "ImageMagick/MSLPopImage",
        "description": "ImageMagick 7.0.7-17 Q16 x86_64 has memory leaks in coders/msl.c, related to MSLPopImage and ProcessMSLScript, and associated with mishandling of MSLPushImage calls.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/08278c7cf1c0b4f1da4cdcfaa857ff6b2373a1b2",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/920",
        "commit_text": "",
        "func_before": "static void MSLPopImage(MSLInfo *msl_info)\n{\n  if (msl_info->number_groups != 0)\n    return;\n  if (msl_info->image[msl_info->n] != (Image *) NULL)\n    msl_info->image[msl_info->n]=DestroyImage(msl_info->image[msl_info->n]);\n  msl_info->attributes[msl_info->n]=DestroyImage(\n    msl_info->attributes[msl_info->n]);\n  msl_info->image_info[msl_info->n]=DestroyImageInfo(\n    msl_info->image_info[msl_info->n]);\n  msl_info->n--;\n}",
        "func": "static void MSLPopImage(MSLInfo *msl_info)\n{\n  if (msl_info->number_groups != 0)\n    return;\n  if (msl_info->image[msl_info->n] != (Image *) NULL)\n    msl_info->image[msl_info->n]=DestroyImage(msl_info->image[msl_info->n]);\n  msl_info->attributes[msl_info->n]=DestroyImage(\n    msl_info->attributes[msl_info->n]);\n  msl_info->draw_info[msl_info->n]=DestroyDrawInfo(\n    msl_info->draw_info[msl_info->n]);\n  msl_info->image_info[msl_info->n]=DestroyImageInfo(\n    msl_info->image_info[msl_info->n]);\n  msl_info->n--;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,8 @@\n     msl_info->image[msl_info->n]=DestroyImage(msl_info->image[msl_info->n]);\n   msl_info->attributes[msl_info->n]=DestroyImage(\n     msl_info->attributes[msl_info->n]);\n+  msl_info->draw_info[msl_info->n]=DestroyDrawInfo(\n+    msl_info->draw_info[msl_info->n]);\n   msl_info->image_info[msl_info->n]=DestroyImageInfo(\n     msl_info->image_info[msl_info->n]);\n   msl_info->n--;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  msl_info->draw_info[msl_info->n]=DestroyDrawInfo(",
                "    msl_info->draw_info[msl_info->n]);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-17934",
        "func_name": "ImageMagick/ConjureImageCommand",
        "description": "ImageMagick 7.0.7-17 Q16 x86_64 has memory leaks in coders/msl.c, related to MSLPopImage and ProcessMSLScript, and associated with mishandling of MSLPushImage calls.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/08278c7cf1c0b4f1da4cdcfaa857ff6b2373a1b2",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/920",
        "commit_text": "",
        "func_before": "WandExport MagickBooleanType ConjureImageCommand(ImageInfo *image_info,\n  int argc,char **argv,char **wand_unused(metadata),ExceptionInfo *exception)\n{\n#define DestroyConjure() \\\n{ \\\n  image=DestroyImageList(image); \\\n  for (i=0; i < (ssize_t) argc; i++) \\\n    argv[i]=DestroyString(argv[i]); \\\n  argv=(char **) RelinquishMagickMemory(argv); \\\n}\n#define ThrowConjureException(asperity,tag,option) \\\n{ \\\n  (void) ThrowMagickException(exception,GetMagickModule(),asperity,tag,\"`%s'\", \\\n     option); \\\n  DestroyConjure(); \\\n  return(MagickFalse); \\\n}\n#define ThrowConjureInvalidArgumentException(option,argument) \\\n{ \\\n  (void) ThrowMagickException(exception,GetMagickModule(),OptionError, \\\n    \"InvalidArgument\",\"`%s': %s\",option,argument); \\\n  DestroyConjure(); \\\n  return(MagickFalse); \\\n}\n\n  char\n    *option;\n\n  Image\n    *image;\n\n  MagickStatusType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    number_images;\n\n  wand_unreferenced(metadata);\n\n  /*\n    Set defaults.\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(exception != (ExceptionInfo *) NULL);\n  if (argc < 2)\n    return(ConjureUsage());\n  image=NewImageList();\n  number_images=0;\n  option=(char *) NULL;\n  /*\n    Conjure an image.\n  */\n  ReadCommandlLine(argc,&argv);\n  status=ExpandFilenames(&argc,&argv);\n  if (status == MagickFalse)\n    ThrowConjureException(ResourceLimitError,\"MemoryAllocationFailed\",\n      GetExceptionMessage(errno));\n  for (i=1; i < (ssize_t) argc; i++)\n  {\n    option=argv[i];\n    if (IsCommandOption(option) != MagickFalse)\n      {\n        if (LocaleCompare(\"concurrent\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"debug\",option+1) == 0)\n          {\n            ssize_t\n              event;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowConjureException(OptionError,\"MissingArgument\",option);\n            event=ParseCommandOption(MagickLogEventOptions,MagickFalse,argv[i]);\n            if (event < 0)\n              ThrowConjureException(OptionError,\"UnrecognizedEventType\",\n                argv[i]);\n            (void) SetLogEventMask(argv[i]);\n            continue;\n          }\n        if (LocaleCompare(\"duration\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowConjureException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowConjureInvalidArgumentException(option,argv[i]);\n            continue;\n          }\n        if ((LocaleCompare(\"help\",option+1) == 0) ||\n            (LocaleCompare(\"-help\",option+1) == 0))\n          {\n            if (*option == '-')\n              return(ConjureUsage());\n            continue;\n          }\n        if (LocaleCompare(\"log\",option+1) == 0)\n          {\n            if (*option == '-')\n              {\n                i++;\n                if (i == (ssize_t) argc)\n                  ThrowConjureException(OptionError,\"MissingLogFormat\",option);\n                (void) SetLogFormat(argv[i]);\n              }\n            continue;\n          }\n        if (LocaleCompare(\"monitor\",option+1) == 0)\n          continue;\n        if (LocaleCompare(\"quiet\",option+1) == 0)\n          continue;\n        if (LocaleCompare(\"regard-warnings\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"seed\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowConjureException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowConjureInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"verbose\",option+1) == 0)\n          {\n            image_info->verbose=(*option == '-') ? MagickTrue : MagickFalse;\n            continue;\n          }\n        if ((LocaleCompare(\"version\",option+1) == 0) ||\n            (LocaleCompare(\"-version\",option+1) == 0))\n          {\n            ListMagickVersion(stdout);\n            return(MagickTrue);\n          }\n        /*\n          Persist key/value pair.\n        */\n        (void) DeleteImageOption(image_info,option+1);\n        status=SetImageOption(image_info,option+1,argv[i+1]);\n        if (status == MagickFalse)\n          ThrowConjureException(ImageError,\"UnableToPersistKey\",option);\n        i++;\n        continue;\n      }\n    /*\n      Interpret MSL script.\n    */\n    (void) DeleteImageOption(image_info,\"filename\");\n    status=SetImageOption(image_info,\"filename\",argv[i]);\n    if (status == MagickFalse)\n      ThrowConjureException(ImageError,\"UnableToPersistKey\",argv[i]);\n    (void) FormatLocaleString(image_info->filename,MaxTextExtent,\"msl:%s\",\n      argv[i]);\n    (void) SetImageOption(image_info,\"filename\",argv[i]);\n    image=ReadImages(image_info,exception);\n    CatchException(exception);\n    if (image != (Image *) NULL)\n      image=DestroyImageList(image);\n    status=image != (Image *) NULL ? MagickTrue : MagickFalse;\n    number_images++;\n  }\n  if (i != (ssize_t) argc)\n    ThrowConjureException(OptionError,\"MissingAnImageFilename\",argv[i]);\n  if (number_images == 0)\n    ThrowConjureException(OptionError,\"MissingAnImageFilename\",argv[argc-1]);\n  if (image != (Image *) NULL)\n    image=DestroyImageList(image);\n  for (i=0; i < (ssize_t) argc; i++)\n    argv[i]=DestroyString(argv[i]);\n  argv=(char **) RelinquishMagickMemory(argv);\n  return(status != 0 ? MagickTrue : MagickFalse);\n}",
        "func": "WandExport MagickBooleanType ConjureImageCommand(ImageInfo *image_info,\n  int argc,char **argv,char **wand_unused(metadata),ExceptionInfo *exception)\n{\n#define DestroyConjure() \\\n{ \\\n  image=DestroyImageList(image); \\\n  for (i=0; i < (ssize_t) argc; i++) \\\n    argv[i]=DestroyString(argv[i]); \\\n  argv=(char **) RelinquishMagickMemory(argv); \\\n}\n#define ThrowConjureException(asperity,tag,option) \\\n{ \\\n  (void) ThrowMagickException(exception,GetMagickModule(),asperity,tag,\"`%s'\", \\\n     option); \\\n  DestroyConjure(); \\\n  return(MagickFalse); \\\n}\n#define ThrowConjureInvalidArgumentException(option,argument) \\\n{ \\\n  (void) ThrowMagickException(exception,GetMagickModule(),OptionError, \\\n    \"InvalidArgument\",\"`%s': %s\",option,argument); \\\n  DestroyConjure(); \\\n  return(MagickFalse); \\\n}\n\n  char\n    *option;\n\n  Image\n    *image;\n\n  MagickStatusType\n    status;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    number_images;\n\n  wand_unreferenced(metadata);\n\n  /*\n    Set defaults.\n  */\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(exception != (ExceptionInfo *) NULL);\n  if (argc < 2)\n    return(ConjureUsage());\n  image=NewImageList();\n  number_images=0;\n  option=(char *) NULL;\n  /*\n    Conjure an image.\n  */\n  ReadCommandlLine(argc,&argv);\n  status=ExpandFilenames(&argc,&argv);\n  if (status == MagickFalse)\n    ThrowConjureException(ResourceLimitError,\"MemoryAllocationFailed\",\n      GetExceptionMessage(errno));\n  for (i=1; i < (ssize_t) argc; i++)\n  {\n    option=argv[i];\n    if (IsCommandOption(option) != MagickFalse)\n      {\n        if (LocaleCompare(\"concurrent\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"debug\",option+1) == 0)\n          {\n            ssize_t\n              event;\n\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowConjureException(OptionError,\"MissingArgument\",option);\n            event=ParseCommandOption(MagickLogEventOptions,MagickFalse,argv[i]);\n            if (event < 0)\n              ThrowConjureException(OptionError,\"UnrecognizedEventType\",\n                argv[i]);\n            (void) SetLogEventMask(argv[i]);\n            continue;\n          }\n        if (LocaleCompare(\"duration\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowConjureException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowConjureInvalidArgumentException(option,argv[i]);\n            continue;\n          }\n        if ((LocaleCompare(\"help\",option+1) == 0) ||\n            (LocaleCompare(\"-help\",option+1) == 0))\n          {\n            if (*option == '-')\n              return(ConjureUsage());\n            continue;\n          }\n        if (LocaleCompare(\"log\",option+1) == 0)\n          {\n            if (*option == '-')\n              {\n                i++;\n                if (i == (ssize_t) argc)\n                  ThrowConjureException(OptionError,\"MissingLogFormat\",option);\n                (void) SetLogFormat(argv[i]);\n              }\n            continue;\n          }\n        if (LocaleCompare(\"monitor\",option+1) == 0)\n          continue;\n        if (LocaleCompare(\"quiet\",option+1) == 0)\n          continue;\n        if (LocaleCompare(\"regard-warnings\",option+1) == 0)\n          break;\n        if (LocaleCompare(\"seed\",option+1) == 0)\n          {\n            if (*option == '+')\n              break;\n            i++;\n            if (i == (ssize_t) argc)\n              ThrowConjureException(OptionError,\"MissingArgument\",option);\n            if (IsGeometry(argv[i]) == MagickFalse)\n              ThrowConjureInvalidArgumentException(option,argv[i]);\n            break;\n          }\n        if (LocaleCompare(\"verbose\",option+1) == 0)\n          {\n            image_info->verbose=(*option == '-') ? MagickTrue : MagickFalse;\n            continue;\n          }\n        if ((LocaleCompare(\"version\",option+1) == 0) ||\n            (LocaleCompare(\"-version\",option+1) == 0))\n          {\n            ListMagickVersion(stdout);\n            return(MagickTrue);\n          }\n        /*\n          Persist key/value pair.\n        */\n        (void) DeleteImageOption(image_info,option+1);\n        status=SetImageOption(image_info,option+1,argv[i+1]);\n        if (status == MagickFalse)\n          ThrowConjureException(ImageError,\"UnableToPersistKey\",option);\n        i++;\n        continue;\n      }\n    /*\n      Interpret MSL script.\n    */\n    (void) DeleteImageOption(image_info,\"filename\");\n    status=SetImageOption(image_info,\"filename\",argv[i]);\n    if (status == MagickFalse)\n      ThrowConjureException(ImageError,\"UnableToPersistKey\",argv[i]);\n    (void) FormatLocaleString(image_info->filename,MaxTextExtent,\"%s\",argv[i]);\n    (void) SetImageOption(image_info,\"filename\",argv[i]);\n    image=ReadImages(image_info,exception);\n    CatchException(exception);\n    if (image != (Image *) NULL)\n      image=DestroyImageList(image);\n    status=image != (Image *) NULL ? MagickTrue : MagickFalse;\n    number_images++;\n  }\n  if (i != (ssize_t) argc)\n    ThrowConjureException(OptionError,\"MissingAnImageFilename\",argv[i]);\n  if (number_images == 0)\n    ThrowConjureException(OptionError,\"MissingAnImageFilename\",argv[argc-1]);\n  if (image != (Image *) NULL)\n    image=DestroyImageList(image);\n  for (i=0; i < (ssize_t) argc; i++)\n    argv[i]=DestroyString(argv[i]);\n  argv=(char **) RelinquishMagickMemory(argv);\n  return(status != 0 ? MagickTrue : MagickFalse);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -159,8 +159,7 @@\n     status=SetImageOption(image_info,\"filename\",argv[i]);\n     if (status == MagickFalse)\n       ThrowConjureException(ImageError,\"UnableToPersistKey\",argv[i]);\n-    (void) FormatLocaleString(image_info->filename,MaxTextExtent,\"msl:%s\",\n-      argv[i]);\n+    (void) FormatLocaleString(image_info->filename,MaxTextExtent,\"%s\",argv[i]);\n     (void) SetImageOption(image_info,\"filename\",argv[i]);\n     image=ReadImages(image_info,exception);\n     CatchException(exception);",
        "diff_line_info": {
            "deleted_lines": [
                "    (void) FormatLocaleString(image_info->filename,MaxTextExtent,\"msl:%s\",",
                "      argv[i]);"
            ],
            "added_lines": [
                "    (void) FormatLocaleString(image_info->filename,MaxTextExtent,\"%s\",argv[i]);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-18008",
        "func_name": "ImageMagick/ReadPWPImage",
        "description": "In ImageMagick 7.0.7-17 Q16, there is a Memory Leak in ReadPWPImage in coders/pwp.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/1a5f95fc018a5667de5a9448aee9d7251b2eb952",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/921",
        "commit_text": "",
        "func_before": "static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  FILE\n    *file;\n\n  Image\n    *image,\n    *next_image,\n    *pwp_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register Image\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    filesize,\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    magick[MaxTextExtent];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  pwp_image=AcquireImage(image_info);\n  image=pwp_image;\n  status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return((Image *) NULL);\n  ResetMagickMemory(magick,0,sizeof(magick));\n  count=ReadBlob(pwp_image,5,magick);\n  if ((count != 5) || (LocaleNCompare((char *) magick,\"SFW95\",5) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  read_info=CloneImageInfo(image_info);\n  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,\n    (void *) NULL);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  unique_file=AcquireUniqueFileResource(read_info->filename);\n  for ( ; ; )\n  {\n    (void) memset(magick,0,sizeof(magick));\n    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))\n    {\n      for (i=0; i < 17; i++)\n        magick[i]=magick[i+1];\n      magick[17]=(unsigned char) c;\n      if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) == 0)\n        break;\n    }\n    if (c == EOF)\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n      }\n    if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) != 0)\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    /*\n      Dump SFW image to a temporary file.\n    */\n    file=(FILE *) NULL;\n    if (unique_file != -1)\n      file=fdopen(unique_file,\"wb\");\n    if ((unique_file == -1) || (file == (FILE *) NULL))\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        ThrowFileException(exception,FileOpenError,\"UnableToWriteFile\",\n          image->filename);\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    length=fwrite(\"SFW94A\",1,6,file);\n    (void) length;\n    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];\n    for (i=0; i < (ssize_t) filesize; i++)\n    {\n      c=ReadBlobByte(pwp_image);\n      if (c == EOF)\n        break;\n      (void) fputc(c,file);\n    }\n    (void) fclose(file);\n    if (c == EOF)\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n      }\n    next_image=ReadImage(read_info,exception);\n    if (next_image == (Image *) NULL)\n      break;\n    (void) FormatLocaleString(next_image->filename,MaxTextExtent,\n      \"slide_%02ld.sfw\",(long) next_image->scene);\n    if (image == (Image *) NULL)\n      image=next_image;\n    else\n      {\n        /*\n          Link image into image list.\n        */\n        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;\n        next_image->previous=p;\n        next_image->scene=p->scene+1;\n        p->next=next_image;\n      }\n    if (image_info->number_scenes != 0)\n      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),\n      GetBlobSize(pwp_image));\n    if (status == MagickFalse)\n      break;\n  }\n  if (unique_file != -1)\n    (void) close(unique_file);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    {\n      if (EOFBlob(image) != MagickFalse)\n        {\n          char\n            *message;\n\n          message=GetExceptionMessage(errno);\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            CorruptImageError,\"UnexpectedEndOfFile\",\"`%s': %s\",image->filename,\n            message);\n          message=DestroyString(message);\n        }\n      (void) CloseBlob(image);\n    }\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  FILE\n    *file;\n\n  Image\n    *image,\n    *next_image,\n    *pwp_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register Image\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    filesize,\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    magick[MaxTextExtent];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  pwp_image=AcquireImage(image_info);\n  image=pwp_image;\n  status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return((Image *) NULL);\n  ResetMagickMemory(magick,0,sizeof(magick));\n  count=ReadBlob(pwp_image,5,magick);\n  if ((count != 5) || (LocaleNCompare((char *) magick,\"SFW95\",5) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  read_info=CloneImageInfo(image_info);\n  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,\n    (void *) NULL);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  unique_file=AcquireUniqueFileResource(read_info->filename);\n  for ( ; ; )\n  {\n    (void) memset(magick,0,sizeof(magick));\n    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))\n    {\n      for (i=0; i < 17; i++)\n        magick[i]=magick[i+1];\n      magick[17]=(unsigned char) c;\n      if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) == 0)\n        break;\n    }\n    if (c == EOF)\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        read_info=DestroyImageInfo(read_info);\n        ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n      }\n    if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) != 0)\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        read_info=DestroyImageInfo(read_info);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    /*\n      Dump SFW image to a temporary file.\n    */\n    file=(FILE *) NULL;\n    if (unique_file != -1)\n      file=fdopen(unique_file,\"wb\");\n    if ((unique_file == -1) || (file == (FILE *) NULL))\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        read_info=DestroyImageInfo(read_info);\n        image=DestroyImageList(image);\n        ThrowFileException(exception,FileOpenError,\"UnableToWriteFile\",\n          image->filename);\n        return((Image *) NULL);\n      }\n    length=fwrite(\"SFW94A\",1,6,file);\n    (void) length;\n    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];\n    for (i=0; i < (ssize_t) filesize; i++)\n    {\n      c=ReadBlobByte(pwp_image);\n      if (c == EOF)\n        break;\n      (void) fputc(c,file);\n    }\n    (void) fclose(file);\n    if (c == EOF)\n      {\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        read_info=DestroyImageInfo(read_info);\n        ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n      }\n    next_image=ReadImage(read_info,exception);\n    if (next_image == (Image *) NULL)\n      break;\n    (void) FormatLocaleString(next_image->filename,MaxTextExtent,\n      \"slide_%02ld.sfw\",(long) next_image->scene);\n    if (image == (Image *) NULL)\n      image=next_image;\n    else\n      {\n        /*\n          Link image into image list.\n        */\n        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;\n        next_image->previous=p;\n        next_image->scene=p->scene+1;\n        p->next=next_image;\n      }\n    if (image_info->number_scenes != 0)\n      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),\n      GetBlobSize(pwp_image));\n    if (status == MagickFalse)\n      break;\n  }\n  if (unique_file != -1)\n    (void) close(unique_file);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    {\n      if (EOFBlob(image) != MagickFalse)\n        {\n          char\n            *message;\n\n          message=GetExceptionMessage(errno);\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            CorruptImageError,\"UnexpectedEndOfFile\",\"`%s': %s\",image->filename,\n            message);\n          message=DestroyString(message);\n        }\n      (void) CloseBlob(image);\n    }\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -72,11 +72,13 @@\n     if (c == EOF)\n       {\n         (void) RelinquishUniqueFileResource(read_info->filename);\n+        read_info=DestroyImageInfo(read_info);\n         ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n       }\n     if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) != 0)\n       {\n         (void) RelinquishUniqueFileResource(read_info->filename);\n+        read_info=DestroyImageInfo(read_info);\n         ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n       }\n     /*\n@@ -88,9 +90,10 @@\n     if ((unique_file == -1) || (file == (FILE *) NULL))\n       {\n         (void) RelinquishUniqueFileResource(read_info->filename);\n+        read_info=DestroyImageInfo(read_info);\n+        image=DestroyImageList(image);\n         ThrowFileException(exception,FileOpenError,\"UnableToWriteFile\",\n           image->filename);\n-        image=DestroyImageList(image);\n         return((Image *) NULL);\n       }\n     length=fwrite(\"SFW94A\",1,6,file);\n@@ -107,6 +110,7 @@\n     if (c == EOF)\n       {\n         (void) RelinquishUniqueFileResource(read_info->filename);\n+        read_info=DestroyImageInfo(read_info);\n         ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n       }\n     next_image=ReadImage(read_info,exception);",
        "diff_line_info": {
            "deleted_lines": [
                "        image=DestroyImageList(image);"
            ],
            "added_lines": [
                "        read_info=DestroyImageInfo(read_info);",
                "        read_info=DestroyImageInfo(read_info);",
                "        read_info=DestroyImageInfo(read_info);",
                "        image=DestroyImageList(image);",
                "        read_info=DestroyImageInfo(read_info);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-5246",
        "func_name": "ImageMagick/ReadPATTERNImage",
        "description": "In ImageMagick 7.0.7-17 Q16, there are memory leaks in ReadPATTERNImage in coders/pattern.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/e59dc85e6ce58fd7618c3680b2a8def62050582f",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/929",
        "commit_text": "",
        "func_before": "static Image *ReadPATTERNImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const void\n    *blob;\n\n  Image\n    *image;\n\n  ImageInfo\n    *blob_info;\n\n  register ssize_t\n    i;\n\n  size_t\n    extent;\n\n  blob_info=CloneImageInfo(image_info);\n  image=(Image *) NULL;\n  blob=(const void *) NULL;\n  extent=0;\n  for (i=0; PatternImageList[i].blob != (const void *) NULL; i++)\n    if (LocaleCompare(blob_info->filename,PatternImageList[i].name) == 0)\n      {\n        (void) CopyMagickString(blob_info->magick,PatternImageList[i].magick,\n          MaxTextExtent);\n        blob=PatternImageList[i].blob;\n        extent=PatternImageList[i].extent;\n        break;\n      }\n  if (blob == (const void *) NULL)\n    ThrowReaderException(OptionError,\"UnrecognizedImageFormat\");\n  image=BlobToImage(blob_info,blob,extent,exception);\n  if (image_info->size != (char *) NULL)\n    {\n      Image\n        *pattern_image;\n\n      /*\n        Tile pattern across image canvas.\n      */\n      pattern_image=image;\n      image=AcquireImage(image_info);\n      (void) TextureImage(image,pattern_image);\n      pattern_image=DestroyImage(pattern_image);\n    }\n  blob_info=DestroyImageInfo(blob_info);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadPATTERNImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const void\n    *blob;\n\n  Image\n    *image;\n\n  ImageInfo\n    *blob_info;\n\n  register ssize_t\n    i;\n\n  size_t\n    extent;\n\n  blob_info=CloneImageInfo(image_info);\n  image=(Image *) NULL;\n  blob=(const void *) NULL;\n  extent=0;\n  for (i=0; PatternImageList[i].blob != (const void *) NULL; i++)\n    if (LocaleCompare(blob_info->filename,PatternImageList[i].name) == 0)\n      {\n        (void) CopyMagickString(blob_info->magick,PatternImageList[i].magick,\n          MaxTextExtent);\n        blob=PatternImageList[i].blob;\n        extent=PatternImageList[i].extent;\n        break;\n      }\n  if (blob == (const void *) NULL)\n    {\n      blob_info=DestroyImageInfo(blob_info);\n      ThrowReaderException(OptionError,\"UnrecognizedImageFormat\");\n    }\n  image=BlobToImage(blob_info,blob,extent,exception);\n  if (image_info->size != (char *) NULL)\n    {\n      Image\n        *pattern_image;\n\n      /*\n        Tile pattern across image canvas.\n      */\n      pattern_image=image;\n      image=AcquireImage(image_info);\n      (void) TextureImage(image,pattern_image);\n      pattern_image=DestroyImage(pattern_image);\n    }\n  blob_info=DestroyImageInfo(blob_info);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,7 +30,10 @@\n         break;\n       }\n   if (blob == (const void *) NULL)\n-    ThrowReaderException(OptionError,\"UnrecognizedImageFormat\");\n+    {\n+      blob_info=DestroyImageInfo(blob_info);\n+      ThrowReaderException(OptionError,\"UnrecognizedImageFormat\");\n+    }\n   image=BlobToImage(blob_info,blob,extent,exception);\n   if (image_info->size != (char *) NULL)\n     {",
        "diff_line_info": {
            "deleted_lines": [
                "    ThrowReaderException(OptionError,\"UnrecognizedImageFormat\");"
            ],
            "added_lines": [
                "    {",
                "      blob_info=DestroyImageInfo(blob_info);",
                "      ThrowReaderException(OptionError,\"UnrecognizedImageFormat\");",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-5247",
        "func_name": "ImageMagick/ReadRLAImage",
        "description": "In ImageMagick 7.0.7-17 Q16, there are memory leaks in ReadRLAImage in coders/rla.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/0ecb22aa909e52d86b4545aa7a51f7a0922147e6",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/928",
        "commit_text": "",
        "func_before": "static Image *ReadRLAImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  typedef struct _WindowFrame\n  {\n    short\n      left,\n      right,\n      bottom,\n      top;\n  } WindowFrame;\n\n  typedef struct _RLAInfo\n  {\n    WindowFrame\n      window,\n      active_window;\n\n    short\n      frame,\n      storage_type,\n      number_channels,\n      number_matte_channels,\n      number_auxiliary_channels,\n      revision;\n\n    char\n      gamma[16+1],\n      red_primary[24+1],\n      green_primary[24+1],\n      blue_primary[24+1],\n      white_point[24+1];\n\n    int\n      job_number;\n\n    char\n      name[128+1],\n      description[128+1],\n      program[64+1],\n      machine[32+1],\n      user[32+1],\n      date[20+1],\n      aspect[24+1],\n      aspect_ratio[8+1],\n      chan[32+1];\n\n    short\n      field;\n\n    char\n      time[12+1],\n      filter[32+1];\n\n    short\n      bits_per_channel,\n      matte_type,\n      matte_bits,\n      auxiliary_type,\n      auxiliary_bits;\n\n    char\n      auxiliary[32+1],\n      space[36+1];\n\n    int\n      next;\n  } RLAInfo;\n\n  Image\n    *image;\n\n  int\n    channel,\n    length,\n    runlength;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    *scanlines;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  ssize_t\n    count,\n    y;\n\n  RLAInfo\n    rla_info;\n\n  unsigned char\n    byte;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) ResetMagickMemory(&rla_info,0,sizeof(rla_info));\n  rla_info.window.left=(short) ReadBlobMSBShort(image);\n  rla_info.window.right=(short) ReadBlobMSBShort(image);\n  rla_info.window.bottom=(short) ReadBlobMSBShort(image);\n  rla_info.window.top=(short) ReadBlobMSBShort(image);\n  rla_info.active_window.left=(short) ReadBlobMSBShort(image);\n  rla_info.active_window.right=(short) ReadBlobMSBShort(image);\n  rla_info.active_window.bottom=(short) ReadBlobMSBShort(image);\n  rla_info.active_window.top=(short) ReadBlobMSBShort(image);\n  rla_info.frame=(short) ReadBlobMSBShort(image);\n  rla_info.storage_type=(short) ReadBlobMSBShort(image);\n  rla_info.number_channels=(short) ReadBlobMSBShort(image);\n  rla_info.number_matte_channels=(short) ReadBlobMSBShort(image);\n  if (rla_info.number_channels == 0)\n    rla_info.number_channels=3;\n  rla_info.number_channels+=rla_info.number_matte_channels;\n  rla_info.number_auxiliary_channels=(short) ReadBlobMSBShort(image);\n  rla_info.revision=(short) ReadBlobMSBShort(image);\n  count=ReadBlob(image,16,(unsigned char *) rla_info.gamma);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.red_primary);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.green_primary);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.blue_primary);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.white_point);\n  rla_info.job_number=ReadBlobMSBSignedLong(image);\n  count=ReadBlob(image,128,(unsigned char *) rla_info.name);\n  count=ReadBlob(image,128,(unsigned char *) rla_info.description);\n  rla_info.description[127]='\\0';\n  count=ReadBlob(image,64,(unsigned char *) rla_info.program);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.machine);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.user);\n  count=ReadBlob(image,20,(unsigned char *) rla_info.date);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.aspect);\n  count=ReadBlob(image,8,(unsigned char *) rla_info.aspect_ratio);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.chan);\n  rla_info.field=(short) ReadBlobMSBShort(image);\n  count=ReadBlob(image,12,(unsigned char *) rla_info.time);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.filter);\n  rla_info.bits_per_channel=(short) ReadBlobMSBShort(image);\n  rla_info.matte_type=(short) ReadBlobMSBShort(image);\n  rla_info.matte_bits=(short) ReadBlobMSBShort(image);\n  rla_info.auxiliary_type=(short) ReadBlobMSBShort(image);\n  rla_info.auxiliary_bits=(short) ReadBlobMSBShort(image);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.auxiliary);\n  count=ReadBlob(image,36,(unsigned char *) rla_info.space);\n  if ((size_t) count != 36)\n    ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n  rla_info.next=ReadBlobMSBSignedLong(image);\n  /*\n    Initialize image structure.\n  */\n  image->matte=rla_info.number_matte_channels != 0 ? MagickTrue : MagickFalse;\n  image->columns=(size_t) (rla_info.active_window.right-\n    rla_info.active_window.left+1);\n  image->rows=(size_t) (rla_info.active_window.top-\n    rla_info.active_window.bottom+1);\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  scanlines=(MagickOffsetType *) AcquireQuantumMemory(image->rows,\n    sizeof(*scanlines));\n  if (scanlines == (MagickOffsetType *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (*rla_info.description != '\\0')\n    (void) SetImageProperty(image,\"comment\",(char *) rla_info.description);\n  /*\n    Read offsets to each scanline data.\n  */\n  for (i=0; i < (ssize_t) image->rows; i++)\n    scanlines[i]=(MagickOffsetType) ReadBlobMSBSignedLong(image);\n  /*\n    Read image data.\n  */\n  x=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    offset=SeekBlob(image,scanlines[image->rows-y-1],SEEK_SET);\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    for (channel=0; channel < (int) rla_info.number_channels; channel++)\n    {\n      length=ReadBlobMSBSignedShort(image);\n      while (length > 0)\n      {\n        byte=(unsigned char) ReadBlobByte(image);\n        runlength=byte;\n        if (byte > 127)\n          runlength=byte-256;\n        length--;\n        if (length == 0)\n          break;\n        if (runlength < 0)\n          {\n            while (runlength < 0)\n            {\n              q=GetAuthenticPixels(image,(ssize_t) (x % image->columns),\n                (ssize_t) (y % image->rows),1,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              byte=(unsigned char) ReadBlobByte(image);\n              length--;\n              switch (channel)\n              {\n                case 0:\n                {\n                  SetPixelRed(q,ScaleCharToQuantum(byte));\n                  break;\n                }\n                case 1:\n                {\n                  SetPixelGreen(q,ScaleCharToQuantum(byte));\n                  break;\n                }\n                case 2:\n                {\n                  SetPixelBlue(q,ScaleCharToQuantum(byte));\n                  break;\n                }\n                case 3:\n                default:\n                {\n                  SetPixelAlpha(q,ScaleCharToQuantum(byte));\n                  break;\n                }\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              x++;\n              runlength++;\n            }\n            continue;\n          }\n        byte=(unsigned char) ReadBlobByte(image);\n        length--;\n        runlength++;\n        do\n        {\n          q=GetAuthenticPixels(image,(ssize_t) (x % image->columns),\n            (ssize_t) (y % image->rows),1,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          switch (channel)\n          {\n            case 0:\n            {\n              SetPixelRed(q,ScaleCharToQuantum(byte));\n              break;\n            }\n            case 1:\n            {\n              SetPixelGreen(q,ScaleCharToQuantum(byte));\n              break;\n            }\n            case 2:\n            {\n              SetPixelBlue(q,ScaleCharToQuantum(byte));\n              break;\n            }\n            case 3:\n            default:\n            {\n              SetPixelAlpha(q,ScaleCharToQuantum(byte));\n              break;\n            }\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          x++;\n          runlength--;\n        }\n        while (runlength > 0);\n      }\n    }\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  scanlines=(MagickOffsetType *) RelinquishMagickMemory(scanlines);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadRLAImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  typedef struct _WindowFrame\n  {\n    short\n      left,\n      right,\n      bottom,\n      top;\n  } WindowFrame;\n\n  typedef struct _RLAInfo\n  {\n    WindowFrame\n      window,\n      active_window;\n\n    short\n      frame,\n      storage_type,\n      number_channels,\n      number_matte_channels,\n      number_auxiliary_channels,\n      revision;\n\n    char\n      gamma[16+1],\n      red_primary[24+1],\n      green_primary[24+1],\n      blue_primary[24+1],\n      white_point[24+1];\n\n    int\n      job_number;\n\n    char\n      name[128+1],\n      description[128+1],\n      program[64+1],\n      machine[32+1],\n      user[32+1],\n      date[20+1],\n      aspect[24+1],\n      aspect_ratio[8+1],\n      chan[32+1];\n\n    short\n      field;\n\n    char\n      time[12+1],\n      filter[32+1];\n\n    short\n      bits_per_channel,\n      matte_type,\n      matte_bits,\n      auxiliary_type,\n      auxiliary_bits;\n\n    char\n      auxiliary[32+1],\n      space[36+1];\n\n    int\n      next;\n  } RLAInfo;\n\n  Image\n    *image;\n\n  int\n    channel,\n    length,\n    runlength;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    *scanlines;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  ssize_t\n    count,\n    y;\n\n  RLAInfo\n    rla_info;\n\n  unsigned char\n    byte;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) ResetMagickMemory(&rla_info,0,sizeof(rla_info));\n  rla_info.window.left=(short) ReadBlobMSBShort(image);\n  rla_info.window.right=(short) ReadBlobMSBShort(image);\n  rla_info.window.bottom=(short) ReadBlobMSBShort(image);\n  rla_info.window.top=(short) ReadBlobMSBShort(image);\n  rla_info.active_window.left=(short) ReadBlobMSBShort(image);\n  rla_info.active_window.right=(short) ReadBlobMSBShort(image);\n  rla_info.active_window.bottom=(short) ReadBlobMSBShort(image);\n  rla_info.active_window.top=(short) ReadBlobMSBShort(image);\n  rla_info.frame=(short) ReadBlobMSBShort(image);\n  rla_info.storage_type=(short) ReadBlobMSBShort(image);\n  rla_info.number_channels=(short) ReadBlobMSBShort(image);\n  rla_info.number_matte_channels=(short) ReadBlobMSBShort(image);\n  if (rla_info.number_channels == 0)\n    rla_info.number_channels=3;\n  rla_info.number_channels+=rla_info.number_matte_channels;\n  rla_info.number_auxiliary_channels=(short) ReadBlobMSBShort(image);\n  rla_info.revision=(short) ReadBlobMSBShort(image);\n  count=ReadBlob(image,16,(unsigned char *) rla_info.gamma);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.red_primary);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.green_primary);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.blue_primary);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.white_point);\n  rla_info.job_number=ReadBlobMSBSignedLong(image);\n  count=ReadBlob(image,128,(unsigned char *) rla_info.name);\n  count=ReadBlob(image,128,(unsigned char *) rla_info.description);\n  rla_info.description[127]='\\0';\n  count=ReadBlob(image,64,(unsigned char *) rla_info.program);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.machine);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.user);\n  count=ReadBlob(image,20,(unsigned char *) rla_info.date);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.aspect);\n  count=ReadBlob(image,8,(unsigned char *) rla_info.aspect_ratio);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.chan);\n  rla_info.field=(short) ReadBlobMSBShort(image);\n  count=ReadBlob(image,12,(unsigned char *) rla_info.time);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.filter);\n  rla_info.bits_per_channel=(short) ReadBlobMSBShort(image);\n  rla_info.matte_type=(short) ReadBlobMSBShort(image);\n  rla_info.matte_bits=(short) ReadBlobMSBShort(image);\n  rla_info.auxiliary_type=(short) ReadBlobMSBShort(image);\n  rla_info.auxiliary_bits=(short) ReadBlobMSBShort(image);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.auxiliary);\n  count=ReadBlob(image,36,(unsigned char *) rla_info.space);\n  if ((size_t) count != 36)\n    ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n  rla_info.next=ReadBlobMSBSignedLong(image);\n  /*\n    Initialize image structure.\n  */\n  image->matte=rla_info.number_matte_channels != 0 ? MagickTrue : MagickFalse;\n  image->columns=(size_t) (rla_info.active_window.right-\n    rla_info.active_window.left+1);\n  image->rows=(size_t) (rla_info.active_window.top-\n    rla_info.active_window.bottom+1);\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  scanlines=(MagickOffsetType *) AcquireQuantumMemory(image->rows,\n    sizeof(*scanlines));\n  if (scanlines == (MagickOffsetType *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (*rla_info.description != '\\0')\n    (void) SetImageProperty(image,\"comment\",(char *) rla_info.description);\n  /*\n    Read offsets to each scanline data.\n  */\n  for (i=0; i < (ssize_t) image->rows; i++)\n    scanlines[i]=(MagickOffsetType) ReadBlobMSBSignedLong(image);\n  /*\n    Read image data.\n  */\n  x=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    offset=SeekBlob(image,scanlines[image->rows-y-1],SEEK_SET);\n    if (offset < 0)\n      {\n        scanlines=(MagickOffsetType *) RelinquishMagickMemory(scanlines);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    for (channel=0; channel < (int) rla_info.number_channels; channel++)\n    {\n      length=ReadBlobMSBSignedShort(image);\n      while (length > 0)\n      {\n        byte=(unsigned char) ReadBlobByte(image);\n        runlength=byte;\n        if (byte > 127)\n          runlength=byte-256;\n        length--;\n        if (length == 0)\n          break;\n        if (runlength < 0)\n          {\n            while (runlength < 0)\n            {\n              q=GetAuthenticPixels(image,(ssize_t) (x % image->columns),\n                (ssize_t) (y % image->rows),1,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              byte=(unsigned char) ReadBlobByte(image);\n              length--;\n              switch (channel)\n              {\n                case 0:\n                {\n                  SetPixelRed(q,ScaleCharToQuantum(byte));\n                  break;\n                }\n                case 1:\n                {\n                  SetPixelGreen(q,ScaleCharToQuantum(byte));\n                  break;\n                }\n                case 2:\n                {\n                  SetPixelBlue(q,ScaleCharToQuantum(byte));\n                  break;\n                }\n                case 3:\n                default:\n                {\n                  SetPixelAlpha(q,ScaleCharToQuantum(byte));\n                  break;\n                }\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              x++;\n              runlength++;\n            }\n            continue;\n          }\n        byte=(unsigned char) ReadBlobByte(image);\n        length--;\n        runlength++;\n        do\n        {\n          q=GetAuthenticPixels(image,(ssize_t) (x % image->columns),\n            (ssize_t) (y % image->rows),1,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          switch (channel)\n          {\n            case 0:\n            {\n              SetPixelRed(q,ScaleCharToQuantum(byte));\n              break;\n            }\n            case 1:\n            {\n              SetPixelGreen(q,ScaleCharToQuantum(byte));\n              break;\n            }\n            case 2:\n            {\n              SetPixelBlue(q,ScaleCharToQuantum(byte));\n              break;\n            }\n            case 3:\n            default:\n            {\n              SetPixelAlpha(q,ScaleCharToQuantum(byte));\n              break;\n            }\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          x++;\n          runlength--;\n        }\n        while (runlength > 0);\n      }\n    }\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  scanlines=(MagickOffsetType *) RelinquishMagickMemory(scanlines);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -200,7 +200,10 @@\n   {\n     offset=SeekBlob(image,scanlines[image->rows-y-1],SEEK_SET);\n     if (offset < 0)\n-      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+      {\n+        scanlines=(MagickOffsetType *) RelinquishMagickMemory(scanlines);\n+        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+      }\n     for (channel=0; channel < (int) rla_info.number_channels; channel++)\n     {\n       length=ReadBlobMSBSignedShort(image);",
        "diff_line_info": {
            "deleted_lines": [
                "      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");"
            ],
            "added_lines": [
                "      {",
                "        scanlines=(MagickOffsetType *) RelinquishMagickMemory(scanlines);",
                "        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-5358",
        "func_name": "ImageMagick/EncodeImageAttributes",
        "description": "ImageMagick 7.0.7-22 Q16 has memory leaks in the EncodeImageAttributes function in coders/json.c, as demonstrated by the ReadPSDLayersInternal function in coders/psd.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/ed80c93e4cbf2727ead75fd8bd5e5d9ecbe762f9",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/939",
        "commit_text": "",
        "func_before": "static MagickBooleanType EncodeImageAttributes(Image *image,FILE *file)\n{\n  char\n    format[MaxTextExtent],\n    key[MaxTextExtent];\n\n  ChannelFeatures\n    *channel_features;\n\n  ChannelMoments\n    *channel_moments;\n\n  ChannelPerceptualHash\n    *channel_phash;\n\n  ChannelStatistics\n    *channel_statistics;\n\n  const char\n    *artifact,\n    *locate,\n    *name,\n    *property,\n    *registry,\n    *value;\n\n  const MagickInfo\n    *magick_info;\n\n  double\n    elapsed_time,\n    user_time;\n\n  ExceptionInfo\n    *exception;\n\n  ImageType\n    type;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    depth,\n    distance,\n    scale;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (file == (FILE *) NULL)\n    file=stdout;\n  exception=AcquireExceptionInfo();\n  *format='\\0';\n  elapsed_time=GetElapsedTime(&image->timer);\n  user_time=GetUserTime(&image->timer);\n  GetTimerInfo(&image->timer);\n  (void) GetVirtualPixels(image,0,0,1,1,exception);\n  exception=DestroyExceptionInfo(exception);\n  exception=(&image->exception);\n  (void) SignatureImage(image);\n  JSONFormatLocaleFile(file,\"{\\n  \\\"image\\\": {\\n    \\\"name\\\": %s,\\n\",\n    image->filename);\n  if (*image->magick_filename != '\\0')\n    if (LocaleCompare(image->magick_filename,image->filename) != 0)\n      {\n        char\n          filename[MaxTextExtent];\n\n        GetPathComponent(image->magick_filename,TailPath,filename);\n        JSONFormatLocaleFile(file,\"    \\\"baseName\\\": %s,\\n\",filename);\n      }\n  magick_info=GetMagickInfo(image->magick,exception);\n  JSONFormatLocaleFile(file,\"    \\\"format\\\": %s,\\n\",image->magick);\n  if ((magick_info != (const MagickInfo *) NULL) &&\n      (GetMagickDescription(magick_info) != (const char *) NULL))\n    JSONFormatLocaleFile(file,\"    \\\"formatDescription\\\": %s,\\n\",\n      GetMagickDescription(magick_info));\n  if ((magick_info != (const MagickInfo *) NULL) &&\n      (GetMagickMimeType(magick_info) != (const char *) NULL))\n    JSONFormatLocaleFile(file,\"    \\\"mimeType\\\": %s,\\n\",\n      GetMagickMimeType(magick_info));\n  JSONFormatLocaleFile(file,\"    \\\"class\\\": %s,\\n\",CommandOptionToMnemonic(\n    MagickClassOptions,(ssize_t) image->storage_class));\n  (void) FormatLocaleFile(file,\"    \\\"geometry\\\": {\\n\"\n    \"      \\\"width\\\": %.20g,\\n      \\\"height\\\": %.20g,\\n\"\n    \"      \\\"x\\\": %.20g,\\n      \\\"y\\\": %.20g\\n    },\\n\",\n    (double) image->columns,(double) image->rows,(double) image->tile_offset.x,\n    (double) image->tile_offset.y);\n  if ((image->magick_columns != 0) || (image->magick_rows != 0))\n    if ((image->magick_columns != image->columns) ||\n        (image->magick_rows != image->rows))\n      (void) FormatLocaleFile(file,\"    \\\"baseGeometry\\\": {\\n\"\n        \"      \\\"width\\\": %g,\\n      \\\"height\\\": %g\\n    },\\n\",(double)\n        image->magick_columns,(double) image->magick_rows);\n  if ((image->x_resolution != 0.0) && (image->y_resolution != 0.0))\n    {\n      (void) FormatLocaleFile(file,\"    \\\"resolution\\\": {\\n\"\n        \"      \\\"x\\\": %g,\\n      \\\"y\\\": %g\\n    },\\n\",image->x_resolution,\n        image->y_resolution);\n      (void) FormatLocaleFile(file,\"    \\\"printSize\\\": {\\n\"\n        \"      \\\"x\\\": %.*g,\\n      \\\"y\\\": %.*g\\n    },\\n\",GetMagickPrecision(),\n        image->columns/image->x_resolution,GetMagickPrecision(),(double)\n        image->rows/image->y_resolution);\n    }\n  JSONFormatLocaleFile(file,\"    \\\"units\\\": %s,\\n\",CommandOptionToMnemonic(\n    MagickResolutionOptions,(ssize_t) image->units));\n  type=IdentifyImageType(image,exception);\n  JSONFormatLocaleFile(file,\"    \\\"type\\\": %s,\\n\",CommandOptionToMnemonic(\n    MagickTypeOptions,(ssize_t) type));\n  if (image->type != UndefinedType)\n    JSONFormatLocaleFile(file,\"    \\\"baseType\\\": %s,\\n\",\n      CommandOptionToMnemonic(MagickTypeOptions,(ssize_t) image->type));\n  JSONFormatLocaleFile(file,\"    \\\"endianess\\\": %s,\\n\",\n    CommandOptionToMnemonic(MagickEndianOptions,(ssize_t) image->endian));\n  locate=GetImageArtifact(image,\"identify:locate\");\n  if (locate == (const char *) NULL)\n    locate=GetImageArtifact(image,\"json:locate\");\n  if (locate != (const char *) NULL)\n    {\n      char\n        target[MaxTextExtent];\n\n      const char\n        *limit;\n\n      size_t\n        max_locations;\n\n      StatisticType\n        type;\n\n      /*\n        Display minimum, maximum, or mean pixel locations.\n      */\n      type=(StatisticType) ParseCommandOption(MagickStatisticOptions,\n        MagickFalse,locate);\n      max_locations=0;\n      limit=GetImageArtifact(image,\"identify:limit\");\n      if (limit == (const char *) NULL)\n        limit=GetImageArtifact(image,\"json:limit\");\n      if (limit != (const char *) NULL)\n        max_locations=StringToUnsignedLong(limit);\n      channel_statistics=GetLocationStatistics(image,type,exception);\n      if (channel_statistics == (ChannelStatistics *) NULL)\n        return(MagickFalse);\n      (void) CopyMagickString(target,locate,MaxTextExtent);\n      *target=(char) toupper((int) ((unsigned char) *target));\n      (void) FormatLocaleFile(file,\"    \\\"channel%s\\\": {\\n\",target);\n      if (image->matte != MagickFalse)\n        (void) PrintChannelLocations(file,image,AlphaChannel,\"alpha\",\n          type,max_locations,MagickTrue,channel_statistics);\n      switch (image->colorspace)\n      {\n        case RGBColorspace:\n        default:\n        {\n          (void) PrintChannelLocations(file,image,RedChannel,\"red\",\n            type,max_locations,MagickTrue,channel_statistics);\n          (void) PrintChannelLocations(file,image,GreenChannel,\"Green\",\n            type,max_locations,MagickTrue,channel_statistics);\n          (void) PrintChannelLocations(file,image,BlueChannel,\"blue\",\n            type,max_locations,MagickFalse,channel_statistics);\n          break;\n        }\n        case CMYKColorspace:\n        {\n          (void) PrintChannelLocations(file,image,CyanChannel,\"cyan\",\n            type,max_locations,MagickTrue,channel_statistics);\n          (void) PrintChannelLocations(file,image,MagentaChannel,\"magenta\",\n            type,max_locations,MagickTrue,channel_statistics);\n          (void) PrintChannelLocations(file,image,YellowChannel,\"yellow\",\n            type,max_locations,MagickTrue,channel_statistics);\n          (void) PrintChannelLocations(file,image,BlackChannel,\"black\",\n            type,max_locations,MagickFalse,channel_statistics);\n          break;\n        }\n        case LinearGRAYColorspace:\n        case GRAYColorspace:\n        {\n          (void) PrintChannelLocations(file,image,GrayChannel,\"gray\",\n            type,max_locations,MagickFalse,channel_statistics);\n          break;\n        }\n      }\n      (void) FormatLocaleFile(file,\"    },\\n\");\n      channel_statistics=(ChannelStatistics *) RelinquishMagickMemory(\n        channel_statistics);\n    }\n  /*\n    Detail channel depth and extrema.\n  */\n  JSONFormatLocaleFile(file,\"    \\\"colorspace\\\": %s,\\n\",\n    CommandOptionToMnemonic(MagickColorspaceOptions,(ssize_t)\n    image->colorspace));\n  channel_statistics=(ChannelStatistics *) NULL;\n  channel_moments=(ChannelMoments *) NULL;\n  channel_phash=(ChannelPerceptualHash *) NULL;\n  channel_features=(ChannelFeatures *) NULL;\n  scale=1;\n  channel_statistics=GetImageChannelStatistics(image,exception);\n  if (channel_statistics == (ChannelStatistics *) NULL)\n    return(MagickFalse);\n  artifact=GetImageArtifact(image,\"identify:moments\");\n  if (artifact == (const char *) NULL)\n    artifact=GetImageArtifact(image,\"json:moments\");\n  if (artifact != (const char *) NULL)\n    {\n      channel_moments=GetImageChannelMoments(image,exception);\n      channel_phash=GetImageChannelPerceptualHash(image,exception);\n    }\n  artifact=GetImageArtifact(image,\"identify:features\");\n  if (artifact == (const char *) NULL)\n    artifact=GetImageArtifact(image,\"json:features\");\n  if (artifact != (const char *) NULL)\n    {\n      distance=StringToUnsignedLong(artifact);\n      channel_features=GetImageChannelFeatures(image,distance,exception);\n    }\n  depth=GetImageDepth(image,exception);\n  (void) FormatLocaleFile(file,\"    \\\"depth\\\": %.20g,\\n\",(double) depth);\n  (void) FormatLocaleFile(file,\"    \\\"baseDepth\\\": %.20g,\\n\",(double)\n    image->depth);\n  (void) FormatLocaleFile(file,\"    \\\"channelDepth\\\": {\\n\");\n  if (image->matte != MagickFalse)\n    (void) FormatLocaleFile(file,\"      \\\"alpha\\\": %.20g,\\n\",(double)\n      channel_statistics[OpacityChannel].depth);\n  switch (image->colorspace)\n  {\n    case RGBColorspace:\n    default:\n    {\n      (void) FormatLocaleFile(file,\"      \\\"red\\\": %.20g,\\n\",(double)\n        channel_statistics[RedChannel].depth);\n      (void) FormatLocaleFile(file,\"      \\\"green\\\": %.20g,\\n\",(double)\n        channel_statistics[GreenChannel].depth);\n      (void) FormatLocaleFile(file,\"      \\\"blue\\\": %.20g\\n\",(double)\n        channel_statistics[BlueChannel].depth);\n      break;\n    }\n    case CMYKColorspace:\n    {\n      (void) FormatLocaleFile(file,\"      \\\"cyan\\\": %.20g,\\n\",(double)\n        channel_statistics[CyanChannel].depth);\n      (void) FormatLocaleFile(file,\"      \\\"magenta\\\": %.20g,\\n\",(double)\n        channel_statistics[MagentaChannel].depth);\n      (void) FormatLocaleFile(file,\"      \\\"yellow\\\": %.20g,\\n\",(double)\n        channel_statistics[YellowChannel].depth);\n      (void) FormatLocaleFile(file,\"      \\\"black\\\": %.20g\\n\",(double)\n        channel_statistics[BlackChannel].depth);\n      break;\n    }\n    case LinearGRAYColorspace:\n    case GRAYColorspace:\n    {\n      (void) FormatLocaleFile(file,\"      \\\"gray\\\": %.20g\\n\",(double)\n        channel_statistics[GrayChannel].depth);\n      break;\n    }\n  }\n  (void) FormatLocaleFile(file,\"    },\\n\");\n  scale=1;\n  if (image->depth <= MAGICKCORE_QUANTUM_DEPTH)\n    scale=QuantumRange/((size_t) QuantumRange >> ((size_t)\n      MAGICKCORE_QUANTUM_DEPTH-image->depth));\n  if (channel_statistics != (ChannelStatistics *) NULL)\n    {\n      (void) FormatLocaleFile(file,\"    \\\"pixels\\\": %.20g,\\n\",\n        (double) image->columns*image->rows);\n      if ((image->colorspace != LinearGRAYColorspace) &&\n          (image->colorspace != GRAYColorspace))\n        {\n          (void) FormatLocaleFile(file,\"    \\\"imageStatistics\\\": {\\n\");\n          (void) PrintChannelStatistics(file,CompositeChannels,\"all\",1.0/\n            scale,MagickFalse,channel_statistics);\n          (void) FormatLocaleFile(file,\"    },\\n\");\n        }\n      (void) FormatLocaleFile(file,\"    \\\"channelStatistics\\\": {\\n\");\n      if (image->matte != MagickFalse)\n        (void) PrintChannelStatistics(file,AlphaChannel,\"alpha\",1.0/scale,\n          MagickTrue,channel_statistics);\n      switch (image->colorspace)\n      {\n        case RGBColorspace:\n        default:\n        {\n          (void) PrintChannelStatistics(file,RedChannel,\"red\",1.0/scale,\n            MagickTrue,channel_statistics);\n          (void) PrintChannelStatistics(file,GreenChannel,\"green\",1.0/scale,\n            MagickTrue,channel_statistics);\n          (void) PrintChannelStatistics(file,BlueChannel,\"blue\",1.0/scale,\n            MagickFalse,channel_statistics);\n          break;\n        }\n        case CMYKColorspace:\n        {\n          (void) PrintChannelStatistics(file,CyanChannel,\"cyan\",1.0/scale,\n            MagickTrue,channel_statistics);\n          (void) PrintChannelStatistics(file,MagentaChannel,\"magenta\",1.0/scale,\n            MagickTrue,channel_statistics);\n          (void) PrintChannelStatistics(file,YellowChannel,\"yellow\",1.0/scale,\n            MagickTrue,channel_statistics);\n          (void) PrintChannelStatistics(file,BlackChannel,\"black\",1.0/scale,\n            MagickFalse,channel_statistics);\n          break;\n        }\n        case LinearGRAYColorspace:\n        case GRAYColorspace:\n        {\n          (void) PrintChannelStatistics(file,GrayChannel,\"gray\",1.0/scale,\n            MagickFalse,channel_statistics);\n          break;\n        }\n      }\n      (void) FormatLocaleFile(file,\"    },\\n\");\n      channel_statistics=(ChannelStatistics *) RelinquishMagickMemory(\n        channel_statistics);\n    }\n  if (channel_moments != (ChannelMoments *) NULL)\n    {\n      (void) FormatLocaleFile(file,\"    \\\"channelMoments\\\": {\\n\");\n      if (image->matte != MagickFalse)\n        (void) PrintChannelMoments(file,AlphaChannel,\"alpha\",MagickTrue,\n          channel_moments);\n      switch (image->colorspace)\n      {\n        case RGBColorspace:\n        default:\n        {\n          (void) PrintChannelMoments(file,RedChannel,\"red\",MagickTrue,\n            channel_moments);\n          (void) PrintChannelMoments(file,GreenChannel,\"green\",MagickTrue,\n            channel_moments);\n          (void) PrintChannelMoments(file,BlueChannel,\"blue\",MagickFalse,\n            channel_moments);\n          break;\n        }\n        case CMYKColorspace:\n        {\n          (void) PrintChannelMoments(file,CyanChannel,\"cyan\",MagickTrue,\n            channel_moments);\n          (void) PrintChannelMoments(file,MagentaChannel,\"magenta\",MagickTrue,\n            channel_moments);\n          (void) PrintChannelMoments(file,YellowChannel,\"yellow\",MagickTrue,\n            channel_moments);\n          (void) PrintChannelMoments(file,BlackChannel,\"black\",MagickFalse,\n            channel_moments);\n          break;\n        }\n        case LinearGRAYColorspace:\n        case GRAYColorspace:\n        {\n          (void) PrintChannelMoments(file,GrayChannel,\"gray\",MagickFalse,\n            channel_moments);\n          break;\n        }\n      }\n      (void) FormatLocaleFile(file,\"    },\\n\");\n      channel_moments=(ChannelMoments *) RelinquishMagickMemory(\n        channel_moments);\n    }\n  if (channel_phash != (ChannelPerceptualHash *) NULL)\n    {\n      (void) FormatLocaleFile(file,\"    \\\"channelPerceptualHash\\\": {\\n\");\n      if (image->matte != MagickFalse)\n        (void) PrintChannelPerceptualHash(file,AlphaChannel,\"alphaAlpha\",\n          MagickTrue,channel_phash);\n      (void) PrintChannelPerceptualHash(file,RedChannel,\"redHue\",MagickTrue,\n        channel_phash);\n      (void) PrintChannelPerceptualHash(file,GreenChannel,\"greenChroma\",\n        MagickTrue,channel_phash);\n      (void) PrintChannelPerceptualHash(file,BlueChannel,\"blueLuma\",MagickFalse,\n        channel_phash);\n      (void) FormatLocaleFile(file,\"    },\\n\");\n      channel_phash=(ChannelPerceptualHash *) RelinquishMagickMemory(\n        channel_phash);\n    }\n  if (channel_features != (ChannelFeatures *) NULL)\n    {\n      (void) FormatLocaleFile(file,\"    \\\"channelFeatures\\\": {\\n\");\n      if (image->matte != MagickFalse)\n        (void) PrintChannelFeatures(file,AlphaChannel,\"alpha\",MagickTrue,\n          channel_features);\n      switch (image->colorspace)\n      {\n        case RGBColorspace:\n        default:\n        {\n          (void) PrintChannelFeatures(file,RedChannel,\"red\",MagickTrue,\n            channel_features);\n          (void) PrintChannelFeatures(file,GreenChannel,\"green\",MagickTrue,\n            channel_features);\n          (void) PrintChannelFeatures(file,BlueChannel,\"blue\",MagickFalse,\n            channel_features);\n          break;\n        }\n        case CMYKColorspace:\n        {\n          (void) PrintChannelFeatures(file,CyanChannel,\"cyan\",MagickTrue,\n            channel_features);\n          (void) PrintChannelFeatures(file,MagentaChannel,\"magenta\",MagickTrue,\n            channel_features);\n          (void) PrintChannelFeatures(file,YellowChannel,\"yellow\",MagickTrue,\n            channel_features);\n          (void) PrintChannelFeatures(file,BlackChannel,\"black\",MagickFalse,\n            channel_features);\n          break;\n        }\n        case LinearGRAYColorspace:\n        case GRAYColorspace:\n        {\n          (void) PrintChannelFeatures(file,GrayChannel,\"gray\",MagickFalse,\n            channel_features);\n          break;\n        }\n      }\n      (void) FormatLocaleFile(file,\"    },\\n\");\n      channel_features=(ChannelFeatures *) RelinquishMagickMemory(\n        channel_features);\n    }\n  if (image->colorspace == CMYKColorspace)\n    (void) FormatLocaleFile(file,\"    \\\"totalInkDensity\\\": \\\"%.*g%%\\\",\\n\",\n      GetMagickPrecision(),100.0*GetImageTotalInkDensity(image)/(double)\n      QuantumRange);\n  x=0;\n  if (image->matte != MagickFalse)\n    {\n      register const IndexPacket\n        *indexes;\n\n      register const PixelPacket\n        *p;\n\n      p=(PixelPacket *) NULL;\n      indexes=(IndexPacket *) NULL;\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n        if (p == (const PixelPacket *) NULL)\n          break;\n        indexes=GetVirtualIndexQueue(image);\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          if (GetPixelOpacity(p) == (Quantum) TransparentOpacity)\n            break;\n          p++;\n        }\n        if (x < (ssize_t) image->columns)\n          break;\n      }\n      if ((x < (ssize_t) image->columns) || (y < (ssize_t) image->rows))\n        ColorFormatLocaleFile(file,\"    \\\"alpha\\\": \\\"%s\\\",\\n\",image,p,\n          indexes+x);\n    }\n  if (image->storage_class == PseudoClass)\n    {\n      register PixelPacket\n        *magick_restrict p;\n\n      (void) FormatLocaleFile(file,\"    \\\"colormapEntries\\\": %.20g,\\n\",\n        (double) image->colors);\n      (void) FormatLocaleFile(file,\"    \\\"colormap\\\": [\\n        \");\n      p=image->colormap;\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        ColorFormatLocaleFile(file,\"\\\"%s\\\"\",image,p,(IndexPacket *) NULL);\n        if (i < (ssize_t) (image->colors-1))\n          (void) FormatLocaleFile(file,\",\");\n        if (((i+1) % 5) == 0)\n          (void) FormatLocaleFile(file,\"\\n      \");\n        p++;\n      }\n      (void) FormatLocaleFile(file,\"\\n    ],\\n\");\n    }\n  if (image->error.mean_error_per_pixel != 0.0)\n    (void) FormatLocaleFile(file,\"    \\\"meanErrorPerPixel\\\": %g,\\n\",\n      image->error.mean_error_per_pixel);\n  if (image->error.normalized_mean_error != 0.0)\n    (void) FormatLocaleFile(file,\"    \\\"normalizedMeanError\\\": %g,\\n\",\n      image->error.normalized_mean_error);\n  if (image->error.normalized_maximum_error != 0.0)\n    (void) FormatLocaleFile(file,\"    \\\"normalizedMaximumError\\\": %g,\\n\",\n      image->error.normalized_maximum_error);\n  JSONFormatLocaleFile(file,\"    \\\"renderingIntent\\\": %s,\\n\",\n    CommandOptionToMnemonic(MagickIntentOptions,(ssize_t)\n    image->rendering_intent));\n  if (image->gamma != 0.0)\n    (void) FormatLocaleFile(file,\"    \\\"gamma\\\": %g,\\n\",image->gamma);\n  if ((image->chromaticity.red_primary.x != 0.0) ||\n      (image->chromaticity.green_primary.x != 0.0) ||\n      (image->chromaticity.blue_primary.x != 0.0) ||\n      (image->chromaticity.white_point.x != 0.0))\n    {\n      /*\n        Display image chromaticity.\n      */\n      (void) FormatLocaleFile(file,\"    \\\"chromaticity\\\": {\\n\");\n      (void) FormatLocaleFile(file,\"      \\\"redPrimary\\\": {\\n\"\n        \"        \\\"x\\\": %g,\\n        \\\"y\\\": %g\\n      },\\n\",\n        image->chromaticity.red_primary.x,image->chromaticity.red_primary.y);\n      (void) FormatLocaleFile(file,\"      \\\"greenPrimary\\\": {\\n\"\n        \"        \\\"x\\\": %g,\\n        \\\"y\\\": %g\\n      },\\n\",\n        image->chromaticity.green_primary.x,\n        image->chromaticity.green_primary.y);\n      (void) FormatLocaleFile(file,\"      \\\"bluePrimary\\\": {\\n\"\n        \"        \\\"x\\\": %g,\\n        \\\"y\\\": %g\\n      },\\n\",\n        image->chromaticity.blue_primary.x,image->chromaticity.blue_primary.y);\n      (void) FormatLocaleFile(file,\"      \\\"whitePrimary\\\": {\\n\"\n        \"        \\\"x\\\": %g,\\n        \\\"y\\\": %g\\n      }\\n\",\n        image->chromaticity.white_point.x,image->chromaticity.white_point.y);\n      (void) FormatLocaleFile(file,\"    },\\n\");\n    }\n  if ((image->extract_info.width*image->extract_info.height) != 0)\n    (void) FormatLocaleFile(file,\"    \\\"tileGeometry\\\": {\\n\"\n      \"      \\\"width\\\": %.20g,\\n      \\\"height\\\": %.20g,\\n\"\n      \"      \\\"x\\\": %.20g,\\n      \\\"y\\\": %.20g\\n    },\\n\",\n      (double) image->extract_info.width,(double) image->extract_info.height,\n      (double) image->extract_info.x,(double) image->extract_info.y);\n  ColorFormatLocaleFile(file,\"    \\\"backgroundColor\\\": \\\"%s\\\",\\n\",image,\n    &image->background_color,(IndexPacket *) NULL);\n  ColorFormatLocaleFile(file,\"    \\\"borderColor\\\": \\\"%s\\\",\\n\",image,\n    &image->border_color,(IndexPacket *) NULL);\n  ColorFormatLocaleFile(file,\"    \\\"matteColor\\\": \\\"%s\\\",\\n\",image,\n    &image->matte_color,(IndexPacket *) NULL);\n  ColorFormatLocaleFile(file,\"    \\\"transparentColor\\\": \\\"%s\\\",\\n\",image,\n    &image->transparent_color,(IndexPacket *) NULL);\n  JSONFormatLocaleFile(file,\"    \\\"interlace\\\": %s,\\n\",CommandOptionToMnemonic(\n    MagickInterlaceOptions,(ssize_t) image->interlace));\n  JSONFormatLocaleFile(file,\"    \\\"intensity\\\": %s,\\n\",CommandOptionToMnemonic(\n   MagickPixelIntensityOptions,(ssize_t)\n    image->intensity));\n  JSONFormatLocaleFile(file,\"    \\\"compose\\\": %s,\\n\",\n    CommandOptionToMnemonic(MagickComposeOptions,(ssize_t) image->compose));\n  if ((image->page.width != 0) || (image->page.height != 0) ||\n      (image->page.x != 0) || (image->page.y != 0))\n    (void) FormatLocaleFile(file,\"    \\\"pageGeometry\\\": {\\n\"\n      \"      \\\"width\\\": %.20g,\\n      \\\"height\\\": %.20g,\\n\"\n      \"      \\\"x\\\": %.20g,\\n      \\\"y\\\": %.20g\\n    },\\n\",\n      (double) image->page.width,(double) image->page.height,\n      (double) image->page.x,(double) image->page.y);\n  if ((image->page.x != 0) || (image->page.y != 0))\n    (void) FormatLocaleFile(file,\"    \\\"originGeometry\\\": %+.20g%+.20g,\\n\",\n      (double) image->page.x,(double) image->page.y);\n  JSONFormatLocaleFile(file,\"    \\\"dispose\\\": %s,\\n\",\n    CommandOptionToMnemonic(MagickDisposeOptions,(ssize_t) image->dispose));\n  if (image->delay != 0)\n    (void) FormatLocaleFile(file,\"    \\\"delay\\\": \\\"%.20gx%.20g\\\",\\n\",\n      (double) image->delay,(double) image->ticks_per_second);\n  if (image->iterations != 1)\n    (void) FormatLocaleFile(file,\"    \\\"iterations\\\": %.20g,\\n\",(double)\n      image->iterations);\n  if ((image->next != (Image *) NULL) || (image->previous != (Image *) NULL))\n    (void) FormatLocaleFile(file,\"    \\\"scene\\\": %.20g,\\n    \\\"scenes\\\": \"\n      \"%.20g,\\n\",(double) image->scene,(double) GetImageListLength(image));\n  else\n    if (image->scene != 0)\n      (void) FormatLocaleFile(file,\"    \\\"scene\\\": %.20g,\\n\",(double)\n        image->scene);\n  JSONFormatLocaleFile(file,\"    \\\"compression\\\": %s,\\n\",\n    CommandOptionToMnemonic(MagickCompressOptions,(ssize_t)\n    image->compression));\n  if (image->quality != UndefinedCompressionQuality)\n    (void) FormatLocaleFile(file,\"    \\\"quality\\\": %.20g,\\n\",(double)\n      image->quality);\n  JSONFormatLocaleFile(file,\"    \\\"orientation\\\": %s,\\n\",\n    CommandOptionToMnemonic(MagickOrientationOptions,(ssize_t)\n    image->orientation));\n  if (image->montage != (char *) NULL)\n    JSONFormatLocaleFile(file,\"    \\\"montage\\\": \\\"%s\\\",\\n\",image->montage);\n  if (image->directory != (char *) NULL)\n    {\n      Image\n        *tile;\n\n      ImageInfo\n        *image_info;\n\n      register char\n        *p,\n        *q;\n\n      WarningHandler\n        handler;\n\n      /*\n        Display visual image directory.\n      */\n      image_info=AcquireImageInfo();\n      (void) CloneString(&image_info->size,\"64x64\");\n      (void) FormatLocaleFile(file,\"    \\\"montageDirectory\\\": [\");\n      p=image->directory;\n      while (*p != '\\0')\n      {\n        q=p;\n        while ((*q != '\\n') && (*q != '\\0'))\n          q++;\n        (void) CopyMagickString(image_info->filename,p,(size_t) (q-p+1));\n        p=q+1;\n        JSONFormatLocaleFile(file,\"{\\n       \\\"name\\\": %s\",\n          image_info->filename);\n        handler=SetWarningHandler((WarningHandler) NULL);\n        tile=ReadImage(image_info,exception);\n        (void) SetWarningHandler(handler);\n        if (tile == (Image *) NULL)\n          {\n            (void) FormatLocaleFile(file,\"    }\");\n            continue;\n          }\n        (void) FormatLocaleFile(file,\",\\n       \\\"info\\\": \\\"%.20gx%.20g %s\\\"\",\n          (double) tile->magick_columns,(double) tile->magick_rows,\n          tile->magick);\n        (void) SignatureImage(tile);\n        ResetImagePropertyIterator(tile);\n        property=GetNextImageProperty(tile);\n        while (property != (const char *) NULL)\n        {\n          JSONFormatLocaleFile(file,\",\\n       %s: \",property);\n          value=GetImageProperty(tile,property);\n          JSONFormatLocaleFile(file,\"%s\",value);\n          property=GetNextImageProperty(tile);\n        }\n        tile=DestroyImage(tile);\n        if (*p != '\\0')\n          (void) FormatLocaleFile(file,\"\\n    },\");\n        else\n          (void) FormatLocaleFile(file,\"\\n    }\");\n      }\n      (void) FormatLocaleFile(file,\"],\\n\");\n      image_info=DestroyImageInfo(image_info);\n    }\n  (void) GetImageProperty(image,\"exif:*\");\n  (void) GetImageProperty(image,\"icc:*\");\n  (void) GetImageProperty(image,\"iptc:*\");\n  (void) GetImageProperty(image,\"xmp:*\");\n  ResetImagePropertyIterator(image);\n  property=GetNextImageProperty(image);\n  if (property != (const char *) NULL)\n    {\n      size_t\n        n;\n\n      /*\n        Display image properties.\n      */\n      n=0;\n      (void) FormatLocaleFile(file,\"    \\\"properties\\\": {\\n\");\n      while (property != (const char *) NULL)\n      {\n        if (n++ != 0)\n          (void) FormatLocaleFile(file,\",\\n\");\n        JSONFormatLocaleFile(file,\"      %s: \",property);\n        value=GetImageProperty(image,property);\n        JSONFormatLocaleFile(file,\"%s\",value);\n        property=GetNextImageProperty(image);\n      }\n      (void) FormatLocaleFile(file,\"\\n    },\\n\");\n    }\n  (void) FormatLocaleString(key,MaxTextExtent,\"8BIM:1999,2998:#1\");\n  value=GetImageProperty(image,key);\n  if (value != (const char *) NULL)\n    {\n      /*\n        Display clipping path.\n      */\n      JSONFormatLocaleFile(file,\"    \\\"clipping path\\\": %s,\\n\",value);\n    }\n  ResetImageProfileIterator(image);\n  name=GetNextImageProfile(image);\n  if (name != (char *) NULL)\n    {\n      const StringInfo\n        *profile;\n\n      size_t\n        n;\n\n      /*\n        Identify image profiles.\n      */\n      n=0;\n      (void) FormatLocaleFile(file,\"    \\\"profiles\\\": {\\n\");\n      while (name != (char *) NULL)\n      {\n        profile=GetImageProfile(image,name);\n        if (profile == (StringInfo *) NULL)\n          continue;\n        if (n++ != 0)\n          (void) FormatLocaleFile(file,\",\\n\");\n        JSONFormatLocaleFile(file,\"      %s: {\\n\",name);\n        if (LocaleCompare(name,\"iptc\") == 0)\n          EncodeIptcProfile(file,profile);\n        (void) FormatLocaleFile(file,\"        \\\"length\\\": %.20g\",(double)\n          GetStringInfoLength(profile));\n        (void) FormatLocaleFile(file,\"\\n      }\");\n        name=GetNextImageProfile(image);\n      }\n      (void) FormatLocaleFile(file,\"\\n    },\\n\");\n    }\n  ResetImageArtifactIterator(image);\n  artifact=GetNextImageArtifact(image);\n  if (artifact != (const char *) NULL)\n    {\n      ssize_t\n        n;\n\n      /*\n        Display image artifacts.\n      */\n      n=0;\n      (void) FormatLocaleFile(file,\"    \\\"artifacts\\\": {\\n\");\n      while (artifact != (const char *) NULL)\n      {\n        if (n++ != 0)\n          (void) FormatLocaleFile(file,\",\\n\");\n        JSONFormatLocaleFile(file,\"      %s: \",artifact);\n        value=GetImageArtifact(image,artifact);\n        JSONFormatLocaleFile(file,\"%s\",value);\n        artifact=GetNextImageArtifact(image);\n      }\n      (void) FormatLocaleFile(file,\"\\n    },\\n\");\n    }\n  ResetImageRegistryIterator();\n  registry=GetNextImageRegistry();\n  if (registry != (const char *) NULL)\n    {\n      ssize_t\n        n;\n\n      /*\n        Display image registry.\n      */\n      (void) FormatLocaleFile(file,\"    \\\"registry\\\": {\\n\");\n      n=0;\n      while (registry != (const char *) NULL)\n      {\n        if (n++ != 0)\n          (void) FormatLocaleFile(file,\",\\n\");\n        JSONFormatLocaleFile(file,\"      %s: \",registry);\n        value=(const char *) GetImageRegistry(StringRegistryType,registry,\n          exception);\n        JSONFormatLocaleFile(file,\"%s\",value);\n        registry=GetNextImageRegistry();\n      }\n      (void) FormatLocaleFile(file,\"    },\\n\");\n    }\n  (void) FormatLocaleFile(file,\"    \\\"tainted\\\": %s,\\n\",\n    image->taint != MagickFalse ? \"true\" : \"false\");\n  (void) FormatMagickSize(GetBlobSize(image),MagickFalse,format);\n  JSONFormatLocaleFile(file,\"    \\\"filesize\\\": %s,\\n\",format);\n  (void) FormatMagickSize((MagickSizeType) image->columns*image->rows,\n     MagickFalse,format);\n  if (strlen(format) > 1)\n    format[strlen(format)-1]='\\0';\n  JSONFormatLocaleFile(file,\"    \\\"numberPixels\\\": %s,\\n\",format);\n  (void) FormatMagickSize((MagickSizeType) ((double) image->columns*image->rows/\n    elapsed_time+0.5),MagickFalse,format);\n  JSONFormatLocaleFile(file,\"    \\\"pixelsPerSecond\\\": %s,\\n\",format);\n  (void) FormatLocaleFile(file,\"    \\\"userTime\\\": \\\"%0.3fu\\\",\\n\",user_time);\n  (void) FormatLocaleFile(file,\"    \\\"elapsedTime\\\": \\\"%lu:%02lu.%03lu\\\",\\n\",\n    (unsigned long) (elapsed_time/60.0),(unsigned long) ceil(fmod(\n    elapsed_time,60.0)),(unsigned long) (1000.0*(elapsed_time-floor(\n    elapsed_time))));\n  JSONFormatLocaleFile(file,\"    \\\"version\\\": %s\\n\",\n    GetMagickVersion((size_t *) NULL));\n  (void) FormatLocaleFile(file,\"  }\\n}\\n\");\n  (void) fflush(file);\n  return(ferror(file) != 0 ? MagickFalse : MagickTrue);\n}",
        "func": "static MagickBooleanType EncodeImageAttributes(Image *image,FILE *file)\n{\n  char\n    format[MaxTextExtent],\n    key[MaxTextExtent];\n\n  ChannelFeatures\n    *channel_features;\n\n  ChannelMoments\n    *channel_moments;\n\n  ChannelPerceptualHash\n    *channel_phash;\n\n  ChannelStatistics\n    *channel_statistics;\n\n  const char\n    *artifact,\n    *locate,\n    *name,\n    *property,\n    *registry,\n    *value;\n\n  const MagickInfo\n    *magick_info;\n\n  double\n    elapsed_time,\n    user_time;\n\n  ExceptionInfo\n    *exception;\n\n  ImageType\n    type;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    depth,\n    distance,\n    scale;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (file == (FILE *) NULL)\n    file=stdout;\n  exception=AcquireExceptionInfo();\n  *format='\\0';\n  elapsed_time=GetElapsedTime(&image->timer);\n  user_time=GetUserTime(&image->timer);\n  GetTimerInfo(&image->timer);\n  (void) GetVirtualPixels(image,0,0,1,1,exception);\n  exception=DestroyExceptionInfo(exception);\n  exception=(&image->exception);\n  (void) SignatureImage(image);\n  JSONFormatLocaleFile(file,\"{\\n  \\\"image\\\": {\\n    \\\"name\\\": %s,\\n\",\n    image->filename);\n  if (*image->magick_filename != '\\0')\n    if (LocaleCompare(image->magick_filename,image->filename) != 0)\n      {\n        char\n          filename[MaxTextExtent];\n\n        GetPathComponent(image->magick_filename,TailPath,filename);\n        JSONFormatLocaleFile(file,\"    \\\"baseName\\\": %s,\\n\",filename);\n      }\n  magick_info=GetMagickInfo(image->magick,exception);\n  JSONFormatLocaleFile(file,\"    \\\"format\\\": %s,\\n\",image->magick);\n  if ((magick_info != (const MagickInfo *) NULL) &&\n      (GetMagickDescription(magick_info) != (const char *) NULL))\n    JSONFormatLocaleFile(file,\"    \\\"formatDescription\\\": %s,\\n\",\n      GetMagickDescription(magick_info));\n  if ((magick_info != (const MagickInfo *) NULL) &&\n      (GetMagickMimeType(magick_info) != (const char *) NULL))\n    JSONFormatLocaleFile(file,\"    \\\"mimeType\\\": %s,\\n\",\n      GetMagickMimeType(magick_info));\n  JSONFormatLocaleFile(file,\"    \\\"class\\\": %s,\\n\",CommandOptionToMnemonic(\n    MagickClassOptions,(ssize_t) image->storage_class));\n  (void) FormatLocaleFile(file,\"    \\\"geometry\\\": {\\n\"\n    \"      \\\"width\\\": %.20g,\\n      \\\"height\\\": %.20g,\\n\"\n    \"      \\\"x\\\": %.20g,\\n      \\\"y\\\": %.20g\\n    },\\n\",\n    (double) image->columns,(double) image->rows,(double) image->tile_offset.x,\n    (double) image->tile_offset.y);\n  if ((image->magick_columns != 0) || (image->magick_rows != 0))\n    if ((image->magick_columns != image->columns) ||\n        (image->magick_rows != image->rows))\n      (void) FormatLocaleFile(file,\"    \\\"baseGeometry\\\": {\\n\"\n        \"      \\\"width\\\": %g,\\n      \\\"height\\\": %g\\n    },\\n\",(double)\n        image->magick_columns,(double) image->magick_rows);\n  if ((image->x_resolution != 0.0) && (image->y_resolution != 0.0))\n    {\n      (void) FormatLocaleFile(file,\"    \\\"resolution\\\": {\\n\"\n        \"      \\\"x\\\": %g,\\n      \\\"y\\\": %g\\n    },\\n\",image->x_resolution,\n        image->y_resolution);\n      (void) FormatLocaleFile(file,\"    \\\"printSize\\\": {\\n\"\n        \"      \\\"x\\\": %.*g,\\n      \\\"y\\\": %.*g\\n    },\\n\",GetMagickPrecision(),\n        image->columns/image->x_resolution,GetMagickPrecision(),(double)\n        image->rows/image->y_resolution);\n    }\n  JSONFormatLocaleFile(file,\"    \\\"units\\\": %s,\\n\",CommandOptionToMnemonic(\n    MagickResolutionOptions,(ssize_t) image->units));\n  type=IdentifyImageType(image,exception);\n  JSONFormatLocaleFile(file,\"    \\\"type\\\": %s,\\n\",CommandOptionToMnemonic(\n    MagickTypeOptions,(ssize_t) type));\n  if (image->type != UndefinedType)\n    JSONFormatLocaleFile(file,\"    \\\"baseType\\\": %s,\\n\",\n      CommandOptionToMnemonic(MagickTypeOptions,(ssize_t) image->type));\n  JSONFormatLocaleFile(file,\"    \\\"endianess\\\": %s,\\n\",\n    CommandOptionToMnemonic(MagickEndianOptions,(ssize_t) image->endian));\n  locate=GetImageArtifact(image,\"identify:locate\");\n  if (locate == (const char *) NULL)\n    locate=GetImageArtifact(image,\"json:locate\");\n  if (locate != (const char *) NULL)\n    {\n      char\n        target[MaxTextExtent];\n\n      const char\n        *limit;\n\n      size_t\n        max_locations;\n\n      StatisticType\n        type;\n\n      /*\n        Display minimum, maximum, or mean pixel locations.\n      */\n      type=(StatisticType) ParseCommandOption(MagickStatisticOptions,\n        MagickFalse,locate);\n      max_locations=0;\n      limit=GetImageArtifact(image,\"identify:limit\");\n      if (limit == (const char *) NULL)\n        limit=GetImageArtifact(image,\"json:limit\");\n      if (limit != (const char *) NULL)\n        max_locations=StringToUnsignedLong(limit);\n      channel_statistics=GetLocationStatistics(image,type,exception);\n      if (channel_statistics == (ChannelStatistics *) NULL)\n        return(MagickFalse);\n      (void) CopyMagickString(target,locate,MaxTextExtent);\n      *target=(char) toupper((int) ((unsigned char) *target));\n      (void) FormatLocaleFile(file,\"    \\\"channel%s\\\": {\\n\",target);\n      if (image->matte != MagickFalse)\n        (void) PrintChannelLocations(file,image,AlphaChannel,\"alpha\",\n          type,max_locations,MagickTrue,channel_statistics);\n      switch (image->colorspace)\n      {\n        case RGBColorspace:\n        default:\n        {\n          (void) PrintChannelLocations(file,image,RedChannel,\"red\",\n            type,max_locations,MagickTrue,channel_statistics);\n          (void) PrintChannelLocations(file,image,GreenChannel,\"Green\",\n            type,max_locations,MagickTrue,channel_statistics);\n          (void) PrintChannelLocations(file,image,BlueChannel,\"blue\",\n            type,max_locations,MagickFalse,channel_statistics);\n          break;\n        }\n        case CMYKColorspace:\n        {\n          (void) PrintChannelLocations(file,image,CyanChannel,\"cyan\",\n            type,max_locations,MagickTrue,channel_statistics);\n          (void) PrintChannelLocations(file,image,MagentaChannel,\"magenta\",\n            type,max_locations,MagickTrue,channel_statistics);\n          (void) PrintChannelLocations(file,image,YellowChannel,\"yellow\",\n            type,max_locations,MagickTrue,channel_statistics);\n          (void) PrintChannelLocations(file,image,BlackChannel,\"black\",\n            type,max_locations,MagickFalse,channel_statistics);\n          break;\n        }\n        case LinearGRAYColorspace:\n        case GRAYColorspace:\n        {\n          (void) PrintChannelLocations(file,image,GrayChannel,\"gray\",\n            type,max_locations,MagickFalse,channel_statistics);\n          break;\n        }\n      }\n      (void) FormatLocaleFile(file,\"    },\\n\");\n      channel_statistics=(ChannelStatistics *) RelinquishMagickMemory(\n        channel_statistics);\n    }\n  /*\n    Detail channel depth and extrema.\n  */\n  JSONFormatLocaleFile(file,\"    \\\"colorspace\\\": %s,\\n\",\n    CommandOptionToMnemonic(MagickColorspaceOptions,(ssize_t)\n    image->colorspace));\n  channel_statistics=(ChannelStatistics *) NULL;\n  channel_moments=(ChannelMoments *) NULL;\n  channel_phash=(ChannelPerceptualHash *) NULL;\n  channel_features=(ChannelFeatures *) NULL;\n  scale=1;\n  channel_statistics=GetImageChannelStatistics(image,exception);\n  if (channel_statistics == (ChannelStatistics *) NULL)\n    return(MagickFalse);\n  artifact=GetImageArtifact(image,\"identify:moments\");\n  if (artifact == (const char *) NULL)\n    artifact=GetImageArtifact(image,\"json:moments\");\n  if (artifact != (const char *) NULL)\n    {\n      channel_moments=GetImageChannelMoments(image,exception);\n      channel_phash=GetImageChannelPerceptualHash(image,exception);\n    }\n  artifact=GetImageArtifact(image,\"identify:features\");\n  if (artifact == (const char *) NULL)\n    artifact=GetImageArtifact(image,\"json:features\");\n  if (artifact != (const char *) NULL)\n    {\n      distance=StringToUnsignedLong(artifact);\n      channel_features=GetImageChannelFeatures(image,distance,exception);\n    }\n  depth=GetImageDepth(image,exception);\n  (void) FormatLocaleFile(file,\"    \\\"depth\\\": %.20g,\\n\",(double) depth);\n  (void) FormatLocaleFile(file,\"    \\\"baseDepth\\\": %.20g,\\n\",(double)\n    image->depth);\n  (void) FormatLocaleFile(file,\"    \\\"channelDepth\\\": {\\n\");\n  if (image->matte != MagickFalse)\n    (void) FormatLocaleFile(file,\"      \\\"alpha\\\": %.20g,\\n\",(double)\n      channel_statistics[OpacityChannel].depth);\n  switch (image->colorspace)\n  {\n    case RGBColorspace:\n    default:\n    {\n      (void) FormatLocaleFile(file,\"      \\\"red\\\": %.20g,\\n\",(double)\n        channel_statistics[RedChannel].depth);\n      (void) FormatLocaleFile(file,\"      \\\"green\\\": %.20g,\\n\",(double)\n        channel_statistics[GreenChannel].depth);\n      (void) FormatLocaleFile(file,\"      \\\"blue\\\": %.20g\\n\",(double)\n        channel_statistics[BlueChannel].depth);\n      break;\n    }\n    case CMYKColorspace:\n    {\n      (void) FormatLocaleFile(file,\"      \\\"cyan\\\": %.20g,\\n\",(double)\n        channel_statistics[CyanChannel].depth);\n      (void) FormatLocaleFile(file,\"      \\\"magenta\\\": %.20g,\\n\",(double)\n        channel_statistics[MagentaChannel].depth);\n      (void) FormatLocaleFile(file,\"      \\\"yellow\\\": %.20g,\\n\",(double)\n        channel_statistics[YellowChannel].depth);\n      (void) FormatLocaleFile(file,\"      \\\"black\\\": %.20g\\n\",(double)\n        channel_statistics[BlackChannel].depth);\n      break;\n    }\n    case LinearGRAYColorspace:\n    case GRAYColorspace:\n    {\n      (void) FormatLocaleFile(file,\"      \\\"gray\\\": %.20g\\n\",(double)\n        channel_statistics[GrayChannel].depth);\n      break;\n    }\n  }\n  (void) FormatLocaleFile(file,\"    },\\n\");\n  scale=1;\n  if (image->depth <= MAGICKCORE_QUANTUM_DEPTH)\n    scale=QuantumRange/((size_t) QuantumRange >> ((size_t)\n      MAGICKCORE_QUANTUM_DEPTH-image->depth));\n  if (channel_statistics != (ChannelStatistics *) NULL)\n    {\n      (void) FormatLocaleFile(file,\"    \\\"pixels\\\": %.20g,\\n\",\n        (double) image->columns*image->rows);\n      if ((image->colorspace != LinearGRAYColorspace) &&\n          (image->colorspace != GRAYColorspace))\n        {\n          (void) FormatLocaleFile(file,\"    \\\"imageStatistics\\\": {\\n\");\n          (void) PrintChannelStatistics(file,CompositeChannels,\"all\",1.0/\n            scale,MagickFalse,channel_statistics);\n          (void) FormatLocaleFile(file,\"    },\\n\");\n        }\n      (void) FormatLocaleFile(file,\"    \\\"channelStatistics\\\": {\\n\");\n      if (image->matte != MagickFalse)\n        (void) PrintChannelStatistics(file,AlphaChannel,\"alpha\",1.0/scale,\n          MagickTrue,channel_statistics);\n      switch (image->colorspace)\n      {\n        case RGBColorspace:\n        default:\n        {\n          (void) PrintChannelStatistics(file,RedChannel,\"red\",1.0/scale,\n            MagickTrue,channel_statistics);\n          (void) PrintChannelStatistics(file,GreenChannel,\"green\",1.0/scale,\n            MagickTrue,channel_statistics);\n          (void) PrintChannelStatistics(file,BlueChannel,\"blue\",1.0/scale,\n            MagickFalse,channel_statistics);\n          break;\n        }\n        case CMYKColorspace:\n        {\n          (void) PrintChannelStatistics(file,CyanChannel,\"cyan\",1.0/scale,\n            MagickTrue,channel_statistics);\n          (void) PrintChannelStatistics(file,MagentaChannel,\"magenta\",1.0/scale,\n            MagickTrue,channel_statistics);\n          (void) PrintChannelStatistics(file,YellowChannel,\"yellow\",1.0/scale,\n            MagickTrue,channel_statistics);\n          (void) PrintChannelStatistics(file,BlackChannel,\"black\",1.0/scale,\n            MagickFalse,channel_statistics);\n          break;\n        }\n        case LinearGRAYColorspace:\n        case GRAYColorspace:\n        {\n          (void) PrintChannelStatistics(file,GrayChannel,\"gray\",1.0/scale,\n            MagickFalse,channel_statistics);\n          break;\n        }\n      }\n      (void) FormatLocaleFile(file,\"    },\\n\");\n      channel_statistics=(ChannelStatistics *) RelinquishMagickMemory(\n        channel_statistics);\n    }\n  if (channel_moments != (ChannelMoments *) NULL)\n    {\n      (void) FormatLocaleFile(file,\"    \\\"channelMoments\\\": {\\n\");\n      if (image->matte != MagickFalse)\n        (void) PrintChannelMoments(file,AlphaChannel,\"alpha\",MagickTrue,\n          channel_moments);\n      switch (image->colorspace)\n      {\n        case RGBColorspace:\n        default:\n        {\n          (void) PrintChannelMoments(file,RedChannel,\"red\",MagickTrue,\n            channel_moments);\n          (void) PrintChannelMoments(file,GreenChannel,\"green\",MagickTrue,\n            channel_moments);\n          (void) PrintChannelMoments(file,BlueChannel,\"blue\",MagickFalse,\n            channel_moments);\n          break;\n        }\n        case CMYKColorspace:\n        {\n          (void) PrintChannelMoments(file,CyanChannel,\"cyan\",MagickTrue,\n            channel_moments);\n          (void) PrintChannelMoments(file,MagentaChannel,\"magenta\",MagickTrue,\n            channel_moments);\n          (void) PrintChannelMoments(file,YellowChannel,\"yellow\",MagickTrue,\n            channel_moments);\n          (void) PrintChannelMoments(file,BlackChannel,\"black\",MagickFalse,\n            channel_moments);\n          break;\n        }\n        case LinearGRAYColorspace:\n        case GRAYColorspace:\n        {\n          (void) PrintChannelMoments(file,GrayChannel,\"gray\",MagickFalse,\n            channel_moments);\n          break;\n        }\n      }\n      (void) FormatLocaleFile(file,\"    },\\n\");\n      channel_moments=(ChannelMoments *) RelinquishMagickMemory(\n        channel_moments);\n    }\n  if (channel_phash != (ChannelPerceptualHash *) NULL)\n    {\n      (void) FormatLocaleFile(file,\"    \\\"channelPerceptualHash\\\": {\\n\");\n      if (image->matte != MagickFalse)\n        (void) PrintChannelPerceptualHash(file,AlphaChannel,\"alphaAlpha\",\n          MagickTrue,channel_phash);\n      (void) PrintChannelPerceptualHash(file,RedChannel,\"redHue\",MagickTrue,\n        channel_phash);\n      (void) PrintChannelPerceptualHash(file,GreenChannel,\"greenChroma\",\n        MagickTrue,channel_phash);\n      (void) PrintChannelPerceptualHash(file,BlueChannel,\"blueLuma\",MagickFalse,\n        channel_phash);\n      (void) FormatLocaleFile(file,\"    },\\n\");\n      channel_phash=(ChannelPerceptualHash *) RelinquishMagickMemory(\n        channel_phash);\n    }\n  if (channel_features != (ChannelFeatures *) NULL)\n    {\n      (void) FormatLocaleFile(file,\"    \\\"channelFeatures\\\": {\\n\");\n      if (image->matte != MagickFalse)\n        (void) PrintChannelFeatures(file,AlphaChannel,\"alpha\",MagickTrue,\n          channel_features);\n      switch (image->colorspace)\n      {\n        case RGBColorspace:\n        default:\n        {\n          (void) PrintChannelFeatures(file,RedChannel,\"red\",MagickTrue,\n            channel_features);\n          (void) PrintChannelFeatures(file,GreenChannel,\"green\",MagickTrue,\n            channel_features);\n          (void) PrintChannelFeatures(file,BlueChannel,\"blue\",MagickFalse,\n            channel_features);\n          break;\n        }\n        case CMYKColorspace:\n        {\n          (void) PrintChannelFeatures(file,CyanChannel,\"cyan\",MagickTrue,\n            channel_features);\n          (void) PrintChannelFeatures(file,MagentaChannel,\"magenta\",MagickTrue,\n            channel_features);\n          (void) PrintChannelFeatures(file,YellowChannel,\"yellow\",MagickTrue,\n            channel_features);\n          (void) PrintChannelFeatures(file,BlackChannel,\"black\",MagickFalse,\n            channel_features);\n          break;\n        }\n        case LinearGRAYColorspace:\n        case GRAYColorspace:\n        {\n          (void) PrintChannelFeatures(file,GrayChannel,\"gray\",MagickFalse,\n            channel_features);\n          break;\n        }\n      }\n      (void) FormatLocaleFile(file,\"    },\\n\");\n      channel_features=(ChannelFeatures *) RelinquishMagickMemory(\n        channel_features);\n    }\n  if (image->colorspace == CMYKColorspace)\n    (void) FormatLocaleFile(file,\"    \\\"totalInkDensity\\\": \\\"%.*g%%\\\",\\n\",\n      GetMagickPrecision(),100.0*GetImageTotalInkDensity(image)/(double)\n      QuantumRange);\n  x=0;\n  if (image->matte != MagickFalse)\n    {\n      register const IndexPacket\n        *indexes;\n\n      register const PixelPacket\n        *p;\n\n      p=(PixelPacket *) NULL;\n      indexes=(IndexPacket *) NULL;\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n        if (p == (const PixelPacket *) NULL)\n          break;\n        indexes=GetVirtualIndexQueue(image);\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          if (GetPixelOpacity(p) == (Quantum) TransparentOpacity)\n            break;\n          p++;\n        }\n        if (x < (ssize_t) image->columns)\n          break;\n      }\n      if ((x < (ssize_t) image->columns) || (y < (ssize_t) image->rows))\n        ColorFormatLocaleFile(file,\"    \\\"alpha\\\": \\\"%s\\\",\\n\",image,p,\n          indexes+x);\n    }\n  if (image->storage_class == PseudoClass)\n    {\n      register PixelPacket\n        *magick_restrict p;\n\n      (void) FormatLocaleFile(file,\"    \\\"colormapEntries\\\": %.20g,\\n\",\n        (double) image->colors);\n      (void) FormatLocaleFile(file,\"    \\\"colormap\\\": [\\n        \");\n      p=image->colormap;\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        ColorFormatLocaleFile(file,\"\\\"%s\\\"\",image,p,(IndexPacket *) NULL);\n        if (i < (ssize_t) (image->colors-1))\n          (void) FormatLocaleFile(file,\",\");\n        if (((i+1) % 5) == 0)\n          (void) FormatLocaleFile(file,\"\\n      \");\n        p++;\n      }\n      (void) FormatLocaleFile(file,\"\\n    ],\\n\");\n    }\n  if (image->error.mean_error_per_pixel != 0.0)\n    (void) FormatLocaleFile(file,\"    \\\"meanErrorPerPixel\\\": %g,\\n\",\n      image->error.mean_error_per_pixel);\n  if (image->error.normalized_mean_error != 0.0)\n    (void) FormatLocaleFile(file,\"    \\\"normalizedMeanError\\\": %g,\\n\",\n      image->error.normalized_mean_error);\n  if (image->error.normalized_maximum_error != 0.0)\n    (void) FormatLocaleFile(file,\"    \\\"normalizedMaximumError\\\": %g,\\n\",\n      image->error.normalized_maximum_error);\n  JSONFormatLocaleFile(file,\"    \\\"renderingIntent\\\": %s,\\n\",\n    CommandOptionToMnemonic(MagickIntentOptions,(ssize_t)\n    image->rendering_intent));\n  if (image->gamma != 0.0)\n    (void) FormatLocaleFile(file,\"    \\\"gamma\\\": %g,\\n\",image->gamma);\n  if ((image->chromaticity.red_primary.x != 0.0) ||\n      (image->chromaticity.green_primary.x != 0.0) ||\n      (image->chromaticity.blue_primary.x != 0.0) ||\n      (image->chromaticity.white_point.x != 0.0))\n    {\n      /*\n        Display image chromaticity.\n      */\n      (void) FormatLocaleFile(file,\"    \\\"chromaticity\\\": {\\n\");\n      (void) FormatLocaleFile(file,\"      \\\"redPrimary\\\": {\\n\"\n        \"        \\\"x\\\": %g,\\n        \\\"y\\\": %g\\n      },\\n\",\n        image->chromaticity.red_primary.x,image->chromaticity.red_primary.y);\n      (void) FormatLocaleFile(file,\"      \\\"greenPrimary\\\": {\\n\"\n        \"        \\\"x\\\": %g,\\n        \\\"y\\\": %g\\n      },\\n\",\n        image->chromaticity.green_primary.x,\n        image->chromaticity.green_primary.y);\n      (void) FormatLocaleFile(file,\"      \\\"bluePrimary\\\": {\\n\"\n        \"        \\\"x\\\": %g,\\n        \\\"y\\\": %g\\n      },\\n\",\n        image->chromaticity.blue_primary.x,image->chromaticity.blue_primary.y);\n      (void) FormatLocaleFile(file,\"      \\\"whitePrimary\\\": {\\n\"\n        \"        \\\"x\\\": %g,\\n        \\\"y\\\": %g\\n      }\\n\",\n        image->chromaticity.white_point.x,image->chromaticity.white_point.y);\n      (void) FormatLocaleFile(file,\"    },\\n\");\n    }\n  if ((image->extract_info.width*image->extract_info.height) != 0)\n    (void) FormatLocaleFile(file,\"    \\\"tileGeometry\\\": {\\n\"\n      \"      \\\"width\\\": %.20g,\\n      \\\"height\\\": %.20g,\\n\"\n      \"      \\\"x\\\": %.20g,\\n      \\\"y\\\": %.20g\\n    },\\n\",\n      (double) image->extract_info.width,(double) image->extract_info.height,\n      (double) image->extract_info.x,(double) image->extract_info.y);\n  ColorFormatLocaleFile(file,\"    \\\"backgroundColor\\\": \\\"%s\\\",\\n\",image,\n    &image->background_color,(IndexPacket *) NULL);\n  ColorFormatLocaleFile(file,\"    \\\"borderColor\\\": \\\"%s\\\",\\n\",image,\n    &image->border_color,(IndexPacket *) NULL);\n  ColorFormatLocaleFile(file,\"    \\\"matteColor\\\": \\\"%s\\\",\\n\",image,\n    &image->matte_color,(IndexPacket *) NULL);\n  ColorFormatLocaleFile(file,\"    \\\"transparentColor\\\": \\\"%s\\\",\\n\",image,\n    &image->transparent_color,(IndexPacket *) NULL);\n  JSONFormatLocaleFile(file,\"    \\\"interlace\\\": %s,\\n\",CommandOptionToMnemonic(\n    MagickInterlaceOptions,(ssize_t) image->interlace));\n  JSONFormatLocaleFile(file,\"    \\\"intensity\\\": %s,\\n\",CommandOptionToMnemonic(\n   MagickPixelIntensityOptions,(ssize_t)\n    image->intensity));\n  JSONFormatLocaleFile(file,\"    \\\"compose\\\": %s,\\n\",\n    CommandOptionToMnemonic(MagickComposeOptions,(ssize_t) image->compose));\n  if ((image->page.width != 0) || (image->page.height != 0) ||\n      (image->page.x != 0) || (image->page.y != 0))\n    (void) FormatLocaleFile(file,\"    \\\"pageGeometry\\\": {\\n\"\n      \"      \\\"width\\\": %.20g,\\n      \\\"height\\\": %.20g,\\n\"\n      \"      \\\"x\\\": %.20g,\\n      \\\"y\\\": %.20g\\n    },\\n\",\n      (double) image->page.width,(double) image->page.height,\n      (double) image->page.x,(double) image->page.y);\n  if ((image->page.x != 0) || (image->page.y != 0))\n    (void) FormatLocaleFile(file,\"    \\\"originGeometry\\\": %+.20g%+.20g,\\n\",\n      (double) image->page.x,(double) image->page.y);\n  JSONFormatLocaleFile(file,\"    \\\"dispose\\\": %s,\\n\",\n    CommandOptionToMnemonic(MagickDisposeOptions,(ssize_t) image->dispose));\n  if (image->delay != 0)\n    (void) FormatLocaleFile(file,\"    \\\"delay\\\": \\\"%.20gx%.20g\\\",\\n\",\n      (double) image->delay,(double) image->ticks_per_second);\n  if (image->iterations != 1)\n    (void) FormatLocaleFile(file,\"    \\\"iterations\\\": %.20g,\\n\",(double)\n      image->iterations);\n  if ((image->next != (Image *) NULL) || (image->previous != (Image *) NULL))\n    (void) FormatLocaleFile(file,\"    \\\"scene\\\": %.20g,\\n    \\\"scenes\\\": \"\n      \"%.20g,\\n\",(double) image->scene,(double) GetImageListLength(image));\n  else\n    if (image->scene != 0)\n      (void) FormatLocaleFile(file,\"    \\\"scene\\\": %.20g,\\n\",(double)\n        image->scene);\n  JSONFormatLocaleFile(file,\"    \\\"compression\\\": %s,\\n\",\n    CommandOptionToMnemonic(MagickCompressOptions,(ssize_t)\n    image->compression));\n  if (image->quality != UndefinedCompressionQuality)\n    (void) FormatLocaleFile(file,\"    \\\"quality\\\": %.20g,\\n\",(double)\n      image->quality);\n  JSONFormatLocaleFile(file,\"    \\\"orientation\\\": %s,\\n\",\n    CommandOptionToMnemonic(MagickOrientationOptions,(ssize_t)\n    image->orientation));\n  if (image->montage != (char *) NULL)\n    JSONFormatLocaleFile(file,\"    \\\"montage\\\": \\\"%s\\\",\\n\",image->montage);\n  if (image->directory != (char *) NULL)\n    {\n      Image\n        *tile;\n\n      ImageInfo\n        *image_info;\n\n      register char\n        *p,\n        *q;\n\n      WarningHandler\n        handler;\n\n      /*\n        Display visual image directory.\n      */\n      image_info=AcquireImageInfo();\n      (void) CloneString(&image_info->size,\"64x64\");\n      (void) FormatLocaleFile(file,\"    \\\"montageDirectory\\\": [\");\n      p=image->directory;\n      while (*p != '\\0')\n      {\n        q=p;\n        while ((*q != '\\n') && (*q != '\\0'))\n          q++;\n        (void) CopyMagickString(image_info->filename,p,(size_t) (q-p+1));\n        p=q+1;\n        JSONFormatLocaleFile(file,\"{\\n       \\\"name\\\": %s\",\n          image_info->filename);\n        handler=SetWarningHandler((WarningHandler) NULL);\n        tile=ReadImage(image_info,exception);\n        (void) SetWarningHandler(handler);\n        if (tile == (Image *) NULL)\n          {\n            (void) FormatLocaleFile(file,\"    }\");\n            continue;\n          }\n        (void) FormatLocaleFile(file,\",\\n       \\\"info\\\": \\\"%.20gx%.20g %s\\\"\",\n          (double) tile->magick_columns,(double) tile->magick_rows,\n          tile->magick);\n        (void) SignatureImage(tile);\n        ResetImagePropertyIterator(tile);\n        property=GetNextImageProperty(tile);\n        while (property != (const char *) NULL)\n        {\n          JSONFormatLocaleFile(file,\",\\n       %s: \",property);\n          value=GetImageProperty(tile,property);\n          JSONFormatLocaleFile(file,\"%s\",value);\n          property=GetNextImageProperty(tile);\n        }\n        tile=DestroyImageList(tile);\n        if (*p != '\\0')\n          (void) FormatLocaleFile(file,\"\\n    },\");\n        else\n          (void) FormatLocaleFile(file,\"\\n    }\");\n      }\n      (void) FormatLocaleFile(file,\"],\\n\");\n      image_info=DestroyImageInfo(image_info);\n    }\n  (void) GetImageProperty(image,\"exif:*\");\n  (void) GetImageProperty(image,\"icc:*\");\n  (void) GetImageProperty(image,\"iptc:*\");\n  (void) GetImageProperty(image,\"xmp:*\");\n  ResetImagePropertyIterator(image);\n  property=GetNextImageProperty(image);\n  if (property != (const char *) NULL)\n    {\n      size_t\n        n;\n\n      /*\n        Display image properties.\n      */\n      n=0;\n      (void) FormatLocaleFile(file,\"    \\\"properties\\\": {\\n\");\n      while (property != (const char *) NULL)\n      {\n        if (n++ != 0)\n          (void) FormatLocaleFile(file,\",\\n\");\n        JSONFormatLocaleFile(file,\"      %s: \",property);\n        value=GetImageProperty(image,property);\n        JSONFormatLocaleFile(file,\"%s\",value);\n        property=GetNextImageProperty(image);\n      }\n      (void) FormatLocaleFile(file,\"\\n    },\\n\");\n    }\n  (void) FormatLocaleString(key,MaxTextExtent,\"8BIM:1999,2998:#1\");\n  value=GetImageProperty(image,key);\n  if (value != (const char *) NULL)\n    {\n      /*\n        Display clipping path.\n      */\n      JSONFormatLocaleFile(file,\"    \\\"clipping path\\\": %s,\\n\",value);\n    }\n  ResetImageProfileIterator(image);\n  name=GetNextImageProfile(image);\n  if (name != (char *) NULL)\n    {\n      const StringInfo\n        *profile;\n\n      size_t\n        n;\n\n      /*\n        Identify image profiles.\n      */\n      n=0;\n      (void) FormatLocaleFile(file,\"    \\\"profiles\\\": {\\n\");\n      while (name != (char *) NULL)\n      {\n        profile=GetImageProfile(image,name);\n        if (profile == (StringInfo *) NULL)\n          continue;\n        if (n++ != 0)\n          (void) FormatLocaleFile(file,\",\\n\");\n        JSONFormatLocaleFile(file,\"      %s: {\\n\",name);\n        if (LocaleCompare(name,\"iptc\") == 0)\n          EncodeIptcProfile(file,profile);\n        (void) FormatLocaleFile(file,\"        \\\"length\\\": %.20g\",(double)\n          GetStringInfoLength(profile));\n        (void) FormatLocaleFile(file,\"\\n      }\");\n        name=GetNextImageProfile(image);\n      }\n      (void) FormatLocaleFile(file,\"\\n    },\\n\");\n    }\n  ResetImageArtifactIterator(image);\n  artifact=GetNextImageArtifact(image);\n  if (artifact != (const char *) NULL)\n    {\n      ssize_t\n        n;\n\n      /*\n        Display image artifacts.\n      */\n      n=0;\n      (void) FormatLocaleFile(file,\"    \\\"artifacts\\\": {\\n\");\n      while (artifact != (const char *) NULL)\n      {\n        if (n++ != 0)\n          (void) FormatLocaleFile(file,\",\\n\");\n        JSONFormatLocaleFile(file,\"      %s: \",artifact);\n        value=GetImageArtifact(image,artifact);\n        JSONFormatLocaleFile(file,\"%s\",value);\n        artifact=GetNextImageArtifact(image);\n      }\n      (void) FormatLocaleFile(file,\"\\n    },\\n\");\n    }\n  ResetImageRegistryIterator();\n  registry=GetNextImageRegistry();\n  if (registry != (const char *) NULL)\n    {\n      ssize_t\n        n;\n\n      /*\n        Display image registry.\n      */\n      (void) FormatLocaleFile(file,\"    \\\"registry\\\": {\\n\");\n      n=0;\n      while (registry != (const char *) NULL)\n      {\n        if (n++ != 0)\n          (void) FormatLocaleFile(file,\",\\n\");\n        JSONFormatLocaleFile(file,\"      %s: \",registry);\n        value=(const char *) GetImageRegistry(StringRegistryType,registry,\n          exception);\n        JSONFormatLocaleFile(file,\"%s\",value);\n        registry=GetNextImageRegistry();\n      }\n      (void) FormatLocaleFile(file,\"    },\\n\");\n    }\n  (void) FormatLocaleFile(file,\"    \\\"tainted\\\": %s,\\n\",\n    image->taint != MagickFalse ? \"true\" : \"false\");\n  (void) FormatMagickSize(GetBlobSize(image),MagickFalse,format);\n  JSONFormatLocaleFile(file,\"    \\\"filesize\\\": %s,\\n\",format);\n  (void) FormatMagickSize((MagickSizeType) image->columns*image->rows,\n     MagickFalse,format);\n  if (strlen(format) > 1)\n    format[strlen(format)-1]='\\0';\n  JSONFormatLocaleFile(file,\"    \\\"numberPixels\\\": %s,\\n\",format);\n  (void) FormatMagickSize((MagickSizeType) ((double) image->columns*image->rows/\n    elapsed_time+0.5),MagickFalse,format);\n  JSONFormatLocaleFile(file,\"    \\\"pixelsPerSecond\\\": %s,\\n\",format);\n  (void) FormatLocaleFile(file,\"    \\\"userTime\\\": \\\"%0.3fu\\\",\\n\",user_time);\n  (void) FormatLocaleFile(file,\"    \\\"elapsedTime\\\": \\\"%lu:%02lu.%03lu\\\",\\n\",\n    (unsigned long) (elapsed_time/60.0),(unsigned long) ceil(fmod(\n    elapsed_time,60.0)),(unsigned long) (1000.0*(elapsed_time-floor(\n    elapsed_time))));\n  JSONFormatLocaleFile(file,\"    \\\"version\\\": %s\\n\",\n    GetMagickVersion((size_t *) NULL));\n  (void) FormatLocaleFile(file,\"  }\\n}\\n\");\n  (void) fflush(file);\n  return(ferror(file) != 0 ? MagickFalse : MagickTrue);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -624,7 +624,7 @@\n           JSONFormatLocaleFile(file,\"%s\",value);\n           property=GetNextImageProperty(tile);\n         }\n-        tile=DestroyImage(tile);\n+        tile=DestroyImageList(tile);\n         if (*p != '\\0')\n           (void) FormatLocaleFile(file,\"\\n    },\");\n         else",
        "diff_line_info": {
            "deleted_lines": [
                "        tile=DestroyImage(tile);"
            ],
            "added_lines": [
                "        tile=DestroyImageList(tile);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-18027",
        "func_name": "ImageMagick/ReadMATImage",
        "description": "In ImageMagick 7.0.7-1 Q16, a memory leak vulnerability was found in the function ReadMATImage in coders/mat.c, which allow remote attackers to cause a denial of service via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/6a88a234cbb88a06fcb7e7ebe6668267b72fa787",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/734",
        "commit_text": "",
        "func_before": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if (MATLAB_HDR.DataType!=miMATRIX)\n      {\n        clone_info=DestroyImageInfo(clone_info);\n        continue;  /* skip another objects. */\n      }\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default:\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          if (tmp == image2)\n            image2=(Image *) NULL;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if ((image != image2) && (image2 != (Image *) NULL))\n    image2=DestroyImage(image2);\n  if (image == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  return(image); \n}",
        "func": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n  image2 = (Image *) NULL;\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if (MATLAB_HDR.DataType!=miMATRIX)\n      {\n        clone_info=DestroyImageInfo(clone_info);\n        continue;  /* skip another objects. */\n      }\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default:\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          if (tmp == image2)\n            image2=(Image *) NULL;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if ((image != image2) && (image2 != (Image *) NULL))\n    image2=DestroyImage(image2);\n  if (image == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  return(image); \n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -40,6 +40,7 @@\n    */\n   quantum_info=(QuantumInfo *) NULL;\n   image = AcquireImage(image_info);\n+  image2 = (Image *) NULL;\n \n   status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n   if (status == MagickFalse)\n@@ -112,6 +113,8 @@\n     filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n \n     clone_info=CloneImageInfo(image_info);\n+    if ((image != image2) && (image2 != (Image *) NULL))\n+      image2=DestroyImage(image2);\n     image2 = image;\n #if defined(MAGICKCORE_ZLIB_DELEGATE)\n     if(MATLAB_HDR.DataType == miCOMPRESSED)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  image2 = (Image *) NULL;",
                "    if ((image != image2) && (image2 != (Image *) NULL))",
                "      image2=DestroyImage(image2);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-18029",
        "func_name": "ImageMagick/ReadMATImage",
        "description": "In ImageMagick 7.0.6-10 Q16, a memory leak vulnerability was found in the function ReadMATImage in coders/mat.c, which allow remote attackers to cause a denial of service via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/d3144a8be81aed6e635de68f0d8e97881638a398",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/691",
        "commit_text": "",
        "func_before": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  register Quantum *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info,exception);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  clone_info=(ImageInfo *) NULL;\n  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if (MATLAB_HDR.DataType!=miMATRIX)\n      {\n        clone_info=DestroyImageInfo(clone_info);\n        continue;  /* skip another objects. */\n      }\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           (void) ReadBlobXXXLong(image2);\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default:\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\n    NEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n    /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        image->type=GrayscaleType;\n        SetImageColorspace(image,GRAYColorspace,exception);\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      {\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(image,q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n            exception);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n            exception);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image,exception);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n        }\n\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          if (tmp == image2)\n            image2=(Image *) NULL;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if (image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  else\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n  return (image);\n}",
        "func": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  register Quantum *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info,exception);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  clone_info=(ImageInfo *) NULL;\n  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if (MATLAB_HDR.DataType!=miMATRIX)\n      {\n        clone_info=DestroyImageInfo(clone_info);\n        continue;  /* skip another objects. */\n      }\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           (void) ReadBlobXXXLong(image2);\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default:\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\n    NEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n    /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        image->type=GrayscaleType;\n        SetImageColorspace(image,GRAYColorspace,exception);\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      {\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(image,q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n            exception);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n            exception);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image,exception);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n        }\n\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          if (tmp == image2)\n            image2=(Image *) NULL;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if ((image != image2) && (image2 != (Image *) NULL))\n    image2=DestroyImage(image2);\n  if (image == (Image *) NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  return(image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -531,10 +531,9 @@\n     clone_info = NULL;\n   }\n   if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n-  if (image==NULL)\n+  if ((image != image2) && (image2 != (Image *) NULL))\n+    image2=DestroyImage(image2);\n+  if (image == (Image *) NULL)\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n-  else\n-    if ((image != image2) && (image2 != (Image *) NULL))\n-      image2=DestroyImage(image2);\n-  return (image);\n+  return(image);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  if (image==NULL)",
                "  else",
                "    if ((image != image2) && (image2 != (Image *) NULL))",
                "      image2=DestroyImage(image2);",
                "  return (image);"
            ],
            "added_lines": [
                "  if ((image != image2) && (image2 != (Image *) NULL))",
                "    image2=DestroyImage(image2);",
                "  if (image == (Image *) NULL)",
                "  return(image);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-15132",
        "func_name": "dovecot/core/auth_client_request_abort",
        "description": "A flaw was found in dovecot 2.0 up to 2.2.33 and 2.3.0. An abort of SASL authentication results in a memory leak in dovecot's auth client used by login processes. The leak has impact in high performance configuration where same login processes are reused and can cause the process to crash due to memory exhaustion.",
        "git_url": "https://github.com/dovecot/core/commit/1a29ed2f96da1be22fa5a4d96c7583aa81b8b060",
        "commit_title": "lib-auth: Fix memory leak in auth_client_request_abort()",
        "commit_text": " This caused memory leaks when authentication was aborted. For example with IMAP:  a AUTHENTICATE PLAIN *  Broken by 9137c55411aa39d41c1e705ddc34d5bd26c65021",
        "func_before": "void auth_client_request_abort(struct auth_client_request **_request)\n{\n\tstruct auth_client_request *request = *_request;\n\n\t*_request = NULL;\n\n\tauth_client_send_cancel(request->conn->client, request->id);\n\tcall_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL);\n}",
        "func": "void auth_client_request_abort(struct auth_client_request **_request)\n{\n\tstruct auth_client_request *request = *_request;\n\n\t*_request = NULL;\n\n\tauth_client_send_cancel(request->conn->client, request->id);\n\tcall_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL);\n\tpool_unref(&request->pool);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,4 +6,5 @@\n \n \tauth_client_send_cancel(request->conn->client, request->id);\n \tcall_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL);\n+\tpool_unref(&request->pool);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tpool_unref(&request->pool);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-26353",
        "func_name": "qemu-project/qemu/virtio_net_receive_rcu",
        "description": "A flaw was found in the virtio-net device of QEMU. This flaw was inadvertently introduced with the fix for CVE-2021-3748, which forgot to unmap the cached virtqueue elements on error, leading to memory leakage and other unexpected results. Affected QEMU version: 6.2.0.",
        "git_url": "https://gitlab.com/qemu-project/qemu/-/commit/abe300d9d894f7138e1af7c8e9c88c04bfe98b37",
        "commit_title": "virtio-net: fix map leaking on error during receive",
        "commit_text": " Commit bedd7e93d0196 (\"virtio-net: fix use after unmap/free for sg\") tries to fix the use after free of the sg by caching the virtqueue elements in an array and unmap them at once after receiving the packets, But it forgot to unmap the cached elements on error which will lead to leaking of mapping and other unexpected results.  Fixing this by detaching the cached elements on error. This addresses CVE-2022-26353.  Cc: qemu-stable@nongnu.org ",
        "func_before": "static ssize_t virtio_net_receive_rcu(NetClientState *nc, const uint8_t *buf,\n                                      size_t size, bool no_rss)\n{\n    VirtIONet *n = qemu_get_nic_opaque(nc);\n    VirtIONetQueue *q = virtio_net_get_subqueue(nc);\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    VirtQueueElement *elems[VIRTQUEUE_MAX_SIZE];\n    size_t lens[VIRTQUEUE_MAX_SIZE];\n    struct iovec mhdr_sg[VIRTQUEUE_MAX_SIZE];\n    struct virtio_net_hdr_mrg_rxbuf mhdr;\n    unsigned mhdr_cnt = 0;\n    size_t offset, i, guest_offset, j;\n    ssize_t err;\n\n    if (!virtio_net_can_receive(nc)) {\n        return -1;\n    }\n\n    if (!no_rss && n->rss_data.enabled && n->rss_data.enabled_software_rss) {\n        int index = virtio_net_process_rss(nc, buf, size);\n        if (index >= 0) {\n            NetClientState *nc2 = qemu_get_subqueue(n->nic, index);\n            return virtio_net_receive_rcu(nc2, buf, size, true);\n        }\n    }\n\n    /* hdr_len refers to the header we supply to the guest */\n    if (!virtio_net_has_buffers(q, size + n->guest_hdr_len - n->host_hdr_len)) {\n        return 0;\n    }\n\n    if (!receive_filter(n, buf, size))\n        return size;\n\n    offset = i = 0;\n\n    while (offset < size) {\n        VirtQueueElement *elem;\n        int len, total;\n        const struct iovec *sg;\n\n        total = 0;\n\n        if (i == VIRTQUEUE_MAX_SIZE) {\n            virtio_error(vdev, \"virtio-net unexpected long buffer chain\");\n            err = size;\n            goto err;\n        }\n\n        elem = virtqueue_pop(q->rx_vq, sizeof(VirtQueueElement));\n        if (!elem) {\n            if (i) {\n                virtio_error(vdev, \"virtio-net unexpected empty queue: \"\n                             \"i %zd mergeable %d offset %zd, size %zd, \"\n                             \"guest hdr len %zd, host hdr len %zd \"\n                             \"guest features 0x%\" PRIx64,\n                             i, n->mergeable_rx_bufs, offset, size,\n                             n->guest_hdr_len, n->host_hdr_len,\n                             vdev->guest_features);\n            }\n            err = -1;\n            goto err;\n        }\n\n        if (elem->in_num < 1) {\n            virtio_error(vdev,\n                         \"virtio-net receive queue contains no in buffers\");\n            virtqueue_detach_element(q->rx_vq, elem, 0);\n            g_free(elem);\n            err = -1;\n            goto err;\n        }\n\n        sg = elem->in_sg;\n        if (i == 0) {\n            assert(offset == 0);\n            if (n->mergeable_rx_bufs) {\n                mhdr_cnt = iov_copy(mhdr_sg, ARRAY_SIZE(mhdr_sg),\n                                    sg, elem->in_num,\n                                    offsetof(typeof(mhdr), num_buffers),\n                                    sizeof(mhdr.num_buffers));\n            }\n\n            receive_header(n, sg, elem->in_num, buf, size);\n            if (n->rss_data.populate_hash) {\n                offset = sizeof(mhdr);\n                iov_from_buf(sg, elem->in_num, offset,\n                             buf + offset, n->host_hdr_len - sizeof(mhdr));\n            }\n            offset = n->host_hdr_len;\n            total += n->guest_hdr_len;\n            guest_offset = n->guest_hdr_len;\n        } else {\n            guest_offset = 0;\n        }\n\n        /* copy in packet.  ugh */\n        len = iov_from_buf(sg, elem->in_num, guest_offset,\n                           buf + offset, size - offset);\n        total += len;\n        offset += len;\n        /* If buffers can't be merged, at this point we\n         * must have consumed the complete packet.\n         * Otherwise, drop it. */\n        if (!n->mergeable_rx_bufs && offset < size) {\n            virtqueue_unpop(q->rx_vq, elem, total);\n            g_free(elem);\n            err = size;\n            goto err;\n        }\n\n        elems[i] = elem;\n        lens[i] = total;\n        i++;\n    }\n\n    if (mhdr_cnt) {\n        virtio_stw_p(vdev, &mhdr.num_buffers, i);\n        iov_from_buf(mhdr_sg, mhdr_cnt,\n                     0,\n                     &mhdr.num_buffers, sizeof mhdr.num_buffers);\n    }\n\n    for (j = 0; j < i; j++) {\n        /* signal other side */\n        virtqueue_fill(q->rx_vq, elems[j], lens[j], j);\n        g_free(elems[j]);\n    }\n\n    virtqueue_flush(q->rx_vq, i);\n    virtio_notify(vdev, q->rx_vq);\n\n    return size;\n\nerr:\n    for (j = 0; j < i; j++) {\n        g_free(elems[j]);\n    }\n\n    return err;\n}",
        "func": "static ssize_t virtio_net_receive_rcu(NetClientState *nc, const uint8_t *buf,\n                                      size_t size, bool no_rss)\n{\n    VirtIONet *n = qemu_get_nic_opaque(nc);\n    VirtIONetQueue *q = virtio_net_get_subqueue(nc);\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    VirtQueueElement *elems[VIRTQUEUE_MAX_SIZE];\n    size_t lens[VIRTQUEUE_MAX_SIZE];\n    struct iovec mhdr_sg[VIRTQUEUE_MAX_SIZE];\n    struct virtio_net_hdr_mrg_rxbuf mhdr;\n    unsigned mhdr_cnt = 0;\n    size_t offset, i, guest_offset, j;\n    ssize_t err;\n\n    if (!virtio_net_can_receive(nc)) {\n        return -1;\n    }\n\n    if (!no_rss && n->rss_data.enabled && n->rss_data.enabled_software_rss) {\n        int index = virtio_net_process_rss(nc, buf, size);\n        if (index >= 0) {\n            NetClientState *nc2 = qemu_get_subqueue(n->nic, index);\n            return virtio_net_receive_rcu(nc2, buf, size, true);\n        }\n    }\n\n    /* hdr_len refers to the header we supply to the guest */\n    if (!virtio_net_has_buffers(q, size + n->guest_hdr_len - n->host_hdr_len)) {\n        return 0;\n    }\n\n    if (!receive_filter(n, buf, size))\n        return size;\n\n    offset = i = 0;\n\n    while (offset < size) {\n        VirtQueueElement *elem;\n        int len, total;\n        const struct iovec *sg;\n\n        total = 0;\n\n        if (i == VIRTQUEUE_MAX_SIZE) {\n            virtio_error(vdev, \"virtio-net unexpected long buffer chain\");\n            err = size;\n            goto err;\n        }\n\n        elem = virtqueue_pop(q->rx_vq, sizeof(VirtQueueElement));\n        if (!elem) {\n            if (i) {\n                virtio_error(vdev, \"virtio-net unexpected empty queue: \"\n                             \"i %zd mergeable %d offset %zd, size %zd, \"\n                             \"guest hdr len %zd, host hdr len %zd \"\n                             \"guest features 0x%\" PRIx64,\n                             i, n->mergeable_rx_bufs, offset, size,\n                             n->guest_hdr_len, n->host_hdr_len,\n                             vdev->guest_features);\n            }\n            err = -1;\n            goto err;\n        }\n\n        if (elem->in_num < 1) {\n            virtio_error(vdev,\n                         \"virtio-net receive queue contains no in buffers\");\n            virtqueue_detach_element(q->rx_vq, elem, 0);\n            g_free(elem);\n            err = -1;\n            goto err;\n        }\n\n        sg = elem->in_sg;\n        if (i == 0) {\n            assert(offset == 0);\n            if (n->mergeable_rx_bufs) {\n                mhdr_cnt = iov_copy(mhdr_sg, ARRAY_SIZE(mhdr_sg),\n                                    sg, elem->in_num,\n                                    offsetof(typeof(mhdr), num_buffers),\n                                    sizeof(mhdr.num_buffers));\n            }\n\n            receive_header(n, sg, elem->in_num, buf, size);\n            if (n->rss_data.populate_hash) {\n                offset = sizeof(mhdr);\n                iov_from_buf(sg, elem->in_num, offset,\n                             buf + offset, n->host_hdr_len - sizeof(mhdr));\n            }\n            offset = n->host_hdr_len;\n            total += n->guest_hdr_len;\n            guest_offset = n->guest_hdr_len;\n        } else {\n            guest_offset = 0;\n        }\n\n        /* copy in packet.  ugh */\n        len = iov_from_buf(sg, elem->in_num, guest_offset,\n                           buf + offset, size - offset);\n        total += len;\n        offset += len;\n        /* If buffers can't be merged, at this point we\n         * must have consumed the complete packet.\n         * Otherwise, drop it. */\n        if (!n->mergeable_rx_bufs && offset < size) {\n            virtqueue_unpop(q->rx_vq, elem, total);\n            g_free(elem);\n            err = size;\n            goto err;\n        }\n\n        elems[i] = elem;\n        lens[i] = total;\n        i++;\n    }\n\n    if (mhdr_cnt) {\n        virtio_stw_p(vdev, &mhdr.num_buffers, i);\n        iov_from_buf(mhdr_sg, mhdr_cnt,\n                     0,\n                     &mhdr.num_buffers, sizeof mhdr.num_buffers);\n    }\n\n    for (j = 0; j < i; j++) {\n        /* signal other side */\n        virtqueue_fill(q->rx_vq, elems[j], lens[j], j);\n        g_free(elems[j]);\n    }\n\n    virtqueue_flush(q->rx_vq, i);\n    virtio_notify(vdev, q->rx_vq);\n\n    return size;\n\nerr:\n    for (j = 0; j < i; j++) {\n        virtqueue_detach_element(q->rx_vq, elems[j], lens[j]);\n        g_free(elems[j]);\n    }\n\n    return err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -134,6 +134,7 @@\n \n err:\n     for (j = 0; j < i; j++) {\n+        virtqueue_detach_element(q->rx_vq, elems[j], lens[j]);\n         g_free(elems[j]);\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        virtqueue_detach_element(q->rx_vq, elems[j], lens[j]);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-26354",
        "func_name": "qemu-project/qemu/vhost_vsock_common_send_transport_reset",
        "description": "A flaw was found in the vhost-vsock device of QEMU. In case of error, an invalid element was not detached from the virtqueue before freeing its memory, leading to memory leakage and other unexpected results. Affected QEMU versions <= 6.2.0.",
        "git_url": "https://gitlab.com/qemu-project/qemu/-/commit/8d1b247f3748ac4078524130c6d7ae42b6140aaf",
        "commit_title": "vhost-vsock: detach the virqueue element in case of error",
        "commit_text": " In vhost_vsock_common_send_transport_reset(), if an element popped from the virtqueue is invalid, we should call virtqueue_detach_element() to detach it from the virtqueue before freeing its memory.  Cc: qemu-stable@nongnu.org Message-Id: <20220228095058.27899-1-sgarzare@redhat.com> ",
        "func_before": "static void vhost_vsock_common_send_transport_reset(VHostVSockCommon *vvc)\n{\n    VirtQueueElement *elem;\n    VirtQueue *vq = vvc->event_vq;\n    struct virtio_vsock_event event = {\n        .id = cpu_to_le32(VIRTIO_VSOCK_EVENT_TRANSPORT_RESET),\n    };\n\n    elem = virtqueue_pop(vq, sizeof(VirtQueueElement));\n    if (!elem) {\n        error_report(\"vhost-vsock missed transport reset event\");\n        return;\n    }\n\n    if (elem->out_num) {\n        error_report(\"invalid vhost-vsock event virtqueue element with \"\n                     \"out buffers\");\n        goto out;\n    }\n\n    if (iov_from_buf(elem->in_sg, elem->in_num, 0,\n                     &event, sizeof(event)) != sizeof(event)) {\n        error_report(\"vhost-vsock event virtqueue element is too short\");\n        goto out;\n    }\n\n    virtqueue_push(vq, elem, sizeof(event));\n    virtio_notify(VIRTIO_DEVICE(vvc), vq);\n\nout:\n    g_free(elem);\n}",
        "func": "static void vhost_vsock_common_send_transport_reset(VHostVSockCommon *vvc)\n{\n    VirtQueueElement *elem;\n    VirtQueue *vq = vvc->event_vq;\n    struct virtio_vsock_event event = {\n        .id = cpu_to_le32(VIRTIO_VSOCK_EVENT_TRANSPORT_RESET),\n    };\n\n    elem = virtqueue_pop(vq, sizeof(VirtQueueElement));\n    if (!elem) {\n        error_report(\"vhost-vsock missed transport reset event\");\n        return;\n    }\n\n    if (elem->out_num) {\n        error_report(\"invalid vhost-vsock event virtqueue element with \"\n                     \"out buffers\");\n        goto err;\n    }\n\n    if (iov_from_buf(elem->in_sg, elem->in_num, 0,\n                     &event, sizeof(event)) != sizeof(event)) {\n        error_report(\"vhost-vsock event virtqueue element is too short\");\n        goto err;\n    }\n\n    virtqueue_push(vq, elem, sizeof(event));\n    virtio_notify(VIRTIO_DEVICE(vvc), vq);\n\n    g_free(elem);\n    return;\n\nerr:\n    virtqueue_detach_element(vq, elem, 0);\n    g_free(elem);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,18 +15,22 @@\n     if (elem->out_num) {\n         error_report(\"invalid vhost-vsock event virtqueue element with \"\n                      \"out buffers\");\n-        goto out;\n+        goto err;\n     }\n \n     if (iov_from_buf(elem->in_sg, elem->in_num, 0,\n                      &event, sizeof(event)) != sizeof(event)) {\n         error_report(\"vhost-vsock event virtqueue element is too short\");\n-        goto out;\n+        goto err;\n     }\n \n     virtqueue_push(vq, elem, sizeof(event));\n     virtio_notify(VIRTIO_DEVICE(vvc), vq);\n \n-out:\n+    g_free(elem);\n+    return;\n+\n+err:\n+    virtqueue_detach_element(vq, elem, 0);\n     g_free(elem);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "        goto out;",
                "        goto out;",
                "out:"
            ],
            "added_lines": [
                "        goto err;",
                "        goto err;",
                "    g_free(elem);",
                "    return;",
                "",
                "err:",
                "    virtqueue_detach_element(vq, elem, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-8577",
        "func_name": "qemu/v9fs_read",
        "description": "Memory leak in the v9fs_read function in hw/9pfs/9p.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (memory consumption) via vectors related to an I/O read operation.",
        "git_url": "https://github.com/qemu/qemu/commit/e95c9a493a5a8d6f969e86c9f19f80ffe6587e19",
        "commit_title": "9pfs: fix potential host memory leak in v9fs_read",
        "commit_text": " In 9pfs read dispatch function, it doesn't free two QEMUIOVector object thus causing potential memory leak. This patch avoid this. ",
        "func_before": "static void v9fs_read(void *opaque)\n{\n    int32_t fid;\n    uint64_t off;\n    ssize_t err = 0;\n    int32_t count = 0;\n    size_t offset = 7;\n    uint32_t max_count;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n\n    err = pdu_unmarshal(pdu, offset, \"dqd\", &fid, &off, &max_count);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_read(pdu->tag, pdu->id, fid, off, max_count);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    if (fidp->fid_type == P9_FID_DIR) {\n\n        if (off == 0) {\n            v9fs_co_rewinddir(pdu, fidp);\n        }\n        count = v9fs_do_readdir_with_stat(pdu, fidp, max_count);\n        if (count < 0) {\n            err = count;\n            goto out;\n        }\n        err = pdu_marshal(pdu, offset, \"d\", count);\n        if (err < 0) {\n            goto out;\n        }\n        err += offset + count;\n    } else if (fidp->fid_type == P9_FID_FILE) {\n        QEMUIOVector qiov_full;\n        QEMUIOVector qiov;\n        int32_t len;\n\n        v9fs_init_qiov_from_pdu(&qiov_full, pdu, offset + 4, max_count, false);\n        qemu_iovec_init(&qiov, qiov_full.niov);\n        do {\n            qemu_iovec_reset(&qiov);\n            qemu_iovec_concat(&qiov, &qiov_full, count, qiov_full.size - count);\n            if (0) {\n                print_sg(qiov.iov, qiov.niov);\n            }\n            /* Loop in case of EINTR */\n            do {\n                len = v9fs_co_preadv(pdu, fidp, qiov.iov, qiov.niov, off);\n                if (len >= 0) {\n                    off   += len;\n                    count += len;\n                }\n            } while (len == -EINTR && !pdu->cancelled);\n            if (len < 0) {\n                /* IO error return the error */\n                err = len;\n                goto out;\n            }\n        } while (count < max_count && len > 0);\n        err = pdu_marshal(pdu, offset, \"d\", count);\n        if (err < 0) {\n            goto out;\n        }\n        err += offset + count;\n        qemu_iovec_destroy(&qiov);\n        qemu_iovec_destroy(&qiov_full);\n    } else if (fidp->fid_type == P9_FID_XATTR) {\n        err = v9fs_xattr_read(s, pdu, fidp, off, max_count);\n    } else {\n        err = -EINVAL;\n    }\n    trace_v9fs_read_return(pdu->tag, pdu->id, count, err);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n}",
        "func": "static void v9fs_read(void *opaque)\n{\n    int32_t fid;\n    uint64_t off;\n    ssize_t err = 0;\n    int32_t count = 0;\n    size_t offset = 7;\n    uint32_t max_count;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n\n    err = pdu_unmarshal(pdu, offset, \"dqd\", &fid, &off, &max_count);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_read(pdu->tag, pdu->id, fid, off, max_count);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    if (fidp->fid_type == P9_FID_DIR) {\n\n        if (off == 0) {\n            v9fs_co_rewinddir(pdu, fidp);\n        }\n        count = v9fs_do_readdir_with_stat(pdu, fidp, max_count);\n        if (count < 0) {\n            err = count;\n            goto out;\n        }\n        err = pdu_marshal(pdu, offset, \"d\", count);\n        if (err < 0) {\n            goto out;\n        }\n        err += offset + count;\n    } else if (fidp->fid_type == P9_FID_FILE) {\n        QEMUIOVector qiov_full;\n        QEMUIOVector qiov;\n        int32_t len;\n\n        v9fs_init_qiov_from_pdu(&qiov_full, pdu, offset + 4, max_count, false);\n        qemu_iovec_init(&qiov, qiov_full.niov);\n        do {\n            qemu_iovec_reset(&qiov);\n            qemu_iovec_concat(&qiov, &qiov_full, count, qiov_full.size - count);\n            if (0) {\n                print_sg(qiov.iov, qiov.niov);\n            }\n            /* Loop in case of EINTR */\n            do {\n                len = v9fs_co_preadv(pdu, fidp, qiov.iov, qiov.niov, off);\n                if (len >= 0) {\n                    off   += len;\n                    count += len;\n                }\n            } while (len == -EINTR && !pdu->cancelled);\n            if (len < 0) {\n                /* IO error return the error */\n                err = len;\n                goto out_free_iovec;\n            }\n        } while (count < max_count && len > 0);\n        err = pdu_marshal(pdu, offset, \"d\", count);\n        if (err < 0) {\n            goto out_free_iovec;\n        }\n        err += offset + count;\nout_free_iovec:\n        qemu_iovec_destroy(&qiov);\n        qemu_iovec_destroy(&qiov_full);\n    } else if (fidp->fid_type == P9_FID_XATTR) {\n        err = v9fs_xattr_read(s, pdu, fidp, off, max_count);\n    } else {\n        err = -EINVAL;\n    }\n    trace_v9fs_read_return(pdu->tag, pdu->id, count, err);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -60,14 +60,15 @@\n             if (len < 0) {\n                 /* IO error return the error */\n                 err = len;\n-                goto out;\n+                goto out_free_iovec;\n             }\n         } while (count < max_count && len > 0);\n         err = pdu_marshal(pdu, offset, \"d\", count);\n         if (err < 0) {\n-            goto out;\n+            goto out_free_iovec;\n         }\n         err += offset + count;\n+out_free_iovec:\n         qemu_iovec_destroy(&qiov);\n         qemu_iovec_destroy(&qiov_full);\n     } else if (fidp->fid_type == P9_FID_XATTR) {",
        "diff_line_info": {
            "deleted_lines": [
                "                goto out;",
                "            goto out;"
            ],
            "added_lines": [
                "                goto out_free_iovec;",
                "            goto out_free_iovec;",
                "out_free_iovec:"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-9102",
        "func_name": "qemu/v9fs_xattrcreate",
        "description": "Memory leak in the v9fs_xattrcreate function in hw/9pfs/9p.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (memory consumption and QEMU process crash) via a large number of Txattrcreate messages with the same fid number.",
        "git_url": "https://github.com/qemu/qemu/commit/ff55e94d23ae94c8628b0115320157c763eb3e06",
        "commit_title": "9pfs: fix memory leak in v9fs_xattrcreate",
        "commit_text": " The 'fs.xattr.value' field in V9fsFidState object doesn't consider the situation that this field has been allocated previously. Every time, it will be allocated directly. This leads to a host memory leak issue if the client sends another Txattrcreate message with the same fid number before the fid from the previous time got clunked.  [groug, updated the changelog to indicate how the leak can occur]",
        "func_before": "static void coroutine_fn v9fs_xattrcreate(void *opaque)\n{\n    int flags;\n    int32_t fid;\n    int64_t size;\n    ssize_t err = 0;\n    V9fsString name;\n    size_t offset = 7;\n    V9fsFidState *file_fidp;\n    V9fsFidState *xattr_fidp;\n    V9fsPDU *pdu = opaque;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsqd\", &fid, &name, &size, &flags);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_xattrcreate(pdu->tag, pdu->id, fid, name.data, size, flags);\n\n    file_fidp = get_fid(pdu, fid);\n    if (file_fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    /* Make the file fid point to xattr */\n    xattr_fidp = file_fidp;\n    xattr_fidp->fid_type = P9_FID_XATTR;\n    xattr_fidp->fs.xattr.copied_len = 0;\n    xattr_fidp->fs.xattr.len = size;\n    xattr_fidp->fs.xattr.flags = flags;\n    v9fs_string_init(&xattr_fidp->fs.xattr.name);\n    v9fs_string_copy(&xattr_fidp->fs.xattr.name, &name);\n    xattr_fidp->fs.xattr.value = g_malloc0(size);\n    err = offset;\n    put_fid(pdu, file_fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}",
        "func": "static void coroutine_fn v9fs_xattrcreate(void *opaque)\n{\n    int flags;\n    int32_t fid;\n    int64_t size;\n    ssize_t err = 0;\n    V9fsString name;\n    size_t offset = 7;\n    V9fsFidState *file_fidp;\n    V9fsFidState *xattr_fidp;\n    V9fsPDU *pdu = opaque;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsqd\", &fid, &name, &size, &flags);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_xattrcreate(pdu->tag, pdu->id, fid, name.data, size, flags);\n\n    file_fidp = get_fid(pdu, fid);\n    if (file_fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    /* Make the file fid point to xattr */\n    xattr_fidp = file_fidp;\n    xattr_fidp->fid_type = P9_FID_XATTR;\n    xattr_fidp->fs.xattr.copied_len = 0;\n    xattr_fidp->fs.xattr.len = size;\n    xattr_fidp->fs.xattr.flags = flags;\n    v9fs_string_init(&xattr_fidp->fs.xattr.name);\n    v9fs_string_copy(&xattr_fidp->fs.xattr.name, &name);\n    g_free(xattr_fidp->fs.xattr.value);\n    xattr_fidp->fs.xattr.value = g_malloc0(size);\n    err = offset;\n    put_fid(pdu, file_fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,6 +30,7 @@\n     xattr_fidp->fs.xattr.flags = flags;\n     v9fs_string_init(&xattr_fidp->fs.xattr.name);\n     v9fs_string_copy(&xattr_fidp->fs.xattr.name, &name);\n+    g_free(xattr_fidp->fs.xattr.value);\n     xattr_fidp->fs.xattr.value = g_malloc0(size);\n     err = offset;\n     put_fid(pdu, file_fidp);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    g_free(xattr_fidp->fs.xattr.value);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-9105",
        "func_name": "qemu/v9fs_link",
        "description": "Memory leak in the v9fs_link function in hw/9pfs/9p.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (memory consumption) via vectors involving a reference to the source fid object.",
        "git_url": "https://github.com/qemu/qemu/commit/4c1586787ff43c9acd18a56c12d720e3e6be9f7c",
        "commit_title": "9pfs: fix memory leak in v9fs_link",
        "commit_text": " The v9fs_link() function keeps a reference on the source fid object. This causes a memory leak since the reference never goes down to 0. This patch fixes the issue.  [groug, rephrased the changelog]",
        "func_before": "static void coroutine_fn v9fs_link(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    int32_t dfid, oldfid;\n    V9fsFidState *dfidp, *oldfidp;\n    V9fsString name;\n    size_t offset = 7;\n    int err = 0;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dds\", &dfid, &oldfid, &name);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n\n    dfidp = get_fid(pdu, dfid);\n    if (dfidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    oldfidp = get_fid(pdu, oldfid);\n    if (oldfidp == NULL) {\n        err = -ENOENT;\n        goto out;\n    }\n    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);\n    if (!err) {\n        err = offset;\n    }\nout:\n    put_fid(pdu, dfidp);\nout_nofid:\n    v9fs_string_free(&name);\n    pdu_complete(pdu, err);\n}",
        "func": "static void coroutine_fn v9fs_link(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    int32_t dfid, oldfid;\n    V9fsFidState *dfidp, *oldfidp;\n    V9fsString name;\n    size_t offset = 7;\n    int err = 0;\n\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dds\", &dfid, &oldfid, &name);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);\n\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n\n    dfidp = get_fid(pdu, dfid);\n    if (dfidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n\n    oldfidp = get_fid(pdu, oldfid);\n    if (oldfidp == NULL) {\n        err = -ENOENT;\n        goto out;\n    }\n    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);\n    if (!err) {\n        err = offset;\n    }\n    put_fid(pdu, oldfidp);\nout:\n    put_fid(pdu, dfidp);\nout_nofid:\n    v9fs_string_free(&name);\n    pdu_complete(pdu, err);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,6 +39,7 @@\n     if (!err) {\n         err = offset;\n     }\n+    put_fid(pdu, oldfidp);\n out:\n     put_fid(pdu, dfidp);\n out_nofid:",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    put_fid(pdu, oldfidp);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-9106",
        "func_name": "qemu/v9fs_write",
        "description": "Memory leak in the v9fs_write function in hw/9pfs/9p.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (memory consumption) by leveraging failure to free an IO vector.",
        "git_url": "https://github.com/qemu/qemu/commit/fdfcc9aeea1492f4b819a24c94dfb678145b1bf9",
        "commit_title": "9pfs: fix memory leak in v9fs_write",
        "commit_text": " If an error occurs when marshalling the transfer length to the guest, the v9fs_write() function doesn't free an IO vector, thus leading to a memory leak. This patch fixes the issue.  [groug, rephrased the changelog]",
        "func_before": "static void coroutine_fn v9fs_write(void *opaque)\n{\n    ssize_t err;\n    int32_t fid;\n    uint64_t off;\n    uint32_t count;\n    int32_t len = 0;\n    int32_t total = 0;\n    size_t offset = 7;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    QEMUIOVector qiov_full;\n    QEMUIOVector qiov;\n\n    err = pdu_unmarshal(pdu, offset, \"dqd\", &fid, &off, &count);\n    if (err < 0) {\n        pdu_complete(pdu, err);\n        return;\n    }\n    offset += err;\n    v9fs_init_qiov_from_pdu(&qiov_full, pdu, offset, count, true);\n    trace_v9fs_write(pdu->tag, pdu->id, fid, off, count, qiov_full.niov);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    if (fidp->fid_type == P9_FID_FILE) {\n        if (fidp->fs.fd == -1) {\n            err = -EINVAL;\n            goto out;\n        }\n    } else if (fidp->fid_type == P9_FID_XATTR) {\n        /*\n         * setxattr operation\n         */\n        err = v9fs_xattr_write(s, pdu, fidp, off, count,\n                               qiov_full.iov, qiov_full.niov);\n        goto out;\n    } else {\n        err = -EINVAL;\n        goto out;\n    }\n    qemu_iovec_init(&qiov, qiov_full.niov);\n    do {\n        qemu_iovec_reset(&qiov);\n        qemu_iovec_concat(&qiov, &qiov_full, total, qiov_full.size - total);\n        if (0) {\n            print_sg(qiov.iov, qiov.niov);\n        }\n        /* Loop in case of EINTR */\n        do {\n            len = v9fs_co_pwritev(pdu, fidp, qiov.iov, qiov.niov, off);\n            if (len >= 0) {\n                off   += len;\n                total += len;\n            }\n        } while (len == -EINTR && !pdu->cancelled);\n        if (len < 0) {\n            /* IO error return the error */\n            err = len;\n            goto out_qiov;\n        }\n    } while (total < count && len > 0);\n\n    offset = 7;\n    err = pdu_marshal(pdu, offset, \"d\", total);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_write_return(pdu->tag, pdu->id, total, err);\nout_qiov:\n    qemu_iovec_destroy(&qiov);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    qemu_iovec_destroy(&qiov_full);\n    pdu_complete(pdu, err);\n}",
        "func": "static void coroutine_fn v9fs_write(void *opaque)\n{\n    ssize_t err;\n    int32_t fid;\n    uint64_t off;\n    uint32_t count;\n    int32_t len = 0;\n    int32_t total = 0;\n    size_t offset = 7;\n    V9fsFidState *fidp;\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    QEMUIOVector qiov_full;\n    QEMUIOVector qiov;\n\n    err = pdu_unmarshal(pdu, offset, \"dqd\", &fid, &off, &count);\n    if (err < 0) {\n        pdu_complete(pdu, err);\n        return;\n    }\n    offset += err;\n    v9fs_init_qiov_from_pdu(&qiov_full, pdu, offset, count, true);\n    trace_v9fs_write(pdu->tag, pdu->id, fid, off, count, qiov_full.niov);\n\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    if (fidp->fid_type == P9_FID_FILE) {\n        if (fidp->fs.fd == -1) {\n            err = -EINVAL;\n            goto out;\n        }\n    } else if (fidp->fid_type == P9_FID_XATTR) {\n        /*\n         * setxattr operation\n         */\n        err = v9fs_xattr_write(s, pdu, fidp, off, count,\n                               qiov_full.iov, qiov_full.niov);\n        goto out;\n    } else {\n        err = -EINVAL;\n        goto out;\n    }\n    qemu_iovec_init(&qiov, qiov_full.niov);\n    do {\n        qemu_iovec_reset(&qiov);\n        qemu_iovec_concat(&qiov, &qiov_full, total, qiov_full.size - total);\n        if (0) {\n            print_sg(qiov.iov, qiov.niov);\n        }\n        /* Loop in case of EINTR */\n        do {\n            len = v9fs_co_pwritev(pdu, fidp, qiov.iov, qiov.niov, off);\n            if (len >= 0) {\n                off   += len;\n                total += len;\n            }\n        } while (len == -EINTR && !pdu->cancelled);\n        if (len < 0) {\n            /* IO error return the error */\n            err = len;\n            goto out_qiov;\n        }\n    } while (total < count && len > 0);\n\n    offset = 7;\n    err = pdu_marshal(pdu, offset, \"d\", total);\n    if (err < 0) {\n        goto out_qiov;\n    }\n    err += offset;\n    trace_v9fs_write_return(pdu->tag, pdu->id, total, err);\nout_qiov:\n    qemu_iovec_destroy(&qiov);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    qemu_iovec_destroy(&qiov_full);\n    pdu_complete(pdu, err);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -68,7 +68,7 @@\n     offset = 7;\n     err = pdu_marshal(pdu, offset, \"d\", total);\n     if (err < 0) {\n-        goto out;\n+        goto out_qiov;\n     }\n     err += offset;\n     trace_v9fs_write_return(pdu->tag, pdu->id, total, err);",
        "diff_line_info": {
            "deleted_lines": [
                "        goto out;"
            ],
            "added_lines": [
                "        goto out_qiov;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7466",
        "func_name": "qemu/usb_xhci_exit",
        "description": "Memory leak in the usb_xhci_exit function in hw/usb/hcd-xhci.c in QEMU (aka Quick Emulator), when the xhci uses msix, allows local guest OS administrators to cause a denial of service (memory consumption and possibly QEMU process crash) by repeatedly unplugging a USB device.",
        "git_url": "https://github.com/qemu/qemu/commit/b53dd4495ced2432a0b652ea895e651d07336f7e",
        "commit_title": "usb:xhci:fix memory leak in usb_xhci_exit",
        "commit_text": " If the xhci uses msix, it doesn't free the corresponding memory, thus leading a memory leak. This patch avoid this. ",
        "func_before": "static void usb_xhci_exit(PCIDevice *dev)\n{\n    int i;\n    XHCIState *xhci = XHCI(dev);\n\n    trace_usb_xhci_exit();\n\n    for (i = 0; i < xhci->numslots; i++) {\n        xhci_disable_slot(xhci, i + 1);\n    }\n\n    if (xhci->mfwrap_timer) {\n        timer_del(xhci->mfwrap_timer);\n        timer_free(xhci->mfwrap_timer);\n        xhci->mfwrap_timer = NULL;\n    }\n\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_cap);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_oper);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_runtime);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_doorbell);\n\n    for (i = 0; i < xhci->numports; i++) {\n        XHCIPort *port = &xhci->ports[i];\n        memory_region_del_subregion(&xhci->mem, &port->mem);\n    }\n\n    /* destroy msix memory region */\n    if (dev->msix_table && dev->msix_pba\n        && dev->msix_entry_used) {\n        memory_region_del_subregion(&xhci->mem, &dev->msix_table_mmio);\n        memory_region_del_subregion(&xhci->mem, &dev->msix_pba_mmio);\n    }\n\n    usb_bus_release(&xhci->bus);\n}",
        "func": "static void usb_xhci_exit(PCIDevice *dev)\n{\n    int i;\n    XHCIState *xhci = XHCI(dev);\n\n    trace_usb_xhci_exit();\n\n    for (i = 0; i < xhci->numslots; i++) {\n        xhci_disable_slot(xhci, i + 1);\n    }\n\n    if (xhci->mfwrap_timer) {\n        timer_del(xhci->mfwrap_timer);\n        timer_free(xhci->mfwrap_timer);\n        xhci->mfwrap_timer = NULL;\n    }\n\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_cap);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_oper);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_runtime);\n    memory_region_del_subregion(&xhci->mem, &xhci->mem_doorbell);\n\n    for (i = 0; i < xhci->numports; i++) {\n        XHCIPort *port = &xhci->ports[i];\n        memory_region_del_subregion(&xhci->mem, &port->mem);\n    }\n\n    /* destroy msix memory region */\n    if (dev->msix_table && dev->msix_pba\n        && dev->msix_entry_used) {\n        msix_uninit(dev, &xhci->mem, &xhci->mem);\n    }\n\n    usb_bus_release(&xhci->bus);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,8 +28,7 @@\n     /* destroy msix memory region */\n     if (dev->msix_table && dev->msix_pba\n         && dev->msix_entry_used) {\n-        memory_region_del_subregion(&xhci->mem, &dev->msix_table_mmio);\n-        memory_region_del_subregion(&xhci->mem, &dev->msix_pba_mmio);\n+        msix_uninit(dev, &xhci->mem, &xhci->mem);\n     }\n \n     usb_bus_release(&xhci->bus);",
        "diff_line_info": {
            "deleted_lines": [
                "        memory_region_del_subregion(&xhci->mem, &dev->msix_table_mmio);",
                "        memory_region_del_subregion(&xhci->mem, &dev->msix_pba_mmio);"
            ],
            "added_lines": [
                "        msix_uninit(dev, &xhci->mem, &xhci->mem);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7995",
        "func_name": "qemu/ehci_process_itd",
        "description": "Memory leak in the ehci_process_itd function in hw/usb/hcd-ehci.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (memory consumption) via a large number of crafted buffer page select (PG) indexes.",
        "git_url": "https://github.com/qemu/qemu/commit/b16c129daf0fed91febbb88de23dae8271c8898a",
        "commit_title": "usb: ehci: fix memory leak in ehci_process_itd",
        "commit_text": " While processing isochronous transfer descriptors(iTD), if the page select(PG) field value is out of bands it will return. In this situation the ehci's sg list is not freed thus leading to a memory leak issue. This patch avoid this. ",
        "func_before": "static int ehci_process_itd(EHCIState *ehci,\n                            EHCIitd *itd,\n                            uint32_t addr)\n{\n    USBDevice *dev;\n    USBEndpoint *ep;\n    uint32_t i, len, pid, dir, devaddr, endp;\n    uint32_t pg, off, ptr1, ptr2, max, mult;\n\n    ehci->periodic_sched_active = PERIODIC_ACTIVE;\n\n    dir =(itd->bufptr[1] & ITD_BUFPTR_DIRECTION);\n    devaddr = get_field(itd->bufptr[0], ITD_BUFPTR_DEVADDR);\n    endp = get_field(itd->bufptr[0], ITD_BUFPTR_EP);\n    max = get_field(itd->bufptr[1], ITD_BUFPTR_MAXPKT);\n    mult = get_field(itd->bufptr[2], ITD_BUFPTR_MULT);\n\n    for(i = 0; i < 8; i++) {\n        if (itd->transact[i] & ITD_XACT_ACTIVE) {\n            pg   = get_field(itd->transact[i], ITD_XACT_PGSEL);\n            off  = itd->transact[i] & ITD_XACT_OFFSET_MASK;\n            len  = get_field(itd->transact[i], ITD_XACT_LENGTH);\n\n            if (len > max * mult) {\n                len = max * mult;\n            }\n            if (len > BUFF_SIZE || pg > 6) {\n                return -1;\n            }\n\n            ptr1 = (itd->bufptr[pg] & ITD_BUFPTR_MASK);\n            qemu_sglist_init(&ehci->isgl, ehci->device, 2, ehci->as);\n            if (off + len > 4096) {\n                /* transfer crosses page border */\n                if (pg == 6) {\n                    return -1;  /* avoid page pg + 1 */\n                }\n                ptr2 = (itd->bufptr[pg + 1] & ITD_BUFPTR_MASK);\n                uint32_t len2 = off + len - 4096;\n                uint32_t len1 = len - len2;\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len1);\n                qemu_sglist_add(&ehci->isgl, ptr2, len2);\n            } else {\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len);\n            }\n\n            pid = dir ? USB_TOKEN_IN : USB_TOKEN_OUT;\n\n            dev = ehci_find_device(ehci, devaddr);\n            ep = usb_ep_get(dev, pid, endp);\n            if (ep && ep->type == USB_ENDPOINT_XFER_ISOC) {\n                usb_packet_setup(&ehci->ipacket, pid, ep, 0, addr, false,\n                                 (itd->transact[i] & ITD_XACT_IOC) != 0);\n                usb_packet_map(&ehci->ipacket, &ehci->isgl);\n                usb_handle_packet(dev, &ehci->ipacket);\n                usb_packet_unmap(&ehci->ipacket, &ehci->isgl);\n            } else {\n                DPRINTF(\"ISOCH: attempt to addess non-iso endpoint\\n\");\n                ehci->ipacket.status = USB_RET_NAK;\n                ehci->ipacket.actual_length = 0;\n            }\n            qemu_sglist_destroy(&ehci->isgl);\n\n            switch (ehci->ipacket.status) {\n            case USB_RET_SUCCESS:\n                break;\n            default:\n                fprintf(stderr, \"Unexpected iso usb result: %d\\n\",\n                        ehci->ipacket.status);\n                /* Fall through */\n            case USB_RET_IOERROR:\n            case USB_RET_NODEV:\n                /* 3.3.2: XACTERR is only allowed on IN transactions */\n                if (dir) {\n                    itd->transact[i] |= ITD_XACT_XACTERR;\n                    ehci_raise_irq(ehci, USBSTS_ERRINT);\n                }\n                break;\n            case USB_RET_BABBLE:\n                itd->transact[i] |= ITD_XACT_BABBLE;\n                ehci_raise_irq(ehci, USBSTS_ERRINT);\n                break;\n            case USB_RET_NAK:\n                /* no data for us, so do a zero-length transfer */\n                ehci->ipacket.actual_length = 0;\n                break;\n            }\n            if (!dir) {\n                set_field(&itd->transact[i], len - ehci->ipacket.actual_length,\n                          ITD_XACT_LENGTH); /* OUT */\n            } else {\n                set_field(&itd->transact[i], ehci->ipacket.actual_length,\n                          ITD_XACT_LENGTH); /* IN */\n            }\n            if (itd->transact[i] & ITD_XACT_IOC) {\n                ehci_raise_irq(ehci, USBSTS_INT);\n            }\n            itd->transact[i] &= ~ITD_XACT_ACTIVE;\n        }\n    }\n    return 0;\n}",
        "func": "static int ehci_process_itd(EHCIState *ehci,\n                            EHCIitd *itd,\n                            uint32_t addr)\n{\n    USBDevice *dev;\n    USBEndpoint *ep;\n    uint32_t i, len, pid, dir, devaddr, endp;\n    uint32_t pg, off, ptr1, ptr2, max, mult;\n\n    ehci->periodic_sched_active = PERIODIC_ACTIVE;\n\n    dir =(itd->bufptr[1] & ITD_BUFPTR_DIRECTION);\n    devaddr = get_field(itd->bufptr[0], ITD_BUFPTR_DEVADDR);\n    endp = get_field(itd->bufptr[0], ITD_BUFPTR_EP);\n    max = get_field(itd->bufptr[1], ITD_BUFPTR_MAXPKT);\n    mult = get_field(itd->bufptr[2], ITD_BUFPTR_MULT);\n\n    for(i = 0; i < 8; i++) {\n        if (itd->transact[i] & ITD_XACT_ACTIVE) {\n            pg   = get_field(itd->transact[i], ITD_XACT_PGSEL);\n            off  = itd->transact[i] & ITD_XACT_OFFSET_MASK;\n            len  = get_field(itd->transact[i], ITD_XACT_LENGTH);\n\n            if (len > max * mult) {\n                len = max * mult;\n            }\n            if (len > BUFF_SIZE || pg > 6) {\n                return -1;\n            }\n\n            ptr1 = (itd->bufptr[pg] & ITD_BUFPTR_MASK);\n            qemu_sglist_init(&ehci->isgl, ehci->device, 2, ehci->as);\n            if (off + len > 4096) {\n                /* transfer crosses page border */\n                if (pg == 6) {\n                    qemu_sglist_destroy(&ehci->isgl);\n                    return -1;  /* avoid page pg + 1 */\n                }\n                ptr2 = (itd->bufptr[pg + 1] & ITD_BUFPTR_MASK);\n                uint32_t len2 = off + len - 4096;\n                uint32_t len1 = len - len2;\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len1);\n                qemu_sglist_add(&ehci->isgl, ptr2, len2);\n            } else {\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len);\n            }\n\n            pid = dir ? USB_TOKEN_IN : USB_TOKEN_OUT;\n\n            dev = ehci_find_device(ehci, devaddr);\n            ep = usb_ep_get(dev, pid, endp);\n            if (ep && ep->type == USB_ENDPOINT_XFER_ISOC) {\n                usb_packet_setup(&ehci->ipacket, pid, ep, 0, addr, false,\n                                 (itd->transact[i] & ITD_XACT_IOC) != 0);\n                usb_packet_map(&ehci->ipacket, &ehci->isgl);\n                usb_handle_packet(dev, &ehci->ipacket);\n                usb_packet_unmap(&ehci->ipacket, &ehci->isgl);\n            } else {\n                DPRINTF(\"ISOCH: attempt to addess non-iso endpoint\\n\");\n                ehci->ipacket.status = USB_RET_NAK;\n                ehci->ipacket.actual_length = 0;\n            }\n            qemu_sglist_destroy(&ehci->isgl);\n\n            switch (ehci->ipacket.status) {\n            case USB_RET_SUCCESS:\n                break;\n            default:\n                fprintf(stderr, \"Unexpected iso usb result: %d\\n\",\n                        ehci->ipacket.status);\n                /* Fall through */\n            case USB_RET_IOERROR:\n            case USB_RET_NODEV:\n                /* 3.3.2: XACTERR is only allowed on IN transactions */\n                if (dir) {\n                    itd->transact[i] |= ITD_XACT_XACTERR;\n                    ehci_raise_irq(ehci, USBSTS_ERRINT);\n                }\n                break;\n            case USB_RET_BABBLE:\n                itd->transact[i] |= ITD_XACT_BABBLE;\n                ehci_raise_irq(ehci, USBSTS_ERRINT);\n                break;\n            case USB_RET_NAK:\n                /* no data for us, so do a zero-length transfer */\n                ehci->ipacket.actual_length = 0;\n                break;\n            }\n            if (!dir) {\n                set_field(&itd->transact[i], len - ehci->ipacket.actual_length,\n                          ITD_XACT_LENGTH); /* OUT */\n            } else {\n                set_field(&itd->transact[i], ehci->ipacket.actual_length,\n                          ITD_XACT_LENGTH); /* IN */\n            }\n            if (itd->transact[i] & ITD_XACT_IOC) {\n                ehci_raise_irq(ehci, USBSTS_INT);\n            }\n            itd->transact[i] &= ~ITD_XACT_ACTIVE;\n        }\n    }\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -33,6 +33,7 @@\n             if (off + len > 4096) {\n                 /* transfer crosses page border */\n                 if (pg == 6) {\n+                    qemu_sglist_destroy(&ehci->isgl);\n                     return -1;  /* avoid page pg + 1 */\n                 }\n                 ptr2 = (itd->bufptr[pg + 1] & ITD_BUFPTR_MASK);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "                    qemu_sglist_destroy(&ehci->isgl);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-5993",
        "func_name": "virglrenderer/vrend_renderer_init_blit_ctx",
        "description": "Memory leak in the vrend_renderer_init_blit_ctx function in vrend_blitter.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (host memory consumption) via a large number of VIRGL_CCMD_BLIT commands.",
        "git_url": "https://cgit.freedesktop.org/virglrenderer/commit/?id=6eb13f7a2dcf391ec9e19b4c2a79e68305f63c22",
        "commit_title": "The 'blit_ctx->initialised' is not setted to true.",
        "commit_text": "Every time init blit context, it will create a new 'blit_ctx->gl_context' thus causing a memory leak. This patch avoid this.  ",
        "func_before": "static void vrend_renderer_init_blit_ctx(struct vrend_blitter_ctx *blit_ctx)\n{\n   struct virgl_gl_ctx_param ctx_params;\n   int i;\n   if (blit_ctx->initialised) {\n      vrend_clicbs->make_current(0, blit_ctx->gl_context);\n      return;\n   }\n\n   ctx_params.shared = true;\n   ctx_params.major_ver = VREND_GL_VER_MAJOR;\n   ctx_params.minor_ver = VREND_GL_VER_MINOR;\n   blit_ctx->gl_context = vrend_clicbs->create_gl_context(0, &ctx_params);\n\n   vrend_clicbs->make_current(0, blit_ctx->gl_context);\n   glGenVertexArrays(1, &blit_ctx->vaoid);\n   glGenFramebuffers(1, &blit_ctx->fb_id);\n\n   glGenBuffers(1, &blit_ctx->vbo_id);\n   blit_build_vs_passthrough(blit_ctx);\n\n   for (i = 0; i < 4; i++)\n      blit_ctx->vertices[i][0][3] = 1; /*v.w*/\n   glBindVertexArray(blit_ctx->vaoid);\n   glBindBuffer(GL_ARRAY_BUFFER, blit_ctx->vbo_id);\n}",
        "func": "static void vrend_renderer_init_blit_ctx(struct vrend_blitter_ctx *blit_ctx)\n{\n   struct virgl_gl_ctx_param ctx_params;\n   int i;\n   if (blit_ctx->initialised) {\n      vrend_clicbs->make_current(0, blit_ctx->gl_context);\n      return;\n   }\n\n   blit_ctx->initialised = true;\n   ctx_params.shared = true;\n   ctx_params.major_ver = VREND_GL_VER_MAJOR;\n   ctx_params.minor_ver = VREND_GL_VER_MINOR;\n   blit_ctx->gl_context = vrend_clicbs->create_gl_context(0, &ctx_params);\n\n   vrend_clicbs->make_current(0, blit_ctx->gl_context);\n   glGenVertexArrays(1, &blit_ctx->vaoid);\n   glGenFramebuffers(1, &blit_ctx->fb_id);\n\n   glGenBuffers(1, &blit_ctx->vbo_id);\n   blit_build_vs_passthrough(blit_ctx);\n\n   for (i = 0; i < 4; i++)\n      blit_ctx->vertices[i][0][3] = 1; /*v.w*/\n   glBindVertexArray(blit_ctx->vaoid);\n   glBindBuffer(GL_ARRAY_BUFFER, blit_ctx->vbo_id);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,7 @@\n       return;\n    }\n \n+   blit_ctx->initialised = true;\n    ctx_params.shared = true;\n    ctx_params.major_ver = VREND_GL_VER_MAJOR;\n    ctx_params.minor_ver = VREND_GL_VER_MINOR;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "   blit_ctx->initialised = true;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-6317",
        "func_name": "virglrenderer/add_shader_program",
        "description": "Memory leak in the add_shader_program function in vrend_renderer.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (host memory consumption) via vectors involving the sprog variable.",
        "git_url": "https://cgit.freedesktop.org/virglrenderer/commit/?id=a2f12a1b0f95b13b6f8dc3d05d7b74b4386394e4",
        "commit_title": "Free 'sprog' in error path to avoid memory leak.",
        "commit_text": " ",
        "func_before": "static struct vrend_linked_shader_program *add_shader_program(struct vrend_context *ctx,\n                                                              struct vrend_shader *vs,\n                                                              struct vrend_shader *fs,\n                                                              struct vrend_shader *gs)\n{\n   struct vrend_linked_shader_program *sprog = CALLOC_STRUCT(vrend_linked_shader_program);\n   char name[16];\n   int i;\n   GLuint prog_id;\n   GLint lret;\n   int id;\n   int last_shader;\n   if (!sprog)\n      return NULL;\n\n   /* need to rewrite VS code to add interpolation params */\n   if ((gs && gs->compiled_fs_id != fs->id) ||\n       (!gs && vs->compiled_fs_id != fs->id)) {\n      bool ret;\n\n      if (gs)\n         vrend_patch_vertex_shader_interpolants(gs->glsl_prog,\n                                                &gs->sel->sinfo,\n                                                &fs->sel->sinfo, true, fs->key.flatshade);\n      else\n         vrend_patch_vertex_shader_interpolants(vs->glsl_prog,\n                                                &vs->sel->sinfo,\n                                                &fs->sel->sinfo, false, fs->key.flatshade);\n      ret = vrend_compile_shader(ctx, gs ? gs : vs);\n      if (ret == false) {\n         glDeleteShader(gs ? gs->id : vs->id);\n         free(sprog);\n         return NULL;\n      }\n      if (gs)\n         gs->compiled_fs_id = fs->id;\n      else\n         vs->compiled_fs_id = fs->id;\n   }\n\n   prog_id = glCreateProgram();\n   glAttachShader(prog_id, vs->id);\n   if (gs) {\n      if (gs->id > 0)\n         glAttachShader(prog_id, gs->id);\n      set_stream_out_varyings(prog_id, &gs->sel->sinfo);\n   }\n   else\n      set_stream_out_varyings(prog_id, &vs->sel->sinfo);\n   glAttachShader(prog_id, fs->id);\n\n   if (fs->sel->sinfo.num_outputs > 1) {\n      if (util_blend_state_is_dual(&ctx->sub->blend_state, 0)) {\n         glBindFragDataLocationIndexed(prog_id, 0, 0, \"fsout_c0\");\n         glBindFragDataLocationIndexed(prog_id, 0, 1, \"fsout_c1\");\n         sprog->dual_src_linked = true;\n      } else {\n         glBindFragDataLocationIndexed(prog_id, 0, 0, \"fsout_c0\");\n         glBindFragDataLocationIndexed(prog_id, 1, 0, \"fsout_c1\");\n         sprog->dual_src_linked = false;\n      }\n   } else\n      sprog->dual_src_linked = false;\n\n   if (vrend_state.have_vertex_attrib_binding) {\n      uint32_t mask = vs->sel->sinfo.attrib_input_mask;\n      while (mask) {\n         i = u_bit_scan(&mask);\n         snprintf(name, 10, \"in_%d\", i);\n         glBindAttribLocation(prog_id, i, name);\n      }\n   }\n\n   glLinkProgram(prog_id);\n\n   glGetProgramiv(prog_id, GL_LINK_STATUS, &lret);\n   if (lret == GL_FALSE) {\n      char infolog[65536];\n      int len;\n      glGetProgramInfoLog(prog_id, 65536, &len, infolog);\n      fprintf(stderr,\"got error linking\\n%s\\n\", infolog);\n      /* dump shaders */\n      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SHADER, 0);\n      fprintf(stderr,\"vert shader: %d GLSL\\n%s\\n\", vs->id, vs->glsl_prog);\n      if (gs)\n         fprintf(stderr,\"geom shader: %d GLSL\\n%s\\n\", gs->id, gs->glsl_prog);\n      fprintf(stderr,\"frag shader: %d GLSL\\n%s\\n\", fs->id, fs->glsl_prog);\n      glDeleteProgram(prog_id);\n      return NULL;\n   }\n\n   sprog->ss[PIPE_SHADER_VERTEX] = vs;\n   sprog->ss[PIPE_SHADER_FRAGMENT] = fs;\n   sprog->ss[PIPE_SHADER_GEOMETRY] = gs;\n\n   list_add(&sprog->sl[PIPE_SHADER_VERTEX], &vs->programs);\n   list_add(&sprog->sl[PIPE_SHADER_FRAGMENT], &fs->programs);\n   if (gs)\n      list_add(&sprog->sl[PIPE_SHADER_GEOMETRY], &gs->programs);\n\n   last_shader = gs ? PIPE_SHADER_GEOMETRY : PIPE_SHADER_FRAGMENT;\n   sprog->id = prog_id;\n\n   list_addtail(&sprog->head, &ctx->sub->programs);\n\n   if (fs->key.pstipple_tex)\n      sprog->fs_stipple_loc = glGetUniformLocation(prog_id, \"pstipple_sampler\");\n   else\n      sprog->fs_stipple_loc = -1;\n   sprog->vs_ws_adjust_loc = glGetUniformLocation(prog_id, \"winsys_adjust\");\n   for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {\n      if (sprog->ss[id]->sel->sinfo.samplers_used_mask) {\n         uint32_t mask = sprog->ss[id]->sel->sinfo.samplers_used_mask;\n         int nsamp = util_bitcount(sprog->ss[id]->sel->sinfo.samplers_used_mask);\n         int index;\n         sprog->shadow_samp_mask[id] = sprog->ss[id]->sel->sinfo.shadow_samp_mask;\n         if (sprog->ss[id]->sel->sinfo.shadow_samp_mask) {\n            sprog->shadow_samp_mask_locs[id] = calloc(nsamp, sizeof(uint32_t));\n            sprog->shadow_samp_add_locs[id] = calloc(nsamp, sizeof(uint32_t));\n         } else {\n            sprog->shadow_samp_mask_locs[id] = sprog->shadow_samp_add_locs[id] = NULL;\n         }\n         sprog->samp_locs[id] = calloc(nsamp, sizeof(uint32_t));\n         if (sprog->samp_locs[id]) {\n            const char *prefix = pipe_shader_to_prefix(id);\n            index = 0;\n            while(mask) {\n               i = u_bit_scan(&mask);\n               snprintf(name, 10, \"%ssamp%d\", prefix, i);\n               sprog->samp_locs[id][index] = glGetUniformLocation(prog_id, name);\n               if (sprog->ss[id]->sel->sinfo.shadow_samp_mask & (1 << i)) {\n                  snprintf(name, 14, \"%sshadmask%d\", prefix, i);\n                  sprog->shadow_samp_mask_locs[id][index] = glGetUniformLocation(prog_id, name);\n                  snprintf(name, 14, \"%sshadadd%d\", prefix, i);\n                  sprog->shadow_samp_add_locs[id][index] = glGetUniformLocation(prog_id, name);\n               }\n               index++;\n            }\n         }\n      } else {\n         sprog->samp_locs[id] = NULL;\n         sprog->shadow_samp_mask_locs[id] = NULL;\n         sprog->shadow_samp_add_locs[id] = NULL;\n         sprog->shadow_samp_mask[id] = 0;\n      }\n      sprog->samplers_used_mask[id] = sprog->ss[id]->sel->sinfo.samplers_used_mask;\n   }\n\n   for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {\n      if (sprog->ss[id]->sel->sinfo.num_consts) {\n         sprog->const_locs[id] = calloc(sprog->ss[id]->sel->sinfo.num_consts, sizeof(uint32_t));\n         if (sprog->const_locs[id]) {\n            const char *prefix = pipe_shader_to_prefix(id);\n            for (i = 0; i < sprog->ss[id]->sel->sinfo.num_consts; i++) {\n               snprintf(name, 16, \"%sconst0[%d]\", prefix, i);\n               sprog->const_locs[id][i] = glGetUniformLocation(prog_id, name);\n            }\n         }\n      } else\n         sprog->const_locs[id] = NULL;\n   }\n\n   if (!vrend_state.have_vertex_attrib_binding) {\n      if (vs->sel->sinfo.num_inputs) {\n         sprog->attrib_locs = calloc(vs->sel->sinfo.num_inputs, sizeof(uint32_t));\n         if (sprog->attrib_locs) {\n            for (i = 0; i < vs->sel->sinfo.num_inputs; i++) {\n               snprintf(name, 10, \"in_%d\", i);\n               sprog->attrib_locs[i] = glGetAttribLocation(prog_id, name);\n            }\n         }\n      } else\n         sprog->attrib_locs = NULL;\n   }\n\n   for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {\n      if (sprog->ss[id]->sel->sinfo.num_ubos) {\n         const char *prefix = pipe_shader_to_prefix(id);\n\n         sprog->ubo_locs[id] = calloc(sprog->ss[id]->sel->sinfo.num_ubos, sizeof(uint32_t));\n         for (i = 0; i < sprog->ss[id]->sel->sinfo.num_ubos; i++) {\n            snprintf(name, 16, \"%subo%d\", prefix, i + 1);\n            sprog->ubo_locs[id][i] = glGetUniformBlockIndex(prog_id, name);\n         }\n      } else\n         sprog->ubo_locs[id] = NULL;\n   }\n\n   if (vs->sel->sinfo.num_ucp) {\n      for (i = 0; i < vs->sel->sinfo.num_ucp; i++) {\n         snprintf(name, 10, \"clipp[%d]\", i);\n         sprog->clip_locs[i] = glGetUniformLocation(prog_id, name);\n      }\n   }\n   return sprog;\n}",
        "func": "static struct vrend_linked_shader_program *add_shader_program(struct vrend_context *ctx,\n                                                              struct vrend_shader *vs,\n                                                              struct vrend_shader *fs,\n                                                              struct vrend_shader *gs)\n{\n   struct vrend_linked_shader_program *sprog = CALLOC_STRUCT(vrend_linked_shader_program);\n   char name[16];\n   int i;\n   GLuint prog_id;\n   GLint lret;\n   int id;\n   int last_shader;\n   if (!sprog)\n      return NULL;\n\n   /* need to rewrite VS code to add interpolation params */\n   if ((gs && gs->compiled_fs_id != fs->id) ||\n       (!gs && vs->compiled_fs_id != fs->id)) {\n      bool ret;\n\n      if (gs)\n         vrend_patch_vertex_shader_interpolants(gs->glsl_prog,\n                                                &gs->sel->sinfo,\n                                                &fs->sel->sinfo, true, fs->key.flatshade);\n      else\n         vrend_patch_vertex_shader_interpolants(vs->glsl_prog,\n                                                &vs->sel->sinfo,\n                                                &fs->sel->sinfo, false, fs->key.flatshade);\n      ret = vrend_compile_shader(ctx, gs ? gs : vs);\n      if (ret == false) {\n         glDeleteShader(gs ? gs->id : vs->id);\n         free(sprog);\n         return NULL;\n      }\n      if (gs)\n         gs->compiled_fs_id = fs->id;\n      else\n         vs->compiled_fs_id = fs->id;\n   }\n\n   prog_id = glCreateProgram();\n   glAttachShader(prog_id, vs->id);\n   if (gs) {\n      if (gs->id > 0)\n         glAttachShader(prog_id, gs->id);\n      set_stream_out_varyings(prog_id, &gs->sel->sinfo);\n   }\n   else\n      set_stream_out_varyings(prog_id, &vs->sel->sinfo);\n   glAttachShader(prog_id, fs->id);\n\n   if (fs->sel->sinfo.num_outputs > 1) {\n      if (util_blend_state_is_dual(&ctx->sub->blend_state, 0)) {\n         glBindFragDataLocationIndexed(prog_id, 0, 0, \"fsout_c0\");\n         glBindFragDataLocationIndexed(prog_id, 0, 1, \"fsout_c1\");\n         sprog->dual_src_linked = true;\n      } else {\n         glBindFragDataLocationIndexed(prog_id, 0, 0, \"fsout_c0\");\n         glBindFragDataLocationIndexed(prog_id, 1, 0, \"fsout_c1\");\n         sprog->dual_src_linked = false;\n      }\n   } else\n      sprog->dual_src_linked = false;\n\n   if (vrend_state.have_vertex_attrib_binding) {\n      uint32_t mask = vs->sel->sinfo.attrib_input_mask;\n      while (mask) {\n         i = u_bit_scan(&mask);\n         snprintf(name, 10, \"in_%d\", i);\n         glBindAttribLocation(prog_id, i, name);\n      }\n   }\n\n   glLinkProgram(prog_id);\n\n   glGetProgramiv(prog_id, GL_LINK_STATUS, &lret);\n   if (lret == GL_FALSE) {\n      char infolog[65536];\n      int len;\n      glGetProgramInfoLog(prog_id, 65536, &len, infolog);\n      fprintf(stderr,\"got error linking\\n%s\\n\", infolog);\n      /* dump shaders */\n      report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SHADER, 0);\n      fprintf(stderr,\"vert shader: %d GLSL\\n%s\\n\", vs->id, vs->glsl_prog);\n      if (gs)\n         fprintf(stderr,\"geom shader: %d GLSL\\n%s\\n\", gs->id, gs->glsl_prog);\n      fprintf(stderr,\"frag shader: %d GLSL\\n%s\\n\", fs->id, fs->glsl_prog);\n      glDeleteProgram(prog_id);\n      free(sprog);\n      return NULL;\n   }\n\n   sprog->ss[PIPE_SHADER_VERTEX] = vs;\n   sprog->ss[PIPE_SHADER_FRAGMENT] = fs;\n   sprog->ss[PIPE_SHADER_GEOMETRY] = gs;\n\n   list_add(&sprog->sl[PIPE_SHADER_VERTEX], &vs->programs);\n   list_add(&sprog->sl[PIPE_SHADER_FRAGMENT], &fs->programs);\n   if (gs)\n      list_add(&sprog->sl[PIPE_SHADER_GEOMETRY], &gs->programs);\n\n   last_shader = gs ? PIPE_SHADER_GEOMETRY : PIPE_SHADER_FRAGMENT;\n   sprog->id = prog_id;\n\n   list_addtail(&sprog->head, &ctx->sub->programs);\n\n   if (fs->key.pstipple_tex)\n      sprog->fs_stipple_loc = glGetUniformLocation(prog_id, \"pstipple_sampler\");\n   else\n      sprog->fs_stipple_loc = -1;\n   sprog->vs_ws_adjust_loc = glGetUniformLocation(prog_id, \"winsys_adjust\");\n   for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {\n      if (sprog->ss[id]->sel->sinfo.samplers_used_mask) {\n         uint32_t mask = sprog->ss[id]->sel->sinfo.samplers_used_mask;\n         int nsamp = util_bitcount(sprog->ss[id]->sel->sinfo.samplers_used_mask);\n         int index;\n         sprog->shadow_samp_mask[id] = sprog->ss[id]->sel->sinfo.shadow_samp_mask;\n         if (sprog->ss[id]->sel->sinfo.shadow_samp_mask) {\n            sprog->shadow_samp_mask_locs[id] = calloc(nsamp, sizeof(uint32_t));\n            sprog->shadow_samp_add_locs[id] = calloc(nsamp, sizeof(uint32_t));\n         } else {\n            sprog->shadow_samp_mask_locs[id] = sprog->shadow_samp_add_locs[id] = NULL;\n         }\n         sprog->samp_locs[id] = calloc(nsamp, sizeof(uint32_t));\n         if (sprog->samp_locs[id]) {\n            const char *prefix = pipe_shader_to_prefix(id);\n            index = 0;\n            while(mask) {\n               i = u_bit_scan(&mask);\n               snprintf(name, 10, \"%ssamp%d\", prefix, i);\n               sprog->samp_locs[id][index] = glGetUniformLocation(prog_id, name);\n               if (sprog->ss[id]->sel->sinfo.shadow_samp_mask & (1 << i)) {\n                  snprintf(name, 14, \"%sshadmask%d\", prefix, i);\n                  sprog->shadow_samp_mask_locs[id][index] = glGetUniformLocation(prog_id, name);\n                  snprintf(name, 14, \"%sshadadd%d\", prefix, i);\n                  sprog->shadow_samp_add_locs[id][index] = glGetUniformLocation(prog_id, name);\n               }\n               index++;\n            }\n         }\n      } else {\n         sprog->samp_locs[id] = NULL;\n         sprog->shadow_samp_mask_locs[id] = NULL;\n         sprog->shadow_samp_add_locs[id] = NULL;\n         sprog->shadow_samp_mask[id] = 0;\n      }\n      sprog->samplers_used_mask[id] = sprog->ss[id]->sel->sinfo.samplers_used_mask;\n   }\n\n   for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {\n      if (sprog->ss[id]->sel->sinfo.num_consts) {\n         sprog->const_locs[id] = calloc(sprog->ss[id]->sel->sinfo.num_consts, sizeof(uint32_t));\n         if (sprog->const_locs[id]) {\n            const char *prefix = pipe_shader_to_prefix(id);\n            for (i = 0; i < sprog->ss[id]->sel->sinfo.num_consts; i++) {\n               snprintf(name, 16, \"%sconst0[%d]\", prefix, i);\n               sprog->const_locs[id][i] = glGetUniformLocation(prog_id, name);\n            }\n         }\n      } else\n         sprog->const_locs[id] = NULL;\n   }\n\n   if (!vrend_state.have_vertex_attrib_binding) {\n      if (vs->sel->sinfo.num_inputs) {\n         sprog->attrib_locs = calloc(vs->sel->sinfo.num_inputs, sizeof(uint32_t));\n         if (sprog->attrib_locs) {\n            for (i = 0; i < vs->sel->sinfo.num_inputs; i++) {\n               snprintf(name, 10, \"in_%d\", i);\n               sprog->attrib_locs[i] = glGetAttribLocation(prog_id, name);\n            }\n         }\n      } else\n         sprog->attrib_locs = NULL;\n   }\n\n   for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) {\n      if (sprog->ss[id]->sel->sinfo.num_ubos) {\n         const char *prefix = pipe_shader_to_prefix(id);\n\n         sprog->ubo_locs[id] = calloc(sprog->ss[id]->sel->sinfo.num_ubos, sizeof(uint32_t));\n         for (i = 0; i < sprog->ss[id]->sel->sinfo.num_ubos; i++) {\n            snprintf(name, 16, \"%subo%d\", prefix, i + 1);\n            sprog->ubo_locs[id][i] = glGetUniformBlockIndex(prog_id, name);\n         }\n      } else\n         sprog->ubo_locs[id] = NULL;\n   }\n\n   if (vs->sel->sinfo.num_ucp) {\n      for (i = 0; i < vs->sel->sinfo.num_ucp; i++) {\n         snprintf(name, 10, \"clipp[%d]\", i);\n         sprog->clip_locs[i] = glGetUniformLocation(prog_id, name);\n      }\n   }\n   return sprog;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -86,6 +86,7 @@\n          fprintf(stderr,\"geom shader: %d GLSL\\n%s\\n\", gs->id, gs->glsl_prog);\n       fprintf(stderr,\"frag shader: %d GLSL\\n%s\\n\", fs->id, fs->glsl_prog);\n       glDeleteProgram(prog_id);\n+      free(sprog);\n       return NULL;\n    }\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      free(sprog);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-6386",
        "func_name": "virglrenderer/vrend_create_vertex_elements_state",
        "description": "Memory leak in the vrend_create_vertex_elements_state function in vrend_renderer.c in virglrenderer allows local guest OS users to cause a denial of service (host memory consumption) via a large number of VIRGL_OBJECT_VERTEX_ELEMENTS commands.",
        "git_url": "https://cgit.freedesktop.org/virglrenderer/commit/?id=737c3350850ca4dbc5633b3bdb4118176ce59920",
        "commit_title": "Free the vertex array in error path.",
        "commit_text": "This was introduced by this commit: renderer: fix heap overflow in vertex elements state create.  I rewrote the code to not require the allocation in the first place if we have an error, seems nicer.  ",
        "func_before": "int vrend_create_vertex_elements_state(struct vrend_context *ctx,\n                                       uint32_t handle,\n                                       unsigned num_elements,\n                                       const struct pipe_vertex_element *elements)\n{\n   struct vrend_vertex_element_array *v = CALLOC_STRUCT(vrend_vertex_element_array);\n   const struct util_format_description *desc;\n   GLenum type;\n   int i;\n   uint32_t ret_handle;\n\n   if (!v)\n      return ENOMEM;\n\n   if (num_elements > PIPE_MAX_ATTRIBS)\n      return EINVAL;\n\n   v->count = num_elements;\n   for (i = 0; i < num_elements; i++) {\n      memcpy(&v->elements[i].base, &elements[i], sizeof(struct pipe_vertex_element));\n\n      desc = util_format_description(elements[i].src_format);\n      if (!desc) {\n         FREE(v);\n         return EINVAL;\n      }\n\n      type = GL_FALSE;\n      if (desc->channel[0].type == UTIL_FORMAT_TYPE_FLOAT) {\n         if (desc->channel[0].size == 32)\n            type = GL_FLOAT;\n         else if (desc->channel[0].size == 64)\n            type = GL_DOUBLE;\n         else if (desc->channel[0].size == 16)\n            type = GL_HALF_FLOAT;\n      } else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&\n                 desc->channel[0].size == 8)\n         type = GL_UNSIGNED_BYTE;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&\n               desc->channel[0].size == 8)\n         type = GL_BYTE;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&\n               desc->channel[0].size == 16)\n         type = GL_UNSIGNED_SHORT;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&\n               desc->channel[0].size == 16)\n         type = GL_SHORT;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&\n               desc->channel[0].size == 32)\n         type = GL_UNSIGNED_INT;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&\n               desc->channel[0].size == 32)\n         type = GL_INT;\n      else if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_SSCALED ||\n               elements[i].src_format == PIPE_FORMAT_R10G10B10A2_SNORM ||\n               elements[i].src_format == PIPE_FORMAT_B10G10R10A2_SNORM)\n         type = GL_INT_2_10_10_10_REV;\n      else if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_USCALED ||\n               elements[i].src_format == PIPE_FORMAT_R10G10B10A2_UNORM ||\n               elements[i].src_format == PIPE_FORMAT_B10G10R10A2_UNORM)\n         type = GL_UNSIGNED_INT_2_10_10_10_REV;\n      else if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT)\n         type = GL_UNSIGNED_INT_10F_11F_11F_REV;\n\n      if (type == GL_FALSE) {\n         report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_VERTEX_FORMAT, elements[i].src_format);\n         FREE(v);\n         return EINVAL;\n      }\n\n      v->elements[i].type = type;\n      if (desc->channel[0].normalized)\n         v->elements[i].norm = GL_TRUE;\n      if (desc->nr_channels == 4 && desc->swizzle[0] == UTIL_FORMAT_SWIZZLE_Z)\n         v->elements[i].nr_chan = GL_BGRA;\n      else if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT)\n         v->elements[i].nr_chan = 3;\n      else\n         v->elements[i].nr_chan = desc->nr_channels;\n   }\n\n   if (vrend_state.have_vertex_attrib_binding) {\n      glGenVertexArrays(1, &v->id);\n      glBindVertexArray(v->id);\n      for (i = 0; i < num_elements; i++) {\n         struct vrend_vertex_element *ve = &v->elements[i];\n\n         if (util_format_is_pure_integer(ve->base.src_format))\n            glVertexAttribIFormat(i, ve->nr_chan, ve->type, ve->base.src_offset);\n         else\n            glVertexAttribFormat(i, ve->nr_chan, ve->type, ve->norm, ve->base.src_offset);\n         glVertexAttribBinding(i, ve->base.vertex_buffer_index);\n         glVertexBindingDivisor(i, ve->base.instance_divisor);\n         glEnableVertexAttribArray(i);\n      }\n   }\n   ret_handle = vrend_renderer_object_insert(ctx, v, sizeof(struct vrend_vertex_element), handle,\n                                             VIRGL_OBJECT_VERTEX_ELEMENTS);\n   if (!ret_handle) {\n      FREE(v);\n      return ENOMEM;\n   }\n   return 0;\n}",
        "func": "int vrend_create_vertex_elements_state(struct vrend_context *ctx,\n                                       uint32_t handle,\n                                       unsigned num_elements,\n                                       const struct pipe_vertex_element *elements)\n{\n   struct vrend_vertex_element_array *v;\n   const struct util_format_description *desc;\n   GLenum type;\n   int i;\n   uint32_t ret_handle;\n\n   if (num_elements > PIPE_MAX_ATTRIBS)\n      return EINVAL;\n\n   v = CALLOC_STRUCT(vrend_vertex_element_array);\n   if (!v)\n      return ENOMEM;\n\n   v->count = num_elements;\n   for (i = 0; i < num_elements; i++) {\n      memcpy(&v->elements[i].base, &elements[i], sizeof(struct pipe_vertex_element));\n\n      desc = util_format_description(elements[i].src_format);\n      if (!desc) {\n         FREE(v);\n         return EINVAL;\n      }\n\n      type = GL_FALSE;\n      if (desc->channel[0].type == UTIL_FORMAT_TYPE_FLOAT) {\n         if (desc->channel[0].size == 32)\n            type = GL_FLOAT;\n         else if (desc->channel[0].size == 64)\n            type = GL_DOUBLE;\n         else if (desc->channel[0].size == 16)\n            type = GL_HALF_FLOAT;\n      } else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&\n                 desc->channel[0].size == 8)\n         type = GL_UNSIGNED_BYTE;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&\n               desc->channel[0].size == 8)\n         type = GL_BYTE;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&\n               desc->channel[0].size == 16)\n         type = GL_UNSIGNED_SHORT;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&\n               desc->channel[0].size == 16)\n         type = GL_SHORT;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED &&\n               desc->channel[0].size == 32)\n         type = GL_UNSIGNED_INT;\n      else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED &&\n               desc->channel[0].size == 32)\n         type = GL_INT;\n      else if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_SSCALED ||\n               elements[i].src_format == PIPE_FORMAT_R10G10B10A2_SNORM ||\n               elements[i].src_format == PIPE_FORMAT_B10G10R10A2_SNORM)\n         type = GL_INT_2_10_10_10_REV;\n      else if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_USCALED ||\n               elements[i].src_format == PIPE_FORMAT_R10G10B10A2_UNORM ||\n               elements[i].src_format == PIPE_FORMAT_B10G10R10A2_UNORM)\n         type = GL_UNSIGNED_INT_2_10_10_10_REV;\n      else if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT)\n         type = GL_UNSIGNED_INT_10F_11F_11F_REV;\n\n      if (type == GL_FALSE) {\n         report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_VERTEX_FORMAT, elements[i].src_format);\n         FREE(v);\n         return EINVAL;\n      }\n\n      v->elements[i].type = type;\n      if (desc->channel[0].normalized)\n         v->elements[i].norm = GL_TRUE;\n      if (desc->nr_channels == 4 && desc->swizzle[0] == UTIL_FORMAT_SWIZZLE_Z)\n         v->elements[i].nr_chan = GL_BGRA;\n      else if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT)\n         v->elements[i].nr_chan = 3;\n      else\n         v->elements[i].nr_chan = desc->nr_channels;\n   }\n\n   if (vrend_state.have_vertex_attrib_binding) {\n      glGenVertexArrays(1, &v->id);\n      glBindVertexArray(v->id);\n      for (i = 0; i < num_elements; i++) {\n         struct vrend_vertex_element *ve = &v->elements[i];\n\n         if (util_format_is_pure_integer(ve->base.src_format))\n            glVertexAttribIFormat(i, ve->nr_chan, ve->type, ve->base.src_offset);\n         else\n            glVertexAttribFormat(i, ve->nr_chan, ve->type, ve->norm, ve->base.src_offset);\n         glVertexAttribBinding(i, ve->base.vertex_buffer_index);\n         glVertexBindingDivisor(i, ve->base.instance_divisor);\n         glEnableVertexAttribArray(i);\n      }\n   }\n   ret_handle = vrend_renderer_object_insert(ctx, v, sizeof(struct vrend_vertex_element), handle,\n                                             VIRGL_OBJECT_VERTEX_ELEMENTS);\n   if (!ret_handle) {\n      FREE(v);\n      return ENOMEM;\n   }\n   return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,17 +3,18 @@\n                                        unsigned num_elements,\n                                        const struct pipe_vertex_element *elements)\n {\n-   struct vrend_vertex_element_array *v = CALLOC_STRUCT(vrend_vertex_element_array);\n+   struct vrend_vertex_element_array *v;\n    const struct util_format_description *desc;\n    GLenum type;\n    int i;\n    uint32_t ret_handle;\n \n+   if (num_elements > PIPE_MAX_ATTRIBS)\n+      return EINVAL;\n+\n+   v = CALLOC_STRUCT(vrend_vertex_element_array);\n    if (!v)\n       return ENOMEM;\n-\n-   if (num_elements > PIPE_MAX_ATTRIBS)\n-      return EINVAL;\n \n    v->count = num_elements;\n    for (i = 0; i < num_elements; i++) {",
        "diff_line_info": {
            "deleted_lines": [
                "   struct vrend_vertex_element_array *v = CALLOC_STRUCT(vrend_vertex_element_array);",
                "",
                "   if (num_elements > PIPE_MAX_ATTRIBS)",
                "      return EINVAL;"
            ],
            "added_lines": [
                "   struct vrend_vertex_element_array *v;",
                "   if (num_elements > PIPE_MAX_ATTRIBS)",
                "      return EINVAL;",
                "",
                "   v = CALLOC_STRUCT(vrend_vertex_element_array);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-6414",
        "func_name": "spice/libcacard/vcard_apdu_new",
        "description": "Memory leak in the vcard_apdu_new function in card_7816.c in libcacard before 2.5.3 allows local guest OS users to cause a denial of service (host memory consumption) via vectors related to allocating a new APDU object.",
        "git_url": "https://cgit.freedesktop.org/spice/libcacard/commit/?id=9113dc6a303604a2d9812ac70c17d076ef11886c",
        "commit_title": "In the error path, 'new_apdu->a_data' is not freed.",
        "commit_text": "This can be triggered by the guest continuely.  ",
        "func_before": "VCardAPDU *\nvcard_apdu_new(unsigned char *raw_apdu, int len, vcard_7816_status_t *status)\n{\n    VCardAPDU *new_apdu;\n\n    *status = VCARD7816_STATUS_EXC_ERROR_MEMORY_FAILURE;\n    if (len < 4) {\n        *status = VCARD7816_STATUS_ERROR_WRONG_LENGTH;\n        return NULL;\n    }\n\n    new_apdu = g_new(VCardAPDU, 1);\n    new_apdu->a_data = g_memdup(raw_apdu, len);\n    new_apdu->a_len = len;\n    *status = vcard_apdu_set_class(new_apdu);\n    if (*status != VCARD7816_STATUS_SUCCESS) {\n        g_free(new_apdu);\n        return NULL;\n    }\n    *status = vcard_apdu_set_length(new_apdu);\n    if (*status != VCARD7816_STATUS_SUCCESS) {\n        g_free(new_apdu);\n        new_apdu = NULL;\n    }\n    return new_apdu;\n}",
        "func": "VCardAPDU *\nvcard_apdu_new(unsigned char *raw_apdu, int len, vcard_7816_status_t *status)\n{\n    VCardAPDU *new_apdu;\n\n    *status = VCARD7816_STATUS_EXC_ERROR_MEMORY_FAILURE;\n    if (len < 4) {\n        *status = VCARD7816_STATUS_ERROR_WRONG_LENGTH;\n        return NULL;\n    }\n\n    new_apdu = g_new(VCardAPDU, 1);\n    new_apdu->a_data = g_memdup(raw_apdu, len);\n    new_apdu->a_len = len;\n    *status = vcard_apdu_set_class(new_apdu);\n    if (*status != VCARD7816_STATUS_SUCCESS) {\n        vcard_apdu_delete(new_apdu);\n        return NULL;\n    }\n    *status = vcard_apdu_set_length(new_apdu);\n    if (*status != VCARD7816_STATUS_SUCCESS) {\n        vcard_apdu_delete(new_apdu);\n        new_apdu = NULL;\n    }\n    return new_apdu;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,12 +14,12 @@\n     new_apdu->a_len = len;\n     *status = vcard_apdu_set_class(new_apdu);\n     if (*status != VCARD7816_STATUS_SUCCESS) {\n-        g_free(new_apdu);\n+        vcard_apdu_delete(new_apdu);\n         return NULL;\n     }\n     *status = vcard_apdu_set_length(new_apdu);\n     if (*status != VCARD7816_STATUS_SUCCESS) {\n-        g_free(new_apdu);\n+        vcard_apdu_delete(new_apdu);\n         new_apdu = NULL;\n     }\n     return new_apdu;",
        "diff_line_info": {
            "deleted_lines": [
                "        g_free(new_apdu);",
                "        g_free(new_apdu);"
            ],
            "added_lines": [
                "        vcard_apdu_delete(new_apdu);",
                "        vcard_apdu_delete(new_apdu);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7392",
        "func_name": "TigerVNC/tigervnc/SSecurityVeNCrypt::~SSecurityVeNCrypt",
        "description": "In TigerVNC 1.7.1 (SSecurityVeNCrypt.cxx SSecurityVeNCrypt::SSecurityVeNCrypt), an unauthenticated client can cause a small memory leak in the server.",
        "git_url": "https://github.com/TigerVNC/tigervnc/commit/8f3e8663b3cf57c0b62d939d6953fbfcc112aadd",
        "commit_title": "Delete underlying ssecurity in SSecurityVeNCrypt.",
        "commit_text": " Otherwise it gets leaked which would allow even not authenticated clients to exhaust server memory.",
        "func_before": "SSecurityVeNCrypt::~SSecurityVeNCrypt()\n{\n  if (subTypes) {\n    delete [] subTypes;\n    subTypes = NULL;\n  }\n}",
        "func": "SSecurityVeNCrypt::~SSecurityVeNCrypt()\n{\n  delete ssecurity;\n\n  if (subTypes) {\n    delete [] subTypes;\n    subTypes = NULL;\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,7 @@\n SSecurityVeNCrypt::~SSecurityVeNCrypt()\n {\n+  delete ssecurity;\n+\n   if (subTypes) {\n     delete [] subTypes;\n     subTypes = NULL;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  delete ssecurity;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7396",
        "func_name": "TigerVNC/tigervnc/SConnection::SConnection",
        "description": "In TigerVNC 1.7.1 (CConnection.cxx CConnection::CConnection), an unauthenticated client can cause a small memory leak in the server.",
        "git_url": "https://github.com/TigerVNC/tigervnc/commit/dccb5f7d776e93863ae10bbff56a45c523c6eeb0",
        "commit_title": "Prevent leak of SecurityServer and ClientServer.",
        "commit_text": " They are created in SConnection's and CConnection's constructors but never destroyed.  There is no reason for the indirection, so lets make them direct members.",
        "func_before": "SConnection::SConnection()\n  : readyForSetColourMapEntries(false),\n    is(0), os(0), reader_(0), writer_(0),\n    security(0), ssecurity(0), state_(RFBSTATE_UNINITIALISED),\n    preferredEncoding(encodingRaw)\n{\n  defaultMajorVersion = 3;\n  defaultMinorVersion = 8;\n  if (rfb::Server::protocol3_3)\n    defaultMinorVersion = 3;\n\n  cp.setVersion(defaultMajorVersion, defaultMinorVersion);\n\n  security = new SecurityServer();\n}",
        "func": "SConnection::SConnection()\n  : readyForSetColourMapEntries(false),\n    is(0), os(0), reader_(0), writer_(0),\n    ssecurity(0), state_(RFBSTATE_UNINITIALISED),\n    preferredEncoding(encodingRaw)\n{\n  defaultMajorVersion = 3;\n  defaultMinorVersion = 8;\n  if (rfb::Server::protocol3_3)\n    defaultMinorVersion = 3;\n\n  cp.setVersion(defaultMajorVersion, defaultMinorVersion);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n SConnection::SConnection()\n   : readyForSetColourMapEntries(false),\n     is(0), os(0), reader_(0), writer_(0),\n-    security(0), ssecurity(0), state_(RFBSTATE_UNINITIALISED),\n+    ssecurity(0), state_(RFBSTATE_UNINITIALISED),\n     preferredEncoding(encodingRaw)\n {\n   defaultMajorVersion = 3;\n@@ -10,6 +10,4 @@\n     defaultMinorVersion = 3;\n \n   cp.setVersion(defaultMajorVersion, defaultMinorVersion);\n-\n-  security = new SecurityServer();\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    security(0), ssecurity(0), state_(RFBSTATE_UNINITIALISED),",
                "",
                "  security = new SecurityServer();"
            ],
            "added_lines": [
                "    ssecurity(0), state_(RFBSTATE_UNINITIALISED),"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7396",
        "func_name": "TigerVNC/tigervnc/SConnection::processVersionMsg",
        "description": "In TigerVNC 1.7.1 (CConnection.cxx CConnection::CConnection), an unauthenticated client can cause a small memory leak in the server.",
        "git_url": "https://github.com/TigerVNC/tigervnc/commit/dccb5f7d776e93863ae10bbff56a45c523c6eeb0",
        "commit_title": "Prevent leak of SecurityServer and ClientServer.",
        "commit_text": " They are created in SConnection's and CConnection's constructors but never destroyed.  There is no reason for the indirection, so lets make them direct members.",
        "func_before": "void SConnection::processVersionMsg()\n{\n  vlog.debug(\"reading protocol version\");\n  bool done;\n  if (!cp.readVersion(is, &done)) {\n    state_ = RFBSTATE_INVALID;\n    throw Exception(\"reading version failed: not an RFB client?\");\n  }\n  if (!done) return;\n\n  vlog.info(\"Client needs protocol version %d.%d\",\n            cp.majorVersion, cp.minorVersion);\n\n  if (cp.majorVersion != 3) {\n    // unknown protocol version\n    char msg[256];\n    sprintf(msg,\"Error: client needs protocol version %d.%d, server has %d.%d\",\n            cp.majorVersion, cp.minorVersion,\n            defaultMajorVersion, defaultMinorVersion);\n    throwConnFailedException(msg);\n  }\n\n  if (cp.minorVersion != 3 && cp.minorVersion != 7 && cp.minorVersion != 8) {\n    vlog.error(\"Client uses unofficial protocol version %d.%d\",\n               cp.majorVersion,cp.minorVersion);\n    if (cp.minorVersion >= 8)\n      cp.minorVersion = 8;\n    else if (cp.minorVersion == 7)\n      cp.minorVersion = 7;\n    else\n      cp.minorVersion = 3;\n    vlog.error(\"Assuming compatibility with version %d.%d\",\n               cp.majorVersion,cp.minorVersion);\n  }\n\n  versionReceived();\n\n  std::list<rdr::U8> secTypes;\n  std::list<rdr::U8>::iterator i;\n  secTypes = security->GetEnabledSecTypes();\n\n  if (cp.isVersion(3,3)) {\n\n    // cope with legacy 3.3 client only if \"no authentication\" or \"vnc\n    // authentication\" is supported.\n    for (i=secTypes.begin(); i!=secTypes.end(); i++) {\n      if (*i == secTypeNone || *i == secTypeVncAuth) break;\n    }\n    if (i == secTypes.end()) {\n      char msg[256];\n      sprintf(msg,\"No supported security type for %d.%d client\",\n              cp.majorVersion, cp.minorVersion);\n      throwConnFailedException(msg);\n    }\n\n    os->writeU32(*i);\n    if (*i == secTypeNone) os->flush();\n    state_ = RFBSTATE_SECURITY;\n    ssecurity = security->GetSSecurity(*i);\n    processSecurityMsg();\n    return;\n  }\n\n  // list supported security types for >=3.7 clients\n\n  if (secTypes.empty())\n    throwConnFailedException(\"No supported security types\");\n\n  os->writeU8(secTypes.size());\n  for (i=secTypes.begin(); i!=secTypes.end(); i++)\n    os->writeU8(*i);\n  os->flush();\n  state_ = RFBSTATE_SECURITY_TYPE;\n}",
        "func": "void SConnection::processVersionMsg()\n{\n  vlog.debug(\"reading protocol version\");\n  bool done;\n  if (!cp.readVersion(is, &done)) {\n    state_ = RFBSTATE_INVALID;\n    throw Exception(\"reading version failed: not an RFB client?\");\n  }\n  if (!done) return;\n\n  vlog.info(\"Client needs protocol version %d.%d\",\n            cp.majorVersion, cp.minorVersion);\n\n  if (cp.majorVersion != 3) {\n    // unknown protocol version\n    char msg[256];\n    sprintf(msg,\"Error: client needs protocol version %d.%d, server has %d.%d\",\n            cp.majorVersion, cp.minorVersion,\n            defaultMajorVersion, defaultMinorVersion);\n    throwConnFailedException(msg);\n  }\n\n  if (cp.minorVersion != 3 && cp.minorVersion != 7 && cp.minorVersion != 8) {\n    vlog.error(\"Client uses unofficial protocol version %d.%d\",\n               cp.majorVersion,cp.minorVersion);\n    if (cp.minorVersion >= 8)\n      cp.minorVersion = 8;\n    else if (cp.minorVersion == 7)\n      cp.minorVersion = 7;\n    else\n      cp.minorVersion = 3;\n    vlog.error(\"Assuming compatibility with version %d.%d\",\n               cp.majorVersion,cp.minorVersion);\n  }\n\n  versionReceived();\n\n  std::list<rdr::U8> secTypes;\n  std::list<rdr::U8>::iterator i;\n  secTypes = security.GetEnabledSecTypes();\n\n  if (cp.isVersion(3,3)) {\n\n    // cope with legacy 3.3 client only if \"no authentication\" or \"vnc\n    // authentication\" is supported.\n    for (i=secTypes.begin(); i!=secTypes.end(); i++) {\n      if (*i == secTypeNone || *i == secTypeVncAuth) break;\n    }\n    if (i == secTypes.end()) {\n      char msg[256];\n      sprintf(msg,\"No supported security type for %d.%d client\",\n              cp.majorVersion, cp.minorVersion);\n      throwConnFailedException(msg);\n    }\n\n    os->writeU32(*i);\n    if (*i == secTypeNone) os->flush();\n    state_ = RFBSTATE_SECURITY;\n    ssecurity = security.GetSSecurity(*i);\n    processSecurityMsg();\n    return;\n  }\n\n  // list supported security types for >=3.7 clients\n\n  if (secTypes.empty())\n    throwConnFailedException(\"No supported security types\");\n\n  os->writeU8(secTypes.size());\n  for (i=secTypes.begin(); i!=secTypes.end(); i++)\n    os->writeU8(*i);\n  os->flush();\n  state_ = RFBSTATE_SECURITY_TYPE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -37,7 +37,7 @@\n \n   std::list<rdr::U8> secTypes;\n   std::list<rdr::U8>::iterator i;\n-  secTypes = security->GetEnabledSecTypes();\n+  secTypes = security.GetEnabledSecTypes();\n \n   if (cp.isVersion(3,3)) {\n \n@@ -56,7 +56,7 @@\n     os->writeU32(*i);\n     if (*i == secTypeNone) os->flush();\n     state_ = RFBSTATE_SECURITY;\n-    ssecurity = security->GetSSecurity(*i);\n+    ssecurity = security.GetSSecurity(*i);\n     processSecurityMsg();\n     return;\n   }",
        "diff_line_info": {
            "deleted_lines": [
                "  secTypes = security->GetEnabledSecTypes();",
                "    ssecurity = security->GetSSecurity(*i);"
            ],
            "added_lines": [
                "  secTypes = security.GetEnabledSecTypes();",
                "    ssecurity = security.GetSSecurity(*i);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7396",
        "func_name": "TigerVNC/tigervnc/SConnection::processSecurityType",
        "description": "In TigerVNC 1.7.1 (CConnection.cxx CConnection::CConnection), an unauthenticated client can cause a small memory leak in the server.",
        "git_url": "https://github.com/TigerVNC/tigervnc/commit/dccb5f7d776e93863ae10bbff56a45c523c6eeb0",
        "commit_title": "Prevent leak of SecurityServer and ClientServer.",
        "commit_text": " They are created in SConnection's and CConnection's constructors but never destroyed.  There is no reason for the indirection, so lets make them direct members.",
        "func_before": "void SConnection::processSecurityType(int secType)\n{\n  // Verify that the requested security type should be offered\n  std::list<rdr::U8> secTypes;\n  std::list<rdr::U8>::iterator i;\n\n  secTypes = security->GetEnabledSecTypes();\n  for (i=secTypes.begin(); i!=secTypes.end(); i++)\n    if (*i == secType) break;\n  if (i == secTypes.end())\n    throw Exception(\"Requested security type not available\");\n\n  vlog.info(\"Client requests security type %s(%d)\",\n            secTypeName(secType),secType);\n\n  try {\n    state_ = RFBSTATE_SECURITY;\n    ssecurity = security->GetSSecurity(secType);\n  } catch (rdr::Exception& e) {\n    throwConnFailedException(e.str());\n  }\n\n  processSecurityMsg();\n}",
        "func": "void SConnection::processSecurityType(int secType)\n{\n  // Verify that the requested security type should be offered\n  std::list<rdr::U8> secTypes;\n  std::list<rdr::U8>::iterator i;\n\n  secTypes = security.GetEnabledSecTypes();\n  for (i=secTypes.begin(); i!=secTypes.end(); i++)\n    if (*i == secType) break;\n  if (i == secTypes.end())\n    throw Exception(\"Requested security type not available\");\n\n  vlog.info(\"Client requests security type %s(%d)\",\n            secTypeName(secType),secType);\n\n  try {\n    state_ = RFBSTATE_SECURITY;\n    ssecurity = security.GetSSecurity(secType);\n  } catch (rdr::Exception& e) {\n    throwConnFailedException(e.str());\n  }\n\n  processSecurityMsg();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n   std::list<rdr::U8> secTypes;\n   std::list<rdr::U8>::iterator i;\n \n-  secTypes = security->GetEnabledSecTypes();\n+  secTypes = security.GetEnabledSecTypes();\n   for (i=secTypes.begin(); i!=secTypes.end(); i++)\n     if (*i == secType) break;\n   if (i == secTypes.end())\n@@ -15,7 +15,7 @@\n \n   try {\n     state_ = RFBSTATE_SECURITY;\n-    ssecurity = security->GetSSecurity(secType);\n+    ssecurity = security.GetSSecurity(secType);\n   } catch (rdr::Exception& e) {\n     throwConnFailedException(e.str());\n   }",
        "diff_line_info": {
            "deleted_lines": [
                "  secTypes = security->GetEnabledSecTypes();",
                "    ssecurity = security->GetSSecurity(secType);"
            ],
            "added_lines": [
                "  secTypes = security.GetEnabledSecTypes();",
                "    ssecurity = security.GetSSecurity(secType);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7396",
        "func_name": "TigerVNC/tigervnc/CConnection::processSecurityTypesMsg",
        "description": "In TigerVNC 1.7.1 (CConnection.cxx CConnection::CConnection), an unauthenticated client can cause a small memory leak in the server.",
        "git_url": "https://github.com/TigerVNC/tigervnc/commit/dccb5f7d776e93863ae10bbff56a45c523c6eeb0",
        "commit_title": "Prevent leak of SecurityServer and ClientServer.",
        "commit_text": " They are created in SConnection's and CConnection's constructors but never destroyed.  There is no reason for the indirection, so lets make them direct members.",
        "func_before": "void CConnection::processSecurityTypesMsg()\n{\n  vlog.debug(\"processing security types message\");\n\n  int secType = secTypeInvalid;\n\n  std::list<rdr::U8> secTypes;\n  secTypes = security->GetEnabledSecTypes();\n\n  if (cp.isVersion(3,3)) {\n\n    // legacy 3.3 server may only offer \"vnc authentication\" or \"none\"\n\n    secType = is->readU32();\n    if (secType == secTypeInvalid) {\n      throwConnFailedException();\n\n    } else if (secType == secTypeNone || secType == secTypeVncAuth) {\n      std::list<rdr::U8>::iterator i;\n      for (i = secTypes.begin(); i != secTypes.end(); i++)\n        if (*i == secType) {\n          secType = *i;\n          break;\n        }\n\n      if (i == secTypes.end())\n        secType = secTypeInvalid;\n    } else {\n      vlog.error(\"Unknown 3.3 security type %d\", secType);\n      throw Exception(\"Unknown 3.3 security type\");\n    }\n\n  } else {\n\n    // >=3.7 server will offer us a list\n\n    int nServerSecTypes = is->readU8();\n    if (nServerSecTypes == 0)\n      throwConnFailedException();\n\n    std::list<rdr::U8>::iterator j;\n\n    for (int i = 0; i < nServerSecTypes; i++) {\n      rdr::U8 serverSecType = is->readU8();\n      vlog.debug(\"Server offers security type %s(%d)\",\n                 secTypeName(serverSecType), serverSecType);\n\n      /*\n       * Use the first type sent by server which matches client's type.\n       * It means server's order specifies priority.\n       */\n      if (secType == secTypeInvalid) {\n        for (j = secTypes.begin(); j != secTypes.end(); j++)\n          if (*j == serverSecType) {\n            secType = *j;\n            break;\n          }\n       }\n    }\n\n    // Inform the server of our decision\n    if (secType != secTypeInvalid) {\n      os->writeU8(secType);\n      os->flush();\n      vlog.info(\"Choosing security type %s(%d)\",secTypeName(secType),secType);\n    }\n  }\n\n  if (secType == secTypeInvalid) {\n    state_ = RFBSTATE_INVALID;\n    vlog.error(\"No matching security types\");\n    throw Exception(\"No matching security types\");\n  }\n\n  state_ = RFBSTATE_SECURITY;\n  csecurity = security->GetCSecurity(secType);\n  processSecurityMsg();\n}",
        "func": "void CConnection::processSecurityTypesMsg()\n{\n  vlog.debug(\"processing security types message\");\n\n  int secType = secTypeInvalid;\n\n  std::list<rdr::U8> secTypes;\n  secTypes = security.GetEnabledSecTypes();\n\n  if (cp.isVersion(3,3)) {\n\n    // legacy 3.3 server may only offer \"vnc authentication\" or \"none\"\n\n    secType = is->readU32();\n    if (secType == secTypeInvalid) {\n      throwConnFailedException();\n\n    } else if (secType == secTypeNone || secType == secTypeVncAuth) {\n      std::list<rdr::U8>::iterator i;\n      for (i = secTypes.begin(); i != secTypes.end(); i++)\n        if (*i == secType) {\n          secType = *i;\n          break;\n        }\n\n      if (i == secTypes.end())\n        secType = secTypeInvalid;\n    } else {\n      vlog.error(\"Unknown 3.3 security type %d\", secType);\n      throw Exception(\"Unknown 3.3 security type\");\n    }\n\n  } else {\n\n    // >=3.7 server will offer us a list\n\n    int nServerSecTypes = is->readU8();\n    if (nServerSecTypes == 0)\n      throwConnFailedException();\n\n    std::list<rdr::U8>::iterator j;\n\n    for (int i = 0; i < nServerSecTypes; i++) {\n      rdr::U8 serverSecType = is->readU8();\n      vlog.debug(\"Server offers security type %s(%d)\",\n                 secTypeName(serverSecType), serverSecType);\n\n      /*\n       * Use the first type sent by server which matches client's type.\n       * It means server's order specifies priority.\n       */\n      if (secType == secTypeInvalid) {\n        for (j = secTypes.begin(); j != secTypes.end(); j++)\n          if (*j == serverSecType) {\n            secType = *j;\n            break;\n          }\n       }\n    }\n\n    // Inform the server of our decision\n    if (secType != secTypeInvalid) {\n      os->writeU8(secType);\n      os->flush();\n      vlog.info(\"Choosing security type %s(%d)\",secTypeName(secType),secType);\n    }\n  }\n\n  if (secType == secTypeInvalid) {\n    state_ = RFBSTATE_INVALID;\n    vlog.error(\"No matching security types\");\n    throw Exception(\"No matching security types\");\n  }\n\n  state_ = RFBSTATE_SECURITY;\n  csecurity = security.GetCSecurity(secType);\n  processSecurityMsg();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n   int secType = secTypeInvalid;\n \n   std::list<rdr::U8> secTypes;\n-  secTypes = security->GetEnabledSecTypes();\n+  secTypes = security.GetEnabledSecTypes();\n \n   if (cp.isVersion(3,3)) {\n \n@@ -73,6 +73,6 @@\n   }\n \n   state_ = RFBSTATE_SECURITY;\n-  csecurity = security->GetCSecurity(secType);\n+  csecurity = security.GetCSecurity(secType);\n   processSecurityMsg();\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  secTypes = security->GetEnabledSecTypes();",
                "  csecurity = security->GetCSecurity(secType);"
            ],
            "added_lines": [
                "  secTypes = security.GetEnabledSecTypes();",
                "  csecurity = security.GetCSecurity(secType);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7396",
        "func_name": "TigerVNC/tigervnc/CConnection::CConnection",
        "description": "In TigerVNC 1.7.1 (CConnection.cxx CConnection::CConnection), an unauthenticated client can cause a small memory leak in the server.",
        "git_url": "https://github.com/TigerVNC/tigervnc/commit/dccb5f7d776e93863ae10bbff56a45c523c6eeb0",
        "commit_title": "Prevent leak of SecurityServer and ClientServer.",
        "commit_text": " They are created in SConnection's and CConnection's constructors but never destroyed.  There is no reason for the indirection, so lets make them direct members.",
        "func_before": "CConnection::CConnection()\n  : csecurity(0), is(0), os(0), reader_(0), writer_(0),\n    shared(false),\n    state_(RFBSTATE_UNINITIALISED), useProtocol3_3(false),\n    framebuffer(NULL), decoder(this)\n{\n  security = new SecurityClient();\n}",
        "func": "CConnection::CConnection()\n  : csecurity(0), is(0), os(0), reader_(0), writer_(0),\n    shared(false),\n    state_(RFBSTATE_UNINITIALISED), useProtocol3_3(false),\n    framebuffer(NULL), decoder(this)\n{\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,5 +4,4 @@\n     state_(RFBSTATE_UNINITIALISED), useProtocol3_3(false),\n     framebuffer(NULL), decoder(this)\n {\n-  security = new SecurityClient();\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  security = new SecurityClient();"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2017-7624",
        "func_name": "jsummers/imageworsener/iw_read_bmp_file",
        "description": "The iw_read_bmp_file function in imagew-bmp.c in libimageworsener.a in ImageWorsener 1.3.0 allows remote attackers to consume an amount of available memory via a crafted file.",
        "git_url": "https://github.com/jsummers/imageworsener/commit/49912f8e5706a686212eb9e10fac3e2abe9e1867",
        "commit_title": "Fixed a memory leak in the BMP decoder",
        "commit_text": " Fixes issue #10",
        "func_before": "IW_IMPL(int) iw_read_bmp_file(struct iw_context *ctx, struct iw_iodescr *iodescr)\n{\n\tstruct iwbmprcontext rctx;\n\tstruct iw_image img;\n\tint retval = 0;\n\n\tiw_zeromem(&rctx,sizeof(struct iwbmprcontext));\n\tiw_zeromem(&img,sizeof(struct iw_image));\n\n\trctx.ctx = ctx;\n\trctx.img = &img;\n\trctx.iodescr = iodescr;\n\n\t// Start with a default sRGB colorspace. This may be overridden later.\n\tiw_make_srgb_csdescr_2(&rctx.csdescr);\n\n\trctx.has_fileheader = !iw_get_value(ctx,IW_VAL_BMP_NO_FILEHEADER);\n\tif(rctx.has_fileheader) {\n\t\tif(!iwbmp_read_file_header(&rctx)) goto done;\n\t}\n\tif(!iwbmp_read_info_header(&rctx)) goto done;\n\n\tiwbmp_set_default_bitfields(&rctx);\n\tif(rctx.bitfields_nbytes>0) {\n\t\tif(!iwbmp_read_bitfields(&rctx)) goto done;\n\t}\n\n\tif(rctx.palette_entries>0) {\n\t\tif(!iwbmp_read_palette(&rctx)) goto done;\n\t}\n\tif(!iwbmp_read_bits(&rctx)) goto done;\n\n\tiw_set_input_image(ctx, &img);\n\n\tiwbmpr_misc_config(ctx, &rctx);\n\n\tretval = 1;\ndone:\n\tif(!retval) {\n\t\tiw_set_error(ctx,\"BMP read failed\");\n\t}\n\treturn retval;\n}",
        "func": "IW_IMPL(int) iw_read_bmp_file(struct iw_context *ctx, struct iw_iodescr *iodescr)\n{\n\tstruct iwbmprcontext rctx;\n\tstruct iw_image img;\n\tint retval = 0;\n\n\tiw_zeromem(&rctx,sizeof(struct iwbmprcontext));\n\tiw_zeromem(&img,sizeof(struct iw_image));\n\n\trctx.ctx = ctx;\n\trctx.img = &img;\n\trctx.iodescr = iodescr;\n\n\t// Start with a default sRGB colorspace. This may be overridden later.\n\tiw_make_srgb_csdescr_2(&rctx.csdescr);\n\n\trctx.has_fileheader = !iw_get_value(ctx,IW_VAL_BMP_NO_FILEHEADER);\n\tif(rctx.has_fileheader) {\n\t\tif(!iwbmp_read_file_header(&rctx)) goto done;\n\t}\n\tif(!iwbmp_read_info_header(&rctx)) goto done;\n\n\tiwbmp_set_default_bitfields(&rctx);\n\tif(rctx.bitfields_nbytes>0) {\n\t\tif(!iwbmp_read_bitfields(&rctx)) goto done;\n\t}\n\n\tif(rctx.palette_entries>0) {\n\t\tif(!iwbmp_read_palette(&rctx)) goto done;\n\t}\n\tif(!iwbmp_read_bits(&rctx)) goto done;\n\n\tiw_set_input_image(ctx, &img);\n\n\tiwbmpr_misc_config(ctx, &rctx);\n\n\tretval = 1;\ndone:\n\tif(!retval) {\n\t\tiw_set_error(ctx,\"BMP read failed\");\n\t\t// If we didn't call iw_set_input_image, 'img' still belongs to us,\n\t\t// so free its contents.\n\t\tiw_free(ctx, img.pixels);\n\t}\n\treturn retval;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -38,6 +38,9 @@\n done:\n \tif(!retval) {\n \t\tiw_set_error(ctx,\"BMP read failed\");\n+\t\t// If we didn't call iw_set_input_image, 'img' still belongs to us,\n+\t\t// so free its contents.\n+\t\tiw_free(ctx, img.pixels);\n \t}\n \treturn retval;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t// If we didn't call iw_set_input_image, 'img' still belongs to us,",
                "\t\t// so free its contents.",
                "\t\tiw_free(ctx, img.pixels);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7941",
        "func_name": "ImageMagick/ReadSGIImage",
        "description": "The ReadSGIImage function in sgi.c in ImageMagick 7.0.5-4 allows remote attackers to consume an amount of available memory via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/721dc1305b2bfff92e5ca605dc1a47c61ce90b9f",
        "commit_title": "Fixed memory leak reported in #428.",
        "commit_text": "",
        "func_before": "static Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info;\n\n  register IndexPacket\n    *indexes;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  SGIInfo\n    iris_info;\n\n  size_t\n    bytes_per_pixel,\n    quantum;\n\n  ssize_t\n    count,\n    y,\n    z;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SGI raster header.\n  */\n  iris_info.magic=ReadBlobMSBShort(image);\n  do\n  {\n    /*\n      Verify SGI identifier.\n    */\n    if (iris_info.magic != 0x01DA)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.storage=(unsigned char) ReadBlobByte(image);\n    switch (iris_info.storage)\n    {\n      case 0x00: image->compression=NoCompression; break;\n      case 0x01: image->compression=RLECompression; break;\n      default:\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n    iris_info.bytes_per_pixel=(unsigned char) ReadBlobByte(image);\n    if ((iris_info.bytes_per_pixel == 0) || (iris_info.bytes_per_pixel > 2))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.dimension=ReadBlobMSBShort(image);\n    if ((iris_info.dimension == 0) || (iris_info.dimension > 3)) \n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.columns=ReadBlobMSBShort(image);\n    iris_info.rows=ReadBlobMSBShort(image);\n    iris_info.depth=ReadBlobMSBShort(image);\n    if ((iris_info.depth == 0) || (iris_info.depth > 4))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.minimum_value=ReadBlobMSBLong(image);\n    iris_info.maximum_value=ReadBlobMSBLong(image);\n    iris_info.sans=ReadBlobMSBLong(image);\n    count=ReadBlob(image,sizeof(iris_info.name),(unsigned char *)\n      iris_info.name);\n    if ((size_t) count != sizeof(iris_info.name))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.name[sizeof(iris_info.name)-1]='\\0';\n    if (*iris_info.name != '\\0')\n      (void) SetImageProperty(image,\"label\",iris_info.name);\n    iris_info.pixel_format=ReadBlobMSBLong(image);\n    if (iris_info.pixel_format != 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    count=ReadBlob(image,sizeof(iris_info.filler),iris_info.filler);\n    if ((size_t) count != sizeof(iris_info.filler))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->columns=iris_info.columns;\n    image->rows=iris_info.rows;\n    image->matte=iris_info.depth == 4 ? MagickTrue : MagickFalse;\n    image->depth=(size_t) MagickMin(iris_info.depth,MAGICKCORE_QUANTUM_DEPTH);\n    if (iris_info.pixel_format == 0)\n      image->depth=(size_t) MagickMin((size_t) 8*iris_info.bytes_per_pixel,\n        MAGICKCORE_QUANTUM_DEPTH);\n    if (iris_info.depth < 3)\n      {\n        image->storage_class=PseudoClass;\n        image->colors=(size_t) (iris_info.bytes_per_pixel > 1 ? 65535 : 256);\n      }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    /*\n      Allocate SGI pixels.\n    */\n    bytes_per_pixel=(size_t) iris_info.bytes_per_pixel;\n    number_pixels=(MagickSizeType) iris_info.columns*iris_info.rows;\n    if ((4*bytes_per_pixel*number_pixels) != ((MagickSizeType) (size_t)\n        (4*bytes_per_pixel*number_pixels)))\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixel_info=AcquireVirtualMemory(iris_info.columns,iris_info.rows*4*\n      bytes_per_pixel*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    if ((int) iris_info.storage != 0x01)\n      {\n        unsigned char\n          *scanline;\n\n        /*\n          Read standard image format.\n        */\n        scanline=(unsigned char *) AcquireQuantumMemory(iris_info.columns,\n          bytes_per_pixel*sizeof(*scanline));\n        if (scanline == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        for (z=0; z < (ssize_t) iris_info.depth; z++)\n        {\n          p=pixels+bytes_per_pixel*z;\n          for (y=0; y < (ssize_t) iris_info.rows; y++)\n          {\n            (void) ReadBlob(image,bytes_per_pixel*iris_info.columns,scanline);\n            if (EOFBlob(image) != MagickFalse)\n              break;\n            if (bytes_per_pixel == 2)\n              for (x=0; x < (ssize_t) iris_info.columns; x++)\n              {\n                *p=scanline[2*x];\n                *(p+1)=scanline[2*x+1];\n                p+=8;\n              }\n            else\n              for (x=0; x < (ssize_t) iris_info.columns; x++)\n              {\n                *p=scanline[x];\n                p+=4;\n              }\n          }\n        }\n        scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n      }\n    else\n      {\n        MemoryInfo\n          *packet_info;\n\n        size_t\n          *runlength;\n\n        ssize_t\n          offset,\n          *offsets;\n\n        unsigned char\n          *packets;\n\n        unsigned int\n          data_order;\n\n        /*\n          Read runlength-encoded image format.\n        */\n        offsets=(ssize_t *) AcquireQuantumMemory((size_t) iris_info.rows,\n          iris_info.depth*sizeof(*offsets));\n        runlength=(size_t *) AcquireQuantumMemory(iris_info.rows,\n          iris_info.depth*sizeof(*runlength));\n        packet_info=AcquireVirtualMemory((size_t) iris_info.columns+10UL,4UL*\n          sizeof(*packets));\n        if ((offsets == (ssize_t *) NULL) ||\n            (runlength == (size_t *) NULL) ||\n            (packet_info == (MemoryInfo *) NULL))\n          {\n            if (offsets == (ssize_t *) NULL)\n              offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n            if (runlength == (size_t *) NULL)\n              runlength=(size_t *) RelinquishMagickMemory(runlength);\n            if (packet_info == (MemoryInfo *) NULL)\n              packet_info=RelinquishVirtualMemory(packet_info);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        packets=(unsigned char *) GetVirtualMemoryBlob(packet_info);\n        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)\n          offsets[i]=(ssize_t) ReadBlobMSBSignedLong(image);\n        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)\n        {\n          runlength[i]=ReadBlobMSBLong(image);\n          if (runlength[i] > (4*(size_t) iris_info.columns+10))\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n        /*\n          Check data order.\n        */\n        offset=0;\n        data_order=0;\n        for (y=0; ((y < (ssize_t) iris_info.rows) && (data_order == 0)); y++)\n          for (z=0; ((z < (ssize_t) iris_info.depth) && (data_order == 0)); z++)\n          {\n            if (offsets[y+z*iris_info.rows] < offset)\n              data_order=1;\n            offset=offsets[y+z*iris_info.rows];\n          }\n        offset=(ssize_t) TellBlob(image);\n        if (data_order == 1)\n          {\n            for (z=0; z < (ssize_t) iris_info.depth; z++)\n            {\n              p=pixels;\n              for (y=0; y < (ssize_t) iris_info.rows; y++)\n              {\n                if (offset != offsets[y+z*iris_info.rows])\n                  {\n                    offset=offsets[y+z*iris_info.rows];\n                    offset=(ssize_t) SeekBlob(image,(MagickOffsetType) offset,\n                      SEEK_SET);\n                  }\n                (void) ReadBlob(image,(size_t) runlength[y+z*iris_info.rows],\n                  packets);\n                if (EOFBlob(image) != MagickFalse)\n                  break;\n                offset+=(ssize_t) runlength[y+z*iris_info.rows];\n                status=SGIDecode(bytes_per_pixel,(ssize_t)\n                  (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,\n                  (ssize_t) iris_info.columns,p+bytes_per_pixel*z);\n                if (status == MagickFalse)\n                  ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n                p+=(iris_info.columns*4*bytes_per_pixel);\n              }\n            }\n          }\n        else\n          {\n            MagickOffsetType\n              position;\n\n            position=TellBlob(image);\n            p=pixels;\n            for (y=0; y < (ssize_t) iris_info.rows; y++)\n            {\n              for (z=0; z < (ssize_t) iris_info.depth; z++)\n              {\n                if (offset != offsets[y+z*iris_info.rows])\n                  {\n                    offset=offsets[y+z*iris_info.rows];\n                    offset=(ssize_t) SeekBlob(image,(MagickOffsetType) offset,\n                      SEEK_SET);\n                  }\n                (void) ReadBlob(image,(size_t) runlength[y+z*iris_info.rows],\n                  packets);\n                if (EOFBlob(image) != MagickFalse)\n                  break;\n                offset+=(ssize_t) runlength[y+z*iris_info.rows];\n                status=SGIDecode(bytes_per_pixel,(ssize_t)\n                  (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,\n                  (ssize_t) iris_info.columns,p+bytes_per_pixel*z);\n                if (status == MagickFalse)\n                  ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              }\n              p+=(iris_info.columns*4*bytes_per_pixel);\n            }\n            offset=(ssize_t) SeekBlob(image,position,SEEK_SET);\n          }\n        packet_info=RelinquishVirtualMemory(packet_info);\n        runlength=(size_t *) RelinquishMagickMemory(runlength);\n        offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n      }\n    /*\n      Convert SGI raster image to pixel packets.\n    */\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Convert SGI image to DirectClass pixel packets.\n        */\n        if (bytes_per_pixel == 2)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=pixels+(image->rows-y-1)*8*image->columns;\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelRed(q,ScaleShortToQuantum((unsigned short)\n                  ((*(p+0) << 8) | (*(p+1)))));\n                SetPixelGreen(q,ScaleShortToQuantum((unsigned short)\n                  ((*(p+2) << 8) | (*(p+3)))));\n                SetPixelBlue(q,ScaleShortToQuantum((unsigned short)\n                  ((*(p+4) << 8) | (*(p+5)))));\n                SetPixelOpacity(q,OpaqueOpacity);\n                if (image->matte != MagickFalse)\n                  SetPixelAlpha(q,ScaleShortToQuantum((unsigned short)\n                    ((*(p+6) << 8) | (*(p+7)))));\n                p+=8;\n                q++;\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=pixels+(image->rows-y-1)*4*image->columns;\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(q,ScaleCharToQuantum(*p));\n              q->green=ScaleCharToQuantum(*(p+1));\n              q->blue=ScaleCharToQuantum(*(p+2));\n              SetPixelOpacity(q,OpaqueOpacity);\n              if (image->matte != MagickFalse)\n                SetPixelAlpha(q,ScaleCharToQuantum(*(p+3)));\n              p+=4;\n              q++;\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n      }\n    else\n      {\n        /*\n          Create grayscale map.\n        */\n        if (AcquireImageColormap(image,image->colors) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Convert SGI image to PseudoClass pixel packets.\n        */\n        if (bytes_per_pixel == 2)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=pixels+(image->rows-y-1)*8*image->columns;\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                quantum=(*p << 8);\n                quantum|=(*(p+1));\n                SetPixelIndex(indexes+x,quantum);\n                p+=8;\n                q++;\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=pixels+(image->rows-y-1)*4*image->columns;\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            indexes=GetAuthenticIndexQueue(image);\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(indexes+x,*p);\n              p+=4;\n              q++;\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        (void) SyncImage(image);\n      }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    iris_info.magic=ReadBlobMSBShort(image);\n    if (iris_info.magic == 0x01DA)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (iris_info.magic == 0x01DA);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info;\n\n  register IndexPacket\n    *indexes;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  SGIInfo\n    iris_info;\n\n  size_t\n    bytes_per_pixel,\n    quantum;\n\n  ssize_t\n    count,\n    y,\n    z;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SGI raster header.\n  */\n  iris_info.magic=ReadBlobMSBShort(image);\n  do\n  {\n    /*\n      Verify SGI identifier.\n    */\n    if (iris_info.magic != 0x01DA)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.storage=(unsigned char) ReadBlobByte(image);\n    switch (iris_info.storage)\n    {\n      case 0x00: image->compression=NoCompression; break;\n      case 0x01: image->compression=RLECompression; break;\n      default:\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n    iris_info.bytes_per_pixel=(unsigned char) ReadBlobByte(image);\n    if ((iris_info.bytes_per_pixel == 0) || (iris_info.bytes_per_pixel > 2))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.dimension=ReadBlobMSBShort(image);\n    if ((iris_info.dimension == 0) || (iris_info.dimension > 3)) \n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.columns=ReadBlobMSBShort(image);\n    iris_info.rows=ReadBlobMSBShort(image);\n    iris_info.depth=ReadBlobMSBShort(image);\n    if ((iris_info.depth == 0) || (iris_info.depth > 4))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.minimum_value=ReadBlobMSBLong(image);\n    iris_info.maximum_value=ReadBlobMSBLong(image);\n    iris_info.sans=ReadBlobMSBLong(image);\n    count=ReadBlob(image,sizeof(iris_info.name),(unsigned char *)\n      iris_info.name);\n    if ((size_t) count != sizeof(iris_info.name))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    iris_info.name[sizeof(iris_info.name)-1]='\\0';\n    if (*iris_info.name != '\\0')\n      (void) SetImageProperty(image,\"label\",iris_info.name);\n    iris_info.pixel_format=ReadBlobMSBLong(image);\n    if (iris_info.pixel_format != 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    count=ReadBlob(image,sizeof(iris_info.filler),iris_info.filler);\n    if ((size_t) count != sizeof(iris_info.filler))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->columns=iris_info.columns;\n    image->rows=iris_info.rows;\n    image->matte=iris_info.depth == 4 ? MagickTrue : MagickFalse;\n    image->depth=(size_t) MagickMin(iris_info.depth,MAGICKCORE_QUANTUM_DEPTH);\n    if (iris_info.pixel_format == 0)\n      image->depth=(size_t) MagickMin((size_t) 8*iris_info.bytes_per_pixel,\n        MAGICKCORE_QUANTUM_DEPTH);\n    if (iris_info.depth < 3)\n      {\n        image->storage_class=PseudoClass;\n        image->colors=(size_t) (iris_info.bytes_per_pixel > 1 ? 65535 : 256);\n      }\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    /*\n      Allocate SGI pixels.\n    */\n    bytes_per_pixel=(size_t) iris_info.bytes_per_pixel;\n    number_pixels=(MagickSizeType) iris_info.columns*iris_info.rows;\n    if ((4*bytes_per_pixel*number_pixels) != ((MagickSizeType) (size_t)\n        (4*bytes_per_pixel*number_pixels)))\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixel_info=AcquireVirtualMemory(iris_info.columns,iris_info.rows*4*\n      bytes_per_pixel*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    if ((int) iris_info.storage != 0x01)\n      {\n        unsigned char\n          *scanline;\n\n        /*\n          Read standard image format.\n        */\n        scanline=(unsigned char *) AcquireQuantumMemory(iris_info.columns,\n          bytes_per_pixel*sizeof(*scanline));\n        if (scanline == (unsigned char *) NULL)\n          {\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        for (z=0; z < (ssize_t) iris_info.depth; z++)\n        {\n          p=pixels+bytes_per_pixel*z;\n          for (y=0; y < (ssize_t) iris_info.rows; y++)\n          {\n            (void) ReadBlob(image,bytes_per_pixel*iris_info.columns,scanline);\n            if (EOFBlob(image) != MagickFalse)\n              break;\n            if (bytes_per_pixel == 2)\n              for (x=0; x < (ssize_t) iris_info.columns; x++)\n              {\n                *p=scanline[2*x];\n                *(p+1)=scanline[2*x+1];\n                p+=8;\n              }\n            else\n              for (x=0; x < (ssize_t) iris_info.columns; x++)\n              {\n                *p=scanline[x];\n                p+=4;\n              }\n          }\n        }\n        scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n      }\n    else\n      {\n        MemoryInfo\n          *packet_info;\n\n        size_t\n          *runlength;\n\n        ssize_t\n          offset,\n          *offsets;\n\n        unsigned char\n          *packets;\n\n        unsigned int\n          data_order;\n\n        /*\n          Read runlength-encoded image format.\n        */\n        offsets=(ssize_t *) AcquireQuantumMemory((size_t) iris_info.rows,\n          iris_info.depth*sizeof(*offsets));\n        runlength=(size_t *) AcquireQuantumMemory(iris_info.rows,\n          iris_info.depth*sizeof(*runlength));\n        packet_info=AcquireVirtualMemory((size_t) iris_info.columns+10UL,4UL*\n          sizeof(*packets));\n        if ((offsets == (ssize_t *) NULL) ||\n            (runlength == (size_t *) NULL) ||\n            (packet_info == (MemoryInfo *) NULL))\n          {\n            offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n            runlength=(size_t *) RelinquishMagickMemory(runlength);\n            if (packet_info != (MemoryInfo *) NULL)\n              packet_info=RelinquishVirtualMemory(packet_info);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        packets=(unsigned char *) GetVirtualMemoryBlob(packet_info);\n        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)\n          offsets[i]=(ssize_t) ReadBlobMSBSignedLong(image);\n        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)\n        {\n          runlength[i]=ReadBlobMSBLong(image);\n          if (runlength[i] > (4*(size_t) iris_info.columns+10))\n            {\n              offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n              runlength=(size_t *) RelinquishMagickMemory(runlength);\n              packet_info=RelinquishVirtualMemory(packet_info);\n              pixel_info=RelinquishVirtualMemory(pixel_info);\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            }\n        }\n        /*\n          Check data order.\n        */\n        offset=0;\n        data_order=0;\n        for (y=0; ((y < (ssize_t) iris_info.rows) && (data_order == 0)); y++)\n          for (z=0; ((z < (ssize_t) iris_info.depth) && (data_order == 0)); z++)\n          {\n            if (offsets[y+z*iris_info.rows] < offset)\n              data_order=1;\n            offset=offsets[y+z*iris_info.rows];\n          }\n        offset=(ssize_t) TellBlob(image);\n        if (data_order == 1)\n          {\n            for (z=0; z < (ssize_t) iris_info.depth; z++)\n            {\n              p=pixels;\n              for (y=0; y < (ssize_t) iris_info.rows; y++)\n              {\n                if (offset != offsets[y+z*iris_info.rows])\n                  {\n                    offset=offsets[y+z*iris_info.rows];\n                    offset=(ssize_t) SeekBlob(image,(MagickOffsetType) offset,\n                      SEEK_SET);\n                  }\n                (void) ReadBlob(image,(size_t) runlength[y+z*iris_info.rows],\n                  packets);\n                if (EOFBlob(image) != MagickFalse)\n                  break;\n                offset+=(ssize_t) runlength[y+z*iris_info.rows];\n                status=SGIDecode(bytes_per_pixel,(ssize_t)\n                  (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,\n                  (ssize_t) iris_info.columns,p+bytes_per_pixel*z);\n                if (status == MagickFalse)\n                  {\n                    offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n                    runlength=(size_t *) RelinquishMagickMemory(runlength);\n                    packet_info=RelinquishVirtualMemory(packet_info);\n                    pixel_info=RelinquishVirtualMemory(pixel_info);\n                    ThrowReaderException(CorruptImageError,\n                      \"ImproperImageHeader\");\n                  }\n                p+=(iris_info.columns*4*bytes_per_pixel);\n              }\n            }\n          }\n        else\n          {\n            MagickOffsetType\n              position;\n\n            position=TellBlob(image);\n            p=pixels;\n            for (y=0; y < (ssize_t) iris_info.rows; y++)\n            {\n              for (z=0; z < (ssize_t) iris_info.depth; z++)\n              {\n                if (offset != offsets[y+z*iris_info.rows])\n                  {\n                    offset=offsets[y+z*iris_info.rows];\n                    offset=(ssize_t) SeekBlob(image,(MagickOffsetType) offset,\n                      SEEK_SET);\n                  }\n                (void) ReadBlob(image,(size_t) runlength[y+z*iris_info.rows],\n                  packets);\n                if (EOFBlob(image) != MagickFalse)\n                  break;\n                offset+=(ssize_t) runlength[y+z*iris_info.rows];\n                status=SGIDecode(bytes_per_pixel,(ssize_t)\n                  (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,\n                  (ssize_t) iris_info.columns,p+bytes_per_pixel*z);\n                if (status == MagickFalse)\n                  {\n                    offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n                    runlength=(size_t *) RelinquishMagickMemory(runlength);\n                    packet_info=RelinquishVirtualMemory(packet_info);\n                    pixel_info=RelinquishVirtualMemory(pixel_info);\n                    ThrowReaderException(CorruptImageError,\n                      \"ImproperImageHeader\");\n                  }\n              }\n              p+=(iris_info.columns*4*bytes_per_pixel);\n            }\n            offset=(ssize_t) SeekBlob(image,position,SEEK_SET);\n          }\n        packet_info=RelinquishVirtualMemory(packet_info);\n        runlength=(size_t *) RelinquishMagickMemory(runlength);\n        offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n      }\n    /*\n      Convert SGI raster image to pixel packets.\n    */\n    if (image->storage_class == DirectClass)\n      {\n        /*\n          Convert SGI image to DirectClass pixel packets.\n        */\n        if (bytes_per_pixel == 2)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=pixels+(image->rows-y-1)*8*image->columns;\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelRed(q,ScaleShortToQuantum((unsigned short)\n                  ((*(p+0) << 8) | (*(p+1)))));\n                SetPixelGreen(q,ScaleShortToQuantum((unsigned short)\n                  ((*(p+2) << 8) | (*(p+3)))));\n                SetPixelBlue(q,ScaleShortToQuantum((unsigned short)\n                  ((*(p+4) << 8) | (*(p+5)))));\n                SetPixelOpacity(q,OpaqueOpacity);\n                if (image->matte != MagickFalse)\n                  SetPixelAlpha(q,ScaleShortToQuantum((unsigned short)\n                    ((*(p+6) << 8) | (*(p+7)))));\n                p+=8;\n                q++;\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=pixels+(image->rows-y-1)*4*image->columns;\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(q,ScaleCharToQuantum(*p));\n              q->green=ScaleCharToQuantum(*(p+1));\n              q->blue=ScaleCharToQuantum(*(p+2));\n              SetPixelOpacity(q,OpaqueOpacity);\n              if (image->matte != MagickFalse)\n                SetPixelAlpha(q,ScaleCharToQuantum(*(p+3)));\n              p+=4;\n              q++;\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n      }\n    else\n      {\n        /*\n          Create grayscale map.\n        */\n        if (AcquireImageColormap(image,image->colors) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Convert SGI image to PseudoClass pixel packets.\n        */\n        if (bytes_per_pixel == 2)\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=pixels+(image->rows-y-1)*8*image->columns;\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                quantum=(*p << 8);\n                quantum|=(*(p+1));\n                SetPixelIndex(indexes+x,quantum);\n                p+=8;\n                q++;\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=pixels+(image->rows-y-1)*4*image->columns;\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            indexes=GetAuthenticIndexQueue(image);\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(indexes+x,*p);\n              p+=4;\n              q++;\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        (void) SyncImage(image);\n      }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    iris_info.magic=ReadBlobMSBShort(image);\n    if (iris_info.magic == 0x01DA)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (iris_info.magic == 0x01DA);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -148,7 +148,10 @@\n         scanline=(unsigned char *) AcquireQuantumMemory(iris_info.columns,\n           bytes_per_pixel*sizeof(*scanline));\n         if (scanline == (unsigned char *) NULL)\n-          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+          {\n+            pixel_info=RelinquishVirtualMemory(pixel_info);\n+            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+          }\n         for (z=0; z < (ssize_t) iris_info.depth; z++)\n         {\n           p=pixels+bytes_per_pixel*z;\n@@ -205,12 +208,11 @@\n             (runlength == (size_t *) NULL) ||\n             (packet_info == (MemoryInfo *) NULL))\n           {\n-            if (offsets == (ssize_t *) NULL)\n-              offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n-            if (runlength == (size_t *) NULL)\n-              runlength=(size_t *) RelinquishMagickMemory(runlength);\n-            if (packet_info == (MemoryInfo *) NULL)\n+            offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n+            runlength=(size_t *) RelinquishMagickMemory(runlength);\n+            if (packet_info != (MemoryInfo *) NULL)\n               packet_info=RelinquishVirtualMemory(packet_info);\n+            pixel_info=RelinquishVirtualMemory(pixel_info);\n             ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n           }\n         packets=(unsigned char *) GetVirtualMemoryBlob(packet_info);\n@@ -220,7 +222,13 @@\n         {\n           runlength[i]=ReadBlobMSBLong(image);\n           if (runlength[i] > (4*(size_t) iris_info.columns+10))\n-            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+            {\n+              offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n+              runlength=(size_t *) RelinquishMagickMemory(runlength);\n+              packet_info=RelinquishVirtualMemory(packet_info);\n+              pixel_info=RelinquishVirtualMemory(pixel_info);\n+              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+            }\n         }\n         /*\n           Check data order.\n@@ -257,7 +265,14 @@\n                   (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,\n                   (ssize_t) iris_info.columns,p+bytes_per_pixel*z);\n                 if (status == MagickFalse)\n-                  ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+                  {\n+                    offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n+                    runlength=(size_t *) RelinquishMagickMemory(runlength);\n+                    packet_info=RelinquishVirtualMemory(packet_info);\n+                    pixel_info=RelinquishVirtualMemory(pixel_info);\n+                    ThrowReaderException(CorruptImageError,\n+                      \"ImproperImageHeader\");\n+                  }\n                 p+=(iris_info.columns*4*bytes_per_pixel);\n               }\n             }\n@@ -288,7 +303,14 @@\n                   (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,\n                   (ssize_t) iris_info.columns,p+bytes_per_pixel*z);\n                 if (status == MagickFalse)\n-                  ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+                  {\n+                    offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n+                    runlength=(size_t *) RelinquishMagickMemory(runlength);\n+                    packet_info=RelinquishVirtualMemory(packet_info);\n+                    pixel_info=RelinquishVirtualMemory(pixel_info);\n+                    ThrowReaderException(CorruptImageError,\n+                      \"ImproperImageHeader\");\n+                  }\n               }\n               p+=(iris_info.columns*4*bytes_per_pixel);\n             }",
        "diff_line_info": {
            "deleted_lines": [
                "          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "            if (offsets == (ssize_t *) NULL)",
                "              offsets=(ssize_t *) RelinquishMagickMemory(offsets);",
                "            if (runlength == (size_t *) NULL)",
                "              runlength=(size_t *) RelinquishMagickMemory(runlength);",
                "            if (packet_info == (MemoryInfo *) NULL)",
                "            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "                  ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "                  ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");"
            ],
            "added_lines": [
                "          {",
                "            pixel_info=RelinquishVirtualMemory(pixel_info);",
                "            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "          }",
                "            offsets=(ssize_t *) RelinquishMagickMemory(offsets);",
                "            runlength=(size_t *) RelinquishMagickMemory(runlength);",
                "            if (packet_info != (MemoryInfo *) NULL)",
                "            pixel_info=RelinquishVirtualMemory(pixel_info);",
                "            {",
                "              offsets=(ssize_t *) RelinquishMagickMemory(offsets);",
                "              runlength=(size_t *) RelinquishMagickMemory(runlength);",
                "              packet_info=RelinquishVirtualMemory(packet_info);",
                "              pixel_info=RelinquishVirtualMemory(pixel_info);",
                "              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "            }",
                "                  {",
                "                    offsets=(ssize_t *) RelinquishMagickMemory(offsets);",
                "                    runlength=(size_t *) RelinquishMagickMemory(runlength);",
                "                    packet_info=RelinquishVirtualMemory(packet_info);",
                "                    pixel_info=RelinquishVirtualMemory(pixel_info);",
                "                    ThrowReaderException(CorruptImageError,",
                "                      \"ImproperImageHeader\");",
                "                  }",
                "                  {",
                "                    offsets=(ssize_t *) RelinquishMagickMemory(offsets);",
                "                    runlength=(size_t *) RelinquishMagickMemory(runlength);",
                "                    packet_info=RelinquishVirtualMemory(packet_info);",
                "                    pixel_info=RelinquishVirtualMemory(pixel_info);",
                "                    ThrowReaderException(CorruptImageError,",
                "                      \"ImproperImageHeader\");",
                "                  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7942",
        "func_name": "ImageMagick/ReadAVSImage",
        "description": "The ReadAVSImage function in avs.c in ImageMagick 7.0.5-4 allows remote attackers to consume an amount of available memory via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/962282327f3a28ffb1138f3ad3fb0438b57ae6b1",
        "commit_title": "Fixed memory leak reported in #429.",
        "commit_text": "",
        "func_before": "static Image *ReadAVSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *pixel_info;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    height,\n    length,\n    width;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read AVS X image.\n  */\n  width=ReadBlobMSBLong(image);\n  height=ReadBlobMSBLong(image);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((width == 0UL) || (height == 0UL))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    /*\n      Convert AVS raster image to pixel packets.\n    */\n    image->columns=width;\n    image->rows=height;\n    image->depth=8;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    pixel_info=AcquireVirtualMemory(image->columns,4*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    length=(size_t) 4*image->columns;\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      count=ReadBlob(image,length,pixels);\n      if ((size_t) count != length)\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      p=pixels;\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (Quantum *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n        SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n        SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n        SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n        if (GetPixelAlpha(image,q) != OpaqueAlpha)\n          image->alpha_trait=BlendPixelTrait;\n        q+=GetPixelChannels(image);\n      }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    width=ReadBlobMSBLong(image);\n    height=ReadBlobMSBLong(image);\n    if ((width != 0UL) && (height != 0UL))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((width != 0UL) && (height != 0UL));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadAVSImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *pixel_info;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    height,\n    length,\n    width;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read AVS X image.\n  */\n  width=ReadBlobMSBLong(image);\n  height=ReadBlobMSBLong(image);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((width == 0UL) || (height == 0UL))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    /*\n      Convert AVS raster image to pixel packets.\n    */\n    image->columns=width;\n    image->rows=height;\n    image->depth=8;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    pixel_info=AcquireVirtualMemory(image->columns,4*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    length=(size_t) 4*image->columns;\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      count=ReadBlob(image,length,pixels);\n      if ((size_t) count != length)\n        {\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n        }\n      p=pixels;\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (Quantum *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n        SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n        SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n        SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n        if (GetPixelAlpha(image,q) != OpaqueAlpha)\n          image->alpha_trait=BlendPixelTrait;\n        q+=GetPixelChannels(image);\n      }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    width=ReadBlobMSBLong(image);\n    height=ReadBlobMSBLong(image);\n    if ((width != 0UL) && (height != 0UL))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((width != 0UL) && (height != 0UL));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -79,7 +79,10 @@\n     {\n       count=ReadBlob(image,length,pixels);\n       if ((size_t) count != length)\n-        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n+        {\n+          pixel_info=RelinquishVirtualMemory(pixel_info);\n+          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n+        }\n       p=pixels;\n       q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n       if (q == (Quantum *) NULL)",
        "diff_line_info": {
            "deleted_lines": [
                "        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");"
            ],
            "added_lines": [
                "        {",
                "          pixel_info=RelinquishVirtualMemory(pixel_info);",
                "          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7943",
        "func_name": "ImageMagick/ReadSVGImage",
        "description": "The ReadSVGImage function in svg.c in ImageMagick 7.0.5-4 allows remote attackers to consume an amount of available memory via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/2e3410d0a07c3e30a42c9626c00e180870907a6b",
        "commit_title": "Fixed leak reported in: #427.",
        "commit_text": "",
        "func_before": "static Image *ReadSVGImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    filename[MaxTextExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image,\n    *next;\n\n  int\n    status,\n    unique_file;\n\n  ssize_t\n    n;\n\n  SVGInfo\n    *svg_info;\n\n  unsigned char\n    message[MaxTextExtent];\n\n  xmlSAXHandler\n    sax_modules;\n\n  xmlSAXHandlerPtr\n    sax_handler;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if ((fabs(image->x_resolution) < MagickEpsilon) ||\n      (fabs(image->y_resolution) < MagickEpsilon))\n    {\n      GeometryInfo\n        geometry_info;\n\n      int\n        flags;\n\n      flags=ParseGeometry(SVGDensityGeometry,&geometry_info);\n      image->x_resolution=geometry_info.rho;\n      image->y_resolution=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->y_resolution=image->x_resolution;\n    }\n  if (LocaleCompare(image_info->magick,\"MSVG\") != 0)\n    {\n      const DelegateInfo\n        *delegate_info;\n\n      delegate_info=GetDelegateInfo(\"svg:decode\",(char *) NULL,exception);\n      if (delegate_info != (const DelegateInfo *) NULL)\n        {\n          char\n            background[MaxTextExtent],\n            command[MaxTextExtent],\n            *density,\n            input_filename[MaxTextExtent],\n            opacity[MaxTextExtent],\n            output_filename[MaxTextExtent],\n            unique[MaxTextExtent];\n\n          int\n            status;\n\n          struct stat\n            attributes;\n\n          /*\n            Our best hope for compliance to the SVG standard.\n          */\n          status=AcquireUniqueSymbolicLink(image->filename,input_filename);\n          (void) AcquireUniqueFilename(output_filename);\n          (void) AcquireUniqueFilename(unique);\n          density=AcquireString(\"\");\n          (void) FormatLocaleString(density,MaxTextExtent,\"%.20g,%.20g\",\n            image->x_resolution,image->y_resolution);\n          (void) FormatLocaleString(background,MaxTextExtent,\n            \"rgb(%.20g%%,%.20g%%,%.20g%%)\",\n            100.0*QuantumScale*image->background_color.red,\n            100.0*QuantumScale*image->background_color.green,\n            100.0*QuantumScale*image->background_color.blue);\n          (void) FormatLocaleString(opacity,MaxTextExtent,\"%.20g\",QuantumScale*\n            (QuantumRange-image->background_color.opacity));\n          (void) FormatLocaleString(command,MaxTextExtent,GetDelegateCommands(\n            delegate_info),input_filename,output_filename,density,background,\n            opacity,unique);\n          density=DestroyString(density);\n          status=ExternalDelegateCommand(MagickFalse,image_info->verbose,\n            command,(char *) NULL,exception);\n          (void) RelinquishUniqueFileResource(unique);\n          (void) RelinquishUniqueFileResource(input_filename);\n          if ((status == 0) && (stat(output_filename,&attributes) == 0) &&\n              (attributes.st_size > 0))\n            {\n              Image\n                *svg_image;\n\n              ImageInfo\n                *read_info;\n\n              read_info=CloneImageInfo(image_info);\n              (void) CopyMagickString(read_info->filename,output_filename,\n                MaxTextExtent);\n              svg_image=ReadImage(read_info,exception);\n              read_info=DestroyImageInfo(read_info);\n              (void) RelinquishUniqueFileResource(output_filename);\n              if (svg_image != (Image *) NULL)\n                {\n                  for (next=GetFirstImageInList(svg_image); next != (Image *) NULL; )\n                  {\n                    (void) CopyMagickString(next->filename,image->filename,\n                      MaxTextExtent);\n                    (void) CopyMagickString(next->magick,image->magick,\n                      MaxTextExtent);\n                    next=GetNextImageInList(next);\n                  }\n                  image=DestroyImage(image);\n                  return(svg_image);\n                }\n            }\n          (void) RelinquishUniqueFileResource(output_filename);\n        }\n      {\n#if defined(MAGICKCORE_RSVG_DELEGATE)\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n        cairo_surface_t\n          *cairo_surface;\n\n        cairo_t\n          *cairo_image;\n\n        MagickBooleanType\n          apply_density;\n\n        MemoryInfo\n          *pixel_info;\n\n        register unsigned char\n          *p;\n\n        RsvgDimensionData\n          dimension_info;\n\n        unsigned char\n          *pixels;\n\n#else\n        GdkPixbuf\n          *pixel_buffer;\n\n        register const guchar\n          *p;\n#endif\n\n        GError\n          *error;\n\n        PixelPacket\n          fill_color;\n\n        register ssize_t\n          x;\n\n        register PixelPacket\n          *q;\n\n        RsvgHandle\n          *svg_handle;\n\n        ssize_t\n          y;\n\n        svg_handle=rsvg_handle_new();\n        if (svg_handle == (RsvgHandle *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        rsvg_handle_set_base_uri(svg_handle,image_info->filename);\n        if ((fabs(image->x_resolution) > MagickEpsilon) &&\n            (fabs(image->y_resolution) > MagickEpsilon))\n          rsvg_handle_set_dpi_x_y(svg_handle,image->x_resolution,\n            image->y_resolution);\n        while ((n=ReadBlob(image,MaxTextExtent-1,message)) != 0)\n        {\n          message[n]='\\0';\n          error=(GError *) NULL;\n          (void) rsvg_handle_write(svg_handle,message,n,&error);\n          if (error != (GError *) NULL)\n            g_error_free(error);\n        }\n        error=(GError *) NULL;\n        rsvg_handle_close(svg_handle,&error);\n        if (error != (GError *) NULL)\n          g_error_free(error);\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n        apply_density=MagickTrue;\n        rsvg_handle_get_dimensions(svg_handle,&dimension_info);\n        if ((image->x_resolution > 0.0) && (image->y_resolution > 0.0))\n          {\n            RsvgDimensionData\n              dpi_dimension_info;\n\n            /*\n              We should not apply the density when the internal 'factor' is 'i'.\n              This can be checked by using the trick below.\n            */\n            rsvg_handle_set_dpi_x_y(svg_handle,image->x_resolution*256,\n              image->y_resolution*256);\n            rsvg_handle_get_dimensions(svg_handle,&dpi_dimension_info);\n            if ((dpi_dimension_info.width != dimension_info.width) ||\n                (dpi_dimension_info.height != dimension_info.height))\n              apply_density=MagickFalse;\n            rsvg_handle_set_dpi_x_y(svg_handle,image->x_resolution,\n              image->y_resolution);\n          }\n        if (image_info->size != (char *) NULL)\n          {\n            (void) GetGeometry(image_info->size,(ssize_t *) NULL,\n              (ssize_t *) NULL,&image->columns,&image->rows);\n            if ((image->columns != 0) || (image->rows != 0))\n              {\n                image->x_resolution=90.0*image->columns/dimension_info.width;\n                image->y_resolution=90.0*image->rows/dimension_info.height;\n                if (fabs(image->x_resolution) < MagickEpsilon)\n                  image->x_resolution=image->y_resolution;\n                else\n                  if (fabs(image->y_resolution) < MagickEpsilon)\n                    image->y_resolution=image->x_resolution;\n                  else\n                    image->x_resolution=image->y_resolution=MagickMin(\n                      image->x_resolution,image->y_resolution);\n                apply_density=MagickTrue;\n              }\n          }\n        if (apply_density != MagickFalse)\n          {\n            image->columns=image->x_resolution*dimension_info.width/90.0;\n            image->rows=image->y_resolution*dimension_info.height/90.0;\n          }\n        else\n          {\n            image->columns=dimension_info.width;\n            image->rows=dimension_info.height;\n          }\n        pixel_info=(MemoryInfo *) NULL;\n#else\n        pixel_buffer=rsvg_handle_get_pixbuf(svg_handle);\n        rsvg_handle_free(svg_handle);\n        image->columns=gdk_pixbuf_get_width(pixel_buffer);\n        image->rows=gdk_pixbuf_get_height(pixel_buffer);\n#endif\n        image->matte=MagickTrue;\n        SetImageProperty(image,\"svg:base-uri\",\n          rsvg_handle_get_base_uri(svg_handle));\n        status=SetImageExtent(image,image->columns,image->rows);\n        if (status == MagickFalse)\n          {\n#if !defined(MAGICKCORE_CAIRO_DELEGATE)\n            g_object_unref(G_OBJECT(pixel_buffer));\n#endif\n            g_object_unref(svg_handle);\n            InheritException(exception,&image->exception);\n            ThrowReaderException(MissingDelegateError,\n              \"NoDecodeDelegateForThisImageFormat\");\n          }\n        if (image_info->ping == MagickFalse)\n          {\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n            size_t\n              stride;\n\n            stride=4*image->columns;\n#if defined(MAGICKCORE_PANGOCAIRO_DELEGATE)\n            stride=(size_t) cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32,\n              (int) image->columns);\n#endif\n            pixel_info=AcquireVirtualMemory(stride,image->rows*sizeof(*pixels));\n            if (pixel_info == (MemoryInfo *) NULL)\n              {\n                g_object_unref(svg_handle);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n            pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n#endif\n            (void) SetImageBackgroundColor(image);\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n            cairo_surface=cairo_image_surface_create_for_data(pixels,\n              CAIRO_FORMAT_ARGB32,(int) image->columns,(int) image->rows, (int)\n              stride);\n            if (cairo_surface == (cairo_surface_t *) NULL)\n              {\n                pixel_info=RelinquishVirtualMemory(pixel_info);\n                g_object_unref(svg_handle);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n            cairo_image=cairo_create(cairo_surface);\n            cairo_set_operator(cairo_image,CAIRO_OPERATOR_CLEAR);\n            cairo_paint(cairo_image);\n            cairo_set_operator(cairo_image,CAIRO_OPERATOR_OVER);\n            if (apply_density != MagickFalse)\n              cairo_scale(cairo_image,image->x_resolution/90.0,\n                image->y_resolution/90.0);\n            rsvg_handle_render_cairo(svg_handle,cairo_image);\n            cairo_destroy(cairo_image);\n            cairo_surface_destroy(cairo_surface);\n            g_object_unref(svg_handle);\n            p=pixels;\n#else\n            p=gdk_pixbuf_get_pixels(pixel_buffer);\n#endif\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n                fill_color.blue=ScaleCharToQuantum(*p++);\n                fill_color.green=ScaleCharToQuantum(*p++);\n                fill_color.red=ScaleCharToQuantum(*p++);\n#else\n                fill_color.red=ScaleCharToQuantum(*p++);\n                fill_color.green=ScaleCharToQuantum(*p++);\n                fill_color.blue=ScaleCharToQuantum(*p++);\n#endif\n                fill_color.opacity=QuantumRange-ScaleCharToQuantum(*p++);\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n                {\n                  double\n                    gamma;\n\n                  gamma=1.0-QuantumScale*fill_color.opacity;\n                  gamma=PerceptibleReciprocal(gamma);\n                  fill_color.blue*=gamma;\n                  fill_color.green*=gamma;\n                  fill_color.red*=gamma;\n                }\n#endif\n                MagickCompositeOver(&fill_color,fill_color.opacity,q,\n                  (MagickRealType) q->opacity,q);\n                q++;\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n        if (pixel_info != (MemoryInfo *) NULL)\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n#else\n        g_object_unref(G_OBJECT(pixel_buffer));\n#endif\n        (void) CloseBlob(image);\n        for (next=GetFirstImageInList(image); next != (Image *) NULL; )\n        {\n          (void) CopyMagickString(next->filename,image->filename,MaxTextExtent);\n          (void) CopyMagickString(next->magick,image->magick,MaxTextExtent);\n          next=GetNextImageInList(next);\n        }\n        return(GetFirstImageInList(image));\n#endif\n      }\n    }\n  /*\n    Open draw file.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"w\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      (void) CopyMagickString(image->filename,filename,MaxTextExtent);\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Parse SVG file.\n  */\n  svg_info=AcquireSVGInfo();\n  if (svg_info == (SVGInfo *) NULL)\n    {\n      (void) fclose(file);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  svg_info->file=file;\n  svg_info->exception=exception;\n  svg_info->image=image;\n  svg_info->image_info=image_info;\n  svg_info->bounds.width=image->columns;\n  svg_info->bounds.height=image->rows;\n  if (image_info->size != (char *) NULL)\n    (void) CloneString(&svg_info->size,image_info->size);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"begin SAX\");\n  (void) xmlSubstituteEntitiesDefault(1);\n  (void) ResetMagickMemory(&sax_modules,0,sizeof(sax_modules));\n  sax_modules.internalSubset=SVGInternalSubset;\n  sax_modules.isStandalone=SVGIsStandalone;\n  sax_modules.hasInternalSubset=SVGHasInternalSubset;\n  sax_modules.hasExternalSubset=SVGHasExternalSubset;\n  sax_modules.resolveEntity=SVGResolveEntity;\n  sax_modules.getEntity=SVGGetEntity;\n  sax_modules.entityDecl=SVGEntityDeclaration;\n  sax_modules.notationDecl=SVGNotationDeclaration;\n  sax_modules.attributeDecl=SVGAttributeDeclaration;\n  sax_modules.elementDecl=SVGElementDeclaration;\n  sax_modules.unparsedEntityDecl=SVGUnparsedEntityDeclaration;\n  sax_modules.setDocumentLocator=SVGSetDocumentLocator;\n  sax_modules.startDocument=SVGStartDocument;\n  sax_modules.endDocument=SVGEndDocument;\n  sax_modules.startElement=SVGStartElement;\n  sax_modules.endElement=SVGEndElement;\n  sax_modules.reference=SVGReference;\n  sax_modules.characters=SVGCharacters;\n  sax_modules.ignorableWhitespace=SVGIgnorableWhitespace;\n  sax_modules.processingInstruction=SVGProcessingInstructions;\n  sax_modules.comment=SVGComment;\n  sax_modules.warning=SVGWarning;\n  sax_modules.error=SVGError;\n  sax_modules.fatalError=SVGError;\n  sax_modules.getParameterEntity=SVGGetParameterEntity;\n  sax_modules.cdataBlock=SVGCDataBlock;\n  sax_modules.externalSubset=SVGExternalSubset;\n  sax_handler=(&sax_modules);\n  n=ReadBlob(image,MaxTextExtent-1,message);\n  message[n]='\\0';\n  if (n > 0)\n    {\n      svg_info->parser=xmlCreatePushParserCtxt(sax_handler,svg_info,(char *)\n        message,n,image->filename);\n      while ((n=ReadBlob(image,MaxTextExtent-1,message)) != 0)\n      {\n        message[n]='\\0';\n        status=xmlParseChunk(svg_info->parser,(char *) message,(int) n,0);\n        if (status != 0)\n          break;\n      }\n    }\n  (void) xmlParseChunk(svg_info->parser,(char *) message,0,1);\n  SVGEndDocument(svg_info);\n  xmlFreeParserCtxt(svg_info->parser);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"end SAX\");\n  (void) fclose(file);\n  (void) CloseBlob(image);\n  image->columns=svg_info->width;\n  image->rows=svg_info->height;\n  if (exception->severity >= ErrorException)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  if (image_info->ping == MagickFalse)\n    {\n      ImageInfo\n        *read_info;\n\n      /*\n        Draw image.\n      */\n      image=DestroyImage(image);\n      image=(Image *) NULL;\n      read_info=CloneImageInfo(image_info);\n      SetImageInfoBlob(read_info,(void *) NULL,0);\n      if (read_info->density != (char *) NULL)\n        read_info->density=DestroyString(read_info->density);\n      (void) FormatLocaleString(read_info->filename,MaxTextExtent,\"mvg:%s\",\n        filename);\n      image=ReadImage(read_info,exception);\n      read_info=DestroyImageInfo(read_info);\n      if (image != (Image *) NULL)\n        (void) CopyMagickString(image->filename,image_info->filename,\n          MaxTextExtent);\n    }\n  /*\n    Relinquish resources.\n  */\n  if (image != (Image *) NULL)\n    {\n      if (svg_info->title != (char *) NULL)\n        (void) SetImageProperty(image,\"svg:title\",svg_info->title);\n      if (svg_info->comment != (char *) NULL)\n        (void) SetImageProperty(image,\"svg:comment\",svg_info->comment);\n    }\n  svg_info=DestroySVGInfo(svg_info);\n  (void) RelinquishUniqueFileResource(filename);\n  for (next=GetFirstImageInList(image); next != (Image *) NULL; )\n  {\n    (void) CopyMagickString(next->filename,image->filename,MaxTextExtent);\n    (void) CopyMagickString(next->magick,image->magick,MaxTextExtent);\n    next=GetNextImageInList(next);\n  }\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadSVGImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    filename[MaxTextExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image,\n    *next;\n\n  int\n    status,\n    unique_file;\n\n  ssize_t\n    n;\n\n  SVGInfo\n    *svg_info;\n\n  unsigned char\n    message[MaxTextExtent];\n\n  xmlSAXHandler\n    sax_modules;\n\n  xmlSAXHandlerPtr\n    sax_handler;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if ((fabs(image->x_resolution) < MagickEpsilon) ||\n      (fabs(image->y_resolution) < MagickEpsilon))\n    {\n      GeometryInfo\n        geometry_info;\n\n      int\n        flags;\n\n      flags=ParseGeometry(SVGDensityGeometry,&geometry_info);\n      image->x_resolution=geometry_info.rho;\n      image->y_resolution=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->y_resolution=image->x_resolution;\n    }\n  if (LocaleCompare(image_info->magick,\"MSVG\") != 0)\n    {\n      const DelegateInfo\n        *delegate_info;\n\n      delegate_info=GetDelegateInfo(\"svg:decode\",(char *) NULL,exception);\n      if (delegate_info != (const DelegateInfo *) NULL)\n        {\n          char\n            background[MaxTextExtent],\n            command[MaxTextExtent],\n            *density,\n            input_filename[MaxTextExtent],\n            opacity[MaxTextExtent],\n            output_filename[MaxTextExtent],\n            unique[MaxTextExtent];\n\n          int\n            status;\n\n          struct stat\n            attributes;\n\n          /*\n            Our best hope for compliance to the SVG standard.\n          */\n          status=AcquireUniqueSymbolicLink(image->filename,input_filename);\n          (void) AcquireUniqueFilename(output_filename);\n          (void) AcquireUniqueFilename(unique);\n          density=AcquireString(\"\");\n          (void) FormatLocaleString(density,MaxTextExtent,\"%.20g,%.20g\",\n            image->x_resolution,image->y_resolution);\n          (void) FormatLocaleString(background,MaxTextExtent,\n            \"rgb(%.20g%%,%.20g%%,%.20g%%)\",\n            100.0*QuantumScale*image->background_color.red,\n            100.0*QuantumScale*image->background_color.green,\n            100.0*QuantumScale*image->background_color.blue);\n          (void) FormatLocaleString(opacity,MaxTextExtent,\"%.20g\",QuantumScale*\n            (QuantumRange-image->background_color.opacity));\n          (void) FormatLocaleString(command,MaxTextExtent,GetDelegateCommands(\n            delegate_info),input_filename,output_filename,density,background,\n            opacity,unique);\n          density=DestroyString(density);\n          status=ExternalDelegateCommand(MagickFalse,image_info->verbose,\n            command,(char *) NULL,exception);\n          (void) RelinquishUniqueFileResource(unique);\n          (void) RelinquishUniqueFileResource(input_filename);\n          if ((status == 0) && (stat(output_filename,&attributes) == 0) &&\n              (attributes.st_size > 0))\n            {\n              Image\n                *svg_image;\n\n              ImageInfo\n                *read_info;\n\n              read_info=CloneImageInfo(image_info);\n              (void) CopyMagickString(read_info->filename,output_filename,\n                MaxTextExtent);\n              svg_image=ReadImage(read_info,exception);\n              read_info=DestroyImageInfo(read_info);\n              (void) RelinquishUniqueFileResource(output_filename);\n              if (svg_image != (Image *) NULL)\n                {\n                  for (next=GetFirstImageInList(svg_image); next != (Image *) NULL; )\n                  {\n                    (void) CopyMagickString(next->filename,image->filename,\n                      MaxTextExtent);\n                    (void) CopyMagickString(next->magick,image->magick,\n                      MaxTextExtent);\n                    next=GetNextImageInList(next);\n                  }\n                  image=DestroyImage(image);\n                  return(svg_image);\n                }\n            }\n          (void) RelinquishUniqueFileResource(output_filename);\n        }\n      {\n#if defined(MAGICKCORE_RSVG_DELEGATE)\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n        cairo_surface_t\n          *cairo_surface;\n\n        cairo_t\n          *cairo_image;\n\n        MagickBooleanType\n          apply_density;\n\n        MemoryInfo\n          *pixel_info;\n\n        register unsigned char\n          *p;\n\n        RsvgDimensionData\n          dimension_info;\n\n        unsigned char\n          *pixels;\n\n#else\n        GdkPixbuf\n          *pixel_buffer;\n\n        register const guchar\n          *p;\n#endif\n\n        GError\n          *error;\n\n        PixelPacket\n          fill_color;\n\n        register ssize_t\n          x;\n\n        register PixelPacket\n          *q;\n\n        RsvgHandle\n          *svg_handle;\n\n        ssize_t\n          y;\n\n        svg_handle=rsvg_handle_new();\n        if (svg_handle == (RsvgHandle *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        rsvg_handle_set_base_uri(svg_handle,image_info->filename);\n        if ((fabs(image->x_resolution) > MagickEpsilon) &&\n            (fabs(image->y_resolution) > MagickEpsilon))\n          rsvg_handle_set_dpi_x_y(svg_handle,image->x_resolution,\n            image->y_resolution);\n        while ((n=ReadBlob(image,MaxTextExtent-1,message)) != 0)\n        {\n          message[n]='\\0';\n          error=(GError *) NULL;\n          (void) rsvg_handle_write(svg_handle,message,n,&error);\n          if (error != (GError *) NULL)\n            g_error_free(error);\n        }\n        error=(GError *) NULL;\n        rsvg_handle_close(svg_handle,&error);\n        if (error != (GError *) NULL)\n          g_error_free(error);\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n        apply_density=MagickTrue;\n        rsvg_handle_get_dimensions(svg_handle,&dimension_info);\n        if ((image->x_resolution > 0.0) && (image->y_resolution > 0.0))\n          {\n            RsvgDimensionData\n              dpi_dimension_info;\n\n            /*\n              We should not apply the density when the internal 'factor' is 'i'.\n              This can be checked by using the trick below.\n            */\n            rsvg_handle_set_dpi_x_y(svg_handle,image->x_resolution*256,\n              image->y_resolution*256);\n            rsvg_handle_get_dimensions(svg_handle,&dpi_dimension_info);\n            if ((dpi_dimension_info.width != dimension_info.width) ||\n                (dpi_dimension_info.height != dimension_info.height))\n              apply_density=MagickFalse;\n            rsvg_handle_set_dpi_x_y(svg_handle,image->x_resolution,\n              image->y_resolution);\n          }\n        if (image_info->size != (char *) NULL)\n          {\n            (void) GetGeometry(image_info->size,(ssize_t *) NULL,\n              (ssize_t *) NULL,&image->columns,&image->rows);\n            if ((image->columns != 0) || (image->rows != 0))\n              {\n                image->x_resolution=90.0*image->columns/dimension_info.width;\n                image->y_resolution=90.0*image->rows/dimension_info.height;\n                if (fabs(image->x_resolution) < MagickEpsilon)\n                  image->x_resolution=image->y_resolution;\n                else\n                  if (fabs(image->y_resolution) < MagickEpsilon)\n                    image->y_resolution=image->x_resolution;\n                  else\n                    image->x_resolution=image->y_resolution=MagickMin(\n                      image->x_resolution,image->y_resolution);\n                apply_density=MagickTrue;\n              }\n          }\n        if (apply_density != MagickFalse)\n          {\n            image->columns=image->x_resolution*dimension_info.width/90.0;\n            image->rows=image->y_resolution*dimension_info.height/90.0;\n          }\n        else\n          {\n            image->columns=dimension_info.width;\n            image->rows=dimension_info.height;\n          }\n        pixel_info=(MemoryInfo *) NULL;\n#else\n        pixel_buffer=rsvg_handle_get_pixbuf(svg_handle);\n        rsvg_handle_free(svg_handle);\n        image->columns=gdk_pixbuf_get_width(pixel_buffer);\n        image->rows=gdk_pixbuf_get_height(pixel_buffer);\n#endif\n        image->matte=MagickTrue;\n        SetImageProperty(image,\"svg:base-uri\",\n          rsvg_handle_get_base_uri(svg_handle));\n        status=SetImageExtent(image,image->columns,image->rows);\n        if (status == MagickFalse)\n          {\n#if !defined(MAGICKCORE_CAIRO_DELEGATE)\n            g_object_unref(G_OBJECT(pixel_buffer));\n#endif\n            g_object_unref(svg_handle);\n            InheritException(exception,&image->exception);\n            ThrowReaderException(MissingDelegateError,\n              \"NoDecodeDelegateForThisImageFormat\");\n          }\n        if (image_info->ping == MagickFalse)\n          {\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n            size_t\n              stride;\n\n            stride=4*image->columns;\n#if defined(MAGICKCORE_PANGOCAIRO_DELEGATE)\n            stride=(size_t) cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32,\n              (int) image->columns);\n#endif\n            pixel_info=AcquireVirtualMemory(stride,image->rows*sizeof(*pixels));\n            if (pixel_info == (MemoryInfo *) NULL)\n              {\n                g_object_unref(svg_handle);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n            pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n#endif\n            (void) SetImageBackgroundColor(image);\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n            cairo_surface=cairo_image_surface_create_for_data(pixels,\n              CAIRO_FORMAT_ARGB32,(int) image->columns,(int) image->rows, (int)\n              stride);\n            if (cairo_surface == (cairo_surface_t *) NULL)\n              {\n                pixel_info=RelinquishVirtualMemory(pixel_info);\n                g_object_unref(svg_handle);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n            cairo_image=cairo_create(cairo_surface);\n            cairo_set_operator(cairo_image,CAIRO_OPERATOR_CLEAR);\n            cairo_paint(cairo_image);\n            cairo_set_operator(cairo_image,CAIRO_OPERATOR_OVER);\n            if (apply_density != MagickFalse)\n              cairo_scale(cairo_image,image->x_resolution/90.0,\n                image->y_resolution/90.0);\n            rsvg_handle_render_cairo(svg_handle,cairo_image);\n            cairo_destroy(cairo_image);\n            cairo_surface_destroy(cairo_surface);\n            g_object_unref(svg_handle);\n            p=pixels;\n#else\n            p=gdk_pixbuf_get_pixels(pixel_buffer);\n#endif\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n                fill_color.blue=ScaleCharToQuantum(*p++);\n                fill_color.green=ScaleCharToQuantum(*p++);\n                fill_color.red=ScaleCharToQuantum(*p++);\n#else\n                fill_color.red=ScaleCharToQuantum(*p++);\n                fill_color.green=ScaleCharToQuantum(*p++);\n                fill_color.blue=ScaleCharToQuantum(*p++);\n#endif\n                fill_color.opacity=QuantumRange-ScaleCharToQuantum(*p++);\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n                {\n                  double\n                    gamma;\n\n                  gamma=1.0-QuantumScale*fill_color.opacity;\n                  gamma=PerceptibleReciprocal(gamma);\n                  fill_color.blue*=gamma;\n                  fill_color.green*=gamma;\n                  fill_color.red*=gamma;\n                }\n#endif\n                MagickCompositeOver(&fill_color,fill_color.opacity,q,\n                  (MagickRealType) q->opacity,q);\n                q++;\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n#if defined(MAGICKCORE_CAIRO_DELEGATE)\n        if (pixel_info != (MemoryInfo *) NULL)\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n#else\n        g_object_unref(G_OBJECT(pixel_buffer));\n#endif\n        (void) CloseBlob(image);\n        for (next=GetFirstImageInList(image); next != (Image *) NULL; )\n        {\n          (void) CopyMagickString(next->filename,image->filename,MaxTextExtent);\n          (void) CopyMagickString(next->magick,image->magick,MaxTextExtent);\n          next=GetNextImageInList(next);\n        }\n        return(GetFirstImageInList(image));\n#endif\n      }\n    }\n  /*\n    Open draw file.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"w\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      (void) CopyMagickString(image->filename,filename,MaxTextExtent);\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Parse SVG file.\n  */\n  svg_info=AcquireSVGInfo();\n  if (svg_info == (SVGInfo *) NULL)\n    {\n      (void) fclose(file);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  svg_info->file=file;\n  svg_info->exception=exception;\n  svg_info->image=image;\n  svg_info->image_info=image_info;\n  svg_info->bounds.width=image->columns;\n  svg_info->bounds.height=image->rows;\n  if (image_info->size != (char *) NULL)\n    (void) CloneString(&svg_info->size,image_info->size);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"begin SAX\");\n  (void) xmlSubstituteEntitiesDefault(1);\n  (void) ResetMagickMemory(&sax_modules,0,sizeof(sax_modules));\n  sax_modules.internalSubset=SVGInternalSubset;\n  sax_modules.isStandalone=SVGIsStandalone;\n  sax_modules.hasInternalSubset=SVGHasInternalSubset;\n  sax_modules.hasExternalSubset=SVGHasExternalSubset;\n  sax_modules.resolveEntity=SVGResolveEntity;\n  sax_modules.getEntity=SVGGetEntity;\n  sax_modules.entityDecl=SVGEntityDeclaration;\n  sax_modules.notationDecl=SVGNotationDeclaration;\n  sax_modules.attributeDecl=SVGAttributeDeclaration;\n  sax_modules.elementDecl=SVGElementDeclaration;\n  sax_modules.unparsedEntityDecl=SVGUnparsedEntityDeclaration;\n  sax_modules.setDocumentLocator=SVGSetDocumentLocator;\n  sax_modules.startDocument=SVGStartDocument;\n  sax_modules.endDocument=SVGEndDocument;\n  sax_modules.startElement=SVGStartElement;\n  sax_modules.endElement=SVGEndElement;\n  sax_modules.reference=SVGReference;\n  sax_modules.characters=SVGCharacters;\n  sax_modules.ignorableWhitespace=SVGIgnorableWhitespace;\n  sax_modules.processingInstruction=SVGProcessingInstructions;\n  sax_modules.comment=SVGComment;\n  sax_modules.warning=SVGWarning;\n  sax_modules.error=SVGError;\n  sax_modules.fatalError=SVGError;\n  sax_modules.getParameterEntity=SVGGetParameterEntity;\n  sax_modules.cdataBlock=SVGCDataBlock;\n  sax_modules.externalSubset=SVGExternalSubset;\n  sax_handler=(&sax_modules);\n  n=ReadBlob(image,MaxTextExtent-1,message);\n  message[n]='\\0';\n  if (n > 0)\n    {\n      svg_info->parser=xmlCreatePushParserCtxt(sax_handler,svg_info,(char *)\n        message,n,image->filename);\n      while ((n=ReadBlob(image,MaxTextExtent-1,message)) != 0)\n      {\n        message[n]='\\0';\n        status=xmlParseChunk(svg_info->parser,(char *) message,(int) n,0);\n        if (status != 0)\n          break;\n      }\n    }\n  (void) xmlParseChunk(svg_info->parser,(char *) message,0,1);\n  SVGEndDocument(svg_info);\n  xmlFreeParserCtxt(svg_info->parser);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"end SAX\");\n  (void) fclose(file);\n  (void) CloseBlob(image);\n  image->columns=svg_info->width;\n  image->rows=svg_info->height;\n  if (exception->severity >= ErrorException)\n    {\n      svg_info=DestroySVGInfo(svg_info);\n      (void) RelinquishUniqueFileResource(filename);\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  if (image_info->ping == MagickFalse)\n    {\n      ImageInfo\n        *read_info;\n\n      /*\n        Draw image.\n      */\n      image=DestroyImage(image);\n      image=(Image *) NULL;\n      read_info=CloneImageInfo(image_info);\n      SetImageInfoBlob(read_info,(void *) NULL,0);\n      if (read_info->density != (char *) NULL)\n        read_info->density=DestroyString(read_info->density);\n      (void) FormatLocaleString(read_info->filename,MaxTextExtent,\"mvg:%s\",\n        filename);\n      image=ReadImage(read_info,exception);\n      read_info=DestroyImageInfo(read_info);\n      if (image != (Image *) NULL)\n        (void) CopyMagickString(image->filename,image_info->filename,\n          MaxTextExtent);\n    }\n  /*\n    Relinquish resources.\n  */\n  if (image != (Image *) NULL)\n    {\n      if (svg_info->title != (char *) NULL)\n        (void) SetImageProperty(image,\"svg:title\",svg_info->title);\n      if (svg_info->comment != (char *) NULL)\n        (void) SetImageProperty(image,\"svg:comment\",svg_info->comment);\n    }\n  svg_info=DestroySVGInfo(svg_info);\n  (void) RelinquishUniqueFileResource(filename);\n  for (next=GetFirstImageInList(image); next != (Image *) NULL; )\n  {\n    (void) CopyMagickString(next->filename,image->filename,MaxTextExtent);\n    (void) CopyMagickString(next->magick,image->magick,MaxTextExtent);\n    next=GetNextImageInList(next);\n  }\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -477,6 +477,8 @@\n   image->rows=svg_info->height;\n   if (exception->severity >= ErrorException)\n     {\n+      svg_info=DestroySVGInfo(svg_info);\n+      (void) RelinquishUniqueFileResource(filename);\n       image=DestroyImage(image);\n       return((Image *) NULL);\n     }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      svg_info=DestroySVGInfo(svg_info);",
                "      (void) RelinquishUniqueFileResource(filename);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8343",
        "func_name": "ImageMagick/ReadAAIImage",
        "description": "In ImageMagick 7.0.5-5, the ReadAAIImage function in aai.c allows attackers to cause a denial of service (memory leak) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/448492b929894ecbfb1007c3cee5c45ce9c6cba3",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/444",
        "commit_text": "",
        "func_before": "static Image *ReadAAIImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    height,\n    length,\n    width;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read AAI Dune image.\n  */\n  width=ReadBlobLSBLong(image);\n  height=ReadBlobLSBLong(image);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((width == 0UL) || (height == 0UL))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    /*\n      Convert AAI raster image to pixel packets.\n    */\n    image->columns=width;\n    image->rows=height;\n    image->depth=8;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    pixels=(unsigned char *) AcquireQuantumMemory(image->columns,\n      4*sizeof(*pixels));\n    if (pixels == (unsigned char *) NULL) \n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    length=(size_t) 4*image->columns;\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      count=ReadBlob(image,length,pixels);\n      if (count != (ssize_t) length)\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      p=pixels;\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (Quantum *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n        SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n        SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n        if (*p == 254)\n          *p=255;\n        SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n        if (GetPixelAlpha(image,q) != OpaqueAlpha)\n          image->alpha_trait=BlendPixelTrait;\n        q+=GetPixelChannels(image);\n      }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    width=ReadBlobLSBLong(image);\n    height=ReadBlobLSBLong(image);\n    if ((width != 0UL) && (height != 0UL))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((width != 0UL) && (height != 0UL));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadAAIImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    height,\n    length,\n    width;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read AAI Dune image.\n  */\n  width=ReadBlobLSBLong(image);\n  height=ReadBlobLSBLong(image);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((width == 0UL) || (height == 0UL))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    /*\n      Convert AAI raster image to pixel packets.\n    */\n    image->columns=width;\n    image->rows=height;\n    image->depth=8;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    pixels=(unsigned char *) AcquireQuantumMemory(image->columns,\n      4*sizeof(*pixels));\n    if (pixels == (unsigned char *) NULL) \n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    length=(size_t) 4*image->columns;\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      count=ReadBlob(image,length,pixels);\n      if (count != (ssize_t) length)\n        {\n          pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n        }\n      p=pixels;\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (Quantum *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n        SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n        SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n        if (*p == 254)\n          *p=255;\n        SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n        if (GetPixelAlpha(image,q) != OpaqueAlpha)\n          image->alpha_trait=BlendPixelTrait;\n        q+=GetPixelChannels(image);\n      }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    width=ReadBlobLSBLong(image);\n    height=ReadBlobLSBLong(image);\n    if ((width != 0UL) && (height != 0UL))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((width != 0UL) && (height != 0UL));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -76,7 +76,10 @@\n     {\n       count=ReadBlob(image,length,pixels);\n       if (count != (ssize_t) length)\n-        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n+        {\n+          pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n+          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n+        }\n       p=pixels;\n       q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n       if (q == (Quantum *) NULL)",
        "diff_line_info": {
            "deleted_lines": [
                "        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");"
            ],
            "added_lines": [
                "        {",
                "          pixels=(unsigned char *) RelinquishMagickMemory(pixels);",
                "          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8344",
        "func_name": "ImageMagick/ReadPCXImage",
        "description": "In ImageMagick 7.0.5-5, the ReadPCXImage function in pcx.c allows attackers to cause a denial of service (memory leak) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/4c6289b2f39a47a430ce27b61d3e3967201e77e8",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/446",
        "commit_text": "",
        "func_before": "static Image *ReadPCXImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowPCXException(severity,tag) \\\n  { \\\n    scanline=(unsigned char *) RelinquishMagickMemory(scanline); \\\n    pixel_info=RelinquishVirtualMemory(pixel_info); \\\n    ThrowReaderException(severity,tag); \\\n  }\n\n  Image\n    *image;\n\n  int\n    bits,\n    id,\n    mask;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    *page_table;\n\n  MemoryInfo\n    *pixel_info;\n\n  PCXInfo\n    pcx_info;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p,\n    *r;\n\n  size_t\n    one,\n    pcx_packets;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    packet,\n    pcx_colormap[768],\n    *pixels,\n    *scanline;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a PCX file.\n  */\n  page_table=(MagickOffsetType *) NULL;\n  if (LocaleCompare(image_info->magick,\"DCX\") == 0)\n    {\n      size_t\n        magic;\n\n      /*\n        Read the DCX page table.\n      */\n      magic=ReadBlobLSBLong(image);\n      if (magic != 987654321)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      page_table=(MagickOffsetType *) AcquireQuantumMemory(1024UL,\n        sizeof(*page_table));\n      if (page_table == (MagickOffsetType *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (id=0; id < 1024; id++)\n      {\n        page_table[id]=(MagickOffsetType) ReadBlobLSBLong(image);\n        if (page_table[id] == 0)\n          break;\n      }\n    }\n  if (page_table != (MagickOffsetType *) NULL)\n    {\n      offset=SeekBlob(image,(MagickOffsetType) page_table[0],SEEK_SET);\n      if (offset < 0)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  count=ReadBlob(image,1,&pcx_info.identifier);\n  for (id=1; id < 1024; id++)\n  {\n    int\n      bits_per_pixel;\n\n    /*\n      Verify PCX identifier.\n    */\n    pcx_info.version=(unsigned char) ReadBlobByte(image);\n    if ((count != 1) || (pcx_info.identifier != 0x0a))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_info.encoding=(unsigned char) ReadBlobByte(image);\n    bits_per_pixel=ReadBlobByte(image);\n    if (bits_per_pixel == -1)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_info.bits_per_pixel=(unsigned char) bits_per_pixel;\n    pcx_info.left=ReadBlobLSBShort(image);\n    pcx_info.top=ReadBlobLSBShort(image);\n    pcx_info.right=ReadBlobLSBShort(image);\n    pcx_info.bottom=ReadBlobLSBShort(image);\n    pcx_info.horizontal_resolution=ReadBlobLSBShort(image);\n    pcx_info.vertical_resolution=ReadBlobLSBShort(image);\n    /*\n      Read PCX raster colormap.\n    */\n    image->columns=(size_t) MagickAbsoluteValue((ssize_t) pcx_info.right-\n      pcx_info.left)+1UL;\n    image->rows=(size_t) MagickAbsoluteValue((ssize_t) pcx_info.bottom-\n      pcx_info.top)+1UL;\n    if ((image->columns == 0) || (image->rows == 0) ||\n        ((pcx_info.bits_per_pixel != 1) && (pcx_info.bits_per_pixel != 2) &&\n         (pcx_info.bits_per_pixel != 4) && (pcx_info.bits_per_pixel != 8)))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->depth=pcx_info.bits_per_pixel;\n    image->units=PixelsPerInchResolution;\n    image->x_resolution=(double) pcx_info.horizontal_resolution;\n    image->y_resolution=(double) pcx_info.vertical_resolution;\n    image->colors=16;\n    count=ReadBlob(image,3*image->colors,pcx_colormap);\n    if (count != (ssize_t) (3*image->colors))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_info.reserved=(unsigned char) ReadBlobByte(image);\n    pcx_info.planes=(unsigned char) ReadBlobByte(image);\n    if ((pcx_info.bits_per_pixel*pcx_info.planes) >= 64)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (pcx_info.planes == 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    one=1;\n    if ((pcx_info.bits_per_pixel != 8) || (pcx_info.planes == 1))\n      if ((pcx_info.version == 3) || (pcx_info.version == 5) ||\n          ((pcx_info.bits_per_pixel*pcx_info.planes) == 1))\n        image->colors=(size_t) MagickMin(one << (1UL*\n          (pcx_info.bits_per_pixel*pcx_info.planes)),256UL);\n    if (AcquireImageColormap(image,image->colors) == MagickFalse)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((pcx_info.bits_per_pixel >= 8) && (pcx_info.planes != 1))\n      image->storage_class=DirectClass;\n    p=pcx_colormap;\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      image->colormap[i].red=ScaleCharToQuantum(*p++);\n      image->colormap[i].green=ScaleCharToQuantum(*p++);\n      image->colormap[i].blue=ScaleCharToQuantum(*p++);\n    }\n    pcx_info.bytes_per_line=ReadBlobLSBShort(image);\n    pcx_info.palette_info=ReadBlobLSBShort(image);\n    pcx_info.horizontal_screensize=ReadBlobLSBShort(image);\n    pcx_info.vertical_screensize=ReadBlobLSBShort(image);\n    for (i=0; i < 54; i++)\n      (void) ReadBlobByte(image);\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    /*\n      Read image data.\n    */\n    if (HeapOverflowSanityCheck(image->rows, (size_t) pcx_info.bytes_per_line) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_packets=(size_t) image->rows*pcx_info.bytes_per_line;\n    if (HeapOverflowSanityCheck(pcx_packets, (size_t) pcx_info.planes) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_packets=(size_t) pcx_packets*pcx_info.planes;\n    if ((size_t) (pcx_info.bits_per_pixel*pcx_info.planes*image->columns) >\n        (pcx_packets*8U))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    scanline=(unsigned char *) AcquireQuantumMemory(MagickMax(image->columns,\n      pcx_info.bytes_per_line),MagickMax(8,pcx_info.planes)*sizeof(*scanline));\n    pixel_info=AcquireVirtualMemory(pcx_packets,2*sizeof(*pixels));\n    if ((scanline == (unsigned char *) NULL) ||\n        (pixel_info == (MemoryInfo *) NULL))\n      {\n        if (scanline != (unsigned char *) NULL)\n          scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n        if (pixel_info != (MemoryInfo *) NULL)\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    /*\n      Uncompress image data.\n    */\n    p=pixels;\n    if (pcx_info.encoding == 0)\n      while (pcx_packets != 0)\n      {\n        packet=(unsigned char) ReadBlobByte(image);\n        if (EOFBlob(image) != MagickFalse)\n          ThrowPCXException(CorruptImageError,\"UnexpectedEndOfFile\");\n        *p++=packet;\n        pcx_packets--;\n      }\n    else\n      while (pcx_packets != 0)\n      {\n        packet=(unsigned char) ReadBlobByte(image);\n        if (EOFBlob(image) != MagickFalse)\n          ThrowPCXException(CorruptImageError,\"UnexpectedEndOfFile\");\n        if ((packet & 0xc0) != 0xc0)\n          {\n            *p++=packet;\n            pcx_packets--;\n            continue;\n          }\n        count=(ssize_t) (packet & 0x3f);\n        packet=(unsigned char) ReadBlobByte(image);\n        if (EOFBlob(image) != MagickFalse)\n          ThrowPCXException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for ( ; count != 0; count--)\n        {\n          *p++=packet;\n          pcx_packets--;\n          if (pcx_packets == 0)\n            break;\n        }\n      }\n    if (image->storage_class == DirectClass)\n      image->matte=pcx_info.planes > 3 ? MagickTrue : MagickFalse;\n    else\n      if ((pcx_info.version == 5) ||\n          ((pcx_info.bits_per_pixel*pcx_info.planes) == 1))\n        {\n          /*\n            Initialize image colormap.\n          */\n          if (image->colors > 256)\n            ThrowPCXException(CorruptImageError,\"ColormapExceeds256Colors\");\n          if ((pcx_info.bits_per_pixel*pcx_info.planes) == 1)\n            {\n              /*\n                Monochrome colormap.\n              */\n              image->colormap[0].red=(Quantum) 0;\n              image->colormap[0].green=(Quantum) 0;\n              image->colormap[0].blue=(Quantum) 0;\n              image->colormap[1].red=QuantumRange;\n              image->colormap[1].green=QuantumRange;\n              image->colormap[1].blue=QuantumRange;\n            }\n          else\n            if (image->colors > 16)\n              {\n                /*\n                  256 color images have their color map at the end of the file.\n                */\n                pcx_info.colormap_signature=(unsigned char) ReadBlobByte(image);\n                count=ReadBlob(image,3*image->colors,pcx_colormap);\n                p=pcx_colormap;\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum(*p++);\n                  image->colormap[i].green=ScaleCharToQuantum(*p++);\n                  image->colormap[i].blue=ScaleCharToQuantum(*p++);\n                }\n            }\n        }\n    /*\n      Convert PCX raster image to pixel packets.\n    */\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=pixels+(y*pcx_info.bytes_per_line*pcx_info.planes);\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (PixelPacket *) NULL)\n        break;\n      indexes=GetAuthenticIndexQueue(image);\n      r=scanline;\n      if (image->storage_class == DirectClass)\n        for (i=0; i < pcx_info.planes; i++)\n        {\n          r=scanline+i;\n          for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n          {\n            switch (i)\n            {\n              case 0:\n              {\n                *r=(*p++);\n                break;\n              }\n              case 1:\n              {\n                *r=(*p++);\n                break;\n              }\n              case 2:\n              {\n                *r=(*p++);\n                break;\n              }\n              case 3:\n              default:\n              {\n                *r=(*p++);\n                break;\n              }\n            }\n            r+=pcx_info.planes;\n          }\n        }\n      else\n        if (pcx_info.planes > 1)\n          {\n            for (x=0; x < (ssize_t) image->columns; x++)\n              *r++=0;\n            for (i=0; i < pcx_info.planes; i++)\n            {\n              r=scanline;\n              for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n              {\n                 bits=(*p++);\n                 for (mask=0x80; mask != 0; mask>>=1)\n                 {\n                   if (bits & mask)\n                     *r|=1 << i;\n                   r++;\n                 }\n               }\n            }\n          }\n        else\n          switch (pcx_info.bits_per_pixel)\n          {\n            case 1:\n            {\n              register ssize_t\n                bit;\n\n              for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n              {\n                for (bit=7; bit >= 0; bit--)\n                  *r++=(unsigned char) ((*p) & (0x01 << bit) ? 0x01 : 0x00);\n                p++;\n              }\n              if ((image->columns % 8) != 0)\n                {\n                  for (bit=7; bit >= (ssize_t) (8-(image->columns % 8)); bit--)\n                    *r++=(unsigned char) ((*p) & (0x01 << bit) ? 0x01 : 0x00);\n                  p++;\n                }\n              break;\n            }\n            case 2:\n            {\n              for (x=0; x < ((ssize_t) image->columns-3); x+=4)\n              {\n                *r++=(*p >> 6) & 0x3;\n                *r++=(*p >> 4) & 0x3;\n                *r++=(*p >> 2) & 0x3;\n                *r++=(*p) & 0x3;\n                p++;\n              }\n              if ((image->columns % 4) != 0)\n                {\n                  for (i=3; i >= (ssize_t) (4-(image->columns % 4)); i--)\n                    *r++=(unsigned char) ((*p >> (i*2)) & 0x03);\n                  p++;\n                }\n              break;\n            }\n            case 4:\n            {\n              for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n              {\n                *r++=(*p >> 4) & 0xf;\n                *r++=(*p) & 0xf;\n                p++;\n              }\n              if ((image->columns % 2) != 0)\n                *r++=(*p++ >> 4) & 0xf;\n              break;\n            }\n            case 8:\n            {\n              (void) CopyMagickMemory(r,p,image->columns);\n              break;\n            }\n            default:\n              break;\n          }\n      /*\n        Transfer image scanline.\n      */\n      r=scanline;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        if (image->storage_class == PseudoClass)\n          SetPixelIndex(indexes+x,*r++);\n        else\n          {\n            SetPixelRed(q,ScaleCharToQuantum(*r++));\n            SetPixelGreen(q,ScaleCharToQuantum(*r++));\n            SetPixelBlue(q,ScaleCharToQuantum(*r++));\n            if (image->matte != MagickFalse)\n              SetPixelAlpha(q,ScaleCharToQuantum(*r++));\n          }\n        q++;\n      }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image);\n    scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (page_table == (MagickOffsetType *) NULL)\n      break;\n    if (page_table[id] == 0)\n      break;\n    offset=SeekBlob(image,(MagickOffsetType) page_table[id],SEEK_SET);\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    count=ReadBlob(image,1,&pcx_info.identifier);\n    if ((count != 0) && (pcx_info.identifier == 0x0a))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  if (page_table != (MagickOffsetType *) NULL)\n    page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadPCXImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define ThrowPCXException(severity,tag) \\\n{ \\\n  if (scanline != (unsigned char *) NULL) \\\n    scanline=(unsigned char *) RelinquishMagickMemory(scanline); \\\n  if (pixel_info != (MemoryInfo *) NULL) \\\n    pixel_info=RelinquishVirtualMemory(pixel_info); \\\n  if (page_table != (MagickOffsetType *) NULL) \\\n    page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table); \\\n  ThrowReaderException(severity,tag); \\\n}\n\n  Image\n    *image;\n\n  int\n    bits,\n    id,\n    mask;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    *page_table;\n\n  MemoryInfo\n    *pixel_info;\n\n  PCXInfo\n    pcx_info;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p,\n    *r;\n\n  size_t\n    one,\n    pcx_packets;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    packet,\n    pcx_colormap[768],\n    *pixels,\n    *scanline;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a PCX file.\n  */\n  page_table=(MagickOffsetType *) NULL;\n  scanline=(unsigned char *) NULL;\n  pixel_info=(MemoryInfo *) NULL;\n  if (LocaleCompare(image_info->magick,\"DCX\") == 0)\n    {\n      size_t\n        magic;\n\n      /*\n        Read the DCX page table.\n      */\n      magic=ReadBlobLSBLong(image);\n      if (magic != 987654321)\n        ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n      page_table=(MagickOffsetType *) AcquireQuantumMemory(1024UL,\n        sizeof(*page_table));\n      if (page_table == (MagickOffsetType *) NULL)\n        ThrowPCXException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (id=0; id < 1024; id++)\n      {\n        page_table[id]=(MagickOffsetType) ReadBlobLSBLong(image);\n        if (page_table[id] == 0)\n          break;\n      }\n    }\n  if (page_table != (MagickOffsetType *) NULL)\n    {\n      offset=SeekBlob(image,(MagickOffsetType) page_table[0],SEEK_SET);\n      if (offset < 0)\n        ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  count=ReadBlob(image,1,&pcx_info.identifier);\n  for (id=1; id < 1024; id++)\n  {\n    int\n      bits_per_pixel;\n\n    /*\n      Verify PCX identifier.\n    */\n    pcx_info.version=(unsigned char) ReadBlobByte(image);\n    if ((count != 1) || (pcx_info.identifier != 0x0a))\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_info.encoding=(unsigned char) ReadBlobByte(image);\n    bits_per_pixel=ReadBlobByte(image);\n    if (bits_per_pixel == -1)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_info.bits_per_pixel=(unsigned char) bits_per_pixel;\n    pcx_info.left=ReadBlobLSBShort(image);\n    pcx_info.top=ReadBlobLSBShort(image);\n    pcx_info.right=ReadBlobLSBShort(image);\n    pcx_info.bottom=ReadBlobLSBShort(image);\n    pcx_info.horizontal_resolution=ReadBlobLSBShort(image);\n    pcx_info.vertical_resolution=ReadBlobLSBShort(image);\n    /*\n      Read PCX raster colormap.\n    */\n    image->columns=(size_t) MagickAbsoluteValue((ssize_t) pcx_info.right-\n      pcx_info.left)+1UL;\n    image->rows=(size_t) MagickAbsoluteValue((ssize_t) pcx_info.bottom-\n      pcx_info.top)+1UL;\n    if ((image->columns == 0) || (image->rows == 0) ||\n        ((pcx_info.bits_per_pixel != 1) && (pcx_info.bits_per_pixel != 2) &&\n         (pcx_info.bits_per_pixel != 4) && (pcx_info.bits_per_pixel != 8)))\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    image->depth=pcx_info.bits_per_pixel;\n    image->units=PixelsPerInchResolution;\n    image->x_resolution=(double) pcx_info.horizontal_resolution;\n    image->y_resolution=(double) pcx_info.vertical_resolution;\n    image->colors=16;\n    count=ReadBlob(image,3*image->colors,pcx_colormap);\n    if (count != (ssize_t) (3*image->colors))\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_info.reserved=(unsigned char) ReadBlobByte(image);\n    pcx_info.planes=(unsigned char) ReadBlobByte(image);\n    if ((pcx_info.bits_per_pixel*pcx_info.planes) >= 64)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    if (pcx_info.planes == 0)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    one=1;\n    if ((pcx_info.bits_per_pixel != 8) || (pcx_info.planes == 1))\n      if ((pcx_info.version == 3) || (pcx_info.version == 5) ||\n          ((pcx_info.bits_per_pixel*pcx_info.planes) == 1))\n        image->colors=(size_t) MagickMin(one << (1UL*\n          (pcx_info.bits_per_pixel*pcx_info.planes)),256UL);\n    if (AcquireImageColormap(image,image->colors) == MagickFalse)\n      ThrowPCXException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if ((pcx_info.bits_per_pixel >= 8) && (pcx_info.planes != 1))\n      image->storage_class=DirectClass;\n    p=pcx_colormap;\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      image->colormap[i].red=ScaleCharToQuantum(*p++);\n      image->colormap[i].green=ScaleCharToQuantum(*p++);\n      image->colormap[i].blue=ScaleCharToQuantum(*p++);\n    }\n    pcx_info.bytes_per_line=ReadBlobLSBShort(image);\n    pcx_info.palette_info=ReadBlobLSBShort(image);\n    pcx_info.horizontal_screensize=ReadBlobLSBShort(image);\n    pcx_info.vertical_screensize=ReadBlobLSBShort(image);\n    for (i=0; i < 54; i++)\n      (void) ReadBlobByte(image);\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    /*\n      Read image data.\n    */\n    if (HeapOverflowSanityCheck(image->rows, (size_t) pcx_info.bytes_per_line) != MagickFalse)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_packets=(size_t) image->rows*pcx_info.bytes_per_line;\n    if (HeapOverflowSanityCheck(pcx_packets, (size_t) pcx_info.planes) != MagickFalse)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    pcx_packets=(size_t) pcx_packets*pcx_info.planes;\n    if ((size_t) (pcx_info.bits_per_pixel*pcx_info.planes*image->columns) >\n        (pcx_packets*8U))\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    scanline=(unsigned char *) AcquireQuantumMemory(MagickMax(image->columns,\n      pcx_info.bytes_per_line),MagickMax(8,pcx_info.planes)*sizeof(*scanline));\n    pixel_info=AcquireVirtualMemory(pcx_packets,2*sizeof(*pixels));\n    if ((scanline == (unsigned char *) NULL) ||\n        (pixel_info == (MemoryInfo *) NULL))\n      {\n        if (scanline != (unsigned char *) NULL)\n          scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n        if (pixel_info != (MemoryInfo *) NULL)\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n        ThrowPCXException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    /*\n      Uncompress image data.\n    */\n    p=pixels;\n    if (pcx_info.encoding == 0)\n      while (pcx_packets != 0)\n      {\n        packet=(unsigned char) ReadBlobByte(image);\n        if (EOFBlob(image) != MagickFalse)\n          ThrowPCXException(CorruptImageError,\"UnexpectedEndOfFile\");\n        *p++=packet;\n        pcx_packets--;\n      }\n    else\n      while (pcx_packets != 0)\n      {\n        packet=(unsigned char) ReadBlobByte(image);\n        if (EOFBlob(image) != MagickFalse)\n          ThrowPCXException(CorruptImageError,\"UnexpectedEndOfFile\");\n        if ((packet & 0xc0) != 0xc0)\n          {\n            *p++=packet;\n            pcx_packets--;\n            continue;\n          }\n        count=(ssize_t) (packet & 0x3f);\n        packet=(unsigned char) ReadBlobByte(image);\n        if (EOFBlob(image) != MagickFalse)\n          ThrowPCXException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for ( ; count != 0; count--)\n        {\n          *p++=packet;\n          pcx_packets--;\n          if (pcx_packets == 0)\n            break;\n        }\n      }\n    if (image->storage_class == DirectClass)\n      image->matte=pcx_info.planes > 3 ? MagickTrue : MagickFalse;\n    else\n      if ((pcx_info.version == 5) ||\n          ((pcx_info.bits_per_pixel*pcx_info.planes) == 1))\n        {\n          /*\n            Initialize image colormap.\n          */\n          if (image->colors > 256)\n            ThrowPCXException(CorruptImageError,\"ColormapExceeds256Colors\");\n          if ((pcx_info.bits_per_pixel*pcx_info.planes) == 1)\n            {\n              /*\n                Monochrome colormap.\n              */\n              image->colormap[0].red=(Quantum) 0;\n              image->colormap[0].green=(Quantum) 0;\n              image->colormap[0].blue=(Quantum) 0;\n              image->colormap[1].red=QuantumRange;\n              image->colormap[1].green=QuantumRange;\n              image->colormap[1].blue=QuantumRange;\n            }\n          else\n            if (image->colors > 16)\n              {\n                /*\n                  256 color images have their color map at the end of the file.\n                */\n                pcx_info.colormap_signature=(unsigned char) ReadBlobByte(image);\n                count=ReadBlob(image,3*image->colors,pcx_colormap);\n                p=pcx_colormap;\n                for (i=0; i < (ssize_t) image->colors; i++)\n                {\n                  image->colormap[i].red=ScaleCharToQuantum(*p++);\n                  image->colormap[i].green=ScaleCharToQuantum(*p++);\n                  image->colormap[i].blue=ScaleCharToQuantum(*p++);\n                }\n            }\n        }\n    /*\n      Convert PCX raster image to pixel packets.\n    */\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=pixels+(y*pcx_info.bytes_per_line*pcx_info.planes);\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (PixelPacket *) NULL)\n        break;\n      indexes=GetAuthenticIndexQueue(image);\n      r=scanline;\n      if (image->storage_class == DirectClass)\n        for (i=0; i < pcx_info.planes; i++)\n        {\n          r=scanline+i;\n          for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n          {\n            switch (i)\n            {\n              case 0:\n              {\n                *r=(*p++);\n                break;\n              }\n              case 1:\n              {\n                *r=(*p++);\n                break;\n              }\n              case 2:\n              {\n                *r=(*p++);\n                break;\n              }\n              case 3:\n              default:\n              {\n                *r=(*p++);\n                break;\n              }\n            }\n            r+=pcx_info.planes;\n          }\n        }\n      else\n        if (pcx_info.planes > 1)\n          {\n            for (x=0; x < (ssize_t) image->columns; x++)\n              *r++=0;\n            for (i=0; i < pcx_info.planes; i++)\n            {\n              r=scanline;\n              for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n              {\n                 bits=(*p++);\n                 for (mask=0x80; mask != 0; mask>>=1)\n                 {\n                   if (bits & mask)\n                     *r|=1 << i;\n                   r++;\n                 }\n               }\n            }\n          }\n        else\n          switch (pcx_info.bits_per_pixel)\n          {\n            case 1:\n            {\n              register ssize_t\n                bit;\n\n              for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n              {\n                for (bit=7; bit >= 0; bit--)\n                  *r++=(unsigned char) ((*p) & (0x01 << bit) ? 0x01 : 0x00);\n                p++;\n              }\n              if ((image->columns % 8) != 0)\n                {\n                  for (bit=7; bit >= (ssize_t) (8-(image->columns % 8)); bit--)\n                    *r++=(unsigned char) ((*p) & (0x01 << bit) ? 0x01 : 0x00);\n                  p++;\n                }\n              break;\n            }\n            case 2:\n            {\n              for (x=0; x < ((ssize_t) image->columns-3); x+=4)\n              {\n                *r++=(*p >> 6) & 0x3;\n                *r++=(*p >> 4) & 0x3;\n                *r++=(*p >> 2) & 0x3;\n                *r++=(*p) & 0x3;\n                p++;\n              }\n              if ((image->columns % 4) != 0)\n                {\n                  for (i=3; i >= (ssize_t) (4-(image->columns % 4)); i--)\n                    *r++=(unsigned char) ((*p >> (i*2)) & 0x03);\n                  p++;\n                }\n              break;\n            }\n            case 4:\n            {\n              for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n              {\n                *r++=(*p >> 4) & 0xf;\n                *r++=(*p) & 0xf;\n                p++;\n              }\n              if ((image->columns % 2) != 0)\n                *r++=(*p++ >> 4) & 0xf;\n              break;\n            }\n            case 8:\n            {\n              (void) CopyMagickMemory(r,p,image->columns);\n              break;\n            }\n            default:\n              break;\n          }\n      /*\n        Transfer image scanline.\n      */\n      r=scanline;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        if (image->storage_class == PseudoClass)\n          SetPixelIndex(indexes+x,*r++);\n        else\n          {\n            SetPixelRed(q,ScaleCharToQuantum(*r++));\n            SetPixelGreen(q,ScaleCharToQuantum(*r++));\n            SetPixelBlue(q,ScaleCharToQuantum(*r++));\n            if (image->matte != MagickFalse)\n              SetPixelAlpha(q,ScaleCharToQuantum(*r++));\n          }\n        q++;\n      }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image);\n    scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (page_table == (MagickOffsetType *) NULL)\n      break;\n    if (page_table[id] == 0)\n      break;\n    offset=SeekBlob(image,(MagickOffsetType) page_table[id],SEEK_SET);\n    if (offset < 0)\n      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n    count=ReadBlob(image,1,&pcx_info.identifier);\n    if ((count != 0) && (pcx_info.identifier == 0x0a))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  if (page_table != (MagickOffsetType *) NULL)\n    page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,11 +1,15 @@\n static Image *ReadPCXImage(const ImageInfo *image_info,ExceptionInfo *exception)\n {\n #define ThrowPCXException(severity,tag) \\\n-  { \\\n+{ \\\n+  if (scanline != (unsigned char *) NULL) \\\n     scanline=(unsigned char *) RelinquishMagickMemory(scanline); \\\n+  if (pixel_info != (MemoryInfo *) NULL) \\\n     pixel_info=RelinquishVirtualMemory(pixel_info); \\\n-    ThrowReaderException(severity,tag); \\\n-  }\n+  if (page_table != (MagickOffsetType *) NULL) \\\n+    page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table); \\\n+  ThrowReaderException(severity,tag); \\\n+}\n \n   Image\n     *image;\n@@ -79,6 +83,8 @@\n     Determine if this a PCX file.\n   */\n   page_table=(MagickOffsetType *) NULL;\n+  scanline=(unsigned char *) NULL;\n+  pixel_info=(MemoryInfo *) NULL;\n   if (LocaleCompare(image_info->magick,\"DCX\") == 0)\n     {\n       size_t\n@@ -89,11 +95,11 @@\n       */\n       magic=ReadBlobLSBLong(image);\n       if (magic != 987654321)\n-        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+        ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n       page_table=(MagickOffsetType *) AcquireQuantumMemory(1024UL,\n         sizeof(*page_table));\n       if (page_table == (MagickOffsetType *) NULL)\n-        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+        ThrowPCXException(ResourceLimitError,\"MemoryAllocationFailed\");\n       for (id=0; id < 1024; id++)\n       {\n         page_table[id]=(MagickOffsetType) ReadBlobLSBLong(image);\n@@ -105,7 +111,7 @@\n     {\n       offset=SeekBlob(image,(MagickOffsetType) page_table[0],SEEK_SET);\n       if (offset < 0)\n-        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+        ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n     }\n   count=ReadBlob(image,1,&pcx_info.identifier);\n   for (id=1; id < 1024; id++)\n@@ -118,11 +124,11 @@\n     */\n     pcx_info.version=(unsigned char) ReadBlobByte(image);\n     if ((count != 1) || (pcx_info.identifier != 0x0a))\n-      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n     pcx_info.encoding=(unsigned char) ReadBlobByte(image);\n     bits_per_pixel=ReadBlobByte(image);\n     if (bits_per_pixel == -1)\n-      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n     pcx_info.bits_per_pixel=(unsigned char) bits_per_pixel;\n     pcx_info.left=ReadBlobLSBShort(image);\n     pcx_info.top=ReadBlobLSBShort(image);\n@@ -140,7 +146,7 @@\n     if ((image->columns == 0) || (image->rows == 0) ||\n         ((pcx_info.bits_per_pixel != 1) && (pcx_info.bits_per_pixel != 2) &&\n          (pcx_info.bits_per_pixel != 4) && (pcx_info.bits_per_pixel != 8)))\n-      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n     image->depth=pcx_info.bits_per_pixel;\n     image->units=PixelsPerInchResolution;\n     image->x_resolution=(double) pcx_info.horizontal_resolution;\n@@ -148,13 +154,13 @@\n     image->colors=16;\n     count=ReadBlob(image,3*image->colors,pcx_colormap);\n     if (count != (ssize_t) (3*image->colors))\n-      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n     pcx_info.reserved=(unsigned char) ReadBlobByte(image);\n     pcx_info.planes=(unsigned char) ReadBlobByte(image);\n     if ((pcx_info.bits_per_pixel*pcx_info.planes) >= 64)\n-      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n     if (pcx_info.planes == 0)\n-      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n     one=1;\n     if ((pcx_info.bits_per_pixel != 8) || (pcx_info.planes == 1))\n       if ((pcx_info.version == 3) || (pcx_info.version == 5) ||\n@@ -162,7 +168,7 @@\n         image->colors=(size_t) MagickMin(one << (1UL*\n           (pcx_info.bits_per_pixel*pcx_info.planes)),256UL);\n     if (AcquireImageColormap(image,image->colors) == MagickFalse)\n-      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+      ThrowPCXException(ResourceLimitError,\"MemoryAllocationFailed\");\n     if ((pcx_info.bits_per_pixel >= 8) && (pcx_info.planes != 1))\n       image->storage_class=DirectClass;\n     p=pcx_colormap;\n@@ -191,14 +197,14 @@\n       Read image data.\n     */\n     if (HeapOverflowSanityCheck(image->rows, (size_t) pcx_info.bytes_per_line) != MagickFalse)\n-      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n     pcx_packets=(size_t) image->rows*pcx_info.bytes_per_line;\n     if (HeapOverflowSanityCheck(pcx_packets, (size_t) pcx_info.planes) != MagickFalse)\n-      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n     pcx_packets=(size_t) pcx_packets*pcx_info.planes;\n     if ((size_t) (pcx_info.bits_per_pixel*pcx_info.planes*image->columns) >\n         (pcx_packets*8U))\n-      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n     scanline=(unsigned char *) AcquireQuantumMemory(MagickMax(image->columns,\n       pcx_info.bytes_per_line),MagickMax(8,pcx_info.planes)*sizeof(*scanline));\n     pixel_info=AcquireVirtualMemory(pcx_packets,2*sizeof(*pixels));\n@@ -209,7 +215,7 @@\n           scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n         if (pixel_info != (MemoryInfo *) NULL)\n           pixel_info=RelinquishVirtualMemory(pixel_info);\n-        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+        ThrowPCXException(ResourceLimitError,\"MemoryAllocationFailed\");\n       }\n     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n     /*\n@@ -463,7 +469,7 @@\n       break;\n     offset=SeekBlob(image,(MagickOffsetType) page_table[id],SEEK_SET);\n     if (offset < 0)\n-      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");\n     count=ReadBlob(image,1,&pcx_info.identifier);\n     if ((count != 0) && (pcx_info.identifier == 0x0a))\n       {",
        "diff_line_info": {
            "deleted_lines": [
                "  { \\",
                "    ThrowReaderException(severity,tag); \\",
                "  }",
                "        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");"
            ],
            "added_lines": [
                "{ \\",
                "  if (scanline != (unsigned char *) NULL) \\",
                "  if (pixel_info != (MemoryInfo *) NULL) \\",
                "  if (page_table != (MagickOffsetType *) NULL) \\",
                "    page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table); \\",
                "  ThrowReaderException(severity,tag); \\",
                "}",
                "  scanline=(unsigned char *) NULL;",
                "  pixel_info=(MemoryInfo *) NULL;",
                "        ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");",
                "        ThrowPCXException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "        ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");",
                "      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");",
                "      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");",
                "      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");",
                "      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");",
                "      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");",
                "      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");",
                "      ThrowPCXException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");",
                "      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");",
                "      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");",
                "        ThrowPCXException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "      ThrowPCXException(CorruptImageError,\"ImproperImageHeader\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8346",
        "func_name": "ImageMagick/ReadDCMPixels",
        "description": "In ImageMagick 7.0.5-5, the ReadDCMImage function in dcm.c allows attackers to cause a denial of service (memory leak) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/528b8990f86c19d9f78c90b06fb5dd76f399ce3d",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/440",
        "commit_text": "",
        "func_before": "static MagickBooleanType ReadDCMPixels(Image *image,DCMInfo *info,\n  DCMStreamInfo *stream_info,MagickBooleanType first_segment,\n  ExceptionInfo *exception)\n{\n  int\n    byte,\n    index;\n\n  MagickBooleanType\n    status;\n\n  LongPixelPacket\n    pixel;\n\n  register ssize_t\n    i,\n    x;\n\n  register IndexPacket\n    *indexes;\n\n  register PixelPacket\n    *q;\n\n  ssize_t\n    y;\n\n  /*\n    Convert DCM Medical image to pixel packets.\n  */\n  byte=0;\n  i=0;\n  status=MagickTrue;\n\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    indexes=GetAuthenticIndexQueue(image);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (info->samples_per_pixel == 1)\n        {\n          int\n            pixel_value;\n\n          if (info->bytes_per_pixel == 1)\n            pixel_value=info->polarity != MagickFalse ? ((int) info->max_value-\n              ReadDCMByte(stream_info,image)) :\n              ReadDCMByte(stream_info,image);\n          else\n            if ((info->bits_allocated != 12) || (info->significant_bits != 12))\n              {\n                if (info->signed_data)\n                  pixel_value=ReadDCMSignedShort(stream_info,image);\n                else\n                  pixel_value=ReadDCMShort(stream_info,image);\n                if (info->polarity != MagickFalse)\n                  pixel_value=(int) info->max_value-pixel_value;\n              }\n            else\n              {\n                if ((i & 0x01) != 0)\n                  pixel_value=(ReadDCMByte(stream_info,image) << 8) |\n                    byte;\n                else\n                  {\n                    pixel_value=ReadDCMSignedShort(stream_info,image);\n                    byte=(int) (pixel_value & 0x0f);\n                    pixel_value>>=4;\n                  }\n                i++;\n              }\n          index=(pixel_value*info->rescale_slope)+info->rescale_intercept;\n          if (info->window_width == 0)\n            {\n              if (info->signed_data == 1)\n                index-=32767;\n            }\n          else\n            {\n              ssize_t\n                window_max,\n                window_min;\n\n              window_min=(ssize_t) ceil((double) info->window_center-\n                (info->window_width-1.0)/2.0-0.5);\n              window_max=(ssize_t) floor((double) info->window_center+\n                (info->window_width-1.0)/2.0+0.5);\n              if ((ssize_t) index <= window_min)\n                index=0;\n              else\n                if ((ssize_t) index > window_max)\n                  index=(int) info->max_value;\n                else\n                  index=(int) (info->max_value*(((index-info->window_center-\n                    0.5)/(info->window_width-1))+0.5));\n            }\n          index&=info->mask;\n          index=(int) ConstrainColormapIndex(image,(size_t) index);\n          if (first_segment != MagickFalse)\n            SetPixelIndex(indexes+x,index);\n          else\n            SetPixelIndex(indexes+x,(((size_t) index) |\n              (((size_t) GetPixelIndex(indexes+x)) << 8)));\n          pixel.red=1U*image->colormap[index].red;\n          pixel.green=1U*image->colormap[index].green;\n          pixel.blue=1U*image->colormap[index].blue;\n        }\n      else\n        {\n          if (info->bytes_per_pixel == 1)\n            {\n              pixel.red=(unsigned int) ReadDCMByte(stream_info,image);\n              pixel.green=(unsigned int) ReadDCMByte(stream_info,image);\n              pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);\n            }\n          else\n            {\n              pixel.red=ReadDCMShort(stream_info,image);\n              pixel.green=ReadDCMShort(stream_info,image);\n              pixel.blue=ReadDCMShort(stream_info,image);\n            }\n          pixel.red&=info->mask;\n          pixel.green&=info->mask;\n          pixel.blue&=info->mask;\n          if (info->scale != (Quantum *) NULL)\n            {\n              if (pixel.red <= GetQuantumRange(info->depth))\n                pixel.red=info->scale[pixel.red];\n              if (pixel.green <= GetQuantumRange(info->depth))\n                pixel.green=info->scale[pixel.green];\n              if (pixel.blue <= GetQuantumRange(info->depth))\n                pixel.blue=info->scale[pixel.blue];\n            }\n        }\n      if (first_segment != MagickFalse)\n        {\n          SetPixelRed(q,pixel.red);\n          SetPixelGreen(q,pixel.green);\n          SetPixelBlue(q,pixel.blue);\n        }\n      else\n        {\n          SetPixelRed(q,(((size_t) pixel.red) |\n            (((size_t) GetPixelRed(q)) << 8)));\n          SetPixelGreen(q,(((size_t) pixel.green) |\n            (((size_t) GetPixelGreen(q)) << 8)));\n          SetPixelBlue(q,(((size_t) pixel.blue) |\n            (((size_t) GetPixelBlue(q)) << 8)));\n        }\n      q++;\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  return(status);\n}",
        "func": "static MagickBooleanType ReadDCMPixels(Image *image,DCMInfo *info,\n  DCMStreamInfo *stream_info,MagickBooleanType first_segment,\n  ExceptionInfo *exception)\n{\n  int\n    byte,\n    index;\n\n  MagickBooleanType\n    status;\n\n  LongPixelPacket\n    pixel;\n\n  register ssize_t\n    i,\n    x;\n\n  register IndexPacket\n    *indexes;\n\n  register PixelPacket\n    *q;\n\n  ssize_t\n    y;\n\n  /*\n    Convert DCM Medical image to pixel packets.\n  */\n  byte=0;\n  i=0;\n  status=MagickTrue;\n\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    indexes=GetAuthenticIndexQueue(image);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (info->samples_per_pixel == 1)\n        {\n          int\n            pixel_value;\n\n          if (info->bytes_per_pixel == 1)\n            pixel_value=info->polarity != MagickFalse ? ((int) info->max_value-\n              ReadDCMByte(stream_info,image)) :\n              ReadDCMByte(stream_info,image);\n          else\n            if ((info->bits_allocated != 12) || (info->significant_bits != 12))\n              {\n                if (info->signed_data)\n                  pixel_value=ReadDCMSignedShort(stream_info,image);\n                else\n                  pixel_value=(int) ReadDCMShort(stream_info,image);\n                if (info->polarity != MagickFalse)\n                  pixel_value=(int) info->max_value-pixel_value;\n              }\n            else\n              {\n                if ((i & 0x01) != 0)\n                  pixel_value=(ReadDCMByte(stream_info,image) << 8) |\n                    byte;\n                else\n                  {\n                    pixel_value=ReadDCMSignedShort(stream_info,image);\n                    byte=(int) (pixel_value & 0x0f);\n                    pixel_value>>=4;\n                  }\n                i++;\n              }\n          index=(int) ((pixel_value*info->rescale_slope)+\n            info->rescale_intercept);\n          if (info->window_width == 0)\n            {\n              if (info->signed_data == 1)\n                index-=32767;\n            }\n          else\n            {\n              ssize_t\n                window_max,\n                window_min;\n\n              window_min=(ssize_t) ceil((double) info->window_center-\n                (info->window_width-1.0)/2.0-0.5);\n              window_max=(ssize_t) floor((double) info->window_center+\n                (info->window_width-1.0)/2.0+0.5);\n              if ((ssize_t) index <= window_min)\n                index=0;\n              else\n                if ((ssize_t) index > window_max)\n                  index=(int) info->max_value;\n                else\n                  index=(int) (info->max_value*(((index-info->window_center-\n                    0.5)/(info->window_width-1))+0.5));\n            }\n          index&=info->mask;\n          index=(int) ConstrainColormapIndex(image,(size_t) index);\n          if (first_segment != MagickFalse)\n            SetPixelIndex(indexes+x,index);\n          else\n            SetPixelIndex(indexes+x,(((size_t) index) |\n              (((size_t) GetPixelIndex(indexes+x)) << 8)));\n          pixel.red=1U*image->colormap[index].red;\n          pixel.green=1U*image->colormap[index].green;\n          pixel.blue=1U*image->colormap[index].blue;\n        }\n      else\n        {\n          if (info->bytes_per_pixel == 1)\n            {\n              pixel.red=(unsigned int) ReadDCMByte(stream_info,image);\n              pixel.green=(unsigned int) ReadDCMByte(stream_info,image);\n              pixel.blue=(unsigned int) ReadDCMByte(stream_info,image);\n            }\n          else\n            {\n              pixel.red=ReadDCMShort(stream_info,image);\n              pixel.green=ReadDCMShort(stream_info,image);\n              pixel.blue=ReadDCMShort(stream_info,image);\n            }\n          pixel.red&=info->mask;\n          pixel.green&=info->mask;\n          pixel.blue&=info->mask;\n          if (info->scale != (Quantum *) NULL)\n            {\n              if ((MagickSizeType) pixel.red <= GetQuantumRange(info->depth))\n                pixel.red=info->scale[pixel.red];\n              if ((MagickSizeType) pixel.green <= GetQuantumRange(info->depth))\n                pixel.green=info->scale[pixel.green];\n              if ((MagickSizeType) pixel.blue <= GetQuantumRange(info->depth))\n                pixel.blue=info->scale[pixel.blue];\n            }\n        }\n      if (first_segment != MagickFalse)\n        {\n          SetPixelRed(q,pixel.red);\n          SetPixelGreen(q,pixel.green);\n          SetPixelBlue(q,pixel.blue);\n        }\n      else\n        {\n          SetPixelRed(q,(((size_t) pixel.red) |\n            (((size_t) GetPixelRed(q)) << 8)));\n          SetPixelGreen(q,(((size_t) pixel.green) |\n            (((size_t) GetPixelGreen(q)) << 8)));\n          SetPixelBlue(q,(((size_t) pixel.blue) |\n            (((size_t) GetPixelBlue(q)) << 8)));\n        }\n      q++;\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  return(status);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -55,7 +55,7 @@\n                 if (info->signed_data)\n                   pixel_value=ReadDCMSignedShort(stream_info,image);\n                 else\n-                  pixel_value=ReadDCMShort(stream_info,image);\n+                  pixel_value=(int) ReadDCMShort(stream_info,image);\n                 if (info->polarity != MagickFalse)\n                   pixel_value=(int) info->max_value-pixel_value;\n               }\n@@ -72,7 +72,8 @@\n                   }\n                 i++;\n               }\n-          index=(pixel_value*info->rescale_slope)+info->rescale_intercept;\n+          index=(int) ((pixel_value*info->rescale_slope)+\n+            info->rescale_intercept);\n           if (info->window_width == 0)\n             {\n               if (info->signed_data == 1)\n@@ -127,11 +128,11 @@\n           pixel.blue&=info->mask;\n           if (info->scale != (Quantum *) NULL)\n             {\n-              if (pixel.red <= GetQuantumRange(info->depth))\n+              if ((MagickSizeType) pixel.red <= GetQuantumRange(info->depth))\n                 pixel.red=info->scale[pixel.red];\n-              if (pixel.green <= GetQuantumRange(info->depth))\n+              if ((MagickSizeType) pixel.green <= GetQuantumRange(info->depth))\n                 pixel.green=info->scale[pixel.green];\n-              if (pixel.blue <= GetQuantumRange(info->depth))\n+              if ((MagickSizeType) pixel.blue <= GetQuantumRange(info->depth))\n                 pixel.blue=info->scale[pixel.blue];\n             }\n         }",
        "diff_line_info": {
            "deleted_lines": [
                "                  pixel_value=ReadDCMShort(stream_info,image);",
                "          index=(pixel_value*info->rescale_slope)+info->rescale_intercept;",
                "              if (pixel.red <= GetQuantumRange(info->depth))",
                "              if (pixel.green <= GetQuantumRange(info->depth))",
                "              if (pixel.blue <= GetQuantumRange(info->depth))"
            ],
            "added_lines": [
                "                  pixel_value=(int) ReadDCMShort(stream_info,image);",
                "          index=(int) ((pixel_value*info->rescale_slope)+",
                "            info->rescale_intercept);",
                "              if ((MagickSizeType) pixel.red <= GetQuantumRange(info->depth))",
                "              if ((MagickSizeType) pixel.green <= GetQuantumRange(info->depth))",
                "              if ((MagickSizeType) pixel.blue <= GetQuantumRange(info->depth))"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8347",
        "func_name": "ImageMagick/ReadEXRImage",
        "description": "In ImageMagick 7.0.5-5, the ReadEXRImage function in exr.c allows attackers to cause a denial of service (memory leak) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/48291e72d4d484e69acab1a6b7709c3e10cc525e",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/441",
        "commit_text": "",
        "func_before": "static Image *ReadEXRImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  ExrWindow\n    data_window,\n    display_window;\n\n  const ImfHeader\n    *hdr_info;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  ImfInputFile\n    *file;\n\n  ImfRgba\n    *scanline;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    columns,\n    y;\n\n  /*\n    Open image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  read_info=CloneImageInfo(image_info);\n  if (IsPathAccessible(read_info->filename) == MagickFalse)\n    {\n      (void) AcquireUniqueFilename(read_info->filename);\n      (void) ImageToFile(image,read_info->filename,exception);\n    }\n  file=ImfOpenInputFile(read_info->filename);\n  if (file == (ImfInputFile *) NULL)\n    {\n      ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",\n        ImfErrorMessage());\n      if (LocaleCompare(image_info->filename,read_info->filename) != 0)\n        (void) RelinquishUniqueFileResource(read_info->filename);\n      read_info=DestroyImageInfo(read_info);\n      return((Image *) NULL);\n    }\n  hdr_info=ImfInputHeader(file);\n  ImfHeaderDisplayWindow(hdr_info,&display_window.min_x,&display_window.min_y,\n    &display_window.max_x,&display_window.max_y);\n  image->columns=display_window.max_x-display_window.min_x+1UL;\n  image->rows=display_window.max_y-display_window.min_y+1UL;\n  image->alpha_trait=BlendPixelTrait;\n  SetImageColorspace(image,RGBColorspace,exception);\n  image->gamma=1.0;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) ImfCloseInputFile(file);\n      if (LocaleCompare(image_info->filename,read_info->filename) != 0)\n        (void) RelinquishUniqueFileResource(read_info->filename);\n      read_info=DestroyImageInfo(read_info);\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  ImfHeaderDataWindow(hdr_info,&data_window.min_x,&data_window.min_y,\n    &data_window.max_x,&data_window.max_y);\n  columns=(ssize_t) data_window.max_x-data_window.min_x+1UL;\n  if ((display_window.min_x > data_window.max_x) ||\n      (display_window.min_x+(int) image->columns <= data_window.min_x))\n    scanline=(ImfRgba *) NULL;\n  else\n    {\n      scanline=(ImfRgba *) AcquireQuantumMemory(columns,sizeof(*scanline));\n      if (scanline == (ImfRgba *) NULL)\n        {\n          (void) ImfCloseInputFile(file);\n          if (LocaleCompare(image_info->filename,read_info->filename) != 0)\n            (void) RelinquishUniqueFileResource(read_info->filename);\n          read_info=DestroyImageInfo(read_info);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n    }\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    int\n      yy;\n\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    yy=display_window.min_y+y;\n    if ((yy < data_window.min_y) || (yy > data_window.max_y) ||\n        (scanline == (ImfRgba *) NULL))\n    {\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        SetPixelViaPixelInfo(image,&image->background_color,q);\n        q+=GetPixelChannels(image);\n      }\n      continue;\n    }\n    ResetMagickMemory(scanline,0,columns*sizeof(*scanline));\n    ImfInputSetFrameBuffer(file,scanline-data_window.min_x-columns*yy,1,\n      columns);\n    ImfInputReadPixels(file,yy,yy);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      int\n        xx;\n\n      xx=display_window.min_x+((int) x-data_window.min_x);\n      if ((xx < 0) || (display_window.min_x+(int) x > data_window.max_x))\n        SetPixelViaPixelInfo(image,&image->background_color,q);\n      else\n        {\n          SetPixelRed(image,ClampToQuantum((MagickRealType) QuantumRange*\n            ImfHalfToFloat(scanline[xx].r)),q);\n          SetPixelGreen(image,ClampToQuantum((MagickRealType) QuantumRange*\n            ImfHalfToFloat(scanline[xx].g)),q);\n          SetPixelBlue(image,ClampToQuantum((MagickRealType) QuantumRange*\n            ImfHalfToFloat(scanline[xx].b)),q);\n          SetPixelAlpha(image,ClampToQuantum((MagickRealType) QuantumRange*\n            ImfHalfToFloat(scanline[xx].a)),q);\n        }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n  scanline=(ImfRgba *) RelinquishMagickMemory(scanline);\n  (void) ImfCloseInputFile(file);\n  if (LocaleCompare(image_info->filename,read_info->filename) != 0)\n    (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadEXRImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  ExrWindow\n    data_window,\n    display_window;\n\n  const ImfHeader\n    *hdr_info;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  ImfInputFile\n    *file;\n\n  ImfRgba\n    *scanline;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    columns,\n    y;\n\n  /*\n    Open image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  read_info=CloneImageInfo(image_info);\n  if (IsPathAccessible(read_info->filename) == MagickFalse)\n    {\n      (void) AcquireUniqueFilename(read_info->filename);\n      (void) ImageToFile(image,read_info->filename,exception);\n    }\n  file=ImfOpenInputFile(read_info->filename);\n  if (file == (ImfInputFile *) NULL)\n    {\n      ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",\n        ImfErrorMessage());\n      if (LocaleCompare(image_info->filename,read_info->filename) != 0)\n        (void) RelinquishUniqueFileResource(read_info->filename);\n      read_info=DestroyImageInfo(read_info);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  hdr_info=ImfInputHeader(file);\n  ImfHeaderDisplayWindow(hdr_info,&display_window.min_x,&display_window.min_y,\n    &display_window.max_x,&display_window.max_y);\n  image->columns=display_window.max_x-display_window.min_x+1UL;\n  image->rows=display_window.max_y-display_window.min_y+1UL;\n  image->alpha_trait=BlendPixelTrait;\n  SetImageColorspace(image,RGBColorspace,exception);\n  image->gamma=1.0;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) ImfCloseInputFile(file);\n      if (LocaleCompare(image_info->filename,read_info->filename) != 0)\n        (void) RelinquishUniqueFileResource(read_info->filename);\n      read_info=DestroyImageInfo(read_info);\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  ImfHeaderDataWindow(hdr_info,&data_window.min_x,&data_window.min_y,\n    &data_window.max_x,&data_window.max_y);\n  columns=(ssize_t) data_window.max_x-data_window.min_x+1UL;\n  if ((display_window.min_x > data_window.max_x) ||\n      (display_window.min_x+(int) image->columns <= data_window.min_x))\n    scanline=(ImfRgba *) NULL;\n  else\n    {\n      scanline=(ImfRgba *) AcquireQuantumMemory(columns,sizeof(*scanline));\n      if (scanline == (ImfRgba *) NULL)\n        {\n          (void) ImfCloseInputFile(file);\n          if (LocaleCompare(image_info->filename,read_info->filename) != 0)\n            (void) RelinquishUniqueFileResource(read_info->filename);\n          read_info=DestroyImageInfo(read_info);\n          image=DestroyImageList(image);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n    }\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    int\n      yy;\n\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    yy=display_window.min_y+y;\n    if ((yy < data_window.min_y) || (yy > data_window.max_y) ||\n        (scanline == (ImfRgba *) NULL))\n      {\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          SetPixelViaPixelInfo(image,&image->background_color,q);\n          q+=GetPixelChannels(image);\n        }\n        continue;\n      }\n    ResetMagickMemory(scanline,0,columns*sizeof(*scanline));\n    ImfInputSetFrameBuffer(file,scanline-data_window.min_x-columns*yy,1,\n      columns);\n    ImfInputReadPixels(file,yy,yy);\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      int\n        xx;\n\n      xx=display_window.min_x+((int) x-data_window.min_x);\n      if ((xx < 0) || (display_window.min_x+(int) x > data_window.max_x))\n        SetPixelViaPixelInfo(image,&image->background_color,q);\n      else\n        {\n          SetPixelRed(image,ClampToQuantum((MagickRealType) QuantumRange*\n            ImfHalfToFloat(scanline[xx].r)),q);\n          SetPixelGreen(image,ClampToQuantum((MagickRealType) QuantumRange*\n            ImfHalfToFloat(scanline[xx].g)),q);\n          SetPixelBlue(image,ClampToQuantum((MagickRealType) QuantumRange*\n            ImfHalfToFloat(scanline[xx].b)),q);\n          SetPixelAlpha(image,ClampToQuantum((MagickRealType) QuantumRange*\n            ImfHalfToFloat(scanline[xx].a)),q);\n        }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n  scanline=(ImfRgba *) RelinquishMagickMemory(scanline);\n  (void) ImfCloseInputFile(file);\n  if (LocaleCompare(image_info->filename,read_info->filename) != 0)\n    (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -63,6 +63,7 @@\n       if (LocaleCompare(image_info->filename,read_info->filename) != 0)\n         (void) RelinquishUniqueFileResource(read_info->filename);\n       read_info=DestroyImageInfo(read_info);\n+      image=DestroyImageList(image);\n       return((Image *) NULL);\n     }\n   hdr_info=ImfInputHeader(file);\n@@ -100,6 +101,7 @@\n           if (LocaleCompare(image_info->filename,read_info->filename) != 0)\n             (void) RelinquishUniqueFileResource(read_info->filename);\n           read_info=DestroyImageInfo(read_info);\n+          image=DestroyImageList(image);\n           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n         }\n     }\n@@ -114,14 +116,14 @@\n     yy=display_window.min_y+y;\n     if ((yy < data_window.min_y) || (yy > data_window.max_y) ||\n         (scanline == (ImfRgba *) NULL))\n-    {\n-      for (x=0; x < (ssize_t) image->columns; x++)\n       {\n-        SetPixelViaPixelInfo(image,&image->background_color,q);\n-        q+=GetPixelChannels(image);\n+        for (x=0; x < (ssize_t) image->columns; x++)\n+        {\n+          SetPixelViaPixelInfo(image,&image->background_color,q);\n+          q+=GetPixelChannels(image);\n+        }\n+        continue;\n       }\n-      continue;\n-    }\n     ResetMagickMemory(scanline,0,columns*sizeof(*scanline));\n     ImfInputSetFrameBuffer(file,scanline-data_window.min_x-columns*yy,1,\n       columns);",
        "diff_line_info": {
            "deleted_lines": [
                "    {",
                "      for (x=0; x < (ssize_t) image->columns; x++)",
                "        SetPixelViaPixelInfo(image,&image->background_color,q);",
                "        q+=GetPixelChannels(image);",
                "      continue;",
                "    }"
            ],
            "added_lines": [
                "      image=DestroyImageList(image);",
                "          image=DestroyImageList(image);",
                "        for (x=0; x < (ssize_t) image->columns; x++)",
                "        {",
                "          SetPixelViaPixelInfo(image,&image->background_color,q);",
                "          q+=GetPixelChannels(image);",
                "        }",
                "        continue;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8348",
        "func_name": "ImageMagick/ReadMATImage",
        "description": "In ImageMagick 7.0.5-5, the ReadMATImage function in mat.c allows attackers to cause a denial of service (memory leak) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/0c60e6ead120fe2036ceb87662de91d52a4ec4aa",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/445",
        "commit_text": "",
        "func_before": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=CloneImageInfo(image_info);\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\nMATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\n    quantum_info=DestroyQuantumInfo(quantum_info);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\nEND_OF_READING:\n  clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}",
        "func": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=CloneImageInfo(image_info);\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\nMATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -344,7 +344,6 @@\n   }\n       }\n     } while(z-- >= 2);\n-    quantum_info=DestroyQuantumInfo(quantum_info);\n ExitLoop:\n \n \n@@ -453,6 +452,7 @@\n   }\n \n   RelinquishMagickMemory(BImgBuff);\n+  quantum_info=DestroyQuantumInfo(quantum_info);\n END_OF_READING:\n   clone_info=DestroyImageInfo(clone_info);\n   CloseBlob(image);",
        "diff_line_info": {
            "deleted_lines": [
                "    quantum_info=DestroyQuantumInfo(quantum_info);"
            ],
            "added_lines": [
                "  quantum_info=DestroyQuantumInfo(quantum_info);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8349",
        "func_name": "ImageMagick/ReadSFWImage",
        "description": "In ImageMagick 7.0.5-5, the ReadSFWImage function in sfw.c allows attackers to cause a denial of service (memory leak) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/5b1b7895bb5c75596942e5c642ea44b0dd13ddec",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/443",
        "commit_text": "",
        "func_before": "static Image *ReadSFWImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  static unsigned char\n    HuffmanTable[] =\n    {\n      0xFF, 0xC4, 0x01, 0xA2, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01, 0x01,\n      0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,\n      0x01, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n      0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04,\n      0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x10, 0x00, 0x02, 0x01,\n      0x03, 0x03, 0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00,\n      0x01, 0x7D, 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21,\n      0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32,\n      0x81, 0x91, 0xA1, 0x08, 0x23, 0x42, 0xB1, 0xC1, 0x15, 0x52, 0xD1,\n      0xF0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0A, 0x16, 0x17, 0x18,\n      0x19, 0x1A, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x34, 0x35, 0x36,\n      0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,\n      0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x63, 0x64,\n      0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77,\n      0x78, 0x79, 0x7A, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A,\n      0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3,\n      0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5,\n      0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,\n      0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9,\n      0xDA, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA,\n      0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0x11,\n      0x00, 0x02, 0x01, 0x02, 0x04, 0x04, 0x03, 0x04, 0x07, 0x05, 0x04,\n      0x04, 0x00, 0x01, 0x02, 0x77, 0x00, 0x01, 0x02, 0x03, 0x11, 0x04,\n      0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13,\n      0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xA1, 0xB1, 0xC1, 0x09,\n      0x23, 0x33, 0x52, 0xF0, 0x15, 0x62, 0x72, 0xD1, 0x0A, 0x16, 0x24,\n      0x34, 0xE1, 0x25, 0xF1, 0x17, 0x18, 0x19, 0x1A, 0x26, 0x27, 0x28,\n      0x29, 0x2A, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45,\n      0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,\n      0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x73,\n      0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x82, 0x83, 0x84, 0x85,\n      0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n      0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9,\n      0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2,\n      0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4,\n      0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6,\n      0xE7, 0xE8, 0xE9, 0xEA, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8,\n      0xF9, 0xFA\n    };\n\n  FILE\n    *file;\n\n  Image\n    *flipped_image,\n    *jpeg_image,\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register unsigned char\n    *header,\n    *data;\n\n  size_t\n    extent;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *buffer,\n    *offset;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read image into a buffer.\n  */\n  if (GetBlobSize(image) != (size_t) GetBlobSize(image))\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  buffer=(unsigned char *) AcquireQuantumMemory((size_t) GetBlobSize(image),\n    sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  count=ReadBlob(image,(size_t) GetBlobSize(image),buffer);\n  if ((count != (ssize_t) GetBlobSize(image)) ||\n      (LocaleNCompare((char *) buffer,\"SFW\",3) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  (void) CloseBlob(image);\n  /*\n    Find the start of the JFIF data\n  */\n  header=SFWScan(buffer,buffer+count-1,(const unsigned char *)\n    \"\\377\\310\\377\\320\",4);\n  if (header == (unsigned char *) NULL)\n    {\n      buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  TranslateSFWMarker(header);  /* translate soi and app tags */\n  TranslateSFWMarker(header+2);\n  (void) CopyMagickMemory(header+6,\"JFIF\\0\\001\\0\",7);  /* JFIF magic */\n  /*\n    Translate remaining markers.\n  */\n  offset=header+2;\n  offset+=(((unsigned int) offset[2]) << 8)+offset[3]+2;\n  for ( ; ; )\n  {\n    if ((offset+4) > (buffer+count-1))\n      {\n        buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    TranslateSFWMarker(offset);\n    if (offset[1] == 0xda)\n      break;\n    offset+=(((unsigned int) offset[2]) << 8)+offset[3]+2;\n  }\n  offset--;\n  data=SFWScan(offset,buffer+count-1,(const unsigned char *) \"\\377\\311\",2);\n  if (data == (unsigned char *) NULL)\n    {\n      buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  TranslateSFWMarker(data++);  /* translate eoi marker */\n  /*\n    Write JFIF file.\n  */\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(read_info->filename);\n  if (unique_file != -1)\n    file=fopen_utf8(read_info->filename,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n      read_info=DestroyImageInfo(read_info);\n      (void) CopyMagickString(image->filename,read_info->filename,\n        MagickPathExtent);\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  extent=fwrite(header,(size_t) (offset-header+1),1,file);\n  (void) extent;\n  extent=fwrite(HuffmanTable,1,sizeof(HuffmanTable)/sizeof(*HuffmanTable),file);\n  extent=fwrite(offset+1,(size_t) (data-offset),1,file);\n  status=ferror(file) != 0 ? MagickFalse : MagickTrue;\n  (void) fclose(file);\n  (void) close(unique_file);\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  if (status == MagickFalse)\n    {\n      char\n        *message;\n\n      (void) remove_utf8(read_info->filename);\n      read_info=DestroyImageInfo(read_info);\n      message=GetExceptionMessage(errno);\n      (void) ThrowMagickException(exception,GetMagickModule(),FileOpenError,\n        \"UnableToWriteFile\",\"`%s': %s\",image->filename,message);\n      message=DestroyString(message);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read JPEG image.\n  */\n  jpeg_image=ReadImage(read_info,exception);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (jpeg_image == (Image *) NULL)\n    {\n      image=DestroyImageList(image);\n      return(jpeg_image);\n    }\n  (void) CopyMagickString(jpeg_image->filename,image->filename,MagickPathExtent);\n  (void) CopyMagickString(jpeg_image->magick,image->magick,MagickPathExtent);\n  image=DestroyImageList(image);\n  image=jpeg_image;\n  /*\n    Correct image orientation.\n  */\n  flipped_image=FlipImage(image,exception);\n  if (flipped_image != (Image *) NULL)\n    {\n      DuplicateBlob(flipped_image,image);\n      image=DestroyImage(image);\n      image=flipped_image;\n    }\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadSFWImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  static unsigned char\n    HuffmanTable[] =\n    {\n      0xFF, 0xC4, 0x01, 0xA2, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01, 0x01,\n      0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,\n      0x01, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n      0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04,\n      0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x10, 0x00, 0x02, 0x01,\n      0x03, 0x03, 0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00,\n      0x01, 0x7D, 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21,\n      0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32,\n      0x81, 0x91, 0xA1, 0x08, 0x23, 0x42, 0xB1, 0xC1, 0x15, 0x52, 0xD1,\n      0xF0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0A, 0x16, 0x17, 0x18,\n      0x19, 0x1A, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x34, 0x35, 0x36,\n      0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,\n      0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x63, 0x64,\n      0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77,\n      0x78, 0x79, 0x7A, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A,\n      0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3,\n      0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5,\n      0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,\n      0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9,\n      0xDA, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA,\n      0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0x11,\n      0x00, 0x02, 0x01, 0x02, 0x04, 0x04, 0x03, 0x04, 0x07, 0x05, 0x04,\n      0x04, 0x00, 0x01, 0x02, 0x77, 0x00, 0x01, 0x02, 0x03, 0x11, 0x04,\n      0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13,\n      0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xA1, 0xB1, 0xC1, 0x09,\n      0x23, 0x33, 0x52, 0xF0, 0x15, 0x62, 0x72, 0xD1, 0x0A, 0x16, 0x24,\n      0x34, 0xE1, 0x25, 0xF1, 0x17, 0x18, 0x19, 0x1A, 0x26, 0x27, 0x28,\n      0x29, 0x2A, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45,\n      0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,\n      0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x73,\n      0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x82, 0x83, 0x84, 0x85,\n      0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,\n      0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9,\n      0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2,\n      0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4,\n      0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6,\n      0xE7, 0xE8, 0xE9, 0xEA, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8,\n      0xF9, 0xFA\n    };\n\n  FILE\n    *file;\n\n  Image\n    *flipped_image,\n    *jpeg_image,\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register unsigned char\n    *header,\n    *data;\n\n  size_t\n    extent;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *buffer,\n    *offset;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read image into a buffer.\n  */\n  if (GetBlobSize(image) != (size_t) GetBlobSize(image))\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  buffer=(unsigned char *) AcquireQuantumMemory((size_t) GetBlobSize(image),\n    sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  count=ReadBlob(image,(size_t) GetBlobSize(image),buffer);\n  if ((count != (ssize_t) GetBlobSize(image)) ||\n      (LocaleNCompare((char *) buffer,\"SFW\",3) != 0))\n    {\n      buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  (void) CloseBlob(image);\n  /*\n    Find the start of the JFIF data\n  */\n  header=SFWScan(buffer,buffer+count-1,(const unsigned char *)\n    \"\\377\\310\\377\\320\",4);\n  if (header == (unsigned char *) NULL)\n    {\n      buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  TranslateSFWMarker(header);  /* translate soi and app tags */\n  TranslateSFWMarker(header+2);\n  (void) CopyMagickMemory(header+6,\"JFIF\\0\\001\\0\",7);  /* JFIF magic */\n  /*\n    Translate remaining markers.\n  */\n  offset=header+2;\n  offset+=(((unsigned int) offset[2]) << 8)+offset[3]+2;\n  for ( ; ; )\n  {\n    if ((offset+4) > (buffer+count-1))\n      {\n        buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    TranslateSFWMarker(offset);\n    if (offset[1] == 0xda)\n      break;\n    offset+=(((unsigned int) offset[2]) << 8)+offset[3]+2;\n  }\n  offset--;\n  data=SFWScan(offset,buffer+count-1,(const unsigned char *) \"\\377\\311\",2);\n  if (data == (unsigned char *) NULL)\n    {\n      buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  TranslateSFWMarker(data++);  /* translate eoi marker */\n  /*\n    Write JFIF file.\n  */\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(read_info->filename);\n  if (unique_file != -1)\n    file=fopen_utf8(read_info->filename,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n      read_info=DestroyImageInfo(read_info);\n      (void) CopyMagickString(image->filename,read_info->filename,\n        MagickPathExtent);\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  extent=fwrite(header,(size_t) (offset-header+1),1,file);\n  (void) extent;\n  extent=fwrite(HuffmanTable,1,sizeof(HuffmanTable)/sizeof(*HuffmanTable),file);\n  extent=fwrite(offset+1,(size_t) (data-offset),1,file);\n  status=ferror(file) != 0 ? MagickFalse : MagickTrue;\n  (void) fclose(file);\n  (void) close(unique_file);\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  if (status == MagickFalse)\n    {\n      char\n        *message;\n\n      (void) remove_utf8(read_info->filename);\n      read_info=DestroyImageInfo(read_info);\n      message=GetExceptionMessage(errno);\n      (void) ThrowMagickException(exception,GetMagickModule(),FileOpenError,\n        \"UnableToWriteFile\",\"`%s': %s\",image->filename,message);\n      message=DestroyString(message);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read JPEG image.\n  */\n  jpeg_image=ReadImage(read_info,exception);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (jpeg_image == (Image *) NULL)\n    {\n      image=DestroyImageList(image);\n      return(jpeg_image);\n    }\n  (void) CopyMagickString(jpeg_image->filename,image->filename,MagickPathExtent);\n  (void) CopyMagickString(jpeg_image->magick,image->magick,MagickPathExtent);\n  image=DestroyImageList(image);\n  image=jpeg_image;\n  /*\n    Correct image orientation.\n  */\n  flipped_image=FlipImage(image,exception);\n  if (flipped_image != (Image *) NULL)\n    {\n      DuplicateBlob(flipped_image,image);\n      image=DestroyImage(image);\n      image=flipped_image;\n    }\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -104,7 +104,10 @@\n   count=ReadBlob(image,(size_t) GetBlobSize(image),buffer);\n   if ((count != (ssize_t) GetBlobSize(image)) ||\n       (LocaleNCompare((char *) buffer,\"SFW\",3) != 0))\n-    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+    {\n+      buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n+      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+    }\n   (void) CloseBlob(image);\n   /*\n     Find the start of the JFIF data",
        "diff_line_info": {
            "deleted_lines": [
                "    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");"
            ],
            "added_lines": [
                "    {",
                "      buffer=(unsigned char *) RelinquishMagickMemory(buffer);",
                "      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8350",
        "func_name": "ImageMagick/ReadOneJNGImage",
        "description": "In ImageMagick 7.0.5-5, the ReadJNGImage function in png.c allows attackers to cause a denial of service (memory leak) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/7a8d04796a94852c72fd90441a0805c27f1b3210",
        "commit_title": "Fixed various leaks in ReadOneJNGImage reported in #447",
        "commit_text": "",
        "func_before": "static Image *ReadOneJNGImage(MngInfo *mng_info,\n    const ImageInfo *image_info, ExceptionInfo *exception)\n{\n  Image\n    *alpha_image,\n    *color_image,\n    *image,\n    *jng_image;\n\n  ImageInfo\n    *alpha_image_info,\n    *color_image_info;\n\n  MagickBooleanType\n    logging;\n\n  int\n    unique_filenames;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    status;\n\n  png_uint_32\n    jng_height,\n    jng_width;\n\n  png_byte\n    jng_color_type,\n    jng_image_sample_depth,\n    jng_image_compression_method,\n    jng_image_interlace_method,\n    jng_alpha_sample_depth,\n    jng_alpha_compression_method,\n    jng_alpha_filter_method,\n    jng_alpha_interlace_method;\n\n  register const PixelPacket\n    *s;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *p;\n\n  unsigned int\n    read_JSEP,\n    reading_idat;\n\n  size_t\n    length;\n\n  jng_alpha_compression_method=0;\n  jng_alpha_sample_depth=8;\n  jng_color_type=0;\n  jng_height=0;\n  jng_width=0;\n  alpha_image=(Image *) NULL;\n  color_image=(Image *) NULL;\n  alpha_image_info=(ImageInfo *) NULL;\n  color_image_info=(ImageInfo *) NULL;\n  unique_filenames=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneJNGImage()\");\n\n  image=mng_info->image;\n\n  if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n    {\n      /*\n        Allocate next image structure.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  AcquireNextImage()\");\n\n      AcquireNextImage(image_info,image);\n\n      if (GetNextImageInList(image) == (Image *) NULL)\n        return((Image *) NULL);\n\n      image=SyncNextImageInList(image);\n    }\n  mng_info->image=image;\n\n  /*\n    Signature bytes have already been read.\n  */\n\n  read_JSEP=MagickFalse;\n  reading_idat=MagickFalse;\n  for (;;)\n  {\n    char\n      type[MaxTextExtent];\n\n    unsigned char\n      *chunk;\n\n    unsigned int\n      count;\n\n    /*\n      Read a new JNG chunk.\n    */\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      2*GetBlobSize(image));\n\n    if (status == MagickFalse)\n      break;\n\n    type[0]='\\0';\n    (void) ConcatenateMagickString(type,\"errr\",MaxTextExtent);\n    length=ReadBlobMSBLong(image);\n    count=(unsigned int) ReadBlob(image,4,(unsigned char *) type);\n\n    if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Reading JNG chunk type %c%c%c%c, length: %.20g\",\n        type[0],type[1],type[2],type[3],(double) length);\n\n    if (length > PNG_UINT_31_MAX || count == 0)\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n\n    p=NULL;\n    chunk=(unsigned char *) NULL;\n\n    if (length != 0)\n      {\n        chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));\n\n        if (chunk == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        for (i=0; i < (ssize_t) length; i++)\n          chunk[i]=(unsigned char) ReadBlobByte(image);\n\n        p=chunk;\n      }\n\n    (void) ReadBlobMSBLong(image);  /* read crc word */\n\n    if (memcmp(type,mng_JHDR,4) == 0)\n      {\n        if (length == 16)\n          {\n            jng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n              (p[2] << 8) | p[3]);\n            jng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n              (p[6] << 8) | p[7]);\n            if ((jng_width == 0) || (jng_height == 0))\n              ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n            jng_color_type=p[8];\n            jng_image_sample_depth=p[9];\n            jng_image_compression_method=p[10];\n            jng_image_interlace_method=p[11];\n\n            image->interlace=jng_image_interlace_method != 0 ? PNGInterlace :\n              NoInterlace;\n\n            jng_alpha_sample_depth=p[12];\n            jng_alpha_compression_method=p[13];\n            jng_alpha_filter_method=p[14];\n            jng_alpha_interlace_method=p[15];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_width:      %16lu,    jng_height:     %16lu\\n\"\n                  \"    jng_color_type: %16d,     jng_image_sample_depth: %3d\\n\"\n                  \"    jng_image_compression_method:%3d\",\n                  (unsigned long) jng_width, (unsigned long) jng_height,\n                  jng_color_type, jng_image_sample_depth,\n                  jng_image_compression_method);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_image_interlace_method:  %3d\"\n                  \"    jng_alpha_sample_depth:      %3d\",\n                  jng_image_interlace_method,\n                  jng_alpha_sample_depth);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_alpha_compression_method:%3d\\n\"\n                  \"    jng_alpha_filter_method:     %3d\\n\"\n                  \"    jng_alpha_interlace_method:  %3d\",\n                  jng_alpha_compression_method,\n                  jng_alpha_filter_method,\n                  jng_alpha_interlace_method);\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n\n    if ((reading_idat == MagickFalse) && (read_JSEP == MagickFalse) &&\n        ((memcmp(type,mng_JDAT,4) == 0) || (memcmp(type,mng_JdAA,4) == 0) ||\n         (memcmp(type,mng_IDAT,4) == 0) || (memcmp(type,mng_JDAA,4) == 0)))\n      {\n        /*\n           o create color_image\n           o open color_blob, attached to color_image\n           o if (color type has alpha)\n               open alpha_blob, attached to alpha_image\n        */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Creating color_blob.\");\n\n        color_image_info=(ImageInfo *)AcquireMagickMemory(sizeof(ImageInfo));\n\n        if (color_image_info == (ImageInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        GetImageInfo(color_image_info);\n        color_image=AcquireImage(color_image_info);\n\n        if (color_image == (Image *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        (void) AcquireUniqueFilename(color_image->filename);\n        unique_filenames++;\n        status=OpenBlob(color_image_info,color_image,WriteBinaryBlobMode,\n          exception);\n\n        if (status == MagickFalse)\n          return((Image *) NULL);\n\n        if ((image_info->ping == MagickFalse) && (jng_color_type >= 12))\n          {\n            alpha_image_info=(ImageInfo *)\n              AcquireMagickMemory(sizeof(ImageInfo));\n\n            if (alpha_image_info == (ImageInfo *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n            GetImageInfo(alpha_image_info);\n            alpha_image=AcquireImage(alpha_image_info);\n\n            if (alpha_image == (Image *) NULL)\n              {\n                alpha_image=DestroyImage(alpha_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Creating alpha_blob.\");\n\n            (void) AcquireUniqueFilename(alpha_image->filename);\n            unique_filenames++;\n            status=OpenBlob(alpha_image_info,alpha_image,WriteBinaryBlobMode,\n              exception);\n\n            if (status == MagickFalse)\n              return((Image *) NULL);\n\n            if (jng_alpha_compression_method == 0)\n              {\n                unsigned char\n                  data[18];\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Writing IHDR chunk to alpha_blob.\");\n\n                (void) WriteBlob(alpha_image,8,(const unsigned char *)\n                  \"\\211PNG\\r\\n\\032\\n\");\n\n                (void) WriteBlobMSBULong(alpha_image,13L);\n                PNGType(data,mng_IHDR);\n                LogPNGChunk(logging,mng_IHDR,13L);\n                PNGLong(data+4,jng_width);\n                PNGLong(data+8,jng_height);\n                data[12]=jng_alpha_sample_depth;\n                data[13]=0; /* color_type gray */\n                data[14]=0; /* compression method 0 */\n                data[15]=0; /* filter_method 0 */\n                data[16]=0; /* interlace_method 0 */\n                (void) WriteBlob(alpha_image,17,data);\n                (void) WriteBlobMSBULong(alpha_image,crc32(0,data,17));\n              }\n          }\n        reading_idat=MagickTrue;\n      }\n\n    if (memcmp(type,mng_JDAT,4) == 0)\n      {\n        /* Copy chunk to color_image->blob */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Copying JDAT chunk data to color_blob.\");\n\n        (void) WriteBlob(color_image,length,chunk);\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_IDAT,4) == 0)\n      {\n        png_byte\n           data[5];\n\n        /* Copy IDAT header and chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying IDAT chunk data to alpha_blob.\");\n\n            (void) WriteBlobMSBULong(alpha_image,(size_t) length);\n            PNGType(data,mng_IDAT);\n            LogPNGChunk(logging,mng_IDAT,length);\n            (void) WriteBlob(alpha_image,4,data);\n            (void) WriteBlob(alpha_image,length,chunk);\n            (void) WriteBlobMSBULong(alpha_image,\n              crc32(crc32(0,data,4),chunk,(uInt) length));\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if ((memcmp(type,mng_JDAA,4) == 0) || (memcmp(type,mng_JdAA,4) == 0))\n      {\n        /* Copy chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying JDAA chunk data to alpha_blob.\");\n\n            (void) WriteBlob(alpha_image,length,chunk);\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_JSEP,4) == 0)\n      {\n        read_JSEP=MagickTrue;\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_bKGD,4) == 0)\n      {\n        if (length == 2)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=image->background_color.red;\n            image->background_color.blue=image->background_color.red;\n          }\n\n        if (length == 6)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=ScaleCharToQuantum(p[3]);\n            image->background_color.blue=ScaleCharToQuantum(p[5]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_gAMA,4) == 0)\n      {\n        if (length == 4)\n          image->gamma=((float) mng_get_long(p))*0.00001;\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_cHRM,4) == 0)\n      {\n        if (length == 32)\n          {\n            image->chromaticity.white_point.x=0.00001*mng_get_long(p);\n            image->chromaticity.white_point.y=0.00001*mng_get_long(&p[4]);\n            image->chromaticity.red_primary.x=0.00001*mng_get_long(&p[8]);\n            image->chromaticity.red_primary.y=0.00001*mng_get_long(&p[12]);\n            image->chromaticity.green_primary.x=0.00001*mng_get_long(&p[16]);\n            image->chromaticity.green_primary.y=0.00001*mng_get_long(&p[20]);\n            image->chromaticity.blue_primary.x=0.00001*mng_get_long(&p[24]);\n            image->chromaticity.blue_primary.y=0.00001*mng_get_long(&p[28]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_sRGB,4) == 0)\n      {\n        if (length == 1)\n          {\n            image->rendering_intent=\n              Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n            image->gamma=1.000f/2.200f;\n            image->chromaticity.red_primary.x=0.6400f;\n            image->chromaticity.red_primary.y=0.3300f;\n            image->chromaticity.green_primary.x=0.3000f;\n            image->chromaticity.green_primary.y=0.6000f;\n            image->chromaticity.blue_primary.x=0.1500f;\n            image->chromaticity.blue_primary.y=0.0600f;\n            image->chromaticity.white_point.x=0.3127f;\n            image->chromaticity.white_point.y=0.3290f;\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_oFFs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->page.x=(ssize_t) mng_get_long(p);\n            image->page.y=(ssize_t) mng_get_long(&p[4]);\n\n            if ((int) p[8] != 0)\n              {\n                image->page.x/=10000;\n                image->page.y/=10000;\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_pHYs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->x_resolution=(double) mng_get_long(p);\n            image->y_resolution=(double) mng_get_long(&p[4]);\n            if ((int) p[8] == PNG_RESOLUTION_METER)\n              {\n                image->units=PixelsPerCentimeterResolution;\n                image->x_resolution=image->x_resolution/100.0f;\n                image->y_resolution=image->y_resolution/100.0f;\n              }\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n#if 0\n    if (memcmp(type,mng_iCCP,4) == 0)\n      {\n        /* To do: */\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n#endif\n\n    if (length != 0)\n      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n    if (memcmp(type,mng_IEND,4))\n      continue;\n\n    break;\n  }\n\n\n  /* IEND found */\n\n  /*\n    Finish up reading image data:\n\n       o read main image from color_blob.\n\n       o close color_blob.\n\n       o if (color_type has alpha)\n            if alpha_encoding is PNG\n               read secondary image from alpha_blob via ReadPNG\n            if alpha_encoding is JPEG\n               read secondary image from alpha_blob via ReadJPEG\n\n       o close alpha_blob.\n\n       o copy intensity of secondary image into\n         opacity samples of main image.\n\n       o destroy the secondary image.\n  */\n\n  if (color_image_info == (ImageInfo *) NULL)\n    {\n      assert(color_image == (Image *) NULL);\n      assert(alpha_image == (Image *) NULL);\n      return((Image *) NULL);\n    }\n\n  if (color_image == (Image *) NULL)\n    {\n      assert(alpha_image == (Image *) NULL);\n      return((Image *) NULL);\n    }\n\n  (void) SeekBlob(color_image,0,SEEK_SET);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Reading jng_image from color_blob.\");\n\n  assert(color_image_info != (ImageInfo *) NULL);\n  (void) FormatLocaleString(color_image_info->filename,MaxTextExtent,\"%s\",\n    color_image->filename);\n\n  color_image_info->ping=MagickFalse;   /* To do: avoid this */\n  jng_image=ReadImage(color_image_info,exception);\n\n  (void) RelinquishUniqueFileResource(color_image->filename);\n  unique_filenames--;\n  color_image=DestroyImage(color_image);\n  color_image_info=DestroyImageInfo(color_image_info);\n\n  if (jng_image == (Image *) NULL)\n    return((Image *) NULL);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Copying jng_image pixels to main image.\");\n  image->columns=jng_width;\n  image->rows=jng_height;\n  length=image->columns*sizeof(PixelPacket);\n\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    s=GetVirtualPixels(jng_image,0,y,image->columns,1,&image->exception);\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    (void) CopyMagickMemory(q,s,length);\n\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n\n  jng_image=DestroyImage(jng_image);\n\n  if (image_info->ping == MagickFalse)\n    {\n     if (jng_color_type >= 12)\n       {\n         if (jng_alpha_compression_method == 0)\n           {\n             png_byte\n               data[5];\n             (void) WriteBlobMSBULong(alpha_image,0x00000000L);\n             PNGType(data,mng_IEND);\n             LogPNGChunk(logging,mng_IEND,0L);\n             (void) WriteBlob(alpha_image,4,data);\n             (void) WriteBlobMSBULong(alpha_image,crc32(0,data,4));\n           }\n\n         (void) SeekBlob(alpha_image,0,SEEK_SET);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"    Reading opacity from alpha_blob.\");\n\n         (void) FormatLocaleString(alpha_image_info->filename,MaxTextExtent,\n           \"%s\",alpha_image->filename);\n\n         jng_image=ReadImage(alpha_image_info,exception);\n\n         if (jng_image != (Image *) NULL)\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             s=GetVirtualPixels(jng_image,0,y,image->columns,1,\n                &image->exception);\n             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (image->matte != MagickFalse)\n               for (x=(ssize_t) image->columns; x != 0; x--,q++,s++)\n                  SetPixelOpacity(q,QuantumRange-\n                      GetPixelRed(s));\n\n             else\n               for (x=(ssize_t) image->columns; x != 0; x--,q++,s++)\n               {\n                  SetPixelAlpha(q,GetPixelRed(s));\n                  if (GetPixelOpacity(q) != OpaqueOpacity)\n                    image->matte=MagickTrue;\n               }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n           }\n         (void) RelinquishUniqueFileResource(alpha_image->filename);\n         unique_filenames--;\n         alpha_image=DestroyImage(alpha_image);\n         alpha_image_info=DestroyImageInfo(alpha_image_info);\n         if (jng_image != (Image *) NULL)\n           jng_image=DestroyImage(jng_image);\n       }\n    }\n\n  /* Read the JNG image.  */\n\n  if (mng_info->mng_type == 0)\n    {\n      mng_info->mng_width=jng_width;\n      mng_info->mng_height=jng_height;\n    }\n\n  if (image->page.width == 0 && image->page.height == 0)\n    {\n      image->page.width=jng_width;\n      image->page.height=jng_height;\n    }\n\n  if (image->page.x == 0 && image->page.y == 0)\n    {\n      image->page.x=mng_info->x_off[mng_info->object_id];\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  else\n    {\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  mng_info->image_found++;\n  status=SetImageProgress(image,LoadImagesTag,2*TellBlob(image),\n    2*GetBlobSize(image));\n\n  if (status == MagickFalse)\n    return((Image *) NULL);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneJNGImage(); unique_filenames=%d\",unique_filenames);\n\n  return(image);\n}",
        "func": "static Image *ReadOneJNGImage(MngInfo *mng_info,\n    const ImageInfo *image_info, ExceptionInfo *exception)\n{\n  Image\n    *alpha_image,\n    *color_image,\n    *image,\n    *jng_image;\n\n  ImageInfo\n    *alpha_image_info,\n    *color_image_info;\n\n  MagickBooleanType\n    logging;\n\n  int\n    unique_filenames;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    status;\n\n  png_uint_32\n    jng_height,\n    jng_width;\n\n  png_byte\n    jng_color_type,\n    jng_image_sample_depth,\n    jng_image_compression_method,\n    jng_image_interlace_method,\n    jng_alpha_sample_depth,\n    jng_alpha_compression_method,\n    jng_alpha_filter_method,\n    jng_alpha_interlace_method;\n\n  register const PixelPacket\n    *s;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *p;\n\n  unsigned int\n    read_JSEP,\n    reading_idat;\n\n  size_t\n    length;\n\n  jng_alpha_compression_method=0;\n  jng_alpha_sample_depth=8;\n  jng_color_type=0;\n  jng_height=0;\n  jng_width=0;\n  alpha_image=(Image *) NULL;\n  color_image=(Image *) NULL;\n  alpha_image_info=(ImageInfo *) NULL;\n  color_image_info=(ImageInfo *) NULL;\n  unique_filenames=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneJNGImage()\");\n\n  image=mng_info->image;\n\n  if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n    {\n      /*\n        Allocate next image structure.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  AcquireNextImage()\");\n\n      AcquireNextImage(image_info,image);\n\n      if (GetNextImageInList(image) == (Image *) NULL)\n        return(DestroyImageList(image));\n\n      image=SyncNextImageInList(image);\n    }\n  mng_info->image=image;\n\n  /*\n    Signature bytes have already been read.\n  */\n\n  read_JSEP=MagickFalse;\n  reading_idat=MagickFalse;\n  for (;;)\n  {\n    char\n      type[MaxTextExtent];\n\n    unsigned char\n      *chunk;\n\n    unsigned int\n      count;\n\n    /*\n      Read a new JNG chunk.\n    */\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      2*GetBlobSize(image));\n\n    if (status == MagickFalse)\n      break;\n\n    type[0]='\\0';\n    (void) ConcatenateMagickString(type,\"errr\",MaxTextExtent);\n    length=ReadBlobMSBLong(image);\n    count=(unsigned int) ReadBlob(image,4,(unsigned char *) type);\n\n    if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Reading JNG chunk type %c%c%c%c, length: %.20g\",\n        type[0],type[1],type[2],type[3],(double) length);\n\n    if (length > PNG_UINT_31_MAX || count == 0)\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n\n    p=NULL;\n    chunk=(unsigned char *) NULL;\n\n    if (length != 0)\n      {\n        chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));\n\n        if (chunk == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        for (i=0; i < (ssize_t) length; i++)\n          chunk[i]=(unsigned char) ReadBlobByte(image);\n\n        p=chunk;\n      }\n\n    (void) ReadBlobMSBLong(image);  /* read crc word */\n\n    if (memcmp(type,mng_JHDR,4) == 0)\n      {\n        if (length == 16)\n          {\n            jng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n              (p[2] << 8) | p[3]);\n            jng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n              (p[6] << 8) | p[7]);\n            if ((jng_width == 0) || (jng_height == 0))\n              ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n            jng_color_type=p[8];\n            jng_image_sample_depth=p[9];\n            jng_image_compression_method=p[10];\n            jng_image_interlace_method=p[11];\n\n            image->interlace=jng_image_interlace_method != 0 ? PNGInterlace :\n              NoInterlace;\n\n            jng_alpha_sample_depth=p[12];\n            jng_alpha_compression_method=p[13];\n            jng_alpha_filter_method=p[14];\n            jng_alpha_interlace_method=p[15];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_width:      %16lu,    jng_height:     %16lu\\n\"\n                  \"    jng_color_type: %16d,     jng_image_sample_depth: %3d\\n\"\n                  \"    jng_image_compression_method:%3d\",\n                  (unsigned long) jng_width, (unsigned long) jng_height,\n                  jng_color_type, jng_image_sample_depth,\n                  jng_image_compression_method);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_image_interlace_method:  %3d\"\n                  \"    jng_alpha_sample_depth:      %3d\",\n                  jng_image_interlace_method,\n                  jng_alpha_sample_depth);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_alpha_compression_method:%3d\\n\"\n                  \"    jng_alpha_filter_method:     %3d\\n\"\n                  \"    jng_alpha_interlace_method:  %3d\",\n                  jng_alpha_compression_method,\n                  jng_alpha_filter_method,\n                  jng_alpha_interlace_method);\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n\n    if ((reading_idat == MagickFalse) && (read_JSEP == MagickFalse) &&\n        ((memcmp(type,mng_JDAT,4) == 0) || (memcmp(type,mng_JdAA,4) == 0) ||\n         (memcmp(type,mng_IDAT,4) == 0) || (memcmp(type,mng_JDAA,4) == 0)))\n      {\n        /*\n           o create color_image\n           o open color_blob, attached to color_image\n           o if (color type has alpha)\n               open alpha_blob, attached to alpha_image\n        */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Creating color_blob.\");\n\n        color_image_info=(ImageInfo *)AcquireMagickMemory(sizeof(ImageInfo));\n\n        if (color_image_info == (ImageInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        GetImageInfo(color_image_info);\n        color_image=AcquireImage(color_image_info);\n\n        if (color_image == (Image *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        (void) AcquireUniqueFilename(color_image->filename);\n        unique_filenames++;\n        status=OpenBlob(color_image_info,color_image,WriteBinaryBlobMode,\n          exception);\n\n        if (status == MagickFalse)\n          return(DestroyImageList(image));\n\n        if ((image_info->ping == MagickFalse) && (jng_color_type >= 12))\n          {\n            alpha_image_info=(ImageInfo *)\n              AcquireMagickMemory(sizeof(ImageInfo));\n\n            if (alpha_image_info == (ImageInfo *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n            GetImageInfo(alpha_image_info);\n            alpha_image=AcquireImage(alpha_image_info);\n\n            if (alpha_image == (Image *) NULL)\n              {\n                alpha_image=DestroyImage(alpha_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Creating alpha_blob.\");\n\n            (void) AcquireUniqueFilename(alpha_image->filename);\n            unique_filenames++;\n            status=OpenBlob(alpha_image_info,alpha_image,WriteBinaryBlobMode,\n              exception);\n\n            if (status == MagickFalse)\n              return(DestroyImageList(image));\n\n            if (jng_alpha_compression_method == 0)\n              {\n                unsigned char\n                  data[18];\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Writing IHDR chunk to alpha_blob.\");\n\n                (void) WriteBlob(alpha_image,8,(const unsigned char *)\n                  \"\\211PNG\\r\\n\\032\\n\");\n\n                (void) WriteBlobMSBULong(alpha_image,13L);\n                PNGType(data,mng_IHDR);\n                LogPNGChunk(logging,mng_IHDR,13L);\n                PNGLong(data+4,jng_width);\n                PNGLong(data+8,jng_height);\n                data[12]=jng_alpha_sample_depth;\n                data[13]=0; /* color_type gray */\n                data[14]=0; /* compression method 0 */\n                data[15]=0; /* filter_method 0 */\n                data[16]=0; /* interlace_method 0 */\n                (void) WriteBlob(alpha_image,17,data);\n                (void) WriteBlobMSBULong(alpha_image,crc32(0,data,17));\n              }\n          }\n        reading_idat=MagickTrue;\n      }\n\n    if (memcmp(type,mng_JDAT,4) == 0)\n      {\n        /* Copy chunk to color_image->blob */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Copying JDAT chunk data to color_blob.\");\n\n        (void) WriteBlob(color_image,length,chunk);\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_IDAT,4) == 0)\n      {\n        png_byte\n           data[5];\n\n        /* Copy IDAT header and chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying IDAT chunk data to alpha_blob.\");\n\n            (void) WriteBlobMSBULong(alpha_image,(size_t) length);\n            PNGType(data,mng_IDAT);\n            LogPNGChunk(logging,mng_IDAT,length);\n            (void) WriteBlob(alpha_image,4,data);\n            (void) WriteBlob(alpha_image,length,chunk);\n            (void) WriteBlobMSBULong(alpha_image,\n              crc32(crc32(0,data,4),chunk,(uInt) length));\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if ((memcmp(type,mng_JDAA,4) == 0) || (memcmp(type,mng_JdAA,4) == 0))\n      {\n        /* Copy chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying JDAA chunk data to alpha_blob.\");\n\n            (void) WriteBlob(alpha_image,length,chunk);\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_JSEP,4) == 0)\n      {\n        read_JSEP=MagickTrue;\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_bKGD,4) == 0)\n      {\n        if (length == 2)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=image->background_color.red;\n            image->background_color.blue=image->background_color.red;\n          }\n\n        if (length == 6)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=ScaleCharToQuantum(p[3]);\n            image->background_color.blue=ScaleCharToQuantum(p[5]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_gAMA,4) == 0)\n      {\n        if (length == 4)\n          image->gamma=((float) mng_get_long(p))*0.00001;\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_cHRM,4) == 0)\n      {\n        if (length == 32)\n          {\n            image->chromaticity.white_point.x=0.00001*mng_get_long(p);\n            image->chromaticity.white_point.y=0.00001*mng_get_long(&p[4]);\n            image->chromaticity.red_primary.x=0.00001*mng_get_long(&p[8]);\n            image->chromaticity.red_primary.y=0.00001*mng_get_long(&p[12]);\n            image->chromaticity.green_primary.x=0.00001*mng_get_long(&p[16]);\n            image->chromaticity.green_primary.y=0.00001*mng_get_long(&p[20]);\n            image->chromaticity.blue_primary.x=0.00001*mng_get_long(&p[24]);\n            image->chromaticity.blue_primary.y=0.00001*mng_get_long(&p[28]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_sRGB,4) == 0)\n      {\n        if (length == 1)\n          {\n            image->rendering_intent=\n              Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n            image->gamma=1.000f/2.200f;\n            image->chromaticity.red_primary.x=0.6400f;\n            image->chromaticity.red_primary.y=0.3300f;\n            image->chromaticity.green_primary.x=0.3000f;\n            image->chromaticity.green_primary.y=0.6000f;\n            image->chromaticity.blue_primary.x=0.1500f;\n            image->chromaticity.blue_primary.y=0.0600f;\n            image->chromaticity.white_point.x=0.3127f;\n            image->chromaticity.white_point.y=0.3290f;\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_oFFs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->page.x=(ssize_t) mng_get_long(p);\n            image->page.y=(ssize_t) mng_get_long(&p[4]);\n\n            if ((int) p[8] != 0)\n              {\n                image->page.x/=10000;\n                image->page.y/=10000;\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_pHYs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->x_resolution=(double) mng_get_long(p);\n            image->y_resolution=(double) mng_get_long(&p[4]);\n            if ((int) p[8] == PNG_RESOLUTION_METER)\n              {\n                image->units=PixelsPerCentimeterResolution;\n                image->x_resolution=image->x_resolution/100.0f;\n                image->y_resolution=image->y_resolution/100.0f;\n              }\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n#if 0\n    if (memcmp(type,mng_iCCP,4) == 0)\n      {\n        /* To do: */\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n#endif\n\n    if (length != 0)\n      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n    if (memcmp(type,mng_IEND,4))\n      continue;\n\n    break;\n  }\n\n\n  /* IEND found */\n\n  /*\n    Finish up reading image data:\n\n       o read main image from color_blob.\n\n       o close color_blob.\n\n       o if (color_type has alpha)\n            if alpha_encoding is PNG\n               read secondary image from alpha_blob via ReadPNG\n            if alpha_encoding is JPEG\n               read secondary image from alpha_blob via ReadJPEG\n\n       o close alpha_blob.\n\n       o copy intensity of secondary image into\n         opacity samples of main image.\n\n       o destroy the secondary image.\n  */\n\n  if (color_image_info == (ImageInfo *) NULL)\n    {\n      assert(color_image == (Image *) NULL);\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  if (color_image == (Image *) NULL)\n    {\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  (void) SeekBlob(color_image,0,SEEK_SET);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Reading jng_image from color_blob.\");\n\n  assert(color_image_info != (ImageInfo *) NULL);\n  (void) FormatLocaleString(color_image_info->filename,MaxTextExtent,\"%s\",\n    color_image->filename);\n\n  color_image_info->ping=MagickFalse;   /* To do: avoid this */\n  jng_image=ReadImage(color_image_info,exception);\n\n  (void) RelinquishUniqueFileResource(color_image->filename);\n  unique_filenames--;\n  color_image=DestroyImage(color_image);\n  color_image_info=DestroyImageInfo(color_image_info);\n\n  if (jng_image == (Image *) NULL)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Copying jng_image pixels to main image.\");\n  image->columns=jng_width;\n  image->rows=jng_height;\n  length=image->columns*sizeof(PixelPacket);\n\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    s=GetVirtualPixels(jng_image,0,y,image->columns,1,&image->exception);\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    (void) CopyMagickMemory(q,s,length);\n\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n\n  jng_image=DestroyImage(jng_image);\n\n  if (image_info->ping == MagickFalse)\n    {\n     if (jng_color_type >= 12)\n       {\n         if (jng_alpha_compression_method == 0)\n           {\n             png_byte\n               data[5];\n             (void) WriteBlobMSBULong(alpha_image,0x00000000L);\n             PNGType(data,mng_IEND);\n             LogPNGChunk(logging,mng_IEND,0L);\n             (void) WriteBlob(alpha_image,4,data);\n             (void) WriteBlobMSBULong(alpha_image,crc32(0,data,4));\n           }\n\n         (void) SeekBlob(alpha_image,0,SEEK_SET);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"    Reading opacity from alpha_blob.\");\n\n         (void) FormatLocaleString(alpha_image_info->filename,MaxTextExtent,\n           \"%s\",alpha_image->filename);\n\n         jng_image=ReadImage(alpha_image_info,exception);\n\n         if (jng_image != (Image *) NULL)\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             s=GetVirtualPixels(jng_image,0,y,image->columns,1,\n                &image->exception);\n             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (image->matte != MagickFalse)\n               for (x=(ssize_t) image->columns; x != 0; x--,q++,s++)\n                  SetPixelOpacity(q,QuantumRange-\n                      GetPixelRed(s));\n\n             else\n               for (x=(ssize_t) image->columns; x != 0; x--,q++,s++)\n               {\n                  SetPixelAlpha(q,GetPixelRed(s));\n                  if (GetPixelOpacity(q) != OpaqueOpacity)\n                    image->matte=MagickTrue;\n               }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n           }\n         (void) RelinquishUniqueFileResource(alpha_image->filename);\n         unique_filenames--;\n         alpha_image=DestroyImage(alpha_image);\n         alpha_image_info=DestroyImageInfo(alpha_image_info);\n         if (jng_image != (Image *) NULL)\n           jng_image=DestroyImage(jng_image);\n       }\n    }\n\n  /* Read the JNG image.  */\n\n  if (mng_info->mng_type == 0)\n    {\n      mng_info->mng_width=jng_width;\n      mng_info->mng_height=jng_height;\n    }\n\n  if (image->page.width == 0 && image->page.height == 0)\n    {\n      image->page.width=jng_width;\n      image->page.height=jng_height;\n    }\n\n  if (image->page.x == 0 && image->page.y == 0)\n    {\n      image->page.x=mng_info->x_off[mng_info->object_id];\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  else\n    {\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  mng_info->image_found++;\n  status=SetImageProgress(image,LoadImagesTag,2*TellBlob(image),\n    2*GetBlobSize(image));\n\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneJNGImage(); unique_filenames=%d\",unique_filenames);\n\n  return(image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -85,7 +85,7 @@\n       AcquireNextImage(image_info,image);\n \n       if (GetNextImageInList(image) == (Image *) NULL)\n-        return((Image *) NULL);\n+        return(DestroyImageList(image));\n \n       image=SyncNextImageInList(image);\n     }\n@@ -236,7 +236,7 @@\n           exception);\n \n         if (status == MagickFalse)\n-          return((Image *) NULL);\n+          return(DestroyImageList(image));\n \n         if ((image_info->ping == MagickFalse) && (jng_color_type >= 12))\n           {\n@@ -266,7 +266,7 @@\n               exception);\n \n             if (status == MagickFalse)\n-              return((Image *) NULL);\n+              return(DestroyImageList(image));\n \n             if (jng_alpha_compression_method == 0)\n               {\n@@ -524,13 +524,13 @@\n     {\n       assert(color_image == (Image *) NULL);\n       assert(alpha_image == (Image *) NULL);\n-      return((Image *) NULL);\n+      return(DestroyImageList(image));\n     }\n \n   if (color_image == (Image *) NULL)\n     {\n       assert(alpha_image == (Image *) NULL);\n-      return((Image *) NULL);\n+      return(DestroyImageList(image));\n     }\n \n   (void) SeekBlob(color_image,0,SEEK_SET);\n@@ -552,7 +552,7 @@\n   color_image_info=DestroyImageInfo(color_image_info);\n \n   if (jng_image == (Image *) NULL)\n-    return((Image *) NULL);\n+    return(DestroyImageList(image));\n \n   if (logging != MagickFalse)\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n@@ -668,7 +668,7 @@\n     2*GetBlobSize(image));\n \n   if (status == MagickFalse)\n-    return((Image *) NULL);\n+    return(DestroyImageList(image));\n \n   if (logging != MagickFalse)\n     (void) LogMagickEvent(CoderEvent,GetMagickModule(),",
        "diff_line_info": {
            "deleted_lines": [
                "        return((Image *) NULL);",
                "          return((Image *) NULL);",
                "              return((Image *) NULL);",
                "      return((Image *) NULL);",
                "      return((Image *) NULL);",
                "    return((Image *) NULL);",
                "    return((Image *) NULL);"
            ],
            "added_lines": [
                "        return(DestroyImageList(image));",
                "          return(DestroyImageList(image));",
                "              return(DestroyImageList(image));",
                "      return(DestroyImageList(image));",
                "      return(DestroyImageList(image));",
                "    return(DestroyImageList(image));",
                "    return(DestroyImageList(image));"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8351",
        "func_name": "ImageMagick/ReadPCDImage",
        "description": "In ImageMagick 7.0.5-5, the ReadPCDImage function in pcd.c allows attackers to cause a denial of service (memory leak) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/23071f835d44e661177957fde0add67db7788a69",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/448",
        "commit_text": "",
        "func_before": "static Image *ReadPCDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    number_pixels;\n\n  register ssize_t\n    i,\n    y;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *c1,\n    *c2,\n    *yy;\n\n  size_t\n    height,\n    number_images,\n    rotate,\n    scene,\n    width;\n\n  ssize_t\n    count,\n    x;\n\n  unsigned char\n    *chroma1,\n    *chroma2,\n    *header,\n    *luma;\n\n  unsigned int\n    overview;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a PCD file.\n  */\n  header=(unsigned char *) AcquireQuantumMemory(0x800,3UL*sizeof(*header));\n  if (header == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  count=ReadBlob(image,3*0x800,header);\n  overview=LocaleNCompare((char *) header,\"PCD_OPA\",7) == 0;\n  if ((count != (3*0x800)) ||\n      ((LocaleNCompare((char *) header+0x800,\"PCD\",3) != 0) && (overview == 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  rotate=header[0x0e02] & 0x03;\n  number_images=(header[10] << 8) | header[11];\n  if (number_images > 65535)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  header=(unsigned char *) RelinquishMagickMemory(header);\n  /*\n    Determine resolution by scene specification.\n  */\n  if ((image->columns == 0) || (image->rows == 0))\n    scene=3;\n  else\n    {\n      width=192;\n      height=128;\n      for (scene=1; scene < 6; scene++)\n      {\n        if ((width >= image->columns) && (height >= image->rows))\n          break;\n        width<<=1;\n        height<<=1;\n      }\n    }\n  if (image_info->number_scenes != 0)\n    scene=(size_t) MagickMin(image_info->scene,6);\n  if (overview != 0)\n    scene=1;\n  /*\n    Initialize image structure.\n  */\n  width=192;\n  height=128;\n  for (i=1; i < (ssize_t) MagickMin(scene,3); i++)\n  {\n    width<<=1;\n    height<<=1;\n  }\n  image->columns=width;\n  image->rows=height;\n  image->depth=8;\n  for ( ; i < (ssize_t) scene; i++)\n  {\n    image->columns<<=1;\n    image->rows<<=1;\n  }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  /*\n    Allocate luma and chroma memory.\n  */\n  number_pixels=(MagickSizeType) image->columns*image->rows;\n  if (number_pixels != (size_t) number_pixels)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  chroma1=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*\n    sizeof(*chroma1));\n  chroma2=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*\n    sizeof(*chroma2));\n  luma=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*\n    sizeof(*luma));\n  if ((chroma1 == (unsigned char *) NULL) ||\n      (chroma2 == (unsigned char *) NULL) || (luma == (unsigned char *) NULL))\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  /*\n    Advance to image data.\n  */\n  offset=93;\n  if (overview != 0)\n    offset=2;\n  else\n    if (scene == 2)\n      offset=20;\n    else\n      if (scene <= 1)\n        offset=1;\n  for (i=0; i < (ssize_t) (offset*0x800); i++)\n    (void) ReadBlobByte(image);\n  if (overview != 0)\n    {\n      Image\n        *overview_image;\n\n      MagickProgressMonitor\n        progress_monitor;\n\n      register ssize_t\n        j;\n\n      /*\n        Read thumbnails from overview image.\n      */\n      for (j=1; j <= (ssize_t) number_images; j++)\n      {\n        progress_monitor=SetImageProgressMonitor(image,\n          (MagickProgressMonitor) NULL,image->client_data);\n        (void) FormatLocaleString(image->filename,MaxTextExtent,\n          \"images/img%04ld.pcd\",(long) j);\n        (void) FormatLocaleString(image->magick_filename,MaxTextExtent,\n          \"images/img%04ld.pcd\",(long) j);\n        image->scene=(size_t) j;\n        image->columns=width;\n        image->rows=height;\n        image->depth=8;\n        yy=luma;\n        c1=chroma1;\n        c2=chroma2;\n        for (y=0; y < (ssize_t) height; y+=2)\n        {\n          count=ReadBlob(image,width,yy);\n          yy+=image->columns;\n          count=ReadBlob(image,width,yy);\n          yy+=image->columns;\n          count=ReadBlob(image,width >> 1,c1);\n          c1+=image->columns;\n          count=ReadBlob(image,width >> 1,c2);\n          c2+=image->columns;\n        }\n        Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma1);\n        Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma2);\n        /*\n          Transfer luminance and chrominance channels.\n        */\n        yy=luma;\n        c1=chroma1;\n        c2=chroma2;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(q,ScaleCharToQuantum(*yy++));\n            SetPixelGreen(q,ScaleCharToQuantum(*c1++));\n            SetPixelBlue(q,ScaleCharToQuantum(*c2++));\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n        }\n        image->colorspace=YCCColorspace;\n        if (LocaleCompare(image_info->magick,\"PCDS\") == 0)\n          SetImageColorspace(image,sRGBColorspace);\n        if (j < (ssize_t) number_images)\n          {\n            /*\n              Allocate next image structure.\n            */\n            AcquireNextImage(image_info,image);\n            if (GetNextImageInList(image) == (Image *) NULL)\n              {\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            image=SyncNextImageInList(image);\n          }\n        (void) SetImageProgressMonitor(image,progress_monitor,\n          image->client_data);\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,j-1,number_images);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n      chroma2=(unsigned char *) RelinquishMagickMemory(chroma2);\n      chroma1=(unsigned char *) RelinquishMagickMemory(chroma1);\n      luma=(unsigned char *) RelinquishMagickMemory(luma);\n      image=GetFirstImageInList(image);\n      overview_image=OverviewImage(image_info,image,exception);\n      return(overview_image);\n    }\n  /*\n    Read interleaved image.\n  */\n  yy=luma;\n  c1=chroma1;\n  c2=chroma2;\n  for (y=0; y < (ssize_t) height; y+=2)\n  {\n    count=ReadBlob(image,width,yy);\n    yy+=image->columns;\n    count=ReadBlob(image,width,yy);\n    yy+=image->columns;\n    count=ReadBlob(image,width >> 1,c1);\n    c1+=image->columns;\n    count=ReadBlob(image,width >> 1,c2);\n    c2+=image->columns;\n  }\n  if (scene >= 4)\n    {\n      /*\n        Recover luminance deltas for 1536x1024 image.\n      */\n      Upsample(768,512,image->columns,luma);\n      Upsample(384,256,image->columns,chroma1);\n      Upsample(384,256,image->columns,chroma2);\n      image->rows=1024;\n      for (i=0; i < (4*0x800); i++)\n        (void) ReadBlobByte(image);\n      status=DecodeImage(image,luma,chroma1,chroma2);\n      if ((scene >= 5) && status)\n        {\n          /*\n            Recover luminance deltas for 3072x2048 image.\n          */\n          Upsample(1536,1024,image->columns,luma);\n          Upsample(768,512,image->columns,chroma1);\n          Upsample(768,512,image->columns,chroma2);\n          image->rows=2048;\n          offset=TellBlob(image)/0x800+12;\n          offset=SeekBlob(image,offset*0x800,SEEK_SET);\n          status=DecodeImage(image,luma,chroma1,chroma2);\n          if ((scene >= 6) && (status != MagickFalse))\n            {\n              /*\n                Recover luminance deltas for 6144x4096 image (vaporware).\n              */\n              Upsample(3072,2048,image->columns,luma);\n              Upsample(1536,1024,image->columns,chroma1);\n              Upsample(1536,1024,image->columns,chroma2);\n              image->rows=4096;\n            }\n        }\n    }\n  Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma1);\n  Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma2);\n  /*\n    Transfer luminance and chrominance channels.\n  */\n  yy=luma;\n  c1=chroma1;\n  c2=chroma2;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelRed(q,ScaleCharToQuantum(*yy++));\n      SetPixelGreen(q,ScaleCharToQuantum(*c1++));\n      SetPixelBlue(q,ScaleCharToQuantum(*c2++));\n      q++;\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  chroma2=(unsigned char *) RelinquishMagickMemory(chroma2);\n  chroma1=(unsigned char *) RelinquishMagickMemory(chroma1);\n  luma=(unsigned char *) RelinquishMagickMemory(luma);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  if (image_info->ping == MagickFalse)\n    if ((rotate == 1) || (rotate == 3))\n      {\n        double\n          degrees;\n\n        Image\n          *rotate_image;\n\n        /*\n          Rotate image.\n        */\n        degrees=rotate == 1 ? -90.0 : 90.0;\n        rotate_image=RotateImage(image,degrees,exception);\n        if (rotate_image != (Image *) NULL)\n          {\n            image=DestroyImage(image);\n            image=rotate_image;\n          }\n      }\n  /*\n    Set CCIR 709 primaries with a D65 white point.\n  */\n  image->chromaticity.red_primary.x=0.6400f;\n  image->chromaticity.red_primary.y=0.3300f;\n  image->chromaticity.green_primary.x=0.3000f;\n  image->chromaticity.green_primary.y=0.6000f;\n  image->chromaticity.blue_primary.x=0.1500f;\n  image->chromaticity.blue_primary.y=0.0600f;\n  image->chromaticity.white_point.x=0.3127f;\n  image->chromaticity.white_point.y=0.3290f;\n  image->gamma=1.000f/2.200f;\n  image->colorspace=YCCColorspace;\n  if (LocaleCompare(image_info->magick,\"PCDS\") == 0)\n    SetImageColorspace(image,sRGBColorspace);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadPCDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    number_pixels;\n\n  register ssize_t\n    i,\n    y;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *c1,\n    *c2,\n    *yy;\n\n  size_t\n    height,\n    number_images,\n    rotate,\n    scene,\n    width;\n\n  ssize_t\n    count,\n    x;\n\n  unsigned char\n    *chroma1,\n    *chroma2,\n    *header,\n    *luma;\n\n  unsigned int\n    overview;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a PCD file.\n  */\n  header=(unsigned char *) AcquireQuantumMemory(0x800,3UL*sizeof(*header));\n  if (header == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  count=ReadBlob(image,3*0x800,header);\n  overview=LocaleNCompare((char *) header,\"PCD_OPA\",7) == 0;\n  if ((count != (3*0x800)) ||\n      ((LocaleNCompare((char *) header+0x800,\"PCD\",3) != 0) && (overview == 0)))\n    {\n      header=(unsigned char *) RelinquishMagickMemory(header);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  rotate=header[0x0e02] & 0x03;\n  number_images=(header[10] << 8) | header[11];\n  header=(unsigned char *) RelinquishMagickMemory(header);\n  if (number_images > 65535)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Determine resolution by scene specification.\n  */\n  if ((image->columns == 0) || (image->rows == 0))\n    scene=3;\n  else\n    {\n      width=192;\n      height=128;\n      for (scene=1; scene < 6; scene++)\n      {\n        if ((width >= image->columns) && (height >= image->rows))\n          break;\n        width<<=1;\n        height<<=1;\n      }\n    }\n  if (image_info->number_scenes != 0)\n    scene=(size_t) MagickMin(image_info->scene,6);\n  if (overview != 0)\n    scene=1;\n  /*\n    Initialize image structure.\n  */\n  width=192;\n  height=128;\n  for (i=1; i < (ssize_t) MagickMin(scene,3); i++)\n  {\n    width<<=1;\n    height<<=1;\n  }\n  image->columns=width;\n  image->rows=height;\n  image->depth=8;\n  for ( ; i < (ssize_t) scene; i++)\n  {\n    image->columns<<=1;\n    image->rows<<=1;\n  }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  /*\n    Allocate luma and chroma memory.\n  */\n  number_pixels=(MagickSizeType) image->columns*image->rows;\n  if (number_pixels != (size_t) number_pixels)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  chroma1=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*\n    sizeof(*chroma1));\n  chroma2=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*\n    sizeof(*chroma2));\n  luma=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*\n    sizeof(*luma));\n  if ((chroma1 == (unsigned char *) NULL) ||\n      (chroma2 == (unsigned char *) NULL) || (luma == (unsigned char *) NULL))\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  /*\n    Advance to image data.\n  */\n  offset=93;\n  if (overview != 0)\n    offset=2;\n  else\n    if (scene == 2)\n      offset=20;\n    else\n      if (scene <= 1)\n        offset=1;\n  for (i=0; i < (ssize_t) (offset*0x800); i++)\n    (void) ReadBlobByte(image);\n  if (overview != 0)\n    {\n      Image\n        *overview_image;\n\n      MagickProgressMonitor\n        progress_monitor;\n\n      register ssize_t\n        j;\n\n      /*\n        Read thumbnails from overview image.\n      */\n      for (j=1; j <= (ssize_t) number_images; j++)\n      {\n        progress_monitor=SetImageProgressMonitor(image,\n          (MagickProgressMonitor) NULL,image->client_data);\n        (void) FormatLocaleString(image->filename,MaxTextExtent,\n          \"images/img%04ld.pcd\",(long) j);\n        (void) FormatLocaleString(image->magick_filename,MaxTextExtent,\n          \"images/img%04ld.pcd\",(long) j);\n        image->scene=(size_t) j;\n        image->columns=width;\n        image->rows=height;\n        image->depth=8;\n        yy=luma;\n        c1=chroma1;\n        c2=chroma2;\n        for (y=0; y < (ssize_t) height; y+=2)\n        {\n          count=ReadBlob(image,width,yy);\n          yy+=image->columns;\n          count=ReadBlob(image,width,yy);\n          yy+=image->columns;\n          count=ReadBlob(image,width >> 1,c1);\n          c1+=image->columns;\n          count=ReadBlob(image,width >> 1,c2);\n          c2+=image->columns;\n        }\n        Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma1);\n        Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma2);\n        /*\n          Transfer luminance and chrominance channels.\n        */\n        yy=luma;\n        c1=chroma1;\n        c2=chroma2;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(q,ScaleCharToQuantum(*yy++));\n            SetPixelGreen(q,ScaleCharToQuantum(*c1++));\n            SetPixelBlue(q,ScaleCharToQuantum(*c2++));\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n        }\n        image->colorspace=YCCColorspace;\n        if (LocaleCompare(image_info->magick,\"PCDS\") == 0)\n          (void) SetImageColorspace(image,sRGBColorspace);\n        if (j < (ssize_t) number_images)\n          {\n            /*\n              Allocate next image structure.\n            */\n            AcquireNextImage(image_info,image);\n            if (GetNextImageInList(image) == (Image *) NULL)\n              {\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            image=SyncNextImageInList(image);\n          }\n        (void) SetImageProgressMonitor(image,progress_monitor,\n          image->client_data);\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,j-1,number_images);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n      chroma2=(unsigned char *) RelinquishMagickMemory(chroma2);\n      chroma1=(unsigned char *) RelinquishMagickMemory(chroma1);\n      luma=(unsigned char *) RelinquishMagickMemory(luma);\n      image=GetFirstImageInList(image);\n      overview_image=OverviewImage(image_info,image,exception);\n      return(overview_image);\n    }\n  /*\n    Read interleaved image.\n  */\n  yy=luma;\n  c1=chroma1;\n  c2=chroma2;\n  for (y=0; y < (ssize_t) height; y+=2)\n  {\n    count=ReadBlob(image,width,yy);\n    yy+=image->columns;\n    count=ReadBlob(image,width,yy);\n    yy+=image->columns;\n    count=ReadBlob(image,width >> 1,c1);\n    c1+=image->columns;\n    count=ReadBlob(image,width >> 1,c2);\n    c2+=image->columns;\n  }\n  if (scene >= 4)\n    {\n      /*\n        Recover luminance deltas for 1536x1024 image.\n      */\n      Upsample(768,512,image->columns,luma);\n      Upsample(384,256,image->columns,chroma1);\n      Upsample(384,256,image->columns,chroma2);\n      image->rows=1024;\n      for (i=0; i < (4*0x800); i++)\n        (void) ReadBlobByte(image);\n      status=DecodeImage(image,luma,chroma1,chroma2);\n      if ((scene >= 5) && status)\n        {\n          /*\n            Recover luminance deltas for 3072x2048 image.\n          */\n          Upsample(1536,1024,image->columns,luma);\n          Upsample(768,512,image->columns,chroma1);\n          Upsample(768,512,image->columns,chroma2);\n          image->rows=2048;\n          offset=TellBlob(image)/0x800+12;\n          offset=SeekBlob(image,offset*0x800,SEEK_SET);\n          status=DecodeImage(image,luma,chroma1,chroma2);\n          if ((scene >= 6) && (status != MagickFalse))\n            {\n              /*\n                Recover luminance deltas for 6144x4096 image (vaporware).\n              */\n              Upsample(3072,2048,image->columns,luma);\n              Upsample(1536,1024,image->columns,chroma1);\n              Upsample(1536,1024,image->columns,chroma2);\n              image->rows=4096;\n            }\n        }\n    }\n  Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma1);\n  Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma2);\n  /*\n    Transfer luminance and chrominance channels.\n  */\n  yy=luma;\n  c1=chroma1;\n  c2=chroma2;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelRed(q,ScaleCharToQuantum(*yy++));\n      SetPixelGreen(q,ScaleCharToQuantum(*c1++));\n      SetPixelBlue(q,ScaleCharToQuantum(*c2++));\n      q++;\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  chroma2=(unsigned char *) RelinquishMagickMemory(chroma2);\n  chroma1=(unsigned char *) RelinquishMagickMemory(chroma1);\n  luma=(unsigned char *) RelinquishMagickMemory(luma);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  if (image_info->ping == MagickFalse)\n    if ((rotate == 1) || (rotate == 3))\n      {\n        double\n          degrees;\n\n        Image\n          *rotate_image;\n\n        /*\n          Rotate image.\n        */\n        degrees=rotate == 1 ? -90.0 : 90.0;\n        rotate_image=RotateImage(image,degrees,exception);\n        if (rotate_image != (Image *) NULL)\n          {\n            image=DestroyImage(image);\n            image=rotate_image;\n          }\n      }\n  /*\n    Set CCIR 709 primaries with a D65 white point.\n  */\n  image->chromaticity.red_primary.x=0.6400f;\n  image->chromaticity.red_primary.y=0.3300f;\n  image->chromaticity.green_primary.x=0.3000f;\n  image->chromaticity.green_primary.y=0.6000f;\n  image->chromaticity.blue_primary.x=0.1500f;\n  image->chromaticity.blue_primary.y=0.0600f;\n  image->chromaticity.white_point.x=0.3127f;\n  image->chromaticity.white_point.y=0.3290f;\n  image->gamma=1.000f/2.200f;\n  image->colorspace=YCCColorspace;\n  if (LocaleCompare(image_info->magick,\"PCDS\") == 0)\n    (void) SetImageColorspace(image,sRGBColorspace);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -71,12 +71,15 @@\n   overview=LocaleNCompare((char *) header,\"PCD_OPA\",7) == 0;\n   if ((count != (3*0x800)) ||\n       ((LocaleNCompare((char *) header+0x800,\"PCD\",3) != 0) && (overview == 0)))\n-    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+    {\n+      header=(unsigned char *) RelinquishMagickMemory(header);\n+      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+    }\n   rotate=header[0x0e02] & 0x03;\n   number_images=(header[10] << 8) | header[11];\n+  header=(unsigned char *) RelinquishMagickMemory(header);\n   if (number_images > 65535)\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n-  header=(unsigned char *) RelinquishMagickMemory(header);\n   /*\n     Determine resolution by scene specification.\n   */\n@@ -216,7 +219,7 @@\n         }\n         image->colorspace=YCCColorspace;\n         if (LocaleCompare(image_info->magick,\"PCDS\") == 0)\n-          SetImageColorspace(image,sRGBColorspace);\n+          (void) SetImageColorspace(image,sRGBColorspace);\n         if (j < (ssize_t) number_images)\n           {\n             /*\n@@ -370,6 +373,6 @@\n   image->gamma=1.000f/2.200f;\n   image->colorspace=YCCColorspace;\n   if (LocaleCompare(image_info->magick,\"PCDS\") == 0)\n-    SetImageColorspace(image,sRGBColorspace);\n+    (void) SetImageColorspace(image,sRGBColorspace);\n   return(GetFirstImageInList(image));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "  header=(unsigned char *) RelinquishMagickMemory(header);",
                "          SetImageColorspace(image,sRGBColorspace);",
                "    SetImageColorspace(image,sRGBColorspace);"
            ],
            "added_lines": [
                "    {",
                "      header=(unsigned char *) RelinquishMagickMemory(header);",
                "      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "    }",
                "  header=(unsigned char *) RelinquishMagickMemory(header);",
                "          (void) SetImageColorspace(image,sRGBColorspace);",
                "    (void) SetImageColorspace(image,sRGBColorspace);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8352",
        "func_name": "ImageMagick/ReadXWDImage",
        "description": "In ImageMagick 7.0.5-5, the ReadXWDImage function in xwd.c allows attackers to cause a denial of service (memory leak) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/2917930679a3543e52070668c3adb3d8c183d1f6",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/452",
        "commit_text": "",
        "func_before": "static Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define CheckOverflowException(length,width,height) \\\n  (((height) != 0) && ((length)/((size_t) height) != ((size_t) width)))\n\n  char\n    *comment;\n\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  int\n    x_status;\n\n  MagickBooleanType\n    authentic_colormap;\n\n  MagickStatusType\n    status;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i;\n\n  register size_t\n    pixel;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned long\n    lsb_first;\n\n  XColor\n    *colors;\n\n  XImage\n    *ximage;\n\n  XWDFileHeader\n    header;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read in header information.\n  */\n  count=ReadBlob(image,sz_XWDheader,(unsigned char *) &header);\n  if (count != sz_XWDheader)\n    ThrowReaderException(CorruptImageError,\"UnableToReadImageHeader\");\n  /*\n    Ensure the header byte-order is most-significant byte first.\n  */\n  lsb_first=1;\n  if ((int) (*(char *) &lsb_first) != 0)\n    MSBOrderLong((unsigned char *) &header,sz_XWDheader);\n  /*\n    Check to see if the dump file is in the proper format.\n  */\n  if (header.file_version != XWD_FILE_VERSION)\n    ThrowReaderException(CorruptImageError,\"FileFormatVersionMismatch\");\n  if (header.header_size < sz_XWDheader)\n    ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  switch (header.visual_class) {\n    case StaticGray:\n    case GrayScale:\n    case StaticColor:\n    case PseudoColor:\n    case TrueColor:\n    case DirectColor:\n      break;\n    default:\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n  switch (header.pixmap_format) {\n    case XYBitmap:\n    case XYPixmap:\n    case ZPixmap:\n      break;\n    default:\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  }\n  length=(size_t) header.header_size-sz_XWDheader;\n  comment=(char *) AcquireQuantumMemory(length+1,sizeof(*comment));\n  if (comment == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  count=ReadBlob(image,length,(unsigned char *) comment);\n  comment[length]='\\0';\n  (void) SetImageProperty(image,\"comment\",comment);\n  comment=DestroyString(comment);\n  if (count != (ssize_t) length)\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  /*\n    Initialize the X image.\n  */\n  ximage=(XImage *) AcquireMagickMemory(sizeof(*ximage));\n  if (ximage == (XImage *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  ximage->depth=(int) header.pixmap_depth;\n  ximage->format=(int) header.pixmap_format;\n  ximage->xoffset=(int) header.xoffset;\n  ximage->data=(char *) NULL;\n  ximage->width=(int) header.pixmap_width;\n  ximage->height=(int) header.pixmap_height;\n  ximage->bitmap_pad=(int) header.bitmap_pad;\n  ximage->bytes_per_line=(int) header.bytes_per_line;\n  ximage->byte_order=(int) header.byte_order;\n  ximage->bitmap_unit=(int) header.bitmap_unit;\n  ximage->bitmap_bit_order=(int) header.bitmap_bit_order;\n  ximage->bits_per_pixel=(int) header.bits_per_pixel;\n  ximage->red_mask=header.red_mask;\n  ximage->green_mask=header.green_mask;\n  ximage->blue_mask=header.blue_mask;\n  if ((ximage->width < 0) || (ximage->height < 0) || (ximage->depth < 0) || \n      (ximage->format < 0) || (ximage->byte_order < 0) ||\n      (ximage->bitmap_bit_order < 0) || (ximage->bitmap_pad < 0) ||\n      (ximage->bytes_per_line < 0))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if ((ximage->width > 65535) || (ximage->height > 65535))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if ((ximage->bits_per_pixel > 32) || (ximage->bitmap_unit > 32))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  x_status=XInitImage(ximage);\n  if (x_status == 0)\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    }\n  /*\n    Read colormap.\n  */\n  authentic_colormap=MagickFalse;\n  colors=(XColor *) NULL;\n  if (header.ncolors != 0)\n    {\n      XWDColor\n        color;\n\n      length=(size_t) header.ncolors;\n      colors=(XColor *) AcquireQuantumMemory(length,sizeof(*colors));\n      if (colors == (XColor *) NULL)\n        {\n          ximage=(XImage *) RelinquishMagickMemory(ximage);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      for (i=0; i < (ssize_t) header.ncolors; i++)\n      {\n        count=ReadBlob(image,sz_XWDColor,(unsigned char *) &color);\n        if (count != sz_XWDColor)\n          {\n            ximage=(XImage *) RelinquishMagickMemory(ximage);\n            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n          }\n        colors[i].pixel=color.pixel;\n        colors[i].red=color.red;\n        colors[i].green=color.green;\n        colors[i].blue=color.blue;\n        colors[i].flags=(char) color.flags;\n        if (color.flags != 0)\n         authentic_colormap=MagickTrue;\n      }\n      /*\n        Ensure the header byte-order is most-significant byte first.\n      */\n      lsb_first=1;\n      if ((int) (*(char *) &lsb_first) != 0)\n        for (i=0; i < (ssize_t) header.ncolors; i++)\n        {\n          MSBOrderLong((unsigned char *) &colors[i].pixel,\n            sizeof(colors[i].pixel));\n          MSBOrderShort((unsigned char *) &colors[i].red,3*\n            sizeof(colors[i].red));\n        }\n    }\n  /*\n    Allocate the pixel buffer.\n  */\n  length=(size_t) ximage->bytes_per_line*ximage->height;\n  if (CheckOverflowException(length,ximage->bytes_per_line,ximage->height))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if (ximage->format != ZPixmap)\n    {\n      size_t\n        extent;\n\n      extent=length;\n      length*=ximage->depth;\n      if (CheckOverflowException(length,extent,ximage->depth))\n        {\n          ximage=(XImage *) RelinquishMagickMemory(ximage);\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n    }\n  ximage->data=(char *) AcquireQuantumMemory(length,sizeof(*ximage->data));\n  if (ximage->data == (char *) NULL)\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     }\n  count=ReadBlob(image,length,(unsigned char *) ximage->data);\n  if (count != (ssize_t) length)\n    {\n      ximage->data=DestroyString(ximage->data);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n    }\n  /*\n    Convert image to MIFF format.\n  */\n  image->columns=(size_t) ximage->width;\n  image->rows=(size_t) ximage->height;\n  image->depth=8;\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if ((header.ncolors == 0U) || (ximage->red_mask != 0) ||\n      (ximage->green_mask != 0) || (ximage->blue_mask != 0))\n    image->storage_class=DirectClass;\n  else\n    image->storage_class=PseudoClass;\n  image->colors=header.ncolors;\n  if (image_info->ping == MagickFalse)\n    switch (image->storage_class)\n    {\n      case DirectClass:\n      default:\n      {\n        register size_t\n          color;\n\n        size_t\n          blue_mask,\n          blue_shift,\n          green_mask,\n          green_shift,\n          red_mask,\n          red_shift;\n\n        /*\n          Determine shift and mask for red, green, and blue.\n        */\n        red_mask=ximage->red_mask;\n        red_shift=0;\n        while ((red_mask != 0) && ((red_mask & 0x01) == 0))\n        {\n          red_mask>>=1;\n          red_shift++;\n        }\n        green_mask=ximage->green_mask;\n        green_shift=0;\n        while ((green_mask != 0) && ((green_mask & 0x01) == 0))\n        {\n          green_mask>>=1;\n          green_shift++;\n        }\n        blue_mask=ximage->blue_mask;\n        blue_shift=0;\n        while ((blue_mask != 0) && ((blue_mask & 0x01) == 0))\n        {\n          blue_mask>>=1;\n          blue_shift++;\n        }\n        /*\n          Convert X image to DirectClass packets.\n        */\n        if ((image->colors != 0) && (authentic_colormap != MagickFalse))\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              pixel=XGetPixel(ximage,(int) x,(int) y);\n              index=(IndexPacket) ((pixel >> red_shift) & red_mask);\n              if (index < header.ncolors)\n                SetPixelRed(q,ScaleShortToQuantum(colors[(ssize_t) index].red));\n              index=(IndexPacket) ((pixel >> green_shift) & green_mask);\n              if (index < header.ncolors)\n                SetPixelGreen(q,ScaleShortToQuantum(colors[(ssize_t)\n                  index].green));\n              index=(IndexPacket) ((pixel >> blue_shift) & blue_mask);\n              if (index < header.ncolors)\n                SetPixelBlue(q,ScaleShortToQuantum(colors[(ssize_t)\n                  index].blue));\n              q++;\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              pixel=XGetPixel(ximage,(int) x,(int) y);\n              color=(pixel >> red_shift) & red_mask;\n              if (red_mask != 0)\n                color=(color*65535UL)/red_mask;\n              SetPixelRed(q,ScaleShortToQuantum((unsigned short) color));\n              color=(pixel >> green_shift) & green_mask;\n              if (green_mask != 0)\n                color=(color*65535UL)/green_mask;\n              SetPixelGreen(q,ScaleShortToQuantum((unsigned short) color));\n              color=(pixel >> blue_shift) & blue_mask;\n              if (blue_mask != 0)\n                color=(color*65535UL)/blue_mask;\n              SetPixelBlue(q,ScaleShortToQuantum((unsigned short) color));\n              q++;\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n        break;\n      }\n      case PseudoClass:\n      {\n        /*\n          Convert X image to PseudoClass packets.\n        */\n        if (AcquireImageColormap(image,image->colors) == MagickFalse)\n          {\n            ximage->data=DestroyString(ximage->data);\n            ximage=(XImage *) RelinquishMagickMemory(ximage);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=ScaleShortToQuantum(colors[i].red);\n          image->colormap[i].green=ScaleShortToQuantum(colors[i].green);\n          image->colormap[i].blue=ScaleShortToQuantum(colors[i].blue);\n        }\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            index=ConstrainColormapIndex(image,XGetPixel(ximage,(int) x,\n              (int) y));\n            SetPixelIndex(indexes+x,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n        break;\n      }\n    }\n  /*\n    Free image and colormap.\n  */\n  if (header.ncolors != 0)\n    colors=(XColor *) RelinquishMagickMemory(colors);\n  ximage->data=DestroyString(ximage->data);\n  ximage=(XImage *) RelinquishMagickMemory(ximage);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define CheckOverflowException(length,width,height) \\\n  (((height) != 0) && ((length)/((size_t) height) != ((size_t) width)))\n\n  char\n    *comment;\n\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  int\n    x_status;\n\n  MagickBooleanType\n    authentic_colormap;\n\n  MagickStatusType\n    status;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i;\n\n  register size_t\n    pixel;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned long\n    lsb_first;\n\n  XColor\n    *colors;\n\n  XImage\n    *ximage;\n\n  XWDFileHeader\n    header;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read in header information.\n  */\n  count=ReadBlob(image,sz_XWDheader,(unsigned char *) &header);\n  if (count != sz_XWDheader)\n    ThrowReaderException(CorruptImageError,\"UnableToReadImageHeader\");\n  /*\n    Ensure the header byte-order is most-significant byte first.\n  */\n  lsb_first=1;\n  if ((int) (*(char *) &lsb_first) != 0)\n    MSBOrderLong((unsigned char *) &header,sz_XWDheader);\n  /*\n    Check to see if the dump file is in the proper format.\n  */\n  if (header.file_version != XWD_FILE_VERSION)\n    ThrowReaderException(CorruptImageError,\"FileFormatVersionMismatch\");\n  if (header.header_size < sz_XWDheader)\n    ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  switch (header.visual_class) {\n    case StaticGray:\n    case GrayScale:\n    case StaticColor:\n    case PseudoColor:\n    case TrueColor:\n    case DirectColor:\n      break;\n    default:\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n  switch (header.pixmap_format) {\n    case XYBitmap:\n    case XYPixmap:\n    case ZPixmap:\n      break;\n    default:\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  }\n  length=(size_t) header.header_size-sz_XWDheader;\n  comment=(char *) AcquireQuantumMemory(length+1,sizeof(*comment));\n  if (comment == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  count=ReadBlob(image,length,(unsigned char *) comment);\n  comment[length]='\\0';\n  (void) SetImageProperty(image,\"comment\",comment);\n  comment=DestroyString(comment);\n  if (count != (ssize_t) length)\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  /*\n    Initialize the X image.\n  */\n  ximage=(XImage *) AcquireMagickMemory(sizeof(*ximage));\n  if (ximage == (XImage *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  ximage->depth=(int) header.pixmap_depth;\n  ximage->format=(int) header.pixmap_format;\n  ximage->xoffset=(int) header.xoffset;\n  ximage->data=(char *) NULL;\n  ximage->width=(int) header.pixmap_width;\n  ximage->height=(int) header.pixmap_height;\n  ximage->bitmap_pad=(int) header.bitmap_pad;\n  ximage->bytes_per_line=(int) header.bytes_per_line;\n  ximage->byte_order=(int) header.byte_order;\n  ximage->bitmap_unit=(int) header.bitmap_unit;\n  ximage->bitmap_bit_order=(int) header.bitmap_bit_order;\n  ximage->bits_per_pixel=(int) header.bits_per_pixel;\n  ximage->red_mask=header.red_mask;\n  ximage->green_mask=header.green_mask;\n  ximage->blue_mask=header.blue_mask;\n  if ((ximage->width < 0) || (ximage->height < 0) || (ximage->depth < 0) || \n      (ximage->format < 0) || (ximage->byte_order < 0) ||\n      (ximage->bitmap_bit_order < 0) || (ximage->bitmap_pad < 0) ||\n      (ximage->bytes_per_line < 0))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if ((ximage->width > 65535) || (ximage->height > 65535))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if ((ximage->bits_per_pixel > 32) || (ximage->bitmap_unit > 32))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  x_status=XInitImage(ximage);\n  if (x_status == 0)\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    }\n  /*\n    Read colormap.\n  */\n  authentic_colormap=MagickFalse;\n  colors=(XColor *) NULL;\n  if (header.ncolors != 0)\n    {\n      XWDColor\n        color;\n\n      length=(size_t) header.ncolors;\n      colors=(XColor *) AcquireQuantumMemory(length,sizeof(*colors));\n      if (colors == (XColor *) NULL)\n        {\n          ximage=(XImage *) RelinquishMagickMemory(ximage);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      for (i=0; i < (ssize_t) header.ncolors; i++)\n      {\n        count=ReadBlob(image,sz_XWDColor,(unsigned char *) &color);\n        if (count != sz_XWDColor)\n          {\n            colors=(XColor *) RelinquishMagickMemory(colors);\n            ximage=(XImage *) RelinquishMagickMemory(ximage);\n            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n          }\n        colors[i].pixel=color.pixel;\n        colors[i].red=color.red;\n        colors[i].green=color.green;\n        colors[i].blue=color.blue;\n        colors[i].flags=(char) color.flags;\n        if (color.flags != 0)\n         authentic_colormap=MagickTrue;\n      }\n      /*\n        Ensure the header byte-order is most-significant byte first.\n      */\n      lsb_first=1;\n      if ((int) (*(char *) &lsb_first) != 0)\n        for (i=0; i < (ssize_t) header.ncolors; i++)\n        {\n          MSBOrderLong((unsigned char *) &colors[i].pixel,\n            sizeof(colors[i].pixel));\n          MSBOrderShort((unsigned char *) &colors[i].red,3*\n            sizeof(colors[i].red));\n        }\n    }\n  /*\n    Allocate the pixel buffer.\n  */\n  length=(size_t) ximage->bytes_per_line*ximage->height;\n  if (CheckOverflowException(length,ximage->bytes_per_line,ximage->height))\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if (ximage->format != ZPixmap)\n    {\n      size_t\n        extent;\n\n      extent=length;\n      length*=ximage->depth;\n      if (CheckOverflowException(length,extent,ximage->depth))\n        {\n          if (header.ncolors != 0)\n            colors=(XColor *) RelinquishMagickMemory(colors);\n          ximage=(XImage *) RelinquishMagickMemory(ximage);\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n    }\n  ximage->data=(char *) AcquireQuantumMemory(length,sizeof(*ximage->data));\n  if (ximage->data == (char *) NULL)\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     }\n  count=ReadBlob(image,length,(unsigned char *) ximage->data);\n  if (count != (ssize_t) length)\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage->data=DestroyString(ximage->data);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n    }\n  /*\n    Convert image to MIFF format.\n  */\n  image->columns=(size_t) ximage->width;\n  image->rows=(size_t) ximage->height;\n  image->depth=8;\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage->data=DestroyString(ximage->data);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if ((header.ncolors == 0U) || (ximage->red_mask != 0) ||\n      (ximage->green_mask != 0) || (ximage->blue_mask != 0))\n    image->storage_class=DirectClass;\n  else\n    image->storage_class=PseudoClass;\n  image->colors=header.ncolors;\n  if (image_info->ping == MagickFalse)\n    switch (image->storage_class)\n    {\n      case DirectClass:\n      default:\n      {\n        register size_t\n          color;\n\n        size_t\n          blue_mask,\n          blue_shift,\n          green_mask,\n          green_shift,\n          red_mask,\n          red_shift;\n\n        /*\n          Determine shift and mask for red, green, and blue.\n        */\n        red_mask=ximage->red_mask;\n        red_shift=0;\n        while ((red_mask != 0) && ((red_mask & 0x01) == 0))\n        {\n          red_mask>>=1;\n          red_shift++;\n        }\n        green_mask=ximage->green_mask;\n        green_shift=0;\n        while ((green_mask != 0) && ((green_mask & 0x01) == 0))\n        {\n          green_mask>>=1;\n          green_shift++;\n        }\n        blue_mask=ximage->blue_mask;\n        blue_shift=0;\n        while ((blue_mask != 0) && ((blue_mask & 0x01) == 0))\n        {\n          blue_mask>>=1;\n          blue_shift++;\n        }\n        /*\n          Convert X image to DirectClass packets.\n        */\n        if ((image->colors != 0) && (authentic_colormap != MagickFalse))\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              pixel=XGetPixel(ximage,(int) x,(int) y);\n              index=(IndexPacket) ((pixel >> red_shift) & red_mask);\n              if (index < header.ncolors)\n                SetPixelRed(q,ScaleShortToQuantum(colors[(ssize_t) index].red));\n              index=(IndexPacket) ((pixel >> green_shift) & green_mask);\n              if (index < header.ncolors)\n                SetPixelGreen(q,ScaleShortToQuantum(colors[(ssize_t)\n                  index].green));\n              index=(IndexPacket) ((pixel >> blue_shift) & blue_mask);\n              if (index < header.ncolors)\n                SetPixelBlue(q,ScaleShortToQuantum(colors[(ssize_t)\n                  index].blue));\n              q++;\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              pixel=XGetPixel(ximage,(int) x,(int) y);\n              color=(pixel >> red_shift) & red_mask;\n              if (red_mask != 0)\n                color=(color*65535UL)/red_mask;\n              SetPixelRed(q,ScaleShortToQuantum((unsigned short) color));\n              color=(pixel >> green_shift) & green_mask;\n              if (green_mask != 0)\n                color=(color*65535UL)/green_mask;\n              SetPixelGreen(q,ScaleShortToQuantum((unsigned short) color));\n              color=(pixel >> blue_shift) & blue_mask;\n              if (blue_mask != 0)\n                color=(color*65535UL)/blue_mask;\n              SetPixelBlue(q,ScaleShortToQuantum((unsigned short) color));\n              q++;\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n        break;\n      }\n      case PseudoClass:\n      {\n        /*\n          Convert X image to PseudoClass packets.\n        */\n        if (AcquireImageColormap(image,image->colors) == MagickFalse)\n          {\n            if (header.ncolors != 0)\n              colors=(XColor *) RelinquishMagickMemory(colors);\n            ximage->data=DestroyString(ximage->data);\n            ximage=(XImage *) RelinquishMagickMemory(ximage);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=ScaleShortToQuantum(colors[i].red);\n          image->colormap[i].green=ScaleShortToQuantum(colors[i].green);\n          image->colormap[i].blue=ScaleShortToQuantum(colors[i].blue);\n        }\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (PixelPacket *) NULL)\n            break;\n          indexes=GetAuthenticIndexQueue(image);\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            index=ConstrainColormapIndex(image,XGetPixel(ximage,(int) x,\n              (int) y));\n            SetPixelIndex(indexes+x,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n        break;\n      }\n    }\n  /*\n    Free image and colormap.\n  */\n  if (header.ncolors != 0)\n    colors=(XColor *) RelinquishMagickMemory(colors);\n  ximage->data=DestroyString(ximage->data);\n  ximage=(XImage *) RelinquishMagickMemory(ximage);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -187,6 +187,7 @@\n         count=ReadBlob(image,sz_XWDColor,(unsigned char *) &color);\n         if (count != sz_XWDColor)\n           {\n+            colors=(XColor *) RelinquishMagickMemory(colors);\n             ximage=(XImage *) RelinquishMagickMemory(ximage);\n             ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n           }\n@@ -217,6 +218,8 @@\n   length=(size_t) ximage->bytes_per_line*ximage->height;\n   if (CheckOverflowException(length,ximage->bytes_per_line,ximage->height))\n     {\n+      if (header.ncolors != 0)\n+        colors=(XColor *) RelinquishMagickMemory(colors);\n       ximage=(XImage *) RelinquishMagickMemory(ximage);\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     }\n@@ -229,6 +232,8 @@\n       length*=ximage->depth;\n       if (CheckOverflowException(length,extent,ximage->depth))\n         {\n+          if (header.ncolors != 0)\n+            colors=(XColor *) RelinquishMagickMemory(colors);\n           ximage=(XImage *) RelinquishMagickMemory(ximage);\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         }\n@@ -236,12 +241,16 @@\n   ximage->data=(char *) AcquireQuantumMemory(length,sizeof(*ximage->data));\n   if (ximage->data == (char *) NULL)\n     {\n+      if (header.ncolors != 0)\n+        colors=(XColor *) RelinquishMagickMemory(colors);\n       ximage=(XImage *) RelinquishMagickMemory(ximage);\n       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n   count=ReadBlob(image,length,(unsigned char *) ximage->data);\n   if (count != (ssize_t) length)\n     {\n+      if (header.ncolors != 0)\n+        colors=(XColor *) RelinquishMagickMemory(colors);\n       ximage->data=DestroyString(ximage->data);\n       ximage=(XImage *) RelinquishMagickMemory(ximage);\n       ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n@@ -255,6 +264,10 @@\n   status=SetImageExtent(image,image->columns,image->rows);\n   if (status == MagickFalse)\n     {\n+      if (header.ncolors != 0)\n+        colors=(XColor *) RelinquishMagickMemory(colors);\n+      ximage->data=DestroyString(ximage->data);\n+      ximage=(XImage *) RelinquishMagickMemory(ximage);\n       InheritException(exception,&image->exception);\n       return(DestroyImageList(image));\n     }\n@@ -376,6 +389,8 @@\n         */\n         if (AcquireImageColormap(image,image->colors) == MagickFalse)\n           {\n+            if (header.ncolors != 0)\n+              colors=(XColor *) RelinquishMagickMemory(colors);\n             ximage->data=DestroyString(ximage->data);\n             ximage=(XImage *) RelinquishMagickMemory(ximage);\n             ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            colors=(XColor *) RelinquishMagickMemory(colors);",
                "      if (header.ncolors != 0)",
                "        colors=(XColor *) RelinquishMagickMemory(colors);",
                "          if (header.ncolors != 0)",
                "            colors=(XColor *) RelinquishMagickMemory(colors);",
                "      if (header.ncolors != 0)",
                "        colors=(XColor *) RelinquishMagickMemory(colors);",
                "      if (header.ncolors != 0)",
                "        colors=(XColor *) RelinquishMagickMemory(colors);",
                "      if (header.ncolors != 0)",
                "        colors=(XColor *) RelinquishMagickMemory(colors);",
                "      ximage->data=DestroyString(ximage->data);",
                "      ximage=(XImage *) RelinquishMagickMemory(ximage);",
                "            if (header.ncolors != 0)",
                "              colors=(XColor *) RelinquishMagickMemory(colors);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8353",
        "func_name": "ImageMagick/ReadPICTImage",
        "description": "In ImageMagick 7.0.5-5, the ReadPICTImage function in pict.c allows attackers to cause a denial of service (memory leak) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/a537c728561b7eedb17ee50c615e11dec005213a",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/454",
        "commit_text": "",
        "func_before": "static Image *ReadPICTImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    geometry[MagickPathExtent],\n    header_ole[4];\n\n  Image\n    *image;\n\n  int\n    c,\n    code;\n\n  MagickBooleanType\n    jpeg,\n    status;\n\n  PICTRectangle\n    frame;\n\n  PICTPixmap\n    pixmap;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    extent,\n    length;\n\n  ssize_t\n    count,\n    flags,\n    j,\n    version,\n    y;\n\n  StringInfo\n    *profile;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read PICT header.\n  */\n  pixmap.bits_per_pixel=0;\n  pixmap.component_count=0;\n  /*\n    Skip header : 512 for standard PICT and 4, ie \"PICT\" for OLE2.\n  */\n  header_ole[0]=ReadBlobByte(image);\n  header_ole[1]=ReadBlobByte(image);\n  header_ole[2]=ReadBlobByte(image);\n  header_ole[3]=ReadBlobByte(image);\n  if (!((header_ole[0] == 0x50) && (header_ole[1] == 0x49) &&\n      (header_ole[2] == 0x43) && (header_ole[3] == 0x54 )))\n    for (i=0; i < 508; i++)\n      if (ReadBlobByte(image) == EOF)\n        break;\n  (void) ReadBlobMSBShort(image);  /* skip picture size */\n  if (ReadRectangle(image,&frame) == MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  while ((c=ReadBlobByte(image)) == 0) ;\n  if (c != 0x11)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  version=ReadBlobByte(image);\n  if (version == 2)\n    {\n      c=ReadBlobByte(image);\n      if (c != 0xff)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  else\n    if (version != 1)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((frame.left < 0) || (frame.right < 0) || (frame.top < 0) ||\n      (frame.bottom < 0) || (frame.left >= frame.right) ||\n      (frame.top >= frame.bottom))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Create black canvas.\n  */\n  flags=0;\n  image->depth=8;\n  image->columns=1UL*(frame.right-frame.left);\n  image->rows=1UL*(frame.bottom-frame.top);\n  image->resolution.x=DefaultResolution;\n  image->resolution.y=DefaultResolution;\n  image->units=UndefinedResolution;\n  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n    if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Interpret PICT opcodes.\n  */\n  jpeg=MagickFalse;\n  for (code=0; EOFBlob(image) == MagickFalse; )\n  {\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if ((version == 1) || ((TellBlob(image) % 2) != 0))\n      code=ReadBlobByte(image);\n    if (version == 2)\n      code=ReadBlobMSBSignedShort(image);\n    if (code < 0)\n      break;\n    if (code > 0xa1)\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"%04X:\",code);\n      }\n    else\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  %04X %s: %s\",code,codes[code].name,codes[code].description);\n        switch (code)\n        {\n          case 0x01:\n          {\n            /*\n              Clipping rectangle.\n            */\n            length=ReadBlobMSBShort(image);\n            if (length != 0x000a)\n              {\n                for (i=0; i < (ssize_t) (length-2); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n                break;\n              }\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            if (((frame.left & 0x8000) != 0) || ((frame.top & 0x8000) != 0))\n              break;\n            image->columns=1UL*(frame.right-frame.left);\n            image->rows=1UL*(frame.bottom-frame.top);\n            status=SetImageExtent(image,image->columns,image->rows,exception);\n            if (status == MagickFalse)\n              return(DestroyImageList(image));\n            (void) SetImageBackgroundColor(image,exception);\n            break;\n          }\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          {\n            ssize_t\n              pattern;\n\n            size_t\n              height,\n              width;\n\n            /*\n              Skip pattern definition.\n            */\n            pattern=1L*ReadBlobMSBShort(image);\n            for (i=0; i < 8; i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            if (pattern == 2)\n              {\n                for (i=0; i < 5; i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n                break;\n              }\n            if (pattern != 1)\n              ThrowReaderException(CorruptImageError,\"UnknownPatternType\");\n            length=ReadBlobMSBShort(image);\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            ReadPixmap(pixmap);\n            image->depth=1UL*pixmap.component_size;\n            image->resolution.x=1.0*pixmap.horizontal_resolution;\n            image->resolution.y=1.0*pixmap.vertical_resolution;\n            image->units=PixelsPerInchResolution;\n            (void) ReadBlobMSBLong(image);\n            flags=1L*ReadBlobMSBShort(image);\n            length=ReadBlobMSBShort(image);\n            for (i=0; i <= (ssize_t) length; i++)\n              (void) ReadBlobMSBLong(image);\n            width=1UL*(frame.bottom-frame.top);\n            height=1UL*(frame.right-frame.left);\n            if (pixmap.bits_per_pixel <= 8)\n              length&=0x7fff;\n            if (pixmap.bits_per_pixel == 16)\n              width<<=1;\n            if (length == 0)\n              length=width;\n            if (length < 8)\n              {\n                for (i=0; i < (ssize_t) (length*height); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n              }\n            else\n              for (j=0; j < (int) height; j++)\n                if (length > 200)\n                  {\n                    for (j=0; j < (ssize_t) ReadBlobMSBShort(image); j++)\n                      if (ReadBlobByte(image) == EOF)\n                        break;\n                  }\n                else\n                  for (j=0; j < (ssize_t) ReadBlobByte(image); j++)\n                    if (ReadBlobByte(image) == EOF)\n                      break;\n            break;\n          }\n          case 0x1b:\n          {\n            /*\n              Initialize image background color.\n            */\n            image->background_color.red=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            image->background_color.green=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            image->background_color.blue=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            break;\n          }\n          case 0x70:\n          case 0x71:\n          case 0x72:\n          case 0x73:\n          case 0x74:\n          case 0x75:\n          case 0x76:\n          case 0x77:\n          {\n            /*\n              Skip polygon or region.\n            */\n            length=ReadBlobMSBShort(image);\n            for (i=0; i < (ssize_t) (length-2); i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            break;\n          }\n          case 0x90:\n          case 0x91:\n          case 0x98:\n          case 0x99:\n          case 0x9a:\n          case 0x9b:\n          {\n            Image\n              *tile_image;\n\n            PICTRectangle\n              source,\n              destination;\n\n            register unsigned char\n              *p;\n\n            size_t\n              j;\n\n            ssize_t\n              bytes_per_line;\n\n            unsigned char\n              *pixels;\n\n            /*\n              Pixmap clipped by a rectangle.\n            */\n            bytes_per_line=0;\n            if ((code != 0x9a) && (code != 0x9b))\n              bytes_per_line=1L*ReadBlobMSBShort(image);\n            else\n              {\n                (void) ReadBlobMSBShort(image);\n                (void) ReadBlobMSBShort(image);\n                (void) ReadBlobMSBShort(image);\n              }\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            /*\n              Initialize tile image.\n            */\n            tile_image=CloneImage(image,1UL*(frame.right-frame.left),\n              1UL*(frame.bottom-frame.top),MagickTrue,exception);\n            if (tile_image == (Image *) NULL)\n              return((Image *) NULL);\n            if ((code == 0x9a) || (code == 0x9b) ||\n                ((bytes_per_line & 0x8000) != 0))\n              {\n                ReadPixmap(pixmap);\n                tile_image->depth=1UL*pixmap.component_size;\n                tile_image->alpha_trait=pixmap.component_count == 4 ?\n                  BlendPixelTrait : UndefinedPixelTrait;\n                tile_image->resolution.x=(double) pixmap.horizontal_resolution;\n                tile_image->resolution.y=(double) pixmap.vertical_resolution;\n                tile_image->units=PixelsPerInchResolution;\n                if (tile_image->alpha_trait != UndefinedPixelTrait)\n                  image->alpha_trait=tile_image->alpha_trait;\n              }\n            if ((code != 0x9a) && (code != 0x9b))\n              {\n                /*\n                  Initialize colormap.\n                */\n                tile_image->colors=2;\n                if ((bytes_per_line & 0x8000) != 0)\n                  {\n                    (void) ReadBlobMSBLong(image);\n                    flags=1L*ReadBlobMSBShort(image);\n                    tile_image->colors=1UL*ReadBlobMSBShort(image)+1;\n                  }\n                status=AcquireImageColormap(tile_image,tile_image->colors,\n                  exception);\n                if (status == MagickFalse)\n                  {\n                    tile_image=DestroyImage(tile_image);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                if ((bytes_per_line & 0x8000) != 0)\n                  {\n                    for (i=0; i < (ssize_t) tile_image->colors; i++)\n                    {\n                      j=ReadBlobMSBShort(image) % tile_image->colors;\n                      if ((flags & 0x8000) != 0)\n                        j=(size_t) i;\n                      tile_image->colormap[j].red=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                      tile_image->colormap[j].green=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                      tile_image->colormap[j].blue=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                    }\n                  }\n                else\n                  {\n                    for (i=0; i < (ssize_t) tile_image->colors; i++)\n                    {\n                      tile_image->colormap[i].red=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].red);\n                      tile_image->colormap[i].green=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].green);\n                      tile_image->colormap[i].blue=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].blue);\n                    }\n                  }\n              }\n            if (ReadRectangle(image,&source) == MagickFalse)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            if (ReadRectangle(image,&destination) == MagickFalse)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            (void) ReadBlobMSBShort(image);\n            if ((code == 0x91) || (code == 0x99) || (code == 0x9b))\n              {\n                /*\n                  Skip region.\n                */\n                length=ReadBlobMSBShort(image);\n                for (i=0; i < (ssize_t) (length-2); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n              }\n            if ((code != 0x9a) && (code != 0x9b) &&\n                (bytes_per_line & 0x8000) == 0)\n              pixels=DecodeImage(image,tile_image,1UL*bytes_per_line,1,&extent,\n                exception);\n            else\n              pixels=DecodeImage(image,tile_image,1UL*bytes_per_line,1U*\n                pixmap.bits_per_pixel,&extent,exception);\n            if (pixels == (unsigned char *) NULL)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n            /*\n              Convert PICT tile image to pixel packets.\n            */\n            p=pixels;\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              if (p > (pixels+extent+image->columns))\n                ThrowReaderException(CorruptImageError,\"NotEnoughPixelData\");\n              q=QueueAuthenticPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                if (tile_image->storage_class == PseudoClass)\n                  {\n                    index=ConstrainColormapIndex(tile_image,*p,exception);\n                    SetPixelIndex(tile_image,index,q);\n                    SetPixelRed(tile_image,\n                      tile_image->colormap[(ssize_t) index].red,q);\n                    SetPixelGreen(tile_image,\n                      tile_image->colormap[(ssize_t) index].green,q);\n                    SetPixelBlue(tile_image,\n                      tile_image->colormap[(ssize_t) index].blue,q);\n                  }\n                else\n                  {\n                    if (pixmap.bits_per_pixel == 16)\n                      {\n                        i=(*p++);\n                        j=(*p);\n                        SetPixelRed(tile_image,ScaleCharToQuantum(\n                          (unsigned char) ((i & 0x7c) << 1)),q);\n                        SetPixelGreen(tile_image,ScaleCharToQuantum(\n                          (unsigned char) (((i & 0x03) << 6) |\n                          ((j & 0xe0) >> 2))),q);\n                        SetPixelBlue(tile_image,ScaleCharToQuantum(\n                          (unsigned char) ((j & 0x1f) << 3)),q);\n                      }\n                    else\n                      if (tile_image->alpha_trait == UndefinedPixelTrait)\n                        {\n                          if (p > (pixels+extent+2*image->columns))\n                            ThrowReaderException(CorruptImageError,\n                              \"NotEnoughPixelData\");\n                          SetPixelRed(tile_image,ScaleCharToQuantum(*p),q);\n                          SetPixelGreen(tile_image,ScaleCharToQuantum(\n                            *(p+tile_image->columns)),q);\n                          SetPixelBlue(tile_image,ScaleCharToQuantum(\n                            *(p+2*tile_image->columns)),q);\n                        }\n                      else\n                        {\n                          if (p > (pixels+extent+3*image->columns))\n                            ThrowReaderException(CorruptImageError,\n                              \"NotEnoughPixelData\");\n                          SetPixelAlpha(tile_image,ScaleCharToQuantum(*p),q);\n                          SetPixelRed(tile_image,ScaleCharToQuantum(\n                            *(p+tile_image->columns)),q);\n                          SetPixelGreen(tile_image,ScaleCharToQuantum(\n                            *(p+2*tile_image->columns)),q);\n                          SetPixelBlue(tile_image,ScaleCharToQuantum(\n                            *(p+3*tile_image->columns)),q);\n                        }\n                  }\n                p++;\n                q+=GetPixelChannels(tile_image);\n              }\n              if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n                break;\n              if ((tile_image->storage_class == DirectClass) &&\n                  (pixmap.bits_per_pixel != 16))\n                {\n                  p+=(pixmap.component_count-1)*tile_image->columns;\n                  if (p < pixels)\n                    break;\n                }\n              status=SetImageProgress(image,LoadImageTag,y,tile_image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            if (jpeg == MagickFalse)\n              if ((code == 0x9a) || (code == 0x9b) ||\n                  ((bytes_per_line & 0x8000) != 0))\n                (void) CompositeImage(image,tile_image,CopyCompositeOp,\n                  MagickTrue,destination.left,destination.top,exception);\n            tile_image=DestroyImage(tile_image);\n            break;\n          }\n          case 0xa1:\n          {\n            unsigned char\n              *info;\n\n            size_t\n              type;\n\n            /*\n              Comment.\n            */\n            type=ReadBlobMSBShort(image);\n            length=ReadBlobMSBShort(image);\n            if (length == 0)\n              break;\n            (void) ReadBlobMSBLong(image);\n            length-=4;\n            if (length == 0)\n              break;\n            info=(unsigned char *) AcquireQuantumMemory(length,sizeof(*info));\n            if (info == (unsigned char *) NULL)\n              break;\n            count=ReadBlob(image,length,info);\n            if (count != (ssize_t) length)\n              ThrowReaderException(ResourceLimitError,\"UnableToReadImageData\");\n            switch (type)\n            {\n              case 0xe0:\n              {\n                profile=BlobToStringInfo((const void *) NULL,length);\n                SetStringInfoDatum(profile,info);\n                status=SetImageProfile(image,\"icc\",profile,exception);\n                profile=DestroyStringInfo(profile);\n                if (status == MagickFalse)\n                  ThrowReaderException(ResourceLimitError,\n                    \"MemoryAllocationFailed\");\n                break;\n              }\n              case 0x1f2:\n              {\n                profile=BlobToStringInfo((const void *) NULL,length);\n                SetStringInfoDatum(profile,info);\n                status=SetImageProfile(image,\"iptc\",profile,exception);\n                if (status == MagickFalse)\n                  ThrowReaderException(ResourceLimitError,\n                    \"MemoryAllocationFailed\");\n                profile=DestroyStringInfo(profile);\n                break;\n              }\n              default:\n                break;\n            }\n            info=(unsigned char *) RelinquishMagickMemory(info);\n            break;\n          }\n          default:\n          {\n            /*\n              Skip to next op code.\n            */\n            if (codes[code].length == -1)\n              (void) ReadBlobMSBShort(image);\n            else\n              for (i=0; i < (ssize_t) codes[code].length; i++)\n                if (ReadBlobByte(image) == EOF)\n                  break;\n          }\n        }\n      }\n    if (code == 0xc00)\n      {\n        /*\n          Skip header.\n        */\n        for (i=0; i < 24; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n    if (((code >= 0xb0) && (code <= 0xcf)) ||\n        ((code >= 0x8000) && (code <= 0x80ff)))\n      continue;\n    if (code == 0x8200)\n      {\n        FILE\n          *file;\n\n        Image\n          *tile_image;\n\n        ImageInfo\n          *read_info;\n\n        int\n          unique_file;\n\n        /*\n          Embedded JPEG.\n        */\n        jpeg=MagickTrue;\n        read_info=CloneImageInfo(image_info);\n        SetImageInfoBlob(read_info,(void *) NULL,0);\n        file=(FILE *) NULL;\n        unique_file=AcquireUniqueFileResource(read_info->filename);\n        if (unique_file != -1)\n          file=fdopen(unique_file,\"wb\");\n        if ((unique_file == -1) || (file == (FILE *) NULL))\n          {\n            (void) RelinquishUniqueFileResource(read_info->filename);\n            (void) CopyMagickString(image->filename,read_info->filename,\n              MagickPathExtent);\n            ThrowFileException(exception,FileOpenError,\n              \"UnableToCreateTemporaryFile\",image->filename);\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        length=ReadBlobMSBLong(image);\n        if (length > 154)\n          {\n            for (i=0; i < 6; i++)\n              (void) ReadBlobMSBLong(image);\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              {\n                (void) fclose(file);\n                (void) RelinquishUniqueFileResource(read_info->filename);\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              }\n            for (i=0; i < 122; i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            for (i=0; i < (ssize_t) (length-154); i++)\n            {\n              c=ReadBlobByte(image);\n              if (c == EOF)\n                break;\n              (void) fputc(c,file);\n            }\n          }\n        (void) fclose(file);\n        (void) close(unique_file);\n        tile_image=ReadImage(read_info,exception);\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        read_info=DestroyImageInfo(read_info);\n        if (tile_image == (Image *) NULL)\n          continue;\n        (void) FormatLocaleString(geometry,MagickPathExtent,\"%.20gx%.20g\",\n          (double) MagickMax(image->columns,tile_image->columns),\n          (double) MagickMax(image->rows,tile_image->rows));\n        (void) SetImageExtent(image,\n          MagickMax(image->columns,tile_image->columns),\n          MagickMax(image->rows,tile_image->rows),exception);\n        (void) TransformImageColorspace(image,tile_image->colorspace,exception);\n        (void) CompositeImage(image,tile_image,CopyCompositeOp,MagickTrue,\n          frame.left,frame.right,exception);\n        image->compression=tile_image->compression;\n        tile_image=DestroyImage(tile_image);\n        continue;\n      }\n    if ((code == 0xff) || (code == 0xffff))\n      break;\n    if (((code >= 0xd0) && (code <= 0xfe)) ||\n        ((code >= 0x8100) && (code <= 0xffff)))\n      {\n        /*\n          Skip reserved.\n        */\n        length=ReadBlobMSBShort(image);\n        for (i=0; i < (ssize_t) length; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n    if ((code >= 0x100) && (code <= 0x7fff))\n      {\n        /*\n          Skip reserved.\n        */\n        length=(size_t) ((code >> 7) & 0xff);\n        for (i=0; i < (ssize_t) length; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadPICTImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    geometry[MagickPathExtent],\n    header_ole[4];\n\n  Image\n    *image;\n\n  int\n    c,\n    code;\n\n  MagickBooleanType\n    jpeg,\n    status;\n\n  PICTRectangle\n    frame;\n\n  PICTPixmap\n    pixmap;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    extent,\n    length;\n\n  ssize_t\n    count,\n    flags,\n    j,\n    version,\n    y;\n\n  StringInfo\n    *profile;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read PICT header.\n  */\n  pixmap.bits_per_pixel=0;\n  pixmap.component_count=0;\n  /*\n    Skip header : 512 for standard PICT and 4, ie \"PICT\" for OLE2.\n  */\n  header_ole[0]=ReadBlobByte(image);\n  header_ole[1]=ReadBlobByte(image);\n  header_ole[2]=ReadBlobByte(image);\n  header_ole[3]=ReadBlobByte(image);\n  if (!((header_ole[0] == 0x50) && (header_ole[1] == 0x49) &&\n      (header_ole[2] == 0x43) && (header_ole[3] == 0x54 )))\n    for (i=0; i < 508; i++)\n      if (ReadBlobByte(image) == EOF)\n        break;\n  (void) ReadBlobMSBShort(image);  /* skip picture size */\n  if (ReadRectangle(image,&frame) == MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  while ((c=ReadBlobByte(image)) == 0) ;\n  if (c != 0x11)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  version=ReadBlobByte(image);\n  if (version == 2)\n    {\n      c=ReadBlobByte(image);\n      if (c != 0xff)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  else\n    if (version != 1)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((frame.left < 0) || (frame.right < 0) || (frame.top < 0) ||\n      (frame.bottom < 0) || (frame.left >= frame.right) ||\n      (frame.top >= frame.bottom))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Create black canvas.\n  */\n  flags=0;\n  image->depth=8;\n  image->columns=1UL*(frame.right-frame.left);\n  image->rows=1UL*(frame.bottom-frame.top);\n  image->resolution.x=DefaultResolution;\n  image->resolution.y=DefaultResolution;\n  image->units=UndefinedResolution;\n  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n    if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Interpret PICT opcodes.\n  */\n  jpeg=MagickFalse;\n  for (code=0; EOFBlob(image) == MagickFalse; )\n  {\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if ((version == 1) || ((TellBlob(image) % 2) != 0))\n      code=ReadBlobByte(image);\n    if (version == 2)\n      code=ReadBlobMSBSignedShort(image);\n    if (code < 0)\n      break;\n    if (code > 0xa1)\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"%04X:\",code);\n      }\n    else\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  %04X %s: %s\",code,codes[code].name,codes[code].description);\n        switch (code)\n        {\n          case 0x01:\n          {\n            /*\n              Clipping rectangle.\n            */\n            length=ReadBlobMSBShort(image);\n            if (length != 0x000a)\n              {\n                for (i=0; i < (ssize_t) (length-2); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n                break;\n              }\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            if (((frame.left & 0x8000) != 0) || ((frame.top & 0x8000) != 0))\n              break;\n            image->columns=1UL*(frame.right-frame.left);\n            image->rows=1UL*(frame.bottom-frame.top);\n            status=SetImageExtent(image,image->columns,image->rows,exception);\n            if (status == MagickFalse)\n              return(DestroyImageList(image));\n            (void) SetImageBackgroundColor(image,exception);\n            break;\n          }\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          {\n            ssize_t\n              pattern;\n\n            size_t\n              height,\n              width;\n\n            /*\n              Skip pattern definition.\n            */\n            pattern=1L*ReadBlobMSBShort(image);\n            for (i=0; i < 8; i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            if (pattern == 2)\n              {\n                for (i=0; i < 5; i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n                break;\n              }\n            if (pattern != 1)\n              ThrowReaderException(CorruptImageError,\"UnknownPatternType\");\n            length=ReadBlobMSBShort(image);\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            ReadPixmap(pixmap);\n            image->depth=1UL*pixmap.component_size;\n            image->resolution.x=1.0*pixmap.horizontal_resolution;\n            image->resolution.y=1.0*pixmap.vertical_resolution;\n            image->units=PixelsPerInchResolution;\n            (void) ReadBlobMSBLong(image);\n            flags=1L*ReadBlobMSBShort(image);\n            length=ReadBlobMSBShort(image);\n            for (i=0; i <= (ssize_t) length; i++)\n              (void) ReadBlobMSBLong(image);\n            width=1UL*(frame.bottom-frame.top);\n            height=1UL*(frame.right-frame.left);\n            if (pixmap.bits_per_pixel <= 8)\n              length&=0x7fff;\n            if (pixmap.bits_per_pixel == 16)\n              width<<=1;\n            if (length == 0)\n              length=width;\n            if (length < 8)\n              {\n                for (i=0; i < (ssize_t) (length*height); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n              }\n            else\n              for (j=0; j < (int) height; j++)\n                if (length > 200)\n                  {\n                    for (j=0; j < (ssize_t) ReadBlobMSBShort(image); j++)\n                      if (ReadBlobByte(image) == EOF)\n                        break;\n                  }\n                else\n                  for (j=0; j < (ssize_t) ReadBlobByte(image); j++)\n                    if (ReadBlobByte(image) == EOF)\n                      break;\n            break;\n          }\n          case 0x1b:\n          {\n            /*\n              Initialize image background color.\n            */\n            image->background_color.red=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            image->background_color.green=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            image->background_color.blue=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            break;\n          }\n          case 0x70:\n          case 0x71:\n          case 0x72:\n          case 0x73:\n          case 0x74:\n          case 0x75:\n          case 0x76:\n          case 0x77:\n          {\n            /*\n              Skip polygon or region.\n            */\n            length=ReadBlobMSBShort(image);\n            for (i=0; i < (ssize_t) (length-2); i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            break;\n          }\n          case 0x90:\n          case 0x91:\n          case 0x98:\n          case 0x99:\n          case 0x9a:\n          case 0x9b:\n          {\n            Image\n              *tile_image;\n\n            PICTRectangle\n              source,\n              destination;\n\n            register unsigned char\n              *p;\n\n            size_t\n              j;\n\n            ssize_t\n              bytes_per_line;\n\n            unsigned char\n              *pixels;\n\n            /*\n              Pixmap clipped by a rectangle.\n            */\n            bytes_per_line=0;\n            if ((code != 0x9a) && (code != 0x9b))\n              bytes_per_line=1L*ReadBlobMSBShort(image);\n            else\n              {\n                (void) ReadBlobMSBShort(image);\n                (void) ReadBlobMSBShort(image);\n                (void) ReadBlobMSBShort(image);\n              }\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            /*\n              Initialize tile image.\n            */\n            tile_image=CloneImage(image,1UL*(frame.right-frame.left),\n              1UL*(frame.bottom-frame.top),MagickTrue,exception);\n            if (tile_image == (Image *) NULL)\n              return((Image *) NULL);\n            if ((code == 0x9a) || (code == 0x9b) ||\n                ((bytes_per_line & 0x8000) != 0))\n              {\n                ReadPixmap(pixmap);\n                tile_image->depth=1UL*pixmap.component_size;\n                tile_image->alpha_trait=pixmap.component_count == 4 ?\n                  BlendPixelTrait : UndefinedPixelTrait;\n                tile_image->resolution.x=(double) pixmap.horizontal_resolution;\n                tile_image->resolution.y=(double) pixmap.vertical_resolution;\n                tile_image->units=PixelsPerInchResolution;\n                if (tile_image->alpha_trait != UndefinedPixelTrait)\n                  image->alpha_trait=tile_image->alpha_trait;\n              }\n            if ((code != 0x9a) && (code != 0x9b))\n              {\n                /*\n                  Initialize colormap.\n                */\n                tile_image->colors=2;\n                if ((bytes_per_line & 0x8000) != 0)\n                  {\n                    (void) ReadBlobMSBLong(image);\n                    flags=1L*ReadBlobMSBShort(image);\n                    tile_image->colors=1UL*ReadBlobMSBShort(image)+1;\n                  }\n                status=AcquireImageColormap(tile_image,tile_image->colors,\n                  exception);\n                if (status == MagickFalse)\n                  {\n                    tile_image=DestroyImage(tile_image);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                if ((bytes_per_line & 0x8000) != 0)\n                  {\n                    for (i=0; i < (ssize_t) tile_image->colors; i++)\n                    {\n                      j=ReadBlobMSBShort(image) % tile_image->colors;\n                      if ((flags & 0x8000) != 0)\n                        j=(size_t) i;\n                      tile_image->colormap[j].red=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                      tile_image->colormap[j].green=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                      tile_image->colormap[j].blue=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                    }\n                  }\n                else\n                  {\n                    for (i=0; i < (ssize_t) tile_image->colors; i++)\n                    {\n                      tile_image->colormap[i].red=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].red);\n                      tile_image->colormap[i].green=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].green);\n                      tile_image->colormap[i].blue=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].blue);\n                    }\n                  }\n              }\n            if (ReadRectangle(image,&source) == MagickFalse)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              }\n            if (ReadRectangle(image,&destination) == MagickFalse)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              }\n            (void) ReadBlobMSBShort(image);\n            if ((code == 0x91) || (code == 0x99) || (code == 0x9b))\n              {\n                /*\n                  Skip region.\n                */\n                length=ReadBlobMSBShort(image);\n                for (i=0; i < (ssize_t) (length-2); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n              }\n            if ((code != 0x9a) && (code != 0x9b) &&\n                (bytes_per_line & 0x8000) == 0)\n              pixels=DecodeImage(image,tile_image,1UL*bytes_per_line,1,&extent,\n                exception);\n            else\n              pixels=DecodeImage(image,tile_image,1UL*bytes_per_line,1U*\n                pixmap.bits_per_pixel,&extent,exception);\n            if (pixels == (unsigned char *) NULL)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n            /*\n              Convert PICT tile image to pixel packets.\n            */\n            p=pixels;\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              if (p > (pixels+extent+image->columns))\n                {\n                  tile_image=DestroyImage(tile_image);\n                  ThrowReaderException(CorruptImageError,\"NotEnoughPixelData\");\n                }\n              q=QueueAuthenticPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                if (tile_image->storage_class == PseudoClass)\n                  {\n                    index=ConstrainColormapIndex(tile_image,*p,exception);\n                    SetPixelIndex(tile_image,index,q);\n                    SetPixelRed(tile_image,\n                      tile_image->colormap[(ssize_t) index].red,q);\n                    SetPixelGreen(tile_image,\n                      tile_image->colormap[(ssize_t) index].green,q);\n                    SetPixelBlue(tile_image,\n                      tile_image->colormap[(ssize_t) index].blue,q);\n                  }\n                else\n                  {\n                    if (pixmap.bits_per_pixel == 16)\n                      {\n                        i=(*p++);\n                        j=(*p);\n                        SetPixelRed(tile_image,ScaleCharToQuantum(\n                          (unsigned char) ((i & 0x7c) << 1)),q);\n                        SetPixelGreen(tile_image,ScaleCharToQuantum(\n                          (unsigned char) (((i & 0x03) << 6) |\n                          ((j & 0xe0) >> 2))),q);\n                        SetPixelBlue(tile_image,ScaleCharToQuantum(\n                          (unsigned char) ((j & 0x1f) << 3)),q);\n                      }\n                    else\n                      if (tile_image->alpha_trait == UndefinedPixelTrait)\n                        {\n                          if (p > (pixels+extent+2*image->columns))\n                            {\n                              tile_image=DestroyImage(tile_image);\n                              ThrowReaderException(CorruptImageError,\n                                \"NotEnoughPixelData\");\n                            }\n                          SetPixelRed(tile_image,ScaleCharToQuantum(*p),q);\n                          SetPixelGreen(tile_image,ScaleCharToQuantum(\n                            *(p+tile_image->columns)),q);\n                          SetPixelBlue(tile_image,ScaleCharToQuantum(\n                            *(p+2*tile_image->columns)),q);\n                        }\n                      else\n                        {\n                          if (p > (pixels+extent+3*image->columns))\n                            {\n                              tile_image=DestroyImage(tile_image);\n                              ThrowReaderException(CorruptImageError,\n                                \"NotEnoughPixelData\");\n                            }\n                          SetPixelAlpha(tile_image,ScaleCharToQuantum(*p),q);\n                          SetPixelRed(tile_image,ScaleCharToQuantum(\n                            *(p+tile_image->columns)),q);\n                          SetPixelGreen(tile_image,ScaleCharToQuantum(\n                            *(p+2*tile_image->columns)),q);\n                          SetPixelBlue(tile_image,ScaleCharToQuantum(\n                            *(p+3*tile_image->columns)),q);\n                        }\n                  }\n                p++;\n                q+=GetPixelChannels(tile_image);\n              }\n              if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n                break;\n              if ((tile_image->storage_class == DirectClass) &&\n                  (pixmap.bits_per_pixel != 16))\n                {\n                  p+=(pixmap.component_count-1)*tile_image->columns;\n                  if (p < pixels)\n                    break;\n                }\n              status=SetImageProgress(image,LoadImageTag,y,tile_image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            if (jpeg == MagickFalse)\n              if ((code == 0x9a) || (code == 0x9b) ||\n                  ((bytes_per_line & 0x8000) != 0))\n                (void) CompositeImage(image,tile_image,CopyCompositeOp,\n                  MagickTrue,destination.left,destination.top,exception);\n            tile_image=DestroyImage(tile_image);\n            break;\n          }\n          case 0xa1:\n          {\n            unsigned char\n              *info;\n\n            size_t\n              type;\n\n            /*\n              Comment.\n            */\n            type=ReadBlobMSBShort(image);\n            length=ReadBlobMSBShort(image);\n            if (length == 0)\n              break;\n            (void) ReadBlobMSBLong(image);\n            length-=4;\n            if (length == 0)\n              break;\n            info=(unsigned char *) AcquireQuantumMemory(length,sizeof(*info));\n            if (info == (unsigned char *) NULL)\n              break;\n            count=ReadBlob(image,length,info);\n            if (count != (ssize_t) length)\n              ThrowReaderException(ResourceLimitError,\"UnableToReadImageData\");\n            switch (type)\n            {\n              case 0xe0:\n              {\n                profile=BlobToStringInfo((const void *) NULL,length);\n                SetStringInfoDatum(profile,info);\n                status=SetImageProfile(image,\"icc\",profile,exception);\n                profile=DestroyStringInfo(profile);\n                if (status == MagickFalse)\n                  {\n                    info=(unsigned char *) RelinquishMagickMemory(info);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                break;\n              }\n              case 0x1f2:\n              {\n                profile=BlobToStringInfo((const void *) NULL,length);\n                SetStringInfoDatum(profile,info);\n                status=SetImageProfile(image,\"iptc\",profile,exception);\n                if (status == MagickFalse)\n                  {\n                    info=(unsigned char *) RelinquishMagickMemory(info);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                profile=DestroyStringInfo(profile);\n                break;\n              }\n              default:\n                break;\n            }\n            info=(unsigned char *) RelinquishMagickMemory(info);\n            break;\n          }\n          default:\n          {\n            /*\n              Skip to next op code.\n            */\n            if (codes[code].length == -1)\n              (void) ReadBlobMSBShort(image);\n            else\n              for (i=0; i < (ssize_t) codes[code].length; i++)\n                if (ReadBlobByte(image) == EOF)\n                  break;\n          }\n        }\n      }\n    if (code == 0xc00)\n      {\n        /*\n          Skip header.\n        */\n        for (i=0; i < 24; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n    if (((code >= 0xb0) && (code <= 0xcf)) ||\n        ((code >= 0x8000) && (code <= 0x80ff)))\n      continue;\n    if (code == 0x8200)\n      {\n        FILE\n          *file;\n\n        Image\n          *tile_image;\n\n        ImageInfo\n          *read_info;\n\n        int\n          unique_file;\n\n        /*\n          Embedded JPEG.\n        */\n        jpeg=MagickTrue;\n        read_info=CloneImageInfo(image_info);\n        SetImageInfoBlob(read_info,(void *) NULL,0);\n        file=(FILE *) NULL;\n        unique_file=AcquireUniqueFileResource(read_info->filename);\n        if (unique_file != -1)\n          file=fdopen(unique_file,\"wb\");\n        if ((unique_file == -1) || (file == (FILE *) NULL))\n          {\n            (void) RelinquishUniqueFileResource(read_info->filename);\n            (void) CopyMagickString(image->filename,read_info->filename,\n              MagickPathExtent);\n            ThrowFileException(exception,FileOpenError,\n              \"UnableToCreateTemporaryFile\",image->filename);\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        length=ReadBlobMSBLong(image);\n        if (length > 154)\n          {\n            for (i=0; i < 6; i++)\n              (void) ReadBlobMSBLong(image);\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              {\n                (void) fclose(file);\n                (void) RelinquishUniqueFileResource(read_info->filename);\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              }\n            for (i=0; i < 122; i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            for (i=0; i < (ssize_t) (length-154); i++)\n            {\n              c=ReadBlobByte(image);\n              if (c == EOF)\n                break;\n              (void) fputc(c,file);\n            }\n          }\n        (void) fclose(file);\n        (void) close(unique_file);\n        tile_image=ReadImage(read_info,exception);\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        read_info=DestroyImageInfo(read_info);\n        if (tile_image == (Image *) NULL)\n          continue;\n        (void) FormatLocaleString(geometry,MagickPathExtent,\"%.20gx%.20g\",\n          (double) MagickMax(image->columns,tile_image->columns),\n          (double) MagickMax(image->rows,tile_image->rows));\n        (void) SetImageExtent(image,\n          MagickMax(image->columns,tile_image->columns),\n          MagickMax(image->rows,tile_image->rows),exception);\n        (void) TransformImageColorspace(image,tile_image->colorspace,exception);\n        (void) CompositeImage(image,tile_image,CopyCompositeOp,MagickTrue,\n          frame.left,frame.right,exception);\n        image->compression=tile_image->compression;\n        tile_image=DestroyImage(tile_image);\n        continue;\n      }\n    if ((code == 0xff) || (code == 0xffff))\n      break;\n    if (((code >= 0xd0) && (code <= 0xfe)) ||\n        ((code >= 0x8100) && (code <= 0xffff)))\n      {\n        /*\n          Skip reserved.\n        */\n        length=ReadBlobMSBShort(image);\n        for (i=0; i < (ssize_t) length; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n    if ((code >= 0x100) && (code <= 0x7fff))\n      {\n        /*\n          Skip reserved.\n        */\n        length=(size_t) ((code >> 7) & 0xff);\n        for (i=0; i < (ssize_t) length; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -379,9 +379,15 @@\n                   }\n               }\n             if (ReadRectangle(image,&source) == MagickFalse)\n-              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+              {\n+                tile_image=DestroyImage(tile_image);\n+                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+              }\n             if (ReadRectangle(image,&destination) == MagickFalse)\n-              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+              {\n+                tile_image=DestroyImage(tile_image);\n+                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+              }\n             (void) ReadBlobMSBShort(image);\n             if ((code == 0x91) || (code == 0x99) || (code == 0x9b))\n               {\n@@ -413,7 +419,10 @@\n             for (y=0; y < (ssize_t) tile_image->rows; y++)\n             {\n               if (p > (pixels+extent+image->columns))\n-                ThrowReaderException(CorruptImageError,\"NotEnoughPixelData\");\n+                {\n+                  tile_image=DestroyImage(tile_image);\n+                  ThrowReaderException(CorruptImageError,\"NotEnoughPixelData\");\n+                }\n               q=QueueAuthenticPixels(tile_image,0,y,tile_image->columns,1,\n                 exception);\n               if (q == (Quantum *) NULL)\n@@ -449,8 +458,11 @@\n                       if (tile_image->alpha_trait == UndefinedPixelTrait)\n                         {\n                           if (p > (pixels+extent+2*image->columns))\n-                            ThrowReaderException(CorruptImageError,\n-                              \"NotEnoughPixelData\");\n+                            {\n+                              tile_image=DestroyImage(tile_image);\n+                              ThrowReaderException(CorruptImageError,\n+                                \"NotEnoughPixelData\");\n+                            }\n                           SetPixelRed(tile_image,ScaleCharToQuantum(*p),q);\n                           SetPixelGreen(tile_image,ScaleCharToQuantum(\n                             *(p+tile_image->columns)),q);\n@@ -460,8 +472,11 @@\n                       else\n                         {\n                           if (p > (pixels+extent+3*image->columns))\n-                            ThrowReaderException(CorruptImageError,\n-                              \"NotEnoughPixelData\");\n+                            {\n+                              tile_image=DestroyImage(tile_image);\n+                              ThrowReaderException(CorruptImageError,\n+                                \"NotEnoughPixelData\");\n+                            }\n                           SetPixelAlpha(tile_image,ScaleCharToQuantum(*p),q);\n                           SetPixelRed(tile_image,ScaleCharToQuantum(\n                             *(p+tile_image->columns)),q);\n@@ -530,8 +545,11 @@\n                 status=SetImageProfile(image,\"icc\",profile,exception);\n                 profile=DestroyStringInfo(profile);\n                 if (status == MagickFalse)\n-                  ThrowReaderException(ResourceLimitError,\n-                    \"MemoryAllocationFailed\");\n+                  {\n+                    info=(unsigned char *) RelinquishMagickMemory(info);\n+                    ThrowReaderException(ResourceLimitError,\n+                      \"MemoryAllocationFailed\");\n+                  }\n                 break;\n               }\n               case 0x1f2:\n@@ -540,8 +558,11 @@\n                 SetStringInfoDatum(profile,info);\n                 status=SetImageProfile(image,\"iptc\",profile,exception);\n                 if (status == MagickFalse)\n-                  ThrowReaderException(ResourceLimitError,\n-                    \"MemoryAllocationFailed\");\n+                  {\n+                    info=(unsigned char *) RelinquishMagickMemory(info);\n+                    ThrowReaderException(ResourceLimitError,\n+                      \"MemoryAllocationFailed\");\n+                  }\n                 profile=DestroyStringInfo(profile);\n                 break;\n               }",
        "diff_line_info": {
            "deleted_lines": [
                "              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "                ThrowReaderException(CorruptImageError,\"NotEnoughPixelData\");",
                "                            ThrowReaderException(CorruptImageError,",
                "                              \"NotEnoughPixelData\");",
                "                            ThrowReaderException(CorruptImageError,",
                "                              \"NotEnoughPixelData\");",
                "                  ThrowReaderException(ResourceLimitError,",
                "                    \"MemoryAllocationFailed\");",
                "                  ThrowReaderException(ResourceLimitError,",
                "                    \"MemoryAllocationFailed\");"
            ],
            "added_lines": [
                "              {",
                "                tile_image=DestroyImage(tile_image);",
                "                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "              }",
                "              {",
                "                tile_image=DestroyImage(tile_image);",
                "                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "              }",
                "                {",
                "                  tile_image=DestroyImage(tile_image);",
                "                  ThrowReaderException(CorruptImageError,\"NotEnoughPixelData\");",
                "                }",
                "                            {",
                "                              tile_image=DestroyImage(tile_image);",
                "                              ThrowReaderException(CorruptImageError,",
                "                                \"NotEnoughPixelData\");",
                "                            }",
                "                            {",
                "                              tile_image=DestroyImage(tile_image);",
                "                              ThrowReaderException(CorruptImageError,",
                "                                \"NotEnoughPixelData\");",
                "                            }",
                "                  {",
                "                    info=(unsigned char *) RelinquishMagickMemory(info);",
                "                    ThrowReaderException(ResourceLimitError,",
                "                      \"MemoryAllocationFailed\");",
                "                  }",
                "                  {",
                "                    info=(unsigned char *) RelinquishMagickMemory(info);",
                "                    ThrowReaderException(ResourceLimitError,",
                "                      \"MemoryAllocationFailed\");",
                "                  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8355",
        "func_name": "ImageMagick/ReadMTVImage",
        "description": "In ImageMagick 7.0.5-5, the ReadMTVImage function in mtv.c allows attackers to cause a denial of service (memory leak) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/d22fd1ff6b41dc81369e255fab81e409049a6e15",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/450",
        "commit_text": "",
        "func_before": "static Image *ReadMTVImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    buffer[MaxTextExtent];\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *p;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned long\n    columns,\n    rows;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read MTV image.\n  */\n  (void) ReadBlobString(image,buffer);\n  count=(ssize_t) sscanf(buffer,\"%lu %lu\\n\",&columns,&rows);\n  if (count <= 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    /*\n      Initialize image structure.\n    */\n    image->columns=columns;\n    image->rows=rows;\n    image->depth=8;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    /*\n      Convert MTV raster image to pixel packets.\n    */\n    pixels=(unsigned char *) AcquireQuantumMemory(image->columns,\n      3UL*sizeof(*pixels));\n    if (pixels == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      count=(ssize_t) ReadBlob(image,(size_t) (3*image->columns),pixels);\n      if (count != (ssize_t) (3*image->columns))\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      p=pixels;\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (PixelPacket *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        SetPixelRed(q,ScaleCharToQuantum(*p++));\n        SetPixelGreen(q,ScaleCharToQuantum(*p++));\n        SetPixelBlue(q,ScaleCharToQuantum(*p++));\n        SetPixelOpacity(q,OpaqueOpacity);\n        q++;\n      }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    *buffer='\\0';\n    (void) ReadBlobString(image,buffer);\n    count=(ssize_t) sscanf(buffer,\"%lu %lu\\n\",&columns,&rows);\n    if (count > 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (count > 0);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadMTVImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    buffer[MaxTextExtent];\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *p;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned long\n    columns,\n    rows;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read MTV image.\n  */\n  (void) ReadBlobString(image,buffer);\n  count=(ssize_t) sscanf(buffer,\"%lu %lu\\n\",&columns,&rows);\n  if (count <= 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    /*\n      Initialize image structure.\n    */\n    image->columns=columns;\n    image->rows=rows;\n    image->depth=8;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    /*\n      Convert MTV raster image to pixel packets.\n    */\n    pixels=(unsigned char *) AcquireQuantumMemory(image->columns,\n      3UL*sizeof(*pixels));\n    if (pixels == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      count=(ssize_t) ReadBlob(image,(size_t) (3*image->columns),pixels);\n      if (count != (ssize_t) (3*image->columns))\n        {\n          pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n        }\n      p=pixels;\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (PixelPacket *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        SetPixelRed(q,ScaleCharToQuantum(*p++));\n        SetPixelGreen(q,ScaleCharToQuantum(*p++));\n        SetPixelBlue(q,ScaleCharToQuantum(*p++));\n        SetPixelOpacity(q,OpaqueOpacity);\n        q++;\n      }\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    *buffer='\\0';\n    (void) ReadBlobString(image,buffer);\n    count=(ssize_t) sscanf(buffer,\"%lu %lu\\n\",&columns,&rows);\n    if (count > 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (count > 0);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -81,7 +81,10 @@\n     {\n       count=(ssize_t) ReadBlob(image,(size_t) (3*image->columns),pixels);\n       if (count != (ssize_t) (3*image->columns))\n-        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n+        {\n+          pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n+          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n+        }\n       p=pixels;\n       q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n       if (q == (PixelPacket *) NULL)",
        "diff_line_info": {
            "deleted_lines": [
                "        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");"
            ],
            "added_lines": [
                "        {",
                "          pixels=(unsigned char *) RelinquishMagickMemory(pixels);",
                "          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8356",
        "func_name": "ImageMagick/ReadSUNImage",
        "description": "In ImageMagick 7.0.5-5, the ReadSUNImage function in sun.c allows attackers to cause a denial of service (memory leak) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/dbc1e15ebc8e9bc4ff4a17cf603ba1ccecf477e3",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/449",
        "commit_text": "",
        "func_before": "static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define RMT_EQUAL_RGB  1\n#define RMT_NONE  0\n#define RMT_RAW  2\n#define RT_STANDARD  1\n#define RT_ENCODED  2\n#define RT_FORMAT_RGB  3\n\n  typedef struct _SUNInfo\n  {\n    unsigned int\n      magic,\n      width,\n      height,\n      depth,\n      length,\n      type,\n      maptype,\n      maplength;\n  } SUNInfo;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_line,\n    extent,\n    height,\n    pixels_length,\n    quantum;\n\n  ssize_t\n    count,\n    y;\n\n  SUNInfo\n    sun_info;\n\n  unsigned char\n    *sun_data,\n    *sun_pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SUN raster header.\n  */\n  (void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));\n  sun_info.magic=ReadBlobMSBLong(image);\n  do\n  {\n    /*\n      Verify SUN identifier.\n    */\n    if (sun_info.magic != 0x59a66a95)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    sun_info.width=ReadBlobMSBLong(image);\n    sun_info.height=ReadBlobMSBLong(image);\n    sun_info.depth=ReadBlobMSBLong(image);\n    sun_info.length=ReadBlobMSBLong(image);\n    sun_info.type=ReadBlobMSBLong(image);\n    sun_info.maptype=ReadBlobMSBLong(image);\n    sun_info.maplength=ReadBlobMSBLong(image);\n    extent=sun_info.height*sun_info.width;\n    if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&\n        (sun_info.type != RT_FORMAT_RGB))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.depth != 1) && (sun_info.depth != 8) &&\n        (sun_info.depth != 24) && (sun_info.depth != 32))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&\n        (sun_info.maptype != RMT_RAW))\n      ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    image->depth=sun_info.depth <= 8 ? sun_info.depth :\n      MAGICKCORE_QUANTUM_DEPTH;\n    if (sun_info.depth < 24)\n      {\n        size_t\n          one;\n\n        image->colors=sun_info.maplength;\n        one=1;\n        if (sun_info.maptype == RMT_NONE)\n          image->colors=one << sun_info.depth;\n        if (sun_info.maptype == RMT_EQUAL_RGB)\n          image->colors=sun_info.maplength/3;\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    switch (sun_info.maptype)\n    {\n      case RMT_NONE:\n        break;\n      case RMT_EQUAL_RGB:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        break;\n      }\n      case RMT_RAW:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,sun_info.maplength,sun_colormap);\n        if (count != (ssize_t) sun_info.maplength)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        break;\n      }\n      default:\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    }\n    image->alpha_trait=sun_info.depth == 32 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    if (image_info->ping != MagickFalse)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    if (sun_info.length == 0)\n      ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n    number_pixels=(MagickSizeType) (image->columns*image->rows);\n    if ((sun_info.type != RT_ENCODED) &&\n        ((number_pixels*sun_info.depth) > (8UL*sun_info.length)))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (HeapOverflowSanityCheck(sun_info.width,sun_info.depth) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    bytes_per_line=sun_info.width*sun_info.depth;\n    sun_data=(unsigned char *) AcquireQuantumMemory(sun_info.length,\n      sizeof(*sun_data));\n    if (sun_data == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);\n    if (count != (ssize_t) sun_info.length)\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      }\n    height=sun_info.height;\n    if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||\n        ((bytes_per_line/sun_info.depth) != sun_info.width))\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n      }\n    quantum=sun_info.depth == 1 ? 15 : 7;\n    bytes_per_line+=quantum;\n    bytes_per_line<<=1;\n    if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+quantum))\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n      }\n    bytes_per_line>>=4;\n    if (HeapOverflowSanityCheck(height,bytes_per_line) != MagickFalse)\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n      }\n    pixels_length=height*bytes_per_line;\n    sun_pixels=(unsigned char *) AcquireQuantumMemory(pixels_length+image->rows,\n      sizeof(*sun_pixels));\n    if (sun_pixels == (unsigned char *) NULL)\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    ResetMagickMemory(sun_pixels,0,pixels_length*sizeof(*sun_pixels));\n    if (sun_info.type == RT_ENCODED)\n      {\n        status=DecodeImage(sun_data,sun_info.length,sun_pixels,pixels_length);\n        if (status == MagickFalse)\n          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      }\n    else\n      {\n        if (sun_info.length > pixels_length)\n          {\n            sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n            sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);\n            ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n          }\n        (void) CopyMagickMemory(sun_pixels,sun_data,sun_info.length);\n      }\n    sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n    /*\n      Convert SUN raster image to pixel packets.\n    */\n    p=sun_pixels;\n    if (sun_info.depth == 1)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=7; bit >= 0; bit--)\n          {\n            SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 : 0x01),\n              q);\n            q+=GetPixelChannels(image);\n          }\n          p++;\n        }\n        if ((image->columns % 8) != 0)\n          {\n            for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)\n            {\n              SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 :\n                0x01),q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n        if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)\n          p++;\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(image,ConstrainColormapIndex(image,*p,exception),q);\n              p++;\n              q+=GetPixelChannels(image);\n            }\n            if ((image->columns % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      else\n        {\n          size_t\n            bytes_per_pixel;\n\n          bytes_per_pixel=3;\n          if (image->alpha_trait != UndefinedPixelTrait)\n            bytes_per_pixel++;\n          if (bytes_per_line == 0)\n            bytes_per_line=bytes_per_pixel*image->columns;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (image->alpha_trait != UndefinedPixelTrait)\n                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n              if (sun_info.type == RT_STANDARD)\n                {\n                  SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n                }\n              else\n                {\n                  SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n                }\n              if (image->colors != 0)\n                {\n                  SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelRed(image,q)].red),q);\n                  SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelGreen(image,q)].green),q);\n                  SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelBlue(image,q)].blue),q);\n                }\n              q+=GetPixelChannels(image);\n            }\n            if (((bytes_per_pixel*image->columns) % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image,exception);\n    sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    sun_info.magic=ReadBlobMSBLong(image);\n    if (sun_info.magic == 0x59a66a95)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (sun_info.magic == 0x59a66a95);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadSUNImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define RMT_EQUAL_RGB  1\n#define RMT_NONE  0\n#define RMT_RAW  2\n#define RT_STANDARD  1\n#define RT_ENCODED  2\n#define RT_FORMAT_RGB  3\n\n  typedef struct _SUNInfo\n  {\n    unsigned int\n      magic,\n      width,\n      height,\n      depth,\n      length,\n      type,\n      maptype,\n      maplength;\n  } SUNInfo;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_line,\n    extent,\n    height,\n    pixels_length,\n    quantum;\n\n  ssize_t\n    count,\n    y;\n\n  SUNInfo\n    sun_info;\n\n  unsigned char\n    *sun_data,\n    *sun_pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read SUN raster header.\n  */\n  (void) ResetMagickMemory(&sun_info,0,sizeof(sun_info));\n  sun_info.magic=ReadBlobMSBLong(image);\n  do\n  {\n    /*\n      Verify SUN identifier.\n    */\n    if (sun_info.magic != 0x59a66a95)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    sun_info.width=ReadBlobMSBLong(image);\n    sun_info.height=ReadBlobMSBLong(image);\n    sun_info.depth=ReadBlobMSBLong(image);\n    sun_info.length=ReadBlobMSBLong(image);\n    sun_info.type=ReadBlobMSBLong(image);\n    sun_info.maptype=ReadBlobMSBLong(image);\n    sun_info.maplength=ReadBlobMSBLong(image);\n    extent=sun_info.height*sun_info.width;\n    if ((sun_info.height != 0) && (sun_info.width != extent/sun_info.height))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.type != RT_STANDARD) && (sun_info.type != RT_ENCODED) &&\n        (sun_info.type != RT_FORMAT_RGB))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype == RMT_NONE) && (sun_info.maplength != 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.depth != 1) && (sun_info.depth != 8) &&\n        (sun_info.depth != 24) && (sun_info.depth != 32))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((sun_info.maptype != RMT_NONE) && (sun_info.maptype != RMT_EQUAL_RGB) &&\n        (sun_info.maptype != RMT_RAW))\n      ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    image->depth=sun_info.depth <= 8 ? sun_info.depth :\n      MAGICKCORE_QUANTUM_DEPTH;\n    if (sun_info.depth < 24)\n      {\n        size_t\n          one;\n\n        image->colors=sun_info.maplength;\n        one=1;\n        if (sun_info.maptype == RMT_NONE)\n          image->colors=one << sun_info.depth;\n        if (sun_info.maptype == RMT_EQUAL_RGB)\n          image->colors=sun_info.maplength/3;\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    switch (sun_info.maptype)\n    {\n      case RMT_NONE:\n        break;\n      case RMT_EQUAL_RGB:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          {\n            sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n          }\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          {\n            sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n          }\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        count=ReadBlob(image,image->colors,sun_colormap);\n        if (count != (ssize_t) image->colors)\n          {\n            sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n          }\n        for (i=0; i < (ssize_t) image->colors; i++)\n          image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(\n            sun_colormap[i]);\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        break;\n      }\n      case RMT_RAW:\n      {\n        unsigned char\n          *sun_colormap;\n\n        /*\n          Read SUN raster colormap.\n        */\n        sun_colormap=(unsigned char *) AcquireQuantumMemory(sun_info.maplength,\n          sizeof(*sun_colormap));\n        if (sun_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        count=ReadBlob(image,sun_info.maplength,sun_colormap);\n        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n        if (count != (ssize_t) sun_info.maplength)\n          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n        break;\n      }\n      default:\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    }\n    image->alpha_trait=sun_info.depth == 32 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n    image->columns=sun_info.width;\n    image->rows=sun_info.height;\n    if (image_info->ping != MagickFalse)\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    if (sun_info.length == 0)\n      ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n    number_pixels=(MagickSizeType) (image->columns*image->rows);\n    if ((sun_info.type != RT_ENCODED) &&\n        ((number_pixels*sun_info.depth) > (8UL*sun_info.length)))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if (HeapOverflowSanityCheck(sun_info.width,sun_info.depth) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    bytes_per_line=sun_info.width*sun_info.depth;\n    sun_data=(unsigned char *) AcquireQuantumMemory(sun_info.length,\n      sizeof(*sun_data));\n    if (sun_data == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    count=(ssize_t) ReadBlob(image,sun_info.length,sun_data);\n    if (count != (ssize_t) sun_info.length)\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      }\n    height=sun_info.height;\n    if ((height == 0) || (sun_info.width == 0) || (sun_info.depth == 0) ||\n        ((bytes_per_line/sun_info.depth) != sun_info.width))\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n      }\n    quantum=sun_info.depth == 1 ? 15 : 7;\n    bytes_per_line+=quantum;\n    bytes_per_line<<=1;\n    if ((bytes_per_line >> 1) != (sun_info.width*sun_info.depth+quantum))\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n      }\n    bytes_per_line>>=4;\n    if (HeapOverflowSanityCheck(height,bytes_per_line) != MagickFalse)\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n      }\n    pixels_length=height*bytes_per_line;\n    sun_pixels=(unsigned char *) AcquireQuantumMemory(pixels_length+image->rows,\n      sizeof(*sun_pixels));\n    if (sun_pixels == (unsigned char *) NULL)\n      {\n        sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    ResetMagickMemory(sun_pixels,0,pixels_length*sizeof(*sun_pixels));\n    if (sun_info.type == RT_ENCODED)\n      {\n        status=DecodeImage(sun_data,sun_info.length,sun_pixels,pixels_length);\n        if (status == MagickFalse)\n          ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      }\n    else\n      {\n        if (sun_info.length > pixels_length)\n          {\n            sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n            sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);\n            ThrowReaderException(ResourceLimitError,\"ImproperImageHeader\");\n          }\n        (void) CopyMagickMemory(sun_pixels,sun_data,sun_info.length);\n      }\n    sun_data=(unsigned char *) RelinquishMagickMemory(sun_data);\n    /*\n      Convert SUN raster image to pixel packets.\n    */\n    p=sun_pixels;\n    if (sun_info.depth == 1)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=7; bit >= 0; bit--)\n          {\n            SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 : 0x01),\n              q);\n            q+=GetPixelChannels(image);\n          }\n          p++;\n        }\n        if ((image->columns % 8) != 0)\n          {\n            for (bit=7; bit >= (int) (8-(image->columns % 8)); bit--)\n            {\n              SetPixelIndex(image,(Quantum) ((*p) & (0x01 << bit) ? 0x00 :\n                0x01),q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n        if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)\n          p++;\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        {\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(image,ConstrainColormapIndex(image,*p,exception),q);\n              p++;\n              q+=GetPixelChannels(image);\n            }\n            if ((image->columns % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      else\n        {\n          size_t\n            bytes_per_pixel;\n\n          bytes_per_pixel=3;\n          if (image->alpha_trait != UndefinedPixelTrait)\n            bytes_per_pixel++;\n          if (bytes_per_line == 0)\n            bytes_per_line=bytes_per_pixel*image->columns;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              if (image->alpha_trait != UndefinedPixelTrait)\n                SetPixelAlpha(image,ScaleCharToQuantum(*p++),q);\n              if (sun_info.type == RT_STANDARD)\n                {\n                  SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n                }\n              else\n                {\n                  SetPixelRed(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelGreen(image,ScaleCharToQuantum(*p++),q);\n                  SetPixelBlue(image,ScaleCharToQuantum(*p++),q);\n                }\n              if (image->colors != 0)\n                {\n                  SetPixelRed(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelRed(image,q)].red),q);\n                  SetPixelGreen(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelGreen(image,q)].green),q);\n                  SetPixelBlue(image,ClampToQuantum(image->colormap[(ssize_t)\n                    GetPixelBlue(image,q)].blue),q);\n                }\n              q+=GetPixelChannels(image);\n            }\n            if (((bytes_per_pixel*image->columns) % 2) != 0)\n              p++;\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image,exception);\n    sun_pixels=(unsigned char *) RelinquishMagickMemory(sun_pixels);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    sun_info.magic=ReadBlobMSBLong(image);\n    if (sun_info.magic == 0x59a66a95)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (sun_info.magic == 0x59a66a95);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -146,19 +146,28 @@\n           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n         count=ReadBlob(image,image->colors,sun_colormap);\n         if (count != (ssize_t) image->colors)\n-          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n+          {\n+            sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n+            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n+          }\n         for (i=0; i < (ssize_t) image->colors; i++)\n           image->colormap[i].red=(MagickRealType) ScaleCharToQuantum(\n             sun_colormap[i]);\n         count=ReadBlob(image,image->colors,sun_colormap);\n         if (count != (ssize_t) image->colors)\n-          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n+          {\n+            sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n+            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n+          }\n         for (i=0; i < (ssize_t) image->colors; i++)\n           image->colormap[i].green=(MagickRealType) ScaleCharToQuantum(\n             sun_colormap[i]);\n         count=ReadBlob(image,image->colors,sun_colormap);\n         if (count != (ssize_t) image->colors)\n-          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n+          {\n+            sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n+            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n+          }\n         for (i=0; i < (ssize_t) image->colors; i++)\n           image->colormap[i].blue=(MagickRealType) ScaleCharToQuantum(\n             sun_colormap[i]);\n@@ -178,9 +187,9 @@\n         if (sun_colormap == (unsigned char *) NULL)\n           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n         count=ReadBlob(image,sun_info.maplength,sun_colormap);\n+        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n         if (count != (ssize_t) sun_info.maplength)\n           ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n-        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);\n         break;\n       }\n       default:",
        "diff_line_info": {
            "deleted_lines": [
                "          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");",
                "          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");",
                "          ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");",
                "        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);"
            ],
            "added_lines": [
                "          {",
                "            sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);",
                "            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");",
                "          }",
                "          {",
                "            sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);",
                "            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");",
                "          }",
                "          {",
                "            sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);",
                "            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");",
                "          }",
                "        sun_colormap=(unsigned char *) RelinquishMagickMemory(sun_colormap);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8357",
        "func_name": "ImageMagick/ReadEPTImage",
        "description": "In ImageMagick 7.0.5-5, the ReadEPTImage function in ept.c allows attackers to cause a denial of service (memory leak) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/e82f14da961e607f1b6ffa525644535686070228",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/453",
        "commit_text": "",
        "func_before": "static Image *ReadEPTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  EPTInfo\n    ept_info;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  ssize_t\n    count;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  ept_info.magick=ReadBlobLSBLong(image);\n  if (ept_info.magick != 0xc6d3d0c5ul)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  ept_info.postscript_offset=(MagickOffsetType) ReadBlobLSBLong(image);\n  ept_info.postscript_length=ReadBlobLSBLong(image);\n  (void) ReadBlobLSBLong(image);\n  (void) ReadBlobLSBLong(image);\n  ept_info.tiff_offset=(MagickOffsetType) ReadBlobLSBLong(image);\n  ept_info.tiff_length=ReadBlobLSBLong(image);\n  (void) ReadBlobLSBShort(image);\n  ept_info.postscript=(unsigned char *) AcquireQuantumMemory(\n    ept_info.postscript_length+1,sizeof(*ept_info.postscript));\n  if (ept_info.postscript == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(ept_info.postscript,0,(ept_info.postscript_length+1)*\n    sizeof(*ept_info.postscript));\n  ept_info.tiff=(unsigned char *) AcquireQuantumMemory(ept_info.tiff_length+1,\n    sizeof(*ept_info.tiff));\n  if (ept_info.tiff == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(ept_info.tiff,0,(ept_info.tiff_length+1)*\n    sizeof(*ept_info.tiff));\n  offset=SeekBlob(image,ept_info.tiff_offset,SEEK_SET);\n  if ((ept_info.tiff_length != 0) && (offset < 30))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  count=ReadBlob(image,ept_info.tiff_length,ept_info.tiff);\n  if (count != (ssize_t) (ept_info.tiff_length))\n    (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageWarning,\n      \"InsufficientImageDataInFile\",\"`%s'\",image->filename);\n  offset=SeekBlob(image,ept_info.postscript_offset,SEEK_SET);\n  if ((ept_info.postscript_length != 0) && (offset < 30))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  count=ReadBlob(image,ept_info.postscript_length,ept_info.postscript);\n  if (count != (ssize_t) (ept_info.postscript_length))\n    (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageWarning,\n      \"InsufficientImageDataInFile\",\"`%s'\",image->filename);\n  (void) CloseBlob(image);\n  image=DestroyImage(image);\n  read_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(read_info->magick,\"EPS\",MagickPathExtent);\n  image=BlobToImage(read_info,ept_info.postscript,ept_info.postscript_length,\n    exception);\n  if (image == (Image *) NULL)\n    {\n      (void) CopyMagickString(read_info->magick,\"TIFF\",MagickPathExtent);\n      image=BlobToImage(read_info,ept_info.tiff,ept_info.tiff_length,exception);\n    }\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick,\"EPT\",MagickPathExtent);\n    }\n  ept_info.tiff=(unsigned char *) RelinquishMagickMemory(ept_info.tiff);\n  ept_info.postscript=(unsigned char *) RelinquishMagickMemory(\n    ept_info.postscript);\n  return(image);\n}",
        "func": "static Image *ReadEPTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  EPTInfo\n    ept_info;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  ssize_t\n    count;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  ept_info.magick=ReadBlobLSBLong(image);\n  if (ept_info.magick != 0xc6d3d0c5ul)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  ept_info.postscript_offset=(MagickOffsetType) ReadBlobLSBLong(image);\n  ept_info.postscript_length=ReadBlobLSBLong(image);\n  (void) ReadBlobLSBLong(image);\n  (void) ReadBlobLSBLong(image);\n  ept_info.tiff_offset=(MagickOffsetType) ReadBlobLSBLong(image);\n  ept_info.tiff_length=ReadBlobLSBLong(image);\n  (void) ReadBlobLSBShort(image);\n  ept_info.postscript=(unsigned char *) AcquireQuantumMemory(\n    ept_info.postscript_length+1,sizeof(*ept_info.postscript));\n  if (ept_info.postscript == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(ept_info.postscript,0,(ept_info.postscript_length+1)*\n    sizeof(*ept_info.postscript));\n  ept_info.tiff=(unsigned char *) AcquireQuantumMemory(ept_info.tiff_length+1,\n    sizeof(*ept_info.tiff));\n  if (ept_info.tiff == (unsigned char *) NULL)\n    {\n      ept_info.postscript=(unsigned char *) RelinquishMagickMemory(\n        ept_info.postscript);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  (void) ResetMagickMemory(ept_info.tiff,0,(ept_info.tiff_length+1)*\n    sizeof(*ept_info.tiff));\n  offset=SeekBlob(image,ept_info.tiff_offset,SEEK_SET);\n  if ((ept_info.tiff_length != 0) && (offset < 30))\n    {\n      ept_info.tiff=(unsigned char *) RelinquishMagickMemory(ept_info.tiff);\n      ept_info.postscript=(unsigned char *) RelinquishMagickMemory(\n        ept_info.postscript);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  count=ReadBlob(image,ept_info.tiff_length,ept_info.tiff);\n  if (count != (ssize_t) (ept_info.tiff_length))\n    (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageWarning,\n      \"InsufficientImageDataInFile\",\"`%s'\",image->filename);\n  offset=SeekBlob(image,ept_info.postscript_offset,SEEK_SET);\n  if ((ept_info.postscript_length != 0) && (offset < 30))\n    {\n      ept_info.tiff=(unsigned char *) RelinquishMagickMemory(ept_info.tiff);\n      ept_info.postscript=(unsigned char *) RelinquishMagickMemory(\n        ept_info.postscript);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  count=ReadBlob(image,ept_info.postscript_length,ept_info.postscript);\n  if (count != (ssize_t) (ept_info.postscript_length))\n    (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageWarning,\n      \"InsufficientImageDataInFile\",\"`%s'\",image->filename);\n  (void) CloseBlob(image);\n  image=DestroyImage(image);\n  read_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(read_info->magick,\"EPS\",MagickPathExtent);\n  image=BlobToImage(read_info,ept_info.postscript,ept_info.postscript_length,\n    exception);\n  if (image == (Image *) NULL)\n    {\n      (void) CopyMagickString(read_info->magick,\"TIFF\",MagickPathExtent);\n      image=BlobToImage(read_info,ept_info.tiff,ept_info.tiff_length,exception);\n    }\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick,\"EPT\",MagickPathExtent);\n    }\n  ept_info.tiff=(unsigned char *) RelinquishMagickMemory(ept_info.tiff);\n  ept_info.postscript=(unsigned char *) RelinquishMagickMemory(\n    ept_info.postscript);\n  return(image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -54,19 +54,33 @@\n   ept_info.tiff=(unsigned char *) AcquireQuantumMemory(ept_info.tiff_length+1,\n     sizeof(*ept_info.tiff));\n   if (ept_info.tiff == (unsigned char *) NULL)\n-    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+    {\n+      ept_info.postscript=(unsigned char *) RelinquishMagickMemory(\n+        ept_info.postscript);\n+      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+    }\n   (void) ResetMagickMemory(ept_info.tiff,0,(ept_info.tiff_length+1)*\n     sizeof(*ept_info.tiff));\n   offset=SeekBlob(image,ept_info.tiff_offset,SEEK_SET);\n   if ((ept_info.tiff_length != 0) && (offset < 30))\n-    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+    {\n+      ept_info.tiff=(unsigned char *) RelinquishMagickMemory(ept_info.tiff);\n+      ept_info.postscript=(unsigned char *) RelinquishMagickMemory(\n+        ept_info.postscript);\n+      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+    }\n   count=ReadBlob(image,ept_info.tiff_length,ept_info.tiff);\n   if (count != (ssize_t) (ept_info.tiff_length))\n     (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageWarning,\n       \"InsufficientImageDataInFile\",\"`%s'\",image->filename);\n   offset=SeekBlob(image,ept_info.postscript_offset,SEEK_SET);\n   if ((ept_info.postscript_length != 0) && (offset < 30))\n-    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+    {\n+      ept_info.tiff=(unsigned char *) RelinquishMagickMemory(ept_info.tiff);\n+      ept_info.postscript=(unsigned char *) RelinquishMagickMemory(\n+        ept_info.postscript);\n+      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+    }\n   count=ReadBlob(image,ept_info.postscript_length,ept_info.postscript);\n   if (count != (ssize_t) (ept_info.postscript_length))\n     (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageWarning,",
        "diff_line_info": {
            "deleted_lines": [
                "    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");"
            ],
            "added_lines": [
                "    {",
                "      ept_info.postscript=(unsigned char *) RelinquishMagickMemory(",
                "        ept_info.postscript);",
                "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "    }",
                "    {",
                "      ept_info.tiff=(unsigned char *) RelinquishMagickMemory(ept_info.tiff);",
                "      ept_info.postscript=(unsigned char *) RelinquishMagickMemory(",
                "        ept_info.postscript);",
                "      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "    }",
                "    {",
                "      ept_info.tiff=(unsigned char *) RelinquishMagickMemory(ept_info.tiff);",
                "      ept_info.postscript=(unsigned char *) RelinquishMagickMemory(",
                "        ept_info.postscript);",
                "      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8086",
        "func_name": "qemu/v9fs_list_xattr",
        "description": "Memory leak in the v9fs_list_xattr function in hw/9pfs/9p-xattr.c in QEMU (aka Quick Emulator) allows local guest OS privileged users to cause a denial of service (memory consumption) via vectors involving the orig_value variable.",
        "git_url": "https://github.com/qemu/qemu/commit/4ffcdef4277a91af15a3c09f7d16af072c29f3f2",
        "commit_title": "9pfs: xattr: fix memory leak in v9fs_list_xattr",
        "commit_text": " Free 'orig_value' in error path. ",
        "func_before": "ssize_t v9fs_list_xattr(FsContext *ctx, const char *path,\n                        void *value, size_t vsize)\n{\n    ssize_t size = 0;\n    void *ovalue = value;\n    XattrOperations *xops;\n    char *orig_value, *orig_value_start;\n    ssize_t xattr_len, parsed_len = 0, attr_len;\n    char *dirpath, *name;\n    int dirfd;\n\n    /* Get the actual len */\n    dirpath = g_path_get_dirname(path);\n    dirfd = local_opendir_nofollow(ctx, dirpath);\n    g_free(dirpath);\n    if (dirfd == -1) {\n        return -1;\n    }\n\n    name = g_path_get_basename(path);\n    xattr_len = flistxattrat_nofollow(dirfd, name, value, 0);\n    if (xattr_len <= 0) {\n        g_free(name);\n        close_preserve_errno(dirfd);\n        return xattr_len;\n    }\n\n    /* Now fetch the xattr and find the actual size */\n    orig_value = g_malloc(xattr_len);\n    xattr_len = flistxattrat_nofollow(dirfd, name, orig_value, xattr_len);\n    g_free(name);\n    close_preserve_errno(dirfd);\n    if (xattr_len < 0) {\n        return -1;\n    }\n\n    /* store the orig pointer */\n    orig_value_start = orig_value;\n    while (xattr_len > parsed_len) {\n        xops = get_xattr_operations(ctx->xops, orig_value);\n        if (!xops) {\n            goto next_entry;\n        }\n\n        if (!value) {\n            size += xops->listxattr(ctx, path, orig_value, value, vsize);\n        } else {\n            size = xops->listxattr(ctx, path, orig_value, value, vsize);\n            if (size < 0) {\n                goto err_out;\n            }\n            value += size;\n            vsize -= size;\n        }\nnext_entry:\n        /* Got the next entry */\n        attr_len = strlen(orig_value) + 1;\n        parsed_len += attr_len;\n        orig_value += attr_len;\n    }\n    if (value) {\n        size = value - ovalue;\n    }\n\nerr_out:\n    g_free(orig_value_start);\n    return size;\n}",
        "func": "ssize_t v9fs_list_xattr(FsContext *ctx, const char *path,\n                        void *value, size_t vsize)\n{\n    ssize_t size = 0;\n    void *ovalue = value;\n    XattrOperations *xops;\n    char *orig_value, *orig_value_start;\n    ssize_t xattr_len, parsed_len = 0, attr_len;\n    char *dirpath, *name;\n    int dirfd;\n\n    /* Get the actual len */\n    dirpath = g_path_get_dirname(path);\n    dirfd = local_opendir_nofollow(ctx, dirpath);\n    g_free(dirpath);\n    if (dirfd == -1) {\n        return -1;\n    }\n\n    name = g_path_get_basename(path);\n    xattr_len = flistxattrat_nofollow(dirfd, name, value, 0);\n    if (xattr_len <= 0) {\n        g_free(name);\n        close_preserve_errno(dirfd);\n        return xattr_len;\n    }\n\n    /* Now fetch the xattr and find the actual size */\n    orig_value = g_malloc(xattr_len);\n    xattr_len = flistxattrat_nofollow(dirfd, name, orig_value, xattr_len);\n    g_free(name);\n    close_preserve_errno(dirfd);\n    if (xattr_len < 0) {\n        g_free(orig_value);\n        return -1;\n    }\n\n    /* store the orig pointer */\n    orig_value_start = orig_value;\n    while (xattr_len > parsed_len) {\n        xops = get_xattr_operations(ctx->xops, orig_value);\n        if (!xops) {\n            goto next_entry;\n        }\n\n        if (!value) {\n            size += xops->listxattr(ctx, path, orig_value, value, vsize);\n        } else {\n            size = xops->listxattr(ctx, path, orig_value, value, vsize);\n            if (size < 0) {\n                goto err_out;\n            }\n            value += size;\n            vsize -= size;\n        }\nnext_entry:\n        /* Got the next entry */\n        attr_len = strlen(orig_value) + 1;\n        parsed_len += attr_len;\n        orig_value += attr_len;\n    }\n    if (value) {\n        size = value - ovalue;\n    }\n\nerr_out:\n    g_free(orig_value_start);\n    return size;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,6 +31,7 @@\n     g_free(name);\n     close_preserve_errno(dirfd);\n     if (xattr_len < 0) {\n+        g_free(orig_value);\n         return -1;\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        g_free(orig_value);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8765",
        "func_name": "ImageMagick/ReadICONImage",
        "description": "The function named ReadICONImage in coders\\icon.c in ImageMagick 7.0.5-5 has a memory leak vulnerability which can cause memory exhaustion via a crafted ICON file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/82c0f060628c5d955e6a36b3579cc81086132092",
        "commit_title": "Added extra check that was reported in #466.",
        "commit_text": "",
        "func_before": "static Image *ReadICONImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  IconFile\n    icon_file;\n\n  IconInfo\n    icon_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    extent;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bit,\n    byte,\n    bytes_per_line,\n    one,\n    scanline_pad;\n\n  ssize_t\n    count,\n    offset,\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"%s\",image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  icon_file.reserved=(short) ReadBlobLSBShort(image);\n  icon_file.resource_type=(short) ReadBlobLSBShort(image);\n  icon_file.count=(short) ReadBlobLSBShort(image);\n  if ((icon_file.reserved != 0) ||\n      ((icon_file.resource_type != 1) && (icon_file.resource_type != 2)) ||\n      (icon_file.count > MaxIcons))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  extent=0;\n  for (i=0; i < icon_file.count; i++)\n  {\n    icon_file.directory[i].width=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].height=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].colors=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].reserved=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].planes=(unsigned short) ReadBlobLSBShort(image);\n    icon_file.directory[i].bits_per_pixel=(unsigned short)\n      ReadBlobLSBShort(image);\n    icon_file.directory[i].size=ReadBlobLSBLong(image);\n    icon_file.directory[i].offset=ReadBlobLSBLong(image);\n    if (EOFBlob(image) != MagickFalse)\n      break;\n    extent=MagickMax(extent,icon_file.directory[i].size);\n  }\n  if ((EOFBlob(image) != MagickFalse) || (extent > GetBlobSize(image)))\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  one=1;\n  for (i=0; i < icon_file.count; i++)\n  {\n    /*\n      Verify Icon identifier.\n    */\n    offset=(ssize_t) SeekBlob(image,(MagickOffsetType)\n      icon_file.directory[i].offset,SEEK_SET);\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    icon_info.size=ReadBlobLSBLong(image);\n    icon_info.width=(unsigned char) ReadBlobLSBSignedLong(image);\n    icon_info.height=(unsigned char) (ReadBlobLSBSignedLong(image)/2);\n    icon_info.planes=ReadBlobLSBShort(image);\n    icon_info.bits_per_pixel=ReadBlobLSBShort(image);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    if (((icon_info.planes == 18505) && (icon_info.bits_per_pixel == 21060)) || \n        (icon_info.size == 0x474e5089))\n      {\n        Image\n          *icon_image;\n\n        ImageInfo\n          *read_info;\n\n        size_t\n          length;\n\n        unsigned char\n          *png;\n\n        /*\n          Icon image encoded as a compressed PNG image.\n        */\n        length=icon_file.directory[i].size;\n        if ((length < 16) || (~length < 16))\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        png=(unsigned char *) AcquireQuantumMemory(length+16,sizeof(*png));\n        if (png == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) CopyMagickMemory(png,\"\\211PNG\\r\\n\\032\\n\\000\\000\\000\\015\",12);\n        png[12]=(unsigned char) icon_info.planes;\n        png[13]=(unsigned char) (icon_info.planes >> 8);\n        png[14]=(unsigned char) icon_info.bits_per_pixel;\n        png[15]=(unsigned char) (icon_info.bits_per_pixel >> 8);\n        count=ReadBlob(image,length-16,png+16);\n        icon_image=(Image *) NULL;\n        if (count > 0)\n          {\n            read_info=CloneImageInfo(image_info);\n            (void) CopyMagickString(read_info->magick,\"PNG\",MaxTextExtent);\n            icon_image=BlobToImage(read_info,png,length+16,exception);\n            read_info=DestroyImageInfo(read_info);\n          }\n        png=(unsigned char *) RelinquishMagickMemory(png);\n        if (icon_image == (Image *) NULL)\n          {\n            if (count != (ssize_t) (length-16))\n              ThrowReaderException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        DestroyBlob(icon_image);\n        icon_image->blob=ReferenceBlob(image->blob);\n        ReplaceImageInList(&image,icon_image);\n        icon_image->scene=i;\n      }\n    else\n      {\n        if (icon_info.bits_per_pixel > 32)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        icon_info.compression=ReadBlobLSBLong(image);\n        icon_info.image_size=ReadBlobLSBLong(image);\n        icon_info.x_pixels=ReadBlobLSBLong(image);\n        icon_info.y_pixels=ReadBlobLSBLong(image);\n        icon_info.number_colors=ReadBlobLSBLong(image);\n        icon_info.colors_important=ReadBlobLSBLong(image);\n        image->matte=MagickTrue;\n        image->columns=(size_t) icon_file.directory[i].width;\n        if ((ssize_t) image->columns > icon_info.width)\n          image->columns=(size_t) icon_info.width;\n        if (image->columns == 0)\n          image->columns=256;\n        image->rows=(size_t) icon_file.directory[i].height;\n        if ((ssize_t) image->rows > icon_info.height)\n          image->rows=(size_t) icon_info.height;\n        if (image->rows == 0)\n          image->rows=256;\n        image->depth=icon_info.bits_per_pixel;\n        if (image->debug != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \" scene    = %.20g\",(double) i);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   size   = %.20g\",(double) icon_info.size);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   width  = %.20g\",(double) icon_file.directory[i].width);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   height = %.20g\",(double) icon_file.directory[i].height);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   colors = %.20g\",(double ) icon_info.number_colors);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   planes = %.20g\",(double) icon_info.planes);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   bpp    = %.20g\",(double) icon_info.bits_per_pixel);\n          }\n      if ((icon_info.number_colors != 0) || (icon_info.bits_per_pixel <= 16U))\n        {\n          image->storage_class=PseudoClass;\n          image->colors=icon_info.number_colors;\n          if (image->colors == 0)\n            image->colors=one << icon_info.bits_per_pixel;\n        }\n      if (image->storage_class == PseudoClass)\n        {\n          register ssize_t\n            i;\n\n          unsigned char\n            *icon_colormap;\n\n          /*\n            Read Icon raster colormap.\n          */\n          if (AcquireImageColormap(image,image->colors) == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          icon_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n            image->colors,4UL*sizeof(*icon_colormap));\n          if (icon_colormap == (unsigned char *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          count=ReadBlob(image,(size_t) (4*image->colors),icon_colormap);\n          if (count != (ssize_t) (4*image->colors))\n            {\n              icon_colormap=(unsigned char *) RelinquishMagickMemory(\n                icon_colormap);\n              ThrowReaderException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            }\n          p=icon_colormap;\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            image->colormap[i].blue=(Quantum) ScaleCharToQuantum(*p++);\n            image->colormap[i].green=(Quantum) ScaleCharToQuantum(*p++);\n            image->colormap[i].red=(Quantum) ScaleCharToQuantum(*p++);\n            p++;\n          }\n          icon_colormap=(unsigned char *) RelinquishMagickMemory(icon_colormap);\n        }\n        /*\n          Convert Icon raster image to pixel packets.\n        */\n        if ((image_info->ping != MagickFalse) &&\n            (image_info->number_scenes != 0))\n          if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n            break;\n        status=SetImageExtent(image,image->columns,image->rows);\n        if (status == MagickFalse)\n          {\n            InheritException(exception,&image->exception);\n            return(DestroyImageList(image));\n          }\n        bytes_per_line=(((image->columns*icon_info.bits_per_pixel)+31) &\n          ~31) >> 3;\n        (void) bytes_per_line;\n        scanline_pad=((((image->columns*icon_info.bits_per_pixel)+31) & ~31)-\n          (image->columns*icon_info.bits_per_pixel)) >> 3;\n        switch (icon_info.bits_per_pixel)\n        {\n          case 1:\n          {\n            /*\n              Convert bitmap scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < (ssize_t) (image->columns-7); x+=8)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                for (bit=0; bit < 8; bit++)\n                  SetPixelIndex(indexes+x+bit,((byte & (0x80 >> bit)) != 0 ?\n                    0x01 : 0x00));\n              }\n              if ((image->columns % 8) != 0)\n                {\n                  byte=(size_t) ReadBlobByte(image);\n                  for (bit=0; bit < (image->columns % 8); bit++)\n                    SetPixelIndex(indexes+x+bit,((byte & (0x80 >> bit)) != 0 ?\n                      0x01 : 0x00));\n                }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 4:\n          {\n            /*\n              Read 4-bit Icon scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                SetPixelIndex(indexes+x,((byte >> 4) & 0xf));\n                SetPixelIndex(indexes+x+1,((byte) & 0xf));\n              }\n              if ((image->columns % 2) != 0)\n                {\n                  byte=(size_t) ReadBlobByte(image);\n                  SetPixelIndex(indexes+x,((byte >> 4) & 0xf));\n                }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 8:\n          {\n            /*\n              Convert PseudoColor scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                SetPixelIndex(indexes+x,byte);\n              }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 16:\n          {\n            /*\n              Convert PseudoColor scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                byte|=(size_t) (ReadBlobByte(image) << 8);\n                SetPixelIndex(indexes+x,byte);\n              }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 24:\n          case 32:\n          {\n            /*\n              Convert DirectColor scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n                  ReadBlobByte(image)));\n                SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n                  ReadBlobByte(image)));\n                SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n                  ReadBlobByte(image)));\n                if (icon_info.bits_per_pixel == 32)\n                  SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image)));\n                q++;\n              }\n              if (icon_info.bits_per_pixel == 24)\n                for (x=0; x < (ssize_t) scanline_pad; x++)\n                  (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          default:\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n        if ((image_info->ping == MagickFalse) &&\n            (icon_info.bits_per_pixel <= 16))\n          (void) SyncImage(image);\n        if (icon_info.bits_per_pixel != 32)\n          {\n            /*\n              Read the ICON alpha mask.\n            */\n            image->storage_class=DirectClass;\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                for (bit=0; bit < 8; bit++)\n                  SetPixelOpacity(q+x+bit,(((byte & (0x80 >> bit)) != 0) ?\n                    TransparentOpacity : OpaqueOpacity));\n              }\n              if ((image->columns % 8) != 0)\n                {\n                  byte=(size_t) ReadBlobByte(image);\n                  for (bit=0; bit < (image->columns % 8); bit++)\n                    SetPixelOpacity(q+x+bit,(((byte & (0x80 >> bit)) != 0) ?\n                      TransparentOpacity : OpaqueOpacity));\n                }\n              if ((image->columns % 32) != 0)\n                for (x=0; x < (ssize_t) ((32-(image->columns % 32))/8); x++)\n                  (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n            }\n          }\n        if (EOFBlob(image) != MagickFalse)\n          {\n            ThrowFileException(exception,CorruptImageError,\n              \"UnexpectedEndOfFile\",image->filename);\n            break;\n          }\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (i < (ssize_t) (icon_file.count-1))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadICONImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  IconFile\n    icon_file;\n\n  IconInfo\n    icon_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    extent;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bit,\n    byte,\n    bytes_per_line,\n    one,\n    scanline_pad;\n\n  ssize_t\n    count,\n    offset,\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"%s\",image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  icon_file.reserved=(short) ReadBlobLSBShort(image);\n  icon_file.resource_type=(short) ReadBlobLSBShort(image);\n  icon_file.count=(short) ReadBlobLSBShort(image);\n  if ((icon_file.reserved != 0) ||\n      ((icon_file.resource_type != 1) && (icon_file.resource_type != 2)) ||\n      (icon_file.count > MaxIcons))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  extent=0;\n  for (i=0; i < icon_file.count; i++)\n  {\n    icon_file.directory[i].width=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].height=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].colors=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].reserved=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].planes=(unsigned short) ReadBlobLSBShort(image);\n    icon_file.directory[i].bits_per_pixel=(unsigned short)\n      ReadBlobLSBShort(image);\n    icon_file.directory[i].size=ReadBlobLSBLong(image);\n    icon_file.directory[i].offset=ReadBlobLSBLong(image);\n    if (EOFBlob(image) != MagickFalse)\n      break;\n    extent=MagickMax(extent,icon_file.directory[i].size);\n  }\n  if ((EOFBlob(image) != MagickFalse) || (extent > GetBlobSize(image)))\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  one=1;\n  for (i=0; i < icon_file.count; i++)\n  {\n    /*\n      Verify Icon identifier.\n    */\n    offset=(ssize_t) SeekBlob(image,(MagickOffsetType)\n      icon_file.directory[i].offset,SEEK_SET);\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    icon_info.size=ReadBlobLSBLong(image);\n    icon_info.width=(unsigned char) ReadBlobLSBSignedLong(image);\n    icon_info.height=(unsigned char) (ReadBlobLSBSignedLong(image)/2);\n    icon_info.planes=ReadBlobLSBShort(image);\n    icon_info.bits_per_pixel=ReadBlobLSBShort(image);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    if (((icon_info.planes == 18505) && (icon_info.bits_per_pixel == 21060)) || \n        (icon_info.size == 0x474e5089))\n      {\n        Image\n          *icon_image;\n\n        ImageInfo\n          *read_info;\n\n        size_t\n          length;\n\n        unsigned char\n          *png;\n\n        /*\n          Icon image encoded as a compressed PNG image.\n        */\n        length=icon_file.directory[i].size;\n        if ((length < 16) || (~length < 16))\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        png=(unsigned char *) AcquireQuantumMemory(length+16,sizeof(*png));\n        if (png == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) CopyMagickMemory(png,\"\\211PNG\\r\\n\\032\\n\\000\\000\\000\\015\",12);\n        png[12]=(unsigned char) icon_info.planes;\n        png[13]=(unsigned char) (icon_info.planes >> 8);\n        png[14]=(unsigned char) icon_info.bits_per_pixel;\n        png[15]=(unsigned char) (icon_info.bits_per_pixel >> 8);\n        count=ReadBlob(image,length-16,png+16);\n        icon_image=(Image *) NULL;\n        if (count > 0)\n          {\n            read_info=CloneImageInfo(image_info);\n            (void) CopyMagickString(read_info->magick,\"PNG\",MaxTextExtent);\n            icon_image=BlobToImage(read_info,png,length+16,exception);\n            read_info=DestroyImageInfo(read_info);\n          }\n        png=(unsigned char *) RelinquishMagickMemory(png);\n        if (icon_image == (Image *) NULL)\n          {\n            if (count != (ssize_t) (length-16))\n              ThrowReaderException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        DestroyBlob(icon_image);\n        icon_image->blob=ReferenceBlob(image->blob);\n        ReplaceImageInList(&image,icon_image);\n        icon_image->scene=i;\n      }\n    else\n      {\n        if (icon_info.bits_per_pixel > 32)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        icon_info.compression=ReadBlobLSBLong(image);\n        icon_info.image_size=ReadBlobLSBLong(image);\n        icon_info.x_pixels=ReadBlobLSBLong(image);\n        icon_info.y_pixels=ReadBlobLSBLong(image);\n        icon_info.number_colors=ReadBlobLSBLong(image);\n        icon_info.colors_important=ReadBlobLSBLong(image);\n        image->matte=MagickTrue;\n        image->columns=(size_t) icon_file.directory[i].width;\n        if ((ssize_t) image->columns > icon_info.width)\n          image->columns=(size_t) icon_info.width;\n        if (image->columns == 0)\n          image->columns=256;\n        image->rows=(size_t) icon_file.directory[i].height;\n        if ((ssize_t) image->rows > icon_info.height)\n          image->rows=(size_t) icon_info.height;\n        if (image->rows == 0)\n          image->rows=256;\n        image->depth=icon_info.bits_per_pixel;\n        if (image->debug != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \" scene    = %.20g\",(double) i);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   size   = %.20g\",(double) icon_info.size);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   width  = %.20g\",(double) icon_file.directory[i].width);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   height = %.20g\",(double) icon_file.directory[i].height);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   colors = %.20g\",(double ) icon_info.number_colors);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   planes = %.20g\",(double) icon_info.planes);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   bpp    = %.20g\",(double) icon_info.bits_per_pixel);\n          }\n      if ((icon_info.number_colors != 0) || (icon_info.bits_per_pixel <= 16U))\n        {\n          image->storage_class=PseudoClass;\n          image->colors=icon_info.number_colors;\n          if ((image->colors == 0) || (image->colors > 256))\n            image->colors=one << icon_info.bits_per_pixel;\n        }\n      if (image->storage_class == PseudoClass)\n        {\n          register ssize_t\n            i;\n\n          unsigned char\n            *icon_colormap;\n\n          /*\n            Read Icon raster colormap.\n          */\n          if (AcquireImageColormap(image,image->colors) == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          icon_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n            image->colors,4UL*sizeof(*icon_colormap));\n          if (icon_colormap == (unsigned char *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          count=ReadBlob(image,(size_t) (4*image->colors),icon_colormap);\n          if (count != (ssize_t) (4*image->colors))\n            {\n              icon_colormap=(unsigned char *) RelinquishMagickMemory(\n                icon_colormap);\n              ThrowReaderException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            }\n          p=icon_colormap;\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            image->colormap[i].blue=(Quantum) ScaleCharToQuantum(*p++);\n            image->colormap[i].green=(Quantum) ScaleCharToQuantum(*p++);\n            image->colormap[i].red=(Quantum) ScaleCharToQuantum(*p++);\n            p++;\n          }\n          icon_colormap=(unsigned char *) RelinquishMagickMemory(icon_colormap);\n        }\n        /*\n          Convert Icon raster image to pixel packets.\n        */\n        if ((image_info->ping != MagickFalse) &&\n            (image_info->number_scenes != 0))\n          if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n            break;\n        status=SetImageExtent(image,image->columns,image->rows);\n        if (status == MagickFalse)\n          {\n            InheritException(exception,&image->exception);\n            return(DestroyImageList(image));\n          }\n        bytes_per_line=(((image->columns*icon_info.bits_per_pixel)+31) &\n          ~31) >> 3;\n        (void) bytes_per_line;\n        scanline_pad=((((image->columns*icon_info.bits_per_pixel)+31) & ~31)-\n          (image->columns*icon_info.bits_per_pixel)) >> 3;\n        switch (icon_info.bits_per_pixel)\n        {\n          case 1:\n          {\n            /*\n              Convert bitmap scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < (ssize_t) (image->columns-7); x+=8)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                for (bit=0; bit < 8; bit++)\n                  SetPixelIndex(indexes+x+bit,((byte & (0x80 >> bit)) != 0 ?\n                    0x01 : 0x00));\n              }\n              if ((image->columns % 8) != 0)\n                {\n                  byte=(size_t) ReadBlobByte(image);\n                  for (bit=0; bit < (image->columns % 8); bit++)\n                    SetPixelIndex(indexes+x+bit,((byte & (0x80 >> bit)) != 0 ?\n                      0x01 : 0x00));\n                }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 4:\n          {\n            /*\n              Read 4-bit Icon scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                SetPixelIndex(indexes+x,((byte >> 4) & 0xf));\n                SetPixelIndex(indexes+x+1,((byte) & 0xf));\n              }\n              if ((image->columns % 2) != 0)\n                {\n                  byte=(size_t) ReadBlobByte(image);\n                  SetPixelIndex(indexes+x,((byte >> 4) & 0xf));\n                }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 8:\n          {\n            /*\n              Convert PseudoColor scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                SetPixelIndex(indexes+x,byte);\n              }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 16:\n          {\n            /*\n              Convert PseudoColor scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                byte|=(size_t) (ReadBlobByte(image) << 8);\n                SetPixelIndex(indexes+x,byte);\n              }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 24:\n          case 32:\n          {\n            /*\n              Convert DirectColor scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n                  ReadBlobByte(image)));\n                SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n                  ReadBlobByte(image)));\n                SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n                  ReadBlobByte(image)));\n                if (icon_info.bits_per_pixel == 32)\n                  SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image)));\n                q++;\n              }\n              if (icon_info.bits_per_pixel == 24)\n                for (x=0; x < (ssize_t) scanline_pad; x++)\n                  (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          default:\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n        if ((image_info->ping == MagickFalse) &&\n            (icon_info.bits_per_pixel <= 16))\n          (void) SyncImage(image);\n        if (icon_info.bits_per_pixel != 32)\n          {\n            /*\n              Read the ICON alpha mask.\n            */\n            image->storage_class=DirectClass;\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                for (bit=0; bit < 8; bit++)\n                  SetPixelOpacity(q+x+bit,(((byte & (0x80 >> bit)) != 0) ?\n                    TransparentOpacity : OpaqueOpacity));\n              }\n              if ((image->columns % 8) != 0)\n                {\n                  byte=(size_t) ReadBlobByte(image);\n                  for (bit=0; bit < (image->columns % 8); bit++)\n                    SetPixelOpacity(q+x+bit,(((byte & (0x80 >> bit)) != 0) ?\n                      TransparentOpacity : OpaqueOpacity));\n                }\n              if ((image->columns % 32) != 0)\n                for (x=0; x < (ssize_t) ((32-(image->columns % 32))/8); x++)\n                  (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n            }\n          }\n        if (EOFBlob(image) != MagickFalse)\n          {\n            ThrowFileException(exception,CorruptImageError,\n              \"UnexpectedEndOfFile\",image->filename);\n            break;\n          }\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (i < (ssize_t) (icon_file.count-1))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -197,7 +197,7 @@\n         {\n           image->storage_class=PseudoClass;\n           image->colors=icon_info.number_colors;\n-          if (image->colors == 0)\n+          if ((image->colors == 0) || (image->colors > 256))\n             image->colors=one << icon_info.bits_per_pixel;\n         }\n       if (image->storage_class == PseudoClass)",
        "diff_line_info": {
            "deleted_lines": [
                "          if (image->colors == 0)"
            ],
            "added_lines": [
                "          if ((image->colors == 0) || (image->colors > 256))"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9143",
        "func_name": "ImageMagick/ReadARTImage",
        "description": "In ImageMagick 7.0.5-5, the ReadARTImage function in coders/art.c allows attackers to cause a denial of service (memory leak) via a crafted .art file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/3b0fe05cddd8910f84e51b4d50099702ea45ba4a",
        "commit_title": "Fixed memory leak reported in #456.",
        "commit_text": "",
        "func_before": "static Image *ReadARTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  const unsigned char\n    *pixels;\n\n  Image\n    *image;\n\n  QuantumInfo\n    *quantum_info;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->depth=1;\n  image->endian=MSBEndian;\n  (void) ReadBlobLSBShort(image);\n  image->columns=(size_t) ReadBlobLSBShort(image);\n  (void) ReadBlobLSBShort(image);\n  image->rows=(size_t) ReadBlobLSBShort(image);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Convert bi-level image to pixel packets.\n  */\n  SetImageColorspace(image,GRAYColorspace,exception);\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  length=GetQuantumExtent(image,quantum_info,GrayQuantum);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    pixels=(const unsigned char *) ReadBlobStream(image,length,\n      GetQuantumPixels(quantum_info),&count);\n    if (count != (ssize_t) length)\n      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n    (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n      GrayQuantum,pixels,exception);\n    pixels=(const unsigned char *) ReadBlobStream(image,(size_t) (-(ssize_t)\n      length) & 0x01,GetQuantumPixels(quantum_info),&count);\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (SetImageProgress(image,LoadImageTag,y,image->rows) == MagickFalse)\n      break;\n  }\n  SetQuantumImageType(image,GrayQuantum);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadARTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  const unsigned char\n    *pixels;\n\n  Image\n    *image;\n\n  QuantumInfo\n    *quantum_info;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->depth=1;\n  image->endian=MSBEndian;\n  (void) ReadBlobLSBShort(image);\n  image->columns=(size_t) ReadBlobLSBShort(image);\n  (void) ReadBlobLSBShort(image);\n  image->rows=(size_t) ReadBlobLSBShort(image);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Convert bi-level image to pixel packets.\n  */\n  SetImageColorspace(image,GRAYColorspace,exception);\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  length=GetQuantumExtent(image,quantum_info,GrayQuantum);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    pixels=(const unsigned char *) ReadBlobStream(image,length,\n      GetQuantumPixels(quantum_info),&count);\n    if (count != (ssize_t) length)\n      {\n        quantum_info=DestroyQuantumInfo(quantum_info);\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      }\n    (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n      GrayQuantum,pixels,exception);\n    pixels=(const unsigned char *) ReadBlobStream(image,(size_t) (-(ssize_t)\n      length) & 0x01,GetQuantumPixels(quantum_info),&count);\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (SetImageProgress(image,LoadImageTag,y,image->rows) == MagickFalse)\n      break;\n  }\n  SetQuantumImageType(image,GrayQuantum);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -71,7 +71,10 @@\n     pixels=(const unsigned char *) ReadBlobStream(image,length,\n       GetQuantumPixels(quantum_info),&count);\n     if (count != (ssize_t) length)\n-      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n+      {\n+        quantum_info=DestroyQuantumInfo(quantum_info);\n+        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n+      }\n     (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n       GrayQuantum,pixels,exception);\n     pixels=(const unsigned char *) ReadBlobStream(image,(size_t) (-(ssize_t)",
        "diff_line_info": {
            "deleted_lines": [
                "      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");"
            ],
            "added_lines": [
                "      {",
                "        quantum_info=DestroyQuantumInfo(quantum_info);",
                "        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9262",
        "func_name": "ImageMagick/ReadOneJNGImage",
        "description": "In ImageMagick 7.0.5-6 Q16, the ReadJNGImage function in coders/png.c allows attackers to cause a denial of service (memory leak) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/4649578df8dcbfb2b08d8623d52486dc124da3a8",
        "commit_title": "Fixed various memory leaks reported in #475.",
        "commit_text": "",
        "func_before": "static Image *ReadOneJNGImage(MngInfo *mng_info,\n    const ImageInfo *image_info, ExceptionInfo *exception)\n{\n  Image\n    *alpha_image,\n    *color_image,\n    *image,\n    *jng_image;\n\n  ImageInfo\n    *alpha_image_info,\n    *color_image_info;\n\n  MagickBooleanType\n    logging;\n\n  int\n    unique_filenames;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    status;\n\n  png_uint_32\n    jng_height,\n    jng_width;\n\n  png_byte\n    jng_color_type,\n    jng_image_sample_depth,\n    jng_image_compression_method,\n    jng_image_interlace_method,\n    jng_alpha_sample_depth,\n    jng_alpha_compression_method,\n    jng_alpha_filter_method,\n    jng_alpha_interlace_method;\n\n  register const PixelPacket\n    *s;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *p;\n\n  unsigned int\n    read_JSEP,\n    reading_idat;\n\n  size_t\n    length;\n\n  jng_alpha_compression_method=0;\n  jng_alpha_sample_depth=8;\n  jng_color_type=0;\n  jng_height=0;\n  jng_width=0;\n  alpha_image=(Image *) NULL;\n  color_image=(Image *) NULL;\n  alpha_image_info=(ImageInfo *) NULL;\n  color_image_info=(ImageInfo *) NULL;\n  unique_filenames=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneJNGImage()\");\n\n  image=mng_info->image;\n\n  if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n    {\n      /*\n        Allocate next image structure.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  AcquireNextImage()\");\n\n      AcquireNextImage(image_info,image);\n\n      if (GetNextImageInList(image) == (Image *) NULL)\n        return(DestroyImageList(image));\n\n      image=SyncNextImageInList(image);\n    }\n  mng_info->image=image;\n\n  /*\n    Signature bytes have already been read.\n  */\n\n  read_JSEP=MagickFalse;\n  reading_idat=MagickFalse;\n  for (;;)\n  {\n    char\n      type[MaxTextExtent];\n\n    unsigned char\n      *chunk;\n\n    unsigned int\n      count;\n\n    /*\n      Read a new JNG chunk.\n    */\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      2*GetBlobSize(image));\n\n    if (status == MagickFalse)\n      break;\n\n    type[0]='\\0';\n    (void) ConcatenateMagickString(type,\"errr\",MaxTextExtent);\n    length=ReadBlobMSBLong(image);\n    count=(unsigned int) ReadBlob(image,4,(unsigned char *) type);\n\n    if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Reading JNG chunk type %c%c%c%c, length: %.20g\",\n        type[0],type[1],type[2],type[3],(double) length);\n\n    if (length > PNG_UINT_31_MAX || count == 0)\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n\n    p=NULL;\n    chunk=(unsigned char *) NULL;\n\n    if (length != 0)\n      {\n        chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));\n\n        if (chunk == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        for (i=0; i < (ssize_t) length; i++)\n          chunk[i]=(unsigned char) ReadBlobByte(image);\n\n        p=chunk;\n      }\n\n    (void) ReadBlobMSBLong(image);  /* read crc word */\n\n    if (memcmp(type,mng_JHDR,4) == 0)\n      {\n        if (length == 16)\n          {\n            jng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n              (p[2] << 8) | p[3]);\n            jng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n              (p[6] << 8) | p[7]);\n            if ((jng_width == 0) || (jng_height == 0))\n              ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n            jng_color_type=p[8];\n            jng_image_sample_depth=p[9];\n            jng_image_compression_method=p[10];\n            jng_image_interlace_method=p[11];\n\n            image->interlace=jng_image_interlace_method != 0 ? PNGInterlace :\n              NoInterlace;\n\n            jng_alpha_sample_depth=p[12];\n            jng_alpha_compression_method=p[13];\n            jng_alpha_filter_method=p[14];\n            jng_alpha_interlace_method=p[15];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_width:      %16lu,    jng_height:     %16lu\\n\"\n                  \"    jng_color_type: %16d,     jng_image_sample_depth: %3d\\n\"\n                  \"    jng_image_compression_method:%3d\",\n                  (unsigned long) jng_width, (unsigned long) jng_height,\n                  jng_color_type, jng_image_sample_depth,\n                  jng_image_compression_method);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_image_interlace_method:  %3d\"\n                  \"    jng_alpha_sample_depth:      %3d\",\n                  jng_image_interlace_method,\n                  jng_alpha_sample_depth);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_alpha_compression_method:%3d\\n\"\n                  \"    jng_alpha_filter_method:     %3d\\n\"\n                  \"    jng_alpha_interlace_method:  %3d\",\n                  jng_alpha_compression_method,\n                  jng_alpha_filter_method,\n                  jng_alpha_interlace_method);\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n\n    if ((reading_idat == MagickFalse) && (read_JSEP == MagickFalse) &&\n        ((memcmp(type,mng_JDAT,4) == 0) || (memcmp(type,mng_JdAA,4) == 0) ||\n         (memcmp(type,mng_IDAT,4) == 0) || (memcmp(type,mng_JDAA,4) == 0)))\n      {\n        /*\n           o create color_image\n           o open color_blob, attached to color_image\n           o if (color type has alpha)\n               open alpha_blob, attached to alpha_image\n        */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Creating color_blob.\");\n\n        color_image_info=(ImageInfo *)AcquireMagickMemory(sizeof(ImageInfo));\n\n        if (color_image_info == (ImageInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        GetImageInfo(color_image_info);\n        color_image=AcquireImage(color_image_info);\n\n        if (color_image == (Image *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        (void) AcquireUniqueFilename(color_image->filename);\n        unique_filenames++;\n        status=OpenBlob(color_image_info,color_image,WriteBinaryBlobMode,\n          exception);\n\n        if (status == MagickFalse)\n          return(DestroyImageList(image));\n\n        if ((image_info->ping == MagickFalse) && (jng_color_type >= 12))\n          {\n            alpha_image_info=(ImageInfo *)\n              AcquireMagickMemory(sizeof(ImageInfo));\n\n            if (alpha_image_info == (ImageInfo *) NULL)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n            GetImageInfo(alpha_image_info);\n            alpha_image=AcquireImage(alpha_image_info);\n\n            if (alpha_image == (Image *) NULL)\n              {\n                alpha_image=DestroyImage(alpha_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Creating alpha_blob.\");\n\n            (void) AcquireUniqueFilename(alpha_image->filename);\n            unique_filenames++;\n            status=OpenBlob(alpha_image_info,alpha_image,WriteBinaryBlobMode,\n              exception);\n\n            if (status == MagickFalse)\n              return(DestroyImageList(image));\n\n            if (jng_alpha_compression_method == 0)\n              {\n                unsigned char\n                  data[18];\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Writing IHDR chunk to alpha_blob.\");\n\n                (void) WriteBlob(alpha_image,8,(const unsigned char *)\n                  \"\\211PNG\\r\\n\\032\\n\");\n\n                (void) WriteBlobMSBULong(alpha_image,13L);\n                PNGType(data,mng_IHDR);\n                LogPNGChunk(logging,mng_IHDR,13L);\n                PNGLong(data+4,jng_width);\n                PNGLong(data+8,jng_height);\n                data[12]=jng_alpha_sample_depth;\n                data[13]=0; /* color_type gray */\n                data[14]=0; /* compression method 0 */\n                data[15]=0; /* filter_method 0 */\n                data[16]=0; /* interlace_method 0 */\n                (void) WriteBlob(alpha_image,17,data);\n                (void) WriteBlobMSBULong(alpha_image,crc32(0,data,17));\n              }\n          }\n        reading_idat=MagickTrue;\n      }\n\n    if (memcmp(type,mng_JDAT,4) == 0)\n      {\n        /* Copy chunk to color_image->blob */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Copying JDAT chunk data to color_blob.\");\n\n        (void) WriteBlob(color_image,length,chunk);\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_IDAT,4) == 0)\n      {\n        png_byte\n           data[5];\n\n        /* Copy IDAT header and chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying IDAT chunk data to alpha_blob.\");\n\n            (void) WriteBlobMSBULong(alpha_image,(size_t) length);\n            PNGType(data,mng_IDAT);\n            LogPNGChunk(logging,mng_IDAT,length);\n            (void) WriteBlob(alpha_image,4,data);\n            (void) WriteBlob(alpha_image,length,chunk);\n            (void) WriteBlobMSBULong(alpha_image,\n              crc32(crc32(0,data,4),chunk,(uInt) length));\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if ((memcmp(type,mng_JDAA,4) == 0) || (memcmp(type,mng_JdAA,4) == 0))\n      {\n        /* Copy chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying JDAA chunk data to alpha_blob.\");\n\n            (void) WriteBlob(alpha_image,length,chunk);\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_JSEP,4) == 0)\n      {\n        read_JSEP=MagickTrue;\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_bKGD,4) == 0)\n      {\n        if (length == 2)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=image->background_color.red;\n            image->background_color.blue=image->background_color.red;\n          }\n\n        if (length == 6)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=ScaleCharToQuantum(p[3]);\n            image->background_color.blue=ScaleCharToQuantum(p[5]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_gAMA,4) == 0)\n      {\n        if (length == 4)\n          image->gamma=((float) mng_get_long(p))*0.00001;\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_cHRM,4) == 0)\n      {\n        if (length == 32)\n          {\n            image->chromaticity.white_point.x=0.00001*mng_get_long(p);\n            image->chromaticity.white_point.y=0.00001*mng_get_long(&p[4]);\n            image->chromaticity.red_primary.x=0.00001*mng_get_long(&p[8]);\n            image->chromaticity.red_primary.y=0.00001*mng_get_long(&p[12]);\n            image->chromaticity.green_primary.x=0.00001*mng_get_long(&p[16]);\n            image->chromaticity.green_primary.y=0.00001*mng_get_long(&p[20]);\n            image->chromaticity.blue_primary.x=0.00001*mng_get_long(&p[24]);\n            image->chromaticity.blue_primary.y=0.00001*mng_get_long(&p[28]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_sRGB,4) == 0)\n      {\n        if (length == 1)\n          {\n            image->rendering_intent=\n              Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n            image->gamma=1.000f/2.200f;\n            image->chromaticity.red_primary.x=0.6400f;\n            image->chromaticity.red_primary.y=0.3300f;\n            image->chromaticity.green_primary.x=0.3000f;\n            image->chromaticity.green_primary.y=0.6000f;\n            image->chromaticity.blue_primary.x=0.1500f;\n            image->chromaticity.blue_primary.y=0.0600f;\n            image->chromaticity.white_point.x=0.3127f;\n            image->chromaticity.white_point.y=0.3290f;\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_oFFs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->page.x=(ssize_t) mng_get_long(p);\n            image->page.y=(ssize_t) mng_get_long(&p[4]);\n\n            if ((int) p[8] != 0)\n              {\n                image->page.x/=10000;\n                image->page.y/=10000;\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_pHYs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->x_resolution=(double) mng_get_long(p);\n            image->y_resolution=(double) mng_get_long(&p[4]);\n            if ((int) p[8] == PNG_RESOLUTION_METER)\n              {\n                image->units=PixelsPerCentimeterResolution;\n                image->x_resolution=image->x_resolution/100.0f;\n                image->y_resolution=image->y_resolution/100.0f;\n              }\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n#if 0\n    if (memcmp(type,mng_iCCP,4) == 0)\n      {\n        /* To do: */\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n#endif\n\n    if (length != 0)\n      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n    if (memcmp(type,mng_IEND,4))\n      continue;\n\n    break;\n  }\n\n\n  /* IEND found */\n\n  /*\n    Finish up reading image data:\n\n       o read main image from color_blob.\n\n       o close color_blob.\n\n       o if (color_type has alpha)\n            if alpha_encoding is PNG\n               read secondary image from alpha_blob via ReadPNG\n            if alpha_encoding is JPEG\n               read secondary image from alpha_blob via ReadJPEG\n\n       o close alpha_blob.\n\n       o copy intensity of secondary image into\n         opacity samples of main image.\n\n       o destroy the secondary image.\n  */\n\n  if (color_image_info == (ImageInfo *) NULL)\n    {\n      assert(color_image == (Image *) NULL);\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  if (color_image == (Image *) NULL)\n    {\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  (void) SeekBlob(color_image,0,SEEK_SET);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Reading jng_image from color_blob.\");\n\n  assert(color_image_info != (ImageInfo *) NULL);\n  (void) FormatLocaleString(color_image_info->filename,MaxTextExtent,\"%s\",\n    color_image->filename);\n\n  color_image_info->ping=MagickFalse;   /* To do: avoid this */\n  jng_image=ReadImage(color_image_info,exception);\n\n  (void) RelinquishUniqueFileResource(color_image->filename);\n  unique_filenames--;\n  color_image=DestroyImage(color_image);\n  color_image_info=DestroyImageInfo(color_image_info);\n\n  if (jng_image == (Image *) NULL)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Copying jng_image pixels to main image.\");\n  image->columns=jng_width;\n  image->rows=jng_height;\n  length=image->columns*sizeof(PixelPacket);\n\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    s=GetVirtualPixels(jng_image,0,y,image->columns,1,&image->exception);\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    (void) CopyMagickMemory(q,s,length);\n\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n\n  jng_image=DestroyImage(jng_image);\n\n  if (image_info->ping == MagickFalse)\n    {\n     if (jng_color_type >= 12)\n       {\n         if (jng_alpha_compression_method == 0)\n           {\n             png_byte\n               data[5];\n             (void) WriteBlobMSBULong(alpha_image,0x00000000L);\n             PNGType(data,mng_IEND);\n             LogPNGChunk(logging,mng_IEND,0L);\n             (void) WriteBlob(alpha_image,4,data);\n             (void) WriteBlobMSBULong(alpha_image,crc32(0,data,4));\n           }\n\n         (void) SeekBlob(alpha_image,0,SEEK_SET);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"    Reading opacity from alpha_blob.\");\n\n         (void) FormatLocaleString(alpha_image_info->filename,MaxTextExtent,\n           \"%s\",alpha_image->filename);\n\n         jng_image=ReadImage(alpha_image_info,exception);\n\n         if (jng_image != (Image *) NULL)\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             s=GetVirtualPixels(jng_image,0,y,image->columns,1,\n                &image->exception);\n             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (image->matte != MagickFalse)\n               for (x=(ssize_t) image->columns; x != 0; x--,q++,s++)\n                  SetPixelOpacity(q,QuantumRange-\n                      GetPixelRed(s));\n\n             else\n               for (x=(ssize_t) image->columns; x != 0; x--,q++,s++)\n               {\n                  SetPixelAlpha(q,GetPixelRed(s));\n                  if (GetPixelOpacity(q) != OpaqueOpacity)\n                    image->matte=MagickTrue;\n               }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n           }\n         (void) RelinquishUniqueFileResource(alpha_image->filename);\n         unique_filenames--;\n         alpha_image=DestroyImage(alpha_image);\n         alpha_image_info=DestroyImageInfo(alpha_image_info);\n         if (jng_image != (Image *) NULL)\n           jng_image=DestroyImage(jng_image);\n       }\n    }\n\n  /* Read the JNG image.  */\n\n  if (mng_info->mng_type == 0)\n    {\n      mng_info->mng_width=jng_width;\n      mng_info->mng_height=jng_height;\n    }\n\n  if (image->page.width == 0 && image->page.height == 0)\n    {\n      image->page.width=jng_width;\n      image->page.height=jng_height;\n    }\n\n  if (image->page.x == 0 && image->page.y == 0)\n    {\n      image->page.x=mng_info->x_off[mng_info->object_id];\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  else\n    {\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  mng_info->image_found++;\n  status=SetImageProgress(image,LoadImagesTag,2*TellBlob(image),\n    2*GetBlobSize(image));\n\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneJNGImage(); unique_filenames=%d\",unique_filenames);\n\n  return(image);\n}",
        "func": "static Image *ReadOneJNGImage(MngInfo *mng_info,\n    const ImageInfo *image_info, ExceptionInfo *exception)\n{\n  Image\n    *alpha_image,\n    *color_image,\n    *image,\n    *jng_image;\n\n  ImageInfo\n    *alpha_image_info,\n    *color_image_info;\n\n  MagickBooleanType\n    logging;\n\n  int\n    unique_filenames;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    status;\n\n  png_uint_32\n    jng_height,\n    jng_width;\n\n  png_byte\n    jng_color_type,\n    jng_image_sample_depth,\n    jng_image_compression_method,\n    jng_image_interlace_method,\n    jng_alpha_sample_depth,\n    jng_alpha_compression_method,\n    jng_alpha_filter_method,\n    jng_alpha_interlace_method;\n\n  register const PixelPacket\n    *s;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *p;\n\n  unsigned int\n    read_JSEP,\n    reading_idat;\n\n  size_t\n    length;\n\n  jng_alpha_compression_method=0;\n  jng_alpha_sample_depth=8;\n  jng_color_type=0;\n  jng_height=0;\n  jng_width=0;\n  alpha_image=(Image *) NULL;\n  color_image=(Image *) NULL;\n  alpha_image_info=(ImageInfo *) NULL;\n  color_image_info=(ImageInfo *) NULL;\n  unique_filenames=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneJNGImage()\");\n\n  image=mng_info->image;\n\n  if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n    {\n      /*\n        Allocate next image structure.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  AcquireNextImage()\");\n\n      AcquireNextImage(image_info,image);\n\n      if (GetNextImageInList(image) == (Image *) NULL)\n        return(DestroyImageList(image));\n\n      image=SyncNextImageInList(image);\n    }\n  mng_info->image=image;\n\n  /*\n    Signature bytes have already been read.\n  */\n\n  read_JSEP=MagickFalse;\n  reading_idat=MagickFalse;\n  for (;;)\n  {\n    char\n      type[MaxTextExtent];\n\n    unsigned char\n      *chunk;\n\n    unsigned int\n      count;\n\n    /*\n      Read a new JNG chunk.\n    */\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      2*GetBlobSize(image));\n\n    if (status == MagickFalse)\n      break;\n\n    type[0]='\\0';\n    (void) ConcatenateMagickString(type,\"errr\",MaxTextExtent);\n    length=ReadBlobMSBLong(image);\n    count=(unsigned int) ReadBlob(image,4,(unsigned char *) type);\n\n    if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Reading JNG chunk type %c%c%c%c, length: %.20g\",\n        type[0],type[1],type[2],type[3],(double) length);\n\n    if (length > PNG_UINT_31_MAX || count == 0)\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n\n    p=NULL;\n    chunk=(unsigned char *) NULL;\n\n    if (length != 0)\n      {\n        chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));\n\n        if (chunk == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        for (i=0; i < (ssize_t) length; i++)\n          chunk[i]=(unsigned char) ReadBlobByte(image);\n\n        p=chunk;\n      }\n\n    (void) ReadBlobMSBLong(image);  /* read crc word */\n\n    if (memcmp(type,mng_JHDR,4) == 0)\n      {\n        if (length == 16)\n          {\n            jng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n              (p[2] << 8) | p[3]);\n            jng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n              (p[6] << 8) | p[7]);\n            if ((jng_width == 0) || (jng_height == 0))\n              ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n            jng_color_type=p[8];\n            jng_image_sample_depth=p[9];\n            jng_image_compression_method=p[10];\n            jng_image_interlace_method=p[11];\n\n            image->interlace=jng_image_interlace_method != 0 ? PNGInterlace :\n              NoInterlace;\n\n            jng_alpha_sample_depth=p[12];\n            jng_alpha_compression_method=p[13];\n            jng_alpha_filter_method=p[14];\n            jng_alpha_interlace_method=p[15];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_width:      %16lu,    jng_height:     %16lu\\n\"\n                  \"    jng_color_type: %16d,     jng_image_sample_depth: %3d\\n\"\n                  \"    jng_image_compression_method:%3d\",\n                  (unsigned long) jng_width, (unsigned long) jng_height,\n                  jng_color_type, jng_image_sample_depth,\n                  jng_image_compression_method);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_image_interlace_method:  %3d\"\n                  \"    jng_alpha_sample_depth:      %3d\",\n                  jng_image_interlace_method,\n                  jng_alpha_sample_depth);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_alpha_compression_method:%3d\\n\"\n                  \"    jng_alpha_filter_method:     %3d\\n\"\n                  \"    jng_alpha_interlace_method:  %3d\",\n                  jng_alpha_compression_method,\n                  jng_alpha_filter_method,\n                  jng_alpha_interlace_method);\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n\n    if ((reading_idat == MagickFalse) && (read_JSEP == MagickFalse) &&\n        ((memcmp(type,mng_JDAT,4) == 0) || (memcmp(type,mng_JdAA,4) == 0) ||\n         (memcmp(type,mng_IDAT,4) == 0) || (memcmp(type,mng_JDAA,4) == 0)))\n      {\n        /*\n           o create color_image\n           o open color_blob, attached to color_image\n           o if (color type has alpha)\n               open alpha_blob, attached to alpha_image\n        */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Creating color_blob.\");\n\n        color_image_info=(ImageInfo *)AcquireMagickMemory(sizeof(ImageInfo));\n\n        if (color_image_info == (ImageInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        GetImageInfo(color_image_info);\n        color_image=AcquireImage(color_image_info);\n\n        if (color_image == (Image *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        (void) AcquireUniqueFilename(color_image->filename);\n        unique_filenames++;\n        status=OpenBlob(color_image_info,color_image,WriteBinaryBlobMode,\n          exception);\n\n        if (status == MagickFalse)\n          {\n            color_image=DestroyImage(color_image);\n            return(DestroyImageList(image));\n          }\n\n        if ((image_info->ping == MagickFalse) && (jng_color_type >= 12))\n          {\n            alpha_image_info=(ImageInfo *)\n              AcquireMagickMemory(sizeof(ImageInfo));\n\n            if (alpha_image_info == (ImageInfo *) NULL)\n              {\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            GetImageInfo(alpha_image_info);\n            alpha_image=AcquireImage(alpha_image_info);\n\n            if (alpha_image == (Image *) NULL)\n              {\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Creating alpha_blob.\");\n\n            (void) AcquireUniqueFilename(alpha_image->filename);\n            unique_filenames++;\n            status=OpenBlob(alpha_image_info,alpha_image,WriteBinaryBlobMode,\n              exception);\n\n            if (status == MagickFalse)\n              {\n                alpha_image=DestroyImage(alpha_image);\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                return(DestroyImageList(image));\n              }\n\n            if (jng_alpha_compression_method == 0)\n              {\n                unsigned char\n                  data[18];\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Writing IHDR chunk to alpha_blob.\");\n\n                (void) WriteBlob(alpha_image,8,(const unsigned char *)\n                  \"\\211PNG\\r\\n\\032\\n\");\n\n                (void) WriteBlobMSBULong(alpha_image,13L);\n                PNGType(data,mng_IHDR);\n                LogPNGChunk(logging,mng_IHDR,13L);\n                PNGLong(data+4,jng_width);\n                PNGLong(data+8,jng_height);\n                data[12]=jng_alpha_sample_depth;\n                data[13]=0; /* color_type gray */\n                data[14]=0; /* compression method 0 */\n                data[15]=0; /* filter_method 0 */\n                data[16]=0; /* interlace_method 0 */\n                (void) WriteBlob(alpha_image,17,data);\n                (void) WriteBlobMSBULong(alpha_image,crc32(0,data,17));\n              }\n          }\n        reading_idat=MagickTrue;\n      }\n\n    if (memcmp(type,mng_JDAT,4) == 0)\n      {\n        /* Copy chunk to color_image->blob */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Copying JDAT chunk data to color_blob.\");\n\n        (void) WriteBlob(color_image,length,chunk);\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_IDAT,4) == 0)\n      {\n        png_byte\n           data[5];\n\n        /* Copy IDAT header and chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying IDAT chunk data to alpha_blob.\");\n\n            (void) WriteBlobMSBULong(alpha_image,(size_t) length);\n            PNGType(data,mng_IDAT);\n            LogPNGChunk(logging,mng_IDAT,length);\n            (void) WriteBlob(alpha_image,4,data);\n            (void) WriteBlob(alpha_image,length,chunk);\n            (void) WriteBlobMSBULong(alpha_image,\n              crc32(crc32(0,data,4),chunk,(uInt) length));\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if ((memcmp(type,mng_JDAA,4) == 0) || (memcmp(type,mng_JdAA,4) == 0))\n      {\n        /* Copy chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying JDAA chunk data to alpha_blob.\");\n\n            (void) WriteBlob(alpha_image,length,chunk);\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_JSEP,4) == 0)\n      {\n        read_JSEP=MagickTrue;\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_bKGD,4) == 0)\n      {\n        if (length == 2)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=image->background_color.red;\n            image->background_color.blue=image->background_color.red;\n          }\n\n        if (length == 6)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=ScaleCharToQuantum(p[3]);\n            image->background_color.blue=ScaleCharToQuantum(p[5]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_gAMA,4) == 0)\n      {\n        if (length == 4)\n          image->gamma=((float) mng_get_long(p))*0.00001;\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_cHRM,4) == 0)\n      {\n        if (length == 32)\n          {\n            image->chromaticity.white_point.x=0.00001*mng_get_long(p);\n            image->chromaticity.white_point.y=0.00001*mng_get_long(&p[4]);\n            image->chromaticity.red_primary.x=0.00001*mng_get_long(&p[8]);\n            image->chromaticity.red_primary.y=0.00001*mng_get_long(&p[12]);\n            image->chromaticity.green_primary.x=0.00001*mng_get_long(&p[16]);\n            image->chromaticity.green_primary.y=0.00001*mng_get_long(&p[20]);\n            image->chromaticity.blue_primary.x=0.00001*mng_get_long(&p[24]);\n            image->chromaticity.blue_primary.y=0.00001*mng_get_long(&p[28]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_sRGB,4) == 0)\n      {\n        if (length == 1)\n          {\n            image->rendering_intent=\n              Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n            image->gamma=1.000f/2.200f;\n            image->chromaticity.red_primary.x=0.6400f;\n            image->chromaticity.red_primary.y=0.3300f;\n            image->chromaticity.green_primary.x=0.3000f;\n            image->chromaticity.green_primary.y=0.6000f;\n            image->chromaticity.blue_primary.x=0.1500f;\n            image->chromaticity.blue_primary.y=0.0600f;\n            image->chromaticity.white_point.x=0.3127f;\n            image->chromaticity.white_point.y=0.3290f;\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_oFFs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->page.x=(ssize_t) mng_get_long(p);\n            image->page.y=(ssize_t) mng_get_long(&p[4]);\n\n            if ((int) p[8] != 0)\n              {\n                image->page.x/=10000;\n                image->page.y/=10000;\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_pHYs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->x_resolution=(double) mng_get_long(p);\n            image->y_resolution=(double) mng_get_long(&p[4]);\n            if ((int) p[8] == PNG_RESOLUTION_METER)\n              {\n                image->units=PixelsPerCentimeterResolution;\n                image->x_resolution=image->x_resolution/100.0f;\n                image->y_resolution=image->y_resolution/100.0f;\n              }\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n#if 0\n    if (memcmp(type,mng_iCCP,4) == 0)\n      {\n        /* To do: */\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n#endif\n\n    if (length != 0)\n      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n    if (memcmp(type,mng_IEND,4))\n      continue;\n\n    break;\n  }\n\n\n  /* IEND found */\n\n  /*\n    Finish up reading image data:\n\n       o read main image from color_blob.\n\n       o close color_blob.\n\n       o if (color_type has alpha)\n            if alpha_encoding is PNG\n               read secondary image from alpha_blob via ReadPNG\n            if alpha_encoding is JPEG\n               read secondary image from alpha_blob via ReadJPEG\n\n       o close alpha_blob.\n\n       o copy intensity of secondary image into\n         opacity samples of main image.\n\n       o destroy the secondary image.\n  */\n\n  if (color_image_info == (ImageInfo *) NULL)\n    {\n      assert(color_image == (Image *) NULL);\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  if (color_image == (Image *) NULL)\n    {\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  (void) SeekBlob(color_image,0,SEEK_SET);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Reading jng_image from color_blob.\");\n\n  assert(color_image_info != (ImageInfo *) NULL);\n  (void) FormatLocaleString(color_image_info->filename,MaxTextExtent,\"%s\",\n    color_image->filename);\n\n  color_image_info->ping=MagickFalse;   /* To do: avoid this */\n  jng_image=ReadImage(color_image_info,exception);\n\n  (void) RelinquishUniqueFileResource(color_image->filename);\n  unique_filenames--;\n  color_image=DestroyImage(color_image);\n  color_image_info=DestroyImageInfo(color_image_info);\n\n  if (jng_image == (Image *) NULL)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Copying jng_image pixels to main image.\");\n  image->columns=jng_width;\n  image->rows=jng_height;\n  length=image->columns*sizeof(PixelPacket);\n\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    s=GetVirtualPixels(jng_image,0,y,image->columns,1,&image->exception);\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    (void) CopyMagickMemory(q,s,length);\n\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n\n  jng_image=DestroyImage(jng_image);\n\n  if (image_info->ping == MagickFalse)\n    {\n     if (jng_color_type >= 12)\n       {\n         if (jng_alpha_compression_method == 0)\n           {\n             png_byte\n               data[5];\n             (void) WriteBlobMSBULong(alpha_image,0x00000000L);\n             PNGType(data,mng_IEND);\n             LogPNGChunk(logging,mng_IEND,0L);\n             (void) WriteBlob(alpha_image,4,data);\n             (void) WriteBlobMSBULong(alpha_image,crc32(0,data,4));\n           }\n\n         (void) SeekBlob(alpha_image,0,SEEK_SET);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"    Reading opacity from alpha_blob.\");\n\n         (void) FormatLocaleString(alpha_image_info->filename,MaxTextExtent,\n           \"%s\",alpha_image->filename);\n\n         jng_image=ReadImage(alpha_image_info,exception);\n\n         if (jng_image != (Image *) NULL)\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             s=GetVirtualPixels(jng_image,0,y,image->columns,1,\n                &image->exception);\n             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (image->matte != MagickFalse)\n               for (x=(ssize_t) image->columns; x != 0; x--,q++,s++)\n                  SetPixelOpacity(q,QuantumRange-\n                      GetPixelRed(s));\n\n             else\n               for (x=(ssize_t) image->columns; x != 0; x--,q++,s++)\n               {\n                  SetPixelAlpha(q,GetPixelRed(s));\n                  if (GetPixelOpacity(q) != OpaqueOpacity)\n                    image->matte=MagickTrue;\n               }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n           }\n         (void) RelinquishUniqueFileResource(alpha_image->filename);\n         unique_filenames--;\n         alpha_image=DestroyImage(alpha_image);\n         alpha_image_info=DestroyImageInfo(alpha_image_info);\n         if (jng_image != (Image *) NULL)\n           jng_image=DestroyImage(jng_image);\n       }\n    }\n\n  /* Read the JNG image.  */\n\n  if (mng_info->mng_type == 0)\n    {\n      mng_info->mng_width=jng_width;\n      mng_info->mng_height=jng_height;\n    }\n\n  if (image->page.width == 0 && image->page.height == 0)\n    {\n      image->page.width=jng_width;\n      image->page.height=jng_height;\n    }\n\n  if (image->page.x == 0 && image->page.y == 0)\n    {\n      image->page.x=mng_info->x_off[mng_info->object_id];\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  else\n    {\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  mng_info->image_found++;\n  status=SetImageProgress(image,LoadImagesTag,2*TellBlob(image),\n    2*GetBlobSize(image));\n\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneJNGImage(); unique_filenames=%d\",unique_filenames);\n\n  return(image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -236,7 +236,10 @@\n           exception);\n \n         if (status == MagickFalse)\n-          return(DestroyImageList(image));\n+          {\n+            color_image=DestroyImage(color_image);\n+            return(DestroyImageList(image));\n+          }\n \n         if ((image_info->ping == MagickFalse) && (jng_color_type >= 12))\n           {\n@@ -244,14 +247,19 @@\n               AcquireMagickMemory(sizeof(ImageInfo));\n \n             if (alpha_image_info == (ImageInfo *) NULL)\n-              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+              {\n+                color_image=DestroyImage(color_image);\n+                ThrowReaderException(ResourceLimitError,\n+                  \"MemoryAllocationFailed\");\n+              }\n \n             GetImageInfo(alpha_image_info);\n             alpha_image=AcquireImage(alpha_image_info);\n \n             if (alpha_image == (Image *) NULL)\n               {\n-                alpha_image=DestroyImage(alpha_image);\n+                alpha_image_info=DestroyImageInfo(alpha_image_info);\n+                color_image=DestroyImage(color_image);\n                 ThrowReaderException(ResourceLimitError,\n                   \"MemoryAllocationFailed\");\n               }\n@@ -266,7 +274,12 @@\n               exception);\n \n             if (status == MagickFalse)\n-              return(DestroyImageList(image));\n+              {\n+                alpha_image=DestroyImage(alpha_image);\n+                alpha_image_info=DestroyImageInfo(alpha_image_info);\n+                color_image=DestroyImage(color_image);\n+                return(DestroyImageList(image));\n+              }\n \n             if (jng_alpha_compression_method == 0)\n               {",
        "diff_line_info": {
            "deleted_lines": [
                "          return(DestroyImageList(image));",
                "              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "                alpha_image=DestroyImage(alpha_image);",
                "              return(DestroyImageList(image));"
            ],
            "added_lines": [
                "          {",
                "            color_image=DestroyImage(color_image);",
                "            return(DestroyImageList(image));",
                "          }",
                "              {",
                "                color_image=DestroyImage(color_image);",
                "                ThrowReaderException(ResourceLimitError,",
                "                  \"MemoryAllocationFailed\");",
                "              }",
                "                alpha_image_info=DestroyImageInfo(alpha_image_info);",
                "                color_image=DestroyImage(color_image);",
                "              {",
                "                alpha_image=DestroyImage(alpha_image);",
                "                alpha_image_info=DestroyImageInfo(alpha_image_info);",
                "                color_image=DestroyImage(color_image);",
                "                return(DestroyImageList(image));",
                "              }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9405",
        "func_name": "ImageMagick/ReadICONImage",
        "description": "In ImageMagick 7.0.5-5, the ReadICONImage function in icon.c:452 allows attackers to cause a denial of service (memory leak) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/29b52a2856c00bae0f11492a124b8d6c1dd9b830",
        "commit_title": "Fixed memory leak reported in #457.",
        "commit_text": "",
        "func_before": "static Image *ReadICONImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  IconFile\n    icon_file;\n\n  IconInfo\n    icon_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    extent;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bit,\n    byte,\n    bytes_per_line,\n    one,\n    scanline_pad;\n\n  ssize_t\n    count,\n    offset,\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"%s\",image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  icon_file.reserved=(short) ReadBlobLSBShort(image);\n  icon_file.resource_type=(short) ReadBlobLSBShort(image);\n  icon_file.count=(short) ReadBlobLSBShort(image);\n  if ((icon_file.reserved != 0) ||\n      ((icon_file.resource_type != 1) && (icon_file.resource_type != 2)) ||\n      (icon_file.count > MaxIcons))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  extent=0;\n  for (i=0; i < icon_file.count; i++)\n  {\n    icon_file.directory[i].width=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].height=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].colors=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].reserved=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].planes=(unsigned short) ReadBlobLSBShort(image);\n    icon_file.directory[i].bits_per_pixel=(unsigned short)\n      ReadBlobLSBShort(image);\n    icon_file.directory[i].size=ReadBlobLSBLong(image);\n    icon_file.directory[i].offset=ReadBlobLSBLong(image);\n    if (EOFBlob(image) != MagickFalse)\n      break;\n    extent=MagickMax(extent,icon_file.directory[i].size);\n  }\n  if ((EOFBlob(image) != MagickFalse) || (extent > GetBlobSize(image)))\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  one=1;\n  for (i=0; i < icon_file.count; i++)\n  {\n    /*\n      Verify Icon identifier.\n    */\n    offset=(ssize_t) SeekBlob(image,(MagickOffsetType)\n      icon_file.directory[i].offset,SEEK_SET);\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    icon_info.size=ReadBlobLSBLong(image);\n    icon_info.width=(unsigned char) ReadBlobLSBSignedLong(image);\n    icon_info.height=(unsigned char) (ReadBlobLSBSignedLong(image)/2);\n    icon_info.planes=ReadBlobLSBShort(image);\n    icon_info.bits_per_pixel=ReadBlobLSBShort(image);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    if (((icon_info.planes == 18505) && (icon_info.bits_per_pixel == 21060)) || \n        (icon_info.size == 0x474e5089))\n      {\n        Image\n          *icon_image;\n\n        ImageInfo\n          *read_info;\n\n        size_t\n          length;\n\n        unsigned char\n          *png;\n\n        /*\n          Icon image encoded as a compressed PNG image.\n        */\n        length=icon_file.directory[i].size;\n        if ((length < 16) || (~length < 16))\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        png=(unsigned char *) AcquireQuantumMemory(length+16,sizeof(*png));\n        if (png == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) CopyMagickMemory(png,\"\\211PNG\\r\\n\\032\\n\\000\\000\\000\\015\",12);\n        png[12]=(unsigned char) icon_info.planes;\n        png[13]=(unsigned char) (icon_info.planes >> 8);\n        png[14]=(unsigned char) icon_info.bits_per_pixel;\n        png[15]=(unsigned char) (icon_info.bits_per_pixel >> 8);\n        count=ReadBlob(image,length-16,png+16);\n        icon_image=(Image *) NULL;\n        if (count > 0)\n          {\n            read_info=CloneImageInfo(image_info);\n            (void) CopyMagickString(read_info->magick,\"PNG\",MaxTextExtent);\n            icon_image=BlobToImage(read_info,png,length+16,exception);\n            read_info=DestroyImageInfo(read_info);\n          }\n        png=(unsigned char *) RelinquishMagickMemory(png);\n        if (icon_image == (Image *) NULL)\n          {\n            if (count != (ssize_t) (length-16))\n              ThrowReaderException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        DestroyBlob(icon_image);\n        icon_image->blob=ReferenceBlob(image->blob);\n        ReplaceImageInList(&image,icon_image);\n        icon_image->scene=i;\n      }\n    else\n      {\n        if (icon_info.bits_per_pixel > 32)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        icon_info.compression=ReadBlobLSBLong(image);\n        icon_info.image_size=ReadBlobLSBLong(image);\n        icon_info.x_pixels=ReadBlobLSBLong(image);\n        icon_info.y_pixels=ReadBlobLSBLong(image);\n        icon_info.number_colors=ReadBlobLSBLong(image);\n        icon_info.colors_important=ReadBlobLSBLong(image);\n        image->matte=MagickTrue;\n        image->columns=(size_t) icon_file.directory[i].width;\n        if ((ssize_t) image->columns > icon_info.width)\n          image->columns=(size_t) icon_info.width;\n        if (image->columns == 0)\n          image->columns=256;\n        image->rows=(size_t) icon_file.directory[i].height;\n        if ((ssize_t) image->rows > icon_info.height)\n          image->rows=(size_t) icon_info.height;\n        if (image->rows == 0)\n          image->rows=256;\n        image->depth=icon_info.bits_per_pixel;\n        if (image->debug != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \" scene    = %.20g\",(double) i);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   size   = %.20g\",(double) icon_info.size);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   width  = %.20g\",(double) icon_file.directory[i].width);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   height = %.20g\",(double) icon_file.directory[i].height);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   colors = %.20g\",(double ) icon_info.number_colors);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   planes = %.20g\",(double) icon_info.planes);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   bpp    = %.20g\",(double) icon_info.bits_per_pixel);\n          }\n      if ((icon_info.number_colors != 0) || (icon_info.bits_per_pixel <= 16U))\n        {\n          image->storage_class=PseudoClass;\n          image->colors=icon_info.number_colors;\n          if (image->colors == 0)\n            image->colors=one << icon_info.bits_per_pixel;\n        }\n      if (image->storage_class == PseudoClass)\n        {\n          register ssize_t\n            i;\n\n          unsigned char\n            *icon_colormap;\n\n          /*\n            Read Icon raster colormap.\n          */\n          if (AcquireImageColormap(image,image->colors) == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          icon_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n            image->colors,4UL*sizeof(*icon_colormap));\n          if (icon_colormap == (unsigned char *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          count=ReadBlob(image,(size_t) (4*image->colors),icon_colormap);\n          if (count != (ssize_t) (4*image->colors))\n            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\");\n          p=icon_colormap;\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            image->colormap[i].blue=(Quantum) ScaleCharToQuantum(*p++);\n            image->colormap[i].green=(Quantum) ScaleCharToQuantum(*p++);\n            image->colormap[i].red=(Quantum) ScaleCharToQuantum(*p++);\n            p++;\n          }\n          icon_colormap=(unsigned char *) RelinquishMagickMemory(icon_colormap);\n        }\n        /*\n          Convert Icon raster image to pixel packets.\n        */\n        if ((image_info->ping != MagickFalse) &&\n            (image_info->number_scenes != 0))\n          if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n            break;\n        status=SetImageExtent(image,image->columns,image->rows);\n        if (status == MagickFalse)\n          {\n            InheritException(exception,&image->exception);\n            return(DestroyImageList(image));\n          }\n        bytes_per_line=(((image->columns*icon_info.bits_per_pixel)+31) &\n          ~31) >> 3;\n        (void) bytes_per_line;\n        scanline_pad=((((image->columns*icon_info.bits_per_pixel)+31) & ~31)-\n          (image->columns*icon_info.bits_per_pixel)) >> 3;\n        switch (icon_info.bits_per_pixel)\n        {\n          case 1:\n          {\n            /*\n              Convert bitmap scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < (ssize_t) (image->columns-7); x+=8)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                for (bit=0; bit < 8; bit++)\n                  SetPixelIndex(indexes+x+bit,((byte & (0x80 >> bit)) != 0 ?\n                    0x01 : 0x00));\n              }\n              if ((image->columns % 8) != 0)\n                {\n                  byte=(size_t) ReadBlobByte(image);\n                  for (bit=0; bit < (image->columns % 8); bit++)\n                    SetPixelIndex(indexes+x+bit,((byte & (0x80 >> bit)) != 0 ?\n                      0x01 : 0x00));\n                }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 4:\n          {\n            /*\n              Read 4-bit Icon scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                SetPixelIndex(indexes+x,((byte >> 4) & 0xf));\n                SetPixelIndex(indexes+x+1,((byte) & 0xf));\n              }\n              if ((image->columns % 2) != 0)\n                {\n                  byte=(size_t) ReadBlobByte(image);\n                  SetPixelIndex(indexes+x,((byte >> 4) & 0xf));\n                }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 8:\n          {\n            /*\n              Convert PseudoColor scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                SetPixelIndex(indexes+x,byte);\n              }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 16:\n          {\n            /*\n              Convert PseudoColor scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                byte|=(size_t) (ReadBlobByte(image) << 8);\n                SetPixelIndex(indexes+x,byte);\n              }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 24:\n          case 32:\n          {\n            /*\n              Convert DirectColor scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n                  ReadBlobByte(image)));\n                SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n                  ReadBlobByte(image)));\n                SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n                  ReadBlobByte(image)));\n                if (icon_info.bits_per_pixel == 32)\n                  SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image)));\n                q++;\n              }\n              if (icon_info.bits_per_pixel == 24)\n                for (x=0; x < (ssize_t) scanline_pad; x++)\n                  (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          default:\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n        if ((image_info->ping == MagickFalse) &&\n            (icon_info.bits_per_pixel <= 16))\n          (void) SyncImage(image);\n        if (icon_info.bits_per_pixel != 32)\n          {\n            /*\n              Read the ICON alpha mask.\n            */\n            image->storage_class=DirectClass;\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                for (bit=0; bit < 8; bit++)\n                  SetPixelOpacity(q+x+bit,(((byte & (0x80 >> bit)) != 0) ?\n                    TransparentOpacity : OpaqueOpacity));\n              }\n              if ((image->columns % 8) != 0)\n                {\n                  byte=(size_t) ReadBlobByte(image);\n                  for (bit=0; bit < (image->columns % 8); bit++)\n                    SetPixelOpacity(q+x+bit,(((byte & (0x80 >> bit)) != 0) ?\n                      TransparentOpacity : OpaqueOpacity));\n                }\n              if ((image->columns % 32) != 0)\n                for (x=0; x < (ssize_t) ((32-(image->columns % 32))/8); x++)\n                  (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n            }\n          }\n        if (EOFBlob(image) != MagickFalse)\n          {\n            ThrowFileException(exception,CorruptImageError,\n              \"UnexpectedEndOfFile\",image->filename);\n            break;\n          }\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (i < (ssize_t) (icon_file.count-1))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadICONImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  IconFile\n    icon_file;\n\n  IconInfo\n    icon_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    extent;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bit,\n    byte,\n    bytes_per_line,\n    one,\n    scanline_pad;\n\n  ssize_t\n    count,\n    offset,\n    y;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"%s\",image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  icon_file.reserved=(short) ReadBlobLSBShort(image);\n  icon_file.resource_type=(short) ReadBlobLSBShort(image);\n  icon_file.count=(short) ReadBlobLSBShort(image);\n  if ((icon_file.reserved != 0) ||\n      ((icon_file.resource_type != 1) && (icon_file.resource_type != 2)) ||\n      (icon_file.count > MaxIcons))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  extent=0;\n  for (i=0; i < icon_file.count; i++)\n  {\n    icon_file.directory[i].width=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].height=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].colors=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].reserved=(unsigned char) ReadBlobByte(image);\n    icon_file.directory[i].planes=(unsigned short) ReadBlobLSBShort(image);\n    icon_file.directory[i].bits_per_pixel=(unsigned short)\n      ReadBlobLSBShort(image);\n    icon_file.directory[i].size=ReadBlobLSBLong(image);\n    icon_file.directory[i].offset=ReadBlobLSBLong(image);\n    if (EOFBlob(image) != MagickFalse)\n      break;\n    extent=MagickMax(extent,icon_file.directory[i].size);\n  }\n  if ((EOFBlob(image) != MagickFalse) || (extent > GetBlobSize(image)))\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  one=1;\n  for (i=0; i < icon_file.count; i++)\n  {\n    /*\n      Verify Icon identifier.\n    */\n    offset=(ssize_t) SeekBlob(image,(MagickOffsetType)\n      icon_file.directory[i].offset,SEEK_SET);\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    icon_info.size=ReadBlobLSBLong(image);\n    icon_info.width=(unsigned char) ReadBlobLSBSignedLong(image);\n    icon_info.height=(unsigned char) (ReadBlobLSBSignedLong(image)/2);\n    icon_info.planes=ReadBlobLSBShort(image);\n    icon_info.bits_per_pixel=ReadBlobLSBShort(image);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    if (((icon_info.planes == 18505) && (icon_info.bits_per_pixel == 21060)) || \n        (icon_info.size == 0x474e5089))\n      {\n        Image\n          *icon_image;\n\n        ImageInfo\n          *read_info;\n\n        size_t\n          length;\n\n        unsigned char\n          *png;\n\n        /*\n          Icon image encoded as a compressed PNG image.\n        */\n        length=icon_file.directory[i].size;\n        if ((length < 16) || (~length < 16))\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        png=(unsigned char *) AcquireQuantumMemory(length+16,sizeof(*png));\n        if (png == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) CopyMagickMemory(png,\"\\211PNG\\r\\n\\032\\n\\000\\000\\000\\015\",12);\n        png[12]=(unsigned char) icon_info.planes;\n        png[13]=(unsigned char) (icon_info.planes >> 8);\n        png[14]=(unsigned char) icon_info.bits_per_pixel;\n        png[15]=(unsigned char) (icon_info.bits_per_pixel >> 8);\n        count=ReadBlob(image,length-16,png+16);\n        icon_image=(Image *) NULL;\n        if (count > 0)\n          {\n            read_info=CloneImageInfo(image_info);\n            (void) CopyMagickString(read_info->magick,\"PNG\",MaxTextExtent);\n            icon_image=BlobToImage(read_info,png,length+16,exception);\n            read_info=DestroyImageInfo(read_info);\n          }\n        png=(unsigned char *) RelinquishMagickMemory(png);\n        if (icon_image == (Image *) NULL)\n          {\n            if (count != (ssize_t) (length-16))\n              ThrowReaderException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        DestroyBlob(icon_image);\n        icon_image->blob=ReferenceBlob(image->blob);\n        ReplaceImageInList(&image,icon_image);\n        icon_image->scene=i;\n      }\n    else\n      {\n        if (icon_info.bits_per_pixel > 32)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        icon_info.compression=ReadBlobLSBLong(image);\n        icon_info.image_size=ReadBlobLSBLong(image);\n        icon_info.x_pixels=ReadBlobLSBLong(image);\n        icon_info.y_pixels=ReadBlobLSBLong(image);\n        icon_info.number_colors=ReadBlobLSBLong(image);\n        icon_info.colors_important=ReadBlobLSBLong(image);\n        image->matte=MagickTrue;\n        image->columns=(size_t) icon_file.directory[i].width;\n        if ((ssize_t) image->columns > icon_info.width)\n          image->columns=(size_t) icon_info.width;\n        if (image->columns == 0)\n          image->columns=256;\n        image->rows=(size_t) icon_file.directory[i].height;\n        if ((ssize_t) image->rows > icon_info.height)\n          image->rows=(size_t) icon_info.height;\n        if (image->rows == 0)\n          image->rows=256;\n        image->depth=icon_info.bits_per_pixel;\n        if (image->debug != MagickFalse)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \" scene    = %.20g\",(double) i);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   size   = %.20g\",(double) icon_info.size);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   width  = %.20g\",(double) icon_file.directory[i].width);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   height = %.20g\",(double) icon_file.directory[i].height);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   colors = %.20g\",(double ) icon_info.number_colors);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   planes = %.20g\",(double) icon_info.planes);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"   bpp    = %.20g\",(double) icon_info.bits_per_pixel);\n          }\n      if ((icon_info.number_colors != 0) || (icon_info.bits_per_pixel <= 16U))\n        {\n          image->storage_class=PseudoClass;\n          image->colors=icon_info.number_colors;\n          if (image->colors == 0)\n            image->colors=one << icon_info.bits_per_pixel;\n        }\n      if (image->storage_class == PseudoClass)\n        {\n          register ssize_t\n            i;\n\n          unsigned char\n            *icon_colormap;\n\n          /*\n            Read Icon raster colormap.\n          */\n          if (AcquireImageColormap(image,image->colors) == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          icon_colormap=(unsigned char *) AcquireQuantumMemory((size_t)\n            image->colors,4UL*sizeof(*icon_colormap));\n          if (icon_colormap == (unsigned char *) NULL)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          count=ReadBlob(image,(size_t) (4*image->colors),icon_colormap);\n          if (count != (ssize_t) (4*image->colors))\n            {\n              icon_colormap=(unsigned char *) RelinquishMagickMemory(\n                icon_colormap);\n              ThrowReaderException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            }\n          p=icon_colormap;\n          for (i=0; i < (ssize_t) image->colors; i++)\n          {\n            image->colormap[i].blue=(Quantum) ScaleCharToQuantum(*p++);\n            image->colormap[i].green=(Quantum) ScaleCharToQuantum(*p++);\n            image->colormap[i].red=(Quantum) ScaleCharToQuantum(*p++);\n            p++;\n          }\n          icon_colormap=(unsigned char *) RelinquishMagickMemory(icon_colormap);\n        }\n        /*\n          Convert Icon raster image to pixel packets.\n        */\n        if ((image_info->ping != MagickFalse) &&\n            (image_info->number_scenes != 0))\n          if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n            break;\n        status=SetImageExtent(image,image->columns,image->rows);\n        if (status == MagickFalse)\n          {\n            InheritException(exception,&image->exception);\n            return(DestroyImageList(image));\n          }\n        bytes_per_line=(((image->columns*icon_info.bits_per_pixel)+31) &\n          ~31) >> 3;\n        (void) bytes_per_line;\n        scanline_pad=((((image->columns*icon_info.bits_per_pixel)+31) & ~31)-\n          (image->columns*icon_info.bits_per_pixel)) >> 3;\n        switch (icon_info.bits_per_pixel)\n        {\n          case 1:\n          {\n            /*\n              Convert bitmap scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < (ssize_t) (image->columns-7); x+=8)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                for (bit=0; bit < 8; bit++)\n                  SetPixelIndex(indexes+x+bit,((byte & (0x80 >> bit)) != 0 ?\n                    0x01 : 0x00));\n              }\n              if ((image->columns % 8) != 0)\n                {\n                  byte=(size_t) ReadBlobByte(image);\n                  for (bit=0; bit < (image->columns % 8); bit++)\n                    SetPixelIndex(indexes+x+bit,((byte & (0x80 >> bit)) != 0 ?\n                      0x01 : 0x00));\n                }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 4:\n          {\n            /*\n              Read 4-bit Icon scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                SetPixelIndex(indexes+x,((byte >> 4) & 0xf));\n                SetPixelIndex(indexes+x+1,((byte) & 0xf));\n              }\n              if ((image->columns % 2) != 0)\n                {\n                  byte=(size_t) ReadBlobByte(image);\n                  SetPixelIndex(indexes+x,((byte >> 4) & 0xf));\n                }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 8:\n          {\n            /*\n              Convert PseudoColor scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                SetPixelIndex(indexes+x,byte);\n              }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 16:\n          {\n            /*\n              Convert PseudoColor scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              indexes=GetAuthenticIndexQueue(image);\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                byte|=(size_t) (ReadBlobByte(image) << 8);\n                SetPixelIndex(indexes+x,byte);\n              }\n              for (x=0; x < (ssize_t) scanline_pad; x++)\n                (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          case 24:\n          case 32:\n          {\n            /*\n              Convert DirectColor scanline.\n            */\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                SetPixelBlue(q,ScaleCharToQuantum((unsigned char)\n                  ReadBlobByte(image)));\n                SetPixelGreen(q,ScaleCharToQuantum((unsigned char)\n                  ReadBlobByte(image)));\n                SetPixelRed(q,ScaleCharToQuantum((unsigned char)\n                  ReadBlobByte(image)));\n                if (icon_info.bits_per_pixel == 32)\n                  SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)\n                    ReadBlobByte(image)));\n                q++;\n              }\n              if (icon_info.bits_per_pixel == 24)\n                for (x=0; x < (ssize_t) scanline_pad; x++)\n                  (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n                    image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n            break;\n          }\n          default:\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n        if ((image_info->ping == MagickFalse) &&\n            (icon_info.bits_per_pixel <= 16))\n          (void) SyncImage(image);\n        if (icon_info.bits_per_pixel != 32)\n          {\n            /*\n              Read the ICON alpha mask.\n            */\n            image->storage_class=DirectClass;\n            for (y=(ssize_t) image->rows-1; y >= 0; y--)\n            {\n              q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n              if (q == (PixelPacket *) NULL)\n                break;\n              for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n              {\n                byte=(size_t) ReadBlobByte(image);\n                for (bit=0; bit < 8; bit++)\n                  SetPixelOpacity(q+x+bit,(((byte & (0x80 >> bit)) != 0) ?\n                    TransparentOpacity : OpaqueOpacity));\n              }\n              if ((image->columns % 8) != 0)\n                {\n                  byte=(size_t) ReadBlobByte(image);\n                  for (bit=0; bit < (image->columns % 8); bit++)\n                    SetPixelOpacity(q+x+bit,(((byte & (0x80 >> bit)) != 0) ?\n                      TransparentOpacity : OpaqueOpacity));\n                }\n              if ((image->columns % 32) != 0)\n                for (x=0; x < (ssize_t) ((32-(image->columns % 32))/8); x++)\n                  (void) ReadBlobByte(image);\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n            }\n          }\n        if (EOFBlob(image) != MagickFalse)\n          {\n            ThrowFileException(exception,CorruptImageError,\n              \"UnexpectedEndOfFile\",image->filename);\n            break;\n          }\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (i < (ssize_t) (icon_file.count-1))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -219,8 +219,12 @@\n             ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n           count=ReadBlob(image,(size_t) (4*image->colors),icon_colormap);\n           if (count != (ssize_t) (4*image->colors))\n-            ThrowReaderException(CorruptImageError,\n-              \"InsufficientImageDataInFile\");\n+            {\n+              icon_colormap=(unsigned char *) RelinquishMagickMemory(\n+                icon_colormap);\n+              ThrowReaderException(CorruptImageError,\n+                \"InsufficientImageDataInFile\");\n+            }\n           p=icon_colormap;\n           for (i=0; i < (ssize_t) image->colors; i++)\n           {",
        "diff_line_info": {
            "deleted_lines": [
                "            ThrowReaderException(CorruptImageError,",
                "              \"InsufficientImageDataInFile\");"
            ],
            "added_lines": [
                "            {",
                "              icon_colormap=(unsigned char *) RelinquishMagickMemory(",
                "                icon_colormap);",
                "              ThrowReaderException(CorruptImageError,",
                "                \"InsufficientImageDataInFile\");",
                "            }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9407",
        "func_name": "ImageMagick/ReadPALMImage",
        "description": "In ImageMagick 7.0.5-5, the ReadPALMImage function in palm.c allows attackers to cause a denial of service (memory leak) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/7851278ed92bcdef72132ceadee9256c9d98acf1",
        "commit_title": "Fixed memory leak reported in #459.",
        "commit_text": "",
        "func_before": "static Image *ReadPALMImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    totalOffset,\n    seekNextDepth;\n\n  MagickPixelPacket\n    transpix;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  size_t\n    bytes_per_row,\n    flags,\n    bits_per_pixel,\n    version,\n    nextDepthOffset,\n    transparentIndex,\n    compressionType,\n    byte,\n    mask,\n    redbits,\n    greenbits,\n    bluebits,\n    one,\n    pad,\n    size,\n    bit;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *lastrow,\n    *one_row,\n    *ptr;\n\n  unsigned short\n    color16;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      (void) DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  totalOffset=0;\n  do\n  {\n    image->columns=ReadBlobMSBShort(image);\n    image->rows=ReadBlobMSBShort(image);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((image->columns == 0) || (image->rows == 0))\n      ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    bytes_per_row=ReadBlobMSBShort(image);\n    flags=ReadBlobMSBShort(image);\n    bits_per_pixel=(size_t) ReadBlobByte(image);\n    if ((bits_per_pixel != 1) && (bits_per_pixel != 2) &&\n        (bits_per_pixel != 4) && (bits_per_pixel != 8) &&\n        (bits_per_pixel != 16))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n    version=(size_t) ReadBlobByte(image);\n    if ((version != 0) && (version != 1) && (version != 2))\n      ThrowReaderException(CorruptImageError,\"FileFormatVersionMismatch\");\n    nextDepthOffset=(size_t) ReadBlobMSBShort(image);\n    transparentIndex=(size_t) ReadBlobByte(image);\n    compressionType=(size_t) ReadBlobByte(image);\n    if ((compressionType != PALM_COMPRESSION_NONE) &&\n        (compressionType != PALM_COMPRESSION_SCANLINE ) &&\n        (compressionType != PALM_COMPRESSION_RLE))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n    pad=ReadBlobMSBShort(image);\n    (void) pad;\n    /*\n      Initialize image colormap.\n    */\n    one=1;\n    if ((bits_per_pixel < 16) &&\n        (AcquireImageColormap(image,one << bits_per_pixel) == MagickFalse))\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    GetMagickPixelPacket(image,&transpix);\n    if (bits_per_pixel == 16)  /* Direct Color */\n      {\n        redbits=(size_t) ReadBlobByte(image);  /* # of bits of red */\n        (void) redbits;\n        greenbits=(size_t) ReadBlobByte(image);  /* # of bits of green */\n        (void) greenbits;\n        bluebits=(size_t) ReadBlobByte(image);  /* # of bits of blue */\n        (void) bluebits;\n        ReadBlobByte(image);  /* reserved by Palm */\n        ReadBlobByte(image);  /* reserved by Palm */\n        transpix.red=(MagickRealType) (QuantumRange*ReadBlobByte(image)/31);\n        transpix.green=(MagickRealType) (QuantumRange*ReadBlobByte(image)/63);\n        transpix.blue=(MagickRealType) (QuantumRange*ReadBlobByte(image)/31);\n      }\n    if (bits_per_pixel == 8)\n      {\n        IndexPacket\n          index;\n\n        if (flags & PALM_HAS_COLORMAP_FLAG)\n          {\n            count=(ssize_t) ReadBlobMSBShort(image);\n            for (i=0; i < (ssize_t) count; i++)\n            {\n              ReadBlobByte(image);\n              index=ConstrainColormapIndex(image,(size_t) (255-i));\n              image->colormap[(int) index].red=ScaleCharToQuantum(\n                (unsigned char) ReadBlobByte(image));\n              image->colormap[(int) index].green=ScaleCharToQuantum(\n                (unsigned char) ReadBlobByte(image));\n              image->colormap[(int) index].blue=ScaleCharToQuantum(\n                (unsigned char) ReadBlobByte(image));\n          }\n        }\n      else\n        for (i=0; i < (ssize_t) (1L << bits_per_pixel); i++)\n        {\n          index=ConstrainColormapIndex(image,(size_t) (255-i));\n          image->colormap[(int) index].red=ScaleCharToQuantum(\n            PalmPalette[i][0]);\n          image->colormap[(int) index].green=ScaleCharToQuantum(\n            PalmPalette[i][1]);\n          image->colormap[(int) index].blue=ScaleCharToQuantum(\n            PalmPalette[i][2]);\n        }\n      }\n    if (flags & PALM_IS_COMPRESSED_FLAG)\n      size=ReadBlobMSBShort(image);\n    (void) size;\n    image->storage_class=DirectClass;\n    if (bits_per_pixel < 16)\n      {\n        image->storage_class=PseudoClass;\n        image->depth=8;\n      }\n    if (image_info->ping != MagickFalse) \n      {\n        (void) CloseBlob(image);\n        return(image);\n      }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    one_row=(unsigned char *) AcquireQuantumMemory(MagickMax(bytes_per_row,\n      2*image->columns),sizeof(*one_row));\n    if (one_row == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    lastrow=(unsigned char *) NULL;\n    if (compressionType == PALM_COMPRESSION_SCANLINE)\n      {\n        lastrow=(unsigned char *) AcquireQuantumMemory(MagickMax(bytes_per_row,\n          2*image->columns),sizeof(*lastrow));\n        if (lastrow == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    mask=(size_t) (1U << bits_per_pixel)-1;\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      if ((flags & PALM_IS_COMPRESSED_FLAG) == 0)\n        {\n          /* TODO move out of loop! */\n          image->compression=NoCompression;\n          count=ReadBlob(image,bytes_per_row,one_row);\n          if (count != (ssize_t) bytes_per_row)\n            break;\n        }\n      else\n        {\n          if (compressionType == PALM_COMPRESSION_RLE)\n            {\n              /* TODO move out of loop! */\n              image->compression=RLECompression;\n              for (i=0; i < (ssize_t) bytes_per_row; )\n              {\n                count=(ssize_t) ReadBlobByte(image);\n                if (count < 0)\n                  break;\n                count=MagickMin(count,(ssize_t) bytes_per_row-i);\n                byte=(size_t) ReadBlobByte(image);\n                (void) ResetMagickMemory(one_row+i,(int) byte,(size_t) count);\n                i+=count;\n              }\n          }\n        else\n          if (compressionType == PALM_COMPRESSION_SCANLINE)\n            {\n              size_t\n                one;\n\n              /* TODO move out of loop! */\n              one=1;\n              image->compression=FaxCompression;\n              for (i=0; i < (ssize_t) bytes_per_row; i+=8)\n              {\n                count=(ssize_t) ReadBlobByte(image);\n                if (count < 0)\n                  break;\n                byte=(size_t) MagickMin((ssize_t) bytes_per_row-i,8);\n                for (bit=0; bit < byte; bit++)\n                {\n                  if ((y == 0) || (count & (one << (7 - bit))))\n                    one_row[i+bit]=(unsigned char) ReadBlobByte(image);\n                  else\n                    one_row[i+bit]=lastrow[i+bit];\n                }\n              }\n              (void) CopyMagickMemory(lastrow, one_row, bytes_per_row);\n            }\n        }\n      ptr=one_row;\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (PixelPacket *) NULL)\n        break;\n      indexes=GetAuthenticIndexQueue(image);\n      if (bits_per_pixel == 16)\n        {\n          if (image->columns > (2*bytes_per_row))\n            ThrowReaderException(CorruptImageError,\"CorruptImage\");\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            color16=(*ptr++ << 8);\n            color16|=(*ptr++);\n            SetPixelRed(q,(QuantumRange*((color16 >> 11) & 0x1f))/0x1f);\n            SetPixelGreen(q,(QuantumRange*((color16 >> 5) & 0x3f))/0x3f);\n            SetPixelBlue(q,(QuantumRange*((color16 >> 0) & 0x1f))/0x1f);\n            SetPixelOpacity(q,OpaqueOpacity);\n            q++;\n          }\n        }\n      else\n        {\n          bit=8-bits_per_pixel;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if ((size_t) (ptr-one_row) >= bytes_per_row)\n              ThrowReaderException(CorruptImageError,\"CorruptImage\");\n            index=(IndexPacket) (mask-(((*ptr) & (mask << bit)) >> bit));\n            SetPixelIndex(indexes+x,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            if (bit)\n              bit-=bits_per_pixel;\n            else\n              {\n                ptr++;\n                bit=8-bits_per_pixel;\n              }\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n    if (flags & PALM_HAS_TRANSPARENCY_FLAG)\n      {\n        IndexPacket index=ConstrainColormapIndex(image,(mask-transparentIndex));\n        if (bits_per_pixel != 16)\n          SetMagickPixelPacket(image,image->colormap+(ssize_t) index,\n            (const IndexPacket *) NULL,&transpix);\n        (void) TransparentPaintImage(image,&transpix,(Quantum)\n          TransparentOpacity,MagickFalse);\n      }\n    one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n    if (compressionType == PALM_COMPRESSION_SCANLINE)\n      lastrow=(unsigned char *) RelinquishMagickMemory(lastrow);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image. Copied from coders/pnm.c\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (nextDepthOffset != 0)\n      {\n        /*\n          Skip to next image.\n        */\n        totalOffset+=(MagickOffsetType) (nextDepthOffset*4);\n        if (totalOffset >= (MagickOffsetType) GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n        else\n          seekNextDepth=SeekBlob(image,totalOffset,SEEK_SET);\n        if (seekNextDepth != totalOffset)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        /*\n          Allocate next image structure. Copied from coders/pnm.c\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            (void) DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (nextDepthOffset != 0);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadPALMImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    totalOffset,\n    seekNextDepth;\n\n  MagickPixelPacket\n    transpix;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  size_t\n    bytes_per_row,\n    flags,\n    bits_per_pixel,\n    version,\n    nextDepthOffset,\n    transparentIndex,\n    compressionType,\n    byte,\n    mask,\n    redbits,\n    greenbits,\n    bluebits,\n    one,\n    pad,\n    size,\n    bit;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *lastrow,\n    *one_row,\n    *ptr;\n\n  unsigned short\n    color16;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      (void) DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  totalOffset=0;\n  do\n  {\n    image->columns=ReadBlobMSBShort(image);\n    image->rows=ReadBlobMSBShort(image);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((image->columns == 0) || (image->rows == 0))\n      ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    bytes_per_row=ReadBlobMSBShort(image);\n    flags=ReadBlobMSBShort(image);\n    bits_per_pixel=(size_t) ReadBlobByte(image);\n    if ((bits_per_pixel != 1) && (bits_per_pixel != 2) &&\n        (bits_per_pixel != 4) && (bits_per_pixel != 8) &&\n        (bits_per_pixel != 16))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n    version=(size_t) ReadBlobByte(image);\n    if ((version != 0) && (version != 1) && (version != 2))\n      ThrowReaderException(CorruptImageError,\"FileFormatVersionMismatch\");\n    nextDepthOffset=(size_t) ReadBlobMSBShort(image);\n    transparentIndex=(size_t) ReadBlobByte(image);\n    compressionType=(size_t) ReadBlobByte(image);\n    if ((compressionType != PALM_COMPRESSION_NONE) &&\n        (compressionType != PALM_COMPRESSION_SCANLINE ) &&\n        (compressionType != PALM_COMPRESSION_RLE))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n    pad=ReadBlobMSBShort(image);\n    (void) pad;\n    /*\n      Initialize image colormap.\n    */\n    one=1;\n    if ((bits_per_pixel < 16) &&\n        (AcquireImageColormap(image,one << bits_per_pixel) == MagickFalse))\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    GetMagickPixelPacket(image,&transpix);\n    if (bits_per_pixel == 16)  /* Direct Color */\n      {\n        redbits=(size_t) ReadBlobByte(image);  /* # of bits of red */\n        (void) redbits;\n        greenbits=(size_t) ReadBlobByte(image);  /* # of bits of green */\n        (void) greenbits;\n        bluebits=(size_t) ReadBlobByte(image);  /* # of bits of blue */\n        (void) bluebits;\n        ReadBlobByte(image);  /* reserved by Palm */\n        ReadBlobByte(image);  /* reserved by Palm */\n        transpix.red=(MagickRealType) (QuantumRange*ReadBlobByte(image)/31);\n        transpix.green=(MagickRealType) (QuantumRange*ReadBlobByte(image)/63);\n        transpix.blue=(MagickRealType) (QuantumRange*ReadBlobByte(image)/31);\n      }\n    if (bits_per_pixel == 8)\n      {\n        IndexPacket\n          index;\n\n        if (flags & PALM_HAS_COLORMAP_FLAG)\n          {\n            count=(ssize_t) ReadBlobMSBShort(image);\n            for (i=0; i < (ssize_t) count; i++)\n            {\n              ReadBlobByte(image);\n              index=ConstrainColormapIndex(image,(size_t) (255-i));\n              image->colormap[(int) index].red=ScaleCharToQuantum(\n                (unsigned char) ReadBlobByte(image));\n              image->colormap[(int) index].green=ScaleCharToQuantum(\n                (unsigned char) ReadBlobByte(image));\n              image->colormap[(int) index].blue=ScaleCharToQuantum(\n                (unsigned char) ReadBlobByte(image));\n          }\n        }\n      else\n        for (i=0; i < (ssize_t) (1L << bits_per_pixel); i++)\n        {\n          index=ConstrainColormapIndex(image,(size_t) (255-i));\n          image->colormap[(int) index].red=ScaleCharToQuantum(\n            PalmPalette[i][0]);\n          image->colormap[(int) index].green=ScaleCharToQuantum(\n            PalmPalette[i][1]);\n          image->colormap[(int) index].blue=ScaleCharToQuantum(\n            PalmPalette[i][2]);\n        }\n      }\n    if (flags & PALM_IS_COMPRESSED_FLAG)\n      size=ReadBlobMSBShort(image);\n    (void) size;\n    image->storage_class=DirectClass;\n    if (bits_per_pixel < 16)\n      {\n        image->storage_class=PseudoClass;\n        image->depth=8;\n      }\n    if (image_info->ping != MagickFalse) \n      {\n        (void) CloseBlob(image);\n        return(image);\n      }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    one_row=(unsigned char *) AcquireQuantumMemory(MagickMax(bytes_per_row,\n      2*image->columns),sizeof(*one_row));\n    if (one_row == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    lastrow=(unsigned char *) NULL;\n    if (compressionType == PALM_COMPRESSION_SCANLINE)\n      {\n        lastrow=(unsigned char *) AcquireQuantumMemory(MagickMax(bytes_per_row,\n          2*image->columns),sizeof(*lastrow));\n        if (lastrow == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    mask=(size_t) (1U << bits_per_pixel)-1;\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      if ((flags & PALM_IS_COMPRESSED_FLAG) == 0)\n        {\n          /* TODO move out of loop! */\n          image->compression=NoCompression;\n          count=ReadBlob(image,bytes_per_row,one_row);\n          if (count != (ssize_t) bytes_per_row)\n            break;\n        }\n      else\n        {\n          if (compressionType == PALM_COMPRESSION_RLE)\n            {\n              /* TODO move out of loop! */\n              image->compression=RLECompression;\n              for (i=0; i < (ssize_t) bytes_per_row; )\n              {\n                count=(ssize_t) ReadBlobByte(image);\n                if (count < 0)\n                  break;\n                count=MagickMin(count,(ssize_t) bytes_per_row-i);\n                byte=(size_t) ReadBlobByte(image);\n                (void) ResetMagickMemory(one_row+i,(int) byte,(size_t) count);\n                i+=count;\n              }\n          }\n        else\n          if (compressionType == PALM_COMPRESSION_SCANLINE)\n            {\n              size_t\n                one;\n\n              /* TODO move out of loop! */\n              one=1;\n              image->compression=FaxCompression;\n              for (i=0; i < (ssize_t) bytes_per_row; i+=8)\n              {\n                count=(ssize_t) ReadBlobByte(image);\n                if (count < 0)\n                  break;\n                byte=(size_t) MagickMin((ssize_t) bytes_per_row-i,8);\n                for (bit=0; bit < byte; bit++)\n                {\n                  if ((y == 0) || (count & (one << (7 - bit))))\n                    one_row[i+bit]=(unsigned char) ReadBlobByte(image);\n                  else\n                    one_row[i+bit]=lastrow[i+bit];\n                }\n              }\n              (void) CopyMagickMemory(lastrow, one_row, bytes_per_row);\n            }\n        }\n      ptr=one_row;\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (PixelPacket *) NULL)\n        break;\n      indexes=GetAuthenticIndexQueue(image);\n      if (bits_per_pixel == 16)\n        {\n          if (image->columns > (2*bytes_per_row))\n            {\n              one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n              if (compressionType == PALM_COMPRESSION_SCANLINE)\n                lastrow=(unsigned char *) RelinquishMagickMemory(lastrow);\n              ThrowReaderException(CorruptImageError,\"CorruptImage\");\n            }\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            color16=(*ptr++ << 8);\n            color16|=(*ptr++);\n            SetPixelRed(q,(QuantumRange*((color16 >> 11) & 0x1f))/0x1f);\n            SetPixelGreen(q,(QuantumRange*((color16 >> 5) & 0x3f))/0x3f);\n            SetPixelBlue(q,(QuantumRange*((color16 >> 0) & 0x1f))/0x1f);\n            SetPixelOpacity(q,OpaqueOpacity);\n            q++;\n          }\n        }\n      else\n        {\n          bit=8-bits_per_pixel;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if ((size_t) (ptr-one_row) >= bytes_per_row)\n              {\n                one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n                if (compressionType == PALM_COMPRESSION_SCANLINE)\n                  lastrow=(unsigned char *) RelinquishMagickMemory(lastrow);\n                ThrowReaderException(CorruptImageError,\"CorruptImage\");\n              }\n            index=(IndexPacket) (mask-(((*ptr) & (mask << bit)) >> bit));\n            SetPixelIndex(indexes+x,index);\n            SetPixelRGBO(q,image->colormap+(ssize_t) index);\n            if (bit)\n              bit-=bits_per_pixel;\n            else\n              {\n                ptr++;\n                bit=8-bits_per_pixel;\n              }\n            q++;\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n    if (flags & PALM_HAS_TRANSPARENCY_FLAG)\n      {\n        IndexPacket index=ConstrainColormapIndex(image,(mask-transparentIndex));\n        if (bits_per_pixel != 16)\n          SetMagickPixelPacket(image,image->colormap+(ssize_t) index,\n            (const IndexPacket *) NULL,&transpix);\n        (void) TransparentPaintImage(image,&transpix,(Quantum)\n          TransparentOpacity,MagickFalse);\n      }\n    one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n    if (compressionType == PALM_COMPRESSION_SCANLINE)\n      lastrow=(unsigned char *) RelinquishMagickMemory(lastrow);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image. Copied from coders/pnm.c\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (nextDepthOffset != 0)\n      {\n        /*\n          Skip to next image.\n        */\n        totalOffset+=(MagickOffsetType) (nextDepthOffset*4);\n        if (totalOffset >= (MagickOffsetType) GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n        else\n          seekNextDepth=SeekBlob(image,totalOffset,SEEK_SET);\n        if (seekNextDepth != totalOffset)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        /*\n          Allocate next image structure. Copied from coders/pnm.c\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            (void) DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (nextDepthOffset != 0);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -256,7 +256,12 @@\n       if (bits_per_pixel == 16)\n         {\n           if (image->columns > (2*bytes_per_row))\n-            ThrowReaderException(CorruptImageError,\"CorruptImage\");\n+            {\n+              one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n+              if (compressionType == PALM_COMPRESSION_SCANLINE)\n+                lastrow=(unsigned char *) RelinquishMagickMemory(lastrow);\n+              ThrowReaderException(CorruptImageError,\"CorruptImage\");\n+            }\n           for (x=0; x < (ssize_t) image->columns; x++)\n           {\n             color16=(*ptr++ << 8);\n@@ -274,7 +279,12 @@\n           for (x=0; x < (ssize_t) image->columns; x++)\n           {\n             if ((size_t) (ptr-one_row) >= bytes_per_row)\n-              ThrowReaderException(CorruptImageError,\"CorruptImage\");\n+              {\n+                one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n+                if (compressionType == PALM_COMPRESSION_SCANLINE)\n+                  lastrow=(unsigned char *) RelinquishMagickMemory(lastrow);\n+                ThrowReaderException(CorruptImageError,\"CorruptImage\");\n+              }\n             index=(IndexPacket) (mask-(((*ptr) & (mask << bit)) >> bit));\n             SetPixelIndex(indexes+x,index);\n             SetPixelRGBO(q,image->colormap+(ssize_t) index);",
        "diff_line_info": {
            "deleted_lines": [
                "            ThrowReaderException(CorruptImageError,\"CorruptImage\");",
                "              ThrowReaderException(CorruptImageError,\"CorruptImage\");"
            ],
            "added_lines": [
                "            {",
                "              one_row=(unsigned char *) RelinquishMagickMemory(one_row);",
                "              if (compressionType == PALM_COMPRESSION_SCANLINE)",
                "                lastrow=(unsigned char *) RelinquishMagickMemory(lastrow);",
                "              ThrowReaderException(CorruptImageError,\"CorruptImage\");",
                "            }",
                "              {",
                "                one_row=(unsigned char *) RelinquishMagickMemory(one_row);",
                "                if (compressionType == PALM_COMPRESSION_SCANLINE)",
                "                  lastrow=(unsigned char *) RelinquishMagickMemory(lastrow);",
                "                ThrowReaderException(CorruptImageError,\"CorruptImage\");",
                "              }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9439",
        "func_name": "ImageMagick/ReadPDBImage",
        "description": "In ImageMagick 7.0.5-5, a memory leak was found in the function ReadPDBImage in coders/pdb.c, which allows attackers to cause a denial of service via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/6c6abed989ea4a3ef472db65ab487c1809a3a718",
        "commit_title": "Fixed various leaks reported in #460.",
        "commit_text": "",
        "func_before": "static Image *ReadPDBImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  unsigned char\n    attributes,\n    tag[3];\n\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  MagickBooleanType\n    status;\n\n  PDBImage\n    pdb_image;\n\n  PDBInfo\n    pdb_info;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_per_pixel,\n    num_pad_bytes,\n    one,\n    packets;\n\n  ssize_t\n    count,\n    img_offset,\n    comment_offset = 0,\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a PDB image file.\n  */\n  count=ReadBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name);\n  if (count != sizeof(pdb_info.name))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  pdb_info.attributes=(short) ReadBlobMSBShort(image);\n  pdb_info.version=(short) ReadBlobMSBShort(image);\n  pdb_info.create_time=ReadBlobMSBLong(image);\n  pdb_info.modify_time=ReadBlobMSBLong(image);\n  pdb_info.archive_time=ReadBlobMSBLong(image);\n  pdb_info.modify_number=ReadBlobMSBLong(image);\n  pdb_info.application_info=ReadBlobMSBLong(image);\n  pdb_info.sort_info=ReadBlobMSBLong(image);\n  (void) ReadBlob(image,4,(unsigned char *) pdb_info.type);\n  (void) ReadBlob(image,4,(unsigned char *) pdb_info.id);\n  pdb_info.seed=ReadBlobMSBLong(image);\n  pdb_info.next_record=ReadBlobMSBLong(image);\n  pdb_info.number_records=(short) ReadBlobMSBShort(image);\n  if ((memcmp(pdb_info.type,\"vIMG\",4) != 0) ||\n      (memcmp(pdb_info.id,\"View\",4) != 0))\n  if (pdb_info.next_record != 0)\n    ThrowReaderException(CoderError,\"MultipleRecordListNotSupported\");\n  /*\n    Read record header.\n  */\n  img_offset=(ssize_t) ReadBlobMSBSignedLong(image);\n  attributes=(unsigned char) (ReadBlobByte(image));\n  (void) attributes;\n  count=ReadBlob(image,3,(unsigned char *) tag);\n  if (count != 3  ||  memcmp(tag,\"\\x6f\\x80\\x00\",3) != 0)\n    ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  if (pdb_info.number_records > 1)\n    {\n      comment_offset=(ssize_t) ReadBlobMSBSignedLong(image);\n      attributes=(unsigned char) (ReadBlobByte(image));\n      count=ReadBlob(image,3,(unsigned char *) tag);\n      if (count != 3  ||  memcmp(tag,\"\\x6f\\x80\\x01\",3) != 0)\n        ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n  num_pad_bytes = (size_t) (img_offset - TellBlob( image ));\n  while (num_pad_bytes-- != 0)\n  {\n    int\n      c;\n\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      break;\n  }\n  /*\n    Read image header.\n  */\n  count=ReadBlob(image,sizeof(pdb_image.name),(unsigned char *) pdb_image.name);\n  if (count != sizeof(pdb_image.name))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  pdb_image.version=ReadBlobByte(image);\n  pdb_image.type=(unsigned char) ReadBlobByte(image);\n  pdb_image.reserved_1=ReadBlobMSBLong(image);\n  pdb_image.note=ReadBlobMSBLong(image);\n  pdb_image.x_last=(short) ReadBlobMSBShort(image);\n  pdb_image.y_last=(short) ReadBlobMSBShort(image);\n  pdb_image.reserved_2=ReadBlobMSBLong(image);\n  pdb_image.x_anchor=ReadBlobMSBShort(image);\n  pdb_image.y_anchor=ReadBlobMSBShort(image);\n  pdb_image.width=(short) ReadBlobMSBShort(image);\n  pdb_image.height=(short) ReadBlobMSBShort(image);\n  /*\n    Initialize image structure.\n  */\n  image->columns=(size_t) pdb_image.width;\n  image->rows=(size_t) pdb_image.height;\n  image->depth=8;\n  image->storage_class=PseudoClass;\n  bits_per_pixel=pdb_image.type == 0 ? 2UL : pdb_image.type == 2 ? 4UL : 1UL;\n  one=1;\n  if (AcquireImageColormap(image,one << bits_per_pixel) == MagickFalse)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  packets=(bits_per_pixel*image->columns+7)/8;\n  pixels=(unsigned char *) AcquireQuantumMemory(packets+257UL,image->rows*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  switch (pdb_image.version & 0x07)\n  {\n    case 0:\n    {\n      image->compression=NoCompression;\n      count=(ssize_t) ReadBlob(image, packets * image -> rows, pixels);\n      break;\n    }\n    case 1:\n    {\n      image->compression=RLECompression;\n      if (!DecodeImage(image, pixels, packets * image -> rows))\n        ThrowReaderException( CorruptImageError, \"RLEDecoderError\" );\n      break;\n    }\n    default:\n      ThrowReaderException(CorruptImageError,\n         \"UnrecognizedImageCompressionType\" );\n  }\n  p=pixels;\n  switch (bits_per_pixel)\n  {\n    case 1:\n    {\n      int\n        bit;\n\n      /*\n        Read 1-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=0; bit < 8; bit++)\n          {\n            index=(IndexPacket) (*p & (0x80 >> bit) ? 0x00 : 0x01);\n            SetPixelIndex(indexes+x+bit,index);\n          }\n          p++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image);\n      break;\n    }\n    case 2:\n    {\n      /*\n        Read 2-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < (ssize_t) image->columns-3; x+=4)\n        {\n          index=ConstrainColormapIndex(image,3UL-((*p >> 6) & 0x03));\n          SetPixelIndex(indexes+x,index);\n          index=ConstrainColormapIndex(image,3UL-((*p >> 4) & 0x03));\n          SetPixelIndex(indexes+x+1,index);\n          index=ConstrainColormapIndex(image,3UL-((*p >> 2) & 0x03));\n          SetPixelIndex(indexes+x+2,index);\n          index=ConstrainColormapIndex(image,3UL-((*p) & 0x03));\n          SetPixelIndex(indexes+x+3,index);\n          p++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image);\n      break;\n    }\n    case 4:\n    {\n      /*\n        Read 4-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < (ssize_t) image->columns-1; x+=2)\n        {\n          index=ConstrainColormapIndex(image,15UL-((*p >> 4) & 0x0f));\n          SetPixelIndex(indexes+x,index);\n          index=ConstrainColormapIndex(image,15UL-((*p) & 0x0f));\n          SetPixelIndex(indexes+x+1,index);\n          p++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image);\n      break;\n    }\n    default:\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  if (pdb_info.number_records > 1)\n    {\n      char\n        *comment;\n\n      int\n        c;\n\n      register char\n        *p;\n\n      size_t\n        length;\n\n      num_pad_bytes = (size_t) (comment_offset - TellBlob( image ));\n      while (num_pad_bytes--) ReadBlobByte( image );\n\n      /*\n        Read comment.\n      */\n      c=ReadBlobByte(image);\n      length=MaxTextExtent;\n      comment=AcquireString((char *) NULL);\n      for (p=comment; c != EOF; p++)\n      {\n        if ((size_t) (p-comment+MaxTextExtent) >= length)\n          {\n            *p='\\0';\n            length<<=1;\n            length+=MaxTextExtent;\n            comment=(char *) ResizeQuantumMemory(comment,length+MaxTextExtent,\n              sizeof(*comment));\n            if (comment == (char *) NULL)\n              break;\n            p=comment+strlen(comment);\n          }\n        *p=c;\n        c=ReadBlobByte(image);\n      }\n      *p='\\0';\n      if (comment == (char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      (void) SetImageProperty(image,\"comment\",comment);\n      comment=DestroyString(comment);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadPDBImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  unsigned char\n    attributes,\n    tag[3];\n\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  MagickBooleanType\n    status;\n\n  PDBImage\n    pdb_image;\n\n  PDBInfo\n    pdb_info;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bits_per_pixel,\n    num_pad_bytes,\n    one,\n    packets;\n\n  ssize_t\n    count,\n    img_offset,\n    comment_offset = 0,\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a PDB image file.\n  */\n  count=ReadBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name);\n  if (count != sizeof(pdb_info.name))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  pdb_info.attributes=(short) ReadBlobMSBShort(image);\n  pdb_info.version=(short) ReadBlobMSBShort(image);\n  pdb_info.create_time=ReadBlobMSBLong(image);\n  pdb_info.modify_time=ReadBlobMSBLong(image);\n  pdb_info.archive_time=ReadBlobMSBLong(image);\n  pdb_info.modify_number=ReadBlobMSBLong(image);\n  pdb_info.application_info=ReadBlobMSBLong(image);\n  pdb_info.sort_info=ReadBlobMSBLong(image);\n  (void) ReadBlob(image,4,(unsigned char *) pdb_info.type);\n  (void) ReadBlob(image,4,(unsigned char *) pdb_info.id);\n  pdb_info.seed=ReadBlobMSBLong(image);\n  pdb_info.next_record=ReadBlobMSBLong(image);\n  pdb_info.number_records=(short) ReadBlobMSBShort(image);\n  if ((memcmp(pdb_info.type,\"vIMG\",4) != 0) ||\n      (memcmp(pdb_info.id,\"View\",4) != 0))\n  if (pdb_info.next_record != 0)\n    ThrowReaderException(CoderError,\"MultipleRecordListNotSupported\");\n  /*\n    Read record header.\n  */\n  img_offset=(ssize_t) ReadBlobMSBSignedLong(image);\n  attributes=(unsigned char) (ReadBlobByte(image));\n  (void) attributes;\n  count=ReadBlob(image,3,(unsigned char *) tag);\n  if (count != 3  ||  memcmp(tag,\"\\x6f\\x80\\x00\",3) != 0)\n    ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  if (pdb_info.number_records > 1)\n    {\n      comment_offset=(ssize_t) ReadBlobMSBSignedLong(image);\n      attributes=(unsigned char) (ReadBlobByte(image));\n      count=ReadBlob(image,3,(unsigned char *) tag);\n      if (count != 3  ||  memcmp(tag,\"\\x6f\\x80\\x01\",3) != 0)\n        ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n  num_pad_bytes = (size_t) (img_offset - TellBlob( image ));\n  while (num_pad_bytes-- != 0)\n  {\n    int\n      c;\n\n    c=ReadBlobByte(image);\n    if (c == EOF)\n      break;\n  }\n  /*\n    Read image header.\n  */\n  count=ReadBlob(image,sizeof(pdb_image.name),(unsigned char *) pdb_image.name);\n  if (count != sizeof(pdb_image.name))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  pdb_image.version=ReadBlobByte(image);\n  pdb_image.type=(unsigned char) ReadBlobByte(image);\n  pdb_image.reserved_1=ReadBlobMSBLong(image);\n  pdb_image.note=ReadBlobMSBLong(image);\n  pdb_image.x_last=(short) ReadBlobMSBShort(image);\n  pdb_image.y_last=(short) ReadBlobMSBShort(image);\n  pdb_image.reserved_2=ReadBlobMSBLong(image);\n  pdb_image.x_anchor=ReadBlobMSBShort(image);\n  pdb_image.y_anchor=ReadBlobMSBShort(image);\n  pdb_image.width=(short) ReadBlobMSBShort(image);\n  pdb_image.height=(short) ReadBlobMSBShort(image);\n  /*\n    Initialize image structure.\n  */\n  image->columns=(size_t) pdb_image.width;\n  image->rows=(size_t) pdb_image.height;\n  image->depth=8;\n  image->storage_class=PseudoClass;\n  bits_per_pixel=pdb_image.type == 0 ? 2UL : pdb_image.type == 2 ? 4UL : 1UL;\n  one=1;\n  if (AcquireImageColormap(image,one << bits_per_pixel) == MagickFalse)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  packets=(bits_per_pixel*image->columns+7)/8;\n  pixels=(unsigned char *) AcquireQuantumMemory(packets+257UL,image->rows*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  switch (pdb_image.version & 0x07)\n  {\n    case 0:\n    {\n      image->compression=NoCompression;\n      count=(ssize_t) ReadBlob(image,packets*image->rows,pixels);\n      break;\n    }\n    case 1:\n    {\n      image->compression=RLECompression;\n      if (!DecodeImage(image,pixels,packets*image->rows))\n        {\n          pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n          ThrowReaderException( CorruptImageError,\"RLEDecoderError\");\n        }\n      break;\n    }\n    default:\n      {\n        pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n        ThrowReaderException(CorruptImageError,\n          \"UnrecognizedImageCompressionType\");\n      }\n  }\n  p=pixels;\n  switch (bits_per_pixel)\n  {\n    case 1:\n    {\n      int\n        bit;\n\n      /*\n        Read 1-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=0; bit < 8; bit++)\n          {\n            index=(IndexPacket) (*p & (0x80 >> bit) ? 0x00 : 0x01);\n            SetPixelIndex(indexes+x+bit,index);\n          }\n          p++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image);\n      break;\n    }\n    case 2:\n    {\n      /*\n        Read 2-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < (ssize_t) image->columns-3; x+=4)\n        {\n          index=ConstrainColormapIndex(image,3UL-((*p >> 6) & 0x03));\n          SetPixelIndex(indexes+x,index);\n          index=ConstrainColormapIndex(image,3UL-((*p >> 4) & 0x03));\n          SetPixelIndex(indexes+x+1,index);\n          index=ConstrainColormapIndex(image,3UL-((*p >> 2) & 0x03));\n          SetPixelIndex(indexes+x+2,index);\n          index=ConstrainColormapIndex(image,3UL-((*p) & 0x03));\n          SetPixelIndex(indexes+x+3,index);\n          p++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image);\n      break;\n    }\n    case 4:\n    {\n      /*\n        Read 4-bit PDB image.\n      */\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < (ssize_t) image->columns-1; x+=2)\n        {\n          index=ConstrainColormapIndex(image,15UL-((*p >> 4) & 0x0f));\n          SetPixelIndex(indexes+x,index);\n          index=ConstrainColormapIndex(image,15UL-((*p) & 0x0f));\n          SetPixelIndex(indexes+x+1,index);\n          p++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n      (void) SyncImage(image);\n      break;\n    }\n    default:\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  if (pdb_info.number_records > 1)\n    {\n      char\n        *comment;\n\n      int\n        c;\n\n      register char\n        *p;\n\n      size_t\n        length;\n\n      num_pad_bytes = (size_t) (comment_offset - TellBlob( image ));\n      while (num_pad_bytes--) ReadBlobByte( image );\n\n      /*\n        Read comment.\n      */\n      c=ReadBlobByte(image);\n      length=MaxTextExtent;\n      comment=AcquireString((char *) NULL);\n      for (p=comment; c != EOF; p++)\n      {\n        if ((size_t) (p-comment+MaxTextExtent) >= length)\n          {\n            *p='\\0';\n            length<<=1;\n            length+=MaxTextExtent;\n            comment=(char *) ResizeQuantumMemory(comment,length+MaxTextExtent,\n              sizeof(*comment));\n            if (comment == (char *) NULL)\n              break;\n            p=comment+strlen(comment);\n          }\n        *p=c;\n        c=ReadBlobByte(image);\n      }\n      *p='\\0';\n      if (comment == (char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      (void) SetImageProperty(image,\"comment\",comment);\n      comment=DestroyString(comment);\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -162,19 +162,25 @@\n     case 0:\n     {\n       image->compression=NoCompression;\n-      count=(ssize_t) ReadBlob(image, packets * image -> rows, pixels);\n+      count=(ssize_t) ReadBlob(image,packets*image->rows,pixels);\n       break;\n     }\n     case 1:\n     {\n       image->compression=RLECompression;\n-      if (!DecodeImage(image, pixels, packets * image -> rows))\n-        ThrowReaderException( CorruptImageError, \"RLEDecoderError\" );\n+      if (!DecodeImage(image,pixels,packets*image->rows))\n+        {\n+          pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n+          ThrowReaderException( CorruptImageError,\"RLEDecoderError\");\n+        }\n       break;\n     }\n     default:\n-      ThrowReaderException(CorruptImageError,\n-         \"UnrecognizedImageCompressionType\" );\n+      {\n+        pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n+        ThrowReaderException(CorruptImageError,\n+          \"UnrecognizedImageCompressionType\");\n+      }\n   }\n   p=pixels;\n   switch (bits_per_pixel)\n@@ -275,7 +281,10 @@\n       break;\n     }\n     default:\n+    {\n+      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+    }\n   }\n   pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n   if (EOFBlob(image) != MagickFalse)",
        "diff_line_info": {
            "deleted_lines": [
                "      count=(ssize_t) ReadBlob(image, packets * image -> rows, pixels);",
                "      if (!DecodeImage(image, pixels, packets * image -> rows))",
                "        ThrowReaderException( CorruptImageError, \"RLEDecoderError\" );",
                "      ThrowReaderException(CorruptImageError,",
                "         \"UnrecognizedImageCompressionType\" );"
            ],
            "added_lines": [
                "      count=(ssize_t) ReadBlob(image,packets*image->rows,pixels);",
                "      if (!DecodeImage(image,pixels,packets*image->rows))",
                "        {",
                "          pixels=(unsigned char *) RelinquishMagickMemory(pixels);",
                "          ThrowReaderException( CorruptImageError,\"RLEDecoderError\");",
                "        }",
                "      {",
                "        pixels=(unsigned char *) RelinquishMagickMemory(pixels);",
                "        ThrowReaderException(CorruptImageError,",
                "          \"UnrecognizedImageCompressionType\");",
                "      }",
                "    {",
                "      pixels=(unsigned char *) RelinquishMagickMemory(pixels);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9440",
        "func_name": "ImageMagick/ReadPSDChannelZip",
        "description": "In ImageMagick 7.0.5-5, a memory leak was found in the function ReadPSDChannel in coders/psd.c, which allows attackers to cause a denial of service via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/d4e8b9722577547177a2daecee98ea9e5fe54968",
        "commit_title": "Fixed memory leak reported in #462.",
        "commit_text": "",
        "func_before": "static MagickBooleanType ReadPSDChannelZip(Image *image,const size_t channels,\n  const ssize_t type,const PSDCompressionType compression,\n  const size_t compact_size,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  register unsigned char\n    *p;\n\n  size_t\n    count,\n    length,\n    packet_size,\n    row_size;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *compact_pixels,\n    *pixels;\n\n  z_stream\n    stream;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is ZIP compressed\");\n\n  compact_pixels=(unsigned char *) AcquireQuantumMemory(compact_size,\n    sizeof(*compact_pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n\n  packet_size=GetPSDPacketSize(image);\n  row_size=image->columns*packet_size;\n  count=image->rows*row_size;\n\n  pixels=(unsigned char *) AcquireQuantumMemory(count,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    {\n      compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n\n  ResetMagickMemory(&stream,0,sizeof(stream));\n  stream.data_type=Z_BINARY;\n  (void) ReadBlob(image,compact_size,compact_pixels);\n\n  stream.next_in=(Bytef *)compact_pixels;\n  stream.avail_in=(uInt) compact_size;\n  stream.next_out=(Bytef *)pixels;\n  stream.avail_out=(uInt) count;\n\n  if (inflateInit(&stream) == Z_OK)\n    {\n      int\n        ret;\n\n      while (stream.avail_out > 0)\n      {\n        ret=inflate(&stream,Z_SYNC_FLUSH);\n        if ((ret != Z_OK) && (ret != Z_STREAM_END))\n          {\n            compact_pixels=(unsigned char *) RelinquishMagickMemory(\n              compact_pixels);\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            return(MagickFalse);\n          }\n      }\n    }\n\n  if (compression == ZipWithPrediction)\n  {\n     p=pixels;\n     while (count > 0)\n     {\n       length=image->columns;\n       while (--length)\n       {\n         if (packet_size == 2)\n           {\n             p[2]+=p[0]+((p[1]+p[3]) >> 8);\n             p[3]+=p[1];\n           }\n         else\n          *(p+1)+=*p;\n         p+=packet_size;\n       }\n       p+=packet_size;\n       count-=row_size;\n     }\n  }\n\n  status=MagickTrue;\n  p=pixels;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=ReadPSDChannelPixels(image,channels,y,type,p,exception);\n    if (status == MagickFalse)\n      break;\n\n    p+=row_size;\n  }\n\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}",
        "func": "static MagickBooleanType ReadPSDChannelZip(Image *image,const size_t channels,\n  const ssize_t type,const PSDCompressionType compression,\n  const size_t compact_size,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  register unsigned char\n    *p;\n\n  size_t\n    count,\n    length,\n    packet_size,\n    row_size;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *compact_pixels,\n    *pixels;\n\n  z_stream\n    stream;\n\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is ZIP compressed\");\n\n  compact_pixels=(unsigned char *) AcquireQuantumMemory(compact_size,\n    sizeof(*compact_pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n\n  packet_size=GetPSDPacketSize(image);\n  row_size=image->columns*packet_size;\n  count=image->rows*row_size;\n\n  pixels=(unsigned char *) AcquireQuantumMemory(count,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    {\n      compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n\n  ResetMagickMemory(&stream,0,sizeof(stream));\n  stream.data_type=Z_BINARY;\n  (void) ReadBlob(image,compact_size,compact_pixels);\n\n  stream.next_in=(Bytef *)compact_pixels;\n  stream.avail_in=(uInt) compact_size;\n  stream.next_out=(Bytef *)pixels;\n  stream.avail_out=(uInt) count;\n\n  if (inflateInit(&stream) == Z_OK)\n    {\n      int\n        ret;\n\n      while (stream.avail_out > 0)\n      {\n        ret=inflate(&stream,Z_SYNC_FLUSH);\n        if ((ret != Z_OK) && (ret != Z_STREAM_END))\n          {\n            (void) inflateEnd(&stream);\n            compact_pixels=(unsigned char *) RelinquishMagickMemory(\n              compact_pixels);\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            return(MagickFalse);\n          }\n      }\n      (void) inflateEnd(&stream);\n    }\n\n  if (compression == ZipWithPrediction)\n  {\n     p=pixels;\n     while (count > 0)\n     {\n       length=image->columns;\n       while (--length)\n       {\n         if (packet_size == 2)\n           {\n             p[2]+=p[0]+((p[1]+p[3]) >> 8);\n             p[3]+=p[1];\n           }\n         else\n          *(p+1)+=*p;\n         p+=packet_size;\n       }\n       p+=packet_size;\n       count-=row_size;\n     }\n  }\n\n  status=MagickTrue;\n  p=pixels;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=ReadPSDChannelPixels(image,channels,y,type,p,exception);\n    if (status == MagickFalse)\n      break;\n\n    p+=row_size;\n  }\n\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -65,12 +65,14 @@\n         ret=inflate(&stream,Z_SYNC_FLUSH);\n         if ((ret != Z_OK) && (ret != Z_STREAM_END))\n           {\n+            (void) inflateEnd(&stream);\n             compact_pixels=(unsigned char *) RelinquishMagickMemory(\n               compact_pixels);\n             pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n             return(MagickFalse);\n           }\n       }\n+      (void) inflateEnd(&stream);\n     }\n \n   if (compression == ZipWithPrediction)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            (void) inflateEnd(&stream);",
                "      (void) inflateEnd(&stream);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-10810",
        "func_name": "torvalds/linux/virtio_gpu_object_create",
        "description": "Memory leak in the virtio_gpu_object_create function in drivers/gpu/drm/virtio/virtgpu_object.c in the Linux kernel through 4.11.8 allows attackers to cause a denial of service (memory consumption) by triggering object-initialization failures.",
        "git_url": "https://github.com/torvalds/linux/commit/385aee965b4e4c36551c362a334378d2985b722a",
        "commit_title": "drm/virtio: don't leak bo on drm_gem_object_init failure",
        "commit_text": " Link: http://patchwork.freedesktop.org/patch/msgid/20170406155941.458-1-kraxel@redhat.com",
        "func_before": "int virtio_gpu_object_create(struct virtio_gpu_device *vgdev,\n\t\t\t     unsigned long size, bool kernel, bool pinned,\n\t\t\t     struct virtio_gpu_object **bo_ptr)\n{\n\tstruct virtio_gpu_object *bo;\n\tenum ttm_bo_type type;\n\tsize_t acc_size;\n\tint ret;\n\n\tif (kernel)\n\t\ttype = ttm_bo_type_kernel;\n\telse\n\t\ttype = ttm_bo_type_device;\n\t*bo_ptr = NULL;\n\n\tacc_size = ttm_bo_dma_acc_size(&vgdev->mman.bdev, size,\n\t\t\t\t       sizeof(struct virtio_gpu_object));\n\n\tbo = kzalloc(sizeof(struct virtio_gpu_object), GFP_KERNEL);\n\tif (bo == NULL)\n\t\treturn -ENOMEM;\n\tsize = roundup(size, PAGE_SIZE);\n\tret = drm_gem_object_init(vgdev->ddev, &bo->gem_base, size);\n\tif (ret != 0)\n\t\treturn ret;\n\tbo->dumb = false;\n\tvirtio_gpu_init_ttm_placement(bo, pinned);\n\n\tret = ttm_bo_init(&vgdev->mman.bdev, &bo->tbo, size, type,\n\t\t\t  &bo->placement, 0, !kernel, NULL, acc_size,\n\t\t\t  NULL, NULL, &virtio_gpu_ttm_bo_destroy);\n\t/* ttm_bo_init failure will call the destroy */\n\tif (ret != 0)\n\t\treturn ret;\n\n\t*bo_ptr = bo;\n\treturn 0;\n}",
        "func": "int virtio_gpu_object_create(struct virtio_gpu_device *vgdev,\n\t\t\t     unsigned long size, bool kernel, bool pinned,\n\t\t\t     struct virtio_gpu_object **bo_ptr)\n{\n\tstruct virtio_gpu_object *bo;\n\tenum ttm_bo_type type;\n\tsize_t acc_size;\n\tint ret;\n\n\tif (kernel)\n\t\ttype = ttm_bo_type_kernel;\n\telse\n\t\ttype = ttm_bo_type_device;\n\t*bo_ptr = NULL;\n\n\tacc_size = ttm_bo_dma_acc_size(&vgdev->mman.bdev, size,\n\t\t\t\t       sizeof(struct virtio_gpu_object));\n\n\tbo = kzalloc(sizeof(struct virtio_gpu_object), GFP_KERNEL);\n\tif (bo == NULL)\n\t\treturn -ENOMEM;\n\tsize = roundup(size, PAGE_SIZE);\n\tret = drm_gem_object_init(vgdev->ddev, &bo->gem_base, size);\n\tif (ret != 0) {\n\t\tkfree(bo);\n\t\treturn ret;\n\t}\n\tbo->dumb = false;\n\tvirtio_gpu_init_ttm_placement(bo, pinned);\n\n\tret = ttm_bo_init(&vgdev->mman.bdev, &bo->tbo, size, type,\n\t\t\t  &bo->placement, 0, !kernel, NULL, acc_size,\n\t\t\t  NULL, NULL, &virtio_gpu_ttm_bo_destroy);\n\t/* ttm_bo_init failure will call the destroy */\n\tif (ret != 0)\n\t\treturn ret;\n\n\t*bo_ptr = bo;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,8 +21,10 @@\n \t\treturn -ENOMEM;\n \tsize = roundup(size, PAGE_SIZE);\n \tret = drm_gem_object_init(vgdev->ddev, &bo->gem_base, size);\n-\tif (ret != 0)\n+\tif (ret != 0) {\n+\t\tkfree(bo);\n \t\treturn ret;\n+\t}\n \tbo->dumb = false;\n \tvirtio_gpu_init_ttm_placement(bo, pinned);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (ret != 0)"
            ],
            "added_lines": [
                "\tif (ret != 0) {",
                "\t\tkfree(bo);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11141",
        "func_name": "ImageMagick/ReadMATImage",
        "description": "The ReadMATImage function in coders\\mat.c in ImageMagick 7.0.5-6 has a memory leak vulnerability that can cause memory exhaustion via a crafted MAT file, related to incorrect ordering of a SetImageExtent call.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/353b942bd83da7e1356ba99c942848bd1871ee9f",
        "commit_title": "Fix moment when quantum info is acquired to fix issue reported in #469.",
        "commit_text": "",
        "func_before": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=CloneImageInfo(image_info);\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\nMATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}",
        "func": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=CloneImageInfo(image_info);\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\nMATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -248,9 +248,6 @@\n     (void) sample_size;\n     image->columns = MATLAB_HDR.SizeX;\n     image->rows = MATLAB_HDR.SizeY;\n-    quantum_info=AcquireQuantumInfo(clone_info,image);\n-    if (quantum_info == (QuantumInfo *) NULL)\n-      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     one=1;\n     image->colors = one << image->depth;\n     if (image->columns == 0 || image->rows == 0)\n@@ -281,6 +278,9 @@\n         InheritException(exception,&image->exception);\n         return(DestroyImageList(image));\n       }\n+    quantum_info=AcquireQuantumInfo(clone_info,image);\n+    if (quantum_info == (QuantumInfo *) NULL)\n+      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n \n   /* ----- Load raster data ----- */\n     BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */",
        "diff_line_info": {
            "deleted_lines": [
                "    quantum_info=AcquireQuantumInfo(clone_info,image);",
                "    if (quantum_info == (QuantumInfo *) NULL)",
                "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"
            ],
            "added_lines": [
                "    quantum_info=AcquireQuantumInfo(clone_info,image);",
                "    if (quantum_info == (QuantumInfo *) NULL)",
                "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11166",
        "func_name": "ImageMagick/ReadXWDImage",
        "description": "The ReadXWDImage function in coders\\xwd.c in ImageMagick 7.0.5-6 has a memory leak vulnerability that can cause memory exhaustion via a crafted length (number of color-map entries) field in the header of an XWD file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/31b842a218225cd7feddf65cbccf9d783c6cb526",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/471",
        "commit_text": "",
        "func_before": "static Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define CheckOverflowException(length,width,height) \\\n  (((height) != 0) && ((length)/((size_t) height) != ((size_t) width)))\n\n  char\n    *comment;\n\n  Image\n    *image;\n\n  int\n    x_status;\n\n  MagickBooleanType\n    authentic_colormap;\n\n  MagickStatusType\n    status;\n\n  Quantum\n    index;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register size_t\n    pixel;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned long\n    lsb_first;\n\n  XColor\n    *colors;\n\n  XImage\n    *ximage;\n\n  XWDFileHeader\n    header;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read in header information.\n  */\n  count=ReadBlob(image,sz_XWDheader,(unsigned char *) &header);\n  if (count != sz_XWDheader)\n    ThrowReaderException(CorruptImageError,\"UnableToReadImageHeader\");\n  /*\n    Ensure the header byte-order is most-significant byte first.\n  */\n  lsb_first=1;\n  if ((int) (*(char *) &lsb_first) != 0)\n    MSBOrderLong((unsigned char *) &header,sz_XWDheader);\n  /*\n    Check to see if the dump file is in the proper format.\n  */\n  if (header.file_version != XWD_FILE_VERSION)\n    ThrowReaderException(CorruptImageError,\"FileFormatVersionMismatch\");\n  if (header.header_size < sz_XWDheader)\n    ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  switch (header.visual_class) {\n    case StaticGray:\n    case GrayScale:\n    case StaticColor:\n    case PseudoColor:\n    case TrueColor:\n    case DirectColor:\n      break;\n    default:\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n  switch (header.pixmap_format) {\n    case XYBitmap:\n    case XYPixmap:\n    case ZPixmap:\n      break;\n    default:\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  }\n  length=(size_t) header.header_size-sz_XWDheader;\n  comment=(char *) AcquireQuantumMemory(length+1,sizeof(*comment));\n  if (comment == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  count=ReadBlob(image,length,(unsigned char *) comment);\n  comment[length]='\\0';\n  (void) SetImageProperty(image,\"comment\",comment,exception);\n  comment=DestroyString(comment);\n  if (count != (ssize_t) length)\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  /*\n    Initialize the X image.\n  */\n  ximage=(XImage *) AcquireMagickMemory(sizeof(*ximage));\n  if (ximage == (XImage *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  ximage->depth=(int) header.pixmap_depth;\n  ximage->format=(int) header.pixmap_format;\n  ximage->xoffset=(int) header.xoffset;\n  ximage->data=(char *) NULL;\n  ximage->width=(int) header.pixmap_width;\n  ximage->height=(int) header.pixmap_height;\n  ximage->bitmap_pad=(int) header.bitmap_pad;\n  ximage->bytes_per_line=(int) header.bytes_per_line;\n  ximage->byte_order=(int) header.byte_order;\n  ximage->bitmap_unit=(int) header.bitmap_unit;\n  ximage->bitmap_bit_order=(int) header.bitmap_bit_order;\n  ximage->bits_per_pixel=(int) header.bits_per_pixel;\n  ximage->red_mask=header.red_mask;\n  ximage->green_mask=header.green_mask;\n  ximage->blue_mask=header.blue_mask;\n  if ((ximage->width < 0) || (ximage->height < 0) || (ximage->depth < 0) ||    \n      (ximage->format < 0) || (ximage->byte_order < 0) || \n      (ximage->bitmap_bit_order < 0) || (ximage->bitmap_pad < 0) || \n      (ximage->bytes_per_line < 0))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if ((ximage->width > 65535) || (ximage->height > 65535))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if ((ximage->bits_per_pixel > 32) || (ximage->bitmap_unit > 32))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  x_status=XInitImage(ximage);\n  if (x_status == 0)\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    }\n  /*\n    Read colormap.\n  */\n  authentic_colormap=MagickFalse;\n  colors=(XColor *) NULL;\n  if (header.ncolors != 0)\n    {\n      XWDColor\n        color;\n\n      length=(size_t) header.ncolors;\n      colors=(XColor *) AcquireQuantumMemory(length,sizeof(*colors));\n      if (colors == (XColor *) NULL)\n        {\n          ximage=(XImage *) RelinquishMagickMemory(ximage);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      for (i=0; i < (ssize_t) header.ncolors; i++)\n      {\n        count=ReadBlob(image,sz_XWDColor,(unsigned char *) &color);\n        if (count != sz_XWDColor)\n          {\n            colors=(XColor *) RelinquishMagickMemory(colors);\n            ximage=(XImage *) RelinquishMagickMemory(ximage);\n            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n          }\n        colors[i].pixel=color.pixel;\n        colors[i].red=color.red;\n        colors[i].green=color.green;\n        colors[i].blue=color.blue;\n        colors[i].flags=(char) color.flags;\n        if (color.flags != 0)\n          authentic_colormap=MagickTrue;\n      }\n      /*\n        Ensure the header byte-order is most-significant byte first.\n      */\n      lsb_first=1;\n      if ((int) (*(char *) &lsb_first) != 0)\n        for (i=0; i < (ssize_t) header.ncolors; i++)\n        {\n          MSBOrderLong((unsigned char *) &colors[i].pixel,\n            sizeof(colors[i].pixel));\n          MSBOrderShort((unsigned char *) &colors[i].red,3*\n            sizeof(colors[i].red));\n        }\n    }\n  /*\n    Allocate the pixel buffer.\n  */\n  length=(size_t) ximage->bytes_per_line*ximage->height;\n  if (CheckOverflowException(length,ximage->bytes_per_line,ximage->height))\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if (ximage->format != ZPixmap)\n    {\n      size_t\n        extent;\n\n      extent=length;\n      length*=ximage->depth;\n      if (CheckOverflowException(length,extent,ximage->depth))\n        {\n          if (header.ncolors != 0)\n            colors=(XColor *) RelinquishMagickMemory(colors);\n          ximage=(XImage *) RelinquishMagickMemory(ximage);\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n    }\n  ximage->data=(char *) AcquireQuantumMemory(length,sizeof(*ximage->data));\n  if (ximage->data == (char *) NULL)\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  count=ReadBlob(image,length,(unsigned char *) ximage->data);\n  if (count != (ssize_t) length)\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage->data=DestroyString(ximage->data);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n    }\n  /*\n    Convert image to MIFF format.\n  */\n  image->columns=(size_t) ximage->width;\n  image->rows=(size_t) ximage->height;\n  image->depth=8;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage->data=DestroyString(ximage->data);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      return(DestroyImageList(image));\n    }\n  if ((header.ncolors == 0U) || (ximage->red_mask != 0) ||\n      (ximage->green_mask != 0) || (ximage->blue_mask != 0))\n    image->storage_class=DirectClass;\n  else\n    image->storage_class=PseudoClass;\n  image->colors=header.ncolors;\n  if (image_info->ping == MagickFalse)\n    switch (image->storage_class)\n    {\n      case DirectClass:\n      default:\n      {\n        register size_t\n          color;\n\n        size_t\n          blue_mask,\n          blue_shift,\n          green_mask,\n          green_shift,\n          red_mask,\n          red_shift;\n\n        /*\n          Determine shift and mask for red, green, and blue.\n        */\n        red_mask=ximage->red_mask;\n        red_shift=0;\n        while ((red_mask != 0) && ((red_mask & 0x01) == 0))\n        {\n          red_mask>>=1;\n          red_shift++;\n        }\n        green_mask=ximage->green_mask;\n        green_shift=0;\n        while ((green_mask != 0) && ((green_mask & 0x01) == 0))\n        {\n          green_mask>>=1;\n          green_shift++;\n        }\n        blue_mask=ximage->blue_mask;\n        blue_shift=0;\n        while ((blue_mask != 0) && ((blue_mask & 0x01) == 0))\n        {\n          blue_mask>>=1;\n          blue_shift++;\n        }\n        /*\n          Convert X image to DirectClass packets.\n        */\n        if ((image->colors != 0) && (authentic_colormap != MagickFalse))\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              pixel=XGetPixel(ximage,(int) x,(int) y);\n              index=(Quantum) ((pixel >> red_shift) & red_mask);\n              if (index < header.ncolors)\n                SetPixelRed(image,ScaleShortToQuantum(\n                  colors[(ssize_t) index].red),q);\n              index=(Quantum) ((pixel >> green_shift) & green_mask);\n              if (index < header.ncolors)\n                SetPixelGreen(image,ScaleShortToQuantum(\n                  colors[(ssize_t) index].green),q);\n              index=(Quantum) ((pixel >> blue_shift) & blue_mask);\n              if (index < header.ncolors)\n                SetPixelBlue(image,ScaleShortToQuantum(\n                  colors[(ssize_t) index].blue),q);\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              pixel=XGetPixel(ximage,(int) x,(int) y);\n              color=(pixel >> red_shift) & red_mask;\n              if (red_mask != 0)\n                color=(color*65535UL)/red_mask;\n              SetPixelRed(image,ScaleShortToQuantum((unsigned short) color),q);\n              color=(pixel >> green_shift) & green_mask;\n              if (green_mask != 0)\n                color=(color*65535UL)/green_mask;\n              SetPixelGreen(image,ScaleShortToQuantum((unsigned short) color),\n                q);\n              color=(pixel >> blue_shift) & blue_mask;\n              if (blue_mask != 0)\n                color=(color*65535UL)/blue_mask;\n              SetPixelBlue(image,ScaleShortToQuantum((unsigned short) color),q);\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n        break;\n      }\n      case PseudoClass:\n      {\n        /*\n          Convert X image to PseudoClass packets.\n        */\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          {\n            if (header.ncolors != 0)\n              colors=(XColor *) RelinquishMagickMemory(colors);\n            ximage->data=DestroyString(ximage->data);\n            ximage=(XImage *) RelinquishMagickMemory(ximage);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(MagickRealType) ScaleShortToQuantum(\n            colors[i].red);\n          image->colormap[i].green=(MagickRealType) ScaleShortToQuantum(\n            colors[i].green);\n          image->colormap[i].blue=(MagickRealType) ScaleShortToQuantum(\n            colors[i].blue);\n        }\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            index=ConstrainColormapIndex(image,XGetPixel(ximage,(int) x,\n              (int) y),exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n        break;\n      }\n    }\n  /*\n    Free image and colormap.\n  */\n  if (header.ncolors != 0)\n    colors=(XColor *) RelinquishMagickMemory(colors);\n  ximage->data=DestroyString(ximage->data);\n  ximage=(XImage *) RelinquishMagickMemory(ximage);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadXWDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define CheckOverflowException(length,width,height) \\\n  (((height) != 0) && ((length)/((size_t) height) != ((size_t) width)))\n\n  char\n    *comment;\n\n  Image\n    *image;\n\n  int\n    x_status;\n\n  MagickBooleanType\n    authentic_colormap;\n\n  MagickStatusType\n    status;\n\n  Quantum\n    index;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register size_t\n    pixel;\n\n  size_t\n    length;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned long\n    lsb_first;\n\n  XColor\n    *colors;\n\n  XImage\n    *ximage;\n\n  XWDFileHeader\n    header;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read in header information.\n  */\n  count=ReadBlob(image,sz_XWDheader,(unsigned char *) &header);\n  if (count != sz_XWDheader)\n    ThrowReaderException(CorruptImageError,\"UnableToReadImageHeader\");\n  /*\n    Ensure the header byte-order is most-significant byte first.\n  */\n  lsb_first=1;\n  if ((int) (*(char *) &lsb_first) != 0)\n    MSBOrderLong((unsigned char *) &header,sz_XWDheader);\n  /*\n    Check to see if the dump file is in the proper format.\n  */\n  if (header.file_version != XWD_FILE_VERSION)\n    ThrowReaderException(CorruptImageError,\"FileFormatVersionMismatch\");\n  if (header.header_size < sz_XWDheader)\n    ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  switch (header.visual_class) {\n    case StaticGray:\n    case GrayScale:\n    case StaticColor:\n    case PseudoColor:\n    case TrueColor:\n    case DirectColor:\n      break;\n    default:\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n  switch (header.pixmap_format) {\n    case XYBitmap:\n    case XYPixmap:\n    case ZPixmap:\n      break;\n    default:\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n  }\n  length=(size_t) header.header_size-sz_XWDheader;\n  comment=(char *) AcquireQuantumMemory(length+1,sizeof(*comment));\n  if (comment == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  count=ReadBlob(image,length,(unsigned char *) comment);\n  comment[length]='\\0';\n  (void) SetImageProperty(image,\"comment\",comment,exception);\n  comment=DestroyString(comment);\n  if (count != (ssize_t) length)\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  /*\n    Initialize the X image.\n  */\n  ximage=(XImage *) AcquireMagickMemory(sizeof(*ximage));\n  if (ximage == (XImage *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  ximage->depth=(int) header.pixmap_depth;\n  ximage->format=(int) header.pixmap_format;\n  ximage->xoffset=(int) header.xoffset;\n  ximage->data=(char *) NULL;\n  ximage->width=(int) header.pixmap_width;\n  ximage->height=(int) header.pixmap_height;\n  ximage->bitmap_pad=(int) header.bitmap_pad;\n  ximage->bytes_per_line=(int) header.bytes_per_line;\n  ximage->byte_order=(int) header.byte_order;\n  ximage->bitmap_unit=(int) header.bitmap_unit;\n  ximage->bitmap_bit_order=(int) header.bitmap_bit_order;\n  ximage->bits_per_pixel=(int) header.bits_per_pixel;\n  ximage->red_mask=header.red_mask;\n  ximage->green_mask=header.green_mask;\n  ximage->blue_mask=header.blue_mask;\n  if ((ximage->width < 0) || (ximage->height < 0) || (ximage->depth < 0) ||    \n      (ximage->format < 0) || (ximage->byte_order < 0) || \n      (ximage->bitmap_bit_order < 0) || (ximage->bitmap_pad < 0) || \n      (ximage->bytes_per_line < 0))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if ((ximage->width > 65535) || (ximage->height > 65535))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if ((ximage->bits_per_pixel > 32) || (ximage->bitmap_unit > 32))\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  x_status=XInitImage(ximage);\n  if (x_status == 0)\n    {\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    }\n  /*\n    Read colormap.\n  */\n  authentic_colormap=MagickFalse;\n  colors=(XColor *) NULL;\n  if (header.ncolors != 0)\n    {\n      XWDColor\n        color;\n\n      length=(size_t) header.ncolors;\n      if (length > ((~0UL)/sizeof(*colors)))\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      colors=(XColor *) AcquireQuantumMemory(length,sizeof(*colors));\n      if (colors == (XColor *) NULL)\n        {\n          ximage=(XImage *) RelinquishMagickMemory(ximage);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n      for (i=0; i < (ssize_t) header.ncolors; i++)\n      {\n        count=ReadBlob(image,sz_XWDColor,(unsigned char *) &color);\n        if (count != sz_XWDColor)\n          {\n            colors=(XColor *) RelinquishMagickMemory(colors);\n            ximage=(XImage *) RelinquishMagickMemory(ximage);\n            ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n          }\n        colors[i].pixel=color.pixel;\n        colors[i].red=color.red;\n        colors[i].green=color.green;\n        colors[i].blue=color.blue;\n        colors[i].flags=(char) color.flags;\n        if (color.flags != 0)\n          authentic_colormap=MagickTrue;\n      }\n      /*\n        Ensure the header byte-order is most-significant byte first.\n      */\n      lsb_first=1;\n      if ((int) (*(char *) &lsb_first) != 0)\n        for (i=0; i < (ssize_t) header.ncolors; i++)\n        {\n          MSBOrderLong((unsigned char *) &colors[i].pixel,\n            sizeof(colors[i].pixel));\n          MSBOrderShort((unsigned char *) &colors[i].red,3*\n            sizeof(colors[i].red));\n        }\n    }\n  /*\n    Allocate the pixel buffer.\n  */\n  length=(size_t) ximage->bytes_per_line*ximage->height;\n  if (CheckOverflowException(length,ximage->bytes_per_line,ximage->height))\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  if (ximage->format != ZPixmap)\n    {\n      size_t\n        extent;\n\n      extent=length;\n      length*=ximage->depth;\n      if (CheckOverflowException(length,extent,ximage->depth))\n        {\n          if (header.ncolors != 0)\n            colors=(XColor *) RelinquishMagickMemory(colors);\n          ximage=(XImage *) RelinquishMagickMemory(ximage);\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        }\n    }\n  ximage->data=(char *) AcquireQuantumMemory(length,sizeof(*ximage->data));\n  if (ximage->data == (char *) NULL)\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  count=ReadBlob(image,length,(unsigned char *) ximage->data);\n  if (count != (ssize_t) length)\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage->data=DestroyString(ximage->data);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n    }\n  /*\n    Convert image to MIFF format.\n  */\n  image->columns=(size_t) ximage->width;\n  image->rows=(size_t) ximage->height;\n  image->depth=8;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    {\n      if (header.ncolors != 0)\n        colors=(XColor *) RelinquishMagickMemory(colors);\n      ximage->data=DestroyString(ximage->data);\n      ximage=(XImage *) RelinquishMagickMemory(ximage);\n      return(DestroyImageList(image));\n    }\n  if ((header.ncolors == 0U) || (ximage->red_mask != 0) ||\n      (ximage->green_mask != 0) || (ximage->blue_mask != 0))\n    image->storage_class=DirectClass;\n  else\n    image->storage_class=PseudoClass;\n  image->colors=header.ncolors;\n  if (image_info->ping == MagickFalse)\n    switch (image->storage_class)\n    {\n      case DirectClass:\n      default:\n      {\n        register size_t\n          color;\n\n        size_t\n          blue_mask,\n          blue_shift,\n          green_mask,\n          green_shift,\n          red_mask,\n          red_shift;\n\n        /*\n          Determine shift and mask for red, green, and blue.\n        */\n        red_mask=ximage->red_mask;\n        red_shift=0;\n        while ((red_mask != 0) && ((red_mask & 0x01) == 0))\n        {\n          red_mask>>=1;\n          red_shift++;\n        }\n        green_mask=ximage->green_mask;\n        green_shift=0;\n        while ((green_mask != 0) && ((green_mask & 0x01) == 0))\n        {\n          green_mask>>=1;\n          green_shift++;\n        }\n        blue_mask=ximage->blue_mask;\n        blue_shift=0;\n        while ((blue_mask != 0) && ((blue_mask & 0x01) == 0))\n        {\n          blue_mask>>=1;\n          blue_shift++;\n        }\n        /*\n          Convert X image to DirectClass packets.\n        */\n        if ((image->colors != 0) && (authentic_colormap != MagickFalse))\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              pixel=XGetPixel(ximage,(int) x,(int) y);\n              index=(Quantum) ((pixel >> red_shift) & red_mask);\n              if (index < header.ncolors)\n                SetPixelRed(image,ScaleShortToQuantum(\n                  colors[(ssize_t) index].red),q);\n              index=(Quantum) ((pixel >> green_shift) & green_mask);\n              if (index < header.ncolors)\n                SetPixelGreen(image,ScaleShortToQuantum(\n                  colors[(ssize_t) index].green),q);\n              index=(Quantum) ((pixel >> blue_shift) & blue_mask);\n              if (index < header.ncolors)\n                SetPixelBlue(image,ScaleShortToQuantum(\n                  colors[(ssize_t) index].blue),q);\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n        else\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              pixel=XGetPixel(ximage,(int) x,(int) y);\n              color=(pixel >> red_shift) & red_mask;\n              if (red_mask != 0)\n                color=(color*65535UL)/red_mask;\n              SetPixelRed(image,ScaleShortToQuantum((unsigned short) color),q);\n              color=(pixel >> green_shift) & green_mask;\n              if (green_mask != 0)\n                color=(color*65535UL)/green_mask;\n              SetPixelGreen(image,ScaleShortToQuantum((unsigned short) color),\n                q);\n              color=(pixel >> blue_shift) & blue_mask;\n              if (blue_mask != 0)\n                color=(color*65535UL)/blue_mask;\n              SetPixelBlue(image,ScaleShortToQuantum((unsigned short) color),q);\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n        break;\n      }\n      case PseudoClass:\n      {\n        /*\n          Convert X image to PseudoClass packets.\n        */\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          {\n            if (header.ncolors != 0)\n              colors=(XColor *) RelinquishMagickMemory(colors);\n            ximage->data=DestroyString(ximage->data);\n            ximage=(XImage *) RelinquishMagickMemory(ximage);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          image->colormap[i].red=(MagickRealType) ScaleShortToQuantum(\n            colors[i].red);\n          image->colormap[i].green=(MagickRealType) ScaleShortToQuantum(\n            colors[i].green);\n          image->colormap[i].blue=(MagickRealType) ScaleShortToQuantum(\n            colors[i].blue);\n        }\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            index=ConstrainColormapIndex(image,XGetPixel(ximage,(int) x,\n              (int) y),exception);\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n        break;\n      }\n    }\n  /*\n    Free image and colormap.\n  */\n  if (header.ncolors != 0)\n    colors=(XColor *) RelinquishMagickMemory(colors);\n  ximage->data=DestroyString(ximage->data);\n  ximage=(XImage *) RelinquishMagickMemory(ximage);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -173,6 +173,8 @@\n         color;\n \n       length=(size_t) header.ncolors;\n+      if (length > ((~0UL)/sizeof(*colors)))\n+        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n       colors=(XColor *) AcquireQuantumMemory(length,sizeof(*colors));\n       if (colors == (XColor *) NULL)\n         {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      if (length > ((~0UL)/sizeof(*colors)))",
                "        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11310",
        "func_name": "ImageMagick/read_user_chunk_callback",
        "description": "The read_user_chunk_callback function in coders\\png.c in ImageMagick 7.0.6-1 Q16 2017-06-21 (beta) has memory leak vulnerabilities via crafted PNG files.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/8ca35831e91c3db8c6d281d09b605001003bec08",
        "commit_title": "coders/png.c: Stop a memory leak in read_user_chunk_callback() (reference",
        "commit_text": " https://github.com/ImageMagick/ImageMagick/issues/517).",
        "func_before": "static int read_user_chunk_callback(png_struct *ping, png_unknown_chunkp chunk)\n{\n  Image\n    *image;\n\n\n  /* The unknown chunk structure contains the chunk data:\n     png_byte name[5];\n     png_byte *data;\n     png_size_t size;\n\n     Note that libpng has already taken care of the CRC handling.\n\n     Returns one of the following:\n         return(-n);  chunk had an error\n         return(0);  did not recognize\n         return(n);  success\n  */\n\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n     \"    read_user_chunk: found %c%c%c%c chunk\",\n       chunk->name[0],chunk->name[1],chunk->name[2],chunk->name[3]);\n\n  if (chunk->name[0]  == 101 &&\n      (chunk->name[1] ==  88 || chunk->name[1] == 120 ) &&\n      chunk->name[2] ==   73 &&\n      chunk-> name[3] == 102)\n    {\n      /* process eXIf or exIf chunk */\n\n      PNGErrorInfo\n        *error_info;\n\n      StringInfo\n        *profile;\n\n      unsigned char\n        *p;\n\n      png_byte\n        *s;\n\n      size_t\n        i;\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \" recognized eXIf|exIf chunk\");\n\n      image=(Image *) png_get_user_chunk_ptr(ping);\n\n      error_info=(PNGErrorInfo *) png_get_error_ptr(ping);\n\n      profile=BlobToStringInfo((const void *) NULL,chunk->size+6);\n\n      if (profile == (StringInfo *) NULL)\n        {\n          (void) ThrowMagickException(error_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n            image->filename);\n          return(-1);\n        }\n      p=GetStringInfoDatum(profile);\n\n      if (*p != 'E')\n        {\n          /* Initialize profile with \"Exif\\0\\0\" if it is not\n             already present by accident\n          */\n          *p++ ='E';\n          *p++ ='x';\n          *p++ ='i';\n          *p++ ='f';\n          *p++ ='\\0';\n          *p++ ='\\0';\n        }\n      else\n        {\n          if (p[1] != 'x' || p[2] != 'i' || p[3] != 'f' ||\n              p[4] != '\\0' || p[5] != '\\0')\n            {\n              /* Chunk is malformed */\n              return(-1);\n            }\n         }\n\n      /* copy chunk->data to profile */\n      s=chunk->data;\n      for (i=0; i<chunk->size; i++)\n        *p++ = *s++;\n\n      error_info=(PNGErrorInfo *) png_get_error_ptr(ping);\n      (void) SetImageProfile(image,\"exif\",profile,\n        error_info->exception);\n\n      return(1);\n    }\n\n  /* vpAg (deprecated, replaced by caNv) */\n  if (chunk->name[0] == 118 &&\n      chunk->name[1] == 112 &&\n      chunk->name[2] ==  65 &&\n      chunk->name[3] == 103)\n    {\n      /* recognized vpAg */\n\n      if (chunk->size != 9)\n        return(-1); /* Error return */\n\n      if (chunk->data[8] != 0)\n        return(0);  /* ImageMagick requires pixel units */\n\n      image=(Image *) png_get_user_chunk_ptr(ping);\n\n      image->page.width=(size_t) ((chunk->data[0] << 24) |\n         (chunk->data[1] << 16) | (chunk->data[2] << 8) | chunk->data[3]);\n\n      image->page.height=(size_t) ((chunk->data[4] << 24) |\n         (chunk->data[5] << 16) | (chunk->data[6] << 8) | chunk->data[7]);\n\n      return(1);\n    }\n\n  /* caNv */\n  if (chunk->name[0] ==  99 &&\n      chunk->name[1] ==  97 &&\n      chunk->name[2] ==  78 &&\n      chunk->name[3] == 118)\n    {\n      /* recognized caNv */\n\n      if (chunk->size != 16)\n        return(-1); /* Error return */\n\n      image=(Image *) png_get_user_chunk_ptr(ping);\n\n      image->page.width=(size_t) ((chunk->data[0] << 24) |\n         (chunk->data[1] << 16) | (chunk->data[2] << 8) | chunk->data[3]);\n\n      image->page.height=(size_t) ((chunk->data[4] << 24) |\n         (chunk->data[5] << 16) | (chunk->data[6] << 8) | chunk->data[7]);\n\n      image->page.x=(size_t) ((chunk->data[8] << 24) |\n         (chunk->data[9] << 16) | (chunk->data[10] << 8) | chunk->data[11]);\n\n      image->page.y=(size_t) ((chunk->data[12] << 24) |\n         (chunk->data[13] << 16) | (chunk->data[14] << 8) | chunk->data[15]);\n\n      return(1);\n    }\n\n  return(0); /* Did not recognize */\n}",
        "func": "static int read_user_chunk_callback(png_struct *ping, png_unknown_chunkp chunk)\n{\n  Image\n    *image;\n\n\n  /* The unknown chunk structure contains the chunk data:\n     png_byte name[5];\n     png_byte *data;\n     png_size_t size;\n\n     Note that libpng has already taken care of the CRC handling.\n\n     Returns one of the following:\n         return(-n);  chunk had an error\n         return(0);  did not recognize\n         return(n);  success\n  */\n\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n     \"    read_user_chunk: found %c%c%c%c chunk\",\n       chunk->name[0],chunk->name[1],chunk->name[2],chunk->name[3]);\n\n  if (chunk->name[0]  == 101 &&\n      (chunk->name[1] ==  88 || chunk->name[1] == 120 ) &&\n      chunk->name[2] ==   73 &&\n      chunk-> name[3] == 102)\n    {\n      /* process eXIf or exIf chunk */\n\n      PNGErrorInfo\n        *error_info;\n\n      StringInfo\n        *profile;\n\n      unsigned char\n        *p;\n\n      png_byte\n        *s;\n\n      size_t\n        i;\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \" recognized eXIf|exIf chunk\");\n\n      image=(Image *) png_get_user_chunk_ptr(ping);\n\n      error_info=(PNGErrorInfo *) png_get_error_ptr(ping);\n\n      profile=BlobToStringInfo((const void *) NULL,chunk->size+6);\n\n      if (profile == (StringInfo *) NULL)\n        {\n          (void) ThrowMagickException(error_info->exception,GetMagickModule(),\n            ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n            image->filename);\n          return(-1);\n        }\n      p=GetStringInfoDatum(profile);\n\n      if (*p != 'E')\n        {\n          /* Initialize profile with \"Exif\\0\\0\" if it is not\n             already present by accident\n          */\n          *p++ ='E';\n          *p++ ='x';\n          *p++ ='i';\n          *p++ ='f';\n          *p++ ='\\0';\n          *p++ ='\\0';\n        }\n      else\n        {\n          if (p[1] != 'x' || p[2] != 'i' || p[3] != 'f' ||\n              p[4] != '\\0' || p[5] != '\\0')\n            {\n              /* Chunk is malformed */\n              profile=DestroyStringInfo(profile);\n              return(-1);\n            }\n         }\n\n      /* copy chunk->data to profile */\n      s=chunk->data;\n      for (i=0; i<chunk->size; i++)\n        *p++ = *s++;\n\n      error_info=(PNGErrorInfo *) png_get_error_ptr(ping);\n      (void) SetImageProfile(image,\"exif\",profile,\n        error_info->exception);\n\n      profile=DestroyStringInfo(profile);\n\n      return(1);\n    }\n\n  /* vpAg (deprecated, replaced by caNv) */\n  if (chunk->name[0] == 118 &&\n      chunk->name[1] == 112 &&\n      chunk->name[2] ==  65 &&\n      chunk->name[3] == 103)\n    {\n      /* recognized vpAg */\n\n      if (chunk->size != 9)\n        return(-1); /* Error return */\n\n      if (chunk->data[8] != 0)\n        return(0);  /* ImageMagick requires pixel units */\n\n      image=(Image *) png_get_user_chunk_ptr(ping);\n\n      image->page.width=(size_t) ((chunk->data[0] << 24) |\n         (chunk->data[1] << 16) | (chunk->data[2] << 8) | chunk->data[3]);\n\n      image->page.height=(size_t) ((chunk->data[4] << 24) |\n         (chunk->data[5] << 16) | (chunk->data[6] << 8) | chunk->data[7]);\n\n      return(1);\n    }\n\n  /* caNv */\n  if (chunk->name[0] ==  99 &&\n      chunk->name[1] ==  97 &&\n      chunk->name[2] ==  78 &&\n      chunk->name[3] == 118)\n    {\n      /* recognized caNv */\n\n      if (chunk->size != 16)\n        return(-1); /* Error return */\n\n      image=(Image *) png_get_user_chunk_ptr(ping);\n\n      image->page.width=(size_t) ((chunk->data[0] << 24) |\n         (chunk->data[1] << 16) | (chunk->data[2] << 8) | chunk->data[3]);\n\n      image->page.height=(size_t) ((chunk->data[4] << 24) |\n         (chunk->data[5] << 16) | (chunk->data[6] << 8) | chunk->data[7]);\n\n      image->page.x=(size_t) ((chunk->data[8] << 24) |\n         (chunk->data[9] << 16) | (chunk->data[10] << 8) | chunk->data[11]);\n\n      image->page.y=(size_t) ((chunk->data[12] << 24) |\n         (chunk->data[13] << 16) | (chunk->data[14] << 8) | chunk->data[15]);\n\n      return(1);\n    }\n\n  return(0); /* Did not recognize */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -79,6 +79,7 @@\n               p[4] != '\\0' || p[5] != '\\0')\n             {\n               /* Chunk is malformed */\n+              profile=DestroyStringInfo(profile);\n               return(-1);\n             }\n          }\n@@ -91,6 +92,8 @@\n       error_info=(PNGErrorInfo *) png_get_error_ptr(ping);\n       (void) SetImageProfile(image,\"exif\",profile,\n         error_info->exception);\n+\n+      profile=DestroyStringInfo(profile);\n \n       return(1);\n     }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "              profile=DestroyStringInfo(profile);",
                "",
                "      profile=DestroyStringInfo(profile);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7727",
        "func_name": "gdraheim/zziplib/unzzip_cat",
        "description": "An issue was discovered in ZZIPlib 0.13.68. There is a memory leak triggered in the function zzip_mem_disk_new in memdisk.c, which will lead to a denial of service attack.",
        "git_url": "https://github.com/gdraheim/zziplib/commit/83a2da55922f67e07f22048ac9671a44cc0d35c4",
        "commit_title": "ensure disk_close to avoid mem-leak #40",
        "commit_text": "",
        "func_before": "static int unzzip_cat (int argc, char ** argv, int extract)\n{\n    int done;\n    int argn;\n    ZZIP_MEM_DISK* disk;\n\n    if (argc == 1)\n    {\n\tprintf (__FILE__\" version \"ZZIP_PACKAGE\" \"ZZIP_VERSION\"\\n\");\n\treturn EXIT_OK; /* better provide an archive argument */\n    }\n\n    disk = zzip_mem_disk_open (argv[1]);\n    if (! disk) {\n        DBG3(\"disk_open failed [%i] %s\", errno, strerror(errno));\n\tperror(argv[1]);\n\treturn exitcode(errno);\n    }\n\n    if (argc == 2)\n    {  /* print directory list */\n\tZZIP_MEM_ENTRY* entry = zzip_mem_disk_findfirst(disk);\n\tDBG2(\"findfirst %p\\n\", entry);\n\tfor (; entry ; entry = zzip_mem_disk_findnext(disk, entry))\n\t{\n\t    char* name = zzip_mem_entry_to_name (entry);\n\t    FILE* out = stdout;\n\t    if (extract) out = create_fopen(name, \"wb\", 1);\n\t    if (! out) {\n\t        if (errno != EISDIR) done = EXIT_ERRORS;\n\t        continue;\n\t    }\n\t    unzzip_mem_disk_cat_file (disk, name, out);\n\t    if (extract) fclose(out);\n\t}\n\treturn done;\n    }\n\n    if (argc == 3 && !extract)\n    {  /* list from one spec */\n\tZZIP_MEM_ENTRY* entry = 0;\n\twhile ((entry = zzip_mem_disk_findmatch(disk, argv[2], entry, 0, 0)))\n\t{\n\t     unzzip_mem_entry_fprint (disk, entry, stdout);\n\t}\n\n\treturn 0;\n    }\n\n    for (argn=1; argn < argc; argn++)\n    {   /* list only the matching entries - each in order of commandline */\n\tZZIP_MEM_ENTRY* entry = zzip_mem_disk_findfirst(disk);\n\tfor (; entry ; entry = zzip_mem_disk_findnext(disk, entry))\n\t{\n\t    char* name = zzip_mem_entry_to_name (entry);\n\t    if (! _zzip_fnmatch (argv[argn], name, \n\t\t_zzip_FNM_NOESCAPE|_zzip_FNM_PATHNAME|_zzip_FNM_PERIOD))\n\t    {\n\t        FILE* out = stdout;\n\t        if (extract) out = create_fopen(name, \"wb\", 1);\n\t        if (! out) {\n\t            if (errno != EISDIR) done = EXIT_ERRORS;\n\t            continue;\n\t        }\n\t\tunzzip_mem_disk_cat_file (disk, name, out);\n\t\tif (extract) fclose(out);\n\t\tbreak; /* match loop */\n\t    }\n\t}\n    }\n    return done;\n}",
        "func": "static int unzzip_cat (int argc, char ** argv, int extract)\n{\n    int done = 0;\n    int argn;\n    ZZIP_MEM_DISK* disk;\n\n    if (argc == 1)\n    {\n\tprintf (__FILE__\" version \"ZZIP_PACKAGE\" \"ZZIP_VERSION\"\\n\");\n\treturn EXIT_OK; /* better provide an archive argument */\n    }\n\n    disk = zzip_mem_disk_open (argv[1]);\n    if (! disk) {\n        DBG3(\"disk_open failed [%i] %s\", errno, strerror(errno));\n\tperror(argv[1]);\n\treturn exitcode(errno);\n    }\n\n    if (argc == 2)\n    {  /* print directory list */\n\tZZIP_MEM_ENTRY* entry = zzip_mem_disk_findfirst(disk);\n\tDBG2(\"findfirst %p\\n\", entry);\n\tfor (; entry ; entry = zzip_mem_disk_findnext(disk, entry))\n\t{\n\t    char* name = zzip_mem_entry_to_name (entry);\n\t    FILE* out = stdout;\n\t    if (extract) out = create_fopen(name, \"wb\", 1);\n\t    if (! out) {\n\t        if (errno != EISDIR) {\n\t             DBG3(\"can not open output file %i %s\", errno, strerror(errno));\n\t             done = EXIT_ERRORS;\n\t        }\n\t        continue;\n\t    }\n\t    unzzip_mem_disk_cat_file (disk, name, out);\n\t    if (extract) fclose(out);\n\t}\n    } \n    else if (argc == 3 && !extract)\n    {  /* list from one spec */\n\tZZIP_MEM_ENTRY* entry = 0;\n\twhile ((entry = zzip_mem_disk_findmatch(disk, argv[2], entry, 0, 0)))\n\t{\n\t     unzzip_mem_entry_fprint (disk, entry, stdout);\n\t}\n    } else {\n\tfor (argn=1; argn < argc; argn++)\n\t{   /* list only the matching entries - each in order of commandline */\n\t    ZZIP_MEM_ENTRY* entry = zzip_mem_disk_findfirst(disk);\n\t    for (; entry ; entry = zzip_mem_disk_findnext(disk, entry))\n\t    {\n\t        char* name = zzip_mem_entry_to_name (entry);\n\t        if (! _zzip_fnmatch (argv[argn], name, \n\t\t    _zzip_FNM_NOESCAPE|_zzip_FNM_PATHNAME|_zzip_FNM_PERIOD))\n\t        {\n\t            FILE* out = stdout;\n\t            if (extract) out = create_fopen(name, \"wb\", 1);\n\t\t    if (! out) {\n\t\t        if (errno != EISDIR) {\n\t\t            DBG3(\"can not open output file %i %s\", errno, strerror(errno));\n\t\t            done = EXIT_ERRORS;\n\t\t        }\n\t\t        continue;\n\t\t    }\n\t\t    unzzip_mem_disk_cat_file (disk, name, out);\n\t\t    if (extract) fclose(out);\n\t\t    break; /* match loop */\n\t\t}\n\t    }\n\t}\n    }\n    zzip_mem_disk_close(disk);\n    return done;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n static int unzzip_cat (int argc, char ** argv, int extract)\n {\n-    int done;\n+    int done = 0;\n     int argn;\n     ZZIP_MEM_DISK* disk;\n \n@@ -27,46 +27,49 @@\n \t    FILE* out = stdout;\n \t    if (extract) out = create_fopen(name, \"wb\", 1);\n \t    if (! out) {\n-\t        if (errno != EISDIR) done = EXIT_ERRORS;\n+\t        if (errno != EISDIR) {\n+\t             DBG3(\"can not open output file %i %s\", errno, strerror(errno));\n+\t             done = EXIT_ERRORS;\n+\t        }\n \t        continue;\n \t    }\n \t    unzzip_mem_disk_cat_file (disk, name, out);\n \t    if (extract) fclose(out);\n \t}\n-\treturn done;\n-    }\n-\n-    if (argc == 3 && !extract)\n+    } \n+    else if (argc == 3 && !extract)\n     {  /* list from one spec */\n \tZZIP_MEM_ENTRY* entry = 0;\n \twhile ((entry = zzip_mem_disk_findmatch(disk, argv[2], entry, 0, 0)))\n \t{\n \t     unzzip_mem_entry_fprint (disk, entry, stdout);\n \t}\n-\n-\treturn 0;\n-    }\n-\n-    for (argn=1; argn < argc; argn++)\n-    {   /* list only the matching entries - each in order of commandline */\n-\tZZIP_MEM_ENTRY* entry = zzip_mem_disk_findfirst(disk);\n-\tfor (; entry ; entry = zzip_mem_disk_findnext(disk, entry))\n-\t{\n-\t    char* name = zzip_mem_entry_to_name (entry);\n-\t    if (! _zzip_fnmatch (argv[argn], name, \n-\t\t_zzip_FNM_NOESCAPE|_zzip_FNM_PATHNAME|_zzip_FNM_PERIOD))\n+    } else {\n+\tfor (argn=1; argn < argc; argn++)\n+\t{   /* list only the matching entries - each in order of commandline */\n+\t    ZZIP_MEM_ENTRY* entry = zzip_mem_disk_findfirst(disk);\n+\t    for (; entry ; entry = zzip_mem_disk_findnext(disk, entry))\n \t    {\n-\t        FILE* out = stdout;\n-\t        if (extract) out = create_fopen(name, \"wb\", 1);\n-\t        if (! out) {\n-\t            if (errno != EISDIR) done = EXIT_ERRORS;\n-\t            continue;\n-\t        }\n-\t\tunzzip_mem_disk_cat_file (disk, name, out);\n-\t\tif (extract) fclose(out);\n-\t\tbreak; /* match loop */\n+\t        char* name = zzip_mem_entry_to_name (entry);\n+\t        if (! _zzip_fnmatch (argv[argn], name, \n+\t\t    _zzip_FNM_NOESCAPE|_zzip_FNM_PATHNAME|_zzip_FNM_PERIOD))\n+\t        {\n+\t            FILE* out = stdout;\n+\t            if (extract) out = create_fopen(name, \"wb\", 1);\n+\t\t    if (! out) {\n+\t\t        if (errno != EISDIR) {\n+\t\t            DBG3(\"can not open output file %i %s\", errno, strerror(errno));\n+\t\t            done = EXIT_ERRORS;\n+\t\t        }\n+\t\t        continue;\n+\t\t    }\n+\t\t    unzzip_mem_disk_cat_file (disk, name, out);\n+\t\t    if (extract) fclose(out);\n+\t\t    break; /* match loop */\n+\t\t}\n \t    }\n \t}\n     }\n+    zzip_mem_disk_close(disk);\n     return done;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    int done;",
                "\t        if (errno != EISDIR) done = EXIT_ERRORS;",
                "\treturn done;",
                "    }",
                "",
                "    if (argc == 3 && !extract)",
                "",
                "\treturn 0;",
                "    }",
                "",
                "    for (argn=1; argn < argc; argn++)",
                "    {   /* list only the matching entries - each in order of commandline */",
                "\tZZIP_MEM_ENTRY* entry = zzip_mem_disk_findfirst(disk);",
                "\tfor (; entry ; entry = zzip_mem_disk_findnext(disk, entry))",
                "\t{",
                "\t    char* name = zzip_mem_entry_to_name (entry);",
                "\t    if (! _zzip_fnmatch (argv[argn], name, ",
                "\t\t_zzip_FNM_NOESCAPE|_zzip_FNM_PATHNAME|_zzip_FNM_PERIOD))",
                "\t        FILE* out = stdout;",
                "\t        if (extract) out = create_fopen(name, \"wb\", 1);",
                "\t        if (! out) {",
                "\t            if (errno != EISDIR) done = EXIT_ERRORS;",
                "\t            continue;",
                "\t        }",
                "\t\tunzzip_mem_disk_cat_file (disk, name, out);",
                "\t\tif (extract) fclose(out);",
                "\t\tbreak; /* match loop */"
            ],
            "added_lines": [
                "    int done = 0;",
                "\t        if (errno != EISDIR) {",
                "\t             DBG3(\"can not open output file %i %s\", errno, strerror(errno));",
                "\t             done = EXIT_ERRORS;",
                "\t        }",
                "    } ",
                "    else if (argc == 3 && !extract)",
                "    } else {",
                "\tfor (argn=1; argn < argc; argn++)",
                "\t{   /* list only the matching entries - each in order of commandline */",
                "\t    ZZIP_MEM_ENTRY* entry = zzip_mem_disk_findfirst(disk);",
                "\t    for (; entry ; entry = zzip_mem_disk_findnext(disk, entry))",
                "\t        char* name = zzip_mem_entry_to_name (entry);",
                "\t        if (! _zzip_fnmatch (argv[argn], name, ",
                "\t\t    _zzip_FNM_NOESCAPE|_zzip_FNM_PATHNAME|_zzip_FNM_PERIOD))",
                "\t        {",
                "\t            FILE* out = stdout;",
                "\t            if (extract) out = create_fopen(name, \"wb\", 1);",
                "\t\t    if (! out) {",
                "\t\t        if (errno != EISDIR) {",
                "\t\t            DBG3(\"can not open output file %i %s\", errno, strerror(errno));",
                "\t\t            done = EXIT_ERRORS;",
                "\t\t        }",
                "\t\t        continue;",
                "\t\t    }",
                "\t\t    unzzip_mem_disk_cat_file (disk, name, out);",
                "\t\t    if (extract) fclose(out);",
                "\t\t    break; /* match loop */",
                "\t\t}",
                "    zzip_mem_disk_close(disk);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7727",
        "func_name": "gdraheim/zziplib/unzzip_list",
        "description": "An issue was discovered in ZZIPlib 0.13.68. There is a memory leak triggered in the function zzip_mem_disk_new in memdisk.c, which will lead to a denial of service attack.",
        "git_url": "https://github.com/gdraheim/zziplib/commit/83a2da55922f67e07f22048ac9671a44cc0d35c4",
        "commit_title": "ensure disk_close to avoid mem-leak #40",
        "commit_text": "",
        "func_before": "static int \nunzzip_list (int argc, char ** argv, int verbose)\n{\n    int argn;\n    ZZIP_MEM_DISK* disk;\n    \n    if (argc == 1)\n    {\n        printf (__FILE__\" version \"ZZIP_PACKAGE\" \"ZZIP_VERSION\"\\n\");\n        return EXIT_OK; /* better provide an archive argument */\n    }\n    \n    disk = zzip_mem_disk_open (argv[1]);\n    if (! disk) {\n        DBG3(\"disk_open failed [%i] %s\", errno, strerror(errno));\n\tperror(argv[1]);\n\treturn exitcode(errno);\n    }\n\n    if (argc == 2)\n    {  /* list all */\n\tZZIP_MEM_ENTRY* entry = zzip_mem_disk_findfirst(disk);\n\tDBG2(\"findfirst %p\", entry);\n\tfor (; entry ; entry = zzip_mem_disk_findnext(disk, entry))\n\t{\n\t    char* name = zzip_mem_entry_to_name (entry);\n\t    long long usize = entry->zz_usize;\n\t    if (!verbose)\n\t    {\n\t\tprintf (\"%22lli %s\\n\", usize, name);\n\t    } else \n\t    {\n\t\tlong long csize = entry->zz_csize;\n\t\tunsigned compr = entry->zz_compr;\n        \tconst char* defl = (compr < sizeof(comprlevel)) ? comprlevel[compr] : \"(redu)\";\n\t\tprintf (\"%lli/%lli %s %s\\n\", csize, usize, defl, name);\n\t    }\n\t}\n\treturn 0;\n    }\n\n    if (argc == 3)\n    {  /* list from one spec */\n\tZZIP_MEM_ENTRY* entry = 0;\n\twhile ((entry = zzip_mem_disk_findmatch(disk, argv[2], entry, 0, 0)))\n\t{\n\t    char* name = zzip_mem_entry_to_name (entry);\n\t    long long usize = entry->zz_usize;\n\t    if (!verbose)\n\t    {\n\t\tprintf (\"%22lli %s\\n\", usize, name);\n\t    } else \n\t    {\n\t\tlong long csize = entry->zz_csize;\n\t\tunsigned compr = entry->zz_compr;\n\t\tconst char* defl = (compr < sizeof(comprlevel)) ? comprlevel[compr] : \"(redu)\";\n\t\tprintf (\"%lli/%lli %s %s\\n\", csize, usize, defl, name);\n\t    }\n\t}\n\treturn 0;\n    }\n\n    {   /* list only the matching entries - in order of zip directory */\n\tZZIP_MEM_ENTRY* entry = zzip_mem_disk_findfirst(disk);\n\tfor (; entry ; entry = zzip_mem_disk_findnext(disk, entry))\n\t{\n\t    char* name = zzip_mem_entry_to_name (entry);\n\t    for (argn=1; argn < argc; argn++)\n\t    {\n\t\tif (! _zzip_fnmatch (argv[argn], name, \n\t\t      _zzip_FNM_NOESCAPE|_zzip_FNM_PATHNAME|_zzip_FNM_PERIOD))\n\t\t{\n\t\t    char* name = zzip_mem_entry_to_name (entry);\n\t\t    long long usize = entry->zz_usize;\n\t\t    if (!verbose)\n\t\t    {\n\t\t\tprintf (\"%22lli %s\\n\", usize, name);\n\t\t    } else \n\t\t    {\n\t\t\tlong long csize = entry->zz_csize;\n\t\t\tunsigned compr = entry->zz_compr;\n\t\t\tconst char* defl = (compr < sizeof(comprlevel)) ? comprlevel[compr] : \"(redu)\";\n\t    \t\tprintf (\"%lli/%lli %s %s\\n\", csize, usize, defl, name);\n\t    \t    }\n\t\t    break; /* match loop */\n\t\t}\n\t    }\n\t}\n\treturn 0;\n    }\n}",
        "func": "static int \nunzzip_list (int argc, char ** argv, int verbose)\n{\n    int argn;\n    ZZIP_MEM_DISK* disk;\n    \n    if (argc == 1)\n    {\n        printf (__FILE__\" version \"ZZIP_PACKAGE\" \"ZZIP_VERSION\"\\n\");\n        return EXIT_OK; /* better provide an archive argument */\n    }\n    \n    disk = zzip_mem_disk_open (argv[1]);\n    if (! disk) {\n        DBG3(\"disk_open failed [%i] %s\", errno, strerror(errno));\n\tperror(argv[1]);\n\treturn exitcode(errno);\n    }\n\n    if (argc == 2)\n    {  /* list all */\n\tZZIP_MEM_ENTRY* entry = zzip_mem_disk_findfirst(disk);\n\tDBG2(\"findfirst %p\", entry);\n\tfor (; entry ; entry = zzip_mem_disk_findnext(disk, entry))\n\t{\n\t    char* name = zzip_mem_entry_to_name (entry);\n\t    long long usize = entry->zz_usize;\n\t    if (!verbose)\n\t    {\n\t\tprintf (\"%22lli %s\\n\", usize, name);\n\t    } else \n\t    {\n\t\tlong long csize = entry->zz_csize;\n\t\tunsigned compr = entry->zz_compr;\n        \tconst char* defl = (compr < sizeof(comprlevel)) ? comprlevel[compr] : \"(redu)\";\n\t\tprintf (\"%lli/%lli %s %s\\n\", csize, usize, defl, name);\n\t    }\n\t}\n    }\n    else if (argc == 3)\n    {  /* list from one spec */\n\tZZIP_MEM_ENTRY* entry = 0;\n\twhile ((entry = zzip_mem_disk_findmatch(disk, argv[2], entry, 0, 0)))\n\t{\n\t    char* name = zzip_mem_entry_to_name (entry);\n\t    long long usize = entry->zz_usize;\n\t    if (!verbose)\n\t    {\n\t\tprintf (\"%22lli %s\\n\", usize, name);\n\t    } else \n\t    {\n\t\tlong long csize = entry->zz_csize;\n\t\tunsigned compr = entry->zz_compr;\n\t\tconst char* defl = (compr < sizeof(comprlevel)) ? comprlevel[compr] : \"(redu)\";\n\t\tprintf (\"%lli/%lli %s %s\\n\", csize, usize, defl, name);\n\t    }\n\t}\n    }\n    else\n    {   /* list only the matching entries - in order of zip directory */\n\tZZIP_MEM_ENTRY* entry = zzip_mem_disk_findfirst(disk);\n\tfor (; entry ; entry = zzip_mem_disk_findnext(disk, entry))\n\t{\n\t    char* name = zzip_mem_entry_to_name (entry);\n\t    for (argn=1; argn < argc; argn++)\n\t    {\n\t\tif (! _zzip_fnmatch (argv[argn], name, \n\t\t      _zzip_FNM_NOESCAPE|_zzip_FNM_PATHNAME|_zzip_FNM_PERIOD))\n\t\t{\n\t\t    char* name = zzip_mem_entry_to_name (entry);\n\t\t    long long usize = entry->zz_usize;\n\t\t    if (!verbose)\n\t\t    {\n\t\t\tprintf (\"%22lli %s\\n\", usize, name);\n\t\t    } else \n\t\t    {\n\t\t\tlong long csize = entry->zz_csize;\n\t\t\tunsigned compr = entry->zz_compr;\n\t\t\tconst char* defl = (compr < sizeof(comprlevel)) ? comprlevel[compr] : \"(redu)\";\n\t    \t\tprintf (\"%lli/%lli %s %s\\n\", csize, usize, defl, name);\n\t    \t    }\n\t\t    break; /* match loop */\n\t\t}\n\t    }\n\t}\n    }\n    zzip_mem_disk_close(disk);\n    return EXIT_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -36,10 +36,8 @@\n \t\tprintf (\"%lli/%lli %s %s\\n\", csize, usize, defl, name);\n \t    }\n \t}\n-\treturn 0;\n     }\n-\n-    if (argc == 3)\n+    else if (argc == 3)\n     {  /* list from one spec */\n \tZZIP_MEM_ENTRY* entry = 0;\n \twhile ((entry = zzip_mem_disk_findmatch(disk, argv[2], entry, 0, 0)))\n@@ -57,9 +55,8 @@\n \t\tprintf (\"%lli/%lli %s %s\\n\", csize, usize, defl, name);\n \t    }\n \t}\n-\treturn 0;\n     }\n-\n+    else\n     {   /* list only the matching entries - in order of zip directory */\n \tZZIP_MEM_ENTRY* entry = zzip_mem_disk_findfirst(disk);\n \tfor (; entry ; entry = zzip_mem_disk_findnext(disk, entry))\n@@ -86,6 +83,7 @@\n \t\t}\n \t    }\n \t}\n-\treturn 0;\n     }\n+    zzip_mem_disk_close(disk);\n+    return EXIT_OK;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn 0;",
                "",
                "    if (argc == 3)",
                "\treturn 0;",
                "",
                "\treturn 0;"
            ],
            "added_lines": [
                "    else if (argc == 3)",
                "    else",
                "    zzip_mem_disk_close(disk);",
                "    return EXIT_OK;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7757",
        "func_name": "torvalds/linux/sas_smp_get_phy_events",
        "description": "Memory leak in the sas_smp_get_phy_events function in drivers/scsi/libsas/sas_expander.c in the Linux kernel through 4.15.7 allows local users to cause a denial of service (memory consumption) via many read accesses to files in the /sys/class/sas_phy directory, as demonstrated by the /sys/class/sas_phy/phy-1:0:12/invalid_dword_count file.",
        "git_url": "https://github.com/torvalds/linux/commit/4a491b1ab11ca0556d2fda1ff1301e862a2d44c4",
        "commit_title": "scsi: libsas: fix memory leak in sas_smp_get_phy_events()",
        "commit_text": " We've got a memory leak with the following producer:  while true; do cat /sys/class/sas_phy/phy-1:0:12/invalid_dword_count >/dev/null; done  The buffer req is allocated and not freed after we return. Fix it. ",
        "func_before": "int sas_smp_get_phy_events(struct sas_phy *phy)\n{\n\tint res;\n\tu8 *req;\n\tu8 *resp;\n\tstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\n\tstruct domain_device *dev = sas_find_dev_by_rphy(rphy);\n\n\treq = alloc_smp_req(RPEL_REQ_SIZE);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tresp = alloc_smp_resp(RPEL_RESP_SIZE);\n\tif (!resp) {\n\t\tkfree(req);\n\t\treturn -ENOMEM;\n\t}\n\n\treq[1] = SMP_REPORT_PHY_ERR_LOG;\n\treq[9] = phy->number;\n\n\tres = smp_execute_task(dev, req, RPEL_REQ_SIZE,\n\t\t\t            resp, RPEL_RESP_SIZE);\n\n\tif (!res)\n\t\tgoto out;\n\n\tphy->invalid_dword_count = scsi_to_u32(&resp[12]);\n\tphy->running_disparity_error_count = scsi_to_u32(&resp[16]);\n\tphy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);\n\tphy->phy_reset_problem_count = scsi_to_u32(&resp[24]);\n\n out:\n\tkfree(resp);\n\treturn res;\n\n}",
        "func": "int sas_smp_get_phy_events(struct sas_phy *phy)\n{\n\tint res;\n\tu8 *req;\n\tu8 *resp;\n\tstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\n\tstruct domain_device *dev = sas_find_dev_by_rphy(rphy);\n\n\treq = alloc_smp_req(RPEL_REQ_SIZE);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tresp = alloc_smp_resp(RPEL_RESP_SIZE);\n\tif (!resp) {\n\t\tkfree(req);\n\t\treturn -ENOMEM;\n\t}\n\n\treq[1] = SMP_REPORT_PHY_ERR_LOG;\n\treq[9] = phy->number;\n\n\tres = smp_execute_task(dev, req, RPEL_REQ_SIZE,\n\t\t\t            resp, RPEL_RESP_SIZE);\n\n\tif (!res)\n\t\tgoto out;\n\n\tphy->invalid_dword_count = scsi_to_u32(&resp[12]);\n\tphy->running_disparity_error_count = scsi_to_u32(&resp[16]);\n\tphy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);\n\tphy->phy_reset_problem_count = scsi_to_u32(&resp[24]);\n\n out:\n\tkfree(req);\n\tkfree(resp);\n\treturn res;\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,6 +31,7 @@\n \tphy->phy_reset_problem_count = scsi_to_u32(&resp[24]);\n \n  out:\n+\tkfree(req);\n \tkfree(resp);\n \treturn res;\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tkfree(req);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-13153",
        "func_name": "ImageMagick/XMagickCommand",
        "description": "In ImageMagick 7.0.8-4, there is a memory leak in the XMagickCommand function in MagickCore/animate.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/4ab4849d667e26df0e63ece9d63ae23bc7ab0fa1",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1195",
        "commit_text": "",
        "func_before": "static Image *XMagickCommand(Display *display,XResourceInfo *resource_info,\n  XWindows *windows,const CommandType command_type,Image **image,\n  MagickStatusType *state,ExceptionInfo *exception)\n{\n  Image\n    *nexus;\n\n  MagickBooleanType\n    proceed;\n\n  MagickStatusType\n    status;\n\n  XTextProperty\n    window_name;\n\n  /*\n    Process user command.\n  */\n  nexus=NewImageList();\n  switch (command_type)\n  {\n    case OpenCommand:\n    {\n      char\n        **filelist;\n\n      Image\n        *images,\n        *next;\n\n      ImageInfo\n        *read_info;\n\n      int\n        number_files;\n\n      register int\n        i;\n\n      static char\n        filenames[MagickPathExtent] = \"*\";\n\n      if (resource_info->immutable != MagickFalse)\n        break;\n      /*\n        Request file name from user.\n      */\n      XFileBrowserWidget(display,windows,\"Animate\",filenames);\n      if (*filenames == '\\0')\n        return((Image *) NULL);\n      /*\n        Expand the filenames.\n      */\n      filelist=(char **) AcquireMagickMemory(sizeof(char *));\n      if (filelist == (char **) NULL)\n        {\n          ThrowXWindowException(ResourceLimitError,\"MemoryAllocationFailed\",\n            filenames);\n          return((Image *) NULL);\n        }\n      number_files=1;\n      filelist[0]=filenames;\n      status=ExpandFilenames(&number_files,&filelist);\n      if ((status == MagickFalse) || (number_files == 0))\n        {\n          if (number_files == 0)\n            {\n              ThrowXWindowException(ImageError,\"NoImagesWereLoaded\",filenames);\n             return((Image *) NULL);\n            }\n          ThrowXWindowException(ResourceLimitError,\"MemoryAllocationFailed\",\n            filenames);\n          return((Image *) NULL);\n        }\n      read_info=CloneImageInfo(resource_info->image_info);\n      images=NewImageList();\n      XSetCursorState(display,windows,MagickTrue);\n      XCheckRefreshWindows(display,windows);\n      for (i=0; i < number_files; i++)\n      {\n        (void) CopyMagickString(read_info->filename,filelist[i],MagickPathExtent);\n        filelist[i]=DestroyString(filelist[i]);\n        *read_info->magick='\\0';\n        next=ReadImage(read_info,exception);\n        CatchException(exception);\n        if (next != (Image *) NULL)\n          AppendImageToList(&images,next);\n        if (number_files <= 5)\n          continue;\n        proceed=SetImageProgress(images,LoadImageTag,i,(MagickSizeType)\n          number_files);\n        if (proceed == MagickFalse)\n          break;\n      }\n      filelist=(char **) RelinquishMagickMemory(filelist);\n      read_info=DestroyImageInfo(read_info);\n      if (images == (Image *) NULL)\n        {\n          XSetCursorState(display,windows,MagickFalse);\n          ThrowXWindowException(ImageError,\"NoImagesWereLoaded\",filenames);\n          return((Image *) NULL);\n        }\n      nexus=GetFirstImageInList(images);\n      *state|=ExitState;\n      break;\n    }\n    case PlayCommand:\n    {\n      char\n        basename[MagickPathExtent];\n\n      int\n        status;\n\n      /*\n        Window name is the base of the filename.\n      */\n      *state|=PlayAnimationState;\n      *state&=(~AutoReverseAnimationState);\n      GetPathComponent((*image)->magick_filename,BasePath,basename);\n      (void) FormatLocaleString(windows->image.name,MagickPathExtent,\n        \"%s: %s\",MagickPackageName,basename);\n      if (resource_info->title != (char *) NULL)\n        {\n          char\n            *title;\n\n          title=InterpretImageProperties(resource_info->image_info,*image,\n            resource_info->title,exception);\n          (void) CopyMagickString(windows->image.name,title,MagickPathExtent);\n          title=DestroyString(title);\n        }\n      status=XStringListToTextProperty(&windows->image.name,1,&window_name);\n      if (status == 0)\n        break;\n      XSetWMName(display,windows->image.id,&window_name);\n      (void) XFree((void *) window_name.value);\n      break;\n    }\n    case StepCommand:\n    case StepBackwardCommand:\n    case StepForwardCommand:\n    {\n      *state|=StepAnimationState;\n      *state&=(~PlayAnimationState);\n      if (command_type == StepBackwardCommand)\n        *state&=(~ForwardAnimationState);\n      if (command_type == StepForwardCommand)\n        *state|=ForwardAnimationState;\n      if (resource_info->title != (char *) NULL)\n        break;\n      break;\n    }\n    case RepeatCommand:\n    {\n      *state|=RepeatAnimationState;\n      *state&=(~AutoReverseAnimationState);\n      *state|=PlayAnimationState;\n      break;\n    }\n    case AutoReverseCommand:\n    {\n      *state|=AutoReverseAnimationState;\n      *state&=(~RepeatAnimationState);\n      *state|=PlayAnimationState;\n      break;\n    }\n    case SaveCommand:\n    {\n      /*\n        Save image.\n      */\n      status=XSaveImage(display,resource_info,windows,*image,exception);\n      if (status == MagickFalse)\n        {\n          char\n            message[MagickPathExtent];\n\n          (void) FormatLocaleString(message,MagickPathExtent,\"%s:%s\",\n            exception->reason != (char *) NULL ? exception->reason : \"\",\n            exception->description != (char *) NULL ? exception->description :\n            \"\");\n          XNoticeWidget(display,windows,\"Unable to save file:\",message);\n          break;\n        }\n      break;\n    }\n    case SlowerCommand:\n    {\n      resource_info->delay++;\n      break;\n    }\n    case FasterCommand:\n    {\n      if (resource_info->delay == 0)\n        break;\n      resource_info->delay--;\n      break;\n    }\n    case ForwardCommand:\n    {\n      *state=ForwardAnimationState;\n      *state&=(~AutoReverseAnimationState);\n      break;\n    }\n    case ReverseCommand:\n    {\n      *state&=(~ForwardAnimationState);\n      *state&=(~AutoReverseAnimationState);\n      break;\n    }\n    case InfoCommand:\n    {\n      XDisplayImageInfo(display,resource_info,windows,(Image *) NULL,*image,\n        exception);\n      break;\n    }\n    case HelpCommand:\n    {\n      /*\n        User requested help.\n      */\n      XTextViewWidget(display,resource_info,windows,MagickFalse,\n        \"Help Viewer - Animate\",AnimateHelp);\n      break;\n    }\n    case BrowseDocumentationCommand:\n    {\n      Atom\n        mozilla_atom;\n\n      Window\n        mozilla_window,\n        root_window;\n\n      /*\n        Browse the ImageMagick documentation.\n      */\n      root_window=XRootWindow(display,XDefaultScreen(display));\n      mozilla_atom=XInternAtom(display,\"_MOZILLA_VERSION\",MagickFalse);\n      mozilla_window=XWindowByProperty(display,root_window,mozilla_atom);\n      if (mozilla_window != (Window) NULL)\n        {\n          char\n            command[MagickPathExtent],\n            *url;\n\n          /*\n            Display documentation using Netscape remote control.\n          */\n          url=GetMagickHomeURL();\n          (void) FormatLocaleString(command,MagickPathExtent,\n            \"openurl(%s,new-tab)\",url);\n          url=DestroyString(url);\n          mozilla_atom=XInternAtom(display,\"_MOZILLA_COMMAND\",MagickFalse);\n          (void) XChangeProperty(display,mozilla_window,mozilla_atom,\n            XA_STRING,8,PropModeReplace,(unsigned char *) command,\n            (int) strlen(command));\n          XSetCursorState(display,windows,MagickFalse);\n          break;\n        }\n      XSetCursorState(display,windows,MagickTrue);\n      XCheckRefreshWindows(display,windows);\n      status=InvokeDelegate(resource_info->image_info,*image,\"browse\",\n        (char *) NULL,exception);\n      if (status == MagickFalse)\n        XNoticeWidget(display,windows,\"Unable to browse documentation\",\n          (char *) NULL);\n      XDelay(display,1500);\n      XSetCursorState(display,windows,MagickFalse);\n      break;\n    }\n    case VersionCommand:\n    {\n      XNoticeWidget(display,windows,GetMagickVersion((size_t *) NULL),\n        GetMagickCopyright());\n      break;\n    }\n    case QuitCommand:\n    {\n      /*\n        exit program\n      */\n      if (resource_info->confirm_exit == MagickFalse)\n        XClientMessage(display,windows->image.id,windows->im_protocols,\n          windows->im_exit,CurrentTime);\n      else\n        {\n          int\n            status;\n\n          /*\n            Confirm program exit.\n          */\n          status=XConfirmWidget(display,windows,\"Do you really want to exit\",\n            resource_info->client_name);\n          if (status != 0)\n            XClientMessage(display,windows->image.id,windows->im_protocols,\n              windows->im_exit,CurrentTime);\n        }\n      break;\n    }\n    default:\n      break;\n  }\n  return(nexus);\n}",
        "func": "static Image *XMagickCommand(Display *display,XResourceInfo *resource_info,\n  XWindows *windows,const CommandType command_type,Image **image,\n  MagickStatusType *state,ExceptionInfo *exception)\n{\n  Image\n    *nexus;\n\n  MagickBooleanType\n    proceed;\n\n  MagickStatusType\n    status;\n\n  XTextProperty\n    window_name;\n\n  /*\n    Process user command.\n  */\n  nexus=NewImageList();\n  switch (command_type)\n  {\n    case OpenCommand:\n    {\n      char\n        **filelist;\n\n      Image\n        *images,\n        *next;\n\n      ImageInfo\n        *read_info;\n\n      int\n        number_files;\n\n      register int\n        i;\n\n      static char\n        filenames[MagickPathExtent] = \"*\";\n\n      if (resource_info->immutable != MagickFalse)\n        break;\n      /*\n        Request file name from user.\n      */\n      XFileBrowserWidget(display,windows,\"Animate\",filenames);\n      if (*filenames == '\\0')\n        return((Image *) NULL);\n      /*\n        Expand the filenames.\n      */\n      filelist=(char **) AcquireMagickMemory(sizeof(char *));\n      if (filelist == (char **) NULL)\n        {\n          ThrowXWindowException(ResourceLimitError,\"MemoryAllocationFailed\",\n            filenames);\n          return((Image *) NULL);\n        }\n      number_files=1;\n      filelist[0]=filenames;\n      status=ExpandFilenames(&number_files,&filelist);\n      if ((status == MagickFalse) || (number_files == 0))\n        {\n          for (i=0; i < number_files; i++)\n            filelist[i]=DestroyString(filelist[i]);\n          filelist=(char **) RelinquishMagickMemory(filelist);\n          if (number_files == 0)\n            {\n              ThrowXWindowException(ImageError,\"NoImagesWereLoaded\",filenames);\n              return((Image *) NULL);\n            }\n          ThrowXWindowException(ResourceLimitError,\"MemoryAllocationFailed\",\n            filenames);\n          return((Image *) NULL);\n        }\n      read_info=CloneImageInfo(resource_info->image_info);\n      images=NewImageList();\n      XSetCursorState(display,windows,MagickTrue);\n      XCheckRefreshWindows(display,windows);\n      for (i=0; i < number_files; i++)\n      {\n        (void) CopyMagickString(read_info->filename,filelist[i],MagickPathExtent);\n        filelist[i]=DestroyString(filelist[i]);\n        *read_info->magick='\\0';\n        next=ReadImage(read_info,exception);\n        CatchException(exception);\n        if (next != (Image *) NULL)\n          AppendImageToList(&images,next);\n        if (number_files <= 5)\n          continue;\n        proceed=SetImageProgress(images,LoadImageTag,i,(MagickSizeType)\n          number_files);\n        if (proceed == MagickFalse)\n          break;\n      }\n      filelist=(char **) RelinquishMagickMemory(filelist);\n      read_info=DestroyImageInfo(read_info);\n      if (images == (Image *) NULL)\n        {\n          XSetCursorState(display,windows,MagickFalse);\n          ThrowXWindowException(ImageError,\"NoImagesWereLoaded\",filenames);\n          return((Image *) NULL);\n        }\n      nexus=GetFirstImageInList(images);\n      *state|=ExitState;\n      break;\n    }\n    case PlayCommand:\n    {\n      char\n        basename[MagickPathExtent];\n\n      int\n        status;\n\n      /*\n        Window name is the base of the filename.\n      */\n      *state|=PlayAnimationState;\n      *state&=(~AutoReverseAnimationState);\n      GetPathComponent((*image)->magick_filename,BasePath,basename);\n      (void) FormatLocaleString(windows->image.name,MagickPathExtent,\n        \"%s: %s\",MagickPackageName,basename);\n      if (resource_info->title != (char *) NULL)\n        {\n          char\n            *title;\n\n          title=InterpretImageProperties(resource_info->image_info,*image,\n            resource_info->title,exception);\n          (void) CopyMagickString(windows->image.name,title,MagickPathExtent);\n          title=DestroyString(title);\n        }\n      status=XStringListToTextProperty(&windows->image.name,1,&window_name);\n      if (status == 0)\n        break;\n      XSetWMName(display,windows->image.id,&window_name);\n      (void) XFree((void *) window_name.value);\n      break;\n    }\n    case StepCommand:\n    case StepBackwardCommand:\n    case StepForwardCommand:\n    {\n      *state|=StepAnimationState;\n      *state&=(~PlayAnimationState);\n      if (command_type == StepBackwardCommand)\n        *state&=(~ForwardAnimationState);\n      if (command_type == StepForwardCommand)\n        *state|=ForwardAnimationState;\n      if (resource_info->title != (char *) NULL)\n        break;\n      break;\n    }\n    case RepeatCommand:\n    {\n      *state|=RepeatAnimationState;\n      *state&=(~AutoReverseAnimationState);\n      *state|=PlayAnimationState;\n      break;\n    }\n    case AutoReverseCommand:\n    {\n      *state|=AutoReverseAnimationState;\n      *state&=(~RepeatAnimationState);\n      *state|=PlayAnimationState;\n      break;\n    }\n    case SaveCommand:\n    {\n      /*\n        Save image.\n      */\n      status=XSaveImage(display,resource_info,windows,*image,exception);\n      if (status == MagickFalse)\n        {\n          char\n            message[MagickPathExtent];\n\n          (void) FormatLocaleString(message,MagickPathExtent,\"%s:%s\",\n            exception->reason != (char *) NULL ? exception->reason : \"\",\n            exception->description != (char *) NULL ? exception->description :\n            \"\");\n          XNoticeWidget(display,windows,\"Unable to save file:\",message);\n          break;\n        }\n      break;\n    }\n    case SlowerCommand:\n    {\n      resource_info->delay++;\n      break;\n    }\n    case FasterCommand:\n    {\n      if (resource_info->delay == 0)\n        break;\n      resource_info->delay--;\n      break;\n    }\n    case ForwardCommand:\n    {\n      *state=ForwardAnimationState;\n      *state&=(~AutoReverseAnimationState);\n      break;\n    }\n    case ReverseCommand:\n    {\n      *state&=(~ForwardAnimationState);\n      *state&=(~AutoReverseAnimationState);\n      break;\n    }\n    case InfoCommand:\n    {\n      XDisplayImageInfo(display,resource_info,windows,(Image *) NULL,*image,\n        exception);\n      break;\n    }\n    case HelpCommand:\n    {\n      /*\n        User requested help.\n      */\n      XTextViewWidget(display,resource_info,windows,MagickFalse,\n        \"Help Viewer - Animate\",AnimateHelp);\n      break;\n    }\n    case BrowseDocumentationCommand:\n    {\n      Atom\n        mozilla_atom;\n\n      Window\n        mozilla_window,\n        root_window;\n\n      /*\n        Browse the ImageMagick documentation.\n      */\n      root_window=XRootWindow(display,XDefaultScreen(display));\n      mozilla_atom=XInternAtom(display,\"_MOZILLA_VERSION\",MagickFalse);\n      mozilla_window=XWindowByProperty(display,root_window,mozilla_atom);\n      if (mozilla_window != (Window) NULL)\n        {\n          char\n            command[MagickPathExtent],\n            *url;\n\n          /*\n            Display documentation using Netscape remote control.\n          */\n          url=GetMagickHomeURL();\n          (void) FormatLocaleString(command,MagickPathExtent,\n            \"openurl(%s,new-tab)\",url);\n          url=DestroyString(url);\n          mozilla_atom=XInternAtom(display,\"_MOZILLA_COMMAND\",MagickFalse);\n          (void) XChangeProperty(display,mozilla_window,mozilla_atom,\n            XA_STRING,8,PropModeReplace,(unsigned char *) command,\n            (int) strlen(command));\n          XSetCursorState(display,windows,MagickFalse);\n          break;\n        }\n      XSetCursorState(display,windows,MagickTrue);\n      XCheckRefreshWindows(display,windows);\n      status=InvokeDelegate(resource_info->image_info,*image,\"browse\",\n        (char *) NULL,exception);\n      if (status == MagickFalse)\n        XNoticeWidget(display,windows,\"Unable to browse documentation\",\n          (char *) NULL);\n      XDelay(display,1500);\n      XSetCursorState(display,windows,MagickFalse);\n      break;\n    }\n    case VersionCommand:\n    {\n      XNoticeWidget(display,windows,GetMagickVersion((size_t *) NULL),\n        GetMagickCopyright());\n      break;\n    }\n    case QuitCommand:\n    {\n      /*\n        exit program\n      */\n      if (resource_info->confirm_exit == MagickFalse)\n        XClientMessage(display,windows->image.id,windows->im_protocols,\n          windows->im_exit,CurrentTime);\n      else\n        {\n          int\n            status;\n\n          /*\n            Confirm program exit.\n          */\n          status=XConfirmWidget(display,windows,\"Do you really want to exit\",\n            resource_info->client_name);\n          if (status != 0)\n            XClientMessage(display,windows->image.id,windows->im_protocols,\n              windows->im_exit,CurrentTime);\n        }\n      break;\n    }\n    default:\n      break;\n  }\n  return(nexus);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -64,10 +64,13 @@\n       status=ExpandFilenames(&number_files,&filelist);\n       if ((status == MagickFalse) || (number_files == 0))\n         {\n+          for (i=0; i < number_files; i++)\n+            filelist[i]=DestroyString(filelist[i]);\n+          filelist=(char **) RelinquishMagickMemory(filelist);\n           if (number_files == 0)\n             {\n               ThrowXWindowException(ImageError,\"NoImagesWereLoaded\",filenames);\n-             return((Image *) NULL);\n+              return((Image *) NULL);\n             }\n           ThrowXWindowException(ResourceLimitError,\"MemoryAllocationFailed\",\n             filenames);",
        "diff_line_info": {
            "deleted_lines": [
                "             return((Image *) NULL);"
            ],
            "added_lines": [
                "          for (i=0; i < number_files; i++)",
                "            filelist[i]=DestroyString(filelist[i]);",
                "          filelist=(char **) RelinquishMagickMemory(filelist);",
                "              return((Image *) NULL);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-13843",
        "func_name": "samtools/htslib/sam_parse1",
        "description": "An issue has been found in HTSlib 1.8. It is a memory leak in bgzf_getline in bgzf.c. NOTE: the software maintainer's position is that the \"failure to free memory\" can be fixed in applications that use the HTSlib library (such as test/test_bgzf.c in the original report) and is not a library issue",
        "git_url": "https://github.com/samtools/htslib/commit/99acb64270f43a015672b4cd9e72c3b02c334c4d",
        "commit_title": "Fix memory leak in `test_realn`.",
        "commit_text": "Fix buffer overflow in `sam_parse1`. Fixes #731.",
        "func_before": "int sam_parse1(kstring_t *s, bam_hdr_t *h, bam1_t *b)\n{\n#define _read_token(_p) (_p); for (; *(_p) && *(_p) != '\\t'; ++(_p)); if (*(_p) != '\\t') goto err_ret; *(_p)++ = 0\n#define _read_token_aux(_p) (_p); for (; *(_p) && *(_p) != '\\t'; ++(_p)); *(_p)++ = 0 // this is different in that it does not test *(_p)=='\\t'\n#define _get_mem(type_t, _x, _s, _l) ks_resize((_s), (_s)->l + (_l)); *(_x) = (type_t*)((_s)->s + (_s)->l); (_s)->l += (_l)\n#define _parse_err(cond, msg) do { if (cond) { hts_log_error(msg); goto err_ret; } } while (0)\n#define _parse_err_param(cond, msg, param) do { if (cond) { hts_log_error(msg, param); goto err_ret; } } while (0)\n#define _parse_warn(cond, msg) do { if (cond) { hts_log_warning(msg); } } while (0)\n\n    uint8_t *t;\n    char *p = s->s, *q;\n    int i;\n    kstring_t str;\n    bam1_core_t *c = &b->core;\n\n    str.l = b->l_data = 0;\n    str.s = (char*)b->data; str.m = b->m_data;\n    memset(c, 0, 32);\n    if (h->cigar_tab == 0) {\n        h->cigar_tab = (int8_t*) malloc(128);\n        for (i = 0; i < 128; ++i)\n            h->cigar_tab[i] = -1;\n        for (i = 0; BAM_CIGAR_STR[i]; ++i)\n            h->cigar_tab[(int)BAM_CIGAR_STR[i]] = i;\n    }\n    // qname\n    q = _read_token(p);\n    _parse_warn(p - q <= 1, \"empty query name\");\n    _parse_err(p - q > 252, \"query name too long\");\n    kputsn_(q, p - q, &str);\n    for (c->l_extranul = 0; str.l % 4 != 0; c->l_extranul++)\n        kputc_('\\0', &str);\n    c->l_qname = p - q + c->l_extranul;\n    // flag\n    c->flag = strtol(p, &p, 0);\n    if (*p++ != '\\t') goto err_ret; // malformated flag\n    // chr\n    q = _read_token(p);\n    if (strcmp(q, \"*\")) {\n        _parse_err(h->n_targets == 0, \"missing SAM header\");\n        c->tid = bam_name2id(h, q);\n        _parse_warn(c->tid < 0, \"urecognized reference name; treated as unmapped\");\n    } else c->tid = -1;\n    // pos\n    c->pos = strtol(p, &p, 10) - 1;\n    if (*p++ != '\\t') goto err_ret;\n    if (c->pos < 0 && c->tid >= 0) {\n        _parse_warn(1, \"mapped query cannot have zero coordinate; treated as unmapped\");\n        c->tid = -1;\n    }\n    if (c->tid < 0) c->flag |= BAM_FUNMAP;\n    // mapq\n    c->qual = strtol(p, &p, 10);\n    if (*p++ != '\\t') goto err_ret;\n    // cigar\n    if (*p != '*') {\n        uint32_t *cigar;\n        size_t n_cigar = 0;\n        for (q = p; *p && *p != '\\t'; ++p)\n            if (!isdigit_c(*p)) ++n_cigar;\n        if (*p++ != '\\t') goto err_ret;\n        _parse_err(n_cigar == 0, \"no CIGAR operations\");\n        _parse_err(n_cigar >= 2147483647, \"too many CIGAR operations\");\n        c->n_cigar = n_cigar;\n        _get_mem(uint32_t, &cigar, &str, c->n_cigar * sizeof(uint32_t));\n        for (i = 0; i < c->n_cigar; ++i, ++q) {\n            int op;\n            cigar[i] = strtol(q, &q, 10)<<BAM_CIGAR_SHIFT;\n            op = (uint8_t)*q >= 128? -1 : h->cigar_tab[(int)*q];\n            _parse_err(op < 0, \"unrecognized CIGAR operator\");\n            cigar[i] |= op;\n        }\n        // can't use bam_endpos() directly as some fields not yet set up\n        i = (!(c->flag&BAM_FUNMAP))? bam_cigar2rlen(c->n_cigar, cigar) : 1;\n    } else {\n        _parse_warn(!(c->flag&BAM_FUNMAP), \"mapped query must have a CIGAR; treated as unmapped\");\n        c->flag |= BAM_FUNMAP;\n        q = _read_token(p);\n        i = 1;\n    }\n    c->bin = hts_reg2bin(c->pos, c->pos + i, 14, 5);\n    // mate chr\n    q = _read_token(p);\n    if (strcmp(q, \"=\") == 0) {\n        c->mtid = c->tid;\n    } else if (strcmp(q, \"*\") == 0) {\n        c->mtid = -1;\n    } else {\n        c->mtid = bam_name2id(h, q);\n        _parse_warn(c->mtid < 0, \"urecognized mate reference name; treated as unmapped\");\n    }\n    // mpos\n    c->mpos = strtol(p, &p, 10) - 1;\n    if (*p++ != '\\t') goto err_ret;\n    if (c->mpos < 0 && c->mtid >= 0) {\n        _parse_warn(1, \"mapped mate cannot have zero coordinate; treated as unmapped\");\n        c->mtid = -1;\n    }\n    // tlen\n    c->isize = strtol(p, &p, 10);\n    if (*p++ != '\\t') goto err_ret;\n    // seq\n    q = _read_token(p);\n    if (strcmp(q, \"*\")) {\n        c->l_qseq = p - q - 1;\n        i = bam_cigar2qlen(c->n_cigar, (uint32_t*)(str.s + c->l_qname));\n        _parse_err(c->n_cigar && i != c->l_qseq, \"CIGAR and query sequence are of different length\");\n        i = (c->l_qseq + 1) >> 1;\n        _get_mem(uint8_t, &t, &str, i);\n        memset(t, 0, i);\n        for (i = 0; i < c->l_qseq; ++i)\n            t[i>>1] |= seq_nt16_table[(int)q[i]] << ((~i&1)<<2);\n    } else c->l_qseq = 0;\n    // qual\n    q = _read_token_aux(p);\n    _get_mem(uint8_t, &t, &str, c->l_qseq);\n    if (strcmp(q, \"*\")) {\n        _parse_err(p - q - 1 != c->l_qseq, \"SEQ and QUAL are of different length\");\n        for (i = 0; i < c->l_qseq; ++i) t[i] = q[i] - 33;\n    } else memset(t, 0xff, c->l_qseq);\n    // aux\n    while (p < s->s + s->l) {\n        uint8_t type;\n        q = _read_token_aux(p); // FIXME: can be accelerated for long 'B' arrays\n        _parse_err(p - q - 1 < 5, \"incomplete aux field\");\n        kputsn_(q, 2, &str);\n        q += 3; type = *q++; ++q; // q points to value\n        if (type != 'Z' && type != 'H') // the only zero length acceptable fields\n            _parse_err(p - q - 1 < 1, \"incomplete aux field\");\n\n        // Ensure str has enough space for a double + type allocated.\n        // This is so we can stuff bigger integers and floats directly into\n        // the kstring.  Sorry.\n        _parse_err(ks_resize(&str, str.l + 16), \"out of memory\");\n\n        if (type == 'A' || type == 'a' || type == 'c' || type == 'C') {\n            kputc_('A', &str);\n            kputc_(*q, &str);\n        } else if (type == 'i' || type == 'I') {\n            if (*q == '-') {\n                long x = strtol(q, &q, 10);\n                if (x >= INT8_MIN) {\n                    kputc_('c', &str); kputc_(x, &str);\n                } else if (x >= INT16_MIN) {\n                    str.s[str.l++] = 's';\n                    i16_to_le(x, (uint8_t *) str.s + str.l);\n                    str.l += 2;\n                } else {\n                    str.s[str.l++] = 'i';\n                    i32_to_le(x, (uint8_t *) str.s + str.l);\n                    str.l += 4;\n                }\n            } else {\n                unsigned long x = strtoul(q, &q, 10);\n                if (x <= UINT8_MAX) {\n                    kputc_('C', &str); kputc_(x, &str);\n                } else if (x <= UINT16_MAX) {\n                    str.s[str.l++] = 'S';\n                    u16_to_le(x, (uint8_t *) str.s + str.l);\n                    str.l += 2;\n                } else {\n                    str.s[str.l++] = 'I';\n                    u32_to_le(x, (uint8_t *) str.s + str.l);\n                    str.l += 4;\n                }\n            }\n        } else if (type == 'f') {\n            str.s[str.l++] = 'f';\n            float_to_le(strtod(q, &q), (uint8_t *) str.s + str.l);\n            str.l += sizeof(float);\n        } else if (type == 'd') {\n            str.s[str.l++] = 'd';\n            double_to_le(strtod(q, &q), (uint8_t *) str.s + str.l);\n            str.l += sizeof(double);\n        } else if (type == 'Z' || type == 'H') {\n            _parse_err(type == 'H' && !((p-q)&1),\n                       \"hex field does not have an even number of digits\");\n            kputc_(type, &str);kputsn_(q, p - q, &str); // note that this include the trailing NULL\n        } else if (type == 'B') {\n            int32_t n, size;\n            size_t bytes;\n            char *r;\n            _parse_err(p - q - 1 < 3, \"incomplete B-typed aux field\");\n            type = *q++; // q points to the first ',' following the typing byte\n\n            size = aux_type2size(type);\n            _parse_err_param(size <= 0 || size > 4,\n                             \"unrecognized type B:%c\", type);\n            _parse_err(*q && *q != ',', \"B aux field type not followed by ','\");\n\n            for (r = q, n = 0; *r; ++r)\n                if (*r == ',') ++n;\n\n            // Ensure space for type + values\n            bytes = (size_t) n * (size_t) size;\n            _parse_err(bytes / size != n\n                       || ks_resize(&str, str.l + bytes + 2 + sizeof(uint32_t)),\n                       \"out of memory\");\n            str.s[str.l++] = 'B';\n            str.s[str.l++] = type;\n            i32_to_le(n, (uint8_t *) str.s + str.l);\n            str.l += sizeof(uint32_t);\n\n            // This ensures that q always ends up at the next comma after\n            // reading a number even if it's followed by junk.  It\n            // prevents the possibility of trying to read more than n items.\n#define _skip_to_comma(q, p) do { while ((q) < (p) && *(q) != ',') (q)++; } while (0)\n\n            if (type == 'c')      while (q + 1 < p) { int8_t   x = strtol(q + 1, &q, 0); kputc_(x, &str); }\n            else if (type == 'C') while (q + 1 < p) { uint8_t  x = strtoul(q + 1, &q, 0); kputc_(x, &str); }\n            else if (type == 's') while (q + 1 < p) { i16_to_le(strtol(q + 1, &q, 0), (uint8_t *) str.s + str.l); str.l += 2; _skip_to_comma(q, p); }\n            else if (type == 'S') while (q + 1 < p) { u16_to_le(strtoul(q + 1, &q, 0), (uint8_t *) str.s + str.l); str.l += 2; _skip_to_comma(q, p); }\n            else if (type == 'i') while (q + 1 < p) { i32_to_le(strtol(q + 1, &q, 0), (uint8_t *) str.s + str.l); str.l += 4; _skip_to_comma(q, p); }\n            else if (type == 'I') while (q + 1 < p) { u32_to_le(strtoul(q + 1, &q, 0), (uint8_t *) str.s + str.l); str.l += 4; _skip_to_comma(q, p); }\n            else if (type == 'f') while (q + 1 < p) { float_to_le(strtod(q + 1, &q), (uint8_t *) str.s + str.l); str.l += 4; _skip_to_comma(q, p); }\n            else _parse_err_param(1, \"unrecognized type B:%c\", type);\n\n#undef _skip_to_comma\n\n        } else _parse_err_param(1, \"unrecognized type %c\", type);\n    }\n    b->data = (uint8_t*)str.s; b->l_data = str.l; b->m_data = str.m;\n    if (bam_tag2cigar(b, 1, 1) < 0)\n        return -2;\n    return 0;\n\n#undef _parse_warn\n#undef _parse_err\n#undef _parse_err_param\n#undef _get_mem\n#undef _read_token_aux\n#undef _read_token\nerr_ret:\n    b->data = (uint8_t*)str.s; b->l_data = str.l; b->m_data = str.m;\n    return -2;\n}",
        "func": "int sam_parse1(kstring_t *s, bam_hdr_t *h, bam1_t *b)\n{\n#define _read_token(_p) (_p); for (; *(_p) && *(_p) != '\\t'; ++(_p)); if (*(_p) != '\\t') goto err_ret; *(_p)++ = 0\n#define _read_token_aux(_p) (_p); for (; *(_p) && *(_p) != '\\t'; ++(_p)); *(_p)++ = 0 // this is different in that it does not test *(_p)=='\\t'\n#define _get_mem(type_t, _x, _s, _l) ks_resize((_s), (_s)->l + (_l)); *(_x) = (type_t*)((_s)->s + (_s)->l); (_s)->l += (_l)\n#define _parse_err(cond, msg) do { if (cond) { hts_log_error(msg); goto err_ret; } } while (0)\n#define _parse_err_param(cond, msg, param) do { if (cond) { hts_log_error(msg, param); goto err_ret; } } while (0)\n#define _parse_warn(cond, msg) do { if (cond) { hts_log_warning(msg); } } while (0)\n\n    uint8_t *t;\n    char *p = s->s, *q;\n    int i;\n    kstring_t str;\n    bam1_core_t *c = &b->core;\n\n    str.l = b->l_data = 0;\n    str.s = (char*)b->data; str.m = b->m_data;\n    memset(c, 0, 32);\n    if (h->cigar_tab == 0) {\n        h->cigar_tab = (int8_t*) malloc(128);\n        for (i = 0; i < 128; ++i)\n            h->cigar_tab[i] = -1;\n        for (i = 0; BAM_CIGAR_STR[i]; ++i)\n            h->cigar_tab[(int)BAM_CIGAR_STR[i]] = i;\n    }\n    // qname\n    q = _read_token(p);\n    _parse_warn(p - q <= 1, \"empty query name\");\n    _parse_err(p - q > 252, \"query name too long\");\n    kputsn_(q, p - q, &str);\n    for (c->l_extranul = 0; str.l % 4 != 0; c->l_extranul++)\n        kputc_('\\0', &str);\n    c->l_qname = p - q + c->l_extranul;\n    // flag\n    c->flag = strtol(p, &p, 0);\n    if (*p++ != '\\t') goto err_ret; // malformated flag\n    // chr\n    q = _read_token(p);\n    if (strcmp(q, \"*\")) {\n        _parse_err(h->n_targets == 0, \"missing SAM header\");\n        c->tid = bam_name2id(h, q);\n        _parse_warn(c->tid < 0, \"urecognized reference name; treated as unmapped\");\n    } else c->tid = -1;\n    // pos\n    c->pos = strtol(p, &p, 10) - 1;\n    if (*p++ != '\\t') goto err_ret;\n    if (c->pos < 0 && c->tid >= 0) {\n        _parse_warn(1, \"mapped query cannot have zero coordinate; treated as unmapped\");\n        c->tid = -1;\n    }\n    if (c->tid < 0) c->flag |= BAM_FUNMAP;\n    // mapq\n    c->qual = strtol(p, &p, 10);\n    if (*p++ != '\\t') goto err_ret;\n    // cigar\n    if (*p != '*') {\n        uint32_t *cigar;\n        size_t n_cigar = 0;\n        for (q = p; *p && *p != '\\t'; ++p)\n            if (!isdigit_c(*p)) ++n_cigar;\n        if (*p++ != '\\t') goto err_ret;\n        _parse_err(n_cigar == 0, \"no CIGAR operations\");\n        _parse_err(n_cigar >= 2147483647, \"too many CIGAR operations\");\n        c->n_cigar = n_cigar;\n        _get_mem(uint32_t, &cigar, &str, c->n_cigar * sizeof(uint32_t));\n        for (i = 0; i < c->n_cigar; ++i, ++q) {\n            int op;\n            cigar[i] = strtol(q, &q, 10)<<BAM_CIGAR_SHIFT;\n            op = (uint8_t)*q >= 128? -1 : h->cigar_tab[(int)*q];\n            _parse_err(op < 0, \"unrecognized CIGAR operator\");\n            cigar[i] |= op;\n        }\n        // can't use bam_endpos() directly as some fields not yet set up\n        i = (!(c->flag&BAM_FUNMAP))? bam_cigar2rlen(c->n_cigar, cigar) : 1;\n    } else {\n        _parse_warn(!(c->flag&BAM_FUNMAP), \"mapped query must have a CIGAR; treated as unmapped\");\n        c->flag |= BAM_FUNMAP;\n        q = _read_token(p);\n        i = 1;\n    }\n    c->bin = hts_reg2bin(c->pos, c->pos + i, 14, 5);\n    // mate chr\n    q = _read_token(p);\n    if (strcmp(q, \"=\") == 0) {\n        c->mtid = c->tid;\n    } else if (strcmp(q, \"*\") == 0) {\n        c->mtid = -1;\n    } else {\n        c->mtid = bam_name2id(h, q);\n        _parse_warn(c->mtid < 0, \"urecognized mate reference name; treated as unmapped\");\n    }\n    // mpos\n    c->mpos = strtol(p, &p, 10) - 1;\n    if (*p++ != '\\t') goto err_ret;\n    if (c->mpos < 0 && c->mtid >= 0) {\n        _parse_warn(1, \"mapped mate cannot have zero coordinate; treated as unmapped\");\n        c->mtid = -1;\n    }\n    // tlen\n    c->isize = strtol(p, &p, 10);\n    if (*p++ != '\\t') goto err_ret;\n    // seq\n    q = _read_token(p);\n    if (strcmp(q, \"*\")) {\n        c->l_qseq = p - q - 1;\n        i = bam_cigar2qlen(c->n_cigar, (uint32_t*)(str.s + c->l_qname));\n        _parse_err(c->n_cigar && i != c->l_qseq, \"CIGAR and query sequence are of different length\");\n        i = (c->l_qseq + 1) >> 1;\n        _get_mem(uint8_t, &t, &str, i);\n        memset(t, 0, i);\n        for (i = 0; i < c->l_qseq; ++i)\n            t[i>>1] |= seq_nt16_table[(unsigned char)q[i]] << ((~i&1)<<2);\n    } else c->l_qseq = 0;\n    // qual\n    q = _read_token_aux(p);\n    _get_mem(uint8_t, &t, &str, c->l_qseq);\n    if (strcmp(q, \"*\")) {\n        _parse_err(p - q - 1 != c->l_qseq, \"SEQ and QUAL are of different length\");\n        for (i = 0; i < c->l_qseq; ++i) t[i] = q[i] - 33;\n    } else memset(t, 0xff, c->l_qseq);\n    // aux\n    while (p < s->s + s->l) {\n        uint8_t type;\n        q = _read_token_aux(p); // FIXME: can be accelerated for long 'B' arrays\n        _parse_err(p - q - 1 < 5, \"incomplete aux field\");\n        kputsn_(q, 2, &str);\n        q += 3; type = *q++; ++q; // q points to value\n        if (type != 'Z' && type != 'H') // the only zero length acceptable fields\n            _parse_err(p - q - 1 < 1, \"incomplete aux field\");\n\n        // Ensure str has enough space for a double + type allocated.\n        // This is so we can stuff bigger integers and floats directly into\n        // the kstring.  Sorry.\n        _parse_err(ks_resize(&str, str.l + 16), \"out of memory\");\n\n        if (type == 'A' || type == 'a' || type == 'c' || type == 'C') {\n            kputc_('A', &str);\n            kputc_(*q, &str);\n        } else if (type == 'i' || type == 'I') {\n            if (*q == '-') {\n                long x = strtol(q, &q, 10);\n                if (x >= INT8_MIN) {\n                    kputc_('c', &str); kputc_(x, &str);\n                } else if (x >= INT16_MIN) {\n                    str.s[str.l++] = 's';\n                    i16_to_le(x, (uint8_t *) str.s + str.l);\n                    str.l += 2;\n                } else {\n                    str.s[str.l++] = 'i';\n                    i32_to_le(x, (uint8_t *) str.s + str.l);\n                    str.l += 4;\n                }\n            } else {\n                unsigned long x = strtoul(q, &q, 10);\n                if (x <= UINT8_MAX) {\n                    kputc_('C', &str); kputc_(x, &str);\n                } else if (x <= UINT16_MAX) {\n                    str.s[str.l++] = 'S';\n                    u16_to_le(x, (uint8_t *) str.s + str.l);\n                    str.l += 2;\n                } else {\n                    str.s[str.l++] = 'I';\n                    u32_to_le(x, (uint8_t *) str.s + str.l);\n                    str.l += 4;\n                }\n            }\n        } else if (type == 'f') {\n            str.s[str.l++] = 'f';\n            float_to_le(strtod(q, &q), (uint8_t *) str.s + str.l);\n            str.l += sizeof(float);\n        } else if (type == 'd') {\n            str.s[str.l++] = 'd';\n            double_to_le(strtod(q, &q), (uint8_t *) str.s + str.l);\n            str.l += sizeof(double);\n        } else if (type == 'Z' || type == 'H') {\n            _parse_err(type == 'H' && !((p-q)&1),\n                       \"hex field does not have an even number of digits\");\n            kputc_(type, &str);kputsn_(q, p - q, &str); // note that this include the trailing NULL\n        } else if (type == 'B') {\n            int32_t n, size;\n            size_t bytes;\n            char *r;\n            _parse_err(p - q - 1 < 3, \"incomplete B-typed aux field\");\n            type = *q++; // q points to the first ',' following the typing byte\n\n            size = aux_type2size(type);\n            _parse_err_param(size <= 0 || size > 4,\n                             \"unrecognized type B:%c\", type);\n            _parse_err(*q && *q != ',', \"B aux field type not followed by ','\");\n\n            for (r = q, n = 0; *r; ++r)\n                if (*r == ',') ++n;\n\n            // Ensure space for type + values\n            bytes = (size_t) n * (size_t) size;\n            _parse_err(bytes / size != n\n                       || ks_resize(&str, str.l + bytes + 2 + sizeof(uint32_t)),\n                       \"out of memory\");\n            str.s[str.l++] = 'B';\n            str.s[str.l++] = type;\n            i32_to_le(n, (uint8_t *) str.s + str.l);\n            str.l += sizeof(uint32_t);\n\n            // This ensures that q always ends up at the next comma after\n            // reading a number even if it's followed by junk.  It\n            // prevents the possibility of trying to read more than n items.\n#define _skip_to_comma(q, p) do { while ((q) < (p) && *(q) != ',') (q)++; } while (0)\n\n            if (type == 'c')      while (q + 1 < p) { int8_t   x = strtol(q + 1, &q, 0); kputc_(x, &str); }\n            else if (type == 'C') while (q + 1 < p) { uint8_t  x = strtoul(q + 1, &q, 0); kputc_(x, &str); }\n            else if (type == 's') while (q + 1 < p) { i16_to_le(strtol(q + 1, &q, 0), (uint8_t *) str.s + str.l); str.l += 2; _skip_to_comma(q, p); }\n            else if (type == 'S') while (q + 1 < p) { u16_to_le(strtoul(q + 1, &q, 0), (uint8_t *) str.s + str.l); str.l += 2; _skip_to_comma(q, p); }\n            else if (type == 'i') while (q + 1 < p) { i32_to_le(strtol(q + 1, &q, 0), (uint8_t *) str.s + str.l); str.l += 4; _skip_to_comma(q, p); }\n            else if (type == 'I') while (q + 1 < p) { u32_to_le(strtoul(q + 1, &q, 0), (uint8_t *) str.s + str.l); str.l += 4; _skip_to_comma(q, p); }\n            else if (type == 'f') while (q + 1 < p) { float_to_le(strtod(q + 1, &q), (uint8_t *) str.s + str.l); str.l += 4; _skip_to_comma(q, p); }\n            else _parse_err_param(1, \"unrecognized type B:%c\", type);\n\n#undef _skip_to_comma\n\n        } else _parse_err_param(1, \"unrecognized type %c\", type);\n    }\n    b->data = (uint8_t*)str.s; b->l_data = str.l; b->m_data = str.m;\n    if (bam_tag2cigar(b, 1, 1) < 0)\n        return -2;\n    return 0;\n\n#undef _parse_warn\n#undef _parse_err\n#undef _parse_err_param\n#undef _get_mem\n#undef _read_token_aux\n#undef _read_token\nerr_ret:\n    b->data = (uint8_t*)str.s; b->l_data = str.l; b->m_data = str.m;\n    return -2;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -109,7 +109,7 @@\n         _get_mem(uint8_t, &t, &str, i);\n         memset(t, 0, i);\n         for (i = 0; i < c->l_qseq; ++i)\n-            t[i>>1] |= seq_nt16_table[(int)q[i]] << ((~i&1)<<2);\n+            t[i>>1] |= seq_nt16_table[(unsigned char)q[i]] << ((~i&1)<<2);\n     } else c->l_qseq = 0;\n     // qual\n     q = _read_token_aux(p);",
        "diff_line_info": {
            "deleted_lines": [
                "            t[i>>1] |= seq_nt16_table[(int)q[i]] << ((~i&1)<<2);"
            ],
            "added_lines": [
                "            t[i>>1] |= seq_nt16_table[(unsigned char)q[i]] << ((~i&1)<<2);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14072",
        "func_name": "saitoha/libsixel/sixel_decoder_decode",
        "description": "libsixel 1.8.1 has a memory leak in sixel_decoder_decode in decoder.c, image_buffer_resize in fromsixel.c, and sixel_decode_raw in fromsixel.c.",
        "git_url": "https://github.com/saitoha/libsixel/commit/f94bc6fec696abd77be275226f28409602bd1f27",
        "commit_title": "Fix memory leak problems reported in #67",
        "commit_text": "https://github.com/saitoha/libsixel/issues/67",
        "func_before": "SIXELAPI SIXELSTATUS\nsixel_decoder_decode(\n    sixel_decoder_t /* in */ *decoder)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    unsigned char *raw_data;\n    int sx;\n    int sy;\n    int raw_len;\n    int max;\n    int n;\n    FILE *input_fp = NULL;\n    unsigned char *indexed_pixels;\n    unsigned char *palette;\n    int ncolors;\n    unsigned char *pixels = NULL;\n\n    sixel_decoder_ref(decoder);\n\n    if (strcmp(decoder->input, \"-\") == 0) {\n        /* for windows */\n#if defined(O_BINARY)\n# if HAVE__SETMODE\n        _setmode(fileno(stdin), O_BINARY);\n# elif HAVE_SETMODE\n        setmode(fileno(stdin), O_BINARY);\n# endif  /* HAVE_SETMODE */\n#endif  /* defined(O_BINARY) */\n        input_fp = stdin;\n    } else {\n        input_fp = fopen(decoder->input, \"rb\");\n        if (!input_fp) {\n            sixel_helper_set_additional_message(\n                \"sixel_decoder_decode: fopen() failed.\");\n            status = (SIXEL_LIBC_ERROR | (errno & 0xff));\n            goto end;\n        }\n    }\n\n    raw_len = 0;\n    max = 64 * 1024;\n\n    raw_data = (unsigned char *)sixel_allocator_malloc(decoder->allocator, (size_t)max);\n    if (raw_data == NULL) {\n        sixel_helper_set_additional_message(\n            \"sixel_decoder_decode: sixel_allocator_malloc() failed.\");\n        status = SIXEL_BAD_ALLOCATION;\n        goto end;\n    }\n\n    for (;;) {\n        if ((max - raw_len) < 4096) {\n            max *= 2;\n            raw_data = (unsigned char *)sixel_allocator_realloc(decoder->allocator, raw_data, (size_t)max);\n            if (raw_data == NULL) {\n                sixel_helper_set_additional_message(\n                    \"sixel_decoder_decode: sixel_allocator_realloc() failed.\");\n                status = SIXEL_BAD_ALLOCATION;\n                goto end;\n            }\n        }\n        if ((n = (int)fread(raw_data + raw_len, 1, 4096, input_fp)) <= 0) {\n            break;\n        }\n        raw_len += n;\n    }\n\n    if (input_fp != stdout) {\n        fclose(input_fp);\n    }\n\n    status = sixel_decode_raw(\n        raw_data,\n        raw_len,\n        &indexed_pixels,\n        &sx,\n        &sy,\n        &palette,\n        &ncolors,\n        decoder->allocator);\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n\n    status = sixel_helper_write_image_file(indexed_pixels, sx, sy, palette,\n                                           SIXEL_PIXELFORMAT_PAL8,\n                                           decoder->output,\n                                           SIXEL_FORMAT_PNG,\n                                           decoder->allocator);\n\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n\nend:\n    sixel_allocator_free(decoder->allocator, pixels);\n    sixel_decoder_unref(decoder);\n\n    return status;\n}",
        "func": "SIXELAPI SIXELSTATUS\nsixel_decoder_decode(\n    sixel_decoder_t /* in */ *decoder)\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    unsigned char *raw_data = NULL;\n    int sx;\n    int sy;\n    int raw_len;\n    int max;\n    int n;\n    FILE *input_fp = NULL;\n    unsigned char *indexed_pixels = NULL;\n    unsigned char *palette = NULL;\n    int ncolors;\n\n    sixel_decoder_ref(decoder);\n\n    if (strcmp(decoder->input, \"-\") == 0) {\n        /* for windows */\n#if defined(O_BINARY)\n# if HAVE__SETMODE\n        _setmode(fileno(stdin), O_BINARY);\n# elif HAVE_SETMODE\n        setmode(fileno(stdin), O_BINARY);\n# endif  /* HAVE_SETMODE */\n#endif  /* defined(O_BINARY) */\n        input_fp = stdin;\n    } else {\n        input_fp = fopen(decoder->input, \"rb\");\n        if (!input_fp) {\n            sixel_helper_set_additional_message(\n                \"sixel_decoder_decode: fopen() failed.\");\n            status = (SIXEL_LIBC_ERROR | (errno & 0xff));\n            goto end;\n        }\n    }\n\n    raw_len = 0;\n    max = 64 * 1024;\n\n    raw_data = (unsigned char *)sixel_allocator_malloc(decoder->allocator, (size_t)max);\n    if (raw_data == NULL) {\n        sixel_helper_set_additional_message(\n            \"sixel_decoder_decode: sixel_allocator_malloc() failed.\");\n        status = SIXEL_BAD_ALLOCATION;\n        goto end;\n    }\n\n    for (;;) {\n        if ((max - raw_len) < 4096) {\n            max *= 2;\n            raw_data = (unsigned char *)sixel_allocator_realloc(decoder->allocator, raw_data, (size_t)max);\n            if (raw_data == NULL) {\n                sixel_helper_set_additional_message(\n                    \"sixel_decoder_decode: sixel_allocator_realloc() failed.\");\n                status = SIXEL_BAD_ALLOCATION;\n                goto end;\n            }\n        }\n        if ((n = (int)fread(raw_data + raw_len, 1, 4096, input_fp)) <= 0) {\n            break;\n        }\n        raw_len += n;\n    }\n\n    if (input_fp != stdout) {\n        fclose(input_fp);\n    }\n\n    status = sixel_decode_raw(\n        raw_data,\n        raw_len,\n        &indexed_pixels,\n        &sx,\n        &sy,\n        &palette,\n        &ncolors,\n        decoder->allocator);\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n\n    status = sixel_helper_write_image_file(indexed_pixels, sx, sy, palette,\n                                           SIXEL_PIXELFORMAT_PAL8,\n                                           decoder->output,\n                                           SIXEL_FORMAT_PNG,\n                                           decoder->allocator);\n\n    if (SIXEL_FAILED(status)) {\n        goto end;\n    }\n\nend:\n    sixel_allocator_free(decoder->allocator, raw_data);\n    sixel_allocator_free(decoder->allocator, indexed_pixels);\n    sixel_allocator_free(decoder->allocator, palette);\n    sixel_decoder_unref(decoder);\n\n    return status;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,17 +3,16 @@\n     sixel_decoder_t /* in */ *decoder)\n {\n     SIXELSTATUS status = SIXEL_FALSE;\n-    unsigned char *raw_data;\n+    unsigned char *raw_data = NULL;\n     int sx;\n     int sy;\n     int raw_len;\n     int max;\n     int n;\n     FILE *input_fp = NULL;\n-    unsigned char *indexed_pixels;\n-    unsigned char *palette;\n+    unsigned char *indexed_pixels = NULL;\n+    unsigned char *palette = NULL;\n     int ncolors;\n-    unsigned char *pixels = NULL;\n \n     sixel_decoder_ref(decoder);\n \n@@ -93,7 +92,9 @@\n     }\n \n end:\n-    sixel_allocator_free(decoder->allocator, pixels);\n+    sixel_allocator_free(decoder->allocator, raw_data);\n+    sixel_allocator_free(decoder->allocator, indexed_pixels);\n+    sixel_allocator_free(decoder->allocator, palette);\n     sixel_decoder_unref(decoder);\n \n     return status;",
        "diff_line_info": {
            "deleted_lines": [
                "    unsigned char *raw_data;",
                "    unsigned char *indexed_pixels;",
                "    unsigned char *palette;",
                "    unsigned char *pixels = NULL;",
                "    sixel_allocator_free(decoder->allocator, pixels);"
            ],
            "added_lines": [
                "    unsigned char *raw_data = NULL;",
                "    unsigned char *indexed_pixels = NULL;",
                "    unsigned char *palette = NULL;",
                "    sixel_allocator_free(decoder->allocator, raw_data);",
                "    sixel_allocator_free(decoder->allocator, indexed_pixels);",
                "    sixel_allocator_free(decoder->allocator, palette);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14434",
        "func_name": "ImageMagick/WriteMPCImage",
        "description": "ImageMagick 7.0.8-4 has a memory leak for a colormap in WriteMPCImage in coders/mpc.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/98a2cceae0dceccbfe54051167c2c80be1f13c3f",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1192",
        "commit_text": "",
        "func_before": "static MagickBooleanType WriteMPCImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent],\n    cache_filename[MagickPathExtent];\n\n  const char\n    *property,\n    *value;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    scene;\n\n  register ssize_t\n    i;\n\n  size_t\n    depth,\n    imageListLength;\n\n  /*\n    Open persistent cache.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) CopyMagickString(cache_filename,image->filename,MagickPathExtent-6);\n  AppendImageFormat(\"cache\",cache_filename);\n  scene=0;\n  offset=0;\n  imageListLength=GetImageListLength(image);\n  do\n  {\n    /*\n      Write persistent cache meta-information.\n    */\n    depth=GetImageQuantumDepth(image,MagickTrue);\n    if ((image->storage_class == PseudoClass) &&\n        (image->colors > (size_t) (GetQuantumRange(image->depth)+1)))\n      (void) SetImageStorageClass(image,DirectClass,exception);\n    (void) WriteBlobString(image,\"id=MagickCache\\n\");\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"magick-signature=%u\\n\",\n      GetMagickSignature((const StringInfo *) NULL));\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"class=%s  colors=%.20g  alpha-trait=%s\\n\",CommandOptionToMnemonic(\n      MagickClassOptions,image->storage_class),(double) image->colors,\n      CommandOptionToMnemonic(MagickPixelTraitOptions,(ssize_t)\n      image->alpha_trait));\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"number-channels=%.20g  number-meta-channels=%.20g\\n\",\n      (double) image->number_channels,(double) image->number_meta_channels);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"columns=%.20g  rows=%.20g depth=%.20g\\n\",(double) image->columns,\n      (double) image->rows,(double) image->depth);\n    (void) WriteBlobString(image,buffer);\n    if (image->type != UndefinedType)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"type=%s\\n\",\n          CommandOptionToMnemonic(MagickTypeOptions,image->type));\n        (void) WriteBlobString(image,buffer);\n      }\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"colorspace=%s\\n\",\n      CommandOptionToMnemonic(MagickColorspaceOptions,image->colorspace));\n    (void) WriteBlobString(image,buffer);\n    if (image->intensity != UndefinedPixelIntensityMethod)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"pixel-intensity=%s\\n\",CommandOptionToMnemonic(\n          MagickPixelIntensityOptions,image->intensity));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->endian != UndefinedEndian)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"endian=%s\\n\",\n          CommandOptionToMnemonic(MagickEndianOptions,image->endian));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->compression != UndefinedCompression)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"compression=%s  quality=%.20g\\n\",CommandOptionToMnemonic(\n          MagickCompressOptions,image->compression),(double) image->quality);\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->units != UndefinedResolution)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"units=%s\\n\",\n          CommandOptionToMnemonic(MagickResolutionOptions,image->units));\n        (void) WriteBlobString(image,buffer);\n      }\n    if ((image->resolution.x != 0) || (image->resolution.y != 0))\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"resolution=%gx%g\\n\",image->resolution.x,image->resolution.y);\n        (void) WriteBlobString(image,buffer);\n      }\n    if ((image->page.width != 0) || (image->page.height != 0))\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"page=%.20gx%.20g%+.20g%+.20g\\n\",(double) image->page.width,(double)\n          image->page.height,(double) image->page.x,(double) image->page.y);\n        (void) WriteBlobString(image,buffer);\n      }\n    else\n      if ((image->page.x != 0) || (image->page.y != 0))\n        {\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"page=%+ld%+ld\\n\",\n            (long) image->page.x,(long) image->page.y);\n          (void) WriteBlobString(image,buffer);\n        }\n    if ((image->tile_offset.x != 0) || (image->tile_offset.y != 0))\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"tile-offset=%+ld%+ld\\n\",(long) image->tile_offset.x,(long)\n           image->tile_offset.y);\n        (void) WriteBlobString(image,buffer);\n      }\n    if ((GetNextImageInList(image) != (Image *) NULL) ||\n        (GetPreviousImageInList(image) != (Image *) NULL))\n      {\n        if (image->scene == 0)\n          (void) FormatLocaleString(buffer,MagickPathExtent,\n            \"iterations=%.20g  delay=%.20g  ticks-per-second=%.20g\\n\",(double)\n            image->iterations,(double) image->delay,(double)\n            image->ticks_per_second);\n        else\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"scene=%.20g  \"\n            \"iterations=%.20g  delay=%.20g  ticks-per-second=%.20g\\n\",\n            (double) image->scene,(double) image->iterations,(double)\n            image->delay,(double) image->ticks_per_second);\n        (void) WriteBlobString(image,buffer);\n      }\n    else\n      {\n        if (image->scene != 0)\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,\"scene=%.20g\\n\",\n              (double) image->scene);\n            (void) WriteBlobString(image,buffer);\n          }\n        if (image->iterations != 0)\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,\n              \"iterations=%.20g\\n\",(double) image->iterations);\n            (void) WriteBlobString(image,buffer);\n          }\n        if (image->delay != 0)\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,\"delay=%.20g\\n\",\n              (double) image->delay);\n            (void) WriteBlobString(image,buffer);\n          }\n        if (image->ticks_per_second != UndefinedTicksPerSecond)\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,\n              \"ticks-per-second=%.20g\\n\",(double) image->ticks_per_second);\n            (void) WriteBlobString(image,buffer);\n          }\n      }\n    if (image->gravity != UndefinedGravity)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"gravity=%s\\n\",\n          CommandOptionToMnemonic(MagickGravityOptions,image->gravity));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->dispose != UndefinedDispose)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"dispose=%s\\n\",\n          CommandOptionToMnemonic(MagickDisposeOptions,image->dispose));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->rendering_intent != UndefinedIntent)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"rendering-intent=%s\\n\",CommandOptionToMnemonic(MagickIntentOptions,\n          image->rendering_intent));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->gamma != 0.0)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"gamma=%g\\n\",\n          image->gamma);\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->chromaticity.white_point.x != 0.0)\n      {\n        /*\n          Note chomaticity points.\n        */\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"red-primary=\"\n          \"%g,%g  green-primary=%g,%g  blue-primary=%g,%g\\n\",\n          image->chromaticity.red_primary.x,image->chromaticity.red_primary.y,\n          image->chromaticity.green_primary.x,\n          image->chromaticity.green_primary.y,\n          image->chromaticity.blue_primary.x,\n          image->chromaticity.blue_primary.y);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"white-point=%g,%g\\n\",image->chromaticity.white_point.x,\n          image->chromaticity.white_point.y);\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->orientation != UndefinedOrientation)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"orientation=%s\\n\",CommandOptionToMnemonic(MagickOrientationOptions,\n          image->orientation));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->profiles != (void *) NULL)\n      {\n        const char\n          *name;\n\n        const StringInfo\n          *profile;\n\n        /*\n          Write image profile names.\n        */\n        ResetImageProfileIterator(image);\n        for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n        {\n          profile=GetImageProfile(image,name);\n          if (profile != (StringInfo *) NULL)\n            {\n              (void) FormatLocaleString(buffer,MagickPathExtent,\"profile=%s\\n\",\n                name);\n              (void) WriteBlobString(image,buffer);\n            }\n          name=GetNextImageProfile(image);\n        }\n      }\n    if (image->montage != (char *) NULL)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"montage=%s\\n\",\n          image->montage);\n        (void) WriteBlobString(image,buffer);\n      }\n    ResetImagePropertyIterator(image);\n    property=GetNextImageProperty(image);\n    while (property != (const char *) NULL)\n    {\n      (void) FormatLocaleString(buffer,MagickPathExtent,\"%s=\",property);\n      (void) WriteBlobString(image,buffer);\n      value=GetImageProperty(image,property,exception);\n      if (value != (const char *) NULL)\n        {\n          size_t\n            length;\n\n          length=strlen(value);\n          for (i=0; i < (ssize_t) length; i++)\n            if (isspace((int) ((unsigned char) value[i])) != 0)\n              break;\n          if ((i == (ssize_t) length) && (i != 0))\n            (void) WriteBlob(image,length,(const unsigned char *) value);\n          else\n            {\n              (void) WriteBlobByte(image,'{');\n              if (strchr(value,'}') == (char *) NULL)\n                (void) WriteBlob(image,length,(const unsigned char *) value);\n              else\n                for (i=0; i < (ssize_t) length; i++)\n                {\n                  if (value[i] == (int) '}')\n                    (void) WriteBlobByte(image,'\\\\');\n                  (void) WriteBlobByte(image,(unsigned char) value[i]);\n                }\n              (void) WriteBlobByte(image,'}');\n            }\n        }\n      (void) WriteBlobByte(image,'\\n');\n      property=GetNextImageProperty(image);\n    }\n    (void) WriteBlobString(image,\"\\f\\n:\\032\");\n    if (image->montage != (char *) NULL)\n      {\n        /*\n          Write montage tile directory.\n        */\n        if (image->directory != (char *) NULL)\n          (void) WriteBlobString(image,image->directory);\n        (void) WriteBlobByte(image,'\\0');\n      }\n    if (image->profiles != 0)\n      {\n        const char\n          *name;\n\n        const StringInfo\n          *profile;\n\n        /*\n          Write image profile blobs.\n        */\n        ResetImageProfileIterator(image);\n        name=GetNextImageProfile(image);\n        while (name != (const char *) NULL)\n        {\n          profile=GetImageProfile(image,name);\n          (void) WriteBlobMSBLong(image,(unsigned int)\n            GetStringInfoLength(profile));\n          (void) WriteBlob(image,GetStringInfoLength(profile),\n            GetStringInfoDatum(profile));\n          name=GetNextImageProfile(image);\n        }\n      }\n    if (image->storage_class == PseudoClass)\n      {\n        size_t\n          packet_size;\n\n        unsigned char\n          *colormap,\n          *q;\n\n        /*\n          Allocate colormap.\n        */\n        packet_size=(size_t) (3UL*depth/8UL);\n        colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          packet_size*sizeof(*colormap));\n        if (colormap == (unsigned char *) NULL)\n          return(MagickFalse);\n        /*\n          Write colormap to file.\n        */\n        q=colormap;\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          switch (depth)\n          {\n            default:\n              ThrowWriterException(CorruptImageError,\"ImageDepthNotSupported\");\n            case 32:\n            {\n              unsigned int\n                pixel;\n\n              pixel=ScaleQuantumToLong(ClampToQuantum(image->colormap[i].red));\n              q=PopLongPixel(MSBEndian,pixel,q);\n              pixel=ScaleQuantumToLong(ClampToQuantum(\n                image->colormap[i].green));\n              q=PopLongPixel(MSBEndian,pixel,q);\n              pixel=ScaleQuantumToLong(ClampToQuantum(image->colormap[i].blue));\n              q=PopLongPixel(MSBEndian,pixel,q);\n              break;\n            }\n            case 16:\n            {\n              unsigned short\n                pixel;\n\n              pixel=ScaleQuantumToShort(ClampToQuantum(image->colormap[i].red));\n              q=PopShortPixel(MSBEndian,pixel,q);\n              pixel=ScaleQuantumToShort(ClampToQuantum(\n                image->colormap[i].green));\n              q=PopShortPixel(MSBEndian,pixel,q);\n              pixel=ScaleQuantumToShort(ClampToQuantum(\n                image->colormap[i].blue));\n              q=PopShortPixel(MSBEndian,pixel,q);\n              break;\n            }\n            case 8:\n            {\n              unsigned char\n                pixel;\n\n              pixel=(unsigned char) ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[i].red));\n              q=PopCharPixel(pixel,q);\n              pixel=(unsigned char) ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[i].green));\n              q=PopCharPixel(pixel,q);\n              pixel=(unsigned char) ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[i].blue));\n              q=PopCharPixel(pixel,q);\n              break;\n            }\n          }\n        }\n        (void) WriteBlob(image,packet_size*image->colors,colormap);\n        colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n      }\n    /*\n      Initialize persistent pixel cache.\n    */\n    status=PersistPixelCache(image,cache_filename,MagickFalse,&offset,\n      exception);\n    if (status == MagickFalse)\n      ThrowWriterException(CacheError,\"UnableToPersistPixelCache\");\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        status=image->progress_monitor(SaveImagesTag,scene,\n          imageListLength,image->client_data);\n        if (status == MagickFalse)\n          break;\n      }\n    scene++;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(status);\n}",
        "func": "static MagickBooleanType WriteMPCImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  char\n    buffer[MagickPathExtent],\n    cache_filename[MagickPathExtent];\n\n  const char\n    *property,\n    *value;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    scene;\n\n  register ssize_t\n    i;\n\n  size_t\n    depth,\n    imageListLength;\n\n  /*\n    Open persistent cache.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) CopyMagickString(cache_filename,image->filename,MagickPathExtent-6);\n  AppendImageFormat(\"cache\",cache_filename);\n  scene=0;\n  offset=0;\n  imageListLength=GetImageListLength(image);\n  do\n  {\n    /*\n      Write persistent cache meta-information.\n    */\n    depth=GetImageQuantumDepth(image,MagickTrue);\n    if ((image->storage_class == PseudoClass) &&\n        (image->colors > (size_t) (GetQuantumRange(image->depth)+1)))\n      (void) SetImageStorageClass(image,DirectClass,exception);\n    (void) WriteBlobString(image,\"id=MagickCache\\n\");\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"magick-signature=%u\\n\",\n      GetMagickSignature((const StringInfo *) NULL));\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"class=%s  colors=%.20g  alpha-trait=%s\\n\",CommandOptionToMnemonic(\n      MagickClassOptions,image->storage_class),(double) image->colors,\n      CommandOptionToMnemonic(MagickPixelTraitOptions,(ssize_t)\n      image->alpha_trait));\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"number-channels=%.20g  number-meta-channels=%.20g\\n\",\n      (double) image->number_channels,(double) image->number_meta_channels);\n    (void) WriteBlobString(image,buffer);\n    (void) FormatLocaleString(buffer,MagickPathExtent,\n      \"columns=%.20g  rows=%.20g depth=%.20g\\n\",(double) image->columns,\n      (double) image->rows,(double) image->depth);\n    (void) WriteBlobString(image,buffer);\n    if (image->type != UndefinedType)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"type=%s\\n\",\n          CommandOptionToMnemonic(MagickTypeOptions,image->type));\n        (void) WriteBlobString(image,buffer);\n      }\n    (void) FormatLocaleString(buffer,MagickPathExtent,\"colorspace=%s\\n\",\n      CommandOptionToMnemonic(MagickColorspaceOptions,image->colorspace));\n    (void) WriteBlobString(image,buffer);\n    if (image->intensity != UndefinedPixelIntensityMethod)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"pixel-intensity=%s\\n\",CommandOptionToMnemonic(\n          MagickPixelIntensityOptions,image->intensity));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->endian != UndefinedEndian)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"endian=%s\\n\",\n          CommandOptionToMnemonic(MagickEndianOptions,image->endian));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->compression != UndefinedCompression)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"compression=%s  quality=%.20g\\n\",CommandOptionToMnemonic(\n          MagickCompressOptions,image->compression),(double) image->quality);\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->units != UndefinedResolution)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"units=%s\\n\",\n          CommandOptionToMnemonic(MagickResolutionOptions,image->units));\n        (void) WriteBlobString(image,buffer);\n      }\n    if ((image->resolution.x != 0) || (image->resolution.y != 0))\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"resolution=%gx%g\\n\",image->resolution.x,image->resolution.y);\n        (void) WriteBlobString(image,buffer);\n      }\n    if ((image->page.width != 0) || (image->page.height != 0))\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"page=%.20gx%.20g%+.20g%+.20g\\n\",(double) image->page.width,(double)\n          image->page.height,(double) image->page.x,(double) image->page.y);\n        (void) WriteBlobString(image,buffer);\n      }\n    else\n      if ((image->page.x != 0) || (image->page.y != 0))\n        {\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"page=%+ld%+ld\\n\",\n            (long) image->page.x,(long) image->page.y);\n          (void) WriteBlobString(image,buffer);\n        }\n    if ((image->tile_offset.x != 0) || (image->tile_offset.y != 0))\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"tile-offset=%+ld%+ld\\n\",(long) image->tile_offset.x,(long)\n           image->tile_offset.y);\n        (void) WriteBlobString(image,buffer);\n      }\n    if ((GetNextImageInList(image) != (Image *) NULL) ||\n        (GetPreviousImageInList(image) != (Image *) NULL))\n      {\n        if (image->scene == 0)\n          (void) FormatLocaleString(buffer,MagickPathExtent,\n            \"iterations=%.20g  delay=%.20g  ticks-per-second=%.20g\\n\",(double)\n            image->iterations,(double) image->delay,(double)\n            image->ticks_per_second);\n        else\n          (void) FormatLocaleString(buffer,MagickPathExtent,\"scene=%.20g  \"\n            \"iterations=%.20g  delay=%.20g  ticks-per-second=%.20g\\n\",\n            (double) image->scene,(double) image->iterations,(double)\n            image->delay,(double) image->ticks_per_second);\n        (void) WriteBlobString(image,buffer);\n      }\n    else\n      {\n        if (image->scene != 0)\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,\"scene=%.20g\\n\",\n              (double) image->scene);\n            (void) WriteBlobString(image,buffer);\n          }\n        if (image->iterations != 0)\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,\n              \"iterations=%.20g\\n\",(double) image->iterations);\n            (void) WriteBlobString(image,buffer);\n          }\n        if (image->delay != 0)\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,\"delay=%.20g\\n\",\n              (double) image->delay);\n            (void) WriteBlobString(image,buffer);\n          }\n        if (image->ticks_per_second != UndefinedTicksPerSecond)\n          {\n            (void) FormatLocaleString(buffer,MagickPathExtent,\n              \"ticks-per-second=%.20g\\n\",(double) image->ticks_per_second);\n            (void) WriteBlobString(image,buffer);\n          }\n      }\n    if (image->gravity != UndefinedGravity)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"gravity=%s\\n\",\n          CommandOptionToMnemonic(MagickGravityOptions,image->gravity));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->dispose != UndefinedDispose)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"dispose=%s\\n\",\n          CommandOptionToMnemonic(MagickDisposeOptions,image->dispose));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->rendering_intent != UndefinedIntent)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"rendering-intent=%s\\n\",CommandOptionToMnemonic(MagickIntentOptions,\n          image->rendering_intent));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->gamma != 0.0)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"gamma=%g\\n\",\n          image->gamma);\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->chromaticity.white_point.x != 0.0)\n      {\n        /*\n          Note chomaticity points.\n        */\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"red-primary=\"\n          \"%g,%g  green-primary=%g,%g  blue-primary=%g,%g\\n\",\n          image->chromaticity.red_primary.x,image->chromaticity.red_primary.y,\n          image->chromaticity.green_primary.x,\n          image->chromaticity.green_primary.y,\n          image->chromaticity.blue_primary.x,\n          image->chromaticity.blue_primary.y);\n        (void) WriteBlobString(image,buffer);\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"white-point=%g,%g\\n\",image->chromaticity.white_point.x,\n          image->chromaticity.white_point.y);\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->orientation != UndefinedOrientation)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\n          \"orientation=%s\\n\",CommandOptionToMnemonic(MagickOrientationOptions,\n          image->orientation));\n        (void) WriteBlobString(image,buffer);\n      }\n    if (image->profiles != (void *) NULL)\n      {\n        const char\n          *name;\n\n        const StringInfo\n          *profile;\n\n        /*\n          Write image profile names.\n        */\n        ResetImageProfileIterator(image);\n        for (name=GetNextImageProfile(image); name != (const char *) NULL; )\n        {\n          profile=GetImageProfile(image,name);\n          if (profile != (StringInfo *) NULL)\n            {\n              (void) FormatLocaleString(buffer,MagickPathExtent,\"profile=%s\\n\",\n                name);\n              (void) WriteBlobString(image,buffer);\n            }\n          name=GetNextImageProfile(image);\n        }\n      }\n    if (image->montage != (char *) NULL)\n      {\n        (void) FormatLocaleString(buffer,MagickPathExtent,\"montage=%s\\n\",\n          image->montage);\n        (void) WriteBlobString(image,buffer);\n      }\n    ResetImagePropertyIterator(image);\n    property=GetNextImageProperty(image);\n    while (property != (const char *) NULL)\n    {\n      (void) FormatLocaleString(buffer,MagickPathExtent,\"%s=\",property);\n      (void) WriteBlobString(image,buffer);\n      value=GetImageProperty(image,property,exception);\n      if (value != (const char *) NULL)\n        {\n          size_t\n            length;\n\n          length=strlen(value);\n          for (i=0; i < (ssize_t) length; i++)\n            if (isspace((int) ((unsigned char) value[i])) != 0)\n              break;\n          if ((i == (ssize_t) length) && (i != 0))\n            (void) WriteBlob(image,length,(const unsigned char *) value);\n          else\n            {\n              (void) WriteBlobByte(image,'{');\n              if (strchr(value,'}') == (char *) NULL)\n                (void) WriteBlob(image,length,(const unsigned char *) value);\n              else\n                for (i=0; i < (ssize_t) length; i++)\n                {\n                  if (value[i] == (int) '}')\n                    (void) WriteBlobByte(image,'\\\\');\n                  (void) WriteBlobByte(image,(unsigned char) value[i]);\n                }\n              (void) WriteBlobByte(image,'}');\n            }\n        }\n      (void) WriteBlobByte(image,'\\n');\n      property=GetNextImageProperty(image);\n    }\n    (void) WriteBlobString(image,\"\\f\\n:\\032\");\n    if (image->montage != (char *) NULL)\n      {\n        /*\n          Write montage tile directory.\n        */\n        if (image->directory != (char *) NULL)\n          (void) WriteBlobString(image,image->directory);\n        (void) WriteBlobByte(image,'\\0');\n      }\n    if (image->profiles != 0)\n      {\n        const char\n          *name;\n\n        const StringInfo\n          *profile;\n\n        /*\n          Write image profile blobs.\n        */\n        ResetImageProfileIterator(image);\n        name=GetNextImageProfile(image);\n        while (name != (const char *) NULL)\n        {\n          profile=GetImageProfile(image,name);\n          (void) WriteBlobMSBLong(image,(unsigned int)\n            GetStringInfoLength(profile));\n          (void) WriteBlob(image,GetStringInfoLength(profile),\n            GetStringInfoDatum(profile));\n          name=GetNextImageProfile(image);\n        }\n      }\n    if (image->storage_class == PseudoClass)\n      {\n        size_t\n          packet_size;\n\n        unsigned char\n          *colormap,\n          *q;\n\n        /*\n          Allocate colormap.\n        */\n        packet_size=(size_t) (3UL*depth/8UL);\n        colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          packet_size*sizeof(*colormap));\n        if (colormap == (unsigned char *) NULL)\n          return(MagickFalse);\n        /*\n          Write colormap to file.\n        */\n        q=colormap;\n        for (i=0; i < (ssize_t) image->colors; i++)\n        {\n          switch (depth)\n          {\n            default:\n            {\n              colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n              ThrowWriterException(CorruptImageError,\"ImageDepthNotSupported\");\n              break;\n            }\n            case 32:\n            {\n              unsigned int\n                pixel;\n\n              pixel=ScaleQuantumToLong(ClampToQuantum(image->colormap[i].red));\n              q=PopLongPixel(MSBEndian,pixel,q);\n              pixel=ScaleQuantumToLong(ClampToQuantum(\n                image->colormap[i].green));\n              q=PopLongPixel(MSBEndian,pixel,q);\n              pixel=ScaleQuantumToLong(ClampToQuantum(image->colormap[i].blue));\n              q=PopLongPixel(MSBEndian,pixel,q);\n              break;\n            }\n            case 16:\n            {\n              unsigned short\n                pixel;\n\n              pixel=ScaleQuantumToShort(ClampToQuantum(image->colormap[i].red));\n              q=PopShortPixel(MSBEndian,pixel,q);\n              pixel=ScaleQuantumToShort(ClampToQuantum(\n                image->colormap[i].green));\n              q=PopShortPixel(MSBEndian,pixel,q);\n              pixel=ScaleQuantumToShort(ClampToQuantum(\n                image->colormap[i].blue));\n              q=PopShortPixel(MSBEndian,pixel,q);\n              break;\n            }\n            case 8:\n            {\n              unsigned char\n                pixel;\n\n              pixel=(unsigned char) ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[i].red));\n              q=PopCharPixel(pixel,q);\n              pixel=(unsigned char) ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[i].green));\n              q=PopCharPixel(pixel,q);\n              pixel=(unsigned char) ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[i].blue));\n              q=PopCharPixel(pixel,q);\n              break;\n            }\n          }\n        }\n        (void) WriteBlob(image,packet_size*image->colors,colormap);\n        colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n      }\n    /*\n      Initialize persistent pixel cache.\n    */\n    status=PersistPixelCache(image,cache_filename,MagickFalse,&offset,\n      exception);\n    if (status == MagickFalse)\n      ThrowWriterException(CacheError,\"UnableToPersistPixelCache\");\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        status=image->progress_monitor(SaveImagesTag,scene,\n          imageListLength,image->client_data);\n        if (status == MagickFalse)\n          break;\n      }\n    scene++;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(status);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -348,7 +348,11 @@\n           switch (depth)\n           {\n             default:\n+            {\n+              colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n               ThrowWriterException(CorruptImageError,\"ImageDepthNotSupported\");\n+              break;\n+            }\n             case 32:\n             {\n               unsigned int",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            {",
                "              colormap=(unsigned char *) RelinquishMagickMemory(colormap);",
                "              break;",
                "            }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14435",
        "func_name": "ImageMagick/DecodeImage",
        "description": "ImageMagick 7.0.8-4 has a memory leak in DecodeImage in coders/pcd.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/957b6397b958a5881005df27eb97319b3175a3c9",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1193",
        "commit_text": "",
        "func_before": "static MagickBooleanType DecodeImage(Image *image,unsigned char *luma,\n  unsigned char *chroma1,unsigned char *chroma2,ExceptionInfo *exception)\n{\n#define IsSync(sum)  ((sum & 0xffffff00UL) == 0xfffffe00UL)\n#define PCDGetBits(n) \\\n{  \\\n  sum=(sum << n) & 0xffffffff; \\\n  bits-=n; \\\n  while (bits <= 24) \\\n  { \\\n    if (p >= (buffer+0x800)) \\\n      { \\\n        count=ReadBlob(image,0x800,buffer); \\\n        p=buffer; \\\n      } \\\n    sum|=((unsigned int) (*p) << (24-bits)); \\\n    bits+=8; \\\n    p++; \\\n  } \\\n}\n\n  typedef struct PCDTable\n  {\n    unsigned int\n      length,\n      sequence;\n\n    MagickStatusType\n      mask;\n\n    unsigned char\n      key;\n  } PCDTable;\n\n  PCDTable\n    *pcd_table[3];\n\n  register ssize_t\n    i,\n    j;\n\n  register PCDTable\n    *r;\n\n  register unsigned char\n    *p,\n    *q;\n\n  size_t\n    bits,\n    length,\n    plane,\n    pcd_length[3],\n    row,\n    sum;\n\n  ssize_t\n    count,\n    quantum;\n\n  unsigned char\n    *buffer;\n\n  /*\n    Initialize Huffman tables.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(luma != (unsigned char *) NULL);\n  assert(chroma1 != (unsigned char *) NULL);\n  assert(chroma2 != (unsigned char *) NULL);\n  buffer=(unsigned char *) AcquireQuantumMemory(0x800,sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  sum=0;\n  bits=32;\n  p=buffer+0x800;\n  for (i=0; i < 3; i++)\n  {\n    pcd_table[i]=(PCDTable *) NULL;\n    pcd_length[i]=0;\n  }\n  for (i=0; i < (image->columns > 1536 ? 3 : 1); i++)\n  {\n    PCDGetBits(8);\n    length=(sum & 0xff)+1;\n    pcd_table[i]=(PCDTable *) AcquireQuantumMemory(length,\n      sizeof(*pcd_table[i]));\n    if (pcd_table[i] == (PCDTable *) NULL)\n      {\n        buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n        ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n          image->filename);\n      }\n    r=pcd_table[i];\n    for (j=0; j < (ssize_t) length; j++)\n    {\n      PCDGetBits(8);\n      r->length=(unsigned int) (sum & 0xff)+1;\n      if (r->length > 16)\n        {\n          buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n          return(MagickFalse);\n        }\n      PCDGetBits(16);\n      r->sequence=(unsigned int) (sum & 0xffff) << 16;\n      PCDGetBits(8);\n      r->key=(unsigned char) (sum & 0xff);\n      r->mask=(~((1U << (32-r->length))-1));\n      r++;\n    }\n    pcd_length[i]=(size_t) length;\n  }\n  /*\n    Search for Sync byte.\n  */\n  for (i=0; i < 1; i++)\n    PCDGetBits(16);\n  for (i=0; i < 1; i++)\n    PCDGetBits(16);\n  while ((sum & 0x00fff000UL) != 0x00fff000UL)\n    PCDGetBits(8);\n  while (IsSync(sum) == 0)\n    PCDGetBits(1);\n  /*\n    Recover the Huffman encoded luminance and chrominance deltas.\n  */\n  count=0;\n  length=0;\n  plane=0;\n  row=0;\n  q=luma;\n  for ( ; ; )\n  {\n    if (IsSync(sum) != 0)\n      {\n        /*\n          Determine plane and row number.\n        */\n        PCDGetBits(16);\n        row=((sum >> 9) & 0x1fff);\n        if (row == image->rows)\n          break;\n        PCDGetBits(8);\n        plane=sum >> 30;\n        PCDGetBits(16);\n        switch (plane)\n        {\n          case 0:\n          {\n            q=luma+row*image->columns;\n            count=(ssize_t) image->columns;\n            break;\n          }\n          case 2:\n          {\n            q=chroma1+(row >> 1)*image->columns;\n            count=(ssize_t) (image->columns >> 1);\n            plane--;\n            break;\n          }\n          case 3:\n          {\n            q=chroma2+(row >> 1)*image->columns;\n            count=(ssize_t) (image->columns >> 1);\n            plane--;\n            break;\n          }\n          default:\n          {\n            ThrowBinaryException(CorruptImageError,\"CorruptImage\",\n              image->filename);\n          }\n        }\n        length=pcd_length[plane];\n        continue;\n      }\n    /*\n      Decode luminance or chrominance deltas.\n    */\n    r=pcd_table[plane];\n    for (i=0; ((i < (ssize_t) length) && ((sum & r->mask) != r->sequence)); i++)\n      r++;\n    if ((row > image->rows) || (r == (PCDTable *) NULL))\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"SkipToSyncByte\",\"`%s'\",image->filename);\n        while ((sum & 0x00fff000) != 0x00fff000)\n          PCDGetBits(8);\n        while (IsSync(sum) == 0)\n          PCDGetBits(1);\n        continue;\n      }\n    if (r->key < 128)\n      quantum=(ssize_t) (*q)+r->key;\n    else\n      quantum=(ssize_t) (*q)+r->key-256;\n    *q=(unsigned char) ((quantum < 0) ? 0 : (quantum > 255) ? 255 : quantum);\n    q++;\n    PCDGetBits(r->length);\n    count--;\n  }\n  /*\n    Relinquish resources.\n  */\n  for (i=0; i < (image->columns > 1536 ? 3 : 1); i++)\n    pcd_table[i]=(PCDTable *) RelinquishMagickMemory(pcd_table[i]);\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  return(MagickTrue);\n}",
        "func": "static MagickBooleanType DecodeImage(Image *image,unsigned char *luma,\n  unsigned char *chroma1,unsigned char *chroma2,ExceptionInfo *exception)\n{\n#define IsSync(sum)  ((sum & 0xffffff00UL) == 0xfffffe00UL)\n#define PCDGetBits(n) \\\n{  \\\n  sum=(sum << n) & 0xffffffff; \\\n  bits-=n; \\\n  while (bits <= 24) \\\n  { \\\n    if (p >= (buffer+0x800)) \\\n      { \\\n        count=ReadBlob(image,0x800,buffer); \\\n        p=buffer; \\\n      } \\\n    sum|=((unsigned int) (*p) << (24-bits)); \\\n    bits+=8; \\\n    p++; \\\n  } \\\n}\n\n  typedef struct PCDTable\n  {\n    unsigned int\n      length,\n      sequence;\n\n    MagickStatusType\n      mask;\n\n    unsigned char\n      key;\n  } PCDTable;\n\n  PCDTable\n    *pcd_table[3];\n\n  register ssize_t\n    i,\n    j;\n\n  register PCDTable\n    *r;\n\n  register unsigned char\n    *p,\n    *q;\n\n  size_t\n    bits,\n    length,\n    plane,\n    pcd_length[3],\n    row,\n    sum;\n\n  ssize_t\n    count,\n    quantum;\n\n  unsigned char\n    *buffer;\n\n  /*\n    Initialize Huffman tables.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(luma != (unsigned char *) NULL);\n  assert(chroma1 != (unsigned char *) NULL);\n  assert(chroma2 != (unsigned char *) NULL);\n  buffer=(unsigned char *) AcquireQuantumMemory(0x800,sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  sum=0;\n  bits=32;\n  p=buffer+0x800;\n  for (i=0; i < 3; i++)\n  {\n    pcd_table[i]=(PCDTable *) NULL;\n    pcd_length[i]=0;\n  }\n  for (i=0; i < (image->columns > 1536 ? 3 : 1); i++)\n  {\n    PCDGetBits(8);\n    length=(sum & 0xff)+1;\n    pcd_table[i]=(PCDTable *) AcquireQuantumMemory(length,\n      sizeof(*pcd_table[i]));\n    if (pcd_table[i] == (PCDTable *) NULL)\n      {\n        buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n        ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n          image->filename);\n      }\n    r=pcd_table[i];\n    for (j=0; j < (ssize_t) length; j++)\n    {\n      PCDGetBits(8);\n      r->length=(unsigned int) (sum & 0xff)+1;\n      if (r->length > 16)\n        {\n          buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n          return(MagickFalse);\n        }\n      PCDGetBits(16);\n      r->sequence=(unsigned int) (sum & 0xffff) << 16;\n      PCDGetBits(8);\n      r->key=(unsigned char) (sum & 0xff);\n      r->mask=(~((1U << (32-r->length))-1));\n      r++;\n    }\n    pcd_length[i]=(size_t) length;\n  }\n  /*\n    Search for Sync byte.\n  */\n  for (i=0; i < 1; i++)\n    PCDGetBits(16);\n  for (i=0; i < 1; i++)\n    PCDGetBits(16);\n  while ((sum & 0x00fff000UL) != 0x00fff000UL)\n    PCDGetBits(8);\n  while (IsSync(sum) == 0)\n    PCDGetBits(1);\n  /*\n    Recover the Huffman encoded luminance and chrominance deltas.\n  */\n  count=0;\n  length=0;\n  plane=0;\n  row=0;\n  q=luma;\n  for ( ; ; )\n  {\n    if (IsSync(sum) != 0)\n      {\n        /*\n          Determine plane and row number.\n        */\n        PCDGetBits(16);\n        row=((sum >> 9) & 0x1fff);\n        if (row == image->rows)\n          break;\n        PCDGetBits(8);\n        plane=sum >> 30;\n        PCDGetBits(16);\n        switch (plane)\n        {\n          case 0:\n          {\n            q=luma+row*image->columns;\n            count=(ssize_t) image->columns;\n            break;\n          }\n          case 2:\n          {\n            q=chroma1+(row >> 1)*image->columns;\n            count=(ssize_t) (image->columns >> 1);\n            plane--;\n            break;\n          }\n          case 3:\n          {\n            q=chroma2+(row >> 1)*image->columns;\n            count=(ssize_t) (image->columns >> 1);\n            plane--;\n            break;\n          }\n          default:\n          {\n            for (i=0; i < (image->columns > 1536 ? 3 : 1); i++)\n              pcd_table[i]=(PCDTable *) RelinquishMagickMemory(pcd_table[i]);\n            buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n            ThrowBinaryException(CorruptImageError,\"CorruptImage\",\n              image->filename);\n          }\n        }\n        length=pcd_length[plane];\n        continue;\n      }\n    /*\n      Decode luminance or chrominance deltas.\n    */\n    r=pcd_table[plane];\n    for (i=0; ((i < (ssize_t) length) && ((sum & r->mask) != r->sequence)); i++)\n      r++;\n    if ((row > image->rows) || (r == (PCDTable *) NULL))\n      {\n        (void) ThrowMagickException(exception,GetMagickModule(),\n          CorruptImageWarning,\"SkipToSyncByte\",\"`%s'\",image->filename);\n        while ((sum & 0x00fff000) != 0x00fff000)\n          PCDGetBits(8);\n        while (IsSync(sum) == 0)\n          PCDGetBits(1);\n        continue;\n      }\n    if (r->key < 128)\n      quantum=(ssize_t) (*q)+r->key;\n    else\n      quantum=(ssize_t) (*q)+r->key-256;\n    *q=(unsigned char) ((quantum < 0) ? 0 : (quantum > 255) ? 255 : quantum);\n    q++;\n    PCDGetBits(r->length);\n    count--;\n  }\n  /*\n    Relinquish resources.\n  */\n  for (i=0; i < (image->columns > 1536 ? 3 : 1); i++)\n    pcd_table[i]=(PCDTable *) RelinquishMagickMemory(pcd_table[i]);\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  return(MagickTrue);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -171,6 +171,9 @@\n           }\n           default:\n           {\n+            for (i=0; i < (image->columns > 1536 ? 3 : 1); i++)\n+              pcd_table[i]=(PCDTable *) RelinquishMagickMemory(pcd_table[i]);\n+            buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n             ThrowBinaryException(CorruptImageError,\"CorruptImage\",\n               image->filename);\n           }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            for (i=0; i < (image->columns > 1536 ? 3 : 1); i++)",
                "              pcd_table[i]=(PCDTable *) RelinquishMagickMemory(pcd_table[i]);",
                "            buffer=(unsigned char *) RelinquishMagickMemory(buffer);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14437",
        "func_name": "ImageMagick/parse8BIM",
        "description": "ImageMagick 7.0.8-4 has a memory leak in parse8BIM in coders/meta.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/082223fb992448dbb574747deac9a30f986c116e",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1190",
        "commit_text": "",
        "func_before": "static ssize_t parse8BIM(Image *ifile, Image *ofile)\n{\n  char\n    brkused,\n    quoted,\n    *line,\n    *token,\n    *newstr,\n    *name;\n\n  int\n    state,\n    next;\n\n  unsigned char\n    dataset;\n\n  unsigned int\n    recnum;\n\n  int\n    inputlen = MagickPathExtent;\n\n  MagickOffsetType\n    savedpos,\n    currentpos;\n\n  ssize_t\n    savedolen = 0L,\n    outputlen = 0L;\n\n  TokenInfo\n    *token_info;\n\n  dataset = 0;\n  recnum = 0;\n  line = (char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*line));\n  if (line == (char *) NULL)\n    return(-1);\n  newstr = name = token = (char *) NULL;\n  savedpos = 0;\n  token_info=AcquireTokenInfo();\n  while (super_fgets(&line,&inputlen,ifile)!=NULL)\n  {\n    state=0;\n    next=0;\n\n    token=(char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*token));\n    if (token == (char *) NULL)\n      break;\n    newstr=(char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*newstr));\n    if (newstr == (char *) NULL)\n      break;\n    while (Tokenizer(token_info,0,token,(size_t) inputlen,line,\"\",\"=\",\"\\\"\",0,\n           &brkused,&next,&quoted)==0)\n    {\n      if (state == 0)\n        {\n          int\n            state,\n            next;\n\n          char\n            brkused,\n            quoted;\n\n          state=0;\n          next=0;\n          while (Tokenizer(token_info,0,newstr,(size_t) inputlen,token,\"\",\"#\",\n            \"\", 0,&brkused,&next,&quoted)==0)\n          {\n            switch (state)\n            {\n              case 0:\n                if (strcmp(newstr,\"8BIM\")==0)\n                  dataset = 255;\n                else\n                  dataset = (unsigned char) StringToLong(newstr);\n                break;\n              case 1:\n                recnum = (unsigned int) StringToUnsignedLong(newstr);\n                break;\n              case 2:\n                name=(char *) AcquireQuantumMemory(strlen(newstr)+MagickPathExtent,\n                  sizeof(*name));\n                if (name)\n                  (void) strcpy(name,newstr);\n                break;\n            }\n            state++;\n          }\n        }\n      else\n        if (state == 1)\n          {\n            int\n              next;\n\n            ssize_t\n              len;\n\n            char\n              brkused,\n              quoted;\n\n            next=0;\n            len = (ssize_t) strlen(token);\n            while (Tokenizer(token_info,0,newstr,(size_t) inputlen,token,\"\",\"&\",\n              \"\",0,&brkused,&next,&quoted)==0)\n            {\n              if (brkused && next > 0)\n                {\n                  size_t\n                    codes_length;\n\n                  char\n                    *s = &token[next-1];\n\n                  codes_length=convertHTMLcodes(s, strlen(s));\n                  if ((ssize_t) codes_length > len)\n                    len=0;\n                  else\n                    len-=codes_length;\n                }\n            }\n\n            if (dataset == 255)\n              {\n                unsigned char\n                  nlen = 0;\n\n                int\n                  i;\n\n                if (savedolen > 0)\n                  {\n                    MagickOffsetType\n                      offset;\n\n                    ssize_t diff = outputlen - savedolen;\n                    currentpos = TellBlob(ofile);\n                    if (currentpos < 0)\n                      return(-1);\n                    offset=SeekBlob(ofile,savedpos,SEEK_SET);\n                    if (offset < 0)\n                      return(-1);\n                    (void) WriteBlobMSBLong(ofile,(unsigned int) diff);\n                    offset=SeekBlob(ofile,currentpos,SEEK_SET);\n                    if (offset < 0)\n                      return(-1);\n                    savedolen = 0L;\n                  }\n                if (outputlen & 1)\n                  {\n                    (void) WriteBlobByte(ofile,0x00);\n                    outputlen++;\n                  }\n                (void) WriteBlobString(ofile,\"8BIM\");\n                (void) WriteBlobMSBShort(ofile,(unsigned short) recnum);\n                outputlen += 6;\n                if (name)\n                  nlen = (unsigned char) strlen(name);\n                (void) WriteBlobByte(ofile,nlen);\n                outputlen++;\n                for (i=0; i<nlen; i++)\n                  (void) WriteBlobByte(ofile,(unsigned char) name[i]);\n                outputlen += nlen;\n                if ((nlen & 0x01) == 0)\n                  {\n                    (void) WriteBlobByte(ofile,0x00);\n                    outputlen++;\n                  }\n                if (recnum != IPTC_ID)\n                  {\n                    (void) WriteBlobMSBLong(ofile, (unsigned int) len);\n                    outputlen += 4;\n\n                    next=0;\n                    outputlen += len;\n                    while (len-- > 0)\n                      (void) WriteBlobByte(ofile,(unsigned char) token[next++]);\n\n                    if (outputlen & 1)\n                      {\n                        (void) WriteBlobByte(ofile,0x00);\n                        outputlen++;\n                      }\n                  }\n                else\n                  {\n                    /* patch in a fake length for now and fix it later */\n                    savedpos = TellBlob(ofile);\n                    if (savedpos < 0)\n                      return(-1);\n                    (void) WriteBlobMSBLong(ofile,0xFFFFFFFFU);\n                    outputlen += 4;\n                    savedolen = outputlen;\n                  }\n              }\n            else\n              {\n                if (len <= 0x7FFF)\n                  {\n                    (void) WriteBlobByte(ofile,0x1c);\n                    (void) WriteBlobByte(ofile,(unsigned char) dataset);\n                    (void) WriteBlobByte(ofile,(unsigned char) (recnum & 0xff));\n                    (void) WriteBlobMSBShort(ofile,(unsigned short) len);\n                    outputlen += 5;\n                    next=0;\n                    outputlen += len;\n                    while (len-- > 0)\n                      (void) WriteBlobByte(ofile,(unsigned char) token[next++]);\n                  }\n              }\n          }\n      state++;\n    }\n    if (token != (char *) NULL)\n      token=DestroyString(token);\n    if (newstr != (char *) NULL)\n      newstr=DestroyString(newstr);\n    if (name != (char *) NULL)\n      name=DestroyString(name);\n  }\n  token_info=DestroyTokenInfo(token_info);\n  if (token != (char *) NULL)\n    token=DestroyString(token);\n  if (newstr != (char *) NULL)\n    newstr=DestroyString(newstr);\n  if (name != (char *) NULL)\n    name=DestroyString(name);\n  line=DestroyString(line);\n  if (savedolen > 0)\n    {\n      MagickOffsetType\n        offset;\n\n      ssize_t diff = outputlen - savedolen;\n\n      currentpos = TellBlob(ofile);\n      if (currentpos < 0)\n        return(-1);\n      offset=SeekBlob(ofile,savedpos,SEEK_SET);\n      if (offset < 0)\n        return(-1);\n      (void) WriteBlobMSBLong(ofile,(unsigned int) diff);\n      offset=SeekBlob(ofile,currentpos,SEEK_SET);\n      if (offset < 0)\n        return(-1);\n      savedolen = 0L;\n    }\n  return outputlen;\n}",
        "func": "static ssize_t parse8BIM(Image *ifile, Image *ofile)\n{\n  char\n    brkused,\n    quoted,\n    *line,\n    *token,\n    *newstr,\n    *name;\n\n  int\n    state,\n    next;\n\n  unsigned char\n    dataset;\n\n  unsigned int\n    recnum;\n\n  int\n    inputlen = MagickPathExtent;\n\n  MagickOffsetType\n    savedpos,\n    currentpos;\n\n  ssize_t\n    savedolen = 0L,\n    outputlen = 0L;\n\n  TokenInfo\n    *token_info;\n\n  dataset = 0;\n  recnum = 0;\n  line = (char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*line));\n  if (line == (char *) NULL)\n    return(-1);\n  newstr = name = token = (char *) NULL;\n  savedpos = 0;\n  token_info=AcquireTokenInfo();\n  while (super_fgets(&line,&inputlen,ifile)!=NULL)\n  {\n    state=0;\n    next=0;\n\n    token=(char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*token));\n    if (token == (char *) NULL)\n      break;\n    newstr=(char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*newstr));\n    if (newstr == (char *) NULL)\n      break;\n    while (Tokenizer(token_info,0,token,(size_t) inputlen,line,\"\",\"=\",\"\\\"\",0,\n           &brkused,&next,&quoted)==0)\n    {\n      if (state == 0)\n        {\n          int\n            state,\n            next;\n\n          char\n            brkused,\n            quoted;\n\n          state=0;\n          next=0;\n          while (Tokenizer(token_info,0,newstr,(size_t) inputlen,token,\"\",\"#\",\n            \"\", 0,&brkused,&next,&quoted)==0)\n          {\n            switch (state)\n            {\n              case 0:\n                if (strcmp(newstr,\"8BIM\")==0)\n                  dataset = 255;\n                else\n                  dataset = (unsigned char) StringToLong(newstr);\n                break;\n              case 1:\n                recnum = (unsigned int) StringToUnsignedLong(newstr);\n                break;\n              case 2:\n                name=(char *) AcquireQuantumMemory(strlen(newstr)+MagickPathExtent,\n                  sizeof(*name));\n                if (name)\n                  (void) strcpy(name,newstr);\n                break;\n            }\n            state++;\n          }\n        }\n      else\n        if (state == 1)\n          {\n            int\n              next;\n\n            ssize_t\n              len;\n\n            char\n              brkused,\n              quoted;\n\n            next=0;\n            len = (ssize_t) strlen(token);\n            while (Tokenizer(token_info,0,newstr,(size_t) inputlen,token,\"\",\"&\",\n              \"\",0,&brkused,&next,&quoted)==0)\n            {\n              if (brkused && next > 0)\n                {\n                  size_t\n                    codes_length;\n\n                  char\n                    *s = &token[next-1];\n\n                  codes_length=convertHTMLcodes(s, strlen(s));\n                  if ((ssize_t) codes_length > len)\n                    len=0;\n                  else\n                    len-=codes_length;\n                }\n            }\n\n            if (dataset == 255)\n              {\n                unsigned char\n                  nlen = 0;\n\n                int\n                  i;\n\n                if (savedolen > 0)\n                  {\n                    MagickOffsetType\n                      offset;\n\n                    ssize_t diff = outputlen - savedolen;\n                    currentpos = TellBlob(ofile);\n                    if (currentpos < 0)\n                      {\n                        line=DestroyString(line);\n                        return(-1);\n                      }\n                    offset=SeekBlob(ofile,savedpos,SEEK_SET);\n                    if (offset < 0)\n                      {\n                        line=DestroyString(line);\n                        return(-1);\n                      }\n                    (void) WriteBlobMSBLong(ofile,(unsigned int) diff);\n                    offset=SeekBlob(ofile,currentpos,SEEK_SET);\n                    if (offset < 0)\n                      {\n                        line=DestroyString(line);\n                        return(-1);\n                      }\n                    savedolen = 0L;\n                  }\n                if (outputlen & 1)\n                  {\n                    (void) WriteBlobByte(ofile,0x00);\n                    outputlen++;\n                  }\n                (void) WriteBlobString(ofile,\"8BIM\");\n                (void) WriteBlobMSBShort(ofile,(unsigned short) recnum);\n                outputlen += 6;\n                if (name)\n                  nlen = (unsigned char) strlen(name);\n                (void) WriteBlobByte(ofile,nlen);\n                outputlen++;\n                for (i=0; i<nlen; i++)\n                  (void) WriteBlobByte(ofile,(unsigned char) name[i]);\n                outputlen += nlen;\n                if ((nlen & 0x01) == 0)\n                  {\n                    (void) WriteBlobByte(ofile,0x00);\n                    outputlen++;\n                  }\n                if (recnum != IPTC_ID)\n                  {\n                    (void) WriteBlobMSBLong(ofile, (unsigned int) len);\n                    outputlen += 4;\n\n                    next=0;\n                    outputlen += len;\n                    while (len-- > 0)\n                      (void) WriteBlobByte(ofile,(unsigned char) token[next++]);\n\n                    if (outputlen & 1)\n                      {\n                        (void) WriteBlobByte(ofile,0x00);\n                        outputlen++;\n                      }\n                  }\n                else\n                  {\n                    /* patch in a fake length for now and fix it later */\n                    savedpos = TellBlob(ofile);\n                    if (savedpos < 0)\n                      return(-1);\n                    (void) WriteBlobMSBLong(ofile,0xFFFFFFFFU);\n                    outputlen += 4;\n                    savedolen = outputlen;\n                  }\n              }\n            else\n              {\n                if (len <= 0x7FFF)\n                  {\n                    (void) WriteBlobByte(ofile,0x1c);\n                    (void) WriteBlobByte(ofile,(unsigned char) dataset);\n                    (void) WriteBlobByte(ofile,(unsigned char) (recnum & 0xff));\n                    (void) WriteBlobMSBShort(ofile,(unsigned short) len);\n                    outputlen += 5;\n                    next=0;\n                    outputlen += len;\n                    while (len-- > 0)\n                      (void) WriteBlobByte(ofile,(unsigned char) token[next++]);\n                  }\n              }\n          }\n      state++;\n    }\n    if (token != (char *) NULL)\n      token=DestroyString(token);\n    if (newstr != (char *) NULL)\n      newstr=DestroyString(newstr);\n    if (name != (char *) NULL)\n      name=DestroyString(name);\n  }\n  token_info=DestroyTokenInfo(token_info);\n  if (token != (char *) NULL)\n    token=DestroyString(token);\n  if (newstr != (char *) NULL)\n    newstr=DestroyString(newstr);\n  if (name != (char *) NULL)\n    name=DestroyString(name);\n  line=DestroyString(line);\n  if (savedolen > 0)\n    {\n      MagickOffsetType\n        offset;\n\n      ssize_t diff = outputlen - savedolen;\n\n      currentpos = TellBlob(ofile);\n      if (currentpos < 0)\n        return(-1);\n      offset=SeekBlob(ofile,savedpos,SEEK_SET);\n      if (offset < 0)\n        return(-1);\n      (void) WriteBlobMSBLong(ofile,(unsigned int) diff);\n      offset=SeekBlob(ofile,currentpos,SEEK_SET);\n      if (offset < 0)\n        return(-1);\n      savedolen = 0L;\n    }\n  return outputlen;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -140,14 +140,23 @@\n                     ssize_t diff = outputlen - savedolen;\n                     currentpos = TellBlob(ofile);\n                     if (currentpos < 0)\n-                      return(-1);\n+                      {\n+                        line=DestroyString(line);\n+                        return(-1);\n+                      }\n                     offset=SeekBlob(ofile,savedpos,SEEK_SET);\n                     if (offset < 0)\n-                      return(-1);\n+                      {\n+                        line=DestroyString(line);\n+                        return(-1);\n+                      }\n                     (void) WriteBlobMSBLong(ofile,(unsigned int) diff);\n                     offset=SeekBlob(ofile,currentpos,SEEK_SET);\n                     if (offset < 0)\n-                      return(-1);\n+                      {\n+                        line=DestroyString(line);\n+                        return(-1);\n+                      }\n                     savedolen = 0L;\n                   }\n                 if (outputlen & 1)",
        "diff_line_info": {
            "deleted_lines": [
                "                      return(-1);",
                "                      return(-1);",
                "                      return(-1);"
            ],
            "added_lines": [
                "                      {",
                "                        line=DestroyString(line);",
                "                        return(-1);",
                "                      }",
                "                      {",
                "                        line=DestroyString(line);",
                "                        return(-1);",
                "                      }",
                "                      {",
                "                        line=DestroyString(line);",
                "                        return(-1);",
                "                      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-16640",
        "func_name": "ImageMagick/ReadOneJNGImage",
        "description": "ImageMagick 7.0.8-5 has a memory leak vulnerability in the function ReadOneJNGImage in coders/png.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/76efa969342568841ecf320b5a041685a6d24e0b",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1201",
        "commit_text": "",
        "func_before": "static Image *ReadOneJNGImage(MngInfo *mng_info,\n    const ImageInfo *image_info, ExceptionInfo *exception)\n{\n  Image\n    *alpha_image,\n    *color_image,\n    *image,\n    *jng_image;\n\n  ImageInfo\n    *alpha_image_info,\n    *color_image_info;\n\n  MagickBooleanType\n    logging;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    status;\n\n  png_uint_32\n    jng_height,\n    jng_width;\n\n  png_byte\n    jng_color_type,\n    jng_image_sample_depth,\n    jng_image_compression_method,\n    jng_image_interlace_method,\n    jng_alpha_sample_depth,\n    jng_alpha_compression_method,\n    jng_alpha_filter_method,\n    jng_alpha_interlace_method;\n\n  register const Quantum\n    *s;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  unsigned int\n    read_JSEP,\n    reading_idat;\n\n  size_t\n    length;\n\n  jng_alpha_compression_method=0;\n  jng_alpha_sample_depth=8;\n  jng_color_type=0;\n  jng_height=0;\n  jng_width=0;\n  alpha_image=(Image *) NULL;\n  color_image=(Image *) NULL;\n  alpha_image_info=(ImageInfo *) NULL;\n  color_image_info=(ImageInfo *) NULL;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneJNGImage()\");\n\n  image=mng_info->image;\n\n  if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n    {\n      /*\n        Allocate next image structure.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  AcquireNextImage()\");\n\n      AcquireNextImage(image_info,image,exception);\n\n      if (GetNextImageInList(image) == (Image *) NULL)\n        return(DestroyImageList(image));\n\n      image=SyncNextImageInList(image);\n    }\n  mng_info->image=image;\n\n  /*\n    Signature bytes have already been read.\n  */\n\n  read_JSEP=MagickFalse;\n  reading_idat=MagickFalse;\n  for (;;)\n  {\n    char\n      type[MagickPathExtent];\n\n    unsigned char\n      *chunk;\n\n    unsigned int\n      count;\n\n    /*\n      Read a new JNG chunk.\n    */\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      2*GetBlobSize(image));\n\n    if (status == MagickFalse)\n      break;\n\n    type[0]='\\0';\n    (void) ConcatenateMagickString(type,\"errr\",MagickPathExtent);\n    length=(size_t) ReadBlobMSBLong(image);\n    count=(unsigned int) ReadBlob(image,4,(unsigned char *) type);\n\n    if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Reading JNG chunk type %c%c%c%c, length: %.20g\",\n        type[0],type[1],type[2],type[3],(double) length);\n\n    if (length > PNG_UINT_31_MAX || count == 0)\n      {\n        DestroyJNG(NULL,&color_image,&color_image_info,\n          &alpha_image,&alpha_image_info);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    if (length > GetBlobSize(image))\n      {\n        DestroyJNG(NULL,&color_image,&color_image_info,\n          &alpha_image,&alpha_image_info);\n        ThrowReaderException(CorruptImageError,\n          \"InsufficientImageDataInFile\");\n      }\n\n    p=NULL;\n    chunk=(unsigned char *) NULL;\n\n    if (length != 0)\n      {\n        chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));\n\n        if (chunk == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        for (i=0; i < (ssize_t) length; i++)\n        {\n          int\n            c;\n\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            break;\n          chunk[i]=(unsigned char) c;\n        }\n        for ( ; i < (ssize_t) length; i++)\n          chunk[i]='\\0';\n\n        p=chunk;\n      }\n\n    (void) ReadBlobMSBLong(image);  /* read crc word */\n\n    if (memcmp(type,mng_JHDR,4) == 0)\n      {\n        if (length == 16)\n          {\n            jng_width=(png_uint_32)mng_get_long(p);\n            jng_height=(png_uint_32)mng_get_long(&p[4]);\n            if ((jng_width == 0) || (jng_height == 0))\n            {\n              DestroyJNG(chunk,&color_image,&color_image_info,\n                &alpha_image,&alpha_image_info);\n\n              ThrowReaderException(CorruptImageError,\n                \"NegativeOrZeroImageSize\");\n            }\n            jng_color_type=p[8];\n            jng_image_sample_depth=p[9];\n            jng_image_compression_method=p[10];\n            jng_image_interlace_method=p[11];\n\n            image->interlace=jng_image_interlace_method != 0 ? PNGInterlace :\n              NoInterlace;\n\n            jng_alpha_sample_depth=p[12];\n            jng_alpha_compression_method=p[13];\n            jng_alpha_filter_method=p[14];\n            jng_alpha_interlace_method=p[15];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_width:      %16lu,    jng_height:     %16lu\\n\"\n                  \"    jng_color_type: %16d,     jng_image_sample_depth: %3d\\n\"\n                  \"    jng_image_compression_method:%3d\",\n                  (unsigned long) jng_width, (unsigned long) jng_height,\n                  jng_color_type, jng_image_sample_depth,\n                  jng_image_compression_method);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_image_interlace_method:  %3d\"\n                  \"    jng_alpha_sample_depth:      %3d\",\n                  jng_image_interlace_method,\n                  jng_alpha_sample_depth);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_alpha_compression_method:%3d\\n\"\n                  \"    jng_alpha_filter_method:     %3d\\n\"\n                  \"    jng_alpha_interlace_method:  %3d\",\n                  jng_alpha_compression_method,\n                  jng_alpha_filter_method,\n                  jng_alpha_interlace_method);\n              }\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        if (jng_width > 65535 || jng_height > 65535 ||\n             (long) jng_width > GetMagickResourceLimit(WidthResource) ||\n             (long) jng_height > GetMagickResourceLimit(HeightResource))\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    JNG width or height too large: (%lu x %lu)\",\n                (long) jng_width, (long) jng_height);\n            DestroyJNG(chunk,&color_image,&color_image_info,\n              &alpha_image,&alpha_image_info);\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          }\n\n        continue;\n      }\n\n\n    if ((reading_idat == MagickFalse) && (read_JSEP == MagickFalse) &&\n        ((memcmp(type,mng_JDAT,4) == 0) || (memcmp(type,mng_JdAA,4) == 0) ||\n         (memcmp(type,mng_IDAT,4) == 0) || (memcmp(type,mng_JDAA,4) == 0)))\n      {\n        /*\n           o create color_image\n           o open color_blob, attached to color_image\n           o if (color type has alpha)\n               open alpha_blob, attached to alpha_image\n        */\n\n        color_image_info=(ImageInfo *)AcquireMagickMemory(sizeof(ImageInfo));\n\n        if (color_image_info == (ImageInfo *) NULL)\n        {\n          DestroyJNG(chunk,&color_image,&color_image_info,\n              &alpha_image,&alpha_image_info);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n\n        GetImageInfo(color_image_info);\n        color_image=AcquireImage(color_image_info,exception);\n\n        if (color_image == (Image *) NULL)\n        {\n          DestroyJNG(chunk,&color_image,&color_image_info,\n              &alpha_image,&alpha_image_info);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Creating color_blob.\");\n\n        (void) AcquireUniqueFilename(color_image->filename);\n        status=OpenBlob(color_image_info,color_image,WriteBinaryBlobMode,\n          exception);\n\n        if (status == MagickFalse)\n          {\n            DestroyJNG(chunk,&color_image,&color_image_info,\n              &alpha_image,&alpha_image_info);\n            return(DestroyImageList(image));\n          }\n\n        if ((image_info->ping == MagickFalse) && (jng_color_type >= 12))\n          {\n            alpha_image_info=(ImageInfo *)\n              AcquireMagickMemory(sizeof(ImageInfo));\n\n            if (alpha_image_info == (ImageInfo *) NULL)\n              {\n                DestroyJNG(chunk,&color_image,&color_image_info,\n                  &alpha_image,&alpha_image_info);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            GetImageInfo(alpha_image_info);\n            alpha_image=AcquireImage(alpha_image_info,exception);\n\n            if (alpha_image == (Image *) NULL)\n              {\n                DestroyJNG(chunk,&color_image,&color_image_info,\n                  &alpha_image,&alpha_image_info);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Creating alpha_blob.\");\n\n            (void) AcquireUniqueFilename(alpha_image->filename);\n            status=OpenBlob(alpha_image_info,alpha_image,WriteBinaryBlobMode,\n              exception);\n\n            if (status == MagickFalse)\n              {\n                DestroyJNG(chunk,&color_image,&color_image_info,\n                  &alpha_image,&alpha_image_info);\n                return(DestroyImageList(image));\n              }\n\n            if (jng_alpha_compression_method == 0)\n              {\n                unsigned char\n                  data[18];\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Writing IHDR chunk to alpha_blob.\");\n\n                (void) WriteBlob(alpha_image,8,(const unsigned char *)\n                  \"\\211PNG\\r\\n\\032\\n\");\n\n                (void) WriteBlobMSBULong(alpha_image,13L);\n                PNGType(data,mng_IHDR);\n                LogPNGChunk(logging,mng_IHDR,13L);\n                PNGLong(data+4,jng_width);\n                PNGLong(data+8,jng_height);\n                data[12]=jng_alpha_sample_depth;\n                data[13]=0; /* color_type gray */\n                data[14]=0; /* compression method 0 */\n                data[15]=0; /* filter_method 0 */\n                data[16]=0; /* interlace_method 0 */\n                (void) WriteBlob(alpha_image,17,data);\n                (void) WriteBlobMSBULong(alpha_image,crc32(0,data,17));\n              }\n          }\n        reading_idat=MagickTrue;\n      }\n\n    if (memcmp(type,mng_JDAT,4) == 0)\n      {\n        /* Copy chunk to color_image->blob */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Copying JDAT chunk data to color_blob.\");\n\n        if ((length != 0) && (color_image != (Image *) NULL))\n          (void) WriteBlob(color_image,length,chunk);\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_IDAT,4) == 0)\n      {\n        png_byte\n           data[5];\n\n        /* Copy IDAT header and chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying IDAT chunk data to alpha_blob.\");\n\n            (void) WriteBlobMSBULong(alpha_image,(size_t) length);\n            PNGType(data,mng_IDAT);\n            LogPNGChunk(logging,mng_IDAT,length);\n            (void) WriteBlob(alpha_image,4,data);\n            (void) WriteBlob(alpha_image,length,chunk);\n            (void) WriteBlobMSBULong(alpha_image,\n              crc32(crc32(0,data,4),chunk,(uInt) length));\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if ((memcmp(type,mng_JDAA,4) == 0) || (memcmp(type,mng_JdAA,4) == 0))\n      {\n        /* Copy chunk data to alpha_image->blob */\n\n        if ((alpha_image != NULL) && (image_info->ping == MagickFalse) &&\n            (length != 0))\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying JDAA chunk data to alpha_blob.\");\n\n            (void) WriteBlob(alpha_image,length,chunk);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_JSEP,4) == 0)\n      {\n        read_JSEP=MagickTrue;\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_bKGD,4) == 0)\n      {\n        if (length == 2)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=image->background_color.red;\n            image->background_color.blue=image->background_color.red;\n          }\n\n        if (length == 6)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=ScaleCharToQuantum(p[3]);\n            image->background_color.blue=ScaleCharToQuantum(p[5]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_gAMA,4) == 0)\n      {\n        if (length == 4)\n          image->gamma=((float) mng_get_long(p))*0.00001;\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_cHRM,4) == 0)\n      {\n        if (length == 32)\n          {\n            image->chromaticity.white_point.x=0.00001*mng_get_long(p);\n            image->chromaticity.white_point.y=0.00001*mng_get_long(&p[4]);\n            image->chromaticity.red_primary.x=0.00001*mng_get_long(&p[8]);\n            image->chromaticity.red_primary.y=0.00001*mng_get_long(&p[12]);\n            image->chromaticity.green_primary.x=0.00001*mng_get_long(&p[16]);\n            image->chromaticity.green_primary.y=0.00001*mng_get_long(&p[20]);\n            image->chromaticity.blue_primary.x=0.00001*mng_get_long(&p[24]);\n            image->chromaticity.blue_primary.y=0.00001*mng_get_long(&p[28]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_sRGB,4) == 0)\n      {\n        if (length == 1)\n          {\n            image->rendering_intent=\n              Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n            image->gamma=1.000f/2.200f;\n            image->chromaticity.red_primary.x=0.6400f;\n            image->chromaticity.red_primary.y=0.3300f;\n            image->chromaticity.green_primary.x=0.3000f;\n            image->chromaticity.green_primary.y=0.6000f;\n            image->chromaticity.blue_primary.x=0.1500f;\n            image->chromaticity.blue_primary.y=0.0600f;\n            image->chromaticity.white_point.x=0.3127f;\n            image->chromaticity.white_point.y=0.3290f;\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_oFFs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->page.x=(ssize_t) mng_get_long(p);\n            image->page.y=(ssize_t) mng_get_long(&p[4]);\n\n            if ((int) p[8] != 0)\n              {\n                image->page.x/=10000;\n                image->page.y/=10000;\n              }\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_pHYs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->resolution.x=(double) mng_get_long(p);\n            image->resolution.y=(double) mng_get_long(&p[4]);\n            if ((int) p[8] == PNG_RESOLUTION_METER)\n              {\n                image->units=PixelsPerCentimeterResolution;\n                image->resolution.x=image->resolution.x/100.0f;\n                image->resolution.y=image->resolution.y/100.0f;\n              }\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n#if 0\n    if (memcmp(type,mng_iCCP,4) == 0)\n      {\n        /* To do: */\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n#endif\n\n    chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n    if (memcmp(type,mng_IEND,4))\n      continue;\n\n    break;\n  }\n\n\n  /* IEND found */\n\n  /*\n    Finish up reading image data:\n\n       o read main image from color_blob.\n\n       o close color_blob.\n\n       o if (color_type has alpha)\n            if alpha_encoding is PNG\n               read secondary image from alpha_blob via ReadPNG\n            if alpha_encoding is JPEG\n               read secondary image from alpha_blob via ReadJPEG\n\n       o close alpha_blob.\n\n       o copy intensity of secondary image into\n         alpha samples of main image.\n\n       o destroy the secondary image.\n  */\n\n  if (color_image_info == (ImageInfo *) NULL)\n    {\n      assert(color_image == (Image *) NULL);\n      assert(alpha_image == (Image *) NULL);\n      if (color_image != (Image *) NULL)\n        color_image=DestroyImageList(color_image);\n      return(DestroyImageList(image));\n    }\n\n  if (color_image == (Image *) NULL)\n    {\n      assert(alpha_image == (Image *) NULL);\n      ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n    }\n\n  (void) SeekBlob(color_image,0,SEEK_SET);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Reading jng_image from color_blob.\");\n\n  assert(color_image_info != (ImageInfo *) NULL);\n  (void) FormatLocaleString(color_image_info->filename,MagickPathExtent,\n    \"jpeg:%s\",color_image->filename);\n\n  color_image_info->ping=MagickFalse;   /* To do: avoid this */\n  jng_image=ReadImage(color_image_info,exception);\n\n  (void) RelinquishUniqueFileResource(color_image->filename);\n  color_image=DestroyImage(color_image);\n  color_image_info=DestroyImageInfo(color_image_info);\n\n  if (jng_image == (Image *) NULL)\n  {\n    DestroyJNG(NULL,NULL,NULL,&alpha_image,&alpha_image_info);\n    return(DestroyImageList(image));\n  }\n\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Copying jng_image pixels to main image.\");\n\n  image->rows=jng_height;\n  image->columns=jng_width;\n\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    {\n      DestroyJNG(NULL,&color_image,&color_image_info,&alpha_image,\n        &alpha_image_info);\n      jng_image=DestroyImageList(jng_image);\n      return(DestroyImageList(image));\n    }\n  if ((image->columns != jng_image->columns) ||\n      (image->rows != jng_image->rows))\n    {\n      DestroyJNG(NULL,&color_image,&color_image_info,&alpha_image,\n        &alpha_image_info);\n      jng_image=DestroyImageList(jng_image);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    s=GetVirtualPixels(jng_image,0,y,image->columns,1,exception);\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if ((s == (const Quantum *)  NULL) || (q == (Quantum *) NULL))\n      break;\n    for (x=(ssize_t) image->columns; x != 0; x--)\n    {\n      SetPixelRed(image,GetPixelRed(jng_image,s),q);\n      SetPixelGreen(image,GetPixelGreen(jng_image,s),q);\n      SetPixelBlue(image,GetPixelBlue(jng_image,s),q);\n      q+=GetPixelChannels(image);\n      s+=GetPixelChannels(jng_image);\n    }\n\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n\n  jng_image=DestroyImage(jng_image);\n\n  if ((image_info->ping == MagickFalse) && (jng_color_type >= 12))\n    {\n      if (jng_alpha_compression_method == 0)\n        {\n          png_byte\n            data[5];\n          (void) WriteBlobMSBULong(alpha_image,0x00000000L);\n          PNGType(data,mng_IEND);\n          LogPNGChunk(logging,mng_IEND,0L);\n          (void) WriteBlob(alpha_image,4,data);\n          (void) WriteBlobMSBULong(alpha_image,crc32(0,data,4));\n        }\n\n      (void) CloseBlob(alpha_image);\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Reading alpha from alpha_blob.\");\n\n      (void) FormatLocaleString(alpha_image_info->filename,MagickPathExtent,\n        \"%s\",alpha_image->filename);\n\n      jng_image=ReadImage(alpha_image_info,exception);\n\n      if (jng_image != (Image *) NULL)\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          s=GetVirtualPixels(jng_image,0,y,image->columns,1,exception);\n          q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n          if ((s == (const Quantum *)  NULL) || (q == (Quantum *) NULL))\n            break;\n\n          if (image->alpha_trait != UndefinedPixelTrait)\n            for (x=(ssize_t) image->columns; x != 0; x--)\n            {\n              SetPixelAlpha(image,GetPixelRed(jng_image,s),q);\n              q+=GetPixelChannels(image);\n              s+=GetPixelChannels(jng_image);\n            }\n\n          else\n            for (x=(ssize_t) image->columns; x != 0; x--)\n            {\n              SetPixelAlpha(image,GetPixelRed(jng_image,s),q);\n              if (GetPixelAlpha(image,q) != OpaqueAlpha)\n                image->alpha_trait=BlendPixelTrait;\n              q+=GetPixelChannels(image);\n              s+=GetPixelChannels(jng_image);\n            }\n\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n        }\n      (void) RelinquishUniqueFileResource(alpha_image->filename);\n      alpha_image=DestroyImage(alpha_image);\n      alpha_image_info=DestroyImageInfo(alpha_image_info);\n      if (jng_image != (Image *) NULL)\n        jng_image=DestroyImage(jng_image);\n    }\n\n  /* Read the JNG image.  */\n\n  if (mng_info->mng_type == 0)\n    {\n      mng_info->mng_width=jng_width;\n      mng_info->mng_height=jng_height;\n    }\n\n  if (image->page.width == 0 && image->page.height == 0)\n    {\n      image->page.width=jng_width;\n      image->page.height=jng_height;\n    }\n\n  if (image->page.x == 0 && image->page.y == 0)\n    {\n      image->page.x=mng_info->x_off[mng_info->object_id];\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  else\n    {\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  mng_info->image_found++;\n  status=SetImageProgress(image,LoadImagesTag,2*TellBlob(image),\n    2*GetBlobSize(image));\n\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneJNGImage()\");\n\n  return(image);\n}",
        "func": "static Image *ReadOneJNGImage(MngInfo *mng_info,\n    const ImageInfo *image_info, ExceptionInfo *exception)\n{\n  Image\n    *alpha_image,\n    *color_image,\n    *image,\n    *jng_image;\n\n  ImageInfo\n    *alpha_image_info,\n    *color_image_info;\n\n  MagickBooleanType\n    logging;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    status;\n\n  png_uint_32\n    jng_height,\n    jng_width;\n\n  png_byte\n    jng_color_type,\n    jng_image_sample_depth,\n    jng_image_compression_method,\n    jng_image_interlace_method,\n    jng_alpha_sample_depth,\n    jng_alpha_compression_method,\n    jng_alpha_filter_method,\n    jng_alpha_interlace_method;\n\n  register const Quantum\n    *s;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  unsigned int\n    read_JSEP,\n    reading_idat;\n\n  size_t\n    length;\n\n  jng_alpha_compression_method=0;\n  jng_alpha_sample_depth=8;\n  jng_color_type=0;\n  jng_height=0;\n  jng_width=0;\n  alpha_image=(Image *) NULL;\n  color_image=(Image *) NULL;\n  alpha_image_info=(ImageInfo *) NULL;\n  color_image_info=(ImageInfo *) NULL;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneJNGImage()\");\n\n  image=mng_info->image;\n\n  if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n    {\n      /*\n        Allocate next image structure.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  AcquireNextImage()\");\n\n      AcquireNextImage(image_info,image,exception);\n\n      if (GetNextImageInList(image) == (Image *) NULL)\n        return(DestroyImageList(image));\n\n      image=SyncNextImageInList(image);\n    }\n  mng_info->image=image;\n\n  /*\n    Signature bytes have already been read.\n  */\n\n  read_JSEP=MagickFalse;\n  reading_idat=MagickFalse;\n  for (;;)\n  {\n    char\n      type[MagickPathExtent];\n\n    unsigned char\n      *chunk;\n\n    unsigned int\n      count;\n\n    /*\n      Read a new JNG chunk.\n    */\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      2*GetBlobSize(image));\n\n    if (status == MagickFalse)\n      break;\n\n    type[0]='\\0';\n    (void) ConcatenateMagickString(type,\"errr\",MagickPathExtent);\n    length=(size_t) ReadBlobMSBLong(image);\n    count=(unsigned int) ReadBlob(image,4,(unsigned char *) type);\n\n    if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Reading JNG chunk type %c%c%c%c, length: %.20g\",\n        type[0],type[1],type[2],type[3],(double) length);\n\n    if (length > PNG_UINT_31_MAX || count == 0)\n      {\n        DestroyJNG(NULL,&color_image,&color_image_info,\n          &alpha_image,&alpha_image_info);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    if (length > GetBlobSize(image))\n      {\n        DestroyJNG(NULL,&color_image,&color_image_info,\n          &alpha_image,&alpha_image_info);\n        ThrowReaderException(CorruptImageError,\n          \"InsufficientImageDataInFile\");\n      }\n\n    p=NULL;\n    chunk=(unsigned char *) NULL;\n\n    if (length != 0)\n      {\n        chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));\n\n        if (chunk == (unsigned char *) NULL)\n          {\n            DestroyJNG(NULL,&color_image,&color_image_info,\n              &alpha_image,&alpha_image_info);\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n\n        for (i=0; i < (ssize_t) length; i++)\n        {\n          int\n            c;\n\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            break;\n          chunk[i]=(unsigned char) c;\n        }\n        for ( ; i < (ssize_t) length; i++)\n          chunk[i]='\\0';\n\n        p=chunk;\n      }\n\n    (void) ReadBlobMSBLong(image);  /* read crc word */\n\n    if (memcmp(type,mng_JHDR,4) == 0)\n      {\n        if (length == 16)\n          {\n            jng_width=(png_uint_32)mng_get_long(p);\n            jng_height=(png_uint_32)mng_get_long(&p[4]);\n            if ((jng_width == 0) || (jng_height == 0))\n              {\n                DestroyJNG(chunk,&color_image,&color_image_info,\n                  &alpha_image,&alpha_image_info);\n                ThrowReaderException(CorruptImageError,\n                  \"NegativeOrZeroImageSize\");\n              }\n            jng_color_type=p[8];\n            jng_image_sample_depth=p[9];\n            jng_image_compression_method=p[10];\n            jng_image_interlace_method=p[11];\n\n            image->interlace=jng_image_interlace_method != 0 ? PNGInterlace :\n              NoInterlace;\n\n            jng_alpha_sample_depth=p[12];\n            jng_alpha_compression_method=p[13];\n            jng_alpha_filter_method=p[14];\n            jng_alpha_interlace_method=p[15];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_width:      %16lu,    jng_height:     %16lu\\n\"\n                  \"    jng_color_type: %16d,     jng_image_sample_depth: %3d\\n\"\n                  \"    jng_image_compression_method:%3d\",\n                  (unsigned long) jng_width, (unsigned long) jng_height,\n                  jng_color_type, jng_image_sample_depth,\n                  jng_image_compression_method);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_image_interlace_method:  %3d\"\n                  \"    jng_alpha_sample_depth:      %3d\",\n                  jng_image_interlace_method,\n                  jng_alpha_sample_depth);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_alpha_compression_method:%3d\\n\"\n                  \"    jng_alpha_filter_method:     %3d\\n\"\n                  \"    jng_alpha_interlace_method:  %3d\",\n                  jng_alpha_compression_method,\n                  jng_alpha_filter_method,\n                  jng_alpha_interlace_method);\n              }\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        if (jng_width > 65535 || jng_height > 65535 ||\n             (long) jng_width > GetMagickResourceLimit(WidthResource) ||\n             (long) jng_height > GetMagickResourceLimit(HeightResource))\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    JNG width or height too large: (%lu x %lu)\",\n                (long) jng_width, (long) jng_height);\n            DestroyJNG(chunk,&color_image,&color_image_info,\n              &alpha_image,&alpha_image_info);\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          }\n\n        continue;\n      }\n\n\n    if ((reading_idat == MagickFalse) && (read_JSEP == MagickFalse) &&\n        ((memcmp(type,mng_JDAT,4) == 0) || (memcmp(type,mng_JdAA,4) == 0) ||\n         (memcmp(type,mng_IDAT,4) == 0) || (memcmp(type,mng_JDAA,4) == 0)))\n      {\n        /*\n           o create color_image\n           o open color_blob, attached to color_image\n           o if (color type has alpha)\n               open alpha_blob, attached to alpha_image\n        */\n\n        color_image_info=(ImageInfo *)AcquireMagickMemory(sizeof(ImageInfo));\n\n        if (color_image_info == (ImageInfo *) NULL)\n        {\n          DestroyJNG(chunk,&color_image,&color_image_info,\n              &alpha_image,&alpha_image_info);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n\n        GetImageInfo(color_image_info);\n        color_image=AcquireImage(color_image_info,exception);\n\n        if (color_image == (Image *) NULL)\n        {\n          DestroyJNG(chunk,&color_image,&color_image_info,\n              &alpha_image,&alpha_image_info);\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Creating color_blob.\");\n\n        (void) AcquireUniqueFilename(color_image->filename);\n        status=OpenBlob(color_image_info,color_image,WriteBinaryBlobMode,\n          exception);\n\n        if (status == MagickFalse)\n          {\n            DestroyJNG(chunk,&color_image,&color_image_info,\n              &alpha_image,&alpha_image_info);\n            return(DestroyImageList(image));\n          }\n\n        if ((image_info->ping == MagickFalse) && (jng_color_type >= 12))\n          {\n            alpha_image_info=(ImageInfo *)\n              AcquireMagickMemory(sizeof(ImageInfo));\n\n            if (alpha_image_info == (ImageInfo *) NULL)\n              {\n                DestroyJNG(chunk,&color_image,&color_image_info,\n                  &alpha_image,&alpha_image_info);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            GetImageInfo(alpha_image_info);\n            alpha_image=AcquireImage(alpha_image_info,exception);\n\n            if (alpha_image == (Image *) NULL)\n              {\n                DestroyJNG(chunk,&color_image,&color_image_info,\n                  &alpha_image,&alpha_image_info);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Creating alpha_blob.\");\n\n            (void) AcquireUniqueFilename(alpha_image->filename);\n            status=OpenBlob(alpha_image_info,alpha_image,WriteBinaryBlobMode,\n              exception);\n\n            if (status == MagickFalse)\n              {\n                DestroyJNG(chunk,&color_image,&color_image_info,\n                  &alpha_image,&alpha_image_info);\n                return(DestroyImageList(image));\n              }\n\n            if (jng_alpha_compression_method == 0)\n              {\n                unsigned char\n                  data[18];\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Writing IHDR chunk to alpha_blob.\");\n\n                (void) WriteBlob(alpha_image,8,(const unsigned char *)\n                  \"\\211PNG\\r\\n\\032\\n\");\n\n                (void) WriteBlobMSBULong(alpha_image,13L);\n                PNGType(data,mng_IHDR);\n                LogPNGChunk(logging,mng_IHDR,13L);\n                PNGLong(data+4,jng_width);\n                PNGLong(data+8,jng_height);\n                data[12]=jng_alpha_sample_depth;\n                data[13]=0; /* color_type gray */\n                data[14]=0; /* compression method 0 */\n                data[15]=0; /* filter_method 0 */\n                data[16]=0; /* interlace_method 0 */\n                (void) WriteBlob(alpha_image,17,data);\n                (void) WriteBlobMSBULong(alpha_image,crc32(0,data,17));\n              }\n          }\n        reading_idat=MagickTrue;\n      }\n\n    if (memcmp(type,mng_JDAT,4) == 0)\n      {\n        /* Copy chunk to color_image->blob */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Copying JDAT chunk data to color_blob.\");\n\n        if ((length != 0) && (color_image != (Image *) NULL))\n          (void) WriteBlob(color_image,length,chunk);\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_IDAT,4) == 0)\n      {\n        png_byte\n           data[5];\n\n        /* Copy IDAT header and chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying IDAT chunk data to alpha_blob.\");\n\n            (void) WriteBlobMSBULong(alpha_image,(size_t) length);\n            PNGType(data,mng_IDAT);\n            LogPNGChunk(logging,mng_IDAT,length);\n            (void) WriteBlob(alpha_image,4,data);\n            (void) WriteBlob(alpha_image,length,chunk);\n            (void) WriteBlobMSBULong(alpha_image,\n              crc32(crc32(0,data,4),chunk,(uInt) length));\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if ((memcmp(type,mng_JDAA,4) == 0) || (memcmp(type,mng_JdAA,4) == 0))\n      {\n        /* Copy chunk data to alpha_image->blob */\n\n        if ((alpha_image != NULL) && (image_info->ping == MagickFalse) &&\n            (length != 0))\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying JDAA chunk data to alpha_blob.\");\n\n            (void) WriteBlob(alpha_image,length,chunk);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_JSEP,4) == 0)\n      {\n        read_JSEP=MagickTrue;\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_bKGD,4) == 0)\n      {\n        if (length == 2)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=image->background_color.red;\n            image->background_color.blue=image->background_color.red;\n          }\n\n        if (length == 6)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=ScaleCharToQuantum(p[3]);\n            image->background_color.blue=ScaleCharToQuantum(p[5]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_gAMA,4) == 0)\n      {\n        if (length == 4)\n          image->gamma=((float) mng_get_long(p))*0.00001;\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_cHRM,4) == 0)\n      {\n        if (length == 32)\n          {\n            image->chromaticity.white_point.x=0.00001*mng_get_long(p);\n            image->chromaticity.white_point.y=0.00001*mng_get_long(&p[4]);\n            image->chromaticity.red_primary.x=0.00001*mng_get_long(&p[8]);\n            image->chromaticity.red_primary.y=0.00001*mng_get_long(&p[12]);\n            image->chromaticity.green_primary.x=0.00001*mng_get_long(&p[16]);\n            image->chromaticity.green_primary.y=0.00001*mng_get_long(&p[20]);\n            image->chromaticity.blue_primary.x=0.00001*mng_get_long(&p[24]);\n            image->chromaticity.blue_primary.y=0.00001*mng_get_long(&p[28]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_sRGB,4) == 0)\n      {\n        if (length == 1)\n          {\n            image->rendering_intent=\n              Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n            image->gamma=1.000f/2.200f;\n            image->chromaticity.red_primary.x=0.6400f;\n            image->chromaticity.red_primary.y=0.3300f;\n            image->chromaticity.green_primary.x=0.3000f;\n            image->chromaticity.green_primary.y=0.6000f;\n            image->chromaticity.blue_primary.x=0.1500f;\n            image->chromaticity.blue_primary.y=0.0600f;\n            image->chromaticity.white_point.x=0.3127f;\n            image->chromaticity.white_point.y=0.3290f;\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_oFFs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->page.x=(ssize_t) mng_get_long(p);\n            image->page.y=(ssize_t) mng_get_long(&p[4]);\n\n            if ((int) p[8] != 0)\n              {\n                image->page.x/=10000;\n                image->page.y/=10000;\n              }\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_pHYs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->resolution.x=(double) mng_get_long(p);\n            image->resolution.y=(double) mng_get_long(&p[4]);\n            if ((int) p[8] == PNG_RESOLUTION_METER)\n              {\n                image->units=PixelsPerCentimeterResolution;\n                image->resolution.x=image->resolution.x/100.0f;\n                image->resolution.y=image->resolution.y/100.0f;\n              }\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n#if 0\n    if (memcmp(type,mng_iCCP,4) == 0)\n      {\n        /* To do: */\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n#endif\n\n    chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n    if (memcmp(type,mng_IEND,4))\n      continue;\n\n    break;\n  }\n\n\n  /* IEND found */\n\n  /*\n    Finish up reading image data:\n\n       o read main image from color_blob.\n\n       o close color_blob.\n\n       o if (color_type has alpha)\n            if alpha_encoding is PNG\n               read secondary image from alpha_blob via ReadPNG\n            if alpha_encoding is JPEG\n               read secondary image from alpha_blob via ReadJPEG\n\n       o close alpha_blob.\n\n       o copy intensity of secondary image into\n         alpha samples of main image.\n\n       o destroy the secondary image.\n  */\n\n  if (color_image_info == (ImageInfo *) NULL)\n    {\n      assert(color_image == (Image *) NULL);\n      assert(alpha_image == (Image *) NULL);\n      if (color_image != (Image *) NULL)\n        color_image=DestroyImageList(color_image);\n      return(DestroyImageList(image));\n    }\n\n  if (color_image == (Image *) NULL)\n    {\n      assert(alpha_image == (Image *) NULL);\n      ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n    }\n\n  (void) SeekBlob(color_image,0,SEEK_SET);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Reading jng_image from color_blob.\");\n\n  assert(color_image_info != (ImageInfo *) NULL);\n  (void) FormatLocaleString(color_image_info->filename,MagickPathExtent,\n    \"jpeg:%s\",color_image->filename);\n\n  color_image_info->ping=MagickFalse;   /* To do: avoid this */\n  jng_image=ReadImage(color_image_info,exception);\n\n  (void) RelinquishUniqueFileResource(color_image->filename);\n  color_image=DestroyImage(color_image);\n  color_image_info=DestroyImageInfo(color_image_info);\n\n  if (jng_image == (Image *) NULL)\n  {\n    DestroyJNG(NULL,NULL,NULL,&alpha_image,&alpha_image_info);\n    return(DestroyImageList(image));\n  }\n\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Copying jng_image pixels to main image.\");\n\n  image->rows=jng_height;\n  image->columns=jng_width;\n\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    {\n      DestroyJNG(NULL,&color_image,&color_image_info,&alpha_image,\n        &alpha_image_info);\n      jng_image=DestroyImageList(jng_image);\n      return(DestroyImageList(image));\n    }\n  if ((image->columns != jng_image->columns) ||\n      (image->rows != jng_image->rows))\n    {\n      DestroyJNG(NULL,&color_image,&color_image_info,&alpha_image,\n        &alpha_image_info);\n      jng_image=DestroyImageList(jng_image);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    s=GetVirtualPixels(jng_image,0,y,image->columns,1,exception);\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if ((s == (const Quantum *)  NULL) || (q == (Quantum *) NULL))\n      break;\n    for (x=(ssize_t) image->columns; x != 0; x--)\n    {\n      SetPixelRed(image,GetPixelRed(jng_image,s),q);\n      SetPixelGreen(image,GetPixelGreen(jng_image,s),q);\n      SetPixelBlue(image,GetPixelBlue(jng_image,s),q);\n      q+=GetPixelChannels(image);\n      s+=GetPixelChannels(jng_image);\n    }\n\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n\n  jng_image=DestroyImage(jng_image);\n\n  if ((image_info->ping == MagickFalse) && (jng_color_type >= 12))\n    {\n      if (jng_alpha_compression_method == 0)\n        {\n          png_byte\n            data[5];\n          (void) WriteBlobMSBULong(alpha_image,0x00000000L);\n          PNGType(data,mng_IEND);\n          LogPNGChunk(logging,mng_IEND,0L);\n          (void) WriteBlob(alpha_image,4,data);\n          (void) WriteBlobMSBULong(alpha_image,crc32(0,data,4));\n        }\n\n      (void) CloseBlob(alpha_image);\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    Reading alpha from alpha_blob.\");\n\n      (void) FormatLocaleString(alpha_image_info->filename,MagickPathExtent,\n        \"%s\",alpha_image->filename);\n\n      jng_image=ReadImage(alpha_image_info,exception);\n\n      if (jng_image != (Image *) NULL)\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          s=GetVirtualPixels(jng_image,0,y,image->columns,1,exception);\n          q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n          if ((s == (const Quantum *)  NULL) || (q == (Quantum *) NULL))\n            break;\n\n          if (image->alpha_trait != UndefinedPixelTrait)\n            for (x=(ssize_t) image->columns; x != 0; x--)\n            {\n              SetPixelAlpha(image,GetPixelRed(jng_image,s),q);\n              q+=GetPixelChannels(image);\n              s+=GetPixelChannels(jng_image);\n            }\n\n          else\n            for (x=(ssize_t) image->columns; x != 0; x--)\n            {\n              SetPixelAlpha(image,GetPixelRed(jng_image,s),q);\n              if (GetPixelAlpha(image,q) != OpaqueAlpha)\n                image->alpha_trait=BlendPixelTrait;\n              q+=GetPixelChannels(image);\n              s+=GetPixelChannels(jng_image);\n            }\n\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n        }\n      (void) RelinquishUniqueFileResource(alpha_image->filename);\n      alpha_image=DestroyImage(alpha_image);\n      alpha_image_info=DestroyImageInfo(alpha_image_info);\n      if (jng_image != (Image *) NULL)\n        jng_image=DestroyImage(jng_image);\n    }\n\n  /* Read the JNG image.  */\n\n  if (mng_info->mng_type == 0)\n    {\n      mng_info->mng_width=jng_width;\n      mng_info->mng_height=jng_height;\n    }\n\n  if (image->page.width == 0 && image->page.height == 0)\n    {\n      image->page.width=jng_width;\n      image->page.height=jng_height;\n    }\n\n  if (image->page.x == 0 && image->page.y == 0)\n    {\n      image->page.x=mng_info->x_off[mng_info->object_id];\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  else\n    {\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  mng_info->image_found++;\n  status=SetImageProgress(image,LoadImagesTag,2*TellBlob(image),\n    2*GetBlobSize(image));\n\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneJNGImage()\");\n\n  return(image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -145,7 +145,11 @@\n         chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));\n \n         if (chunk == (unsigned char *) NULL)\n-          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+          {\n+            DestroyJNG(NULL,&color_image,&color_image_info,\n+              &alpha_image,&alpha_image_info);\n+            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+          }\n \n         for (i=0; i < (ssize_t) length; i++)\n         {\n@@ -172,13 +176,12 @@\n             jng_width=(png_uint_32)mng_get_long(p);\n             jng_height=(png_uint_32)mng_get_long(&p[4]);\n             if ((jng_width == 0) || (jng_height == 0))\n-            {\n-              DestroyJNG(chunk,&color_image,&color_image_info,\n-                &alpha_image,&alpha_image_info);\n-\n-              ThrowReaderException(CorruptImageError,\n-                \"NegativeOrZeroImageSize\");\n-            }\n+              {\n+                DestroyJNG(chunk,&color_image,&color_image_info,\n+                  &alpha_image,&alpha_image_info);\n+                ThrowReaderException(CorruptImageError,\n+                  \"NegativeOrZeroImageSize\");\n+              }\n             jng_color_type=p[8];\n             jng_image_sample_depth=p[9];\n             jng_image_compression_method=p[10];",
        "diff_line_info": {
            "deleted_lines": [
                "          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "            {",
                "              DestroyJNG(chunk,&color_image,&color_image_info,",
                "                &alpha_image,&alpha_image_info);",
                "",
                "              ThrowReaderException(CorruptImageError,",
                "                \"NegativeOrZeroImageSize\");",
                "            }"
            ],
            "added_lines": [
                "          {",
                "            DestroyJNG(NULL,&color_image,&color_image_info,",
                "              &alpha_image,&alpha_image_info);",
                "            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "          }",
                "              {",
                "                DestroyJNG(chunk,&color_image,&color_image_info,",
                "                  &alpha_image,&alpha_image_info);",
                "                ThrowReaderException(CorruptImageError,",
                "                  \"NegativeOrZeroImageSize\");",
                "              }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-16641",
        "func_name": "ImageMagick/TIFFWritePhotoshopLayers",
        "description": "ImageMagick 7.0.8-6 has a memory leak vulnerability in the TIFFWritePhotoshopLayers function in coders/tiff.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/256825d4eb33dc301496710d15cf5a7ae924088b",
        "commit_title": "Fixed possible memory leak reported in #1206",
        "commit_text": "",
        "func_before": "static MagickBooleanType TIFFWritePhotoshopLayers(Image* image,\n  const ImageInfo *image_info,EndianType endian,ExceptionInfo *exception)\n{\n  BlobInfo\n    *blob;\n\n  CustomStreamInfo\n    *custom_stream;\n\n  Image\n    *base_image,\n    *next;\n\n  ImageInfo\n    *clone_info;\n\n  MagickBooleanType\n    status;\n\n  PhotoshopProfile\n    profile;\n\n  PSDInfo\n    info;\n\n  StringInfo\n    *layers;\n\n  base_image=CloneImage(image,0,0,MagickFalse,exception);\n  if (base_image == (Image *) NULL)\n    return(MagickTrue);\n  clone_info=CloneImageInfo(image_info);\n  if (clone_info == (ImageInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  profile.offset=0;\n  profile.quantum=MagickMinBlobExtent;\n  layers=AcquireStringInfo(profile.quantum);\n  if (layers == (StringInfo *) NULL)\n    {\n      clone_info=DestroyImageInfo(clone_info);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  profile.data=layers;\n  profile.extent=layers->length;\n  custom_stream=TIFFAcquireCustomStreamForWriting(&profile,exception);\n  if (custom_stream == (CustomStreamInfo *) NULL)\n    {\n      clone_info=DestroyImageInfo(clone_info);\n      layers=DestroyStringInfo(layers);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  blob=CloneBlobInfo((BlobInfo *) NULL);\n  if (blob == (BlobInfo *) NULL)\n    {\n      clone_info=DestroyImageInfo(clone_info);\n      layers=DestroyStringInfo(layers);\n      custom_stream=DestroyCustomStreamInfo(custom_stream);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  DestroyBlob(base_image);\n  base_image->blob=blob;\n  next=base_image;\n  while (next != (Image *) NULL)\n    next=SyncNextImageInList(next);\n  AttachCustomStream(base_image->blob,custom_stream);\n  InitPSDInfo(image,&info);\n  base_image->endian=endian;\n  WriteBlobString(base_image,\"Adobe Photoshop Document Data Block\");\n  WriteBlobByte(base_image,0);\n  WriteBlobString(base_image,base_image->endian == LSBEndian ? \"MIB8ryaL\" :\n    \"8BIMLayr\");\n  status=WritePSDLayers(base_image,clone_info,&info,exception);\n  if (status != MagickFalse)\n    {\n      SetStringInfoLength(layers,(size_t) profile.offset);\n      status=SetImageProfile(image,\"tiff:37724\",layers,exception);\n    }\n  next=base_image;\n  while (next != (Image *) NULL)\n  {\n    CloseBlob(next);\n    next=next->next;\n  }\n  layers=DestroyStringInfo(layers);\n  clone_info=DestroyImageInfo(clone_info);\n  custom_stream=DestroyCustomStreamInfo(custom_stream);\n  return(status);\n}",
        "func": "static MagickBooleanType TIFFWritePhotoshopLayers(Image* image,\n  const ImageInfo *image_info,EndianType endian,ExceptionInfo *exception)\n{\n  BlobInfo\n    *blob;\n\n  CustomStreamInfo\n    *custom_stream;\n\n  Image\n    *base_image,\n    *next;\n\n  ImageInfo\n    *clone_info;\n\n  MagickBooleanType\n    status;\n\n  PhotoshopProfile\n    profile;\n\n  PSDInfo\n    info;\n\n  StringInfo\n    *layers;\n\n  base_image=CloneImage(image,0,0,MagickFalse,exception);\n  if (base_image == (Image *) NULL)\n    return(MagickTrue);\n  clone_info=CloneImageInfo(image_info);\n  if (clone_info == (ImageInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  profile.offset=0;\n  profile.quantum=MagickMinBlobExtent;\n  layers=AcquireStringInfo(profile.quantum);\n  if (layers == (StringInfo *) NULL)\n    {\n      base_image=DestroyImage(base_image);\n      clone_info=DestroyImageInfo(clone_info);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  profile.data=layers;\n  profile.extent=layers->length;\n  custom_stream=TIFFAcquireCustomStreamForWriting(&profile,exception);\n  if (custom_stream == (CustomStreamInfo *) NULL)\n    {\n      base_image=DestroyImage(base_image);\n      clone_info=DestroyImageInfo(clone_info);\n      layers=DestroyStringInfo(layers);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  blob=CloneBlobInfo((BlobInfo *) NULL);\n  if (blob == (BlobInfo *) NULL)\n    {\n      base_image=DestroyImage(base_image);\n      clone_info=DestroyImageInfo(clone_info);\n      layers=DestroyStringInfo(layers);\n      custom_stream=DestroyCustomStreamInfo(custom_stream);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  DestroyBlob(base_image);\n  base_image->blob=blob;\n  next=base_image;\n  while (next != (Image *) NULL)\n    next=SyncNextImageInList(next);\n  AttachCustomStream(base_image->blob,custom_stream);\n  InitPSDInfo(image,&info);\n  base_image->endian=endian;\n  WriteBlobString(base_image,\"Adobe Photoshop Document Data Block\");\n  WriteBlobByte(base_image,0);\n  WriteBlobString(base_image,base_image->endian == LSBEndian ? \"MIB8ryaL\" :\n    \"8BIMLayr\");\n  status=WritePSDLayers(base_image,clone_info,&info,exception);\n  if (status != MagickFalse)\n    {\n      SetStringInfoLength(layers,(size_t) profile.offset);\n      status=SetImageProfile(image,\"tiff:37724\",layers,exception);\n    }\n  next=base_image;\n  while (next != (Image *) NULL)\n  {\n    CloseBlob(next);\n    next=next->next;\n  }\n  layers=DestroyStringInfo(layers);\n  clone_info=DestroyImageInfo(clone_info);\n  custom_stream=DestroyCustomStreamInfo(custom_stream);\n  return(status);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -38,6 +38,7 @@\n   layers=AcquireStringInfo(profile.quantum);\n   if (layers == (StringInfo *) NULL)\n     {\n+      base_image=DestroyImage(base_image);\n       clone_info=DestroyImageInfo(clone_info);\n       ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n         image->filename);\n@@ -47,6 +48,7 @@\n   custom_stream=TIFFAcquireCustomStreamForWriting(&profile,exception);\n   if (custom_stream == (CustomStreamInfo *) NULL)\n     {\n+      base_image=DestroyImage(base_image);\n       clone_info=DestroyImageInfo(clone_info);\n       layers=DestroyStringInfo(layers);\n       ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n@@ -55,6 +57,7 @@\n   blob=CloneBlobInfo((BlobInfo *) NULL);\n   if (blob == (BlobInfo *) NULL)\n     {\n+      base_image=DestroyImage(base_image);\n       clone_info=DestroyImageInfo(clone_info);\n       layers=DestroyStringInfo(layers);\n       custom_stream=DestroyCustomStreamInfo(custom_stream);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      base_image=DestroyImage(base_image);",
                "      base_image=DestroyImage(base_image);",
                "      base_image=DestroyImage(base_image);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-16750",
        "func_name": "ImageMagick/formatIPTCfromBuffer",
        "description": "In ImageMagick 7.0.7-29 and earlier, a memory leak in the formatIPTCfromBuffer function in coders/meta.c was found.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/33d1b9590c401d4aee666ffd10b16868a38cf705",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1118",
        "commit_text": "",
        "func_before": "static int formatIPTCfromBuffer(Image *ofile, char *s, ssize_t len)\n{\n  char\n    temp[MagickPathExtent];\n\n  unsigned int\n    foundiptc,\n    tagsfound;\n\n  unsigned char\n    recnum,\n    dataset;\n\n  unsigned char\n    *readable,\n    *str;\n\n  ssize_t\n    tagindx,\n    taglen;\n\n  int\n    i,\n    tagcount = (int) (sizeof(tags) / sizeof(tag_spec));\n\n  int\n    c;\n\n  foundiptc = 0; /* found the IPTC-Header */\n  tagsfound = 0; /* number of tags found */\n\n  while (len > 0)\n  {\n    c = *s++; len--;\n    if (c == 0x1c)\n      foundiptc = 1;\n    else\n      {\n        if (foundiptc)\n          return -1;\n        else\n          continue;\n      }\n    /*\n      We found the 0x1c tag and now grab the dataset and record number tags.\n    */\n    c = *s++; len--;\n    if (len < 0) return -1;\n    dataset = (unsigned char) c;\n    c = *s++; len--;\n    if (len < 0) return -1;\n    recnum = (unsigned char) c;\n    /* try to match this record to one of the ones in our named table */\n    for (i=0; i< tagcount; i++)\n      if (tags[i].id == (short) recnum)\n        break;\n    if (i < tagcount)\n      readable=(unsigned char *) tags[i].name;\n    else\n      readable=(unsigned char *) \"\";\n    /*\n      We decode the length of the block that follows - ssize_t or short fmt.\n    */\n    c=(*s++);\n    len--;\n    if (len < 0)\n      return(-1);\n    if (c & (unsigned char) 0x80)\n      return(0);\n    else\n      {\n        s--;\n        len++;\n        taglen=readWordFromBuffer(&s, &len);\n      }\n    if (taglen < 0)\n      return(-1);\n    if (taglen > 65535)\n      return(-1);\n    /* make a buffer to hold the tag datand snag it from the input stream */\n    str=(unsigned char *) AcquireQuantumMemory((size_t) (taglen+MagickPathExtent),\n      sizeof(*str));\n    if (str == (unsigned char *) NULL)\n      printf(\"MemoryAllocationFailed\");\n    for (tagindx=0; tagindx<taglen; tagindx++)\n    {\n      c = *s++; len--;\n      if (len < 0)\n        return(-1);\n      str[tagindx]=(unsigned char) c;\n    }\n    str[taglen]=0;\n\n    /* now finish up by formatting this binary data into ASCII equivalent */\n    if (strlen((char *)readable) > 0)\n      (void) FormatLocaleString(temp,MagickPathExtent,\"%d#%d#%s=\",\n        (unsigned int) dataset,(unsigned int) recnum, readable);\n    else\n      (void) FormatLocaleString(temp,MagickPathExtent,\"%d#%d=\",\n        (unsigned int) dataset,(unsigned int) recnum);\n    (void) WriteBlobString(ofile,temp);\n    formatString( ofile, (char *)str, taglen );\n    str=(unsigned char *) RelinquishMagickMemory(str);\n\n    tagsfound++;\n  }\n  return ((int) tagsfound);\n}",
        "func": "static int formatIPTCfromBuffer(Image *ofile, char *s, ssize_t len)\n{\n  char\n    temp[MagickPathExtent];\n\n  unsigned int\n    foundiptc,\n    tagsfound;\n\n  unsigned char\n    recnum,\n    dataset;\n\n  unsigned char\n    *readable,\n    *str;\n\n  ssize_t\n    tagindx,\n    taglen;\n\n  int\n    i,\n    tagcount = (int) (sizeof(tags) / sizeof(tag_spec));\n\n  int\n    c;\n\n  foundiptc = 0; /* found the IPTC-Header */\n  tagsfound = 0; /* number of tags found */\n\n  while (len > 0)\n  {\n    c = *s++; len--;\n    if (c == 0x1c)\n      foundiptc = 1;\n    else\n      {\n        if (foundiptc)\n          return -1;\n        else\n          continue;\n      }\n    /*\n      We found the 0x1c tag and now grab the dataset and record number tags.\n    */\n    c = *s++; len--;\n    if (len < 0) return -1;\n    dataset = (unsigned char) c;\n    c = *s++; len--;\n    if (len < 0) return -1;\n    recnum = (unsigned char) c;\n    /* try to match this record to one of the ones in our named table */\n    for (i=0; i< tagcount; i++)\n      if (tags[i].id == (short) recnum)\n        break;\n    if (i < tagcount)\n      readable=(unsigned char *) tags[i].name;\n    else\n      readable=(unsigned char *) \"\";\n    /*\n      We decode the length of the block that follows - ssize_t or short fmt.\n    */\n    c=(*s++);\n    len--;\n    if (len < 0)\n      return(-1);\n    if (c & (unsigned char) 0x80)\n      return(0);\n    else\n      {\n        s--;\n        len++;\n        taglen=readWordFromBuffer(&s, &len);\n      }\n    if (taglen < 0)\n      return(-1);\n    if (taglen > 65535)\n      return(-1);\n    /* make a buffer to hold the tag datand snag it from the input stream */\n    str=(unsigned char *) AcquireQuantumMemory((size_t) (taglen+\n      MagickPathExtent),sizeof(*str));\n    if (str == (unsigned char *) NULL)\n      {\n        (void) printf(\"MemoryAllocationFailed\");\n        return 0;\n      }\n    for (tagindx=0; tagindx<taglen; tagindx++)\n    {\n      c = *s++; len--;\n      if (len < 0)\n        {\n          str=(unsigned char *) RelinquishMagickMemory(str);\n          return(-1);\n        }\n      str[tagindx]=(unsigned char) c;\n    }\n    str[taglen]=0;\n\n    /* now finish up by formatting this binary data into ASCII equivalent */\n    if (strlen((char *)readable) > 0)\n      (void) FormatLocaleString(temp,MagickPathExtent,\"%d#%d#%s=\",\n        (unsigned int) dataset,(unsigned int) recnum, readable);\n    else\n      (void) FormatLocaleString(temp,MagickPathExtent,\"%d#%d=\",\n        (unsigned int) dataset,(unsigned int) recnum);\n    (void) WriteBlobString(ofile,temp);\n    formatString( ofile, (char *)str, taglen );\n    str=(unsigned char *) RelinquishMagickMemory(str);\n\n    tagsfound++;\n  }\n  return ((int) tagsfound);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -78,15 +78,21 @@\n     if (taglen > 65535)\n       return(-1);\n     /* make a buffer to hold the tag datand snag it from the input stream */\n-    str=(unsigned char *) AcquireQuantumMemory((size_t) (taglen+MagickPathExtent),\n-      sizeof(*str));\n+    str=(unsigned char *) AcquireQuantumMemory((size_t) (taglen+\n+      MagickPathExtent),sizeof(*str));\n     if (str == (unsigned char *) NULL)\n-      printf(\"MemoryAllocationFailed\");\n+      {\n+        (void) printf(\"MemoryAllocationFailed\");\n+        return 0;\n+      }\n     for (tagindx=0; tagindx<taglen; tagindx++)\n     {\n       c = *s++; len--;\n       if (len < 0)\n-        return(-1);\n+        {\n+          str=(unsigned char *) RelinquishMagickMemory(str);\n+          return(-1);\n+        }\n       str[tagindx]=(unsigned char) c;\n     }\n     str[taglen]=0;",
        "diff_line_info": {
            "deleted_lines": [
                "    str=(unsigned char *) AcquireQuantumMemory((size_t) (taglen+MagickPathExtent),",
                "      sizeof(*str));",
                "      printf(\"MemoryAllocationFailed\");",
                "        return(-1);"
            ],
            "added_lines": [
                "    str=(unsigned char *) AcquireQuantumMemory((size_t) (taglen+",
                "      MagickPathExtent),sizeof(*str));",
                "      {",
                "        (void) printf(\"MemoryAllocationFailed\");",
                "        return 0;",
                "      }",
                "        {",
                "          str=(unsigned char *) RelinquishMagickMemory(str);",
                "          return(-1);",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-16750",
        "func_name": "ImageMagick/formatIPTC",
        "description": "In ImageMagick 7.0.7-29 and earlier, a memory leak in the formatIPTCfromBuffer function in coders/meta.c was found.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/33d1b9590c401d4aee666ffd10b16868a38cf705",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1118",
        "commit_text": "",
        "func_before": "static int formatIPTC(Image *ifile, Image *ofile)\n{\n  char\n    temp[MagickPathExtent];\n\n  unsigned int\n    foundiptc,\n    tagsfound;\n\n  unsigned char\n    recnum,\n    dataset;\n\n  unsigned char\n    *readable,\n    *str;\n\n  ssize_t\n    tagindx,\n    taglen;\n\n  int\n    i,\n    tagcount = (int) (sizeof(tags) / sizeof(tag_spec));\n\n  int\n    c;\n\n  foundiptc = 0; /* found the IPTC-Header */\n  tagsfound = 0; /* number of tags found */\n\n  c = ReadBlobByte(ifile);\n  while (c != EOF)\n  {\n    if (c == 0x1c)\n      foundiptc = 1;\n    else\n      {\n        if (foundiptc)\n          return(-1);\n        else\n          {\n            c=0;\n            continue;\n          }\n      }\n\n    /* we found the 0x1c tag and now grab the dataset and record number tags */\n    c = ReadBlobByte(ifile);\n    if (c == EOF)\n      return(-1);\n    dataset = (unsigned char) c;\n    c = ReadBlobByte(ifile);\n    if (c == EOF)\n      return(-1);\n    recnum = (unsigned char) c;\n    /* try to match this record to one of the ones in our named table */\n    for (i=0; i< tagcount; i++)\n    {\n      if (tags[i].id == (short) recnum)\n          break;\n    }\n    if (i < tagcount)\n      readable = (unsigned char *) tags[i].name;\n    else\n      readable = (unsigned char *) \"\";\n    /*\n      We decode the length of the block that follows - ssize_t or short fmt.\n    */\n    c=ReadBlobByte(ifile);\n    if (c == EOF)\n      return(-1);\n    if (c & (unsigned char) 0x80)\n      return(0);\n    else\n      {\n        int\n          c0;\n\n        c0=ReadBlobByte(ifile);\n        if (c0 == EOF)\n          return(-1);\n        taglen = (c << 8) | c0;\n      }\n    if (taglen < 0)\n      return(-1);\n    /* make a buffer to hold the tag datand snag it from the input stream */\n    str=(unsigned char *) AcquireQuantumMemory((size_t) (taglen+MagickPathExtent),\n      sizeof(*str));\n    if (str == (unsigned char *) NULL)\n      return(0);\n    for (tagindx=0; tagindx<taglen; tagindx++)\n    {\n      c=ReadBlobByte(ifile);\n      if (c == EOF)\n        {\n          str=(unsigned char *) RelinquishMagickMemory(str);\n          return(-1);\n        }\n      str[tagindx] = (unsigned char) c;\n    }\n    str[taglen] = 0;\n\n    /* now finish up by formatting this binary data into ASCII equivalent */\n    if (strlen((char *)readable) > 0)\n      (void) FormatLocaleString(temp,MagickPathExtent,\"%d#%d#%s=\",\n        (unsigned int) dataset, (unsigned int) recnum, readable);\n    else\n      (void) FormatLocaleString(temp,MagickPathExtent,\"%d#%d=\",\n        (unsigned int) dataset,(unsigned int) recnum);\n    (void) WriteBlobString(ofile,temp);\n    formatString( ofile, (char *)str, taglen );\n    str=(unsigned char *) RelinquishMagickMemory(str);\n\n    tagsfound++;\n\n    c=ReadBlobByte(ifile);\n  }\n  return((int) tagsfound);\n}",
        "func": "static int formatIPTC(Image *ifile, Image *ofile)\n{\n  char\n    temp[MagickPathExtent];\n\n  unsigned int\n    foundiptc,\n    tagsfound;\n\n  unsigned char\n    recnum,\n    dataset;\n\n  unsigned char\n    *readable,\n    *str;\n\n  ssize_t\n    tagindx,\n    taglen;\n\n  int\n    i,\n    tagcount = (int) (sizeof(tags) / sizeof(tag_spec));\n\n  int\n    c;\n\n  foundiptc = 0; /* found the IPTC-Header */\n  tagsfound = 0; /* number of tags found */\n\n  c = ReadBlobByte(ifile);\n  while (c != EOF)\n  {\n    if (c == 0x1c)\n      foundiptc = 1;\n    else\n      {\n        if (foundiptc)\n          return(-1);\n        else\n          {\n            c=0;\n            continue;\n          }\n      }\n\n    /* we found the 0x1c tag and now grab the dataset and record number tags */\n    c = ReadBlobByte(ifile);\n    if (c == EOF)\n      return(-1);\n    dataset = (unsigned char) c;\n    c = ReadBlobByte(ifile);\n    if (c == EOF)\n      return(-1);\n    recnum = (unsigned char) c;\n    /* try to match this record to one of the ones in our named table */\n    for (i=0; i< tagcount; i++)\n    {\n      if (tags[i].id == (short) recnum)\n          break;\n    }\n    if (i < tagcount)\n      readable = (unsigned char *) tags[i].name;\n    else\n      readable = (unsigned char *) \"\";\n    /*\n      We decode the length of the block that follows - ssize_t or short fmt.\n    */\n    c=ReadBlobByte(ifile);\n    if (c == EOF)\n      return(-1);\n    if (c & (unsigned char) 0x80)\n      return(0);\n    else\n      {\n        int\n          c0;\n\n        c0=ReadBlobByte(ifile);\n        if (c0 == EOF)\n          return(-1);\n        taglen = (c << 8) | c0;\n      }\n    if (taglen < 0)\n      return(-1);\n    /* make a buffer to hold the tag datand snag it from the input stream */\n    str=(unsigned char *) AcquireQuantumMemory((size_t) (taglen+\n      MagickPathExtent),sizeof(*str));\n    if (str == (unsigned char *) NULL)\n      return(0);\n    for (tagindx=0; tagindx<taglen; tagindx++)\n    {\n      c=ReadBlobByte(ifile);\n      if (c == EOF)\n        {\n          str=(unsigned char *) RelinquishMagickMemory(str);\n          return(-1);\n        }\n      str[tagindx] = (unsigned char) c;\n    }\n    str[taglen] = 0;\n\n    /* now finish up by formatting this binary data into ASCII equivalent */\n    if (strlen((char *)readable) > 0)\n      (void) FormatLocaleString(temp,MagickPathExtent,\"%d#%d#%s=\",\n        (unsigned int) dataset, (unsigned int) recnum, readable);\n    else\n      (void) FormatLocaleString(temp,MagickPathExtent,\"%d#%d=\",\n        (unsigned int) dataset,(unsigned int) recnum);\n    (void) WriteBlobString(ofile,temp);\n    formatString( ofile, (char *)str, taglen );\n    str=(unsigned char *) RelinquishMagickMemory(str);\n\n    tagsfound++;\n\n    c=ReadBlobByte(ifile);\n  }\n  return((int) tagsfound);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -85,8 +85,8 @@\n     if (taglen < 0)\n       return(-1);\n     /* make a buffer to hold the tag datand snag it from the input stream */\n-    str=(unsigned char *) AcquireQuantumMemory((size_t) (taglen+MagickPathExtent),\n-      sizeof(*str));\n+    str=(unsigned char *) AcquireQuantumMemory((size_t) (taglen+\n+      MagickPathExtent),sizeof(*str));\n     if (str == (unsigned char *) NULL)\n       return(0);\n     for (tagindx=0; tagindx<taglen; tagindx++)",
        "diff_line_info": {
            "deleted_lines": [
                "    str=(unsigned char *) AcquireQuantumMemory((size_t) (taglen+MagickPathExtent),",
                "      sizeof(*str));"
            ],
            "added_lines": [
                "    str=(unsigned char *) AcquireQuantumMemory((size_t) (taglen+",
                "      MagickPathExtent),sizeof(*str));"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-17965",
        "func_name": "ImageMagick/WriteSGIImage",
        "description": "ImageMagick 7.0.7-28 has a memory leak vulnerability in WriteSGIImage in coders/sgi.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/e92492afac23315358850e5e050144930049e9cb",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1052",
        "commit_text": "",
        "func_before": "static MagickBooleanType WriteSGIImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  CompressionType\n    compression;\n\n  const char\n    *value;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info;\n\n  SGIInfo\n    iris_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  ssize_t\n    y,\n    z;\n\n  unsigned char\n    *pixels,\n    *packets;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((image->columns > 65535UL) || (image->rows > 65535UL))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  scene=0;\n  do\n  {\n    /*\n      Initialize SGI raster file header.\n    */\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    (void) memset(&iris_info,0,sizeof(iris_info));\n    iris_info.magic=0x01DA;\n    compression=image->compression;\n    if (image_info->compression != UndefinedCompression)\n      compression=image_info->compression;\n    if (image->depth > 8)\n      compression=NoCompression;\n    if (compression == NoCompression)\n      iris_info.storage=(unsigned char) 0x00;\n    else\n      iris_info.storage=(unsigned char) 0x01;\n    iris_info.bytes_per_pixel=(unsigned char) (image->depth > 8 ? 2 : 1);\n    iris_info.dimension=3;\n    iris_info.columns=(unsigned short) image->columns;\n    iris_info.rows=(unsigned short) image->rows;\n    if (image->alpha_trait != UndefinedPixelTrait)\n      iris_info.depth=4;\n    else\n      {\n        if ((image_info->type != TrueColorType) &&\n            (SetImageGray(image,exception) != MagickFalse))\n          {\n            iris_info.dimension=2;\n            iris_info.depth=1;\n          }\n        else\n          iris_info.depth=3;\n      }\n    iris_info.minimum_value=0;\n    iris_info.maximum_value=(size_t) (image->depth <= 8 ?\n      1UL*ScaleQuantumToChar(QuantumRange) :\n      1UL*ScaleQuantumToShort(QuantumRange));\n    /*\n      Write SGI header.\n    */\n    (void) WriteBlobMSBShort(image,iris_info.magic);\n    (void) WriteBlobByte(image,iris_info.storage);\n    (void) WriteBlobByte(image,iris_info.bytes_per_pixel);\n    (void) WriteBlobMSBShort(image,iris_info.dimension);\n    (void) WriteBlobMSBShort(image,iris_info.columns);\n    (void) WriteBlobMSBShort(image,iris_info.rows);\n    (void) WriteBlobMSBShort(image,iris_info.depth);\n    (void) WriteBlobMSBLong(image,(unsigned int) iris_info.minimum_value);\n    (void) WriteBlobMSBLong(image,(unsigned int) iris_info.maximum_value);\n    (void) WriteBlobMSBLong(image,(unsigned int) iris_info.sans);\n    value=GetImageProperty(image,\"label\",exception);\n    if (value != (const char *) NULL)\n      (void) CopyMagickString(iris_info.name,value,sizeof(iris_info.name));\n    (void) WriteBlob(image,sizeof(iris_info.name),(unsigned char *)\n      iris_info.name);\n    (void) WriteBlobMSBLong(image,(unsigned int) iris_info.pixel_format);\n    (void) WriteBlob(image,sizeof(iris_info.filler),iris_info.filler);\n    /*\n      Allocate SGI pixels.\n    */\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    if ((4*iris_info.bytes_per_pixel*number_pixels) !=\n        ((MagickSizeType) (size_t) (4*iris_info.bytes_per_pixel*number_pixels)))\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixel_info=AcquireVirtualMemory((size_t) number_pixels,4*\n      iris_info.bytes_per_pixel*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    /*\n      Convert image pixels to uncompressed SGI pixels.\n    */\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      if (image->depth <= 8)\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          register unsigned char\n            *q;\n\n          q=(unsigned char *) pixels;\n          q+=((iris_info.rows-1)-y)*(4*iris_info.columns)+4*x;\n          *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n          *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n          *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n          *q++=ScaleQuantumToChar(GetPixelAlpha(image,p));\n          p+=GetPixelChannels(image);\n        }\n      else\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          register unsigned short\n            *q;\n\n          q=(unsigned short *) pixels;\n          q+=((iris_info.rows-1)-y)*(4*iris_info.columns)+4*x;\n          *q++=ScaleQuantumToShort(GetPixelRed(image,p));\n          *q++=ScaleQuantumToShort(GetPixelGreen(image,p));\n          *q++=ScaleQuantumToShort(GetPixelBlue(image,p));\n          *q++=ScaleQuantumToShort(GetPixelAlpha(image,p));\n          p+=GetPixelChannels(image);\n        }\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    switch (compression)\n    {\n      case NoCompression:\n      {\n        /*\n          Write uncompressed SGI pixels.\n        */\n        for (z=0; z < (ssize_t) iris_info.depth; z++)\n        {\n          for (y=0; y < (ssize_t) iris_info.rows; y++)\n          {\n            if (image->depth <= 8)\n              for (x=0; x < (ssize_t) iris_info.columns; x++)\n              {\n                register unsigned char\n                  *q;\n\n                q=(unsigned char *) pixels;\n                q+=y*(4*iris_info.columns)+4*x+z;\n                (void) WriteBlobByte(image,*q);\n              }\n            else\n              for (x=0; x < (ssize_t) iris_info.columns; x++)\n              {\n                register unsigned short\n                  *q;\n\n                q=(unsigned short *) pixels;\n                q+=y*(4*iris_info.columns)+4*x+z;\n                (void) WriteBlobMSBShort(image,*q);\n              }\n          }\n        }\n        break;\n      }\n      default:\n      {\n        MemoryInfo\n          *packet_info;\n\n        size_t\n          length,\n          number_packets,\n          *runlength;\n\n        ssize_t\n          offset,\n          *offsets;\n\n        /*\n          Convert SGI uncompressed pixels.\n        */\n        offsets=(ssize_t *) AcquireQuantumMemory(iris_info.rows,\n          iris_info.depth*sizeof(*offsets));\n        runlength=(size_t *) AcquireQuantumMemory(iris_info.rows,\n          iris_info.depth*sizeof(*runlength));\n        packet_info=AcquireVirtualMemory((2*(size_t) iris_info.columns+10)*\n          image->rows,4*sizeof(*packets));\n        if ((offsets == (ssize_t *) NULL) ||\n            (runlength == (size_t *) NULL) ||\n            (packet_info == (MemoryInfo *) NULL))\n          {\n            if (offsets != (ssize_t *) NULL)\n              offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n            if (runlength != (size_t *) NULL)\n              runlength=(size_t *) RelinquishMagickMemory(runlength);\n            if (packet_info != (MemoryInfo *) NULL)\n              packet_info=RelinquishVirtualMemory(packet_info);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        packets=(unsigned char *) GetVirtualMemoryBlob(packet_info);\n        offset=512+4*2*((ssize_t) iris_info.rows*iris_info.depth);\n        number_packets=0;\n        q=pixels;\n        for (y=0; y < (ssize_t) iris_info.rows; y++)\n        {\n          for (z=0; z < (ssize_t) iris_info.depth; z++)\n          {\n            length=SGIEncode(q+z,(size_t) iris_info.columns,packets+\n              number_packets);\n            number_packets+=length;\n            offsets[y+z*iris_info.rows]=offset;\n            runlength[y+z*iris_info.rows]=(size_t) length;\n            offset+=(ssize_t) length;\n          }\n          q+=(iris_info.columns*4);\n        }\n        /*\n          Write out line start and length tables and runlength-encoded pixels.\n        */\n        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)\n          (void) WriteBlobMSBLong(image,(unsigned int) offsets[i]);\n        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)\n          (void) WriteBlobMSBLong(image,(unsigned int) runlength[i]);\n        (void) WriteBlob(image,number_packets,packets);\n        /*\n          Relinquish resources.\n        */\n        offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n        runlength=(size_t *) RelinquishMagickMemory(runlength);\n        packet_info=RelinquishVirtualMemory(packet_info);\n        break;\n      }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
        "func": "static MagickBooleanType WriteSGIImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  CompressionType\n    compression;\n\n  const char\n    *value;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  MagickSizeType\n    number_pixels;\n\n  MemoryInfo\n    *pixel_info;\n\n  SGIInfo\n    iris_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  ssize_t\n    y,\n    z;\n\n  unsigned char\n    *pixels,\n    *packets;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((image->columns > 65535UL) || (image->rows > 65535UL))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  scene=0;\n  do\n  {\n    /*\n      Initialize SGI raster file header.\n    */\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    (void) memset(&iris_info,0,sizeof(iris_info));\n    iris_info.magic=0x01DA;\n    compression=image->compression;\n    if (image_info->compression != UndefinedCompression)\n      compression=image_info->compression;\n    if (image->depth > 8)\n      compression=NoCompression;\n    if (compression == NoCompression)\n      iris_info.storage=(unsigned char) 0x00;\n    else\n      iris_info.storage=(unsigned char) 0x01;\n    iris_info.bytes_per_pixel=(unsigned char) (image->depth > 8 ? 2 : 1);\n    iris_info.dimension=3;\n    iris_info.columns=(unsigned short) image->columns;\n    iris_info.rows=(unsigned short) image->rows;\n    if (image->alpha_trait != UndefinedPixelTrait)\n      iris_info.depth=4;\n    else\n      {\n        if ((image_info->type != TrueColorType) &&\n            (SetImageGray(image,exception) != MagickFalse))\n          {\n            iris_info.dimension=2;\n            iris_info.depth=1;\n          }\n        else\n          iris_info.depth=3;\n      }\n    iris_info.minimum_value=0;\n    iris_info.maximum_value=(size_t) (image->depth <= 8 ?\n      1UL*ScaleQuantumToChar(QuantumRange) :\n      1UL*ScaleQuantumToShort(QuantumRange));\n    /*\n      Write SGI header.\n    */\n    (void) WriteBlobMSBShort(image,iris_info.magic);\n    (void) WriteBlobByte(image,iris_info.storage);\n    (void) WriteBlobByte(image,iris_info.bytes_per_pixel);\n    (void) WriteBlobMSBShort(image,iris_info.dimension);\n    (void) WriteBlobMSBShort(image,iris_info.columns);\n    (void) WriteBlobMSBShort(image,iris_info.rows);\n    (void) WriteBlobMSBShort(image,iris_info.depth);\n    (void) WriteBlobMSBLong(image,(unsigned int) iris_info.minimum_value);\n    (void) WriteBlobMSBLong(image,(unsigned int) iris_info.maximum_value);\n    (void) WriteBlobMSBLong(image,(unsigned int) iris_info.sans);\n    value=GetImageProperty(image,\"label\",exception);\n    if (value != (const char *) NULL)\n      (void) CopyMagickString(iris_info.name,value,sizeof(iris_info.name));\n    (void) WriteBlob(image,sizeof(iris_info.name),(unsigned char *)\n      iris_info.name);\n    (void) WriteBlobMSBLong(image,(unsigned int) iris_info.pixel_format);\n    (void) WriteBlob(image,sizeof(iris_info.filler),iris_info.filler);\n    /*\n      Allocate SGI pixels.\n    */\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    if ((4*iris_info.bytes_per_pixel*number_pixels) !=\n        ((MagickSizeType) (size_t) (4*iris_info.bytes_per_pixel*number_pixels)))\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixel_info=AcquireVirtualMemory((size_t) number_pixels,4*\n      iris_info.bytes_per_pixel*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    /*\n      Convert image pixels to uncompressed SGI pixels.\n    */\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      if (image->depth <= 8)\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          register unsigned char\n            *q;\n\n          q=(unsigned char *) pixels;\n          q+=((iris_info.rows-1)-y)*(4*iris_info.columns)+4*x;\n          *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n          *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n          *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n          *q++=ScaleQuantumToChar(GetPixelAlpha(image,p));\n          p+=GetPixelChannels(image);\n        }\n      else\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          register unsigned short\n            *q;\n\n          q=(unsigned short *) pixels;\n          q+=((iris_info.rows-1)-y)*(4*iris_info.columns)+4*x;\n          *q++=ScaleQuantumToShort(GetPixelRed(image,p));\n          *q++=ScaleQuantumToShort(GetPixelGreen(image,p));\n          *q++=ScaleQuantumToShort(GetPixelBlue(image,p));\n          *q++=ScaleQuantumToShort(GetPixelAlpha(image,p));\n          p+=GetPixelChannels(image);\n        }\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    switch (compression)\n    {\n      case NoCompression:\n      {\n        /*\n          Write uncompressed SGI pixels.\n        */\n        for (z=0; z < (ssize_t) iris_info.depth; z++)\n        {\n          for (y=0; y < (ssize_t) iris_info.rows; y++)\n          {\n            if (image->depth <= 8)\n              for (x=0; x < (ssize_t) iris_info.columns; x++)\n              {\n                register unsigned char\n                  *q;\n\n                q=(unsigned char *) pixels;\n                q+=y*(4*iris_info.columns)+4*x+z;\n                (void) WriteBlobByte(image,*q);\n              }\n            else\n              for (x=0; x < (ssize_t) iris_info.columns; x++)\n              {\n                register unsigned short\n                  *q;\n\n                q=(unsigned short *) pixels;\n                q+=y*(4*iris_info.columns)+4*x+z;\n                (void) WriteBlobMSBShort(image,*q);\n              }\n          }\n        }\n        break;\n      }\n      default:\n      {\n        MemoryInfo\n          *packet_info;\n\n        size_t\n          length,\n          number_packets,\n          *runlength;\n\n        ssize_t\n          offset,\n          *offsets;\n\n        /*\n          Convert SGI uncompressed pixels.\n        */\n        offsets=(ssize_t *) AcquireQuantumMemory(iris_info.rows,\n          iris_info.depth*sizeof(*offsets));\n        runlength=(size_t *) AcquireQuantumMemory(iris_info.rows,\n          iris_info.depth*sizeof(*runlength));\n        packet_info=AcquireVirtualMemory((2*(size_t) iris_info.columns+10)*\n          image->rows,4*sizeof(*packets));\n        if ((offsets == (ssize_t *) NULL) ||\n            (runlength == (size_t *) NULL) ||\n            (packet_info == (MemoryInfo *) NULL))\n          {\n            if (offsets != (ssize_t *) NULL)\n              offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n            if (runlength != (size_t *) NULL)\n              runlength=(size_t *) RelinquishMagickMemory(runlength);\n            if (packet_info != (MemoryInfo *) NULL)\n              packet_info=RelinquishVirtualMemory(packet_info);\n            pixel_info=RelinquishVirtualMemory(pixel_info);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        packets=(unsigned char *) GetVirtualMemoryBlob(packet_info);\n        offset=512+4*2*((ssize_t) iris_info.rows*iris_info.depth);\n        number_packets=0;\n        q=pixels;\n        for (y=0; y < (ssize_t) iris_info.rows; y++)\n        {\n          for (z=0; z < (ssize_t) iris_info.depth; z++)\n          {\n            length=SGIEncode(q+z,(size_t) iris_info.columns,packets+\n              number_packets);\n            number_packets+=length;\n            offsets[y+z*iris_info.rows]=offset;\n            runlength[y+z*iris_info.rows]=(size_t) length;\n            offset+=(ssize_t) length;\n          }\n          q+=(iris_info.columns*4);\n        }\n        /*\n          Write out line start and length tables and runlength-encoded pixels.\n        */\n        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)\n          (void) WriteBlobMSBLong(image,(unsigned int) offsets[i]);\n        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)\n          (void) WriteBlobMSBLong(image,(unsigned int) runlength[i]);\n        (void) WriteBlob(image,number_packets,packets);\n        /*\n          Relinquish resources.\n        */\n        offsets=(ssize_t *) RelinquishMagickMemory(offsets);\n        runlength=(size_t *) RelinquishMagickMemory(runlength);\n        packet_info=RelinquishVirtualMemory(packet_info);\n        break;\n      }\n    }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -239,6 +239,7 @@\n               runlength=(size_t *) RelinquishMagickMemory(runlength);\n             if (packet_info != (MemoryInfo *) NULL)\n               packet_info=RelinquishVirtualMemory(packet_info);\n+            pixel_info=RelinquishVirtualMemory(pixel_info);\n             ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n           }\n         packets=(unsigned char *) GetVirtualMemoryBlob(packet_info);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            pixel_info=RelinquishVirtualMemory(pixel_info);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-17966",
        "func_name": "ImageMagick/WritePDBImage",
        "description": "ImageMagick 7.0.7-28 has a memory leak vulnerability in WritePDBImage in coders/pdb.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/11fb9ec5b9ee4491c90e6b959e4017bd85ce9e17",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1050",
        "commit_text": "",
        "func_before": "static MagickBooleanType WritePDBImage(const ImageInfo *image_info,Image *image)\n{\n  const char\n    *comment;\n\n  int\n    bits;\n\n  MagickBooleanType\n    status;\n\n  PDBImage\n    pdb_image;\n\n  PDBInfo\n    pdb_info;\n\n  QuantumInfo\n    *quantum_info;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bits_per_pixel,\n    literal,\n    packets,\n    packet_size,\n    repeat;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *buffer,\n    *runlength,\n    *scanline;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  if ((image -> colors <= 2 ) ||\n      (GetImageType(image,&image->exception ) == BilevelType)) {\n    bits_per_pixel=1;\n  } else if (image->colors <= 4) {\n    bits_per_pixel=2;\n  } else if (image->colors <= 8) {\n    bits_per_pixel=3;\n  } else {\n    bits_per_pixel=4;\n  }\n  (void) memset(&pdb_info,0,sizeof(pdb_info));\n  (void) memset(&pdb_image,0,sizeof(pdb_image));\n  (void) CopyMagickString(pdb_info.name,image_info->filename,\n    sizeof(pdb_info.name));\n  pdb_info.attributes=0;\n  pdb_info.version=0;\n  pdb_info.create_time=time(NULL);\n  pdb_info.modify_time=pdb_info.create_time;\n  pdb_info.archive_time=0;\n  pdb_info.modify_number=0;\n  pdb_info.application_info=0;\n  pdb_info.sort_info=0;\n  (void) memcpy(pdb_info.type,\"vIMG\",4);\n  (void) memcpy(pdb_info.id,\"View\",4);\n  pdb_info.seed=0;\n  pdb_info.next_record=0;\n  comment=GetImageProperty(image,\"comment\");\n  pdb_info.number_records=(comment == (const char *) NULL ? 1 : 2);\n  (void) WriteBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.attributes);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.version);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.create_time);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.modify_time);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.archive_time);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.modify_number);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.application_info);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.sort_info);\n  (void) WriteBlob(image,4,(unsigned char *) pdb_info.type);\n  (void) WriteBlob(image,4,(unsigned char *) pdb_info.id);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.seed);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.next_record);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.number_records);\n  (void) CopyMagickString(pdb_image.name,pdb_info.name,sizeof(pdb_image.name));\n  pdb_image.version=1;  /* RLE Compressed */\n  switch (bits_per_pixel)\n  {\n    case 1: pdb_image.type=(unsigned char) 0xff; break;  /* monochrome */\n    case 2: pdb_image.type=(unsigned char) 0x00; break;  /* 2 bit gray */\n    default: pdb_image.type=(unsigned char) 0x02;  /* 4 bit gray */\n  }\n  pdb_image.reserved_1=0;\n  pdb_image.note=0;\n  pdb_image.x_last=0;\n  pdb_image.y_last=0;\n  pdb_image.reserved_2=0;\n  pdb_image.x_anchor=(unsigned short) 0xffff;\n  pdb_image.y_anchor=(unsigned short) 0xffff;\n  pdb_image.width=(short) image->columns;\n  if (image->columns % 16)\n    pdb_image.width=(short) (16*(image->columns/16+1));\n  pdb_image.height=(short) image->rows;\n  packets=((bits_per_pixel*image->columns+7)/8);\n  packet_size=(size_t) (image->depth > 8 ? 2 : 1);\n  runlength=(unsigned char *) AcquireQuantumMemory(9UL*packets,\n    image->rows*sizeof(*runlength));\n  buffer=(unsigned char *) AcquireQuantumMemory(512,sizeof(*buffer));\n  scanline=(unsigned char *) AcquireQuantumMemory(image->columns,packet_size*\n    sizeof(*scanline));\n  if ((runlength == (unsigned char *) NULL) ||\n      (buffer == (unsigned char *) NULL) ||\n      (scanline == (unsigned char *) NULL))\n    {\n      if (runlength != (unsigned char *) NULL)\n        runlength=(unsigned char *) RelinquishMagickMemory(runlength);\n      if (buffer != (unsigned char *) NULL)\n        buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n      if (scanline != (unsigned char *) NULL)\n        scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  (void) ResetMagickMemory(buffer,0,512*sizeof(*buffer));\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace);\n  /*\n    Convert to GRAY raster scanline.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  status=SetQuantumDepth(image,quantum_info,image->depth > 8 ? 16 : 8);\n  bits=8/(int) bits_per_pixel-1;  /* start at most significant bits */\n  literal=0;\n  repeat=0;\n  q=runlength;\n  buffer[0]=0x00;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    (void) ExportQuantumPixels(image,(const CacheView *) NULL,quantum_info,\n      GrayQuantum,scanline,&image->exception);\n    for (x=0; x < (ssize_t) pdb_image.width; x++)\n    {\n      if (x < (ssize_t) image->columns)\n        buffer[literal+repeat]|=(0xff-scanline[x*packet_size]) >>\n          (8-bits_per_pixel) << bits*bits_per_pixel;\n      bits--;\n      if (bits < 0)\n        {\n          if (((literal+repeat) > 0) &&\n              (buffer[literal+repeat] == buffer[literal+repeat-1]))\n            {\n              if (repeat == 0)\n                {\n                  literal--;\n                  repeat++;\n                }\n              repeat++;\n              if (0x7f < repeat)\n                {\n                  q=EncodeRLE(q,buffer,literal,repeat);\n                  literal=0;\n                  repeat=0;\n                }\n            }\n          else\n            {\n              if (repeat >= 2)\n                literal+=repeat;\n              else\n                {\n                  q=EncodeRLE(q,buffer,literal,repeat);\n                  buffer[0]=buffer[literal+repeat];\n                  literal=0;\n                }\n              literal++;\n              repeat=0;\n              if (0x7f < literal)\n                {\n                  q=EncodeRLE(q,buffer,(literal < 0x80 ? literal : 0x80),0);\n                  (void) memmove(buffer,buffer+literal+repeat,0x80);\n                  literal-=0x80;\n                }\n            }\n        bits=8/(int) bits_per_pixel-1;\n        buffer[literal+repeat]=0x00;\n      }\n    }\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  q=EncodeRLE(q,buffer,literal,repeat);\n  scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  /*\n    Write the Image record header.\n  */\n  (void) WriteBlobMSBLong(image,(unsigned int) (TellBlob(image)+8*\n    pdb_info.number_records));\n  (void) WriteBlobByte(image,0x40);\n  (void) WriteBlobByte(image,0x6f);\n  (void) WriteBlobByte(image,0x80);\n  (void) WriteBlobByte(image,0);\n  if (pdb_info.number_records > 1)\n    {\n      /*\n        Write the comment record header.\n      */\n      (void) WriteBlobMSBLong(image,(unsigned int) (TellBlob(image)+8+58+q-\n        runlength));\n      (void) WriteBlobByte(image,0x40);\n      (void) WriteBlobByte(image,0x6f);\n      (void) WriteBlobByte(image,0x80);\n      (void) WriteBlobByte(image,1);\n    }\n  /*\n    Write the Image data.\n  */\n  (void) WriteBlob(image,sizeof(pdb_image.name),(unsigned char *)\n    pdb_image.name);\n  (void) WriteBlobByte(image,(unsigned char) pdb_image.version);\n  (void) WriteBlobByte(image,pdb_image.type);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.reserved_1);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.note);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.x_last);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.y_last);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.reserved_2);\n  (void) WriteBlobMSBShort(image,pdb_image.x_anchor);\n  (void) WriteBlobMSBShort(image,pdb_image.y_anchor);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.width);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.height);\n  (void) WriteBlob(image,(size_t) (q-runlength),runlength);\n  runlength=(unsigned char *) RelinquishMagickMemory(runlength);\n  if (pdb_info.number_records > 1)\n    (void) WriteBlobString(image,comment);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
        "func": "static MagickBooleanType WritePDBImage(const ImageInfo *image_info,Image *image)\n{\n  const char\n    *comment;\n\n  int\n    bits;\n\n  MagickBooleanType\n    status;\n\n  PDBImage\n    pdb_image;\n\n  PDBInfo\n    pdb_info;\n\n  QuantumInfo\n    *quantum_info;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bits_per_pixel,\n    literal,\n    packets,\n    packet_size,\n    repeat;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *buffer,\n    *runlength,\n    *scanline;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  if ((image -> colors <= 2 ) ||\n      (GetImageType(image,&image->exception ) == BilevelType)) {\n    bits_per_pixel=1;\n  } else if (image->colors <= 4) {\n    bits_per_pixel=2;\n  } else if (image->colors <= 8) {\n    bits_per_pixel=3;\n  } else {\n    bits_per_pixel=4;\n  }\n  (void) memset(&pdb_info,0,sizeof(pdb_info));\n  (void) memset(&pdb_image,0,sizeof(pdb_image));\n  (void) CopyMagickString(pdb_info.name,image_info->filename,\n    sizeof(pdb_info.name));\n  pdb_info.attributes=0;\n  pdb_info.version=0;\n  pdb_info.create_time=time(NULL);\n  pdb_info.modify_time=pdb_info.create_time;\n  pdb_info.archive_time=0;\n  pdb_info.modify_number=0;\n  pdb_info.application_info=0;\n  pdb_info.sort_info=0;\n  (void) memcpy(pdb_info.type,\"vIMG\",4);\n  (void) memcpy(pdb_info.id,\"View\",4);\n  pdb_info.seed=0;\n  pdb_info.next_record=0;\n  comment=GetImageProperty(image,\"comment\");\n  pdb_info.number_records=(comment == (const char *) NULL ? 1 : 2);\n  (void) WriteBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.attributes);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.version);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.create_time);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.modify_time);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.archive_time);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.modify_number);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.application_info);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.sort_info);\n  (void) WriteBlob(image,4,(unsigned char *) pdb_info.type);\n  (void) WriteBlob(image,4,(unsigned char *) pdb_info.id);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.seed);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.next_record);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.number_records);\n  (void) CopyMagickString(pdb_image.name,pdb_info.name,sizeof(pdb_image.name));\n  pdb_image.version=1;  /* RLE Compressed */\n  switch (bits_per_pixel)\n  {\n    case 1: pdb_image.type=(unsigned char) 0xff; break;  /* monochrome */\n    case 2: pdb_image.type=(unsigned char) 0x00; break;  /* 2 bit gray */\n    default: pdb_image.type=(unsigned char) 0x02;  /* 4 bit gray */\n  }\n  pdb_image.reserved_1=0;\n  pdb_image.note=0;\n  pdb_image.x_last=0;\n  pdb_image.y_last=0;\n  pdb_image.reserved_2=0;\n  pdb_image.x_anchor=(unsigned short) 0xffff;\n  pdb_image.y_anchor=(unsigned short) 0xffff;\n  pdb_image.width=(short) image->columns;\n  if (image->columns % 16)\n    pdb_image.width=(short) (16*(image->columns/16+1));\n  pdb_image.height=(short) image->rows;\n  packets=((bits_per_pixel*image->columns+7)/8);\n  packet_size=(size_t) (image->depth > 8 ? 2 : 1);\n  runlength=(unsigned char *) AcquireQuantumMemory(9UL*packets,\n    image->rows*sizeof(*runlength));\n  buffer=(unsigned char *) AcquireQuantumMemory(512,sizeof(*buffer));\n  scanline=(unsigned char *) AcquireQuantumMemory(image->columns,packet_size*\n    sizeof(*scanline));\n  if ((runlength == (unsigned char *) NULL) ||\n      (buffer == (unsigned char *) NULL) ||\n      (scanline == (unsigned char *) NULL))\n    {\n      if (runlength != (unsigned char *) NULL)\n        runlength=(unsigned char *) RelinquishMagickMemory(runlength);\n      if (buffer != (unsigned char *) NULL)\n        buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n      if (scanline != (unsigned char *) NULL)\n        scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  (void) ResetMagickMemory(buffer,0,512*sizeof(*buffer));\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    (void) TransformImageColorspace(image,sRGBColorspace);\n  /*\n    Convert to GRAY raster scanline.\n  */\n  quantum_info=AcquireQuantumInfo(image_info,image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    {\n      runlength=(unsigned char *) RelinquishMagickMemory(runlength);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  status=SetQuantumDepth(image,quantum_info,image->depth > 8 ? 16 : 8);\n  bits=8/(int) bits_per_pixel-1;  /* start at most significant bits */\n  literal=0;\n  repeat=0;\n  q=runlength;\n  buffer[0]=0x00;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    (void) ExportQuantumPixels(image,(const CacheView *) NULL,quantum_info,\n      GrayQuantum,scanline,&image->exception);\n    for (x=0; x < (ssize_t) pdb_image.width; x++)\n    {\n      if (x < (ssize_t) image->columns)\n        buffer[literal+repeat]|=(0xff-scanline[x*packet_size]) >>\n          (8-bits_per_pixel) << bits*bits_per_pixel;\n      bits--;\n      if (bits < 0)\n        {\n          if (((literal+repeat) > 0) &&\n              (buffer[literal+repeat] == buffer[literal+repeat-1]))\n            {\n              if (repeat == 0)\n                {\n                  literal--;\n                  repeat++;\n                }\n              repeat++;\n              if (0x7f < repeat)\n                {\n                  q=EncodeRLE(q,buffer,literal,repeat);\n                  literal=0;\n                  repeat=0;\n                }\n            }\n          else\n            {\n              if (repeat >= 2)\n                literal+=repeat;\n              else\n                {\n                  q=EncodeRLE(q,buffer,literal,repeat);\n                  buffer[0]=buffer[literal+repeat];\n                  literal=0;\n                }\n              literal++;\n              repeat=0;\n              if (0x7f < literal)\n                {\n                  q=EncodeRLE(q,buffer,(literal < 0x80 ? literal : 0x80),0);\n                  (void) memmove(buffer,buffer+literal+repeat,0x80);\n                  literal-=0x80;\n                }\n            }\n        bits=8/(int) bits_per_pixel-1;\n        buffer[literal+repeat]=0x00;\n      }\n    }\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  q=EncodeRLE(q,buffer,literal,repeat);\n  scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  /*\n    Write the Image record header.\n  */\n  (void) WriteBlobMSBLong(image,(unsigned int) (TellBlob(image)+8*\n    pdb_info.number_records));\n  (void) WriteBlobByte(image,0x40);\n  (void) WriteBlobByte(image,0x6f);\n  (void) WriteBlobByte(image,0x80);\n  (void) WriteBlobByte(image,0);\n  if (pdb_info.number_records > 1)\n    {\n      /*\n        Write the comment record header.\n      */\n      (void) WriteBlobMSBLong(image,(unsigned int) (TellBlob(image)+8+58+q-\n        runlength));\n      (void) WriteBlobByte(image,0x40);\n      (void) WriteBlobByte(image,0x6f);\n      (void) WriteBlobByte(image,0x80);\n      (void) WriteBlobByte(image,1);\n    }\n  /*\n    Write the Image data.\n  */\n  (void) WriteBlob(image,sizeof(pdb_image.name),(unsigned char *)\n    pdb_image.name);\n  (void) WriteBlobByte(image,(unsigned char) pdb_image.version);\n  (void) WriteBlobByte(image,pdb_image.type);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.reserved_1);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.note);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.x_last);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.y_last);\n  (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.reserved_2);\n  (void) WriteBlobMSBShort(image,pdb_image.x_anchor);\n  (void) WriteBlobMSBShort(image,pdb_image.y_anchor);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.width);\n  (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.height);\n  (void) WriteBlob(image,(size_t) (q-runlength),runlength);\n  runlength=(unsigned char *) RelinquishMagickMemory(runlength);\n  if (pdb_info.number_records > 1)\n    (void) WriteBlobString(image,comment);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -143,7 +143,10 @@\n   */\n   quantum_info=AcquireQuantumInfo(image_info,image);\n   if (quantum_info == (QuantumInfo *) NULL)\n-    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n+    {\n+      runlength=(unsigned char *) RelinquishMagickMemory(runlength);\n+      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n+    }\n   status=SetQuantumDepth(image,quantum_info,image->depth > 8 ? 16 : 8);\n   bits=8/(int) bits_per_pixel-1;  /* start at most significant bits */\n   literal=0;",
        "diff_line_info": {
            "deleted_lines": [
                "    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");"
            ],
            "added_lines": [
                "    {",
                "      runlength=(unsigned char *) RelinquishMagickMemory(runlength);",
                "      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-18016",
        "func_name": "ImageMagick/WritePCXImage",
        "description": "ImageMagick 7.0.7-28 has a memory leak vulnerability in WritePCXImage in coders/pcx.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/df8a62fe4938aa41a39e815937c58bc0ed21b664",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1049",
        "commit_text": "",
        "func_before": "static MagickBooleanType WritePCXImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    *page_table,\n    scene;\n\n  MemoryInfo\n    *pixel_info;\n\n  PCXInfo\n    pcx_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pcx_colormap,\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if ((image->columns > 65535UL) || (image->rows > 65535UL))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  page_table=(MagickOffsetType *) NULL;\n  if ((LocaleCompare(image_info->magick,\"DCX\") == 0) ||\n      ((GetNextImageInList(image) != (Image *) NULL) &&\n       (image_info->adjoin != MagickFalse)))\n    {\n      /*\n        Write the DCX page table.\n      */\n      (void) WriteBlobLSBLong(image,0x3ADE68B1L);\n      page_table=(MagickOffsetType *) AcquireQuantumMemory(1024UL,\n        sizeof(*page_table));\n      if (page_table == (MagickOffsetType *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (scene=0; scene < 1024; scene++)\n        (void) WriteBlobLSBLong(image,0x00000000L);\n    }\n  scene=0;\n  do\n  {\n    if (page_table != (MagickOffsetType *) NULL)\n      page_table[scene]=TellBlob(image);\n    /*\n      Initialize PCX raster file header.\n    */\n    pcx_info.identifier=0x0a;\n    pcx_info.version=5;\n    pcx_info.encoding=image_info->compression == NoCompression ? 0 : 1;\n    pcx_info.bits_per_pixel=8;\n    if ((image->storage_class == PseudoClass) &&\n        (SetImageMonochrome(image,exception) != MagickFalse))\n      pcx_info.bits_per_pixel=1;\n    pcx_info.left=0;\n    pcx_info.top=0;\n    pcx_info.right=(unsigned short) (image->columns-1);\n    pcx_info.bottom=(unsigned short) (image->rows-1);\n    switch (image->units)\n    {\n      case UndefinedResolution:\n      case PixelsPerInchResolution:\n      default:\n      {\n        pcx_info.horizontal_resolution=(unsigned short) image->resolution.x;\n        pcx_info.vertical_resolution=(unsigned short) image->resolution.y;\n        break;\n      }\n      case PixelsPerCentimeterResolution:\n      {\n        pcx_info.horizontal_resolution=(unsigned short)\n          (2.54*image->resolution.x+0.5);\n        pcx_info.vertical_resolution=(unsigned short)\n          (2.54*image->resolution.y+0.5);\n        break;\n      }\n    }\n    pcx_info.reserved=0;\n    pcx_info.planes=1;\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        pcx_info.planes=3;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          pcx_info.planes++;\n      }\n    length=(((size_t) image->columns*pcx_info.bits_per_pixel+7)/8);\n    if (length > 65535UL)\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n    pcx_info.bytes_per_line=(unsigned short) length;\n    pcx_info.palette_info=1;\n    pcx_info.colormap_signature=0x0c;\n    /*\n      Write PCX header.\n    */\n    (void) WriteBlobByte(image,pcx_info.identifier);\n    (void) WriteBlobByte(image,pcx_info.version);\n    (void) WriteBlobByte(image,pcx_info.encoding);\n    (void) WriteBlobByte(image,pcx_info.bits_per_pixel);\n    (void) WriteBlobLSBShort(image,pcx_info.left);\n    (void) WriteBlobLSBShort(image,pcx_info.top);\n    (void) WriteBlobLSBShort(image,pcx_info.right);\n    (void) WriteBlobLSBShort(image,pcx_info.bottom);\n    (void) WriteBlobLSBShort(image,pcx_info.horizontal_resolution);\n    (void) WriteBlobLSBShort(image,pcx_info.vertical_resolution);\n    /*\n      Dump colormap to file.\n    */\n    pcx_colormap=(unsigned char *) AcquireQuantumMemory(256UL,\n      3*sizeof(*pcx_colormap));\n    if (pcx_colormap == (unsigned char *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) memset(pcx_colormap,0,3*256*sizeof(*pcx_colormap));\n    q=pcx_colormap;\n    if ((image->storage_class == PseudoClass) && (image->colors <= 256))\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        *q++=ScaleQuantumToChar(image->colormap[i].red);\n        *q++=ScaleQuantumToChar(image->colormap[i].green);\n        *q++=ScaleQuantumToChar(image->colormap[i].blue);\n      }\n    (void) WriteBlob(image,3*16,(const unsigned char *) pcx_colormap);\n    (void) WriteBlobByte(image,pcx_info.reserved);\n    (void) WriteBlobByte(image,pcx_info.planes);\n    (void) WriteBlobLSBShort(image,pcx_info.bytes_per_line);\n    (void) WriteBlobLSBShort(image,pcx_info.palette_info);\n    for (i=0; i < 58; i++)\n      (void) WriteBlobByte(image,'\\0');\n    length=(size_t) pcx_info.bytes_per_line;\n    pixel_info=AcquireVirtualMemory(length,pcx_info.planes*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      {\n        pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);\n        if (page_table != (MagickOffsetType *) NULL)\n          page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    q=pixels;\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        /*\n          Convert DirectClass image to PCX raster pixels.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=pixels;\n          for (i=0; i < pcx_info.planes; i++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            switch ((int) i)\n            {\n              case 0:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n              case 1:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n              case 2:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n              case 3:\n              default:\n              {\n                for (x=(ssize_t) pcx_info.bytes_per_line; x != 0; x--)\n                {\n                  *q++=ScaleQuantumToChar((Quantum) (GetPixelAlpha(image,p)));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n            }\n          }\n          if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      {\n        if (pcx_info.bits_per_pixel > 1)\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            q=pixels;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              *q++=(unsigned char) GetPixelIndex(image,p);\n              p+=GetPixelChannels(image);\n            }\n            if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                  y,image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        else\n          {\n            register unsigned char\n              bit,\n              byte;\n\n            /*\n              Convert PseudoClass image to a PCX monochrome image.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              bit=0;\n              byte=0;\n              q=pixels;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte<<=1;\n                if (GetPixelLuma(image,p) >= (QuantumRange/2.0))\n                  byte|=0x01;\n                bit++;\n                if (bit == 8)\n                  {\n                    *q++=byte;\n                    bit=0;\n                    byte=0;\n                  }\n                p+=GetPixelChannels(image);\n              }\n              if (bit != 0)\n                *q++=byte << (8-bit);\n              if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        (void) WriteBlobByte(image,pcx_info.colormap_signature);\n        (void) WriteBlob(image,3*256,pcx_colormap);\n      }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);\n    if (page_table == (MagickOffsetType *) NULL)\n      break;\n    if (scene >= 1023)\n      break;\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  if (page_table != (MagickOffsetType *) NULL)\n    {\n      /*\n        Write the DCX page table.\n      */\n      page_table[scene+1]=0;\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        {\n          page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n          ThrowWriterException(CorruptImageError,\"ImproperImageHeader\");\n        }\n      (void) WriteBlobLSBLong(image,0x3ADE68B1L);\n      for (i=0; i <= (ssize_t) scene; i++)\n        (void) WriteBlobLSBLong(image,(unsigned int) page_table[i]);\n      page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n    }\n  if (status == MagickFalse)\n    {\n      char\n        *message;\n\n      message=GetExceptionMessage(errno);\n      (void) ThrowMagickException(exception,GetMagickModule(),FileOpenError,\n        \"UnableToWriteFile\",\"`%s': %s\",image->filename,message);\n      message=DestroyString(message);\n    }\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
        "func": "static MagickBooleanType WritePCXImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    *page_table,\n    scene;\n\n  MemoryInfo\n    *pixel_info;\n\n  PCXInfo\n    pcx_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pcx_colormap,\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  if ((image->columns > 65535UL) || (image->rows > 65535UL))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  page_table=(MagickOffsetType *) NULL;\n  if ((LocaleCompare(image_info->magick,\"DCX\") == 0) ||\n      ((GetNextImageInList(image) != (Image *) NULL) &&\n       (image_info->adjoin != MagickFalse)))\n    {\n      /*\n        Write the DCX page table.\n      */\n      (void) WriteBlobLSBLong(image,0x3ADE68B1L);\n      page_table=(MagickOffsetType *) AcquireQuantumMemory(1024UL,\n        sizeof(*page_table));\n      if (page_table == (MagickOffsetType *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (scene=0; scene < 1024; scene++)\n        (void) WriteBlobLSBLong(image,0x00000000L);\n    }\n  scene=0;\n  do\n  {\n    if (page_table != (MagickOffsetType *) NULL)\n      page_table[scene]=TellBlob(image);\n    /*\n      Initialize PCX raster file header.\n    */\n    pcx_info.identifier=0x0a;\n    pcx_info.version=5;\n    pcx_info.encoding=image_info->compression == NoCompression ? 0 : 1;\n    pcx_info.bits_per_pixel=8;\n    if ((image->storage_class == PseudoClass) &&\n        (SetImageMonochrome(image,exception) != MagickFalse))\n      pcx_info.bits_per_pixel=1;\n    pcx_info.left=0;\n    pcx_info.top=0;\n    pcx_info.right=(unsigned short) (image->columns-1);\n    pcx_info.bottom=(unsigned short) (image->rows-1);\n    switch (image->units)\n    {\n      case UndefinedResolution:\n      case PixelsPerInchResolution:\n      default:\n      {\n        pcx_info.horizontal_resolution=(unsigned short) image->resolution.x;\n        pcx_info.vertical_resolution=(unsigned short) image->resolution.y;\n        break;\n      }\n      case PixelsPerCentimeterResolution:\n      {\n        pcx_info.horizontal_resolution=(unsigned short)\n          (2.54*image->resolution.x+0.5);\n        pcx_info.vertical_resolution=(unsigned short)\n          (2.54*image->resolution.y+0.5);\n        break;\n      }\n    }\n    pcx_info.reserved=0;\n    pcx_info.planes=1;\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        pcx_info.planes=3;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          pcx_info.planes++;\n      }\n    length=(((size_t) image->columns*pcx_info.bits_per_pixel+7)/8);\n    if (length > 65535UL)\n      ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n    pcx_info.bytes_per_line=(unsigned short) length;\n    pcx_info.palette_info=1;\n    pcx_info.colormap_signature=0x0c;\n    /*\n      Write PCX header.\n    */\n    (void) WriteBlobByte(image,pcx_info.identifier);\n    (void) WriteBlobByte(image,pcx_info.version);\n    (void) WriteBlobByte(image,pcx_info.encoding);\n    (void) WriteBlobByte(image,pcx_info.bits_per_pixel);\n    (void) WriteBlobLSBShort(image,pcx_info.left);\n    (void) WriteBlobLSBShort(image,pcx_info.top);\n    (void) WriteBlobLSBShort(image,pcx_info.right);\n    (void) WriteBlobLSBShort(image,pcx_info.bottom);\n    (void) WriteBlobLSBShort(image,pcx_info.horizontal_resolution);\n    (void) WriteBlobLSBShort(image,pcx_info.vertical_resolution);\n    /*\n      Dump colormap to file.\n    */\n    pcx_colormap=(unsigned char *) AcquireQuantumMemory(256UL,\n      3*sizeof(*pcx_colormap));\n    if (pcx_colormap == (unsigned char *) NULL)\n      {\n        if (page_table != (MagickOffsetType *) NULL)\n          page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    (void) memset(pcx_colormap,0,3*256*sizeof(*pcx_colormap));\n    q=pcx_colormap;\n    if ((image->storage_class == PseudoClass) && (image->colors <= 256))\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        *q++=ScaleQuantumToChar(image->colormap[i].red);\n        *q++=ScaleQuantumToChar(image->colormap[i].green);\n        *q++=ScaleQuantumToChar(image->colormap[i].blue);\n      }\n    (void) WriteBlob(image,3*16,(const unsigned char *) pcx_colormap);\n    (void) WriteBlobByte(image,pcx_info.reserved);\n    (void) WriteBlobByte(image,pcx_info.planes);\n    (void) WriteBlobLSBShort(image,pcx_info.bytes_per_line);\n    (void) WriteBlobLSBShort(image,pcx_info.palette_info);\n    for (i=0; i < 58; i++)\n      (void) WriteBlobByte(image,'\\0');\n    length=(size_t) pcx_info.bytes_per_line;\n    pixel_info=AcquireVirtualMemory(length,pcx_info.planes*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      {\n        pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);\n        if (page_table != (MagickOffsetType *) NULL)\n          page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    q=pixels;\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        /*\n          Convert DirectClass image to PCX raster pixels.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=pixels;\n          for (i=0; i < pcx_info.planes; i++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            switch ((int) i)\n            {\n              case 0:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n              case 1:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n              case 2:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n              case 3:\n              default:\n              {\n                for (x=(ssize_t) pcx_info.bytes_per_line; x != 0; x--)\n                {\n                  *q++=ScaleQuantumToChar((Quantum) (GetPixelAlpha(image,p)));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n            }\n          }\n          if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      {\n        if (pcx_info.bits_per_pixel > 1)\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            q=pixels;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              *q++=(unsigned char) GetPixelIndex(image,p);\n              p+=GetPixelChannels(image);\n            }\n            if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                  y,image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        else\n          {\n            register unsigned char\n              bit,\n              byte;\n\n            /*\n              Convert PseudoClass image to a PCX monochrome image.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              bit=0;\n              byte=0;\n              q=pixels;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte<<=1;\n                if (GetPixelLuma(image,p) >= (QuantumRange/2.0))\n                  byte|=0x01;\n                bit++;\n                if (bit == 8)\n                  {\n                    *q++=byte;\n                    bit=0;\n                    byte=0;\n                  }\n                p+=GetPixelChannels(image);\n              }\n              if (bit != 0)\n                *q++=byte << (8-bit);\n              if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        (void) WriteBlobByte(image,pcx_info.colormap_signature);\n        (void) WriteBlob(image,3*256,pcx_colormap);\n      }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);\n    if (page_table == (MagickOffsetType *) NULL)\n      break;\n    if (scene >= 1023)\n      break;\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  if (page_table != (MagickOffsetType *) NULL)\n    {\n      /*\n        Write the DCX page table.\n      */\n      page_table[scene+1]=0;\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        {\n          page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n          ThrowWriterException(CorruptImageError,\"ImproperImageHeader\");\n        }\n      (void) WriteBlobLSBLong(image,0x3ADE68B1L);\n      for (i=0; i <= (ssize_t) scene; i++)\n        (void) WriteBlobLSBLong(image,(unsigned int) page_table[i]);\n      page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n    }\n  if (status == MagickFalse)\n    {\n      char\n        *message;\n\n      message=GetExceptionMessage(errno);\n      (void) ThrowMagickException(exception,GetMagickModule(),FileOpenError,\n        \"UnableToWriteFile\",\"`%s': %s\",image->filename,message);\n      message=DestroyString(message);\n    }\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -139,7 +139,11 @@\n     pcx_colormap=(unsigned char *) AcquireQuantumMemory(256UL,\n       3*sizeof(*pcx_colormap));\n     if (pcx_colormap == (unsigned char *) NULL)\n-      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n+      {\n+        if (page_table != (MagickOffsetType *) NULL)\n+          page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n+        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n+      }\n     (void) memset(pcx_colormap,0,3*256*sizeof(*pcx_colormap));\n     q=pcx_colormap;\n     if ((image->storage_class == PseudoClass) && (image->colors <= 256))",
        "diff_line_info": {
            "deleted_lines": [
                "      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");"
            ],
            "added_lines": [
                "      {",
                "        if (page_table != (MagickOffsetType *) NULL)",
                "          page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);",
                "        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-18226",
        "func_name": "wireshark/steamdiscover_dissect_body_authrequest",
        "description": "In Wireshark 2.6.0 to 2.6.3, the Steam IHS Discovery dissector could consume system memory. This was addressed in epan/dissectors/packet-steam-ihs-discovery.c by changing the memory-management approach.",
        "git_url": "https://github.com/wireshark/wireshark/commit/6e920ddc3cad2886ef07ca1a8e50e2a5c50986f7",
        "commit_title": "steam-ihs: fix memleak on exception",
        "commit_text": " When protobuf_dissect_unknown_field throws an exception, steamdiscover_dissect_body_status will leak memory as wmem_destroy_allocator is not called. Capture fuzz-2018-10-06-3104.pcap from the linked bug leaks 64kiB memory in each frame 14 and 36.  Bug: 15171 (cherry picked from commit f3986c24728f03a346a10388fd6c15ea9ae16d41)",
        "func_before": "static void\nsteamdiscover_dissect_body_authrequest(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                       gint offset, gint bytes_left)\n{\n    guint len;\n    gint64 value;\n    protobuf_desc_t pb = { tvb, offset, bytes_left };\n    protobuf_tag_t tag = { 0, 0, 0 };\n    wmem_allocator_t *strpool;\n    strpool = wmem_allocator_new(WMEM_ALLOCATOR_SIMPLE);\n    guint8* devicename;\n    while (protobuf_iter_next(&pb, &tag)) {\n        switch(tag.field_number) {\n            case STEAMDISCOVER_FN_AUTHREQUEST_DEVICETOKEN:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_LENGTHDELIMITED);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_item(tree, hf_steam_ihs_discovery_body_authrequest_devicetoken, pb.tvb,\n                        pb.offset+len, (gint)value, ENC_NA);\n                len += (gint)value;\n                break;\n            case STEAMDISCOVER_FN_AUTHREQUEST_DEVICENAME:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_LENGTHDELIMITED);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_item(tree, hf_steam_ihs_discovery_body_authrequest_devicename, pb.tvb,\n                        pb.offset+len, (gint)value, ENC_UTF_8|ENC_NA);\n                devicename = tvb_get_string_enc(strpool, pb.tvb, pb.offset+len, (gint)value, ENC_UTF_8);\n                if (devicename && strlen(devicename)) {\n                    col_append_fstr(pinfo->cinfo, COL_INFO, \" from %s\", devicename);\n                }\n                len += (gint)value;\n                break;\n            case STEAMDISCOVER_FN_AUTHREQUEST_ENCRYPTEDREQUEST:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_LENGTHDELIMITED);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_item(tree, hf_steam_ihs_discovery_body_authrequest_encryptedrequest, pb.tvb,\n                        pb.offset+len, (gint)value, ENC_NA);\n                len += (gint)value;\n                break;\n            default:\n                len = protobuf_dissect_unknown_field(&pb, &tag, pinfo, tree, NULL);\n                break;\n        }\n        protobuf_seek_forward(&pb, len);\n    }\n    wmem_destroy_allocator(strpool);\n}",
        "func": "static void\nsteamdiscover_dissect_body_authrequest(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                       gint offset, gint bytes_left)\n{\n    guint len;\n    gint64 value;\n    protobuf_desc_t pb = { tvb, offset, bytes_left };\n    protobuf_tag_t tag = { 0, 0, 0 };\n    guint8* devicename;\n    while (protobuf_iter_next(&pb, &tag)) {\n        switch(tag.field_number) {\n            case STEAMDISCOVER_FN_AUTHREQUEST_DEVICETOKEN:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_LENGTHDELIMITED);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_item(tree, hf_steam_ihs_discovery_body_authrequest_devicetoken, pb.tvb,\n                        pb.offset+len, (gint)value, ENC_NA);\n                len += (gint)value;\n                break;\n            case STEAMDISCOVER_FN_AUTHREQUEST_DEVICENAME:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_LENGTHDELIMITED);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_item(tree, hf_steam_ihs_discovery_body_authrequest_devicename, pb.tvb,\n                        pb.offset+len, (gint)value, ENC_UTF_8|ENC_NA);\n                devicename = tvb_get_string_enc(wmem_packet_scope(), pb.tvb, pb.offset+len, (gint)value, ENC_UTF_8);\n                if (devicename && strlen(devicename)) {\n                    col_append_fstr(pinfo->cinfo, COL_INFO, \" from %s\", devicename);\n                }\n                len += (gint)value;\n                break;\n            case STEAMDISCOVER_FN_AUTHREQUEST_ENCRYPTEDREQUEST:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_LENGTHDELIMITED);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_item(tree, hf_steam_ihs_discovery_body_authrequest_encryptedrequest, pb.tvb,\n                        pb.offset+len, (gint)value, ENC_NA);\n                len += (gint)value;\n                break;\n            default:\n                len = protobuf_dissect_unknown_field(&pb, &tag, pinfo, tree, NULL);\n                break;\n        }\n        protobuf_seek_forward(&pb, len);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,8 +6,6 @@\n     gint64 value;\n     protobuf_desc_t pb = { tvb, offset, bytes_left };\n     protobuf_tag_t tag = { 0, 0, 0 };\n-    wmem_allocator_t *strpool;\n-    strpool = wmem_allocator_new(WMEM_ALLOCATOR_SIMPLE);\n     guint8* devicename;\n     while (protobuf_iter_next(&pb, &tag)) {\n         switch(tag.field_number) {\n@@ -23,7 +21,7 @@\n                 value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                 proto_tree_add_item(tree, hf_steam_ihs_discovery_body_authrequest_devicename, pb.tvb,\n                         pb.offset+len, (gint)value, ENC_UTF_8|ENC_NA);\n-                devicename = tvb_get_string_enc(strpool, pb.tvb, pb.offset+len, (gint)value, ENC_UTF_8);\n+                devicename = tvb_get_string_enc(wmem_packet_scope(), pb.tvb, pb.offset+len, (gint)value, ENC_UTF_8);\n                 if (devicename && strlen(devicename)) {\n                     col_append_fstr(pinfo->cinfo, COL_INFO, \" from %s\", devicename);\n                 }\n@@ -42,5 +40,4 @@\n         }\n         protobuf_seek_forward(&pb, len);\n     }\n-    wmem_destroy_allocator(strpool);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    wmem_allocator_t *strpool;",
                "    strpool = wmem_allocator_new(WMEM_ALLOCATOR_SIMPLE);",
                "                devicename = tvb_get_string_enc(strpool, pb.tvb, pb.offset+len, (gint)value, ENC_UTF_8);",
                "    wmem_destroy_allocator(strpool);"
            ],
            "added_lines": [
                "                devicename = tvb_get_string_enc(wmem_packet_scope(), pb.tvb, pb.offset+len, (gint)value, ENC_UTF_8);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-18226",
        "func_name": "wireshark/steamdiscover_dissect_body_status",
        "description": "In Wireshark 2.6.0 to 2.6.3, the Steam IHS Discovery dissector could consume system memory. This was addressed in epan/dissectors/packet-steam-ihs-discovery.c by changing the memory-management approach.",
        "git_url": "https://github.com/wireshark/wireshark/commit/6e920ddc3cad2886ef07ca1a8e50e2a5c50986f7",
        "commit_title": "steam-ihs: fix memleak on exception",
        "commit_text": " When protobuf_dissect_unknown_field throws an exception, steamdiscover_dissect_body_status will leak memory as wmem_destroy_allocator is not called. Capture fuzz-2018-10-06-3104.pcap from the linked bug leaks 64kiB memory in each frame 14 and 36.  Bug: 15171 (cherry picked from commit f3986c24728f03a346a10388fd6c15ea9ae16d41)",
        "func_before": "static void\nsteamdiscover_dissect_body_status(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                     gint offset, gint bytes_left)\n{\n    gint64 value;\n    gint len;\n    gint len2;\n    protobuf_desc_t pb = { tvb, offset, bytes_left };\n    protobuf_desc_t pb2 = { tvb, 0, 0 };\n    protobuf_tag_t tag = { 0, 0, 0 };\n    wmem_allocator_t* strpool;\n    guint8 *hostname;\n    strpool = wmem_allocator_new(WMEM_ALLOCATOR_SIMPLE);\n    nstime_t timestamp;\n    proto_tree *user_tree;\n    proto_item *user_it;\n    while (protobuf_iter_next(&pb, &tag)) {\n        switch(tag.field_number) {\n            case STEAMDISCOVER_FN_STATUS_VERSION:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_VARINT);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_int(tree, hf_steam_ihs_discovery_body_status_version, pb.tvb,\n                        pb.offset, len, (gint32)value);\n                break;\n            case STEAMDISCOVER_FN_STATUS_MINVERSION:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_VARINT);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_int(tree, hf_steam_ihs_discovery_body_status_minversion, pb.tvb,\n                        pb.offset, len, (gint32)value);\n                break;\n            case STEAMDISCOVER_FN_STATUS_CONNECTPORT:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_VARINT);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_uint(tree, hf_steam_ihs_discovery_body_status_connectport, pb.tvb,\n                        pb.offset, len, (guint32)value);\n                break;\n            case STEAMDISCOVER_FN_STATUS_HOSTNAME:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_LENGTHDELIMITED);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_item(tree, hf_steam_ihs_discovery_body_status_hostname, pb.tvb,\n                        pb.offset+len, (gint)value, ENC_UTF_8|ENC_NA);\n                hostname = tvb_get_string_enc(strpool, pb.tvb, pb.offset+len, (gint)value, ENC_UTF_8);\n                if(hostname && strlen(hostname)) {\n                    col_add_fstr(pinfo->cinfo, COL_INFO, \"%s from %s\", hf_steam_ihs_discovery_header_msgtype_strings[STEAMDISCOVER_MSGTYPE_CLIENTBROADCASTMSGSTATUS].strptr, hostname);\n                }\n                len += (gint)value;\n                break;\n            case STEAMDISCOVER_FN_STATUS_ENABLEDSERVICES:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_VARINT);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_uint(tree, hf_steam_ihs_discovery_body_status_enabledservices, pb.tvb,\n                        pb.offset, len, (guint32)value);\n                break;\n            case STEAMDISCOVER_FN_STATUS_OSTYPE:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_VARINT);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_int(tree, hf_steam_ihs_discovery_body_status_ostype, pb.tvb,\n                        pb.offset, len, (gint32)value);\n                break;\n            case STEAMDISCOVER_FN_STATUS_IS64BIT:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_VARINT);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_boolean(tree, hf_steam_ihs_discovery_body_status_is64bit, pb.tvb,\n                        pb.offset, len, (gint32)value);\n                break;\n            case STEAMDISCOVER_FN_STATUS_USERS:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_LENGTHDELIMITED);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                pb2.offset = pb.offset+len;\n                pb2.bytes_left = (gint)value;\n                len += (gint)value;\n                user_tree = proto_tree_add_subtree(tree, pb.tvb, pb.offset, len, ett_steam_ihs_discovery_body_status_user, &user_it, \"User\");\n                while (protobuf_iter_next(&pb2, &tag)) {\n                    switch(tag.field_number) {\n                        case STEAMDISCOVER_FN_STATUS_USER_STEAMID:\n                            if((len2 = protobuf_verify_wiretype(&pb2, &tag, pinfo, user_tree, PROTOBUF_WIRETYPE_64BIT))) break;\n                            len2 = 8;\n                            value = tvb_get_letoh64(pb2.tvb, pb2.offset);\n                            proto_tree_add_uint64(user_tree, hf_steam_ihs_discovery_body_status_user_steamid, pb2.tvb,\n                                    pb2.offset, len2, (guint64)value);\n                            proto_item_append_text(user_it, \", Steam ID: %\"G_GUINT64_FORMAT, (guint64)value);\n                            break;\n                        case STEAMDISCOVER_FN_STATUS_USER_AUTHKEYID:\n                            if((len2 = protobuf_verify_wiretype(&pb2, &tag, pinfo, user_tree, PROTOBUF_WIRETYPE_VARINT))) break;\n                            value = get_varint64(pb2.tvb, pb2.offset, pb2.bytes_left, &len2);\n                            proto_tree_add_uint(user_tree, hf_steam_ihs_discovery_body_status_user_authkeyid, pb2.tvb,\n                                    pb2.offset, len2, (guint32)value);\n                            proto_item_append_text(user_it, \", Auth Key ID: %\"G_GUINT32_FORMAT, (guint32)value);\n                            break;\n                        default:\n                            len2 = protobuf_dissect_unknown_field(&pb2, &tag, pinfo, tree, NULL);\n                            break;\n                    }\n                    protobuf_seek_forward(&pb2, len2);\n                }\n                break;\n            case STEAMDISCOVER_FN_STATUS_EUNIVERSE:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_VARINT);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_int(tree, hf_steam_ihs_discovery_body_status_euniverse, pb.tvb,\n                        pb.offset, len, (gint32)value);\n                break;\n            case STEAMDISCOVER_FN_STATUS_TIMESTAMP:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_VARINT);\n                timestamp.secs = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                timestamp.nsecs = 0;\n                proto_tree_add_time(tree, hf_steam_ihs_discovery_body_status_timestamp, pb.tvb,\n                        pb.offset, len, &timestamp);\n                break;\n            case STEAMDISCOVER_FN_STATUS_SCREENLOCKED:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_VARINT);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_boolean(tree, hf_steam_ihs_discovery_body_status_screenlocked, pb.tvb,\n                        pb.offset, len, (gint32)value);\n                break;\n            case STEAMDISCOVER_FN_STATUS_GAMESRUNNING:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_VARINT);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_boolean(tree, hf_steam_ihs_discovery_body_status_gamesrunning, pb.tvb,\n                        pb.offset, len, (gint32)value);\n                break;\n            case STEAMDISCOVER_FN_STATUS_MACADDRESSES:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_LENGTHDELIMITED);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_item(tree, hf_steam_ihs_discovery_body_status_macaddresses, pb.tvb,\n                        pb.offset+len, (gint)value, ENC_UTF_8|ENC_NA);\n                len += (gint)value;\n                break;\n            default:\n                len = protobuf_dissect_unknown_field(&pb, &tag, pinfo, tree, NULL);\n                break;\n        }\n        protobuf_seek_forward(&pb, len);\n    }\n    wmem_destroy_allocator(strpool);\n}",
        "func": "static void\nsteamdiscover_dissect_body_status(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                                     gint offset, gint bytes_left)\n{\n    gint64 value;\n    gint len;\n    gint len2;\n    protobuf_desc_t pb = { tvb, offset, bytes_left };\n    protobuf_desc_t pb2 = { tvb, 0, 0 };\n    protobuf_tag_t tag = { 0, 0, 0 };\n    guint8 *hostname;\n    nstime_t timestamp;\n    proto_tree *user_tree;\n    proto_item *user_it;\n    while (protobuf_iter_next(&pb, &tag)) {\n        switch(tag.field_number) {\n            case STEAMDISCOVER_FN_STATUS_VERSION:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_VARINT);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_int(tree, hf_steam_ihs_discovery_body_status_version, pb.tvb,\n                        pb.offset, len, (gint32)value);\n                break;\n            case STEAMDISCOVER_FN_STATUS_MINVERSION:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_VARINT);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_int(tree, hf_steam_ihs_discovery_body_status_minversion, pb.tvb,\n                        pb.offset, len, (gint32)value);\n                break;\n            case STEAMDISCOVER_FN_STATUS_CONNECTPORT:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_VARINT);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_uint(tree, hf_steam_ihs_discovery_body_status_connectport, pb.tvb,\n                        pb.offset, len, (guint32)value);\n                break;\n            case STEAMDISCOVER_FN_STATUS_HOSTNAME:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_LENGTHDELIMITED);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_item(tree, hf_steam_ihs_discovery_body_status_hostname, pb.tvb,\n                        pb.offset+len, (gint)value, ENC_UTF_8|ENC_NA);\n                hostname = tvb_get_string_enc(wmem_packet_scope(), pb.tvb, pb.offset+len, (gint)value, ENC_UTF_8);\n                if(hostname && strlen(hostname)) {\n                    col_add_fstr(pinfo->cinfo, COL_INFO, \"%s from %s\", hf_steam_ihs_discovery_header_msgtype_strings[STEAMDISCOVER_MSGTYPE_CLIENTBROADCASTMSGSTATUS].strptr, hostname);\n                }\n                len += (gint)value;\n                break;\n            case STEAMDISCOVER_FN_STATUS_ENABLEDSERVICES:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_VARINT);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_uint(tree, hf_steam_ihs_discovery_body_status_enabledservices, pb.tvb,\n                        pb.offset, len, (guint32)value);\n                break;\n            case STEAMDISCOVER_FN_STATUS_OSTYPE:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_VARINT);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_int(tree, hf_steam_ihs_discovery_body_status_ostype, pb.tvb,\n                        pb.offset, len, (gint32)value);\n                break;\n            case STEAMDISCOVER_FN_STATUS_IS64BIT:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_VARINT);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_boolean(tree, hf_steam_ihs_discovery_body_status_is64bit, pb.tvb,\n                        pb.offset, len, (gint32)value);\n                break;\n            case STEAMDISCOVER_FN_STATUS_USERS:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_LENGTHDELIMITED);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                pb2.offset = pb.offset+len;\n                pb2.bytes_left = (gint)value;\n                len += (gint)value;\n                user_tree = proto_tree_add_subtree(tree, pb.tvb, pb.offset, len, ett_steam_ihs_discovery_body_status_user, &user_it, \"User\");\n                while (protobuf_iter_next(&pb2, &tag)) {\n                    switch(tag.field_number) {\n                        case STEAMDISCOVER_FN_STATUS_USER_STEAMID:\n                            if((len2 = protobuf_verify_wiretype(&pb2, &tag, pinfo, user_tree, PROTOBUF_WIRETYPE_64BIT))) break;\n                            len2 = 8;\n                            value = tvb_get_letoh64(pb2.tvb, pb2.offset);\n                            proto_tree_add_uint64(user_tree, hf_steam_ihs_discovery_body_status_user_steamid, pb2.tvb,\n                                    pb2.offset, len2, (guint64)value);\n                            proto_item_append_text(user_it, \", Steam ID: %\"G_GUINT64_FORMAT, (guint64)value);\n                            break;\n                        case STEAMDISCOVER_FN_STATUS_USER_AUTHKEYID:\n                            if((len2 = protobuf_verify_wiretype(&pb2, &tag, pinfo, user_tree, PROTOBUF_WIRETYPE_VARINT))) break;\n                            value = get_varint64(pb2.tvb, pb2.offset, pb2.bytes_left, &len2);\n                            proto_tree_add_uint(user_tree, hf_steam_ihs_discovery_body_status_user_authkeyid, pb2.tvb,\n                                    pb2.offset, len2, (guint32)value);\n                            proto_item_append_text(user_it, \", Auth Key ID: %\"G_GUINT32_FORMAT, (guint32)value);\n                            break;\n                        default:\n                            len2 = protobuf_dissect_unknown_field(&pb2, &tag, pinfo, tree, NULL);\n                            break;\n                    }\n                    protobuf_seek_forward(&pb2, len2);\n                }\n                break;\n            case STEAMDISCOVER_FN_STATUS_EUNIVERSE:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_VARINT);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_int(tree, hf_steam_ihs_discovery_body_status_euniverse, pb.tvb,\n                        pb.offset, len, (gint32)value);\n                break;\n            case STEAMDISCOVER_FN_STATUS_TIMESTAMP:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_VARINT);\n                timestamp.secs = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                timestamp.nsecs = 0;\n                proto_tree_add_time(tree, hf_steam_ihs_discovery_body_status_timestamp, pb.tvb,\n                        pb.offset, len, &timestamp);\n                break;\n            case STEAMDISCOVER_FN_STATUS_SCREENLOCKED:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_VARINT);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_boolean(tree, hf_steam_ihs_discovery_body_status_screenlocked, pb.tvb,\n                        pb.offset, len, (gint32)value);\n                break;\n            case STEAMDISCOVER_FN_STATUS_GAMESRUNNING:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_VARINT);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_boolean(tree, hf_steam_ihs_discovery_body_status_gamesrunning, pb.tvb,\n                        pb.offset, len, (gint32)value);\n                break;\n            case STEAMDISCOVER_FN_STATUS_MACADDRESSES:\n                STEAMDISCOVER_ENSURE_WIRETYPE(PROTOBUF_WIRETYPE_LENGTHDELIMITED);\n                value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                proto_tree_add_item(tree, hf_steam_ihs_discovery_body_status_macaddresses, pb.tvb,\n                        pb.offset+len, (gint)value, ENC_UTF_8|ENC_NA);\n                len += (gint)value;\n                break;\n            default:\n                len = protobuf_dissect_unknown_field(&pb, &tag, pinfo, tree, NULL);\n                break;\n        }\n        protobuf_seek_forward(&pb, len);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,9 +8,7 @@\n     protobuf_desc_t pb = { tvb, offset, bytes_left };\n     protobuf_desc_t pb2 = { tvb, 0, 0 };\n     protobuf_tag_t tag = { 0, 0, 0 };\n-    wmem_allocator_t* strpool;\n     guint8 *hostname;\n-    strpool = wmem_allocator_new(WMEM_ALLOCATOR_SIMPLE);\n     nstime_t timestamp;\n     proto_tree *user_tree;\n     proto_item *user_it;\n@@ -39,7 +37,7 @@\n                 value = get_varint64(pb.tvb, pb.offset, pb.bytes_left, &len);\n                 proto_tree_add_item(tree, hf_steam_ihs_discovery_body_status_hostname, pb.tvb,\n                         pb.offset+len, (gint)value, ENC_UTF_8|ENC_NA);\n-                hostname = tvb_get_string_enc(strpool, pb.tvb, pb.offset+len, (gint)value, ENC_UTF_8);\n+                hostname = tvb_get_string_enc(wmem_packet_scope(), pb.tvb, pb.offset+len, (gint)value, ENC_UTF_8);\n                 if(hostname && strlen(hostname)) {\n                     col_add_fstr(pinfo->cinfo, COL_INFO, \"%s from %s\", hf_steam_ihs_discovery_header_msgtype_strings[STEAMDISCOVER_MSGTYPE_CLIENTBROADCASTMSGSTATUS].strptr, hostname);\n                 }\n@@ -132,5 +130,4 @@\n         }\n         protobuf_seek_forward(&pb, len);\n     }\n-    wmem_destroy_allocator(strpool);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    wmem_allocator_t* strpool;",
                "    strpool = wmem_allocator_new(WMEM_ALLOCATOR_SIMPLE);",
                "                hostname = tvb_get_string_enc(strpool, pb.tvb, pb.offset+len, (gint)value, ENC_UTF_8);",
                "    wmem_destroy_allocator(strpool);"
            ],
            "added_lines": [
                "                hostname = tvb_get_string_enc(wmem_packet_scope(), pb.tvb, pb.offset+len, (gint)value, ENC_UTF_8);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-18443",
        "func_name": "AcademySoftwareFoundation/openexr/ThreadPool::Data::~Data",
        "description": "OpenEXR 2.3.0 has a memory leak in ThreadPool in IlmBase/IlmThread/IlmThreadPool.cpp, as demonstrated by exrmultiview.",
        "git_url": "https://github.com/AcademySoftwareFoundation/openexr/commit/adbc1900cb9d25fcc4df008d4008b781cf2fa4f8",
        "commit_title": "Fix #350 - memory leak on exit",
        "commit_text": " This fixes CVE-2018-18443, the last thread pool provider set into the pool was not being correctly cleaned up at shutdown of the thread pool. ",
        "func_before": "ThreadPool::Data::~Data()\n{\n#ifdef ILMBASE_FORCE_CXX03\n    provider->finish();\n#else\n    ThreadPoolProvider *p = provider.load( std::memory_order_relaxed );\n    p->finish();\n#endif\n}",
        "func": "ThreadPool::Data::~Data()\n{\n#ifdef ILMBASE_FORCE_CXX03\n    provider->finish();\n    delete provider;\n#else\n    ThreadPoolProvider *p = provider.load( std::memory_order_relaxed );\n    p->finish();\n    delete p;\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,8 +2,10 @@\n {\n #ifdef ILMBASE_FORCE_CXX03\n     provider->finish();\n+    delete provider;\n #else\n     ThreadPoolProvider *p = provider.load( std::memory_order_relaxed );\n     p->finish();\n+    delete p;\n #endif\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    delete provider;",
                "    delete p;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-18482",
        "func_name": "pganalyze/libpg_query/pg_query_parse_plpgsql",
        "description": "An issue was discovered in libpg_query 10-1.0.2. There is a memory leak in pg_query_raw_parse in pg_query_parse.c, which might lead to a denial of service.",
        "git_url": "https://github.com/pganalyze/libpg_query/commit/bc8a2f43a8fa30948da34a7543713c16630b49fb",
        "commit_title": "Free stderr_buffer when parsing plpgsql",
        "commit_text": " Fixes #49",
        "func_before": "PgQueryPlpgsqlParseResult pg_query_parse_plpgsql(const char* input)\n{\n\tMemoryContext ctx = NULL;\n\tPgQueryPlpgsqlParseResult result = {0};\n\tPgQueryInternalParsetreeAndError parse_result;\n\tcreateFunctionStmts statements;\n\tsize_t i;\n\n\tctx = pg_query_enter_memory_context(\"pg_query_parse_plpgsql\");\n\n\tparse_result = pg_query_raw_parse(input);\n\tresult.error = parse_result.error;\n\tif (result.error != NULL) {\n\t\tpg_query_exit_memory_context(ctx);\n\t\treturn result;\n\t}\n\n\tstatements.stmts_buf_size = 100;\n\tstatements.stmts = (CreateFunctionStmt**) palloc(statements.stmts_buf_size * sizeof(CreateFunctionStmt*));\n\tstatements.stmts_count = 0;\n\n\tcreate_function_stmts_walker((Node*) parse_result.tree, &statements);\n\n\tif (statements.stmts_count == 0) {\n\t\tresult.plpgsql_funcs = strdup(\"[]\");\n\t\tpg_query_exit_memory_context(ctx);\n\t\treturn result;\n\t}\n\n\tresult.plpgsql_funcs = strdup(\"[\\n\");\n\n\tfor (i = 0; i < statements.stmts_count; i++) {\n\t\tPgQueryInternalPlpgsqlFuncAndError func_and_error;\n\n\t\tfunc_and_error = pg_query_raw_parse_plpgsql(statements.stmts[i]);\n\n\t\t// These are all malloc-ed and will survive exiting the memory context, the caller is responsible to free them now\n\t\tresult.error = func_and_error.error;\n\n\t\tif (result.error != NULL) {\n\t\t\tpg_query_exit_memory_context(ctx);\n\t\t\treturn result;\n\t\t}\n\n\t\tif (func_and_error.func != NULL) {\n\t\t\tchar *func_json;\n\t\t\tchar *new_out;\n\t\t\tint ignored;\n\n\t\t\tfunc_json = plpgsqlToJSON(func_and_error.func);\n\t\t\tplpgsql_free_function_memory(func_and_error.func);\n\n\t\t\tignored = asprintf(&new_out, \"%s%s,\\n\", result.plpgsql_funcs, func_json);\n\t\t\tfree(result.plpgsql_funcs);\n\t\t\tresult.plpgsql_funcs = new_out;\n\n\t\t\tpfree(func_json);\n\t\t}\n\t}\n\n\tresult.plpgsql_funcs[strlen(result.plpgsql_funcs) - 2] = '\\n';\n\tresult.plpgsql_funcs[strlen(result.plpgsql_funcs) - 1] = ']';\n\n\tpg_query_exit_memory_context(ctx);\n\n\treturn result;\n}",
        "func": "PgQueryPlpgsqlParseResult pg_query_parse_plpgsql(const char* input)\n{\n\tMemoryContext ctx = NULL;\n\tPgQueryPlpgsqlParseResult result = {0};\n\tPgQueryInternalParsetreeAndError parse_result;\n\tcreateFunctionStmts statements;\n\tsize_t i;\n\n\tctx = pg_query_enter_memory_context(\"pg_query_parse_plpgsql\");\n\n\tparse_result = pg_query_raw_parse(input);\n\tresult.error = parse_result.error;\n\tif (result.error != NULL) {\n\t\tpg_query_exit_memory_context(ctx);\n\t\treturn result;\n\t}\n\n\tstatements.stmts_buf_size = 100;\n\tstatements.stmts = (CreateFunctionStmt**) palloc(statements.stmts_buf_size * sizeof(CreateFunctionStmt*));\n\tstatements.stmts_count = 0;\n\n\tcreate_function_stmts_walker((Node*) parse_result.tree, &statements);\n\n\tif (statements.stmts_count == 0) {\n\t\tresult.plpgsql_funcs = strdup(\"[]\");\n\t\tpg_query_exit_memory_context(ctx);\n\t\treturn result;\n\t}\n\n\tresult.plpgsql_funcs = strdup(\"[\\n\");\n\n\tfor (i = 0; i < statements.stmts_count; i++) {\n\t\tPgQueryInternalPlpgsqlFuncAndError func_and_error;\n\n\t\tfunc_and_error = pg_query_raw_parse_plpgsql(statements.stmts[i]);\n\n\t\t// These are all malloc-ed and will survive exiting the memory context, the caller is responsible to free them now\n\t\tresult.error = func_and_error.error;\n\n\t\tif (result.error != NULL) {\n\t\t\tpg_query_exit_memory_context(ctx);\n\t\t\treturn result;\n\t\t}\n\n\t\tif (func_and_error.func != NULL) {\n\t\t\tchar *func_json;\n\t\t\tchar *new_out;\n\t\t\tint ignored;\n\n\t\t\tfunc_json = plpgsqlToJSON(func_and_error.func);\n\t\t\tplpgsql_free_function_memory(func_and_error.func);\n\n\t\t\tignored = asprintf(&new_out, \"%s%s,\\n\", result.plpgsql_funcs, func_json);\n\t\t\tfree(result.plpgsql_funcs);\n\t\t\tresult.plpgsql_funcs = new_out;\n\n\t\t\tpfree(func_json);\n\t\t}\n\t}\n\n\tresult.plpgsql_funcs[strlen(result.plpgsql_funcs) - 2] = '\\n';\n\tresult.plpgsql_funcs[strlen(result.plpgsql_funcs) - 1] = ']';\n\n\tfree(parse_result.stderr_buffer);\n\tpg_query_exit_memory_context(ctx);\n\n\treturn result;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -61,6 +61,7 @@\n \tresult.plpgsql_funcs[strlen(result.plpgsql_funcs) - 2] = '\\n';\n \tresult.plpgsql_funcs[strlen(result.plpgsql_funcs) - 1] = ']';\n \n+\tfree(parse_result.stderr_buffer);\n \tpg_query_exit_memory_context(ctx);\n \n \treturn result;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tfree(parse_result.stderr_buffer);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-18544",
        "func_name": "ImageMagick/WriteMSLImage",
        "description": "There is a memory leak in the function WriteMSLImage of coders/msl.c in ImageMagick 7.0.8-13 Q16, and the function ProcessMSLScript of coders/msl.c in GraphicsMagick before 1.3.31.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/c9c4ef4e7ca83d8a00effd16723f37946e89fbad",
        "commit_title": "Fixed leaking of the image when writing an MSL image (#1360).",
        "commit_text": "",
        "func_before": "static MagickBooleanType WriteMSLImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  Image\n    *msl_image;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  msl_image=CloneImage(image,0,0,MagickTrue,exception);\n  return(ProcessMSLScript(image_info,&msl_image,exception));\n}",
        "func": "static MagickBooleanType WriteMSLImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  Image\n    *msl_image;\n\n  MagickBooleanType\n    status;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  msl_image=CloneImage(image,0,0,MagickTrue,exception);\n  status=ProcessMSLScript(image_info,&msl_image,exception);\n  msl_image=DestroyImageList(msl_image);\n  return(status);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,9 @@\n {\n   Image\n     *msl_image;\n+\n+  MagickBooleanType\n+    status;\n \n   assert(image_info != (const ImageInfo *) NULL);\n   assert(image_info->signature == MagickCoreSignature);\n@@ -11,5 +14,7 @@\n   if (image->debug != MagickFalse)\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n   msl_image=CloneImage(image,0,0,MagickTrue,exception);\n-  return(ProcessMSLScript(image_info,&msl_image,exception));\n+  status=ProcessMSLScript(image_info,&msl_image,exception);\n+  msl_image=DestroyImageList(msl_image);\n+  return(status);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  return(ProcessMSLScript(image_info,&msl_image,exception));"
            ],
            "added_lines": [
                "",
                "  MagickBooleanType",
                "    status;",
                "  status=ProcessMSLScript(image_info,&msl_image,exception);",
                "  msl_image=DestroyImageList(msl_image);",
                "  return(status);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-18897",
        "func_name": "poppler/GfxColorSpace::setDisplayProfile",
        "description": "An issue was discovered in Poppler 0.71.0. There is a memory leak in GfxColorSpace::setDisplayProfile in GfxState.cc, as demonstrated by pdftocairo.",
        "git_url": "https://cgit.freedesktop.org/poppler/poppler/commit/?id=e07c8b4784234383cb5ddcf1133ea91a772506e2",
        "commit_title": "",
        "commit_text": "",
        "func_before": "void GfxColorSpace::setDisplayProfile(void *displayProfileA) {\n  displayProfile = displayProfileA;\n  if (displayProfile != nullptr) {\n    cmsHTRANSFORM transform;\n    unsigned int nChannels;\n\n    displayPixelType = getCMSColorSpaceType(cmsGetColorSpace(displayProfile));\n    nChannels = getCMSNChannels(cmsGetColorSpace(displayProfile));\n    // create transform from XYZ\n    cmsHPROFILE XYZProfile = cmsCreateXYZProfile();\n    if ((transform = cmsCreateTransform(XYZProfile, TYPE_XYZ_DBL,\n\t   displayProfile,\n\t   COLORSPACE_SH(displayPixelType) |\n\t     CHANNELS_SH(nChannels) | BYTES_SH(1),\n\t  INTENT_RELATIVE_COLORIMETRIC,LCMS_FLAGS)) == nullptr) {\n      error(errSyntaxWarning, -1, \"Can't create Lab transform\");\n    } else {\n      XYZ2DisplayTransform = new GfxColorTransform(transform, INTENT_RELATIVE_COLORIMETRIC, PT_XYZ, displayPixelType);\n    }\n    cmsCloseProfile(XYZProfile);\n  }\n}",
        "func": "void GfxColorSpace::setDisplayProfile(void *displayProfileA) {\n  if (displayProfile != nullptr) {\n    error(errInternal, -1, \"The display color profile can only be set once before any rendering is done.\");\n    return;\n  }\n  displayProfile = displayProfileA;\n  if (displayProfile != nullptr) {\n    cmsHTRANSFORM transform;\n    unsigned int nChannels;\n\n    displayPixelType = getCMSColorSpaceType(cmsGetColorSpace(displayProfile));\n    nChannels = getCMSNChannels(cmsGetColorSpace(displayProfile));\n    // create transform from XYZ\n    cmsHPROFILE XYZProfile = cmsCreateXYZProfile();\n    if ((transform = cmsCreateTransform(XYZProfile, TYPE_XYZ_DBL,\n\t   displayProfile,\n\t   COLORSPACE_SH(displayPixelType) |\n\t     CHANNELS_SH(nChannels) | BYTES_SH(1),\n\t  INTENT_RELATIVE_COLORIMETRIC,LCMS_FLAGS)) == nullptr) {\n      error(errSyntaxWarning, -1, \"Can't create Lab transform\");\n    } else {\n      XYZ2DisplayTransform = new GfxColorTransform(transform, INTENT_RELATIVE_COLORIMETRIC, PT_XYZ, displayPixelType);\n    }\n    cmsCloseProfile(XYZProfile);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,8 @@\n void GfxColorSpace::setDisplayProfile(void *displayProfileA) {\n+  if (displayProfile != nullptr) {\n+    error(errInternal, -1, \"The display color profile can only be set once before any rendering is done.\");\n+    return;\n+  }\n   displayProfile = displayProfileA;\n   if (displayProfile != nullptr) {\n     cmsHTRANSFORM transform;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  if (displayProfile != nullptr) {",
                "    error(errInternal, -1, \"The display color profile can only be set once before any rendering is done.\");",
                "    return;",
                "  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-18897",
        "func_name": "poppler/GfxColorSpace::setDisplayProfileName",
        "description": "An issue was discovered in Poppler 0.71.0. There is a memory leak in GfxColorSpace::setDisplayProfile in GfxState.cc, as demonstrated by pdftocairo.",
        "git_url": "https://cgit.freedesktop.org/poppler/poppler/commit/?id=e07c8b4784234383cb5ddcf1133ea91a772506e2",
        "commit_title": "",
        "commit_text": "",
        "func_before": "void GfxColorSpace::setDisplayProfileName(GooString *name) {\n  displayProfileName = name->copy();\n}",
        "func": "void GfxColorSpace::setDisplayProfileName(GooString *name) {\n  if (displayProfile != nullptr) {\n    error(errInternal, -1, \"The display color profile can only be set before any rendering is done.\");\n    return;\n  }\n  delete displayProfileName;\n  displayProfileName = name->copy();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,3 +1,8 @@\n void GfxColorSpace::setDisplayProfileName(GooString *name) {\n+  if (displayProfile != nullptr) {\n+    error(errInternal, -1, \"The display color profile can only be set before any rendering is done.\");\n+    return;\n+  }\n+  delete displayProfileName;\n   displayProfileName = name->copy();\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  if (displayProfile != nullptr) {",
                "    error(errInternal, -1, \"The display color profile can only be set before any rendering is done.\");",
                "    return;",
                "  }",
                "  delete displayProfileName;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19132",
        "func_name": "squid-cache/squid/snmpDecodePacket",
        "description": "Squid before 4.4, when SNMP is enabled, allows a denial of service (Memory Leak) via an SNMP packet.",
        "git_url": "https://github.com/squid-cache/squid/commit/4a49b6dd822597691b4d25c2bd21d0d418413246",
        "commit_title": "fix memory leak when parsing SNMP packet",
        "commit_text": "",
        "func_before": "static void\nsnmpDecodePacket(SnmpRequest * rq)\n{\n    struct snmp_pdu *PDU;\n    u_char *Community;\n    u_char *buf = rq->buf;\n    int len = rq->len;\n\n    if (!Config.accessList.snmp) {\n        debugs(49, DBG_IMPORTANT, \"WARNING: snmp_access not configured. agent query DENIED from : \" << rq->from);\n        return;\n    }\n\n    debugs(49, 5, HERE << \"Called.\");\n    PDU = snmp_pdu_create(0);\n    /* Allways answer on SNMPv1 */\n    rq->session.Version = SNMP_VERSION_1;\n    Community = snmp_parse(&rq->session, PDU, buf, len);\n\n    /* Check if we have explicit permission to access SNMP data.\n     * default (set above) is to deny all */\n    if (Community) {\n        ACLFilledChecklist checklist(Config.accessList.snmp, NULL, NULL);\n        checklist.src_addr = rq->from;\n        checklist.snmp_community = (char *) Community;\n\n        if (checklist.fastCheck().allowed() && (snmp_coexist_V2toV1(PDU))) {\n            rq->community = Community;\n            rq->PDU = PDU;\n            debugs(49, 5, \"snmpAgentParse: reqid=[\" << PDU->reqid << \"]\");\n            snmpConstructReponse(rq);\n        } else {\n            debugs(49, DBG_IMPORTANT, \"WARNING: SNMP agent query DENIED from : \" << rq->from);\n        }\n        xfree(Community);\n\n    } else {\n        debugs(49, DBG_IMPORTANT, \"WARNING: Failed SNMP agent query from : \" << rq->from);\n        snmp_free_pdu(PDU);\n    }\n}",
        "func": "static void\nsnmpDecodePacket(SnmpRequest * rq)\n{\n    struct snmp_pdu *PDU;\n    u_char *Community;\n    u_char *buf = rq->buf;\n    int len = rq->len;\n\n    if (!Config.accessList.snmp) {\n        debugs(49, DBG_IMPORTANT, \"WARNING: snmp_access not configured. agent query DENIED from : \" << rq->from);\n        return;\n    }\n\n    debugs(49, 5, HERE << \"Called.\");\n    PDU = snmp_pdu_create(0);\n    /* Allways answer on SNMPv1 */\n    rq->session.Version = SNMP_VERSION_1;\n    Community = snmp_parse(&rq->session, PDU, buf, len);\n\n    /* Check if we have explicit permission to access SNMP data.\n     * default (set above) is to deny all */\n    if (Community) {\n        ACLFilledChecklist checklist(Config.accessList.snmp, NULL, NULL);\n        checklist.src_addr = rq->from;\n        checklist.snmp_community = (char *) Community;\n\n        if (checklist.fastCheck().allowed() && (snmp_coexist_V2toV1(PDU))) {\n            rq->community = Community;\n            rq->PDU = PDU;\n            debugs(49, 5, \"snmpAgentParse: reqid=[\" << PDU->reqid << \"]\");\n            snmpConstructReponse(rq);\n        } else {\n            debugs(49, DBG_IMPORTANT, \"WARNING: SNMP agent query DENIED from : \" << rq->from);\n            snmp_free_pdu(PDU);\n        }\n        xfree(Community);\n\n    } else {\n        debugs(49, DBG_IMPORTANT, \"WARNING: Failed SNMP agent query from : \" << rq->from);\n        snmp_free_pdu(PDU);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,6 +31,7 @@\n             snmpConstructReponse(rq);\n         } else {\n             debugs(49, DBG_IMPORTANT, \"WARNING: SNMP agent query DENIED from : \" << rq->from);\n+            snmp_free_pdu(PDU);\n         }\n         xfree(Community);\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            snmp_free_pdu(PDU);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-20002",
        "func_name": "binutils-gdb/_bfd_generic_read_minisymbols",
        "description": "The _bfd_generic_read_minisymbols function in syms.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.31, has a memory leak via a crafted ELF file, leading to a denial of service (memory consumption), as demonstrated by nm.",
        "git_url": "https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=c2f5dc30afa34696f2da0081c4ac50b958ecb0e9",
        "commit_title": "",
        "commit_text": "PR23952, memory leak in _bfd_generic_read_minisymbols  bfd/ \tPR 23952 \t* syms.c (_bfd_generic_read_minisymbols): Free syms before \treturning with zero symcount. binutils/ \t* nm.c (display_rel_file): Use xrealloc to increase minisyms \tfor synthetic symbols. ",
        "func_before": "long\n_bfd_generic_read_minisymbols (bfd *abfd,\n\t\t\t       bfd_boolean dynamic,\n\t\t\t       void **minisymsp,\n\t\t\t       unsigned int *sizep)\n{\n  long storage;\n  asymbol **syms = NULL;\n  long symcount;\n\n  if (dynamic)\n    storage = bfd_get_dynamic_symtab_upper_bound (abfd);\n  else\n    storage = bfd_get_symtab_upper_bound (abfd);\n  if (storage < 0)\n    goto error_return;\n  if (storage == 0)\n    return 0;\n\n  syms = (asymbol **) bfd_malloc (storage);\n  if (syms == NULL)\n    goto error_return;\n\n  if (dynamic)\n    symcount = bfd_canonicalize_dynamic_symtab (abfd, syms);\n  else\n    symcount = bfd_canonicalize_symtab (abfd, syms);\n  if (symcount < 0)\n    goto error_return;\n\n  *minisymsp = syms;\n  *sizep = sizeof (asymbol *);\n\n  return symcount;\n\n error_return:\n  bfd_set_error (bfd_error_no_symbols);\n  if (syms != NULL)\n    free (syms);\n  return -1;\n}",
        "func": "long\n_bfd_generic_read_minisymbols (bfd *abfd,\n\t\t\t       bfd_boolean dynamic,\n\t\t\t       void **minisymsp,\n\t\t\t       unsigned int *sizep)\n{\n  long storage;\n  asymbol **syms = NULL;\n  long symcount;\n\n  if (dynamic)\n    storage = bfd_get_dynamic_symtab_upper_bound (abfd);\n  else\n    storage = bfd_get_symtab_upper_bound (abfd);\n  if (storage < 0)\n    goto error_return;\n  if (storage == 0)\n    return 0;\n\n  syms = (asymbol **) bfd_malloc (storage);\n  if (syms == NULL)\n    goto error_return;\n\n  if (dynamic)\n    symcount = bfd_canonicalize_dynamic_symtab (abfd, syms);\n  else\n    symcount = bfd_canonicalize_symtab (abfd, syms);\n  if (symcount < 0)\n    goto error_return;\n\n  if (symcount == 0)\n    /* We return 0 above when storage is 0.  Exit in the same state\n       here, so as to not complicate callers with having to deal with\n       freeing memory for zero symcount.  */\n    free (syms);\n  else\n    {\n      *minisymsp = syms;\n      *sizep = sizeof (asymbol *);\n    }\n  return symcount;\n\n error_return:\n  bfd_set_error (bfd_error_no_symbols);\n  if (syms != NULL)\n    free (syms);\n  return -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,9 +28,16 @@\n   if (symcount < 0)\n     goto error_return;\n \n-  *minisymsp = syms;\n-  *sizep = sizeof (asymbol *);\n-\n+  if (symcount == 0)\n+    /* We return 0 above when storage is 0.  Exit in the same state\n+       here, so as to not complicate callers with having to deal with\n+       freeing memory for zero symcount.  */\n+    free (syms);\n+  else\n+    {\n+      *minisymsp = syms;\n+      *sizep = sizeof (asymbol *);\n+    }\n   return symcount;\n \n  error_return:",
        "diff_line_info": {
            "deleted_lines": [
                "  *minisymsp = syms;",
                "  *sizep = sizeof (asymbol *);",
                ""
            ],
            "added_lines": [
                "  if (symcount == 0)",
                "    /* We return 0 above when storage is 0.  Exit in the same state",
                "       here, so as to not complicate callers with having to deal with",
                "       freeing memory for zero symcount.  */",
                "    free (syms);",
                "  else",
                "    {",
                "      *minisymsp = syms;",
                "      *sizep = sizeof (asymbol *);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-20002",
        "func_name": "binutils-gdb/display_rel_file",
        "description": "The _bfd_generic_read_minisymbols function in syms.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.31, has a memory leak via a crafted ELF file, leading to a denial of service (memory consumption), as demonstrated by nm.",
        "git_url": "https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=c2f5dc30afa34696f2da0081c4ac50b958ecb0e9",
        "commit_title": "",
        "commit_text": "PR23952, memory leak in _bfd_generic_read_minisymbols  bfd/ \tPR 23952 \t* syms.c (_bfd_generic_read_minisymbols): Free syms before \treturning with zero symcount. binutils/ \t* nm.c (display_rel_file): Use xrealloc to increase minisyms \tfor synthetic symbols. ",
        "func_before": "static void\ndisplay_rel_file (bfd *abfd, bfd *archive_bfd)\n{\n  long symcount;\n  void *minisyms;\n  unsigned int size;\n  struct size_sym *symsizes;\n  asymbol *synthsyms = NULL;\n\n  if (! dynamic)\n    {\n      if (!(bfd_get_file_flags (abfd) & HAS_SYMS))\n\t{\n\t  non_fatal (_(\"%s: no symbols\"), bfd_get_filename (abfd));\n\t  return;\n\t}\n    }\n\n  symcount = bfd_read_minisymbols (abfd, dynamic, &minisyms, &size);\n  if (symcount < 0)\n    {\n      if (dynamic && bfd_get_error () == bfd_error_no_symbols)\n\t{\n\t  non_fatal (_(\"%s: no symbols\"), bfd_get_filename (abfd));\n\t  return;\n\t}\n\n      bfd_fatal (bfd_get_filename (abfd));\n    }\n\n  if (symcount == 0)\n    {\n      non_fatal (_(\"%s: no symbols\"), bfd_get_filename (abfd));\n      return;\n    }\n\n  if (show_synthetic && size == sizeof (asymbol *))\n    {\n      asymbol **static_syms = NULL;\n      asymbol **dyn_syms = NULL;\n      long static_count = 0;\n      long dyn_count = 0;\n      long synth_count;\n\n      if (dynamic)\n\t{\n\t  dyn_count = symcount;\n\t  dyn_syms = (asymbol **) minisyms;\n\t}\n      else\n\t{\n\t  long storage = bfd_get_dynamic_symtab_upper_bound (abfd);\n\n\t  static_count = symcount;\n\t  static_syms = (asymbol **) minisyms;\n\n\t  if (storage > 0)\n\t    {\n\t      dyn_syms = (asymbol **) xmalloc (storage);\n\t      dyn_count = bfd_canonicalize_dynamic_symtab (abfd, dyn_syms);\n\t      if (dyn_count < 0)\n\t\tbfd_fatal (bfd_get_filename (abfd));\n\t    }\n\t}\n\n      synth_count = bfd_get_synthetic_symtab (abfd, static_count, static_syms,\n\t\t\t\t\t      dyn_count, dyn_syms, &synthsyms);\n      if (synth_count > 0)\n\t{\n\t  asymbol **symp;\n\t  void *new_mini;\n\t  long i;\n\n\t  new_mini = xmalloc ((symcount + synth_count + 1) * sizeof (*symp));\n\t  symp = (asymbol **) new_mini;\n\t  memcpy (symp, minisyms, symcount * sizeof (*symp));\n\t  symp += symcount;\n\t  for (i = 0; i < synth_count; i++)\n\t    *symp++ = synthsyms + i;\n\t  *symp = 0;\n\t  minisyms = new_mini;\n\t  symcount += synth_count;\n\t}\n    }\n\n  /* Discard the symbols we don't want to print.\n     It's OK to do this in place; we'll free the storage anyway\n     (after printing).  */\n\n  symcount = filter_symbols (abfd, dynamic, minisyms, symcount, size);\n\n  symsizes = NULL;\n  if (! no_sort)\n    {\n      sort_bfd = abfd;\n      sort_dynamic = dynamic;\n      sort_x = bfd_make_empty_symbol (abfd);\n      sort_y = bfd_make_empty_symbol (abfd);\n      if (sort_x == NULL || sort_y == NULL)\n\tbfd_fatal (bfd_get_filename (abfd));\n\n      if (! sort_by_size)\n\tqsort (minisyms, symcount, size,\n\t       sorters[sort_numerically][reverse_sort]);\n      else\n\tsymcount = sort_symbols_by_size (abfd, dynamic, minisyms, symcount,\n\t\t\t\t\t size, &symsizes);\n    }\n\n  if (! sort_by_size)\n    print_symbols (abfd, dynamic, minisyms, symcount, size, archive_bfd);\n  else\n    print_size_symbols (abfd, dynamic, symsizes, symcount, archive_bfd);\n\n  if (synthsyms)\n    free (synthsyms);\n  free (minisyms);\n  free (symsizes);\n}",
        "func": "static void\ndisplay_rel_file (bfd *abfd, bfd *archive_bfd)\n{\n  long symcount;\n  void *minisyms;\n  unsigned int size;\n  struct size_sym *symsizes;\n  asymbol *synthsyms = NULL;\n\n  if (! dynamic)\n    {\n      if (!(bfd_get_file_flags (abfd) & HAS_SYMS))\n\t{\n\t  non_fatal (_(\"%s: no symbols\"), bfd_get_filename (abfd));\n\t  return;\n\t}\n    }\n\n  symcount = bfd_read_minisymbols (abfd, dynamic, &minisyms, &size);\n  if (symcount < 0)\n    {\n      if (dynamic && bfd_get_error () == bfd_error_no_symbols)\n\t{\n\t  non_fatal (_(\"%s: no symbols\"), bfd_get_filename (abfd));\n\t  return;\n\t}\n\n      bfd_fatal (bfd_get_filename (abfd));\n    }\n\n  if (symcount == 0)\n    {\n      non_fatal (_(\"%s: no symbols\"), bfd_get_filename (abfd));\n      return;\n    }\n\n  if (show_synthetic && size == sizeof (asymbol *))\n    {\n      asymbol **static_syms = NULL;\n      asymbol **dyn_syms = NULL;\n      long static_count = 0;\n      long dyn_count = 0;\n      long synth_count;\n\n      if (dynamic)\n\t{\n\t  dyn_count = symcount;\n\t  dyn_syms = (asymbol **) minisyms;\n\t}\n      else\n\t{\n\t  long storage = bfd_get_dynamic_symtab_upper_bound (abfd);\n\n\t  static_count = symcount;\n\t  static_syms = (asymbol **) minisyms;\n\n\t  if (storage > 0)\n\t    {\n\t      dyn_syms = (asymbol **) xmalloc (storage);\n\t      dyn_count = bfd_canonicalize_dynamic_symtab (abfd, dyn_syms);\n\t      if (dyn_count < 0)\n\t\tbfd_fatal (bfd_get_filename (abfd));\n\t    }\n\t}\n\n      synth_count = bfd_get_synthetic_symtab (abfd, static_count, static_syms,\n\t\t\t\t\t      dyn_count, dyn_syms, &synthsyms);\n      if (synth_count > 0)\n\t{\n\t  asymbol **symp;\n\t  long i;\n\n\t  minisyms = xrealloc (minisyms,\n\t\t\t       (symcount + synth_count + 1) * sizeof (*symp));\n\t  symp = (asymbol **) minisyms + symcount;\n\t  for (i = 0; i < synth_count; i++)\n\t    *symp++ = synthsyms + i;\n\t  *symp = 0;\n\t  symcount += synth_count;\n\t}\n    }\n\n  /* Discard the symbols we don't want to print.\n     It's OK to do this in place; we'll free the storage anyway\n     (after printing).  */\n\n  symcount = filter_symbols (abfd, dynamic, minisyms, symcount, size);\n\n  symsizes = NULL;\n  if (! no_sort)\n    {\n      sort_bfd = abfd;\n      sort_dynamic = dynamic;\n      sort_x = bfd_make_empty_symbol (abfd);\n      sort_y = bfd_make_empty_symbol (abfd);\n      if (sort_x == NULL || sort_y == NULL)\n\tbfd_fatal (bfd_get_filename (abfd));\n\n      if (! sort_by_size)\n\tqsort (minisyms, symcount, size,\n\t       sorters[sort_numerically][reverse_sort]);\n      else\n\tsymcount = sort_symbols_by_size (abfd, dynamic, minisyms, symcount,\n\t\t\t\t\t size, &symsizes);\n    }\n\n  if (! sort_by_size)\n    print_symbols (abfd, dynamic, minisyms, symcount, size, archive_bfd);\n  else\n    print_size_symbols (abfd, dynamic, symsizes, symcount, archive_bfd);\n\n  if (synthsyms)\n    free (synthsyms);\n  free (minisyms);\n  free (symsizes);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -68,17 +68,14 @@\n       if (synth_count > 0)\n \t{\n \t  asymbol **symp;\n-\t  void *new_mini;\n \t  long i;\n \n-\t  new_mini = xmalloc ((symcount + synth_count + 1) * sizeof (*symp));\n-\t  symp = (asymbol **) new_mini;\n-\t  memcpy (symp, minisyms, symcount * sizeof (*symp));\n-\t  symp += symcount;\n+\t  minisyms = xrealloc (minisyms,\n+\t\t\t       (symcount + synth_count + 1) * sizeof (*symp));\n+\t  symp = (asymbol **) minisyms + symcount;\n \t  for (i = 0; i < synth_count; i++)\n \t    *symp++ = synthsyms + i;\n \t  *symp = 0;\n-\t  minisyms = new_mini;\n \t  symcount += synth_count;\n \t}\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "\t  void *new_mini;",
                "\t  new_mini = xmalloc ((symcount + synth_count + 1) * sizeof (*symp));",
                "\t  symp = (asymbol **) new_mini;",
                "\t  memcpy (symp, minisyms, symcount * sizeof (*symp));",
                "\t  symp += symcount;",
                "\t  minisyms = new_mini;"
            ],
            "added_lines": [
                "\t  minisyms = xrealloc (minisyms,",
                "\t\t\t       (symcount + synth_count + 1) * sizeof (*symp));",
                "\t  symp = (asymbol **) minisyms + symcount;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-22996",
        "func_name": "torvalds/linux/qmp_get",
        "description": "In the Linux kernel before 5.17.2, drivers/soc/qcom/qcom_aoss.c does not release an of_find_device_by_node reference after use, e.g., with put_device.",
        "git_url": "https://github.com/torvalds/linux/commit/4b41a9d0fe3db5f91078a380f62f0572c3ecf2dd",
        "commit_title": "soc: qcom: aoss: Fix missing put_device call in qmp_get",
        "commit_text": " The reference taken by 'of_find_device_by_node()' must be released when not needed anymore. Add the corresponding 'put_device()' in the error handling paths.  Link: https://lore.kernel.org/r/20220108095931.21527-1-linmq006@gmail.com",
        "func_before": "struct qmp *qmp_get(struct device *dev)\n{\n\tstruct platform_device *pdev;\n\tstruct device_node *np;\n\tstruct qmp *qmp;\n\n\tif (!dev || !dev->of_node)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnp = of_parse_phandle(dev->of_node, \"qcom,qmp\", 0);\n\tif (!np)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tpdev = of_find_device_by_node(np);\n\tof_node_put(np);\n\tif (!pdev)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tqmp = platform_get_drvdata(pdev);\n\n\treturn qmp ? qmp : ERR_PTR(-EPROBE_DEFER);\n}",
        "func": "struct qmp *qmp_get(struct device *dev)\n{\n\tstruct platform_device *pdev;\n\tstruct device_node *np;\n\tstruct qmp *qmp;\n\n\tif (!dev || !dev->of_node)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnp = of_parse_phandle(dev->of_node, \"qcom,qmp\", 0);\n\tif (!np)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tpdev = of_find_device_by_node(np);\n\tof_node_put(np);\n\tif (!pdev)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tqmp = platform_get_drvdata(pdev);\n\n\tif (!qmp) {\n\t\tput_device(&pdev->dev);\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\treturn qmp;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,5 +18,9 @@\n \n \tqmp = platform_get_drvdata(pdev);\n \n-\treturn qmp ? qmp : ERR_PTR(-EPROBE_DEFER);\n+\tif (!qmp) {\n+\t\tput_device(&pdev->dev);\n+\t\treturn ERR_PTR(-EPROBE_DEFER);\n+\t}\n+\treturn qmp;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn qmp ? qmp : ERR_PTR(-EPROBE_DEFER);"
            ],
            "added_lines": [
                "\tif (!qmp) {",
                "\t\tput_device(&pdev->dev);",
                "\t\treturn ERR_PTR(-EPROBE_DEFER);",
                "\t}",
                "\treturn qmp;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-1488",
        "func_name": "rsyslog/processBatchMultiRuleset",
        "description": "A memory leak in rsyslog before 5.7.6 was found in the way deamon processed log messages are logged when $RepeatedMsgReduction was enabled. A local attacker could use this flaw to cause a denial of the rsyslogd daemon service by crashing the service via a sequence of repeated log messages sent within short periods of time.",
        "git_url": "https://github.com/rsyslog/rsyslog/commit/1ef709cc97d54f74d3fdeb83788cc4b01f4c6a2a",
        "commit_title": "bugfix: fixed a memory leak and potential abort condition",
        "commit_text": " this could happen if multiple rulesets were used and some output batches contained messages belonging to more than one ruleset. fixes: http://bugzilla.adiscon.com/show_bug.cgi?id=226 fixes: http://bugzilla.adiscon.com/show_bug.cgi?id=218",
        "func_before": "static inline rsRetVal\nprocessBatchMultiRuleset(batch_t *pBatch)\n{\n\truleset_t *currRuleset;\n\tbatch_t snglRuleBatch;\n\tint i;\n\tint iStart;\t/* start index of partial batch */\n\tint iNew;\t/* index for new (temporary) batch */\n\tDEFiRet;\n\n\tCHKiRet(batchInit(&snglRuleBatch, pBatch->nElem));\n\tsnglRuleBatch.pbShutdownImmediate = pBatch->pbShutdownImmediate;\n\n\twhile(1) { /* loop broken inside */\n\t\t/* search for first unprocessed element */\n\t\tfor(iStart = 0 ; iStart < pBatch->nElem && pBatch->pElem[iStart].state == BATCH_STATE_DISC ; ++iStart)\n\t\t\t/* just search, no action */;\n\n\t\tif(iStart == pBatch->nElem)\n\t\t\tFINALIZE; /* everything processed */\n\n\t\t/* prepare temporary batch */\n\t\tcurrRuleset = batchElemGetRuleset(pBatch, iStart);\n\t\tiNew = 0;\n\t\tfor(i = iStart ; i < pBatch->nElem ; ++i) {\n\t\t\tif(batchElemGetRuleset(pBatch, i) == currRuleset) {\n\t\t\t\tbatchCopyElem(&(snglRuleBatch.pElem[iNew++]), &(pBatch->pElem[i]));\n\t\t\t\t/* We indicate the element also as done, so it will not be processed again */\n\t\t\t\tpBatch->pElem[i].state = BATCH_STATE_DISC;\n\t\t\t}\n\t\t}\n\t\tsnglRuleBatch.nElem = iNew; /* was left just right by the for loop */\n\t\tbatchSetSingleRuleset(&snglRuleBatch, 1);\n\t\t/* process temp batch */\n\t\tprocessBatch(&snglRuleBatch);\n\t}\n\tbatchFree(&snglRuleBatch);\n\nfinalize_it:\n\tRETiRet;\n}",
        "func": "static inline rsRetVal\nprocessBatchMultiRuleset(batch_t *pBatch)\n{\n\truleset_t *currRuleset;\n\tbatch_t snglRuleBatch;\n\tint i;\n\tint iStart;\t/* start index of partial batch */\n\tint iNew;\t/* index for new (temporary) batch */\n\tint bHaveUnprocessed;\t/* do we (still) have unprocessed entries? (loop term predicate) */\n\tDEFiRet;\n\n\tdo {\n\t\tbHaveUnprocessed = 0;\n\t\t/* search for first unprocessed element */\n\t\tfor(iStart = 0 ; iStart < pBatch->nElem && pBatch->pElem[iStart].state == BATCH_STATE_DISC ; ++iStart)\n\t\t\t/* just search, no action */;\n\t\tif(iStart == pBatch->nElem)\n\t\t\tbreak; /* everything processed */\n\n\t\t/* prepare temporary batch */\n\t\tCHKiRet(batchInit(&snglRuleBatch, pBatch->nElem));\n\t\tsnglRuleBatch.pbShutdownImmediate = pBatch->pbShutdownImmediate;\n\t\tcurrRuleset = batchElemGetRuleset(pBatch, iStart);\n\t\tiNew = 0;\n\t\tfor(i = iStart ; i < pBatch->nElem ; ++i) {\n\t\t\tif(batchElemGetRuleset(pBatch, i) == currRuleset) {\n\t\t\t\t/* for performance reasons, we copy only those members that we actually need */\n\t\t\t\tsnglRuleBatch.pElem[iNew].pUsrp = pBatch->pElem[i].pUsrp;\n\t\t\t\tsnglRuleBatch.pElem[iNew].state = pBatch->pElem[i].state;\n\t\t\t\t++iNew;\n\t\t\t\t/* We indicate the element also as done, so it will not be processed again */\n\t\t\t\tpBatch->pElem[i].state = BATCH_STATE_DISC;\n\t\t\t} else {\n\t\t\t\tbHaveUnprocessed = 1;\n\t\t\t}\n\t\t}\n\t\tsnglRuleBatch.nElem = iNew; /* was left just right by the for loop */\n\t\tbatchSetSingleRuleset(&snglRuleBatch, 1);\n\t\t/* process temp batch */\n\t\tprocessBatch(&snglRuleBatch);\n\t\tbatchFree(&snglRuleBatch);\n\t} while(bHaveUnprocessed == 1);\n\nfinalize_it:\n\tRETiRet;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,35 +6,40 @@\n \tint i;\n \tint iStart;\t/* start index of partial batch */\n \tint iNew;\t/* index for new (temporary) batch */\n+\tint bHaveUnprocessed;\t/* do we (still) have unprocessed entries? (loop term predicate) */\n \tDEFiRet;\n \n-\tCHKiRet(batchInit(&snglRuleBatch, pBatch->nElem));\n-\tsnglRuleBatch.pbShutdownImmediate = pBatch->pbShutdownImmediate;\n-\n-\twhile(1) { /* loop broken inside */\n+\tdo {\n+\t\tbHaveUnprocessed = 0;\n \t\t/* search for first unprocessed element */\n \t\tfor(iStart = 0 ; iStart < pBatch->nElem && pBatch->pElem[iStart].state == BATCH_STATE_DISC ; ++iStart)\n \t\t\t/* just search, no action */;\n-\n \t\tif(iStart == pBatch->nElem)\n-\t\t\tFINALIZE; /* everything processed */\n+\t\t\tbreak; /* everything processed */\n \n \t\t/* prepare temporary batch */\n+\t\tCHKiRet(batchInit(&snglRuleBatch, pBatch->nElem));\n+\t\tsnglRuleBatch.pbShutdownImmediate = pBatch->pbShutdownImmediate;\n \t\tcurrRuleset = batchElemGetRuleset(pBatch, iStart);\n \t\tiNew = 0;\n \t\tfor(i = iStart ; i < pBatch->nElem ; ++i) {\n \t\t\tif(batchElemGetRuleset(pBatch, i) == currRuleset) {\n-\t\t\t\tbatchCopyElem(&(snglRuleBatch.pElem[iNew++]), &(pBatch->pElem[i]));\n+\t\t\t\t/* for performance reasons, we copy only those members that we actually need */\n+\t\t\t\tsnglRuleBatch.pElem[iNew].pUsrp = pBatch->pElem[i].pUsrp;\n+\t\t\t\tsnglRuleBatch.pElem[iNew].state = pBatch->pElem[i].state;\n+\t\t\t\t++iNew;\n \t\t\t\t/* We indicate the element also as done, so it will not be processed again */\n \t\t\t\tpBatch->pElem[i].state = BATCH_STATE_DISC;\n+\t\t\t} else {\n+\t\t\t\tbHaveUnprocessed = 1;\n \t\t\t}\n \t\t}\n \t\tsnglRuleBatch.nElem = iNew; /* was left just right by the for loop */\n \t\tbatchSetSingleRuleset(&snglRuleBatch, 1);\n \t\t/* process temp batch */\n \t\tprocessBatch(&snglRuleBatch);\n-\t}\n-\tbatchFree(&snglRuleBatch);\n+\t\tbatchFree(&snglRuleBatch);\n+\t} while(bHaveUnprocessed == 1);\n \n finalize_it:\n \tRETiRet;",
        "diff_line_info": {
            "deleted_lines": [
                "\tCHKiRet(batchInit(&snglRuleBatch, pBatch->nElem));",
                "\tsnglRuleBatch.pbShutdownImmediate = pBatch->pbShutdownImmediate;",
                "",
                "\twhile(1) { /* loop broken inside */",
                "",
                "\t\t\tFINALIZE; /* everything processed */",
                "\t\t\t\tbatchCopyElem(&(snglRuleBatch.pElem[iNew++]), &(pBatch->pElem[i]));",
                "\t}",
                "\tbatchFree(&snglRuleBatch);"
            ],
            "added_lines": [
                "\tint bHaveUnprocessed;\t/* do we (still) have unprocessed entries? (loop term predicate) */",
                "\tdo {",
                "\t\tbHaveUnprocessed = 0;",
                "\t\t\tbreak; /* everything processed */",
                "\t\tCHKiRet(batchInit(&snglRuleBatch, pBatch->nElem));",
                "\t\tsnglRuleBatch.pbShutdownImmediate = pBatch->pbShutdownImmediate;",
                "\t\t\t\t/* for performance reasons, we copy only those members that we actually need */",
                "\t\t\t\tsnglRuleBatch.pElem[iNew].pUsrp = pBatch->pElem[i].pUsrp;",
                "\t\t\t\tsnglRuleBatch.pElem[iNew].state = pBatch->pElem[i].state;",
                "\t\t\t\t++iNew;",
                "\t\t\t} else {",
                "\t\t\t\tbHaveUnprocessed = 1;",
                "\t\tbatchFree(&snglRuleBatch);",
                "\t} while(bHaveUnprocessed == 1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-1488",
        "func_name": "rsyslog/batchInit",
        "description": "A memory leak in rsyslog before 5.7.6 was found in the way deamon processed log messages are logged when $RepeatedMsgReduction was enabled. A local attacker could use this flaw to cause a denial of the rsyslogd daemon service by crashing the service via a sequence of repeated log messages sent within short periods of time.",
        "git_url": "https://github.com/rsyslog/rsyslog/commit/1ef709cc97d54f74d3fdeb83788cc4b01f4c6a2a",
        "commit_title": "bugfix: fixed a memory leak and potential abort condition",
        "commit_text": " this could happen if multiple rulesets were used and some output batches contained messages belonging to more than one ruleset. fixes: http://bugzilla.adiscon.com/show_bug.cgi?id=226 fixes: http://bugzilla.adiscon.com/show_bug.cgi?id=218",
        "func_before": "static inline rsRetVal\nbatchInit(batch_t *pBatch, int maxElem) {\n\tDEFiRet;\n\tpBatch->maxElem = maxElem;\n\tCHKmalloc(pBatch->pElem = calloc((size_t)maxElem, sizeof(batch_obj_t)));\n\t// TODO: replace calloc by inidividual writes?\nfinalize_it:\n\tRETiRet;\n}",
        "func": "static inline rsRetVal\nbatchInit(batch_t *pBatch, int maxElem) {\n\tDEFiRet;\n\tpBatch->iDoneUpTo = 0;\n\tpBatch->maxElem = maxElem;\n\tCHKmalloc(pBatch->pElem = calloc((size_t)maxElem, sizeof(batch_obj_t)));\n\t// TODO: replace calloc by inidividual writes?\nfinalize_it:\n\tRETiRet;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,7 @@\n static inline rsRetVal\n batchInit(batch_t *pBatch, int maxElem) {\n \tDEFiRet;\n+\tpBatch->iDoneUpTo = 0;\n \tpBatch->maxElem = maxElem;\n \tCHKmalloc(pBatch->pElem = calloc((size_t)maxElem, sizeof(batch_obj_t)));\n \t// TODO: replace calloc by inidividual writes?",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tpBatch->iDoneUpTo = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-1488",
        "func_name": "rsyslog/batchCopyElem",
        "description": "A memory leak in rsyslog before 5.7.6 was found in the way deamon processed log messages are logged when $RepeatedMsgReduction was enabled. A local attacker could use this flaw to cause a denial of the rsyslogd daemon service by crashing the service via a sequence of repeated log messages sent within short periods of time.",
        "git_url": "https://github.com/rsyslog/rsyslog/commit/1ef709cc97d54f74d3fdeb83788cc4b01f4c6a2a",
        "commit_title": "bugfix: fixed a memory leak and potential abort condition",
        "commit_text": " this could happen if multiple rulesets were used and some output batches contained messages belonging to more than one ruleset. fixes: http://bugzilla.adiscon.com/show_bug.cgi?id=226 fixes: http://bugzilla.adiscon.com/show_bug.cgi?id=218",
        "func_before": "static inline void\nbatchCopyElem(batch_obj_t *pDest, batch_obj_t *pSrc) {\n\tmemcpy(pDest, pSrc, sizeof(batch_obj_t));\n}",
        "func": "static inline void\nbatchCopyElem(batch_obj_t *pDest, batch_obj_t *pSrc) {\n\tmemset(pDest, 0, sizeof(batch_obj_t));\n\tpDest->pUsrp = pSrc->pUsrp;\n\tpDest->state = pSrc->state;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,6 @@\n static inline void\n batchCopyElem(batch_obj_t *pDest, batch_obj_t *pSrc) {\n-\tmemcpy(pDest, pSrc, sizeof(batch_obj_t));\n+\tmemset(pDest, 0, sizeof(batch_obj_t));\n+\tpDest->pUsrp = pSrc->pUsrp;\n+\tpDest->state = pSrc->state;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tmemcpy(pDest, pSrc, sizeof(batch_obj_t));"
            ],
            "added_lines": [
                "\tmemset(pDest, 0, sizeof(batch_obj_t));",
                "\tpDest->pUsrp = pSrc->pUsrp;",
                "\tpDest->state = pSrc->state;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19533",
        "func_name": "torvalds/linux/ttusb_dec_send_command",
        "description": "In the Linux kernel before 5.3.4, there is an info-leak bug that can be caused by a malicious USB device in the drivers/media/usb/ttusb-dec/ttusb_dec.c driver, aka CID-a10feaf8c464.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=a10feaf8c464c3f9cfdd3a8a7ce17e1c0d498da1",
        "commit_title": "The function at issue does not always initialize each byte allocated",
        "commit_text": "for 'b' and can therefore leak uninitialized memory to a USB device in the call to usb_bulk_msg()  Use kzalloc() instead of kmalloc()  ",
        "func_before": "static int ttusb_dec_send_command(struct ttusb_dec *dec, const u8 command,\n\t\t\t\t  int param_length, const u8 params[],\n\t\t\t\t  int *result_length, u8 cmd_result[])\n{\n\tint result, actual_len;\n\tu8 *b;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tb = kmalloc(COMMAND_PACKET_SIZE + 4, GFP_KERNEL);\n\tif (!b)\n\t\treturn -ENOMEM;\n\n\tif ((result = mutex_lock_interruptible(&dec->usb_mutex))) {\n\t\tkfree(b);\n\t\tprintk(\"%s: Failed to lock usb mutex.\\n\", __func__);\n\t\treturn result;\n\t}\n\n\tb[0] = 0xaa;\n\tb[1] = ++dec->trans_count;\n\tb[2] = command;\n\tb[3] = param_length;\n\n\tif (params)\n\t\tmemcpy(&b[4], params, param_length);\n\n\tif (debug) {\n\t\tprintk(KERN_DEBUG \"%s: command: %*ph\\n\",\n\t\t       __func__, param_length, b);\n\t}\n\n\tresult = usb_bulk_msg(dec->udev, dec->command_pipe, b,\n\t\t\t      COMMAND_PACKET_SIZE + 4, &actual_len, 1000);\n\n\tif (result) {\n\t\tprintk(\"%s: command bulk message failed: error %d\\n\",\n\t\t       __func__, result);\n\t\tmutex_unlock(&dec->usb_mutex);\n\t\tkfree(b);\n\t\treturn result;\n\t}\n\n\tresult = usb_bulk_msg(dec->udev, dec->result_pipe, b,\n\t\t\t      COMMAND_PACKET_SIZE + 4, &actual_len, 1000);\n\n\tif (result) {\n\t\tprintk(\"%s: result bulk message failed: error %d\\n\",\n\t\t       __func__, result);\n\t\tmutex_unlock(&dec->usb_mutex);\n\t\tkfree(b);\n\t\treturn result;\n\t} else {\n\t\tif (debug) {\n\t\t\tprintk(KERN_DEBUG \"%s: result: %*ph\\n\",\n\t\t\t       __func__, actual_len, b);\n\t\t}\n\n\t\tif (result_length)\n\t\t\t*result_length = b[3];\n\t\tif (cmd_result && b[3] > 0)\n\t\t\tmemcpy(cmd_result, &b[4], b[3]);\n\n\t\tmutex_unlock(&dec->usb_mutex);\n\n\t\tkfree(b);\n\t\treturn 0;\n\t}\n}",
        "func": "static int ttusb_dec_send_command(struct ttusb_dec *dec, const u8 command,\n\t\t\t\t  int param_length, const u8 params[],\n\t\t\t\t  int *result_length, u8 cmd_result[])\n{\n\tint result, actual_len;\n\tu8 *b;\n\n\tdprintk(\"%s\\n\", __func__);\n\n\tb = kzalloc(COMMAND_PACKET_SIZE + 4, GFP_KERNEL);\n\tif (!b)\n\t\treturn -ENOMEM;\n\n\tif ((result = mutex_lock_interruptible(&dec->usb_mutex))) {\n\t\tkfree(b);\n\t\tprintk(\"%s: Failed to lock usb mutex.\\n\", __func__);\n\t\treturn result;\n\t}\n\n\tb[0] = 0xaa;\n\tb[1] = ++dec->trans_count;\n\tb[2] = command;\n\tb[3] = param_length;\n\n\tif (params)\n\t\tmemcpy(&b[4], params, param_length);\n\n\tif (debug) {\n\t\tprintk(KERN_DEBUG \"%s: command: %*ph\\n\",\n\t\t       __func__, param_length, b);\n\t}\n\n\tresult = usb_bulk_msg(dec->udev, dec->command_pipe, b,\n\t\t\t      COMMAND_PACKET_SIZE + 4, &actual_len, 1000);\n\n\tif (result) {\n\t\tprintk(\"%s: command bulk message failed: error %d\\n\",\n\t\t       __func__, result);\n\t\tmutex_unlock(&dec->usb_mutex);\n\t\tkfree(b);\n\t\treturn result;\n\t}\n\n\tresult = usb_bulk_msg(dec->udev, dec->result_pipe, b,\n\t\t\t      COMMAND_PACKET_SIZE + 4, &actual_len, 1000);\n\n\tif (result) {\n\t\tprintk(\"%s: result bulk message failed: error %d\\n\",\n\t\t       __func__, result);\n\t\tmutex_unlock(&dec->usb_mutex);\n\t\tkfree(b);\n\t\treturn result;\n\t} else {\n\t\tif (debug) {\n\t\t\tprintk(KERN_DEBUG \"%s: result: %*ph\\n\",\n\t\t\t       __func__, actual_len, b);\n\t\t}\n\n\t\tif (result_length)\n\t\t\t*result_length = b[3];\n\t\tif (cmd_result && b[3] > 0)\n\t\t\tmemcpy(cmd_result, &b[4], b[3]);\n\n\t\tmutex_unlock(&dec->usb_mutex);\n\n\t\tkfree(b);\n\t\treturn 0;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,7 @@\n \n \tdprintk(\"%s\\n\", __func__);\n \n-\tb = kmalloc(COMMAND_PACKET_SIZE + 4, GFP_KERNEL);\n+\tb = kzalloc(COMMAND_PACKET_SIZE + 4, GFP_KERNEL);\n \tif (!b)\n \t\treturn -ENOMEM;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tb = kmalloc(COMMAND_PACKET_SIZE + 4, GFP_KERNEL);"
            ],
            "added_lines": [
                "\tb = kzalloc(COMMAND_PACKET_SIZE + 4, GFP_KERNEL);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11447",
        "func_name": "ImageMagick/ReadSCREENSHOTImage",
        "description": "The ReadSCREENSHOTImage function in coders/screenshot.c in ImageMagick before 7.0.6-1 has memory leaks, causing denial of service.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/72a50e400d98d7a2fd610caedfeb9af043dc5582",
        "commit_title": "Fixed potential memory leak.",
        "commit_text": "",
        "func_before": "static Image *ReadSCREENSHOTImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=(Image *) NULL;\n#if defined(MAGICKCORE_WINGDI32_DELEGATE)\n  {\n    BITMAPINFO\n      bmi;\n\n    DISPLAY_DEVICE\n      device;\n\n    HBITMAP\n      bitmap,\n      bitmapOld;\n\n    HDC\n      bitmapDC,\n      hDC;\n\n    Image\n      *screen;\n\n    int\n      i;\n\n    MagickBooleanType\n      status;\n\n    register Quantum\n      *q;\n\n    register ssize_t\n      x;\n\n    RGBTRIPLE\n      *p;\n\n    ssize_t\n      y;\n\n    assert(image_info != (const ImageInfo *) NULL);\n    i=0;\n    device.cb = sizeof(device);\n    image=(Image *) NULL;\n    while(EnumDisplayDevices(NULL,i,&device,0) && ++i)\n    {\n      if ((device.StateFlags & DISPLAY_DEVICE_ACTIVE) != DISPLAY_DEVICE_ACTIVE)\n        continue;\n\n      hDC=CreateDC(device.DeviceName,device.DeviceName,NULL,NULL);\n      if (hDC == (HDC) NULL)\n        ThrowReaderException(CoderError,\"UnableToCreateDC\");\n\n      screen=AcquireImage(image_info,exception);\n      screen->columns=(size_t) GetDeviceCaps(hDC,HORZRES);\n      screen->rows=(size_t) GetDeviceCaps(hDC,VERTRES);\n      screen->storage_class=DirectClass;\n      status=SetImageExtent(screen,screen->columns,screen->rows,exception);\n      if (status == MagickFalse)\n        return(DestroyImageList(image));\n      if (image == (Image *) NULL)\n        image=screen;\n      else\n        AppendImageToList(&image,screen);\n\n      bitmapDC=CreateCompatibleDC(hDC);\n      if (bitmapDC == (HDC) NULL)\n        {\n          DeleteDC(hDC);\n          ThrowReaderException(CoderError,\"UnableToCreateDC\");\n        }\n      (void) ResetMagickMemory(&bmi,0,sizeof(BITMAPINFO));\n      bmi.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);\n      bmi.bmiHeader.biWidth=(LONG) screen->columns;\n      bmi.bmiHeader.biHeight=(-1)*(LONG) screen->rows;\n      bmi.bmiHeader.biPlanes=1;\n      bmi.bmiHeader.biBitCount=24;\n      bmi.bmiHeader.biCompression=BI_RGB;\n      bitmap=CreateDIBSection(hDC,&bmi,DIB_RGB_COLORS,(void **) &p,NULL,0);\n      if (bitmap == (HBITMAP) NULL)\n        {\n          DeleteDC(hDC);\n          DeleteDC(bitmapDC);\n          ThrowReaderException(CoderError,\"UnableToCreateBitmap\");\n        }\n      bitmapOld=(HBITMAP) SelectObject(bitmapDC,bitmap);\n      if (bitmapOld == (HBITMAP) NULL)\n        {\n          DeleteDC(hDC);\n          DeleteDC(bitmapDC);\n          DeleteObject(bitmap);\n          ThrowReaderException(CoderError,\"UnableToCreateBitmap\");\n        }\n      BitBlt(bitmapDC,0,0,(int) screen->columns,(int) screen->rows,hDC,0,0,\n        SRCCOPY);\n      (void) SelectObject(bitmapDC,bitmapOld);\n\n      for (y=0; y < (ssize_t) screen->rows; y++)\n      {\n        q=QueueAuthenticPixels(screen,0,y,screen->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) screen->columns; x++)\n        {\n          SetPixelRed(image,ScaleCharToQuantum(p->rgbtRed),q);\n          SetPixelGreen(image,ScaleCharToQuantum(p->rgbtGreen),q);\n          SetPixelBlue(image,ScaleCharToQuantum(p->rgbtBlue),q);\n          SetPixelAlpha(image,OpaqueAlpha,q);\n          p++;\n          q+=GetPixelChannels(image);\n        }\n        if (SyncAuthenticPixels(screen,exception) == MagickFalse)\n          break;\n      }\n\n      DeleteDC(hDC);\n      DeleteDC(bitmapDC);\n      DeleteObject(bitmap);\n    }\n  }\n#elif defined(MAGICKCORE_X11_DELEGATE)\n  {\n    const char\n      *option;\n\n    XImportInfo\n      ximage_info;\n\n    XGetImportInfo(&ximage_info);\n    option=GetImageOption(image_info,\"x:screen\");\n    if (option != (const char *) NULL)\n      ximage_info.screen=IsStringTrue(option);\n    option=GetImageOption(image_info,\"x:silent\");\n    if (option != (const char *) NULL)\n      ximage_info.silent=IsStringTrue(option);\n    image=XImportImage(image_info,&ximage_info,exception);\n  }\n#endif\n  return(image);\n}",
        "func": "static Image *ReadSCREENSHOTImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=(Image *) NULL;\n#if defined(MAGICKCORE_WINGDI32_DELEGATE)\n  {\n    BITMAPINFO\n      bmi;\n\n    DISPLAY_DEVICE\n      device;\n\n    HBITMAP\n      bitmap,\n      bitmapOld;\n\n    HDC\n      bitmapDC,\n      hDC;\n\n    Image\n      *screen;\n\n    int\n      i;\n\n    MagickBooleanType\n      status;\n\n    register Quantum\n      *q;\n\n    register ssize_t\n      x;\n\n    RGBTRIPLE\n      *p;\n\n    ssize_t\n      y;\n\n    assert(image_info != (const ImageInfo *) NULL);\n    i=0;\n    device.cb = sizeof(device);\n    image=(Image *) NULL;\n    while(EnumDisplayDevices(NULL,i,&device,0) && ++i)\n    {\n      if ((device.StateFlags & DISPLAY_DEVICE_ACTIVE) != DISPLAY_DEVICE_ACTIVE)\n        continue;\n\n      hDC=CreateDC(device.DeviceName,device.DeviceName,NULL,NULL);\n      if (hDC == (HDC) NULL)\n        ThrowReaderException(CoderError,\"UnableToCreateDC\");\n\n      screen=AcquireImage(image_info,exception);\n      screen->columns=(size_t) GetDeviceCaps(hDC,HORZRES);\n      screen->rows=(size_t) GetDeviceCaps(hDC,VERTRES);\n      screen->storage_class=DirectClass;\n      if (image == (Image *) NULL)\n        image=screen;\n      else\n        AppendImageToList(&image,screen);\n      status=SetImageExtent(screen,screen->columns,screen->rows,exception);\n      if (status == MagickFalse)\n        return(DestroyImageList(image));\n\n      bitmapDC=CreateCompatibleDC(hDC);\n      if (bitmapDC == (HDC) NULL)\n        {\n          DeleteDC(hDC);\n          ThrowReaderException(CoderError,\"UnableToCreateDC\");\n        }\n      (void) ResetMagickMemory(&bmi,0,sizeof(BITMAPINFO));\n      bmi.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);\n      bmi.bmiHeader.biWidth=(LONG) screen->columns;\n      bmi.bmiHeader.biHeight=(-1)*(LONG) screen->rows;\n      bmi.bmiHeader.biPlanes=1;\n      bmi.bmiHeader.biBitCount=24;\n      bmi.bmiHeader.biCompression=BI_RGB;\n      bitmap=CreateDIBSection(hDC,&bmi,DIB_RGB_COLORS,(void **) &p,NULL,0);\n      if (bitmap == (HBITMAP) NULL)\n        {\n          DeleteDC(hDC);\n          DeleteDC(bitmapDC);\n          ThrowReaderException(CoderError,\"UnableToCreateBitmap\");\n        }\n      bitmapOld=(HBITMAP) SelectObject(bitmapDC,bitmap);\n      if (bitmapOld == (HBITMAP) NULL)\n        {\n          DeleteDC(hDC);\n          DeleteDC(bitmapDC);\n          DeleteObject(bitmap);\n          ThrowReaderException(CoderError,\"UnableToCreateBitmap\");\n        }\n      BitBlt(bitmapDC,0,0,(int) screen->columns,(int) screen->rows,hDC,0,0,\n        SRCCOPY);\n      (void) SelectObject(bitmapDC,bitmapOld);\n\n      for (y=0; y < (ssize_t) screen->rows; y++)\n      {\n        q=QueueAuthenticPixels(screen,0,y,screen->columns,1,exception);\n        if (q == (Quantum *) NULL)\n          break;\n        for (x=0; x < (ssize_t) screen->columns; x++)\n        {\n          SetPixelRed(image,ScaleCharToQuantum(p->rgbtRed),q);\n          SetPixelGreen(image,ScaleCharToQuantum(p->rgbtGreen),q);\n          SetPixelBlue(image,ScaleCharToQuantum(p->rgbtBlue),q);\n          SetPixelAlpha(image,OpaqueAlpha,q);\n          p++;\n          q+=GetPixelChannels(image);\n        }\n        if (SyncAuthenticPixels(screen,exception) == MagickFalse)\n          break;\n      }\n\n      DeleteDC(hDC);\n      DeleteDC(bitmapDC);\n      DeleteObject(bitmap);\n    }\n  }\n#elif defined(MAGICKCORE_X11_DELEGATE)\n  {\n    const char\n      *option;\n\n    XImportInfo\n      ximage_info;\n\n    XGetImportInfo(&ximage_info);\n    option=GetImageOption(image_info,\"x:screen\");\n    if (option != (const char *) NULL)\n      ximage_info.screen=IsStringTrue(option);\n    option=GetImageOption(image_info,\"x:silent\");\n    if (option != (const char *) NULL)\n      ximage_info.silent=IsStringTrue(option);\n    image=XImportImage(image_info,&ximage_info,exception);\n  }\n#endif\n  return(image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -65,13 +65,13 @@\n       screen->columns=(size_t) GetDeviceCaps(hDC,HORZRES);\n       screen->rows=(size_t) GetDeviceCaps(hDC,VERTRES);\n       screen->storage_class=DirectClass;\n-      status=SetImageExtent(screen,screen->columns,screen->rows,exception);\n-      if (status == MagickFalse)\n-        return(DestroyImageList(image));\n       if (image == (Image *) NULL)\n         image=screen;\n       else\n         AppendImageToList(&image,screen);\n+      status=SetImageExtent(screen,screen->columns,screen->rows,exception);\n+      if (status == MagickFalse)\n+        return(DestroyImageList(image));\n \n       bitmapDC=CreateCompatibleDC(hDC);\n       if (bitmapDC == (HDC) NULL)",
        "diff_line_info": {
            "deleted_lines": [
                "      status=SetImageExtent(screen,screen->columns,screen->rows,exception);",
                "      if (status == MagickFalse)",
                "        return(DestroyImageList(image));"
            ],
            "added_lines": [
                "      status=SetImageExtent(screen,screen->columns,screen->rows,exception);",
                "      if (status == MagickFalse)",
                "        return(DestroyImageList(image));"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11528",
        "func_name": "ImageMagick/ReadDIBImage",
        "description": "The ReadDIBImage function in coders/dib.c in ImageMagick before 6.9.9-0 and 7.x before 7.0.6-1 allows remote attackers to cause a denial of service (memory leak) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/e5b294754697d9e261224ad4f6e8eeee9e04275f",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/522",
        "commit_text": "",
        "func_before": "static Image *ReadDIBImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  DIBInfo\n    dib_info;\n\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  ssize_t\n    bit,\n    y;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *pixel_info;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_line,\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a DIB file.\n  */\n  (void) ResetMagickMemory(&dib_info,0,sizeof(dib_info));\n  dib_info.size=ReadBlobLSBLong(image);\n  if (dib_info.size != 40)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Microsoft Windows 3.X DIB image file.\n  */\n  dib_info.width=ReadBlobLSBSignedLong(image);\n  dib_info.height=ReadBlobLSBSignedLong(image);\n  dib_info.planes=ReadBlobLSBShort(image);\n  dib_info.bits_per_pixel=ReadBlobLSBShort(image);\n  dib_info.compression=ReadBlobLSBLong(image);\n  dib_info.image_size=ReadBlobLSBLong(image);\n  dib_info.x_pixels=ReadBlobLSBLong(image);\n  dib_info.y_pixels=ReadBlobLSBLong(image);\n  dib_info.number_colors=ReadBlobLSBLong(image);\n  dib_info.colors_important=ReadBlobLSBLong(image);\n  if ((dib_info.bits_per_pixel != 1) && (dib_info.bits_per_pixel != 4) &&\n      (dib_info.bits_per_pixel != 8) && (dib_info.bits_per_pixel != 16) &&\n      (dib_info.bits_per_pixel != 24) && (dib_info.bits_per_pixel != 32))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((dib_info.compression == BI_BITFIELDS) &&\n      ((dib_info.bits_per_pixel == 16) || (dib_info.bits_per_pixel == 32)))\n    {\n      dib_info.red_mask=ReadBlobLSBLong(image);\n      dib_info.green_mask=ReadBlobLSBLong(image);\n      dib_info.blue_mask=ReadBlobLSBLong(image);\n    }\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  if (dib_info.width <= 0)\n    ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n  if (dib_info.height == 0)\n    ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n  if (dib_info.planes != 1)\n    ThrowReaderException(CorruptImageError,\"StaticPlanesValueNotEqualToOne\");\n  if ((dib_info.bits_per_pixel != 1) && (dib_info.bits_per_pixel != 4) &&\n      (dib_info.bits_per_pixel != 8) && (dib_info.bits_per_pixel != 16) &&\n      (dib_info.bits_per_pixel != 24) && (dib_info.bits_per_pixel != 32))\n    ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n  if (dib_info.bits_per_pixel < 16 &&\n      dib_info.number_colors > (size_t) (1UL << dib_info.bits_per_pixel))\n    ThrowReaderException(CorruptImageError,\"UnrecognizedNumberOfColors\");\n  if ((dib_info.compression == 1) && (dib_info.bits_per_pixel != 8))\n    ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n  if ((dib_info.compression == 2) && (dib_info.bits_per_pixel != 4))\n    ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n  if ((dib_info.compression == 3) && (dib_info.bits_per_pixel < 16))\n    ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n  switch (dib_info.compression)\n  {\n    case BI_RGB:\n    case BI_RLE8:\n    case BI_RLE4:\n    case BI_BITFIELDS:\n      break;\n    case BI_JPEG:\n      ThrowReaderException(CoderError,\"JPEGCompressNotSupported\");\n    case BI_PNG:\n      ThrowReaderException(CoderError,\"PNGCompressNotSupported\");\n    default:\n      ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n  }\n  image->columns=(size_t) MagickAbsoluteValue(dib_info.width);\n  image->rows=(size_t) MagickAbsoluteValue(dib_info.height);\n  image->matte=dib_info.bits_per_pixel == 32 ? MagickTrue : MagickFalse;\n  image->depth=8;\n  if ((dib_info.number_colors > 256) || (dib_info.colors_important > 256))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((dib_info.number_colors != 0) || (dib_info.bits_per_pixel < 16))\n    {\n      size_t\n        one;\n\n      image->storage_class=PseudoClass;\n      image->colors=dib_info.number_colors;\n      one=1;\n      if (image->colors == 0)\n        image->colors=one << dib_info.bits_per_pixel;\n    }\n  if (image_info->size)\n    {\n      RectangleInfo\n        geometry;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseAbsoluteGeometry(image_info->size,&geometry);\n      if (flags & WidthValue)\n        if ((geometry.width != 0) && (geometry.width < image->columns))\n          image->columns=geometry.width;\n      if (flags & HeightValue)\n        if ((geometry.height != 0) && (geometry.height < image->rows))\n          image->rows=geometry.height;\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if (image->storage_class == PseudoClass)\n    {\n      size_t\n        length,\n        packet_size;\n\n      unsigned char\n        *dib_colormap;\n\n      /*\n        Read DIB raster colormap.\n      */\n      if (AcquireImageColormap(image,image->colors) == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      length=(size_t) image->colors;\n      dib_colormap=(unsigned char *) AcquireQuantumMemory(length,\n        4*sizeof(*dib_colormap));\n      if (dib_colormap == (unsigned char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      packet_size=4;\n      count=ReadBlob(image,packet_size*image->colors,dib_colormap);\n      if (count != (ssize_t) (packet_size*image->colors))\n        ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n      p=dib_colormap;\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        image->colormap[i].blue=ScaleCharToQuantum(*p++);\n        image->colormap[i].green=ScaleCharToQuantum(*p++);\n        image->colormap[i].red=ScaleCharToQuantum(*p++);\n        if (packet_size == 4)\n          p++;\n      }\n      dib_colormap=(unsigned char *) RelinquishMagickMemory(dib_colormap);\n    }\n  /*\n    Read image data.\n  */\n  if (dib_info.compression == BI_RLE4)\n    dib_info.bits_per_pixel<<=1;\n  bytes_per_line=4*((image->columns*dib_info.bits_per_pixel+31)/32);\n  length=bytes_per_line*image->rows;\n  pixel_info=AcquireVirtualMemory((size_t) image->rows,MagickMax(\n    bytes_per_line,image->columns+256UL)*sizeof(*pixels));\n  if (pixel_info == (MemoryInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n  if ((dib_info.compression == BI_RGB) ||\n      (dib_info.compression == BI_BITFIELDS))\n    {\n      count=ReadBlob(image,length,pixels);\n      if (count != (ssize_t) (length))\n        {\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        }\n    }\n  else\n    {\n      /*\n        Convert run-length encoded raster pixels.\n      */\n      status=DecodeImage(image,dib_info.compression ? MagickTrue : MagickFalse,\n        pixels);\n      if (status == MagickFalse)\n        {\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n          ThrowReaderException(CorruptImageError,\n            \"UnableToRunlengthDecodeImage\");\n        }\n    }\n  /*\n    Initialize image structure.\n  */\n  image->units=PixelsPerCentimeterResolution;\n  image->x_resolution=(double) dib_info.x_pixels/100.0;\n  image->y_resolution=(double) dib_info.y_pixels/100.0;\n  /*\n    Convert DIB raster image to pixel packets.\n  */\n  switch (dib_info.bits_per_pixel)\n  {\n    case 1:\n    {\n      /*\n        Convert bitmap scanline.\n      */\n      for (y=(ssize_t) image->rows-1; y >= 0; y--)\n      {\n        p=pixels+(image->rows-y-1)*bytes_per_line;\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=0; bit < 8; bit++)\n          {\n            index=(IndexPacket) ((*p) & (0x80 >> bit) ? 0x01 : 0x00);\n            SetPixelIndex(indexes+x+bit,index);\n          }\n          p++;\n        }\n        if ((image->columns % 8) != 0)\n          {\n            for (bit=0; bit < (ssize_t) (image->columns % 8); bit++)\n            {\n              index=(IndexPacket) ((*p) & (0x80 >> bit) ? 0x01 : 0x00);\n              SetPixelIndex(indexes+x+bit,index);\n            }\n            p++;\n          }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n      (void) SyncImage(image);\n      break;\n    }\n    case 4:\n    {\n      /*\n        Convert PseudoColor scanline.\n      */\n      for (y=(ssize_t) image->rows-1; y >= 0; y--)\n      {\n        p=pixels+(image->rows-y-1)*bytes_per_line;\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n        {\n          index=ConstrainColormapIndex(image,(*p >> 4) & 0xf);\n          SetPixelIndex(indexes+x,index);\n          index=ConstrainColormapIndex(image,*p & 0xf);\n          SetPixelIndex(indexes+x+1,index);\n          p++;\n        }\n        if ((image->columns % 2) != 0)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0xf);\n            SetPixelIndex(indexes+x,index);\n            p++;\n          }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n      (void) SyncImage(image);\n      break;\n    }\n    case 8:\n    {\n      /*\n        Convert PseudoColor scanline.\n      */\n      if ((dib_info.compression == BI_RLE8) ||\n          (dib_info.compression == BI_RLE4))\n        bytes_per_line=image->columns;\n      for (y=(ssize_t) image->rows-1; y >= 0; y--)\n      {\n        p=pixels+(image->rows-y-1)*bytes_per_line;\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          index=ConstrainColormapIndex(image,*p);\n          SetPixelIndex(indexes+x,index);\n          p++;\n          q++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n      (void) SyncImage(image);\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        word;\n\n      /*\n        Convert PseudoColor scanline.\n      */\n      image->storage_class=DirectClass;\n      if (dib_info.compression == BI_RLE8)\n        bytes_per_line=2*image->columns;\n      for (y=(ssize_t) image->rows-1; y >= 0; y--)\n      {\n        p=pixels+(image->rows-y-1)*bytes_per_line;\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          word=(*p++);\n          word|=(*p++ << 8);\n          if (dib_info.red_mask == 0)\n            {\n              SetPixelRed(q,ScaleCharToQuantum(ScaleColor5to8(\n                (unsigned char) ((word >> 10) & 0x1f))));\n              SetPixelGreen(q,ScaleCharToQuantum(ScaleColor5to8(\n                (unsigned char) ((word >> 5) & 0x1f))));\n              SetPixelBlue(q,ScaleCharToQuantum(ScaleColor5to8(\n                (unsigned char) (word & 0x1f))));\n            }\n          else\n            {\n              SetPixelRed(q,ScaleCharToQuantum(ScaleColor5to8(\n                (unsigned char) ((word >> 11) & 0x1f))));\n              SetPixelGreen(q,ScaleCharToQuantum(ScaleColor6to8(\n                (unsigned char) ((word >> 5) & 0x3f))));\n              SetPixelBlue(q,ScaleCharToQuantum(ScaleColor5to8(\n                (unsigned char) (word & 0x1f))));\n            }\n          q++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n      break;\n    }\n    case 24:\n    case 32:\n    {\n      /*\n        Convert DirectColor scanline.\n      */\n      for (y=(ssize_t) image->rows-1; y >= 0; y--)\n      {\n        p=pixels+(image->rows-y-1)*bytes_per_line;\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          SetPixelBlue(q,ScaleCharToQuantum(*p++));\n          SetPixelGreen(q,ScaleCharToQuantum(*p++));\n          SetPixelRed(q,ScaleCharToQuantum(*p++));\n          if (image->matte != MagickFalse)\n            SetPixelOpacity(q,ScaleCharToQuantum(*p++));\n          q++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n      break;\n    }\n    default:\n    {\n      pixel_info=RelinquishVirtualMemory(pixel_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  }\n  pixel_info=RelinquishVirtualMemory(pixel_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  if (dib_info.height < 0)\n    {\n      Image\n        *flipped_image;\n\n      /*\n        Correct image orientation.\n      */\n      flipped_image=FlipImage(image,exception);\n      if (flipped_image != (Image *) NULL)\n        {\n          DuplicateBlob(flipped_image,image);\n          image=DestroyImage(image);\n          image=flipped_image;\n        }\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadDIBImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  DIBInfo\n    dib_info;\n\n  Image\n    *image;\n\n  IndexPacket\n    index;\n\n  ssize_t\n    bit,\n    y;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *pixel_info;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_line,\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a DIB file.\n  */\n  (void) ResetMagickMemory(&dib_info,0,sizeof(dib_info));\n  dib_info.size=ReadBlobLSBLong(image);\n  if (dib_info.size != 40)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Microsoft Windows 3.X DIB image file.\n  */\n  dib_info.width=ReadBlobLSBSignedLong(image);\n  dib_info.height=ReadBlobLSBSignedLong(image);\n  dib_info.planes=ReadBlobLSBShort(image);\n  dib_info.bits_per_pixel=ReadBlobLSBShort(image);\n  dib_info.compression=ReadBlobLSBLong(image);\n  dib_info.image_size=ReadBlobLSBLong(image);\n  dib_info.x_pixels=ReadBlobLSBLong(image);\n  dib_info.y_pixels=ReadBlobLSBLong(image);\n  dib_info.number_colors=ReadBlobLSBLong(image);\n  dib_info.colors_important=ReadBlobLSBLong(image);\n  if ((dib_info.bits_per_pixel != 1) && (dib_info.bits_per_pixel != 4) &&\n      (dib_info.bits_per_pixel != 8) && (dib_info.bits_per_pixel != 16) &&\n      (dib_info.bits_per_pixel != 24) && (dib_info.bits_per_pixel != 32))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((dib_info.compression == BI_BITFIELDS) &&\n      ((dib_info.bits_per_pixel == 16) || (dib_info.bits_per_pixel == 32)))\n    {\n      dib_info.red_mask=ReadBlobLSBLong(image);\n      dib_info.green_mask=ReadBlobLSBLong(image);\n      dib_info.blue_mask=ReadBlobLSBLong(image);\n    }\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  if (dib_info.width <= 0)\n    ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n  if (dib_info.height == 0)\n    ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n  if (dib_info.planes != 1)\n    ThrowReaderException(CorruptImageError,\"StaticPlanesValueNotEqualToOne\");\n  if ((dib_info.bits_per_pixel != 1) && (dib_info.bits_per_pixel != 4) &&\n      (dib_info.bits_per_pixel != 8) && (dib_info.bits_per_pixel != 16) &&\n      (dib_info.bits_per_pixel != 24) && (dib_info.bits_per_pixel != 32))\n    ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n  if (dib_info.bits_per_pixel < 16 &&\n      dib_info.number_colors > (size_t) (1UL << dib_info.bits_per_pixel))\n    ThrowReaderException(CorruptImageError,\"UnrecognizedNumberOfColors\");\n  if ((dib_info.compression == 1) && (dib_info.bits_per_pixel != 8))\n    ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n  if ((dib_info.compression == 2) && (dib_info.bits_per_pixel != 4))\n    ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n  if ((dib_info.compression == 3) && (dib_info.bits_per_pixel < 16))\n    ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n  switch (dib_info.compression)\n  {\n    case BI_RGB:\n    case BI_RLE8:\n    case BI_RLE4:\n    case BI_BITFIELDS:\n      break;\n    case BI_JPEG:\n      ThrowReaderException(CoderError,\"JPEGCompressNotSupported\");\n    case BI_PNG:\n      ThrowReaderException(CoderError,\"PNGCompressNotSupported\");\n    default:\n      ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n  }\n  image->columns=(size_t) MagickAbsoluteValue(dib_info.width);\n  image->rows=(size_t) MagickAbsoluteValue(dib_info.height);\n  image->matte=dib_info.bits_per_pixel == 32 ? MagickTrue : MagickFalse;\n  image->depth=8;\n  if ((dib_info.number_colors > 256) || (dib_info.colors_important > 256))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((dib_info.number_colors != 0) || (dib_info.bits_per_pixel < 16))\n    {\n      size_t\n        one;\n\n      image->storage_class=PseudoClass;\n      image->colors=dib_info.number_colors;\n      one=1;\n      if (image->colors == 0)\n        image->colors=one << dib_info.bits_per_pixel;\n    }\n  if (image_info->size)\n    {\n      RectangleInfo\n        geometry;\n\n      MagickStatusType\n        flags;\n\n      flags=ParseAbsoluteGeometry(image_info->size,&geometry);\n      if (flags & WidthValue)\n        if ((geometry.width != 0) && (geometry.width < image->columns))\n          image->columns=geometry.width;\n      if (flags & HeightValue)\n        if ((geometry.height != 0) && (geometry.height < image->rows))\n          image->rows=geometry.height;\n    }\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if (image->storage_class == PseudoClass)\n    {\n      size_t\n        length,\n        packet_size;\n\n      unsigned char\n        *dib_colormap;\n\n      /*\n        Read DIB raster colormap.\n      */\n      if (AcquireImageColormap(image,image->colors) == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      length=(size_t) image->colors;\n      dib_colormap=(unsigned char *) AcquireQuantumMemory(length,\n        4*sizeof(*dib_colormap));\n      if (dib_colormap == (unsigned char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      packet_size=4;\n      count=ReadBlob(image,packet_size*image->colors,dib_colormap);\n      if (count != (ssize_t) (packet_size*image->colors))\n        {\n          dib_colormap=(unsigned char *) RelinquishMagickMemory(dib_colormap);\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        }\n      p=dib_colormap;\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        image->colormap[i].blue=ScaleCharToQuantum(*p++);\n        image->colormap[i].green=ScaleCharToQuantum(*p++);\n        image->colormap[i].red=ScaleCharToQuantum(*p++);\n        if (packet_size == 4)\n          p++;\n      }\n      dib_colormap=(unsigned char *) RelinquishMagickMemory(dib_colormap);\n    }\n  /*\n    Read image data.\n  */\n  if (dib_info.compression == BI_RLE4)\n    dib_info.bits_per_pixel<<=1;\n  bytes_per_line=4*((image->columns*dib_info.bits_per_pixel+31)/32);\n  length=bytes_per_line*image->rows;\n  pixel_info=AcquireVirtualMemory((size_t) image->rows,MagickMax(\n    bytes_per_line,image->columns+256UL)*sizeof(*pixels));\n  if (pixel_info == (MemoryInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n  if ((dib_info.compression == BI_RGB) ||\n      (dib_info.compression == BI_BITFIELDS))\n    {\n      count=ReadBlob(image,length,pixels);\n      if (count != (ssize_t) (length))\n        {\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        }\n    }\n  else\n    {\n      /*\n        Convert run-length encoded raster pixels.\n      */\n      status=DecodeImage(image,dib_info.compression ? MagickTrue : MagickFalse,\n        pixels);\n      if (status == MagickFalse)\n        {\n          pixel_info=RelinquishVirtualMemory(pixel_info);\n          ThrowReaderException(CorruptImageError,\n            \"UnableToRunlengthDecodeImage\");\n        }\n    }\n  /*\n    Initialize image structure.\n  */\n  image->units=PixelsPerCentimeterResolution;\n  image->x_resolution=(double) dib_info.x_pixels/100.0;\n  image->y_resolution=(double) dib_info.y_pixels/100.0;\n  /*\n    Convert DIB raster image to pixel packets.\n  */\n  switch (dib_info.bits_per_pixel)\n  {\n    case 1:\n    {\n      /*\n        Convert bitmap scanline.\n      */\n      for (y=(ssize_t) image->rows-1; y >= 0; y--)\n      {\n        p=pixels+(image->rows-y-1)*bytes_per_line;\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < ((ssize_t) image->columns-7); x+=8)\n        {\n          for (bit=0; bit < 8; bit++)\n          {\n            index=(IndexPacket) ((*p) & (0x80 >> bit) ? 0x01 : 0x00);\n            SetPixelIndex(indexes+x+bit,index);\n          }\n          p++;\n        }\n        if ((image->columns % 8) != 0)\n          {\n            for (bit=0; bit < (ssize_t) (image->columns % 8); bit++)\n            {\n              index=(IndexPacket) ((*p) & (0x80 >> bit) ? 0x01 : 0x00);\n              SetPixelIndex(indexes+x+bit,index);\n            }\n            p++;\n          }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n      (void) SyncImage(image);\n      break;\n    }\n    case 4:\n    {\n      /*\n        Convert PseudoColor scanline.\n      */\n      for (y=(ssize_t) image->rows-1; y >= 0; y--)\n      {\n        p=pixels+(image->rows-y-1)*bytes_per_line;\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < ((ssize_t) image->columns-1); x+=2)\n        {\n          index=ConstrainColormapIndex(image,(*p >> 4) & 0xf);\n          SetPixelIndex(indexes+x,index);\n          index=ConstrainColormapIndex(image,*p & 0xf);\n          SetPixelIndex(indexes+x+1,index);\n          p++;\n        }\n        if ((image->columns % 2) != 0)\n          {\n            index=ConstrainColormapIndex(image,(*p >> 4) & 0xf);\n            SetPixelIndex(indexes+x,index);\n            p++;\n          }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n      (void) SyncImage(image);\n      break;\n    }\n    case 8:\n    {\n      /*\n        Convert PseudoColor scanline.\n      */\n      if ((dib_info.compression == BI_RLE8) ||\n          (dib_info.compression == BI_RLE4))\n        bytes_per_line=image->columns;\n      for (y=(ssize_t) image->rows-1; y >= 0; y--)\n      {\n        p=pixels+(image->rows-y-1)*bytes_per_line;\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(image);\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          index=ConstrainColormapIndex(image,*p);\n          SetPixelIndex(indexes+x,index);\n          p++;\n          q++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n      (void) SyncImage(image);\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        word;\n\n      /*\n        Convert PseudoColor scanline.\n      */\n      image->storage_class=DirectClass;\n      if (dib_info.compression == BI_RLE8)\n        bytes_per_line=2*image->columns;\n      for (y=(ssize_t) image->rows-1; y >= 0; y--)\n      {\n        p=pixels+(image->rows-y-1)*bytes_per_line;\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          word=(*p++);\n          word|=(*p++ << 8);\n          if (dib_info.red_mask == 0)\n            {\n              SetPixelRed(q,ScaleCharToQuantum(ScaleColor5to8(\n                (unsigned char) ((word >> 10) & 0x1f))));\n              SetPixelGreen(q,ScaleCharToQuantum(ScaleColor5to8(\n                (unsigned char) ((word >> 5) & 0x1f))));\n              SetPixelBlue(q,ScaleCharToQuantum(ScaleColor5to8(\n                (unsigned char) (word & 0x1f))));\n            }\n          else\n            {\n              SetPixelRed(q,ScaleCharToQuantum(ScaleColor5to8(\n                (unsigned char) ((word >> 11) & 0x1f))));\n              SetPixelGreen(q,ScaleCharToQuantum(ScaleColor6to8(\n                (unsigned char) ((word >> 5) & 0x3f))));\n              SetPixelBlue(q,ScaleCharToQuantum(ScaleColor5to8(\n                (unsigned char) (word & 0x1f))));\n            }\n          q++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n      break;\n    }\n    case 24:\n    case 32:\n    {\n      /*\n        Convert DirectColor scanline.\n      */\n      for (y=(ssize_t) image->rows-1; y >= 0; y--)\n      {\n        p=pixels+(image->rows-y-1)*bytes_per_line;\n        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          SetPixelBlue(q,ScaleCharToQuantum(*p++));\n          SetPixelGreen(q,ScaleCharToQuantum(*p++));\n          SetPixelRed(q,ScaleCharToQuantum(*p++));\n          if (image->matte != MagickFalse)\n            SetPixelOpacity(q,ScaleCharToQuantum(*p++));\n          q++;\n        }\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,image->rows-y-1,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n      break;\n    }\n    default:\n    {\n      pixel_info=RelinquishVirtualMemory(pixel_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  }\n  pixel_info=RelinquishVirtualMemory(pixel_info);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  if (dib_info.height < 0)\n    {\n      Image\n        *flipped_image;\n\n      /*\n        Correct image orientation.\n      */\n      flipped_image=FlipImage(image,exception);\n      if (flipped_image != (Image *) NULL)\n        {\n          DuplicateBlob(flipped_image,image);\n          image=DestroyImage(image);\n          image=flipped_image;\n        }\n    }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -188,7 +188,10 @@\n       packet_size=4;\n       count=ReadBlob(image,packet_size*image->colors,dib_colormap);\n       if (count != (ssize_t) (packet_size*image->colors))\n-        ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n+        {\n+          dib_colormap=(unsigned char *) RelinquishMagickMemory(dib_colormap);\n+          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n+        }\n       p=dib_colormap;\n       for (i=0; i < (ssize_t) image->colors; i++)\n       {",
        "diff_line_info": {
            "deleted_lines": [
                "        ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");"
            ],
            "added_lines": [
                "        {",
                "          dib_colormap=(unsigned char *) RelinquishMagickMemory(dib_colormap);",
                "          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11529",
        "func_name": "ImageMagick/ReadMATImage",
        "description": "The ReadMATImage function in coders/mat.c in ImageMagick before 6.9.9-0 and 7.x before 7.0.6-1 allows remote attackers to cause a denial of service (memory leak) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/a678ee79a7c5380183d3edaa4cf4f0ca6cb75d3d",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/525",
        "commit_text": "",
        "func_before": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  register Quantum *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info,exception);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  clone_info=CloneImageInfo(image_info);\n  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\nMATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           (void) ReadBlobXXXLong(image2);\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\n    NEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        image->type=GrayscaleType;\n        SetImageColorspace(image,GRAYColorspace,exception);\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(image,q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n            exception);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n            exception);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image,exception);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n        }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}",
        "func": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  register Quantum *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info,exception);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  clone_info=(ImageInfo *) NULL;\n  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\nMATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           (void) ReadBlobXXXLong(image2);\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\n    NEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        image->type=GrayscaleType;\n        SetImageColorspace(image,GRAYColorspace,exception);\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(image,q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n            exception);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n            exception);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image,exception);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n        }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -49,7 +49,7 @@\n      Read MATLAB image.\n    */\n   quantum_info=(QuantumInfo *) NULL;\n-  clone_info=CloneImageInfo(image_info);\n+  clone_info=(ImageInfo *) NULL;\n   if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n   if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n@@ -102,6 +102,7 @@\n     if(EOFBlob(image)) break;\n     filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n \n+    clone_info=CloneImageInfo(image_info);\n     image2 = image;\n #if defined(MAGICKCORE_ZLIB_DELEGATE)\n     if(MATLAB_HDR.DataType == miCOMPRESSED)",
        "diff_line_info": {
            "deleted_lines": [
                "  clone_info=CloneImageInfo(image_info);"
            ],
            "added_lines": [
                "  clone_info=(ImageInfo *) NULL;",
                "    clone_info=CloneImageInfo(image_info);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11531",
        "func_name": "ImageMagick/WriteHISTOGRAMImage",
        "description": "When ImageMagick 7.0.6-1 processes a crafted file in convert, it can lead to a Memory Leak in the WriteHISTOGRAMImage() function in coders/histogram.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/1885ab1231e82f90d3f0e839555ee3e1a441bbf8",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/566",
        "commit_text": "",
        "func_before": "static MagickBooleanType WriteHISTOGRAMImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n#define HistogramDensity  \"256x200\"\n\n  char\n    filename[MagickPathExtent];\n\n  const char\n    *option;\n\n  Image\n    *histogram_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    *histogram;\n\n  double\n    maximum,\n    scale;\n\n  RectangleInfo\n    geometry;\n\n  register const Quantum\n    *p;\n\n  register Quantum\n    *q,\n    *r;\n\n  register ssize_t\n    x;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  /*\n    Allocate histogram image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  SetGeometry(image,&geometry);\n  if (image_info->density == (char *) NULL)\n    (void) ParseAbsoluteGeometry(HistogramDensity,&geometry);\n  else\n    (void) ParseAbsoluteGeometry(image_info->density,&geometry);\n  histogram_image=CloneImage(image,geometry.width,geometry.height,MagickTrue,\n    exception);\n  if (histogram_image == (Image *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) SetImageStorageClass(histogram_image,DirectClass,exception);\n  /*\n    Allocate histogram count arrays.\n  */\n  length=MagickMax((size_t) ScaleQuantumToChar(QuantumRange)+1UL,\n    histogram_image->columns);\n  histogram=(PixelInfo *) AcquireQuantumMemory(length,sizeof(*histogram));\n  if (histogram == (PixelInfo *) NULL)\n    {\n      histogram_image=DestroyImage(histogram_image);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  /*\n    Initialize histogram count arrays.\n  */\n  (void) ResetMagickMemory(histogram,0,length*sizeof(*histogram));\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n        histogram[ScaleQuantumToChar(GetPixelRed(image,p))].red++;\n      if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n        histogram[ScaleQuantumToChar(GetPixelGreen(image,p))].green++;\n      if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n        histogram[ScaleQuantumToChar(GetPixelBlue(image,p))].blue++;\n      p+=GetPixelChannels(image);\n    }\n  }\n  maximum=histogram[0].red;\n  for (x=0; x < (ssize_t) histogram_image->columns; x++)\n  {\n    if (((GetPixelRedTraits(image) & UpdatePixelTrait) != 0) &&\n        (maximum < histogram[x].red))\n      maximum=histogram[x].red;\n    if (((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0) &&\n        (maximum < histogram[x].green))\n      maximum=histogram[x].green;\n    if (((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0) &&\n        (maximum < histogram[x].blue))\n      maximum=histogram[x].blue;\n  }\n  scale=0.0;\n  if (fabs(maximum) >= MagickEpsilon)\n    scale=(double) histogram_image->rows/maximum;\n  /*\n    Initialize histogram image.\n  */\n  (void) QueryColorCompliance(\"#000000\",AllCompliance,\n    &histogram_image->background_color,exception);\n  (void) SetImageBackgroundColor(histogram_image,exception);\n  for (x=0; x < (ssize_t) histogram_image->columns; x++)\n  {\n    q=GetAuthenticPixels(histogram_image,x,0,1,histogram_image->rows,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n      {\n        y=(ssize_t) ceil(histogram_image->rows-scale*histogram[x].red-0.5);\n        r=q+y*GetPixelChannels(histogram_image);\n        for ( ; y < (ssize_t) histogram_image->rows; y++)\n        {\n          SetPixelRed(histogram_image,QuantumRange,r);\n          r+=GetPixelChannels(histogram_image);\n        }\n      }\n    if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n      {\n        y=(ssize_t) ceil(histogram_image->rows-scale*histogram[x].green-0.5);\n        r=q+y*GetPixelChannels(histogram_image);\n        for ( ; y < (ssize_t) histogram_image->rows; y++)\n        {\n          SetPixelGreen(histogram_image,QuantumRange,r);\n          r+=GetPixelChannels(histogram_image);\n        }\n      }\n    if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n      {\n        y=(ssize_t) ceil(histogram_image->rows-scale*histogram[x].blue-0.5);\n        r=q+y*GetPixelChannels(histogram_image);\n        for ( ; y < (ssize_t) histogram_image->rows; y++)\n        {\n          SetPixelBlue(histogram_image,QuantumRange,r);\n          r+=GetPixelChannels(histogram_image);\n        }\n      }\n    if (SyncAuthenticPixels(histogram_image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,SaveImageTag,y,histogram_image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  histogram=(PixelInfo *) RelinquishMagickMemory(histogram);\n  option=GetImageOption(image_info,\"histogram:unique-colors\");\n  if ((option == (const char *) NULL) || (IsStringTrue(option) != MagickFalse))\n    {\n      FILE\n        *file;\n\n      int\n        unique_file;\n\n      /*\n        Add a unique colors as an image comment.\n      */\n      file=(FILE *) NULL;\n      unique_file=AcquireUniqueFileResource(filename);\n      if (unique_file != -1)\n        file=fdopen(unique_file,\"wb\");\n      if ((unique_file != -1) && (file != (FILE *) NULL))\n        {\n          char\n            *property;\n\n          (void) GetNumberColors(image,file,exception);\n          (void) fclose(file);\n          property=FileToString(filename,~0UL,exception);\n          if (property != (char *) NULL)\n            {\n              (void) SetImageProperty(histogram_image,\"comment\",property,\n                exception);\n              property=DestroyString(property);\n            }\n        }\n      (void) RelinquishUniqueFileResource(filename);\n    }\n  /*\n    Write Histogram image.\n  */\n  (void) CopyMagickString(histogram_image->filename,image_info->filename,\n    MagickPathExtent);\n  (void) ResetImagePage(histogram_image,\"0x0+0+0\");\n  write_info=CloneImageInfo(image_info);\n  *write_info->magick='\\0';\n  (void) SetImageInfo(write_info,1,exception);\n  if ((*write_info->magick == '\\0') ||\n      (LocaleCompare(write_info->magick,\"HISTOGRAM\") == 0))\n    (void) FormatLocaleString(histogram_image->filename,MagickPathExtent,\n      \"miff:%s\",write_info->filename);\n  histogram_image->blob=(BlobInfo *) DetachBlob(histogram_image->blob);\n  histogram_image->blob=CloneBlobInfo(image->blob);\n  status=WriteImage(write_info,histogram_image,exception);\n  image->blob=(BlobInfo *) DetachBlob(image->blob);\n  image->blob=CloneBlobInfo(histogram_image->blob);\n  histogram_image=DestroyImage(histogram_image);\n  write_info=DestroyImageInfo(write_info);\n  return(status);\n}",
        "func": "static MagickBooleanType WriteHISTOGRAMImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n#define HistogramDensity  \"256x200\"\n\n  char\n    filename[MagickPathExtent];\n\n  const char\n    *option;\n\n  Image\n    *histogram_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    *histogram;\n\n  double\n    maximum,\n    scale;\n\n  RectangleInfo\n    geometry;\n\n  register const Quantum\n    *p;\n\n  register Quantum\n    *q,\n    *r;\n\n  register ssize_t\n    x;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  /*\n    Allocate histogram image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  SetGeometry(image,&geometry);\n  if (image_info->density == (char *) NULL)\n    (void) ParseAbsoluteGeometry(HistogramDensity,&geometry);\n  else\n    (void) ParseAbsoluteGeometry(image_info->density,&geometry);\n  histogram_image=CloneImage(image,geometry.width,geometry.height,MagickTrue,\n    exception);\n  if (histogram_image == (Image *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) SetImageStorageClass(histogram_image,DirectClass,exception);\n  /*\n    Allocate histogram count arrays.\n  */\n  length=MagickMax((size_t) ScaleQuantumToChar(QuantumRange)+1UL,\n    histogram_image->columns);\n  histogram=(PixelInfo *) AcquireQuantumMemory(length,sizeof(*histogram));\n  if (histogram == (PixelInfo *) NULL)\n    {\n      histogram_image=DestroyImage(histogram_image);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  /*\n    Initialize histogram count arrays.\n  */\n  (void) ResetMagickMemory(histogram,0,length*sizeof(*histogram));\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n        histogram[ScaleQuantumToChar(GetPixelRed(image,p))].red++;\n      if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n        histogram[ScaleQuantumToChar(GetPixelGreen(image,p))].green++;\n      if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n        histogram[ScaleQuantumToChar(GetPixelBlue(image,p))].blue++;\n      p+=GetPixelChannels(image);\n    }\n  }\n  maximum=histogram[0].red;\n  for (x=0; x < (ssize_t) histogram_image->columns; x++)\n  {\n    if (((GetPixelRedTraits(image) & UpdatePixelTrait) != 0) &&\n        (maximum < histogram[x].red))\n      maximum=histogram[x].red;\n    if (((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0) &&\n        (maximum < histogram[x].green))\n      maximum=histogram[x].green;\n    if (((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0) &&\n        (maximum < histogram[x].blue))\n      maximum=histogram[x].blue;\n  }\n  scale=0.0;\n  if (fabs(maximum) >= MagickEpsilon)\n    scale=(double) histogram_image->rows/maximum;\n  /*\n    Initialize histogram image.\n  */\n  (void) QueryColorCompliance(\"#000000\",AllCompliance,\n    &histogram_image->background_color,exception);\n  (void) SetImageBackgroundColor(histogram_image,exception);\n  for (x=0; x < (ssize_t) histogram_image->columns; x++)\n  {\n    q=GetAuthenticPixels(histogram_image,x,0,1,histogram_image->rows,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n      {\n        y=(ssize_t) ceil(histogram_image->rows-scale*histogram[x].red-0.5);\n        r=q+y*GetPixelChannels(histogram_image);\n        for ( ; y < (ssize_t) histogram_image->rows; y++)\n        {\n          SetPixelRed(histogram_image,QuantumRange,r);\n          r+=GetPixelChannels(histogram_image);\n        }\n      }\n    if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n      {\n        y=(ssize_t) ceil(histogram_image->rows-scale*histogram[x].green-0.5);\n        r=q+y*GetPixelChannels(histogram_image);\n        for ( ; y < (ssize_t) histogram_image->rows; y++)\n        {\n          SetPixelGreen(histogram_image,QuantumRange,r);\n          r+=GetPixelChannels(histogram_image);\n        }\n      }\n    if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n      {\n        y=(ssize_t) ceil(histogram_image->rows-scale*histogram[x].blue-0.5);\n        r=q+y*GetPixelChannels(histogram_image);\n        for ( ; y < (ssize_t) histogram_image->rows; y++)\n        {\n          SetPixelBlue(histogram_image,QuantumRange,r);\n          r+=GetPixelChannels(histogram_image);\n        }\n      }\n    if (SyncAuthenticPixels(histogram_image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,SaveImageTag,y,histogram_image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  histogram=(PixelInfo *) RelinquishMagickMemory(histogram);\n  option=GetImageOption(image_info,\"histogram:unique-colors\");\n  if ((option == (const char *) NULL) || (IsStringTrue(option) != MagickFalse))\n    {\n      FILE\n        *file;\n\n      int\n        unique_file;\n\n      /*\n        Add a unique colors as an image comment.\n      */\n      file=(FILE *) NULL;\n      unique_file=AcquireUniqueFileResource(filename);\n      if (unique_file != -1)\n        file=fdopen(unique_file,\"wb\");\n      if ((unique_file != -1) && (file != (FILE *) NULL))\n        {\n          char\n            *property;\n\n          (void) GetNumberColors(image,file,exception);\n          (void) fclose(file);\n          property=FileToString(filename,~0UL,exception);\n          if (property != (char *) NULL)\n            {\n              (void) SetImageProperty(histogram_image,\"comment\",property,\n                exception);\n              property=DestroyString(property);\n            }\n        }\n      (void) RelinquishUniqueFileResource(filename);\n    }\n  /*\n    Write Histogram image.\n  */\n  (void) CopyMagickString(histogram_image->filename,image_info->filename,\n    MagickPathExtent);\n  (void) ResetImagePage(histogram_image,\"0x0+0+0\");\n  write_info=CloneImageInfo(image_info);\n  *write_info->magick='\\0';\n  (void) SetImageInfo(write_info,1,exception);\n  if ((*write_info->magick == '\\0') ||\n      (LocaleCompare(write_info->magick,\"HISTOGRAM\") == 0))\n    (void) FormatLocaleString(histogram_image->filename,MagickPathExtent,\n      \"miff:%s\",write_info->filename);\n  status=WriteImage(write_info,histogram_image,exception);\n  histogram_image=DestroyImage(histogram_image);\n  write_info=DestroyImageInfo(write_info);\n  return(status);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -205,11 +205,7 @@\n       (LocaleCompare(write_info->magick,\"HISTOGRAM\") == 0))\n     (void) FormatLocaleString(histogram_image->filename,MagickPathExtent,\n       \"miff:%s\",write_info->filename);\n-  histogram_image->blob=(BlobInfo *) DetachBlob(histogram_image->blob);\n-  histogram_image->blob=CloneBlobInfo(image->blob);\n   status=WriteImage(write_info,histogram_image,exception);\n-  image->blob=(BlobInfo *) DetachBlob(image->blob);\n-  image->blob=CloneBlobInfo(histogram_image->blob);\n   histogram_image=DestroyImage(histogram_image);\n   write_info=DestroyImageInfo(write_info);\n   return(status);",
        "diff_line_info": {
            "deleted_lines": [
                "  histogram_image->blob=(BlobInfo *) DetachBlob(histogram_image->blob);",
                "  histogram_image->blob=CloneBlobInfo(image->blob);",
                "  image->blob=(BlobInfo *) DetachBlob(image->blob);",
                "  image->blob=CloneBlobInfo(histogram_image->blob);"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2017-11536",
        "func_name": "ImageMagick/WriteJP2Image",
        "description": "When ImageMagick 7.0.6-1 processes a crafted file in convert, it can lead to a Memory Leak in the WriteJP2Image() function in coders/jp2.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/167e1538ae9818d46c9462a4273082871e35a480",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/567",
        "commit_text": "",
        "func_before": "static MagickBooleanType WriteJP2Image(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  const char\n    *option,\n    *property;\n\n  int\n    jp2_status;\n\n  MagickBooleanType\n    status;\n\n  opj_codec_t\n    *jp2_codec;\n\n  OPJ_COLOR_SPACE\n    jp2_colorspace;\n\n  opj_cparameters_t\n    parameters;\n\n  opj_image_cmptparm_t\n    jp2_info[5];\n\n  opj_image_t\n    *jp2_image;\n\n  opj_stream_t\n    *jp2_stream;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  unsigned int\n    channels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Initialize JPEG 2000 API.\n  */\n  opj_set_default_encoder_parameters(&parameters);\n  for (i=1; i < 6; i++)\n    if (((size_t) (1UL << (i+2)) > image->columns) &&\n        ((size_t) (1UL << (i+2)) > image->rows))\n      break;\n  parameters.numresolution=i;\n  option=GetImageOption(image_info,\"jp2:number-resolutions\");\n  if (option != (const char *) NULL)\n    parameters.numresolution=StringToInteger(option);\n  parameters.tcp_numlayers=1;\n  parameters.tcp_rates[0]=0;  /* lossless */\n  parameters.cp_disto_alloc=1;\n  if ((image_info->quality != 0) && (image_info->quality != 100))\n    {\n      parameters.tcp_distoratio[0]=(double) image_info->quality;\n      parameters.cp_fixed_quality=OPJ_TRUE;\n    }\n  if (image_info->extract != (char *) NULL)\n    {\n      RectangleInfo\n        geometry;\n\n      int\n        flags;\n\n      /*\n        Set tile size.\n      */\n      flags=ParseAbsoluteGeometry(image_info->extract,&geometry);\n      parameters.cp_tdx=(int) geometry.width;\n      parameters.cp_tdy=(int) geometry.width;\n      if ((flags & HeightValue) != 0)\n        parameters.cp_tdy=(int) geometry.height;\n      if ((flags & XValue) != 0)\n        parameters.cp_tx0=geometry.x;\n      if ((flags & YValue) != 0)\n        parameters.cp_ty0=geometry.y;\n      parameters.tile_size_on=OPJ_TRUE;\n    }\n  option=GetImageOption(image_info,\"jp2:quality\");\n  if (option != (const char *) NULL)\n    {\n      register const char\n        *p;\n\n      /*\n        Set quality PSNR.\n      */\n      p=option;\n      for (i=0; sscanf(p,\"%f\",&parameters.tcp_distoratio[i]) == 1; i++)\n      {\n        if (i > 100)\n          break;\n        while ((*p != '\\0') && (*p != ','))\n          p++;\n        if (*p == '\\0')\n          break;\n        p++;\n      }\n      parameters.tcp_numlayers=i+1;\n      parameters.cp_fixed_quality=OPJ_TRUE;\n    }\n  option=GetImageOption(image_info,\"jp2:progression-order\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"LRCP\") == 0)\n        parameters.prog_order=OPJ_LRCP;\n      if (LocaleCompare(option,\"RLCP\") == 0)\n        parameters.prog_order=OPJ_RLCP;\n      if (LocaleCompare(option,\"RPCL\") == 0)\n        parameters.prog_order=OPJ_RPCL;\n      if (LocaleCompare(option,\"PCRL\") == 0)\n        parameters.prog_order=OPJ_PCRL;\n      if (LocaleCompare(option,\"CPRL\") == 0)\n        parameters.prog_order=OPJ_CPRL;\n    }\n  option=GetImageOption(image_info,\"jp2:rate\");\n  if (option != (const char *) NULL)\n    {\n      register const char\n        *p;\n\n      /*\n        Set compression rate.\n      */\n      p=option;\n      for (i=0; sscanf(p,\"%f\",&parameters.tcp_rates[i]) == 1; i++)\n      {\n        if (i >= 100)\n          break;\n        while ((*p != '\\0') && (*p != ','))\n          p++;\n        if (*p == '\\0')\n          break;\n        p++;\n      }\n      parameters.tcp_numlayers=i+1;\n      parameters.cp_disto_alloc=OPJ_TRUE;\n    }\n  if (image_info->sampling_factor != (const char *) NULL)\n    (void) sscanf(image_info->sampling_factor,\"%d,%d\",\n      &parameters.subsampling_dx,&parameters.subsampling_dy);\n  property=GetImageProperty(image,\"comment\",exception);\n  if (property != (const char *) NULL)\n    parameters.cp_comment=ConstantString(property);\n  channels=3;\n  jp2_colorspace=OPJ_CLRSPC_SRGB;\n  if (image->colorspace == YUVColorspace)\n    {\n      jp2_colorspace=OPJ_CLRSPC_SYCC;\n      parameters.subsampling_dx=2;\n    }\n  else\n    {\n      if (IsGrayColorspace(image->colorspace) != MagickFalse)\n        {\n          channels=1;\n          jp2_colorspace=OPJ_CLRSPC_GRAY;\n        }\n      else\n        (void) TransformImageColorspace(image,sRGBColorspace,exception);\n      if (image->alpha_trait != UndefinedPixelTrait)\n        channels++;\n    }\n  parameters.tcp_mct=channels == 3 ? 1 : 0;\n  ResetMagickMemory(jp2_info,0,sizeof(jp2_info));\n  for (i=0; i < (ssize_t) channels; i++)\n  {\n    jp2_info[i].prec=(OPJ_UINT32) image->depth;\n    jp2_info[i].bpp=(OPJ_UINT32) image->depth;\n    if ((image->depth == 1) &&\n        ((LocaleCompare(image_info->magick,\"JPT\") == 0) ||\n         (LocaleCompare(image_info->magick,\"JP2\") == 0)))\n      {\n        jp2_info[i].prec++;  /* OpenJPEG returns exception for depth @ 1 */\n        jp2_info[i].bpp++;\n      }\n    jp2_info[i].sgnd=0;\n    jp2_info[i].dx=parameters.subsampling_dx;\n    jp2_info[i].dy=parameters.subsampling_dy;\n    jp2_info[i].w=(OPJ_UINT32) image->columns;\n    jp2_info[i].h=(OPJ_UINT32) image->rows;\n  }\n  jp2_image=opj_image_create((OPJ_UINT32) channels,jp2_info,jp2_colorspace);\n  if (jp2_image == (opj_image_t *) NULL)\n    ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n  jp2_image->x0=parameters.image_offset_x0;\n  jp2_image->y0=parameters.image_offset_y0;\n  jp2_image->x1=(unsigned int) (2*parameters.image_offset_x0+(image->columns-1)*\n    parameters.subsampling_dx+1);\n  jp2_image->y1=(unsigned int) (2*parameters.image_offset_y0+(image->rows-1)*\n    parameters.subsampling_dx+1);\n  if ((image->depth == 12) &&\n      ((image->columns == 2048) || (image->rows == 1080) ||\n       (image->columns == 4096) || (image->rows == 2160)))\n    CinemaProfileCompliance(jp2_image,&parameters);\n  if (channels == 4)\n    jp2_image->comps[3].alpha=1;\n  else\n   if ((channels == 2) && (jp2_colorspace == OPJ_CLRSPC_GRAY))\n     jp2_image->comps[1].alpha=1;\n  /*\n    Convert to JP2 pixels.\n  */\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *p;\n\n    ssize_t\n      x;\n\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      for (i=0; i < (ssize_t) channels; i++)\n      {\n        double\n          scale;\n\n        register int\n          *q;\n\n        scale=(double) ((1UL << jp2_image->comps[i].prec)-1)/QuantumRange;\n        q=jp2_image->comps[i].data+(y/jp2_image->comps[i].dy*\n          image->columns/jp2_image->comps[i].dx+x/jp2_image->comps[i].dx);\n        switch (i)\n        {\n          case 0:\n          {\n            if (jp2_colorspace == OPJ_CLRSPC_GRAY)\n              {\n                *q=(int) (scale*GetPixelLuma(image,p));\n                break;\n              }\n            *q=(int) (scale*GetPixelRed(image,p));\n            break;\n          }\n          case 1:\n          {\n            if (jp2_colorspace == OPJ_CLRSPC_GRAY)\n              {\n                *q=(int) (scale*GetPixelAlpha(image,p));\n                break;\n              }\n            *q=(int) (scale*GetPixelGreen(image,p));\n            break;\n          }\n          case 2:\n          {\n            *q=(int) (scale*GetPixelBlue(image,p));\n            break;\n          }\n          case 3:\n          {\n            *q=(int) (scale*GetPixelAlpha(image,p));\n            break;\n          }\n        }\n      }\n      p+=GetPixelChannels(image);\n    }\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  if (LocaleCompare(image_info->magick,\"JPT\") == 0)\n    jp2_codec=opj_create_compress(OPJ_CODEC_JPT);\n  else\n    if (LocaleCompare(image_info->magick,\"J2K\") == 0)\n      jp2_codec=opj_create_compress(OPJ_CODEC_J2K);\n    else\n      jp2_codec=opj_create_compress(OPJ_CODEC_JP2);\n  opj_set_warning_handler(jp2_codec,JP2WarningHandler,exception);\n  opj_set_error_handler(jp2_codec,JP2ErrorHandler,exception);\n  opj_setup_encoder(jp2_codec,&parameters,jp2_image);\n  jp2_stream=opj_stream_create(OPJ_J2K_STREAM_CHUNK_SIZE,OPJ_FALSE);\n  opj_stream_set_read_function(jp2_stream,JP2ReadHandler);\n  opj_stream_set_write_function(jp2_stream,JP2WriteHandler);\n  opj_stream_set_seek_function(jp2_stream,JP2SeekHandler);\n  opj_stream_set_skip_function(jp2_stream,JP2SkipHandler);\n  opj_stream_set_user_data(jp2_stream,image,NULL);\n  if (jp2_stream == (opj_stream_t *) NULL)\n    ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n  jp2_status=opj_start_compress(jp2_codec,jp2_image,jp2_stream);\n  if (jp2_status == 0)\n    ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n  if ((opj_encode(jp2_codec,jp2_stream) == 0) ||\n      (opj_end_compress(jp2_codec,jp2_stream) == 0))\n    {\n      opj_stream_destroy(jp2_stream);\n      opj_destroy_codec(jp2_codec);\n      opj_image_destroy(jp2_image);\n      ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n    }\n  /*\n    Free resources.\n  */\n  opj_stream_destroy(jp2_stream);\n  opj_destroy_codec(jp2_codec);\n  opj_image_destroy(jp2_image);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
        "func": "static MagickBooleanType WriteJP2Image(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  const char\n    *option,\n    *property;\n\n  int\n    jp2_status;\n\n  MagickBooleanType\n    status;\n\n  opj_codec_t\n    *jp2_codec;\n\n  OPJ_COLOR_SPACE\n    jp2_colorspace;\n\n  opj_cparameters_t\n    parameters;\n\n  opj_image_cmptparm_t\n    jp2_info[5];\n\n  opj_image_t\n    *jp2_image;\n\n  opj_stream_t\n    *jp2_stream;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  unsigned int\n    channels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Initialize JPEG 2000 API.\n  */\n  opj_set_default_encoder_parameters(&parameters);\n  for (i=1; i < 6; i++)\n    if (((size_t) (1UL << (i+2)) > image->columns) &&\n        ((size_t) (1UL << (i+2)) > image->rows))\n      break;\n  parameters.numresolution=i;\n  option=GetImageOption(image_info,\"jp2:number-resolutions\");\n  if (option != (const char *) NULL)\n    parameters.numresolution=StringToInteger(option);\n  parameters.tcp_numlayers=1;\n  parameters.tcp_rates[0]=0;  /* lossless */\n  parameters.cp_disto_alloc=1;\n  if ((image_info->quality != 0) && (image_info->quality != 100))\n    {\n      parameters.tcp_distoratio[0]=(double) image_info->quality;\n      parameters.cp_fixed_quality=OPJ_TRUE;\n    }\n  if (image_info->extract != (char *) NULL)\n    {\n      RectangleInfo\n        geometry;\n\n      int\n        flags;\n\n      /*\n        Set tile size.\n      */\n      flags=ParseAbsoluteGeometry(image_info->extract,&geometry);\n      parameters.cp_tdx=(int) geometry.width;\n      parameters.cp_tdy=(int) geometry.width;\n      if ((flags & HeightValue) != 0)\n        parameters.cp_tdy=(int) geometry.height;\n      if ((flags & XValue) != 0)\n        parameters.cp_tx0=geometry.x;\n      if ((flags & YValue) != 0)\n        parameters.cp_ty0=geometry.y;\n      parameters.tile_size_on=OPJ_TRUE;\n    }\n  option=GetImageOption(image_info,\"jp2:quality\");\n  if (option != (const char *) NULL)\n    {\n      register const char\n        *p;\n\n      /*\n        Set quality PSNR.\n      */\n      p=option;\n      for (i=0; sscanf(p,\"%f\",&parameters.tcp_distoratio[i]) == 1; i++)\n      {\n        if (i > 100)\n          break;\n        while ((*p != '\\0') && (*p != ','))\n          p++;\n        if (*p == '\\0')\n          break;\n        p++;\n      }\n      parameters.tcp_numlayers=i+1;\n      parameters.cp_fixed_quality=OPJ_TRUE;\n    }\n  option=GetImageOption(image_info,\"jp2:progression-order\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"LRCP\") == 0)\n        parameters.prog_order=OPJ_LRCP;\n      if (LocaleCompare(option,\"RLCP\") == 0)\n        parameters.prog_order=OPJ_RLCP;\n      if (LocaleCompare(option,\"RPCL\") == 0)\n        parameters.prog_order=OPJ_RPCL;\n      if (LocaleCompare(option,\"PCRL\") == 0)\n        parameters.prog_order=OPJ_PCRL;\n      if (LocaleCompare(option,\"CPRL\") == 0)\n        parameters.prog_order=OPJ_CPRL;\n    }\n  option=GetImageOption(image_info,\"jp2:rate\");\n  if (option != (const char *) NULL)\n    {\n      register const char\n        *p;\n\n      /*\n        Set compression rate.\n      */\n      p=option;\n      for (i=0; sscanf(p,\"%f\",&parameters.tcp_rates[i]) == 1; i++)\n      {\n        if (i >= 100)\n          break;\n        while ((*p != '\\0') && (*p != ','))\n          p++;\n        if (*p == '\\0')\n          break;\n        p++;\n      }\n      parameters.tcp_numlayers=i+1;\n      parameters.cp_disto_alloc=OPJ_TRUE;\n    }\n  if (image_info->sampling_factor != (const char *) NULL)\n    (void) sscanf(image_info->sampling_factor,\"%d,%d\",\n      &parameters.subsampling_dx,&parameters.subsampling_dy);\n  property=GetImageProperty(image,\"comment\",exception);\n  if (property != (const char *) NULL)\n    parameters.cp_comment=property;\n  channels=3;\n  jp2_colorspace=OPJ_CLRSPC_SRGB;\n  if (image->colorspace == YUVColorspace)\n    {\n      jp2_colorspace=OPJ_CLRSPC_SYCC;\n      parameters.subsampling_dx=2;\n    }\n  else\n    {\n      if (IsGrayColorspace(image->colorspace) != MagickFalse)\n        {\n          channels=1;\n          jp2_colorspace=OPJ_CLRSPC_GRAY;\n        }\n      else\n        (void) TransformImageColorspace(image,sRGBColorspace,exception);\n      if (image->alpha_trait != UndefinedPixelTrait)\n        channels++;\n    }\n  parameters.tcp_mct=channels == 3 ? 1 : 0;\n  ResetMagickMemory(jp2_info,0,sizeof(jp2_info));\n  for (i=0; i < (ssize_t) channels; i++)\n  {\n    jp2_info[i].prec=(OPJ_UINT32) image->depth;\n    jp2_info[i].bpp=(OPJ_UINT32) image->depth;\n    if ((image->depth == 1) &&\n        ((LocaleCompare(image_info->magick,\"JPT\") == 0) ||\n         (LocaleCompare(image_info->magick,\"JP2\") == 0)))\n      {\n        jp2_info[i].prec++;  /* OpenJPEG returns exception for depth @ 1 */\n        jp2_info[i].bpp++;\n      }\n    jp2_info[i].sgnd=0;\n    jp2_info[i].dx=parameters.subsampling_dx;\n    jp2_info[i].dy=parameters.subsampling_dy;\n    jp2_info[i].w=(OPJ_UINT32) image->columns;\n    jp2_info[i].h=(OPJ_UINT32) image->rows;\n  }\n  jp2_image=opj_image_create((OPJ_UINT32) channels,jp2_info,jp2_colorspace);\n  if (jp2_image == (opj_image_t *) NULL)\n    ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n  jp2_image->x0=parameters.image_offset_x0;\n  jp2_image->y0=parameters.image_offset_y0;\n  jp2_image->x1=(unsigned int) (2*parameters.image_offset_x0+(image->columns-1)*\n    parameters.subsampling_dx+1);\n  jp2_image->y1=(unsigned int) (2*parameters.image_offset_y0+(image->rows-1)*\n    parameters.subsampling_dx+1);\n  if ((image->depth == 12) &&\n      ((image->columns == 2048) || (image->rows == 1080) ||\n       (image->columns == 4096) || (image->rows == 2160)))\n    CinemaProfileCompliance(jp2_image,&parameters);\n  if (channels == 4)\n    jp2_image->comps[3].alpha=1;\n  else\n   if ((channels == 2) && (jp2_colorspace == OPJ_CLRSPC_GRAY))\n     jp2_image->comps[1].alpha=1;\n  /*\n    Convert to JP2 pixels.\n  */\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *p;\n\n    ssize_t\n      x;\n\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      for (i=0; i < (ssize_t) channels; i++)\n      {\n        double\n          scale;\n\n        register int\n          *q;\n\n        scale=(double) ((1UL << jp2_image->comps[i].prec)-1)/QuantumRange;\n        q=jp2_image->comps[i].data+(y/jp2_image->comps[i].dy*\n          image->columns/jp2_image->comps[i].dx+x/jp2_image->comps[i].dx);\n        switch (i)\n        {\n          case 0:\n          {\n            if (jp2_colorspace == OPJ_CLRSPC_GRAY)\n              {\n                *q=(int) (scale*GetPixelLuma(image,p));\n                break;\n              }\n            *q=(int) (scale*GetPixelRed(image,p));\n            break;\n          }\n          case 1:\n          {\n            if (jp2_colorspace == OPJ_CLRSPC_GRAY)\n              {\n                *q=(int) (scale*GetPixelAlpha(image,p));\n                break;\n              }\n            *q=(int) (scale*GetPixelGreen(image,p));\n            break;\n          }\n          case 2:\n          {\n            *q=(int) (scale*GetPixelBlue(image,p));\n            break;\n          }\n          case 3:\n          {\n            *q=(int) (scale*GetPixelAlpha(image,p));\n            break;\n          }\n        }\n      }\n      p+=GetPixelChannels(image);\n    }\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  if (LocaleCompare(image_info->magick,\"JPT\") == 0)\n    jp2_codec=opj_create_compress(OPJ_CODEC_JPT);\n  else\n    if (LocaleCompare(image_info->magick,\"J2K\") == 0)\n      jp2_codec=opj_create_compress(OPJ_CODEC_J2K);\n    else\n      jp2_codec=opj_create_compress(OPJ_CODEC_JP2);\n  opj_set_warning_handler(jp2_codec,JP2WarningHandler,exception);\n  opj_set_error_handler(jp2_codec,JP2ErrorHandler,exception);\n  opj_setup_encoder(jp2_codec,&parameters,jp2_image);\n  jp2_stream=opj_stream_create(OPJ_J2K_STREAM_CHUNK_SIZE,OPJ_FALSE);\n  opj_stream_set_read_function(jp2_stream,JP2ReadHandler);\n  opj_stream_set_write_function(jp2_stream,JP2WriteHandler);\n  opj_stream_set_seek_function(jp2_stream,JP2SeekHandler);\n  opj_stream_set_skip_function(jp2_stream,JP2SkipHandler);\n  opj_stream_set_user_data(jp2_stream,image,NULL);\n  if (jp2_stream == (opj_stream_t *) NULL)\n    ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n  jp2_status=opj_start_compress(jp2_codec,jp2_image,jp2_stream);\n  if (jp2_status == 0)\n    ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n  if ((opj_encode(jp2_codec,jp2_stream) == 0) ||\n      (opj_end_compress(jp2_codec,jp2_stream) == 0))\n    {\n      opj_stream_destroy(jp2_stream);\n      opj_destroy_codec(jp2_codec);\n      opj_image_destroy(jp2_image);\n      ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n    }\n  /*\n    Free resources.\n  */\n  opj_stream_destroy(jp2_stream);\n  opj_destroy_codec(jp2_codec);\n  opj_image_destroy(jp2_image);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -159,7 +159,7 @@\n       &parameters.subsampling_dx,&parameters.subsampling_dy);\n   property=GetImageProperty(image,\"comment\",exception);\n   if (property != (const char *) NULL)\n-    parameters.cp_comment=ConstantString(property);\n+    parameters.cp_comment=property;\n   channels=3;\n   jp2_colorspace=OPJ_CLRSPC_SRGB;\n   if (image->colorspace == YUVColorspace)",
        "diff_line_info": {
            "deleted_lines": [
                "    parameters.cp_comment=ConstantString(property);"
            ],
            "added_lines": [
                "    parameters.cp_comment=property;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11644",
        "func_name": "ImageMagick/ReadMATImage",
        "description": "When ImageMagick 7.0.6-1 processes a crafted file in convert, it can lead to a Memory Leak in the ReadMATImage() function in coders/mat.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/418f88dd18af34b6cb64f709567c81b89865d7bc",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/587",
        "commit_text": "",
        "func_before": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}",
        "func": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if ((image != image2) && (image2 != (Image *) NULL))\n    image2=DestroyImage(image2);\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -510,6 +510,8 @@\n     clone_info = NULL;\n   }\n   if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n+  if ((image != image2) && (image2 != (Image *) NULL))\n+    image2=DestroyImage(image2);\n   if(image==NULL)\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n   return (image);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  if ((image != image2) && (image2 != (Image *) NULL))",
                "    image2=DestroyImage(image2);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11724",
        "func_name": "ImageMagick/ReadMATImage",
        "description": "The ReadMATImage function in coders/mat.c in ImageMagick through 6.9.9-3 and 7.x through 7.0.6-3 has memory leaks involving the quantum_info and clone_info data structures.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/4b9eeffe5b159ab5de3b3e1487c5e8bca8d0db39",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/624",
        "commit_text": "",
        "func_before": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  register Quantum *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info,exception);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  clone_info=(ImageInfo *) NULL;\n  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           (void) ReadBlobXXXLong(image2);\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default:\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\n    NEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n    /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        image->type=GrayscaleType;\n        SetImageColorspace(image,GRAYColorspace,exception);\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(image,q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n            exception);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n            exception);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image,exception);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n        }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if (image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  else\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n  return (image);\n}",
        "func": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  register Quantum *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info,exception);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  clone_info=(ImageInfo *) NULL;\n  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           (void) ReadBlobXXXLong(image2);\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default:\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\n    NEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n    /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        image->type=GrayscaleType;\n        SetImageColorspace(image,GRAYColorspace,exception);\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(image,q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n            exception);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n            exception);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image,exception);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n        }\n\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if (image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  else\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n  return (image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -467,6 +467,11 @@\n           }\n         }\n         }\n+\n+    if (quantum_info != (QuantumInfo *) NULL)\n+      quantum_info=DestroyQuantumInfo(quantum_info);\n+    if (clone_info)\n+      clone_info=DestroyImageInfo(clone_info);\n   }\n \n   RelinquishMagickMemory(BImgBuff);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    if (quantum_info != (QuantumInfo *) NULL)",
                "      quantum_info=DestroyQuantumInfo(quantum_info);",
                "    if (clone_info)",
                "      clone_info=DestroyImageInfo(clone_info);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11724",
        "func_name": "ImageMagick/ReadMATImage",
        "description": "The ReadMATImage function in coders/mat.c in ImageMagick through 6.9.9-3 and 7.x through 7.0.6-3 has memory leaks involving the quantum_info and clone_info data structures.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/5163756a1f829a561912dfdb74a0dae41d8ed8cf",
        "commit_title": " https://github.com/ImageMagick/ImageMagick/issues/624",
        "commit_text": "",
        "func_before": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default:\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if (image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  else\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n  return (image);\n}",
        "func": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default:\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if (image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  else\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n  return (image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -471,6 +471,10 @@\n           }\n          }\n        }\n+    if (quantum_info != (QuantumInfo *) NULL)\n+      quantum_info=DestroyQuantumInfo(quantum_info);\n+    if (clone_info)\n+      clone_info=DestroyImageInfo(clone_info);\n   }\n \n   RelinquishMagickMemory(BImgBuff);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (quantum_info != (QuantumInfo *) NULL)",
                "      quantum_info=DestroyQuantumInfo(quantum_info);",
                "    if (clone_info)",
                "      clone_info=DestroyImageInfo(clone_info);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11751",
        "func_name": "ImageMagick/WritePICONImage",
        "description": "The WritePICONImage function in coders/xpm.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/b04e9c949d917a4a603f1a9bfe09737246229323",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/631",
        "commit_text": "",
        "func_before": "static MagickBooleanType WritePICONImage(const ImageInfo *image_info,\n  Image *image)\n{\n#define ColormapExtent  155\n#define GraymapExtent  95\n#define PiconGeometry  \"48x48>\"\n\n  static unsigned char\n    Colormap[]=\n    {\n      0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x06, 0x00, 0x05, 0x00, 0xf4, 0x05,\n      0x00, 0x00, 0x00, 0x00, 0x2f, 0x4f, 0x4f, 0x70, 0x80, 0x90, 0x7e, 0x7e,\n      0x7e, 0xdc, 0xdc, 0xdc, 0xff, 0xff, 0xff, 0x00, 0x00, 0x80, 0x00, 0x00,\n      0xff, 0x1e, 0x90, 0xff, 0x87, 0xce, 0xeb, 0xe6, 0xe6, 0xfa, 0x00, 0xff,\n      0xff, 0x80, 0x00, 0x80, 0xb2, 0x22, 0x22, 0x2e, 0x8b, 0x57, 0x32, 0xcd,\n      0x32, 0x00, 0xff, 0x00, 0x98, 0xfb, 0x98, 0xff, 0x00, 0xff, 0xff, 0x00,\n      0x00, 0xff, 0x63, 0x47, 0xff, 0xa5, 0x00, 0xff, 0xd7, 0x00, 0xff, 0xff,\n      0x00, 0xee, 0x82, 0xee, 0xa0, 0x52, 0x2d, 0xcd, 0x85, 0x3f, 0xd2, 0xb4,\n      0x8c, 0xf5, 0xde, 0xb3, 0xff, 0xfa, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x21, 0xf9, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00,\n      0x00, 0x00, 0x06, 0x00, 0x05, 0x00, 0x00, 0x05, 0x18, 0x20, 0x10, 0x08,\n      0x03, 0x51, 0x18, 0x07, 0x92, 0x28, 0x0b, 0xd3, 0x38, 0x0f, 0x14, 0x49,\n      0x13, 0x55, 0x59, 0x17, 0x96, 0x69, 0x1b, 0xd7, 0x85, 0x00, 0x3b,\n    },\n    Graymap[]=\n    {\n      0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x04, 0x00, 0x04, 0x00, 0xf3, 0x0f,\n      0x00, 0x00, 0x00, 0x00, 0x12, 0x12, 0x12, 0x21, 0x21, 0x21, 0x33, 0x33,\n      0x33, 0x45, 0x45, 0x45, 0x54, 0x54, 0x54, 0x66, 0x66, 0x66, 0x78, 0x78,\n      0x78, 0x87, 0x87, 0x87, 0x99, 0x99, 0x99, 0xab, 0xab, 0xab, 0xba, 0xba,\n      0xba, 0xcc, 0xcc, 0xcc, 0xde, 0xde, 0xde, 0xed, 0xed, 0xed, 0xff, 0xff,\n      0xff, 0x21, 0xf9, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00,\n      0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04, 0x0c, 0x10, 0x04, 0x31,\n      0x48, 0x31, 0x07, 0x25, 0xb5, 0x58, 0x73, 0x4f, 0x04, 0x00, 0x3b,\n    };\n\n#define MaxCixels  92\n\n  static const char\n    Cixel[MaxCixels+1] = \" .XoO+@#$%&*=-;:>,<1234567890qwertyuipasdfghjk\"\n                         \"lzxcvbnmMNBVCZASDFGHJKLPIUYTREWQ!~^/()_`'][{}|\";\n\n  char\n    buffer[MaxTextExtent],\n    basename[MaxTextExtent],\n    name[MaxTextExtent],\n    symbol[MaxTextExtent];\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *affinity_image,\n    *picon;\n\n  ImageInfo\n    *blob_info;\n\n  MagickBooleanType\n    status,\n    transparent;\n\n  MagickPixelPacket\n    pixel;\n\n  QuantizeInfo\n    *quantize_info;\n\n  RectangleInfo\n    geometry;\n\n  register const IndexPacket\n    *indexes;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  size_t\n    characters_per_pixel,\n    colors;\n\n  ssize_t\n    j,\n    k,\n    y;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  SetGeometry(image,&geometry);\n  (void) ParseMetaGeometry(PiconGeometry,&geometry.x,&geometry.y,\n    &geometry.width,&geometry.height);\n  picon=ResizeImage(image,geometry.width,geometry.height,TriangleFilter,1.0,\n    &image->exception);\n  blob_info=CloneImageInfo(image_info);\n  (void) AcquireUniqueFilename(blob_info->filename);\n  if ((image_info->type != TrueColorType) &&\n      (SetImageGray(image,&image->exception) != MagickFalse))\n    affinity_image=BlobToImage(blob_info,Graymap,GraymapExtent,\n      &image->exception);\n  else\n    affinity_image=BlobToImage(blob_info,Colormap,ColormapExtent,\n      &image->exception);\n  (void) RelinquishUniqueFileResource(blob_info->filename);\n  blob_info=DestroyImageInfo(blob_info);\n  if ((picon == (Image *) NULL) || (affinity_image == (Image *) NULL))\n    return(MagickFalse);\n  quantize_info=AcquireQuantizeInfo(image_info);\n  status=RemapImage(quantize_info,picon,affinity_image);\n  quantize_info=DestroyQuantizeInfo(quantize_info);\n  affinity_image=DestroyImage(affinity_image);\n  transparent=MagickFalse;\n  exception=(&image->exception);\n  if (picon->storage_class == PseudoClass)\n    {\n      (void) CompressImageColormap(picon);\n      if (picon->matte != MagickFalse)\n        transparent=MagickTrue;\n    }\n  else\n    {\n      /*\n        Convert DirectClass to PseudoClass picon.\n      */\n      if (picon->matte != MagickFalse)\n        {\n          /*\n            Map all the transparent pixels.\n          */\n          for (y=0; y < (ssize_t) picon->rows; y++)\n          {\n            q=GetAuthenticPixels(picon,0,y,picon->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            for (x=0; x < (ssize_t) picon->columns; x++)\n            {\n              if (q->opacity == (Quantum) TransparentOpacity)\n                transparent=MagickTrue;\n              else\n                SetPixelOpacity(q,OpaqueOpacity);\n              q++;\n            }\n            if (SyncAuthenticPixels(picon,exception) == MagickFalse)\n              break;\n          }\n        }\n      (void) SetImageType(picon,PaletteType);\n    }\n  colors=picon->colors;\n  if (transparent != MagickFalse)\n    {\n      register IndexPacket\n        *indexes;\n\n      colors++;\n      picon->colormap=(PixelPacket *) ResizeQuantumMemory((void **)\n        picon->colormap,(size_t) colors,sizeof(*picon->colormap));\n      if (picon->colormap == (PixelPacket *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationError\");\n      for (y=0; y < (ssize_t) picon->rows; y++)\n      {\n        q=GetAuthenticPixels(picon,0,y,picon->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(picon);\n        for (x=0; x < (ssize_t) picon->columns; x++)\n        {\n          if (q->opacity == (Quantum) TransparentOpacity)\n            SetPixelIndex(indexes+x,picon->colors);\n          q++;\n        }\n        if (SyncAuthenticPixels(picon,exception) == MagickFalse)\n          break;\n      }\n    }\n  /*\n    Compute the character per pixel.\n  */\n  characters_per_pixel=1;\n  for (k=MaxCixels; (ssize_t) colors > k; k*=MaxCixels)\n    characters_per_pixel++;\n  /*\n    XPM header.\n  */\n  (void) WriteBlobString(image,\"/* XPM */\\n\");\n  GetPathComponent(picon->filename,BasePath,basename);\n  (void) FormatLocaleString(buffer,MaxTextExtent,\n    \"static char *%s[] = {\\n\",basename);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"/* columns rows colors chars-per-pixel */\\n\");\n  (void) FormatLocaleString(buffer,MaxTextExtent,\n    \"\\\"%.20g %.20g %.20g %.20g\\\",\\n\",(double) picon->columns,(double)\n    picon->rows,(double) colors,(double) characters_per_pixel);\n  (void) WriteBlobString(image,buffer);\n  GetMagickPixelPacket(image,&pixel);\n  for (i=0; i < (ssize_t) colors; i++)\n  {\n    /*\n      Define XPM color.\n    */\n    SetMagickPixelPacket(image,picon->colormap+i,(IndexPacket *) NULL,&pixel);\n    pixel.colorspace=sRGBColorspace;\n    pixel.depth=8;\n    pixel.opacity=(MagickRealType) OpaqueOpacity;\n    (void) QueryMagickColorname(image,&pixel,XPMCompliance,name,\n      &image->exception);\n    if (transparent != MagickFalse)\n      {\n        if (i == (ssize_t) (colors-1))\n          (void) CopyMagickString(name,\"grey75\",MaxTextExtent);\n      }\n    /*\n      Write XPM color.\n    */\n    k=i % MaxCixels;\n    symbol[0]=Cixel[k];\n    for (j=1; j < (ssize_t) characters_per_pixel; j++)\n    {\n      k=((i-k)/MaxCixels) % MaxCixels;\n      symbol[j]=Cixel[k];\n    }\n    symbol[j]='\\0';\n    (void) FormatLocaleString(buffer,MaxTextExtent,\"\\\"%s c %s\\\",\\n\",\n       symbol,name);\n    (void) WriteBlobString(image,buffer);\n  }\n  /*\n    Define XPM pixels.\n  */\n  (void) WriteBlobString(image,\"/* pixels */\\n\");\n  for (y=0; y < (ssize_t) picon->rows; y++)\n  {\n    p=GetVirtualPixels(picon,0,y,picon->columns,1,&picon->exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    indexes=GetVirtualIndexQueue(picon);\n    (void) WriteBlobString(image,\"\\\"\");\n    for (x=0; x < (ssize_t) picon->columns; x++)\n    {\n      k=((ssize_t) GetPixelIndex(indexes+x) % MaxCixels);\n      symbol[0]=Cixel[k];\n      for (j=1; j < (ssize_t) characters_per_pixel; j++)\n      {\n        k=(((int) GetPixelIndex(indexes+x)-k)/MaxCixels) % MaxCixels;\n        symbol[j]=Cixel[k];\n      }\n      symbol[j]='\\0';\n      (void) CopyMagickString(buffer,symbol,MaxTextExtent);\n      (void) WriteBlobString(image,buffer);\n    }\n    (void) FormatLocaleString(buffer,MaxTextExtent,\"\\\"%s\\n\",\n      y == (ssize_t) (picon->rows-1) ? \"\" : \",\");\n    (void) WriteBlobString(image,buffer);\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      picon->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  picon=DestroyImage(picon);\n  (void) WriteBlobString(image,\"};\\n\");\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
        "func": "static MagickBooleanType WritePICONImage(const ImageInfo *image_info,\n  Image *image)\n{\n#define ColormapExtent  155\n#define GraymapExtent  95\n#define PiconGeometry  \"48x48>\"\n\n  static unsigned char\n    Colormap[]=\n    {\n      0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x06, 0x00, 0x05, 0x00, 0xf4, 0x05,\n      0x00, 0x00, 0x00, 0x00, 0x2f, 0x4f, 0x4f, 0x70, 0x80, 0x90, 0x7e, 0x7e,\n      0x7e, 0xdc, 0xdc, 0xdc, 0xff, 0xff, 0xff, 0x00, 0x00, 0x80, 0x00, 0x00,\n      0xff, 0x1e, 0x90, 0xff, 0x87, 0xce, 0xeb, 0xe6, 0xe6, 0xfa, 0x00, 0xff,\n      0xff, 0x80, 0x00, 0x80, 0xb2, 0x22, 0x22, 0x2e, 0x8b, 0x57, 0x32, 0xcd,\n      0x32, 0x00, 0xff, 0x00, 0x98, 0xfb, 0x98, 0xff, 0x00, 0xff, 0xff, 0x00,\n      0x00, 0xff, 0x63, 0x47, 0xff, 0xa5, 0x00, 0xff, 0xd7, 0x00, 0xff, 0xff,\n      0x00, 0xee, 0x82, 0xee, 0xa0, 0x52, 0x2d, 0xcd, 0x85, 0x3f, 0xd2, 0xb4,\n      0x8c, 0xf5, 0xde, 0xb3, 0xff, 0xfa, 0xcd, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x21, 0xf9, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00,\n      0x00, 0x00, 0x06, 0x00, 0x05, 0x00, 0x00, 0x05, 0x18, 0x20, 0x10, 0x08,\n      0x03, 0x51, 0x18, 0x07, 0x92, 0x28, 0x0b, 0xd3, 0x38, 0x0f, 0x14, 0x49,\n      0x13, 0x55, 0x59, 0x17, 0x96, 0x69, 0x1b, 0xd7, 0x85, 0x00, 0x3b,\n    },\n    Graymap[]=\n    {\n      0x47, 0x49, 0x46, 0x38, 0x37, 0x61, 0x04, 0x00, 0x04, 0x00, 0xf3, 0x0f,\n      0x00, 0x00, 0x00, 0x00, 0x12, 0x12, 0x12, 0x21, 0x21, 0x21, 0x33, 0x33,\n      0x33, 0x45, 0x45, 0x45, 0x54, 0x54, 0x54, 0x66, 0x66, 0x66, 0x78, 0x78,\n      0x78, 0x87, 0x87, 0x87, 0x99, 0x99, 0x99, 0xab, 0xab, 0xab, 0xba, 0xba,\n      0xba, 0xcc, 0xcc, 0xcc, 0xde, 0xde, 0xde, 0xed, 0xed, 0xed, 0xff, 0xff,\n      0xff, 0x21, 0xf9, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00,\n      0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04, 0x0c, 0x10, 0x04, 0x31,\n      0x48, 0x31, 0x07, 0x25, 0xb5, 0x58, 0x73, 0x4f, 0x04, 0x00, 0x3b,\n    };\n\n#define MaxCixels  92\n\n  static const char\n    Cixel[MaxCixels+1] = \" .XoO+@#$%&*=-;:>,<1234567890qwertyuipasdfghjk\"\n                         \"lzxcvbnmMNBVCZASDFGHJKLPIUYTREWQ!~^/()_`'][{}|\";\n\n  char\n    buffer[MaxTextExtent],\n    basename[MaxTextExtent],\n    name[MaxTextExtent],\n    symbol[MaxTextExtent];\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *affinity_image,\n    *picon;\n\n  ImageInfo\n    *blob_info;\n\n  MagickBooleanType\n    status,\n    transparent;\n\n  MagickPixelPacket\n    pixel;\n\n  QuantizeInfo\n    *quantize_info;\n\n  RectangleInfo\n    geometry;\n\n  register const IndexPacket\n    *indexes;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  size_t\n    characters_per_pixel,\n    colors;\n\n  ssize_t\n    j,\n    k,\n    y;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  SetGeometry(image,&geometry);\n  (void) ParseMetaGeometry(PiconGeometry,&geometry.x,&geometry.y,\n    &geometry.width,&geometry.height);\n  picon=ResizeImage(image,geometry.width,geometry.height,TriangleFilter,1.0,\n    &image->exception);\n  blob_info=CloneImageInfo(image_info);\n  (void) AcquireUniqueFilename(blob_info->filename);\n  if ((image_info->type != TrueColorType) &&\n      (SetImageGray(image,&image->exception) != MagickFalse))\n    affinity_image=BlobToImage(blob_info,Graymap,GraymapExtent,\n      &image->exception);\n  else\n    affinity_image=BlobToImage(blob_info,Colormap,ColormapExtent,\n      &image->exception);\n  (void) RelinquishUniqueFileResource(blob_info->filename);\n  blob_info=DestroyImageInfo(blob_info);\n  if ((picon == (Image *) NULL) || (affinity_image == (Image *) NULL))\n    {\n      if (affinity_image != (Image *) NULL)\n        affinity_image=DestroyImage(affinity_image);\n      if (picon != (Image *) NULL)\n        picon=DestroyImage(picon);\n      return(MagickFalse);\n    }\n  quantize_info=AcquireQuantizeInfo(image_info);\n  status=RemapImage(quantize_info,picon,affinity_image);\n  quantize_info=DestroyQuantizeInfo(quantize_info);\n  affinity_image=DestroyImage(affinity_image);\n  transparent=MagickFalse;\n  exception=(&image->exception);\n  if (picon->storage_class == PseudoClass)\n    {\n      (void) CompressImageColormap(picon);\n      if (picon->matte != MagickFalse)\n        transparent=MagickTrue;\n    }\n  else\n    {\n      /*\n        Convert DirectClass to PseudoClass picon.\n      */\n      if (picon->matte != MagickFalse)\n        {\n          /*\n            Map all the transparent pixels.\n          */\n          for (y=0; y < (ssize_t) picon->rows; y++)\n          {\n            q=GetAuthenticPixels(picon,0,y,picon->columns,1,exception);\n            if (q == (PixelPacket *) NULL)\n              break;\n            for (x=0; x < (ssize_t) picon->columns; x++)\n            {\n              if (q->opacity == (Quantum) TransparentOpacity)\n                transparent=MagickTrue;\n              else\n                SetPixelOpacity(q,OpaqueOpacity);\n              q++;\n            }\n            if (SyncAuthenticPixels(picon,exception) == MagickFalse)\n              break;\n          }\n        }\n      (void) SetImageType(picon,PaletteType);\n    }\n  colors=picon->colors;\n  if (transparent != MagickFalse)\n    {\n      register IndexPacket\n        *indexes;\n\n      colors++;\n      picon->colormap=(PixelPacket *) ResizeQuantumMemory((void **)\n        picon->colormap,(size_t) colors,sizeof(*picon->colormap));\n      if (picon->colormap == (PixelPacket *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationError\");\n      for (y=0; y < (ssize_t) picon->rows; y++)\n      {\n        q=GetAuthenticPixels(picon,0,y,picon->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n          break;\n        indexes=GetAuthenticIndexQueue(picon);\n        for (x=0; x < (ssize_t) picon->columns; x++)\n        {\n          if (q->opacity == (Quantum) TransparentOpacity)\n            SetPixelIndex(indexes+x,picon->colors);\n          q++;\n        }\n        if (SyncAuthenticPixels(picon,exception) == MagickFalse)\n          break;\n      }\n    }\n  /*\n    Compute the character per pixel.\n  */\n  characters_per_pixel=1;\n  for (k=MaxCixels; (ssize_t) colors > k; k*=MaxCixels)\n    characters_per_pixel++;\n  /*\n    XPM header.\n  */\n  (void) WriteBlobString(image,\"/* XPM */\\n\");\n  GetPathComponent(picon->filename,BasePath,basename);\n  (void) FormatLocaleString(buffer,MaxTextExtent,\n    \"static char *%s[] = {\\n\",basename);\n  (void) WriteBlobString(image,buffer);\n  (void) WriteBlobString(image,\"/* columns rows colors chars-per-pixel */\\n\");\n  (void) FormatLocaleString(buffer,MaxTextExtent,\n    \"\\\"%.20g %.20g %.20g %.20g\\\",\\n\",(double) picon->columns,(double)\n    picon->rows,(double) colors,(double) characters_per_pixel);\n  (void) WriteBlobString(image,buffer);\n  GetMagickPixelPacket(image,&pixel);\n  for (i=0; i < (ssize_t) colors; i++)\n  {\n    /*\n      Define XPM color.\n    */\n    SetMagickPixelPacket(image,picon->colormap+i,(IndexPacket *) NULL,&pixel);\n    pixel.colorspace=sRGBColorspace;\n    pixel.depth=8;\n    pixel.opacity=(MagickRealType) OpaqueOpacity;\n    (void) QueryMagickColorname(image,&pixel,XPMCompliance,name,\n      &image->exception);\n    if (transparent != MagickFalse)\n      {\n        if (i == (ssize_t) (colors-1))\n          (void) CopyMagickString(name,\"grey75\",MaxTextExtent);\n      }\n    /*\n      Write XPM color.\n    */\n    k=i % MaxCixels;\n    symbol[0]=Cixel[k];\n    for (j=1; j < (ssize_t) characters_per_pixel; j++)\n    {\n      k=((i-k)/MaxCixels) % MaxCixels;\n      symbol[j]=Cixel[k];\n    }\n    symbol[j]='\\0';\n    (void) FormatLocaleString(buffer,MaxTextExtent,\"\\\"%s c %s\\\",\\n\",\n       symbol,name);\n    (void) WriteBlobString(image,buffer);\n  }\n  /*\n    Define XPM pixels.\n  */\n  (void) WriteBlobString(image,\"/* pixels */\\n\");\n  for (y=0; y < (ssize_t) picon->rows; y++)\n  {\n    p=GetVirtualPixels(picon,0,y,picon->columns,1,&picon->exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    indexes=GetVirtualIndexQueue(picon);\n    (void) WriteBlobString(image,\"\\\"\");\n    for (x=0; x < (ssize_t) picon->columns; x++)\n    {\n      k=((ssize_t) GetPixelIndex(indexes+x) % MaxCixels);\n      symbol[0]=Cixel[k];\n      for (j=1; j < (ssize_t) characters_per_pixel; j++)\n      {\n        k=(((int) GetPixelIndex(indexes+x)-k)/MaxCixels) % MaxCixels;\n        symbol[j]=Cixel[k];\n      }\n      symbol[j]='\\0';\n      (void) CopyMagickString(buffer,symbol,MaxTextExtent);\n      (void) WriteBlobString(image,buffer);\n    }\n    (void) FormatLocaleString(buffer,MaxTextExtent,\"\\\"%s\\n\",\n      y == (ssize_t) (picon->rows-1) ? \"\" : \",\");\n    (void) WriteBlobString(image,buffer);\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      picon->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  picon=DestroyImage(picon);\n  (void) WriteBlobString(image,\"};\\n\");\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -121,7 +121,13 @@\n   (void) RelinquishUniqueFileResource(blob_info->filename);\n   blob_info=DestroyImageInfo(blob_info);\n   if ((picon == (Image *) NULL) || (affinity_image == (Image *) NULL))\n-    return(MagickFalse);\n+    {\n+      if (affinity_image != (Image *) NULL)\n+        affinity_image=DestroyImage(affinity_image);\n+      if (picon != (Image *) NULL)\n+        picon=DestroyImage(picon);\n+      return(MagickFalse);\n+    }\n   quantize_info=AcquireQuantizeInfo(image_info);\n   status=RemapImage(quantize_info,picon,affinity_image);\n   quantize_info=DestroyQuantizeInfo(quantize_info);",
        "diff_line_info": {
            "deleted_lines": [
                "    return(MagickFalse);"
            ],
            "added_lines": [
                "    {",
                "      if (affinity_image != (Image *) NULL)",
                "        affinity_image=DestroyImage(affinity_image);",
                "      if (picon != (Image *) NULL)",
                "        picon=DestroyImage(picon);",
                "      return(MagickFalse);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11752",
        "func_name": "ImageMagick/ReadMAGICKImage",
        "description": "The ReadMAGICKImage function in coders/magick.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/21d19d0c64ff070dbf37279432837bf425c0d5dd",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/628",
        "commit_text": "",
        "func_before": "static Image *ReadMAGICKImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const void\n    *blob;\n\n  Image\n    *image;\n\n  ImageInfo\n    *blob_info;\n\n  register ssize_t\n    i;\n\n  size_t\n    extent;\n\n  blob_info=CloneImageInfo(image_info);\n  if (LocaleCompare(image_info->magick,\"MAGICK\") != 0)\n    (void) CopyMagickString(blob_info->filename,image_info->magick,\n      MaxTextExtent);\n  image=(Image *) NULL;\n  blob=(const void *) NULL;\n  extent=0;\n  for (i=0; MagickImageList[i].blob != (const void *) NULL; i++)\n    if (LocaleCompare(blob_info->filename,MagickImageList[i].name) == 0)\n      {\n        (void) CopyMagickString(blob_info->magick,MagickImageList[i].magick,\n          MaxTextExtent);\n        blob=MagickImageList[i].blob;\n        extent=MagickImageList[i].extent;\n        break;\n      }\n  if (blob == (const void *) NULL)\n    ThrowReaderException(OptionError,\"UnrecognizedImageFormat\");\n  image=BlobToImage(blob_info,blob,extent,exception);\n  blob_info=DestroyImageInfo(blob_info);\n  if (image == (Image *) NULL)\n    return(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadMAGICKImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const void\n    *blob;\n\n  Image\n    *image;\n\n  ImageInfo\n    *blob_info;\n\n  register ssize_t\n    i;\n\n  size_t\n    extent;\n\n  blob_info=CloneImageInfo(image_info);\n  if (LocaleCompare(image_info->magick,\"MAGICK\") != 0)\n    (void) CopyMagickString(blob_info->filename,image_info->magick,\n      MaxTextExtent);\n  image=(Image *) NULL;\n  blob=(const void *) NULL;\n  extent=0;\n  for (i=0; MagickImageList[i].blob != (const void *) NULL; i++)\n    if (LocaleCompare(blob_info->filename,MagickImageList[i].name) == 0)\n      {\n        (void) CopyMagickString(blob_info->magick,MagickImageList[i].magick,\n          MaxTextExtent);\n        blob=MagickImageList[i].blob;\n        extent=MagickImageList[i].extent;\n        break;\n      }\n  if (blob == (const void *) NULL)\n    {\n      blob_info=DestroyImageInfo(blob_info);\n      ThrowReaderException(OptionError,\"UnrecognizedImageFormat\");\n    }\n  image=BlobToImage(blob_info,blob,extent,exception);\n  blob_info=DestroyImageInfo(blob_info);\n  if (image == (Image *) NULL)\n    return(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -33,7 +33,10 @@\n         break;\n       }\n   if (blob == (const void *) NULL)\n-    ThrowReaderException(OptionError,\"UnrecognizedImageFormat\");\n+    {\n+      blob_info=DestroyImageInfo(blob_info);\n+      ThrowReaderException(OptionError,\"UnrecognizedImageFormat\");\n+    }\n   image=BlobToImage(blob_info,blob,extent,exception);\n   blob_info=DestroyImageInfo(blob_info);\n   if (image == (Image *) NULL)",
        "diff_line_info": {
            "deleted_lines": [
                "    ThrowReaderException(OptionError,\"UnrecognizedImageFormat\");"
            ],
            "added_lines": [
                "    {",
                "      blob_info=DestroyImageInfo(blob_info);",
                "      ThrowReaderException(OptionError,\"UnrecognizedImageFormat\");",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12418",
        "func_name": "ImageMagick/format8BIM",
        "description": "ImageMagick 7.0.6-5 has memory leaks in the parse8BIMW and format8BIM functions in coders/meta.c, related to the WriteImage function in MagickCore/constitute.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/46382526a3f09cebf9f2af680fc55b2a668fcbef",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/643",
        "commit_text": "",
        "func_before": "static int format8BIM(Image *ifile, Image *ofile)\n{\n  char\n    temp[MagickPathExtent];\n\n  unsigned int\n    foundOSType;\n\n  int\n    ID,\n    resCount,\n    i,\n    c;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *PString,\n    *str;\n\n  resCount=0;\n  foundOSType=0; /* found the OSType */\n  (void) foundOSType;\n  c=ReadBlobByte(ifile);\n  while (c != EOF)\n  {\n    if (c == '8')\n      {\n        unsigned char\n          buffer[5];\n\n        buffer[0]=(unsigned char) c;\n        for (i=1; i<4; i++)\n        {\n          c=ReadBlobByte(ifile);\n          if (c == EOF)\n            return(-1);\n          buffer[i] = (unsigned char) c;\n        }\n        buffer[4]=0;\n        if (strcmp((const char *)buffer, \"8BIM\") == 0)\n          foundOSType=1;\n        else\n          continue;\n      }\n    else\n      {\n        c=ReadBlobByte(ifile);\n        continue;\n      }\n    /*\n      We found the OSType (8BIM) and now grab the ID, PString, and Size fields.\n    */\n    ID=ReadBlobMSBSignedShort(ifile);\n    if (ID < 0)\n      return(-1);\n    {\n      unsigned char\n        plen;\n\n      c=ReadBlobByte(ifile);\n      if (c == EOF)\n        return(-1);\n      plen = (unsigned char) c;\n      PString=(unsigned char *) AcquireQuantumMemory((size_t) (plen+\n        MagickPathExtent),sizeof(*PString));\n      if (PString == (unsigned char *) NULL)\n        {\n          printf(\"MemoryAllocationFailed\");\n          return 0;\n        }\n      for (i=0; i<plen; i++)\n      {\n        c=ReadBlobByte(ifile);\n        if (c == EOF) return -1;\n        PString[i] = (unsigned char) c;\n      }\n      PString[ plen ] = 0;\n      if ((plen & 0x01) == 0)\n      {\n        c=ReadBlobByte(ifile);\n        if (c == EOF)\n          return(-1);\n      }\n    }\n    count=ReadBlobMSBSignedLong(ifile);\n    if (count < 0) return -1;\n    /* make a buffer to hold the datand snag it from the input stream */\n    str=(unsigned char *) AcquireQuantumMemory((size_t) count,sizeof(*str));\n    if (str == (unsigned char *) NULL)\n      {\n        printf(\"MemoryAllocationFailed\");\n        return 0;\n      }\n    for (i=0; i < (ssize_t) count; i++)\n    {\n      c=ReadBlobByte(ifile);\n      if (c == EOF)\n        return(-1);\n      str[i]=(unsigned char) c;\n    }\n\n    /* we currently skip thumbnails, since it does not make\n     * any sense preserving them in a real world application\n     */\n    if (ID != THUMBNAIL_ID)\n      {\n        /* now finish up by formatting this binary data into\n         * ASCII equivalent\n         */\n        if (strlen((const char *)PString) > 0)\n          (void) FormatLocaleString(temp,MagickPathExtent,\"8BIM#%d#%s=\",ID,\n            PString);\n        else\n          (void) FormatLocaleString(temp,MagickPathExtent,\"8BIM#%d=\",ID);\n        (void) WriteBlobString(ofile,temp);\n        if (ID == IPTC_ID)\n          {\n            formatString(ofile, \"IPTC\", 4);\n            formatIPTCfromBuffer(ofile, (char *)str, (ssize_t) count);\n          }\n        else\n          formatString(ofile, (char *)str, (ssize_t) count);\n      }\n    str=(unsigned char *) RelinquishMagickMemory(str);\n    PString=(unsigned char *) RelinquishMagickMemory(PString);\n    resCount++;\n    c=ReadBlobByte(ifile);\n  }\n  return resCount;\n}",
        "func": "static int format8BIM(Image *ifile, Image *ofile)\n{\n  char\n    temp[MagickPathExtent];\n\n  unsigned int\n    foundOSType;\n\n  int\n    ID,\n    resCount,\n    i,\n    c;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *PString,\n    *str;\n\n  resCount=0;\n  foundOSType=0; /* found the OSType */\n  (void) foundOSType;\n  c=ReadBlobByte(ifile);\n  while (c != EOF)\n  {\n    if (c == '8')\n      {\n        unsigned char\n          buffer[5];\n\n        buffer[0]=(unsigned char) c;\n        for (i=1; i<4; i++)\n        {\n          c=ReadBlobByte(ifile);\n          if (c == EOF)\n            return(-1);\n          buffer[i] = (unsigned char) c;\n        }\n        buffer[4]=0;\n        if (strcmp((const char *)buffer, \"8BIM\") == 0)\n          foundOSType=1;\n        else\n          continue;\n      }\n    else\n      {\n        c=ReadBlobByte(ifile);\n        continue;\n      }\n    /*\n      We found the OSType (8BIM) and now grab the ID, PString, and Size fields.\n    */\n    ID=ReadBlobMSBSignedShort(ifile);\n    if (ID < 0)\n      return(-1);\n    {\n      unsigned char\n        plen;\n\n      c=ReadBlobByte(ifile);\n      if (c == EOF)\n        return(-1);\n      plen = (unsigned char) c;\n      PString=(unsigned char *) AcquireQuantumMemory((size_t) (plen+\n        MagickPathExtent),sizeof(*PString));\n      if (PString == (unsigned char *) NULL)\n        {\n          printf(\"MemoryAllocationFailed\");\n          return 0;\n        }\n      for (i=0; i<plen; i++)\n      {\n        c=ReadBlobByte(ifile);\n        if (c == EOF)\n          {\n            PString=(unsigned char *) RelinquishMagickMemory(PString);\n            return -1;\n          }\n        PString[i] = (unsigned char) c;\n      }\n      PString[ plen ] = 0;\n      if ((plen & 0x01) == 0)\n      {\n        c=ReadBlobByte(ifile);\n        if (c == EOF)\n          {\n            PString=(unsigned char *) RelinquishMagickMemory(PString);\n            return -1;\n          }\n      }\n    }\n    count=ReadBlobMSBSignedLong(ifile);\n    if (count < 0)\n      {\n        PString=(unsigned char *) RelinquishMagickMemory(PString);\n        return -1;\n      }\n    /* make a buffer to hold the datand snag it from the input stream */\n    str=(unsigned char *) AcquireQuantumMemory((size_t) count,sizeof(*str));\n    if (str == (unsigned char *) NULL)\n      {\n        PString=(unsigned char *) RelinquishMagickMemory(PString);\n        printf(\"MemoryAllocationFailed\");\n        return 0;\n      }\n    for (i=0; i < (ssize_t) count; i++)\n    {\n      c=ReadBlobByte(ifile);\n      if (c == EOF)\n        {\n          PString=(unsigned char *) RelinquishMagickMemory(PString);\n          return -1;\n        }\n      str[i]=(unsigned char) c;\n    }\n\n    /* we currently skip thumbnails, since it does not make\n     * any sense preserving them in a real world application\n     */\n    if (ID != THUMBNAIL_ID)\n      {\n        /* now finish up by formatting this binary data into\n         * ASCII equivalent\n         */\n        if (strlen((const char *)PString) > 0)\n          (void) FormatLocaleString(temp,MagickPathExtent,\"8BIM#%d#%s=\",ID,\n            PString);\n        else\n          (void) FormatLocaleString(temp,MagickPathExtent,\"8BIM#%d=\",ID);\n        (void) WriteBlobString(ofile,temp);\n        if (ID == IPTC_ID)\n          {\n            formatString(ofile, \"IPTC\", 4);\n            formatIPTCfromBuffer(ofile, (char *)str, (ssize_t) count);\n          }\n        else\n          formatString(ofile, (char *)str, (ssize_t) count);\n      }\n    str=(unsigned char *) RelinquishMagickMemory(str);\n    PString=(unsigned char *) RelinquishMagickMemory(PString);\n    resCount++;\n    c=ReadBlobByte(ifile);\n  }\n  return resCount;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -73,7 +73,11 @@\n       for (i=0; i<plen; i++)\n       {\n         c=ReadBlobByte(ifile);\n-        if (c == EOF) return -1;\n+        if (c == EOF)\n+          {\n+            PString=(unsigned char *) RelinquishMagickMemory(PString);\n+            return -1;\n+          }\n         PString[i] = (unsigned char) c;\n       }\n       PString[ plen ] = 0;\n@@ -81,15 +85,23 @@\n       {\n         c=ReadBlobByte(ifile);\n         if (c == EOF)\n-          return(-1);\n+          {\n+            PString=(unsigned char *) RelinquishMagickMemory(PString);\n+            return -1;\n+          }\n       }\n     }\n     count=ReadBlobMSBSignedLong(ifile);\n-    if (count < 0) return -1;\n+    if (count < 0)\n+      {\n+        PString=(unsigned char *) RelinquishMagickMemory(PString);\n+        return -1;\n+      }\n     /* make a buffer to hold the datand snag it from the input stream */\n     str=(unsigned char *) AcquireQuantumMemory((size_t) count,sizeof(*str));\n     if (str == (unsigned char *) NULL)\n       {\n+        PString=(unsigned char *) RelinquishMagickMemory(PString);\n         printf(\"MemoryAllocationFailed\");\n         return 0;\n       }\n@@ -97,7 +109,10 @@\n     {\n       c=ReadBlobByte(ifile);\n       if (c == EOF)\n-        return(-1);\n+        {\n+          PString=(unsigned char *) RelinquishMagickMemory(PString);\n+          return -1;\n+        }\n       str[i]=(unsigned char) c;\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "        if (c == EOF) return -1;",
                "          return(-1);",
                "    if (count < 0) return -1;",
                "        return(-1);"
            ],
            "added_lines": [
                "        if (c == EOF)",
                "          {",
                "            PString=(unsigned char *) RelinquishMagickMemory(PString);",
                "            return -1;",
                "          }",
                "          {",
                "            PString=(unsigned char *) RelinquishMagickMemory(PString);",
                "            return -1;",
                "          }",
                "    if (count < 0)",
                "      {",
                "        PString=(unsigned char *) RelinquishMagickMemory(PString);",
                "        return -1;",
                "      }",
                "        PString=(unsigned char *) RelinquishMagickMemory(PString);",
                "        {",
                "          PString=(unsigned char *) RelinquishMagickMemory(PString);",
                "          return -1;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12427",
        "func_name": "ImageMagick/ProcessMSLScript",
        "description": "The ProcessMSLScript function in coders/msl.c in ImageMagick before 6.9.9-5 and 7.x before 7.0.6-5 allows remote attackers to cause a denial of service (memory leak) via a crafted file, related to the WriteMSLImage function.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/e793eb203e5e0f91f5037aed6585e81b1e27395b",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/636",
        "commit_text": "",
        "func_before": "static MagickBooleanType ProcessMSLScript(const ImageInfo *image_info,\n  Image **image,ExceptionInfo *exception)\n{\n  char\n    message[MagickPathExtent];\n\n  Image\n    *msl_image;\n\n  int\n    status;\n\n  ssize_t\n    n;\n\n  MSLInfo\n    msl_info;\n\n  xmlSAXHandler\n    sax_modules;\n\n  xmlSAXHandlerPtr\n    sax_handler;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(image != (Image **) NULL);\n  msl_image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,msl_image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        msl_image->filename);\n      msl_image=DestroyImageList(msl_image);\n      return(MagickFalse);\n    }\n  msl_image->columns=1;\n  msl_image->rows=1;\n  /*\n    Parse MSL file.\n  */\n  (void) ResetMagickMemory(&msl_info,0,sizeof(msl_info));\n  msl_info.exception=exception;\n  msl_info.image_info=(ImageInfo **) AcquireMagickMemory(\n    sizeof(*msl_info.image_info));\n  msl_info.draw_info=(DrawInfo **) AcquireMagickMemory(\n    sizeof(*msl_info.draw_info));\n  /* top of the stack is the MSL file itself */\n  msl_info.image=(Image **) AcquireMagickMemory(sizeof(*msl_info.image));\n  msl_info.attributes=(Image **) AcquireMagickMemory(\n    sizeof(*msl_info.attributes));\n  msl_info.group_info=(MSLGroupInfo *) AcquireMagickMemory(\n    sizeof(*msl_info.group_info));\n  if ((msl_info.image_info == (ImageInfo **) NULL) ||\n      (msl_info.image == (Image **) NULL) ||\n      (msl_info.attributes == (Image **) NULL) ||\n      (msl_info.group_info == (MSLGroupInfo *) NULL))\n    ThrowFatalException(ResourceLimitFatalError,\"UnableToInterpretMSLImage\");\n  *msl_info.image_info=CloneImageInfo(image_info);\n  *msl_info.draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  *msl_info.attributes=AcquireImage(image_info,exception);\n  msl_info.group_info[0].numImages=0;\n  /* the first slot is used to point to the MSL file image */\n  *msl_info.image=msl_image;\n  if (*image != (Image *) NULL)\n    MSLPushImage(&msl_info,*image);\n  (void) xmlSubstituteEntitiesDefault(1);\n  (void) ResetMagickMemory(&sax_modules,0,sizeof(sax_modules));\n  sax_modules.internalSubset=MSLInternalSubset;\n  sax_modules.isStandalone=MSLIsStandalone;\n  sax_modules.hasInternalSubset=MSLHasInternalSubset;\n  sax_modules.hasExternalSubset=MSLHasExternalSubset;\n  sax_modules.resolveEntity=MSLResolveEntity;\n  sax_modules.getEntity=MSLGetEntity;\n  sax_modules.entityDecl=MSLEntityDeclaration;\n  sax_modules.notationDecl=MSLNotationDeclaration;\n  sax_modules.attributeDecl=MSLAttributeDeclaration;\n  sax_modules.elementDecl=MSLElementDeclaration;\n  sax_modules.unparsedEntityDecl=MSLUnparsedEntityDeclaration;\n  sax_modules.setDocumentLocator=MSLSetDocumentLocator;\n  sax_modules.startDocument=MSLStartDocument;\n  sax_modules.endDocument=MSLEndDocument;\n  sax_modules.startElement=MSLStartElement;\n  sax_modules.endElement=MSLEndElement;\n  sax_modules.reference=MSLReference;\n  sax_modules.characters=MSLCharacters;\n  sax_modules.ignorableWhitespace=MSLIgnorableWhitespace;\n  sax_modules.processingInstruction=MSLProcessingInstructions;\n  sax_modules.comment=MSLComment;\n  sax_modules.warning=MSLWarning;\n  sax_modules.error=MSLError;\n  sax_modules.fatalError=MSLError;\n  sax_modules.getParameterEntity=MSLGetParameterEntity;\n  sax_modules.cdataBlock=MSLCDataBlock;\n  sax_modules.externalSubset=MSLExternalSubset;\n  sax_handler=(&sax_modules);\n  msl_info.parser=xmlCreatePushParserCtxt(sax_handler,&msl_info,(char *) NULL,0,\n    msl_image->filename);\n  while (ReadBlobString(msl_image,message) != (char *) NULL)\n  {\n    n=(ssize_t) strlen(message);\n    if (n == 0)\n      continue;\n    status=xmlParseChunk(msl_info.parser,message,(int) n,MagickFalse);\n    if (status != 0)\n      break;\n    (void) xmlParseChunk(msl_info.parser,\" \",1,MagickFalse);\n    if (msl_info.exception->severity >= ErrorException)\n      break;\n  }\n  if (msl_info.exception->severity == UndefinedException)\n    (void) xmlParseChunk(msl_info.parser,\" \",1,MagickTrue);\n  xmlFreeParserCtxt(msl_info.parser);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"end SAX\");\n  msl_info.group_info=(MSLGroupInfo *) RelinquishMagickMemory(\n    msl_info.group_info);\n  if (*image == (Image *) NULL)\n    *image=(*msl_info.image);\n  if (msl_info.exception->severity != UndefinedException)\n    return(MagickFalse);\n  return(MagickTrue);\n}",
        "func": "static MagickBooleanType ProcessMSLScript(const ImageInfo *image_info,\n  Image **image,ExceptionInfo *exception)\n{\n  char\n    message[MagickPathExtent];\n\n  Image\n    *msl_image;\n\n  int\n    status;\n\n  ssize_t\n    n;\n\n  MSLInfo\n    msl_info;\n\n  xmlSAXHandler\n    sax_modules;\n\n  xmlSAXHandlerPtr\n    sax_handler;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(image != (Image **) NULL);\n  msl_image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,msl_image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        msl_image->filename);\n      msl_image=DestroyImageList(msl_image);\n      return(MagickFalse);\n    }\n  msl_image->columns=1;\n  msl_image->rows=1;\n  /*\n    Parse MSL file.\n  */\n  (void) ResetMagickMemory(&msl_info,0,sizeof(msl_info));\n  msl_info.exception=exception;\n  msl_info.image_info=(ImageInfo **) AcquireMagickMemory(\n    sizeof(*msl_info.image_info));\n  msl_info.draw_info=(DrawInfo **) AcquireMagickMemory(\n    sizeof(*msl_info.draw_info));\n  /* top of the stack is the MSL file itself */\n  msl_info.image=(Image **) AcquireMagickMemory(sizeof(*msl_info.image));\n  msl_info.attributes=(Image **) AcquireMagickMemory(\n    sizeof(*msl_info.attributes));\n  msl_info.group_info=(MSLGroupInfo *) AcquireMagickMemory(\n    sizeof(*msl_info.group_info));\n  if ((msl_info.image_info == (ImageInfo **) NULL) ||\n      (msl_info.image == (Image **) NULL) ||\n      (msl_info.attributes == (Image **) NULL) ||\n      (msl_info.group_info == (MSLGroupInfo *) NULL))\n    ThrowFatalException(ResourceLimitFatalError,\"UnableToInterpretMSLImage\");\n  *msl_info.image_info=CloneImageInfo(image_info);\n  *msl_info.draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  *msl_info.attributes=AcquireImage(image_info,exception);\n  msl_info.group_info[0].numImages=0;\n  /* the first slot is used to point to the MSL file image */\n  *msl_info.image=msl_image;\n  if (*image != (Image *) NULL)\n    MSLPushImage(&msl_info,*image);\n  (void) xmlSubstituteEntitiesDefault(1);\n  (void) ResetMagickMemory(&sax_modules,0,sizeof(sax_modules));\n  sax_modules.internalSubset=MSLInternalSubset;\n  sax_modules.isStandalone=MSLIsStandalone;\n  sax_modules.hasInternalSubset=MSLHasInternalSubset;\n  sax_modules.hasExternalSubset=MSLHasExternalSubset;\n  sax_modules.resolveEntity=MSLResolveEntity;\n  sax_modules.getEntity=MSLGetEntity;\n  sax_modules.entityDecl=MSLEntityDeclaration;\n  sax_modules.notationDecl=MSLNotationDeclaration;\n  sax_modules.attributeDecl=MSLAttributeDeclaration;\n  sax_modules.elementDecl=MSLElementDeclaration;\n  sax_modules.unparsedEntityDecl=MSLUnparsedEntityDeclaration;\n  sax_modules.setDocumentLocator=MSLSetDocumentLocator;\n  sax_modules.startDocument=MSLStartDocument;\n  sax_modules.endDocument=MSLEndDocument;\n  sax_modules.startElement=MSLStartElement;\n  sax_modules.endElement=MSLEndElement;\n  sax_modules.reference=MSLReference;\n  sax_modules.characters=MSLCharacters;\n  sax_modules.ignorableWhitespace=MSLIgnorableWhitespace;\n  sax_modules.processingInstruction=MSLProcessingInstructions;\n  sax_modules.comment=MSLComment;\n  sax_modules.warning=MSLWarning;\n  sax_modules.error=MSLError;\n  sax_modules.fatalError=MSLError;\n  sax_modules.getParameterEntity=MSLGetParameterEntity;\n  sax_modules.cdataBlock=MSLCDataBlock;\n  sax_modules.externalSubset=MSLExternalSubset;\n  sax_handler=(&sax_modules);\n  msl_info.parser=xmlCreatePushParserCtxt(sax_handler,&msl_info,(char *) NULL,0,\n    msl_image->filename);\n  while (ReadBlobString(msl_image,message) != (char *) NULL)\n  {\n    n=(ssize_t) strlen(message);\n    if (n == 0)\n      continue;\n    status=xmlParseChunk(msl_info.parser,message,(int) n,MagickFalse);\n    if (status != 0)\n      break;\n    (void) xmlParseChunk(msl_info.parser,\" \",1,MagickFalse);\n    if (msl_info.exception->severity >= ErrorException)\n      break;\n  }\n  if (msl_info.exception->severity == UndefinedException)\n    (void) xmlParseChunk(msl_info.parser,\" \",1,MagickTrue);\n  /*\n    Free resources.\n  */\n  xmlFreeParserCtxt(msl_info.parser);\n  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"end SAX\");\n  msl_info.group_info=(MSLGroupInfo *) RelinquishMagickMemory(\n    msl_info.group_info);\n  if (*image == (Image *) NULL)\n    *image=(*msl_info.image);\n  *msl_info.image_info=DestroyImageInfo(*msl_info.image_info);\n  msl_info.image_info=(ImageInfo **) RelinquishMagickMemory(\n    msl_info.image_info);\n  *msl_info.draw_info=DestroyDrawInfo(*msl_info.draw_info);\n  msl_info.draw_info=(DrawInfo **) RelinquishMagickMemory(msl_info.draw_info);\n  msl_info.image=(Image **) RelinquishMagickMemory(msl_info.image);\n  *msl_info.attributes=DestroyImage(*msl_info.attributes);\n  msl_info.attributes=(Image **) RelinquishMagickMemory(msl_info.attributes);\n  msl_info.group_info=(MSLGroupInfo *) RelinquishMagickMemory(\n    msl_info.group_info);\n  if (msl_info.exception->severity != UndefinedException)\n    return(MagickFalse);\n  return(MagickTrue);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -116,12 +116,25 @@\n   }\n   if (msl_info.exception->severity == UndefinedException)\n     (void) xmlParseChunk(msl_info.parser,\" \",1,MagickTrue);\n+  /*\n+    Free resources.\n+  */\n   xmlFreeParserCtxt(msl_info.parser);\n   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"end SAX\");\n   msl_info.group_info=(MSLGroupInfo *) RelinquishMagickMemory(\n     msl_info.group_info);\n   if (*image == (Image *) NULL)\n     *image=(*msl_info.image);\n+  *msl_info.image_info=DestroyImageInfo(*msl_info.image_info);\n+  msl_info.image_info=(ImageInfo **) RelinquishMagickMemory(\n+    msl_info.image_info);\n+  *msl_info.draw_info=DestroyDrawInfo(*msl_info.draw_info);\n+  msl_info.draw_info=(DrawInfo **) RelinquishMagickMemory(msl_info.draw_info);\n+  msl_info.image=(Image **) RelinquishMagickMemory(msl_info.image);\n+  *msl_info.attributes=DestroyImage(*msl_info.attributes);\n+  msl_info.attributes=(Image **) RelinquishMagickMemory(msl_info.attributes);\n+  msl_info.group_info=(MSLGroupInfo *) RelinquishMagickMemory(\n+    msl_info.group_info);\n   if (msl_info.exception->severity != UndefinedException)\n     return(MagickFalse);\n   return(MagickTrue);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  /*",
                "    Free resources.",
                "  */",
                "  *msl_info.image_info=DestroyImageInfo(*msl_info.image_info);",
                "  msl_info.image_info=(ImageInfo **) RelinquishMagickMemory(",
                "    msl_info.image_info);",
                "  *msl_info.draw_info=DestroyDrawInfo(*msl_info.draw_info);",
                "  msl_info.draw_info=(DrawInfo **) RelinquishMagickMemory(msl_info.draw_info);",
                "  msl_info.image=(Image **) RelinquishMagickMemory(msl_info.image);",
                "  *msl_info.attributes=DestroyImage(*msl_info.attributes);",
                "  msl_info.attributes=(Image **) RelinquishMagickMemory(msl_info.attributes);",
                "  msl_info.group_info=(MSLGroupInfo *) RelinquishMagickMemory(",
                "    msl_info.group_info);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12433",
        "func_name": "ImageMagick/ReadPESImage",
        "description": "In ImageMagick 7.0.6-1, a memory leak vulnerability was found in the function ReadPESImage in coders/pes.c, which allows attackers to cause a denial of service, related to ResizeMagickMemory in memory.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/7beec9a7a8a5701652b313e6e94bafd36b3627dc",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/548",
        "commit_text": "",
        "func_before": "static Image *ReadPESImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    delta_x,\n    delta_y,\n    j,\n    unique_file,\n    x,\n    y;\n\n  MagickBooleanType\n    status;\n\n  PESBlockInfo\n    blocks[256];\n\n  PointInfo\n    *stitches;\n\n  SegmentInfo\n    bounds;\n\n  register ssize_t\n    i;\n\n  size_t\n    number_blocks,\n    number_colors,\n    number_stitches;\n\n  ssize_t\n    count,\n    offset;\n\n  unsigned char\n    magick[4],\n    version[4];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Verify PES identifier.\n  */\n  count=ReadBlob(image,4,magick);\n  if ((count != 4) || (LocaleNCompare((char *) magick,\"#PES\",4) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  count=ReadBlob(image,4,version);\n  offset=ReadBlobLSBSignedLong(image);\n  if (DiscardBlobBytes(image,offset+36) == MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  /*\n    Get PES colors.\n  */\n  number_colors=(size_t) ReadBlobByte(image)+1;\n  for (i=0; i < (ssize_t) number_colors; i++)\n  {\n    j=ReadBlobByte(image);\n    blocks[i].color=PESColor+(j < 0 ? 0 : j);\n    blocks[i].offset=0;\n  }\n  for ( ; i < 256L; i++)\n  {\n    blocks[i].offset=0;\n    blocks[i].color=PESColor;\n  }\n  if (DiscardBlobBytes(image,532L-number_colors-21) == MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  /*\n    Stitch away.\n  */\n  number_stitches=64;\n  stitches=(PointInfo *) AcquireQuantumMemory(number_stitches,\n    sizeof(*stitches));\n  if (stitches == (PointInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  bounds.x1=65535.0;\n  bounds.y1=65535.0;\n  bounds.x2=(-65535.0);\n  bounds.y2=(-65535.0);\n  i=0;\n  j=0;\n  delta_x=0;\n  delta_y=0;\n  while (EOFBlob(image) == MagickFalse)\n  {\n    x=ReadBlobByte(image);\n    y=ReadBlobByte(image);\n    if ((x == 0xff) && (y == 0))\n      break;\n    if ((x == 254) && (y == 176))\n      {\n        /*\n          Start a new stitch block.\n        */\n        j++;\n        blocks[j].offset=(ssize_t) i;\n        if (j >= 256)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) ReadBlobByte(image);\n        continue;\n      }\n    if ((x & 0x80) == 0)\n      {\n        /*\n          Normal stitch.\n        */\n        if ((x & 0x40) != 0)\n          x-=0x80;\n      }\n    else\n      {\n        /*\n          Jump stitch.\n        */\n        x=((x & 0x0f) << 8)+y;\n        if ((x & 0x800) != 0)\n          x-=0x1000;\n        y=ReadBlobByte(image);\n      }\n    if ((y & 0x80) == 0)\n      {\n        /*\n          Normal stitch.\n        */\n        if ((y & 0x40) != 0)\n          y-=0x80;\n      }\n    else\n      {\n        /*\n          Jump stitch.\n        */\n        y=((y & 0x0f) << 8)+ReadBlobByte(image);\n        if ((y & 0x800) != 0)\n          y-=0x1000;\n      }\n    /*\n      Note stitch (x,y).\n    */\n    x+=delta_x;\n    y+=delta_y;\n    delta_x=x;\n    delta_y=y;\n    stitches[i].x=(double) x;\n    stitches[i].y=(double) y;\n    if ((double) x < bounds.x1)\n      bounds.x1=(double) x;\n    if ((double) x > bounds.x2)\n      bounds.x2=(double) x;\n    if ((double) y < bounds.y1)\n      bounds.y1=(double) y;\n    if ((double) y > bounds.y2)\n      bounds.y2=(double) y;\n    i++;\n    if (i >= (ssize_t) number_stitches)\n      {\n        /*\n          Make room for more stitches.\n        */\n        number_stitches<<=1;\n        stitches=(PointInfo *)  ResizeQuantumMemory(stitches,(size_t)\n          number_stitches,sizeof(*stitches));\n        if (stitches == (PointInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     }\n  }\n  j++;\n  blocks[j].offset=(ssize_t) i;\n  number_blocks=(size_t) j;\n  image->columns=bounds.x2-bounds.x1;\n  image->rows=bounds.y2-bounds.y1;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Write stitches as SVG file.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n  (void) FormatLocaleFile(file,\"<?xml version=\\\"1.0\\\"?>\\n\");\n  (void) FormatLocaleFile(file,\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" \"\n    \"xlink=\\\"http://www.w3.org/1999/xlink\\\" \"\n    \"ev=\\\"http://www.w3.org/2001/xml-events\\\" version=\\\"1.1\\\" \"\n    \"baseProfile=\\\"full\\\" width=\\\"%g\\\" height=\\\"%g\\\">\\n\",(double)\n    image->columns,(double) image->rows);\n  for (i=0; i < (ssize_t) number_blocks; i++)\n  {\n    offset=blocks[i].offset;\n    (void) FormatLocaleFile(file,\"  <path stroke=\\\"#%02x%02x%02x\\\" \"\n      \"fill=\\\"none\\\" d=\\\"M %g %g\",blocks[i].color->red,blocks[i].color->green,\n      blocks[i].color->blue,stitches[offset].x-bounds.x1,\n      stitches[offset].y-bounds.y1);\n    for (j=1; j < (ssize_t) (blocks[i+1].offset-offset); j++)\n      (void) FormatLocaleFile(file,\" L %g %g\",stitches[offset+j].x-bounds.x1,\n        stitches[offset+j].y-bounds.y1);\n    (void) FormatLocaleFile(file,\"\\\"/>\\n\");\n  }\n  (void) FormatLocaleFile(file,\"</svg>\\n\");\n  (void) fclose(file);\n  (void) CloseBlob(image);\n  image=DestroyImage(image);\n  /*\n    Read SVG file.\n  */\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"svg:%s\",\n    filename);\n  image=ReadImage(read_info,exception);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick_filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick,\"PES\",MagickPathExtent);\n    }\n  read_info=DestroyImageInfo(read_info);\n  (void) RelinquishUniqueFileResource(filename);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadPESImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    delta_x,\n    delta_y,\n    j,\n    unique_file,\n    x,\n    y;\n\n  MagickBooleanType\n    status;\n\n  PESBlockInfo\n    blocks[256];\n\n  PointInfo\n    *stitches;\n\n  SegmentInfo\n    bounds;\n\n  register ssize_t\n    i;\n\n  size_t\n    number_blocks,\n    number_colors,\n    number_stitches;\n\n  ssize_t\n    count,\n    offset;\n\n  unsigned char\n    magick[4],\n    version[4];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Verify PES identifier.\n  */\n  count=ReadBlob(image,4,magick);\n  if ((count != 4) || (LocaleNCompare((char *) magick,\"#PES\",4) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  count=ReadBlob(image,4,version);\n  offset=ReadBlobLSBSignedLong(image);\n  if (DiscardBlobBytes(image,offset+36) == MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  /*\n    Get PES colors.\n  */\n  number_colors=(size_t) ReadBlobByte(image)+1;\n  for (i=0; i < (ssize_t) number_colors; i++)\n  {\n    j=ReadBlobByte(image);\n    blocks[i].color=PESColor+(j < 0 ? 0 : j);\n    blocks[i].offset=0;\n  }\n  for ( ; i < 256L; i++)\n  {\n    blocks[i].offset=0;\n    blocks[i].color=PESColor;\n  }\n  if (DiscardBlobBytes(image,532L-number_colors-21) == MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  /*\n    Stitch away.\n  */\n  number_stitches=64;\n  stitches=(PointInfo *) AcquireQuantumMemory(number_stitches,\n    sizeof(*stitches));\n  if (stitches == (PointInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  bounds.x1=65535.0;\n  bounds.y1=65535.0;\n  bounds.x2=(-65535.0);\n  bounds.y2=(-65535.0);\n  i=0;\n  j=0;\n  delta_x=0;\n  delta_y=0;\n  while (EOFBlob(image) == MagickFalse)\n  {\n    x=ReadBlobByte(image);\n    y=ReadBlobByte(image);\n    if ((x == 0xff) && (y == 0))\n      break;\n    if ((x == 254) && (y == 176))\n      {\n        /*\n          Start a new stitch block.\n        */\n        j++;\n        blocks[j].offset=(ssize_t) i;\n        if (j >= 256)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) ReadBlobByte(image);\n        continue;\n      }\n    if ((x & 0x80) == 0)\n      {\n        /*\n          Normal stitch.\n        */\n        if ((x & 0x40) != 0)\n          x-=0x80;\n      }\n    else\n      {\n        /*\n          Jump stitch.\n        */\n        x=((x & 0x0f) << 8)+y;\n        if ((x & 0x800) != 0)\n          x-=0x1000;\n        y=ReadBlobByte(image);\n      }\n    if ((y & 0x80) == 0)\n      {\n        /*\n          Normal stitch.\n        */\n        if ((y & 0x40) != 0)\n          y-=0x80;\n      }\n    else\n      {\n        /*\n          Jump stitch.\n        */\n        y=((y & 0x0f) << 8)+ReadBlobByte(image);\n        if ((y & 0x800) != 0)\n          y-=0x1000;\n      }\n    /*\n      Note stitch (x,y).\n    */\n    x+=delta_x;\n    y+=delta_y;\n    delta_x=x;\n    delta_y=y;\n    stitches[i].x=(double) x;\n    stitches[i].y=(double) y;\n    if ((double) x < bounds.x1)\n      bounds.x1=(double) x;\n    if ((double) x > bounds.x2)\n      bounds.x2=(double) x;\n    if ((double) y < bounds.y1)\n      bounds.y1=(double) y;\n    if ((double) y > bounds.y2)\n      bounds.y2=(double) y;\n    i++;\n    if (i >= (ssize_t) number_stitches)\n      {\n        /*\n          Make room for more stitches.\n        */\n        number_stitches<<=1;\n        stitches=(PointInfo *)  ResizeQuantumMemory(stitches,(size_t)\n          number_stitches,sizeof(*stitches));\n        if (stitches == (PointInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     }\n  }\n  j++;\n  blocks[j].offset=(ssize_t) i;\n  number_blocks=(size_t) j;\n  image->columns=bounds.x2-bounds.x1;\n  image->rows=bounds.y2-bounds.y1;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    {\n      stitches=(PointInfo *) RelinquishMagickMemory(stitches);\n      return(DestroyImageList(image));\n    }\n  /*\n    Write stitches as SVG file.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n  (void) FormatLocaleFile(file,\"<?xml version=\\\"1.0\\\"?>\\n\");\n  (void) FormatLocaleFile(file,\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" \"\n    \"xlink=\\\"http://www.w3.org/1999/xlink\\\" \"\n    \"ev=\\\"http://www.w3.org/2001/xml-events\\\" version=\\\"1.1\\\" \"\n    \"baseProfile=\\\"full\\\" width=\\\"%g\\\" height=\\\"%g\\\">\\n\",(double)\n    image->columns,(double) image->rows);\n  for (i=0; i < (ssize_t) number_blocks; i++)\n  {\n    offset=blocks[i].offset;\n    (void) FormatLocaleFile(file,\"  <path stroke=\\\"#%02x%02x%02x\\\" \"\n      \"fill=\\\"none\\\" d=\\\"M %g %g\",blocks[i].color->red,blocks[i].color->green,\n      blocks[i].color->blue,stitches[offset].x-bounds.x1,\n      stitches[offset].y-bounds.y1);\n    for (j=1; j < (ssize_t) (blocks[i+1].offset-offset); j++)\n      (void) FormatLocaleFile(file,\" L %g %g\",stitches[offset+j].x-bounds.x1,\n        stitches[offset+j].y-bounds.y1);\n    (void) FormatLocaleFile(file,\"\\\"/>\\n\");\n  }\n  (void) FormatLocaleFile(file,\"</svg>\\n\");\n  (void) fclose(file);\n  stitches=(PointInfo *) RelinquishMagickMemory(stitches);\n  (void) CloseBlob(image);\n  image=DestroyImage(image);\n  /*\n    Read SVG file.\n  */\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"svg:%s\",\n    filename);\n  image=ReadImage(read_info,exception);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick_filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick,\"PES\",MagickPathExtent);\n    }\n  read_info=DestroyImageInfo(read_info);\n  (void) RelinquishUniqueFileResource(filename);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -204,7 +204,10 @@\n   image->rows=bounds.y2-bounds.y1;\n   status=SetImageExtent(image,image->columns,image->rows,exception);\n   if (status == MagickFalse)\n-    return(DestroyImageList(image));\n+    {\n+      stitches=(PointInfo *) RelinquishMagickMemory(stitches);\n+      return(DestroyImageList(image));\n+    }\n   /*\n     Write stitches as SVG file.\n   */\n@@ -234,6 +237,7 @@\n   }\n   (void) FormatLocaleFile(file,\"</svg>\\n\");\n   (void) fclose(file);\n+  stitches=(PointInfo *) RelinquishMagickMemory(stitches);\n   (void) CloseBlob(image);\n   image=DestroyImage(image);\n   /*",
        "diff_line_info": {
            "deleted_lines": [
                "    return(DestroyImageList(image));"
            ],
            "added_lines": [
                "    {",
                "      stitches=(PointInfo *) RelinquishMagickMemory(stitches);",
                "      return(DestroyImageList(image));",
                "    }",
                "  stitches=(PointInfo *) RelinquishMagickMemory(stitches);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12564",
        "func_name": "ImageMagick/ReadMATImage",
        "description": "In ImageMagick 7.0.6-2, a memory leak vulnerability was found in the function ReadMATImage in coders/mat.c, which allows attackers to cause a denial of service.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/a4779cfbee2e4235fa9f9f8f2e58dca17f7ccc6b",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/601",
        "commit_text": "",
        "func_before": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if ((image != image2) && (image2 != (Image *) NULL))\n    image2=DestroyImage(image2);\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}",
        "func": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if ((image != image2) && (image2 != (Image *) NULL))\n    image2=DestroyImage(image2);\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -250,6 +250,10 @@\n         ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n         break;\n       default:\n+        if ((image != image2) && (image2 != (Image *) NULL))\n+          image2=DestroyImage(image2);\n+        if (clone_info)\n+          clone_info=DestroyImageInfo(clone_info);\n         ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n     }\n     (void) sample_size;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if ((image != image2) && (image2 != (Image *) NULL))",
                "          image2=DestroyImage(image2);",
                "        if (clone_info)",
                "          clone_info=DestroyImageInfo(clone_info);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12566",
        "func_name": "ImageMagick/WriteMAPImage",
        "description": "In ImageMagick 7.0.6-2, a memory leak vulnerability was found in the function ReadMVGImage in coders/mvg.c, which allows attackers to cause a denial of service, related to the function ReadSVGImage in svg.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/27b3b9ca5cfb7b8935852cf315abc005ea7c1e16",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/603",
        "commit_text": "",
        "func_before": "static MagickBooleanType WriteMAPImage(const ImageInfo *image_info,Image *image)\n{\n  MagickBooleanType\n    status;\n\n  register const IndexPacket\n    *indexes;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    depth,\n    packet_size;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *colormap,\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  /*\n    Allocate colormap.\n  */\n  if (IsPaletteImage(image,&image->exception) == MagickFalse)\n    (void) SetImageType(image,PaletteType);\n  depth=GetImageQuantumDepth(image,MagickTrue);\n  packet_size=(size_t) (depth/8);\n  pixels=(unsigned char *) AcquireQuantumMemory(image->columns,packet_size*\n    sizeof(*pixels));\n  packet_size=(size_t) (image->colors > 256 ? 6UL : 3UL);\n  colormap=(unsigned char *) AcquireQuantumMemory(image->colors,packet_size*\n    sizeof(*colormap));\n  if ((pixels == (unsigned char *) NULL) ||\n      (colormap == (unsigned char *) NULL))\n    {\n      if (colormap != (unsigned char *) NULL)\n        colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n      if (pixels != (unsigned char *) NULL)\n        pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  /*\n    Write colormap to file.\n  */\n  q=colormap;\n  if (image->colors <= 256)\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      *q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].red);\n      *q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].green);\n      *q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].blue);\n    }\n  else\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].red) >> 8);\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].red) & 0xff);\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].green) >> 8);\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].green) &\n        0xff);\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].blue) >> 8);\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].blue) &\n        0xff);\n    }\n  (void) WriteBlob(image,packet_size*image->colors,colormap);\n  colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n  /*\n    Write image pixels to file.\n  */\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    indexes=GetVirtualIndexQueue(image);\n    q=pixels;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (image->colors > 256)\n        *q++=(unsigned char) ((size_t) GetPixelIndex(indexes+x) >> 8);\n      *q++=(unsigned char) GetPixelIndex(indexes+x);\n    }\n    (void) WriteBlob(image,(size_t) (q-pixels),pixels);\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  (void) CloseBlob(image);\n  return(status);\n}",
        "func": "static MagickBooleanType WriteMAPImage(const ImageInfo *image_info,Image *image)\n{\n  MagickBooleanType\n    status;\n\n  register const IndexPacket\n    *indexes;\n\n  register const PixelPacket\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    depth,\n    packet_size;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *colormap,\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  /*\n    Allocate colormap.\n  */\n  if (SetImageType(image,PaletteType) == MagickFalse)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  depth=GetImageQuantumDepth(image,MagickTrue);\n  packet_size=(size_t) (depth/8);\n  pixels=(unsigned char *) AcquireQuantumMemory(image->columns,packet_size*\n    sizeof(*pixels));\n  packet_size=(size_t) (image->colors > 256 ? 6UL : 3UL);\n  colormap=(unsigned char *) AcquireQuantumMemory(image->colors,packet_size*\n    sizeof(*colormap));\n  if ((pixels == (unsigned char *) NULL) ||\n      (colormap == (unsigned char *) NULL))\n    {\n      if (colormap != (unsigned char *) NULL)\n        colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n      if (pixels != (unsigned char *) NULL)\n        pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  /*\n    Write colormap to file.\n  */\n  q=colormap;\n  if (image->colors <= 256)\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      *q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].red);\n      *q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].green);\n      *q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].blue);\n    }\n  else\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].red) >> 8);\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].red) & 0xff);\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].green) >> 8);\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].green) &\n        0xff);\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].blue) >> 8);\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].blue) &\n        0xff);\n    }\n  (void) WriteBlob(image,packet_size*image->colors,colormap);\n  colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n  /*\n    Write image pixels to file.\n  */\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    indexes=GetVirtualIndexQueue(image);\n    q=pixels;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (image->colors > 256)\n        *q++=(unsigned char) ((size_t) GetPixelIndex(indexes+x) >> 8);\n      *q++=(unsigned char) GetPixelIndex(indexes+x);\n    }\n    (void) WriteBlob(image,(size_t) (q-pixels),pixels);\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  (void) CloseBlob(image);\n  return(status);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -43,8 +43,8 @@\n   /*\n     Allocate colormap.\n   */\n-  if (IsPaletteImage(image,&image->exception) == MagickFalse)\n-    (void) SetImageType(image,PaletteType);\n+  if (SetImageType(image,PaletteType) == MagickFalse)\n+    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n   depth=GetImageQuantumDepth(image,MagickTrue);\n   packet_size=(size_t) (depth/8);\n   pixels=(unsigned char *) AcquireQuantumMemory(image->columns,packet_size*",
        "diff_line_info": {
            "deleted_lines": [
                "  if (IsPaletteImage(image,&image->exception) == MagickFalse)",
                "    (void) SetImageType(image,PaletteType);"
            ],
            "added_lines": [
                "  if (SetImageType(image,PaletteType) == MagickFalse)",
                "    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12566",
        "func_name": "ImageMagick/ReadMVGImage",
        "description": "In ImageMagick 7.0.6-2, a memory leak vulnerability was found in the function ReadMVGImage in coders/mvg.c, which allows attackers to cause a denial of service, related to the function ReadSVGImage in svg.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/27b3b9ca5cfb7b8935852cf315abc005ea7c1e16",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/603",
        "commit_text": "",
        "func_before": "static Image *ReadMVGImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define BoundingBox  \"viewbox\"\n\n  DrawInfo\n    *draw_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  /*\n    Open image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if ((image->columns == 0) || (image->rows == 0))\n    {\n      char\n        primitive[MaxTextExtent];\n\n      register char\n        *p;\n\n      SegmentInfo\n        bounds;\n\n      /*\n        Determine size of image canvas.\n      */\n      while (ReadBlobString(image,primitive) != (char *) NULL)\n      {\n        for (p=primitive; (*p == ' ') || (*p == '\\t'); p++) ;\n        if (LocaleNCompare(BoundingBox,p,strlen(BoundingBox)) != 0)\n          continue;\n        (void) sscanf(p,\"viewbox %lf %lf %lf %lf\",&bounds.x1,&bounds.y1,\n          &bounds.x2,&bounds.y2);\n        image->columns=(size_t) floor((bounds.x2-bounds.x1)+0.5);\n        image->rows=(size_t) floor((bounds.y2-bounds.y1)+0.5);\n        break;\n      }\n    }\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(OptionError,\"MustSpecifyImageSize\");\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  draw_info->affine.sx=image->x_resolution == 0.0 ? 1.0 : image->x_resolution/\n    96.0;\n  draw_info->affine.sy=image->y_resolution == 0.0 ? 1.0 : image->y_resolution/\n    96.0;\n  image->columns=(size_t) (draw_info->affine.sx*image->columns);\n  image->rows=(size_t) (draw_info->affine.sy*image->rows);\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if (SetImageBackgroundColor(image) == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Render drawing.\n  */\n  if (GetBlobStreamData(image) == (unsigned char *) NULL)\n    draw_info->primitive=FileToString(image->filename,~0UL,exception);\n  else\n    {\n      draw_info->primitive=(char *) AcquireMagickMemory(GetBlobSize(image)+1);\n      if (draw_info->primitive != (char *) NULL)\n        {\n          CopyMagickMemory(draw_info->primitive,GetBlobStreamData(image),\n            GetBlobSize(image));\n          draw_info->primitive[GetBlobSize(image)]='\\0';\n        }\n     }\n  if (draw_info->primitive == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) DrawImage(image,draw_info);\n  (void) SetImageArtifact(image,\"MVG\",draw_info->primitive);\n  draw_info=DestroyDrawInfo(draw_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadMVGImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n#define BoundingBox  \"viewbox\"\n\n  DrawInfo\n    *draw_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  /*\n    Open image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if ((image->columns == 0) || (image->rows == 0))\n    {\n      char\n        primitive[MaxTextExtent];\n\n      register char\n        *p;\n\n      SegmentInfo\n        bounds;\n\n      /*\n        Determine size of image canvas.\n      */\n      while (ReadBlobString(image,primitive) != (char *) NULL)\n      {\n        for (p=primitive; (*p == ' ') || (*p == '\\t'); p++) ;\n        if (LocaleNCompare(BoundingBox,p,strlen(BoundingBox)) != 0)\n          continue;\n        (void) sscanf(p,\"viewbox %lf %lf %lf %lf\",&bounds.x1,&bounds.y1,\n          &bounds.x2,&bounds.y2);\n        image->columns=(size_t) floor((bounds.x2-bounds.x1)+0.5);\n        image->rows=(size_t) floor((bounds.y2-bounds.y1)+0.5);\n        break;\n      }\n    }\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(OptionError,\"MustSpecifyImageSize\");\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  draw_info->affine.sx=image->x_resolution == 0.0 ? 1.0 : image->x_resolution/\n    96.0;\n  draw_info->affine.sy=image->y_resolution == 0.0 ? 1.0 : image->y_resolution/\n    96.0;\n  image->columns=(size_t) (draw_info->affine.sx*image->columns);\n  image->rows=(size_t) (draw_info->affine.sy*image->rows);\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      draw_info=DestroyDrawInfo(draw_info);\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if (SetImageBackgroundColor(image) == MagickFalse)\n    {\n      draw_info=DestroyDrawInfo(draw_info);\n      InheritException(exception,&image->exception);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Render drawing.\n  */\n  if (GetBlobStreamData(image) == (unsigned char *) NULL)\n    draw_info->primitive=FileToString(image->filename,~0UL,exception);\n  else\n    {\n      draw_info->primitive=(char *) AcquireMagickMemory(GetBlobSize(image)+1);\n      if (draw_info->primitive != (char *) NULL)\n        {\n          CopyMagickMemory(draw_info->primitive,GetBlobStreamData(image),\n            GetBlobSize(image));\n          draw_info->primitive[GetBlobSize(image)]='\\0';\n        }\n     }\n  if (draw_info->primitive == (char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) DrawImage(image,draw_info);\n  (void) SetImageArtifact(image,\"MVG\",draw_info->primitive);\n  draw_info=DestroyDrawInfo(draw_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -66,11 +66,13 @@\n   status=SetImageExtent(image,image->columns,image->rows);\n   if (status == MagickFalse)\n     {\n+      draw_info=DestroyDrawInfo(draw_info);\n       InheritException(exception,&image->exception);\n       return(DestroyImageList(image));\n     }\n   if (SetImageBackgroundColor(image) == MagickFalse)\n     {\n+      draw_info=DestroyDrawInfo(draw_info);\n       InheritException(exception,&image->exception);\n       image=DestroyImageList(image);\n       return((Image *) NULL);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      draw_info=DestroyDrawInfo(draw_info);",
                "      draw_info=DestroyDrawInfo(draw_info);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12641",
        "func_name": "ImageMagick/ReadOneJNGImage",
        "description": "ImageMagick 7.0.6-1 has a memory leak vulnerability in ReadOneJNGImage in coders\\png.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/c9aa9f80828594eacbe3affe16c43d623562e5d8",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/550",
        "commit_text": "",
        "func_before": "static Image *ReadOneJNGImage(MngInfo *mng_info,\n    const ImageInfo *image_info, ExceptionInfo *exception)\n{\n  Image\n    *alpha_image,\n    *color_image,\n    *image,\n    *jng_image;\n\n  ImageInfo\n    *alpha_image_info,\n    *color_image_info;\n\n  MagickBooleanType\n    logging;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    status;\n\n  png_uint_32\n    jng_height,\n    jng_width;\n\n  png_byte\n    jng_color_type,\n    jng_image_sample_depth,\n    jng_image_compression_method,\n    jng_image_interlace_method,\n    jng_alpha_sample_depth,\n    jng_alpha_compression_method,\n    jng_alpha_filter_method,\n    jng_alpha_interlace_method;\n\n  register const Quantum\n    *s;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  unsigned int\n    read_JSEP,\n    reading_idat;\n\n  size_t\n    length;\n\n  jng_alpha_compression_method=0;\n  jng_alpha_sample_depth=8;\n  jng_color_type=0;\n  jng_height=0;\n  jng_width=0;\n  alpha_image=(Image *) NULL;\n  color_image=(Image *) NULL;\n  alpha_image_info=(ImageInfo *) NULL;\n  color_image_info=(ImageInfo *) NULL;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneJNGImage()\");\n\n  image=mng_info->image;\n\n  if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n    {\n      /*\n        Allocate next image structure.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  AcquireNextImage()\");\n\n      AcquireNextImage(image_info,image,exception);\n\n      if (GetNextImageInList(image) == (Image *) NULL)\n        return(DestroyImageList(image));\n\n      image=SyncNextImageInList(image);\n    }\n  mng_info->image=image;\n\n  /*\n    Signature bytes have already been read.\n  */\n\n  read_JSEP=MagickFalse;\n  reading_idat=MagickFalse;\n  for (;;)\n  {\n    char\n      type[MagickPathExtent];\n\n    unsigned char\n      *chunk;\n\n    unsigned int\n      count;\n\n    /*\n      Read a new JNG chunk.\n    */\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      2*GetBlobSize(image));\n\n    if (status == MagickFalse)\n      break;\n\n    type[0]='\\0';\n    (void) ConcatenateMagickString(type,\"errr\",MagickPathExtent);\n    length=ReadBlobMSBLong(image);\n    count=(unsigned int) ReadBlob(image,4,(unsigned char *) type);\n\n    if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Reading JNG chunk type %c%c%c%c, length: %.20g\",\n        type[0],type[1],type[2],type[3],(double) length);\n\n    if (length > PNG_UINT_31_MAX || count == 0)\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n\n    p=NULL;\n    chunk=(unsigned char *) NULL;\n\n    if (length != 0)\n      {\n        if (length > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        chunk=(unsigned char *) AcquireQuantumMemory(length+MagickPathExtent,\n          sizeof(*chunk));\n\n        if (chunk == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        for (i=0; i < (ssize_t) length; i++)\n        {\n          int\n            c;\n\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            break;\n          chunk[i]=(unsigned char) c;\n        }\n\n        p=chunk;\n      }\n\n    (void) ReadBlobMSBLong(image);  /* read crc word */\n\n    if (memcmp(type,mng_JHDR,4) == 0)\n      {\n        if (length == 16)\n          {\n            jng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n              (p[2] << 8) | p[3]);\n            jng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n              (p[6] << 8) | p[7]);\n            if ((jng_width == 0) || (jng_height == 0))\n              ThrowReaderException(CorruptImageError,\n                \"NegativeOrZeroImageSize\");\n            jng_color_type=p[8];\n            jng_image_sample_depth=p[9];\n            jng_image_compression_method=p[10];\n            jng_image_interlace_method=p[11];\n\n            image->interlace=jng_image_interlace_method != 0 ? PNGInterlace :\n              NoInterlace;\n\n            jng_alpha_sample_depth=p[12];\n            jng_alpha_compression_method=p[13];\n            jng_alpha_filter_method=p[14];\n            jng_alpha_interlace_method=p[15];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_width:      %16lu,    jng_height:     %16lu\\n\"\n                  \"    jng_color_type: %16d,     jng_image_sample_depth: %3d\\n\"\n                  \"    jng_image_compression_method:%3d\",\n                  (unsigned long) jng_width, (unsigned long) jng_height,\n                  jng_color_type, jng_image_sample_depth,\n                  jng_image_compression_method);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_image_interlace_method:  %3d\"\n                  \"    jng_alpha_sample_depth:      %3d\",\n                  jng_image_interlace_method,\n                  jng_alpha_sample_depth);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_alpha_compression_method:%3d\\n\"\n                  \"    jng_alpha_filter_method:     %3d\\n\"\n                  \"    jng_alpha_interlace_method:  %3d\",\n                  jng_alpha_compression_method,\n                  jng_alpha_filter_method,\n                  jng_alpha_interlace_method);\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n\n    if ((reading_idat == MagickFalse) && (read_JSEP == MagickFalse) &&\n        ((memcmp(type,mng_JDAT,4) == 0) || (memcmp(type,mng_JdAA,4) == 0) ||\n         (memcmp(type,mng_IDAT,4) == 0) || (memcmp(type,mng_JDAA,4) == 0)))\n      {\n        /*\n           o create color_image\n           o open color_blob, attached to color_image\n           o if (color type has alpha)\n               open alpha_blob, attached to alpha_image\n        */\n\n        color_image_info=(ImageInfo *)AcquireMagickMemory(sizeof(ImageInfo));\n\n        if (color_image_info == (ImageInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        GetImageInfo(color_image_info);\n        color_image=AcquireImage(color_image_info,exception);\n\n        if (color_image == (Image *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Creating color_blob.\");\n\n        (void) AcquireUniqueFilename(color_image->filename);\n        status=OpenBlob(color_image_info,color_image,WriteBinaryBlobMode,\n          exception);\n\n        if (status == MagickFalse)\n          {\n            color_image=DestroyImage(color_image);\n            return(DestroyImageList(image));\n          }\n\n        if ((image_info->ping == MagickFalse) && (jng_color_type >= 12))\n          {\n            alpha_image_info=(ImageInfo *)\n              AcquireMagickMemory(sizeof(ImageInfo));\n\n            if (alpha_image_info == (ImageInfo *) NULL)\n              {\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            GetImageInfo(alpha_image_info);\n            alpha_image=AcquireImage(alpha_image_info,exception);\n\n            if (alpha_image == (Image *) NULL)\n              {\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Creating alpha_blob.\");\n\n            (void) AcquireUniqueFilename(alpha_image->filename);\n            status=OpenBlob(alpha_image_info,alpha_image,WriteBinaryBlobMode,\n              exception);\n\n            if (status == MagickFalse)\n              {\n                alpha_image=DestroyImage(alpha_image);\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                return(DestroyImageList(image));\n              }\n\n            if (jng_alpha_compression_method == 0)\n              {\n                unsigned char\n                  data[18];\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Writing IHDR chunk to alpha_blob.\");\n\n                (void) WriteBlob(alpha_image,8,(const unsigned char *)\n                  \"\\211PNG\\r\\n\\032\\n\");\n\n                (void) WriteBlobMSBULong(alpha_image,13L);\n                PNGType(data,mng_IHDR);\n                LogPNGChunk(logging,mng_IHDR,13L);\n                PNGLong(data+4,jng_width);\n                PNGLong(data+8,jng_height);\n                data[12]=jng_alpha_sample_depth;\n                data[13]=0; /* color_type gray */\n                data[14]=0; /* compression method 0 */\n                data[15]=0; /* filter_method 0 */\n                data[16]=0; /* interlace_method 0 */\n                (void) WriteBlob(alpha_image,17,data);\n                (void) WriteBlobMSBULong(alpha_image,crc32(0,data,17));\n              }\n          }\n        reading_idat=MagickTrue;\n      }\n\n    if (memcmp(type,mng_JDAT,4) == 0)\n      {\n        /* Copy chunk to color_image->blob */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Copying JDAT chunk data to color_blob.\");\n\n        if (length != 0)\n          {\n            (void) WriteBlob(color_image,length,chunk);\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n          }\n\n        continue;\n      }\n\n    if (memcmp(type,mng_IDAT,4) == 0)\n      {\n        png_byte\n           data[5];\n\n        /* Copy IDAT header and chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying IDAT chunk data to alpha_blob.\");\n\n            (void) WriteBlobMSBULong(alpha_image,(size_t) length);\n            PNGType(data,mng_IDAT);\n            LogPNGChunk(logging,mng_IDAT,length);\n            (void) WriteBlob(alpha_image,4,data);\n            (void) WriteBlob(alpha_image,length,chunk);\n            (void) WriteBlobMSBULong(alpha_image,\n              crc32(crc32(0,data,4),chunk,(uInt) length));\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if ((memcmp(type,mng_JDAA,4) == 0) || (memcmp(type,mng_JdAA,4) == 0))\n      {\n        /* Copy chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying JDAA chunk data to alpha_blob.\");\n\n            (void) WriteBlob(alpha_image,length,chunk);\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_JSEP,4) == 0)\n      {\n        read_JSEP=MagickTrue;\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_bKGD,4) == 0)\n      {\n        if (length == 2)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=image->background_color.red;\n            image->background_color.blue=image->background_color.red;\n          }\n\n        if (length == 6)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=ScaleCharToQuantum(p[3]);\n            image->background_color.blue=ScaleCharToQuantum(p[5]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_gAMA,4) == 0)\n      {\n        if (length == 4)\n          image->gamma=((float) mng_get_long(p))*0.00001;\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_cHRM,4) == 0)\n      {\n        if (length == 32)\n          {\n            image->chromaticity.white_point.x=0.00001*mng_get_long(p);\n            image->chromaticity.white_point.y=0.00001*mng_get_long(&p[4]);\n            image->chromaticity.red_primary.x=0.00001*mng_get_long(&p[8]);\n            image->chromaticity.red_primary.y=0.00001*mng_get_long(&p[12]);\n            image->chromaticity.green_primary.x=0.00001*mng_get_long(&p[16]);\n            image->chromaticity.green_primary.y=0.00001*mng_get_long(&p[20]);\n            image->chromaticity.blue_primary.x=0.00001*mng_get_long(&p[24]);\n            image->chromaticity.blue_primary.y=0.00001*mng_get_long(&p[28]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_sRGB,4) == 0)\n      {\n        if (length == 1)\n          {\n            image->rendering_intent=\n              Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n            image->gamma=1.000f/2.200f;\n            image->chromaticity.red_primary.x=0.6400f;\n            image->chromaticity.red_primary.y=0.3300f;\n            image->chromaticity.green_primary.x=0.3000f;\n            image->chromaticity.green_primary.y=0.6000f;\n            image->chromaticity.blue_primary.x=0.1500f;\n            image->chromaticity.blue_primary.y=0.0600f;\n            image->chromaticity.white_point.x=0.3127f;\n            image->chromaticity.white_point.y=0.3290f;\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_oFFs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->page.x=(ssize_t) mng_get_long(p);\n            image->page.y=(ssize_t) mng_get_long(&p[4]);\n\n            if ((int) p[8] != 0)\n              {\n                image->page.x/=10000;\n                image->page.y/=10000;\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_pHYs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->resolution.x=(double) mng_get_long(p);\n            image->resolution.y=(double) mng_get_long(&p[4]);\n            if ((int) p[8] == PNG_RESOLUTION_METER)\n              {\n                image->units=PixelsPerCentimeterResolution;\n                image->resolution.x=image->resolution.x/100.0f;\n                image->resolution.y=image->resolution.y/100.0f;\n              }\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n#if 0\n    if (memcmp(type,mng_iCCP,4) == 0)\n      {\n        /* To do: */\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n#endif\n\n    if (length != 0)\n      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n    if (memcmp(type,mng_IEND,4))\n      continue;\n\n    break;\n  }\n\n\n  /* IEND found */\n\n  /*\n    Finish up reading image data:\n\n       o read main image from color_blob.\n\n       o close color_blob.\n\n       o if (color_type has alpha)\n            if alpha_encoding is PNG\n               read secondary image from alpha_blob via ReadPNG\n            if alpha_encoding is JPEG\n               read secondary image from alpha_blob via ReadJPEG\n\n       o close alpha_blob.\n\n       o copy intensity of secondary image into\n         alpha samples of main image.\n\n       o destroy the secondary image.\n  */\n\n  if (color_image_info == (ImageInfo *) NULL)\n    {\n      assert(color_image == (Image *) NULL);\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  if (color_image == (Image *) NULL)\n    {\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  (void) SeekBlob(color_image,0,SEEK_SET);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Reading jng_image from color_blob.\");\n\n  assert(color_image_info != (ImageInfo *) NULL);\n  (void) FormatLocaleString(color_image_info->filename,MagickPathExtent,\"%s\",\n    color_image->filename);\n\n  color_image_info->ping=MagickFalse;   /* To do: avoid this */\n  jng_image=ReadImage(color_image_info,exception);\n\n  (void) RelinquishUniqueFileResource(color_image->filename);\n  color_image=DestroyImage(color_image);\n  color_image_info=DestroyImageInfo(color_image_info);\n\n  if (jng_image == (Image *) NULL)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Copying jng_image pixels to main image.\");\n\n  image->rows=jng_height;\n  image->columns=jng_width;\n\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    s=GetVirtualPixels(jng_image,0,y,image->columns,1,exception);\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    for (x=(ssize_t) image->columns; x != 0; x--)\n    {\n      SetPixelRed(image,GetPixelRed(jng_image,s),q);\n      SetPixelGreen(image,GetPixelGreen(jng_image,s),q);\n      SetPixelBlue(image,GetPixelBlue(jng_image,s),q);\n      q+=GetPixelChannels(image);\n      s+=GetPixelChannels(jng_image);\n    }\n\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n\n  jng_image=DestroyImage(jng_image);\n\n  if (image_info->ping == MagickFalse)\n    {\n     if (jng_color_type >= 12)\n       {\n         if (jng_alpha_compression_method == 0)\n           {\n             png_byte\n               data[5];\n             (void) WriteBlobMSBULong(alpha_image,0x00000000L);\n             PNGType(data,mng_IEND);\n             LogPNGChunk(logging,mng_IEND,0L);\n             (void) WriteBlob(alpha_image,4,data);\n             (void) WriteBlobMSBULong(alpha_image,crc32(0,data,4));\n           }\n\n         (void) CloseBlob(alpha_image);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"    Reading alpha from alpha_blob.\");\n\n         (void) FormatLocaleString(alpha_image_info->filename,MagickPathExtent,\n           \"%s\",alpha_image->filename);\n\n         jng_image=ReadImage(alpha_image_info,exception);\n\n         if (jng_image != (Image *) NULL)\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             s=GetVirtualPixels(jng_image,0,y,image->columns,1,\n               exception);\n             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (image->alpha_trait != UndefinedPixelTrait)\n               for (x=(ssize_t) image->columns; x != 0; x--)\n               {\n                  SetPixelAlpha(image,GetPixelRed(jng_image,s),q);\n                  q+=GetPixelChannels(image);\n                  s+=GetPixelChannels(jng_image);\n               }\n\n             else\n               for (x=(ssize_t) image->columns; x != 0; x--)\n               {\n                  SetPixelAlpha(image,GetPixelRed(jng_image,s),q);\n                  if (GetPixelAlpha(image,q) != OpaqueAlpha)\n                    image->alpha_trait=BlendPixelTrait;\n                  q+=GetPixelChannels(image);\n                  s+=GetPixelChannels(jng_image);\n               }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n           }\n         (void) RelinquishUniqueFileResource(alpha_image->filename);\n         alpha_image=DestroyImage(alpha_image);\n         alpha_image_info=DestroyImageInfo(alpha_image_info);\n         if (jng_image != (Image *) NULL)\n           jng_image=DestroyImage(jng_image);\n       }\n    }\n\n  /* Read the JNG image.  */\n\n  if (mng_info->mng_type == 0)\n    {\n      mng_info->mng_width=jng_width;\n      mng_info->mng_height=jng_height;\n    }\n\n  if (image->page.width == 0 && image->page.height == 0)\n    {\n      image->page.width=jng_width;\n      image->page.height=jng_height;\n    }\n\n  if (image->page.x == 0 && image->page.y == 0)\n    {\n      image->page.x=mng_info->x_off[mng_info->object_id];\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  else\n    {\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  mng_info->image_found++;\n  status=SetImageProgress(image,LoadImagesTag,2*TellBlob(image),\n    2*GetBlobSize(image));\n\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneJNGImage()\");\n\n  return(image);\n}",
        "func": "static Image *ReadOneJNGImage(MngInfo *mng_info,\n    const ImageInfo *image_info, ExceptionInfo *exception)\n{\n  Image\n    *alpha_image,\n    *color_image,\n    *image,\n    *jng_image;\n\n  ImageInfo\n    *alpha_image_info,\n    *color_image_info;\n\n  MagickBooleanType\n    logging;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    status;\n\n  png_uint_32\n    jng_height,\n    jng_width;\n\n  png_byte\n    jng_color_type,\n    jng_image_sample_depth,\n    jng_image_compression_method,\n    jng_image_interlace_method,\n    jng_alpha_sample_depth,\n    jng_alpha_compression_method,\n    jng_alpha_filter_method,\n    jng_alpha_interlace_method;\n\n  register const Quantum\n    *s;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *p;\n\n  unsigned int\n    read_JSEP,\n    reading_idat;\n\n  size_t\n    length;\n\n  jng_alpha_compression_method=0;\n  jng_alpha_sample_depth=8;\n  jng_color_type=0;\n  jng_height=0;\n  jng_width=0;\n  alpha_image=(Image *) NULL;\n  color_image=(Image *) NULL;\n  alpha_image_info=(ImageInfo *) NULL;\n  color_image_info=(ImageInfo *) NULL;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneJNGImage()\");\n\n  image=mng_info->image;\n\n  if (GetAuthenticPixelQueue(image) != (Quantum *) NULL)\n    {\n      /*\n        Allocate next image structure.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  AcquireNextImage()\");\n\n      AcquireNextImage(image_info,image,exception);\n\n      if (GetNextImageInList(image) == (Image *) NULL)\n        return(DestroyImageList(image));\n\n      image=SyncNextImageInList(image);\n    }\n  mng_info->image=image;\n\n  /*\n    Signature bytes have already been read.\n  */\n\n  read_JSEP=MagickFalse;\n  reading_idat=MagickFalse;\n  for (;;)\n  {\n    char\n      type[MagickPathExtent];\n\n    unsigned char\n      *chunk;\n\n    unsigned int\n      count;\n\n    /*\n      Read a new JNG chunk.\n    */\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      2*GetBlobSize(image));\n\n    if (status == MagickFalse)\n      break;\n\n    type[0]='\\0';\n    (void) ConcatenateMagickString(type,\"errr\",MagickPathExtent);\n    length=ReadBlobMSBLong(image);\n    count=(unsigned int) ReadBlob(image,4,(unsigned char *) type);\n\n    if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Reading JNG chunk type %c%c%c%c, length: %.20g\",\n        type[0],type[1],type[2],type[3],(double) length);\n\n    if (length > PNG_UINT_31_MAX || count == 0)\n      {\n        if (color_image != (Image *) NULL)\n          color_image=DestroyImage(color_image);\n        if (color_image_info != (Image *) NULL)\n          color_image_info=DestroyImageInfo(color_image_info);\n        ThrowReaderException(CorruptImageError,\"CorruptImage\");\n      }\n\n    p=NULL;\n    chunk=(unsigned char *) NULL;\n\n    if (length != 0)\n      {\n        if (length > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        chunk=(unsigned char *) AcquireQuantumMemory(length+MagickPathExtent,\n          sizeof(*chunk));\n\n        if (chunk == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        for (i=0; i < (ssize_t) length; i++)\n        {\n          int\n            c;\n\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            break;\n          chunk[i]=(unsigned char) c;\n        }\n\n        p=chunk;\n      }\n\n    (void) ReadBlobMSBLong(image);  /* read crc word */\n\n    if (memcmp(type,mng_JHDR,4) == 0)\n      {\n        if (length == 16)\n          {\n            jng_width=(size_t) ((p[0] << 24) | (p[1] << 16) |\n              (p[2] << 8) | p[3]);\n            jng_height=(size_t) ((p[4] << 24) | (p[5] << 16) |\n              (p[6] << 8) | p[7]);\n            if ((jng_width == 0) || (jng_height == 0))\n              ThrowReaderException(CorruptImageError,\n                \"NegativeOrZeroImageSize\");\n            jng_color_type=p[8];\n            jng_image_sample_depth=p[9];\n            jng_image_compression_method=p[10];\n            jng_image_interlace_method=p[11];\n\n            image->interlace=jng_image_interlace_method != 0 ? PNGInterlace :\n              NoInterlace;\n\n            jng_alpha_sample_depth=p[12];\n            jng_alpha_compression_method=p[13];\n            jng_alpha_filter_method=p[14];\n            jng_alpha_interlace_method=p[15];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_width:      %16lu,    jng_height:     %16lu\\n\"\n                  \"    jng_color_type: %16d,     jng_image_sample_depth: %3d\\n\"\n                  \"    jng_image_compression_method:%3d\",\n                  (unsigned long) jng_width, (unsigned long) jng_height,\n                  jng_color_type, jng_image_sample_depth,\n                  jng_image_compression_method);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_image_interlace_method:  %3d\"\n                  \"    jng_alpha_sample_depth:      %3d\",\n                  jng_image_interlace_method,\n                  jng_alpha_sample_depth);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_alpha_compression_method:%3d\\n\"\n                  \"    jng_alpha_filter_method:     %3d\\n\"\n                  \"    jng_alpha_interlace_method:  %3d\",\n                  jng_alpha_compression_method,\n                  jng_alpha_filter_method,\n                  jng_alpha_interlace_method);\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n\n    if ((reading_idat == MagickFalse) && (read_JSEP == MagickFalse) &&\n        ((memcmp(type,mng_JDAT,4) == 0) || (memcmp(type,mng_JdAA,4) == 0) ||\n         (memcmp(type,mng_IDAT,4) == 0) || (memcmp(type,mng_JDAA,4) == 0)))\n      {\n        /*\n           o create color_image\n           o open color_blob, attached to color_image\n           o if (color type has alpha)\n               open alpha_blob, attached to alpha_image\n        */\n\n        color_image_info=(ImageInfo *)AcquireMagickMemory(sizeof(ImageInfo));\n\n        if (color_image_info == (ImageInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        GetImageInfo(color_image_info);\n        color_image=AcquireImage(color_image_info,exception);\n\n        if (color_image == (Image *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Creating color_blob.\");\n\n        (void) AcquireUniqueFilename(color_image->filename);\n        status=OpenBlob(color_image_info,color_image,WriteBinaryBlobMode,\n          exception);\n\n        if (status == MagickFalse)\n          {\n            color_image=DestroyImage(color_image);\n            return(DestroyImageList(image));\n          }\n\n        if ((image_info->ping == MagickFalse) && (jng_color_type >= 12))\n          {\n            alpha_image_info=(ImageInfo *)\n              AcquireMagickMemory(sizeof(ImageInfo));\n\n            if (alpha_image_info == (ImageInfo *) NULL)\n              {\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            GetImageInfo(alpha_image_info);\n            alpha_image=AcquireImage(alpha_image_info,exception);\n\n            if (alpha_image == (Image *) NULL)\n              {\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Creating alpha_blob.\");\n\n            (void) AcquireUniqueFilename(alpha_image->filename);\n            status=OpenBlob(alpha_image_info,alpha_image,WriteBinaryBlobMode,\n              exception);\n\n            if (status == MagickFalse)\n              {\n                alpha_image=DestroyImage(alpha_image);\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                return(DestroyImageList(image));\n              }\n\n            if (jng_alpha_compression_method == 0)\n              {\n                unsigned char\n                  data[18];\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Writing IHDR chunk to alpha_blob.\");\n\n                (void) WriteBlob(alpha_image,8,(const unsigned char *)\n                  \"\\211PNG\\r\\n\\032\\n\");\n\n                (void) WriteBlobMSBULong(alpha_image,13L);\n                PNGType(data,mng_IHDR);\n                LogPNGChunk(logging,mng_IHDR,13L);\n                PNGLong(data+4,jng_width);\n                PNGLong(data+8,jng_height);\n                data[12]=jng_alpha_sample_depth;\n                data[13]=0; /* color_type gray */\n                data[14]=0; /* compression method 0 */\n                data[15]=0; /* filter_method 0 */\n                data[16]=0; /* interlace_method 0 */\n                (void) WriteBlob(alpha_image,17,data);\n                (void) WriteBlobMSBULong(alpha_image,crc32(0,data,17));\n              }\n          }\n        reading_idat=MagickTrue;\n      }\n\n    if (memcmp(type,mng_JDAT,4) == 0)\n      {\n        /* Copy chunk to color_image->blob */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Copying JDAT chunk data to color_blob.\");\n\n        if (length != 0)\n          {\n            (void) WriteBlob(color_image,length,chunk);\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n          }\n\n        continue;\n      }\n\n    if (memcmp(type,mng_IDAT,4) == 0)\n      {\n        png_byte\n           data[5];\n\n        /* Copy IDAT header and chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying IDAT chunk data to alpha_blob.\");\n\n            (void) WriteBlobMSBULong(alpha_image,(size_t) length);\n            PNGType(data,mng_IDAT);\n            LogPNGChunk(logging,mng_IDAT,length);\n            (void) WriteBlob(alpha_image,4,data);\n            (void) WriteBlob(alpha_image,length,chunk);\n            (void) WriteBlobMSBULong(alpha_image,\n              crc32(crc32(0,data,4),chunk,(uInt) length));\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if ((memcmp(type,mng_JDAA,4) == 0) || (memcmp(type,mng_JdAA,4) == 0))\n      {\n        /* Copy chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying JDAA chunk data to alpha_blob.\");\n\n            (void) WriteBlob(alpha_image,length,chunk);\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_JSEP,4) == 0)\n      {\n        read_JSEP=MagickTrue;\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_bKGD,4) == 0)\n      {\n        if (length == 2)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=image->background_color.red;\n            image->background_color.blue=image->background_color.red;\n          }\n\n        if (length == 6)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=ScaleCharToQuantum(p[3]);\n            image->background_color.blue=ScaleCharToQuantum(p[5]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_gAMA,4) == 0)\n      {\n        if (length == 4)\n          image->gamma=((float) mng_get_long(p))*0.00001;\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_cHRM,4) == 0)\n      {\n        if (length == 32)\n          {\n            image->chromaticity.white_point.x=0.00001*mng_get_long(p);\n            image->chromaticity.white_point.y=0.00001*mng_get_long(&p[4]);\n            image->chromaticity.red_primary.x=0.00001*mng_get_long(&p[8]);\n            image->chromaticity.red_primary.y=0.00001*mng_get_long(&p[12]);\n            image->chromaticity.green_primary.x=0.00001*mng_get_long(&p[16]);\n            image->chromaticity.green_primary.y=0.00001*mng_get_long(&p[20]);\n            image->chromaticity.blue_primary.x=0.00001*mng_get_long(&p[24]);\n            image->chromaticity.blue_primary.y=0.00001*mng_get_long(&p[28]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_sRGB,4) == 0)\n      {\n        if (length == 1)\n          {\n            image->rendering_intent=\n              Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n            image->gamma=1.000f/2.200f;\n            image->chromaticity.red_primary.x=0.6400f;\n            image->chromaticity.red_primary.y=0.3300f;\n            image->chromaticity.green_primary.x=0.3000f;\n            image->chromaticity.green_primary.y=0.6000f;\n            image->chromaticity.blue_primary.x=0.1500f;\n            image->chromaticity.blue_primary.y=0.0600f;\n            image->chromaticity.white_point.x=0.3127f;\n            image->chromaticity.white_point.y=0.3290f;\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_oFFs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->page.x=(ssize_t) mng_get_long(p);\n            image->page.y=(ssize_t) mng_get_long(&p[4]);\n\n            if ((int) p[8] != 0)\n              {\n                image->page.x/=10000;\n                image->page.y/=10000;\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_pHYs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->resolution.x=(double) mng_get_long(p);\n            image->resolution.y=(double) mng_get_long(&p[4]);\n            if ((int) p[8] == PNG_RESOLUTION_METER)\n              {\n                image->units=PixelsPerCentimeterResolution;\n                image->resolution.x=image->resolution.x/100.0f;\n                image->resolution.y=image->resolution.y/100.0f;\n              }\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n#if 0\n    if (memcmp(type,mng_iCCP,4) == 0)\n      {\n        /* To do: */\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n#endif\n\n    if (length != 0)\n      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n    if (memcmp(type,mng_IEND,4))\n      continue;\n\n    break;\n  }\n\n\n  /* IEND found */\n\n  /*\n    Finish up reading image data:\n\n       o read main image from color_blob.\n\n       o close color_blob.\n\n       o if (color_type has alpha)\n            if alpha_encoding is PNG\n               read secondary image from alpha_blob via ReadPNG\n            if alpha_encoding is JPEG\n               read secondary image from alpha_blob via ReadJPEG\n\n       o close alpha_blob.\n\n       o copy intensity of secondary image into\n         alpha samples of main image.\n\n       o destroy the secondary image.\n  */\n\n  if (color_image_info == (ImageInfo *) NULL)\n    {\n      assert(color_image == (Image *) NULL);\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  if (color_image == (Image *) NULL)\n    {\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  (void) SeekBlob(color_image,0,SEEK_SET);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Reading jng_image from color_blob.\");\n\n  assert(color_image_info != (ImageInfo *) NULL);\n  (void) FormatLocaleString(color_image_info->filename,MagickPathExtent,\"%s\",\n    color_image->filename);\n\n  color_image_info->ping=MagickFalse;   /* To do: avoid this */\n  jng_image=ReadImage(color_image_info,exception);\n\n  (void) RelinquishUniqueFileResource(color_image->filename);\n  color_image=DestroyImage(color_image);\n  color_image_info=DestroyImageInfo(color_image_info);\n\n  if (jng_image == (Image *) NULL)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Copying jng_image pixels to main image.\");\n\n  image->rows=jng_height;\n  image->columns=jng_width;\n\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    s=GetVirtualPixels(jng_image,0,y,image->columns,1,exception);\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    for (x=(ssize_t) image->columns; x != 0; x--)\n    {\n      SetPixelRed(image,GetPixelRed(jng_image,s),q);\n      SetPixelGreen(image,GetPixelGreen(jng_image,s),q);\n      SetPixelBlue(image,GetPixelBlue(jng_image,s),q);\n      q+=GetPixelChannels(image);\n      s+=GetPixelChannels(jng_image);\n    }\n\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n\n  jng_image=DestroyImage(jng_image);\n\n  if (image_info->ping == MagickFalse)\n    {\n     if (jng_color_type >= 12)\n       {\n         if (jng_alpha_compression_method == 0)\n           {\n             png_byte\n               data[5];\n             (void) WriteBlobMSBULong(alpha_image,0x00000000L);\n             PNGType(data,mng_IEND);\n             LogPNGChunk(logging,mng_IEND,0L);\n             (void) WriteBlob(alpha_image,4,data);\n             (void) WriteBlobMSBULong(alpha_image,crc32(0,data,4));\n           }\n\n         (void) CloseBlob(alpha_image);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"    Reading alpha from alpha_blob.\");\n\n         (void) FormatLocaleString(alpha_image_info->filename,MagickPathExtent,\n           \"%s\",alpha_image->filename);\n\n         jng_image=ReadImage(alpha_image_info,exception);\n\n         if (jng_image != (Image *) NULL)\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             s=GetVirtualPixels(jng_image,0,y,image->columns,1,\n               exception);\n             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (image->alpha_trait != UndefinedPixelTrait)\n               for (x=(ssize_t) image->columns; x != 0; x--)\n               {\n                  SetPixelAlpha(image,GetPixelRed(jng_image,s),q);\n                  q+=GetPixelChannels(image);\n                  s+=GetPixelChannels(jng_image);\n               }\n\n             else\n               for (x=(ssize_t) image->columns; x != 0; x--)\n               {\n                  SetPixelAlpha(image,GetPixelRed(jng_image,s),q);\n                  if (GetPixelAlpha(image,q) != OpaqueAlpha)\n                    image->alpha_trait=BlendPixelTrait;\n                  q+=GetPixelChannels(image);\n                  s+=GetPixelChannels(jng_image);\n               }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n           }\n         (void) RelinquishUniqueFileResource(alpha_image->filename);\n         alpha_image=DestroyImage(alpha_image);\n         alpha_image_info=DestroyImageInfo(alpha_image_info);\n         if (jng_image != (Image *) NULL)\n           jng_image=DestroyImage(jng_image);\n       }\n    }\n\n  /* Read the JNG image.  */\n\n  if (mng_info->mng_type == 0)\n    {\n      mng_info->mng_width=jng_width;\n      mng_info->mng_height=jng_height;\n    }\n\n  if (image->page.width == 0 && image->page.height == 0)\n    {\n      image->page.width=jng_width;\n      image->page.height=jng_height;\n    }\n\n  if (image->page.x == 0 && image->page.y == 0)\n    {\n      image->page.x=mng_info->x_off[mng_info->object_id];\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  else\n    {\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  mng_info->image_found++;\n  status=SetImageProgress(image,LoadImagesTag,2*TellBlob(image),\n    2*GetBlobSize(image));\n\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneJNGImage()\");\n\n  return(image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -124,7 +124,13 @@\n         type[0],type[1],type[2],type[3],(double) length);\n \n     if (length > PNG_UINT_31_MAX || count == 0)\n-      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n+      {\n+        if (color_image != (Image *) NULL)\n+          color_image=DestroyImage(color_image);\n+        if (color_image_info != (Image *) NULL)\n+          color_image_info=DestroyImageInfo(color_image_info);\n+        ThrowReaderException(CorruptImageError,\"CorruptImage\");\n+      }\n \n     p=NULL;\n     chunk=(unsigned char *) NULL;",
        "diff_line_info": {
            "deleted_lines": [
                "      ThrowReaderException(CorruptImageError,\"CorruptImage\");"
            ],
            "added_lines": [
                "      {",
                "        if (color_image != (Image *) NULL)",
                "          color_image=DestroyImage(color_image);",
                "        if (color_image_info != (Image *) NULL)",
                "          color_image_info=DestroyImageInfo(color_image_info);",
                "        ThrowReaderException(CorruptImageError,\"CorruptImage\");",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12654",
        "func_name": "ImageMagick/ReadPICTImage",
        "description": "The ReadPICTImage function in coders/pict.c in ImageMagick 7.0.6-3 allows attackers to cause a denial of service (memory leak) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/ffcb8f8e2248fde38a2cb30aeb48403d2b3471cc",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/620",
        "commit_text": "",
        "func_before": "static Image *ReadPICTImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    geometry[MagickPathExtent],\n    header_ole[4];\n\n  Image\n    *image;\n\n  int\n    c,\n    code;\n\n  MagickBooleanType\n    jpeg,\n    status;\n\n  PICTRectangle\n    frame;\n\n  PICTPixmap\n    pixmap;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    extent,\n    length;\n\n  ssize_t\n    count,\n    flags,\n    j,\n    version,\n    y;\n\n  StringInfo\n    *profile;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read PICT header.\n  */\n  pixmap.bits_per_pixel=0;\n  pixmap.component_count=0;\n  /*\n    Skip header : 512 for standard PICT and 4, ie \"PICT\" for OLE2.\n  */\n  header_ole[0]=ReadBlobByte(image);\n  header_ole[1]=ReadBlobByte(image);\n  header_ole[2]=ReadBlobByte(image);\n  header_ole[3]=ReadBlobByte(image);\n  if (!((header_ole[0] == 0x50) && (header_ole[1] == 0x49) &&\n      (header_ole[2] == 0x43) && (header_ole[3] == 0x54 )))\n    for (i=0; i < 508; i++)\n      if (ReadBlobByte(image) == EOF)\n        break;\n  (void) ReadBlobMSBShort(image);  /* skip picture size */\n  if (ReadRectangle(image,&frame) == MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  while ((c=ReadBlobByte(image)) == 0) ;\n  if (c != 0x11)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  version=ReadBlobByte(image);\n  if (version == 2)\n    {\n      c=ReadBlobByte(image);\n      if (c != 0xff)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  else\n    if (version != 1)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((frame.left < 0) || (frame.right < 0) || (frame.top < 0) ||\n      (frame.bottom < 0) || (frame.left >= frame.right) ||\n      (frame.top >= frame.bottom))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Create black canvas.\n  */\n  flags=0;\n  image->depth=8;\n  image->columns=1UL*(frame.right-frame.left);\n  image->rows=1UL*(frame.bottom-frame.top);\n  image->resolution.x=DefaultResolution;\n  image->resolution.y=DefaultResolution;\n  image->units=UndefinedResolution;\n  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n    if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Interpret PICT opcodes.\n  */\n  jpeg=MagickFalse;\n  for (code=0; EOFBlob(image) == MagickFalse; )\n  {\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if ((version == 1) || ((TellBlob(image) % 2) != 0))\n      code=ReadBlobByte(image);\n    if (version == 2)\n      code=ReadBlobMSBSignedShort(image);\n    if (code < 0)\n      break;\n    if (code > 0xa1)\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"%04X:\",code);\n      }\n    else\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  %04X %s: %s\",code,codes[code].name,codes[code].description);\n        switch (code)\n        {\n          case 0x01:\n          {\n            /*\n              Clipping rectangle.\n            */\n            length=ReadBlobMSBShort(image);\n            if (length != 0x000a)\n              {\n                for (i=0; i < (ssize_t) (length-2); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n                break;\n              }\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            if (((frame.left & 0x8000) != 0) || ((frame.top & 0x8000) != 0))\n              break;\n            image->columns=1UL*(frame.right-frame.left);\n            image->rows=1UL*(frame.bottom-frame.top);\n            status=SetImageExtent(image,image->columns,image->rows,exception);\n            if (status == MagickFalse)\n              return(DestroyImageList(image));\n            (void) SetImageBackgroundColor(image,exception);\n            break;\n          }\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          {\n            ssize_t\n              pattern;\n\n            size_t\n              height,\n              width;\n\n            /*\n              Skip pattern definition.\n            */\n            pattern=1L*ReadBlobMSBShort(image);\n            for (i=0; i < 8; i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            if (pattern == 2)\n              {\n                for (i=0; i < 5; i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n                break;\n              }\n            if (pattern != 1)\n              ThrowReaderException(CorruptImageError,\"UnknownPatternType\");\n            length=ReadBlobMSBShort(image);\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            ReadPixmap(pixmap);\n            image->depth=1UL*pixmap.component_size;\n            image->resolution.x=1.0*pixmap.horizontal_resolution;\n            image->resolution.y=1.0*pixmap.vertical_resolution;\n            image->units=PixelsPerInchResolution;\n            (void) ReadBlobMSBLong(image);\n            flags=1L*ReadBlobMSBShort(image);\n            length=ReadBlobMSBShort(image);\n            for (i=0; i <= (ssize_t) length; i++)\n              (void) ReadBlobMSBLong(image);\n            width=1UL*(frame.bottom-frame.top);\n            height=1UL*(frame.right-frame.left);\n            if (pixmap.bits_per_pixel <= 8)\n              length&=0x7fff;\n            if (pixmap.bits_per_pixel == 16)\n              width<<=1;\n            if (length == 0)\n              length=width;\n            if (length < 8)\n              {\n                for (i=0; i < (ssize_t) (length*height); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n              }\n            else\n              for (j=0; j < (int) height; j++)\n                if (length > 200)\n                  {\n                    for (j=0; j < (ssize_t) ReadBlobMSBShort(image); j++)\n                      if (ReadBlobByte(image) == EOF)\n                        break;\n                  }\n                else\n                  for (j=0; j < (ssize_t) ReadBlobByte(image); j++)\n                    if (ReadBlobByte(image) == EOF)\n                      break;\n            break;\n          }\n          case 0x1b:\n          {\n            /*\n              Initialize image background color.\n            */\n            image->background_color.red=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            image->background_color.green=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            image->background_color.blue=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            break;\n          }\n          case 0x70:\n          case 0x71:\n          case 0x72:\n          case 0x73:\n          case 0x74:\n          case 0x75:\n          case 0x76:\n          case 0x77:\n          {\n            /*\n              Skip polygon or region.\n            */\n            length=ReadBlobMSBShort(image);\n            for (i=0; i < (ssize_t) (length-2); i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            break;\n          }\n          case 0x90:\n          case 0x91:\n          case 0x98:\n          case 0x99:\n          case 0x9a:\n          case 0x9b:\n          {\n            Image\n              *tile_image;\n\n            PICTRectangle\n              source,\n              destination;\n\n            register unsigned char\n              *p;\n\n            size_t\n              j;\n\n            ssize_t\n              bytes_per_line;\n\n            unsigned char\n              *pixels;\n\n            /*\n              Pixmap clipped by a rectangle.\n            */\n            bytes_per_line=0;\n            if ((code != 0x9a) && (code != 0x9b))\n              bytes_per_line=1L*ReadBlobMSBShort(image);\n            else\n              {\n                (void) ReadBlobMSBShort(image);\n                (void) ReadBlobMSBShort(image);\n                (void) ReadBlobMSBShort(image);\n              }\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            /*\n              Initialize tile image.\n            */\n            tile_image=CloneImage(image,1UL*(frame.right-frame.left),\n              1UL*(frame.bottom-frame.top),MagickTrue,exception);\n            if (tile_image == (Image *) NULL)\n              return((Image *) NULL);\n            if ((code == 0x9a) || (code == 0x9b) ||\n                ((bytes_per_line & 0x8000) != 0))\n              {\n                ReadPixmap(pixmap);\n                tile_image->depth=1UL*pixmap.component_size;\n                tile_image->alpha_trait=pixmap.component_count == 4 ?\n                  BlendPixelTrait : UndefinedPixelTrait;\n                tile_image->resolution.x=(double) pixmap.horizontal_resolution;\n                tile_image->resolution.y=(double) pixmap.vertical_resolution;\n                tile_image->units=PixelsPerInchResolution;\n                if (tile_image->alpha_trait != UndefinedPixelTrait)\n                  image->alpha_trait=tile_image->alpha_trait;\n              }\n            if ((code != 0x9a) && (code != 0x9b))\n              {\n                /*\n                  Initialize colormap.\n                */\n                tile_image->colors=2;\n                if ((bytes_per_line & 0x8000) != 0)\n                  {\n                    (void) ReadBlobMSBLong(image);\n                    flags=1L*ReadBlobMSBShort(image);\n                    tile_image->colors=1UL*ReadBlobMSBShort(image)+1;\n                  }\n                status=AcquireImageColormap(tile_image,tile_image->colors,\n                  exception);\n                if (status == MagickFalse)\n                  {\n                    tile_image=DestroyImage(tile_image);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                if ((bytes_per_line & 0x8000) != 0)\n                  {\n                    for (i=0; i < (ssize_t) tile_image->colors; i++)\n                    {\n                      j=ReadBlobMSBShort(image) % tile_image->colors;\n                      if ((flags & 0x8000) != 0)\n                        j=(size_t) i;\n                      tile_image->colormap[j].red=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                      tile_image->colormap[j].green=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                      tile_image->colormap[j].blue=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                    }\n                  }\n                else\n                  {\n                    for (i=0; i < (ssize_t) tile_image->colors; i++)\n                    {\n                      tile_image->colormap[i].red=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].red);\n                      tile_image->colormap[i].green=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].green);\n                      tile_image->colormap[i].blue=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].blue);\n                    }\n                  }\n              }\n            if (ReadRectangle(image,&source) == MagickFalse)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              }\n            if (ReadRectangle(image,&destination) == MagickFalse)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              }\n            (void) ReadBlobMSBShort(image);\n            if ((code == 0x91) || (code == 0x99) || (code == 0x9b))\n              {\n                /*\n                  Skip region.\n                */\n                length=ReadBlobMSBShort(image);\n                for (i=0; i < (ssize_t) (length-2); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n              }\n            if ((code != 0x9a) && (code != 0x9b) &&\n                (bytes_per_line & 0x8000) == 0)\n              pixels=DecodeImage(image,tile_image,1UL*bytes_per_line,1,&extent,\n                exception);\n            else\n              pixels=DecodeImage(image,tile_image,1UL*bytes_per_line,1U*\n                pixmap.bits_per_pixel,&extent,exception);\n            if (pixels == (unsigned char *) NULL)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n            /*\n              Convert PICT tile image to pixel packets.\n            */\n            p=pixels;\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              if (p > (pixels+extent+image->columns))\n                {\n                  tile_image=DestroyImage(tile_image);\n                  ThrowReaderException(CorruptImageError,\"NotEnoughPixelData\");\n                }\n              q=QueueAuthenticPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                if (tile_image->storage_class == PseudoClass)\n                  {\n                    index=ConstrainColormapIndex(tile_image,*p,exception);\n                    SetPixelIndex(tile_image,index,q);\n                    SetPixelRed(tile_image,\n                      tile_image->colormap[(ssize_t) index].red,q);\n                    SetPixelGreen(tile_image,\n                      tile_image->colormap[(ssize_t) index].green,q);\n                    SetPixelBlue(tile_image,\n                      tile_image->colormap[(ssize_t) index].blue,q);\n                  }\n                else\n                  {\n                    if (pixmap.bits_per_pixel == 16)\n                      {\n                        i=(*p++);\n                        j=(*p);\n                        SetPixelRed(tile_image,ScaleCharToQuantum(\n                          (unsigned char) ((i & 0x7c) << 1)),q);\n                        SetPixelGreen(tile_image,ScaleCharToQuantum(\n                          (unsigned char) (((i & 0x03) << 6) |\n                          ((j & 0xe0) >> 2))),q);\n                        SetPixelBlue(tile_image,ScaleCharToQuantum(\n                          (unsigned char) ((j & 0x1f) << 3)),q);\n                      }\n                    else\n                      if (tile_image->alpha_trait == UndefinedPixelTrait)\n                        {\n                          if (p > (pixels+extent+2*image->columns))\n                            {\n                              tile_image=DestroyImage(tile_image);\n                              ThrowReaderException(CorruptImageError,\n                                \"NotEnoughPixelData\");\n                            }\n                          SetPixelRed(tile_image,ScaleCharToQuantum(*p),q);\n                          SetPixelGreen(tile_image,ScaleCharToQuantum(\n                            *(p+tile_image->columns)),q);\n                          SetPixelBlue(tile_image,ScaleCharToQuantum(\n                            *(p+2*tile_image->columns)),q);\n                        }\n                      else\n                        {\n                          if (p > (pixels+extent+3*image->columns))\n                            {\n                              tile_image=DestroyImage(tile_image);\n                              ThrowReaderException(CorruptImageError,\n                                \"NotEnoughPixelData\");\n                            }\n                          SetPixelAlpha(tile_image,ScaleCharToQuantum(*p),q);\n                          SetPixelRed(tile_image,ScaleCharToQuantum(\n                            *(p+tile_image->columns)),q);\n                          SetPixelGreen(tile_image,ScaleCharToQuantum(\n                            *(p+2*tile_image->columns)),q);\n                          SetPixelBlue(tile_image,ScaleCharToQuantum(\n                            *(p+3*tile_image->columns)),q);\n                        }\n                  }\n                p++;\n                q+=GetPixelChannels(tile_image);\n              }\n              if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n                break;\n              if ((tile_image->storage_class == DirectClass) &&\n                  (pixmap.bits_per_pixel != 16))\n                {\n                  p+=(pixmap.component_count-1)*tile_image->columns;\n                  if (p < pixels)\n                    break;\n                }\n              status=SetImageProgress(image,LoadImageTag,y,tile_image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            if (jpeg == MagickFalse)\n              if ((code == 0x9a) || (code == 0x9b) ||\n                  ((bytes_per_line & 0x8000) != 0))\n                (void) CompositeImage(image,tile_image,CopyCompositeOp,\n                  MagickTrue,destination.left,destination.top,exception);\n            tile_image=DestroyImage(tile_image);\n            break;\n          }\n          case 0xa1:\n          {\n            unsigned char\n              *info;\n\n            size_t\n              type;\n\n            /*\n              Comment.\n            */\n            type=ReadBlobMSBShort(image);\n            length=ReadBlobMSBShort(image);\n            if (length == 0)\n              break;\n            (void) ReadBlobMSBLong(image);\n            length-=4;\n            if (length == 0)\n              break;\n            info=(unsigned char *) AcquireQuantumMemory(length,sizeof(*info));\n            if (info == (unsigned char *) NULL)\n              break;\n            count=ReadBlob(image,length,info);\n            if (count != (ssize_t) length)\n              ThrowReaderException(ResourceLimitError,\"UnableToReadImageData\");\n            switch (type)\n            {\n              case 0xe0:\n              {\n                profile=BlobToStringInfo((const void *) NULL,length);\n                SetStringInfoDatum(profile,info);\n                status=SetImageProfile(image,\"icc\",profile,exception);\n                profile=DestroyStringInfo(profile);\n                if (status == MagickFalse)\n                  {\n                    info=(unsigned char *) RelinquishMagickMemory(info);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                break;\n              }\n              case 0x1f2:\n              {\n                profile=BlobToStringInfo((const void *) NULL,length);\n                SetStringInfoDatum(profile,info);\n                status=SetImageProfile(image,\"iptc\",profile,exception);\n                if (status == MagickFalse)\n                  {\n                    info=(unsigned char *) RelinquishMagickMemory(info);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                profile=DestroyStringInfo(profile);\n                break;\n              }\n              default:\n                break;\n            }\n            info=(unsigned char *) RelinquishMagickMemory(info);\n            break;\n          }\n          default:\n          {\n            /*\n              Skip to next op code.\n            */\n            if (codes[code].length == -1)\n              (void) ReadBlobMSBShort(image);\n            else\n              for (i=0; i < (ssize_t) codes[code].length; i++)\n                if (ReadBlobByte(image) == EOF)\n                  break;\n          }\n        }\n      }\n    if (code == 0xc00)\n      {\n        /*\n          Skip header.\n        */\n        for (i=0; i < 24; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n    if (((code >= 0xb0) && (code <= 0xcf)) ||\n        ((code >= 0x8000) && (code <= 0x80ff)))\n      continue;\n    if (code == 0x8200)\n      {\n        FILE\n          *file;\n\n        Image\n          *tile_image;\n\n        ImageInfo\n          *read_info;\n\n        int\n          unique_file;\n\n        /*\n          Embedded JPEG.\n        */\n        jpeg=MagickTrue;\n        read_info=CloneImageInfo(image_info);\n        SetImageInfoBlob(read_info,(void *) NULL,0);\n        file=(FILE *) NULL;\n        unique_file=AcquireUniqueFileResource(read_info->filename);\n        if (unique_file != -1)\n          file=fdopen(unique_file,\"wb\");\n        if ((unique_file == -1) || (file == (FILE *) NULL))\n          {\n            (void) RelinquishUniqueFileResource(read_info->filename);\n            (void) CopyMagickString(image->filename,read_info->filename,\n              MagickPathExtent);\n            ThrowFileException(exception,FileOpenError,\n              \"UnableToCreateTemporaryFile\",image->filename);\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        length=ReadBlobMSBLong(image);\n        if (length > 154)\n          {\n            for (i=0; i < 6; i++)\n              (void) ReadBlobMSBLong(image);\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              {\n                (void) fclose(file);\n                (void) RelinquishUniqueFileResource(read_info->filename);\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              }\n            for (i=0; i < 122; i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            for (i=0; i < (ssize_t) (length-154); i++)\n            {\n              c=ReadBlobByte(image);\n              if (c == EOF)\n                break;\n              (void) fputc(c,file);\n            }\n          }\n        (void) fclose(file);\n        (void) close(unique_file);\n        tile_image=ReadImage(read_info,exception);\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        read_info=DestroyImageInfo(read_info);\n        if (tile_image == (Image *) NULL)\n          continue;\n        (void) FormatLocaleString(geometry,MagickPathExtent,\"%.20gx%.20g\",\n          (double) MagickMax(image->columns,tile_image->columns),\n          (double) MagickMax(image->rows,tile_image->rows));\n        (void) SetImageExtent(image,\n          MagickMax(image->columns,tile_image->columns),\n          MagickMax(image->rows,tile_image->rows),exception);\n        (void) TransformImageColorspace(image,tile_image->colorspace,exception);\n        (void) CompositeImage(image,tile_image,CopyCompositeOp,MagickTrue,\n          frame.left,frame.right,exception);\n        image->compression=tile_image->compression;\n        tile_image=DestroyImage(tile_image);\n        continue;\n      }\n    if ((code == 0xff) || (code == 0xffff))\n      break;\n    if (((code >= 0xd0) && (code <= 0xfe)) ||\n        ((code >= 0x8100) && (code <= 0xffff)))\n      {\n        /*\n          Skip reserved.\n        */\n        length=ReadBlobMSBShort(image);\n        for (i=0; i < (ssize_t) length; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n    if ((code >= 0x100) && (code <= 0x7fff))\n      {\n        /*\n          Skip reserved.\n        */\n        length=(size_t) ((code >> 7) & 0xff);\n        for (i=0; i < (ssize_t) length; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadPICTImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    geometry[MagickPathExtent],\n    header_ole[4];\n\n  Image\n    *image;\n\n  int\n    c,\n    code;\n\n  MagickBooleanType\n    jpeg,\n    status;\n\n  PICTRectangle\n    frame;\n\n  PICTPixmap\n    pixmap;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    extent,\n    length;\n\n  ssize_t\n    count,\n    flags,\n    j,\n    version,\n    y;\n\n  StringInfo\n    *profile;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read PICT header.\n  */\n  pixmap.bits_per_pixel=0;\n  pixmap.component_count=0;\n  /*\n    Skip header : 512 for standard PICT and 4, ie \"PICT\" for OLE2.\n  */\n  header_ole[0]=ReadBlobByte(image);\n  header_ole[1]=ReadBlobByte(image);\n  header_ole[2]=ReadBlobByte(image);\n  header_ole[3]=ReadBlobByte(image);\n  if (!((header_ole[0] == 0x50) && (header_ole[1] == 0x49) &&\n      (header_ole[2] == 0x43) && (header_ole[3] == 0x54 )))\n    for (i=0; i < 508; i++)\n      if (ReadBlobByte(image) == EOF)\n        break;\n  (void) ReadBlobMSBShort(image);  /* skip picture size */\n  if (ReadRectangle(image,&frame) == MagickFalse)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  while ((c=ReadBlobByte(image)) == 0) ;\n  if (c != 0x11)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  version=ReadBlobByte(image);\n  if (version == 2)\n    {\n      c=ReadBlobByte(image);\n      if (c != 0xff)\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  else\n    if (version != 1)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((frame.left < 0) || (frame.right < 0) || (frame.top < 0) ||\n      (frame.bottom < 0) || (frame.left >= frame.right) ||\n      (frame.top >= frame.bottom))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Create black canvas.\n  */\n  flags=0;\n  image->depth=8;\n  image->columns=1UL*(frame.right-frame.left);\n  image->rows=1UL*(frame.bottom-frame.top);\n  image->resolution.x=DefaultResolution;\n  image->resolution.y=DefaultResolution;\n  image->units=UndefinedResolution;\n  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n    if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Interpret PICT opcodes.\n  */\n  jpeg=MagickFalse;\n  for (code=0; EOFBlob(image) == MagickFalse; )\n  {\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if ((version == 1) || ((TellBlob(image) % 2) != 0))\n      code=ReadBlobByte(image);\n    if (version == 2)\n      code=ReadBlobMSBSignedShort(image);\n    if (code < 0)\n      break;\n    if (code > 0xa1)\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"%04X:\",code);\n      }\n    else\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  %04X %s: %s\",code,codes[code].name,codes[code].description);\n        switch (code)\n        {\n          case 0x01:\n          {\n            /*\n              Clipping rectangle.\n            */\n            length=ReadBlobMSBShort(image);\n            if (length != 0x000a)\n              {\n                for (i=0; i < (ssize_t) (length-2); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n                break;\n              }\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            if (((frame.left & 0x8000) != 0) || ((frame.top & 0x8000) != 0))\n              break;\n            image->columns=1UL*(frame.right-frame.left);\n            image->rows=1UL*(frame.bottom-frame.top);\n            status=SetImageExtent(image,image->columns,image->rows,exception);\n            if (status == MagickFalse)\n              return(DestroyImageList(image));\n            (void) SetImageBackgroundColor(image,exception);\n            break;\n          }\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          {\n            ssize_t\n              pattern;\n\n            size_t\n              height,\n              width;\n\n            /*\n              Skip pattern definition.\n            */\n            pattern=1L*ReadBlobMSBShort(image);\n            for (i=0; i < 8; i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            if (pattern == 2)\n              {\n                for (i=0; i < 5; i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n                break;\n              }\n            if (pattern != 1)\n              ThrowReaderException(CorruptImageError,\"UnknownPatternType\");\n            length=ReadBlobMSBShort(image);\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            if (ReadPixmap(image,&pixmap) == MagickFalse)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            image->depth=1UL*pixmap.component_size;\n            image->resolution.x=1.0*pixmap.horizontal_resolution;\n            image->resolution.y=1.0*pixmap.vertical_resolution;\n            image->units=PixelsPerInchResolution;\n            (void) ReadBlobMSBLong(image);\n            flags=1L*ReadBlobMSBShort(image);\n            length=ReadBlobMSBShort(image);\n            for (i=0; i <= (ssize_t) length; i++)\n              (void) ReadBlobMSBLong(image);\n            width=1UL*(frame.bottom-frame.top);\n            height=1UL*(frame.right-frame.left);\n            if (pixmap.bits_per_pixel <= 8)\n              length&=0x7fff;\n            if (pixmap.bits_per_pixel == 16)\n              width<<=1;\n            if (length == 0)\n              length=width;\n            if (length < 8)\n              {\n                for (i=0; i < (ssize_t) (length*height); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n              }\n            else\n              for (j=0; j < (int) height; j++)\n                if (length > 200)\n                  {\n                    for (j=0; j < (ssize_t) ReadBlobMSBShort(image); j++)\n                      if (ReadBlobByte(image) == EOF)\n                        break;\n                  }\n                else\n                  for (j=0; j < (ssize_t) ReadBlobByte(image); j++)\n                    if (ReadBlobByte(image) == EOF)\n                      break;\n            break;\n          }\n          case 0x1b:\n          {\n            /*\n              Initialize image background color.\n            */\n            image->background_color.red=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            image->background_color.green=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            image->background_color.blue=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            break;\n          }\n          case 0x70:\n          case 0x71:\n          case 0x72:\n          case 0x73:\n          case 0x74:\n          case 0x75:\n          case 0x76:\n          case 0x77:\n          {\n            /*\n              Skip polygon or region.\n            */\n            length=ReadBlobMSBShort(image);\n            for (i=0; i < (ssize_t) (length-2); i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            break;\n          }\n          case 0x90:\n          case 0x91:\n          case 0x98:\n          case 0x99:\n          case 0x9a:\n          case 0x9b:\n          {\n            Image\n              *tile_image;\n\n            PICTRectangle\n              source,\n              destination;\n\n            register unsigned char\n              *p;\n\n            size_t\n              j;\n\n            ssize_t\n              bytes_per_line;\n\n            unsigned char\n              *pixels;\n\n            /*\n              Pixmap clipped by a rectangle.\n            */\n            bytes_per_line=0;\n            if ((code != 0x9a) && (code != 0x9b))\n              bytes_per_line=1L*ReadBlobMSBShort(image);\n            else\n              {\n                (void) ReadBlobMSBShort(image);\n                (void) ReadBlobMSBShort(image);\n                (void) ReadBlobMSBShort(image);\n              }\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n            /*\n              Initialize tile image.\n            */\n            tile_image=CloneImage(image,1UL*(frame.right-frame.left),\n              1UL*(frame.bottom-frame.top),MagickTrue,exception);\n            if (tile_image == (Image *) NULL)\n              return((Image *) NULL);\n            if ((code == 0x9a) || (code == 0x9b) ||\n                ((bytes_per_line & 0x8000) != 0))\n              {\n                if (ReadPixmap(image,&pixmap) == MagickFalse)\n                  {\n                    tile_image=DestroyImage(tile_image);\n                    ThrowReaderException(CorruptImageError,\n                      \"ImproperImageHeader\");\n                  }\n                tile_image->depth=1UL*pixmap.component_size;\n                tile_image->alpha_trait=pixmap.component_count == 4 ?\n                  BlendPixelTrait : UndefinedPixelTrait;\n                tile_image->resolution.x=(double) pixmap.horizontal_resolution;\n                tile_image->resolution.y=(double) pixmap.vertical_resolution;\n                tile_image->units=PixelsPerInchResolution;\n                if (tile_image->alpha_trait != UndefinedPixelTrait)\n                  image->alpha_trait=tile_image->alpha_trait;\n              }\n            if ((code != 0x9a) && (code != 0x9b))\n              {\n                /*\n                  Initialize colormap.\n                */\n                tile_image->colors=2;\n                if ((bytes_per_line & 0x8000) != 0)\n                  {\n                    (void) ReadBlobMSBLong(image);\n                    flags=1L*ReadBlobMSBShort(image);\n                    tile_image->colors=1UL*ReadBlobMSBShort(image)+1;\n                  }\n                status=AcquireImageColormap(tile_image,tile_image->colors,\n                  exception);\n                if (status == MagickFalse)\n                  {\n                    tile_image=DestroyImage(tile_image);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                if ((bytes_per_line & 0x8000) != 0)\n                  {\n                    for (i=0; i < (ssize_t) tile_image->colors; i++)\n                    {\n                      j=ReadBlobMSBShort(image) % tile_image->colors;\n                      if ((flags & 0x8000) != 0)\n                        j=(size_t) i;\n                      tile_image->colormap[j].red=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                      tile_image->colormap[j].green=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                      tile_image->colormap[j].blue=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                    }\n                  }\n                else\n                  {\n                    for (i=0; i < (ssize_t) tile_image->colors; i++)\n                    {\n                      tile_image->colormap[i].red=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].red);\n                      tile_image->colormap[i].green=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].green);\n                      tile_image->colormap[i].blue=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].blue);\n                    }\n                  }\n              }\n            if (ReadRectangle(image,&source) == MagickFalse)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              }\n            if (ReadRectangle(image,&destination) == MagickFalse)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              }\n            (void) ReadBlobMSBShort(image);\n            if ((code == 0x91) || (code == 0x99) || (code == 0x9b))\n              {\n                /*\n                  Skip region.\n                */\n                length=ReadBlobMSBShort(image);\n                for (i=0; i < (ssize_t) (length-2); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n              }\n            if ((code != 0x9a) && (code != 0x9b) &&\n                (bytes_per_line & 0x8000) == 0)\n              pixels=DecodeImage(image,tile_image,1UL*bytes_per_line,1,&extent,\n                exception);\n            else\n              pixels=DecodeImage(image,tile_image,1UL*bytes_per_line,1U*\n                pixmap.bits_per_pixel,&extent,exception);\n            if (pixels == (unsigned char *) NULL)\n              {\n                tile_image=DestroyImage(tile_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n            /*\n              Convert PICT tile image to pixel packets.\n            */\n            p=pixels;\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              if (p > (pixels+extent+image->columns))\n                {\n                  tile_image=DestroyImage(tile_image);\n                  ThrowReaderException(CorruptImageError,\"NotEnoughPixelData\");\n                }\n              q=QueueAuthenticPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                if (tile_image->storage_class == PseudoClass)\n                  {\n                    index=ConstrainColormapIndex(tile_image,*p,exception);\n                    SetPixelIndex(tile_image,index,q);\n                    SetPixelRed(tile_image,\n                      tile_image->colormap[(ssize_t) index].red,q);\n                    SetPixelGreen(tile_image,\n                      tile_image->colormap[(ssize_t) index].green,q);\n                    SetPixelBlue(tile_image,\n                      tile_image->colormap[(ssize_t) index].blue,q);\n                  }\n                else\n                  {\n                    if (pixmap.bits_per_pixel == 16)\n                      {\n                        i=(*p++);\n                        j=(*p);\n                        SetPixelRed(tile_image,ScaleCharToQuantum(\n                          (unsigned char) ((i & 0x7c) << 1)),q);\n                        SetPixelGreen(tile_image,ScaleCharToQuantum(\n                          (unsigned char) (((i & 0x03) << 6) |\n                          ((j & 0xe0) >> 2))),q);\n                        SetPixelBlue(tile_image,ScaleCharToQuantum(\n                          (unsigned char) ((j & 0x1f) << 3)),q);\n                      }\n                    else\n                      if (tile_image->alpha_trait == UndefinedPixelTrait)\n                        {\n                          if (p > (pixels+extent+2*image->columns))\n                            {\n                              tile_image=DestroyImage(tile_image);\n                              ThrowReaderException(CorruptImageError,\n                                \"NotEnoughPixelData\");\n                            }\n                          SetPixelRed(tile_image,ScaleCharToQuantum(*p),q);\n                          SetPixelGreen(tile_image,ScaleCharToQuantum(\n                            *(p+tile_image->columns)),q);\n                          SetPixelBlue(tile_image,ScaleCharToQuantum(\n                            *(p+2*tile_image->columns)),q);\n                        }\n                      else\n                        {\n                          if (p > (pixels+extent+3*image->columns))\n                            {\n                              tile_image=DestroyImage(tile_image);\n                              ThrowReaderException(CorruptImageError,\n                                \"NotEnoughPixelData\");\n                            }\n                          SetPixelAlpha(tile_image,ScaleCharToQuantum(*p),q);\n                          SetPixelRed(tile_image,ScaleCharToQuantum(\n                            *(p+tile_image->columns)),q);\n                          SetPixelGreen(tile_image,ScaleCharToQuantum(\n                            *(p+2*tile_image->columns)),q);\n                          SetPixelBlue(tile_image,ScaleCharToQuantum(\n                            *(p+3*tile_image->columns)),q);\n                        }\n                  }\n                p++;\n                q+=GetPixelChannels(tile_image);\n              }\n              if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n                break;\n              if ((tile_image->storage_class == DirectClass) &&\n                  (pixmap.bits_per_pixel != 16))\n                {\n                  p+=(pixmap.component_count-1)*tile_image->columns;\n                  if (p < pixels)\n                    break;\n                }\n              status=SetImageProgress(image,LoadImageTag,y,tile_image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            if (jpeg == MagickFalse)\n              if ((code == 0x9a) || (code == 0x9b) ||\n                  ((bytes_per_line & 0x8000) != 0))\n                (void) CompositeImage(image,tile_image,CopyCompositeOp,\n                  MagickTrue,destination.left,destination.top,exception);\n            tile_image=DestroyImage(tile_image);\n            break;\n          }\n          case 0xa1:\n          {\n            unsigned char\n              *info;\n\n            size_t\n              type;\n\n            /*\n              Comment.\n            */\n            type=ReadBlobMSBShort(image);\n            length=ReadBlobMSBShort(image);\n            if (length == 0)\n              break;\n            (void) ReadBlobMSBLong(image);\n            length-=4;\n            if (length == 0)\n              break;\n            info=(unsigned char *) AcquireQuantumMemory(length,sizeof(*info));\n            if (info == (unsigned char *) NULL)\n              break;\n            count=ReadBlob(image,length,info);\n            if (count != (ssize_t) length)\n              ThrowReaderException(ResourceLimitError,\"UnableToReadImageData\");\n            switch (type)\n            {\n              case 0xe0:\n              {\n                profile=BlobToStringInfo((const void *) NULL,length);\n                SetStringInfoDatum(profile,info);\n                status=SetImageProfile(image,\"icc\",profile,exception);\n                profile=DestroyStringInfo(profile);\n                if (status == MagickFalse)\n                  {\n                    info=(unsigned char *) RelinquishMagickMemory(info);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                break;\n              }\n              case 0x1f2:\n              {\n                profile=BlobToStringInfo((const void *) NULL,length);\n                SetStringInfoDatum(profile,info);\n                status=SetImageProfile(image,\"iptc\",profile,exception);\n                if (status == MagickFalse)\n                  {\n                    info=(unsigned char *) RelinquishMagickMemory(info);\n                    ThrowReaderException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                profile=DestroyStringInfo(profile);\n                break;\n              }\n              default:\n                break;\n            }\n            info=(unsigned char *) RelinquishMagickMemory(info);\n            break;\n          }\n          default:\n          {\n            /*\n              Skip to next op code.\n            */\n            if (codes[code].length == -1)\n              (void) ReadBlobMSBShort(image);\n            else\n              for (i=0; i < (ssize_t) codes[code].length; i++)\n                if (ReadBlobByte(image) == EOF)\n                  break;\n          }\n        }\n      }\n    if (code == 0xc00)\n      {\n        /*\n          Skip header.\n        */\n        for (i=0; i < 24; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n    if (((code >= 0xb0) && (code <= 0xcf)) ||\n        ((code >= 0x8000) && (code <= 0x80ff)))\n      continue;\n    if (code == 0x8200)\n      {\n        FILE\n          *file;\n\n        Image\n          *tile_image;\n\n        ImageInfo\n          *read_info;\n\n        int\n          unique_file;\n\n        /*\n          Embedded JPEG.\n        */\n        jpeg=MagickTrue;\n        read_info=CloneImageInfo(image_info);\n        SetImageInfoBlob(read_info,(void *) NULL,0);\n        file=(FILE *) NULL;\n        unique_file=AcquireUniqueFileResource(read_info->filename);\n        if (unique_file != -1)\n          file=fdopen(unique_file,\"wb\");\n        if ((unique_file == -1) || (file == (FILE *) NULL))\n          {\n            (void) RelinquishUniqueFileResource(read_info->filename);\n            (void) CopyMagickString(image->filename,read_info->filename,\n              MagickPathExtent);\n            ThrowFileException(exception,FileOpenError,\n              \"UnableToCreateTemporaryFile\",image->filename);\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        length=ReadBlobMSBLong(image);\n        if (length > 154)\n          {\n            for (i=0; i < 6; i++)\n              (void) ReadBlobMSBLong(image);\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              {\n                (void) fclose(file);\n                (void) RelinquishUniqueFileResource(read_info->filename);\n                ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n              }\n            for (i=0; i < 122; i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            for (i=0; i < (ssize_t) (length-154); i++)\n            {\n              c=ReadBlobByte(image);\n              if (c == EOF)\n                break;\n              (void) fputc(c,file);\n            }\n          }\n        (void) fclose(file);\n        (void) close(unique_file);\n        tile_image=ReadImage(read_info,exception);\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        read_info=DestroyImageInfo(read_info);\n        if (tile_image == (Image *) NULL)\n          continue;\n        (void) FormatLocaleString(geometry,MagickPathExtent,\"%.20gx%.20g\",\n          (double) MagickMax(image->columns,tile_image->columns),\n          (double) MagickMax(image->rows,tile_image->rows));\n        (void) SetImageExtent(image,\n          MagickMax(image->columns,tile_image->columns),\n          MagickMax(image->rows,tile_image->rows),exception);\n        (void) TransformImageColorspace(image,tile_image->colorspace,exception);\n        (void) CompositeImage(image,tile_image,CopyCompositeOp,MagickTrue,\n          frame.left,frame.right,exception);\n        image->compression=tile_image->compression;\n        tile_image=DestroyImage(tile_image);\n        continue;\n      }\n    if ((code == 0xff) || (code == 0xffff))\n      break;\n    if (((code >= 0xd0) && (code <= 0xfe)) ||\n        ((code >= 0x8100) && (code <= 0xffff)))\n      {\n        /*\n          Skip reserved.\n        */\n        length=ReadBlobMSBShort(image);\n        for (i=0; i < (ssize_t) length; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n    if ((code >= 0x100) && (code <= 0x7fff))\n      {\n        /*\n          Skip reserved.\n        */\n        length=(size_t) ((code >> 7) & 0xff);\n        for (i=0; i < (ssize_t) length; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -201,7 +201,8 @@\n             length=ReadBlobMSBShort(image);\n             if (ReadRectangle(image,&frame) == MagickFalse)\n               ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n-            ReadPixmap(pixmap);\n+            if (ReadPixmap(image,&pixmap) == MagickFalse)\n+              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n             image->depth=1UL*pixmap.component_size;\n             image->resolution.x=1.0*pixmap.horizontal_resolution;\n             image->resolution.y=1.0*pixmap.vertical_resolution;\n@@ -320,7 +321,12 @@\n             if ((code == 0x9a) || (code == 0x9b) ||\n                 ((bytes_per_line & 0x8000) != 0))\n               {\n-                ReadPixmap(pixmap);\n+                if (ReadPixmap(image,&pixmap) == MagickFalse)\n+                  {\n+                    tile_image=DestroyImage(tile_image);\n+                    ThrowReaderException(CorruptImageError,\n+                      \"ImproperImageHeader\");\n+                  }\n                 tile_image->depth=1UL*pixmap.component_size;\n                 tile_image->alpha_trait=pixmap.component_count == 4 ?\n                   BlendPixelTrait : UndefinedPixelTrait;",
        "diff_line_info": {
            "deleted_lines": [
                "            ReadPixmap(pixmap);",
                "                ReadPixmap(pixmap);"
            ],
            "added_lines": [
                "            if (ReadPixmap(image,&pixmap) == MagickFalse)",
                "              ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "                if (ReadPixmap(image,&pixmap) == MagickFalse)",
                "                  {",
                "                    tile_image=DestroyImage(tile_image);",
                "                    ThrowReaderException(CorruptImageError,",
                "                      \"ImproperImageHeader\");",
                "                  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12663",
        "func_name": "ImageMagick/WriteMAPImage",
        "description": "ImageMagick 7.0.6-2 has a memory leak vulnerability in WriteMAPImage in coders/map.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/1dc0ac5016f1c4d50b100a086526d6a2453a5444",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/573",
        "commit_text": "",
        "func_before": "static MagickBooleanType WriteMAPImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    depth,\n    packet_size;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *colormap,\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  /*\n    Allocate colormap.\n  */\n  if (IsPaletteImage(image) == MagickFalse)\n    (void) SetImageType(image,PaletteType,exception);\n  depth=GetImageQuantumDepth(image,MagickTrue);\n  packet_size=(size_t) (depth/8);\n  pixels=(unsigned char *) AcquireQuantumMemory(image->columns,packet_size*\n    sizeof(*pixels));\n  packet_size=(size_t) (image->colors > 256 ? 6UL : 3UL);\n  colormap=(unsigned char *) AcquireQuantumMemory(image->colors,packet_size*\n    sizeof(*colormap));\n  if ((pixels == (unsigned char *) NULL) ||\n      (colormap == (unsigned char *) NULL))\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  /*\n    Write colormap to file.\n  */\n  q=colormap;\n  q=colormap;\n  if (image->colors <= 256)\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      *q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].red);\n      *q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].green);\n      *q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].blue);\n    }\n  else\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].red) >> 8);\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].red) & 0xff);\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].green) >> 8);\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].green) & 0xff);;\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].blue) >> 8);\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].blue) & 0xff);\n    }\n  (void) WriteBlob(image,packet_size*image->colors,colormap);\n  colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n  /*\n    Write image pixels to file.\n  */\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    q=pixels;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (image->colors > 256)\n        *q++=(unsigned char) ((size_t) GetPixelIndex(image,p) >> 8);\n      *q++=(unsigned char) GetPixelIndex(image,p);\n      p+=GetPixelChannels(image);\n    }\n    (void) WriteBlob(image,(size_t) (q-pixels),pixels);\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  (void) CloseBlob(image);\n  return(status);\n}",
        "func": "static MagickBooleanType WriteMAPImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    depth,\n    packet_size;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *colormap,\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  /*\n    Allocate colormap.\n  */\n  if (IsPaletteImage(image) == MagickFalse)\n    (void) SetImageType(image,PaletteType,exception);\n  depth=GetImageQuantumDepth(image,MagickTrue);\n  packet_size=(size_t) (depth/8);\n  pixels=(unsigned char *) AcquireQuantumMemory(image->columns,packet_size*\n    sizeof(*pixels));\n  packet_size=(size_t) (image->colors > 256 ? 6UL : 3UL);\n  colormap=(unsigned char *) AcquireQuantumMemory(image->colors,packet_size*\n    sizeof(*colormap));\n  if ((pixels == (unsigned char *) NULL) ||\n      (colormap == (unsigned char *) NULL))\n    {\n      if (colormap != (unsigned char *) NULL)\n        colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n      if (pixels != (unsigned char *) NULL)\n        pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  /*\n    Write colormap to file.\n  */\n  q=colormap;\n  if (image->colors <= 256)\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      *q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].red);\n      *q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].green);\n      *q++=(unsigned char) ScaleQuantumToChar(image->colormap[i].blue);\n    }\n  else\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].red) >> 8);\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].red) & 0xff);\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].green) >> 8);\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].green) &\n        0xff);\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].blue) >> 8);\n      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].blue) &\n        0xff);\n    }\n  (void) WriteBlob(image,packet_size*image->colors,colormap);\n  colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n  /*\n    Write image pixels to file.\n  */\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    q=pixels;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (image->colors > 256)\n        *q++=(unsigned char) ((size_t) GetPixelIndex(image,p) >> 8);\n      *q++=(unsigned char) GetPixelIndex(image,p);\n      p+=GetPixelChannels(image);\n    }\n    (void) WriteBlob(image,(size_t) (q-pixels),pixels);\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  (void) CloseBlob(image);\n  return(status);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -54,11 +54,16 @@\n     sizeof(*colormap));\n   if ((pixels == (unsigned char *) NULL) ||\n       (colormap == (unsigned char *) NULL))\n-    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n+    {\n+      if (colormap != (unsigned char *) NULL)\n+        colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n+      if (pixels != (unsigned char *) NULL)\n+        pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n+      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n+    }\n   /*\n     Write colormap to file.\n   */\n-  q=colormap;\n   q=colormap;\n   if (image->colors <= 256)\n     for (i=0; i < (ssize_t) image->colors; i++)\n@@ -73,9 +78,11 @@\n       *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].red) >> 8);\n       *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].red) & 0xff);\n       *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].green) >> 8);\n-      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].green) & 0xff);;\n+      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].green) &\n+        0xff);\n       *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].blue) >> 8);\n-      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].blue) & 0xff);\n+      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].blue) &\n+        0xff);\n     }\n   (void) WriteBlob(image,packet_size*image->colors,colormap);\n   colormap=(unsigned char *) RelinquishMagickMemory(colormap);",
        "diff_line_info": {
            "deleted_lines": [
                "    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "  q=colormap;",
                "      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].green) & 0xff);;",
                "      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].blue) & 0xff);"
            ],
            "added_lines": [
                "    {",
                "      if (colormap != (unsigned char *) NULL)",
                "        colormap=(unsigned char *) RelinquishMagickMemory(colormap);",
                "      if (pixels != (unsigned char *) NULL)",
                "        pixels=(unsigned char *) RelinquishMagickMemory(pixels);",
                "      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "    }",
                "      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].green) &",
                "        0xff);",
                "      *q++=(unsigned char) (ScaleQuantumToShort(image->colormap[i].blue) &",
                "        0xff);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12664",
        "func_name": "ImageMagick/SetGrayscaleImage",
        "description": "ImageMagick 7.0.6-2 has a memory leak vulnerability in WritePALMImage in coders/palm.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/0417cea1b6d72f90bd4f1f573f91e42a8ba66a89",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/574",
        "commit_text": "",
        "func_before": "static MagickBooleanType SetGrayscaleImage(Image *image,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    *colormap;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    *colormap_index,\n    j,\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->type != GrayscaleType)\n    (void) TransformImageColorspace(image,GRAYColorspace,exception);\n  colormap_index=(ssize_t *) AcquireQuantumMemory(MaxColormapSize,\n    sizeof(*colormap_index));\n  if (colormap_index == (ssize_t *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  if (image->storage_class != PseudoClass)\n    {\n      (void) ResetMagickMemory(colormap_index,(-1),MaxColormapSize*\n        sizeof(*colormap_index));\n      if (AcquireImageColormap(image,MaxColormapSize,exception) == MagickFalse)\n        ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n          image->filename);\n      image->colors=0;\n      status=MagickTrue;\n      image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,4) shared(status) \\\n        magick_threads(image,image,image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        register Quantum\n          *magick_restrict q;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          register size_t\n            intensity;\n\n          intensity=ScaleQuantumToMap(GetPixelRed(image,q));\n          if (colormap_index[intensity] < 0)\n            {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp critical (MagickCore_SetGrayscaleImage)\n#endif\n              if (colormap_index[intensity] < 0)\n                {\n                  colormap_index[intensity]=(ssize_t) image->colors;\n                  image->colormap[image->colors].red=(double)\n                    GetPixelRed(image,q);\n                  image->colormap[image->colors].green=(double)\n                    GetPixelGreen(image,q);\n                  image->colormap[image->colors].blue=(double)\n                    GetPixelBlue(image,q);\n                  image->colors++;\n               }\n            }\n          SetPixelIndex(image,(Quantum) colormap_index[intensity],q);\n          q+=GetPixelChannels(image);\n        }\n        if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n          status=MagickFalse;\n      }\n      image_view=DestroyCacheView(image_view);\n    }\n  for (i=0; i < (ssize_t) image->colors; i++)\n    image->colormap[i].alpha=(double) i;\n  qsort((void *) image->colormap,image->colors,sizeof(PixelInfo),\n    IntensityCompare);\n  colormap=(PixelInfo *) AcquireQuantumMemory(image->colors,sizeof(*colormap));\n  if (colormap == (PixelInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  j=0;\n  colormap[j]=image->colormap[0];\n  for (i=0; i < (ssize_t) image->colors; i++)\n  {\n    if (IsPixelInfoEquivalent(&colormap[j],&image->colormap[i]) == MagickFalse)\n      {\n        j++;\n        colormap[j]=image->colormap[i];\n      }\n    colormap_index[(ssize_t) image->colormap[i].alpha]=j;\n  }\n  image->colors=(size_t) (j+1);\n  image->colormap=(PixelInfo *) RelinquishMagickMemory(image->colormap);\n  image->colormap=colormap;\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelIndex(image,(Quantum) colormap_index[ScaleQuantumToMap(\n        GetPixelIndex(image,q))],q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  colormap_index=(ssize_t *) RelinquishMagickMemory(colormap_index);\n  image->type=GrayscaleType;\n  if (SetImageMonochrome(image,exception) != MagickFalse)\n    image->type=BilevelType;\n  return(status);\n}",
        "func": "static MagickBooleanType SetGrayscaleImage(Image *image,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    *colormap;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    *colormap_index,\n    j,\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->type != GrayscaleType)\n    (void) TransformImageColorspace(image,GRAYColorspace,exception);\n  colormap_index=(ssize_t *) AcquireQuantumMemory(MaxColormapSize,\n    sizeof(*colormap_index));\n  if (colormap_index == (ssize_t *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  if (image->storage_class != PseudoClass)\n    {\n      (void) ResetMagickMemory(colormap_index,(-1),MaxColormapSize*\n        sizeof(*colormap_index));\n      if (AcquireImageColormap(image,MaxColormapSize,exception) == MagickFalse)\n        {\n          colormap_index=(ssize_t *) RelinquishMagickMemory(colormap_index);\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        }\n      image->colors=0;\n      status=MagickTrue;\n      image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,4) shared(status) \\\n        magick_threads(image,image,image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        register Quantum\n          *magick_restrict q;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          register size_t\n            intensity;\n\n          intensity=ScaleQuantumToMap(GetPixelRed(image,q));\n          if (colormap_index[intensity] < 0)\n            {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp critical (MagickCore_SetGrayscaleImage)\n#endif\n              if (colormap_index[intensity] < 0)\n                {\n                  colormap_index[intensity]=(ssize_t) image->colors;\n                  image->colormap[image->colors].red=(double)\n                    GetPixelRed(image,q);\n                  image->colormap[image->colors].green=(double)\n                    GetPixelGreen(image,q);\n                  image->colormap[image->colors].blue=(double)\n                    GetPixelBlue(image,q);\n                  image->colors++;\n               }\n            }\n          SetPixelIndex(image,(Quantum) colormap_index[intensity],q);\n          q+=GetPixelChannels(image);\n        }\n        if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n          status=MagickFalse;\n      }\n      image_view=DestroyCacheView(image_view);\n    }\n  for (i=0; i < (ssize_t) image->colors; i++)\n    image->colormap[i].alpha=(double) i;\n  qsort((void *) image->colormap,image->colors,sizeof(PixelInfo),\n    IntensityCompare);\n  colormap=(PixelInfo *) AcquireQuantumMemory(image->colors,sizeof(*colormap));\n  if (colormap == (PixelInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  j=0;\n  colormap[j]=image->colormap[0];\n  for (i=0; i < (ssize_t) image->colors; i++)\n  {\n    if (IsPixelInfoEquivalent(&colormap[j],&image->colormap[i]) == MagickFalse)\n      {\n        j++;\n        colormap[j]=image->colormap[i];\n      }\n    colormap_index[(ssize_t) image->colormap[i].alpha]=j;\n  }\n  image->colors=(size_t) (j+1);\n  image->colormap=(PixelInfo *) RelinquishMagickMemory(image->colormap);\n  image->colormap=colormap;\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelIndex(image,(Quantum) colormap_index[ScaleQuantumToMap(\n        GetPixelIndex(image,q))],q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  colormap_index=(ssize_t *) RelinquishMagickMemory(colormap_index);\n  image->type=GrayscaleType;\n  if (SetImageMonochrome(image,exception) != MagickFalse)\n    image->type=BilevelType;\n  return(status);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,8 +32,11 @@\n       (void) ResetMagickMemory(colormap_index,(-1),MaxColormapSize*\n         sizeof(*colormap_index));\n       if (AcquireImageColormap(image,MaxColormapSize,exception) == MagickFalse)\n-        ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n-          image->filename);\n+        {\n+          colormap_index=(ssize_t *) RelinquishMagickMemory(colormap_index);\n+          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n+            image->filename);\n+        }\n       image->colors=0;\n       status=MagickTrue;\n       image_view=AcquireAuthenticCacheView(image,exception);",
        "diff_line_info": {
            "deleted_lines": [
                "        ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",",
                "          image->filename);"
            ],
            "added_lines": [
                "        {",
                "          colormap_index=(ssize_t *) RelinquishMagickMemory(colormap_index);",
                "          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",",
                "            image->filename);",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12664",
        "func_name": "ImageMagick/WritePALMImage",
        "description": "ImageMagick 7.0.6-2 has a memory leak vulnerability in WritePALMImage in coders/palm.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/0417cea1b6d72f90bd4f1f573f91e42a8ba66a89",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/574",
        "commit_text": "",
        "func_before": "static MagickBooleanType WritePALMImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    currentOffset,\n    offset,\n    scene;\n\n  MagickSizeType\n    cc;\n\n  PixelInfo\n    transpix;\n\n  QuantizeInfo\n    *quantize_info;\n\n  register ssize_t\n    x;\n\n  register const Quantum\n    *p;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    y;\n\n  size_t\n    count,\n    bits_per_pixel,\n    bytes_per_row,\n    nextDepthOffset,\n    one;\n\n  unsigned char\n    bit,\n    byte,\n    color,\n    *lastrow,\n    *one_row,\n    *ptr,\n    version;\n\n  unsigned int\n    transparentIndex;\n\n  unsigned short\n    color16,\n    flags;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  quantize_info=AcquireQuantizeInfo(image_info);\n  flags=0;\n  currentOffset=0;\n  transparentIndex=0;\n  transpix.red=0.0;\n  transpix.green=0.0;\n  transpix.blue=0.0;\n  transpix.alpha=0.0;\n  one=1;\n  version=0;\n  scene=0;\n  do\n  {\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    count=GetNumberColors(image,NULL,exception);\n    for (bits_per_pixel=1;  (one << bits_per_pixel) < count; bits_per_pixel*=2) ;\n    if (bits_per_pixel > 16)\n      bits_per_pixel=16;\n    else\n      if (bits_per_pixel < 16)\n        (void) TransformImageColorspace(image,image->colorspace,exception);\n    if (bits_per_pixel < 8)\n      {\n        (void) TransformImageColorspace(image,GRAYColorspace,exception);\n        (void) SetImageType(image,PaletteType,exception);\n        (void) SortColormapByIntensity(image,exception);\n      }\n    if ((image->storage_class == PseudoClass) && (image->colors > 256))\n      (void) SetImageStorageClass(image,DirectClass,exception);\n    if (image->storage_class == PseudoClass)\n      flags|=PALM_HAS_COLORMAP_FLAG;\n    else\n      flags|=PALM_IS_DIRECT_COLOR;\n    (void) WriteBlobMSBShort(image,(unsigned short) image->columns); /* width */\n    (void) WriteBlobMSBShort(image,(unsigned short) image->rows);  /* height */\n    bytes_per_row=((image->columns+(16/bits_per_pixel-1))/(16/\n      bits_per_pixel))*2;\n    (void) WriteBlobMSBShort(image,(unsigned short) bytes_per_row);\n    if ((image_info->compression == RLECompression) ||\n        (image_info->compression == FaxCompression))\n      flags|=PALM_IS_COMPRESSED_FLAG;\n    (void) WriteBlobMSBShort(image, flags);\n    (void) WriteBlobByte(image,(unsigned char) bits_per_pixel);\n    if (bits_per_pixel > 1)\n      version=1;\n    if ((image_info->compression == RLECompression) ||\n        (image_info->compression == FaxCompression))\n      version=2;\n    (void) WriteBlobByte(image,version);\n    (void) WriteBlobMSBShort(image,0);  /* nextDepthOffset */\n    (void) WriteBlobByte(image,(unsigned char) transparentIndex);\n    if (image_info->compression == RLECompression)\n      (void) WriteBlobByte(image,PALM_COMPRESSION_RLE);\n    else\n      if (image_info->compression == FaxCompression)\n        (void) WriteBlobByte(image,PALM_COMPRESSION_SCANLINE);\n      else\n        (void) WriteBlobByte(image,PALM_COMPRESSION_NONE);\n    (void) WriteBlobMSBShort(image,0);  /* reserved */\n    offset=16;\n    if (bits_per_pixel == 16)\n      {\n        (void) WriteBlobByte(image,5);  /* # of bits of red */\n        (void) WriteBlobByte(image,6);  /* # of bits of green */\n        (void) WriteBlobByte(image,5);  /* # of bits of blue */\n        (void) WriteBlobByte(image,0);  /* reserved by Palm */\n        (void) WriteBlobMSBLong(image,0);  /* no transparent color, YET */\n        offset+=8;\n      }\n    if (bits_per_pixel == 8)\n      {\n        if (flags & PALM_HAS_COLORMAP_FLAG)  /* Write out colormap */\n          {\n            quantize_info->dither_method=IdentifyPaletteImage(image,exception)\n              == MagickFalse ? RiemersmaDitherMethod : NoDitherMethod;\n            quantize_info->number_colors=image->colors;\n            (void) QuantizeImage(quantize_info,image,exception);\n            (void) WriteBlobMSBShort(image,(unsigned short) image->colors);\n            for (count = 0; count < image->colors; count++)\n            {\n              (void) WriteBlobByte(image,(unsigned char) count);\n              (void) WriteBlobByte(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[count].red)));\n              (void) WriteBlobByte(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[count].green)));\n              (void) WriteBlobByte(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[count].blue)));\n            }\n            offset+=2+count*4;\n          }\n      else  /* Map colors to Palm standard colormap */\n        {\n          Image\n            *affinity_image;\n\n          affinity_image=ConstituteImage(256,1,\"RGB\",CharPixel,&PalmPalette,\n            exception);\n          (void) TransformImageColorspace(affinity_image,\n            affinity_image->colorspace,exception);\n          (void) RemapImage(quantize_info,image,affinity_image,exception);\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(image,(Quantum) FindColor(&image->colormap[(ssize_t)\n                GetPixelIndex(image,q)]),q);\n              q+=GetPixelChannels(image);\n            }\n          }\n          affinity_image=DestroyImage(affinity_image);\n        }\n      }\n    if (flags & PALM_IS_COMPRESSED_FLAG)\n      (void) WriteBlobMSBShort(image,0);  /* fill in size later */\n    lastrow=(unsigned char *) NULL;\n    if (image_info->compression == FaxCompression)\n      lastrow=(unsigned char *) AcquireQuantumMemory(bytes_per_row,\n        sizeof(*lastrow));\n      /* TODO check whether memory really was acquired? */\n    one_row=(unsigned char *) AcquireQuantumMemory(bytes_per_row,\n      sizeof(*one_row));\n    if (one_row == (unsigned char *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      ptr=one_row;\n      (void) ResetMagickMemory(ptr,0,bytes_per_row);\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      if (bits_per_pixel == 16)\n        {\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            color16=(unsigned short) ((((31*(size_t) GetPixelRed(image,p))/\n              (size_t) QuantumRange) << 11) | (((63*(size_t)\n              GetPixelGreen(image,p))/(size_t) QuantumRange) << 5) |\n              ((31*(size_t) GetPixelBlue(image,p))/(size_t) QuantumRange));\n            if (GetPixelAlpha(image,p) == (Quantum) TransparentAlpha)\n              {\n                transpix.red=(MagickRealType) GetPixelRed(image,p);\n                transpix.green=(MagickRealType) GetPixelGreen(image,p);\n                transpix.blue=(MagickRealType) GetPixelBlue(image,p);\n                transpix.alpha=(MagickRealType) GetPixelAlpha(image,p);\n                flags|=PALM_HAS_TRANSPARENCY_FLAG;\n              }\n            *ptr++=(unsigned char) ((color16 >> 8) & 0xff);\n            *ptr++=(unsigned char) (color16 & 0xff);\n            p+=GetPixelChannels(image);\n          }\n        }\n      else\n        {\n          byte=0x00;\n          bit=(unsigned char) (8-bits_per_pixel);\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (bits_per_pixel >= 8)\n              color=(unsigned char) GetPixelIndex(image,p);\n            else\n              color=(unsigned char) (GetPixelIndex(image,p)*\n                ((one << bits_per_pixel)-1)/MagickMax(1*image->colors-1,1));\n            byte|=color << bit;\n            if (bit != 0)\n              bit-=(unsigned char) bits_per_pixel;\n            else\n              {\n                *ptr++=byte;\n                byte=0x00;\n                bit=(unsigned char) (8-bits_per_pixel);\n              }\n            p+=GetPixelChannels(image);\n          }\n          if ((image->columns % (8/bits_per_pixel)) != 0)\n            *ptr++=byte;\n        }\n      if (image_info->compression == RLECompression)\n        {\n          x=0;\n          while (x < (ssize_t) bytes_per_row)\n          {\n            byte=one_row[x];\n            count=1;\n            while ((one_row[++x] == byte) && (count < 255) &&\n                   (x < (ssize_t) bytes_per_row))\n              count++;\n            (void) WriteBlobByte(image,(unsigned char) count);\n            (void) WriteBlobByte(image,(unsigned char) byte);\n          }\n        }\n      else\n        if (image_info->compression == FaxCompression)\n          {\n            char\n              tmpbuf[8],\n              *tptr;\n  \n            for (x = 0;  x < (ssize_t) bytes_per_row;  x += 8)\n            {\n              tptr = tmpbuf;\n              for (bit=0, byte=0; bit < (unsigned char) MagickMin(8,(ssize_t) bytes_per_row-x); bit++)\n              {\n                if ((y == 0) || (lastrow[x + bit] != one_row[x + bit]))\n                  {\n                    byte |= (1 << (7 - bit));\n                    *tptr++ = (char) one_row[x + bit];\n                  }\n              }\n              (void) WriteBlobByte(image, byte);\n              (void) WriteBlob(image,tptr-tmpbuf,(unsigned char *) tmpbuf);\n            }\n            (void) CopyMagickMemory(lastrow,one_row,bytes_per_row);\n          }\n        else\n          (void) WriteBlob(image,bytes_per_row,one_row);\n      }\n    if (flags & PALM_HAS_TRANSPARENCY_FLAG)\n      {\n        offset=SeekBlob(image,currentOffset+6,SEEK_SET);\n        (void) WriteBlobMSBShort(image,flags);\n        offset=SeekBlob(image,currentOffset+12,SEEK_SET);\n        (void) WriteBlobByte(image,(unsigned char) transparentIndex);  /* trans index */\n      }\n    if (bits_per_pixel == 16)\n      {\n        offset=SeekBlob(image,currentOffset+20,SEEK_SET);\n        (void) WriteBlobByte(image,0);  /* reserved by Palm */\n        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.red)/QuantumRange));\n        (void) WriteBlobByte(image,(unsigned char) ((63*transpix.green)/QuantumRange));\n        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.blue)/QuantumRange));\n      }\n    if (flags & PALM_IS_COMPRESSED_FLAG)  /* fill in size now */\n      {\n        offset=SeekBlob(image,currentOffset+offset,SEEK_SET);\n        (void) WriteBlobMSBShort(image,(unsigned short) (GetBlobSize(image)-\n          currentOffset-offset));\n      }\n    if (one_row != (unsigned char *) NULL) \n      one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n    if (lastrow != (unsigned char *) NULL) \n      lastrow=(unsigned char *) RelinquishMagickMemory(lastrow);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    /* padding to 4 byte word */\n    for (cc=(GetBlobSize(image)) % 4; cc > 0; cc--)\n      (void) WriteBlobByte(image,0);\n    /* write nextDepthOffset and return to end of image */\n    offset=SeekBlob(image,currentOffset+10,SEEK_SET);\n    nextDepthOffset=(size_t) ((GetBlobSize(image)-currentOffset)/4);\n    (void) WriteBlobMSBShort(image,(unsigned short) nextDepthOffset);\n    currentOffset=(MagickOffsetType) GetBlobSize(image);\n    offset=SeekBlob(image,currentOffset,SEEK_SET);\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  quantize_info=DestroyQuantizeInfo(quantize_info);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
        "func": "static MagickBooleanType WritePALMImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    currentOffset,\n    offset,\n    scene;\n\n  MagickSizeType\n    cc;\n\n  PixelInfo\n    transpix;\n\n  QuantizeInfo\n    *quantize_info;\n\n  register ssize_t\n    x;\n\n  register const Quantum\n    *p;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    y;\n\n  size_t\n    count,\n    bits_per_pixel,\n    bytes_per_row,\n    nextDepthOffset,\n    one;\n\n  unsigned char\n    bit,\n    byte,\n    color,\n    *last_row,\n    *one_row,\n    *ptr,\n    version;\n\n  unsigned int\n    transparentIndex;\n\n  unsigned short\n    color16,\n    flags;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  quantize_info=AcquireQuantizeInfo(image_info);\n  flags=0;\n  currentOffset=0;\n  transparentIndex=0;\n  transpix.red=0.0;\n  transpix.green=0.0;\n  transpix.blue=0.0;\n  transpix.alpha=0.0;\n  one=1;\n  version=0;\n  scene=0;\n  do\n  {\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    count=GetNumberColors(image,NULL,exception);\n    for (bits_per_pixel=1;  (one << bits_per_pixel) < count; bits_per_pixel*=2) ;\n    if (bits_per_pixel > 16)\n      bits_per_pixel=16;\n    else\n      if (bits_per_pixel < 16)\n        (void) TransformImageColorspace(image,image->colorspace,exception);\n    if (bits_per_pixel < 8)\n      {\n        (void) TransformImageColorspace(image,GRAYColorspace,exception);\n        (void) SetImageType(image,PaletteType,exception);\n        (void) SortColormapByIntensity(image,exception);\n      }\n    if ((image->storage_class == PseudoClass) && (image->colors > 256))\n      (void) SetImageStorageClass(image,DirectClass,exception);\n    if (image->storage_class == PseudoClass)\n      flags|=PALM_HAS_COLORMAP_FLAG;\n    else\n      flags|=PALM_IS_DIRECT_COLOR;\n    (void) WriteBlobMSBShort(image,(unsigned short) image->columns); /* width */\n    (void) WriteBlobMSBShort(image,(unsigned short) image->rows);  /* height */\n    bytes_per_row=((image->columns+(16/bits_per_pixel-1))/(16/\n      bits_per_pixel))*2;\n    (void) WriteBlobMSBShort(image,(unsigned short) bytes_per_row);\n    if ((image_info->compression == RLECompression) ||\n        (image_info->compression == FaxCompression))\n      flags|=PALM_IS_COMPRESSED_FLAG;\n    (void) WriteBlobMSBShort(image, flags);\n    (void) WriteBlobByte(image,(unsigned char) bits_per_pixel);\n    if (bits_per_pixel > 1)\n      version=1;\n    if ((image_info->compression == RLECompression) ||\n        (image_info->compression == FaxCompression))\n      version=2;\n    (void) WriteBlobByte(image,version);\n    (void) WriteBlobMSBShort(image,0);  /* nextDepthOffset */\n    (void) WriteBlobByte(image,(unsigned char) transparentIndex);\n    if (image_info->compression == RLECompression)\n      (void) WriteBlobByte(image,PALM_COMPRESSION_RLE);\n    else\n      if (image_info->compression == FaxCompression)\n        (void) WriteBlobByte(image,PALM_COMPRESSION_SCANLINE);\n      else\n        (void) WriteBlobByte(image,PALM_COMPRESSION_NONE);\n    (void) WriteBlobMSBShort(image,0);  /* reserved */\n    offset=16;\n    if (bits_per_pixel == 16)\n      {\n        (void) WriteBlobByte(image,5);  /* # of bits of red */\n        (void) WriteBlobByte(image,6);  /* # of bits of green */\n        (void) WriteBlobByte(image,5);  /* # of bits of blue */\n        (void) WriteBlobByte(image,0);  /* reserved by Palm */\n        (void) WriteBlobMSBLong(image,0);  /* no transparent color, YET */\n        offset+=8;\n      }\n    if (bits_per_pixel == 8)\n      {\n        if (flags & PALM_HAS_COLORMAP_FLAG)  /* Write out colormap */\n          {\n            quantize_info->dither_method=IdentifyPaletteImage(image,exception)\n              == MagickFalse ? RiemersmaDitherMethod : NoDitherMethod;\n            quantize_info->number_colors=image->colors;\n            (void) QuantizeImage(quantize_info,image,exception);\n            (void) WriteBlobMSBShort(image,(unsigned short) image->colors);\n            for (count = 0; count < image->colors; count++)\n            {\n              (void) WriteBlobByte(image,(unsigned char) count);\n              (void) WriteBlobByte(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[count].red)));\n              (void) WriteBlobByte(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[count].green)));\n              (void) WriteBlobByte(image,ScaleQuantumToChar(ClampToQuantum(\n                image->colormap[count].blue)));\n            }\n            offset+=2+count*4;\n          }\n      else  /* Map colors to Palm standard colormap */\n        {\n          Image\n            *affinity_image;\n\n          affinity_image=ConstituteImage(256,1,\"RGB\",CharPixel,&PalmPalette,\n            exception);\n          (void) TransformImageColorspace(affinity_image,\n            affinity_image->colorspace,exception);\n          (void) RemapImage(quantize_info,image,affinity_image,exception);\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelIndex(image,(Quantum) FindColor(&image->colormap[(ssize_t)\n                GetPixelIndex(image,q)]),q);\n              q+=GetPixelChannels(image);\n            }\n          }\n          affinity_image=DestroyImage(affinity_image);\n        }\n      }\n    if (flags & PALM_IS_COMPRESSED_FLAG)\n      (void) WriteBlobMSBShort(image,0);  /* fill in size later */\n    last_row=(unsigned char *) NULL;\n    if (image_info->compression == FaxCompression)\n      {\n        last_row=(unsigned char *) AcquireQuantumMemory(bytes_per_row,\n          sizeof(*last_row));\n        if (last_row == (unsigned char *) NULL)\n          {\n            quantize_info=DestroyQuantizeInfo(quantize_info);\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n      }\n    one_row=(unsigned char *) AcquireQuantumMemory(bytes_per_row,\n      sizeof(*one_row));\n    if (one_row == (unsigned char *) NULL)\n      {\n        quantize_info=DestroyQuantizeInfo(quantize_info);\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      ptr=one_row;\n      (void) ResetMagickMemory(ptr,0,bytes_per_row);\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      if (bits_per_pixel == 16)\n        {\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            color16=(unsigned short) ((((31*(size_t) GetPixelRed(image,p))/\n              (size_t) QuantumRange) << 11) | (((63*(size_t)\n              GetPixelGreen(image,p))/(size_t) QuantumRange) << 5) |\n              ((31*(size_t) GetPixelBlue(image,p))/(size_t) QuantumRange));\n            if (GetPixelAlpha(image,p) == (Quantum) TransparentAlpha)\n              {\n                transpix.red=(MagickRealType) GetPixelRed(image,p);\n                transpix.green=(MagickRealType) GetPixelGreen(image,p);\n                transpix.blue=(MagickRealType) GetPixelBlue(image,p);\n                transpix.alpha=(MagickRealType) GetPixelAlpha(image,p);\n                flags|=PALM_HAS_TRANSPARENCY_FLAG;\n              }\n            *ptr++=(unsigned char) ((color16 >> 8) & 0xff);\n            *ptr++=(unsigned char) (color16 & 0xff);\n            p+=GetPixelChannels(image);\n          }\n        }\n      else\n        {\n          byte=0x00;\n          bit=(unsigned char) (8-bits_per_pixel);\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (bits_per_pixel >= 8)\n              color=(unsigned char) GetPixelIndex(image,p);\n            else\n              color=(unsigned char) (GetPixelIndex(image,p)*\n                ((one << bits_per_pixel)-1)/MagickMax(1*image->colors-1,1));\n            byte|=color << bit;\n            if (bit != 0)\n              bit-=(unsigned char) bits_per_pixel;\n            else\n              {\n                *ptr++=byte;\n                byte=0x00;\n                bit=(unsigned char) (8-bits_per_pixel);\n              }\n            p+=GetPixelChannels(image);\n          }\n          if ((image->columns % (8/bits_per_pixel)) != 0)\n            *ptr++=byte;\n        }\n      if (image_info->compression == RLECompression)\n        {\n          x=0;\n          while (x < (ssize_t) bytes_per_row)\n          {\n            byte=one_row[x];\n            count=1;\n            while ((one_row[++x] == byte) && (count < 255) &&\n                   (x < (ssize_t) bytes_per_row))\n              count++;\n            (void) WriteBlobByte(image,(unsigned char) count);\n            (void) WriteBlobByte(image,(unsigned char) byte);\n          }\n        }\n      else\n        if (image_info->compression == FaxCompression)\n          {\n            char\n              tmpbuf[8],\n              *tptr;\n  \n            for (x = 0;  x < (ssize_t) bytes_per_row;  x += 8)\n            {\n              tptr = tmpbuf;\n              for (bit=0, byte=0; bit < (unsigned char) MagickMin(8,(ssize_t) bytes_per_row-x); bit++)\n              {\n                if ((y == 0) || (last_row[x + bit] != one_row[x + bit]))\n                  {\n                    byte |= (1 << (7 - bit));\n                    *tptr++ = (char) one_row[x + bit];\n                  }\n              }\n              (void) WriteBlobByte(image, byte);\n              (void) WriteBlob(image,tptr-tmpbuf,(unsigned char *) tmpbuf);\n            }\n            (void) CopyMagickMemory(last_row,one_row,bytes_per_row);\n          }\n        else\n          (void) WriteBlob(image,bytes_per_row,one_row);\n      }\n    if (flags & PALM_HAS_TRANSPARENCY_FLAG)\n      {\n        offset=SeekBlob(image,currentOffset+6,SEEK_SET);\n        (void) WriteBlobMSBShort(image,flags);\n        offset=SeekBlob(image,currentOffset+12,SEEK_SET);\n        (void) WriteBlobByte(image,(unsigned char) transparentIndex);  /* trans index */\n      }\n    if (bits_per_pixel == 16)\n      {\n        offset=SeekBlob(image,currentOffset+20,SEEK_SET);\n        (void) WriteBlobByte(image,0);  /* reserved by Palm */\n        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.red)/\n          QuantumRange));\n        (void) WriteBlobByte(image,(unsigned char) ((63*transpix.green)/\n          QuantumRange));\n        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.blue)/\n          QuantumRange));\n      }\n    if (flags & PALM_IS_COMPRESSED_FLAG)  /* fill in size now */\n      {\n        offset=SeekBlob(image,currentOffset+offset,SEEK_SET);\n        (void) WriteBlobMSBShort(image,(unsigned short) (GetBlobSize(image)-\n          currentOffset-offset));\n      }\n    if (one_row != (unsigned char *) NULL) \n      one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n    if (last_row != (unsigned char *) NULL) \n      last_row=(unsigned char *) RelinquishMagickMemory(last_row);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    /* padding to 4 byte word */\n    for (cc=(GetBlobSize(image)) % 4; cc > 0; cc--)\n      (void) WriteBlobByte(image,0);\n    /* write nextDepthOffset and return to end of image */\n    offset=SeekBlob(image,currentOffset+10,SEEK_SET);\n    nextDepthOffset=(size_t) ((GetBlobSize(image)-currentOffset)/4);\n    (void) WriteBlobMSBShort(image,(unsigned short) nextDepthOffset);\n    currentOffset=(MagickOffsetType) GetBlobSize(image);\n    offset=SeekBlob(image,currentOffset,SEEK_SET);\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  quantize_info=DestroyQuantizeInfo(quantize_info);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -41,7 +41,7 @@\n     bit,\n     byte,\n     color,\n-    *lastrow,\n+    *last_row,\n     *one_row,\n     *ptr,\n     version;\n@@ -184,15 +184,24 @@\n       }\n     if (flags & PALM_IS_COMPRESSED_FLAG)\n       (void) WriteBlobMSBShort(image,0);  /* fill in size later */\n-    lastrow=(unsigned char *) NULL;\n+    last_row=(unsigned char *) NULL;\n     if (image_info->compression == FaxCompression)\n-      lastrow=(unsigned char *) AcquireQuantumMemory(bytes_per_row,\n-        sizeof(*lastrow));\n-      /* TODO check whether memory really was acquired? */\n+      {\n+        last_row=(unsigned char *) AcquireQuantumMemory(bytes_per_row,\n+          sizeof(*last_row));\n+        if (last_row == (unsigned char *) NULL)\n+          {\n+            quantize_info=DestroyQuantizeInfo(quantize_info);\n+            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n+          }\n+      }\n     one_row=(unsigned char *) AcquireQuantumMemory(bytes_per_row,\n       sizeof(*one_row));\n     if (one_row == (unsigned char *) NULL)\n-      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n+      {\n+        quantize_info=DestroyQuantizeInfo(quantize_info);\n+        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n+      }\n     for (y=0; y < (ssize_t) image->rows; y++)\n     {\n       ptr=one_row;\n@@ -272,7 +281,7 @@\n               tptr = tmpbuf;\n               for (bit=0, byte=0; bit < (unsigned char) MagickMin(8,(ssize_t) bytes_per_row-x); bit++)\n               {\n-                if ((y == 0) || (lastrow[x + bit] != one_row[x + bit]))\n+                if ((y == 0) || (last_row[x + bit] != one_row[x + bit]))\n                   {\n                     byte |= (1 << (7 - bit));\n                     *tptr++ = (char) one_row[x + bit];\n@@ -281,7 +290,7 @@\n               (void) WriteBlobByte(image, byte);\n               (void) WriteBlob(image,tptr-tmpbuf,(unsigned char *) tmpbuf);\n             }\n-            (void) CopyMagickMemory(lastrow,one_row,bytes_per_row);\n+            (void) CopyMagickMemory(last_row,one_row,bytes_per_row);\n           }\n         else\n           (void) WriteBlob(image,bytes_per_row,one_row);\n@@ -297,9 +306,12 @@\n       {\n         offset=SeekBlob(image,currentOffset+20,SEEK_SET);\n         (void) WriteBlobByte(image,0);  /* reserved by Palm */\n-        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.red)/QuantumRange));\n-        (void) WriteBlobByte(image,(unsigned char) ((63*transpix.green)/QuantumRange));\n-        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.blue)/QuantumRange));\n+        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.red)/\n+          QuantumRange));\n+        (void) WriteBlobByte(image,(unsigned char) ((63*transpix.green)/\n+          QuantumRange));\n+        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.blue)/\n+          QuantumRange));\n       }\n     if (flags & PALM_IS_COMPRESSED_FLAG)  /* fill in size now */\n       {\n@@ -309,8 +321,8 @@\n       }\n     if (one_row != (unsigned char *) NULL) \n       one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n-    if (lastrow != (unsigned char *) NULL) \n-      lastrow=(unsigned char *) RelinquishMagickMemory(lastrow);\n+    if (last_row != (unsigned char *) NULL) \n+      last_row=(unsigned char *) RelinquishMagickMemory(last_row);\n     if (GetNextImageInList(image) == (Image *) NULL)\n       break;\n     /* padding to 4 byte word */",
        "diff_line_info": {
            "deleted_lines": [
                "    *lastrow,",
                "    lastrow=(unsigned char *) NULL;",
                "      lastrow=(unsigned char *) AcquireQuantumMemory(bytes_per_row,",
                "        sizeof(*lastrow));",
                "      /* TODO check whether memory really was acquired? */",
                "      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "                if ((y == 0) || (lastrow[x + bit] != one_row[x + bit]))",
                "            (void) CopyMagickMemory(lastrow,one_row,bytes_per_row);",
                "        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.red)/QuantumRange));",
                "        (void) WriteBlobByte(image,(unsigned char) ((63*transpix.green)/QuantumRange));",
                "        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.blue)/QuantumRange));",
                "    if (lastrow != (unsigned char *) NULL) ",
                "      lastrow=(unsigned char *) RelinquishMagickMemory(lastrow);"
            ],
            "added_lines": [
                "    *last_row,",
                "    last_row=(unsigned char *) NULL;",
                "      {",
                "        last_row=(unsigned char *) AcquireQuantumMemory(bytes_per_row,",
                "          sizeof(*last_row));",
                "        if (last_row == (unsigned char *) NULL)",
                "          {",
                "            quantize_info=DestroyQuantizeInfo(quantize_info);",
                "            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "          }",
                "      }",
                "      {",
                "        quantize_info=DestroyQuantizeInfo(quantize_info);",
                "        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "      }",
                "                if ((y == 0) || (last_row[x + bit] != one_row[x + bit]))",
                "            (void) CopyMagickMemory(last_row,one_row,bytes_per_row);",
                "        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.red)/",
                "          QuantumRange));",
                "        (void) WriteBlobByte(image,(unsigned char) ((63*transpix.green)/",
                "          QuantumRange));",
                "        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.blue)/",
                "          QuantumRange));",
                "    if (last_row != (unsigned char *) NULL) ",
                "      last_row=(unsigned char *) RelinquishMagickMemory(last_row);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12664",
        "func_name": "ImageMagick/ReadPALMImage",
        "description": "ImageMagick 7.0.6-2 has a memory leak vulnerability in WritePALMImage in coders/palm.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/0417cea1b6d72f90bd4f1f573f91e42a8ba66a89",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/574",
        "commit_text": "",
        "func_before": "static Image *ReadPALMImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    totalOffset,\n    seekNextDepth;\n\n  PixelInfo\n    transpix;\n\n  Quantum\n    index;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  size_t\n    bytes_per_row,\n    flags,\n    bits_per_pixel,\n    version,\n    nextDepthOffset,\n    transparentIndex,\n    compressionType,\n    byte,\n    mask,\n    redbits,\n    greenbits,\n    bluebits,\n    one,\n    pad,\n    size,\n    bit;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *lastrow,\n    *one_row,\n    *ptr;\n\n  unsigned short\n    color16;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      (void) DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  totalOffset=0;\n  do\n  {\n    image->columns=ReadBlobMSBShort(image);\n    image->rows=ReadBlobMSBShort(image);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((image->columns == 0) || (image->rows == 0))\n      ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    bytes_per_row=ReadBlobMSBShort(image);\n    flags=ReadBlobMSBShort(image);\n    bits_per_pixel=(size_t) ReadBlobByte(image);\n    if ((bits_per_pixel != 1) && (bits_per_pixel != 2) &&\n        (bits_per_pixel != 4) && (bits_per_pixel != 8) &&\n        (bits_per_pixel != 16))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n    version=(size_t) ReadBlobByte(image);\n    if ((version != 0) && (version != 1) && (version != 2))\n      ThrowReaderException(CorruptImageError,\"FileFormatVersionMismatch\");\n    nextDepthOffset=(size_t) ReadBlobMSBShort(image);\n    transparentIndex=(size_t) ReadBlobByte(image);\n    compressionType=(size_t) ReadBlobByte(image);\n    if ((compressionType != PALM_COMPRESSION_NONE) &&\n        (compressionType != PALM_COMPRESSION_SCANLINE ) &&\n        (compressionType != PALM_COMPRESSION_RLE))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n    pad=ReadBlobMSBShort(image);\n    (void) pad;\n    /*\n      Initialize image colormap.\n    */\n    one=1;\n    if ((bits_per_pixel < 16) &&\n        (AcquireImageColormap(image,one << bits_per_pixel,exception) == MagickFalse))\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    GetPixelInfo(image,&transpix);\n    if (bits_per_pixel == 16)  /* Direct Color */\n      {\n        redbits=(size_t) ReadBlobByte(image);  /* # of bits of red */\n        (void) redbits;\n        greenbits=(size_t) ReadBlobByte(image);  /* # of bits of green */\n        (void) greenbits;\n        bluebits=(size_t) ReadBlobByte(image);  /* # of bits of blue */\n        (void) bluebits;\n        ReadBlobByte(image);  /* reserved by Palm */\n        ReadBlobByte(image);  /* reserved by Palm */\n        transpix.red=(double) (QuantumRange*ReadBlobByte(image)/31);\n        transpix.green=(double) (QuantumRange*ReadBlobByte(image)/63);\n        transpix.blue=(double) (QuantumRange*ReadBlobByte(image)/31);\n      }\n    if (bits_per_pixel == 8)\n      {\n        ssize_t\n          index;\n\n        if (flags & PALM_HAS_COLORMAP_FLAG)\n          {\n            count=(ssize_t) ReadBlobMSBShort(image);\n            for (i=0; i < (ssize_t) count; i++)\n            {\n              ReadBlobByte(image);\n              index=ConstrainColormapIndex(image,255-i,exception);\n              image->colormap[index].red=(MagickRealType)\n                ScaleCharToQuantum((unsigned char) ReadBlobByte(image));\n              image->colormap[index].green=(MagickRealType)\n                ScaleCharToQuantum((unsigned char) ReadBlobByte(image));\n              image->colormap[index].blue=(MagickRealType)\n                ScaleCharToQuantum((unsigned char) ReadBlobByte(image));\n          }\n        }\n      else\n        for (i=0; i < (ssize_t) (1L << bits_per_pixel); i++)\n        {\n          index=ConstrainColormapIndex(image,255-i,exception);\n          image->colormap[index].red=(MagickRealType)\n            ScaleCharToQuantum(PalmPalette[i][0]);\n          image->colormap[index].green=(MagickRealType)\n            ScaleCharToQuantum(PalmPalette[i][1]);\n          image->colormap[index].blue=(MagickRealType)\n            ScaleCharToQuantum(PalmPalette[i][2]);\n        }\n      }\n    if (flags & PALM_IS_COMPRESSED_FLAG)\n      size=ReadBlobMSBShort(image);\n    (void) size;\n    image->storage_class=DirectClass;\n    if (bits_per_pixel < 16)\n      {\n        image->storage_class=PseudoClass;\n        image->depth=8;\n      }\n    if (image_info->ping != MagickFalse)\n      {\n        (void) CloseBlob(image);\n        return(image);\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    one_row=(unsigned char *) AcquireQuantumMemory(MagickMax(bytes_per_row,\n      2*image->columns),sizeof(*one_row));\n    if (one_row == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    lastrow=(unsigned char *) NULL;\n    if (compressionType == PALM_COMPRESSION_SCANLINE)\n      {\n        lastrow=(unsigned char *) AcquireQuantumMemory(MagickMax(bytes_per_row,\n          2*image->columns),sizeof(*lastrow));\n        if (lastrow == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    mask=(size_t) (1U << bits_per_pixel)-1;\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      if ((flags & PALM_IS_COMPRESSED_FLAG) == 0)\n        {\n          /* TODO move out of loop! */\n          image->compression=NoCompression;\n          count=ReadBlob(image,bytes_per_row,one_row);\n          if (count != (ssize_t) bytes_per_row)\n            break;\n        }\n      else\n        {\n          if (compressionType == PALM_COMPRESSION_RLE)\n            { \n              /* TODO move out of loop! */\n              image->compression=RLECompression;\n              for (i=0; i < (ssize_t) bytes_per_row; )\n              {\n                count=(ssize_t) ReadBlobByte(image);\n                if (count < 0)\n                  break;\n                count=MagickMin(count,(ssize_t) bytes_per_row-i);\n                byte=(size_t) ReadBlobByte(image);\n                (void) ResetMagickMemory(one_row+i,(int) byte,(size_t) count);\n                i+=count;\n              }\n          }\n        else\n          if (compressionType == PALM_COMPRESSION_SCANLINE)\n            {\n              size_t\n                one;\n\n              /* TODO move out of loop! */\n              one=1;\n              image->compression=FaxCompression;\n              for (i=0; i < (ssize_t) bytes_per_row; i+=8)\n              {\n                count=(ssize_t) ReadBlobByte(image);\n                if (count < 0)\n                  break;\n                byte=(size_t) MagickMin((ssize_t) bytes_per_row-i,8);\n                for (bit=0; bit < byte; bit++)\n                {\n                  if ((y == 0) || (count & (one << (7 - bit))))\n                    one_row[i+bit]=(unsigned char) ReadBlobByte(image);\n                  else\n                    one_row[i+bit]=lastrow[i+bit];\n                }\n              }\n              (void) CopyMagickMemory(lastrow, one_row, bytes_per_row);\n            }\n        }\n      ptr=one_row;\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (Quantum *) NULL)\n        break;\n      if (bits_per_pixel == 16)\n        {\n          if (image->columns > (2*bytes_per_row))\n            {\n              one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n              if (compressionType == PALM_COMPRESSION_SCANLINE)\n                lastrow=(unsigned char *) RelinquishMagickMemory(lastrow);\n              ThrowReaderException(CorruptImageError,\"CorruptImage\");\n            }\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            color16=(*ptr++ << 8);\n            color16|=(*ptr++);\n            SetPixelRed(image,(Quantum) ((QuantumRange*((color16 >> 11) &\n              0x1f))/0x1f),q);\n            SetPixelGreen(image,(Quantum) ((QuantumRange*((color16 >> 5) &\n              0x3f))/0x3f),q);\n            SetPixelBlue(image,(Quantum) ((QuantumRange*((color16 >> 0) &\n              0x1f))/0x1f),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            q+=GetPixelChannels(image);\n          }\n        }\n      else\n        {\n          bit=8-bits_per_pixel;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if ((size_t) (ptr-one_row) >= bytes_per_row)\n              {\n                one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n                if (compressionType == PALM_COMPRESSION_SCANLINE)\n                  lastrow=(unsigned char *) RelinquishMagickMemory(lastrow);\n                ThrowReaderException(CorruptImageError,\"CorruptImage\");\n              }\n            index=(Quantum) (mask-(((*ptr) & (mask << bit)) >> bit));\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            if (bit)\n              bit-=bits_per_pixel;\n            else\n              {\n                ptr++;\n                bit=8-bits_per_pixel;\n              }\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n    if (flags & PALM_HAS_TRANSPARENCY_FLAG)\n      {\n        ssize_t index=ConstrainColormapIndex(image,(ssize_t) (mask-\n          transparentIndex),exception);\n        if (bits_per_pixel != 16)\n          transpix=image->colormap[index];\n        (void) TransparentPaintImage(image,&transpix,(Quantum) TransparentAlpha,\n          MagickFalse,exception);\n      }\n    one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n    if (compressionType == PALM_COMPRESSION_SCANLINE)\n      lastrow=(unsigned char *) RelinquishMagickMemory(lastrow);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image. Copied from coders/pnm.c\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (nextDepthOffset != 0)\n      { \n        /*\n          Skip to next image. \n        */\n        totalOffset+=(MagickOffsetType) (nextDepthOffset*4);\n        if (totalOffset >= (MagickOffsetType) GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n        else\n          seekNextDepth=SeekBlob(image,totalOffset,SEEK_SET);\n        if (seekNextDepth != totalOffset)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        /*\n          Allocate next image structure. Copied from coders/pnm.c\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            (void) DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (nextDepthOffset != 0);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadPALMImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    totalOffset,\n    seekNextDepth;\n\n  PixelInfo\n    transpix;\n\n  Quantum\n    index;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  size_t\n    bytes_per_row,\n    flags,\n    bits_per_pixel,\n    version,\n    nextDepthOffset,\n    transparentIndex,\n    compressionType,\n    byte,\n    mask,\n    redbits,\n    greenbits,\n    bluebits,\n    one,\n    pad,\n    size,\n    bit;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *last_row,\n    *one_row,\n    *ptr;\n\n  unsigned short\n    color16;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      (void) DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  totalOffset=0;\n  do\n  {\n    image->columns=ReadBlobMSBShort(image);\n    image->rows=ReadBlobMSBShort(image);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((image->columns == 0) || (image->rows == 0))\n      ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    bytes_per_row=ReadBlobMSBShort(image);\n    flags=ReadBlobMSBShort(image);\n    bits_per_pixel=(size_t) ReadBlobByte(image);\n    if ((bits_per_pixel != 1) && (bits_per_pixel != 2) &&\n        (bits_per_pixel != 4) && (bits_per_pixel != 8) &&\n        (bits_per_pixel != 16))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedBitsPerPixel\");\n    version=(size_t) ReadBlobByte(image);\n    if ((version != 0) && (version != 1) && (version != 2))\n      ThrowReaderException(CorruptImageError,\"FileFormatVersionMismatch\");\n    nextDepthOffset=(size_t) ReadBlobMSBShort(image);\n    transparentIndex=(size_t) ReadBlobByte(image);\n    compressionType=(size_t) ReadBlobByte(image);\n    if ((compressionType != PALM_COMPRESSION_NONE) &&\n        (compressionType != PALM_COMPRESSION_SCANLINE ) &&\n        (compressionType != PALM_COMPRESSION_RLE))\n      ThrowReaderException(CorruptImageError,\"UnrecognizedImageCompression\");\n    pad=ReadBlobMSBShort(image);\n    (void) pad;\n    /*\n      Initialize image colormap.\n    */\n    one=1;\n    if ((bits_per_pixel < 16) &&\n        (AcquireImageColormap(image,one << bits_per_pixel,exception) == MagickFalse))\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    GetPixelInfo(image,&transpix);\n    if (bits_per_pixel == 16)  /* Direct Color */\n      {\n        redbits=(size_t) ReadBlobByte(image);  /* # of bits of red */\n        (void) redbits;\n        greenbits=(size_t) ReadBlobByte(image);  /* # of bits of green */\n        (void) greenbits;\n        bluebits=(size_t) ReadBlobByte(image);  /* # of bits of blue */\n        (void) bluebits;\n        ReadBlobByte(image);  /* reserved by Palm */\n        ReadBlobByte(image);  /* reserved by Palm */\n        transpix.red=(double) (QuantumRange*ReadBlobByte(image)/31);\n        transpix.green=(double) (QuantumRange*ReadBlobByte(image)/63);\n        transpix.blue=(double) (QuantumRange*ReadBlobByte(image)/31);\n      }\n    if (bits_per_pixel == 8)\n      {\n        ssize_t\n          index;\n\n        if (flags & PALM_HAS_COLORMAP_FLAG)\n          {\n            count=(ssize_t) ReadBlobMSBShort(image);\n            for (i=0; i < (ssize_t) count; i++)\n            {\n              ReadBlobByte(image);\n              index=ConstrainColormapIndex(image,255-i,exception);\n              image->colormap[index].red=(MagickRealType)\n                ScaleCharToQuantum((unsigned char) ReadBlobByte(image));\n              image->colormap[index].green=(MagickRealType)\n                ScaleCharToQuantum((unsigned char) ReadBlobByte(image));\n              image->colormap[index].blue=(MagickRealType)\n                ScaleCharToQuantum((unsigned char) ReadBlobByte(image));\n          }\n        }\n      else\n        for (i=0; i < (ssize_t) (1L << bits_per_pixel); i++)\n        {\n          index=ConstrainColormapIndex(image,255-i,exception);\n          image->colormap[index].red=(MagickRealType)\n            ScaleCharToQuantum(PalmPalette[i][0]);\n          image->colormap[index].green=(MagickRealType)\n            ScaleCharToQuantum(PalmPalette[i][1]);\n          image->colormap[index].blue=(MagickRealType)\n            ScaleCharToQuantum(PalmPalette[i][2]);\n        }\n      }\n    if (flags & PALM_IS_COMPRESSED_FLAG)\n      size=ReadBlobMSBShort(image);\n    (void) size;\n    image->storage_class=DirectClass;\n    if (bits_per_pixel < 16)\n      {\n        image->storage_class=PseudoClass;\n        image->depth=8;\n      }\n    if (image_info->ping != MagickFalse)\n      {\n        (void) CloseBlob(image);\n        return(image);\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    one_row=(unsigned char *) AcquireQuantumMemory(MagickMax(bytes_per_row,\n      2*image->columns),sizeof(*one_row));\n    if (one_row == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    last_row=(unsigned char *) NULL;\n    if (compressionType == PALM_COMPRESSION_SCANLINE)\n      {\n        last_row=(unsigned char *) AcquireQuantumMemory(MagickMax(bytes_per_row,\n          2*image->columns),sizeof(*last_row));\n        if (last_row == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    mask=(size_t) (1U << bits_per_pixel)-1;\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      if ((flags & PALM_IS_COMPRESSED_FLAG) == 0)\n        {\n          /* TODO move out of loop! */\n          image->compression=NoCompression;\n          count=ReadBlob(image,bytes_per_row,one_row);\n          if (count != (ssize_t) bytes_per_row)\n            break;\n        }\n      else\n        {\n          if (compressionType == PALM_COMPRESSION_RLE)\n            { \n              /* TODO move out of loop! */\n              image->compression=RLECompression;\n              for (i=0; i < (ssize_t) bytes_per_row; )\n              {\n                count=(ssize_t) ReadBlobByte(image);\n                if (count < 0)\n                  break;\n                count=MagickMin(count,(ssize_t) bytes_per_row-i);\n                byte=(size_t) ReadBlobByte(image);\n                (void) ResetMagickMemory(one_row+i,(int) byte,(size_t) count);\n                i+=count;\n              }\n          }\n        else\n          if (compressionType == PALM_COMPRESSION_SCANLINE)\n            {\n              size_t\n                one;\n\n              /* TODO move out of loop! */\n              one=1;\n              image->compression=FaxCompression;\n              for (i=0; i < (ssize_t) bytes_per_row; i+=8)\n              {\n                count=(ssize_t) ReadBlobByte(image);\n                if (count < 0)\n                  break;\n                byte=(size_t) MagickMin((ssize_t) bytes_per_row-i,8);\n                for (bit=0; bit < byte; bit++)\n                {\n                  if ((y == 0) || (count & (one << (7 - bit))))\n                    one_row[i+bit]=(unsigned char) ReadBlobByte(image);\n                  else\n                    one_row[i+bit]=last_row[i+bit];\n                }\n              }\n              (void) CopyMagickMemory(last_row, one_row, bytes_per_row);\n            }\n        }\n      ptr=one_row;\n      q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (q == (Quantum *) NULL)\n        break;\n      if (bits_per_pixel == 16)\n        {\n          if (image->columns > (2*bytes_per_row))\n            {\n              one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n              if (compressionType == PALM_COMPRESSION_SCANLINE)\n                last_row=(unsigned char *) RelinquishMagickMemory(last_row);\n              ThrowReaderException(CorruptImageError,\"CorruptImage\");\n            }\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            color16=(*ptr++ << 8);\n            color16|=(*ptr++);\n            SetPixelRed(image,(Quantum) ((QuantumRange*((color16 >> 11) &\n              0x1f))/0x1f),q);\n            SetPixelGreen(image,(Quantum) ((QuantumRange*((color16 >> 5) &\n              0x3f))/0x3f),q);\n            SetPixelBlue(image,(Quantum) ((QuantumRange*((color16 >> 0) &\n              0x1f))/0x1f),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            q+=GetPixelChannels(image);\n          }\n        }\n      else\n        {\n          bit=8-bits_per_pixel;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if ((size_t) (ptr-one_row) >= bytes_per_row)\n              {\n                one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n                if (compressionType == PALM_COMPRESSION_SCANLINE)\n                  last_row=(unsigned char *) RelinquishMagickMemory(last_row);\n                ThrowReaderException(CorruptImageError,\"CorruptImage\");\n              }\n            index=(Quantum) (mask-(((*ptr) & (mask << bit)) >> bit));\n            SetPixelIndex(image,index,q);\n            SetPixelViaPixelInfo(image,image->colormap+(ssize_t) index,q);\n            if (bit)\n              bit-=bits_per_pixel;\n            else\n              {\n                ptr++;\n                bit=8-bits_per_pixel;\n              }\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n        }\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n              image->rows);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n    if (flags & PALM_HAS_TRANSPARENCY_FLAG)\n      {\n        ssize_t index=ConstrainColormapIndex(image,(ssize_t) (mask-\n          transparentIndex),exception);\n        if (bits_per_pixel != 16)\n          transpix=image->colormap[index];\n        (void) TransparentPaintImage(image,&transpix,(Quantum) TransparentAlpha,\n          MagickFalse,exception);\n      }\n    one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n    if (compressionType == PALM_COMPRESSION_SCANLINE)\n      last_row=(unsigned char *) RelinquishMagickMemory(last_row);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image. Copied from coders/pnm.c\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if (nextDepthOffset != 0)\n      { \n        /*\n          Skip to next image. \n        */\n        totalOffset+=(MagickOffsetType) (nextDepthOffset*4);\n        if (totalOffset >= (MagickOffsetType) GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n        else\n          seekNextDepth=SeekBlob(image,totalOffset,SEEK_SET);\n        if (seekNextDepth != totalOffset)\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        /*\n          Allocate next image structure. Copied from coders/pnm.c\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            (void) DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (nextDepthOffset != 0);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -47,7 +47,7 @@\n     y;\n \n   unsigned char\n-    *lastrow,\n+    *last_row,\n     *one_row,\n     *ptr;\n \n@@ -177,12 +177,12 @@\n       2*image->columns),sizeof(*one_row));\n     if (one_row == (unsigned char *) NULL)\n       ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n-    lastrow=(unsigned char *) NULL;\n+    last_row=(unsigned char *) NULL;\n     if (compressionType == PALM_COMPRESSION_SCANLINE)\n       {\n-        lastrow=(unsigned char *) AcquireQuantumMemory(MagickMax(bytes_per_row,\n-          2*image->columns),sizeof(*lastrow));\n-        if (lastrow == (unsigned char *) NULL)\n+        last_row=(unsigned char *) AcquireQuantumMemory(MagickMax(bytes_per_row,\n+          2*image->columns),sizeof(*last_row));\n+        if (last_row == (unsigned char *) NULL)\n           ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n       }\n     mask=(size_t) (1U << bits_per_pixel)-1;\n@@ -233,10 +233,10 @@\n                   if ((y == 0) || (count & (one << (7 - bit))))\n                     one_row[i+bit]=(unsigned char) ReadBlobByte(image);\n                   else\n-                    one_row[i+bit]=lastrow[i+bit];\n+                    one_row[i+bit]=last_row[i+bit];\n                 }\n               }\n-              (void) CopyMagickMemory(lastrow, one_row, bytes_per_row);\n+              (void) CopyMagickMemory(last_row, one_row, bytes_per_row);\n             }\n         }\n       ptr=one_row;\n@@ -249,7 +249,7 @@\n             {\n               one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n               if (compressionType == PALM_COMPRESSION_SCANLINE)\n-                lastrow=(unsigned char *) RelinquishMagickMemory(lastrow);\n+                last_row=(unsigned char *) RelinquishMagickMemory(last_row);\n               ThrowReaderException(CorruptImageError,\"CorruptImage\");\n             }\n           for (x=0; x < (ssize_t) image->columns; x++)\n@@ -275,7 +275,7 @@\n               {\n                 one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n                 if (compressionType == PALM_COMPRESSION_SCANLINE)\n-                  lastrow=(unsigned char *) RelinquishMagickMemory(lastrow);\n+                  last_row=(unsigned char *) RelinquishMagickMemory(last_row);\n                 ThrowReaderException(CorruptImageError,\"CorruptImage\");\n               }\n             index=(Quantum) (mask-(((*ptr) & (mask << bit)) >> bit));\n@@ -312,7 +312,7 @@\n       }\n     one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n     if (compressionType == PALM_COMPRESSION_SCANLINE)\n-      lastrow=(unsigned char *) RelinquishMagickMemory(lastrow);\n+      last_row=(unsigned char *) RelinquishMagickMemory(last_row);\n     if (EOFBlob(image) != MagickFalse)\n       {\n         ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",",
        "diff_line_info": {
            "deleted_lines": [
                "    *lastrow,",
                "    lastrow=(unsigned char *) NULL;",
                "        lastrow=(unsigned char *) AcquireQuantumMemory(MagickMax(bytes_per_row,",
                "          2*image->columns),sizeof(*lastrow));",
                "        if (lastrow == (unsigned char *) NULL)",
                "                    one_row[i+bit]=lastrow[i+bit];",
                "              (void) CopyMagickMemory(lastrow, one_row, bytes_per_row);",
                "                lastrow=(unsigned char *) RelinquishMagickMemory(lastrow);",
                "                  lastrow=(unsigned char *) RelinquishMagickMemory(lastrow);",
                "      lastrow=(unsigned char *) RelinquishMagickMemory(lastrow);"
            ],
            "added_lines": [
                "    *last_row,",
                "    last_row=(unsigned char *) NULL;",
                "        last_row=(unsigned char *) AcquireQuantumMemory(MagickMax(bytes_per_row,",
                "          2*image->columns),sizeof(*last_row));",
                "        if (last_row == (unsigned char *) NULL)",
                "                    one_row[i+bit]=last_row[i+bit];",
                "              (void) CopyMagickMemory(last_row, one_row, bytes_per_row);",
                "                last_row=(unsigned char *) RelinquishMagickMemory(last_row);",
                "                  last_row=(unsigned char *) RelinquishMagickMemory(last_row);",
                "      last_row=(unsigned char *) RelinquishMagickMemory(last_row);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12665",
        "func_name": "ImageMagick/WritePICTImage",
        "description": "ImageMagick 7.0.6-2 has a memory leak vulnerability in WritePICTImage in coders/pict.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/c1b09bbec148f6ae11d0b686fdb89ac6dc0ab14e",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/577",
        "commit_text": "",
        "func_before": "static MagickBooleanType WritePICTImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n#define MaxCount  128\n#define PictCropRegionOp  0x01\n#define PictEndOfPictureOp  0xff\n#define PictJPEGOp  0x8200\n#define PictInfoOp  0x0C00\n#define PictInfoSize  512\n#define PictPixmapOp  0x9A\n#define PictPICTOp  0x98\n#define PictVersion  0x11\n\n  const StringInfo\n    *profile;\n\n  double\n    x_resolution,\n    y_resolution;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  PICTPixmap\n    pixmap;\n\n  PICTRectangle\n    bounds,\n    crop_rectangle,\n    destination_rectangle,\n    frame_rectangle,\n    size_rectangle,\n    source_rectangle;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    bytes_per_line,\n    count,\n    row_bytes,\n    storage_class;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *buffer,\n    *packed_scanline,\n    *scanline;\n\n  unsigned short\n    base_address,\n    transfer_mode;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((image->columns > 65535L) || (image->rows > 65535L))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  /*\n    Initialize image info.\n  */\n  size_rectangle.top=0;\n  size_rectangle.left=0;\n  size_rectangle.bottom=(short) image->rows;\n  size_rectangle.right=(short) image->columns;\n  frame_rectangle=size_rectangle;\n  crop_rectangle=size_rectangle;\n  source_rectangle=size_rectangle;\n  destination_rectangle=size_rectangle;\n  base_address=0xff;\n  row_bytes=image->columns;\n  bounds.top=0;\n  bounds.left=0;\n  bounds.bottom=(short) image->rows;\n  bounds.right=(short) image->columns;\n  pixmap.version=0;\n  pixmap.pack_type=0;\n  pixmap.pack_size=0;\n  pixmap.pixel_type=0;\n  pixmap.bits_per_pixel=8;\n  pixmap.component_count=1;\n  pixmap.component_size=8;\n  pixmap.plane_bytes=0;\n  pixmap.table=0;\n  pixmap.reserved=0;\n  transfer_mode=0;\n  x_resolution=image->resolution.x != 0.0 ? image->resolution.x :\n    DefaultResolution;\n  y_resolution=image->resolution.y != 0.0 ? image->resolution.y :\n    DefaultResolution;\n  storage_class=image->storage_class;\n  if (image_info->compression == JPEGCompression)\n    storage_class=DirectClass;\n  if (storage_class == DirectClass)\n    {\n      pixmap.component_count=image->alpha_trait != UndefinedPixelTrait ? 4 : 3;\n      pixmap.pixel_type=16;\n      pixmap.bits_per_pixel=32;\n      pixmap.pack_type=0x04;\n      transfer_mode=0x40;\n      row_bytes=4*image->columns;\n    }\n  /*\n    Allocate memory.\n  */\n  bytes_per_line=image->columns;\n  if (storage_class == DirectClass)\n    bytes_per_line*=image->alpha_trait != UndefinedPixelTrait ? 4 : 3;\n  buffer=(unsigned char *) AcquireQuantumMemory(PictInfoSize,sizeof(*buffer));\n  packed_scanline=(unsigned char *) AcquireQuantumMemory((size_t)\n   (row_bytes+MaxCount),sizeof(*packed_scanline));\n  scanline=(unsigned char *) AcquireQuantumMemory(row_bytes,sizeof(*scanline));\n  if ((buffer == (unsigned char *) NULL) ||\n      (packed_scanline == (unsigned char *) NULL) ||\n      (scanline == (unsigned char *) NULL))\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(scanline,0,row_bytes);\n  (void) ResetMagickMemory(packed_scanline,0,(size_t) (row_bytes+MaxCount));\n  /*\n    Write header, header size, size bounding box, version, and reserved.\n  */\n  (void) ResetMagickMemory(buffer,0,PictInfoSize);\n  (void) WriteBlob(image,PictInfoSize,buffer);\n  (void) WriteBlobMSBShort(image,0);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.right);\n  (void) WriteBlobMSBShort(image,PictVersion);\n  (void) WriteBlobMSBShort(image,0x02ff);  /* version #2 */\n  (void) WriteBlobMSBShort(image,PictInfoOp);\n  (void) WriteBlobMSBLong(image,0xFFFE0000UL);\n  /*\n    Write full size of the file, resolution, frame bounding box, and reserved.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) x_resolution);\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) y_resolution);\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.right);\n  (void) WriteBlobMSBLong(image,0x00000000L);\n  profile=GetImageProfile(image,\"iptc\");\n  if (profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlobMSBShort(image,0xa1);\n      (void) WriteBlobMSBShort(image,0x1f2);\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (GetStringInfoLength(profile)+4));\n      (void) WriteBlobString(image,\"8BIM\");\n      (void) WriteBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n    }\n  profile=GetImageProfile(image,\"icc\");\n  if (profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlobMSBShort(image,0xa1);\n      (void) WriteBlobMSBShort(image,0xe0);\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (GetStringInfoLength(profile)+4));\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n      (void) WriteBlobMSBShort(image,0xa1);\n      (void) WriteBlobMSBShort(image,0xe0);\n      (void) WriteBlobMSBShort(image,4);\n      (void) WriteBlobMSBLong(image,0x00000002UL);\n    }\n  /*\n    Write crop region opcode and crop bounding box.\n  */\n  (void) WriteBlobMSBShort(image,PictCropRegionOp);\n  (void) WriteBlobMSBShort(image,0xa);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.right);\n  if (image_info->compression == JPEGCompression)\n    {\n      Image\n        *jpeg_image;\n\n      ImageInfo\n        *jpeg_info;\n\n      size_t\n        length;\n\n      unsigned char\n        *blob;\n\n      jpeg_image=CloneImage(image,0,0,MagickTrue,exception);\n      if (jpeg_image == (Image *) NULL)\n        {\n          (void) CloseBlob(image);\n          return(MagickFalse);\n        }\n      jpeg_info=CloneImageInfo(image_info);\n      (void) CopyMagickString(jpeg_info->magick,\"JPEG\",MagickPathExtent);\n      length=0;\n      blob=(unsigned char *) ImageToBlob(jpeg_info,jpeg_image,&length,\n        exception);\n      jpeg_info=DestroyImageInfo(jpeg_info);\n      if (blob == (unsigned char *) NULL)\n        return(MagickFalse);\n      jpeg_image=DestroyImage(jpeg_image);\n      (void) WriteBlobMSBShort(image,PictJPEGOp);\n      (void) WriteBlobMSBLong(image,(unsigned int) length+154);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBLong(image,0x00010000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00010000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x40000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00400000UL);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->rows);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->columns);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBShort(image,768);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00566A70UL);\n      (void) WriteBlobMSBLong(image,0x65670000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000001UL);\n      (void) WriteBlobMSBLong(image,0x00016170UL);\n      (void) WriteBlobMSBLong(image,0x706C0000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBShort(image,768);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->columns);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->rows);\n      (void) WriteBlobMSBShort(image,(unsigned short) x_resolution);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBShort(image,(unsigned short) y_resolution);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x87AC0001UL);\n      (void) WriteBlobMSBLong(image,0x0B466F74UL);\n      (void) WriteBlobMSBLong(image,0x6F202D20UL);\n      (void) WriteBlobMSBLong(image,0x4A504547UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x0018FFFFUL);\n      (void) WriteBlob(image,length,blob);\n      if ((length & 0x01) != 0)\n        (void) WriteBlobByte(image,'\\0');\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n    }\n  /*\n    Write picture opcode, row bytes, and picture bounding box, and version.\n  */\n  if (storage_class == PseudoClass)\n    (void) WriteBlobMSBShort(image,PictPICTOp);\n  else\n    {\n      (void) WriteBlobMSBShort(image,PictPixmapOp);\n      (void) WriteBlobMSBLong(image,(size_t) base_address);\n    }\n  (void) WriteBlobMSBShort(image,(unsigned short) (row_bytes | 0x8000));\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.right);\n  /*\n    Write pack type, pack size, resolution, pixel type, and pixel size.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.version);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.pack_type);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.pack_size);\n  (void) WriteBlobMSBShort(image,(unsigned short) (x_resolution+0.5));\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) (y_resolution+0.5));\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.pixel_type);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.bits_per_pixel);\n  /*\n    Write component count, size, plane bytes, table size, and reserved.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.component_count);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.component_size);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.plane_bytes);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.table);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.reserved);\n  if (storage_class == PseudoClass)\n    {\n      /*\n        Write image colormap.\n      */\n      (void) WriteBlobMSBLong(image,0x00000000L);  /* color seed */\n      (void) WriteBlobMSBShort(image,0L);  /* color flags */\n      (void) WriteBlobMSBShort(image,(unsigned short) (image->colors-1));\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        (void) WriteBlobMSBShort(image,(unsigned short) i);\n        (void) WriteBlobMSBShort(image,ScaleQuantumToShort(\n          image->colormap[i].red));\n        (void) WriteBlobMSBShort(image,ScaleQuantumToShort(\n          image->colormap[i].green));\n        (void) WriteBlobMSBShort(image,ScaleQuantumToShort(\n          image->colormap[i].blue));\n      }\n    }\n  /*\n    Write source and destination rectangle.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.right);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.right);\n  (void) WriteBlobMSBShort(image,(unsigned short) transfer_mode);\n  /*\n    Write picture data.\n  */\n  count=0;\n  if (storage_class == PseudoClass)\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        scanline[x]=(unsigned char) GetPixelIndex(image,p);\n        p+=GetPixelChannels(image);\n      }\n      count+=EncodeImage(image,scanline,(size_t) (row_bytes & 0x7FFF),\n        packed_scanline);\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n  else\n    if (image_info->compression == JPEGCompression)\n      {\n        (void) ResetMagickMemory(scanline,0,row_bytes);\n        for (y=0; y < (ssize_t) image->rows; y++)\n          count+=EncodeImage(image,scanline,(size_t) (row_bytes & 0x7FFF),\n            packed_scanline);\n      }\n    else\n      {\n        register unsigned char\n          *blue,\n          *green,\n          *opacity,\n          *red;\n\n        red=scanline;\n        green=scanline+image->columns;\n        blue=scanline+2*image->columns;\n        opacity=scanline+3*image->columns;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          red=scanline;\n          green=scanline+image->columns;\n          blue=scanline+2*image->columns;\n          if (image->alpha_trait != UndefinedPixelTrait)\n            {\n              opacity=scanline;\n              red=scanline+image->columns;\n              green=scanline+2*image->columns;\n              blue=scanline+3*image->columns;\n            }\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *red++=ScaleQuantumToChar(GetPixelRed(image,p));\n            *green++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *blue++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            if (image->alpha_trait != UndefinedPixelTrait)\n              *opacity++=ScaleQuantumToChar((Quantum) (GetPixelAlpha(image,p)));\n            p+=GetPixelChannels(image);\n          }\n          count+=EncodeImage(image,scanline,bytes_per_line,packed_scanline);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n  if ((count & 0x01) != 0)\n    (void) WriteBlobByte(image,'\\0');\n  (void) WriteBlobMSBShort(image,PictEndOfPictureOp);\n  offset=TellBlob(image);\n  offset=SeekBlob(image,512,SEEK_SET);\n  (void) WriteBlobMSBShort(image,(unsigned short) offset);\n  scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n  packed_scanline=(unsigned char *) RelinquishMagickMemory(packed_scanline);\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
        "func": "static MagickBooleanType WritePICTImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n#define MaxCount  128\n#define PictCropRegionOp  0x01\n#define PictEndOfPictureOp  0xff\n#define PictJPEGOp  0x8200\n#define PictInfoOp  0x0C00\n#define PictInfoSize  512\n#define PictPixmapOp  0x9A\n#define PictPICTOp  0x98\n#define PictVersion  0x11\n\n  const StringInfo\n    *profile;\n\n  double\n    x_resolution,\n    y_resolution;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  PICTPixmap\n    pixmap;\n\n  PICTRectangle\n    bounds,\n    crop_rectangle,\n    destination_rectangle,\n    frame_rectangle,\n    size_rectangle,\n    source_rectangle;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    bytes_per_line,\n    count,\n    row_bytes,\n    storage_class;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *buffer,\n    *packed_scanline,\n    *scanline;\n\n  unsigned short\n    base_address,\n    transfer_mode;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((image->columns > 65535L) || (image->rows > 65535L))\n    ThrowWriterException(ImageError,\"WidthOrHeightExceedsLimit\");\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  /*\n    Initialize image info.\n  */\n  size_rectangle.top=0;\n  size_rectangle.left=0;\n  size_rectangle.bottom=(short) image->rows;\n  size_rectangle.right=(short) image->columns;\n  frame_rectangle=size_rectangle;\n  crop_rectangle=size_rectangle;\n  source_rectangle=size_rectangle;\n  destination_rectangle=size_rectangle;\n  base_address=0xff;\n  row_bytes=image->columns;\n  bounds.top=0;\n  bounds.left=0;\n  bounds.bottom=(short) image->rows;\n  bounds.right=(short) image->columns;\n  pixmap.version=0;\n  pixmap.pack_type=0;\n  pixmap.pack_size=0;\n  pixmap.pixel_type=0;\n  pixmap.bits_per_pixel=8;\n  pixmap.component_count=1;\n  pixmap.component_size=8;\n  pixmap.plane_bytes=0;\n  pixmap.table=0;\n  pixmap.reserved=0;\n  transfer_mode=0;\n  x_resolution=image->resolution.x != 0.0 ? image->resolution.x :\n    DefaultResolution;\n  y_resolution=image->resolution.y != 0.0 ? image->resolution.y :\n    DefaultResolution;\n  storage_class=image->storage_class;\n  if (image_info->compression == JPEGCompression)\n    storage_class=DirectClass;\n  if (storage_class == DirectClass)\n    {\n      pixmap.component_count=image->alpha_trait != UndefinedPixelTrait ? 4 : 3;\n      pixmap.pixel_type=16;\n      pixmap.bits_per_pixel=32;\n      pixmap.pack_type=0x04;\n      transfer_mode=0x40;\n      row_bytes=4*image->columns;\n    }\n  /*\n    Allocate memory.\n  */\n  bytes_per_line=image->columns;\n  if (storage_class == DirectClass)\n    bytes_per_line*=image->alpha_trait != UndefinedPixelTrait ? 4 : 3;\n  buffer=(unsigned char *) AcquireQuantumMemory(PictInfoSize,sizeof(*buffer));\n  packed_scanline=(unsigned char *) AcquireQuantumMemory((size_t)\n   (row_bytes+MaxCount),sizeof(*packed_scanline));\n  scanline=(unsigned char *) AcquireQuantumMemory(row_bytes,sizeof(*scanline));\n  if ((buffer == (unsigned char *) NULL) ||\n      (packed_scanline == (unsigned char *) NULL) ||\n      (scanline == (unsigned char *) NULL))\n    {\n      if (scanline != (unsigned char *) NULL)\n        scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n      if (packed_scanline != (unsigned char *) NULL)\n        packed_scanline=(unsigned char *) RelinquishMagickMemory(\n          packed_scanline);\n      if (buffer != (unsigned char *) NULL)\n        buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  (void) ResetMagickMemory(scanline,0,row_bytes);\n  (void) ResetMagickMemory(packed_scanline,0,(size_t) (row_bytes+MaxCount));\n  /*\n    Write header, header size, size bounding box, version, and reserved.\n  */\n  (void) ResetMagickMemory(buffer,0,PictInfoSize);\n  (void) WriteBlob(image,PictInfoSize,buffer);\n  (void) WriteBlobMSBShort(image,0);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.right);\n  (void) WriteBlobMSBShort(image,PictVersion);\n  (void) WriteBlobMSBShort(image,0x02ff);  /* version #2 */\n  (void) WriteBlobMSBShort(image,PictInfoOp);\n  (void) WriteBlobMSBLong(image,0xFFFE0000UL);\n  /*\n    Write full size of the file, resolution, frame bounding box, and reserved.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) x_resolution);\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) y_resolution);\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) frame_rectangle.right);\n  (void) WriteBlobMSBLong(image,0x00000000L);\n  profile=GetImageProfile(image,\"iptc\");\n  if (profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlobMSBShort(image,0xa1);\n      (void) WriteBlobMSBShort(image,0x1f2);\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (GetStringInfoLength(profile)+4));\n      (void) WriteBlobString(image,\"8BIM\");\n      (void) WriteBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n    }\n  profile=GetImageProfile(image,\"icc\");\n  if (profile != (StringInfo *) NULL)\n    {\n      (void) WriteBlobMSBShort(image,0xa1);\n      (void) WriteBlobMSBShort(image,0xe0);\n      (void) WriteBlobMSBShort(image,(unsigned short)\n        (GetStringInfoLength(profile)+4));\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlob(image,GetStringInfoLength(profile),\n        GetStringInfoDatum(profile));\n      (void) WriteBlobMSBShort(image,0xa1);\n      (void) WriteBlobMSBShort(image,0xe0);\n      (void) WriteBlobMSBShort(image,4);\n      (void) WriteBlobMSBLong(image,0x00000002UL);\n    }\n  /*\n    Write crop region opcode and crop bounding box.\n  */\n  (void) WriteBlobMSBShort(image,PictCropRegionOp);\n  (void) WriteBlobMSBShort(image,0xa);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) crop_rectangle.right);\n  if (image_info->compression == JPEGCompression)\n    {\n      Image\n        *jpeg_image;\n\n      ImageInfo\n        *jpeg_info;\n\n      size_t\n        length;\n\n      unsigned char\n        *blob;\n\n      jpeg_image=CloneImage(image,0,0,MagickTrue,exception);\n      if (jpeg_image == (Image *) NULL)\n        {\n          (void) CloseBlob(image);\n          return(MagickFalse);\n        }\n      jpeg_info=CloneImageInfo(image_info);\n      (void) CopyMagickString(jpeg_info->magick,\"JPEG\",MagickPathExtent);\n      length=0;\n      blob=(unsigned char *) ImageToBlob(jpeg_info,jpeg_image,&length,\n        exception);\n      jpeg_info=DestroyImageInfo(jpeg_info);\n      if (blob == (unsigned char *) NULL)\n        return(MagickFalse);\n      jpeg_image=DestroyImage(jpeg_image);\n      (void) WriteBlobMSBShort(image,PictJPEGOp);\n      (void) WriteBlobMSBLong(image,(unsigned int) length+154);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBLong(image,0x00010000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00010000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x40000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00400000UL);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->rows);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->columns);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBShort(image,768);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00566A70UL);\n      (void) WriteBlobMSBLong(image,0x65670000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000001UL);\n      (void) WriteBlobMSBLong(image,0x00016170UL);\n      (void) WriteBlobMSBLong(image,0x706C0000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBShort(image,768);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->columns);\n      (void) WriteBlobMSBShort(image,(unsigned short) image->rows);\n      (void) WriteBlobMSBShort(image,(unsigned short) x_resolution);\n      (void) WriteBlobMSBShort(image,0x0000);\n      (void) WriteBlobMSBShort(image,(unsigned short) y_resolution);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x87AC0001UL);\n      (void) WriteBlobMSBLong(image,0x0B466F74UL);\n      (void) WriteBlobMSBLong(image,0x6F202D20UL);\n      (void) WriteBlobMSBLong(image,0x4A504547UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x00000000UL);\n      (void) WriteBlobMSBLong(image,0x0018FFFFUL);\n      (void) WriteBlob(image,length,blob);\n      if ((length & 0x01) != 0)\n        (void) WriteBlobByte(image,'\\0');\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n    }\n  /*\n    Write picture opcode, row bytes, and picture bounding box, and version.\n  */\n  if (storage_class == PseudoClass)\n    (void) WriteBlobMSBShort(image,PictPICTOp);\n  else\n    {\n      (void) WriteBlobMSBShort(image,PictPixmapOp);\n      (void) WriteBlobMSBLong(image,(size_t) base_address);\n    }\n  (void) WriteBlobMSBShort(image,(unsigned short) (row_bytes | 0x8000));\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) bounds.right);\n  /*\n    Write pack type, pack size, resolution, pixel type, and pixel size.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.version);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.pack_type);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.pack_size);\n  (void) WriteBlobMSBShort(image,(unsigned short) (x_resolution+0.5));\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) (y_resolution+0.5));\n  (void) WriteBlobMSBShort(image,0x0000);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.pixel_type);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.bits_per_pixel);\n  /*\n    Write component count, size, plane bytes, table size, and reserved.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.component_count);\n  (void) WriteBlobMSBShort(image,(unsigned short) pixmap.component_size);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.plane_bytes);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.table);\n  (void) WriteBlobMSBLong(image,(unsigned int) pixmap.reserved);\n  if (storage_class == PseudoClass)\n    {\n      /*\n        Write image colormap.\n      */\n      (void) WriteBlobMSBLong(image,0x00000000L);  /* color seed */\n      (void) WriteBlobMSBShort(image,0L);  /* color flags */\n      (void) WriteBlobMSBShort(image,(unsigned short) (image->colors-1));\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        (void) WriteBlobMSBShort(image,(unsigned short) i);\n        (void) WriteBlobMSBShort(image,ScaleQuantumToShort(\n          image->colormap[i].red));\n        (void) WriteBlobMSBShort(image,ScaleQuantumToShort(\n          image->colormap[i].green));\n        (void) WriteBlobMSBShort(image,ScaleQuantumToShort(\n          image->colormap[i].blue));\n      }\n    }\n  /*\n    Write source and destination rectangle.\n  */\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) source_rectangle.right);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.left);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.bottom);\n  (void) WriteBlobMSBShort(image,(unsigned short) destination_rectangle.right);\n  (void) WriteBlobMSBShort(image,(unsigned short) transfer_mode);\n  /*\n    Write picture data.\n  */\n  count=0;\n  if (storage_class == PseudoClass)\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n      if (p == (const Quantum *) NULL)\n        break;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        scanline[x]=(unsigned char) GetPixelIndex(image,p);\n        p+=GetPixelChannels(image);\n      }\n      count+=EncodeImage(image,scanline,(size_t) (row_bytes & 0x7FFF),\n        packed_scanline);\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n  else\n    if (image_info->compression == JPEGCompression)\n      {\n        (void) ResetMagickMemory(scanline,0,row_bytes);\n        for (y=0; y < (ssize_t) image->rows; y++)\n          count+=EncodeImage(image,scanline,(size_t) (row_bytes & 0x7FFF),\n            packed_scanline);\n      }\n    else\n      {\n        register unsigned char\n          *blue,\n          *green,\n          *opacity,\n          *red;\n\n        red=scanline;\n        green=scanline+image->columns;\n        blue=scanline+2*image->columns;\n        opacity=scanline+3*image->columns;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n          if (p == (const Quantum *) NULL)\n            break;\n          red=scanline;\n          green=scanline+image->columns;\n          blue=scanline+2*image->columns;\n          if (image->alpha_trait != UndefinedPixelTrait)\n            {\n              opacity=scanline;\n              red=scanline+image->columns;\n              green=scanline+2*image->columns;\n              blue=scanline+3*image->columns;\n            }\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *red++=ScaleQuantumToChar(GetPixelRed(image,p));\n            *green++=ScaleQuantumToChar(GetPixelGreen(image,p));\n            *blue++=ScaleQuantumToChar(GetPixelBlue(image,p));\n            if (image->alpha_trait != UndefinedPixelTrait)\n              *opacity++=ScaleQuantumToChar((Quantum) (GetPixelAlpha(image,p)));\n            p+=GetPixelChannels(image);\n          }\n          count+=EncodeImage(image,scanline,bytes_per_line,packed_scanline);\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n  if ((count & 0x01) != 0)\n    (void) WriteBlobByte(image,'\\0');\n  (void) WriteBlobMSBShort(image,PictEndOfPictureOp);\n  offset=TellBlob(image);\n  offset=SeekBlob(image,512,SEEK_SET);\n  (void) WriteBlobMSBShort(image,(unsigned short) offset);\n  scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n  packed_scanline=(unsigned char *) RelinquishMagickMemory(packed_scanline);\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -134,7 +134,16 @@\n   if ((buffer == (unsigned char *) NULL) ||\n       (packed_scanline == (unsigned char *) NULL) ||\n       (scanline == (unsigned char *) NULL))\n-    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n+    {\n+      if (scanline != (unsigned char *) NULL)\n+        scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n+      if (packed_scanline != (unsigned char *) NULL)\n+        packed_scanline=(unsigned char *) RelinquishMagickMemory(\n+          packed_scanline);\n+      if (buffer != (unsigned char *) NULL)\n+        buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n+      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n+    }\n   (void) ResetMagickMemory(scanline,0,row_bytes);\n   (void) ResetMagickMemory(packed_scanline,0,(size_t) (row_bytes+MaxCount));\n   /*",
        "diff_line_info": {
            "deleted_lines": [
                "    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");"
            ],
            "added_lines": [
                "    {",
                "      if (scanline != (unsigned char *) NULL)",
                "        scanline=(unsigned char *) RelinquishMagickMemory(scanline);",
                "      if (packed_scanline != (unsigned char *) NULL)",
                "        packed_scanline=(unsigned char *) RelinquishMagickMemory(",
                "          packed_scanline);",
                "      if (buffer != (unsigned char *) NULL)",
                "        buffer=(unsigned char *) RelinquishMagickMemory(buffer);",
                "      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12666",
        "func_name": "ImageMagick/WriteINLINEImage",
        "description": "ImageMagick 7.0.6-2 has a memory leak vulnerability in WriteINLINEImage in coders/inline.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/d5559407ce29f4371e5df9c1cbde65455fe5854c",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/572",
        "commit_text": "",
        "func_before": "static MagickBooleanType WriteINLINEImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    *base64,\n    message[MagickPathExtent];\n\n  const MagickInfo\n    *magick_info;\n\n  Image\n    *write_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    blob_length,\n    encode_length;\n\n  unsigned char\n    *blob;\n\n  /*\n    Convert image to base64-encoding.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  write_info=CloneImageInfo(image_info);\n  (void) SetImageInfo(write_info,1,exception);\n  if (LocaleCompare(write_info->magick,\"INLINE\") == 0)\n    (void) CopyMagickString(write_info->magick,image->magick,MagickPathExtent);\n  magick_info=GetMagickInfo(write_info->magick,exception);\n  if ((magick_info == (const MagickInfo *) NULL) ||\n      (GetMagickMimeType(magick_info) == (const char *) NULL))\n    ThrowWriterException(CorruptImageError,\"ImageTypeNotSupported\");\n  (void) CopyMagickString(image->filename,write_info->filename,\n    MagickPathExtent);\n  blob_length=2048;\n  write_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (write_image == (Image *) NULL)\n    {\n      write_info=DestroyImageInfo(write_info);\n      return(MagickTrue);\n    }\n  blob=(unsigned char *) ImageToBlob(write_info,write_image,&blob_length,\n    exception);\n  write_image=DestroyImage(write_image);\n  write_info=DestroyImageInfo(write_info);\n  if (blob == (unsigned char *) NULL)\n    return(MagickFalse);\n  encode_length=0;\n  base64=Base64Encode(blob,blob_length,&encode_length);\n  blob=(unsigned char *) RelinquishMagickMemory(blob);\n  if (base64 == (char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  /*\n    Write base64-encoded image.\n  */\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      base64=DestroyString(base64);\n      return(status);\n    }\n  (void) FormatLocaleString(message,MagickPathExtent,\"data:%s;base64,\",\n    GetMagickMimeType(magick_info));\n  (void) WriteBlobString(image,message);\n  (void) WriteBlobString(image,base64);\n  base64=DestroyString(base64);\n  return(MagickTrue);\n}",
        "func": "static MagickBooleanType WriteINLINEImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    *base64,\n    message[MagickPathExtent];\n\n  const MagickInfo\n    *magick_info;\n\n  Image\n    *write_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    blob_length,\n    encode_length;\n\n  unsigned char\n    *blob;\n\n  /*\n    Convert image to base64-encoding.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  write_info=CloneImageInfo(image_info);\n  (void) SetImageInfo(write_info,1,exception);\n  if (LocaleCompare(write_info->magick,\"INLINE\") == 0)\n    (void) CopyMagickString(write_info->magick,image->magick,MagickPathExtent);\n  magick_info=GetMagickInfo(write_info->magick,exception);\n  if ((magick_info == (const MagickInfo *) NULL) ||\n      (GetMagickMimeType(magick_info) == (const char *) NULL))\n    {\n      write_info=DestroyImageInfo(write_info);\n      ThrowWriterException(CorruptImageError,\"ImageTypeNotSupported\");\n    }\n  (void) CopyMagickString(image->filename,write_info->filename,\n    MagickPathExtent);\n  blob_length=2048;\n  write_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (write_image == (Image *) NULL)\n    {\n      write_info=DestroyImageInfo(write_info);\n      return(MagickTrue);\n    }\n  blob=(unsigned char *) ImageToBlob(write_info,write_image,&blob_length,\n    exception);\n  write_image=DestroyImage(write_image);\n  write_info=DestroyImageInfo(write_info);\n  if (blob == (unsigned char *) NULL)\n    return(MagickFalse);\n  encode_length=0;\n  base64=Base64Encode(blob,blob_length,&encode_length);\n  blob=(unsigned char *) RelinquishMagickMemory(blob);\n  if (base64 == (char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  /*\n    Write base64-encoded image.\n  */\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      base64=DestroyString(base64);\n      return(status);\n    }\n  (void) FormatLocaleString(message,MagickPathExtent,\"data:%s;base64,\",\n    GetMagickMimeType(magick_info));\n  (void) WriteBlobString(image,message);\n  (void) WriteBlobString(image,base64);\n  base64=DestroyString(base64);\n  return(MagickTrue);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -40,7 +40,10 @@\n   magick_info=GetMagickInfo(write_info->magick,exception);\n   if ((magick_info == (const MagickInfo *) NULL) ||\n       (GetMagickMimeType(magick_info) == (const char *) NULL))\n-    ThrowWriterException(CorruptImageError,\"ImageTypeNotSupported\");\n+    {\n+      write_info=DestroyImageInfo(write_info);\n+      ThrowWriterException(CorruptImageError,\"ImageTypeNotSupported\");\n+    }\n   (void) CopyMagickString(image->filename,write_info->filename,\n     MagickPathExtent);\n   blob_length=2048;",
        "diff_line_info": {
            "deleted_lines": [
                "    ThrowWriterException(CorruptImageError,\"ImageTypeNotSupported\");"
            ],
            "added_lines": [
                "    {",
                "      write_info=DestroyImageInfo(write_info);",
                "      ThrowWriterException(CorruptImageError,\"ImageTypeNotSupported\");",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12667",
        "func_name": "ImageMagick/ReadMATImage",
        "description": "ImageMagick 7.0.6-1 has a memory leak vulnerability in ReadMATImage in coders\\mat.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/bfb7915d4b2e11acb6a819e451c382dc645277db",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/553",
        "commit_text": "",
        "func_before": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  register Quantum *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info,exception);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  clone_info=(ImageInfo *) NULL;\n  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\nMATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if(MATLAB_HDR.ObjectSize+filepos > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           (void) ReadBlobXXXLong(image2);\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\n    NEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n    /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        image->type=GrayscaleType;\n        SetImageColorspace(image,GRAYColorspace,exception);\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(image,q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n            exception);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n            exception);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image,exception);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n        }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}",
        "func": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  register Quantum *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info,exception);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  clone_info=(ImageInfo *) NULL;\n  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if(MATLAB_HDR.ObjectSize+filepos > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           (void) ReadBlobXXXLong(image2);\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\n    NEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n    /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        image->type=GrayscaleType;\n        SetImageColorspace(image,GRAYColorspace,exception);\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(image,q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n            exception);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n            exception);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image,exception);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n        }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -87,7 +87,11 @@\n     goto MATLAB_KO;    /* unsupported endian */\n \n   if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n-MATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+    {\n+MATLAB_KO:\n+      clone_info=DestroyImageInfo(clone_info);\n+      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+    }\n \n   filepos = TellBlob(image);\n   while(!EOFBlob(image)) /* object parser loop */",
        "diff_line_info": {
            "deleted_lines": [
                "MATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");"
            ],
            "added_lines": [
                "    {",
                "MATLAB_KO:",
                "      clone_info=DestroyImageInfo(clone_info);",
                "      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12668",
        "func_name": "ImageMagick/WritePCXImage",
        "description": "ImageMagick 7.0.6-2 has a memory leak vulnerability in WritePCXImage in coders/pcx.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/2ba8f335fa06daf1165e0878462686028e633a74",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/575",
        "commit_text": "",
        "func_before": "static MagickBooleanType WritePCXImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    *page_table,\n    scene;\n\n  MemoryInfo\n    *pixel_info;\n\n  PCXInfo\n    pcx_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pcx_colormap,\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  page_table=(MagickOffsetType *) NULL;\n  if ((LocaleCompare(image_info->magick,\"DCX\") == 0) ||\n      ((GetNextImageInList(image) != (Image *) NULL) &&\n       (image_info->adjoin != MagickFalse)))\n    {\n      /*\n        Write the DCX page table.\n      */\n      (void) WriteBlobLSBLong(image,0x3ADE68B1L);\n      page_table=(MagickOffsetType *) AcquireQuantumMemory(1024UL,\n        sizeof(*page_table));\n      if (page_table == (MagickOffsetType *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (scene=0; scene < 1024; scene++)\n        (void) WriteBlobLSBLong(image,0x00000000L);\n    }\n  scene=0;\n  do\n  {\n    if (page_table != (MagickOffsetType *) NULL)\n      page_table[scene]=TellBlob(image);\n    /*\n      Initialize PCX raster file header.\n    */\n    pcx_info.identifier=0x0a;\n    pcx_info.version=5;\n    pcx_info.encoding=image_info->compression == NoCompression ? 0 : 1;\n    pcx_info.bits_per_pixel=8;\n    if ((image->storage_class == PseudoClass) &&\n        (SetImageMonochrome(image,exception) != MagickFalse))\n      pcx_info.bits_per_pixel=1;\n    pcx_info.left=0;\n    pcx_info.top=0;\n    pcx_info.right=(unsigned short) (image->columns-1);\n    pcx_info.bottom=(unsigned short) (image->rows-1);\n    switch (image->units)\n    {\n      case UndefinedResolution:\n      case PixelsPerInchResolution:\n      default:\n      {\n        pcx_info.horizontal_resolution=(unsigned short) image->resolution.x;\n        pcx_info.vertical_resolution=(unsigned short) image->resolution.y;\n        break;\n      }\n      case PixelsPerCentimeterResolution:\n      {\n        pcx_info.horizontal_resolution=(unsigned short)\n          (2.54*image->resolution.x+0.5);\n        pcx_info.vertical_resolution=(unsigned short)\n          (2.54*image->resolution.y+0.5);\n        break;\n      }\n    }\n    pcx_info.reserved=0;\n    pcx_info.planes=1;\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        pcx_info.planes=3;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          pcx_info.planes++;\n      }\n    pcx_info.bytes_per_line=(unsigned short) (((size_t) image->columns*\n      pcx_info.bits_per_pixel+7)/8);\n    pcx_info.palette_info=1;\n    pcx_info.colormap_signature=0x0c;\n    /*\n      Write PCX header.\n    */\n    (void) WriteBlobByte(image,pcx_info.identifier);\n    (void) WriteBlobByte(image,pcx_info.version);\n    (void) WriteBlobByte(image,pcx_info.encoding);\n    (void) WriteBlobByte(image,pcx_info.bits_per_pixel);\n    (void) WriteBlobLSBShort(image,pcx_info.left);\n    (void) WriteBlobLSBShort(image,pcx_info.top);\n    (void) WriteBlobLSBShort(image,pcx_info.right);\n    (void) WriteBlobLSBShort(image,pcx_info.bottom);\n    (void) WriteBlobLSBShort(image,pcx_info.horizontal_resolution);\n    (void) WriteBlobLSBShort(image,pcx_info.vertical_resolution);\n    /*\n      Dump colormap to file.\n    */\n    pcx_colormap=(unsigned char *) AcquireQuantumMemory(256UL,\n      3*sizeof(*pcx_colormap));\n    if (pcx_colormap == (unsigned char *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) memset(pcx_colormap,0,3*256*sizeof(*pcx_colormap));\n    q=pcx_colormap;\n    if ((image->storage_class == PseudoClass) && (image->colors <= 256))\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        *q++=ScaleQuantumToChar(image->colormap[i].red);\n        *q++=ScaleQuantumToChar(image->colormap[i].green);\n        *q++=ScaleQuantumToChar(image->colormap[i].blue);\n      }\n    (void) WriteBlob(image,3*16,(const unsigned char *) pcx_colormap);\n    (void) WriteBlobByte(image,pcx_info.reserved);\n    (void) WriteBlobByte(image,pcx_info.planes);\n    (void) WriteBlobLSBShort(image,pcx_info.bytes_per_line);\n    (void) WriteBlobLSBShort(image,pcx_info.palette_info);\n    for (i=0; i < 58; i++)\n      (void) WriteBlobByte(image,'\\0');\n    length=(size_t) pcx_info.bytes_per_line;\n    pixel_info=AcquireVirtualMemory(length,pcx_info.planes*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    q=pixels;\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        /*\n          Convert DirectClass image to PCX raster pixels.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=pixels;\n          for (i=0; i < pcx_info.planes; i++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            switch ((int) i)\n            {\n              case 0:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n              case 1:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n              case 2:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n              case 3:\n              default:\n              {\n                for (x=(ssize_t) pcx_info.bytes_per_line; x != 0; x--)\n                {\n                  *q++=ScaleQuantumToChar((Quantum) (GetPixelAlpha(image,p)));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n            }\n          }\n          if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      {\n        if (pcx_info.bits_per_pixel > 1)\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            q=pixels;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              *q++=(unsigned char) GetPixelIndex(image,p);\n              p+=GetPixelChannels(image);\n            }\n            if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        else\n          {\n            register unsigned char\n              bit,\n              byte;\n\n            /*\n              Convert PseudoClass image to a PCX monochrome image.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              bit=0;\n              byte=0;\n              q=pixels;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte<<=1;\n                if (GetPixelLuma(image,p) >= (QuantumRange/2.0))\n                  byte|=0x01;\n                bit++;\n                if (bit == 8)\n                  {\n                    *q++=byte;\n                    bit=0;\n                    byte=0;\n                  }\n                p+=GetPixelChannels(image);\n              }\n              if (bit != 0)\n                *q++=byte << (8-bit);\n              if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        (void) WriteBlobByte(image,pcx_info.colormap_signature);\n        (void) WriteBlob(image,3*256,pcx_colormap);\n      }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);\n    if (page_table == (MagickOffsetType *) NULL)\n      break;\n    if (scene >= 1023)\n      break;\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  if (page_table != (MagickOffsetType *) NULL)\n    {\n      /*\n        Write the DCX page table.\n      */\n      page_table[scene+1]=0;\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        ThrowWriterException(CorruptImageError,\"ImproperImageHeader\");\n      (void) WriteBlobLSBLong(image,0x3ADE68B1L);\n      for (i=0; i <= (ssize_t) scene; i++)\n        (void) WriteBlobLSBLong(image,(unsigned int) page_table[i]);\n      page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n    }\n  if (status == MagickFalse)\n    {\n      char\n        *message;\n\n      message=GetExceptionMessage(errno);\n      (void) ThrowMagickException(exception,GetMagickModule(),FileOpenError,\n        \"UnableToWriteFile\",\"`%s': %s\",image->filename,message);\n      message=DestroyString(message);\n    }\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
        "func": "static MagickBooleanType WritePCXImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    *page_table,\n    scene;\n\n  MemoryInfo\n    *pixel_info;\n\n  PCXInfo\n    pcx_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pcx_colormap,\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  page_table=(MagickOffsetType *) NULL;\n  if ((LocaleCompare(image_info->magick,\"DCX\") == 0) ||\n      ((GetNextImageInList(image) != (Image *) NULL) &&\n       (image_info->adjoin != MagickFalse)))\n    {\n      /*\n        Write the DCX page table.\n      */\n      (void) WriteBlobLSBLong(image,0x3ADE68B1L);\n      page_table=(MagickOffsetType *) AcquireQuantumMemory(1024UL,\n        sizeof(*page_table));\n      if (page_table == (MagickOffsetType *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (scene=0; scene < 1024; scene++)\n        (void) WriteBlobLSBLong(image,0x00000000L);\n    }\n  scene=0;\n  do\n  {\n    if (page_table != (MagickOffsetType *) NULL)\n      page_table[scene]=TellBlob(image);\n    /*\n      Initialize PCX raster file header.\n    */\n    pcx_info.identifier=0x0a;\n    pcx_info.version=5;\n    pcx_info.encoding=image_info->compression == NoCompression ? 0 : 1;\n    pcx_info.bits_per_pixel=8;\n    if ((image->storage_class == PseudoClass) &&\n        (SetImageMonochrome(image,exception) != MagickFalse))\n      pcx_info.bits_per_pixel=1;\n    pcx_info.left=0;\n    pcx_info.top=0;\n    pcx_info.right=(unsigned short) (image->columns-1);\n    pcx_info.bottom=(unsigned short) (image->rows-1);\n    switch (image->units)\n    {\n      case UndefinedResolution:\n      case PixelsPerInchResolution:\n      default:\n      {\n        pcx_info.horizontal_resolution=(unsigned short) image->resolution.x;\n        pcx_info.vertical_resolution=(unsigned short) image->resolution.y;\n        break;\n      }\n      case PixelsPerCentimeterResolution:\n      {\n        pcx_info.horizontal_resolution=(unsigned short)\n          (2.54*image->resolution.x+0.5);\n        pcx_info.vertical_resolution=(unsigned short)\n          (2.54*image->resolution.y+0.5);\n        break;\n      }\n    }\n    pcx_info.reserved=0;\n    pcx_info.planes=1;\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        pcx_info.planes=3;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          pcx_info.planes++;\n      }\n    pcx_info.bytes_per_line=(unsigned short) (((size_t) image->columns*\n      pcx_info.bits_per_pixel+7)/8);\n    pcx_info.palette_info=1;\n    pcx_info.colormap_signature=0x0c;\n    /*\n      Write PCX header.\n    */\n    (void) WriteBlobByte(image,pcx_info.identifier);\n    (void) WriteBlobByte(image,pcx_info.version);\n    (void) WriteBlobByte(image,pcx_info.encoding);\n    (void) WriteBlobByte(image,pcx_info.bits_per_pixel);\n    (void) WriteBlobLSBShort(image,pcx_info.left);\n    (void) WriteBlobLSBShort(image,pcx_info.top);\n    (void) WriteBlobLSBShort(image,pcx_info.right);\n    (void) WriteBlobLSBShort(image,pcx_info.bottom);\n    (void) WriteBlobLSBShort(image,pcx_info.horizontal_resolution);\n    (void) WriteBlobLSBShort(image,pcx_info.vertical_resolution);\n    /*\n      Dump colormap to file.\n    */\n    pcx_colormap=(unsigned char *) AcquireQuantumMemory(256UL,\n      3*sizeof(*pcx_colormap));\n    if (pcx_colormap == (unsigned char *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) memset(pcx_colormap,0,3*256*sizeof(*pcx_colormap));\n    q=pcx_colormap;\n    if ((image->storage_class == PseudoClass) && (image->colors <= 256))\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        *q++=ScaleQuantumToChar(image->colormap[i].red);\n        *q++=ScaleQuantumToChar(image->colormap[i].green);\n        *q++=ScaleQuantumToChar(image->colormap[i].blue);\n      }\n    (void) WriteBlob(image,3*16,(const unsigned char *) pcx_colormap);\n    (void) WriteBlobByte(image,pcx_info.reserved);\n    (void) WriteBlobByte(image,pcx_info.planes);\n    (void) WriteBlobLSBShort(image,pcx_info.bytes_per_line);\n    (void) WriteBlobLSBShort(image,pcx_info.palette_info);\n    for (i=0; i < 58; i++)\n      (void) WriteBlobByte(image,'\\0');\n    length=(size_t) pcx_info.bytes_per_line;\n    pixel_info=AcquireVirtualMemory(length,pcx_info.planes*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      {\n        pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    q=pixels;\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        /*\n          Convert DirectClass image to PCX raster pixels.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=pixels;\n          for (i=0; i < pcx_info.planes; i++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            switch ((int) i)\n            {\n              case 0:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n              case 1:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n              case 2:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n              case 3:\n              default:\n              {\n                for (x=(ssize_t) pcx_info.bytes_per_line; x != 0; x--)\n                {\n                  *q++=ScaleQuantumToChar((Quantum) (GetPixelAlpha(image,p)));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n            }\n          }\n          if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      {\n        if (pcx_info.bits_per_pixel > 1)\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            q=pixels;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              *q++=(unsigned char) GetPixelIndex(image,p);\n              p+=GetPixelChannels(image);\n            }\n            if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        else\n          {\n            register unsigned char\n              bit,\n              byte;\n\n            /*\n              Convert PseudoClass image to a PCX monochrome image.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              bit=0;\n              byte=0;\n              q=pixels;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte<<=1;\n                if (GetPixelLuma(image,p) >= (QuantumRange/2.0))\n                  byte|=0x01;\n                bit++;\n                if (bit == 8)\n                  {\n                    *q++=byte;\n                    bit=0;\n                    byte=0;\n                  }\n                p+=GetPixelChannels(image);\n              }\n              if (bit != 0)\n                *q++=byte << (8-bit);\n              if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        (void) WriteBlobByte(image,pcx_info.colormap_signature);\n        (void) WriteBlob(image,3*256,pcx_colormap);\n      }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);\n    if (page_table == (MagickOffsetType *) NULL)\n      break;\n    if (scene >= 1023)\n      break;\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  if (page_table != (MagickOffsetType *) NULL)\n    {\n      /*\n        Write the DCX page table.\n      */\n      page_table[scene+1]=0;\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        ThrowWriterException(CorruptImageError,\"ImproperImageHeader\");\n      (void) WriteBlobLSBLong(image,0x3ADE68B1L);\n      for (i=0; i <= (ssize_t) scene; i++)\n        (void) WriteBlobLSBLong(image,(unsigned int) page_table[i]);\n      page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n    }\n  if (status == MagickFalse)\n    {\n      char\n        *message;\n\n      message=GetExceptionMessage(errno);\n      (void) ThrowMagickException(exception,GetMagickModule(),FileOpenError,\n        \"UnableToWriteFile\",\"`%s': %s\",image->filename,message);\n      message=DestroyString(message);\n    }\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -155,7 +155,10 @@\n     length=(size_t) pcx_info.bytes_per_line;\n     pixel_info=AcquireVirtualMemory(length,pcx_info.planes*sizeof(*pixels));\n     if (pixel_info == (MemoryInfo *) NULL)\n-      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n+      {\n+        pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);\n+        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n+      }\n     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n     q=pixels;\n     if ((image->storage_class == DirectClass) || (image->colors > 256))",
        "diff_line_info": {
            "deleted_lines": [
                "      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");"
            ],
            "added_lines": [
                "      {",
                "        pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);",
                "        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12669",
        "func_name": "ImageMagick/WriteCALSImage",
        "description": "ImageMagick 7.0.6-2 has a memory leak vulnerability in WriteCALSImage in coders/cals.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/73b6c35cede48ccb2e29dbe62c2d77488e5e70b7",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/571",
        "commit_text": "",
        "func_before": "static MagickBooleanType WriteCALSImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    header[129];\n\n  Image\n    *group4_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    density,\n    length,\n    orient_x,\n    orient_y;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *group4;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Create standard CALS header.\n  */\n  count=WriteCALSRecord(image,\"srcdocid: NONE\");\n  (void) count;\n  count=WriteCALSRecord(image,\"dstdocid: NONE\");\n  count=WriteCALSRecord(image,\"txtfilid: NONE\");\n  count=WriteCALSRecord(image,\"figid: NONE\");\n  count=WriteCALSRecord(image,\"srcgph: NONE\");\n  count=WriteCALSRecord(image,\"doccls: NONE\");\n  count=WriteCALSRecord(image,\"rtype: 1\");\n  orient_x=0;\n  orient_y=0;\n  switch (image->orientation)\n  {\n    case TopRightOrientation:\n    {\n      orient_x=180;\n      orient_y=270;\n      break;\n    }\n    case BottomRightOrientation:\n    {\n      orient_x=180;\n      orient_y=90;\n      break;\n    }\n    case BottomLeftOrientation:\n    {\n      orient_y=90;\n      break;\n    }\n    case LeftTopOrientation:\n    {\n      orient_x=270;\n      break;\n    }\n    case RightTopOrientation:\n    {\n      orient_x=270;\n      orient_y=180;\n      break;\n    }\n    case RightBottomOrientation:\n    {\n      orient_x=90;\n      orient_y=180;\n      break;\n    }\n    case LeftBottomOrientation:\n    {\n      orient_x=90;\n      break;\n    }\n    default:\n    {\n      orient_y=270;\n      break;\n    }\n  }\n  (void) FormatLocaleString(header,sizeof(header),\"rorient: %03ld,%03ld\",\n    (long) orient_x,(long) orient_y);\n  count=WriteCALSRecord(image,header);\n  (void) FormatLocaleString(header,sizeof(header),\"rpelcnt: %06lu,%06lu\",\n    (unsigned long) image->columns,(unsigned long) image->rows);\n  count=WriteCALSRecord(image,header);  \n  density=200;\n  if (image_info->density != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      (void) ParseGeometry(image_info->density,&geometry_info);\n      density=(size_t) floor(geometry_info.rho+0.5);\n    }\n  (void) FormatLocaleString(header,sizeof(header),\"rdensty: %04lu\",\n    (unsigned long) density);\n  count=WriteCALSRecord(image,header);\n  count=WriteCALSRecord(image,\"notes: NONE\");\n  (void) ResetMagickMemory(header,' ',128);\n  for (i=0; i < 5; i++)\n    (void) WriteBlob(image,128,(unsigned char *) header);\n  /*\n    Write CALS pixels.\n  */\n  write_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(write_info->filename,\"GROUP4:\",MagickPathExtent);\n  (void) CopyMagickString(write_info->magick,\"GROUP4\",MagickPathExtent);\n  group4_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (group4_image == (Image *) NULL)\n    {\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  group4=(unsigned char *) ImageToBlob(write_info,group4_image,&length,\n    exception);\n  group4_image=DestroyImage(group4_image);\n  if (group4 == (unsigned char *) NULL)\n    {\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  write_info=DestroyImageInfo(write_info);\n  if (WriteBlob(image,length,group4) != (ssize_t) length)\n    status=MagickFalse;\n  group4=(unsigned char *) RelinquishMagickMemory(group4);\n  (void) CloseBlob(image);\n  return(status);\n}",
        "func": "static MagickBooleanType WriteCALSImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    header[129];\n\n  Image\n    *group4_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    density,\n    length,\n    orient_x,\n    orient_y;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *group4;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Create standard CALS header.\n  */\n  count=WriteCALSRecord(image,\"srcdocid: NONE\");\n  (void) count;\n  count=WriteCALSRecord(image,\"dstdocid: NONE\");\n  count=WriteCALSRecord(image,\"txtfilid: NONE\");\n  count=WriteCALSRecord(image,\"figid: NONE\");\n  count=WriteCALSRecord(image,\"srcgph: NONE\");\n  count=WriteCALSRecord(image,\"doccls: NONE\");\n  count=WriteCALSRecord(image,\"rtype: 1\");\n  orient_x=0;\n  orient_y=0;\n  switch (image->orientation)\n  {\n    case TopRightOrientation:\n    {\n      orient_x=180;\n      orient_y=270;\n      break;\n    }\n    case BottomRightOrientation:\n    {\n      orient_x=180;\n      orient_y=90;\n      break;\n    }\n    case BottomLeftOrientation:\n    {\n      orient_y=90;\n      break;\n    }\n    case LeftTopOrientation:\n    {\n      orient_x=270;\n      break;\n    }\n    case RightTopOrientation:\n    {\n      orient_x=270;\n      orient_y=180;\n      break;\n    }\n    case RightBottomOrientation:\n    {\n      orient_x=90;\n      orient_y=180;\n      break;\n    }\n    case LeftBottomOrientation:\n    {\n      orient_x=90;\n      break;\n    }\n    default:\n    {\n      orient_y=270;\n      break;\n    }\n  }\n  (void) FormatLocaleString(header,sizeof(header),\"rorient: %03ld,%03ld\",\n    (long) orient_x,(long) orient_y);\n  count=WriteCALSRecord(image,header);\n  (void) FormatLocaleString(header,sizeof(header),\"rpelcnt: %06lu,%06lu\",\n    (unsigned long) image->columns,(unsigned long) image->rows);\n  count=WriteCALSRecord(image,header);  \n  density=200;\n  if (image_info->density != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      (void) ParseGeometry(image_info->density,&geometry_info);\n      density=(size_t) floor(geometry_info.rho+0.5);\n    }\n  (void) FormatLocaleString(header,sizeof(header),\"rdensty: %04lu\",\n    (unsigned long) density);\n  count=WriteCALSRecord(image,header);\n  count=WriteCALSRecord(image,\"notes: NONE\");\n  (void) ResetMagickMemory(header,' ',128);\n  for (i=0; i < 5; i++)\n    (void) WriteBlob(image,128,(unsigned char *) header);\n  /*\n    Write CALS pixels.\n  */\n  write_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(write_info->filename,\"GROUP4:\",MagickPathExtent);\n  (void) CopyMagickString(write_info->magick,\"GROUP4\",MagickPathExtent);\n  group4_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (group4_image == (Image *) NULL)\n    {\n      write_info=DestroyImageInfo(write_info);\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  group4=(unsigned char *) ImageToBlob(write_info,group4_image,&length,\n    exception);\n  group4_image=DestroyImage(group4_image);\n  if (group4 == (unsigned char *) NULL)\n    {\n      write_info=DestroyImageInfo(write_info);\n      (void) CloseBlob(image);\n      return(MagickFalse);\n    }\n  write_info=DestroyImageInfo(write_info);\n  if (WriteBlob(image,length,group4) != (ssize_t) length)\n    status=MagickFalse;\n  group4=(unsigned char *) RelinquishMagickMemory(group4);\n  (void) CloseBlob(image);\n  return(status);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -133,6 +133,7 @@\n   group4_image=CloneImage(image,0,0,MagickTrue,exception);\n   if (group4_image == (Image *) NULL)\n     {\n+      write_info=DestroyImageInfo(write_info);\n       (void) CloseBlob(image);\n       return(MagickFalse);\n     }\n@@ -141,6 +142,7 @@\n   group4_image=DestroyImage(group4_image);\n   if (group4 == (unsigned char *) NULL)\n     {\n+      write_info=DestroyImageInfo(write_info);\n       (void) CloseBlob(image);\n       return(MagickFalse);\n     }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      write_info=DestroyImageInfo(write_info);",
                "      write_info=DestroyImageInfo(write_info);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12672",
        "func_name": "ImageMagick/ReadMATImage",
        "description": "In ImageMagick 7.0.6-3, a memory leak vulnerability was found in the function ReadMATImage in coders/mat.c, which allows attackers to cause a denial of service.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/f9b992dd2a4caab1dace919f9190b2c173a4e18c",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/617",
        "commit_text": "",
        "func_before": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if (image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  else\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n  return (image);\n}",
        "func": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if (image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  else\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n  return (image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -89,6 +89,8 @@\n   if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n     {\n MATLAB_KO:\n+      if ((image != image2) && (image2 != (Image *) NULL))\n+        image2=DestroyImage(image2);\n       if (clone_info != (ImageInfo *) NULL)\n         clone_info=DestroyImageInfo(clone_info);\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      if ((image != image2) && (image2 != (Image *) NULL))",
                "        image2=DestroyImage(image2);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12675",
        "func_name": "ImageMagick/ReadMATImage",
        "description": "In ImageMagick 7.0.6-3, a missing check for multidimensional data was found in coders/mat.c, leading to a memory leak in the function ReadImage in MagickCore/constitute.c, which allows attackers to cause a denial of service.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/7a020acbcfea6e53eff6766c87ea175eac9dcd18",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/616",
        "commit_text": "",
        "func_before": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  register Quantum *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info,exception);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  clone_info=(ImageInfo *) NULL;\n  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           (void) ReadBlobXXXLong(image2);\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\n    NEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n    /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        image->type=GrayscaleType;\n        SetImageColorspace(image,GRAYColorspace,exception);\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(image,q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n            exception);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n            exception);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image,exception);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n        }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if (image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  else\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n  return (image);\n}",
        "func": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  register Quantum *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info,exception);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  clone_info=(ImageInfo *) NULL;\n  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           (void) ReadBlobXXXLong(image2);\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default:\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\n    NEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n    /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        image->type=GrayscaleType;\n        SetImageColorspace(image,GRAYColorspace,exception);\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(image,q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n            exception);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n            exception);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image,exception);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n        }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if (image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  else\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n  return (image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -154,7 +154,12 @@\n          if (Frames == 0)\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          break;\n-      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n+      default:\n+        if (clone_info != (ImageInfo *) NULL)\n+          clone_info=DestroyImageInfo(clone_info);\n+        if ((image != image2) && (image2 != (Image *) NULL))\n+          image2=DestroyImage(image2);\n+        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n     }\n \n     MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);",
        "diff_line_info": {
            "deleted_lines": [
                "      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");"
            ],
            "added_lines": [
                "      default:",
                "        if (clone_info != (ImageInfo *) NULL)",
                "          clone_info=DestroyImageInfo(clone_info);",
                "        if ((image != image2) && (image2 != (Image *) NULL))",
                "          image2=DestroyImage(image2);",
                "        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12676",
        "func_name": "ImageMagick/ReadOneJNGImage",
        "description": "In ImageMagick 7.0.6-3, a memory leak vulnerability was found in the function ReadOneJNGImage in coders/png.c, which allows attackers to cause a denial of service.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/7287f50888c26b133ee173816332fcaec4e8cb62",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/618",
        "commit_text": "",
        "func_before": "static Image *ReadOneJNGImage(MngInfo *mng_info,\n    const ImageInfo *image_info, ExceptionInfo *exception)\n{\n  Image\n    *alpha_image,\n    *color_image,\n    *image,\n    *jng_image;\n\n  ImageInfo\n    *alpha_image_info,\n    *color_image_info;\n\n  MagickBooleanType\n    logging;\n\n  int\n    unique_filenames;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    status;\n\n  png_uint_32\n    jng_height,\n    jng_width;\n\n  png_byte\n    jng_color_type,\n    jng_image_sample_depth,\n    jng_image_compression_method,\n    jng_image_interlace_method,\n    jng_alpha_sample_depth,\n    jng_alpha_compression_method,\n    jng_alpha_filter_method,\n    jng_alpha_interlace_method;\n\n  register const PixelPacket\n    *s;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *p;\n\n  unsigned int\n    read_JSEP,\n    reading_idat;\n\n  size_t\n    length;\n\n  jng_alpha_compression_method=0;\n  jng_alpha_sample_depth=8;\n  jng_color_type=0;\n  jng_height=0;\n  jng_width=0;\n  alpha_image=(Image *) NULL;\n  color_image=(Image *) NULL;\n  alpha_image_info=(ImageInfo *) NULL;\n  color_image_info=(ImageInfo *) NULL;\n  unique_filenames=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneJNGImage()\");\n\n  image=mng_info->image;\n\n  if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n    {\n      /*\n        Allocate next image structure.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  AcquireNextImage()\");\n\n      AcquireNextImage(image_info,image);\n\n      if (GetNextImageInList(image) == (Image *) NULL)\n        return(DestroyImageList(image));\n\n      image=SyncNextImageInList(image);\n    }\n  mng_info->image=image;\n\n  /*\n    Signature bytes have already been read.\n  */\n\n  read_JSEP=MagickFalse;\n  reading_idat=MagickFalse;\n  for (;;)\n  {\n    char\n      type[MaxTextExtent];\n\n    unsigned char\n      *chunk;\n\n    unsigned int\n      count;\n\n    /*\n      Read a new JNG chunk.\n    */\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      2*GetBlobSize(image));\n\n    if (status == MagickFalse)\n      break;\n\n    type[0]='\\0';\n    (void) ConcatenateMagickString(type,\"errr\",MaxTextExtent);\n    length=ReadBlobMSBLong(image);\n    count=(unsigned int) ReadBlob(image,4,(unsigned char *) type);\n\n    if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Reading JNG chunk type %c%c%c%c, length: %.20g\",\n        type[0],type[1],type[2],type[3],(double) length);\n\n    if (length > PNG_UINT_31_MAX || count == 0)\n      {\n        DestroyJNG(NULL,&color_image,&color_image_info,\n          &alpha_image,&alpha_image_info);\n        ThrowReaderException(CorruptImageError,\"CorruptImage\");\n      }\n\n    p=NULL;\n    chunk=(unsigned char *) NULL;\n\n    if (length != 0)\n      {\n        if (length > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));\n\n        if (chunk == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        for (i=0; i < (ssize_t) length; i++)\n        {\n          int\n            c;\n\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            break;\n          chunk[i]=(unsigned char) c;\n        }\n\n        p=chunk;\n      }\n\n    (void) ReadBlobMSBLong(image);  /* read crc word */\n\n    if (memcmp(type,mng_JHDR,4) == 0)\n      {\n        if (length == 16)\n          {\n            jng_width=(png_uint_32)mng_get_long(p);\n            jng_height=(png_uint_32)mng_get_long(&p[4]);\n            if ((jng_width == 0) || (jng_height == 0))\n              ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n            jng_color_type=p[8];\n            jng_image_sample_depth=p[9];\n            jng_image_compression_method=p[10];\n            jng_image_interlace_method=p[11];\n\n            image->interlace=jng_image_interlace_method != 0 ? PNGInterlace :\n              NoInterlace;\n\n            jng_alpha_sample_depth=p[12];\n            jng_alpha_compression_method=p[13];\n            jng_alpha_filter_method=p[14];\n            jng_alpha_interlace_method=p[15];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_width:      %16lu,    jng_height:     %16lu\\n\"\n                  \"    jng_color_type: %16d,     jng_image_sample_depth: %3d\\n\"\n                  \"    jng_image_compression_method:%3d\",\n                  (unsigned long) jng_width, (unsigned long) jng_height,\n                  jng_color_type, jng_image_sample_depth,\n                  jng_image_compression_method);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_image_interlace_method:  %3d\"\n                  \"    jng_alpha_sample_depth:      %3d\",\n                  jng_image_interlace_method,\n                  jng_alpha_sample_depth);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_alpha_compression_method:%3d\\n\"\n                  \"    jng_alpha_filter_method:     %3d\\n\"\n                  \"    jng_alpha_interlace_method:  %3d\",\n                  jng_alpha_compression_method,\n                  jng_alpha_filter_method,\n                  jng_alpha_interlace_method);\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        if (jng_width > 65535 || jng_height > 65535 ||\n             (long) jng_width > GetMagickResourceLimit(WidthResource) ||\n             (long) jng_height > GetMagickResourceLimit(HeightResource))\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    JNG width or height too large: (%lu x %lu)\",\n                (long) jng_width, (long) jng_height);\n            DestroyJNG(chunk,&color_image,&color_image_info,\n              &alpha_image,&alpha_image_info);\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          }\n\n        continue;\n      }\n\n\n    if ((reading_idat == MagickFalse) && (read_JSEP == MagickFalse) &&\n        ((memcmp(type,mng_JDAT,4) == 0) || (memcmp(type,mng_JdAA,4) == 0) ||\n         (memcmp(type,mng_IDAT,4) == 0) || (memcmp(type,mng_JDAA,4) == 0)))\n      {\n        /*\n           o create color_image\n           o open color_blob, attached to color_image\n           o if (color type has alpha)\n               open alpha_blob, attached to alpha_image\n        */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Creating color_blob.\");\n\n        color_image_info=(ImageInfo *)AcquireMagickMemory(sizeof(ImageInfo));\n\n        if (color_image_info == (ImageInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        GetImageInfo(color_image_info);\n        color_image=AcquireImage(color_image_info);\n\n        if (color_image == (Image *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        (void) AcquireUniqueFilename(color_image->filename);\n        unique_filenames++;\n        status=OpenBlob(color_image_info,color_image,WriteBinaryBlobMode,\n          exception);\n\n        if (status == MagickFalse)\n          {\n            color_image=DestroyImage(color_image);\n            return(DestroyImageList(image));\n          }\n\n        if ((image_info->ping == MagickFalse) && (jng_color_type >= 12))\n          {\n            alpha_image_info=(ImageInfo *)\n              AcquireMagickMemory(sizeof(ImageInfo));\n\n            if (alpha_image_info == (ImageInfo *) NULL)\n              {\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            GetImageInfo(alpha_image_info);\n            alpha_image=AcquireImage(alpha_image_info);\n\n            if (alpha_image == (Image *) NULL)\n              {\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Creating alpha_blob.\");\n\n            (void) AcquireUniqueFilename(alpha_image->filename);\n            unique_filenames++;\n            status=OpenBlob(alpha_image_info,alpha_image,WriteBinaryBlobMode,\n              exception);\n\n            if (status == MagickFalse)\n              {\n                alpha_image=DestroyImage(alpha_image);\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                return(DestroyImageList(image));\n              }\n\n            if (jng_alpha_compression_method == 0)\n              {\n                unsigned char\n                  data[18];\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Writing IHDR chunk to alpha_blob.\");\n\n                (void) WriteBlob(alpha_image,8,(const unsigned char *)\n                  \"\\211PNG\\r\\n\\032\\n\");\n\n                (void) WriteBlobMSBULong(alpha_image,13L);\n                PNGType(data,mng_IHDR);\n                LogPNGChunk(logging,mng_IHDR,13L);\n                PNGLong(data+4,jng_width);\n                PNGLong(data+8,jng_height);\n                data[12]=jng_alpha_sample_depth;\n                data[13]=0; /* color_type gray */\n                data[14]=0; /* compression method 0 */\n                data[15]=0; /* filter_method 0 */\n                data[16]=0; /* interlace_method 0 */\n                (void) WriteBlob(alpha_image,17,data);\n                (void) WriteBlobMSBULong(alpha_image,crc32(0,data,17));\n              }\n          }\n        reading_idat=MagickTrue;\n      }\n\n    if (memcmp(type,mng_JDAT,4) == 0)\n      {\n        /* Copy chunk to color_image->blob */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Copying JDAT chunk data to color_blob.\");\n\n        if (length != 0)\n          {\n            (void) WriteBlob(color_image,length,chunk);\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n          }\n\n        continue;\n      }\n\n    if (memcmp(type,mng_IDAT,4) == 0)\n      {\n        png_byte\n           data[5];\n\n        /* Copy IDAT header and chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying IDAT chunk data to alpha_blob.\");\n\n            (void) WriteBlobMSBULong(alpha_image,(size_t) length);\n            PNGType(data,mng_IDAT);\n            LogPNGChunk(logging,mng_IDAT,length);\n            (void) WriteBlob(alpha_image,4,data);\n            (void) WriteBlob(alpha_image,length,chunk);\n            (void) WriteBlobMSBULong(alpha_image,\n              crc32(crc32(0,data,4),chunk,(uInt) length));\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if ((memcmp(type,mng_JDAA,4) == 0) || (memcmp(type,mng_JdAA,4) == 0))\n      {\n        /* Copy chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying JDAA chunk data to alpha_blob.\");\n\n            (void) WriteBlob(alpha_image,length,chunk);\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_JSEP,4) == 0)\n      {\n        read_JSEP=MagickTrue;\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_bKGD,4) == 0)\n      {\n        if (length == 2)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=image->background_color.red;\n            image->background_color.blue=image->background_color.red;\n          }\n\n        if (length == 6)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=ScaleCharToQuantum(p[3]);\n            image->background_color.blue=ScaleCharToQuantum(p[5]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_gAMA,4) == 0)\n      {\n        if (length == 4)\n          image->gamma=((float) mng_get_long(p))*0.00001;\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_cHRM,4) == 0)\n      {\n        if (length == 32)\n          {\n            image->chromaticity.white_point.x=0.00001*mng_get_long(p);\n            image->chromaticity.white_point.y=0.00001*mng_get_long(&p[4]);\n            image->chromaticity.red_primary.x=0.00001*mng_get_long(&p[8]);\n            image->chromaticity.red_primary.y=0.00001*mng_get_long(&p[12]);\n            image->chromaticity.green_primary.x=0.00001*mng_get_long(&p[16]);\n            image->chromaticity.green_primary.y=0.00001*mng_get_long(&p[20]);\n            image->chromaticity.blue_primary.x=0.00001*mng_get_long(&p[24]);\n            image->chromaticity.blue_primary.y=0.00001*mng_get_long(&p[28]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_sRGB,4) == 0)\n      {\n        if (length == 1)\n          {\n            image->rendering_intent=\n              Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n            image->gamma=1.000f/2.200f;\n            image->chromaticity.red_primary.x=0.6400f;\n            image->chromaticity.red_primary.y=0.3300f;\n            image->chromaticity.green_primary.x=0.3000f;\n            image->chromaticity.green_primary.y=0.6000f;\n            image->chromaticity.blue_primary.x=0.1500f;\n            image->chromaticity.blue_primary.y=0.0600f;\n            image->chromaticity.white_point.x=0.3127f;\n            image->chromaticity.white_point.y=0.3290f;\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_oFFs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->page.x=(ssize_t) mng_get_long(p);\n            image->page.y=(ssize_t) mng_get_long(&p[4]);\n\n            if ((int) p[8] != 0)\n              {\n                image->page.x/=10000;\n                image->page.y/=10000;\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_pHYs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->x_resolution=(double) mng_get_long(p);\n            image->y_resolution=(double) mng_get_long(&p[4]);\n            if ((int) p[8] == PNG_RESOLUTION_METER)\n              {\n                image->units=PixelsPerCentimeterResolution;\n                image->x_resolution=image->x_resolution/100.0f;\n                image->y_resolution=image->y_resolution/100.0f;\n              }\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n#if 0\n    if (memcmp(type,mng_iCCP,4) == 0)\n      {\n        /* To do: */\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n#endif\n\n    if (length != 0)\n      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n    if (memcmp(type,mng_IEND,4))\n      continue;\n\n    break;\n  }\n\n\n  /* IEND found */\n\n  /*\n    Finish up reading image data:\n\n       o read main image from color_blob.\n\n       o close color_blob.\n\n       o if (color_type has alpha)\n            if alpha_encoding is PNG\n               read secondary image from alpha_blob via ReadPNG\n            if alpha_encoding is JPEG\n               read secondary image from alpha_blob via ReadJPEG\n\n       o close alpha_blob.\n\n       o copy intensity of secondary image into\n         opacity samples of main image.\n\n       o destroy the secondary image.\n  */\n\n  if (color_image_info == (ImageInfo *) NULL)\n    {\n      assert(color_image == (Image *) NULL);\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  if (color_image == (Image *) NULL)\n    {\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  (void) SeekBlob(color_image,0,SEEK_SET);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Reading jng_image from color_blob.\");\n\n  assert(color_image_info != (ImageInfo *) NULL);\n  (void) FormatLocaleString(color_image_info->filename,MaxTextExtent,\"%s\",\n    color_image->filename);\n\n  color_image_info->ping=MagickFalse;   /* To do: avoid this */\n  jng_image=ReadImage(color_image_info,exception);\n\n  (void) RelinquishUniqueFileResource(color_image->filename);\n  unique_filenames--;\n  color_image=DestroyImage(color_image);\n  color_image_info=DestroyImageInfo(color_image_info);\n\n  if (jng_image == (Image *) NULL)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Copying jng_image pixels to main image.\");\n  image->columns=jng_width;\n  image->rows=jng_height;\n  length=image->columns*sizeof(PixelPacket);\n\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    s=GetVirtualPixels(jng_image,0,y,image->columns,1,&image->exception);\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    (void) CopyMagickMemory(q,s,length);\n\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n\n  jng_image=DestroyImage(jng_image);\n\n  if (image_info->ping == MagickFalse)\n    {\n     if (jng_color_type >= 12)\n       {\n         if (jng_alpha_compression_method == 0)\n           {\n             png_byte\n               data[5];\n             (void) WriteBlobMSBULong(alpha_image,0x00000000L);\n             PNGType(data,mng_IEND);\n             LogPNGChunk(logging,mng_IEND,0L);\n             (void) WriteBlob(alpha_image,4,data);\n             (void) WriteBlobMSBULong(alpha_image,crc32(0,data,4));\n           }\n\n         (void) SeekBlob(alpha_image,0,SEEK_SET);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"    Reading opacity from alpha_blob.\");\n\n         (void) FormatLocaleString(alpha_image_info->filename,MaxTextExtent,\n           \"%s\",alpha_image->filename);\n\n         jng_image=ReadImage(alpha_image_info,exception);\n\n         if (jng_image != (Image *) NULL)\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             s=GetVirtualPixels(jng_image,0,y,image->columns,1,\n                &image->exception);\n             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (image->matte != MagickFalse)\n               for (x=(ssize_t) image->columns; x != 0; x--,q++,s++)\n                  SetPixelOpacity(q,QuantumRange-\n                      GetPixelRed(s));\n\n             else\n               for (x=(ssize_t) image->columns; x != 0; x--,q++,s++)\n               {\n                  SetPixelAlpha(q,GetPixelRed(s));\n                  if (GetPixelOpacity(q) != OpaqueOpacity)\n                    image->matte=MagickTrue;\n               }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n           }\n         (void) RelinquishUniqueFileResource(alpha_image->filename);\n         unique_filenames--;\n         alpha_image=DestroyImage(alpha_image);\n         alpha_image_info=DestroyImageInfo(alpha_image_info);\n         if (jng_image != (Image *) NULL)\n           jng_image=DestroyImage(jng_image);\n       }\n    }\n\n  /* Read the JNG image.  */\n\n  if (mng_info->mng_type == 0)\n    {\n      mng_info->mng_width=jng_width;\n      mng_info->mng_height=jng_height;\n    }\n\n  if (image->page.width == 0 && image->page.height == 0)\n    {\n      image->page.width=jng_width;\n      image->page.height=jng_height;\n    }\n\n  if (image->page.x == 0 && image->page.y == 0)\n    {\n      image->page.x=mng_info->x_off[mng_info->object_id];\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  else\n    {\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  mng_info->image_found++;\n  status=SetImageProgress(image,LoadImagesTag,2*TellBlob(image),\n    2*GetBlobSize(image));\n\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneJNGImage(); unique_filenames=%d\",unique_filenames);\n\n  return(image);\n}",
        "func": "static Image *ReadOneJNGImage(MngInfo *mng_info,\n    const ImageInfo *image_info, ExceptionInfo *exception)\n{\n  Image\n    *alpha_image,\n    *color_image,\n    *image,\n    *jng_image;\n\n  ImageInfo\n    *alpha_image_info,\n    *color_image_info;\n\n  MagickBooleanType\n    logging;\n\n  int\n    unique_filenames;\n\n  ssize_t\n    y;\n\n  MagickBooleanType\n    status;\n\n  png_uint_32\n    jng_height,\n    jng_width;\n\n  png_byte\n    jng_color_type,\n    jng_image_sample_depth,\n    jng_image_compression_method,\n    jng_image_interlace_method,\n    jng_alpha_sample_depth,\n    jng_alpha_compression_method,\n    jng_alpha_filter_method,\n    jng_alpha_interlace_method;\n\n  register const PixelPacket\n    *s;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  register unsigned char\n    *p;\n\n  unsigned int\n    read_JSEP,\n    reading_idat;\n\n  size_t\n    length;\n\n  jng_alpha_compression_method=0;\n  jng_alpha_sample_depth=8;\n  jng_color_type=0;\n  jng_height=0;\n  jng_width=0;\n  alpha_image=(Image *) NULL;\n  color_image=(Image *) NULL;\n  alpha_image_info=(ImageInfo *) NULL;\n  color_image_info=(ImageInfo *) NULL;\n  unique_filenames=0;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter ReadOneJNGImage()\");\n\n  image=mng_info->image;\n\n  if (GetAuthenticPixelQueue(image) != (PixelPacket *) NULL)\n    {\n      /*\n        Allocate next image structure.\n      */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n           \"  AcquireNextImage()\");\n\n      AcquireNextImage(image_info,image);\n\n      if (GetNextImageInList(image) == (Image *) NULL)\n        return(DestroyImageList(image));\n\n      image=SyncNextImageInList(image);\n    }\n  mng_info->image=image;\n\n  /*\n    Signature bytes have already been read.\n  */\n\n  read_JSEP=MagickFalse;\n  reading_idat=MagickFalse;\n  for (;;)\n  {\n    char\n      type[MaxTextExtent];\n\n    unsigned char\n      *chunk;\n\n    unsigned int\n      count;\n\n    /*\n      Read a new JNG chunk.\n    */\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      2*GetBlobSize(image));\n\n    if (status == MagickFalse)\n      break;\n\n    type[0]='\\0';\n    (void) ConcatenateMagickString(type,\"errr\",MaxTextExtent);\n    length=ReadBlobMSBLong(image);\n    count=(unsigned int) ReadBlob(image,4,(unsigned char *) type);\n\n    if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Reading JNG chunk type %c%c%c%c, length: %.20g\",\n        type[0],type[1],type[2],type[3],(double) length);\n\n    if (length > PNG_UINT_31_MAX || count == 0)\n      {\n        DestroyJNG(NULL,&color_image,&color_image_info,\n          &alpha_image,&alpha_image_info);\n        ThrowReaderException(CorruptImageError,\"CorruptImage\");\n      }\n\n    p=NULL;\n    chunk=(unsigned char *) NULL;\n\n    if (length != 0)\n      {\n        if (length > GetBlobSize(image))\n          {\n            if (color_image != (Image *) NULL)\n              color_image=DestroyImage(color_image);\n            if (color_image_info != (ImageInfo *) NULL)\n              color_image_info=DestroyImageInfo(color_image_info);\n            ThrowReaderException(CorruptImageError,\n              \"InsufficientImageDataInFile\");\n          }\n        chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));\n\n        if (chunk == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        for (i=0; i < (ssize_t) length; i++)\n        {\n          int\n            c;\n\n          c=ReadBlobByte(image);\n          if (c == EOF)\n            break;\n          chunk[i]=(unsigned char) c;\n        }\n\n        p=chunk;\n      }\n\n    (void) ReadBlobMSBLong(image);  /* read crc word */\n\n    if (memcmp(type,mng_JHDR,4) == 0)\n      {\n        if (length == 16)\n          {\n            jng_width=(png_uint_32)mng_get_long(p);\n            jng_height=(png_uint_32)mng_get_long(&p[4]);\n            if ((jng_width == 0) || (jng_height == 0))\n              ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n            jng_color_type=p[8];\n            jng_image_sample_depth=p[9];\n            jng_image_compression_method=p[10];\n            jng_image_interlace_method=p[11];\n\n            image->interlace=jng_image_interlace_method != 0 ? PNGInterlace :\n              NoInterlace;\n\n            jng_alpha_sample_depth=p[12];\n            jng_alpha_compression_method=p[13];\n            jng_alpha_filter_method=p[14];\n            jng_alpha_interlace_method=p[15];\n\n            if (logging != MagickFalse)\n              {\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_width:      %16lu,    jng_height:     %16lu\\n\"\n                  \"    jng_color_type: %16d,     jng_image_sample_depth: %3d\\n\"\n                  \"    jng_image_compression_method:%3d\",\n                  (unsigned long) jng_width, (unsigned long) jng_height,\n                  jng_color_type, jng_image_sample_depth,\n                  jng_image_compression_method);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_image_interlace_method:  %3d\"\n                  \"    jng_alpha_sample_depth:      %3d\",\n                  jng_image_interlace_method,\n                  jng_alpha_sample_depth);\n\n                (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                  \"    jng_alpha_compression_method:%3d\\n\"\n                  \"    jng_alpha_filter_method:     %3d\\n\"\n                  \"    jng_alpha_interlace_method:  %3d\",\n                  jng_alpha_compression_method,\n                  jng_alpha_filter_method,\n                  jng_alpha_interlace_method);\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        if (jng_width > 65535 || jng_height > 65535 ||\n             (long) jng_width > GetMagickResourceLimit(WidthResource) ||\n             (long) jng_height > GetMagickResourceLimit(HeightResource))\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"    JNG width or height too large: (%lu x %lu)\",\n                (long) jng_width, (long) jng_height);\n            DestroyJNG(chunk,&color_image,&color_image_info,\n              &alpha_image,&alpha_image_info);\n            ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n          }\n\n        continue;\n      }\n\n\n    if ((reading_idat == MagickFalse) && (read_JSEP == MagickFalse) &&\n        ((memcmp(type,mng_JDAT,4) == 0) || (memcmp(type,mng_JdAA,4) == 0) ||\n         (memcmp(type,mng_IDAT,4) == 0) || (memcmp(type,mng_JDAA,4) == 0)))\n      {\n        /*\n           o create color_image\n           o open color_blob, attached to color_image\n           o if (color type has alpha)\n               open alpha_blob, attached to alpha_image\n        */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Creating color_blob.\");\n\n        color_image_info=(ImageInfo *)AcquireMagickMemory(sizeof(ImageInfo));\n\n        if (color_image_info == (ImageInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        GetImageInfo(color_image_info);\n        color_image=AcquireImage(color_image_info);\n\n        if (color_image == (Image *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n        (void) AcquireUniqueFilename(color_image->filename);\n        unique_filenames++;\n        status=OpenBlob(color_image_info,color_image,WriteBinaryBlobMode,\n          exception);\n\n        if (status == MagickFalse)\n          {\n            color_image=DestroyImage(color_image);\n            return(DestroyImageList(image));\n          }\n\n        if ((image_info->ping == MagickFalse) && (jng_color_type >= 12))\n          {\n            alpha_image_info=(ImageInfo *)\n              AcquireMagickMemory(sizeof(ImageInfo));\n\n            if (alpha_image_info == (ImageInfo *) NULL)\n              {\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            GetImageInfo(alpha_image_info);\n            alpha_image=AcquireImage(alpha_image_info);\n\n            if (alpha_image == (Image *) NULL)\n              {\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                ThrowReaderException(ResourceLimitError,\n                  \"MemoryAllocationFailed\");\n              }\n\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Creating alpha_blob.\");\n\n            (void) AcquireUniqueFilename(alpha_image->filename);\n            unique_filenames++;\n            status=OpenBlob(alpha_image_info,alpha_image,WriteBinaryBlobMode,\n              exception);\n\n            if (status == MagickFalse)\n              {\n                alpha_image=DestroyImage(alpha_image);\n                alpha_image_info=DestroyImageInfo(alpha_image_info);\n                color_image=DestroyImage(color_image);\n                return(DestroyImageList(image));\n              }\n\n            if (jng_alpha_compression_method == 0)\n              {\n                unsigned char\n                  data[18];\n\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Writing IHDR chunk to alpha_blob.\");\n\n                (void) WriteBlob(alpha_image,8,(const unsigned char *)\n                  \"\\211PNG\\r\\n\\032\\n\");\n\n                (void) WriteBlobMSBULong(alpha_image,13L);\n                PNGType(data,mng_IHDR);\n                LogPNGChunk(logging,mng_IHDR,13L);\n                PNGLong(data+4,jng_width);\n                PNGLong(data+8,jng_height);\n                data[12]=jng_alpha_sample_depth;\n                data[13]=0; /* color_type gray */\n                data[14]=0; /* compression method 0 */\n                data[15]=0; /* filter_method 0 */\n                data[16]=0; /* interlace_method 0 */\n                (void) WriteBlob(alpha_image,17,data);\n                (void) WriteBlobMSBULong(alpha_image,crc32(0,data,17));\n              }\n          }\n        reading_idat=MagickTrue;\n      }\n\n    if (memcmp(type,mng_JDAT,4) == 0)\n      {\n        /* Copy chunk to color_image->blob */\n\n        if (logging != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    Copying JDAT chunk data to color_blob.\");\n\n        if (length != 0)\n          {\n            (void) WriteBlob(color_image,length,chunk);\n            chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n          }\n\n        continue;\n      }\n\n    if (memcmp(type,mng_IDAT,4) == 0)\n      {\n        png_byte\n           data[5];\n\n        /* Copy IDAT header and chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying IDAT chunk data to alpha_blob.\");\n\n            (void) WriteBlobMSBULong(alpha_image,(size_t) length);\n            PNGType(data,mng_IDAT);\n            LogPNGChunk(logging,mng_IDAT,length);\n            (void) WriteBlob(alpha_image,4,data);\n            (void) WriteBlob(alpha_image,length,chunk);\n            (void) WriteBlobMSBULong(alpha_image,\n              crc32(crc32(0,data,4),chunk,(uInt) length));\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if ((memcmp(type,mng_JDAA,4) == 0) || (memcmp(type,mng_JdAA,4) == 0))\n      {\n        /* Copy chunk data to alpha_image->blob */\n\n        if (alpha_image != NULL && image_info->ping == MagickFalse)\n          {\n            if (logging != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    Copying JDAA chunk data to alpha_blob.\");\n\n            (void) WriteBlob(alpha_image,length,chunk);\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_JSEP,4) == 0)\n      {\n        read_JSEP=MagickTrue;\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_bKGD,4) == 0)\n      {\n        if (length == 2)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=image->background_color.red;\n            image->background_color.blue=image->background_color.red;\n          }\n\n        if (length == 6)\n          {\n            image->background_color.red=ScaleCharToQuantum(p[1]);\n            image->background_color.green=ScaleCharToQuantum(p[3]);\n            image->background_color.blue=ScaleCharToQuantum(p[5]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_gAMA,4) == 0)\n      {\n        if (length == 4)\n          image->gamma=((float) mng_get_long(p))*0.00001;\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_cHRM,4) == 0)\n      {\n        if (length == 32)\n          {\n            image->chromaticity.white_point.x=0.00001*mng_get_long(p);\n            image->chromaticity.white_point.y=0.00001*mng_get_long(&p[4]);\n            image->chromaticity.red_primary.x=0.00001*mng_get_long(&p[8]);\n            image->chromaticity.red_primary.y=0.00001*mng_get_long(&p[12]);\n            image->chromaticity.green_primary.x=0.00001*mng_get_long(&p[16]);\n            image->chromaticity.green_primary.y=0.00001*mng_get_long(&p[20]);\n            image->chromaticity.blue_primary.x=0.00001*mng_get_long(&p[24]);\n            image->chromaticity.blue_primary.y=0.00001*mng_get_long(&p[28]);\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_sRGB,4) == 0)\n      {\n        if (length == 1)\n          {\n            image->rendering_intent=\n              Magick_RenderingIntent_from_PNG_RenderingIntent(p[0]);\n            image->gamma=1.000f/2.200f;\n            image->chromaticity.red_primary.x=0.6400f;\n            image->chromaticity.red_primary.y=0.3300f;\n            image->chromaticity.green_primary.x=0.3000f;\n            image->chromaticity.green_primary.y=0.6000f;\n            image->chromaticity.blue_primary.x=0.1500f;\n            image->chromaticity.blue_primary.y=0.0600f;\n            image->chromaticity.white_point.x=0.3127f;\n            image->chromaticity.white_point.y=0.3290f;\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n    if (memcmp(type,mng_oFFs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->page.x=(ssize_t) mng_get_long(p);\n            image->page.y=(ssize_t) mng_get_long(&p[4]);\n\n            if ((int) p[8] != 0)\n              {\n                image->page.x/=10000;\n                image->page.y/=10000;\n              }\n          }\n\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n\n    if (memcmp(type,mng_pHYs,4) == 0)\n      {\n        if (length > 8)\n          {\n            image->x_resolution=(double) mng_get_long(p);\n            image->y_resolution=(double) mng_get_long(&p[4]);\n            if ((int) p[8] == PNG_RESOLUTION_METER)\n              {\n                image->units=PixelsPerCentimeterResolution;\n                image->x_resolution=image->x_resolution/100.0f;\n                image->y_resolution=image->y_resolution/100.0f;\n              }\n          }\n\n        chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n        continue;\n      }\n\n#if 0\n    if (memcmp(type,mng_iCCP,4) == 0)\n      {\n        /* To do: */\n        if (length != 0)\n          chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n        continue;\n      }\n#endif\n\n    if (length != 0)\n      chunk=(unsigned char *) RelinquishMagickMemory(chunk);\n\n    if (memcmp(type,mng_IEND,4))\n      continue;\n\n    break;\n  }\n\n\n  /* IEND found */\n\n  /*\n    Finish up reading image data:\n\n       o read main image from color_blob.\n\n       o close color_blob.\n\n       o if (color_type has alpha)\n            if alpha_encoding is PNG\n               read secondary image from alpha_blob via ReadPNG\n            if alpha_encoding is JPEG\n               read secondary image from alpha_blob via ReadJPEG\n\n       o close alpha_blob.\n\n       o copy intensity of secondary image into\n         opacity samples of main image.\n\n       o destroy the secondary image.\n  */\n\n  if (color_image_info == (ImageInfo *) NULL)\n    {\n      assert(color_image == (Image *) NULL);\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  if (color_image == (Image *) NULL)\n    {\n      assert(alpha_image == (Image *) NULL);\n      return(DestroyImageList(image));\n    }\n\n  (void) SeekBlob(color_image,0,SEEK_SET);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Reading jng_image from color_blob.\");\n\n  assert(color_image_info != (ImageInfo *) NULL);\n  (void) FormatLocaleString(color_image_info->filename,MaxTextExtent,\"%s\",\n    color_image->filename);\n\n  color_image_info->ping=MagickFalse;   /* To do: avoid this */\n  jng_image=ReadImage(color_image_info,exception);\n\n  (void) RelinquishUniqueFileResource(color_image->filename);\n  unique_filenames--;\n  color_image=DestroyImage(color_image);\n  color_image_info=DestroyImageInfo(color_image_info);\n\n  if (jng_image == (Image *) NULL)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"    Copying jng_image pixels to main image.\");\n  image->columns=jng_width;\n  image->rows=jng_height;\n  length=image->columns*sizeof(PixelPacket);\n\n  status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    {\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    s=GetVirtualPixels(jng_image,0,y,image->columns,1,&image->exception);\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    (void) CopyMagickMemory(q,s,length);\n\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n  }\n\n  jng_image=DestroyImage(jng_image);\n\n  if (image_info->ping == MagickFalse)\n    {\n     if (jng_color_type >= 12)\n       {\n         if (jng_alpha_compression_method == 0)\n           {\n             png_byte\n               data[5];\n             (void) WriteBlobMSBULong(alpha_image,0x00000000L);\n             PNGType(data,mng_IEND);\n             LogPNGChunk(logging,mng_IEND,0L);\n             (void) WriteBlob(alpha_image,4,data);\n             (void) WriteBlobMSBULong(alpha_image,crc32(0,data,4));\n           }\n\n         (void) SeekBlob(alpha_image,0,SEEK_SET);\n\n         if (logging != MagickFalse)\n           (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"    Reading opacity from alpha_blob.\");\n\n         (void) FormatLocaleString(alpha_image_info->filename,MaxTextExtent,\n           \"%s\",alpha_image->filename);\n\n         jng_image=ReadImage(alpha_image_info,exception);\n\n         if (jng_image != (Image *) NULL)\n           for (y=0; y < (ssize_t) image->rows; y++)\n           {\n             s=GetVirtualPixels(jng_image,0,y,image->columns,1,\n                &image->exception);\n             q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n\n             if (image->matte != MagickFalse)\n               for (x=(ssize_t) image->columns; x != 0; x--,q++,s++)\n                  SetPixelOpacity(q,QuantumRange-\n                      GetPixelRed(s));\n\n             else\n               for (x=(ssize_t) image->columns; x != 0; x--,q++,s++)\n               {\n                  SetPixelAlpha(q,GetPixelRed(s));\n                  if (GetPixelOpacity(q) != OpaqueOpacity)\n                    image->matte=MagickTrue;\n               }\n\n             if (SyncAuthenticPixels(image,exception) == MagickFalse)\n               break;\n           }\n         (void) RelinquishUniqueFileResource(alpha_image->filename);\n         unique_filenames--;\n         alpha_image=DestroyImage(alpha_image);\n         alpha_image_info=DestroyImageInfo(alpha_image_info);\n         if (jng_image != (Image *) NULL)\n           jng_image=DestroyImage(jng_image);\n       }\n    }\n\n  /* Read the JNG image.  */\n\n  if (mng_info->mng_type == 0)\n    {\n      mng_info->mng_width=jng_width;\n      mng_info->mng_height=jng_height;\n    }\n\n  if (image->page.width == 0 && image->page.height == 0)\n    {\n      image->page.width=jng_width;\n      image->page.height=jng_height;\n    }\n\n  if (image->page.x == 0 && image->page.y == 0)\n    {\n      image->page.x=mng_info->x_off[mng_info->object_id];\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  else\n    {\n      image->page.y=mng_info->y_off[mng_info->object_id];\n    }\n\n  mng_info->image_found++;\n  status=SetImageProgress(image,LoadImagesTag,2*TellBlob(image),\n    2*GetBlobSize(image));\n\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit ReadOneJNGImage(); unique_filenames=%d\",unique_filenames);\n\n  return(image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -140,7 +140,14 @@\n     if (length != 0)\n       {\n         if (length > GetBlobSize(image))\n-          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n+          {\n+            if (color_image != (Image *) NULL)\n+              color_image=DestroyImage(color_image);\n+            if (color_image_info != (ImageInfo *) NULL)\n+              color_image_info=DestroyImageInfo(color_image_info);\n+            ThrowReaderException(CorruptImageError,\n+              \"InsufficientImageDataInFile\");\n+          }\n         chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));\n \n         if (chunk == (unsigned char *) NULL)",
        "diff_line_info": {
            "deleted_lines": [
                "          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");"
            ],
            "added_lines": [
                "          {",
                "            if (color_image != (Image *) NULL)",
                "              color_image=DestroyImage(color_image);",
                "            if (color_image_info != (ImageInfo *) NULL)",
                "              color_image_info=DestroyImageInfo(color_image_info);",
                "            ThrowReaderException(CorruptImageError,",
                "              \"InsufficientImageDataInFile\");",
                "          }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-13058",
        "func_name": "ImageMagick/SeparateImage",
        "description": "In ImageMagick 7.0.6-6, a memory leak vulnerability was found in the function WritePCXImage in coders/pcx.c, which allows attackers to cause a denial of service via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/7adfde272ffc5d0c02cfb2846fd4c001e6d5cca1",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/666",
        "commit_text": "",
        "func_before": "MagickExport Image *SeparateImage(const Image *image,\n  const ChannelType channel_type,ExceptionInfo *exception)\n{\n#define GetChannelBit(mask,bit)  (((size_t) (mask) >> (size_t) (bit)) & 0x01)\n#define SeparateImageTag  \"Separate/Image\"\n\n  CacheView\n    *image_view,\n    *separate_view;\n\n  Image\n    *separate_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  /*\n    Initialize separate image attributes.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  separate_image=CloneImage(image,image->columns,image->rows,MagickTrue,\n    exception);\n  if (separate_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(separate_image,DirectClass,exception) == MagickFalse)\n    {\n      separate_image=DestroyImage(separate_image);\n      return((Image *) NULL);\n    }\n  (void) SetImageColorspace(separate_image,GRAYColorspace,exception);\n  separate_image->intensity=Rec709LuminancePixelIntensityMethod;\n  separate_image->alpha_trait=UndefinedPixelTrait;\n  /*\n    Separate image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  separate_view=AcquireAuthenticCacheView(separate_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(separate_view,0,y,separate_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelWriteMask(image,p) == 0)\n        {\n          SetPixelBackgoundColor(separate_image,q);\n          p+=GetPixelChannels(image);\n          q+=GetPixelChannels(separate_image);\n          continue;\n        }\n      SetPixelChannel(separate_image,GrayPixelChannel,0,q);\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (GetChannelBit(channel_type,channel) == 0))\n          continue;\n        SetPixelChannel(separate_image,GrayPixelChannel,p[i],q);\n      }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(separate_image);\n    }\n    if (SyncCacheViewAuthenticPixels(separate_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_SeparateImage)\n#endif\n        proceed=SetImageProgress(image,SeparateImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  separate_view=DestroyCacheView(separate_view);\n  image_view=DestroyCacheView(image_view);\n  (void) SetImageChannelMask(separate_image,DefaultChannels);\n  if (status == MagickFalse)\n    separate_image=DestroyImage(separate_image);\n  return(separate_image);\n}",
        "func": "MagickExport Image *SeparateImage(const Image *image,\n  const ChannelType channel_type,ExceptionInfo *exception)\n{\n#define GetChannelBit(mask,bit)  (((size_t) (mask) >> (size_t) (bit)) & 0x01)\n#define SeparateImageTag  \"Separate/Image\"\n\n  CacheView\n    *image_view,\n    *separate_view;\n\n  Image\n    *separate_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  /*\n    Initialize separate image attributes.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  separate_image=CloneImage(image,image->columns,image->rows,MagickTrue,\n    exception);\n  if (separate_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(separate_image,DirectClass,exception) == MagickFalse)\n    {\n      separate_image=DestroyImage(separate_image);\n      return((Image *) NULL);\n    }\n  separate_image->intensity=Rec709LuminancePixelIntensityMethod;\n  separate_image->alpha_trait=UndefinedPixelTrait;\n  (void) SetImageColorspace(separate_image,GRAYColorspace,exception);\n  /*\n    Separate image.\n  */\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  separate_view=AcquireAuthenticCacheView(separate_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(progress,status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=QueueCacheViewAuthenticPixels(separate_view,0,y,separate_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelWriteMask(image,p) == 0)\n        {\n          SetPixelBackgoundColor(separate_image,q);\n          p+=GetPixelChannels(image);\n          q+=GetPixelChannels(separate_image);\n          continue;\n        }\n      SetPixelChannel(separate_image,GrayPixelChannel,0,q);\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel channel=GetPixelChannelChannel(image,i);\n        PixelTrait traits=GetPixelChannelTraits(image,channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (GetChannelBit(channel_type,channel) == 0))\n          continue;\n        SetPixelChannel(separate_image,GrayPixelChannel,p[i],q);\n      }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(separate_image);\n    }\n    if (SyncCacheViewAuthenticPixels(separate_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp critical (MagickCore_SeparateImage)\n#endif\n        proceed=SetImageProgress(image,SeparateImageTag,progress++,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  separate_view=DestroyCacheView(separate_view);\n  image_view=DestroyCacheView(image_view);\n  (void) SetImageChannelMask(separate_image,DefaultChannels);\n  if (status == MagickFalse)\n    separate_image=DestroyImage(separate_image);\n  return(separate_image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -38,9 +38,9 @@\n       separate_image=DestroyImage(separate_image);\n       return((Image *) NULL);\n     }\n-  (void) SetImageColorspace(separate_image,GRAYColorspace,exception);\n   separate_image->intensity=Rec709LuminancePixelIntensityMethod;\n   separate_image->alpha_trait=UndefinedPixelTrait;\n+  (void) SetImageColorspace(separate_image,GRAYColorspace,exception);\n   /*\n     Separate image.\n   */",
        "diff_line_info": {
            "deleted_lines": [
                "  (void) SetImageColorspace(separate_image,GRAYColorspace,exception);"
            ],
            "added_lines": [
                "  (void) SetImageColorspace(separate_image,GRAYColorspace,exception);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-13058",
        "func_name": "ImageMagick/DestroyXResources",
        "description": "In ImageMagick 7.0.6-6, a memory leak vulnerability was found in the function WritePCXImage in coders/pcx.c, which allows attackers to cause a denial of service via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/7adfde272ffc5d0c02cfb2846fd4c001e6d5cca1",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/666",
        "commit_text": "",
        "func_before": "MagickExport void DestroyXResources(void)\n{\n  register int\n    i;\n\n  unsigned int\n    number_windows;\n\n  XWindowInfo\n    *magick_windows[MaxXWindows];\n\n  XWindows\n    *windows;\n\n  DestroyXWidget();\n  windows=XSetWindows((XWindows *) ~0);\n  if ((windows == (XWindows *) NULL) || (windows->display == (Display *) NULL))\n    return;\n  number_windows=0;\n  magick_windows[number_windows++]=(&windows->context);\n  magick_windows[number_windows++]=(&windows->group_leader);\n  magick_windows[number_windows++]=(&windows->backdrop);\n  magick_windows[number_windows++]=(&windows->icon);\n  magick_windows[number_windows++]=(&windows->image);\n  magick_windows[number_windows++]=(&windows->info);\n  magick_windows[number_windows++]=(&windows->magnify);\n  magick_windows[number_windows++]=(&windows->pan);\n  magick_windows[number_windows++]=(&windows->command);\n  magick_windows[number_windows++]=(&windows->widget);\n  magick_windows[number_windows++]=(&windows->popup);\n  magick_windows[number_windows++]=(&windows->context);\n  for (i=0; i < (int) number_windows; i++)\n  {\n    if (magick_windows[i]->mapped != MagickFalse)\n      {\n        (void) XWithdrawWindow(windows->display,magick_windows[i]->id,\n          magick_windows[i]->screen);\n        magick_windows[i]->mapped=MagickFalse;\n      }\n    if (magick_windows[i]->name != (char *) NULL)\n      magick_windows[i]->name=(char *)\n        RelinquishMagickMemory(magick_windows[i]->name);\n    if (magick_windows[i]->icon_name != (char *) NULL)\n      magick_windows[i]->icon_name=(char *)\n        RelinquishMagickMemory(magick_windows[i]->icon_name);\n    if (magick_windows[i]->cursor != (Cursor) NULL)\n      {\n        (void) XFreeCursor(windows->display,magick_windows[i]->cursor);\n        magick_windows[i]->cursor=(Cursor) NULL;\n      }\n    if (magick_windows[i]->busy_cursor != (Cursor) NULL)\n      {\n        (void) XFreeCursor(windows->display,magick_windows[i]->busy_cursor);\n        magick_windows[i]->busy_cursor=(Cursor) NULL;\n      }\n    if (magick_windows[i]->highlight_stipple != (Pixmap) NULL)\n      {\n        (void) XFreePixmap(windows->display,\n          magick_windows[i]->highlight_stipple);\n        magick_windows[i]->highlight_stipple=(Pixmap) NULL;\n      }\n    if (magick_windows[i]->shadow_stipple != (Pixmap) NULL)\n      {\n        (void) XFreePixmap(windows->display,magick_windows[i]->shadow_stipple);\n        magick_windows[i]->shadow_stipple=(Pixmap) NULL;\n      }\n    if (magick_windows[i]->ximage != (XImage *) NULL)\n      {\n        XDestroyImage(magick_windows[i]->ximage);\n        magick_windows[i]->ximage=(XImage *) NULL;\n      }\n    if (magick_windows[i]->pixmap != (Pixmap) NULL)\n      {\n        (void) XFreePixmap(windows->display,magick_windows[i]->pixmap);\n        magick_windows[i]->pixmap=(Pixmap) NULL;\n      }\n    if (magick_windows[i]->id != (Window) NULL)\n      {\n        (void) XDestroyWindow(windows->display,magick_windows[i]->id);\n        magick_windows[i]->id=(Window) NULL;\n      }\n    if (magick_windows[i]->destroy != MagickFalse)\n      {\n        if (magick_windows[i]->image != (Image *) NULL)\n          {\n            magick_windows[i]->image=DestroyImage(magick_windows[i]->image);\n            magick_windows[i]->image=NewImageList();\n          }\n        if (magick_windows[i]->matte_pixmap != (Pixmap) NULL)\n          {\n            (void) XFreePixmap(windows->display,\n              magick_windows[i]->matte_pixmap);\n            magick_windows[i]->matte_pixmap=(Pixmap) NULL;\n          }\n      }\n    if (magick_windows[i]->segment_info != (void *) NULL)\n      {\n#if defined(MAGICKCORE_HAVE_SHARED_MEMORY)\n        XShmSegmentInfo\n          *segment_info;\n\n        segment_info=(XShmSegmentInfo *) magick_windows[i]->segment_info;\n        if (segment_info != (XShmSegmentInfo *) NULL)\n          if (segment_info[0].shmid >= 0)\n            {\n              if (segment_info[0].shmaddr != NULL)\n                (void) shmdt(segment_info[0].shmaddr);\n              (void) shmctl(segment_info[0].shmid,IPC_RMID,0);\n              segment_info[0].shmaddr=NULL;\n              segment_info[0].shmid=(-1);\n            }\n#endif\n        magick_windows[i]->segment_info=(void *)\n          RelinquishMagickMemory(magick_windows[i]->segment_info);\n      }\n  }\n  windows->icon_resources=(XResourceInfo *)\n    RelinquishMagickMemory(windows->icon_resources);\n  if (windows->icon_pixel != (XPixelInfo *) NULL)\n    {\n      if (windows->icon_pixel->pixels != (unsigned long *) NULL)\n        windows->icon_pixel->pixels=(unsigned long *)\n          RelinquishMagickMemory(windows->icon_pixel->pixels);\n      if (windows->icon_pixel->annotate_context != (GC) NULL)\n        XFreeGC(windows->display,windows->icon_pixel->annotate_context);\n      windows->icon_pixel=(XPixelInfo *)\n        RelinquishMagickMemory(windows->icon_pixel);\n    }\n  if (windows->pixel_info != (XPixelInfo *) NULL)\n    {\n      if (windows->pixel_info->pixels != (unsigned long *) NULL)\n        windows->pixel_info->pixels=(unsigned long *)\n          RelinquishMagickMemory(windows->pixel_info->pixels);\n      if (windows->pixel_info->annotate_context != (GC) NULL)\n        XFreeGC(windows->display,windows->pixel_info->annotate_context);\n      if (windows->pixel_info->widget_context != (GC) NULL)\n        XFreeGC(windows->display,windows->pixel_info->widget_context);\n      if (windows->pixel_info->highlight_context != (GC) NULL)\n        XFreeGC(windows->display,windows->pixel_info->highlight_context);\n      windows->pixel_info=(XPixelInfo *)\n        RelinquishMagickMemory(windows->pixel_info);\n    }\n  if (windows->font_info != (XFontStruct *) NULL)\n    {\n      XFreeFont(windows->display,windows->font_info);\n      windows->font_info=(XFontStruct *) NULL;\n    }\n  if (windows->class_hints != (XClassHint *) NULL)\n    {\n      if (windows->class_hints->res_name != (char *) NULL)\n        windows->class_hints->res_name=DestroyString(\n          windows->class_hints->res_name);\n      if (windows->class_hints->res_class != (char *) NULL)\n        windows->class_hints->res_class=DestroyString(\n          windows->class_hints->res_class);\n      XFree(windows->class_hints);\n      windows->class_hints=(XClassHint *) NULL;\n    }\n  if (windows->manager_hints != (XWMHints *) NULL)\n    {\n      XFree(windows->manager_hints);\n      windows->manager_hints=(XWMHints *) NULL;\n    }\n  if (windows->map_info != (XStandardColormap *) NULL)\n    {\n      XFree(windows->map_info);\n      windows->map_info=(XStandardColormap *) NULL;\n    }\n  if (windows->icon_map != (XStandardColormap *) NULL)\n    {\n      XFree(windows->icon_map);\n      windows->icon_map=(XStandardColormap *) NULL;\n    }\n  if (windows->visual_info != (XVisualInfo *) NULL)\n    {\n      XFree(windows->visual_info);\n      windows->visual_info=(XVisualInfo *) NULL;\n    }\n  if (windows->icon_visual != (XVisualInfo *) NULL)\n    {\n      XFree(windows->icon_visual);\n      windows->icon_visual=(XVisualInfo *) NULL;\n    }\n  (void) XSetWindows((XWindows *) NULL);\n}",
        "func": "MagickExport void DestroyXResources(void)\n{\n  register int\n    i;\n\n  unsigned int\n    number_windows;\n\n  XWindowInfo\n    *magick_windows[MaxXWindows];\n\n  XWindows\n    *windows;\n\n  DestroyXWidget();\n  windows=XSetWindows((XWindows *) ~0);\n  if ((windows == (XWindows *) NULL) || (windows->display == (Display *) NULL))\n    return;\n  number_windows=0;\n  magick_windows[number_windows++]=(&windows->context);\n  magick_windows[number_windows++]=(&windows->group_leader);\n  magick_windows[number_windows++]=(&windows->backdrop);\n  magick_windows[number_windows++]=(&windows->icon);\n  magick_windows[number_windows++]=(&windows->image);\n  magick_windows[number_windows++]=(&windows->info);\n  magick_windows[number_windows++]=(&windows->magnify);\n  magick_windows[number_windows++]=(&windows->pan);\n  magick_windows[number_windows++]=(&windows->command);\n  magick_windows[number_windows++]=(&windows->widget);\n  magick_windows[number_windows++]=(&windows->popup);\n  for (i=0; i < (int) number_windows; i++)\n  {\n    if (magick_windows[i]->mapped != MagickFalse)\n      {\n        (void) XWithdrawWindow(windows->display,magick_windows[i]->id,\n          magick_windows[i]->screen);\n        magick_windows[i]->mapped=MagickFalse;\n      }\n    if (magick_windows[i]->name != (char *) NULL)\n      magick_windows[i]->name=(char *)\n        RelinquishMagickMemory(magick_windows[i]->name);\n    if (magick_windows[i]->icon_name != (char *) NULL)\n      magick_windows[i]->icon_name=(char *)\n        RelinquishMagickMemory(magick_windows[i]->icon_name);\n    if (magick_windows[i]->cursor != (Cursor) NULL)\n      {\n        (void) XFreeCursor(windows->display,magick_windows[i]->cursor);\n        magick_windows[i]->cursor=(Cursor) NULL;\n      }\n    if (magick_windows[i]->busy_cursor != (Cursor) NULL)\n      {\n        (void) XFreeCursor(windows->display,magick_windows[i]->busy_cursor);\n        magick_windows[i]->busy_cursor=(Cursor) NULL;\n      }\n    if (magick_windows[i]->highlight_stipple != (Pixmap) NULL)\n      {\n        (void) XFreePixmap(windows->display,\n          magick_windows[i]->highlight_stipple);\n        magick_windows[i]->highlight_stipple=(Pixmap) NULL;\n      }\n    if (magick_windows[i]->shadow_stipple != (Pixmap) NULL)\n      {\n        (void) XFreePixmap(windows->display,magick_windows[i]->shadow_stipple);\n        magick_windows[i]->shadow_stipple=(Pixmap) NULL;\n      }\n    if (magick_windows[i]->ximage != (XImage *) NULL)\n      {\n        XDestroyImage(magick_windows[i]->ximage);\n        magick_windows[i]->ximage=(XImage *) NULL;\n      }\n    if (magick_windows[i]->pixmap != (Pixmap) NULL)\n      {\n        (void) XFreePixmap(windows->display,magick_windows[i]->pixmap);\n        magick_windows[i]->pixmap=(Pixmap) NULL;\n      }\n    if (magick_windows[i]->id != (Window) NULL)\n      {\n        (void) XDestroyWindow(windows->display,magick_windows[i]->id);\n        magick_windows[i]->id=(Window) NULL;\n      }\n    if (magick_windows[i]->destroy != MagickFalse)\n      {\n        if (magick_windows[i]->image != (Image *) NULL)\n          {\n            magick_windows[i]->image=DestroyImage(magick_windows[i]->image);\n            magick_windows[i]->image=NewImageList();\n          }\n        if (magick_windows[i]->matte_pixmap != (Pixmap) NULL)\n          {\n            (void) XFreePixmap(windows->display,\n              magick_windows[i]->matte_pixmap);\n            magick_windows[i]->matte_pixmap=(Pixmap) NULL;\n          }\n      }\n    if (magick_windows[i]->segment_info != (void *) NULL)\n      {\n#if defined(MAGICKCORE_HAVE_SHARED_MEMORY)\n        XShmSegmentInfo\n          *segment_info;\n\n        segment_info=(XShmSegmentInfo *) magick_windows[i]->segment_info;\n        if (segment_info != (XShmSegmentInfo *) NULL)\n          if (segment_info[0].shmid >= 0)\n            {\n              if (segment_info[0].shmaddr != NULL)\n                (void) shmdt(segment_info[0].shmaddr);\n              (void) shmctl(segment_info[0].shmid,IPC_RMID,0);\n              segment_info[0].shmaddr=NULL;\n              segment_info[0].shmid=(-1);\n            }\n#endif\n        magick_windows[i]->segment_info=(void *)\n          RelinquishMagickMemory(magick_windows[i]->segment_info);\n      }\n  }\n  windows->icon_resources=(XResourceInfo *)\n    RelinquishMagickMemory(windows->icon_resources);\n  if (windows->icon_pixel != (XPixelInfo *) NULL)\n    {\n      if (windows->icon_pixel->pixels != (unsigned long *) NULL)\n        windows->icon_pixel->pixels=(unsigned long *)\n          RelinquishMagickMemory(windows->icon_pixel->pixels);\n      if (windows->icon_pixel->annotate_context != (GC) NULL)\n        XFreeGC(windows->display,windows->icon_pixel->annotate_context);\n      windows->icon_pixel=(XPixelInfo *)\n        RelinquishMagickMemory(windows->icon_pixel);\n    }\n  if (windows->pixel_info != (XPixelInfo *) NULL)\n    {\n      if (windows->pixel_info->pixels != (unsigned long *) NULL)\n        windows->pixel_info->pixels=(unsigned long *)\n          RelinquishMagickMemory(windows->pixel_info->pixels);\n      if (windows->pixel_info->annotate_context != (GC) NULL)\n        XFreeGC(windows->display,windows->pixel_info->annotate_context);\n      if (windows->pixel_info->widget_context != (GC) NULL)\n        XFreeGC(windows->display,windows->pixel_info->widget_context);\n      if (windows->pixel_info->highlight_context != (GC) NULL)\n        XFreeGC(windows->display,windows->pixel_info->highlight_context);\n      windows->pixel_info=(XPixelInfo *)\n        RelinquishMagickMemory(windows->pixel_info);\n    }\n  if (windows->font_info != (XFontStruct *) NULL)\n    {\n      XFreeFont(windows->display,windows->font_info);\n      windows->font_info=(XFontStruct *) NULL;\n    }\n  if (windows->class_hints != (XClassHint *) NULL)\n    {\n      if (windows->class_hints->res_name != (char *) NULL)\n        windows->class_hints->res_name=DestroyString(\n          windows->class_hints->res_name);\n      if (windows->class_hints->res_class != (char *) NULL)\n        windows->class_hints->res_class=DestroyString(\n          windows->class_hints->res_class);\n      XFree(windows->class_hints);\n      windows->class_hints=(XClassHint *) NULL;\n    }\n  if (windows->manager_hints != (XWMHints *) NULL)\n    {\n      XFree(windows->manager_hints);\n      windows->manager_hints=(XWMHints *) NULL;\n    }\n  if (windows->map_info != (XStandardColormap *) NULL)\n    {\n      XFree(windows->map_info);\n      windows->map_info=(XStandardColormap *) NULL;\n    }\n  if (windows->icon_map != (XStandardColormap *) NULL)\n    {\n      XFree(windows->icon_map);\n      windows->icon_map=(XStandardColormap *) NULL;\n    }\n  if (windows->visual_info != (XVisualInfo *) NULL)\n    {\n      XFree(windows->visual_info);\n      windows->visual_info=(XVisualInfo *) NULL;\n    }\n  if (windows->icon_visual != (XVisualInfo *) NULL)\n    {\n      XFree(windows->icon_visual);\n      windows->icon_visual=(XVisualInfo *) NULL;\n    }\n  (void) XSetWindows((XWindows *) NULL);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,7 +28,6 @@\n   magick_windows[number_windows++]=(&windows->command);\n   magick_windows[number_windows++]=(&windows->widget);\n   magick_windows[number_windows++]=(&windows->popup);\n-  magick_windows[number_windows++]=(&windows->context);\n   for (i=0; i < (int) number_windows; i++)\n   {\n     if (magick_windows[i]->mapped != MagickFalse)",
        "diff_line_info": {
            "deleted_lines": [
                "  magick_windows[number_windows++]=(&windows->context);"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2017-13058",
        "func_name": "ImageMagick/WritePCXImage",
        "description": "In ImageMagick 7.0.6-6, a memory leak vulnerability was found in the function WritePCXImage in coders/pcx.c, which allows attackers to cause a denial of service via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/7adfde272ffc5d0c02cfb2846fd4c001e6d5cca1",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/666",
        "commit_text": "",
        "func_before": "static MagickBooleanType WritePCXImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    *page_table,\n    scene;\n\n  MemoryInfo\n    *pixel_info;\n\n  PCXInfo\n    pcx_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pcx_colormap,\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  page_table=(MagickOffsetType *) NULL;\n  if ((LocaleCompare(image_info->magick,\"DCX\") == 0) ||\n      ((GetNextImageInList(image) != (Image *) NULL) &&\n       (image_info->adjoin != MagickFalse)))\n    {\n      /*\n        Write the DCX page table.\n      */\n      (void) WriteBlobLSBLong(image,0x3ADE68B1L);\n      page_table=(MagickOffsetType *) AcquireQuantumMemory(1024UL,\n        sizeof(*page_table));\n      if (page_table == (MagickOffsetType *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (scene=0; scene < 1024; scene++)\n        (void) WriteBlobLSBLong(image,0x00000000L);\n    }\n  scene=0;\n  do\n  {\n    if (page_table != (MagickOffsetType *) NULL)\n      page_table[scene]=TellBlob(image);\n    /*\n      Initialize PCX raster file header.\n    */\n    pcx_info.identifier=0x0a;\n    pcx_info.version=5;\n    pcx_info.encoding=image_info->compression == NoCompression ? 0 : 1;\n    pcx_info.bits_per_pixel=8;\n    if ((image->storage_class == PseudoClass) &&\n        (SetImageMonochrome(image,exception) != MagickFalse))\n      pcx_info.bits_per_pixel=1;\n    pcx_info.left=0;\n    pcx_info.top=0;\n    pcx_info.right=(unsigned short) (image->columns-1);\n    pcx_info.bottom=(unsigned short) (image->rows-1);\n    switch (image->units)\n    {\n      case UndefinedResolution:\n      case PixelsPerInchResolution:\n      default:\n      {\n        pcx_info.horizontal_resolution=(unsigned short) image->resolution.x;\n        pcx_info.vertical_resolution=(unsigned short) image->resolution.y;\n        break;\n      }\n      case PixelsPerCentimeterResolution:\n      {\n        pcx_info.horizontal_resolution=(unsigned short)\n          (2.54*image->resolution.x+0.5);\n        pcx_info.vertical_resolution=(unsigned short)\n          (2.54*image->resolution.y+0.5);\n        break;\n      }\n    }\n    pcx_info.reserved=0;\n    pcx_info.planes=1;\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        pcx_info.planes=3;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          pcx_info.planes++;\n      }\n    pcx_info.bytes_per_line=(unsigned short) (((size_t) image->columns*\n      pcx_info.bits_per_pixel+7)/8);\n    pcx_info.palette_info=1;\n    pcx_info.colormap_signature=0x0c;\n    /*\n      Write PCX header.\n    */\n    (void) WriteBlobByte(image,pcx_info.identifier);\n    (void) WriteBlobByte(image,pcx_info.version);\n    (void) WriteBlobByte(image,pcx_info.encoding);\n    (void) WriteBlobByte(image,pcx_info.bits_per_pixel);\n    (void) WriteBlobLSBShort(image,pcx_info.left);\n    (void) WriteBlobLSBShort(image,pcx_info.top);\n    (void) WriteBlobLSBShort(image,pcx_info.right);\n    (void) WriteBlobLSBShort(image,pcx_info.bottom);\n    (void) WriteBlobLSBShort(image,pcx_info.horizontal_resolution);\n    (void) WriteBlobLSBShort(image,pcx_info.vertical_resolution);\n    /*\n      Dump colormap to file.\n    */\n    pcx_colormap=(unsigned char *) AcquireQuantumMemory(256UL,\n      3*sizeof(*pcx_colormap));\n    if (pcx_colormap == (unsigned char *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) memset(pcx_colormap,0,3*256*sizeof(*pcx_colormap));\n    q=pcx_colormap;\n    if ((image->storage_class == PseudoClass) && (image->colors <= 256))\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        *q++=ScaleQuantumToChar(image->colormap[i].red);\n        *q++=ScaleQuantumToChar(image->colormap[i].green);\n        *q++=ScaleQuantumToChar(image->colormap[i].blue);\n      }\n    (void) WriteBlob(image,3*16,(const unsigned char *) pcx_colormap);\n    (void) WriteBlobByte(image,pcx_info.reserved);\n    (void) WriteBlobByte(image,pcx_info.planes);\n    (void) WriteBlobLSBShort(image,pcx_info.bytes_per_line);\n    (void) WriteBlobLSBShort(image,pcx_info.palette_info);\n    for (i=0; i < 58; i++)\n      (void) WriteBlobByte(image,'\\0');\n    length=(size_t) pcx_info.bytes_per_line;\n    pixel_info=AcquireVirtualMemory(length,pcx_info.planes*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      {\n        pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    q=pixels;\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        /*\n          Convert DirectClass image to PCX raster pixels.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=pixels;\n          for (i=0; i < pcx_info.planes; i++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            switch ((int) i)\n            {\n              case 0:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n              case 1:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n              case 2:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n              case 3:\n              default:\n              {\n                for (x=(ssize_t) pcx_info.bytes_per_line; x != 0; x--)\n                {\n                  *q++=ScaleQuantumToChar((Quantum) (GetPixelAlpha(image,p)));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n            }\n          }\n          if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      {\n        if (pcx_info.bits_per_pixel > 1)\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            q=pixels;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              *q++=(unsigned char) GetPixelIndex(image,p);\n              p+=GetPixelChannels(image);\n            }\n            if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        else\n          {\n            register unsigned char\n              bit,\n              byte;\n\n            /*\n              Convert PseudoClass image to a PCX monochrome image.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              bit=0;\n              byte=0;\n              q=pixels;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte<<=1;\n                if (GetPixelLuma(image,p) >= (QuantumRange/2.0))\n                  byte|=0x01;\n                bit++;\n                if (bit == 8)\n                  {\n                    *q++=byte;\n                    bit=0;\n                    byte=0;\n                  }\n                p+=GetPixelChannels(image);\n              }\n              if (bit != 0)\n                *q++=byte << (8-bit);\n              if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        (void) WriteBlobByte(image,pcx_info.colormap_signature);\n        (void) WriteBlob(image,3*256,pcx_colormap);\n      }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);\n    if (page_table == (MagickOffsetType *) NULL)\n      break;\n    if (scene >= 1023)\n      break;\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  if (page_table != (MagickOffsetType *) NULL)\n    {\n      /*\n        Write the DCX page table.\n      */\n      page_table[scene+1]=0;\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        ThrowWriterException(CorruptImageError,\"ImproperImageHeader\");\n      (void) WriteBlobLSBLong(image,0x3ADE68B1L);\n      for (i=0; i <= (ssize_t) scene; i++)\n        (void) WriteBlobLSBLong(image,(unsigned int) page_table[i]);\n      page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n    }\n  if (status == MagickFalse)\n    {\n      char\n        *message;\n\n      message=GetExceptionMessage(errno);\n      (void) ThrowMagickException(exception,GetMagickModule(),FileOpenError,\n        \"UnableToWriteFile\",\"`%s': %s\",image->filename,message);\n      message=DestroyString(message);\n    }\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
        "func": "static MagickBooleanType WritePCXImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    *page_table,\n    scene;\n\n  MemoryInfo\n    *pixel_info;\n\n  PCXInfo\n    pcx_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *q;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pcx_colormap,\n    *pixels;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) TransformImageColorspace(image,sRGBColorspace,exception);\n  page_table=(MagickOffsetType *) NULL;\n  if ((LocaleCompare(image_info->magick,\"DCX\") == 0) ||\n      ((GetNextImageInList(image) != (Image *) NULL) &&\n       (image_info->adjoin != MagickFalse)))\n    {\n      /*\n        Write the DCX page table.\n      */\n      (void) WriteBlobLSBLong(image,0x3ADE68B1L);\n      page_table=(MagickOffsetType *) AcquireQuantumMemory(1024UL,\n        sizeof(*page_table));\n      if (page_table == (MagickOffsetType *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (scene=0; scene < 1024; scene++)\n        (void) WriteBlobLSBLong(image,0x00000000L);\n    }\n  scene=0;\n  do\n  {\n    if (page_table != (MagickOffsetType *) NULL)\n      page_table[scene]=TellBlob(image);\n    /*\n      Initialize PCX raster file header.\n    */\n    pcx_info.identifier=0x0a;\n    pcx_info.version=5;\n    pcx_info.encoding=image_info->compression == NoCompression ? 0 : 1;\n    pcx_info.bits_per_pixel=8;\n    if ((image->storage_class == PseudoClass) &&\n        (SetImageMonochrome(image,exception) != MagickFalse))\n      pcx_info.bits_per_pixel=1;\n    pcx_info.left=0;\n    pcx_info.top=0;\n    pcx_info.right=(unsigned short) (image->columns-1);\n    pcx_info.bottom=(unsigned short) (image->rows-1);\n    switch (image->units)\n    {\n      case UndefinedResolution:\n      case PixelsPerInchResolution:\n      default:\n      {\n        pcx_info.horizontal_resolution=(unsigned short) image->resolution.x;\n        pcx_info.vertical_resolution=(unsigned short) image->resolution.y;\n        break;\n      }\n      case PixelsPerCentimeterResolution:\n      {\n        pcx_info.horizontal_resolution=(unsigned short)\n          (2.54*image->resolution.x+0.5);\n        pcx_info.vertical_resolution=(unsigned short)\n          (2.54*image->resolution.y+0.5);\n        break;\n      }\n    }\n    pcx_info.reserved=0;\n    pcx_info.planes=1;\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        pcx_info.planes=3;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          pcx_info.planes++;\n      }\n    pcx_info.bytes_per_line=(unsigned short) (((size_t) image->columns*\n      pcx_info.bits_per_pixel+7)/8);\n    pcx_info.palette_info=1;\n    pcx_info.colormap_signature=0x0c;\n    /*\n      Write PCX header.\n    */\n    (void) WriteBlobByte(image,pcx_info.identifier);\n    (void) WriteBlobByte(image,pcx_info.version);\n    (void) WriteBlobByte(image,pcx_info.encoding);\n    (void) WriteBlobByte(image,pcx_info.bits_per_pixel);\n    (void) WriteBlobLSBShort(image,pcx_info.left);\n    (void) WriteBlobLSBShort(image,pcx_info.top);\n    (void) WriteBlobLSBShort(image,pcx_info.right);\n    (void) WriteBlobLSBShort(image,pcx_info.bottom);\n    (void) WriteBlobLSBShort(image,pcx_info.horizontal_resolution);\n    (void) WriteBlobLSBShort(image,pcx_info.vertical_resolution);\n    /*\n      Dump colormap to file.\n    */\n    pcx_colormap=(unsigned char *) AcquireQuantumMemory(256UL,\n      3*sizeof(*pcx_colormap));\n    if (pcx_colormap == (unsigned char *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) memset(pcx_colormap,0,3*256*sizeof(*pcx_colormap));\n    q=pcx_colormap;\n    if ((image->storage_class == PseudoClass) && (image->colors <= 256))\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        *q++=ScaleQuantumToChar(image->colormap[i].red);\n        *q++=ScaleQuantumToChar(image->colormap[i].green);\n        *q++=ScaleQuantumToChar(image->colormap[i].blue);\n      }\n    (void) WriteBlob(image,3*16,(const unsigned char *) pcx_colormap);\n    (void) WriteBlobByte(image,pcx_info.reserved);\n    (void) WriteBlobByte(image,pcx_info.planes);\n    (void) WriteBlobLSBShort(image,pcx_info.bytes_per_line);\n    (void) WriteBlobLSBShort(image,pcx_info.palette_info);\n    for (i=0; i < 58; i++)\n      (void) WriteBlobByte(image,'\\0');\n    length=(size_t) pcx_info.bytes_per_line;\n    pixel_info=AcquireVirtualMemory(length,pcx_info.planes*sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      {\n        pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);\n        if (page_table != (MagickOffsetType *) NULL)\n          page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    q=pixels;\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      {\n        /*\n          Convert DirectClass image to PCX raster pixels.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=pixels;\n          for (i=0; i < pcx_info.planes; i++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            switch ((int) i)\n            {\n              case 0:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelRed(image,p));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n              case 1:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelGreen(image,p));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n              case 2:\n              {\n                for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++)\n                {\n                  *q++=ScaleQuantumToChar(GetPixelBlue(image,p));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n              case 3:\n              default:\n              {\n                for (x=(ssize_t) pcx_info.bytes_per_line; x != 0; x--)\n                {\n                  *q++=ScaleQuantumToChar((Quantum) (GetPixelAlpha(image,p)));\n                  p+=GetPixelChannels(image);\n                }\n                break;\n              }\n            }\n          }\n          if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      {\n        if (pcx_info.bits_per_pixel > 1)\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n            if (p == (const Quantum *) NULL)\n              break;\n            q=pixels;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              *q++=(unsigned char) GetPixelIndex(image,p);\n              p+=GetPixelChannels(image);\n            }\n            if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                  y,image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        else\n          {\n            register unsigned char\n              bit,\n              byte;\n\n            /*\n              Convert PseudoClass image to a PCX monochrome image.\n            */\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n              if (p == (const Quantum *) NULL)\n                break;\n              bit=0;\n              byte=0;\n              q=pixels;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte<<=1;\n                if (GetPixelLuma(image,p) >= (QuantumRange/2.0))\n                  byte|=0x01;\n                bit++;\n                if (bit == 8)\n                  {\n                    *q++=byte;\n                    bit=0;\n                    byte=0;\n                  }\n                p+=GetPixelChannels(image);\n              }\n              if (bit != 0)\n                *q++=byte << (8-bit);\n              if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse)\n                break;\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        (void) WriteBlobByte(image,pcx_info.colormap_signature);\n        (void) WriteBlob(image,3*256,pcx_colormap);\n      }\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);\n    if (page_table == (MagickOffsetType *) NULL)\n      break;\n    if (scene >= 1023)\n      break;\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  if (page_table != (MagickOffsetType *) NULL)\n    {\n      /*\n        Write the DCX page table.\n      */\n      page_table[scene+1]=0;\n      offset=SeekBlob(image,0L,SEEK_SET);\n      if (offset < 0)\n        {\n          page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n          ThrowWriterException(CorruptImageError,\"ImproperImageHeader\");\n        }\n      (void) WriteBlobLSBLong(image,0x3ADE68B1L);\n      for (i=0; i <= (ssize_t) scene; i++)\n        (void) WriteBlobLSBLong(image,(unsigned int) page_table[i]);\n      page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n    }\n  if (status == MagickFalse)\n    {\n      char\n        *message;\n\n      message=GetExceptionMessage(errno);\n      (void) ThrowMagickException(exception,GetMagickModule(),FileOpenError,\n        \"UnableToWriteFile\",\"`%s': %s\",image->filename,message);\n      message=DestroyString(message);\n    }\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -157,6 +157,8 @@\n     if (pixel_info == (MemoryInfo *) NULL)\n       {\n         pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap);\n+        if (page_table != (MagickOffsetType *) NULL)\n+          page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n         ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n       }\n     pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n@@ -244,8 +246,8 @@\n               break;\n             if (image->previous == (Image *) NULL)\n               {\n-                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n-                image->rows);\n+                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n+                  y,image->rows);\n                 if (status == MagickFalse)\n                   break;\n               }\n@@ -319,7 +321,10 @@\n       page_table[scene+1]=0;\n       offset=SeekBlob(image,0L,SEEK_SET);\n       if (offset < 0)\n-        ThrowWriterException(CorruptImageError,\"ImproperImageHeader\");\n+        {\n+          page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);\n+          ThrowWriterException(CorruptImageError,\"ImproperImageHeader\");\n+        }\n       (void) WriteBlobLSBLong(image,0x3ADE68B1L);\n       for (i=0; i <= (ssize_t) scene; i++)\n         (void) WriteBlobLSBLong(image,(unsigned int) page_table[i]);",
        "diff_line_info": {
            "deleted_lines": [
                "                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,",
                "                image->rows);",
                "        ThrowWriterException(CorruptImageError,\"ImproperImageHeader\");"
            ],
            "added_lines": [
                "        if (page_table != (MagickOffsetType *) NULL)",
                "          page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);",
                "                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)",
                "                  y,image->rows);",
                "        {",
                "          page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table);",
                "          ThrowWriterException(CorruptImageError,\"ImproperImageHeader\");",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-13059",
        "func_name": "ImageMagick/WriteOneJNGImage",
        "description": "In ImageMagick 7.0.6-6, a memory leak vulnerability was found in the function WriteOneJNGImage in coders/png.c, which allows attackers to cause a denial of service (WriteJNGImage memory consumption) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/6519c467c9577ac963e0e44f8f47641fb24c192d",
        "commit_title": "Fixed memory leak reported in #667.",
        "commit_text": "",
        "func_before": "static MagickBooleanType WriteOneJNGImage(MngInfo *mng_info,\n   const ImageInfo *image_info,Image *image)\n{\n  Image\n    *jpeg_image;\n\n  ImageInfo\n    *jpeg_image_info;\n\n  int\n    unique_filenames;\n\n  MagickBooleanType\n    logging,\n    status;\n\n  size_t\n    length;\n\n  unsigned char\n    *blob,\n    chunk[80],\n    *p;\n\n  unsigned int\n    jng_alpha_compression_method,\n    jng_alpha_sample_depth,\n    jng_color_type,\n    transparent;\n\n  size_t\n    jng_alpha_quality,\n    jng_quality;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter WriteOneJNGImage()\");\n\n  blob=(unsigned char *) NULL;\n  jpeg_image=(Image *) NULL;\n  jpeg_image_info=(ImageInfo *) NULL;\n  length=0;\n\n  unique_filenames=0;\n\n  status=MagickTrue;\n  transparent=image_info->type==GrayscaleMatteType ||\n     image_info->type==TrueColorMatteType || image->matte != MagickFalse;\n\n  jng_alpha_sample_depth = 0;\n\n  jng_quality=image_info->quality == 0UL ? 75UL : image_info->quality%1000;\n\n  jng_alpha_compression_method=image->compression==JPEGCompression? 8 : 0;\n\n  jng_alpha_quality=image_info->quality == 0UL ? 75UL :\n      image_info->quality;\n\n  if (jng_alpha_quality >= 1000)\n    jng_alpha_quality /= 1000;\n\n  if (transparent != 0)\n    {\n      jng_color_type=14;\n\n      /* Create JPEG blob, image, and image_info */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Creating jpeg_image_info for opacity.\");\n\n      jpeg_image_info=(ImageInfo *) CloneImageInfo(image_info);\n\n      if (jpeg_image_info == (ImageInfo *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Creating jpeg_image.\");\n\n      jpeg_image=CloneImage(image,0,0,MagickTrue,&image->exception);\n\n      if (jpeg_image == (Image *) NULL)\n        {\n          jpeg_image_info=DestroyImageInfo(jpeg_image_info);\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n\n      (void) CopyMagickString(jpeg_image->magick,\"JPEG\",MaxTextExtent);\n\n      status=SeparateImageChannel(jpeg_image,OpacityChannel);\n      if (status == MagickFalse)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n      status=NegateImage(jpeg_image,MagickFalse);\n      if (status == MagickFalse)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n      jpeg_image->matte=MagickFalse;\n\n      jpeg_image_info->type=GrayscaleType;\n      jpeg_image->quality=jng_alpha_quality;\n      (void) SetImageType(jpeg_image,GrayscaleType);\n      (void) AcquireUniqueFilename(jpeg_image->filename);\n      unique_filenames++;\n      (void) FormatLocaleString(jpeg_image_info->filename,MaxTextExtent,\n        \"%s\",jpeg_image->filename);\n    }\n  else\n    {\n      jng_alpha_compression_method=0;\n      jng_color_type=10;\n      jng_alpha_sample_depth=0;\n    }\n\n  /* To do: check bit depth of PNG alpha channel */\n\n  /* Check if image is grayscale. */\n  if (image_info->type != TrueColorMatteType && image_info->type !=\n    TrueColorType && SetImageGray(image,&image->exception))\n    jng_color_type-=2;\n\n  if (logging != MagickFalse)\n    {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    JNG Quality           = %d\",(int) jng_quality);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    JNG Color Type        = %d\",jng_color_type);\n        if (transparent != 0)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    JNG Alpha Compression = %d\",jng_alpha_compression_method);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    JNG Alpha Depth       = %d\",jng_alpha_sample_depth);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    JNG Alpha Quality     = %d\",(int) jng_alpha_quality);\n          }\n    }\n\n  if (transparent != 0)\n    {\n      if (jng_alpha_compression_method==0)\n        {\n          const char\n            *value;\n\n          /* Encode opacity as a grayscale PNG blob */\n\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Creating PNG blob for alpha.\");\n\n          status=OpenBlob(jpeg_image_info,jpeg_image,WriteBinaryBlobMode,\n            &image->exception);\n          if (status == MagickFalse)\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n          length=0;\n\n          (void) CopyMagickString(jpeg_image_info->magick,\"PNG\",MaxTextExtent);\n          (void) CopyMagickString(jpeg_image->magick,\"PNG\",MaxTextExtent);\n          jpeg_image_info->interlace=NoInterlace;\n\n          /* Exclude all ancillary chunks */\n          (void) SetImageArtifact(jpeg_image,\"png:exclude-chunks\",\"all\");\n\n          blob=ImageToBlob(jpeg_image_info,jpeg_image,&length,\n            &image->exception);\n\n          /* Retrieve sample depth used */\n          value=GetImageProperty(jpeg_image,\"png:bit-depth-written\");\n          if (value != (char *) NULL)\n            jng_alpha_sample_depth= (unsigned int) value[0];\n        }\n      else\n        {\n          /* Encode opacity as a grayscale JPEG blob */\n\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Creating JPEG blob for alpha.\");\n\n          status=OpenBlob(jpeg_image_info,jpeg_image,WriteBinaryBlobMode,\n            &image->exception);\n\n          if (status == MagickFalse)\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n          (void) CopyMagickString(jpeg_image_info->magick,\"JPEG\",MaxTextExtent);\n          (void) CopyMagickString(jpeg_image->magick,\"JPEG\",MaxTextExtent);\n          jpeg_image_info->interlace=NoInterlace;\n          blob=ImageToBlob(jpeg_image_info,jpeg_image,&length,\n           &image->exception);\n          jng_alpha_sample_depth=8;\n\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Successfully read jpeg_image into a blob, length=%.20g.\",\n              (double) length);\n\n        }\n      /* Destroy JPEG image and image_info */\n      jpeg_image=DestroyImage(jpeg_image);\n      (void) RelinquishUniqueFileResource(jpeg_image_info->filename);\n      unique_filenames--;\n      jpeg_image_info=DestroyImageInfo(jpeg_image_info);\n    }\n\n  /* Write JHDR chunk */\n  (void) WriteBlobMSBULong(image,16L);  /* chunk data length=16 */\n  PNGType(chunk,mng_JHDR);\n  LogPNGChunk(logging,mng_JHDR,16L);\n  PNGLong(chunk+4,(png_uint_32) image->columns);\n  PNGLong(chunk+8,(png_uint_32) image->rows);\n  chunk[12]=jng_color_type;\n  chunk[13]=8;  /* sample depth */\n  chunk[14]=8; /*jng_image_compression_method */\n  chunk[15]=(unsigned char) (image_info->interlace == NoInterlace ? 0 : 8);\n  chunk[16]=jng_alpha_sample_depth;\n  chunk[17]=jng_alpha_compression_method;\n  chunk[18]=0; /*jng_alpha_filter_method */\n  chunk[19]=0; /*jng_alpha_interlace_method */\n  (void) WriteBlob(image,20,chunk);\n  (void) WriteBlobMSBULong(image,crc32(0,chunk,20));\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG width:%15lu\",(unsigned long) image->columns);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG height:%14lu\",(unsigned long) image->rows);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG color type:%10d\",jng_color_type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG sample depth:%8d\",8);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG compression:%9d\",8);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG interlace:%11d\",0);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG alpha depth:%9d\",jng_alpha_sample_depth);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG alpha compression:%3d\",jng_alpha_compression_method);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG alpha filter:%8d\",0);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG alpha interlace:%5d\",0);\n    }\n\n  /*\n     Write leading ancillary chunks\n  */\n\n  if (transparent != 0)\n  {\n    /*\n      Write JNG bKGD chunk\n    */\n\n    unsigned char\n      blue,\n      green,\n      red;\n\n    ssize_t\n      num_bytes;\n\n    if (jng_color_type == 8 || jng_color_type == 12)\n      num_bytes=6L;\n    else\n      num_bytes=10L;\n    (void) WriteBlobMSBULong(image,(size_t) (num_bytes-4L));\n    PNGType(chunk,mng_bKGD);\n    LogPNGChunk(logging,mng_bKGD,(size_t) (num_bytes-4L));\n    red=ScaleQuantumToChar(image->background_color.red);\n    green=ScaleQuantumToChar(image->background_color.green);\n    blue=ScaleQuantumToChar(image->background_color.blue);\n    *(chunk+4)=0;\n    *(chunk+5)=red;\n    *(chunk+6)=0;\n    *(chunk+7)=green;\n    *(chunk+8)=0;\n    *(chunk+9)=blue;\n    (void) WriteBlob(image,(size_t) num_bytes,chunk);\n    (void) WriteBlobMSBULong(image,crc32(0,chunk,(uInt) num_bytes));\n  }\n\n  if ((image->colorspace == sRGBColorspace || image->rendering_intent))\n    {\n      /*\n        Write JNG sRGB chunk\n      */\n      (void) WriteBlobMSBULong(image,1L);\n      PNGType(chunk,mng_sRGB);\n      LogPNGChunk(logging,mng_sRGB,1L);\n\n      if (image->rendering_intent != UndefinedIntent)\n        chunk[4]=(unsigned char)\n          Magick_RenderingIntent_to_PNG_RenderingIntent(\n          (image->rendering_intent));\n\n      else\n        chunk[4]=(unsigned char)\n          Magick_RenderingIntent_to_PNG_RenderingIntent(\n          (PerceptualIntent));\n\n      (void) WriteBlob(image,5,chunk);\n      (void) WriteBlobMSBULong(image,crc32(0,chunk,5));\n    }\n  else\n    {\n      if (image->gamma != 0.0)\n        {\n          /*\n             Write JNG gAMA chunk\n          */\n          (void) WriteBlobMSBULong(image,4L);\n          PNGType(chunk,mng_gAMA);\n          LogPNGChunk(logging,mng_gAMA,4L);\n          PNGLong(chunk+4,(png_uint_32) (100000*image->gamma+0.5));\n          (void) WriteBlob(image,8,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,8));\n        }\n\n      if ((mng_info->equal_chrms == MagickFalse) &&\n          (image->chromaticity.red_primary.x != 0.0))\n        {\n          PrimaryInfo\n            primary;\n\n          /*\n             Write JNG cHRM chunk\n          */\n          (void) WriteBlobMSBULong(image,32L);\n          PNGType(chunk,mng_cHRM);\n          LogPNGChunk(logging,mng_cHRM,32L);\n          primary=image->chromaticity.white_point;\n          PNGLong(chunk+4,(png_uint_32) (100000*primary.x+0.5));\n          PNGLong(chunk+8,(png_uint_32) (100000*primary.y+0.5));\n          primary=image->chromaticity.red_primary;\n          PNGLong(chunk+12,(png_uint_32) (100000*primary.x+0.5));\n          PNGLong(chunk+16,(png_uint_32) (100000*primary.y+0.5));\n          primary=image->chromaticity.green_primary;\n          PNGLong(chunk+20,(png_uint_32) (100000*primary.x+0.5));\n          PNGLong(chunk+24,(png_uint_32) (100000*primary.y+0.5));\n          primary=image->chromaticity.blue_primary;\n          PNGLong(chunk+28,(png_uint_32) (100000*primary.x+0.5));\n          PNGLong(chunk+32,(png_uint_32) (100000*primary.y+0.5));\n          (void) WriteBlob(image,36,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,36));\n        }\n    }\n\n  if (image->x_resolution && image->y_resolution && !mng_info->equal_physs)\n    {\n      /*\n         Write JNG pHYs chunk\n      */\n      (void) WriteBlobMSBULong(image,9L);\n      PNGType(chunk,mng_pHYs);\n      LogPNGChunk(logging,mng_pHYs,9L);\n      if (image->units == PixelsPerInchResolution)\n        {\n          PNGLong(chunk+4,(png_uint_32)\n            (image->x_resolution*100.0/2.54+0.5));\n\n          PNGLong(chunk+8,(png_uint_32)\n            (image->y_resolution*100.0/2.54+0.5));\n\n          chunk[12]=1;\n        }\n\n      else\n        {\n          if (image->units == PixelsPerCentimeterResolution)\n            {\n              PNGLong(chunk+4,(png_uint_32)\n                (image->x_resolution*100.0+0.5));\n\n              PNGLong(chunk+8,(png_uint_32)\n                (image->y_resolution*100.0+0.5));\n\n              chunk[12]=1;\n            }\n\n          else\n            {\n              PNGLong(chunk+4,(png_uint_32) (image->x_resolution+0.5));\n              PNGLong(chunk+8,(png_uint_32) (image->y_resolution+0.5));\n              chunk[12]=0;\n            }\n        }\n      (void) WriteBlob(image,13,chunk);\n      (void) WriteBlobMSBULong(image,crc32(0,chunk,13));\n    }\n\n  if (mng_info->write_mng == 0 && (image->page.x || image->page.y))\n    {\n      /*\n         Write JNG oFFs chunk\n      */\n      (void) WriteBlobMSBULong(image,9L);\n      PNGType(chunk,mng_oFFs);\n      LogPNGChunk(logging,mng_oFFs,9L);\n      PNGsLong(chunk+4,(ssize_t) (image->page.x));\n      PNGsLong(chunk+8,(ssize_t) (image->page.y));\n      chunk[12]=0;\n      (void) WriteBlob(image,13,chunk);\n      (void) WriteBlobMSBULong(image,crc32(0,chunk,13));\n    }\n\n  if (transparent != 0)\n    {\n      if (jng_alpha_compression_method==0)\n        {\n          register ssize_t\n            i;\n\n          size_t\n            len;\n\n          /* Write IDAT chunk header */\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Write IDAT chunks from blob, length=%.20g.\",(double)\n              length);\n\n          /* Copy IDAT chunks */\n          len=0;\n          p=blob+8;\n          for (i=8; i<(ssize_t) length; i+=len+12)\n          {\n            len=(((unsigned int) *(p    ) & 0xff) << 24) +\n                (((unsigned int) *(p + 1) & 0xff) << 16) +\n                (((unsigned int) *(p + 2) & 0xff) <<  8) +\n                (((unsigned int) *(p + 3) & 0xff)      ) ;\n            p+=4;\n\n            if (*(p)==73 && *(p+1)==68 && *(p+2)==65 && *(p+3)==84) /* IDAT */\n              {\n                /* Found an IDAT chunk. */\n                (void) WriteBlobMSBULong(image,len);\n                LogPNGChunk(logging,mng_IDAT,len);\n                (void) WriteBlob(image,len+4,p);\n                (void) WriteBlobMSBULong(image,crc32(0,p,(uInt) len+4));\n              }\n\n            else\n              {\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Skipping %c%c%c%c chunk, length=%.20g.\",\n                    *(p),*(p+1),*(p+2),*(p+3),(double) len);\n              }\n            p+=(8+len);\n          }\n        }\n      else if (length != 0)\n        {\n          /* Write JDAA chunk header */\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Write JDAA chunk, length=%.20g.\",(double) length);\n          (void) WriteBlobMSBULong(image,(size_t) length);\n          PNGType(chunk,mng_JDAA);\n          LogPNGChunk(logging,mng_JDAA,length);\n          /* Write JDAT chunk(s) data */\n          (void) WriteBlob(image,4,chunk);\n          (void) WriteBlob(image,length,blob);\n          (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),blob,\n             (uInt) length));\n        }\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n    }\n\n  /* Encode image as a JPEG blob */\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Creating jpeg_image_info.\");\n  jpeg_image_info=(ImageInfo *) CloneImageInfo(image_info);\n  if (jpeg_image_info == (ImageInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Creating jpeg_image.\");\n\n  jpeg_image=CloneImage(image,0,0,MagickTrue,&image->exception);\n  if (jpeg_image == (Image *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) CopyMagickString(jpeg_image->magick,\"JPEG\",MaxTextExtent);\n\n  (void) AcquireUniqueFilename(jpeg_image->filename);\n  unique_filenames++;\n  (void) FormatLocaleString(jpeg_image_info->filename,MaxTextExtent,\"%s\",\n    jpeg_image->filename);\n\n  status=OpenBlob(jpeg_image_info,jpeg_image,WriteBinaryBlobMode,\n    &image->exception);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Created jpeg_image, %.20g x %.20g.\",(double) jpeg_image->columns,\n      (double) jpeg_image->rows);\n\n  if (status == MagickFalse)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  if (jng_color_type == 8 || jng_color_type == 12)\n    jpeg_image_info->type=GrayscaleType;\n\n  jpeg_image_info->quality=jng_quality;\n  jpeg_image->quality=jng_quality;\n  (void) CopyMagickString(jpeg_image_info->magick,\"JPEG\",MaxTextExtent);\n  (void) CopyMagickString(jpeg_image->magick,\"JPEG\",MaxTextExtent);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Creating blob.\");\n\n  blob=ImageToBlob(jpeg_image_info,jpeg_image,&length,&image->exception);\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Successfully read jpeg_image into a blob, length=%.20g.\",\n        (double) length);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Write JDAT chunk, length=%.20g.\",(double) length);\n    }\n\n  /* Write JDAT chunk(s) */\n  (void) WriteBlobMSBULong(image,(size_t) length);\n  PNGType(chunk,mng_JDAT);\n  LogPNGChunk(logging,mng_JDAT,length);\n  (void) WriteBlob(image,4,chunk);\n  (void) WriteBlob(image,length,blob);\n  (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),blob,(uInt) length));\n\n  jpeg_image=DestroyImage(jpeg_image);\n  (void) RelinquishUniqueFileResource(jpeg_image_info->filename);\n  unique_filenames--;\n  jpeg_image_info=DestroyImageInfo(jpeg_image_info);\n  blob=(unsigned char *) RelinquishMagickMemory(blob);\n\n  /* Write IEND chunk */\n  (void) WriteBlobMSBULong(image,0L);\n  PNGType(chunk,mng_IEND);\n  LogPNGChunk(logging,mng_IEND,0);\n  (void) WriteBlob(image,4,chunk);\n  (void) WriteBlobMSBULong(image,crc32(0,chunk,4));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit WriteOneJNGImage(); unique_filenames=%d\",unique_filenames);\n\n  return(status);\n}",
        "func": "static MagickBooleanType WriteOneJNGImage(MngInfo *mng_info,\n   const ImageInfo *image_info,Image *image)\n{\n  Image\n    *jpeg_image;\n\n  ImageInfo\n    *jpeg_image_info;\n\n  int\n    unique_filenames;\n\n  MagickBooleanType\n    logging,\n    status;\n\n  size_t\n    length;\n\n  unsigned char\n    *blob,\n    chunk[80],\n    *p;\n\n  unsigned int\n    jng_alpha_compression_method,\n    jng_alpha_sample_depth,\n    jng_color_type,\n    transparent;\n\n  size_t\n    jng_alpha_quality,\n    jng_quality;\n\n  logging=LogMagickEvent(CoderEvent,GetMagickModule(),\n    \"  Enter WriteOneJNGImage()\");\n\n  blob=(unsigned char *) NULL;\n  jpeg_image=(Image *) NULL;\n  jpeg_image_info=(ImageInfo *) NULL;\n  length=0;\n\n  unique_filenames=0;\n\n  status=MagickTrue;\n  transparent=image_info->type==GrayscaleMatteType ||\n     image_info->type==TrueColorMatteType || image->matte != MagickFalse;\n\n  jng_alpha_sample_depth = 0;\n\n  jng_quality=image_info->quality == 0UL ? 75UL : image_info->quality%1000;\n\n  jng_alpha_compression_method=image->compression==JPEGCompression? 8 : 0;\n\n  jng_alpha_quality=image_info->quality == 0UL ? 75UL :\n      image_info->quality;\n\n  if (jng_alpha_quality >= 1000)\n    jng_alpha_quality /= 1000;\n\n  if (transparent != 0)\n    {\n      jng_color_type=14;\n\n      /* Create JPEG blob, image, and image_info */\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Creating jpeg_image_info for opacity.\");\n\n      jpeg_image_info=(ImageInfo *) CloneImageInfo(image_info);\n\n      if (jpeg_image_info == (ImageInfo *) NULL)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  Creating jpeg_image.\");\n\n      jpeg_image=CloneImage(image,0,0,MagickTrue,&image->exception);\n\n      if (jpeg_image == (Image *) NULL)\n        {\n          jpeg_image_info=DestroyImageInfo(jpeg_image_info);\n          ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n\n      (void) CopyMagickString(jpeg_image->magick,\"JPEG\",MaxTextExtent);\n\n      status=SeparateImageChannel(jpeg_image,OpacityChannel);\n      if (status == MagickFalse)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n      status=NegateImage(jpeg_image,MagickFalse);\n      if (status == MagickFalse)\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n      jpeg_image->matte=MagickFalse;\n\n      jpeg_image_info->type=GrayscaleType;\n      jpeg_image->quality=jng_alpha_quality;\n      (void) SetImageType(jpeg_image,GrayscaleType);\n      (void) AcquireUniqueFilename(jpeg_image->filename);\n      unique_filenames++;\n      (void) FormatLocaleString(jpeg_image_info->filename,MaxTextExtent,\n        \"%s\",jpeg_image->filename);\n    }\n  else\n    {\n      jng_alpha_compression_method=0;\n      jng_color_type=10;\n      jng_alpha_sample_depth=0;\n    }\n\n  /* To do: check bit depth of PNG alpha channel */\n\n  /* Check if image is grayscale. */\n  if (image_info->type != TrueColorMatteType && image_info->type !=\n    TrueColorType && SetImageGray(image,&image->exception))\n    jng_color_type-=2;\n\n  if (logging != MagickFalse)\n    {\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    JNG Quality           = %d\",(int) jng_quality);\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"    JNG Color Type        = %d\",jng_color_type);\n        if (transparent != 0)\n          {\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    JNG Alpha Compression = %d\",jng_alpha_compression_method);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    JNG Alpha Depth       = %d\",jng_alpha_sample_depth);\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    JNG Alpha Quality     = %d\",(int) jng_alpha_quality);\n          }\n    }\n\n  if (transparent != 0)\n    {\n      if (jng_alpha_compression_method==0)\n        {\n          const char\n            *value;\n\n          /* Encode opacity as a grayscale PNG blob */\n\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Creating PNG blob for alpha.\");\n\n          status=OpenBlob(jpeg_image_info,jpeg_image,WriteBinaryBlobMode,\n            &image->exception);\n          if (status == MagickFalse)\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n          length=0;\n\n          (void) CopyMagickString(jpeg_image_info->magick,\"PNG\",MaxTextExtent);\n          (void) CopyMagickString(jpeg_image->magick,\"PNG\",MaxTextExtent);\n          jpeg_image_info->interlace=NoInterlace;\n\n          /* Exclude all ancillary chunks */\n          (void) SetImageArtifact(jpeg_image,\"png:exclude-chunks\",\"all\");\n\n          blob=ImageToBlob(jpeg_image_info,jpeg_image,&length,\n            &image->exception);\n\n          /* Retrieve sample depth used */\n          value=GetImageProperty(jpeg_image,\"png:bit-depth-written\");\n          if (value != (char *) NULL)\n            jng_alpha_sample_depth= (unsigned int) value[0];\n        }\n      else\n        {\n          /* Encode opacity as a grayscale JPEG blob */\n\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Creating JPEG blob for alpha.\");\n\n          status=OpenBlob(jpeg_image_info,jpeg_image,WriteBinaryBlobMode,\n            &image->exception);\n\n          if (status == MagickFalse)\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n          (void) CopyMagickString(jpeg_image_info->magick,\"JPEG\",MaxTextExtent);\n          (void) CopyMagickString(jpeg_image->magick,\"JPEG\",MaxTextExtent);\n          jpeg_image_info->interlace=NoInterlace;\n          blob=ImageToBlob(jpeg_image_info,jpeg_image,&length,\n           &image->exception);\n          jng_alpha_sample_depth=8;\n\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Successfully read jpeg_image into a blob, length=%.20g.\",\n              (double) length);\n\n        }\n      /* Destroy JPEG image and image_info */\n      jpeg_image=DestroyImage(jpeg_image);\n      (void) RelinquishUniqueFileResource(jpeg_image_info->filename);\n      unique_filenames--;\n      jpeg_image_info=DestroyImageInfo(jpeg_image_info);\n    }\n\n  /* Write JHDR chunk */\n  (void) WriteBlobMSBULong(image,16L);  /* chunk data length=16 */\n  PNGType(chunk,mng_JHDR);\n  LogPNGChunk(logging,mng_JHDR,16L);\n  PNGLong(chunk+4,(png_uint_32) image->columns);\n  PNGLong(chunk+8,(png_uint_32) image->rows);\n  chunk[12]=jng_color_type;\n  chunk[13]=8;  /* sample depth */\n  chunk[14]=8; /*jng_image_compression_method */\n  chunk[15]=(unsigned char) (image_info->interlace == NoInterlace ? 0 : 8);\n  chunk[16]=jng_alpha_sample_depth;\n  chunk[17]=jng_alpha_compression_method;\n  chunk[18]=0; /*jng_alpha_filter_method */\n  chunk[19]=0; /*jng_alpha_interlace_method */\n  (void) WriteBlob(image,20,chunk);\n  (void) WriteBlobMSBULong(image,crc32(0,chunk,20));\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG width:%15lu\",(unsigned long) image->columns);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG height:%14lu\",(unsigned long) image->rows);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG color type:%10d\",jng_color_type);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG sample depth:%8d\",8);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG compression:%9d\",8);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG interlace:%11d\",0);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG alpha depth:%9d\",jng_alpha_sample_depth);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG alpha compression:%3d\",jng_alpha_compression_method);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG alpha filter:%8d\",0);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"    JNG alpha interlace:%5d\",0);\n    }\n\n  /*\n     Write leading ancillary chunks\n  */\n\n  if (transparent != 0)\n  {\n    /*\n      Write JNG bKGD chunk\n    */\n\n    unsigned char\n      blue,\n      green,\n      red;\n\n    ssize_t\n      num_bytes;\n\n    if (jng_color_type == 8 || jng_color_type == 12)\n      num_bytes=6L;\n    else\n      num_bytes=10L;\n    (void) WriteBlobMSBULong(image,(size_t) (num_bytes-4L));\n    PNGType(chunk,mng_bKGD);\n    LogPNGChunk(logging,mng_bKGD,(size_t) (num_bytes-4L));\n    red=ScaleQuantumToChar(image->background_color.red);\n    green=ScaleQuantumToChar(image->background_color.green);\n    blue=ScaleQuantumToChar(image->background_color.blue);\n    *(chunk+4)=0;\n    *(chunk+5)=red;\n    *(chunk+6)=0;\n    *(chunk+7)=green;\n    *(chunk+8)=0;\n    *(chunk+9)=blue;\n    (void) WriteBlob(image,(size_t) num_bytes,chunk);\n    (void) WriteBlobMSBULong(image,crc32(0,chunk,(uInt) num_bytes));\n  }\n\n  if ((image->colorspace == sRGBColorspace || image->rendering_intent))\n    {\n      /*\n        Write JNG sRGB chunk\n      */\n      (void) WriteBlobMSBULong(image,1L);\n      PNGType(chunk,mng_sRGB);\n      LogPNGChunk(logging,mng_sRGB,1L);\n\n      if (image->rendering_intent != UndefinedIntent)\n        chunk[4]=(unsigned char)\n          Magick_RenderingIntent_to_PNG_RenderingIntent(\n          (image->rendering_intent));\n\n      else\n        chunk[4]=(unsigned char)\n          Magick_RenderingIntent_to_PNG_RenderingIntent(\n          (PerceptualIntent));\n\n      (void) WriteBlob(image,5,chunk);\n      (void) WriteBlobMSBULong(image,crc32(0,chunk,5));\n    }\n  else\n    {\n      if (image->gamma != 0.0)\n        {\n          /*\n             Write JNG gAMA chunk\n          */\n          (void) WriteBlobMSBULong(image,4L);\n          PNGType(chunk,mng_gAMA);\n          LogPNGChunk(logging,mng_gAMA,4L);\n          PNGLong(chunk+4,(png_uint_32) (100000*image->gamma+0.5));\n          (void) WriteBlob(image,8,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,8));\n        }\n\n      if ((mng_info->equal_chrms == MagickFalse) &&\n          (image->chromaticity.red_primary.x != 0.0))\n        {\n          PrimaryInfo\n            primary;\n\n          /*\n             Write JNG cHRM chunk\n          */\n          (void) WriteBlobMSBULong(image,32L);\n          PNGType(chunk,mng_cHRM);\n          LogPNGChunk(logging,mng_cHRM,32L);\n          primary=image->chromaticity.white_point;\n          PNGLong(chunk+4,(png_uint_32) (100000*primary.x+0.5));\n          PNGLong(chunk+8,(png_uint_32) (100000*primary.y+0.5));\n          primary=image->chromaticity.red_primary;\n          PNGLong(chunk+12,(png_uint_32) (100000*primary.x+0.5));\n          PNGLong(chunk+16,(png_uint_32) (100000*primary.y+0.5));\n          primary=image->chromaticity.green_primary;\n          PNGLong(chunk+20,(png_uint_32) (100000*primary.x+0.5));\n          PNGLong(chunk+24,(png_uint_32) (100000*primary.y+0.5));\n          primary=image->chromaticity.blue_primary;\n          PNGLong(chunk+28,(png_uint_32) (100000*primary.x+0.5));\n          PNGLong(chunk+32,(png_uint_32) (100000*primary.y+0.5));\n          (void) WriteBlob(image,36,chunk);\n          (void) WriteBlobMSBULong(image,crc32(0,chunk,36));\n        }\n    }\n\n  if (image->x_resolution && image->y_resolution && !mng_info->equal_physs)\n    {\n      /*\n         Write JNG pHYs chunk\n      */\n      (void) WriteBlobMSBULong(image,9L);\n      PNGType(chunk,mng_pHYs);\n      LogPNGChunk(logging,mng_pHYs,9L);\n      if (image->units == PixelsPerInchResolution)\n        {\n          PNGLong(chunk+4,(png_uint_32)\n            (image->x_resolution*100.0/2.54+0.5));\n\n          PNGLong(chunk+8,(png_uint_32)\n            (image->y_resolution*100.0/2.54+0.5));\n\n          chunk[12]=1;\n        }\n\n      else\n        {\n          if (image->units == PixelsPerCentimeterResolution)\n            {\n              PNGLong(chunk+4,(png_uint_32)\n                (image->x_resolution*100.0+0.5));\n\n              PNGLong(chunk+8,(png_uint_32)\n                (image->y_resolution*100.0+0.5));\n\n              chunk[12]=1;\n            }\n\n          else\n            {\n              PNGLong(chunk+4,(png_uint_32) (image->x_resolution+0.5));\n              PNGLong(chunk+8,(png_uint_32) (image->y_resolution+0.5));\n              chunk[12]=0;\n            }\n        }\n      (void) WriteBlob(image,13,chunk);\n      (void) WriteBlobMSBULong(image,crc32(0,chunk,13));\n    }\n\n  if (mng_info->write_mng == 0 && (image->page.x || image->page.y))\n    {\n      /*\n         Write JNG oFFs chunk\n      */\n      (void) WriteBlobMSBULong(image,9L);\n      PNGType(chunk,mng_oFFs);\n      LogPNGChunk(logging,mng_oFFs,9L);\n      PNGsLong(chunk+4,(ssize_t) (image->page.x));\n      PNGsLong(chunk+8,(ssize_t) (image->page.y));\n      chunk[12]=0;\n      (void) WriteBlob(image,13,chunk);\n      (void) WriteBlobMSBULong(image,crc32(0,chunk,13));\n    }\n\n  if (transparent != 0)\n    {\n      if (jng_alpha_compression_method==0)\n        {\n          register ssize_t\n            i;\n\n          size_t\n            len;\n\n          /* Write IDAT chunk header */\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Write IDAT chunks from blob, length=%.20g.\",(double)\n              length);\n\n          /* Copy IDAT chunks */\n          len=0;\n          p=blob+8;\n          for (i=8; i<(ssize_t) length; i+=len+12)\n          {\n            len=(((unsigned int) *(p    ) & 0xff) << 24) +\n                (((unsigned int) *(p + 1) & 0xff) << 16) +\n                (((unsigned int) *(p + 2) & 0xff) <<  8) +\n                (((unsigned int) *(p + 3) & 0xff)      ) ;\n            p+=4;\n\n            if (*(p)==73 && *(p+1)==68 && *(p+2)==65 && *(p+3)==84) /* IDAT */\n              {\n                /* Found an IDAT chunk. */\n                (void) WriteBlobMSBULong(image,len);\n                LogPNGChunk(logging,mng_IDAT,len);\n                (void) WriteBlob(image,len+4,p);\n                (void) WriteBlobMSBULong(image,crc32(0,p,(uInt) len+4));\n              }\n\n            else\n              {\n                if (logging != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"    Skipping %c%c%c%c chunk, length=%.20g.\",\n                    *(p),*(p+1),*(p+2),*(p+3),(double) len);\n              }\n            p+=(8+len);\n          }\n        }\n      else if (length != 0)\n        {\n          /* Write JDAA chunk header */\n          if (logging != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  Write JDAA chunk, length=%.20g.\",(double) length);\n          (void) WriteBlobMSBULong(image,(size_t) length);\n          PNGType(chunk,mng_JDAA);\n          LogPNGChunk(logging,mng_JDAA,length);\n          /* Write JDAT chunk(s) data */\n          (void) WriteBlob(image,4,chunk);\n          (void) WriteBlob(image,length,blob);\n          (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),blob,\n             (uInt) length));\n        }\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n    }\n\n  /* Encode image as a JPEG blob */\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Creating jpeg_image_info.\");\n  jpeg_image_info=(ImageInfo *) CloneImageInfo(image_info);\n  if (jpeg_image_info == (ImageInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Creating jpeg_image.\");\n\n  jpeg_image=CloneImage(image,0,0,MagickTrue,&image->exception);\n  if (jpeg_image == (Image *) NULL)\n    {\n      jpeg_image_info=DestroyImageInfo(jpeg_image_info);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  (void) CopyMagickString(jpeg_image->magick,\"JPEG\",MaxTextExtent);\n\n  (void) AcquireUniqueFilename(jpeg_image->filename);\n  unique_filenames++;\n  (void) FormatLocaleString(jpeg_image_info->filename,MaxTextExtent,\"%s\",\n    jpeg_image->filename);\n\n  status=OpenBlob(jpeg_image_info,jpeg_image,WriteBinaryBlobMode,\n    &image->exception);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Created jpeg_image, %.20g x %.20g.\",(double) jpeg_image->columns,\n      (double) jpeg_image->rows);\n\n  if (status == MagickFalse)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  if (jng_color_type == 8 || jng_color_type == 12)\n    jpeg_image_info->type=GrayscaleType;\n\n  jpeg_image_info->quality=jng_quality;\n  jpeg_image->quality=jng_quality;\n  (void) CopyMagickString(jpeg_image_info->magick,\"JPEG\",MaxTextExtent);\n  (void) CopyMagickString(jpeg_image->magick,\"JPEG\",MaxTextExtent);\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  Creating blob.\");\n\n  blob=ImageToBlob(jpeg_image_info,jpeg_image,&length,&image->exception);\n\n  if (logging != MagickFalse)\n    {\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Successfully read jpeg_image into a blob, length=%.20g.\",\n        (double) length);\n\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Write JDAT chunk, length=%.20g.\",(double) length);\n    }\n\n  /* Write JDAT chunk(s) */\n  (void) WriteBlobMSBULong(image,(size_t) length);\n  PNGType(chunk,mng_JDAT);\n  LogPNGChunk(logging,mng_JDAT,length);\n  (void) WriteBlob(image,4,chunk);\n  (void) WriteBlob(image,length,blob);\n  (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),blob,(uInt) length));\n\n  jpeg_image=DestroyImage(jpeg_image);\n  (void) RelinquishUniqueFileResource(jpeg_image_info->filename);\n  unique_filenames--;\n  jpeg_image_info=DestroyImageInfo(jpeg_image_info);\n  blob=(unsigned char *) RelinquishMagickMemory(blob);\n\n  /* Write IEND chunk */\n  (void) WriteBlobMSBULong(image,0L);\n  PNGType(chunk,mng_IEND);\n  LogPNGChunk(logging,mng_IEND,0);\n  (void) WriteBlob(image,4,chunk);\n  (void) WriteBlobMSBULong(image,crc32(0,chunk,4));\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n      \"  exit WriteOneJNGImage(); unique_filenames=%d\",unique_filenames);\n\n  return(status);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -493,7 +493,10 @@\n \n   jpeg_image=CloneImage(image,0,0,MagickTrue,&image->exception);\n   if (jpeg_image == (Image *) NULL)\n-    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n+    {\n+      jpeg_image_info=DestroyImageInfo(jpeg_image_info);\n+      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n+    }\n   (void) CopyMagickString(jpeg_image->magick,\"JPEG\",MaxTextExtent);\n \n   (void) AcquireUniqueFilename(jpeg_image->filename);",
        "diff_line_info": {
            "deleted_lines": [
                "    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");"
            ],
            "added_lines": [
                "    {",
                "      jpeg_image_info=DestroyImageInfo(jpeg_image_info);",
                "      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-13060",
        "func_name": "ImageMagick/ReadMATImage",
        "description": "In ImageMagick 7.0.6-5, a memory leak vulnerability was found in the function ReadMATImage in coders/mat.c, which allows attackers to cause a denial of service via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/7d957e40e68c9af33f24d52f610d48ec758e88d9",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/644",
        "commit_text": "",
        "func_before": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default:\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if (image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  else\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n  return (image);\n}",
        "func": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  PixelPacket *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  size_t Unknown6;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  image = AcquireImage(image_info);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=(ImageInfo *) NULL;\n  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\n    {\nMATLAB_KO:\n      if ((image != image2) && (image2 != (Image *) NULL))\n        image2=DestroyImage(image2);\n      if (clone_info != (ImageInfo *) NULL)\n        clone_info=DestroyImageInfo(clone_info);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))\n      goto MATLAB_KO;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    clone_info=CloneImageInfo(image_info);\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           Unknown6 = ReadBlobXXXLong(image2);\n           (void) Unknown6;\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n           ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default:\n        if (clone_info != (ImageInfo *) NULL)\n          clone_info=DestroyImageInfo(clone_info);\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\nNEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        if (clone_info)\n          clone_info=DestroyImageInfo(clone_info);\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)\n      goto MATLAB_KO;\n      /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        SetImageColorspace(image,GRAYColorspace);\n        image->type=GrayscaleType;\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        if ((image != image2) && (image2 != (Image *) NULL))\n          image2=DestroyImage(image2);\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (PixelPacket *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n\n    if(image2!=NULL)\n      if(image2!=image)   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) unlink(clone_info->filename);\n          }\n         }\n       }\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if (image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\")\n  else\n    if ((image != image2) && (image2 != (Image *) NULL))\n      image2=DestroyImage(image2);\n  return (image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -296,6 +296,8 @@\n     status=SetImageExtent(image,image->columns,image->rows);\n     if (status == MagickFalse)\n       {\n+        if ((image != image2) && (image2 != (Image *) NULL))\n+          image2=DestroyImage(image2);\n         InheritException(exception,&image->exception);\n         return(DestroyImageList(image));\n       }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if ((image != image2) && (image2 != (Image *) NULL))",
                "          image2=DestroyImage(image2);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-13062",
        "func_name": "ImageMagick/formatIPTC",
        "description": "In ImageMagick 7.0.6-6, a memory leak vulnerability was found in the function formatIPTC in coders/meta.c, which allows attackers to cause a denial of service (WriteMETAImage memory consumption) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/45131f6133847d8494e8916c9ac12284cdbf6226",
        "commit_title": "Fixed memory leak reported in #669.",
        "commit_text": "",
        "func_before": "static int formatIPTC(Image *ifile, Image *ofile)\n{\n  char\n    temp[MagickPathExtent];\n\n  unsigned int\n    foundiptc,\n    tagsfound;\n\n  unsigned char\n    recnum,\n    dataset;\n\n  unsigned char\n    *readable,\n    *str;\n\n  ssize_t\n    tagindx,\n    taglen;\n\n  int\n    i,\n    tagcount = (int) (sizeof(tags) / sizeof(tag_spec));\n\n  int\n    c;\n\n  foundiptc = 0; /* found the IPTC-Header */\n  tagsfound = 0; /* number of tags found */\n\n  c = ReadBlobByte(ifile);\n  while (c != EOF)\n  {\n    if (c == 0x1c)\n      foundiptc = 1;\n    else\n      {\n        if (foundiptc)\n          return(-1);\n        else\n          {\n            c=0;\n            continue;\n          }\n      }\n\n    /* we found the 0x1c tag and now grab the dataset and record number tags */\n    c = ReadBlobByte(ifile);\n    if (c == EOF) return -1;\n    dataset = (unsigned char) c;\n    c = ReadBlobByte(ifile);\n    if (c == EOF) return -1;\n    recnum = (unsigned char) c;\n    /* try to match this record to one of the ones in our named table */\n    for (i=0; i< tagcount; i++)\n    {\n      if (tags[i].id == (short) recnum)\n          break;\n    }\n    if (i < tagcount)\n      readable = (unsigned char *) tags[i].name;\n    else\n      readable = (unsigned char *) \"\";\n    /*\n      We decode the length of the block that follows - ssize_t or short fmt.\n    */\n    c=ReadBlobByte(ifile);\n    if (c == EOF) return -1;\n    if (c & (unsigned char) 0x80)\n      return 0;\n    else\n      {\n        int\n          c0;\n\n        c0=ReadBlobByte(ifile);\n        if (c0 == EOF) return -1;\n        taglen = (c << 8) | c0;\n      }\n    if (taglen < 0) return -1;\n    /* make a buffer to hold the tag datand snag it from the input stream */\n    str=(unsigned char *) AcquireQuantumMemory((size_t) (taglen+MagickPathExtent),\n      sizeof(*str));\n    if (str == (unsigned char *) NULL)\n      {\n        printf(\"MemoryAllocationFailed\");\n        return 0;\n      }\n    for (tagindx=0; tagindx<taglen; tagindx++)\n    {\n      c=ReadBlobByte(ifile);\n      if (c == EOF) return -1;\n      str[tagindx] = (unsigned char) c;\n    }\n    str[taglen] = 0;\n\n    /* now finish up by formatting this binary data into ASCII equivalent */\n    if (strlen((char *)readable) > 0)\n      (void) FormatLocaleString(temp,MagickPathExtent,\"%d#%d#%s=\",\n        (unsigned int) dataset, (unsigned int) recnum, readable);\n    else\n      (void) FormatLocaleString(temp,MagickPathExtent,\"%d#%d=\",\n        (unsigned int) dataset,(unsigned int) recnum);\n    (void) WriteBlobString(ofile,temp);\n    formatString( ofile, (char *)str, taglen );\n    str=(unsigned char *) RelinquishMagickMemory(str);\n\n    tagsfound++;\n\n    c=ReadBlobByte(ifile);\n  }\n  return((int) tagsfound);\n}",
        "func": "static int formatIPTC(Image *ifile, Image *ofile)\n{\n  char\n    temp[MagickPathExtent];\n\n  unsigned int\n    foundiptc,\n    tagsfound;\n\n  unsigned char\n    recnum,\n    dataset;\n\n  unsigned char\n    *readable,\n    *str;\n\n  ssize_t\n    tagindx,\n    taglen;\n\n  int\n    i,\n    tagcount = (int) (sizeof(tags) / sizeof(tag_spec));\n\n  int\n    c;\n\n  foundiptc = 0; /* found the IPTC-Header */\n  tagsfound = 0; /* number of tags found */\n\n  c = ReadBlobByte(ifile);\n  while (c != EOF)\n  {\n    if (c == 0x1c)\n      foundiptc = 1;\n    else\n      {\n        if (foundiptc)\n          return(-1);\n        else\n          {\n            c=0;\n            continue;\n          }\n      }\n\n    /* we found the 0x1c tag and now grab the dataset and record number tags */\n    c = ReadBlobByte(ifile);\n    if (c == EOF)\n      return(-1);\n    dataset = (unsigned char) c;\n    c = ReadBlobByte(ifile);\n    if (c == EOF)\n      return(-1);\n    recnum = (unsigned char) c;\n    /* try to match this record to one of the ones in our named table */\n    for (i=0; i< tagcount; i++)\n    {\n      if (tags[i].id == (short) recnum)\n          break;\n    }\n    if (i < tagcount)\n      readable = (unsigned char *) tags[i].name;\n    else\n      readable = (unsigned char *) \"\";\n    /*\n      We decode the length of the block that follows - ssize_t or short fmt.\n    */\n    c=ReadBlobByte(ifile);\n    if (c == EOF)\n      return(-1);\n    if (c & (unsigned char) 0x80)\n      return(0);\n    else\n      {\n        int\n          c0;\n\n        c0=ReadBlobByte(ifile);\n        if (c0 == EOF)\n          return(-1);\n        taglen = (c << 8) | c0;\n      }\n    if (taglen < 0)\n      return(-1);\n    /* make a buffer to hold the tag datand snag it from the input stream */\n    str=(unsigned char *) AcquireQuantumMemory((size_t) (taglen+MagickPathExtent),\n      sizeof(*str));\n    if (str == (unsigned char *) NULL)\n      {\n        printf(\"MemoryAllocationFailed\");\n        return(0);\n      }\n    for (tagindx=0; tagindx<taglen; tagindx++)\n    {\n      c=ReadBlobByte(ifile);\n      if (c == EOF)\n        {\n          str=(unsigned char *) RelinquishMagickMemory(str);\n          return(-1);\n        }\n      str[tagindx] = (unsigned char) c;\n    }\n    str[taglen] = 0;\n\n    /* now finish up by formatting this binary data into ASCII equivalent */\n    if (strlen((char *)readable) > 0)\n      (void) FormatLocaleString(temp,MagickPathExtent,\"%d#%d#%s=\",\n        (unsigned int) dataset, (unsigned int) recnum, readable);\n    else\n      (void) FormatLocaleString(temp,MagickPathExtent,\"%d#%d=\",\n        (unsigned int) dataset,(unsigned int) recnum);\n    (void) WriteBlobString(ofile,temp);\n    formatString( ofile, (char *)str, taglen );\n    str=(unsigned char *) RelinquishMagickMemory(str);\n\n    tagsfound++;\n\n    c=ReadBlobByte(ifile);\n  }\n  return((int) tagsfound);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -47,10 +47,12 @@\n \n     /* we found the 0x1c tag and now grab the dataset and record number tags */\n     c = ReadBlobByte(ifile);\n-    if (c == EOF) return -1;\n+    if (c == EOF)\n+      return(-1);\n     dataset = (unsigned char) c;\n     c = ReadBlobByte(ifile);\n-    if (c == EOF) return -1;\n+    if (c == EOF)\n+      return(-1);\n     recnum = (unsigned char) c;\n     /* try to match this record to one of the ones in our named table */\n     for (i=0; i< tagcount; i++)\n@@ -66,31 +68,38 @@\n       We decode the length of the block that follows - ssize_t or short fmt.\n     */\n     c=ReadBlobByte(ifile);\n-    if (c == EOF) return -1;\n+    if (c == EOF)\n+      return(-1);\n     if (c & (unsigned char) 0x80)\n-      return 0;\n+      return(0);\n     else\n       {\n         int\n           c0;\n \n         c0=ReadBlobByte(ifile);\n-        if (c0 == EOF) return -1;\n+        if (c0 == EOF)\n+          return(-1);\n         taglen = (c << 8) | c0;\n       }\n-    if (taglen < 0) return -1;\n+    if (taglen < 0)\n+      return(-1);\n     /* make a buffer to hold the tag datand snag it from the input stream */\n     str=(unsigned char *) AcquireQuantumMemory((size_t) (taglen+MagickPathExtent),\n       sizeof(*str));\n     if (str == (unsigned char *) NULL)\n       {\n         printf(\"MemoryAllocationFailed\");\n-        return 0;\n+        return(0);\n       }\n     for (tagindx=0; tagindx<taglen; tagindx++)\n     {\n       c=ReadBlobByte(ifile);\n-      if (c == EOF) return -1;\n+      if (c == EOF)\n+        {\n+          str=(unsigned char *) RelinquishMagickMemory(str);\n+          return(-1);\n+        }\n       str[tagindx] = (unsigned char) c;\n     }\n     str[taglen] = 0;",
        "diff_line_info": {
            "deleted_lines": [
                "    if (c == EOF) return -1;",
                "    if (c == EOF) return -1;",
                "    if (c == EOF) return -1;",
                "      return 0;",
                "        if (c0 == EOF) return -1;",
                "    if (taglen < 0) return -1;",
                "        return 0;",
                "      if (c == EOF) return -1;"
            ],
            "added_lines": [
                "    if (c == EOF)",
                "      return(-1);",
                "    if (c == EOF)",
                "      return(-1);",
                "    if (c == EOF)",
                "      return(-1);",
                "      return(0);",
                "        if (c0 == EOF)",
                "          return(-1);",
                "    if (taglen < 0)",
                "      return(-1);",
                "        return(0);",
                "      if (c == EOF)",
                "        {",
                "          str=(unsigned char *) RelinquishMagickMemory(str);",
                "          return(-1);",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-13146",
        "func_name": "ImageMagick/ReadMATImageV4",
        "description": "In ImageMagick before 6.9.8-5 and 7.x before 7.0.5-6, there is a memory leak in the ReadMATImage function in coders/mat.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/79e5dbcdd1fc2f714f9bae548bc55d5073f3ed20",
        "commit_title": "...",
        "commit_text": "",
        "func_before": "static Image *ReadMATImageV4(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  typedef struct {\n    unsigned char Type[4];\n    unsigned int nRows;\n    unsigned int nCols;\n    unsigned int imagf;\n    unsigned int nameLen;\n  } MAT4_HDR;\n\n  long\n    ldblk;\n\n  EndianType\n    endian;\n\n  Image\n    *rotate_image;\n\n  MagickBooleanType\n    status;\n\n  MAT4_HDR\n    HDR;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumFormatType\n    format_type;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned int\n    depth;\n\n\n  (void) SeekBlob(image,0,SEEK_SET);\n  while (EOFBlob(image) != MagickFalse)\n  {\n    /*\n     Object parser loop.\n    */\n    ldblk=ReadBlobLSBLong(image);\n    if ((ldblk > 9999) || (ldblk < 0))\n      break;\n    HDR.Type[3]=ldblk % 10; ldblk /= 10;  /* T digit */\n    HDR.Type[2]=ldblk % 10; ldblk /= 10;  /* P digit */\n    HDR.Type[1]=ldblk % 10; ldblk /= 10;  /* O digit */\n    HDR.Type[0]=ldblk;        /* M digit */\n    if (HDR.Type[3] != 0)\n      break;  /* Data format */\n    if (HDR.Type[2] != 0)\n      break;  /* Always 0 */\n    if (HDR.Type[0] == 0)\n      {\n        HDR.nRows=ReadBlobLSBLong(image);\n        HDR.nCols=ReadBlobLSBLong(image);\n        HDR.imagf=ReadBlobLSBLong(image);\n        HDR.nameLen=ReadBlobLSBLong(image);\n        endian=LSBEndian;\n      }\n    else\n      {\n        HDR.nRows=ReadBlobMSBLong(image);\n        HDR.nCols=ReadBlobMSBLong(image);\n        HDR.imagf=ReadBlobMSBLong(image);\n        HDR.nameLen=ReadBlobMSBLong(image);\n        endian=MSBEndian;\n      }\n    if ((HDR.imagf != 0) && (HDR.imagf != 1))\n      break;\n    if (HDR.nameLen > 0xFFFF)\n      return((Image *) NULL);\n    for (i=0; i < (ssize_t) HDR.nameLen; i++)\n    {\n      int\n        byte;\n\n      /*\n        Skip matrix name.\n      */\n      byte=ReadBlobByte(image);\n      if (byte == EOF)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          break;\n        }\n    }\n    image->columns=(size_t) HDR.nRows;\n    image->rows=(size_t) HDR.nCols;\n    SetImageColorspace(image,GRAYColorspace,exception);\n    if (image_info->ping != MagickFalse)\n      {\n        Swap(image->columns,image->rows);\n        return(image);\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return((Image *) NULL);\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      return((Image *) NULL);\n    switch(HDR.Type[1])\n    {\n      case 0:\n        format_type=FloatingPointQuantumFormat;\n        depth=64;\n        break;\n      case 1:\n        format_type=FloatingPointQuantumFormat;\n        depth=32;\n        break;\n      case 2:\n        format_type=UnsignedQuantumFormat;\n        depth=16;\n        break;\n      case 3:\n        format_type=SignedQuantumFormat;\n        depth=16;\n        break;\n      case 4:\n        format_type=UnsignedQuantumFormat;\n        depth=8;\n        break;\n      default:\n        format_type=UnsignedQuantumFormat;\n        depth=8;\n        break;\n    }\n    image->depth=depth;\n    if (HDR.Type[0] != 0)\n      SetQuantumEndian(image,quantum_info,MSBEndian);\n    status=SetQuantumFormat(image,quantum_info,format_type);\n    status=SetQuantumDepth(image,quantum_info,depth);\n    status=SetQuantumEndian(image,quantum_info,endian);\n    SetQuantumScale(quantum_info,1.0);\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      int\n        status;\n\n      register Quantum\n        *magick_restrict q;\n\n      count=ReadBlob(image,depth/8*image->columns,(char *) pixels);\n      if (count == -1)\n        break;\n      q=QueueAuthenticPixels(image,0,image->rows-y-1,image->columns,1,\n        exception);\n      if (q == (Quantum *) NULL)\n        break;\n      (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n        GrayQuantum,pixels,exception);\n      if ((HDR.Type[1] == 2) || (HDR.Type[1] == 3))\n        FixSignedValues(image,q,(int) image->columns);\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (HDR.imagf == 1)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        /*\n          Read complex pixels.\n        */\n        count=ReadBlob(image,depth/8*image->columns,(char *) pixels);\n        if (count == -1)\n          break;\n        if (HDR.Type[1] == 0)\n          InsertComplexDoubleRow(image,(double *) pixels,y,0,0,exception);\n        else\n          InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception);\n      }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    rotate_image=RotateImage(image,90.0,exception);\n    if (rotate_image != (Image *) NULL)\n      {\n        image=DestroyImage(image);\n        image=rotate_image;\n      }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    /*\n      Allocate next image structure.\n    */\n    AcquireNextImage(image_info,image,exception);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      GetBlobSize(image));\n    if (status == MagickFalse)\n      break;\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadMATImageV4(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  typedef struct {\n    unsigned char Type[4];\n    unsigned int nRows;\n    unsigned int nCols;\n    unsigned int imagf;\n    unsigned int nameLen;\n  } MAT4_HDR;\n\n  long\n    ldblk;\n\n  EndianType\n    endian;\n\n  Image\n    *rotate_image;\n\n  MagickBooleanType\n    status;\n\n  MAT4_HDR\n    HDR;\n\n  QuantumInfo\n    *quantum_info;\n\n  QuantumFormatType\n    format_type;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned int\n    depth;\n\n\n  quantum_info=(QuantumInfo *) NULL;\n  (void) SeekBlob(image,0,SEEK_SET);\n  while (EOFBlob(image) != MagickFalse)\n  {\n    /*\n     Object parser loop.\n    */\n    ldblk=ReadBlobLSBLong(image);\n    if ((ldblk > 9999) || (ldblk < 0))\n      break;\n    HDR.Type[3]=ldblk % 10; ldblk /= 10;  /* T digit */\n    HDR.Type[2]=ldblk % 10; ldblk /= 10;  /* P digit */\n    HDR.Type[1]=ldblk % 10; ldblk /= 10;  /* O digit */\n    HDR.Type[0]=ldblk;        /* M digit */\n    if (HDR.Type[3] != 0)\n      break;  /* Data format */\n    if (HDR.Type[2] != 0)\n      break;  /* Always 0 */\n    if (HDR.Type[0] == 0)\n      {\n        HDR.nRows=ReadBlobLSBLong(image);\n        HDR.nCols=ReadBlobLSBLong(image);\n        HDR.imagf=ReadBlobLSBLong(image);\n        HDR.nameLen=ReadBlobLSBLong(image);\n        endian=LSBEndian;\n      }\n    else\n      {\n        HDR.nRows=ReadBlobMSBLong(image);\n        HDR.nCols=ReadBlobMSBLong(image);\n        HDR.imagf=ReadBlobMSBLong(image);\n        HDR.nameLen=ReadBlobMSBLong(image);\n        endian=MSBEndian;\n      }\n    if ((HDR.imagf != 0) && (HDR.imagf != 1))\n      break;\n    if (HDR.nameLen > 0xFFFF)\n      return((Image *) NULL);\n    for (i=0; i < (ssize_t) HDR.nameLen; i++)\n    {\n      int\n        byte;\n\n      /*\n        Skip matrix name.\n      */\n      byte=ReadBlobByte(image);\n      if (byte == EOF)\n        {\n          ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n            image->filename);\n          break;\n        }\n    }\n    image->columns=(size_t) HDR.nRows;\n    image->rows=(size_t) HDR.nCols;\n    SetImageColorspace(image,GRAYColorspace,exception);\n    if (image_info->ping != MagickFalse)\n      {\n        Swap(image->columns,image->rows);\n        return(image);\n      }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return((Image *) NULL);\n    quantum_info=AcquireQuantumInfo(image_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      return((Image *) NULL);\n    switch(HDR.Type[1])\n    {\n      case 0:\n        format_type=FloatingPointQuantumFormat;\n        depth=64;\n        break;\n      case 1:\n        format_type=FloatingPointQuantumFormat;\n        depth=32;\n        break;\n      case 2:\n        format_type=UnsignedQuantumFormat;\n        depth=16;\n        break;\n      case 3:\n        format_type=SignedQuantumFormat;\n        depth=16;\n        break;\n      case 4:\n        format_type=UnsignedQuantumFormat;\n        depth=8;\n        break;\n      default:\n        format_type=UnsignedQuantumFormat;\n        depth=8;\n        break;\n    }\n    image->depth=depth;\n    if (HDR.Type[0] != 0)\n      SetQuantumEndian(image,quantum_info,MSBEndian);\n    status=SetQuantumFormat(image,quantum_info,format_type);\n    status=SetQuantumDepth(image,quantum_info,depth);\n    status=SetQuantumEndian(image,quantum_info,endian);\n    SetQuantumScale(quantum_info,1.0);\n    pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      int\n        status;\n\n      register Quantum\n        *magick_restrict q;\n\n      count=ReadBlob(image,depth/8*image->columns,(char *) pixels);\n      if (count == -1)\n        break;\n      q=QueueAuthenticPixels(image,0,image->rows-y-1,image->columns,1,\n        exception);\n      if (q == (Quantum *) NULL)\n        break;\n      (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,\n        GrayQuantum,pixels,exception);\n      if ((HDR.Type[1] == 2) || (HDR.Type[1] == 3))\n        FixSignedValues(image,q,(int) image->columns);\n      if (SyncAuthenticPixels(image,exception) == MagickFalse)\n        break;\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n            image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n    if (HDR.imagf == 1)\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        /*\n          Read complex pixels.\n        */\n        count=ReadBlob(image,depth/8*image->columns,(char *) pixels);\n        if (count == -1)\n          break;\n        if (HDR.Type[1] == 0)\n          InsertComplexDoubleRow(image,(double *) pixels,y,0,0,exception);\n        else\n          InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception);\n      }\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    rotate_image=RotateImage(image,90.0,exception);\n    if (rotate_image != (Image *) NULL)\n      {\n        image=DestroyImage(image);\n        image=rotate_image;\n      }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    /*\n      Allocate next image structure.\n    */\n    AcquireNextImage(image_info,image,exception);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      {\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n      GetBlobSize(image));\n    if (status == MagickFalse)\n      break;\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -44,6 +44,7 @@\n     depth;\n \n \n+  quantum_info=(QuantumInfo *) NULL;\n   (void) SeekBlob(image,0,SEEK_SET);\n   while (EOFBlob(image) != MagickFalse)\n   {\n@@ -189,7 +190,8 @@\n         else\n           InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception);\n       }\n-    quantum_info=DestroyQuantumInfo(quantum_info);\n+    if (quantum_info != (QuantumInfo *) NULL)\n+      quantum_info=DestroyQuantumInfo(quantum_info);\n     rotate_image=RotateImage(image,90.0,exception);\n     if (rotate_image != (Image *) NULL)\n       {",
        "diff_line_info": {
            "deleted_lines": [
                "    quantum_info=DestroyQuantumInfo(quantum_info);"
            ],
            "added_lines": [
                "  quantum_info=(QuantumInfo *) NULL;",
                "    if (quantum_info != (QuantumInfo *) NULL)",
                "      quantum_info=DestroyQuantumInfo(quantum_info);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-13146",
        "func_name": "ImageMagick/ReadMATImage",
        "description": "In ImageMagick before 6.9.8-5 and 7.x before 7.0.5-6, there is a memory leak in the ReadMATImage function in coders/mat.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/79e5dbcdd1fc2f714f9bae548bc55d5073f3ed20",
        "commit_title": "...",
        "commit_text": "",
        "func_before": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  register Quantum *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info,exception);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  clone_info=CloneImageInfo(image_info);\n  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\nMATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           (void) ReadBlobXXXLong(image2);\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\n    NEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        image->type=GrayscaleType;\n        SetImageColorspace(image,GRAYColorspace,exception);\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(image,q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n            exception);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n            exception);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image,exception);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n        }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}",
        "func": "static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image *image, *image2=NULL,\n   *rotated_image;\n  register Quantum *q;\n\n  unsigned int status;\n  MATHeader MATLAB_HDR;\n  size_t size;\n  size_t CellType;\n  QuantumInfo *quantum_info;\n  ImageInfo *clone_info;\n  int i;\n  ssize_t ldblk;\n  unsigned char *BImgBuff = NULL;\n  double MinVal, MaxVal;\n  unsigned z, z2;\n  unsigned Frames;\n  int logging;\n  int sample_size;\n  MagickOffsetType filepos=0x80;\n  BlobInfo *blob;\n  size_t one;\n\n  unsigned int (*ReadBlobXXXLong)(Image *image);\n  unsigned short (*ReadBlobXXXShort)(Image *image);\n  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);\n  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);\n\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter\");\n\n  /*\n     Open image file.\n   */\n  image = AcquireImage(image_info,exception);\n\n  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n     Read MATLAB image.\n   */\n  quantum_info=(QuantumInfo *) NULL;\n  clone_info=CloneImageInfo(image_info);\n  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if (strncmp(MATLAB_HDR.identific,\"MATLAB\",6) != 0)\n    {\n      image2=ReadMATImageV4(image_info,image,exception);\n      if (image2  == NULL)\n        goto MATLAB_KO;\n      image=image2;\n      goto END_OF_READING;\n    }\n  MATLAB_HDR.Version = ReadBlobLSBShort(image);\n  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  if (logging)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"  Endian %c%c\",\n      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);\n  if (!strncmp(MATLAB_HDR.EndianIndicator, \"IM\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobLSBLong;\n    ReadBlobXXXShort = ReadBlobLSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesLSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsLSB;\n    image->endian = LSBEndian;\n  }\n  else if (!strncmp(MATLAB_HDR.EndianIndicator, \"MI\", 2))\n  {\n    ReadBlobXXXLong = ReadBlobMSBLong;\n    ReadBlobXXXShort = ReadBlobMSBShort;\n    ReadBlobDoublesXXX = ReadBlobDoublesMSB;\n    ReadBlobFloatsXXX = ReadBlobFloatsMSB;\n    image->endian = MSBEndian;\n  }\n  else\n    goto MATLAB_KO;    /* unsupported endian */\n\n  if (strncmp(MATLAB_HDR.identific, \"MATLAB\", 6))\nMATLAB_KO: ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n\n  filepos = TellBlob(image);\n  while(!EOFBlob(image)) /* object parser loop */\n  {\n    Frames = 1;\n    (void) SeekBlob(image,filepos,SEEK_SET);\n    /* printf(\"pos=%X\\n\",TellBlob(image)); */\n\n    MATLAB_HDR.DataType = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);\n    if(EOFBlob(image)) break;\n    filepos += MATLAB_HDR.ObjectSize + 4 + 4;\n\n    image2 = image;\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n    if(MATLAB_HDR.DataType == miCOMPRESSED)\n    {\n      image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);\n      if(image2==NULL) continue;\n      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); /* replace compressed object type. */\n    }\n#endif\n\n    if(MATLAB_HDR.DataType!=miMATRIX) continue;  /* skip another objects. */\n\n    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);\n\n    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;\n    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;\n\n    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);\n    if(image!=image2)\n      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  /* ??? don't understand why ?? */\n    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);\n    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);\n    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);\n\n\n    switch(MATLAB_HDR.DimFlag)\n    {\n      case  8: z2=z=1; break;      /* 2D matrix*/\n      case 12: z2=z = ReadBlobXXXLong(image2);  /* 3D matrix RGB*/\n           (void) ReadBlobXXXLong(image2);\n         if(z!=3) ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         break;\n      case 16: z2=z = ReadBlobXXXLong(image2);  /* 4D matrix animation */\n         if(z!=3 && z!=1)\n            ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n         Frames = ReadBlobXXXLong(image2);\n         if (Frames == 0)\n           ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n         break;\n      default: ThrowReaderException(CoderError, \"MultidimensionalMatricesAreNotSupported\");\n    }\n\n    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);\n    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);\n\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"MATLAB_HDR.StructureClass %d\",MATLAB_HDR.StructureClass);\n    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&\n        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    /* float + complex float */\n        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    /* double + complex double */\n        MATLAB_HDR.StructureClass != mxINT8_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    /* uint8 + uint8 3D */\n        MATLAB_HDR.StructureClass != mxINT16_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    /* uint16 + uint16 3D */\n        MATLAB_HDR.StructureClass != mxINT32_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    /* uint32 + uint32 3D */\n        MATLAB_HDR.StructureClass != mxINT64_CLASS &&\n        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    /* uint64 + uint64 3D */\n      ThrowReaderException(CoderError,\"UnsupportedCellTypeInTheMatrix\");\n\n    switch (MATLAB_HDR.NameFlag)\n    {\n      case 0:\n        size = ReadBlobXXXLong(image2);  /* Object name string size */\n        size = 4 * (ssize_t) ((size + 3 + 1) / 4);\n        (void) SeekBlob(image2, size, SEEK_CUR);\n        break;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n        (void) ReadBlob(image2, 4, (unsigned char *) &size); /* Object name string */\n        break;\n      default:\n        goto MATLAB_KO;\n    }\n\n    CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n    if (logging)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"MATLAB_HDR.CellType: %.20g\",(double) CellType);\n\n    (void) ReadBlob(image2, 4, (unsigned char *) &size);     /* data size */\n\n    NEXT_FRAME:\n    switch (CellType)\n    {\n      case miINT8:\n      case miUINT8:\n        sample_size = 8;\n        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)\n          image->depth = 1;\n        else\n          image->depth = 8;         /* Byte type cell */\n        ldblk = (ssize_t) MATLAB_HDR.SizeX;\n        break;\n      case miINT16:\n      case miUINT16:\n        sample_size = 16;\n        image->depth = 16;        /* Word type cell */\n        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);\n        break;\n      case miINT32:\n      case miUINT32:\n        sample_size = 32;\n        image->depth = 32;        /* Dword type cell */\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miINT64:\n      case miUINT64:\n        sample_size = 64;\n        image->depth = 64;        /* Qword type cell */\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      case miSINGLE:\n        sample_size = 32;\n        image->depth = 32;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {              /* complex float type cell */\n  }\n        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);\n        break;\n      case miDOUBLE:\n        sample_size = 64;\n        image->depth = 64;        /* double type cell */\n        (void) SetImageOption(clone_info,\"quantum:format\",\"floating-point\");\nDisableMSCWarning(4127)\n        if (sizeof(double) != 8)\nRestoreMSCWarning\n          ThrowReaderException(CoderError, \"IncompatibleSizeOfDouble\");\n        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n  {                         /* complex double type cell */\n  }\n        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);\n        break;\n      default:\n        ThrowReaderException(CoderError, \"UnsupportedCellTypeInTheMatrix\");\n    }\n    (void) sample_size;\n    image->columns = MATLAB_HDR.SizeX;\n    image->rows = MATLAB_HDR.SizeY;\n    quantum_info=AcquireQuantumInfo(clone_info,image);\n    if (quantum_info == (QuantumInfo *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    one=1;\n    image->colors = one << image->depth;\n    if (image->columns == 0 || image->rows == 0)\n      goto MATLAB_KO;\n    /* Image is gray when no complex flag is set and 2D Matrix */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      {\n        image->type=GrayscaleType;\n        SetImageColorspace(image,GRAYColorspace,exception);\n      }\n\n\n    /*\n      If ping is true, then only set image size and colors without\n      reading any image data.\n    */\n    if (image_info->ping)\n    {\n      size_t temp = image->columns;\n      image->columns = image->rows;\n      image->rows = temp;\n      goto done_reading; /* !!!!!! BAD  !!!! */\n    }\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n\n  /* ----- Load raster data ----- */\n    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    /* Ldblk was set in the check phase */\n    if (BImgBuff == NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));\n\n    MinVal = 0;\n    MaxVal = 0;\n    if (CellType==miDOUBLE || CellType==miSINGLE)        /* Find Min and Max Values for floats */\n    {\n      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);\n    }\n\n    /* Main loop for reading all scanlines */\n    if(z==1) z=0; /* read grey scanlines */\n    /* else read color scanlines */\n    do\n    {\n      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n      {\n        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);\n        if (q == (Quantum *) NULL)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT set image pixels returns unexpected NULL on a row %u.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto done_reading;    /* Skip image rotation, when cannot set image pixels    */\n  }\n        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n             \"  MAT cannot read scanrow %u from a file.\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))\n        {\n          FixLogical((unsigned char *)BImgBuff,ldblk);\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n    {\nImportQuantumPixelsFailed:\n      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  MAT failed to ImportQuantumPixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n      break;\n    }\n        }\n        else\n        {\n          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)\n      goto ImportQuantumPixelsFailed;\n\n\n          if (z<=1 &&       /* fix only during a last pass z==0 || z==1 */\n          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))\n      FixSignedValues(image,q,MATLAB_HDR.SizeX);\n        }\n\n        if (!SyncAuthenticPixels(image,exception))\n  {\n    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  MAT failed to sync image pixels for a row %u\", (unsigned)(MATLAB_HDR.SizeY-i-1));\n    goto ExitLoop;\n  }\n      }\n    } while(z-- >= 2);\nExitLoop:\n\n\n    /* Read complex part of numbers here */\n    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)\n    {        /* Find Min and Max Values for complex parts of floats */\n      CellType = ReadBlobXXXLong(image2);    /* Additional object type */\n      i = ReadBlobXXXLong(image2);           /* size of a complex part - toss away*/\n\n      if (CellType==miDOUBLE || CellType==miSINGLE)\n      {\n        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);\n      }\n\n      if (CellType==miDOUBLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);\n          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,\n            exception);\n  }\n\n      if (CellType==miSINGLE)\n        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)\n  {\n          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);\n          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,\n            exception);\n  }\n    }\n\n      /* Image is gray when no complex flag is set and 2D Matrix AGAIN!!! */\n    if ((MATLAB_HDR.DimFlag == 8) &&\n        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))\n      image->type=GrayscaleType;\n    if (image->depth == 1)\n      image->type=BilevelType;\n\n    if(image2==image)\n        image2 = NULL;    /* Remove shadow copy to an image before rotation. */\n\n      /*  Rotate image. */\n    rotated_image = RotateImage(image, 90.0, exception);\n    if (rotated_image != (Image *) NULL)\n    {\n        /* Remove page offsets added by RotateImage */\n      rotated_image->page.x=0;\n      rotated_image->page.y=0;\n\n      blob = rotated_image->blob;\n      rotated_image->blob = image->blob;\n      rotated_image->colors = image->colors;\n      image->blob = blob;\n      AppendImageToList(&image,rotated_image);\n      DeleteImageFromList(&image);\n    }\n\ndone_reading:\n\n    if(image2!=NULL)\n      if(image2!=image)\n      {\n        DeleteImageFromList(&image2);\n  if(clone_info)\n  {\n          if(clone_info->file)\n    {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n    }\n        }\n      }\n\n      /* Allocate next image structure. */\n    AcquireNextImage(image_info,image,exception);\n    if (image->next == (Image *) NULL) break;\n    image=SyncNextImageInList(image);\n    image->columns=image->rows=0;\n    image->colors=0;\n\n      /* row scan buffer is no longer needed */\n    RelinquishMagickMemory(BImgBuff);\n    BImgBuff = NULL;\n\n    if(--Frames>0)\n    {\n      z = z2;\n      if(image2==NULL) image2 = image;\n      goto NEXT_FRAME;\n    }\n    if ((image2!=NULL) && (image2!=image))   /* Does shadow temporary decompressed image exist? */\n      {\n/*  CloseBlob(image2); */\n        DeleteImageFromList(&image2);\n        if(clone_info)\n        {\n          if(clone_info->file)\n          {\n            fclose(clone_info->file);\n            clone_info->file = NULL;\n            (void) remove_utf8(clone_info->filename);\n          }\n        }\n        }\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */\n    for (p=image; p != (Image *) NULL; p=p->next)\n      p->scene=scene++;\n  }\n\n  if(clone_info != NULL)  /* cleanup garbage file from compression */\n  {\n    if(clone_info->file)\n    {\n      fclose(clone_info->file);\n      clone_info->file = NULL;\n      (void) remove_utf8(clone_info->filename);\n    }\n    DestroyImageInfo(clone_info);\n    clone_info = NULL;\n  }\n  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),\"return\");\n  if(image==NULL)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  return (image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -48,6 +48,7 @@\n   /*\n      Read MATLAB image.\n    */\n+  quantum_info=(QuantumInfo *) NULL;\n   clone_info=CloneImageInfo(image_info);\n   if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)\n     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n@@ -448,7 +449,8 @@\n   }\n \n   RelinquishMagickMemory(BImgBuff);\n-  quantum_info=DestroyQuantumInfo(quantum_info);\n+  if (quantum_info != (QuantumInfo *) NULL)\n+    quantum_info=DestroyQuantumInfo(quantum_info);\n END_OF_READING:\n   clone_info=DestroyImageInfo(clone_info);\n   CloseBlob(image);",
        "diff_line_info": {
            "deleted_lines": [
                "  quantum_info=DestroyQuantumInfo(quantum_info);"
            ],
            "added_lines": [
                "  quantum_info=(QuantumInfo *) NULL;",
                "  if (quantum_info != (QuantumInfo *) NULL)",
                "    quantum_info=DestroyQuantumInfo(quantum_info);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-6499",
        "func_name": "ImageMagick/Magick::throwException",
        "description": "An issue was discovered in Magick++ in ImageMagick 6.9.7. A specially crafted file creating a nested exception could lead to a memory leak (thus, a DoS).",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/3358f060fc182551822576b2c0a8850faab5d543",
        "commit_title": "Fixed memory leak when creating nested exceptions in Magick++.",
        "commit_text": "",
        "func_before": "MagickPPExport void Magick::throwException(ExceptionInfo *exception_,\n  const bool quiet_)\n{\n  const ExceptionInfo\n    *p;\n\n  Exception\n    *nestedException,\n    *q;\n\n  ExceptionType\n    severity;\n\n  size_t\n    index;\n\n  // Just return if there is no reported error\n  if (exception_->severity == UndefinedException)\n    return;\n\n  std::string message=formatExceptionMessage(exception_);\n  nestedException=(Exception *) NULL;\n  LockSemaphoreInfo(exception_->semaphore);\n  if (exception_->exceptions != (void *) NULL)\n    {\n      index=GetNumberOfElementsInLinkedList((LinkedListInfo *)\n        exception_->exceptions);\n      while(index > 0)\n      {\n        p=(const ExceptionInfo *) GetValueFromLinkedList((LinkedListInfo *)\n          exception_->exceptions,--index);\n        if ((p->severity != exception_->severity) || (LocaleCompare(p->reason,\n            exception_->reason) != 0) || (LocaleCompare(p->description,\n            exception_->description) != 0))\n          {\n            if (nestedException == (Exception *) NULL)\n              nestedException=createException(p);\n            else\n              {\n                q=createException(p);\n                nestedException->nested(q);\n                nestedException=q;\n              }\n          }\n      }\n    }\n  severity=exception_->severity;\n  UnlockSemaphoreInfo(exception_->semaphore);\n\n  if ((quiet_) && (severity < MagickCore::ErrorException))\n    {\n      delete nestedException;\n      return;\n    }\n\n  DestroyExceptionInfo(exception_);\n\n  switch (severity)\n  {\n    case BlobError:\n    case BlobFatalError:\n      throw ErrorBlob(message,nestedException);\n    case BlobWarning:\n      throw WarningBlob(message,nestedException);\n    case CacheError:\n    case CacheFatalError:\n      throw ErrorCache(message,nestedException);\n    case CacheWarning:\n      throw WarningCache(message,nestedException);\n    case CoderError:\n    case CoderFatalError:\n      throw ErrorCoder(message,nestedException);\n    case CoderWarning:\n      throw WarningCoder(message,nestedException);\n    case ConfigureError:\n    case ConfigureFatalError:\n      throw ErrorConfigure(message,nestedException);\n    case ConfigureWarning:\n      throw WarningConfigure(message,nestedException);\n    case CorruptImageError:\n    case CorruptImageFatalError:\n      throw ErrorCorruptImage(message,nestedException);\n    case CorruptImageWarning:\n      throw WarningCorruptImage(message,nestedException);\n    case DelegateError:\n    case DelegateFatalError:\n      throw ErrorDelegate(message,nestedException);\n    case DelegateWarning:\n      throw WarningDelegate(message,nestedException);\n    case DrawError:\n    case DrawFatalError:\n      throw ErrorDraw(message,nestedException);\n    case DrawWarning:\n      throw WarningDraw(message,nestedException);\n    case FileOpenError:\n    case FileOpenFatalError:\n      throw ErrorFileOpen(message,nestedException);\n    case FileOpenWarning:\n      throw WarningFileOpen(message,nestedException);\n    case ImageError:\n    case ImageFatalError:\n      throw ErrorImage(message,nestedException);\n    case ImageWarning:\n      throw WarningImage(message,nestedException);\n    case MissingDelegateError:\n    case MissingDelegateFatalError:\n      throw ErrorMissingDelegate(message,nestedException);\n    case MissingDelegateWarning:\n      throw WarningMissingDelegate(message,nestedException);\n    case ModuleError:\n    case ModuleFatalError:\n      throw ErrorModule(message,nestedException);\n    case ModuleWarning:\n      throw WarningModule(message,nestedException);\n    case MonitorError:\n    case MonitorFatalError:\n      throw ErrorMonitor(message,nestedException);\n    case MonitorWarning:\n      throw WarningMonitor(message,nestedException);\n    case OptionError:\n    case OptionFatalError:\n      throw ErrorOption(message,nestedException);\n    case OptionWarning:\n      throw WarningOption(message,nestedException);\n    case PolicyWarning:\n      throw WarningPolicy(message,nestedException);\n    case PolicyError:\n    case PolicyFatalError:\n      throw ErrorPolicy(message,nestedException);\n    case RegistryError:\n    case RegistryFatalError:\n      throw ErrorRegistry(message,nestedException);\n    case RegistryWarning:\n      throw WarningRegistry(message,nestedException);\n    case ResourceLimitError:\n    case ResourceLimitFatalError:\n      throw ErrorResourceLimit(message,nestedException);\n    case ResourceLimitWarning:\n      throw WarningResourceLimit(message,nestedException);\n    case StreamError:\n    case StreamFatalError:\n      throw ErrorStream(message,nestedException);\n    case StreamWarning:\n      throw WarningStream(message,nestedException);\n    case TypeError:\n    case TypeFatalError:\n      throw ErrorType(message,nestedException);\n    case TypeWarning:\n      throw WarningType(message,nestedException);\n    case UndefinedException:\n    default:\n      throw ErrorUndefined(message,nestedException);\n    case XServerError:\n    case XServerFatalError:\n      throw ErrorXServer(message,nestedException);\n    case XServerWarning:\n      throw WarningXServer(message,nestedException);\n    }\n}",
        "func": "MagickPPExport void Magick::throwException(ExceptionInfo *exception_,\n  const bool quiet_)\n{\n  const ExceptionInfo\n    *p;\n\n  Exception\n    *nestedException,\n    *q;\n\n  ExceptionType\n    severity;\n\n  size_t\n    index;\n\n  // Just return if there is no reported error\n  if (exception_->severity == UndefinedException)\n    return;\n\n  std::string message=formatExceptionMessage(exception_);\n  nestedException=(Exception *) NULL;\n  LockSemaphoreInfo(exception_->semaphore);\n  if (exception_->exceptions != (void *) NULL)\n    {\n      index=GetNumberOfElementsInLinkedList((LinkedListInfo *)\n        exception_->exceptions);\n      while(index > 0)\n      {\n        p=(const ExceptionInfo *) GetValueFromLinkedList((LinkedListInfo *)\n          exception_->exceptions,--index);\n        if ((p->severity != exception_->severity) || (LocaleCompare(p->reason,\n            exception_->reason) != 0) || (LocaleCompare(p->description,\n            exception_->description) != 0))\n          {\n            if (nestedException == (Exception *) NULL)\n              {\n                nestedException=createException(p);\n                q=nestedException;\n              }\n            else\n              {\n                Exception\n                  *r;\n\n                r=createException(p);\n                q->nested(r);\n                q=r;\n              }\n          }\n      }\n    }\n  severity=exception_->severity;\n  UnlockSemaphoreInfo(exception_->semaphore);\n\n  if ((quiet_) && (severity < MagickCore::ErrorException))\n    {\n      delete nestedException;\n      return;\n    }\n\n  DestroyExceptionInfo(exception_);\n\n  switch (severity)\n  {\n    case BlobError:\n    case BlobFatalError:\n      throw ErrorBlob(message,nestedException);\n    case BlobWarning:\n      throw WarningBlob(message,nestedException);\n    case CacheError:\n    case CacheFatalError:\n      throw ErrorCache(message,nestedException);\n    case CacheWarning:\n      throw WarningCache(message,nestedException);\n    case CoderError:\n    case CoderFatalError:\n      throw ErrorCoder(message,nestedException);\n    case CoderWarning:\n      throw WarningCoder(message,nestedException);\n    case ConfigureError:\n    case ConfigureFatalError:\n      throw ErrorConfigure(message,nestedException);\n    case ConfigureWarning:\n      throw WarningConfigure(message,nestedException);\n    case CorruptImageError:\n    case CorruptImageFatalError:\n      throw ErrorCorruptImage(message,nestedException);\n    case CorruptImageWarning:\n      throw WarningCorruptImage(message,nestedException);\n    case DelegateError:\n    case DelegateFatalError:\n      throw ErrorDelegate(message,nestedException);\n    case DelegateWarning:\n      throw WarningDelegate(message,nestedException);\n    case DrawError:\n    case DrawFatalError:\n      throw ErrorDraw(message,nestedException);\n    case DrawWarning:\n      throw WarningDraw(message,nestedException);\n    case FileOpenError:\n    case FileOpenFatalError:\n      throw ErrorFileOpen(message,nestedException);\n    case FileOpenWarning:\n      throw WarningFileOpen(message,nestedException);\n    case ImageError:\n    case ImageFatalError:\n      throw ErrorImage(message,nestedException);\n    case ImageWarning:\n      throw WarningImage(message,nestedException);\n    case MissingDelegateError:\n    case MissingDelegateFatalError:\n      throw ErrorMissingDelegate(message,nestedException);\n    case MissingDelegateWarning:\n      throw WarningMissingDelegate(message,nestedException);\n    case ModuleError:\n    case ModuleFatalError:\n      throw ErrorModule(message,nestedException);\n    case ModuleWarning:\n      throw WarningModule(message,nestedException);\n    case MonitorError:\n    case MonitorFatalError:\n      throw ErrorMonitor(message,nestedException);\n    case MonitorWarning:\n      throw WarningMonitor(message,nestedException);\n    case OptionError:\n    case OptionFatalError:\n      throw ErrorOption(message,nestedException);\n    case OptionWarning:\n      throw WarningOption(message,nestedException);\n    case PolicyWarning:\n      throw WarningPolicy(message,nestedException);\n    case PolicyError:\n    case PolicyFatalError:\n      throw ErrorPolicy(message,nestedException);\n    case RegistryError:\n    case RegistryFatalError:\n      throw ErrorRegistry(message,nestedException);\n    case RegistryWarning:\n      throw WarningRegistry(message,nestedException);\n    case ResourceLimitError:\n    case ResourceLimitFatalError:\n      throw ErrorResourceLimit(message,nestedException);\n    case ResourceLimitWarning:\n      throw WarningResourceLimit(message,nestedException);\n    case StreamError:\n    case StreamFatalError:\n      throw ErrorStream(message,nestedException);\n    case StreamWarning:\n      throw WarningStream(message,nestedException);\n    case TypeError:\n    case TypeFatalError:\n      throw ErrorType(message,nestedException);\n    case TypeWarning:\n      throw WarningType(message,nestedException);\n    case UndefinedException:\n    default:\n      throw ErrorUndefined(message,nestedException);\n    case XServerError:\n    case XServerFatalError:\n      throw ErrorXServer(message,nestedException);\n    case XServerWarning:\n      throw WarningXServer(message,nestedException);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -34,12 +34,18 @@\n             exception_->description) != 0))\n           {\n             if (nestedException == (Exception *) NULL)\n-              nestedException=createException(p);\n+              {\n+                nestedException=createException(p);\n+                q=nestedException;\n+              }\n             else\n               {\n-                q=createException(p);\n-                nestedException->nested(q);\n-                nestedException=q;\n+                Exception\n+                  *r;\n+\n+                r=createException(p);\n+                q->nested(r);\n+                q=r;\n               }\n           }\n       }",
        "diff_line_info": {
            "deleted_lines": [
                "              nestedException=createException(p);",
                "                q=createException(p);",
                "                nestedException->nested(q);",
                "                nestedException=q;"
            ],
            "added_lines": [
                "              {",
                "                nestedException=createException(p);",
                "                q=nestedException;",
                "              }",
                "                Exception",
                "                  *r;",
                "",
                "                r=createException(p);",
                "                q->nested(r);",
                "                q=r;"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-2903",
        "func_name": "kernel/git/netdev/net-next/ipddp_xmit",
        "description": "Memory leak in the appletalk subsystem in the Linux kernel 2.4.x through 2.4.37.6 and 2.6.x through 2.6.31, when the appletalk and ipddp modules are loaded but the ipddp\"N\" device is not found, allows remote attackers to cause a denial of service (memory consumption) via IP-DDP datagrams.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/davem/net-next.git;a=commit;h=ffcfb8db540ff879c2a85bf7e404954281443414",
        "commit_title": "And also do a better job of returning proper NET_{RX,XMIT}_ values.",
        "commit_text": " Based on a patch and suggestions by Mark Smith.  This fixes CVE-2009-2903  ",
        "func_before": "static netdev_tx_t ipddp_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\t__be32 paddr = skb_rtable(skb)->rt_gateway;\n        struct ddpehdr *ddp;\n        struct ipddp_route *rt;\n        struct atalk_addr *our_addr;\n\n\tspin_lock(&ipddp_route_lock);\n\n\t/*\n         * Find appropriate route to use, based only on IP number.\n         */\n        for(rt = ipddp_route_list; rt != NULL; rt = rt->next)\n        {\n                if(rt->ip == paddr)\n                        break;\n        }\n        if(rt == NULL) {\n\t\tspin_unlock(&ipddp_route_lock);\n                return NETDEV_TX_OK;\n\t}\n\n        our_addr = atalk_find_dev_addr(rt->dev);\n\n\tif(ipddp_mode == IPDDP_DECAP)\n\t\t/* \n\t\t * Pull off the excess room that should not be there.\n\t\t * This is due to a hard-header problem. This is the\n\t\t * quick fix for now though, till it breaks.\n\t\t */\n\t\tskb_pull(skb, 35-(sizeof(struct ddpehdr)+1));\n\n\t/* Create the Extended DDP header */\n\tddp = (struct ddpehdr *)skb->data;\n        ddp->deh_len_hops = htons(skb->len + (1<<10));\n        ddp->deh_sum = 0;\n\n\t/*\n         * For Localtalk we need aarp_send_ddp to strip the\n         * long DDP header and place a shot DDP header on it.\n         */\n        if(rt->dev->type == ARPHRD_LOCALTLK)\n        {\n                ddp->deh_dnet  = 0;   /* FIXME more hops?? */\n                ddp->deh_snet  = 0;\n        }\n        else\n        {\n                ddp->deh_dnet  = rt->at.s_net;   /* FIXME more hops?? */\n                ddp->deh_snet  = our_addr->s_net;\n        }\n        ddp->deh_dnode = rt->at.s_node;\n        ddp->deh_snode = our_addr->s_node;\n        ddp->deh_dport = 72;\n        ddp->deh_sport = 72;\n\n        *((__u8 *)(ddp+1)) = 22;        \t/* ddp type = IP */\n\n        skb->protocol = htons(ETH_P_ATALK);     /* Protocol has changed */\n\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += skb->len;\n\n        if(aarp_send_ddp(rt->dev, skb, &rt->at, NULL) < 0)\n                dev_kfree_skb(skb);\n\n\tspin_unlock(&ipddp_route_lock);\n\n        return NETDEV_TX_OK;\n}",
        "func": "static netdev_tx_t ipddp_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\t__be32 paddr = skb_rtable(skb)->rt_gateway;\n        struct ddpehdr *ddp;\n        struct ipddp_route *rt;\n        struct atalk_addr *our_addr;\n\n\tspin_lock(&ipddp_route_lock);\n\n\t/*\n         * Find appropriate route to use, based only on IP number.\n         */\n        for(rt = ipddp_route_list; rt != NULL; rt = rt->next)\n        {\n                if(rt->ip == paddr)\n                        break;\n        }\n        if(rt == NULL) {\n\t\tspin_unlock(&ipddp_route_lock);\n                return NETDEV_TX_OK;\n\t}\n\n        our_addr = atalk_find_dev_addr(rt->dev);\n\n\tif(ipddp_mode == IPDDP_DECAP)\n\t\t/* \n\t\t * Pull off the excess room that should not be there.\n\t\t * This is due to a hard-header problem. This is the\n\t\t * quick fix for now though, till it breaks.\n\t\t */\n\t\tskb_pull(skb, 35-(sizeof(struct ddpehdr)+1));\n\n\t/* Create the Extended DDP header */\n\tddp = (struct ddpehdr *)skb->data;\n        ddp->deh_len_hops = htons(skb->len + (1<<10));\n        ddp->deh_sum = 0;\n\n\t/*\n         * For Localtalk we need aarp_send_ddp to strip the\n         * long DDP header and place a shot DDP header on it.\n         */\n        if(rt->dev->type == ARPHRD_LOCALTLK)\n        {\n                ddp->deh_dnet  = 0;   /* FIXME more hops?? */\n                ddp->deh_snet  = 0;\n        }\n        else\n        {\n                ddp->deh_dnet  = rt->at.s_net;   /* FIXME more hops?? */\n                ddp->deh_snet  = our_addr->s_net;\n        }\n        ddp->deh_dnode = rt->at.s_node;\n        ddp->deh_snode = our_addr->s_node;\n        ddp->deh_dport = 72;\n        ddp->deh_sport = 72;\n\n        *((__u8 *)(ddp+1)) = 22;        \t/* ddp type = IP */\n\n        skb->protocol = htons(ETH_P_ATALK);     /* Protocol has changed */\n\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += skb->len;\n\n\taarp_send_ddp(rt->dev, skb, &rt->at, NULL);\n\n\tspin_unlock(&ipddp_route_lock);\n\n        return NETDEV_TX_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -61,8 +61,7 @@\n \tdev->stats.tx_packets++;\n \tdev->stats.tx_bytes += skb->len;\n \n-        if(aarp_send_ddp(rt->dev, skb, &rt->at, NULL) < 0)\n-                dev_kfree_skb(skb);\n+\taarp_send_ddp(rt->dev, skb, &rt->at, NULL);\n \n \tspin_unlock(&ipddp_route_lock);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "        if(aarp_send_ddp(rt->dev, skb, &rt->at, NULL) < 0)",
                "                dev_kfree_skb(skb);"
            ],
            "added_lines": [
                "\taarp_send_ddp(rt->dev, skb, &rt->at, NULL);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-2903",
        "func_name": "kernel/git/netdev/net-next/atalk_route_packet",
        "description": "Memory leak in the appletalk subsystem in the Linux kernel 2.4.x through 2.4.37.6 and 2.6.x through 2.6.31, when the appletalk and ipddp modules are loaded but the ipddp\"N\" device is not found, allows remote attackers to cause a denial of service (memory consumption) via IP-DDP datagrams.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/davem/net-next.git;a=commit;h=ffcfb8db540ff879c2a85bf7e404954281443414",
        "commit_title": "And also do a better job of returning proper NET_{RX,XMIT}_ values.",
        "commit_text": " Based on a patch and suggestions by Mark Smith.  This fixes CVE-2009-2903  ",
        "func_before": "static void atalk_route_packet(struct sk_buff *skb, struct net_device *dev,\n\t\t\t       struct ddpehdr *ddp, __u16 len_hops,\n\t\t\t       int origlen)\n{\n\tstruct atalk_route *rt;\n\tstruct atalk_addr ta;\n\n\t/*\n\t * Don't route multicast, etc., packets, or packets sent to \"this\n\t * network\"\n\t */\n\tif (skb->pkt_type != PACKET_HOST || !ddp->deh_dnet) {\n\t\t/*\n\t\t * FIXME:\n\t\t *\n\t\t * Can it ever happen that a packet is from a PPP iface and\n\t\t * needs to be broadcast onto the default network?\n\t\t */\n\t\tif (dev->type == ARPHRD_PPP)\n\t\t\tprintk(KERN_DEBUG \"AppleTalk: didn't forward broadcast \"\n\t\t\t\t\t  \"packet received from PPP iface\\n\");\n\t\tgoto free_it;\n\t}\n\n\tta.s_net  = ddp->deh_dnet;\n\tta.s_node = ddp->deh_dnode;\n\n\t/* Route the packet */\n\trt = atrtr_find(&ta);\n\t/* increment hops count */\n\tlen_hops += 1 << 10;\n\tif (!rt || !(len_hops & (15 << 10)))\n\t\tgoto free_it;\n\n\t/* FIXME: use skb->cb to be able to use shared skbs */\n\n\t/*\n\t * Route goes through another gateway, so set the target to the\n\t * gateway instead.\n\t */\n\n\tif (rt->flags & RTF_GATEWAY) {\n\t\tta.s_net  = rt->gateway.s_net;\n\t\tta.s_node = rt->gateway.s_node;\n\t}\n\n\t/* Fix up skb->len field */\n\tskb_trim(skb, min_t(unsigned int, origlen,\n\t\t\t    (rt->dev->hard_header_len +\n\t\t\t     ddp_dl->header_length + (len_hops & 1023))));\n\n\t/* FIXME: use skb->cb to be able to use shared skbs */\n\tddp->deh_len_hops = htons(len_hops);\n\n\t/*\n\t * Send the buffer onwards\n\t *\n\t * Now we must always be careful. If it's come from LocalTalk to\n\t * EtherTalk it might not fit\n\t *\n\t * Order matters here: If a packet has to be copied to make a new\n\t * headroom (rare hopefully) then it won't need unsharing.\n\t *\n\t * Note. ddp-> becomes invalid at the realloc.\n\t */\n\tif (skb_headroom(skb) < 22) {\n\t\t/* 22 bytes - 12 ether, 2 len, 3 802.2 5 snap */\n\t\tstruct sk_buff *nskb = skb_realloc_headroom(skb, 32);\n\t\tkfree_skb(skb);\n\t\tif (!nskb)\n\t\t\tgoto out;\n\t\tskb = nskb;\n\t} else\n\t\tskb = skb_unshare(skb, GFP_ATOMIC);\n\n\t/*\n\t * If the buffer didn't vanish into the lack of space bitbucket we can\n\t * send it.\n\t */\n\tif (skb && aarp_send_ddp(rt->dev, skb, &ta, NULL) == -1)\n\t\tgoto free_it;\nout:\n\treturn;\nfree_it:\n\tkfree_skb(skb);\n}",
        "func": "static int atalk_route_packet(struct sk_buff *skb, struct net_device *dev,\n\t\t\t      struct ddpehdr *ddp, __u16 len_hops, int origlen)\n{\n\tstruct atalk_route *rt;\n\tstruct atalk_addr ta;\n\n\t/*\n\t * Don't route multicast, etc., packets, or packets sent to \"this\n\t * network\"\n\t */\n\tif (skb->pkt_type != PACKET_HOST || !ddp->deh_dnet) {\n\t\t/*\n\t\t * FIXME:\n\t\t *\n\t\t * Can it ever happen that a packet is from a PPP iface and\n\t\t * needs to be broadcast onto the default network?\n\t\t */\n\t\tif (dev->type == ARPHRD_PPP)\n\t\t\tprintk(KERN_DEBUG \"AppleTalk: didn't forward broadcast \"\n\t\t\t\t\t  \"packet received from PPP iface\\n\");\n\t\tgoto free_it;\n\t}\n\n\tta.s_net  = ddp->deh_dnet;\n\tta.s_node = ddp->deh_dnode;\n\n\t/* Route the packet */\n\trt = atrtr_find(&ta);\n\t/* increment hops count */\n\tlen_hops += 1 << 10;\n\tif (!rt || !(len_hops & (15 << 10)))\n\t\tgoto free_it;\n\n\t/* FIXME: use skb->cb to be able to use shared skbs */\n\n\t/*\n\t * Route goes through another gateway, so set the target to the\n\t * gateway instead.\n\t */\n\n\tif (rt->flags & RTF_GATEWAY) {\n\t\tta.s_net  = rt->gateway.s_net;\n\t\tta.s_node = rt->gateway.s_node;\n\t}\n\n\t/* Fix up skb->len field */\n\tskb_trim(skb, min_t(unsigned int, origlen,\n\t\t\t    (rt->dev->hard_header_len +\n\t\t\t     ddp_dl->header_length + (len_hops & 1023))));\n\n\t/* FIXME: use skb->cb to be able to use shared skbs */\n\tddp->deh_len_hops = htons(len_hops);\n\n\t/*\n\t * Send the buffer onwards\n\t *\n\t * Now we must always be careful. If it's come from LocalTalk to\n\t * EtherTalk it might not fit\n\t *\n\t * Order matters here: If a packet has to be copied to make a new\n\t * headroom (rare hopefully) then it won't need unsharing.\n\t *\n\t * Note. ddp-> becomes invalid at the realloc.\n\t */\n\tif (skb_headroom(skb) < 22) {\n\t\t/* 22 bytes - 12 ether, 2 len, 3 802.2 5 snap */\n\t\tstruct sk_buff *nskb = skb_realloc_headroom(skb, 32);\n\t\tkfree_skb(skb);\n\t\tskb = nskb;\n\t} else\n\t\tskb = skb_unshare(skb, GFP_ATOMIC);\n\n\t/*\n\t * If the buffer didn't vanish into the lack of space bitbucket we can\n\t * send it.\n\t */\n\tif (skb == NULL)\n\t\tgoto drop;\n\n\tif (aarp_send_ddp(rt->dev, skb, &ta, NULL) == NET_XMIT_DROP)\n\t\treturn NET_RX_DROP;\n\treturn NET_XMIT_SUCCESS;\nfree_it:\n\tkfree_skb(skb);\ndrop:\n\treturn NET_RX_DROP;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,5 @@\n-static void atalk_route_packet(struct sk_buff *skb, struct net_device *dev,\n-\t\t\t       struct ddpehdr *ddp, __u16 len_hops,\n-\t\t\t       int origlen)\n+static int atalk_route_packet(struct sk_buff *skb, struct net_device *dev,\n+\t\t\t      struct ddpehdr *ddp, __u16 len_hops, int origlen)\n {\n \tstruct atalk_route *rt;\n \tstruct atalk_addr ta;\n@@ -67,8 +66,6 @@\n \t\t/* 22 bytes - 12 ether, 2 len, 3 802.2 5 snap */\n \t\tstruct sk_buff *nskb = skb_realloc_headroom(skb, 32);\n \t\tkfree_skb(skb);\n-\t\tif (!nskb)\n-\t\t\tgoto out;\n \t\tskb = nskb;\n \t} else\n \t\tskb = skb_unshare(skb, GFP_ATOMIC);\n@@ -77,10 +74,14 @@\n \t * If the buffer didn't vanish into the lack of space bitbucket we can\n \t * send it.\n \t */\n-\tif (skb && aarp_send_ddp(rt->dev, skb, &ta, NULL) == -1)\n-\t\tgoto free_it;\n-out:\n-\treturn;\n+\tif (skb == NULL)\n+\t\tgoto drop;\n+\n+\tif (aarp_send_ddp(rt->dev, skb, &ta, NULL) == NET_XMIT_DROP)\n+\t\treturn NET_RX_DROP;\n+\treturn NET_XMIT_SUCCESS;\n free_it:\n \tkfree_skb(skb);\n+drop:\n+\treturn NET_RX_DROP;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static void atalk_route_packet(struct sk_buff *skb, struct net_device *dev,",
                "\t\t\t       struct ddpehdr *ddp, __u16 len_hops,",
                "\t\t\t       int origlen)",
                "\t\tif (!nskb)",
                "\t\t\tgoto out;",
                "\tif (skb && aarp_send_ddp(rt->dev, skb, &ta, NULL) == -1)",
                "\t\tgoto free_it;",
                "out:",
                "\treturn;"
            ],
            "added_lines": [
                "static int atalk_route_packet(struct sk_buff *skb, struct net_device *dev,",
                "\t\t\t      struct ddpehdr *ddp, __u16 len_hops, int origlen)",
                "\tif (skb == NULL)",
                "\t\tgoto drop;",
                "",
                "\tif (aarp_send_ddp(rt->dev, skb, &ta, NULL) == NET_XMIT_DROP)",
                "\t\treturn NET_RX_DROP;",
                "\treturn NET_XMIT_SUCCESS;",
                "drop:",
                "\treturn NET_RX_DROP;"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-2903",
        "func_name": "kernel/git/netdev/net-next/atalk_rcv",
        "description": "Memory leak in the appletalk subsystem in the Linux kernel 2.4.x through 2.4.37.6 and 2.6.x through 2.6.31, when the appletalk and ipddp modules are loaded but the ipddp\"N\" device is not found, allows remote attackers to cause a denial of service (memory consumption) via IP-DDP datagrams.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/davem/net-next.git;a=commit;h=ffcfb8db540ff879c2a85bf7e404954281443414",
        "commit_title": "And also do a better job of returning proper NET_{RX,XMIT}_ values.",
        "commit_text": " Based on a patch and suggestions by Mark Smith.  This fixes CVE-2009-2903  ",
        "func_before": "static int atalk_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t     struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct ddpehdr *ddp;\n\tstruct sock *sock;\n\tstruct atalk_iface *atif;\n\tstruct sockaddr_at tosat;\n\tint origlen;\n\t__u16 len_hops;\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\tgoto drop;\n\n\t/* Don't mangle buffer if shared */\n\tif (!(skb = skb_share_check(skb, GFP_ATOMIC)))\n\t\tgoto out;\n\n\t/* Size check and make sure header is contiguous */\n\tif (!pskb_may_pull(skb, sizeof(*ddp)))\n\t\tgoto drop;\n\n\tddp = ddp_hdr(skb);\n\n\tlen_hops = ntohs(ddp->deh_len_hops);\n\n\t/* Trim buffer in case of stray trailing data */\n\toriglen = skb->len;\n\tskb_trim(skb, min_t(unsigned int, skb->len, len_hops & 1023));\n\n\t/*\n\t * Size check to see if ddp->deh_len was crap\n\t * (Otherwise we'll detonate most spectacularly\n\t * in the middle of atalk_checksum() or recvmsg()).\n\t */\n\tif (skb->len < sizeof(*ddp) || skb->len < (len_hops & 1023)) {\n\t\tpr_debug(\"AppleTalk: dropping corrupted frame (deh_len=%u, \"\n\t\t\t \"skb->len=%u)\\n\", len_hops & 1023, skb->len);\n\t\tgoto drop;\n\t}\n\n\t/*\n\t * Any checksums. Note we don't do htons() on this == is assumed to be\n\t * valid for net byte orders all over the networking code...\n\t */\n\tif (ddp->deh_sum &&\n\t    atalk_checksum(skb, len_hops & 1023) != ddp->deh_sum)\n\t\t/* Not a valid AppleTalk frame - dustbin time */\n\t\tgoto drop;\n\n\t/* Check the packet is aimed at us */\n\tif (!ddp->deh_dnet)\t/* Net 0 is 'this network' */\n\t\tatif = atalk_find_anynet(ddp->deh_dnode, dev);\n\telse\n\t\tatif = atalk_find_interface(ddp->deh_dnet, ddp->deh_dnode);\n\n\tif (!atif) {\n\t\t/* Not ours, so we route the packet via the correct\n\t\t * AppleTalk iface\n\t\t */\n\t\tatalk_route_packet(skb, dev, ddp, len_hops, origlen);\n\t\treturn NET_RX_SUCCESS;\n\t}\n\n\t/* if IP over DDP is not selected this code will be optimized out */\n\tif (is_ip_over_ddp(skb))\n\t\treturn handle_ip_over_ddp(skb);\n\t/*\n\t * Which socket - atalk_search_socket() looks for a *full match*\n\t * of the <net, node, port> tuple.\n\t */\n\ttosat.sat_addr.s_net  = ddp->deh_dnet;\n\ttosat.sat_addr.s_node = ddp->deh_dnode;\n\ttosat.sat_port\t      = ddp->deh_dport;\n\n\tsock = atalk_search_socket(&tosat, atif);\n\tif (!sock) /* But not one of our sockets */\n\t\tgoto drop;\n\n\t/* Queue packet (standard) */\n\tskb->sk = sock;\n\n\tif (sock_queue_rcv_skb(sock, skb) < 0)\n\t\tgoto drop;\n\n\treturn NET_RX_SUCCESS;\n\ndrop:\n\tkfree_skb(skb);\nout:\n\treturn NET_RX_DROP;\n\n}",
        "func": "static int atalk_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t     struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct ddpehdr *ddp;\n\tstruct sock *sock;\n\tstruct atalk_iface *atif;\n\tstruct sockaddr_at tosat;\n\tint origlen;\n\t__u16 len_hops;\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\tgoto drop;\n\n\t/* Don't mangle buffer if shared */\n\tif (!(skb = skb_share_check(skb, GFP_ATOMIC)))\n\t\tgoto out;\n\n\t/* Size check and make sure header is contiguous */\n\tif (!pskb_may_pull(skb, sizeof(*ddp)))\n\t\tgoto drop;\n\n\tddp = ddp_hdr(skb);\n\n\tlen_hops = ntohs(ddp->deh_len_hops);\n\n\t/* Trim buffer in case of stray trailing data */\n\toriglen = skb->len;\n\tskb_trim(skb, min_t(unsigned int, skb->len, len_hops & 1023));\n\n\t/*\n\t * Size check to see if ddp->deh_len was crap\n\t * (Otherwise we'll detonate most spectacularly\n\t * in the middle of atalk_checksum() or recvmsg()).\n\t */\n\tif (skb->len < sizeof(*ddp) || skb->len < (len_hops & 1023)) {\n\t\tpr_debug(\"AppleTalk: dropping corrupted frame (deh_len=%u, \"\n\t\t\t \"skb->len=%u)\\n\", len_hops & 1023, skb->len);\n\t\tgoto drop;\n\t}\n\n\t/*\n\t * Any checksums. Note we don't do htons() on this == is assumed to be\n\t * valid for net byte orders all over the networking code...\n\t */\n\tif (ddp->deh_sum &&\n\t    atalk_checksum(skb, len_hops & 1023) != ddp->deh_sum)\n\t\t/* Not a valid AppleTalk frame - dustbin time */\n\t\tgoto drop;\n\n\t/* Check the packet is aimed at us */\n\tif (!ddp->deh_dnet)\t/* Net 0 is 'this network' */\n\t\tatif = atalk_find_anynet(ddp->deh_dnode, dev);\n\telse\n\t\tatif = atalk_find_interface(ddp->deh_dnet, ddp->deh_dnode);\n\n\tif (!atif) {\n\t\t/* Not ours, so we route the packet via the correct\n\t\t * AppleTalk iface\n\t\t */\n\t\treturn atalk_route_packet(skb, dev, ddp, len_hops, origlen);\n\t}\n\n\t/* if IP over DDP is not selected this code will be optimized out */\n\tif (is_ip_over_ddp(skb))\n\t\treturn handle_ip_over_ddp(skb);\n\t/*\n\t * Which socket - atalk_search_socket() looks for a *full match*\n\t * of the <net, node, port> tuple.\n\t */\n\ttosat.sat_addr.s_net  = ddp->deh_dnet;\n\ttosat.sat_addr.s_node = ddp->deh_dnode;\n\ttosat.sat_port\t      = ddp->deh_dport;\n\n\tsock = atalk_search_socket(&tosat, atif);\n\tif (!sock) /* But not one of our sockets */\n\t\tgoto drop;\n\n\t/* Queue packet (standard) */\n\tskb->sk = sock;\n\n\tif (sock_queue_rcv_skb(sock, skb) < 0)\n\t\tgoto drop;\n\n\treturn NET_RX_SUCCESS;\n\ndrop:\n\tkfree_skb(skb);\nout:\n\treturn NET_RX_DROP;\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -57,8 +57,7 @@\n \t\t/* Not ours, so we route the packet via the correct\n \t\t * AppleTalk iface\n \t\t */\n-\t\tatalk_route_packet(skb, dev, ddp, len_hops, origlen);\n-\t\treturn NET_RX_SUCCESS;\n+\t\treturn atalk_route_packet(skb, dev, ddp, len_hops, origlen);\n \t}\n \n \t/* if IP over DDP is not selected this code will be optimized out */",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tatalk_route_packet(skb, dev, ddp, len_hops, origlen);",
                "\t\treturn NET_RX_SUCCESS;"
            ],
            "added_lines": [
                "\t\treturn atalk_route_packet(skb, dev, ddp, len_hops, origlen);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-2903",
        "func_name": "kernel/git/netdev/net-next/handle_ip_over_ddp",
        "description": "Memory leak in the appletalk subsystem in the Linux kernel 2.4.x through 2.4.37.6 and 2.6.x through 2.6.31, when the appletalk and ipddp modules are loaded but the ipddp\"N\" device is not found, allows remote attackers to cause a denial of service (memory consumption) via IP-DDP datagrams.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/davem/net-next.git;a=commit;h=ffcfb8db540ff879c2a85bf7e404954281443414",
        "commit_title": "And also do a better job of returning proper NET_{RX,XMIT}_ values.",
        "commit_text": " Based on a patch and suggestions by Mark Smith.  This fixes CVE-2009-2903  ",
        "func_before": "static int handle_ip_over_ddp(struct sk_buff *skb)\n{\n\tstruct net_device *dev = __dev_get_by_name(&init_net, \"ipddp0\");\n\tstruct net_device_stats *stats;\n\n\t/* This needs to be able to handle ipddp\"N\" devices */\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tskb->protocol = htons(ETH_P_IP);\n\tskb_pull(skb, 13);\n\tskb->dev   = dev;\n\tskb_reset_transport_header(skb);\n\n\tstats = netdev_priv(dev);\n\tstats->rx_packets++;\n\tstats->rx_bytes += skb->len + 13;\n\tnetif_rx(skb);  /* Send the SKB up to a higher place. */\n\treturn 0;\n}",
        "func": "static int handle_ip_over_ddp(struct sk_buff *skb)\n{\n\tstruct net_device *dev = __dev_get_by_name(&init_net, \"ipddp0\");\n\tstruct net_device_stats *stats;\n\n\t/* This needs to be able to handle ipddp\"N\" devices */\n\tif (!dev) {\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n\tskb->protocol = htons(ETH_P_IP);\n\tskb_pull(skb, 13);\n\tskb->dev   = dev;\n\tskb_reset_transport_header(skb);\n\n\tstats = netdev_priv(dev);\n\tstats->rx_packets++;\n\tstats->rx_bytes += skb->len + 13;\n\treturn netif_rx(skb);  /* Send the SKB up to a higher place. */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,8 +4,10 @@\n \tstruct net_device_stats *stats;\n \n \t/* This needs to be able to handle ipddp\"N\" devices */\n-\tif (!dev)\n-\t\treturn -ENODEV;\n+\tif (!dev) {\n+\t\tkfree_skb(skb);\n+\t\treturn NET_RX_DROP;\n+\t}\n \n \tskb->protocol = htons(ETH_P_IP);\n \tskb_pull(skb, 13);\n@@ -15,6 +17,5 @@\n \tstats = netdev_priv(dev);\n \tstats->rx_packets++;\n \tstats->rx_bytes += skb->len + 13;\n-\tnetif_rx(skb);  /* Send the SKB up to a higher place. */\n-\treturn 0;\n+\treturn netif_rx(skb);  /* Send the SKB up to a higher place. */\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!dev)",
                "\t\treturn -ENODEV;",
                "\tnetif_rx(skb);  /* Send the SKB up to a higher place. */",
                "\treturn 0;"
            ],
            "added_lines": [
                "\tif (!dev) {",
                "\t\tkfree_skb(skb);",
                "\t\treturn NET_RX_DROP;",
                "\t}",
                "\treturn netif_rx(skb);  /* Send the SKB up to a higher place. */"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-2903",
        "func_name": "kernel/git/netdev/net-next/atalk_sendmsg",
        "description": "Memory leak in the appletalk subsystem in the Linux kernel 2.4.x through 2.4.37.6 and 2.6.x through 2.6.31, when the appletalk and ipddp modules are loaded but the ipddp\"N\" device is not found, allows remote attackers to cause a denial of service (memory consumption) via IP-DDP datagrams.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/davem/net-next.git;a=commit;h=ffcfb8db540ff879c2a85bf7e404954281443414",
        "commit_title": "And also do a better job of returning proper NET_{RX,XMIT}_ values.",
        "commit_text": " Based on a patch and suggestions by Mark Smith.  This fixes CVE-2009-2903  ",
        "func_before": "static int atalk_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n\t\t\t size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\tstruct sockaddr_at *usat = (struct sockaddr_at *)msg->msg_name;\n\tint flags = msg->msg_flags;\n\tint loopback = 0;\n\tstruct sockaddr_at local_satalk, gsat;\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\tstruct ddpehdr *ddp;\n\tint size;\n\tstruct atalk_route *rt;\n\tint err;\n\n\tif (flags & ~(MSG_DONTWAIT|MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tif (len > DDP_MAXSZ)\n\t\treturn -EMSGSIZE;\n\n\tif (usat) {\n\t\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\t\tif (atalk_autobind(sk) < 0)\n\t\t\t\treturn -EBUSY;\n\n\t\tif (msg->msg_namelen < sizeof(*usat) ||\n\t\t    usat->sat_family != AF_APPLETALK)\n\t\t\treturn -EINVAL;\n\n\t\t/* netatalk didn't implement this check */\n\t\tif (usat->sat_addr.s_node == ATADDR_BCAST &&\n\t\t    !sock_flag(sk, SOCK_BROADCAST)) {\n\t\t\treturn -EPERM;\n\t\t}\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tusat = &local_satalk;\n\t\tusat->sat_family      = AF_APPLETALK;\n\t\tusat->sat_port\t      = at->dest_port;\n\t\tusat->sat_addr.s_node = at->dest_node;\n\t\tusat->sat_addr.s_net  = at->dest_net;\n\t}\n\n\t/* Build a packet */\n\tSOCK_DEBUG(sk, \"SK %p: Got address.\\n\", sk);\n\n\t/* For headers */\n\tsize = sizeof(struct ddpehdr) + len + ddp_dl->header_length;\n\n\tif (usat->sat_addr.s_net || usat->sat_addr.s_node == ATADDR_ANYNODE) {\n\t\trt = atrtr_find(&usat->sat_addr);\n\t} else {\n\t\tstruct atalk_addr at_hint;\n\n\t\tat_hint.s_node = 0;\n\t\tat_hint.s_net  = at->src_net;\n\n\t\trt = atrtr_find(&at_hint);\n\t}\n\tif (!rt)\n\t\treturn -ENETUNREACH;\n\n\tdev = rt->dev;\n\n\tSOCK_DEBUG(sk, \"SK %p: Size needed %d, device %s\\n\",\n\t\t\tsk, size, dev->name);\n\n\tsize += dev->hard_header_len;\n\tskb = sock_alloc_send_skb(sk, size, (flags & MSG_DONTWAIT), &err);\n\tif (!skb)\n\t\treturn err;\n\n\tskb->sk = sk;\n\tskb_reserve(skb, ddp_dl->header_length);\n\tskb_reserve(skb, dev->hard_header_len);\n\tskb->dev = dev;\n\n\tSOCK_DEBUG(sk, \"SK %p: Begin build.\\n\", sk);\n\n\tddp = (struct ddpehdr *)skb_put(skb, sizeof(struct ddpehdr));\n\tddp->deh_len_hops  = htons(len + sizeof(*ddp));\n\tddp->deh_dnet  = usat->sat_addr.s_net;\n\tddp->deh_snet  = at->src_net;\n\tddp->deh_dnode = usat->sat_addr.s_node;\n\tddp->deh_snode = at->src_node;\n\tddp->deh_dport = usat->sat_port;\n\tddp->deh_sport = at->src_port;\n\n\tSOCK_DEBUG(sk, \"SK %p: Copy user data (%Zd bytes).\\n\", sk, len);\n\n\terr = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\n\tif (sk->sk_no_check == 1)\n\t\tddp->deh_sum = 0;\n\telse\n\t\tddp->deh_sum = atalk_checksum(skb, len + sizeof(*ddp));\n\n\t/*\n\t * Loopback broadcast packets to non gateway targets (ie routes\n\t * to group we are in)\n\t */\n\tif (ddp->deh_dnode == ATADDR_BCAST &&\n\t    !(rt->flags & RTF_GATEWAY) && !(dev->flags & IFF_LOOPBACK)) {\n\t\tstruct sk_buff *skb2 = skb_copy(skb, GFP_KERNEL);\n\n\t\tif (skb2) {\n\t\t\tloopback = 1;\n\t\t\tSOCK_DEBUG(sk, \"SK %p: send out(copy).\\n\", sk);\n\t\t\tif (aarp_send_ddp(dev, skb2,\n\t\t\t\t\t  &usat->sat_addr, NULL) == -1)\n\t\t\t\tkfree_skb(skb2);\n\t\t\t\t/* else queued/sent above in the aarp queue */\n\t\t}\n\t}\n\n\tif (dev->flags & IFF_LOOPBACK || loopback) {\n\t\tSOCK_DEBUG(sk, \"SK %p: Loop back.\\n\", sk);\n\t\t/* loop back */\n\t\tskb_orphan(skb);\n\t\tif (ddp->deh_dnode == ATADDR_BCAST) {\n\t\t\tstruct atalk_addr at_lo;\n\n\t\t\tat_lo.s_node = 0;\n\t\t\tat_lo.s_net  = 0;\n\n\t\t\trt = atrtr_find(&at_lo);\n\t\t\tif (!rt) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn -ENETUNREACH;\n\t\t\t}\n\t\t\tdev = rt->dev;\n\t\t\tskb->dev = dev;\n\t\t}\n\t\tddp_dl->request(ddp_dl, skb, dev->dev_addr);\n\t} else {\n\t\tSOCK_DEBUG(sk, \"SK %p: send out.\\n\", sk);\n\t\tif (rt->flags & RTF_GATEWAY) {\n\t\t    gsat.sat_addr = rt->gateway;\n\t\t    usat = &gsat;\n\t\t}\n\n\t\tif (aarp_send_ddp(dev, skb, &usat->sat_addr, NULL) == -1)\n\t\t\tkfree_skb(skb);\n\t\t/* else queued/sent above in the aarp queue */\n\t}\n\tSOCK_DEBUG(sk, \"SK %p: Done write (%Zd).\\n\", sk, len);\n\n\treturn len;\n}",
        "func": "static int atalk_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n\t\t\t size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atalk_sock *at = at_sk(sk);\n\tstruct sockaddr_at *usat = (struct sockaddr_at *)msg->msg_name;\n\tint flags = msg->msg_flags;\n\tint loopback = 0;\n\tstruct sockaddr_at local_satalk, gsat;\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\tstruct ddpehdr *ddp;\n\tint size;\n\tstruct atalk_route *rt;\n\tint err;\n\n\tif (flags & ~(MSG_DONTWAIT|MSG_CMSG_COMPAT))\n\t\treturn -EINVAL;\n\n\tif (len > DDP_MAXSZ)\n\t\treturn -EMSGSIZE;\n\n\tif (usat) {\n\t\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\t\tif (atalk_autobind(sk) < 0)\n\t\t\t\treturn -EBUSY;\n\n\t\tif (msg->msg_namelen < sizeof(*usat) ||\n\t\t    usat->sat_family != AF_APPLETALK)\n\t\t\treturn -EINVAL;\n\n\t\t/* netatalk didn't implement this check */\n\t\tif (usat->sat_addr.s_node == ATADDR_BCAST &&\n\t\t    !sock_flag(sk, SOCK_BROADCAST)) {\n\t\t\treturn -EPERM;\n\t\t}\n\t} else {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tusat = &local_satalk;\n\t\tusat->sat_family      = AF_APPLETALK;\n\t\tusat->sat_port\t      = at->dest_port;\n\t\tusat->sat_addr.s_node = at->dest_node;\n\t\tusat->sat_addr.s_net  = at->dest_net;\n\t}\n\n\t/* Build a packet */\n\tSOCK_DEBUG(sk, \"SK %p: Got address.\\n\", sk);\n\n\t/* For headers */\n\tsize = sizeof(struct ddpehdr) + len + ddp_dl->header_length;\n\n\tif (usat->sat_addr.s_net || usat->sat_addr.s_node == ATADDR_ANYNODE) {\n\t\trt = atrtr_find(&usat->sat_addr);\n\t} else {\n\t\tstruct atalk_addr at_hint;\n\n\t\tat_hint.s_node = 0;\n\t\tat_hint.s_net  = at->src_net;\n\n\t\trt = atrtr_find(&at_hint);\n\t}\n\tif (!rt)\n\t\treturn -ENETUNREACH;\n\n\tdev = rt->dev;\n\n\tSOCK_DEBUG(sk, \"SK %p: Size needed %d, device %s\\n\",\n\t\t\tsk, size, dev->name);\n\n\tsize += dev->hard_header_len;\n\tskb = sock_alloc_send_skb(sk, size, (flags & MSG_DONTWAIT), &err);\n\tif (!skb)\n\t\treturn err;\n\n\tskb->sk = sk;\n\tskb_reserve(skb, ddp_dl->header_length);\n\tskb_reserve(skb, dev->hard_header_len);\n\tskb->dev = dev;\n\n\tSOCK_DEBUG(sk, \"SK %p: Begin build.\\n\", sk);\n\n\tddp = (struct ddpehdr *)skb_put(skb, sizeof(struct ddpehdr));\n\tddp->deh_len_hops  = htons(len + sizeof(*ddp));\n\tddp->deh_dnet  = usat->sat_addr.s_net;\n\tddp->deh_snet  = at->src_net;\n\tddp->deh_dnode = usat->sat_addr.s_node;\n\tddp->deh_snode = at->src_node;\n\tddp->deh_dport = usat->sat_port;\n\tddp->deh_sport = at->src_port;\n\n\tSOCK_DEBUG(sk, \"SK %p: Copy user data (%Zd bytes).\\n\", sk, len);\n\n\terr = memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\n\tif (sk->sk_no_check == 1)\n\t\tddp->deh_sum = 0;\n\telse\n\t\tddp->deh_sum = atalk_checksum(skb, len + sizeof(*ddp));\n\n\t/*\n\t * Loopback broadcast packets to non gateway targets (ie routes\n\t * to group we are in)\n\t */\n\tif (ddp->deh_dnode == ATADDR_BCAST &&\n\t    !(rt->flags & RTF_GATEWAY) && !(dev->flags & IFF_LOOPBACK)) {\n\t\tstruct sk_buff *skb2 = skb_copy(skb, GFP_KERNEL);\n\n\t\tif (skb2) {\n\t\t\tloopback = 1;\n\t\t\tSOCK_DEBUG(sk, \"SK %p: send out(copy).\\n\", sk);\n\t\t\t/*\n\t\t\t * If it fails it is queued/sent above in the aarp queue\n\t\t\t */\n\t\t\taarp_send_ddp(dev, skb2, &usat->sat_addr, NULL);\n\t\t}\n\t}\n\n\tif (dev->flags & IFF_LOOPBACK || loopback) {\n\t\tSOCK_DEBUG(sk, \"SK %p: Loop back.\\n\", sk);\n\t\t/* loop back */\n\t\tskb_orphan(skb);\n\t\tif (ddp->deh_dnode == ATADDR_BCAST) {\n\t\t\tstruct atalk_addr at_lo;\n\n\t\t\tat_lo.s_node = 0;\n\t\t\tat_lo.s_net  = 0;\n\n\t\t\trt = atrtr_find(&at_lo);\n\t\t\tif (!rt) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn -ENETUNREACH;\n\t\t\t}\n\t\t\tdev = rt->dev;\n\t\t\tskb->dev = dev;\n\t\t}\n\t\tddp_dl->request(ddp_dl, skb, dev->dev_addr);\n\t} else {\n\t\tSOCK_DEBUG(sk, \"SK %p: send out.\\n\", sk);\n\t\tif (rt->flags & RTF_GATEWAY) {\n\t\t    gsat.sat_addr = rt->gateway;\n\t\t    usat = &gsat;\n\t\t}\n\n\t\t/*\n\t\t * If it fails it is queued/sent above in the aarp queue\n\t\t */\n\t\taarp_send_ddp(dev, skb, &usat->sat_addr, NULL);\n\t}\n\tSOCK_DEBUG(sk, \"SK %p: Done write (%Zd).\\n\", sk, len);\n\n\treturn len;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -113,10 +113,10 @@\n \t\tif (skb2) {\n \t\t\tloopback = 1;\n \t\t\tSOCK_DEBUG(sk, \"SK %p: send out(copy).\\n\", sk);\n-\t\t\tif (aarp_send_ddp(dev, skb2,\n-\t\t\t\t\t  &usat->sat_addr, NULL) == -1)\n-\t\t\t\tkfree_skb(skb2);\n-\t\t\t\t/* else queued/sent above in the aarp queue */\n+\t\t\t/*\n+\t\t\t * If it fails it is queued/sent above in the aarp queue\n+\t\t\t */\n+\t\t\taarp_send_ddp(dev, skb2, &usat->sat_addr, NULL);\n \t\t}\n \t}\n \n@@ -146,9 +146,10 @@\n \t\t    usat = &gsat;\n \t\t}\n \n-\t\tif (aarp_send_ddp(dev, skb, &usat->sat_addr, NULL) == -1)\n-\t\t\tkfree_skb(skb);\n-\t\t/* else queued/sent above in the aarp queue */\n+\t\t/*\n+\t\t * If it fails it is queued/sent above in the aarp queue\n+\t\t */\n+\t\taarp_send_ddp(dev, skb, &usat->sat_addr, NULL);\n \t}\n \tSOCK_DEBUG(sk, \"SK %p: Done write (%Zd).\\n\", sk, len);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tif (aarp_send_ddp(dev, skb2,",
                "\t\t\t\t\t  &usat->sat_addr, NULL) == -1)",
                "\t\t\t\tkfree_skb(skb2);",
                "\t\t\t\t/* else queued/sent above in the aarp queue */",
                "\t\tif (aarp_send_ddp(dev, skb, &usat->sat_addr, NULL) == -1)",
                "\t\t\tkfree_skb(skb);",
                "\t\t/* else queued/sent above in the aarp queue */"
            ],
            "added_lines": [
                "\t\t\t/*",
                "\t\t\t * If it fails it is queued/sent above in the aarp queue",
                "\t\t\t */",
                "\t\t\taarp_send_ddp(dev, skb2, &usat->sat_addr, NULL);",
                "\t\t/*",
                "\t\t * If it fails it is queued/sent above in the aarp queue",
                "\t\t */",
                "\t\taarp_send_ddp(dev, skb, &usat->sat_addr, NULL);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-2903",
        "func_name": "kernel/git/netdev/net-next/aarp_send_ddp",
        "description": "Memory leak in the appletalk subsystem in the Linux kernel 2.4.x through 2.4.37.6 and 2.6.x through 2.6.31, when the appletalk and ipddp modules are loaded but the ipddp\"N\" device is not found, allows remote attackers to cause a denial of service (memory consumption) via IP-DDP datagrams.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/davem/net-next.git;a=commit;h=ffcfb8db540ff879c2a85bf7e404954281443414",
        "commit_title": "And also do a better job of returning proper NET_{RX,XMIT}_ values.",
        "commit_text": " Based on a patch and suggestions by Mark Smith.  This fixes CVE-2009-2903  ",
        "func_before": "int aarp_send_ddp(struct net_device *dev, struct sk_buff *skb,\n\t\t  struct atalk_addr *sa, void *hwaddr)\n{\n\tstatic char ddp_eth_multicast[ETH_ALEN] =\n\t\t{ 0x09, 0x00, 0x07, 0xFF, 0xFF, 0xFF };\n\tint hash;\n\tstruct aarp_entry *a;\n\n\tskb_reset_network_header(skb);\n\n\t/* Check for LocalTalk first */\n\tif (dev->type == ARPHRD_LOCALTLK) {\n\t\tstruct atalk_addr *at = atalk_find_dev_addr(dev);\n\t\tstruct ddpehdr *ddp = (struct ddpehdr *)skb->data;\n\t\tint ft = 2;\n\n\t\t/*\n\t\t * Compressible ?\n\t\t *\n\t\t * IFF: src_net == dest_net == device_net\n\t\t * (zero matches anything)\n\t\t */\n\n\t\tif ((!ddp->deh_snet || at->s_net == ddp->deh_snet) &&\n\t\t    (!ddp->deh_dnet || at->s_net == ddp->deh_dnet)) {\n\t\t\tskb_pull(skb, sizeof(*ddp) - 4);\n\n\t\t\t/*\n\t\t\t *\tThe upper two remaining bytes are the port\n\t\t\t *\tnumbers\twe just happen to need. Now put the\n\t\t\t *\tlength in the lower two.\n\t\t\t */\n\t\t\t*((__be16 *)skb->data) = htons(skb->len);\n\t\t\tft = 1;\n\t\t}\n\t\t/*\n\t\t * Nice and easy. No AARP type protocols occur here so we can\n\t\t * just shovel it out with a 3 byte LLAP header\n\t\t */\n\n\t\tskb_push(skb, 3);\n\t\tskb->data[0] = sa->s_node;\n\t\tskb->data[1] = at->s_node;\n\t\tskb->data[2] = ft;\n\t\tskb->dev     = dev;\n\t\tgoto sendit;\n\t}\n\n\t/* On a PPP link we neither compress nor aarp.  */\n\tif (dev->type == ARPHRD_PPP) {\n\t\tskb->protocol = htons(ETH_P_PPPTALK);\n\t\tskb->dev = dev;\n\t\tgoto sendit;\n\t}\n\n\t/* Non ELAP we cannot do. */\n\tif (dev->type != ARPHRD_ETHER)\n\t\treturn -1;\n\n\tskb->dev = dev;\n\tskb->protocol = htons(ETH_P_ATALK);\n\thash = sa->s_node % (AARP_HASH_SIZE - 1);\n\n\t/* Do we have a resolved entry? */\n\tif (sa->s_node == ATADDR_BCAST) {\n\t\t/* Send it */\n\t\tddp_dl->request(ddp_dl, skb, ddp_eth_multicast);\n\t\tgoto sent;\n\t}\n\n\twrite_lock_bh(&aarp_lock);\n\ta = __aarp_find_entry(resolved[hash], dev, sa);\n\n\tif (a) { /* Return 1 and fill in the address */\n\t\ta->expires_at = jiffies + (sysctl_aarp_expiry_time * 10);\n\t\tddp_dl->request(ddp_dl, skb, a->hwaddr);\n\t\twrite_unlock_bh(&aarp_lock);\n\t\tgoto sent;\n\t}\n\n\t/* Do we have an unresolved entry: This is the less common path */\n\ta = __aarp_find_entry(unresolved[hash], dev, sa);\n\tif (a) { /* Queue onto the unresolved queue */\n\t\tskb_queue_tail(&a->packet_queue, skb);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Allocate a new entry */\n\ta = aarp_alloc();\n\tif (!a) {\n\t\t/* Whoops slipped... good job it's an unreliable protocol 8) */\n\t\twrite_unlock_bh(&aarp_lock);\n\t\treturn -1;\n\t}\n\n\t/* Set up the queue */\n\tskb_queue_tail(&a->packet_queue, skb);\n\ta->expires_at\t = jiffies + sysctl_aarp_resolve_time;\n\ta->dev\t\t = dev;\n\ta->next\t\t = unresolved[hash];\n\ta->target_addr\t = *sa;\n\ta->xmit_count\t = 0;\n\tunresolved[hash] = a;\n\tunresolved_count++;\n\n\t/* Send an initial request for the address */\n\t__aarp_send_query(a);\n\n\t/*\n\t * Switch to fast timer if needed (That is if this is the first\n\t * unresolved entry to get added)\n\t */\n\n\tif (unresolved_count == 1)\n\t\tmod_timer(&aarp_timer, jiffies + sysctl_aarp_tick_time);\n\n\t/* Now finally, it is safe to drop the lock. */\nout_unlock:\n\twrite_unlock_bh(&aarp_lock);\n\n\t/* Tell the ddp layer we have taken over for this frame. */\n\treturn 0;\n\nsendit:\n\tif (skb->sk)\n\t\tskb->priority = skb->sk->sk_priority;\n\tdev_queue_xmit(skb);\nsent:\n\treturn 1;\n}",
        "func": "int aarp_send_ddp(struct net_device *dev, struct sk_buff *skb,\n\t\t  struct atalk_addr *sa, void *hwaddr)\n{\n\tstatic char ddp_eth_multicast[ETH_ALEN] =\n\t\t{ 0x09, 0x00, 0x07, 0xFF, 0xFF, 0xFF };\n\tint hash;\n\tstruct aarp_entry *a;\n\n\tskb_reset_network_header(skb);\n\n\t/* Check for LocalTalk first */\n\tif (dev->type == ARPHRD_LOCALTLK) {\n\t\tstruct atalk_addr *at = atalk_find_dev_addr(dev);\n\t\tstruct ddpehdr *ddp = (struct ddpehdr *)skb->data;\n\t\tint ft = 2;\n\n\t\t/*\n\t\t * Compressible ?\n\t\t *\n\t\t * IFF: src_net == dest_net == device_net\n\t\t * (zero matches anything)\n\t\t */\n\n\t\tif ((!ddp->deh_snet || at->s_net == ddp->deh_snet) &&\n\t\t    (!ddp->deh_dnet || at->s_net == ddp->deh_dnet)) {\n\t\t\tskb_pull(skb, sizeof(*ddp) - 4);\n\n\t\t\t/*\n\t\t\t *\tThe upper two remaining bytes are the port\n\t\t\t *\tnumbers\twe just happen to need. Now put the\n\t\t\t *\tlength in the lower two.\n\t\t\t */\n\t\t\t*((__be16 *)skb->data) = htons(skb->len);\n\t\t\tft = 1;\n\t\t}\n\t\t/*\n\t\t * Nice and easy. No AARP type protocols occur here so we can\n\t\t * just shovel it out with a 3 byte LLAP header\n\t\t */\n\n\t\tskb_push(skb, 3);\n\t\tskb->data[0] = sa->s_node;\n\t\tskb->data[1] = at->s_node;\n\t\tskb->data[2] = ft;\n\t\tskb->dev     = dev;\n\t\tgoto sendit;\n\t}\n\n\t/* On a PPP link we neither compress nor aarp.  */\n\tif (dev->type == ARPHRD_PPP) {\n\t\tskb->protocol = htons(ETH_P_PPPTALK);\n\t\tskb->dev = dev;\n\t\tgoto sendit;\n\t}\n\n\t/* Non ELAP we cannot do. */\n\tif (dev->type != ARPHRD_ETHER)\n\t\tgoto free_it;\n\n\tskb->dev = dev;\n\tskb->protocol = htons(ETH_P_ATALK);\n\thash = sa->s_node % (AARP_HASH_SIZE - 1);\n\n\t/* Do we have a resolved entry? */\n\tif (sa->s_node == ATADDR_BCAST) {\n\t\t/* Send it */\n\t\tddp_dl->request(ddp_dl, skb, ddp_eth_multicast);\n\t\tgoto sent;\n\t}\n\n\twrite_lock_bh(&aarp_lock);\n\ta = __aarp_find_entry(resolved[hash], dev, sa);\n\n\tif (a) { /* Return 1 and fill in the address */\n\t\ta->expires_at = jiffies + (sysctl_aarp_expiry_time * 10);\n\t\tddp_dl->request(ddp_dl, skb, a->hwaddr);\n\t\twrite_unlock_bh(&aarp_lock);\n\t\tgoto sent;\n\t}\n\n\t/* Do we have an unresolved entry: This is the less common path */\n\ta = __aarp_find_entry(unresolved[hash], dev, sa);\n\tif (a) { /* Queue onto the unresolved queue */\n\t\tskb_queue_tail(&a->packet_queue, skb);\n\t\tgoto out_unlock;\n\t}\n\n\t/* Allocate a new entry */\n\ta = aarp_alloc();\n\tif (!a) {\n\t\t/* Whoops slipped... good job it's an unreliable protocol 8) */\n\t\twrite_unlock_bh(&aarp_lock);\n\t\tgoto free_it;\n\t}\n\n\t/* Set up the queue */\n\tskb_queue_tail(&a->packet_queue, skb);\n\ta->expires_at\t = jiffies + sysctl_aarp_resolve_time;\n\ta->dev\t\t = dev;\n\ta->next\t\t = unresolved[hash];\n\ta->target_addr\t = *sa;\n\ta->xmit_count\t = 0;\n\tunresolved[hash] = a;\n\tunresolved_count++;\n\n\t/* Send an initial request for the address */\n\t__aarp_send_query(a);\n\n\t/*\n\t * Switch to fast timer if needed (That is if this is the first\n\t * unresolved entry to get added)\n\t */\n\n\tif (unresolved_count == 1)\n\t\tmod_timer(&aarp_timer, jiffies + sysctl_aarp_tick_time);\n\n\t/* Now finally, it is safe to drop the lock. */\nout_unlock:\n\twrite_unlock_bh(&aarp_lock);\n\n\t/* Tell the ddp layer we have taken over for this frame. */\n\tgoto sent;\n\nsendit:\n\tif (skb->sk)\n\t\tskb->priority = skb->sk->sk_priority;\n\tif (dev_queue_xmit(skb))\n\t\tgoto drop;\nsent:\n\treturn NET_XMIT_SUCCESS;\nfree_it:\n\tkfree_skb(skb);\ndrop:\n\treturn NET_XMIT_DROP;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -55,7 +55,7 @@\n \n \t/* Non ELAP we cannot do. */\n \tif (dev->type != ARPHRD_ETHER)\n-\t\treturn -1;\n+\t\tgoto free_it;\n \n \tskb->dev = dev;\n \tskb->protocol = htons(ETH_P_ATALK);\n@@ -90,7 +90,7 @@\n \tif (!a) {\n \t\t/* Whoops slipped... good job it's an unreliable protocol 8) */\n \t\twrite_unlock_bh(&aarp_lock);\n-\t\treturn -1;\n+\t\tgoto free_it;\n \t}\n \n \t/* Set up the queue */\n@@ -119,12 +119,17 @@\n \twrite_unlock_bh(&aarp_lock);\n \n \t/* Tell the ddp layer we have taken over for this frame. */\n-\treturn 0;\n+\tgoto sent;\n \n sendit:\n \tif (skb->sk)\n \t\tskb->priority = skb->sk->sk_priority;\n-\tdev_queue_xmit(skb);\n+\tif (dev_queue_xmit(skb))\n+\t\tgoto drop;\n sent:\n-\treturn 1;\n+\treturn NET_XMIT_SUCCESS;\n+free_it:\n+\tkfree_skb(skb);\n+drop:\n+\treturn NET_XMIT_DROP;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treturn -1;",
                "\t\treturn -1;",
                "\treturn 0;",
                "\tdev_queue_xmit(skb);",
                "\treturn 1;"
            ],
            "added_lines": [
                "\t\tgoto free_it;",
                "\t\tgoto free_it;",
                "\tgoto sent;",
                "\tif (dev_queue_xmit(skb))",
                "\t\tgoto drop;",
                "\treturn NET_XMIT_SUCCESS;",
                "free_it:",
                "\tkfree_skb(skb);",
                "drop:",
                "\treturn NET_XMIT_DROP;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-45887",
        "func_name": "torvalds/linux/ttusb_dec_exit_dvb",
        "description": "An issue was discovered in the Linux kernel through 6.0.9. drivers/media/usb/ttusb-dec/ttusb_dec.c has a memory leak because of the lack of a dvb_frontend_detach call.",
        "git_url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=517a281338322ff8293f988771c98aaa7205e457",
        "commit_title": "Since dvb_frontend_detach() is not called in ttusb_dec_exit_dvb(),",
        "commit_text": "which is called when the device is disconnected, dvb_frontend_free() is not finally called.  This causes a memory leak just by repeatedly plugging and unplugging the device.  Fix this issue by adding dvb_frontend_detach() to ttusb_dec_exit_dvb().  Link: https://lore.kernel.org/linux-media/20221117045925.14297-5-imv4bel@gmail.com ",
        "func_before": "static void ttusb_dec_exit_dvb(struct ttusb_dec *dec)\n{\n\tdprintk(\"%s\\n\", __func__);\n\n\tdvb_net_release(&dec->dvb_net);\n\tdec->demux.dmx.close(&dec->demux.dmx);\n\tdec->demux.dmx.remove_frontend(&dec->demux.dmx, &dec->frontend);\n\tdvb_dmxdev_release(&dec->dmxdev);\n\tdvb_dmx_release(&dec->demux);\n\tif (dec->fe) {\n\t\tdvb_unregister_frontend(dec->fe);\n\t\tif (dec->fe->ops.release)\n\t\t\tdec->fe->ops.release(dec->fe);\n\t}\n\tdvb_unregister_adapter(&dec->adapter);\n}",
        "func": "static void ttusb_dec_exit_dvb(struct ttusb_dec *dec)\n{\n\tdprintk(\"%s\\n\", __func__);\n\n\tdvb_net_release(&dec->dvb_net);\n\tdec->demux.dmx.close(&dec->demux.dmx);\n\tdec->demux.dmx.remove_frontend(&dec->demux.dmx, &dec->frontend);\n\tdvb_dmxdev_release(&dec->dmxdev);\n\tdvb_dmx_release(&dec->demux);\n\tif (dec->fe) {\n\t\tdvb_unregister_frontend(dec->fe);\n\t\tdvb_frontend_detach(dec->fe);\n\t}\n\tdvb_unregister_adapter(&dec->adapter);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,8 +9,7 @@\n \tdvb_dmx_release(&dec->demux);\n \tif (dec->fe) {\n \t\tdvb_unregister_frontend(dec->fe);\n-\t\tif (dec->fe->ops.release)\n-\t\t\tdec->fe->ops.release(dec->fe);\n+\t\tdvb_frontend_detach(dec->fe);\n \t}\n \tdvb_unregister_adapter(&dec->adapter);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (dec->fe->ops.release)",
                "\t\t\tdec->fe->ops.release(dec->fe);"
            ],
            "added_lines": [
                "\t\tdvb_frontend_detach(dec->fe);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-8087",
        "func_name": "torvalds/linux/hwsim_new_radio_nl",
        "description": "Memory leak in the hwsim_new_radio_nl function in drivers/net/wireless/mac80211_hwsim.c in the Linux kernel through 4.15.9 allows local users to cause a denial of service (memory consumption) by triggering an out-of-array error case.",
        "git_url": "https://github.com/torvalds/linux/commit/0ddcff49b672239dda94d70d0fcf50317a9f4b51",
        "commit_title": "mac80211_hwsim: fix possible memory leak in hwsim_new_radio_nl()",
        "commit_text": " 'hwname' is malloced in hwsim_new_radio_nl() and should be freed before leaving from the error handling cases, otherwise it will cause memory leak. ",
        "func_before": "static int hwsim_new_radio_nl(struct sk_buff *msg, struct genl_info *info)\n{\n\tstruct hwsim_new_radio_params param = { 0 };\n\tconst char *hwname = NULL;\n\tint ret;\n\n\tparam.reg_strict = info->attrs[HWSIM_ATTR_REG_STRICT_REG];\n\tparam.p2p_device = info->attrs[HWSIM_ATTR_SUPPORT_P2P_DEVICE];\n\tparam.channels = channels;\n\tparam.destroy_on_close =\n\t\tinfo->attrs[HWSIM_ATTR_DESTROY_RADIO_ON_CLOSE];\n\n\tif (info->attrs[HWSIM_ATTR_CHANNELS])\n\t\tparam.channels = nla_get_u32(info->attrs[HWSIM_ATTR_CHANNELS]);\n\n\tif (info->attrs[HWSIM_ATTR_NO_VIF])\n\t\tparam.no_vif = true;\n\n\tif (info->attrs[HWSIM_ATTR_RADIO_NAME]) {\n\t\thwname = kasprintf(GFP_KERNEL, \"%.*s\",\n\t\t\t\t   nla_len(info->attrs[HWSIM_ATTR_RADIO_NAME]),\n\t\t\t\t   (char *)nla_data(info->attrs[HWSIM_ATTR_RADIO_NAME]));\n\t\tif (!hwname)\n\t\t\treturn -ENOMEM;\n\t\tparam.hwname = hwname;\n\t}\n\n\tif (info->attrs[HWSIM_ATTR_USE_CHANCTX])\n\t\tparam.use_chanctx = true;\n\telse\n\t\tparam.use_chanctx = (param.channels > 1);\n\n\tif (info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2])\n\t\tparam.reg_alpha2 =\n\t\t\tnla_data(info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2]);\n\n\tif (info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]) {\n\t\tu32 idx = nla_get_u32(info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]);\n\n\t\tif (idx >= ARRAY_SIZE(hwsim_world_regdom_custom))\n\t\t\treturn -EINVAL;\n\t\tparam.regd = hwsim_world_regdom_custom[idx];\n\t}\n\n\tret = mac80211_hwsim_new_radio(info, &param);\n\tkfree(hwname);\n\treturn ret;\n}",
        "func": "static int hwsim_new_radio_nl(struct sk_buff *msg, struct genl_info *info)\n{\n\tstruct hwsim_new_radio_params param = { 0 };\n\tconst char *hwname = NULL;\n\tint ret;\n\n\tparam.reg_strict = info->attrs[HWSIM_ATTR_REG_STRICT_REG];\n\tparam.p2p_device = info->attrs[HWSIM_ATTR_SUPPORT_P2P_DEVICE];\n\tparam.channels = channels;\n\tparam.destroy_on_close =\n\t\tinfo->attrs[HWSIM_ATTR_DESTROY_RADIO_ON_CLOSE];\n\n\tif (info->attrs[HWSIM_ATTR_CHANNELS])\n\t\tparam.channels = nla_get_u32(info->attrs[HWSIM_ATTR_CHANNELS]);\n\n\tif (info->attrs[HWSIM_ATTR_NO_VIF])\n\t\tparam.no_vif = true;\n\n\tif (info->attrs[HWSIM_ATTR_RADIO_NAME]) {\n\t\thwname = kasprintf(GFP_KERNEL, \"%.*s\",\n\t\t\t\t   nla_len(info->attrs[HWSIM_ATTR_RADIO_NAME]),\n\t\t\t\t   (char *)nla_data(info->attrs[HWSIM_ATTR_RADIO_NAME]));\n\t\tif (!hwname)\n\t\t\treturn -ENOMEM;\n\t\tparam.hwname = hwname;\n\t}\n\n\tif (info->attrs[HWSIM_ATTR_USE_CHANCTX])\n\t\tparam.use_chanctx = true;\n\telse\n\t\tparam.use_chanctx = (param.channels > 1);\n\n\tif (info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2])\n\t\tparam.reg_alpha2 =\n\t\t\tnla_data(info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2]);\n\n\tif (info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]) {\n\t\tu32 idx = nla_get_u32(info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]);\n\n\t\tif (idx >= ARRAY_SIZE(hwsim_world_regdom_custom)) {\n\t\t\tkfree(hwname);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tparam.regd = hwsim_world_regdom_custom[idx];\n\t}\n\n\tret = mac80211_hwsim_new_radio(info, &param);\n\tkfree(hwname);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -37,8 +37,10 @@\n \tif (info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]) {\n \t\tu32 idx = nla_get_u32(info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]);\n \n-\t\tif (idx >= ARRAY_SIZE(hwsim_world_regdom_custom))\n+\t\tif (idx >= ARRAY_SIZE(hwsim_world_regdom_custom)) {\n+\t\t\tkfree(hwname);\n \t\t\treturn -EINVAL;\n+\t\t}\n \t\tparam.regd = hwsim_world_regdom_custom[idx];\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (idx >= ARRAY_SIZE(hwsim_world_regdom_custom))"
            ],
            "added_lines": [
                "\t\tif (idx >= ARRAY_SIZE(hwsim_world_regdom_custom)) {",
                "\t\t\tkfree(hwname);",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-18251",
        "func_name": "ImageMagick/ReadPCDImage",
        "description": "An issue was discovered in ImageMagick 7.0.7. A memory leak vulnerability was found in the function ReadPCDImage in coders/pcd.c, which allow remote attackers to cause a denial of service via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/12a43437fec6f9245327636dc2730863bb9fdd8b",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/809",
        "commit_text": "",
        "func_before": "static Image *ReadPCDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    number_pixels;\n\n  register ssize_t\n    i,\n    y;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *c1,\n    *c2,\n    *yy;\n\n  size_t\n    height,\n    number_images,\n    rotate,\n    scene,\n    width;\n\n  ssize_t\n    count,\n    x;\n\n  unsigned char\n    *chroma1,\n    *chroma2,\n    *header,\n    *luma;\n\n  unsigned int\n    overview;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a PCD file.\n  */\n  header=(unsigned char *) AcquireQuantumMemory(0x800,3UL*sizeof(*header));\n  if (header == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  count=ReadBlob(image,3*0x800,header);\n  overview=LocaleNCompare((char *) header,\"PCD_OPA\",7) == 0;\n  if ((count != (3*0x800)) ||\n      ((LocaleNCompare((char *) header+0x800,\"PCD\",3) != 0) && (overview ==0)))\n    {\n      header=(unsigned char *) RelinquishMagickMemory(header);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  rotate=header[0x0e02] & 0x03;\n  number_images=(header[10] << 8) | header[11];\n  header=(unsigned char *) RelinquishMagickMemory(header);\n  if (number_images > 65535)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Determine resolution by scene specification.\n  */\n  if ((image->columns == 0) || (image->rows == 0))\n    scene=3;\n  else\n    {\n      width=192;\n      height=128;\n      for (scene=1; scene < 6; scene++)\n      {\n        if ((width >= image->columns) && (height >= image->rows))\n          break;\n        width<<=1;\n        height<<=1;\n      }\n    }\n  if (image_info->number_scenes != 0)\n    scene=(size_t) MagickMin(image_info->scene,6);\n  if (overview != 0)\n    scene=1;\n  /*\n    Initialize image structure.\n  */\n  width=192;\n  height=128;\n  for (i=1; i < (ssize_t) MagickMin(scene,3); i++)\n  {\n    width<<=1;\n    height<<=1;\n  }\n  image->columns=width;\n  image->rows=height;\n  image->depth=8;\n  for ( ; i < (ssize_t) scene; i++)\n  {\n    image->columns<<=1;\n    image->rows<<=1;\n  }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Allocate luma and chroma memory.\n  */\n  number_pixels=(MagickSizeType) image->columns*image->rows;\n  if (number_pixels != (size_t) number_pixels)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  chroma1=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*\n    10*sizeof(*chroma1));\n  chroma2=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*\n    10*sizeof(*chroma2));\n  luma=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*\n    10*sizeof(*luma));\n  if ((chroma1 == (unsigned char *) NULL) ||\n      (chroma2 == (unsigned char *) NULL) || (luma == (unsigned char *) NULL))\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  /*\n    Advance to image data.\n  */\n  offset=93;\n  if (overview != 0)\n    offset=2;\n  else\n    if (scene == 2)\n      offset=20;\n    else\n      if (scene <= 1)\n        offset=1;\n  for (i=0; i < (ssize_t) (offset*0x800); i++)\n    (void) ReadBlobByte(image);\n  if (overview != 0)\n    {\n      Image\n        *overview_image;\n\n      MagickProgressMonitor\n        progress_monitor;\n\n      register ssize_t\n        j;\n\n      /*\n        Read thumbnails from overview image.\n      */\n      for (j=1; j <= (ssize_t) number_images; j++)\n      {\n        progress_monitor=SetImageProgressMonitor(image,\n          (MagickProgressMonitor) NULL,image->client_data);\n        (void) FormatLocaleString(image->filename,MagickPathExtent,\n          \"images/img%04ld.pcd\",(long) j);\n        (void) FormatLocaleString(image->magick_filename,MagickPathExtent,\n          \"images/img%04ld.pcd\",(long) j);\n        image->scene=(size_t) j;\n        image->columns=width;\n        image->rows=height;\n        image->depth=8;\n        yy=luma;\n        c1=chroma1;\n        c2=chroma2;\n        for (y=0; y < (ssize_t) height; y+=2)\n        {\n          count=ReadBlob(image,width,yy);\n          yy+=image->columns;\n          count=ReadBlob(image,width,yy);\n          yy+=image->columns;\n          count=ReadBlob(image,width >> 1,c1);\n          c1+=image->columns;\n          count=ReadBlob(image,width >> 1,c2);\n          c2+=image->columns;\n        }\n        Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma1);\n        Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma2);\n        /*\n          Transfer luminance and chrominance channels.\n        */\n        yy=luma;\n        c1=chroma1;\n        c2=chroma2;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum(*yy++),q);\n            SetPixelGreen(image,ScaleCharToQuantum(*c1++),q);\n            SetPixelBlue(image,ScaleCharToQuantum(*c2++),q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n        }\n        image->colorspace=YCCColorspace;\n        if (LocaleCompare(image_info->magick,\"PCDS\") == 0)\n          (void) SetImageColorspace(image,sRGBColorspace,exception);\n        if (j < (ssize_t) number_images)\n          {\n            /*\n              Allocate next image structure.\n            */\n            AcquireNextImage(image_info,image,exception);\n            if (GetNextImageInList(image) == (Image *) NULL)\n              {\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            image=SyncNextImageInList(image);\n          }\n        (void) SetImageProgressMonitor(image,progress_monitor,\n          image->client_data);\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,j-1,number_images);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n      chroma2=(unsigned char *) RelinquishMagickMemory(chroma2);\n      chroma1=(unsigned char *) RelinquishMagickMemory(chroma1);\n      luma=(unsigned char *) RelinquishMagickMemory(luma);\n      image=GetFirstImageInList(image);\n      overview_image=OverviewImage(image_info,image,exception);\n      return(overview_image);\n    }\n  /*\n    Read interleaved image.\n  */\n  yy=luma;\n  c1=chroma1;\n  c2=chroma2;\n  for (y=0; y < (ssize_t) height; y+=2)\n  {\n    count=ReadBlob(image,width,yy);\n    yy+=image->columns;\n    count=ReadBlob(image,width,yy);\n    yy+=image->columns;\n    count=ReadBlob(image,width >> 1,c1);\n    c1+=image->columns;\n    count=ReadBlob(image,width >> 1,c2);\n    c2+=image->columns;\n  }\n  if (scene >= 4)\n    {\n      /*\n        Recover luminance deltas for 1536x1024 image.\n      */\n      Upsample(768,512,image->columns,luma);\n      Upsample(384,256,image->columns,chroma1);\n      Upsample(384,256,image->columns,chroma2);\n      image->rows=1024;\n      for (i=0; i < (4*0x800); i++)\n        (void) ReadBlobByte(image);\n      status=DecodeImage(image,luma,chroma1,chroma2,exception);\n      if ((scene >= 5) && status)\n        {\n          /*\n            Recover luminance deltas for 3072x2048 image.\n          */\n          Upsample(1536,1024,image->columns,luma);\n          Upsample(768,512,image->columns,chroma1);\n          Upsample(768,512,image->columns,chroma2);\n          image->rows=2048;\n          offset=TellBlob(image)/0x800+12;\n          offset=SeekBlob(image,offset*0x800,SEEK_SET);\n          status=DecodeImage(image,luma,chroma1,chroma2,exception);\n          if ((scene >= 6) && (status != MagickFalse))\n            {\n              /*\n                Recover luminance deltas for 6144x4096 image (vaporware).\n              */\n              Upsample(3072,2048,image->columns,luma);\n              Upsample(1536,1024,image->columns,chroma1);\n              Upsample(1536,1024,image->columns,chroma2);\n              image->rows=4096;\n            }\n        }\n    }\n  Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma1);\n  Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma2);\n  /*\n    Transfer luminance and chrominance channels.\n  */\n  yy=luma;\n  c1=chroma1;\n  c2=chroma2;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelRed(image,ScaleCharToQuantum(*yy++),q);\n      SetPixelGreen(image,ScaleCharToQuantum(*c1++),q);\n      SetPixelBlue(image,ScaleCharToQuantum(*c2++),q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  chroma2=(unsigned char *) RelinquishMagickMemory(chroma2);\n  chroma1=(unsigned char *) RelinquishMagickMemory(chroma1);\n  luma=(unsigned char *) RelinquishMagickMemory(luma);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  if (image_info->ping == MagickFalse)\n    if ((rotate == 1) || (rotate == 3))\n      {\n        double\n          degrees;\n\n        Image\n          *rotate_image;\n\n        /*\n          Rotate image.\n        */\n        degrees=rotate == 1 ? -90.0 : 90.0;\n        rotate_image=RotateImage(image,degrees,exception);\n        if (rotate_image != (Image *) NULL)\n          {\n            image=DestroyImage(image);\n            image=rotate_image;\n          }\n      }\n  /*\n    Set CCIR 709 primaries with a D65 white point.\n  */\n  image->chromaticity.red_primary.x=0.6400f;\n  image->chromaticity.red_primary.y=0.3300f;\n  image->chromaticity.green_primary.x=0.3000f;\n  image->chromaticity.green_primary.y=0.6000f;\n  image->chromaticity.blue_primary.x=0.1500f;\n  image->chromaticity.blue_primary.y=0.0600f;\n  image->chromaticity.white_point.x=0.3127f;\n  image->chromaticity.white_point.y=0.3290f;\n  image->gamma=1.000f/2.200f;\n  image->colorspace=YCCColorspace;\n  if (LocaleCompare(image_info->magick,\"PCDS\") == 0)\n    (void) SetImageColorspace(image,sRGBColorspace,exception);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadPCDImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    number_pixels;\n\n  register ssize_t\n    i,\n    y;\n\n  register Quantum\n    *q;\n\n  register unsigned char\n    *c1,\n    *c2,\n    *yy;\n\n  size_t\n    height,\n    number_images,\n    rotate,\n    scene,\n    width;\n\n  ssize_t\n    count,\n    x;\n\n  unsigned char\n    *chroma1,\n    *chroma2,\n    *header,\n    *luma;\n\n  unsigned int\n    overview;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Determine if this a PCD file.\n  */\n  header=(unsigned char *) AcquireQuantumMemory(0x800,3UL*sizeof(*header));\n  if (header == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  count=ReadBlob(image,3*0x800,header);\n  overview=LocaleNCompare((char *) header,\"PCD_OPA\",7) == 0;\n  if ((count != (3*0x800)) ||\n      ((LocaleNCompare((char *) header+0x800,\"PCD\",3) != 0) && (overview ==0)))\n    {\n      header=(unsigned char *) RelinquishMagickMemory(header);\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  rotate=header[0x0e02] & 0x03;\n  number_images=(header[10] << 8) | header[11];\n  header=(unsigned char *) RelinquishMagickMemory(header);\n  if (number_images > 65535)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Determine resolution by scene specification.\n  */\n  if ((image->columns == 0) || (image->rows == 0))\n    scene=3;\n  else\n    {\n      width=192;\n      height=128;\n      for (scene=1; scene < 6; scene++)\n      {\n        if ((width >= image->columns) && (height >= image->rows))\n          break;\n        width<<=1;\n        height<<=1;\n      }\n    }\n  if (image_info->number_scenes != 0)\n    scene=(size_t) MagickMin(image_info->scene,6);\n  if (overview != 0)\n    scene=1;\n  /*\n    Initialize image structure.\n  */\n  width=192;\n  height=128;\n  for (i=1; i < (ssize_t) MagickMin(scene,3); i++)\n  {\n    width<<=1;\n    height<<=1;\n  }\n  image->columns=width;\n  image->rows=height;\n  image->depth=8;\n  for ( ; i < (ssize_t) scene; i++)\n  {\n    image->columns<<=1;\n    image->rows<<=1;\n  }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Allocate luma and chroma memory.\n  */\n  number_pixels=(MagickSizeType) image->columns*image->rows;\n  if (number_pixels != (size_t) number_pixels)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  chroma1=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*\n    10*sizeof(*chroma1));\n  chroma2=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*\n    10*sizeof(*chroma2));\n  luma=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows*\n    10*sizeof(*luma));\n  if ((chroma1 == (unsigned char *) NULL) ||\n      (chroma2 == (unsigned char *) NULL) || (luma == (unsigned char *) NULL))\n    {\n      if (chroma1 != (unsigned char *) NULL)\n        chroma1=(unsigned char *) RelinquishMagickMemory(chroma1);\n      if (chroma2 != (unsigned char *) NULL)\n        chroma2=(unsigned char *) RelinquishMagickMemory(chroma2);\n      if (luma != (unsigned char *) NULL)\n        luma=(unsigned char *) RelinquishMagickMemory(luma);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  /*\n    Advance to image data.\n  */\n  offset=93;\n  if (overview != 0)\n    offset=2;\n  else\n    if (scene == 2)\n      offset=20;\n    else\n      if (scene <= 1)\n        offset=1;\n  for (i=0; i < (ssize_t) (offset*0x800); i++)\n    (void) ReadBlobByte(image);\n  if (overview != 0)\n    {\n      Image\n        *overview_image;\n\n      MagickProgressMonitor\n        progress_monitor;\n\n      register ssize_t\n        j;\n\n      /*\n        Read thumbnails from overview image.\n      */\n      for (j=1; j <= (ssize_t) number_images; j++)\n      {\n        progress_monitor=SetImageProgressMonitor(image,\n          (MagickProgressMonitor) NULL,image->client_data);\n        (void) FormatLocaleString(image->filename,MagickPathExtent,\n          \"images/img%04ld.pcd\",(long) j);\n        (void) FormatLocaleString(image->magick_filename,MagickPathExtent,\n          \"images/img%04ld.pcd\",(long) j);\n        image->scene=(size_t) j;\n        image->columns=width;\n        image->rows=height;\n        image->depth=8;\n        yy=luma;\n        c1=chroma1;\n        c2=chroma2;\n        for (y=0; y < (ssize_t) height; y+=2)\n        {\n          count=ReadBlob(image,width,yy);\n          yy+=image->columns;\n          count=ReadBlob(image,width,yy);\n          yy+=image->columns;\n          count=ReadBlob(image,width >> 1,c1);\n          c1+=image->columns;\n          count=ReadBlob(image,width >> 1,c2);\n          c2+=image->columns;\n        }\n        Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma1);\n        Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma2);\n        /*\n          Transfer luminance and chrominance channels.\n        */\n        yy=luma;\n        c1=chroma1;\n        c2=chroma2;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelRed(image,ScaleCharToQuantum(*yy++),q);\n            SetPixelGreen(image,ScaleCharToQuantum(*c1++),q);\n            SetPixelBlue(image,ScaleCharToQuantum(*c2++),q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n        }\n        image->colorspace=YCCColorspace;\n        if (LocaleCompare(image_info->magick,\"PCDS\") == 0)\n          (void) SetImageColorspace(image,sRGBColorspace,exception);\n        if (j < (ssize_t) number_images)\n          {\n            /*\n              Allocate next image structure.\n            */\n            AcquireNextImage(image_info,image,exception);\n            if (GetNextImageInList(image) == (Image *) NULL)\n              {\n                image=DestroyImageList(image);\n                return((Image *) NULL);\n              }\n            image=SyncNextImageInList(image);\n          }\n        (void) SetImageProgressMonitor(image,progress_monitor,\n          image->client_data);\n        if (image->previous == (Image *) NULL)\n          {\n            status=SetImageProgress(image,LoadImageTag,j-1,number_images);\n            if (status == MagickFalse)\n              break;\n          }\n      }\n      chroma2=(unsigned char *) RelinquishMagickMemory(chroma2);\n      chroma1=(unsigned char *) RelinquishMagickMemory(chroma1);\n      luma=(unsigned char *) RelinquishMagickMemory(luma);\n      image=GetFirstImageInList(image);\n      overview_image=OverviewImage(image_info,image,exception);\n      return(overview_image);\n    }\n  /*\n    Read interleaved image.\n  */\n  yy=luma;\n  c1=chroma1;\n  c2=chroma2;\n  for (y=0; y < (ssize_t) height; y+=2)\n  {\n    count=ReadBlob(image,width,yy);\n    yy+=image->columns;\n    count=ReadBlob(image,width,yy);\n    yy+=image->columns;\n    count=ReadBlob(image,width >> 1,c1);\n    c1+=image->columns;\n    count=ReadBlob(image,width >> 1,c2);\n    c2+=image->columns;\n  }\n  if (scene >= 4)\n    {\n      /*\n        Recover luminance deltas for 1536x1024 image.\n      */\n      Upsample(768,512,image->columns,luma);\n      Upsample(384,256,image->columns,chroma1);\n      Upsample(384,256,image->columns,chroma2);\n      image->rows=1024;\n      for (i=0; i < (4*0x800); i++)\n        (void) ReadBlobByte(image);\n      status=DecodeImage(image,luma,chroma1,chroma2,exception);\n      if ((scene >= 5) && status)\n        {\n          /*\n            Recover luminance deltas for 3072x2048 image.\n          */\n          Upsample(1536,1024,image->columns,luma);\n          Upsample(768,512,image->columns,chroma1);\n          Upsample(768,512,image->columns,chroma2);\n          image->rows=2048;\n          offset=TellBlob(image)/0x800+12;\n          offset=SeekBlob(image,offset*0x800,SEEK_SET);\n          status=DecodeImage(image,luma,chroma1,chroma2,exception);\n          if ((scene >= 6) && (status != MagickFalse))\n            {\n              /*\n                Recover luminance deltas for 6144x4096 image (vaporware).\n              */\n              Upsample(3072,2048,image->columns,luma);\n              Upsample(1536,1024,image->columns,chroma1);\n              Upsample(1536,1024,image->columns,chroma2);\n              image->rows=4096;\n            }\n        }\n    }\n  Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma1);\n  Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma2);\n  /*\n    Transfer luminance and chrominance channels.\n  */\n  yy=luma;\n  c1=chroma1;\n  c2=chroma2;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      SetPixelRed(image,ScaleCharToQuantum(*yy++),q);\n      SetPixelGreen(image,ScaleCharToQuantum(*c1++),q);\n      SetPixelBlue(image,ScaleCharToQuantum(*c2++),q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  chroma2=(unsigned char *) RelinquishMagickMemory(chroma2);\n  chroma1=(unsigned char *) RelinquishMagickMemory(chroma1);\n  luma=(unsigned char *) RelinquishMagickMemory(luma);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  if (image_info->ping == MagickFalse)\n    if ((rotate == 1) || (rotate == 3))\n      {\n        double\n          degrees;\n\n        Image\n          *rotate_image;\n\n        /*\n          Rotate image.\n        */\n        degrees=rotate == 1 ? -90.0 : 90.0;\n        rotate_image=RotateImage(image,degrees,exception);\n        if (rotate_image != (Image *) NULL)\n          {\n            image=DestroyImage(image);\n            image=rotate_image;\n          }\n      }\n  /*\n    Set CCIR 709 primaries with a D65 white point.\n  */\n  image->chromaticity.red_primary.x=0.6400f;\n  image->chromaticity.red_primary.y=0.3300f;\n  image->chromaticity.green_primary.x=0.3000f;\n  image->chromaticity.green_primary.y=0.6000f;\n  image->chromaticity.blue_primary.x=0.1500f;\n  image->chromaticity.blue_primary.y=0.0600f;\n  image->chromaticity.white_point.x=0.3127f;\n  image->chromaticity.white_point.y=0.3290f;\n  image->gamma=1.000f/2.200f;\n  image->colorspace=YCCColorspace;\n  if (LocaleCompare(image_info->magick,\"PCDS\") == 0)\n    (void) SetImageColorspace(image,sRGBColorspace,exception);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -136,7 +136,15 @@\n     10*sizeof(*luma));\n   if ((chroma1 == (unsigned char *) NULL) ||\n       (chroma2 == (unsigned char *) NULL) || (luma == (unsigned char *) NULL))\n-    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+    {\n+      if (chroma1 != (unsigned char *) NULL)\n+        chroma1=(unsigned char *) RelinquishMagickMemory(chroma1);\n+      if (chroma2 != (unsigned char *) NULL)\n+        chroma2=(unsigned char *) RelinquishMagickMemory(chroma2);\n+      if (luma != (unsigned char *) NULL)\n+        luma=(unsigned char *) RelinquishMagickMemory(luma);\n+      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+    }\n   /*\n     Advance to image data.\n   */",
        "diff_line_info": {
            "deleted_lines": [
                "    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");"
            ],
            "added_lines": [
                "    {",
                "      if (chroma1 != (unsigned char *) NULL)",
                "        chroma1=(unsigned char *) RelinquishMagickMemory(chroma1);",
                "      if (chroma2 != (unsigned char *) NULL)",
                "        chroma2=(unsigned char *) RelinquishMagickMemory(chroma2);",
                "      if (luma != (unsigned char *) NULL)",
                "        luma=(unsigned char *) RelinquishMagickMemory(luma);",
                "      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-18254",
        "func_name": "ImageMagick/WriteGIFImage",
        "description": "An issue was discovered in ImageMagick 7.0.7. A memory leak vulnerability was found in the function WriteGIFImage in coders/gif.c, which allow remote attackers to cause a denial of service via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/24d5699753170c141b46816284430516c2d48fed",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/808",
        "commit_text": "",
        "func_before": "static MagickBooleanType WriteGIFImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  int\n    c;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  RectangleInfo\n    page;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bits_per_pixel,\n    delay,\n    length,\n    one;\n\n  ssize_t\n    j,\n    opacity;\n\n  unsigned char\n    *colormap,\n    *global_colormap;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Allocate colormap.\n  */\n  global_colormap=(unsigned char *) AcquireQuantumMemory(768UL,\n    sizeof(*global_colormap));\n  colormap=(unsigned char *) AcquireQuantumMemory(768UL,sizeof(*colormap));\n  if ((global_colormap == (unsigned char *) NULL) ||\n      (colormap == (unsigned char *) NULL))\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  for (i=0; i < 768; i++)\n    colormap[i]=(unsigned char) 0;\n  /*\n    Write GIF header.\n  */\n  write_info=CloneImageInfo(image_info);\n  if (LocaleCompare(write_info->magick,\"GIF87\") != 0)\n    (void) WriteBlob(image,6,(unsigned char *) \"GIF89a\");\n  else\n    {\n      (void) WriteBlob(image,6,(unsigned char *) \"GIF87a\");\n      write_info->adjoin=MagickFalse;\n    }\n  /*\n    Determine image bounding box.\n  */\n  page.width=image->columns;\n  if (image->page.width > page.width)\n    page.width=image->page.width;\n  page.height=image->rows;\n  if (image->page.height > page.height)\n    page.height=image->page.height;\n  page.x=image->page.x;\n  page.y=image->page.y;\n  (void) WriteBlobLSBShort(image,(unsigned short) page.width);\n  (void) WriteBlobLSBShort(image,(unsigned short) page.height);\n  /*\n    Write images to file.\n  */\n  if ((write_info->adjoin != MagickFalse) &&\n      (GetNextImageInList(image) != (Image *) NULL))\n    write_info->interlace=NoInterlace;\n  scene=0;\n  one=1;\n  do\n  {\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    opacity=(-1);\n    if (IsImageOpaque(image,exception) != MagickFalse)\n      {\n        if ((image->storage_class == DirectClass) || (image->colors > 256))\n          (void) SetImageType(image,PaletteType,exception);\n      }\n    else\n      {\n        double\n          alpha,\n          beta;\n\n        /*\n          Identify transparent colormap index.\n        */\n        if ((image->storage_class == DirectClass) || (image->colors > 256))\n          (void) SetImageType(image,PaletteBilevelAlphaType,exception);\n        for (i=0; i < (ssize_t) image->colors; i++)\n          if (image->colormap[i].alpha != OpaqueAlpha)\n            {\n              if (opacity < 0)\n                {\n                  opacity=i;\n                  continue;\n                }\n              alpha=fabs(image->colormap[i].alpha-TransparentAlpha);\n              beta=fabs(image->colormap[opacity].alpha-TransparentAlpha);\n              if (alpha < beta)\n                opacity=i;\n            }\n        if (opacity == -1)\n          {\n            (void) SetImageType(image,PaletteBilevelAlphaType,exception);\n            for (i=0; i < (ssize_t) image->colors; i++)\n              if (image->colormap[i].alpha != OpaqueAlpha)\n                {\n                  if (opacity < 0)\n                    {\n                      opacity=i;\n                      continue;\n                    }\n                  alpha=fabs(image->colormap[i].alpha-TransparentAlpha);\n                  beta=fabs(image->colormap[opacity].alpha-TransparentAlpha);\n                  if (alpha < beta)\n                    opacity=i;\n                }\n          }\n        if (opacity >= 0)\n          {\n            image->colormap[opacity].red=image->transparent_color.red;\n            image->colormap[opacity].green=image->transparent_color.green;\n            image->colormap[opacity].blue=image->transparent_color.blue;\n          }\n      }\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    for (bits_per_pixel=1; bits_per_pixel < 8; bits_per_pixel++)\n      if ((one << bits_per_pixel) >= image->colors)\n        break;\n    q=colormap;\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));\n      *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));\n      *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));\n    }\n    for ( ; i < (ssize_t) (one << bits_per_pixel); i++)\n    {\n      *q++=(unsigned char) 0x0;\n      *q++=(unsigned char) 0x0;\n      *q++=(unsigned char) 0x0;\n    }\n    if ((GetPreviousImageInList(image) == (Image *) NULL) ||\n        (write_info->adjoin == MagickFalse))\n      {\n        /*\n          Write global colormap.\n        */\n        c=0x80;\n        c|=(8-1) << 4;  /* color resolution */\n        c|=(bits_per_pixel-1);   /* size of global colormap */\n        (void) WriteBlobByte(image,(unsigned char) c);\n        for (j=0; j < (ssize_t) image->colors; j++)\n          if (IsPixelInfoEquivalent(&image->background_color,image->colormap+j))\n            break;\n        (void) WriteBlobByte(image,(unsigned char)\n          (j == (ssize_t) image->colors ? 0 : j));  /* background color */\n        (void) WriteBlobByte(image,(unsigned char) 0x00);  /* reserved */\n        length=(size_t) (3*(one << bits_per_pixel));\n        (void) WriteBlob(image,length,colormap);\n        for (j=0; j < 768; j++)\n          global_colormap[j]=colormap[j];\n      }\n    if (LocaleCompare(write_info->magick,\"GIF87\") != 0)\n      {\n        const char\n          *value;\n\n        /*\n          Write graphics control extension.\n        */\n        (void) WriteBlobByte(image,(unsigned char) 0x21);\n        (void) WriteBlobByte(image,(unsigned char) 0xf9);\n        (void) WriteBlobByte(image,(unsigned char) 0x04);\n        c=image->dispose << 2;\n        if (opacity >= 0)\n          c|=0x01;\n        (void) WriteBlobByte(image,(unsigned char) c);\n        delay=(size_t) (100*image->delay/MagickMax((size_t)\n          image->ticks_per_second,1));\n        (void) WriteBlobLSBShort(image,(unsigned short) delay);\n        (void) WriteBlobByte(image,(unsigned char) (opacity >= 0 ? opacity :\n          0));\n        (void) WriteBlobByte(image,(unsigned char) 0x00);\n        value=GetImageProperty(image,\"comment\",exception);\n        if ((LocaleCompare(write_info->magick,\"GIF87\") != 0) &&\n            (value != (const char *) NULL))\n          {\n            register const char \n              *p;\n\n            size_t\n              count;\n    \n            /*\n              Write comment extension.\n            */\n            (void) WriteBlobByte(image,(unsigned char) 0x21);\n            (void) WriteBlobByte(image,(unsigned char) 0xfe);\n            for (p=value; *p != '\\0'; )\n            {\n              count=MagickMin(strlen(p),255);\n              (void) WriteBlobByte(image,(unsigned char) count);\n              for (i=0; i < (ssize_t) count; i++)\n                (void) WriteBlobByte(image,(unsigned char) *p++);\n            }\n            (void) WriteBlobByte(image,(unsigned char) 0x00);\n          }\n        if ((GetPreviousImageInList(image) == (Image *) NULL) &&\n            (GetNextImageInList(image) != (Image *) NULL) &&\n            (image->iterations != 1))\n          {\n            /*\n              Write Netscape Loop extension.\n            */\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Writing GIF Extension %s\",\"NETSCAPE2.0\");\n            (void) WriteBlobByte(image,(unsigned char) 0x21);\n            (void) WriteBlobByte(image,(unsigned char) 0xff);\n            (void) WriteBlobByte(image,(unsigned char) 0x0b);\n            (void) WriteBlob(image,11,(unsigned char *) \"NETSCAPE2.0\");\n            (void) WriteBlobByte(image,(unsigned char) 0x03);\n            (void) WriteBlobByte(image,(unsigned char) 0x01);\n            (void) WriteBlobLSBShort(image,(unsigned short) (image->iterations ?\n              image->iterations-1 : 0));\n            (void) WriteBlobByte(image,(unsigned char) 0x00);\n          }\n        if ((image->gamma != 1.0f/2.2f))\n          {\n            char\n              attributes[MagickPathExtent];\n\n            ssize_t\n              count;\n\n            /*\n              Write ImageMagick extension.\n            */\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Writing GIF Extension %s\",\"ImageMagick\");\n            (void) WriteBlobByte(image,(unsigned char) 0x21);\n            (void) WriteBlobByte(image,(unsigned char) 0xff);\n            (void) WriteBlobByte(image,(unsigned char) 0x0b);\n            (void) WriteBlob(image,11,(unsigned char *) \"ImageMagick\");\n            count=FormatLocaleString(attributes,MagickPathExtent,\"gamma=%g\",\n              image->gamma);\n            (void) WriteBlobByte(image,(unsigned char) count);\n            (void) WriteBlob(image,(size_t) count,(unsigned char *) attributes);\n            (void) WriteBlobByte(image,(unsigned char) 0x00);\n          }\n        ResetImageProfileIterator(image);\n        for ( ; ; )\n        {\n          char\n            *name;\n\n          const StringInfo\n            *profile;\n\n          name=GetNextImageProfile(image);\n          if (name == (const char *) NULL)\n            break;\n          profile=GetImageProfile(image,name);\n          if (profile != (StringInfo *) NULL)\n          {\n            if ((LocaleCompare(name,\"ICC\") == 0) ||\n                (LocaleCompare(name,\"ICM\") == 0) ||\n                (LocaleCompare(name,\"IPTC\") == 0) ||\n                (LocaleCompare(name,\"8BIM\") == 0) ||\n                (LocaleNCompare(name,\"gif:\",4) == 0))\n            {\n               ssize_t\n                 offset;\n\n               unsigned char\n                 *datum;\n\n               datum=GetStringInfoDatum(profile);\n               length=GetStringInfoLength(profile);\n               (void) WriteBlobByte(image,(unsigned char) 0x21);\n               (void) WriteBlobByte(image,(unsigned char) 0xff);\n               (void) WriteBlobByte(image,(unsigned char) 0x0b);\n               if ((LocaleCompare(name,\"ICC\") == 0) ||\n                   (LocaleCompare(name,\"ICM\") == 0))\n                 {\n                   /*\n                     Write ICC extension.\n                   */\n                   (void) WriteBlob(image,11,(unsigned char *) \"ICCRGBG1012\");\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                     \"  Writing GIF Extension %s\",\"ICCRGBG1012\");\n                 }\n               else\n                 if ((LocaleCompare(name,\"IPTC\") == 0))\n                   {\n                     /*\n                       Write IPTC extension.\n                     */\n                     (void) WriteBlob(image,11,(unsigned char *) \"MGKIPTC0000\");\n                     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"  Writing GIF Extension %s\",\"MGKIPTC0000\");\n                   }\n                 else\n                   if ((LocaleCompare(name,\"8BIM\") == 0))\n                     {\n                       /*\n                         Write 8BIM extension.\n                       */\n                        (void) WriteBlob(image,11,(unsigned char *)\n                          \"MGK8BIM0000\");\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  Writing GIF Extension %s\",\"MGK8BIM0000\");\n                     }\n                   else\n                     {\n                       char\n                         extension[MagickPathExtent];\n\n                       /*\n                         Write generic extension.\n                       */\n                       (void) CopyMagickString(extension,name+4,\n                         sizeof(extension));\n                       (void) WriteBlob(image,11,(unsigned char *) extension);\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"  Writing GIF Extension %s\",name);\n                     }\n               offset=0;\n               while ((ssize_t) length > offset)\n               {\n                 size_t\n                   block_length;\n\n                 if ((length-offset) < 255)\n                   block_length=length-offset;\n                 else\n                   block_length=255;\n                 (void) WriteBlobByte(image,(unsigned char) block_length);\n                 (void) WriteBlob(image,(size_t) block_length,datum+offset);\n                 offset+=(ssize_t) block_length;\n               }\n               (void) WriteBlobByte(image,(unsigned char) 0x00);\n            }\n          }\n        }\n      }\n    (void) WriteBlobByte(image,',');  /* image separator */\n    /*\n      Write the image header.\n    */\n    page.x=image->page.x;\n    page.y=image->page.y;\n    if ((image->page.width != 0) && (image->page.height != 0))\n      page=image->page;\n    (void) WriteBlobLSBShort(image,(unsigned short) (page.x < 0 ? 0 : page.x));\n    (void) WriteBlobLSBShort(image,(unsigned short) (page.y < 0 ? 0 : page.y));\n    (void) WriteBlobLSBShort(image,(unsigned short) image->columns);\n    (void) WriteBlobLSBShort(image,(unsigned short) image->rows);\n    c=0x00;\n    if (write_info->interlace != NoInterlace)\n      c|=0x40;  /* pixel data is interlaced */\n    for (j=0; j < (ssize_t) (3*image->colors); j++)\n      if (colormap[j] != global_colormap[j])\n        break;\n    if (j == (ssize_t) (3*image->colors))\n      (void) WriteBlobByte(image,(unsigned char) c);\n    else\n      {\n        c|=0x80;\n        c|=(bits_per_pixel-1);   /* size of local colormap */\n        (void) WriteBlobByte(image,(unsigned char) c);\n        length=(size_t) (3*(one << bits_per_pixel));\n        (void) WriteBlob(image,length,colormap);\n      }\n    /*\n      Write the image data.\n    */\n    c=(int) MagickMax(bits_per_pixel,2);\n    (void) WriteBlobByte(image,(unsigned char) c);\n    status=EncodeImage(write_info,image,(size_t) MagickMax(bits_per_pixel,2)+1,\n      exception);\n    if (status == MagickFalse)\n      {\n        global_colormap=(unsigned char *) RelinquishMagickMemory(\n          global_colormap);\n        colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n        write_info=DestroyImageInfo(write_info);\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    (void) WriteBlobByte(image,(unsigned char) 0x00);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    scene++;\n    status=SetImageProgress(image,SaveImagesTag,scene,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (write_info->adjoin != MagickFalse);\n  (void) WriteBlobByte(image,';'); /* terminator */\n  global_colormap=(unsigned char *) RelinquishMagickMemory(global_colormap);\n  colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n  write_info=DestroyImageInfo(write_info);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
        "func": "static MagickBooleanType WriteGIFImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  int\n    c;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  RectangleInfo\n    page;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *q;\n\n  size_t\n    bits_per_pixel,\n    delay,\n    length,\n    one;\n\n  ssize_t\n    j,\n    opacity;\n\n  unsigned char\n    *colormap,\n    *global_colormap;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Allocate colormap.\n  */\n  global_colormap=(unsigned char *) AcquireQuantumMemory(768UL,\n    sizeof(*global_colormap));\n  colormap=(unsigned char *) AcquireQuantumMemory(768UL,sizeof(*colormap));\n  if ((global_colormap == (unsigned char *) NULL) ||\n      (colormap == (unsigned char *) NULL))\n    {\n      if (global_colormap != (unsigned char *) NULL)\n        global_colormap=(unsigned char *) RelinquishMagickMemory(\n          global_colormap);\n      if (colormap != (unsigned char *) NULL)\n        colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  for (i=0; i < 768; i++)\n    colormap[i]=(unsigned char) 0;\n  /*\n    Write GIF header.\n  */\n  write_info=CloneImageInfo(image_info);\n  if (LocaleCompare(write_info->magick,\"GIF87\") != 0)\n    (void) WriteBlob(image,6,(unsigned char *) \"GIF89a\");\n  else\n    {\n      (void) WriteBlob(image,6,(unsigned char *) \"GIF87a\");\n      write_info->adjoin=MagickFalse;\n    }\n  /*\n    Determine image bounding box.\n  */\n  page.width=image->columns;\n  if (image->page.width > page.width)\n    page.width=image->page.width;\n  page.height=image->rows;\n  if (image->page.height > page.height)\n    page.height=image->page.height;\n  page.x=image->page.x;\n  page.y=image->page.y;\n  (void) WriteBlobLSBShort(image,(unsigned short) page.width);\n  (void) WriteBlobLSBShort(image,(unsigned short) page.height);\n  /*\n    Write images to file.\n  */\n  if ((write_info->adjoin != MagickFalse) &&\n      (GetNextImageInList(image) != (Image *) NULL))\n    write_info->interlace=NoInterlace;\n  scene=0;\n  one=1;\n  do\n  {\n    (void) TransformImageColorspace(image,sRGBColorspace,exception);\n    opacity=(-1);\n    if (IsImageOpaque(image,exception) != MagickFalse)\n      {\n        if ((image->storage_class == DirectClass) || (image->colors > 256))\n          (void) SetImageType(image,PaletteType,exception);\n      }\n    else\n      {\n        double\n          alpha,\n          beta;\n\n        /*\n          Identify transparent colormap index.\n        */\n        if ((image->storage_class == DirectClass) || (image->colors > 256))\n          (void) SetImageType(image,PaletteBilevelAlphaType,exception);\n        for (i=0; i < (ssize_t) image->colors; i++)\n          if (image->colormap[i].alpha != OpaqueAlpha)\n            {\n              if (opacity < 0)\n                {\n                  opacity=i;\n                  continue;\n                }\n              alpha=fabs(image->colormap[i].alpha-TransparentAlpha);\n              beta=fabs(image->colormap[opacity].alpha-TransparentAlpha);\n              if (alpha < beta)\n                opacity=i;\n            }\n        if (opacity == -1)\n          {\n            (void) SetImageType(image,PaletteBilevelAlphaType,exception);\n            for (i=0; i < (ssize_t) image->colors; i++)\n              if (image->colormap[i].alpha != OpaqueAlpha)\n                {\n                  if (opacity < 0)\n                    {\n                      opacity=i;\n                      continue;\n                    }\n                  alpha=fabs(image->colormap[i].alpha-TransparentAlpha);\n                  beta=fabs(image->colormap[opacity].alpha-TransparentAlpha);\n                  if (alpha < beta)\n                    opacity=i;\n                }\n          }\n        if (opacity >= 0)\n          {\n            image->colormap[opacity].red=image->transparent_color.red;\n            image->colormap[opacity].green=image->transparent_color.green;\n            image->colormap[opacity].blue=image->transparent_color.blue;\n          }\n      }\n    if ((image->storage_class == DirectClass) || (image->colors > 256))\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    for (bits_per_pixel=1; bits_per_pixel < 8; bits_per_pixel++)\n      if ((one << bits_per_pixel) >= image->colors)\n        break;\n    q=colormap;\n    for (i=0; i < (ssize_t) image->colors; i++)\n    {\n      *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].red));\n      *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].green));\n      *q++=ScaleQuantumToChar(ClampToQuantum(image->colormap[i].blue));\n    }\n    for ( ; i < (ssize_t) (one << bits_per_pixel); i++)\n    {\n      *q++=(unsigned char) 0x0;\n      *q++=(unsigned char) 0x0;\n      *q++=(unsigned char) 0x0;\n    }\n    if ((GetPreviousImageInList(image) == (Image *) NULL) ||\n        (write_info->adjoin == MagickFalse))\n      {\n        /*\n          Write global colormap.\n        */\n        c=0x80;\n        c|=(8-1) << 4;  /* color resolution */\n        c|=(bits_per_pixel-1);   /* size of global colormap */\n        (void) WriteBlobByte(image,(unsigned char) c);\n        for (j=0; j < (ssize_t) image->colors; j++)\n          if (IsPixelInfoEquivalent(&image->background_color,image->colormap+j))\n            break;\n        (void) WriteBlobByte(image,(unsigned char)\n          (j == (ssize_t) image->colors ? 0 : j));  /* background color */\n        (void) WriteBlobByte(image,(unsigned char) 0x00);  /* reserved */\n        length=(size_t) (3*(one << bits_per_pixel));\n        (void) WriteBlob(image,length,colormap);\n        for (j=0; j < 768; j++)\n          global_colormap[j]=colormap[j];\n      }\n    if (LocaleCompare(write_info->magick,\"GIF87\") != 0)\n      {\n        const char\n          *value;\n\n        /*\n          Write graphics control extension.\n        */\n        (void) WriteBlobByte(image,(unsigned char) 0x21);\n        (void) WriteBlobByte(image,(unsigned char) 0xf9);\n        (void) WriteBlobByte(image,(unsigned char) 0x04);\n        c=image->dispose << 2;\n        if (opacity >= 0)\n          c|=0x01;\n        (void) WriteBlobByte(image,(unsigned char) c);\n        delay=(size_t) (100*image->delay/MagickMax((size_t)\n          image->ticks_per_second,1));\n        (void) WriteBlobLSBShort(image,(unsigned short) delay);\n        (void) WriteBlobByte(image,(unsigned char) (opacity >= 0 ? opacity :\n          0));\n        (void) WriteBlobByte(image,(unsigned char) 0x00);\n        value=GetImageProperty(image,\"comment\",exception);\n        if ((LocaleCompare(write_info->magick,\"GIF87\") != 0) &&\n            (value != (const char *) NULL))\n          {\n            register const char \n              *p;\n\n            size_t\n              count;\n    \n            /*\n              Write comment extension.\n            */\n            (void) WriteBlobByte(image,(unsigned char) 0x21);\n            (void) WriteBlobByte(image,(unsigned char) 0xfe);\n            for (p=value; *p != '\\0'; )\n            {\n              count=MagickMin(strlen(p),255);\n              (void) WriteBlobByte(image,(unsigned char) count);\n              for (i=0; i < (ssize_t) count; i++)\n                (void) WriteBlobByte(image,(unsigned char) *p++);\n            }\n            (void) WriteBlobByte(image,(unsigned char) 0x00);\n          }\n        if ((GetPreviousImageInList(image) == (Image *) NULL) &&\n            (GetNextImageInList(image) != (Image *) NULL) &&\n            (image->iterations != 1))\n          {\n            /*\n              Write Netscape Loop extension.\n            */\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Writing GIF Extension %s\",\"NETSCAPE2.0\");\n            (void) WriteBlobByte(image,(unsigned char) 0x21);\n            (void) WriteBlobByte(image,(unsigned char) 0xff);\n            (void) WriteBlobByte(image,(unsigned char) 0x0b);\n            (void) WriteBlob(image,11,(unsigned char *) \"NETSCAPE2.0\");\n            (void) WriteBlobByte(image,(unsigned char) 0x03);\n            (void) WriteBlobByte(image,(unsigned char) 0x01);\n            (void) WriteBlobLSBShort(image,(unsigned short) (image->iterations ?\n              image->iterations-1 : 0));\n            (void) WriteBlobByte(image,(unsigned char) 0x00);\n          }\n        if ((image->gamma != 1.0f/2.2f))\n          {\n            char\n              attributes[MagickPathExtent];\n\n            ssize_t\n              count;\n\n            /*\n              Write ImageMagick extension.\n            */\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n               \"  Writing GIF Extension %s\",\"ImageMagick\");\n            (void) WriteBlobByte(image,(unsigned char) 0x21);\n            (void) WriteBlobByte(image,(unsigned char) 0xff);\n            (void) WriteBlobByte(image,(unsigned char) 0x0b);\n            (void) WriteBlob(image,11,(unsigned char *) \"ImageMagick\");\n            count=FormatLocaleString(attributes,MagickPathExtent,\"gamma=%g\",\n              image->gamma);\n            (void) WriteBlobByte(image,(unsigned char) count);\n            (void) WriteBlob(image,(size_t) count,(unsigned char *) attributes);\n            (void) WriteBlobByte(image,(unsigned char) 0x00);\n          }\n        ResetImageProfileIterator(image);\n        for ( ; ; )\n        {\n          char\n            *name;\n\n          const StringInfo\n            *profile;\n\n          name=GetNextImageProfile(image);\n          if (name == (const char *) NULL)\n            break;\n          profile=GetImageProfile(image,name);\n          if (profile != (StringInfo *) NULL)\n          {\n            if ((LocaleCompare(name,\"ICC\") == 0) ||\n                (LocaleCompare(name,\"ICM\") == 0) ||\n                (LocaleCompare(name,\"IPTC\") == 0) ||\n                (LocaleCompare(name,\"8BIM\") == 0) ||\n                (LocaleNCompare(name,\"gif:\",4) == 0))\n            {\n               ssize_t\n                 offset;\n\n               unsigned char\n                 *datum;\n\n               datum=GetStringInfoDatum(profile);\n               length=GetStringInfoLength(profile);\n               (void) WriteBlobByte(image,(unsigned char) 0x21);\n               (void) WriteBlobByte(image,(unsigned char) 0xff);\n               (void) WriteBlobByte(image,(unsigned char) 0x0b);\n               if ((LocaleCompare(name,\"ICC\") == 0) ||\n                   (LocaleCompare(name,\"ICM\") == 0))\n                 {\n                   /*\n                     Write ICC extension.\n                   */\n                   (void) WriteBlob(image,11,(unsigned char *) \"ICCRGBG1012\");\n                   (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                     \"  Writing GIF Extension %s\",\"ICCRGBG1012\");\n                 }\n               else\n                 if ((LocaleCompare(name,\"IPTC\") == 0))\n                   {\n                     /*\n                       Write IPTC extension.\n                     */\n                     (void) WriteBlob(image,11,(unsigned char *) \"MGKIPTC0000\");\n                     (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                       \"  Writing GIF Extension %s\",\"MGKIPTC0000\");\n                   }\n                 else\n                   if ((LocaleCompare(name,\"8BIM\") == 0))\n                     {\n                       /*\n                         Write 8BIM extension.\n                       */\n                        (void) WriteBlob(image,11,(unsigned char *)\n                          \"MGK8BIM0000\");\n                        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                          \"  Writing GIF Extension %s\",\"MGK8BIM0000\");\n                     }\n                   else\n                     {\n                       char\n                         extension[MagickPathExtent];\n\n                       /*\n                         Write generic extension.\n                       */\n                       (void) CopyMagickString(extension,name+4,\n                         sizeof(extension));\n                       (void) WriteBlob(image,11,(unsigned char *) extension);\n                       (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                         \"  Writing GIF Extension %s\",name);\n                     }\n               offset=0;\n               while ((ssize_t) length > offset)\n               {\n                 size_t\n                   block_length;\n\n                 if ((length-offset) < 255)\n                   block_length=length-offset;\n                 else\n                   block_length=255;\n                 (void) WriteBlobByte(image,(unsigned char) block_length);\n                 (void) WriteBlob(image,(size_t) block_length,datum+offset);\n                 offset+=(ssize_t) block_length;\n               }\n               (void) WriteBlobByte(image,(unsigned char) 0x00);\n            }\n          }\n        }\n      }\n    (void) WriteBlobByte(image,',');  /* image separator */\n    /*\n      Write the image header.\n    */\n    page.x=image->page.x;\n    page.y=image->page.y;\n    if ((image->page.width != 0) && (image->page.height != 0))\n      page=image->page;\n    (void) WriteBlobLSBShort(image,(unsigned short) (page.x < 0 ? 0 : page.x));\n    (void) WriteBlobLSBShort(image,(unsigned short) (page.y < 0 ? 0 : page.y));\n    (void) WriteBlobLSBShort(image,(unsigned short) image->columns);\n    (void) WriteBlobLSBShort(image,(unsigned short) image->rows);\n    c=0x00;\n    if (write_info->interlace != NoInterlace)\n      c|=0x40;  /* pixel data is interlaced */\n    for (j=0; j < (ssize_t) (3*image->colors); j++)\n      if (colormap[j] != global_colormap[j])\n        break;\n    if (j == (ssize_t) (3*image->colors))\n      (void) WriteBlobByte(image,(unsigned char) c);\n    else\n      {\n        c|=0x80;\n        c|=(bits_per_pixel-1);   /* size of local colormap */\n        (void) WriteBlobByte(image,(unsigned char) c);\n        length=(size_t) (3*(one << bits_per_pixel));\n        (void) WriteBlob(image,length,colormap);\n      }\n    /*\n      Write the image data.\n    */\n    c=(int) MagickMax(bits_per_pixel,2);\n    (void) WriteBlobByte(image,(unsigned char) c);\n    status=EncodeImage(write_info,image,(size_t) MagickMax(bits_per_pixel,2)+1,\n      exception);\n    if (status == MagickFalse)\n      {\n        global_colormap=(unsigned char *) RelinquishMagickMemory(\n          global_colormap);\n        colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n        write_info=DestroyImageInfo(write_info);\n        ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n      }\n    (void) WriteBlobByte(image,(unsigned char) 0x00);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    scene++;\n    status=SetImageProgress(image,SaveImagesTag,scene,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (write_info->adjoin != MagickFalse);\n  (void) WriteBlobByte(image,';'); /* terminator */\n  global_colormap=(unsigned char *) RelinquishMagickMemory(global_colormap);\n  colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n  write_info=DestroyImageInfo(write_info);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -58,7 +58,14 @@\n   colormap=(unsigned char *) AcquireQuantumMemory(768UL,sizeof(*colormap));\n   if ((global_colormap == (unsigned char *) NULL) ||\n       (colormap == (unsigned char *) NULL))\n-    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n+    {\n+      if (global_colormap != (unsigned char *) NULL)\n+        global_colormap=(unsigned char *) RelinquishMagickMemory(\n+          global_colormap);\n+      if (colormap != (unsigned char *) NULL)\n+        colormap=(unsigned char *) RelinquishMagickMemory(colormap);\n+      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n+    }\n   for (i=0; i < 768; i++)\n     colormap[i]=(unsigned char) 0;\n   /*",
        "diff_line_info": {
            "deleted_lines": [
                "    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");"
            ],
            "added_lines": [
                "    {",
                "      if (global_colormap != (unsigned char *) NULL)",
                "        global_colormap=(unsigned char *) RelinquishMagickMemory(",
                "          global_colormap);",
                "      if (colormap != (unsigned char *) NULL)",
                "        colormap=(unsigned char *) RelinquishMagickMemory(colormap);",
                "      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-9265",
        "func_name": "wireshark/add_tn3270_conversation",
        "description": "In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, epan/dissectors/packet-tn3270.c has a memory leak.",
        "git_url": "https://github.com/wireshark/wireshark/commit/b12cc581cd4878d74b6116ca02c7dbe650c1f242",
        "commit_title": "TN3270: fix memory leaks in conversation management",
        "commit_text": " Bug: 14480 (cherry picked from commit 98ab887a2d4ffbe7b255655c510b676c32e93608)",
        "func_before": "void\nadd_tn3270_conversation(packet_info *pinfo, int tn3270e, gint model)\n{\n  conversation_t     *conversation;\n  tn3270_conv_info_t *tn3270_info;\n\n  conversation = find_or_create_conversation(pinfo);\n\n  /*\n   * Do we already have a type and mechanism?\n   */\n  tn3270_info = (tn3270_conv_info_t *)conversation_get_proto_data(conversation, proto_tn3270);\n  if (tn3270_info == NULL) {\n    /* No.  Attach that information to the conversation, and add\n     * it to the list of information structures.\n     */\n    tn3270_info = wmem_new(wmem_file_scope(), tn3270_conv_info_t);\n\n    copy_address(&(tn3270_info->outbound_addr), &(pinfo->dst));\n    tn3270_info->outbound_port = pinfo->destport;\n\n    copy_address(&(tn3270_info->inbound_addr), &(pinfo->src));\n    tn3270_info->inbound_port  = pinfo->srcport;\n\n    conversation_add_proto_data(conversation, proto_tn3270, tn3270_info);\n  }\n\n  /* The maximum rows/cols is tied to the 3270 model number */\n  switch (model) {\n    default:\n    case 2:\n      tn3270_info->altrows = 24;\n      tn3270_info->altcols = 80;\n      break;\n    case 3:\n      tn3270_info->altrows = 32;\n      tn3270_info->altcols = 80;\n      break;\n    case 4:\n      tn3270_info->altrows = 43;\n      tn3270_info->altcols = 80;\n      break;\n    case 5:\n      tn3270_info->altrows = 27;\n      tn3270_info->altcols = 132;\n      break;\n  }\n  tn3270_info->rows = 24;\n  tn3270_info->cols = 80;\n\n  tn3270_info->extended = tn3270e;\n\n}",
        "func": "void\nadd_tn3270_conversation(packet_info *pinfo, int tn3270e, gint model)\n{\n  conversation_t     *conversation;\n  tn3270_conv_info_t *tn3270_info;\n\n  conversation = find_or_create_conversation(pinfo);\n\n  /*\n   * Do we already have a type and mechanism?\n   */\n  tn3270_info = (tn3270_conv_info_t *)conversation_get_proto_data(conversation, proto_tn3270);\n  if (tn3270_info == NULL) {\n    /* No.  Attach that information to the conversation, and add\n     * it to the list of information structures.\n     */\n    tn3270_info = wmem_new(wmem_file_scope(), tn3270_conv_info_t);\n\n    copy_address_wmem(wmem_file_scope(), &(tn3270_info->outbound_addr), &(pinfo->dst));\n    tn3270_info->outbound_port = pinfo->destport;\n\n    copy_address_wmem(wmem_file_scope(), &(tn3270_info->inbound_addr), &(pinfo->src));\n    tn3270_info->inbound_port  = pinfo->srcport;\n\n    conversation_add_proto_data(conversation, proto_tn3270, tn3270_info);\n  }\n\n  /* The maximum rows/cols is tied to the 3270 model number */\n  switch (model) {\n    default:\n    case 2:\n      tn3270_info->altrows = 24;\n      tn3270_info->altcols = 80;\n      break;\n    case 3:\n      tn3270_info->altrows = 32;\n      tn3270_info->altcols = 80;\n      break;\n    case 4:\n      tn3270_info->altrows = 43;\n      tn3270_info->altcols = 80;\n      break;\n    case 5:\n      tn3270_info->altrows = 27;\n      tn3270_info->altcols = 132;\n      break;\n  }\n  tn3270_info->rows = 24;\n  tn3270_info->cols = 80;\n\n  tn3270_info->extended = tn3270e;\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,10 +16,10 @@\n      */\n     tn3270_info = wmem_new(wmem_file_scope(), tn3270_conv_info_t);\n \n-    copy_address(&(tn3270_info->outbound_addr), &(pinfo->dst));\n+    copy_address_wmem(wmem_file_scope(), &(tn3270_info->outbound_addr), &(pinfo->dst));\n     tn3270_info->outbound_port = pinfo->destport;\n \n-    copy_address(&(tn3270_info->inbound_addr), &(pinfo->src));\n+    copy_address_wmem(wmem_file_scope(), &(tn3270_info->inbound_addr), &(pinfo->src));\n     tn3270_info->inbound_port  = pinfo->srcport;\n \n     conversation_add_proto_data(conversation, proto_tn3270, tn3270_info);",
        "diff_line_info": {
            "deleted_lines": [
                "    copy_address(&(tn3270_info->outbound_addr), &(pinfo->dst));",
                "    copy_address(&(tn3270_info->inbound_addr), &(pinfo->src));"
            ],
            "added_lines": [
                "    copy_address_wmem(wmem_file_scope(), &(tn3270_info->outbound_addr), &(pinfo->dst));",
                "    copy_address_wmem(wmem_file_scope(), &(tn3270_info->inbound_addr), &(pinfo->src));"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-9266",
        "func_name": "wireshark/dissect_application_isup",
        "description": "In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, epan/dissectors/packet-isup.c has a memory leak.",
        "git_url": "https://github.com/wireshark/wireshark/commit/9d3714e767cb104dcfa1647935fa5960b16bb8e1",
        "commit_title": "ISUP: plug some memory leaks",
        "commit_text": " Bug: 14481 (cherry picked from commit 1b18b1dd0e171ec660ad1ce5d47bab80ddc3da86)",
        "func_before": "static int\ndissect_application_isup(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\n{\n/* Set up structures needed to add the protocol subtree and manage it */\n  proto_item *ti;\n  proto_tree *isup_tree = NULL;\n  tvbuff_t   *message_tvb;\n  guint8      message_type;\n  char       *version, *base;\n  guint8      itu_isup_variant = ISUP_ITU_STANDARD_VARIANT; /* Default */\n\n  if (data) {\n    http_message_info_t *message_info = (http_message_info_t *)data;\n    if (message_info->media_str) {\n      version = ws_find_media_type_parameter(message_info->media_str, \"version\");\n      base = ws_find_media_type_parameter(message_info->media_str, \"base\");\n      if ((version && g_ascii_strncasecmp(version, \"ansi\", 4) == 0) ||\n          (base && g_ascii_strncasecmp(base, \"ansi\", 4) == 0)) {\n        /*\n         * \"version\" or \"base\" parameter begins with \"ansi\", so it's ANSI.\n         */\n        isup_standard = ANSI_STANDARD;\n        col_append_str(pinfo->cinfo, COL_PROTOCOL, \"/ISUP(ANSI)\");\n        message_type = tvb_get_guint8(tvb, 0);\n        /* application/ISUP has no  CIC  */\n        col_append_sep_fstr(pinfo->cinfo, COL_INFO, \", \",\n                            \"ISUP:%s\",\n                            val_to_str_ext_const(message_type, &ansi_isup_message_type_value_acro_ext, \"reserved\"));\n        if (tree) {\n          ti = proto_tree_add_item(tree, proto_isup, tvb, 0, -1, ENC_NA);\n          isup_tree = proto_item_add_subtree(ti, ett_isup);\n        }\n\n        message_tvb = tvb_new_subset_remaining(tvb, 0);\n        dissect_ansi_isup_message(message_tvb, pinfo, isup_tree, ISUP_ITU_STANDARD_VARIANT, 0);\n        return tvb_reported_length(tvb);\n      } else if ((version && g_ascii_strcasecmp(version, \"spirou\") == 0) ||\n          (base && g_ascii_strcasecmp(base, \"spirou\") == 0)) {\n        /*\n         * \"version\" or \"base\" version is \"spirou\", so it's SPIROU.\n         */\n        isup_standard    = ITU_STANDARD;\n        itu_isup_variant = ISUP_FRENCH_VARIANT;\n      } else {\n        isup_standard = ITU_STANDARD;\n      }\n      g_free(version);\n      g_free(base);\n    } else {\n      /* default to ITU */\n      isup_standard = ITU_STANDARD;\n    }\n  } else {\n    /* default to ITU */\n    isup_standard = ITU_STANDARD;\n  }\n\n\n  /* Extract message type field */\n  message_type = tvb_get_guint8(tvb, 0);\n\n  switch (itu_isup_variant) {\n    case ISUP_ITU_STANDARD_VARIANT:\n      /* Make entries in Protocol column and Info column on summary display */\n      col_append_str(pinfo->cinfo, COL_PROTOCOL, \"/ISUP(ITU)\");\n\n      /* application/ISUP has no  CIC  */\n      col_append_sep_fstr(pinfo->cinfo, COL_INFO, \", \",\n                          \"ISUP:%s\",\n                          val_to_str_ext_const(message_type, &isup_message_type_value_acro_ext, \"reserved\"));\n      break;\n    case ISUP_FRENCH_VARIANT:\n      /* Make entries in Protocol column and Info column on summary display */\n      col_append_str(pinfo->cinfo, COL_PROTOCOL, \"/ISUP(French)\");\n\n      /* application/ISUP has no  CIC  */\n      col_append_sep_fstr(pinfo->cinfo, COL_INFO, \", \",\n                          \"ISUP:%s\",\n                          val_to_str_ext_const(message_type, &french_isup_message_type_value_acro_ext, \"reserved\"));\n      break;\n#if 0\n      /* This case can't happen unless/until we can parse the Israeli variant\n       * out of the content type\n       */\n    case ISUP_ISRAELI_VARIANT:\n      /* Make entries in Protocol column and Info column on summary display */\n      col_append_str(pinfo->cinfo, COL_PROTOCOL, \"/ISUP(Israeli)\");\n\n      /* application/ISUP has no  CIC  */\n      col_append_sep_fstr(pinfo->cinfo, COL_INFO, \", \",\n                          \"ISUP:%s\",\n                          val_to_str_ext_const(message_type, &israeli_isup_message_type_value_acro_ext, \"reserved\"));\n      break;\n#endif\n    default:\n      col_append_sep_fstr(pinfo->cinfo, COL_INFO, \", \",\n                          \"ISUP: Unknown variant %d\", itu_isup_variant);\n      break;\n  }\n\n  if (tree) {\n    ti = proto_tree_add_item(tree, proto_isup, tvb, 0, -1, ENC_NA);\n    isup_tree = proto_item_add_subtree(ti, ett_isup);\n  }\n\n  message_tvb = tvb_new_subset_remaining(tvb, 0);\n  dissect_isup_message(message_tvb, pinfo, isup_tree, itu_isup_variant, 0);\n  return tvb_reported_length(tvb);\n}",
        "func": "static int\ndissect_application_isup(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data)\n{\n/* Set up structures needed to add the protocol subtree and manage it */\n  proto_item *ti;\n  proto_tree *isup_tree = NULL;\n  tvbuff_t   *message_tvb;\n  guint8      message_type;\n  char       *version, *base;\n  guint8      itu_isup_variant = ISUP_ITU_STANDARD_VARIANT; /* Default */\n\n  if (data) {\n    http_message_info_t *message_info = (http_message_info_t *)data;\n    if (message_info->media_str) {\n      version = ws_find_media_type_parameter(message_info->media_str, \"version\");\n      base = ws_find_media_type_parameter(message_info->media_str, \"base\");\n      if ((version && g_ascii_strncasecmp(version, \"ansi\", 4) == 0) ||\n          (base && g_ascii_strncasecmp(base, \"ansi\", 4) == 0)) {\n        /*\n         * \"version\" or \"base\" parameter begins with \"ansi\", so it's ANSI.\n         */\n        isup_standard = ANSI_STANDARD;\n        col_append_str(pinfo->cinfo, COL_PROTOCOL, \"/ISUP(ANSI)\");\n        message_type = tvb_get_guint8(tvb, 0);\n        /* application/ISUP has no  CIC  */\n        col_append_sep_fstr(pinfo->cinfo, COL_INFO, \", \",\n                            \"ISUP:%s\",\n                            val_to_str_ext_const(message_type, &ansi_isup_message_type_value_acro_ext, \"reserved\"));\n        if (tree) {\n          ti = proto_tree_add_item(tree, proto_isup, tvb, 0, -1, ENC_NA);\n          isup_tree = proto_item_add_subtree(ti, ett_isup);\n        }\n\n        message_tvb = tvb_new_subset_remaining(tvb, 0);\n        dissect_ansi_isup_message(message_tvb, pinfo, isup_tree, ISUP_ITU_STANDARD_VARIANT, 0);\n        g_free(version);\n        g_free(base);\n        return tvb_reported_length(tvb);\n      } else if ((version && g_ascii_strcasecmp(version, \"spirou\") == 0) ||\n          (base && g_ascii_strcasecmp(base, \"spirou\") == 0)) {\n        /*\n         * \"version\" or \"base\" version is \"spirou\", so it's SPIROU.\n         */\n        isup_standard    = ITU_STANDARD;\n        itu_isup_variant = ISUP_FRENCH_VARIANT;\n      } else {\n        isup_standard = ITU_STANDARD;\n      }\n      g_free(version);\n      g_free(base);\n    } else {\n      /* default to ITU */\n      isup_standard = ITU_STANDARD;\n    }\n  } else {\n    /* default to ITU */\n    isup_standard = ITU_STANDARD;\n  }\n\n\n  /* Extract message type field */\n  message_type = tvb_get_guint8(tvb, 0);\n\n  switch (itu_isup_variant) {\n    case ISUP_ITU_STANDARD_VARIANT:\n      /* Make entries in Protocol column and Info column on summary display */\n      col_append_str(pinfo->cinfo, COL_PROTOCOL, \"/ISUP(ITU)\");\n\n      /* application/ISUP has no  CIC  */\n      col_append_sep_fstr(pinfo->cinfo, COL_INFO, \", \",\n                          \"ISUP:%s\",\n                          val_to_str_ext_const(message_type, &isup_message_type_value_acro_ext, \"reserved\"));\n      break;\n    case ISUP_FRENCH_VARIANT:\n      /* Make entries in Protocol column and Info column on summary display */\n      col_append_str(pinfo->cinfo, COL_PROTOCOL, \"/ISUP(French)\");\n\n      /* application/ISUP has no  CIC  */\n      col_append_sep_fstr(pinfo->cinfo, COL_INFO, \", \",\n                          \"ISUP:%s\",\n                          val_to_str_ext_const(message_type, &french_isup_message_type_value_acro_ext, \"reserved\"));\n      break;\n#if 0\n      /* This case can't happen unless/until we can parse the Israeli variant\n       * out of the content type\n       */\n    case ISUP_ISRAELI_VARIANT:\n      /* Make entries in Protocol column and Info column on summary display */\n      col_append_str(pinfo->cinfo, COL_PROTOCOL, \"/ISUP(Israeli)\");\n\n      /* application/ISUP has no  CIC  */\n      col_append_sep_fstr(pinfo->cinfo, COL_INFO, \", \",\n                          \"ISUP:%s\",\n                          val_to_str_ext_const(message_type, &israeli_isup_message_type_value_acro_ext, \"reserved\"));\n      break;\n#endif\n    default:\n      col_append_sep_fstr(pinfo->cinfo, COL_INFO, \", \",\n                          \"ISUP: Unknown variant %d\", itu_isup_variant);\n      break;\n  }\n\n  if (tree) {\n    ti = proto_tree_add_item(tree, proto_isup, tvb, 0, -1, ENC_NA);\n    isup_tree = proto_item_add_subtree(ti, ett_isup);\n  }\n\n  message_tvb = tvb_new_subset_remaining(tvb, 0);\n  dissect_isup_message(message_tvb, pinfo, isup_tree, itu_isup_variant, 0);\n  return tvb_reported_length(tvb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -33,6 +33,8 @@\n \n         message_tvb = tvb_new_subset_remaining(tvb, 0);\n         dissect_ansi_isup_message(message_tvb, pinfo, isup_tree, ISUP_ITU_STANDARD_VARIANT, 0);\n+        g_free(version);\n+        g_free(base);\n         return tvb_reported_length(tvb);\n       } else if ((version && g_ascii_strcasecmp(version, \"spirou\") == 0) ||\n           (base && g_ascii_strcasecmp(base, \"spirou\") == 0)) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        g_free(version);",
                "        g_free(base);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-9267",
        "func_name": "wireshark/dissect_lapd_bitstream",
        "description": "In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, epan/dissectors/packet-lapd.c has a memory leak.",
        "git_url": "https://github.com/wireshark/wireshark/commit/8ed057f7faa709dbde34b91f0715a957837f74d9",
        "commit_title": "LAPD: fix some memory leaks in conversation management",
        "commit_text": " Bug: 14482 (cherry picked from commit bf4e620e2d15689e8582425224160f39dcc8589c)",
        "func_before": "static int\ndissect_lapd_bitstream(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* dissector_data _U_)\n{\n\tguint8\t\tbyte, full_byte = 0x00, bit_offset = 0;\n\tgboolean\tbit;\n\tguint8\t\ti, ones = 0, data[MAX_LAPD_PACKET_LEN];\n\tint\t\tdata_len = 0;\n\tgint\t\toffset = 0, available;\n\tguint8\t\t*buff;\n\ttvbuff_t\t*new_tvb;\n\n\tenum lapd_bitstream_states state = OUT_OF_SYNC;\n\tlapd_ppi_t\t\t*lapd_ppi;\n\tconversation_t\t\t*conversation = NULL;\n\tlapd_convo_data_t\t*convo_data = NULL;\n\tlapd_byte_state_t\t*lapd_byte_state, *prev_byte_state = NULL;\n\tgboolean\t\tforward_stream = TRUE;\n\n\t/* get remaining data from previous packets */\n\tconversation = find_or_create_conversation(pinfo);\n\tlapd_ppi = (lapd_ppi_t*)p_get_proto_data(wmem_file_scope(), pinfo, proto_lapd, 0);\n\tif (lapd_ppi) {\n\t\tprev_byte_state = &lapd_ppi->start_byte_state;\n\t\tif (prev_byte_state) {\n\t\t\tstate = prev_byte_state->state;\n\t\t\tfull_byte = prev_byte_state->full_byte;\n\t\t\tbit_offset = prev_byte_state->bit_offset;\n\t\t\tones = prev_byte_state->ones;\n\t\t\tmemcpy(data, prev_byte_state->data, prev_byte_state->data_len);\n\t\t\tdata_len = prev_byte_state->data_len;\n\t\t}\n\n\t} else if (conversation) {\n\t\tconvo_data = (lapd_convo_data_t*)conversation_get_proto_data(conversation, proto_lapd);\n\t\tif (NULL != convo_data) {\n\t\t\tif (addresses_equal(&convo_data->addr_a, &pinfo->src)\n\t\t\t\t\t&& addresses_equal(&convo_data->addr_b, &pinfo->dst)\n\t\t\t\t\t&& convo_data-> port_a == pinfo->srcport\n\t\t\t\t\t&& convo_data-> port_b == pinfo->destport) {\n\t\t\t\t/* \"forward\" direction */\n\t\t\t\tforward_stream = TRUE;\n\t\t\t\tprev_byte_state = convo_data->byte_state_a;\n\t\t\t} else if (addresses_equal(&convo_data-> addr_b, &pinfo->src)\n\t\t\t\t\t&& addresses_equal(&convo_data->addr_a, &pinfo->dst)\n\t\t\t\t\t&& convo_data-> port_b == pinfo->srcport\n\t\t\t\t\t&& convo_data-> port_a == pinfo->destport) {\n\t\t\t\t/* \"backward\" direction */\n\t\t\t\tforward_stream = FALSE;\n\t\t\t\tprev_byte_state = convo_data->byte_state_b;\n\t\t\t}\n\t\t}\n\t\tif (prev_byte_state) {\n\t\t\tstate = prev_byte_state->state;\n\t\t\tfull_byte = prev_byte_state->full_byte;\n\t\t\tbit_offset = prev_byte_state->bit_offset;\n\t\t\tones = prev_byte_state->ones;\n\n\t\t\tmemcpy(data, prev_byte_state->data, prev_byte_state->data_len);\n\t\t\tdata_len = prev_byte_state->data_len;\n\t\t}\n\t}\n\n\t/* Consume tvb bytes */\n\tavailable = tvb_reported_length_remaining(tvb, offset);\n\twhile (offset < available) {\n\t\tbyte = tvb_get_guint8(tvb,offset);\n\t\toffset++;\n\t\tfor (i=0; i < 8; i++) { /* cycle through bits */\n\t\t\tbit = byte & (0x80 >> i) ? TRUE : FALSE;\n\n\t\t\t/* consume a bit */\n\t\t\tif (bit) {\n\t\t\t\tones++;\n\t\t\t\tfull_byte |= (1 << bit_offset++);\n\t\t\t} else {\n\t\t\t\tif (ones == 5 && state == DATA) {\n\t\t\t\t\t/* we don't increase bit_offset, it is an inserted zero */\n\t\t\t\t} else if (ones == 6 && state == DATA) { /* probably starting flag sequence */\n\t\t\t\t\tbuff = (guint8 *)g_memdup(data, data_len);\n\t\t\t\t\t/* Allocate new tvb for the LAPD frame */\n\t\t\t\t\tnew_tvb = tvb_new_child_real_data(tvb, buff, data_len, data_len);\n\t\t\t\t\ttvb_set_free_cb(new_tvb, g_free);\n\t\t\t\t\tadd_new_data_source(pinfo, new_tvb, \"Decoded LAPD bitstream\");\n\t\t\t\t\tdata_len = 0;\n\t\t\t\t\tstate = FLAGS;\n\t\t\t\t\tbit_offset++;\n\n\t\t\t\t\tif (full_byte != 0x7E) {\n\t\t\t\t\t\tdata_len = 0;\n\t\t\t\t\t\tstate = OUT_OF_SYNC;\n\t\t\t\t\t\tlapd_log_abort(tvb, pinfo, tree, offset, \"Abort! 6 ones that don't match 0x7e!\");\n\n\t\t\t\t\t}\n\t\t\t\t\tdissect_lapd_full(new_tvb, pinfo, tree, TRUE);\n\t\t\t\t} else if (ones >= 7) { /* frame reset or 11111111 flag byte */\n\t\t\t\t\tdata_len = 0;\n\t\t\t\t\tstate = OUT_OF_SYNC;\n\t\t\t\t\tbit_offset++;\n\n\t\t\t\t\tlapd_log_abort(tvb, pinfo, tree, offset, \"Abort! 7 ones!\");\n\t\t\t\t} else {\n\t\t\t\t\tbit_offset++;\n\t\t\t\t}\n\t\t\t\tones = 0;\n\t\t\t}\n\n\t\t\tif (bit_offset == 8) { /* we have a new complete byte */\n\t\t\t\tswitch (state) {\n\t\t\t\t\tcase OUT_OF_SYNC:\n\t\t\t\t\t\tif (full_byte == 0x7E) { /* we have a flag byte */\n\t\t\t\t\t\t\tstate = FLAGS;\n\t\t\t\t\t\t\tfull_byte = 0x00;\n\t\t\t\t\t\t\tbit_offset = 0;\n\t\t\t\t\t\t} else { /* no sync yet, wait for a new byte */\n\t\t\t\t\t\t\tfull_byte = (full_byte >> 1) & 0x7F;\n\t\t\t\t\t\t\tbit_offset--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FLAGS:\n\t\t\t\t\t\tif (full_byte == 0x7E) { /* we have a flag byte */\n\t\t\t\t\t\t\tfull_byte = 0x00;\n\t\t\t\t\t\t\tbit_offset = 0;\n\t\t\t\t\t\t} else { /* we got the first data byte */\n\t\t\t\t\t\t\tstate = DATA;\n\t\t\t\t\t\t\tnew_byte(full_byte, data, &data_len);\n\t\t\t\t\t\t\tfull_byte = 0x00;\n\t\t\t\t\t\t\tbit_offset = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DATA:\n\t\t\t\t\t\t/* we got a new data byte */\n\t\t\t\t\t\tnew_byte(full_byte, data, &data_len);\n\t\t\t\t\t\tfull_byte = 0x00;\n\t\t\t\t\t\tbit_offset = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t{\n\t\tif (NULL == p_get_proto_data(wmem_file_scope(), pinfo, proto_lapd, 0)) {\n\t\t\t/* Per packet information */\n\t\t\tlapd_ppi = wmem_new(wmem_file_scope(), lapd_ppi_t);\n\t\t\tlapd_ppi->has_crc = TRUE;\n\t\t\tif (prev_byte_state)\n\t\t\t\tfill_lapd_byte_state(&lapd_ppi->start_byte_state, prev_byte_state->state,\n\t\t\t\t\t\tprev_byte_state->full_byte, prev_byte_state->bit_offset,\n\t\t\t\t\t\tprev_byte_state->ones, prev_byte_state->data, prev_byte_state->data_len);\n\t\t\telse\n\t\t\t\tfill_lapd_byte_state(&lapd_ppi->start_byte_state, OUT_OF_SYNC, 0x00, 0, 0, data, 0);\n\n\t\t\tp_add_proto_data(wmem_file_scope(), pinfo, proto_lapd, 0, lapd_ppi);\n\n\n\t\t\t/* Conversation info*/\n\n\t\t\tif (conversation) {\n\t\t\t\tif (convo_data) { /* already have lapd convo data */\n\t\t\t\t\tif (forward_stream)\n\t\t\t\t\t\tfill_lapd_byte_state(convo_data->byte_state_a, state, full_byte, bit_offset, ones, data, data_len);\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!convo_data->byte_state_b)\n\t\t\t\t\t\t\tconvo_data->byte_state_b = wmem_new(wmem_file_scope(), lapd_byte_state_t);\n\t\t\t\t\t\tfill_lapd_byte_state(convo_data->byte_state_b, state, full_byte, bit_offset, ones, data, data_len);\n\t\t\t\t\t}\n\t\t\t\t} else { /* lapd convo data has to be created */\n\t\t\t\t\tlapd_byte_state = wmem_new(wmem_file_scope(), lapd_byte_state_t);\n\t\t\t\t\tfill_lapd_byte_state(lapd_byte_state, state, full_byte, bit_offset, ones, data, data_len);\n\t\t\t\t\tconvo_data = wmem_new(wmem_file_scope(), lapd_convo_data_t);\n\t\t\t\t\tcopy_address(&convo_data->addr_a, &pinfo->src);\n\t\t\t\t\tcopy_address(&convo_data->addr_b, &pinfo->dst);\n\t\t\t\t\tconvo_data->port_a = pinfo->srcport;\n\t\t\t\t\tconvo_data->port_b = pinfo->destport;\n\t\t\t\t\tconvo_data->byte_state_a = lapd_byte_state;\n\t\t\t\t\tconvo_data->byte_state_b = NULL;\n\t\t\t\t\tconversation_add_proto_data(conversation, proto_lapd, convo_data);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn tvb_captured_length(tvb);\n}",
        "func": "static int\ndissect_lapd_bitstream(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* dissector_data _U_)\n{\n\tguint8\t\tbyte, full_byte = 0x00, bit_offset = 0;\n\tgboolean\tbit;\n\tguint8\t\ti, ones = 0, data[MAX_LAPD_PACKET_LEN];\n\tint\t\tdata_len = 0;\n\tgint\t\toffset = 0, available;\n\tguint8\t\t*buff;\n\ttvbuff_t\t*new_tvb;\n\n\tenum lapd_bitstream_states state = OUT_OF_SYNC;\n\tlapd_ppi_t\t\t*lapd_ppi;\n\tconversation_t\t\t*conversation = NULL;\n\tlapd_convo_data_t\t*convo_data = NULL;\n\tlapd_byte_state_t\t*lapd_byte_state, *prev_byte_state = NULL;\n\tgboolean\t\tforward_stream = TRUE;\n\n\t/* get remaining data from previous packets */\n\tconversation = find_or_create_conversation(pinfo);\n\tlapd_ppi = (lapd_ppi_t*)p_get_proto_data(wmem_file_scope(), pinfo, proto_lapd, 0);\n\tif (lapd_ppi) {\n\t\tprev_byte_state = &lapd_ppi->start_byte_state;\n\t\tif (prev_byte_state) {\n\t\t\tstate = prev_byte_state->state;\n\t\t\tfull_byte = prev_byte_state->full_byte;\n\t\t\tbit_offset = prev_byte_state->bit_offset;\n\t\t\tones = prev_byte_state->ones;\n\t\t\tmemcpy(data, prev_byte_state->data, prev_byte_state->data_len);\n\t\t\tdata_len = prev_byte_state->data_len;\n\t\t}\n\n\t} else if (conversation) {\n\t\tconvo_data = (lapd_convo_data_t*)conversation_get_proto_data(conversation, proto_lapd);\n\t\tif (NULL != convo_data) {\n\t\t\tif (addresses_equal(&convo_data->addr_a, &pinfo->src)\n\t\t\t\t\t&& addresses_equal(&convo_data->addr_b, &pinfo->dst)\n\t\t\t\t\t&& convo_data-> port_a == pinfo->srcport\n\t\t\t\t\t&& convo_data-> port_b == pinfo->destport) {\n\t\t\t\t/* \"forward\" direction */\n\t\t\t\tforward_stream = TRUE;\n\t\t\t\tprev_byte_state = convo_data->byte_state_a;\n\t\t\t} else if (addresses_equal(&convo_data-> addr_b, &pinfo->src)\n\t\t\t\t\t&& addresses_equal(&convo_data->addr_a, &pinfo->dst)\n\t\t\t\t\t&& convo_data-> port_b == pinfo->srcport\n\t\t\t\t\t&& convo_data-> port_a == pinfo->destport) {\n\t\t\t\t/* \"backward\" direction */\n\t\t\t\tforward_stream = FALSE;\n\t\t\t\tprev_byte_state = convo_data->byte_state_b;\n\t\t\t}\n\t\t}\n\t\tif (prev_byte_state) {\n\t\t\tstate = prev_byte_state->state;\n\t\t\tfull_byte = prev_byte_state->full_byte;\n\t\t\tbit_offset = prev_byte_state->bit_offset;\n\t\t\tones = prev_byte_state->ones;\n\n\t\t\tmemcpy(data, prev_byte_state->data, prev_byte_state->data_len);\n\t\t\tdata_len = prev_byte_state->data_len;\n\t\t}\n\t}\n\n\t/* Consume tvb bytes */\n\tavailable = tvb_reported_length_remaining(tvb, offset);\n\twhile (offset < available) {\n\t\tbyte = tvb_get_guint8(tvb,offset);\n\t\toffset++;\n\t\tfor (i=0; i < 8; i++) { /* cycle through bits */\n\t\t\tbit = byte & (0x80 >> i) ? TRUE : FALSE;\n\n\t\t\t/* consume a bit */\n\t\t\tif (bit) {\n\t\t\t\tones++;\n\t\t\t\tfull_byte |= (1 << bit_offset++);\n\t\t\t} else {\n\t\t\t\tif (ones == 5 && state == DATA) {\n\t\t\t\t\t/* we don't increase bit_offset, it is an inserted zero */\n\t\t\t\t} else if (ones == 6 && state == DATA) { /* probably starting flag sequence */\n\t\t\t\t\tbuff = (guint8 *)g_memdup(data, data_len);\n\t\t\t\t\t/* Allocate new tvb for the LAPD frame */\n\t\t\t\t\tnew_tvb = tvb_new_child_real_data(tvb, buff, data_len, data_len);\n\t\t\t\t\ttvb_set_free_cb(new_tvb, g_free);\n\t\t\t\t\tadd_new_data_source(pinfo, new_tvb, \"Decoded LAPD bitstream\");\n\t\t\t\t\tdata_len = 0;\n\t\t\t\t\tstate = FLAGS;\n\t\t\t\t\tbit_offset++;\n\n\t\t\t\t\tif (full_byte != 0x7E) {\n\t\t\t\t\t\tdata_len = 0;\n\t\t\t\t\t\tstate = OUT_OF_SYNC;\n\t\t\t\t\t\tlapd_log_abort(tvb, pinfo, tree, offset, \"Abort! 6 ones that don't match 0x7e!\");\n\n\t\t\t\t\t}\n\t\t\t\t\tdissect_lapd_full(new_tvb, pinfo, tree, TRUE);\n\t\t\t\t} else if (ones >= 7) { /* frame reset or 11111111 flag byte */\n\t\t\t\t\tdata_len = 0;\n\t\t\t\t\tstate = OUT_OF_SYNC;\n\t\t\t\t\tbit_offset++;\n\n\t\t\t\t\tlapd_log_abort(tvb, pinfo, tree, offset, \"Abort! 7 ones!\");\n\t\t\t\t} else {\n\t\t\t\t\tbit_offset++;\n\t\t\t\t}\n\t\t\t\tones = 0;\n\t\t\t}\n\n\t\t\tif (bit_offset == 8) { /* we have a new complete byte */\n\t\t\t\tswitch (state) {\n\t\t\t\t\tcase OUT_OF_SYNC:\n\t\t\t\t\t\tif (full_byte == 0x7E) { /* we have a flag byte */\n\t\t\t\t\t\t\tstate = FLAGS;\n\t\t\t\t\t\t\tfull_byte = 0x00;\n\t\t\t\t\t\t\tbit_offset = 0;\n\t\t\t\t\t\t} else { /* no sync yet, wait for a new byte */\n\t\t\t\t\t\t\tfull_byte = (full_byte >> 1) & 0x7F;\n\t\t\t\t\t\t\tbit_offset--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase FLAGS:\n\t\t\t\t\t\tif (full_byte == 0x7E) { /* we have a flag byte */\n\t\t\t\t\t\t\tfull_byte = 0x00;\n\t\t\t\t\t\t\tbit_offset = 0;\n\t\t\t\t\t\t} else { /* we got the first data byte */\n\t\t\t\t\t\t\tstate = DATA;\n\t\t\t\t\t\t\tnew_byte(full_byte, data, &data_len);\n\t\t\t\t\t\t\tfull_byte = 0x00;\n\t\t\t\t\t\t\tbit_offset = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DATA:\n\t\t\t\t\t\t/* we got a new data byte */\n\t\t\t\t\t\tnew_byte(full_byte, data, &data_len);\n\t\t\t\t\t\tfull_byte = 0x00;\n\t\t\t\t\t\tbit_offset = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t{\n\t\tif (NULL == p_get_proto_data(wmem_file_scope(), pinfo, proto_lapd, 0)) {\n\t\t\t/* Per packet information */\n\t\t\tlapd_ppi = wmem_new(wmem_file_scope(), lapd_ppi_t);\n\t\t\tlapd_ppi->has_crc = TRUE;\n\t\t\tif (prev_byte_state)\n\t\t\t\tfill_lapd_byte_state(&lapd_ppi->start_byte_state, prev_byte_state->state,\n\t\t\t\t\t\tprev_byte_state->full_byte, prev_byte_state->bit_offset,\n\t\t\t\t\t\tprev_byte_state->ones, prev_byte_state->data, prev_byte_state->data_len);\n\t\t\telse\n\t\t\t\tfill_lapd_byte_state(&lapd_ppi->start_byte_state, OUT_OF_SYNC, 0x00, 0, 0, data, 0);\n\n\t\t\tp_add_proto_data(wmem_file_scope(), pinfo, proto_lapd, 0, lapd_ppi);\n\n\n\t\t\t/* Conversation info*/\n\n\t\t\tif (conversation) {\n\t\t\t\tif (convo_data) { /* already have lapd convo data */\n\t\t\t\t\tif (forward_stream)\n\t\t\t\t\t\tfill_lapd_byte_state(convo_data->byte_state_a, state, full_byte, bit_offset, ones, data, data_len);\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!convo_data->byte_state_b)\n\t\t\t\t\t\t\tconvo_data->byte_state_b = wmem_new(wmem_file_scope(), lapd_byte_state_t);\n\t\t\t\t\t\tfill_lapd_byte_state(convo_data->byte_state_b, state, full_byte, bit_offset, ones, data, data_len);\n\t\t\t\t\t}\n\t\t\t\t} else { /* lapd convo data has to be created */\n\t\t\t\t\tlapd_byte_state = wmem_new(wmem_file_scope(), lapd_byte_state_t);\n\t\t\t\t\tfill_lapd_byte_state(lapd_byte_state, state, full_byte, bit_offset, ones, data, data_len);\n\t\t\t\t\tconvo_data = wmem_new(wmem_file_scope(), lapd_convo_data_t);\n\t\t\t\t\tcopy_address_wmem(wmem_file_scope(), &convo_data->addr_a, &pinfo->src);\n\t\t\t\t\tcopy_address_wmem(wmem_file_scope(), &convo_data->addr_b, &pinfo->dst);\n\t\t\t\t\tconvo_data->port_a = pinfo->srcport;\n\t\t\t\t\tconvo_data->port_b = pinfo->destport;\n\t\t\t\t\tconvo_data->byte_state_a = lapd_byte_state;\n\t\t\t\t\tconvo_data->byte_state_b = NULL;\n\t\t\t\t\tconversation_add_proto_data(conversation, proto_lapd, convo_data);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn tvb_captured_length(tvb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -170,8 +170,8 @@\n \t\t\t\t\tlapd_byte_state = wmem_new(wmem_file_scope(), lapd_byte_state_t);\n \t\t\t\t\tfill_lapd_byte_state(lapd_byte_state, state, full_byte, bit_offset, ones, data, data_len);\n \t\t\t\t\tconvo_data = wmem_new(wmem_file_scope(), lapd_convo_data_t);\n-\t\t\t\t\tcopy_address(&convo_data->addr_a, &pinfo->src);\n-\t\t\t\t\tcopy_address(&convo_data->addr_b, &pinfo->dst);\n+\t\t\t\t\tcopy_address_wmem(wmem_file_scope(), &convo_data->addr_a, &pinfo->src);\n+\t\t\t\t\tcopy_address_wmem(wmem_file_scope(), &convo_data->addr_b, &pinfo->dst);\n \t\t\t\t\tconvo_data->port_a = pinfo->srcport;\n \t\t\t\t\tconvo_data->port_b = pinfo->destport;\n \t\t\t\t\tconvo_data->byte_state_a = lapd_byte_state;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t\tcopy_address(&convo_data->addr_a, &pinfo->src);",
                "\t\t\t\t\tcopy_address(&convo_data->addr_b, &pinfo->dst);"
            ],
            "added_lines": [
                "\t\t\t\t\tcopy_address_wmem(wmem_file_scope(), &convo_data->addr_a, &pinfo->src);",
                "\t\t\t\t\tcopy_address_wmem(wmem_file_scope(), &convo_data->addr_b, &pinfo->dst);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-9268",
        "func_name": "wireshark/dissect_smb2_create_request",
        "description": "In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, epan/dissectors/packet-smb2.c has a memory leak.",
        "git_url": "https://github.com/wireshark/wireshark/commit/c69d710d2bf39fe633800db65efddf55701131b6",
        "commit_title": "SMB2: use file scope to avoid leaking memory",
        "commit_text": " Bug: 14483 (cherry picked from commit 4945c50d3f8269c56d9d087d16d080144de146dc)",
        "func_before": "static int\ndissect_smb2_create_request(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, smb2_info_t *si)\n{\n\toffset_length_buffer_t  f_olb, e_olb;\n\tconst char             *fname;\n\n\t/* buffer code */\n\toffset = dissect_smb2_buffercode(tree, tvb, offset, NULL);\n\n\t/* security flags */\n\toffset++;\n\n\t/* oplock */\n\toffset = dissect_smb2_oplock(tree, tvb, offset);\n\n\t/* impersonation level */\n\tproto_tree_add_item(tree, hf_smb2_impersonation_level, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\n\t/* create flags */\n\tproto_tree_add_item(tree, hf_smb2_create_flags, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n\toffset += 8;\n\n\t/* reserved */\n\tproto_tree_add_item(tree, hf_smb2_reserved, tvb, offset, 8, ENC_NA);\n\toffset += 8;\n\n\t/* access mask */\n\toffset = dissect_smb_access_mask(tvb, tree, offset);\n\n\t/* File Attributes */\n\toffset = dissect_file_ext_attr(tvb, tree, offset);\n\n\t/* share access */\n\toffset = dissect_nt_share_access(tvb, tree, offset);\n\n\t/* create disposition */\n\tproto_tree_add_item(tree, hf_smb2_create_disposition, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\n\t/* create options */\n\toffset = dissect_nt_create_options(tvb, tree, offset);\n\n\t/* filename  offset/length */\n\toffset = dissect_smb2_olb_length_offset(tvb, offset, &f_olb, OLB_O_UINT16_S_UINT16, hf_smb2_filename);\n\n\t/* extrainfo offset */\n\toffset = dissect_smb2_olb_length_offset(tvb, offset, &e_olb, OLB_O_UINT32_S_UINT32, hf_smb2_extrainfo);\n\n\t/* filename string */\n\tfname = dissect_smb2_olb_string(pinfo, tree, tvb, &f_olb, OLB_TYPE_UNICODE_STRING);\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \" File: %s\", fname);\n\n\t/* save the name if it looks sane */\n\tif (!pinfo->fd->flags.visited) {\n\t\tif (si->saved && si->saved->extra_info_type == SMB2_EI_FILENAME) {\n\t\t\tg_free(si->saved->extra_info);\n\t\t\tsi->saved->extra_info = NULL;\n\t\t\tsi->saved->extra_info_type = SMB2_EI_NONE;\n\t\t}\n\t\tif (si->saved && f_olb.len && f_olb.len<256) {\n\t\t\tsi->saved->extra_info_type = SMB2_EI_FILENAME;\n\t\t\tsi->saved->extra_info = (gchar *)g_malloc(f_olb.len+1);\n\t\t\tg_snprintf((gchar *)si->saved->extra_info, f_olb.len+1, \"%s\", fname);\n\t\t}\n\t}\n\n\t/* If extrainfo_offset is non-null then this points to another\n\t * buffer. The offset is relative to the start of the smb packet\n\t */\n\tdissect_smb2_olb_buffer(pinfo, tree, tvb, &e_olb, si, dissect_smb2_create_extra_info);\n\n\toffset = dissect_smb2_olb_tvb_max_offset(offset, &f_olb);\n\toffset = dissect_smb2_olb_tvb_max_offset(offset, &e_olb);\n\n\treturn offset;\n}",
        "func": "static int\ndissect_smb2_create_request(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, smb2_info_t *si)\n{\n\toffset_length_buffer_t  f_olb, e_olb;\n\tconst char             *fname;\n\n\t/* buffer code */\n\toffset = dissect_smb2_buffercode(tree, tvb, offset, NULL);\n\n\t/* security flags */\n\toffset++;\n\n\t/* oplock */\n\toffset = dissect_smb2_oplock(tree, tvb, offset);\n\n\t/* impersonation level */\n\tproto_tree_add_item(tree, hf_smb2_impersonation_level, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\n\t/* create flags */\n\tproto_tree_add_item(tree, hf_smb2_create_flags, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n\toffset += 8;\n\n\t/* reserved */\n\tproto_tree_add_item(tree, hf_smb2_reserved, tvb, offset, 8, ENC_NA);\n\toffset += 8;\n\n\t/* access mask */\n\toffset = dissect_smb_access_mask(tvb, tree, offset);\n\n\t/* File Attributes */\n\toffset = dissect_file_ext_attr(tvb, tree, offset);\n\n\t/* share access */\n\toffset = dissect_nt_share_access(tvb, tree, offset);\n\n\t/* create disposition */\n\tproto_tree_add_item(tree, hf_smb2_create_disposition, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\n\t/* create options */\n\toffset = dissect_nt_create_options(tvb, tree, offset);\n\n\t/* filename  offset/length */\n\toffset = dissect_smb2_olb_length_offset(tvb, offset, &f_olb, OLB_O_UINT16_S_UINT16, hf_smb2_filename);\n\n\t/* extrainfo offset */\n\toffset = dissect_smb2_olb_length_offset(tvb, offset, &e_olb, OLB_O_UINT32_S_UINT32, hf_smb2_extrainfo);\n\n\t/* filename string */\n\tfname = dissect_smb2_olb_string(pinfo, tree, tvb, &f_olb, OLB_TYPE_UNICODE_STRING);\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \" File: %s\", fname);\n\n\t/* save the name if it looks sane */\n\tif (!pinfo->fd->flags.visited) {\n\t\tif (si->saved && si->saved->extra_info_type == SMB2_EI_FILENAME) {\n\t\t\twmem_free(wmem_file_scope(), si->saved->extra_info);\n\t\t\tsi->saved->extra_info = NULL;\n\t\t\tsi->saved->extra_info_type = SMB2_EI_NONE;\n\t\t}\n\t\tif (si->saved && f_olb.len && f_olb.len<256) {\n\t\t\tsi->saved->extra_info_type = SMB2_EI_FILENAME;\n\t\t\tsi->saved->extra_info = (gchar *)wmem_alloc(wmem_file_scope(), f_olb.len+1);\n\t\t\tg_snprintf((gchar *)si->saved->extra_info, f_olb.len+1, \"%s\", fname);\n\t\t}\n\t}\n\n\t/* If extrainfo_offset is non-null then this points to another\n\t * buffer. The offset is relative to the start of the smb packet\n\t */\n\tdissect_smb2_olb_buffer(pinfo, tree, tvb, &e_olb, si, dissect_smb2_create_extra_info);\n\n\toffset = dissect_smb2_olb_tvb_max_offset(offset, &f_olb);\n\toffset = dissect_smb2_olb_tvb_max_offset(offset, &e_olb);\n\n\treturn offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -54,13 +54,13 @@\n \t/* save the name if it looks sane */\n \tif (!pinfo->fd->flags.visited) {\n \t\tif (si->saved && si->saved->extra_info_type == SMB2_EI_FILENAME) {\n-\t\t\tg_free(si->saved->extra_info);\n+\t\t\twmem_free(wmem_file_scope(), si->saved->extra_info);\n \t\t\tsi->saved->extra_info = NULL;\n \t\t\tsi->saved->extra_info_type = SMB2_EI_NONE;\n \t\t}\n \t\tif (si->saved && f_olb.len && f_olb.len<256) {\n \t\t\tsi->saved->extra_info_type = SMB2_EI_FILENAME;\n-\t\t\tsi->saved->extra_info = (gchar *)g_malloc(f_olb.len+1);\n+\t\t\tsi->saved->extra_info = (gchar *)wmem_alloc(wmem_file_scope(), f_olb.len+1);\n \t\t\tg_snprintf((gchar *)si->saved->extra_info, f_olb.len+1, \"%s\", fname);\n \t\t}\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tg_free(si->saved->extra_info);",
                "\t\t\tsi->saved->extra_info = (gchar *)g_malloc(f_olb.len+1);"
            ],
            "added_lines": [
                "\t\t\twmem_free(wmem_file_scope(), si->saved->extra_info);",
                "\t\t\tsi->saved->extra_info = (gchar *)wmem_alloc(wmem_file_scope(), f_olb.len+1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-9268",
        "func_name": "wireshark/dissect_smb2_create_response",
        "description": "In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, epan/dissectors/packet-smb2.c has a memory leak.",
        "git_url": "https://github.com/wireshark/wireshark/commit/c69d710d2bf39fe633800db65efddf55701131b6",
        "commit_title": "SMB2: use file scope to avoid leaking memory",
        "commit_text": " Bug: 14483 (cherry picked from commit 4945c50d3f8269c56d9d087d16d080144de146dc)",
        "func_before": "static int\ndissect_smb2_create_response(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, smb2_info_t *si)\n{\n\tguint64 end_of_file;\n\tguint32\tattr_mask;\n\toffset_length_buffer_t e_olb;\n\tstatic const int *create_rep_flags_fields[] = {\n\t\t&hf_smb2_create_rep_flags_reparse_point,\n\t\tNULL\n\t};\n\tgboolean continue_dissection;\n\n\tswitch (si->status) {\n\t/* buffer code */\n\tcase 0x00000000: offset = dissect_smb2_buffercode(tree, tvb, offset, NULL); break;\n\tdefault: offset = dissect_smb2_error_response(tvb, pinfo, tree, offset, si, &continue_dissection);\n\t\tif (!continue_dissection) return offset;\n\t}\n\n\t/* oplock */\n\toffset = dissect_smb2_oplock(tree, tvb, offset);\n\n\t/* reserved */\n\tproto_tree_add_bitmask(tree, tvb, offset, hf_smb2_create_rep_flags,\n\t\t\t       ett_smb2_create_rep_flags, create_rep_flags_fields, ENC_LITTLE_ENDIAN);\n\toffset += 1;\n\n\t/* create action */\n\tproto_tree_add_item(tree, hf_smb2_create_action, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\n\t/* create time */\n\toffset = dissect_nt_64bit_time(tvb, tree, offset, hf_smb2_create_timestamp);\n\n\t/* last access */\n\toffset = dissect_nt_64bit_time(tvb, tree, offset, hf_smb2_last_access_timestamp);\n\n\t/* last write */\n\toffset = dissect_nt_64bit_time(tvb, tree, offset, hf_smb2_last_write_timestamp);\n\n\t/* last change */\n\toffset = dissect_nt_64bit_time(tvb, tree, offset, hf_smb2_last_change_timestamp);\n\n\t/* allocation size */\n\tproto_tree_add_item(tree, hf_smb2_allocation_size, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n\toffset += 8;\n\n\t/* end of file */\n\tend_of_file = tvb_get_letoh64(tvb, offset);\n\tif (si->eo_file_info) {\n\t\tsi->eo_file_info->end_of_file = tvb_get_letoh64(tvb, offset);\n\t}\n\tproto_tree_add_item(tree, hf_smb2_end_of_file, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n\toffset += 8;\n\n\t/* File Attributes */\n\tattr_mask=tvb_get_letohl(tvb, offset);\n\toffset = dissect_file_ext_attr(tvb, tree, offset);\n\n\t/* reserved */\n\tproto_tree_add_item(tree, hf_smb2_reserved, tvb, offset, 4, ENC_NA);\n\toffset += 4;\n\n\t/* fid */\n\toffset = dissect_smb2_fid(tvb, pinfo, tree, offset, si, FID_MODE_OPEN);\n\n\t/* We save this after dissect_smb2_fid just because it would be\n\tpossible to have this response without having the mathing request.\n\tIn that case the entry in the file info hash table has been created\n\tin dissect_smb2_fid */\n\tif (si->eo_file_info) {\n\t\tsi->eo_file_info->end_of_file = end_of_file;\n\t\tsi->eo_file_info->attr_mask = attr_mask;\n\t}\n\n\t/* extrainfo offset */\n\toffset = dissect_smb2_olb_length_offset(tvb, offset, &e_olb, OLB_O_UINT32_S_UINT32, hf_smb2_extrainfo);\n\n\t/* If extrainfo_offset is non-null then this points to another\n\t * buffer. The offset is relative to the start of the smb packet\n\t */\n\tdissect_smb2_olb_buffer(pinfo, tree, tvb, &e_olb, si, dissect_smb2_create_extra_info);\n\n\toffset = dissect_smb2_olb_tvb_max_offset(offset, &e_olb);\n\n\t/* free si->saved->extra_info   we don't need it any more */\n\tif (si->saved && si->saved->extra_info_type == SMB2_EI_FILENAME) {\n\t\tg_free(si->saved->extra_info);\n\t\tsi->saved->extra_info = NULL;\n\t\tsi->saved->extra_info_type = SMB2_EI_NONE;\n\t}\n\n\treturn offset;\n}",
        "func": "static int\ndissect_smb2_create_response(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, smb2_info_t *si)\n{\n\tguint64 end_of_file;\n\tguint32\tattr_mask;\n\toffset_length_buffer_t e_olb;\n\tstatic const int *create_rep_flags_fields[] = {\n\t\t&hf_smb2_create_rep_flags_reparse_point,\n\t\tNULL\n\t};\n\tgboolean continue_dissection;\n\n\tswitch (si->status) {\n\t/* buffer code */\n\tcase 0x00000000: offset = dissect_smb2_buffercode(tree, tvb, offset, NULL); break;\n\tdefault: offset = dissect_smb2_error_response(tvb, pinfo, tree, offset, si, &continue_dissection);\n\t\tif (!continue_dissection) return offset;\n\t}\n\n\t/* oplock */\n\toffset = dissect_smb2_oplock(tree, tvb, offset);\n\n\t/* reserved */\n\tproto_tree_add_bitmask(tree, tvb, offset, hf_smb2_create_rep_flags,\n\t\t\t       ett_smb2_create_rep_flags, create_rep_flags_fields, ENC_LITTLE_ENDIAN);\n\toffset += 1;\n\n\t/* create action */\n\tproto_tree_add_item(tree, hf_smb2_create_action, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\n\t/* create time */\n\toffset = dissect_nt_64bit_time(tvb, tree, offset, hf_smb2_create_timestamp);\n\n\t/* last access */\n\toffset = dissect_nt_64bit_time(tvb, tree, offset, hf_smb2_last_access_timestamp);\n\n\t/* last write */\n\toffset = dissect_nt_64bit_time(tvb, tree, offset, hf_smb2_last_write_timestamp);\n\n\t/* last change */\n\toffset = dissect_nt_64bit_time(tvb, tree, offset, hf_smb2_last_change_timestamp);\n\n\t/* allocation size */\n\tproto_tree_add_item(tree, hf_smb2_allocation_size, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n\toffset += 8;\n\n\t/* end of file */\n\tend_of_file = tvb_get_letoh64(tvb, offset);\n\tif (si->eo_file_info) {\n\t\tsi->eo_file_info->end_of_file = tvb_get_letoh64(tvb, offset);\n\t}\n\tproto_tree_add_item(tree, hf_smb2_end_of_file, tvb, offset, 8, ENC_LITTLE_ENDIAN);\n\toffset += 8;\n\n\t/* File Attributes */\n\tattr_mask=tvb_get_letohl(tvb, offset);\n\toffset = dissect_file_ext_attr(tvb, tree, offset);\n\n\t/* reserved */\n\tproto_tree_add_item(tree, hf_smb2_reserved, tvb, offset, 4, ENC_NA);\n\toffset += 4;\n\n\t/* fid */\n\toffset = dissect_smb2_fid(tvb, pinfo, tree, offset, si, FID_MODE_OPEN);\n\n\t/* We save this after dissect_smb2_fid just because it would be\n\tpossible to have this response without having the mathing request.\n\tIn that case the entry in the file info hash table has been created\n\tin dissect_smb2_fid */\n\tif (si->eo_file_info) {\n\t\tsi->eo_file_info->end_of_file = end_of_file;\n\t\tsi->eo_file_info->attr_mask = attr_mask;\n\t}\n\n\t/* extrainfo offset */\n\toffset = dissect_smb2_olb_length_offset(tvb, offset, &e_olb, OLB_O_UINT32_S_UINT32, hf_smb2_extrainfo);\n\n\t/* If extrainfo_offset is non-null then this points to another\n\t * buffer. The offset is relative to the start of the smb packet\n\t */\n\tdissect_smb2_olb_buffer(pinfo, tree, tvb, &e_olb, si, dissect_smb2_create_extra_info);\n\n\toffset = dissect_smb2_olb_tvb_max_offset(offset, &e_olb);\n\n\t/* free si->saved->extra_info   we don't need it any more */\n\tif (si->saved && si->saved->extra_info_type == SMB2_EI_FILENAME) {\n\t\twmem_free(wmem_file_scope(), si->saved->extra_info);\n\t\tsi->saved->extra_info = NULL;\n\t\tsi->saved->extra_info_type = SMB2_EI_NONE;\n\t}\n\n\treturn offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -85,7 +85,7 @@\n \n \t/* free si->saved->extra_info   we don't need it any more */\n \tif (si->saved && si->saved->extra_info_type == SMB2_EI_FILENAME) {\n-\t\tg_free(si->saved->extra_info);\n+\t\twmem_free(wmem_file_scope(), si->saved->extra_info);\n \t\tsi->saved->extra_info = NULL;\n \t\tsi->saved->extra_info_type = SMB2_EI_NONE;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tg_free(si->saved->extra_info);"
            ],
            "added_lines": [
                "\t\twmem_free(wmem_file_scope(), si->saved->extra_info);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-9268",
        "func_name": "wireshark/dissect_smb2_find_response",
        "description": "In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, epan/dissectors/packet-smb2.c has a memory leak.",
        "git_url": "https://github.com/wireshark/wireshark/commit/c69d710d2bf39fe633800db65efddf55701131b6",
        "commit_title": "SMB2: use file scope to avoid leaking memory",
        "commit_text": " Bug: 14483 (cherry picked from commit 4945c50d3f8269c56d9d087d16d080144de146dc)",
        "func_before": "static int\ndissect_smb2_find_response(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, smb2_info_t *si _U_)\n{\n\toffset_length_buffer_t olb;\n\tproto_item *item = NULL;\n\tgboolean continue_dissection;\n\n\tif (si->saved) {\n\t\t/* infolevel */\n\t\titem = proto_tree_add_uint(tree, hf_smb2_find_info_level, tvb, offset, 0, si->saved->infolevel);\n\t\tPROTO_ITEM_SET_GENERATED(item);\n\t}\n\n\tif (!pinfo->fd->flags.visited && si->saved && si->saved->extra_info_type == SMB2_EI_FINDPATTERN) {\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \" %s Pattern: %s\",\n\t\t\t\tval_to_str(si->saved->infolevel, smb2_find_info_levels, \"(Level:0x%02x)\"),\n\t\t\t\t(const char *)si->saved->extra_info);\n\n\t\tg_free(si->saved->extra_info);\n\t\tsi->saved->extra_info_type = SMB2_EI_NONE;\n\t\tsi->saved->extra_info = NULL;\n\t}\n\n\tswitch (si->status) {\n\t/* buffer code */\n\tcase 0x00000000: offset = dissect_smb2_buffercode(tree, tvb, offset, NULL); break;\n\tdefault: offset = dissect_smb2_error_response(tvb, pinfo, tree, offset, si, &continue_dissection);\n\t\tif (!continue_dissection) return offset;\n\t}\n\n\t/* findinfo offset */\n\toffset = dissect_smb2_olb_length_offset(tvb, offset, &olb, OLB_O_UINT16_S_UINT32, hf_smb2_find_info_blob);\n\n\t/* the buffer */\n\tdissect_smb2_olb_buffer(pinfo, tree, tvb, &olb, si, dissect_smb2_find_data);\n\n\toffset = dissect_smb2_olb_tvb_max_offset(offset, &olb);\n\n\treturn offset;\n}",
        "func": "static int\ndissect_smb2_find_response(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, smb2_info_t *si _U_)\n{\n\toffset_length_buffer_t olb;\n\tproto_item *item = NULL;\n\tgboolean continue_dissection;\n\n\tif (si->saved) {\n\t\t/* infolevel */\n\t\titem = proto_tree_add_uint(tree, hf_smb2_find_info_level, tvb, offset, 0, si->saved->infolevel);\n\t\tPROTO_ITEM_SET_GENERATED(item);\n\t}\n\n\tif (!pinfo->fd->flags.visited && si->saved && si->saved->extra_info_type == SMB2_EI_FINDPATTERN) {\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \" %s Pattern: %s\",\n\t\t\t\tval_to_str(si->saved->infolevel, smb2_find_info_levels, \"(Level:0x%02x)\"),\n\t\t\t\t(const char *)si->saved->extra_info);\n\n\t\twmem_free(wmem_file_scope(), si->saved->extra_info);\n\t\tsi->saved->extra_info_type = SMB2_EI_NONE;\n\t\tsi->saved->extra_info = NULL;\n\t}\n\n\tswitch (si->status) {\n\t/* buffer code */\n\tcase 0x00000000: offset = dissect_smb2_buffercode(tree, tvb, offset, NULL); break;\n\tdefault: offset = dissect_smb2_error_response(tvb, pinfo, tree, offset, si, &continue_dissection);\n\t\tif (!continue_dissection) return offset;\n\t}\n\n\t/* findinfo offset */\n\toffset = dissect_smb2_olb_length_offset(tvb, offset, &olb, OLB_O_UINT16_S_UINT32, hf_smb2_find_info_blob);\n\n\t/* the buffer */\n\tdissect_smb2_olb_buffer(pinfo, tree, tvb, &olb, si, dissect_smb2_find_data);\n\n\toffset = dissect_smb2_olb_tvb_max_offset(offset, &olb);\n\n\treturn offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,7 +16,7 @@\n \t\t\t\tval_to_str(si->saved->infolevel, smb2_find_info_levels, \"(Level:0x%02x)\"),\n \t\t\t\t(const char *)si->saved->extra_info);\n \n-\t\tg_free(si->saved->extra_info);\n+\t\twmem_free(wmem_file_scope(), si->saved->extra_info);\n \t\tsi->saved->extra_info_type = SMB2_EI_NONE;\n \t\tsi->saved->extra_info = NULL;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tg_free(si->saved->extra_info);"
            ],
            "added_lines": [
                "\t\twmem_free(wmem_file_scope(), si->saved->extra_info);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-9268",
        "func_name": "wireshark/dissect_smb2_find_request",
        "description": "In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, epan/dissectors/packet-smb2.c has a memory leak.",
        "git_url": "https://github.com/wireshark/wireshark/commit/c69d710d2bf39fe633800db65efddf55701131b6",
        "commit_title": "SMB2: use file scope to avoid leaking memory",
        "commit_text": " Bug: 14483 (cherry picked from commit 4945c50d3f8269c56d9d087d16d080144de146dc)",
        "func_before": "static int\ndissect_smb2_find_request(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, smb2_info_t *si)\n{\n\toffset_length_buffer_t olb;\n\tconst char *buf;\n\tguint8      il;\n\tstatic const int *f_fields[] = {\n\t\t&hf_smb2_find_flags_restart_scans,\n\t\t&hf_smb2_find_flags_single_entry,\n\t\t&hf_smb2_find_flags_index_specified,\n\t\t&hf_smb2_find_flags_reopen,\n\t\tNULL\n\t};\n\n\t/* buffer code */\n\toffset = dissect_smb2_buffercode(tree, tvb, offset, NULL);\n\n\til = tvb_get_guint8(tvb, offset);\n\tif (si->saved) {\n\t\tsi->saved->infolevel = il;\n\t}\n\n\t/* infolevel */\n\tproto_tree_add_uint(tree, hf_smb2_find_info_level, tvb, offset, 1, il);\n\toffset += 1;\n\n\t/* find flags */\n\tproto_tree_add_bitmask(tree, tvb, offset, hf_smb2_find_flags, ett_smb2_find_flags, f_fields, ENC_LITTLE_ENDIAN);\n\toffset += 1;\n\n\t/* file index */\n\tproto_tree_add_item(tree, hf_smb2_file_index, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\n\t/* fid */\n\toffset = dissect_smb2_fid(tvb, pinfo, tree, offset, si, FID_MODE_USE);\n\n\t/* search pattern  offset/length */\n\toffset = dissect_smb2_olb_length_offset(tvb, offset, &olb, OLB_O_UINT16_S_UINT16, hf_smb2_find_pattern);\n\n\t/* output buffer length */\n\tproto_tree_add_item(tree, hf_smb2_output_buffer_len, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\n\t/* search pattern */\n\tbuf = dissect_smb2_olb_string(pinfo, tree, tvb, &olb, OLB_TYPE_UNICODE_STRING);\n\n\toffset = dissect_smb2_olb_tvb_max_offset(offset, &olb);\n\n\tif (!pinfo->fd->flags.visited && si->saved && olb.len) {\n\t\tsi->saved->extra_info_type = SMB2_EI_FINDPATTERN;\n\t\tsi->saved->extra_info = g_malloc(olb.len+1);\n\t\tg_snprintf((char *)si->saved->extra_info,olb.len+1,\"%s\",buf);\n\t}\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \" %s Pattern: %s\",\n\t\t\tval_to_str(il, smb2_find_info_levels, \"(Level:0x%02x)\"),\n\t\t\tbuf);\n\n\treturn offset;\n}",
        "func": "static int\ndissect_smb2_find_request(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, smb2_info_t *si)\n{\n\toffset_length_buffer_t olb;\n\tconst char *buf;\n\tguint8      il;\n\tstatic const int *f_fields[] = {\n\t\t&hf_smb2_find_flags_restart_scans,\n\t\t&hf_smb2_find_flags_single_entry,\n\t\t&hf_smb2_find_flags_index_specified,\n\t\t&hf_smb2_find_flags_reopen,\n\t\tNULL\n\t};\n\n\t/* buffer code */\n\toffset = dissect_smb2_buffercode(tree, tvb, offset, NULL);\n\n\til = tvb_get_guint8(tvb, offset);\n\tif (si->saved) {\n\t\tsi->saved->infolevel = il;\n\t}\n\n\t/* infolevel */\n\tproto_tree_add_uint(tree, hf_smb2_find_info_level, tvb, offset, 1, il);\n\toffset += 1;\n\n\t/* find flags */\n\tproto_tree_add_bitmask(tree, tvb, offset, hf_smb2_find_flags, ett_smb2_find_flags, f_fields, ENC_LITTLE_ENDIAN);\n\toffset += 1;\n\n\t/* file index */\n\tproto_tree_add_item(tree, hf_smb2_file_index, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\n\t/* fid */\n\toffset = dissect_smb2_fid(tvb, pinfo, tree, offset, si, FID_MODE_USE);\n\n\t/* search pattern  offset/length */\n\toffset = dissect_smb2_olb_length_offset(tvb, offset, &olb, OLB_O_UINT16_S_UINT16, hf_smb2_find_pattern);\n\n\t/* output buffer length */\n\tproto_tree_add_item(tree, hf_smb2_output_buffer_len, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n\toffset += 4;\n\n\t/* search pattern */\n\tbuf = dissect_smb2_olb_string(pinfo, tree, tvb, &olb, OLB_TYPE_UNICODE_STRING);\n\n\toffset = dissect_smb2_olb_tvb_max_offset(offset, &olb);\n\n\tif (!pinfo->fd->flags.visited && si->saved && olb.len) {\n\t\tsi->saved->extra_info_type = SMB2_EI_FINDPATTERN;\n\t\tsi->saved->extra_info = wmem_alloc(wmem_file_scope(), olb.len+1);\n\t\tg_snprintf((char *)si->saved->extra_info,olb.len+1,\"%s\",buf);\n\t}\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \" %s Pattern: %s\",\n\t\t\tval_to_str(il, smb2_find_info_levels, \"(Level:0x%02x)\"),\n\t\t\tbuf);\n\n\treturn offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -49,7 +49,7 @@\n \n \tif (!pinfo->fd->flags.visited && si->saved && olb.len) {\n \t\tsi->saved->extra_info_type = SMB2_EI_FINDPATTERN;\n-\t\tsi->saved->extra_info = g_malloc(olb.len+1);\n+\t\tsi->saved->extra_info = wmem_alloc(wmem_file_scope(), olb.len+1);\n \t\tg_snprintf((char *)si->saved->extra_info,olb.len+1,\"%s\",buf);\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tsi->saved->extra_info = g_malloc(olb.len+1);"
            ],
            "added_lines": [
                "\t\tsi->saved->extra_info = wmem_alloc(wmem_file_scope(), olb.len+1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-9269",
        "func_name": "wireshark/get_modname_from_repoid",
        "description": "In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, epan/dissectors/packet-giop.c has a memory leak.",
        "git_url": "https://github.com/wireshark/wireshark/commit/e19aba33026212cbe000ece633adf14d109489fa",
        "commit_title": "GIOP: use wmem packet scope for get_modname_from_repoid()",
        "commit_text": " Bug: 14484 (cherry picked from commit 4581eb2de2e5aacfc9a2224df181010dc8e6141b)",
        "func_before": "static gchar * get_modname_from_repoid(gchar *repoid) {\n\n  gchar  *modname;\n  gchar   c         = 'a';\n  guint8  stop_mod  = 0;        /* Index of last character of modname in Repoid  */\n  const guint8  start_mod = 4;  /* Index where Module name starts in repoid */\n  int     i;\n\n  /* Must start with IDL: , otherwise I get confused */\n\n  if (g_ascii_strncasecmp(\"IDL:\", repoid, 4))\n    return NULL;\n\n  /* Looks like a RepoID to me, so get Module or interface name */\n\n  /* TODO -- put some code here to get Module name */\n\n  for (i=4; c != '\\0'; i++) {\n    c = repoid[i];\n    stop_mod = i;               /* save */\n    if (c == ':' )              /* delimiters */\n      break;\n\n  }\n\n  /* Now create a new string based on start and stop and \\0 */\n\n  modname = g_strndup(repoid+4, stop_mod - start_mod);\n\n  return modname;\n\n}",
        "func": "static gchar * get_modname_from_repoid(gchar *repoid) {\n\n  gchar  *modname;\n  gchar   c         = 'a';\n  guint8  stop_mod  = 0;        /* Index of last character of modname in Repoid  */\n  const guint8  start_mod = 4;  /* Index where Module name starts in repoid */\n  int     i;\n\n  /* Must start with IDL: , otherwise I get confused */\n\n  if (g_ascii_strncasecmp(\"IDL:\", repoid, 4))\n    return NULL;\n\n  /* Looks like a RepoID to me, so get Module or interface name */\n\n  /* TODO -- put some code here to get Module name */\n\n  for (i=4; c != '\\0'; i++) {\n    c = repoid[i];\n    stop_mod = i;               /* save */\n    if (c == ':' )              /* delimiters */\n      break;\n\n  }\n\n  /* Now create a new string based on start and stop and \\0 */\n\n  modname = wmem_strndup(wmem_packet_scope(), repoid+4, stop_mod - start_mod);\n\n  return modname;\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,7 +25,7 @@\n \n   /* Now create a new string based on start and stop and \\0 */\n \n-  modname = g_strndup(repoid+4, stop_mod - start_mod);\n+  modname = wmem_strndup(wmem_packet_scope(), repoid+4, stop_mod - start_mod);\n \n   return modname;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "  modname = g_strndup(repoid+4, stop_mod - start_mod);"
            ],
            "added_lines": [
                "  modname = wmem_strndup(wmem_packet_scope(), repoid+4, stop_mod - start_mod);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-9270",
        "func_name": "wireshark/oid_string2subid",
        "description": "In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, epan/oids.c has a memory leak.",
        "git_url": "https://github.com/wireshark/wireshark/commit/0fbc50f9b9219be54d6db47f04b65af19696a7c7",
        "commit_title": "oids.c: fix a memory leak in oid_string2subid()",
        "commit_text": " Bug: 14485 (cherry picked from commit f46d129f21ee0c2b43545c500a8ea4dbc4d59815)",
        "func_before": "guint oid_string2subid(wmem_allocator_t *scope, const char* str, guint32** subids_p) {\n\tconst char* r = str;\n\tguint32* subids;\n\tguint32* subids_overflow;\n\tguint n = check_num_oid(str);\n\t/*\n\t * we cannot handle sub-ids greater than 32bytes\n\t * keep a pilot subid of 64 bytes to check the limit\n\t */\n\tguint64 subid = 0;\n\n\tD(6,(\"oid_string2subid: str='%s'\",str));\n\n\tif (!n) {\n\t\t*subids_p = NULL;\n\t\treturn 0;\n\t}\n\n\t*subids_p = subids = wmem_alloc0_array(scope, guint32, n);\n\tsubids_overflow = subids + n;\n\tdo switch(*r) {\n\t\tcase '.':\n\t\t\tsubid = 0;\n\t\t\tsubids++;\n\t\t\tcontinue;\n\t\tcase '1' : case '2' : case '3' : case '4' : case '5' :\n\t\tcase '6' : case '7' : case '8' : case '9' : case '0' :\n\t\t\tsubid *= 10;\n\t\t\tsubid += *r - '0';\n\n\t\t\tif( subids >= subids_overflow ||  subid > 0xffffffff) {\n\t\t\t\t*subids_p=NULL;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t*(subids) *= 10;\n\t\t\t*(subids) += *r - '0';\n\t\t\tcontinue;\n\t\tcase '\\0':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t} while(*r++);\n\n\treturn n;\n}",
        "func": "guint oid_string2subid(wmem_allocator_t *scope, const char* str, guint32** subids_p) {\n\tconst char* r = str;\n\tguint32* subids;\n\tguint32* subids_overflow;\n\tguint n = check_num_oid(str);\n\t/*\n\t * we cannot handle sub-ids greater than 32bytes\n\t * keep a pilot subid of 64 bytes to check the limit\n\t */\n\tguint64 subid = 0;\n\n\tD(6,(\"oid_string2subid: str='%s'\",str));\n\n\tif (!n) {\n\t\t*subids_p = NULL;\n\t\treturn 0;\n\t}\n\n\t*subids_p = subids = wmem_alloc0_array(scope, guint32, n);\n\tsubids_overflow = subids + n;\n\tdo switch(*r) {\n\t\tcase '.':\n\t\t\tsubid = 0;\n\t\t\tsubids++;\n\t\t\tcontinue;\n\t\tcase '1' : case '2' : case '3' : case '4' : case '5' :\n\t\tcase '6' : case '7' : case '8' : case '9' : case '0' :\n\t\t\tsubid *= 10;\n\t\t\tsubid += *r - '0';\n\n\t\t\tif( subids >= subids_overflow ||  subid > 0xffffffff) {\n\t\t\t\twmem_free(scope, *subids_p);\n\t\t\t\t*subids_p=NULL;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t*(subids) *= 10;\n\t\t\t*(subids) += *r - '0';\n\t\t\tcontinue;\n\t\tcase '\\0':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t} while(*r++);\n\n\treturn n;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -29,6 +29,7 @@\n \t\t\tsubid += *r - '0';\n \n \t\t\tif( subids >= subids_overflow ||  subid > 0xffffffff) {\n+\t\t\t\twmem_free(scope, *subids_p);\n \t\t\t\t*subids_p=NULL;\n \t\t\t\treturn 0;\n \t\t\t}",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\t\twmem_free(scope, *subids_p);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-9271",
        "func_name": "wireshark/process_body_part",
        "description": "In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, epan/dissectors/packet-multipart.c has a memory leak.",
        "git_url": "https://github.com/wireshark/wireshark/commit/5b0228945dc74ee82d2ab4a4e7af2bdfe7b75910",
        "commit_title": "multipart: use packet scope memory to avoid leaking in case an exception is triggered by subdissectors",
        "commit_text": " Bug: 14486 (cherry picked from commit 05c4705a19448646ca316ba3b1eb333a05482956)",
        "func_before": "static gint\nprocess_body_part(proto_tree *tree, tvbuff_t *tvb,\n        http_message_info_t *input_message_info, multipart_info_t *m_info,\n        packet_info *pinfo, gint start, gint idx,\n        gboolean *last_boundary)\n{\n    proto_tree *subtree;\n    proto_item *ti;\n    gint offset = start, next_offset = 0;\n    http_message_info_t message_info = { input_message_info->type, NULL };\n    gint body_start, boundary_start, boundary_line_len;\n\n    gchar *content_type_str = NULL;\n    gchar *content_encoding_str = NULL;\n    char *filename = NULL;\n    char *mimetypename = NULL;\n    gboolean last_field = FALSE;\n    gboolean is_raw_data = FALSE;\n\n    const guint8 *boundary = (guint8 *)m_info->boundary;\n    gint boundary_len = m_info->boundary_length;\n\n    ti = proto_tree_add_item(tree, hf_multipart_part, tvb, start, 0, ENC_ASCII|ENC_NA);\n    subtree = proto_item_add_subtree(ti, ett_multipart_body);\n\n    /* find the next boundary to find the end of this body part */\n    boundary_start = find_next_boundary(tvb, offset, boundary, boundary_len,\n            &boundary_line_len, last_boundary);\n\n    if (boundary_start <= 0) {\n        return -1;\n    }\n\n    /*\n     * Process the MIME-part-headers\n     */\n\n    while (!last_field)\n    {\n        gint colon_offset;\n        char *hdr_str;\n        char *header_str;\n\n        /* Look for the end of the header (denoted by cr)\n         * 3:d argument to imf_find_field_end() maxlen; must be last offset in the tvb.\n         */\n        next_offset = imf_find_field_end(tvb, offset, tvb_reported_length_remaining(tvb, offset)+offset, &last_field);\n        /* the following should never happen */\n        /* If cr not found, won't have advanced - get out to avoid infinite loop! */\n        /*\n        if (next_offset == offset) {\n            break;\n        }\n        */\n        if (last_field && (next_offset+2) <= boundary_start) {\n            /* Add the extra CRLF of the last field */\n            next_offset += 2;\n        } else if((next_offset-2) == boundary_start) {\n            /* if CRLF is the start of next boundary it belongs to the boundary and not the field,\n               so it's the last field without CRLF */\n            last_field = TRUE;\n            next_offset -= 2;\n        } else if (next_offset > boundary_start) {\n            /* if there is no CRLF between last field and next boundary - trim it! */\n            next_offset = boundary_start;\n        }\n\n        hdr_str = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, next_offset - offset, ENC_ASCII);\n\n        header_str = unfold_and_compact_mime_header(hdr_str, &colon_offset);\n        if (colon_offset <= 0) {\n            /* if there is no colon it's no header, so break and add complete line to the body */\n            next_offset = offset;\n            break;\n        } else {\n            gint hf_index;\n\n            /* Split header name from header value */\n            header_str[colon_offset] = '\\0';\n            hf_index = is_known_multipart_header(header_str, colon_offset);\n\n            if (hf_index == -1) {\n                if(isprint_string(hdr_str)) {\n                    proto_tree_add_format_text(subtree, tvb, offset, next_offset - offset);\n                } else {\n                    /* if the header name is unkown and not printable, break and add complete line to the body */\n                    next_offset = offset;\n                    break;\n                }\n            } else {\n                char *value_str = g_strdup(header_str + colon_offset + 1);\n\n                proto_tree_add_string_format(subtree,\n                      hf_header_array[hf_index], tvb,\n                      offset, next_offset - offset,\n                      (const char *)value_str, \"%s\",\n                      tvb_format_text(tvb, offset, next_offset - offset));\n\n                switch (hf_index) {\n                    case POS_ORIGINALCONTENT:\n                        {\n                            char *semicolonp;\n                            /* The Content-Type starts at colon_offset + 1 or after the type parameter */\n                            char* type_str = ws_find_media_type_parameter(value_str, \"type\");\n                            if(type_str != NULL) {\n                                g_free(value_str);\n                                value_str = type_str;\n                            }\n\n                            semicolonp = strchr(value_str, ';');\n\n                            if (semicolonp != NULL) {\n                                *semicolonp = '\\0';\n                                m_info->orig_parameters = wmem_strdup(wmem_packet_scope(),\n                                                             semicolonp + 1);\n                            }\n\n                            m_info->orig_content_type = wmem_ascii_strdown(wmem_packet_scope(), value_str, -1);\n                        }\n                        break;\n                    case POS_CONTENT_TYPE:\n                        {\n                            /* The Content-Type starts at colon_offset + 1 */\n                            char *semicolonp = strchr(value_str, ';');\n\n                            if (semicolonp != NULL) {\n                                *semicolonp = '\\0';\n                                message_info.media_str = wmem_strdup(wmem_packet_scope(), semicolonp + 1);\n                            } else {\n                                message_info.media_str = NULL;\n                            }\n\n                            content_type_str = wmem_ascii_strdown(wmem_packet_scope(), value_str, -1);\n\n                            /* Show content-type in root 'part' label */\n                            proto_item_append_text(ti, \" (%s)\", content_type_str);\n\n                            /* find the \"name\" parameter in case we don't find a content disposition \"filename\" */\n                            mimetypename = ws_find_media_type_parameter(message_info.media_str, \"name\");\n\n                            if(strncmp(content_type_str, \"application/octet-stream\",\n                                    sizeof(\"application/octet-stream\")-1) == 0) {\n                                is_raw_data = TRUE;\n                            }\n\n                            /* there are only 2 body parts possible and each part has specific content types */\n                            if(m_info->protocol && idx == 0\n                                && (is_raw_data || g_ascii_strncasecmp(content_type_str, m_info->protocol,\n                                                        strlen(m_info->protocol)) != 0))\n                            {\n                                return -1;\n                            }\n                        }\n                        break;\n                        case POS_CONTENT_TRANSFER_ENCODING:\n                        {\n                            /* The Content-Transferring starts at colon_offset + 1 */\n                            char *crp = strchr(value_str, '\\r');\n\n                            if (crp != NULL) {\n                                *crp = '\\0';\n                            }\n\n                            content_encoding_str = wmem_ascii_strdown(wmem_packet_scope(), value_str, -1);\n                        }\n                        break;\n                        case POS_CONTENT_DISPOSITION:\n                        {\n                            /* find the \"filename\" parameter */\n                            filename = ws_find_media_type_parameter(value_str, \"filename\");\n                        }\n                        break;\n                    default:\n                        break;\n                }\n                g_free(value_str);\n            }\n        }\n        offset = next_offset;\n    }\n\n    body_start = next_offset;\n\n    /*\n     * Process the body\n     */\n\n    {\n        gint body_len = boundary_start - body_start;\n        tvbuff_t *tmp_tvb = tvb_new_subset_length(tvb, body_start, body_len);\n        /* if multipart subtype is encrypted the protcol string was set */\n        /* see: https://msdn.microsoft.com/en-us/library/cc251581.aspx */\n        /* there are only 2 body parts possible and each part has specific content types */\n        if(m_info->protocol && idx == 1 && is_raw_data)\n        {\n            gssapi_encrypt_info_t  encrypt;\n\n            memset(&encrypt, 0, sizeof(encrypt));\n            encrypt.decrypt_gssapi_tvb=DECRYPT_GSSAPI_NORMAL;\n\n            dissect_kerberos_encrypted_message(tmp_tvb, pinfo, subtree, &encrypt);\n\n            if(encrypt.gssapi_decrypted_tvb){\n                    tmp_tvb = encrypt.gssapi_decrypted_tvb;\n                    is_raw_data = FALSE;\n                    content_type_str = m_info->orig_content_type;\n                    message_info.media_str = m_info->orig_parameters;\n            } else if(encrypt.gssapi_encrypted_tvb) {\n                    tmp_tvb = encrypt.gssapi_encrypted_tvb;\n                    proto_tree_add_expert(tree, pinfo, &ei_multipart_decryption_not_possible, tmp_tvb, 0, -1);\n            }\n        }\n\n        if (!is_raw_data &&\n            content_type_str) {\n\n            /*\n             * subdissection\n             */\n            gboolean dissected;\n\n            /*\n             * Try and remove any content transfer encoding so that each sub-dissector\n             * doesn't have to do it itself\n             *\n             */\n\n            if(content_encoding_str && remove_base64_encoding) {\n\n                if(!g_ascii_strncasecmp(content_encoding_str, \"base64\", 6))\n                    tmp_tvb = base64_decode(pinfo, tmp_tvb, filename ? filename : (mimetypename ? mimetypename : content_type_str));\n\n            }\n\n            /*\n             * First try the dedicated multipart dissector table\n             */\n            dissected = dissector_try_string(multipart_media_subdissector_table,\n                        content_type_str, tmp_tvb, pinfo, subtree, &message_info);\n            if (! dissected) {\n                /*\n                 * Fall back to the default media dissector table\n                 */\n                dissected = dissector_try_string(media_type_dissector_table,\n                        content_type_str, tmp_tvb, pinfo, subtree, &message_info);\n            }\n            if (! dissected) {\n                const char *save_match_string = pinfo->match_string;\n                pinfo->match_string = content_type_str;\n                call_dissector_with_data(media_handle, tmp_tvb, pinfo, subtree, &message_info);\n                pinfo->match_string = save_match_string;\n            }\n            message_info.media_str = NULL; /* Shares same memory as content_type_str */\n        } else {\n            call_data_dissector(tmp_tvb, pinfo, subtree);\n        }\n        proto_item_set_len(ti, boundary_start - start);\n        if (*last_boundary == TRUE) {\n           proto_tree_add_item(tree, hf_multipart_last_boundary, tvb, boundary_start, boundary_line_len, ENC_NA|ENC_ASCII);\n        } else {\n           proto_tree_add_item(tree, hf_multipart_boundary, tvb, boundary_start, boundary_line_len, ENC_NA|ENC_ASCII);\n        }\n\n        g_free(filename);\n        g_free(mimetypename);\n\n        return boundary_start + boundary_line_len;\n    }\n}",
        "func": "static gint\nprocess_body_part(proto_tree *tree, tvbuff_t *tvb,\n        http_message_info_t *input_message_info, multipart_info_t *m_info,\n        packet_info *pinfo, gint start, gint idx,\n        gboolean *last_boundary)\n{\n    proto_tree *subtree;\n    proto_item *ti;\n    gint offset = start, next_offset = 0;\n    http_message_info_t message_info = { input_message_info->type, NULL };\n    gint body_start, boundary_start, boundary_line_len;\n\n    gchar *content_type_str = NULL;\n    gchar *content_encoding_str = NULL;\n    char *filename = NULL;\n    char *mimetypename = NULL;\n    char *tmp;\n    gboolean last_field = FALSE;\n    gboolean is_raw_data = FALSE;\n\n    const guint8 *boundary = (guint8 *)m_info->boundary;\n    gint boundary_len = m_info->boundary_length;\n\n    ti = proto_tree_add_item(tree, hf_multipart_part, tvb, start, 0, ENC_ASCII|ENC_NA);\n    subtree = proto_item_add_subtree(ti, ett_multipart_body);\n\n    /* find the next boundary to find the end of this body part */\n    boundary_start = find_next_boundary(tvb, offset, boundary, boundary_len,\n            &boundary_line_len, last_boundary);\n\n    if (boundary_start <= 0) {\n        return -1;\n    }\n\n    /*\n     * Process the MIME-part-headers\n     */\n\n    while (!last_field)\n    {\n        gint colon_offset;\n        char *hdr_str;\n        char *header_str;\n\n        /* Look for the end of the header (denoted by cr)\n         * 3:d argument to imf_find_field_end() maxlen; must be last offset in the tvb.\n         */\n        next_offset = imf_find_field_end(tvb, offset, tvb_reported_length_remaining(tvb, offset)+offset, &last_field);\n        /* the following should never happen */\n        /* If cr not found, won't have advanced - get out to avoid infinite loop! */\n        /*\n        if (next_offset == offset) {\n            break;\n        }\n        */\n        if (last_field && (next_offset+2) <= boundary_start) {\n            /* Add the extra CRLF of the last field */\n            next_offset += 2;\n        } else if((next_offset-2) == boundary_start) {\n            /* if CRLF is the start of next boundary it belongs to the boundary and not the field,\n               so it's the last field without CRLF */\n            last_field = TRUE;\n            next_offset -= 2;\n        } else if (next_offset > boundary_start) {\n            /* if there is no CRLF between last field and next boundary - trim it! */\n            next_offset = boundary_start;\n        }\n\n        hdr_str = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, next_offset - offset, ENC_ASCII);\n\n        header_str = unfold_and_compact_mime_header(hdr_str, &colon_offset);\n        if (colon_offset <= 0) {\n            /* if there is no colon it's no header, so break and add complete line to the body */\n            next_offset = offset;\n            break;\n        } else {\n            gint hf_index;\n\n            /* Split header name from header value */\n            header_str[colon_offset] = '\\0';\n            hf_index = is_known_multipart_header(header_str, colon_offset);\n\n            if (hf_index == -1) {\n                if(isprint_string(hdr_str)) {\n                    proto_tree_add_format_text(subtree, tvb, offset, next_offset - offset);\n                } else {\n                    /* if the header name is unkown and not printable, break and add complete line to the body */\n                    next_offset = offset;\n                    break;\n                }\n            } else {\n                char *value_str = g_strdup(header_str + colon_offset + 1);\n\n                proto_tree_add_string_format(subtree,\n                      hf_header_array[hf_index], tvb,\n                      offset, next_offset - offset,\n                      (const char *)value_str, \"%s\",\n                      tvb_format_text(tvb, offset, next_offset - offset));\n\n                switch (hf_index) {\n                    case POS_ORIGINALCONTENT:\n                        {\n                            char *semicolonp;\n                            /* The Content-Type starts at colon_offset + 1 or after the type parameter */\n                            char* type_str = ws_find_media_type_parameter(value_str, \"type\");\n                            if(type_str != NULL) {\n                                g_free(value_str);\n                                value_str = type_str;\n                            }\n\n                            semicolonp = strchr(value_str, ';');\n\n                            if (semicolonp != NULL) {\n                                *semicolonp = '\\0';\n                                m_info->orig_parameters = wmem_strdup(wmem_packet_scope(),\n                                                             semicolonp + 1);\n                            }\n\n                            m_info->orig_content_type = wmem_ascii_strdown(wmem_packet_scope(), value_str, -1);\n                        }\n                        break;\n                    case POS_CONTENT_TYPE:\n                        {\n                            /* The Content-Type starts at colon_offset + 1 */\n                            char *semicolonp = strchr(value_str, ';');\n\n                            if (semicolonp != NULL) {\n                                *semicolonp = '\\0';\n                                message_info.media_str = wmem_strdup(wmem_packet_scope(), semicolonp + 1);\n                            } else {\n                                message_info.media_str = NULL;\n                            }\n\n                            content_type_str = wmem_ascii_strdown(wmem_packet_scope(), value_str, -1);\n\n                            /* Show content-type in root 'part' label */\n                            proto_item_append_text(ti, \" (%s)\", content_type_str);\n\n                            /* find the \"name\" parameter in case we don't find a content disposition \"filename\" */\n                            tmp = ws_find_media_type_parameter(message_info.media_str, \"name\");\n                            if (tmp) {\n                                mimetypename = wmem_strdup(wmem_packet_scope(), tmp);\n                                g_free(tmp);\n                            }\n\n                            if(strncmp(content_type_str, \"application/octet-stream\",\n                                    sizeof(\"application/octet-stream\")-1) == 0) {\n                                is_raw_data = TRUE;\n                            }\n\n                            /* there are only 2 body parts possible and each part has specific content types */\n                            if(m_info->protocol && idx == 0\n                                && (is_raw_data || g_ascii_strncasecmp(content_type_str, m_info->protocol,\n                                                        strlen(m_info->protocol)) != 0))\n                            {\n                                return -1;\n                            }\n                        }\n                        break;\n                        case POS_CONTENT_TRANSFER_ENCODING:\n                        {\n                            /* The Content-Transferring starts at colon_offset + 1 */\n                            char *crp = strchr(value_str, '\\r');\n\n                            if (crp != NULL) {\n                                *crp = '\\0';\n                            }\n\n                            content_encoding_str = wmem_ascii_strdown(wmem_packet_scope(), value_str, -1);\n                        }\n                        break;\n                        case POS_CONTENT_DISPOSITION:\n                        {\n                            /* find the \"filename\" parameter */\n                            tmp = ws_find_media_type_parameter(value_str, \"filename\");\n                            if (tmp) {\n                                filename = wmem_strdup(wmem_packet_scope(), tmp);\n                                g_free(tmp);\n                            }\n                        }\n                        break;\n                    default:\n                        break;\n                }\n                g_free(value_str);\n            }\n        }\n        offset = next_offset;\n    }\n\n    body_start = next_offset;\n\n    /*\n     * Process the body\n     */\n\n    {\n        gint body_len = boundary_start - body_start;\n        tvbuff_t *tmp_tvb = tvb_new_subset_length(tvb, body_start, body_len);\n        /* if multipart subtype is encrypted the protcol string was set */\n        /* see: https://msdn.microsoft.com/en-us/library/cc251581.aspx */\n        /* there are only 2 body parts possible and each part has specific content types */\n        if(m_info->protocol && idx == 1 && is_raw_data)\n        {\n            gssapi_encrypt_info_t  encrypt;\n\n            memset(&encrypt, 0, sizeof(encrypt));\n            encrypt.decrypt_gssapi_tvb=DECRYPT_GSSAPI_NORMAL;\n\n            dissect_kerberos_encrypted_message(tmp_tvb, pinfo, subtree, &encrypt);\n\n            if(encrypt.gssapi_decrypted_tvb){\n                    tmp_tvb = encrypt.gssapi_decrypted_tvb;\n                    is_raw_data = FALSE;\n                    content_type_str = m_info->orig_content_type;\n                    message_info.media_str = m_info->orig_parameters;\n            } else if(encrypt.gssapi_encrypted_tvb) {\n                    tmp_tvb = encrypt.gssapi_encrypted_tvb;\n                    proto_tree_add_expert(tree, pinfo, &ei_multipart_decryption_not_possible, tmp_tvb, 0, -1);\n            }\n        }\n\n        if (!is_raw_data &&\n            content_type_str) {\n\n            /*\n             * subdissection\n             */\n            gboolean dissected;\n\n            /*\n             * Try and remove any content transfer encoding so that each sub-dissector\n             * doesn't have to do it itself\n             *\n             */\n\n            if(content_encoding_str && remove_base64_encoding) {\n\n                if(!g_ascii_strncasecmp(content_encoding_str, \"base64\", 6))\n                    tmp_tvb = base64_decode(pinfo, tmp_tvb, filename ? filename : (mimetypename ? mimetypename : content_type_str));\n\n            }\n\n            /*\n             * First try the dedicated multipart dissector table\n             */\n            dissected = dissector_try_string(multipart_media_subdissector_table,\n                        content_type_str, tmp_tvb, pinfo, subtree, &message_info);\n            if (! dissected) {\n                /*\n                 * Fall back to the default media dissector table\n                 */\n                dissected = dissector_try_string(media_type_dissector_table,\n                        content_type_str, tmp_tvb, pinfo, subtree, &message_info);\n            }\n            if (! dissected) {\n                const char *save_match_string = pinfo->match_string;\n                pinfo->match_string = content_type_str;\n                call_dissector_with_data(media_handle, tmp_tvb, pinfo, subtree, &message_info);\n                pinfo->match_string = save_match_string;\n            }\n            message_info.media_str = NULL; /* Shares same memory as content_type_str */\n        } else {\n            call_data_dissector(tmp_tvb, pinfo, subtree);\n        }\n        proto_item_set_len(ti, boundary_start - start);\n        if (*last_boundary == TRUE) {\n           proto_tree_add_item(tree, hf_multipart_last_boundary, tvb, boundary_start, boundary_line_len, ENC_NA|ENC_ASCII);\n        } else {\n           proto_tree_add_item(tree, hf_multipart_boundary, tvb, boundary_start, boundary_line_len, ENC_NA|ENC_ASCII);\n        }\n\n        return boundary_start + boundary_line_len;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,7 @@\n     gchar *content_encoding_str = NULL;\n     char *filename = NULL;\n     char *mimetypename = NULL;\n+    char *tmp;\n     gboolean last_field = FALSE;\n     gboolean is_raw_data = FALSE;\n \n@@ -136,7 +137,11 @@\n                             proto_item_append_text(ti, \" (%s)\", content_type_str);\n \n                             /* find the \"name\" parameter in case we don't find a content disposition \"filename\" */\n-                            mimetypename = ws_find_media_type_parameter(message_info.media_str, \"name\");\n+                            tmp = ws_find_media_type_parameter(message_info.media_str, \"name\");\n+                            if (tmp) {\n+                                mimetypename = wmem_strdup(wmem_packet_scope(), tmp);\n+                                g_free(tmp);\n+                            }\n \n                             if(strncmp(content_type_str, \"application/octet-stream\",\n                                     sizeof(\"application/octet-stream\")-1) == 0) {\n@@ -167,7 +172,11 @@\n                         case POS_CONTENT_DISPOSITION:\n                         {\n                             /* find the \"filename\" parameter */\n-                            filename = ws_find_media_type_parameter(value_str, \"filename\");\n+                            tmp = ws_find_media_type_parameter(value_str, \"filename\");\n+                            if (tmp) {\n+                                filename = wmem_strdup(wmem_packet_scope(), tmp);\n+                                g_free(tmp);\n+                            }\n                         }\n                         break;\n                     default:\n@@ -261,9 +270,6 @@\n            proto_tree_add_item(tree, hf_multipart_boundary, tvb, boundary_start, boundary_line_len, ENC_NA|ENC_ASCII);\n         }\n \n-        g_free(filename);\n-        g_free(mimetypename);\n-\n         return boundary_start + boundary_line_len;\n     }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "                            mimetypename = ws_find_media_type_parameter(message_info.media_str, \"name\");",
                "                            filename = ws_find_media_type_parameter(value_str, \"filename\");",
                "        g_free(filename);",
                "        g_free(mimetypename);",
                ""
            ],
            "added_lines": [
                "    char *tmp;",
                "                            tmp = ws_find_media_type_parameter(message_info.media_str, \"name\");",
                "                            if (tmp) {",
                "                                mimetypename = wmem_strdup(wmem_packet_scope(), tmp);",
                "                                g_free(tmp);",
                "                            }",
                "                            tmp = ws_find_media_type_parameter(value_str, \"filename\");",
                "                            if (tmp) {",
                "                                filename = wmem_strdup(wmem_packet_scope(), tmp);",
                "                                g_free(tmp);",
                "                            }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-9272",
        "func_name": "wireshark/find_or_create_call_info_conv",
        "description": "In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, epan/dissectors/packet-h223.c has a memory leak.",
        "git_url": "https://github.com/wireshark/wireshark/commit/6e3b90824a82724f445a0374e99f0b76e4cf5e8b",
        "commit_title": "H223: fix a memory leak in conversation management",
        "commit_text": " Bug: 14487 (cherry picked from commit 8f81eb2cf671573461ccba3bde6ce5ec99016afa)",
        "func_before": "static h223_call_info *\nfind_or_create_call_info_conv(packet_info * pinfo)\n{\n    h223_call_info *datax;\n    conversation_t *conv;\n\n    /* assume we're running atop TCP or RTP; use the conversation support */\n    conv = find_conversation( pinfo->num,\n                              &pinfo->src,&pinfo->dst,\n                              pinfo->ptype,\n                              pinfo->srcport,pinfo->destport, 0 );\n\n    /* both RTP and TCP track their conversations, so just assert here if\n     * we can't find one */\n    DISSECTOR_ASSERT(conv);\n\n    datax = (h223_call_info *)conversation_get_proto_data(conv, proto_h223);\n\n    if(datax == NULL && pinfo->ptype == PT_UDP ) {\n        conversation_t *conv2;\n\n        /* RTP tracks the two sides of the conversation totally separately;\n         * this messes us up totally.\n         *\n         * Look for another converstation, going in the opposite direction.\n         */\n        conv2 = find_conversation( pinfo->num,\n                                  &pinfo->dst,&pinfo->src,\n                                  pinfo->ptype,\n                                  pinfo->destport,pinfo->srcport, 0 );\n        if(conv2 != NULL)\n            datax = (h223_call_info *)conversation_get_proto_data(conv2, proto_h223);\n\n        if(datax != NULL) {\n#ifdef DEBUG_H223\n            g_debug(\"%u: Identified conv %p as reverse of conv %p with call %p and type=%u src=%u.%u.%u.%u:%u dst=%u.%u.%u.%u:%u\",\n                    pinfo->num, conv, conv2, datax, pinfo->ptype,\n                    pinfo->dst.data[0], pinfo->dst.data[1], pinfo->dst.data[2], pinfo->dst.data[3],\n                    pinfo->destport,\n                    pinfo->src.data[0], pinfo->src.data[1], pinfo->src.data[2], pinfo->src.data[3],\n                    pinfo->srcport);\n#endif\n            conversation_add_proto_data(conv, proto_h223, datax);\n        }\n    }\n\n    /* we still haven't found any call data - create a new one for this\n     * conversation */\n    if(datax == NULL) {\n        datax = create_call_info(pinfo->num);\n\n#ifdef DEBUG_H223\n        g_debug(\"%u: Created new call %p for conv %p type=%u src=%u.%u.%u.%u:%u dst=%u.%u.%u.%u:%u\",\n                pinfo->num, datax, conv, pinfo->ptype,\n                pinfo->src.data[0], pinfo->src.data[1], pinfo->src.data[2], pinfo->src.data[3],\n                pinfo->srcport,\n                pinfo->dst.data[0], pinfo->dst.data[1], pinfo->dst.data[2], pinfo->dst.data[3],\n                pinfo->destport);\n#endif\n\n        conversation_add_proto_data(conv, proto_h223, datax);\n        /* add the source details so we can distinguish directions\n         * in future */\n        copy_address(&(datax -> srcaddress), &(pinfo->src));\n        datax -> srcport = pinfo->srcport;\n    }\n\n    /* work out what direction we're really going in */\n    if( addresses_equal( &(pinfo->src), &(datax->srcaddress))\n        && pinfo->srcport == datax->srcport )\n        pinfo->p2p_dir = P2P_DIR_SENT;\n    else\n        pinfo->p2p_dir = P2P_DIR_RECV;\n\n    return datax;\n}",
        "func": "static h223_call_info *\nfind_or_create_call_info_conv(packet_info * pinfo)\n{\n    h223_call_info *datax;\n    conversation_t *conv;\n\n    /* assume we're running atop TCP or RTP; use the conversation support */\n    conv = find_conversation( pinfo->num,\n                              &pinfo->src,&pinfo->dst,\n                              pinfo->ptype,\n                              pinfo->srcport,pinfo->destport, 0 );\n\n    /* both RTP and TCP track their conversations, so just assert here if\n     * we can't find one */\n    DISSECTOR_ASSERT(conv);\n\n    datax = (h223_call_info *)conversation_get_proto_data(conv, proto_h223);\n\n    if(datax == NULL && pinfo->ptype == PT_UDP ) {\n        conversation_t *conv2;\n\n        /* RTP tracks the two sides of the conversation totally separately;\n         * this messes us up totally.\n         *\n         * Look for another converstation, going in the opposite direction.\n         */\n        conv2 = find_conversation( pinfo->num,\n                                  &pinfo->dst,&pinfo->src,\n                                  pinfo->ptype,\n                                  pinfo->destport,pinfo->srcport, 0 );\n        if(conv2 != NULL)\n            datax = (h223_call_info *)conversation_get_proto_data(conv2, proto_h223);\n\n        if(datax != NULL) {\n#ifdef DEBUG_H223\n            g_debug(\"%u: Identified conv %p as reverse of conv %p with call %p and type=%u src=%u.%u.%u.%u:%u dst=%u.%u.%u.%u:%u\",\n                    pinfo->num, conv, conv2, datax, pinfo->ptype,\n                    pinfo->dst.data[0], pinfo->dst.data[1], pinfo->dst.data[2], pinfo->dst.data[3],\n                    pinfo->destport,\n                    pinfo->src.data[0], pinfo->src.data[1], pinfo->src.data[2], pinfo->src.data[3],\n                    pinfo->srcport);\n#endif\n            conversation_add_proto_data(conv, proto_h223, datax);\n        }\n    }\n\n    /* we still haven't found any call data - create a new one for this\n     * conversation */\n    if(datax == NULL) {\n        datax = create_call_info(pinfo->num);\n\n#ifdef DEBUG_H223\n        g_debug(\"%u: Created new call %p for conv %p type=%u src=%u.%u.%u.%u:%u dst=%u.%u.%u.%u:%u\",\n                pinfo->num, datax, conv, pinfo->ptype,\n                pinfo->src.data[0], pinfo->src.data[1], pinfo->src.data[2], pinfo->src.data[3],\n                pinfo->srcport,\n                pinfo->dst.data[0], pinfo->dst.data[1], pinfo->dst.data[2], pinfo->dst.data[3],\n                pinfo->destport);\n#endif\n\n        conversation_add_proto_data(conv, proto_h223, datax);\n        /* add the source details so we can distinguish directions\n         * in future */\n        copy_address_wmem(wmem_file_scope(), &(datax -> srcaddress), &(pinfo->src));\n        datax -> srcport = pinfo->srcport;\n    }\n\n    /* work out what direction we're really going in */\n    if( addresses_equal( &(pinfo->src), &(datax->srcaddress))\n        && pinfo->srcport == datax->srcport )\n        pinfo->p2p_dir = P2P_DIR_SENT;\n    else\n        pinfo->p2p_dir = P2P_DIR_RECV;\n\n    return datax;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -61,7 +61,7 @@\n         conversation_add_proto_data(conv, proto_h223, datax);\n         /* add the source details so we can distinguish directions\n          * in future */\n-        copy_address(&(datax -> srcaddress), &(pinfo->src));\n+        copy_address_wmem(wmem_file_scope(), &(datax -> srcaddress), &(pinfo->src));\n         datax -> srcport = pinfo->srcport;\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "        copy_address(&(datax -> srcaddress), &(pinfo->src));"
            ],
            "added_lines": [
                "        copy_address_wmem(wmem_file_scope(), &(datax -> srcaddress), &(pinfo->src));"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-9273",
        "func_name": "wireshark/dissect_pcp_message",
        "description": "In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, epan/dissectors/packet-pcp.c has a memory leak.",
        "git_url": "https://github.com/wireshark/wireshark/commit/1f8f1456f1e73b6c09e50a64749e43413ac12df7",
        "commit_title": "PCP: allocate conversation info in file scope",
        "commit_text": " Bug: 14488 (cherry picked from commit 035f49d2c85ff9e0bab74e5af4c990ab2beea170)",
        "func_before": "static int dissect_pcp_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n{\n    proto_item *root_pcp_item;\n    proto_tree *pcp_tree;\n    conversation_t  *conversation;\n    pcp_conv_info_t *pcp_conv_info;\n    guint32     packet_type;\n    gint32      err_bytes;\n    int         offset = 0;\n\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"PCP\");\n    col_clear(pinfo->cinfo, COL_INFO);\n\n\n    conversation = find_or_create_conversation(pinfo);\n\n    pcp_conv_info = (pcp_conv_info_t*)conversation_get_proto_data(conversation, proto_pcp);\n\n    if(pcp_conv_info == NULL) {\n        pcp_conv_info = (pcp_conv_info_t*)g_malloc(sizeof(pcp_conv_info_t));\n        conversation_add_proto_data(conversation, proto_pcp, pcp_conv_info);\n\n        pcp_conv_info->pmid_name_candidates = wmem_array_new(wmem_file_scope(), sizeof(guint8 *));\n        pcp_conv_info->pmid_to_name = wmem_map_new(wmem_file_scope(), g_direct_hash, g_direct_equal);\n        pcp_conv_info->last_pmns_names_frame = 0;\n        pcp_conv_info->last_processed_pmns_names_frame = 0;\n    }\n\n    root_pcp_item = proto_tree_add_item(tree, proto_pcp, tvb, 0, -1, ENC_NA);\n    pcp_tree      = proto_item_add_subtree(root_pcp_item, ett_pcp);\n\n    packet_type   = tvb_get_ntohl(tvb, 4);\n\n    /* check if we are the client requesting or the server */\n    if (pinfo->srcport == PCP_PORT || pinfo->srcport == PMPROXY_PORT) {\n        col_set_str(pinfo->cinfo, COL_INFO, \"Server > Client \");\n    } else {\n        col_set_str(pinfo->cinfo, COL_INFO, \"Client > Server \");\n    }\n\n    /* PCP packet length */\n    proto_tree_add_item(pcp_tree, hf_pcp_pdu_length, tvb, offset, 4, ENC_BIG_ENDIAN);\n    offset += 4;\n    /* PCP Packet type */\n    proto_tree_add_item(pcp_tree, hf_pcp_pdu_type,   tvb, offset, 4, ENC_BIG_ENDIAN);\n    offset += 4;\n    /* PCP Remote PID */\n    proto_tree_add_item(pcp_tree, hf_pcp_pdu_pid,    tvb, offset, 4, ENC_BIG_ENDIAN);\n    offset += 4;\n\n    /* dissect the rest of the packet depending on the type */\n    switch (packet_type) {\n        case PCP_PDU_CREDS:\n            dissect_pcp_message_creds(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        case PCP_PDU_START_OR_ERROR:\n            err_bytes = tvb_get_ntohl(tvb, offset); /* get the first 4 bytes, determine if this is an error or not */\n            /* errors are signed and are all negative so check for a negative number.\n               It's the only way we can differentiate between start/error packets */\n            if (err_bytes < 0) {\n                dissect_pcp_message_error(tvb, pinfo, pcp_tree, offset);\n            } else {\n                dissect_pcp_message_start(tvb, pinfo, pcp_tree, offset);\n            }\n            break;\n\n        case PCP_PDU_PMNS_TRAVERSE:\n            dissect_pcp_message_pmns_traverse(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        case PCP_PDU_PMNS_NAMES:\n            dissect_pcp_message_pmns_names(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        case PCP_PDU_PMNS_CHILD:\n            dissect_pcp_message_pmns_child(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        case PCP_PDU_PMNS_IDS:\n            dissect_pcp_message_pmns_ids(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        case PCP_PDU_PROFILE:\n            dissect_pcp_message_profile(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        case PCP_PDU_FETCH:\n            dissect_pcp_message_fetch(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        case PCP_PDU_RESULT:\n            dissect_pcp_message_result(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        case PCP_PDU_DESC_REQ:\n            dissect_pcp_message_desc_req(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        case PCP_PDU_DESC:\n            dissect_pcp_message_desc(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        case PCP_PDU_INSTANCE_REQ:\n            dissect_pcp_message_instance_req(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        case PCP_PDU_INSTANCE:\n            dissect_pcp_message_instance(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        case PCP_PDU_TEXT_REQ:\n            dissect_pcp_message_text_req(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        case PCP_PDU_TEXT:\n            dissect_pcp_message_text(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        case PCP_PDU_USER_AUTH:\n            dissect_pcp_message_user_auth(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        default:\n            /* append the type of packet */\n            col_append_str(pinfo->cinfo, COL_INFO, \"[UNIMPLEMENTED TYPE]\");\n            /* if we got here, then we didn't get a packet type that we know of */\n            expert_add_info(pinfo, pcp_tree, &ei_pcp_unimplemented_packet_type);\n            break;\n    }\n    return tvb_captured_length(tvb);\n}",
        "func": "static int dissect_pcp_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n{\n    proto_item *root_pcp_item;\n    proto_tree *pcp_tree;\n    conversation_t  *conversation;\n    pcp_conv_info_t *pcp_conv_info;\n    guint32     packet_type;\n    gint32      err_bytes;\n    int         offset = 0;\n\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"PCP\");\n    col_clear(pinfo->cinfo, COL_INFO);\n\n\n    conversation = find_or_create_conversation(pinfo);\n\n    pcp_conv_info = (pcp_conv_info_t*)conversation_get_proto_data(conversation, proto_pcp);\n\n    if(pcp_conv_info == NULL) {\n        pcp_conv_info = (pcp_conv_info_t*)wmem_alloc(wmem_file_scope(), sizeof(pcp_conv_info_t));\n        conversation_add_proto_data(conversation, proto_pcp, pcp_conv_info);\n\n        pcp_conv_info->pmid_name_candidates = wmem_array_new(wmem_file_scope(), sizeof(guint8 *));\n        pcp_conv_info->pmid_to_name = wmem_map_new(wmem_file_scope(), g_direct_hash, g_direct_equal);\n        pcp_conv_info->last_pmns_names_frame = 0;\n        pcp_conv_info->last_processed_pmns_names_frame = 0;\n    }\n\n    root_pcp_item = proto_tree_add_item(tree, proto_pcp, tvb, 0, -1, ENC_NA);\n    pcp_tree      = proto_item_add_subtree(root_pcp_item, ett_pcp);\n\n    packet_type   = tvb_get_ntohl(tvb, 4);\n\n    /* check if we are the client requesting or the server */\n    if (pinfo->srcport == PCP_PORT || pinfo->srcport == PMPROXY_PORT) {\n        col_set_str(pinfo->cinfo, COL_INFO, \"Server > Client \");\n    } else {\n        col_set_str(pinfo->cinfo, COL_INFO, \"Client > Server \");\n    }\n\n    /* PCP packet length */\n    proto_tree_add_item(pcp_tree, hf_pcp_pdu_length, tvb, offset, 4, ENC_BIG_ENDIAN);\n    offset += 4;\n    /* PCP Packet type */\n    proto_tree_add_item(pcp_tree, hf_pcp_pdu_type,   tvb, offset, 4, ENC_BIG_ENDIAN);\n    offset += 4;\n    /* PCP Remote PID */\n    proto_tree_add_item(pcp_tree, hf_pcp_pdu_pid,    tvb, offset, 4, ENC_BIG_ENDIAN);\n    offset += 4;\n\n    /* dissect the rest of the packet depending on the type */\n    switch (packet_type) {\n        case PCP_PDU_CREDS:\n            dissect_pcp_message_creds(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        case PCP_PDU_START_OR_ERROR:\n            err_bytes = tvb_get_ntohl(tvb, offset); /* get the first 4 bytes, determine if this is an error or not */\n            /* errors are signed and are all negative so check for a negative number.\n               It's the only way we can differentiate between start/error packets */\n            if (err_bytes < 0) {\n                dissect_pcp_message_error(tvb, pinfo, pcp_tree, offset);\n            } else {\n                dissect_pcp_message_start(tvb, pinfo, pcp_tree, offset);\n            }\n            break;\n\n        case PCP_PDU_PMNS_TRAVERSE:\n            dissect_pcp_message_pmns_traverse(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        case PCP_PDU_PMNS_NAMES:\n            dissect_pcp_message_pmns_names(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        case PCP_PDU_PMNS_CHILD:\n            dissect_pcp_message_pmns_child(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        case PCP_PDU_PMNS_IDS:\n            dissect_pcp_message_pmns_ids(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        case PCP_PDU_PROFILE:\n            dissect_pcp_message_profile(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        case PCP_PDU_FETCH:\n            dissect_pcp_message_fetch(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        case PCP_PDU_RESULT:\n            dissect_pcp_message_result(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        case PCP_PDU_DESC_REQ:\n            dissect_pcp_message_desc_req(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        case PCP_PDU_DESC:\n            dissect_pcp_message_desc(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        case PCP_PDU_INSTANCE_REQ:\n            dissect_pcp_message_instance_req(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        case PCP_PDU_INSTANCE:\n            dissect_pcp_message_instance(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        case PCP_PDU_TEXT_REQ:\n            dissect_pcp_message_text_req(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        case PCP_PDU_TEXT:\n            dissect_pcp_message_text(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        case PCP_PDU_USER_AUTH:\n            dissect_pcp_message_user_auth(tvb, pinfo, pcp_tree, offset);\n            break;\n\n        default:\n            /* append the type of packet */\n            col_append_str(pinfo->cinfo, COL_INFO, \"[UNIMPLEMENTED TYPE]\");\n            /* if we got here, then we didn't get a packet type that we know of */\n            expert_add_info(pinfo, pcp_tree, &ei_pcp_unimplemented_packet_type);\n            break;\n    }\n    return tvb_captured_length(tvb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n     pcp_conv_info = (pcp_conv_info_t*)conversation_get_proto_data(conversation, proto_pcp);\n \n     if(pcp_conv_info == NULL) {\n-        pcp_conv_info = (pcp_conv_info_t*)g_malloc(sizeof(pcp_conv_info_t));\n+        pcp_conv_info = (pcp_conv_info_t*)wmem_alloc(wmem_file_scope(), sizeof(pcp_conv_info_t));\n         conversation_add_proto_data(conversation, proto_pcp, pcp_conv_info);\n \n         pcp_conv_info->pmid_name_candidates = wmem_array_new(wmem_file_scope(), sizeof(guint8 *));",
        "diff_line_info": {
            "deleted_lines": [
                "        pcp_conv_info = (pcp_conv_info_t*)g_malloc(sizeof(pcp_conv_info_t));"
            ],
            "added_lines": [
                "        pcp_conv_info = (pcp_conv_info_t*)wmem_alloc(wmem_file_scope(), sizeof(pcp_conv_info_t));"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-9274",
        "func_name": "wireshark/cfile_open_failure_message",
        "description": "In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, ui/failure_message.c has a memory leak.",
        "git_url": "https://github.com/wireshark/wireshark/commit/211845aba4794720ae265c782cdffddae54a3e7a",
        "commit_title": "failure_message.c: fix a memory leak if err is not negative",
        "commit_text": " Bug: 14489 (cherry picked from commit b94d3af3039b8bdfbd4d760fda412fdfa121b732)",
        "func_before": "void\ncfile_open_failure_message(const char *progname, const char *filename,\n                           int err, gchar *err_info)\n{\n    char *file_description;\n\n    /* Get a string that describes what we're opening */\n    file_description = input_file_description(filename);\n\n    if (err < 0) {\n        /* Wiretap error. */\n        switch (err) {\n\n        case WTAP_ERR_NOT_REGULAR_FILE:\n            cmdarg_err(\"The %s is a \\\"special file\\\" or socket or other non-regular file.\",\n                       file_description);\n            break;\n\n        case WTAP_ERR_RANDOM_OPEN_PIPE:\n            cmdarg_err(\"The %s is a pipe or FIFO; %s can't read pipe or FIFO files in two-pass mode.\",\n                       file_description, progname);\n            break;\n\n        case WTAP_ERR_FILE_UNKNOWN_FORMAT:\n            cmdarg_err(\"The %s isn't a capture file in a format %s understands.\",\n                       file_description, progname);\n            break;\n\n        case WTAP_ERR_UNSUPPORTED:\n            cmdarg_err(\"The %s contains record data that %s doesn't support.\\n\"\n                       \"(%s)\",\n                       file_description, progname,\n                       err_info != NULL ? err_info : \"no information supplied\");\n            g_free(err_info);\n            break;\n\n        case WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED:\n            cmdarg_err(\"The %s is a capture for a network type that %s doesn't support.\",\n                       file_description, progname);\n            break;\n\n        case WTAP_ERR_BAD_FILE:\n            cmdarg_err(\"The %s appears to be damaged or corrupt.\\n\"\n                       \"(%s)\",\n                       file_description,\n                       err_info != NULL ? err_info : \"no information supplied\");\n            g_free(err_info);\n            break;\n\n        case WTAP_ERR_CANT_OPEN:\n            cmdarg_err(\"The %s could not be opened for some unknown reason.\",\n                       file_description);\n            break;\n\n        case WTAP_ERR_SHORT_READ:\n            cmdarg_err(\"The %s appears to have been cut short in the middle of a packet or other data.\",\n                       file_description);\n            break;\n\n        case WTAP_ERR_DECOMPRESS:\n            cmdarg_err(\"The %s cannot be decompressed; it may be damaged or corrupt.\"\n                       \"(%s)\",\n                       file_description,\n                       err_info != NULL ? err_info : \"no information supplied\");\n            g_free(err_info);\n            break;\n\n        default:\n            cmdarg_err(\"The %s could not be opened: %s.\",\n                       file_description,\n                       wtap_strerror(err));\n            break;\n        }\n        g_free(file_description);\n    } else\n        cmdarg_err(file_open_error_message(err, FALSE), filename);\n}",
        "func": "void\ncfile_open_failure_message(const char *progname, const char *filename,\n                           int err, gchar *err_info)\n{\n    if (err < 0) {\n        /* Get a string that describes what we're opening */\n        char *file_description = input_file_description(filename);\n\n        /* Wiretap error. */\n        switch (err) {\n\n        case WTAP_ERR_NOT_REGULAR_FILE:\n            cmdarg_err(\"The %s is a \\\"special file\\\" or socket or other non-regular file.\",\n                       file_description);\n            break;\n\n        case WTAP_ERR_RANDOM_OPEN_PIPE:\n            cmdarg_err(\"The %s is a pipe or FIFO; %s can't read pipe or FIFO files in two-pass mode.\",\n                       file_description, progname);\n            break;\n\n        case WTAP_ERR_FILE_UNKNOWN_FORMAT:\n            cmdarg_err(\"The %s isn't a capture file in a format %s understands.\",\n                       file_description, progname);\n            break;\n\n        case WTAP_ERR_UNSUPPORTED:\n            cmdarg_err(\"The %s contains record data that %s doesn't support.\\n\"\n                       \"(%s)\",\n                       file_description, progname,\n                       err_info != NULL ? err_info : \"no information supplied\");\n            g_free(err_info);\n            break;\n\n        case WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED:\n            cmdarg_err(\"The %s is a capture for a network type that %s doesn't support.\",\n                       file_description, progname);\n            break;\n\n        case WTAP_ERR_BAD_FILE:\n            cmdarg_err(\"The %s appears to be damaged or corrupt.\\n\"\n                       \"(%s)\",\n                       file_description,\n                       err_info != NULL ? err_info : \"no information supplied\");\n            g_free(err_info);\n            break;\n\n        case WTAP_ERR_CANT_OPEN:\n            cmdarg_err(\"The %s could not be opened for some unknown reason.\",\n                       file_description);\n            break;\n\n        case WTAP_ERR_SHORT_READ:\n            cmdarg_err(\"The %s appears to have been cut short in the middle of a packet or other data.\",\n                       file_description);\n            break;\n\n        case WTAP_ERR_DECOMPRESS:\n            cmdarg_err(\"The %s cannot be decompressed; it may be damaged or corrupt.\"\n                       \"(%s)\",\n                       file_description,\n                       err_info != NULL ? err_info : \"no information supplied\");\n            g_free(err_info);\n            break;\n\n        default:\n            cmdarg_err(\"The %s could not be opened: %s.\",\n                       file_description,\n                       wtap_strerror(err));\n            break;\n        }\n        g_free(file_description);\n    } else\n        cmdarg_err(file_open_error_message(err, FALSE), filename);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,12 +2,10 @@\n cfile_open_failure_message(const char *progname, const char *filename,\n                            int err, gchar *err_info)\n {\n-    char *file_description;\n+    if (err < 0) {\n+        /* Get a string that describes what we're opening */\n+        char *file_description = input_file_description(filename);\n \n-    /* Get a string that describes what we're opening */\n-    file_description = input_file_description(filename);\n-\n-    if (err < 0) {\n         /* Wiretap error. */\n         switch (err) {\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    char *file_description;",
                "    /* Get a string that describes what we're opening */",
                "    file_description = input_file_description(filename);",
                "",
                "    if (err < 0) {"
            ],
            "added_lines": [
                "    if (err < 0) {",
                "        /* Get a string that describes what we're opening */",
                "        char *file_description = input_file_description(filename);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-9274",
        "func_name": "wireshark/cfile_dump_open_failure_message",
        "description": "In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, ui/failure_message.c has a memory leak.",
        "git_url": "https://github.com/wireshark/wireshark/commit/f38e895dfc0d97bce64f73ce99df706911d9aa07",
        "commit_title": "Plug another leak for Wiretap errors.",
        "commit_text": " Clean up comments while we're at it. ",
        "func_before": "void\ncfile_dump_open_failure_message(const char *progname, const char *filename,\n                                int err, int file_type_subtype)\n{\n    char *file_description;\n\n    /* Get a string that describes what we're opening */\n    file_description = output_file_description(filename);\n\n    if (err < 0) {\n        /* Wiretap error. */\n        switch (err) {\n\n        case WTAP_ERR_NOT_REGULAR_FILE:\n            cmdarg_err(\"The %s is a \\\"special file\\\" or socket or other non-regular file.\",\n                       file_description);\n            break;\n\n        case WTAP_ERR_CANT_WRITE_TO_PIPE:\n            cmdarg_err(\"The %s is a pipe, and \\\"%s\\\" capture files can't be written to a pipe.\",\n                       file_description,\n                       wtap_file_type_subtype_short_string(file_type_subtype));\n            break;\n\n        case WTAP_ERR_UNWRITABLE_FILE_TYPE:\n            cmdarg_err(\"%s doesn't support writing capture files in that format.\",\n                       progname);\n            break;\n\n        case WTAP_ERR_UNWRITABLE_ENCAP:\n            cmdarg_err(\"The capture file being read can't be written as a \\\"%s\\\" file.\",\n                       wtap_file_type_subtype_short_string(file_type_subtype));\n            break;\n\n        case WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED:\n            cmdarg_err(\"The capture file being read can't be written as a \\\"%s\\\" file.\",\n                       wtap_file_type_subtype_short_string(file_type_subtype));\n            break;\n\n        case WTAP_ERR_CANT_OPEN:\n            cmdarg_err(\"The %s could not be created for some unknown reason.\",\n                       file_description);\n            break;\n\n        case WTAP_ERR_SHORT_WRITE:\n            cmdarg_err(\"A full header couldn't be written to the %s.\",\n                       file_description);\n            break;\n\n        case WTAP_ERR_COMPRESSION_NOT_SUPPORTED:\n            cmdarg_err(\"This file type cannot be written as a compressed file.\");\n            break;\n\n        default:\n            cmdarg_err(\"The %s could not be created: %s.\",\n                       file_description,\n                       wtap_strerror(err));\n            break;\n        }\n        g_free(file_description);\n    } else\n        cmdarg_err(file_open_error_message(err, TRUE), filename);\n}",
        "func": "void\ncfile_dump_open_failure_message(const char *progname, const char *filename,\n                                int err, int file_type_subtype)\n{\n    if (err < 0) {\n        /*\n         * Wiretap error.\n         * Get a string that describes what we're opening.\n         */\n        char *file_description = input_file_description(filename);\n\n        switch (err) {\n\n        case WTAP_ERR_NOT_REGULAR_FILE:\n            cmdarg_err(\"The %s is a \\\"special file\\\" or socket or other non-regular file.\",\n                       file_description);\n            break;\n\n        case WTAP_ERR_CANT_WRITE_TO_PIPE:\n            cmdarg_err(\"The %s is a pipe, and \\\"%s\\\" capture files can't be written to a pipe.\",\n                       file_description,\n                       wtap_file_type_subtype_short_string(file_type_subtype));\n            break;\n\n        case WTAP_ERR_UNWRITABLE_FILE_TYPE:\n            cmdarg_err(\"%s doesn't support writing capture files in that format.\",\n                       progname);\n            break;\n\n        case WTAP_ERR_UNWRITABLE_ENCAP:\n            cmdarg_err(\"The capture file being read can't be written as a \\\"%s\\\" file.\",\n                       wtap_file_type_subtype_short_string(file_type_subtype));\n            break;\n\n        case WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED:\n            cmdarg_err(\"The capture file being read can't be written as a \\\"%s\\\" file.\",\n                       wtap_file_type_subtype_short_string(file_type_subtype));\n            break;\n\n        case WTAP_ERR_CANT_OPEN:\n            cmdarg_err(\"The %s could not be created for some unknown reason.\",\n                       file_description);\n            break;\n\n        case WTAP_ERR_SHORT_WRITE:\n            cmdarg_err(\"A full header couldn't be written to the %s.\",\n                       file_description);\n            break;\n\n        case WTAP_ERR_COMPRESSION_NOT_SUPPORTED:\n            cmdarg_err(\"This file type cannot be written as a compressed file.\");\n            break;\n\n        default:\n            cmdarg_err(\"The %s could not be created: %s.\",\n                       file_description,\n                       wtap_strerror(err));\n            break;\n        }\n        g_free(file_description);\n    } else\n        cmdarg_err(file_open_error_message(err, TRUE), filename);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,13 +2,13 @@\n cfile_dump_open_failure_message(const char *progname, const char *filename,\n                                 int err, int file_type_subtype)\n {\n-    char *file_description;\n+    if (err < 0) {\n+        /*\n+         * Wiretap error.\n+         * Get a string that describes what we're opening.\n+         */\n+        char *file_description = input_file_description(filename);\n \n-    /* Get a string that describes what we're opening */\n-    file_description = output_file_description(filename);\n-\n-    if (err < 0) {\n-        /* Wiretap error. */\n         switch (err) {\n \n         case WTAP_ERR_NOT_REGULAR_FILE:",
        "diff_line_info": {
            "deleted_lines": [
                "    char *file_description;",
                "    /* Get a string that describes what we're opening */",
                "    file_description = output_file_description(filename);",
                "",
                "    if (err < 0) {",
                "        /* Wiretap error. */"
            ],
            "added_lines": [
                "    if (err < 0) {",
                "        /*",
                "         * Wiretap error.",
                "         * Get a string that describes what we're opening.",
                "         */",
                "        char *file_description = input_file_description(filename);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-9274",
        "func_name": "wireshark/cfile_open_failure_message",
        "description": "In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, ui/failure_message.c has a memory leak.",
        "git_url": "https://github.com/wireshark/wireshark/commit/f38e895dfc0d97bce64f73ce99df706911d9aa07",
        "commit_title": "Plug another leak for Wiretap errors.",
        "commit_text": " Clean up comments while we're at it. ",
        "func_before": "void\ncfile_open_failure_message(const char *progname, const char *filename,\n                           int err, gchar *err_info)\n{\n    if (err < 0) {\n        /* Get a string that describes what we're opening */\n        char *file_description = input_file_description(filename);\n\n        /* Wiretap error. */\n        switch (err) {\n\n        case WTAP_ERR_NOT_REGULAR_FILE:\n            cmdarg_err(\"The %s is a \\\"special file\\\" or socket or other non-regular file.\",\n                       file_description);\n            break;\n\n        case WTAP_ERR_RANDOM_OPEN_PIPE:\n            cmdarg_err(\"The %s is a pipe or FIFO; %s can't read pipe or FIFO files in two-pass mode.\",\n                       file_description, progname);\n            break;\n\n        case WTAP_ERR_FILE_UNKNOWN_FORMAT:\n            cmdarg_err(\"The %s isn't a capture file in a format %s understands.\",\n                       file_description, progname);\n            break;\n\n        case WTAP_ERR_UNSUPPORTED:\n            cmdarg_err(\"The %s contains record data that %s doesn't support.\\n\"\n                       \"(%s)\",\n                       file_description, progname,\n                       err_info != NULL ? err_info : \"no information supplied\");\n            g_free(err_info);\n            break;\n\n        case WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED:\n            cmdarg_err(\"The %s is a capture for a network type that %s doesn't support.\",\n                       file_description, progname);\n            break;\n\n        case WTAP_ERR_BAD_FILE:\n            cmdarg_err(\"The %s appears to be damaged or corrupt.\\n\"\n                       \"(%s)\",\n                       file_description,\n                       err_info != NULL ? err_info : \"no information supplied\");\n            g_free(err_info);\n            break;\n\n        case WTAP_ERR_CANT_OPEN:\n            cmdarg_err(\"The %s could not be opened for some unknown reason.\",\n                       file_description);\n            break;\n\n        case WTAP_ERR_SHORT_READ:\n            cmdarg_err(\"The %s appears to have been cut short in the middle of a packet or other data.\",\n                       file_description);\n            break;\n\n        case WTAP_ERR_DECOMPRESS:\n            cmdarg_err(\"The %s cannot be decompressed; it may be damaged or corrupt.\"\n                       \"(%s)\",\n                       file_description,\n                       err_info != NULL ? err_info : \"no information supplied\");\n            g_free(err_info);\n            break;\n\n        case WTAP_ERR_DECOMPRESSION_NOT_SUPPORTED:\n            cmdarg_err(\"The %s cannot be decompressed; it is compressed in a way that we don't support.\"\n                       \"(%s)\",\n                       file_description,\n                       err_info != NULL ? err_info : \"no information supplied\");\n            g_free(err_info);\n            break;\n\n        default:\n            cmdarg_err(\"The %s could not be opened: %s.\",\n                       file_description,\n                       wtap_strerror(err));\n            break;\n        }\n        g_free(file_description);\n    } else\n        cmdarg_err(file_open_error_message(err, FALSE), filename);\n}",
        "func": "void\ncfile_open_failure_message(const char *progname, const char *filename,\n                           int err, gchar *err_info)\n{\n    if (err < 0) {\n        /*\n         * Wiretap error.\n         * Get a string that describes what we're opening.\n         */\n        char *file_description = input_file_description(filename);\n\n        switch (err) {\n\n        case WTAP_ERR_NOT_REGULAR_FILE:\n            cmdarg_err(\"The %s is a \\\"special file\\\" or socket or other non-regular file.\",\n                       file_description);\n            break;\n\n        case WTAP_ERR_RANDOM_OPEN_PIPE:\n            cmdarg_err(\"The %s is a pipe or FIFO; %s can't read pipe or FIFO files in two-pass mode.\",\n                       file_description, progname);\n            break;\n\n        case WTAP_ERR_FILE_UNKNOWN_FORMAT:\n            cmdarg_err(\"The %s isn't a capture file in a format %s understands.\",\n                       file_description, progname);\n            break;\n\n        case WTAP_ERR_UNSUPPORTED:\n            cmdarg_err(\"The %s contains record data that %s doesn't support.\\n\"\n                       \"(%s)\",\n                       file_description, progname,\n                       err_info != NULL ? err_info : \"no information supplied\");\n            g_free(err_info);\n            break;\n\n        case WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED:\n            cmdarg_err(\"The %s is a capture for a network type that %s doesn't support.\",\n                       file_description, progname);\n            break;\n\n        case WTAP_ERR_BAD_FILE:\n            cmdarg_err(\"The %s appears to be damaged or corrupt.\\n\"\n                       \"(%s)\",\n                       file_description,\n                       err_info != NULL ? err_info : \"no information supplied\");\n            g_free(err_info);\n            break;\n\n        case WTAP_ERR_CANT_OPEN:\n            cmdarg_err(\"The %s could not be opened for some unknown reason.\",\n                       file_description);\n            break;\n\n        case WTAP_ERR_SHORT_READ:\n            cmdarg_err(\"The %s appears to have been cut short in the middle of a packet or other data.\",\n                       file_description);\n            break;\n\n        case WTAP_ERR_DECOMPRESS:\n            cmdarg_err(\"The %s cannot be decompressed; it may be damaged or corrupt.\"\n                       \"(%s)\",\n                       file_description,\n                       err_info != NULL ? err_info : \"no information supplied\");\n            g_free(err_info);\n            break;\n\n        case WTAP_ERR_DECOMPRESSION_NOT_SUPPORTED:\n            cmdarg_err(\"The %s cannot be decompressed; it is compressed in a way that we don't support.\"\n                       \"(%s)\",\n                       file_description,\n                       err_info != NULL ? err_info : \"no information supplied\");\n            g_free(err_info);\n            break;\n\n        default:\n            cmdarg_err(\"The %s could not be opened: %s.\",\n                       file_description,\n                       wtap_strerror(err));\n            break;\n        }\n        g_free(file_description);\n    } else\n        cmdarg_err(file_open_error_message(err, FALSE), filename);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,10 +3,12 @@\n                            int err, gchar *err_info)\n {\n     if (err < 0) {\n-        /* Get a string that describes what we're opening */\n+        /*\n+         * Wiretap error.\n+         * Get a string that describes what we're opening.\n+         */\n         char *file_description = input_file_description(filename);\n \n-        /* Wiretap error. */\n         switch (err) {\n \n         case WTAP_ERR_NOT_REGULAR_FILE:",
        "diff_line_info": {
            "deleted_lines": [
                "        /* Get a string that describes what we're opening */",
                "        /* Wiretap error. */"
            ],
            "added_lines": [
                "        /*",
                "         * Wiretap error.",
                "         * Get a string that describes what we're opening.",
                "         */"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-10205",
        "func_name": "hyperhq/hyperstart/hyper_rescan_scsi",
        "description": "hyperstart 1.0.0 in HyperHQ Hyper has memory leaks in the container_setup_modules and hyper_rescan_scsi functions in container.c, related to runV 1.0.0 for Docker.",
        "git_url": "https://github.com/hyperhq/hyperstart/commit/bde26da80122117cce5cea65e1d51129fc5a7e3c",
        "commit_title": "hyperstart: fix several mem leak",
        "commit_text": "",
        "func_before": "static int hyper_rescan_scsi(void)\n{\n\tstruct dirent **list;\n\tstruct dirent *dir;\n\tint fd = -1, i, num;\n\tchar path[256];\n\n\tnum = scandir(\"/sys/class/scsi_host/\", &list, NULL, NULL);\n\tif (num < 0) {\n\t\tperror(\"scan /sys/class/scsi_host/ failed\");\n\t\treturn -1;\n\t}\n\n\tmemset(path, 0, sizeof(path));\n\n\tfor (i = 0; i < num; i++) {\n\t\tdir = list[i];\n\t\tif (dir->d_name[0] == '.')\n\t\t\tcontinue;\n\n\t\tif (snprintf(path, sizeof(path), \"/sys/class/scsi_host/%s/scan\",\n\t\t\t     dir->d_name) < 0) {\n\t\t\tfprintf(stderr, \"get scsi host device %s path failed\\n\",\n\t\t\t\tdir->d_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfprintf(stdout, \"path %s\\n\", path);\n\t\tfd = open(path, O_WRONLY);\n\t\tif (fd < 0) {\n\t\t\tperror(\"open path failed\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (write(fd, \"- - - \\n\", 7) < 0)\n\t\t\tperror(\"write to scan failed\");\n\n\t\tclose(fd);\n\t}\n\n\tfprintf(stdout, \"finish scan scsi\\n\");\n\treturn 0;\n\tfree(list);\n}",
        "func": "static int hyper_rescan_scsi(void)\n{\n\tstruct dirent **list;\n\tstruct dirent *dir;\n\tint fd = -1, i, num;\n\tchar path[256];\n\n\tnum = scandir(\"/sys/class/scsi_host/\", &list, NULL, NULL);\n\tif (num < 0) {\n\t\tperror(\"scan /sys/class/scsi_host/ failed\");\n\t\treturn -1;\n\t}\n\n\tmemset(path, 0, sizeof(path));\n\n\tfor (i = 0; i < num; i++) {\n\t\tdir = list[i];\n\t\tif (dir->d_name[0] == '.')\n\t\t\tcontinue;\n\n\t\tif (snprintf(path, sizeof(path), \"/sys/class/scsi_host/%s/scan\",\n\t\t\t     dir->d_name) < 0) {\n\t\t\tfprintf(stderr, \"get scsi host device %s path failed\\n\",\n\t\t\t\tdir->d_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfprintf(stdout, \"path %s\\n\", path);\n\t\tfd = open(path, O_WRONLY);\n\t\tif (fd < 0) {\n\t\t\tperror(\"open path failed\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (write(fd, \"- - - \\n\", 7) < 0)\n\t\t\tperror(\"write to scan failed\");\n\n\t\tclose(fd);\n\t}\n\n\tfprintf(stdout, \"finish scan scsi\\n\");\n\tfor (i = 0; i < num; i++) {\n\t\tfree(list[i]);\n\t}\n\tfree(list);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,6 +39,9 @@\n \t}\n \n \tfprintf(stdout, \"finish scan scsi\\n\");\n+\tfor (i = 0; i < num; i++) {\n+\t\tfree(list[i]);\n+\t}\n+\tfree(list);\n \treturn 0;\n-\tfree(list);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tfree(list);"
            ],
            "added_lines": [
                "\tfor (i = 0; i < num; i++) {",
                "\t\tfree(list[i]);",
                "\t}",
                "\tfree(list);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-10205",
        "func_name": "hyperhq/hyperstart/container_setup_modules",
        "description": "hyperstart 1.0.0 in HyperHQ Hyper has memory leaks in the container_setup_modules and hyper_rescan_scsi functions in container.c, related to runV 1.0.0 for Docker.",
        "git_url": "https://github.com/hyperhq/hyperstart/commit/bde26da80122117cce5cea65e1d51129fc5a7e3c",
        "commit_title": "hyperstart: fix several mem leak",
        "commit_text": "",
        "func_before": "static int container_setup_modules(struct hyper_container *container)\n{\n\tstruct stat st;\n\tstruct utsname uts;\n\tchar src[512], dst[512];\n\n\tif (uname(&uts) < 0) {\n\t\tperror(\"fail to call uname\");\n\t\treturn -1;\n\t}\n\n\tsprintf(src, \"/lib/modules/%s\", uts.release);\n\tsprintf(dst, \"./%s\", src);\n\n\tif (stat(dst, &st) == 0) {\n\t\tstruct dirent **list;\n\t\tint num;\n\n\t\tif (!S_ISDIR(st.st_mode)) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tnum = scandir(dst, &list, NULL, NULL);\n\t\tif (num > 2) {\n\t\t\tfprintf(stdout, \"%s is not null, %d\", dst, num);\n\t\t\treturn 0;\n\t\t}\n\t} else if (errno == ENOENT) {\n\t\tif (hyper_mkdir(dst, 0755) < 0)\n\t\t\treturn -1;\n\t} else {\n\t\treturn -1;\n\t}\n\n\tif (mount(src, dst, NULL, MS_BIND, NULL) < 0) {\n\t\tperror(\"mount bind modules failed\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
        "func": "static int container_setup_modules(struct hyper_container *container)\n{\n\tstruct stat st;\n\tstruct utsname uts;\n\tchar src[512], dst[512];\n\n\tif (uname(&uts) < 0) {\n\t\tperror(\"fail to call uname\");\n\t\treturn -1;\n\t}\n\n\tsprintf(src, \"/lib/modules/%s\", uts.release);\n\tsprintf(dst, \"./%s\", src);\n\n\tif (stat(dst, &st) == 0) {\n\t\tstruct dirent **list;\n\t\tint num;\n\t\tint i;\n\n\t\tif (!S_ISDIR(st.st_mode)) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tnum = scandir(dst, &list, NULL, NULL);\n\t\tif (num > 1) {\n\t\t\tfor (i = 0; i < num; i++) {\n\t\t\t\tfree(list[i]);\n\t\t\t}\n\t\t\tfree(list);\n\t\t}\n\t\tif (num > 2) {\n\t\t\tfprintf(stdout, \"%s is not null, %d\", dst, num);\n\t\t\treturn 0;\n\t\t}\n\t} else if (errno == ENOENT) {\n\t\tif (hyper_mkdir(dst, 0755) < 0)\n\t\t\treturn -1;\n\t} else {\n\t\treturn -1;\n\t}\n\n\tif (mount(src, dst, NULL, MS_BIND, NULL) < 0) {\n\t\tperror(\"mount bind modules failed\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,12 +15,19 @@\n \tif (stat(dst, &st) == 0) {\n \t\tstruct dirent **list;\n \t\tint num;\n+\t\tint i;\n \n \t\tif (!S_ISDIR(st.st_mode)) {\n \t\t\treturn -1;\n \t\t}\n \n \t\tnum = scandir(dst, &list, NULL, NULL);\n+\t\tif (num > 1) {\n+\t\t\tfor (i = 0; i < num; i++) {\n+\t\t\t\tfree(list[i]);\n+\t\t\t}\n+\t\t\tfree(list);\n+\t\t}\n \t\tif (num > 2) {\n \t\t\tfprintf(stdout, \"%s is not null, %d\", dst, num);\n \t\t\treturn 0;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tint i;",
                "\t\tif (num > 1) {",
                "\t\t\tfor (i = 0; i < num; i++) {",
                "\t\t\t\tfree(list[i]);",
                "\t\t\t}",
                "\t\t\tfree(list);",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-11655",
        "func_name": "ImageMagick/GetImagePixelCache",
        "description": "In ImageMagick 7.0.7-20 Q16 x86_64, a memory leak vulnerability was found in the function GetImagePixelCache in MagickCore/cache.c, which allows attackers to cause a denial of service via a crafted CALS image file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/a7414b7322201a9c8a5cacf563f08468c329b4b1",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/930",
        "commit_text": "https://github.com/ImageMagick/ImageMagick/issues/932",
        "func_before": "static Cache GetImagePixelCache(Image *image,const MagickBooleanType clone,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickBooleanType\n    destroy,\n    status;\n\n  static MagickSizeType\n    cache_timelimit = MagickResourceInfinity,\n    cpu_throttle = MagickResourceInfinity,\n    cycles = 0;\n\n  status=MagickTrue;\n  if (cpu_throttle == MagickResourceInfinity)\n    cpu_throttle=GetMagickResourceLimit(ThrottleResource);\n  if ((cpu_throttle != 0) && ((cycles++ % 32) == 0))\n    MagickDelay(cpu_throttle);\n  if (cache_epoch == 0)\n    {\n      /*\n        Set the expire time in seconds.\n      */\n      cache_timelimit=GetMagickResourceLimit(TimeResource);\n      cache_epoch=time((time_t *) NULL);\n    }\n  if ((cache_timelimit != MagickResourceInfinity) &&\n      ((MagickSizeType) (time((time_t *) NULL)-cache_epoch) >= cache_timelimit))\n    {\n#if defined(ECANCELED)\n      errno=ECANCELED;\n#endif\n      ThrowFatalException(ResourceLimitFatalError,\"TimeLimitExceeded\");\n    }\n  LockSemaphoreInfo(image->semaphore);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n#if defined(MAGICKCORE_OPENCL_SUPPORT)\n  CopyOpenCLBuffer(cache_info);\n#endif\n  destroy=MagickFalse;\n  if ((cache_info->reference_count > 1) || (cache_info->mode == ReadMode))\n    {\n      LockSemaphoreInfo(cache_info->semaphore);\n      if ((cache_info->reference_count > 1) || (cache_info->mode == ReadMode))\n        {\n          CacheInfo\n            *clone_info;\n\n          Image\n            clone_image;\n\n          /*\n            Clone pixel cache.\n          */\n          clone_image=(*image);\n          clone_image.semaphore=AcquireSemaphoreInfo();\n          clone_image.reference_count=1;\n          clone_image.cache=ClonePixelCache(cache_info);\n          clone_info=(CacheInfo *) clone_image.cache;\n          status=OpenPixelCache(&clone_image,IOMode,exception);\n          if (status == MagickFalse)\n            clone_info=(CacheInfo *) DestroyPixelCache(clone_info);\n          else\n            {\n              if (clone != MagickFalse)\n                status=ClonePixelCacheRepository(clone_info,cache_info,\n                  exception);\n              if (status != MagickFalse)\n                {\n                  destroy=MagickTrue;\n                  image->cache=clone_info;\n                }\n            }\n          RelinquishSemaphoreInfo(&clone_image.semaphore);\n        }\n      UnlockSemaphoreInfo(cache_info->semaphore);\n    }\n  if (destroy != MagickFalse)\n    cache_info=(CacheInfo *) DestroyPixelCache(cache_info);\n  if (status != MagickFalse)\n    {\n      /*\n        Ensure the image matches the pixel cache morphology.\n      */\n      image->type=UndefinedType;\n      if (ValidatePixelCacheMorphology(image) == MagickFalse)\n        {\n          status=OpenPixelCache(image,IOMode,exception);\n          cache_info=(CacheInfo *) image->cache;\n          if (cache_info->type == DiskCache)\n            (void) ClosePixelCacheOnDisk(cache_info);\n        }\n    }\n  UnlockSemaphoreInfo(image->semaphore);\n  if (status == MagickFalse)\n    return((Cache) NULL);\n  return(image->cache);\n}",
        "func": "static Cache GetImagePixelCache(Image *image,const MagickBooleanType clone,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickBooleanType\n    destroy,\n    status;\n\n  static MagickSizeType\n    cache_timelimit = MagickResourceInfinity,\n    cpu_throttle = MagickResourceInfinity,\n    cycles = 0;\n\n  status=MagickTrue;\n  if (cpu_throttle == MagickResourceInfinity)\n    cpu_throttle=GetMagickResourceLimit(ThrottleResource);\n  if ((cpu_throttle != 0) && ((cycles++ % 32) == 0))\n    MagickDelay(cpu_throttle);\n  if (cache_epoch == 0)\n    {\n      /*\n        Set the expire time in seconds.\n      */\n      cache_timelimit=GetMagickResourceLimit(TimeResource);\n      cache_epoch=time((time_t *) NULL);\n    }\n  if ((cache_timelimit != MagickResourceInfinity) &&\n      ((MagickSizeType) (time((time_t *) NULL)-cache_epoch) >= cache_timelimit))\n    {\n#if defined(ECANCELED)\n      errno=ECANCELED;\n#endif\n      ThrowFatalException(ResourceLimitFatalError,\"TimeLimitExceeded\");\n    }\n  LockSemaphoreInfo(image->semaphore);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n#if defined(MAGICKCORE_OPENCL_SUPPORT)\n  CopyOpenCLBuffer(cache_info);\n#endif\n  destroy=MagickFalse;\n  if ((cache_info->reference_count > 1) || (cache_info->mode == ReadMode))\n    {\n      LockSemaphoreInfo(cache_info->semaphore);\n      if ((cache_info->reference_count > 1) || (cache_info->mode == ReadMode))\n        {\n          CacheInfo\n            *clone_info;\n\n          Image\n            clone_image;\n\n          /*\n            Clone pixel cache.\n          */\n          clone_image=(*image);\n          clone_image.semaphore=AcquireSemaphoreInfo();\n          clone_image.reference_count=1;\n          clone_image.cache=ClonePixelCache(cache_info);\n          clone_info=(CacheInfo *) clone_image.cache;\n          status=OpenPixelCache(&clone_image,IOMode,exception);\n          if (status == MagickFalse)\n            clone_info=(CacheInfo *) DestroyPixelCache(clone_info);\n          else\n            {\n              if (clone != MagickFalse)\n                status=ClonePixelCacheRepository(clone_info,cache_info,\n                  exception);\n              if (status == MagickFalse)\n                clone_info=(CacheInfo *) DestroyPixelCache(clone_info);\n              else\n                {\n                  destroy=MagickTrue;\n                  image->cache=clone_info;\n                }\n            }\n          RelinquishSemaphoreInfo(&clone_image.semaphore);\n        }\n      UnlockSemaphoreInfo(cache_info->semaphore);\n    }\n  if (destroy != MagickFalse)\n    cache_info=(CacheInfo *) DestroyPixelCache(cache_info);\n  if (status != MagickFalse)\n    {\n      /*\n        Ensure the image matches the pixel cache morphology.\n      */\n      image->type=UndefinedType;\n      if (ValidatePixelCacheMorphology(image) == MagickFalse)\n        {\n          status=OpenPixelCache(image,IOMode,exception);\n          cache_info=(CacheInfo *) image->cache;\n          if (cache_info->type == DiskCache)\n            (void) ClosePixelCacheOnDisk(cache_info);\n        }\n    }\n  UnlockSemaphoreInfo(image->semaphore);\n  if (status == MagickFalse)\n    return((Cache) NULL);\n  return(image->cache);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -68,7 +68,9 @@\n               if (clone != MagickFalse)\n                 status=ClonePixelCacheRepository(clone_info,cache_info,\n                   exception);\n-              if (status != MagickFalse)\n+              if (status == MagickFalse)\n+                clone_info=(CacheInfo *) DestroyPixelCache(clone_info);\n+              else\n                 {\n                   destroy=MagickTrue;\n                   image->cache=clone_info;",
        "diff_line_info": {
            "deleted_lines": [
                "              if (status != MagickFalse)"
            ],
            "added_lines": [
                "              if (status == MagickFalse)",
                "                clone_info=(CacheInfo *) DestroyPixelCache(clone_info);",
                "              else"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-11655",
        "func_name": "ImageMagick/GetImagePixelCache",
        "description": "In ImageMagick 7.0.7-20 Q16 x86_64, a memory leak vulnerability was found in the function GetImagePixelCache in MagickCore/cache.c, which allows attackers to cause a denial of service via a crafted CALS image file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/a22af7eda74f551e9279e469d2487d1997536ddb",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/932",
        "commit_text": "https://github.com/ImageMagick/ImageMagick/issues/930",
        "func_before": "static Cache GetImagePixelCache(Image *image,const MagickBooleanType clone,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickBooleanType\n    destroy,\n    status;\n\n  static MagickSizeType\n    cache_timelimit = MagickResourceInfinity,\n    cpu_throttle = MagickResourceInfinity,\n    cycles = 0;\n\n  status=MagickTrue;\n  if (cpu_throttle == MagickResourceInfinity)\n    cpu_throttle=GetMagickResourceLimit(ThrottleResource);\n  if ((cpu_throttle != 0) && ((cycles++ % 32) == 0))\n    MagickDelay(cpu_throttle);\n  if (cache_epoch == 0)\n    {\n      /*\n        Set the expire time in seconds.\n      */\n      cache_epoch=time((time_t *) NULL);\n      cache_timelimit=GetMagickResourceLimit(TimeResource);\n    }\n  if ((cache_timelimit != MagickResourceInfinity) &&\n      ((MagickSizeType) (time((time_t *) NULL)-cache_epoch) >= cache_timelimit))\n    {\n#if defined(ECANCELED)\n      errno=ECANCELED;\n#endif\n      ThrowFatalException(ResourceLimitFatalError,\"TimeLimitExceeded\");\n    }\n  LockSemaphoreInfo(image->semaphore);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n#if defined(MAGICKCORE_OPENCL_SUPPORT)\n  CopyOpenCLBuffer(cache_info);\n#endif\n  destroy=MagickFalse;\n  if ((cache_info->reference_count > 1) || (cache_info->mode == ReadMode))\n    {\n      LockSemaphoreInfo(cache_info->semaphore);\n      if ((cache_info->reference_count > 1) || (cache_info->mode == ReadMode))\n        {\n          CacheInfo\n            *clone_info;\n\n          Image\n            clone_image;\n\n          /*\n            Clone pixel cache.\n          */\n          clone_image=(*image);\n          clone_image.semaphore=AllocateSemaphoreInfo();\n          clone_image.reference_count=1;\n          clone_image.cache=ClonePixelCache(cache_info);\n          clone_info=(CacheInfo *) clone_image.cache;\n          status=OpenPixelCache(&clone_image,IOMode,exception);\n          if (status == MagickFalse)\n            clone_info=(CacheInfo *) DestroyPixelCache(clone_info);\n          else\n            {\n              if (clone != MagickFalse)\n                status=ClonePixelCacheRepository(clone_info,cache_info,\n                  exception);\n              if (status != MagickFalse)\n                {\n                  destroy=MagickTrue;\n                  image->cache=clone_info;\n                }\n            }\n          DestroySemaphoreInfo(&clone_image.semaphore);\n        }\n      UnlockSemaphoreInfo(cache_info->semaphore);\n    }\n  if (destroy != MagickFalse)\n    cache_info=(CacheInfo *) DestroyPixelCache(cache_info);\n  if (status != MagickFalse)\n    {\n      /*\n        Ensure the image matches the pixel cache morphology.\n      */\n      image->type=UndefinedType;\n      if (ValidatePixelCacheMorphology(image) == MagickFalse)\n        {\n          status=OpenPixelCache(image,IOMode,exception);\n          cache_info=(CacheInfo *) image->cache;\n          if (cache_info->type == DiskCache)\n            (void) ClosePixelCacheOnDisk(cache_info);\n        }\n    }\n  UnlockSemaphoreInfo(image->semaphore);\n  if (status == MagickFalse)\n    return((Cache) NULL);\n  return(image->cache);\n}",
        "func": "static Cache GetImagePixelCache(Image *image,const MagickBooleanType clone,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickBooleanType\n    destroy,\n    status;\n\n  static MagickSizeType\n    cache_timelimit = MagickResourceInfinity,\n    cpu_throttle = MagickResourceInfinity,\n    cycles = 0;\n\n  status=MagickTrue;\n  if (cpu_throttle == MagickResourceInfinity)\n    cpu_throttle=GetMagickResourceLimit(ThrottleResource);\n  if ((cpu_throttle != 0) && ((cycles++ % 32) == 0))\n    MagickDelay(cpu_throttle);\n  if (cache_epoch == 0)\n    {\n      /*\n        Set the expire time in seconds.\n      */\n      cache_epoch=time((time_t *) NULL);\n      cache_timelimit=GetMagickResourceLimit(TimeResource);\n    }\n  if ((cache_timelimit != MagickResourceInfinity) &&\n      ((MagickSizeType) (time((time_t *) NULL)-cache_epoch) >= cache_timelimit))\n    {\n#if defined(ECANCELED)\n      errno=ECANCELED;\n#endif\n      ThrowFatalException(ResourceLimitFatalError,\"TimeLimitExceeded\");\n    }\n  LockSemaphoreInfo(image->semaphore);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n#if defined(MAGICKCORE_OPENCL_SUPPORT)\n  CopyOpenCLBuffer(cache_info);\n#endif\n  destroy=MagickFalse;\n  if ((cache_info->reference_count > 1) || (cache_info->mode == ReadMode))\n    {\n      LockSemaphoreInfo(cache_info->semaphore);\n      if ((cache_info->reference_count > 1) || (cache_info->mode == ReadMode))\n        {\n          CacheInfo\n            *clone_info;\n\n          Image\n            clone_image;\n\n          /*\n            Clone pixel cache.\n          */\n          clone_image=(*image);\n          clone_image.semaphore=AllocateSemaphoreInfo();\n          clone_image.reference_count=1;\n          clone_image.cache=ClonePixelCache(cache_info);\n          clone_info=(CacheInfo *) clone_image.cache;\n          status=OpenPixelCache(&clone_image,IOMode,exception);\n          if (status == MagickFalse)\n            clone_info=(CacheInfo *) DestroyPixelCache(clone_info);\n          else\n            {\n              if (clone != MagickFalse)\n                status=ClonePixelCacheRepository(clone_info,cache_info,\n                  exception);\n              if (status == MagickFalse)\n                clone_info=(CacheInfo *) DestroyPixelCache(clone_info);\n              else\n                {\n                  destroy=MagickTrue;\n                  image->cache=clone_info;\n                }\n            }\n          DestroySemaphoreInfo(&clone_image.semaphore);\n        }\n      UnlockSemaphoreInfo(cache_info->semaphore);\n    }\n  if (destroy != MagickFalse)\n    cache_info=(CacheInfo *) DestroyPixelCache(cache_info);\n  if (status != MagickFalse)\n    {\n      /*\n        Ensure the image matches the pixel cache morphology.\n      */\n      image->type=UndefinedType;\n      if (ValidatePixelCacheMorphology(image) == MagickFalse)\n        {\n          status=OpenPixelCache(image,IOMode,exception);\n          cache_info=(CacheInfo *) image->cache;\n          if (cache_info->type == DiskCache)\n            (void) ClosePixelCacheOnDisk(cache_info);\n        }\n    }\n  UnlockSemaphoreInfo(image->semaphore);\n  if (status == MagickFalse)\n    return((Cache) NULL);\n  return(image->cache);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -68,7 +68,9 @@\n               if (clone != MagickFalse)\n                 status=ClonePixelCacheRepository(clone_info,cache_info,\n                   exception);\n-              if (status != MagickFalse)\n+              if (status == MagickFalse)\n+                clone_info=(CacheInfo *) DestroyPixelCache(clone_info);\n+              else\n                 {\n                   destroy=MagickTrue;\n                   image->cache=clone_info;",
        "diff_line_info": {
            "deleted_lines": [
                "              if (status != MagickFalse)"
            ],
            "added_lines": [
                "              if (status == MagickFalse)",
                "                clone_info=(CacheInfo *) DestroyPixelCache(clone_info);",
                "              else"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-11656",
        "func_name": "ImageMagick/ReadRLAImage",
        "description": "In ImageMagick 7.0.7-20 Q16 x86_64, a memory leak vulnerability was found in the function ReadDCMImage in coders/dcm.c, which allows attackers to cause a denial of service via a crafted DCM image file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/caedfada2addf611eebb8c88477a47c6c2f641ca",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/931",
        "commit_text": "",
        "func_before": "static Image *ReadRLAImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  typedef struct _WindowFrame\n  {\n    short\n      left,\n      right,\n      bottom,\n      top;\n  } WindowFrame;\n\n  typedef struct _RLAInfo\n  {\n    WindowFrame\n      window,\n      active_window;\n\n    short\n      frame,\n      storage_type,\n      number_channels,\n      number_matte_channels,\n      number_auxiliary_channels,\n      revision;\n\n    char\n      gamma[16+1],\n      red_primary[24+1],\n      green_primary[24+1],\n      blue_primary[24+1],\n      white_point[24+1];\n\n    int\n      job_number;\n\n    char\n      name[128+1],\n      description[128+1],\n      program[64+1],\n      machine[32+1],\n      user[32+1],\n      date[20+1],\n      aspect[24+1],\n      aspect_ratio[8+1],\n      chan[32+1];\n\n    short\n      field;\n\n    char\n      time[12],\n      filter[32];\n\n    short\n      bits_per_channel,\n      matte_type,\n      matte_bits,\n      auxiliary_type,\n      auxiliary_bits;\n\n    char\n      auxiliary[32+1],\n      space[36+1];\n\n    int\n      next;\n  } RLAInfo;\n\n  Image\n    *image;\n\n  int\n    channel,\n    length,\n    runlength;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    *scanlines;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    count,\n    y;\n\n  RLAInfo\n    rla_info;\n\n  unsigned char\n    byte;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) ResetMagickMemory(&rla_info,0,sizeof(rla_info));\n  rla_info.window.left=(short) ReadBlobMSBShort(image);\n  rla_info.window.right=(short) ReadBlobMSBShort(image);\n  rla_info.window.bottom=(short) ReadBlobMSBShort(image);\n  rla_info.window.top=(short) ReadBlobMSBShort(image);\n  rla_info.active_window.left=(short) ReadBlobMSBShort(image);\n  rla_info.active_window.right=(short) ReadBlobMSBShort(image);\n  rla_info.active_window.bottom=(short) ReadBlobMSBShort(image);\n  rla_info.active_window.top=(short) ReadBlobMSBShort(image);\n  rla_info.frame=(short) ReadBlobMSBShort(image);\n  rla_info.storage_type=(short) ReadBlobMSBShort(image);\n  rla_info.number_channels=(short) ReadBlobMSBShort(image);\n  rla_info.number_matte_channels=(short) ReadBlobMSBShort(image);\n  if (rla_info.number_channels == 0)\n    rla_info.number_channels=3;\n  rla_info.number_channels+=rla_info.number_matte_channels;\n  rla_info.number_auxiliary_channels=(short) ReadBlobMSBShort(image);\n  rla_info.revision=(short) ReadBlobMSBShort(image);\n  count=ReadBlob(image,16,(unsigned char *) rla_info.gamma);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.red_primary);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.green_primary);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.blue_primary);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.white_point);\n  rla_info.job_number=ReadBlobMSBSignedLong(image);\n  count=ReadBlob(image,128,(unsigned char *) rla_info.name);\n  count=ReadBlob(image,128,(unsigned char *) rla_info.description);\n  rla_info.description[127]='\\0';\n  count=ReadBlob(image,64,(unsigned char *) rla_info.program);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.machine);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.user);\n  count=ReadBlob(image,20,(unsigned char *) rla_info.date);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.aspect);\n  count=ReadBlob(image,8,(unsigned char *) rla_info.aspect_ratio);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.chan);\n  rla_info.field=(short) ReadBlobMSBShort(image);\n  count=ReadBlob(image,12,(unsigned char *) rla_info.time);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.filter);\n  rla_info.bits_per_channel=(short) ReadBlobMSBShort(image);\n  rla_info.matte_type=(short) ReadBlobMSBShort(image);\n  rla_info.matte_bits=(short) ReadBlobMSBShort(image);\n  rla_info.auxiliary_type=(short) ReadBlobMSBShort(image);\n  rla_info.auxiliary_bits=(short) ReadBlobMSBShort(image);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.auxiliary);\n  count=ReadBlob(image,36,(unsigned char *) rla_info.space);\n  if ((size_t) count != 36)\n    ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n  rla_info.next=ReadBlobMSBSignedLong(image);\n  /*\n    Initialize image structure.\n  */\n  image->alpha_trait=rla_info.number_matte_channels != 0 ? BlendPixelTrait : \n    UndefinedPixelTrait;\n  image->columns=(size_t) (rla_info.active_window.right-\n    rla_info.active_window.left+1);\n  image->rows=(size_t) (rla_info.active_window.top-\n    rla_info.active_window.bottom+1);\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  scanlines=(MagickOffsetType *) AcquireQuantumMemory(image->rows,\n    sizeof(*scanlines));\n  if (scanlines == (MagickOffsetType *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (*rla_info.description != '\\0')\n    (void) SetImageProperty(image,\"comment\",rla_info.description,exception);\n  /*\n    Read offsets to each scanline data.\n  */\n  for (i=0; i < (ssize_t) image->rows; i++)\n    scanlines[i]=(MagickOffsetType) ReadBlobMSBSignedLong(image);\n  /*\n    Read image data.\n  */\n  x=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    offset=SeekBlob(image,scanlines[image->rows-y-1],SEEK_SET);\n    if (offset < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    for (channel=0; channel < (int) rla_info.number_channels; channel++)\n    {\n      length=ReadBlobMSBSignedShort(image);\n      while (length > 0)\n      {\n        byte=(unsigned char) ReadBlobByte(image);\n        runlength=byte;\n        if (byte > 127)\n          runlength=byte-256;\n        length--;\n        if (length == 0)\n          break;\n        if (runlength < 0)\n          {\n            while (runlength < 0)\n            {\n              q=GetAuthenticPixels(image,(ssize_t) (x % image->columns),\n                (ssize_t) (y % image->rows),1,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              byte=(unsigned char) ReadBlobByte(image);\n              length--;\n              switch (channel)\n              {\n                case 0:\n                {\n                  SetPixelRed(image,ScaleCharToQuantum(byte),q);\n                  break;\n                }\n                case 1:\n                {\n                  SetPixelGreen(image,ScaleCharToQuantum(byte),q);\n                  break;\n                }\n                case 2:\n                {\n                  SetPixelBlue(image,ScaleCharToQuantum(byte),q);\n                  break;\n                }\n                case 3:\n                default:\n                {\n                  SetPixelAlpha(image,ScaleCharToQuantum(byte),q);\n                  break;\n                }\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              x++;\n              runlength++;\n            }\n            continue;\n          }\n        byte=(unsigned char) ReadBlobByte(image);\n        length--;\n        runlength++;\n        do\n        {\n          q=GetAuthenticPixels(image,(ssize_t) (x % image->columns),\n            (ssize_t) (y % image->rows),1,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          switch (channel)\n          {\n            case 0:\n            {\n              SetPixelRed(image,ScaleCharToQuantum(byte),q);\n              break;\n            }\n            case 1:\n            {\n              SetPixelGreen(image,ScaleCharToQuantum(byte),q);\n              break;\n            }\n            case 2:\n            {\n              SetPixelBlue(image,ScaleCharToQuantum(byte),q);\n              break;\n            }\n            case 3:\n            default:\n            {\n              SetPixelAlpha(image,ScaleCharToQuantum(byte),q);\n              break;\n            }\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          x++;\n          runlength--;\n        }\n        while (runlength > 0);\n      }\n    }\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  scanlines=(MagickOffsetType *) RelinquishMagickMemory(scanlines);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadRLAImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  typedef struct _WindowFrame\n  {\n    short\n      left,\n      right,\n      bottom,\n      top;\n  } WindowFrame;\n\n  typedef struct _RLAInfo\n  {\n    WindowFrame\n      window,\n      active_window;\n\n    short\n      frame,\n      storage_type,\n      number_channels,\n      number_matte_channels,\n      number_auxiliary_channels,\n      revision;\n\n    char\n      gamma[16+1],\n      red_primary[24+1],\n      green_primary[24+1],\n      blue_primary[24+1],\n      white_point[24+1];\n\n    int\n      job_number;\n\n    char\n      name[128+1],\n      description[128+1],\n      program[64+1],\n      machine[32+1],\n      user[32+1],\n      date[20+1],\n      aspect[24+1],\n      aspect_ratio[8+1],\n      chan[32+1];\n\n    short\n      field;\n\n    char\n      time[12],\n      filter[32];\n\n    short\n      bits_per_channel,\n      matte_type,\n      matte_bits,\n      auxiliary_type,\n      auxiliary_bits;\n\n    char\n      auxiliary[32+1],\n      space[36+1];\n\n    int\n      next;\n  } RLAInfo;\n\n  Image\n    *image;\n\n  int\n    channel,\n    length,\n    runlength;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset,\n    *scanlines;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    count,\n    y;\n\n  RLAInfo\n    rla_info;\n\n  unsigned char\n    byte;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) ResetMagickMemory(&rla_info,0,sizeof(rla_info));\n  rla_info.window.left=(short) ReadBlobMSBShort(image);\n  rla_info.window.right=(short) ReadBlobMSBShort(image);\n  rla_info.window.bottom=(short) ReadBlobMSBShort(image);\n  rla_info.window.top=(short) ReadBlobMSBShort(image);\n  rla_info.active_window.left=(short) ReadBlobMSBShort(image);\n  rla_info.active_window.right=(short) ReadBlobMSBShort(image);\n  rla_info.active_window.bottom=(short) ReadBlobMSBShort(image);\n  rla_info.active_window.top=(short) ReadBlobMSBShort(image);\n  rla_info.frame=(short) ReadBlobMSBShort(image);\n  rla_info.storage_type=(short) ReadBlobMSBShort(image);\n  rla_info.number_channels=(short) ReadBlobMSBShort(image);\n  rla_info.number_matte_channels=(short) ReadBlobMSBShort(image);\n  if (rla_info.number_channels == 0)\n    rla_info.number_channels=3;\n  rla_info.number_channels+=rla_info.number_matte_channels;\n  rla_info.number_auxiliary_channels=(short) ReadBlobMSBShort(image);\n  rla_info.revision=(short) ReadBlobMSBShort(image);\n  count=ReadBlob(image,16,(unsigned char *) rla_info.gamma);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.red_primary);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.green_primary);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.blue_primary);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.white_point);\n  rla_info.job_number=ReadBlobMSBSignedLong(image);\n  count=ReadBlob(image,128,(unsigned char *) rla_info.name);\n  count=ReadBlob(image,128,(unsigned char *) rla_info.description);\n  rla_info.description[127]='\\0';\n  count=ReadBlob(image,64,(unsigned char *) rla_info.program);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.machine);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.user);\n  count=ReadBlob(image,20,(unsigned char *) rla_info.date);\n  count=ReadBlob(image,24,(unsigned char *) rla_info.aspect);\n  count=ReadBlob(image,8,(unsigned char *) rla_info.aspect_ratio);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.chan);\n  rla_info.field=(short) ReadBlobMSBShort(image);\n  count=ReadBlob(image,12,(unsigned char *) rla_info.time);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.filter);\n  rla_info.bits_per_channel=(short) ReadBlobMSBShort(image);\n  rla_info.matte_type=(short) ReadBlobMSBShort(image);\n  rla_info.matte_bits=(short) ReadBlobMSBShort(image);\n  rla_info.auxiliary_type=(short) ReadBlobMSBShort(image);\n  rla_info.auxiliary_bits=(short) ReadBlobMSBShort(image);\n  count=ReadBlob(image,32,(unsigned char *) rla_info.auxiliary);\n  count=ReadBlob(image,36,(unsigned char *) rla_info.space);\n  if ((size_t) count != 36)\n    ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n  rla_info.next=ReadBlobMSBSignedLong(image);\n  /*\n    Initialize image structure.\n  */\n  image->alpha_trait=rla_info.number_matte_channels != 0 ? BlendPixelTrait : \n    UndefinedPixelTrait;\n  image->columns=(size_t) (rla_info.active_window.right-\n    rla_info.active_window.left+1);\n  image->rows=(size_t) (rla_info.active_window.top-\n    rla_info.active_window.bottom+1);\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  scanlines=(MagickOffsetType *) AcquireQuantumMemory(image->rows,\n    sizeof(*scanlines));\n  if (scanlines == (MagickOffsetType *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (*rla_info.description != '\\0')\n    (void) SetImageProperty(image,\"comment\",rla_info.description,exception);\n  /*\n    Read offsets to each scanline data.\n  */\n  for (i=0; i < (ssize_t) image->rows; i++)\n    scanlines[i]=(MagickOffsetType) ReadBlobMSBSignedLong(image);\n  /*\n    Read image data.\n  */\n  x=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    offset=SeekBlob(image,scanlines[image->rows-y-1],SEEK_SET);\n    if (offset < 0)\n      {\n        scanlines=(MagickOffsetType *) RelinquishMagickMemory(scanlines);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    for (channel=0; channel < (int) rla_info.number_channels; channel++)\n    {\n      length=ReadBlobMSBSignedShort(image);\n      while (length > 0)\n      {\n        byte=(unsigned char) ReadBlobByte(image);\n        runlength=byte;\n        if (byte > 127)\n          runlength=byte-256;\n        length--;\n        if (length == 0)\n          break;\n        if (runlength < 0)\n          {\n            while (runlength < 0)\n            {\n              q=GetAuthenticPixels(image,(ssize_t) (x % image->columns),\n                (ssize_t) (y % image->rows),1,1,exception);\n              if (q == (Quantum *) NULL)\n                break;\n              byte=(unsigned char) ReadBlobByte(image);\n              length--;\n              switch (channel)\n              {\n                case 0:\n                {\n                  SetPixelRed(image,ScaleCharToQuantum(byte),q);\n                  break;\n                }\n                case 1:\n                {\n                  SetPixelGreen(image,ScaleCharToQuantum(byte),q);\n                  break;\n                }\n                case 2:\n                {\n                  SetPixelBlue(image,ScaleCharToQuantum(byte),q);\n                  break;\n                }\n                case 3:\n                default:\n                {\n                  SetPixelAlpha(image,ScaleCharToQuantum(byte),q);\n                  break;\n                }\n              }\n              if (SyncAuthenticPixels(image,exception) == MagickFalse)\n                break;\n              x++;\n              runlength++;\n            }\n            continue;\n          }\n        byte=(unsigned char) ReadBlobByte(image);\n        length--;\n        runlength++;\n        do\n        {\n          q=GetAuthenticPixels(image,(ssize_t) (x % image->columns),\n            (ssize_t) (y % image->rows),1,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          switch (channel)\n          {\n            case 0:\n            {\n              SetPixelRed(image,ScaleCharToQuantum(byte),q);\n              break;\n            }\n            case 1:\n            {\n              SetPixelGreen(image,ScaleCharToQuantum(byte),q);\n              break;\n            }\n            case 2:\n            {\n              SetPixelBlue(image,ScaleCharToQuantum(byte),q);\n              break;\n            }\n            case 3:\n            default:\n            {\n              SetPixelAlpha(image,ScaleCharToQuantum(byte),q);\n              break;\n            }\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          x++;\n          runlength--;\n        }\n        while (runlength > 0);\n      }\n    }\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  scanlines=(MagickOffsetType *) RelinquishMagickMemory(scanlines);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -198,7 +198,10 @@\n   {\n     offset=SeekBlob(image,scanlines[image->rows-y-1],SEEK_SET);\n     if (offset < 0)\n-      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+      {\n+        scanlines=(MagickOffsetType *) RelinquishMagickMemory(scanlines);\n+        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n+      }\n     for (channel=0; channel < (int) rla_info.number_channels; channel++)\n     {\n       length=ReadBlobMSBSignedShort(image);\n@@ -298,10 +301,10 @@\n     if (status == MagickFalse)\n       break;\n   }\n+  scanlines=(MagickOffsetType *) RelinquishMagickMemory(scanlines);\n   if (EOFBlob(image) != MagickFalse)\n     ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n       image->filename);\n-  scanlines=(MagickOffsetType *) RelinquishMagickMemory(scanlines);\n   (void) CloseBlob(image);\n   return(GetFirstImageInList(image));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "  scanlines=(MagickOffsetType *) RelinquishMagickMemory(scanlines);"
            ],
            "added_lines": [
                "      {",
                "        scanlines=(MagickOffsetType *) RelinquishMagickMemory(scanlines);",
                "        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
                "      }",
                "  scanlines=(MagickOffsetType *) RelinquishMagickMemory(scanlines);"
            ]
        }
    }
]