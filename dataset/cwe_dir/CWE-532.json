[
    {
        "cve_id": "CVE-2017-0380",
        "func_name": "torproject/tor/rend_service_intro_established",
        "description": "The rend_service_intro_established function in or/rendservice.c in Tor before 0.2.8.15, 0.2.9.x before 0.2.9.12, 0.3.0.x before 0.3.0.11, 0.3.1.x before 0.3.1.7, and 0.3.2.x before 0.3.2.1-alpha, when SafeLogging is disabled, allows attackers to obtain sensitive information by leveraging access to the log files of a hidden service, because uninitialized stack data is included in an error message about construction of an introduction point circuit.",
        "git_url": "https://github.com/torproject/tor/commit/09ea89764a4d3a907808ed7d4fe42abfe64bd486",
        "commit_title": "Fix log-uninitialized-stack bug in rend_service_intro_established.",
        "commit_text": " Fixes bug 23490; bugfix on 0.2.7.2-alpha.  TROVE-2017-008 CVE-2017-0380",
        "func_before": "int\nrend_service_intro_established(origin_circuit_t *circuit,\n                               const uint8_t *request,\n                               size_t request_len)\n{\n  rend_service_t *service;\n  rend_intro_point_t *intro;\n  char serviceid[REND_SERVICE_ID_LEN_BASE32+1];\n  (void) request;\n  (void) request_len;\n  tor_assert(circuit->rend_data);\n  /* XXX: This is version 2 specific (only supported one for now). */\n  const char *rend_pk_digest =\n    (char *) rend_data_get_pk_digest(circuit->rend_data, NULL);\n\n  if (circuit->base_.purpose != CIRCUIT_PURPOSE_S_ESTABLISH_INTRO) {\n    log_warn(LD_PROTOCOL,\n             \"received INTRO_ESTABLISHED cell on non-intro circuit.\");\n    goto err;\n  }\n  service = rend_service_get_by_pk_digest(rend_pk_digest);\n  if (!service) {\n    log_warn(LD_REND, \"Unknown service on introduction circuit %u.\",\n             (unsigned)circuit->base_.n_circ_id);\n    goto err;\n  }\n  /* We've just successfully established a intro circuit to one of our\n   * introduction point, account for it. */\n  intro = find_intro_point(circuit);\n  if (intro == NULL) {\n    log_warn(LD_REND,\n             \"Introduction circuit established without a rend_intro_point_t \"\n             \"object for service %s on circuit %u\",\n             safe_str_client(serviceid), (unsigned)circuit->base_.n_circ_id);\n    goto err;\n  }\n  intro->circuit_established = 1;\n  /* We might not have every introduction point ready but at this point we\n   * know that the descriptor needs to be uploaded. */\n  service->desc_is_dirty = time(NULL);\n  circuit_change_purpose(TO_CIRCUIT(circuit), CIRCUIT_PURPOSE_S_INTRO);\n\n  base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32 + 1,\n                rend_pk_digest, REND_SERVICE_ID_LEN);\n  log_info(LD_REND,\n           \"Received INTRO_ESTABLISHED cell on circuit %u for service %s\",\n           (unsigned)circuit->base_.n_circ_id, serviceid);\n\n  /* Getting a valid INTRODUCE_ESTABLISHED means we've successfully\n   * used the circ */\n  pathbias_mark_use_success(circuit);\n\n  return 0;\n err:\n  circuit_mark_for_close(TO_CIRCUIT(circuit), END_CIRC_REASON_TORPROTOCOL);\n  return -1;\n}",
        "func": "int\nrend_service_intro_established(origin_circuit_t *circuit,\n                               const uint8_t *request,\n                               size_t request_len)\n{\n  rend_service_t *service;\n  rend_intro_point_t *intro;\n  char serviceid[REND_SERVICE_ID_LEN_BASE32+1];\n  (void) request;\n  (void) request_len;\n  tor_assert(circuit->rend_data);\n  /* XXX: This is version 2 specific (only supported one for now). */\n  const char *rend_pk_digest =\n    (char *) rend_data_get_pk_digest(circuit->rend_data, NULL);\n\n  if (circuit->base_.purpose != CIRCUIT_PURPOSE_S_ESTABLISH_INTRO) {\n    log_warn(LD_PROTOCOL,\n             \"received INTRO_ESTABLISHED cell on non-intro circuit.\");\n    goto err;\n  }\n  service = rend_service_get_by_pk_digest(rend_pk_digest);\n  if (!service) {\n    log_warn(LD_REND, \"Unknown service on introduction circuit %u.\",\n             (unsigned)circuit->base_.n_circ_id);\n    goto err;\n  }\n  base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32 + 1,\n                rend_pk_digest, REND_SERVICE_ID_LEN);\n  /* We've just successfully established a intro circuit to one of our\n   * introduction point, account for it. */\n  intro = find_intro_point(circuit);\n  if (intro == NULL) {\n    log_warn(LD_REND,\n             \"Introduction circuit established without a rend_intro_point_t \"\n             \"object for service %s on circuit %u\",\n             safe_str_client(serviceid), (unsigned)circuit->base_.n_circ_id);\n    goto err;\n  }\n  intro->circuit_established = 1;\n  /* We might not have every introduction point ready but at this point we\n   * know that the descriptor needs to be uploaded. */\n  service->desc_is_dirty = time(NULL);\n  circuit_change_purpose(TO_CIRCUIT(circuit), CIRCUIT_PURPOSE_S_INTRO);\n\n  log_info(LD_REND,\n           \"Received INTRO_ESTABLISHED cell on circuit %u for service %s\",\n           (unsigned)circuit->base_.n_circ_id, serviceid);\n\n  /* Getting a valid INTRODUCE_ESTABLISHED means we've successfully\n   * used the circ */\n  pathbias_mark_use_success(circuit);\n\n  return 0;\n err:\n  circuit_mark_for_close(TO_CIRCUIT(circuit), END_CIRC_REASON_TORPROTOCOL);\n  return -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,6 +24,8 @@\n              (unsigned)circuit->base_.n_circ_id);\n     goto err;\n   }\n+  base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32 + 1,\n+                rend_pk_digest, REND_SERVICE_ID_LEN);\n   /* We've just successfully established a intro circuit to one of our\n    * introduction point, account for it. */\n   intro = find_intro_point(circuit);\n@@ -40,8 +42,6 @@\n   service->desc_is_dirty = time(NULL);\n   circuit_change_purpose(TO_CIRCUIT(circuit), CIRCUIT_PURPOSE_S_INTRO);\n \n-  base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32 + 1,\n-                rend_pk_digest, REND_SERVICE_ID_LEN);\n   log_info(LD_REND,\n            \"Received INTRO_ESTABLISHED cell on circuit %u for service %s\",\n            (unsigned)circuit->base_.n_circ_id, serviceid);",
        "diff_line_info": {
            "deleted_lines": [
                "  base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32 + 1,",
                "                rend_pk_digest, REND_SERVICE_ID_LEN);"
            ],
            "added_lines": [
                "  base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32 + 1,",
                "                rend_pk_digest, REND_SERVICE_ID_LEN);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-29869",
        "func_name": "piastry/cifs-utils/open_cred_file",
        "description": "cifs-utils through 6.14, with verbose logging, can cause an information leak when a file contains = (equal sign) characters but is not a valid credentials file.",
        "git_url": "https://github.com/piastry/cifs-utils/commit/8acc963a2e7e9d63fe1f2e7f73f5a03f83d9c379",
        "commit_title": "mount.cifs: fix verbose messages on option parsing",
        "commit_text": " When verbose logging is enabled, invalid credentials file lines may be dumped to stderr. This may lead to information disclosure in particular conditions when the credentials file given is sensitive and contains '=' signs.  Bug: https://bugzilla.samba.org/show_bug.cgi?id=15026 ",
        "func_before": "static int open_cred_file(char *file_name,\n\t\t\tstruct parsed_mount_info *parsed_info)\n{\n\tchar *line_buf = NULL;\n\tchar *temp_val = NULL;\n\tFILE *fs = NULL;\n\tint i;\n\tconst int line_buf_size = 4096;\n\tconst int min_non_white = 10;\n\n\ti = toggle_dac_capability(0, 1);\n\tif (i)\n\t\tgoto return_i;\n\n\ti = access(file_name, R_OK);\n\tif (i) {\n\t\ttoggle_dac_capability(0, 0);\n\t\ti = errno;\n\t\tgoto return_i;\n\t}\n\n\tfs = fopen(file_name, \"r\");\n\tif (fs == NULL) {\n\t\ttoggle_dac_capability(0, 0);\n\t\ti = errno;\n\t\tgoto return_i;\n\t}\n\n\ti = toggle_dac_capability(0, 0);\n\tif (i)\n\t\tgoto return_i;\n\n\tline_buf = (char *)malloc(line_buf_size);\n\tif (line_buf == NULL) {\n\t\ti = EX_SYSERR;\n\t\tgoto return_i;\n\t}\n\n\t/* parse line from credentials file */\n\twhile (fgets(line_buf, line_buf_size, fs)) {\n\t\t/* eat leading white space */\n\t\tfor (i = 0; i < line_buf_size - min_non_white + 1; i++) {\n\t\t\tif ((line_buf[i] != ' ') && (line_buf[i] != '\\t'))\n\t\t\t\tbreak;\n\t\t}\n\t\tnull_terminate_endl(line_buf);\n\n\t\t/* parse next token */\n\t\tswitch (parse_cred_line(line_buf + i, &temp_val)) {\n\t\tcase CRED_USER:\n\t\t\tstrlcpy(parsed_info->username, temp_val,\n\t\t\t\tsizeof(parsed_info->username));\n\t\t\tparsed_info->got_user = 1;\n\t\t\tbreak;\n\t\tcase CRED_PASS:\n\t\t\ti = set_password(parsed_info, temp_val);\n\t\t\tif (i)\n\t\t\t\tgoto return_i;\n\t\t\tbreak;\n\t\tcase CRED_DOM:\n\t\t\tif (parsed_info->verboseflag)\n\t\t\t\tfprintf(stderr, \"domain=%s\\n\",\n\t\t\t\t\ttemp_val);\n\t\t\tstrlcpy(parsed_info->domain, temp_val,\n\t\t\t\tsizeof(parsed_info->domain));\n\t\t\tbreak;\n\t\tcase CRED_UNPARSEABLE:\n\t\t\tif (parsed_info->verboseflag)\n\t\t\t\tfprintf(stderr, \"Credential formatted \"\n\t\t\t\t\t\"incorrectly: %s\\n\",\n\t\t\t\t\ttemp_val ? temp_val : \"(null)\");\n\t\t\tbreak;\n\t\t}\n\t}\n\ti = 0;\nreturn_i:\n\tif (fs != NULL)\n\t\tfclose(fs);\n\n\t/* make sure passwords are scrubbed from memory */\n\tif (line_buf != NULL)\n\t\tmemset(line_buf, 0, line_buf_size);\n\tfree(line_buf);\n\treturn i;\n}",
        "func": "static int open_cred_file(char *file_name,\n\t\t\tstruct parsed_mount_info *parsed_info)\n{\n\tchar *line_buf = NULL;\n\tchar *temp_val = NULL;\n\tFILE *fs = NULL;\n\tint i;\n\tconst int line_buf_size = 4096;\n\tconst int min_non_white = 10;\n\n\ti = toggle_dac_capability(0, 1);\n\tif (i)\n\t\tgoto return_i;\n\n\ti = access(file_name, R_OK);\n\tif (i) {\n\t\ttoggle_dac_capability(0, 0);\n\t\ti = errno;\n\t\tgoto return_i;\n\t}\n\n\tfs = fopen(file_name, \"r\");\n\tif (fs == NULL) {\n\t\ttoggle_dac_capability(0, 0);\n\t\ti = errno;\n\t\tgoto return_i;\n\t}\n\n\ti = toggle_dac_capability(0, 0);\n\tif (i)\n\t\tgoto return_i;\n\n\tline_buf = (char *)malloc(line_buf_size);\n\tif (line_buf == NULL) {\n\t\ti = EX_SYSERR;\n\t\tgoto return_i;\n\t}\n\n\t/* parse line from credentials file */\n\twhile (fgets(line_buf, line_buf_size, fs)) {\n\t\t/* eat leading white space */\n\t\tfor (i = 0; i < line_buf_size - min_non_white + 1; i++) {\n\t\t\tif ((line_buf[i] != ' ') && (line_buf[i] != '\\t'))\n\t\t\t\tbreak;\n\t\t}\n\t\tnull_terminate_endl(line_buf);\n\n\t\t/* parse next token */\n\t\tswitch (parse_cred_line(line_buf + i, &temp_val)) {\n\t\tcase CRED_USER:\n\t\t\tstrlcpy(parsed_info->username, temp_val,\n\t\t\t\tsizeof(parsed_info->username));\n\t\t\tparsed_info->got_user = 1;\n\t\t\tbreak;\n\t\tcase CRED_PASS:\n\t\t\ti = set_password(parsed_info, temp_val);\n\t\t\tif (i)\n\t\t\t\tgoto return_i;\n\t\t\tbreak;\n\t\tcase CRED_DOM:\n\t\t\tstrlcpy(parsed_info->domain, temp_val,\n\t\t\t\tsizeof(parsed_info->domain));\n\t\t\tbreak;\n\t\tcase CRED_UNPARSEABLE:\n\t\t\tif (parsed_info->verboseflag)\n\t\t\t\tfprintf(stderr, \"Credential formatted \"\n\t\t\t\t\t\"incorrectly\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\ti = 0;\nreturn_i:\n\tif (fs != NULL)\n\t\tfclose(fs);\n\n\t/* make sure passwords are scrubbed from memory */\n\tif (line_buf != NULL)\n\t\tmemset(line_buf, 0, line_buf_size);\n\tfree(line_buf);\n\treturn i;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -58,17 +58,13 @@\n \t\t\t\tgoto return_i;\n \t\t\tbreak;\n \t\tcase CRED_DOM:\n-\t\t\tif (parsed_info->verboseflag)\n-\t\t\t\tfprintf(stderr, \"domain=%s\\n\",\n-\t\t\t\t\ttemp_val);\n \t\t\tstrlcpy(parsed_info->domain, temp_val,\n \t\t\t\tsizeof(parsed_info->domain));\n \t\t\tbreak;\n \t\tcase CRED_UNPARSEABLE:\n \t\t\tif (parsed_info->verboseflag)\n \t\t\t\tfprintf(stderr, \"Credential formatted \"\n-\t\t\t\t\t\"incorrectly: %s\\n\",\n-\t\t\t\t\ttemp_val ? temp_val : \"(null)\");\n+\t\t\t\t\t\"incorrectly\\n\");\n \t\t\tbreak;\n \t\t}\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tif (parsed_info->verboseflag)",
                "\t\t\t\tfprintf(stderr, \"domain=%s\\n\",",
                "\t\t\t\t\ttemp_val);",
                "\t\t\t\t\t\"incorrectly: %s\\n\",",
                "\t\t\t\t\ttemp_val ? temp_val : \"(null)\");"
            ],
            "added_lines": [
                "\t\t\t\t\t\"incorrectly\\n\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-1943",
        "func_name": "NetworkManager/destroy_one_secret",
        "description": "The destroy_one_secret function in nm-setting-vpn.c in libnm-util in the NetworkManager package 0.8.999-3.git20110526 in Fedora 15 creates a log entry containing a certificate password, which allows local users to obtain sensitive information by reading a log file.",
        "git_url": "http://cgit.freedesktop.org/NetworkManager/NetworkManager/commit/?id=78ce088843d59d4494965bfc40b30a2e63d065f6",
        "commit_title": "",
        "commit_text": "",
        "func_before": "static void\ndestroy_one_secret (gpointer data)\n{\n\tchar *secret = (char *) data;\n\n\t/* Don't leave the secret lying around in memory */\ng_message (\"%s: destroying %s\", __func__, secret);\n\tmemset (secret, 0, strlen (secret));\n\tg_free (secret);\n}",
        "func": "static void\ndestroy_one_secret (gpointer data)\n{\n\tchar *secret = (char *) data;\n\n\t/* Don't leave the secret lying around in memory */\n\tmemset (secret, 0, strlen (secret));\n\tg_free (secret);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,6 @@\n \tchar *secret = (char *) data;\n \n \t/* Don't leave the secret lying around in memory */\n-g_message (\"%s: destroying %s\", __func__, secret);\n \tmemset (secret, 0, strlen (secret));\n \tg_free (secret);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "g_message (\"%s: destroying %s\", __func__, secret);"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2017-5549",
        "func_name": "torvalds/linux/klsi_105_get_line_state",
        "description": "The klsi_105_get_line_state function in drivers/usb/serial/kl5kusb105.c in the Linux kernel before 4.9.5 places uninitialized heap-memory contents into a log entry upon a failure to read the line status, which allows local users to obtain sensitive information by reading the log.",
        "git_url": "https://github.com/torvalds/linux/commit/146cc8a17a3b4996f6805ee5c080e7101277c410",
        "commit_title": "USB: serial: kl5kusb105: fix line-state error handling",
        "commit_text": " The current implementation failed to detect short transfers when attempting to read the line state, and also, to make things worse, logged the content of the uninitialised heap transfer buffer.  Cc: stable <stable@vger.kernel.org>",
        "func_before": "static int klsi_105_get_line_state(struct usb_serial_port *port,\n\t\t\t\t   unsigned long *line_state_p)\n{\n\tint rc;\n\tu8 *status_buf;\n\t__u16 status;\n\n\tdev_info(&port->serial->dev->dev, \"sending SIO Poll request\\n\");\n\n\tstatus_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL);\n\tif (!status_buf)\n\t\treturn -ENOMEM;\n\n\tstatus_buf[0] = 0xff;\n\tstatus_buf[1] = 0xff;\n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_POLL,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t     0, /* value */\n\t\t\t     0, /* index */\n\t\t\t     status_buf, KLSI_STATUSBUF_LEN,\n\t\t\t     10000\n\t\t\t     );\n\tif (rc < 0)\n\t\tdev_err(&port->dev, \"Reading line status failed (error = %d)\\n\",\n\t\t\trc);\n\telse {\n\t\tstatus = get_unaligned_le16(status_buf);\n\n\t\tdev_info(&port->serial->dev->dev, \"read status %x %x\\n\",\n\t\t\t status_buf[0], status_buf[1]);\n\n\t\t*line_state_p = klsi_105_status2linestate(status);\n\t}\n\n\tkfree(status_buf);\n\treturn rc;\n}",
        "func": "static int klsi_105_get_line_state(struct usb_serial_port *port,\n\t\t\t\t   unsigned long *line_state_p)\n{\n\tint rc;\n\tu8 *status_buf;\n\t__u16 status;\n\n\tdev_info(&port->serial->dev->dev, \"sending SIO Poll request\\n\");\n\n\tstatus_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL);\n\tif (!status_buf)\n\t\treturn -ENOMEM;\n\n\tstatus_buf[0] = 0xff;\n\tstatus_buf[1] = 0xff;\n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_POLL,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t     0, /* value */\n\t\t\t     0, /* index */\n\t\t\t     status_buf, KLSI_STATUSBUF_LEN,\n\t\t\t     10000\n\t\t\t     );\n\tif (rc != KLSI_STATUSBUF_LEN) {\n\t\tdev_err(&port->dev, \"reading line status failed: %d\\n\", rc);\n\t\tif (rc >= 0)\n\t\t\trc = -EIO;\n\t} else {\n\t\tstatus = get_unaligned_le16(status_buf);\n\n\t\tdev_info(&port->serial->dev->dev, \"read status %x %x\\n\",\n\t\t\t status_buf[0], status_buf[1]);\n\n\t\t*line_state_p = klsi_105_status2linestate(status);\n\t}\n\n\tkfree(status_buf);\n\treturn rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,10 +22,11 @@\n \t\t\t     status_buf, KLSI_STATUSBUF_LEN,\n \t\t\t     10000\n \t\t\t     );\n-\tif (rc < 0)\n-\t\tdev_err(&port->dev, \"Reading line status failed (error = %d)\\n\",\n-\t\t\trc);\n-\telse {\n+\tif (rc != KLSI_STATUSBUF_LEN) {\n+\t\tdev_err(&port->dev, \"reading line status failed: %d\\n\", rc);\n+\t\tif (rc >= 0)\n+\t\t\trc = -EIO;\n+\t} else {\n \t\tstatus = get_unaligned_le16(status_buf);\n \n \t\tdev_info(&port->serial->dev->dev, \"read status %x %x\\n\",",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (rc < 0)",
                "\t\tdev_err(&port->dev, \"Reading line status failed (error = %d)\\n\",",
                "\t\t\trc);",
                "\telse {"
            ],
            "added_lines": [
                "\tif (rc != KLSI_STATUSBUF_LEN) {",
                "\t\tdev_err(&port->dev, \"reading line status failed: %d\\n\", rc);",
                "\t\tif (rc >= 0)",
                "\t\t\trc = -EIO;",
                "\t} else {"
            ]
        }
    },
    {
        "cve_id": "CVE-2024-21668",
        "func_name": "mrousavy/react-native-mmkv/MmkvHostObject::MmkvHostObject",
        "description": "react-native-mmkv is a library that allows easy use of MMKV inside React Native applications. Before version 2.11.0, the react-native-mmkv logged the optional encryption key for the MMKV database into the Android system log. The key can be obtained by anyone with access to the Android Debugging Bridge (ADB) if it is enabled in the phone settings. This bug is not present on iOS devices. By logging the encryption secret to the system logs, attackers can trivially recover the secret by enabling ADB and undermining an app's thread model. This issue has been patched in version 2.11.0.",
        "git_url": "https://github.com/mrousavy/react-native-mmkv/commit/a8995ccb7184281f7d168bad3e9987c9bd05f00d",
        "commit_title": "fix: Don't leak encryption key in logs",
        "commit_text": "",
        "func_before": "MmkvHostObject::MmkvHostObject(const std::string& instanceId, std::string path,\n                               std::string cryptKey) {\n  __android_log_print(ANDROID_LOG_INFO, \"RNMMKV\",\n                      \"Creating MMKV instance \\\"%s\\\"... (Path: %s, Encryption-Key: %s)\",\n                      instanceId.c_str(), path.c_str(), cryptKey.c_str());\n  std::string* pathPtr = path.size() > 0 ? &path : nullptr;\n  std::string* cryptKeyPtr = cryptKey.size() > 0 ? &cryptKey : nullptr;\n  instance = MMKV::mmkvWithID(instanceId, mmkv::DEFAULT_MMAP_SIZE, MMKV_SINGLE_PROCESS, cryptKeyPtr,\n                              pathPtr);\n\n  if (instance == nullptr) {\n    // Check if instanceId is invalid\n    if (instanceId.empty()) {\n      throw std::runtime_error(\"Failed to create MMKV instance! `id` cannot be empty!\");\n    }\n\n    // Check if encryptionKey is invalid\n    if (cryptKey.size() > 16) {\n      throw std::runtime_error(\n          \"Failed to create MMKV instance! `encryptionKey` cannot be longer than 16 bytes!\");\n    }\n\n    throw std::runtime_error(\"Failed to create MMKV instance!\");\n  }\n}",
        "func": "MmkvHostObject::MmkvHostObject(const std::string& instanceId, std::string path,\n                               std::string cryptKey) {\n  bool hasEncryptionKey = cryptKey.size() > 0;\n  __android_log_print(ANDROID_LOG_INFO, \"RNMMKV\",\n                      \"Creating MMKV instance \\\"%s\\\"... (Path: %s, Encrypted: %b)\",\n                      instanceId.c_str(), path.c_str(), hasEncryptionKey);\n  std::string* pathPtr = path.size() > 0 ? &path : nullptr;\n  std::string* cryptKeyPtr = cryptKey.size() > 0 ? &cryptKey : nullptr;\n  instance = MMKV::mmkvWithID(instanceId, mmkv::DEFAULT_MMAP_SIZE, MMKV_SINGLE_PROCESS, cryptKeyPtr,\n                              pathPtr);\n\n  if (instance == nullptr) {\n    // Check if instanceId is invalid\n    if (instanceId.empty()) {\n      throw std::runtime_error(\"Failed to create MMKV instance! `id` cannot be empty!\");\n    }\n\n    // Check if encryptionKey is invalid\n    if (cryptKey.size() > 16) {\n      throw std::runtime_error(\n          \"Failed to create MMKV instance! `encryptionKey` cannot be longer than 16 bytes!\");\n    }\n\n    throw std::runtime_error(\"Failed to create MMKV instance!\");\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,9 @@\n MmkvHostObject::MmkvHostObject(const std::string& instanceId, std::string path,\n                                std::string cryptKey) {\n+  bool hasEncryptionKey = cryptKey.size() > 0;\n   __android_log_print(ANDROID_LOG_INFO, \"RNMMKV\",\n-                      \"Creating MMKV instance \\\"%s\\\"... (Path: %s, Encryption-Key: %s)\",\n-                      instanceId.c_str(), path.c_str(), cryptKey.c_str());\n+                      \"Creating MMKV instance \\\"%s\\\"... (Path: %s, Encrypted: %b)\",\n+                      instanceId.c_str(), path.c_str(), hasEncryptionKey);\n   std::string* pathPtr = path.size() > 0 ? &path : nullptr;\n   std::string* cryptKeyPtr = cryptKey.size() > 0 ? &cryptKey : nullptr;\n   instance = MMKV::mmkvWithID(instanceId, mmkv::DEFAULT_MMAP_SIZE, MMKV_SINGLE_PROCESS, cryptKeyPtr,",
        "diff_line_info": {
            "deleted_lines": [
                "                      \"Creating MMKV instance \\\"%s\\\"... (Path: %s, Encryption-Key: %s)\",",
                "                      instanceId.c_str(), path.c_str(), cryptKey.c_str());"
            ],
            "added_lines": [
                "  bool hasEncryptionKey = cryptKey.size() > 0;",
                "                      \"Creating MMKV instance \\\"%s\\\"... (Path: %s, Encrypted: %b)\",",
                "                      instanceId.c_str(), path.c_str(), hasEncryptionKey);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-13881",
        "func_name": "kravietz/pam_tacplus/_pam_parse",
        "description": "In support.c in pam_tacplus 1.3.8 through 1.5.1, the TACACS+ shared secret gets logged via syslog if the DEBUG loglevel and journald are used.",
        "git_url": "https://github.com/kravietz/pam_tacplus/commit/4a9852c31c2fd0c0e72fbb689a586aabcfb11cb0",
        "commit_title": "pam: don't leak TACACS+ secret to journald",
        "commit_text": " If journald for syslog is used, the journal is going to store everything, even DEBUG loglevel messages. Pre-journald logging of system-wide DEBUG loglevel could be avoided and is not affected in all cases.  With journald presence it's probably safe to no longer log sensitive details at DEBUG level.  Fix #149 ",
        "func_before": "int _pam_parse(int argc, const char **argv) {\n    int ctrl = 0;\n    const char *current_secret = NULL;\n\n    /* otherwise the list will grow with each call */\n    memset(tac_srv, 0, sizeof(tacplus_server_t) * TAC_PLUS_MAXSERVERS);\n    memset(&tac_srv_addr, 0, sizeof(struct addrinfo) * TAC_PLUS_MAXSERVERS);\n    memset(&tac_sock_addr, 0, sizeof(struct sockaddr) * TAC_PLUS_MAXSERVERS);\n    memset(&tac_sock6_addr, 0, sizeof(struct sockaddr_in6) * TAC_PLUS_MAXSERVERS);\n    tac_srv_no = 0;\n\n    tac_service[0] = 0;\n    tac_protocol[0] = 0;\n    tac_prompt[0] = 0;\n    tac_login[0] = 0;\n\n    for (ctrl = 0; argc-- > 0; ++argv) {\n        if (!strcmp(*argv, \"debug\")) { /* all */\n            ctrl |= PAM_TAC_DEBUG;\n        } else if (!strcmp(*argv, \"use_first_pass\")) {\n            ctrl |= PAM_TAC_USE_FIRST_PASS;\n        } else if (!strcmp(*argv, \"try_first_pass\")) {\n            ctrl |= PAM_TAC_TRY_FIRST_PASS;\n        } else if (!strncmp(*argv, \"service=\", 8)) { /* author & acct */\n            xstrcpy(tac_service, *argv + 8, sizeof(tac_service));\n        } else if (!strncmp(*argv, \"protocol=\", 9)) { /* author & acct */\n            xstrcpy(tac_protocol, *argv + 9, sizeof(tac_protocol));\n        } else if (!strncmp(*argv, \"prompt=\", 7)) { /* authentication */\n            xstrcpy(tac_prompt, *argv + 7, sizeof(tac_prompt));\n            /* Replace _ with space */\n            unsigned long chr;\n            for (chr = 0; chr < strlen(tac_prompt); chr++) {\n                if (tac_prompt[chr] == '_') {\n                    tac_prompt[chr] = ' ';\n                }\n            }\n        } else if (!strncmp(*argv, \"login=\", 6)) {\n            xstrcpy(tac_login, *argv + 6, sizeof(tac_login));\n        } else if (!strcmp(*argv, \"acct_all\")) {\n            ctrl |= PAM_TAC_ACCT;\n        } else if (!strncmp(*argv, \"server=\", 7)) { /* authen & acct */\n            if (tac_srv_no < TAC_PLUS_MAXSERVERS) {\n                struct addrinfo hints, *servers, *server;\n                int rv;\n                char *close_bracket, *server_name, *port, server_buf[256];\n\n                memset(&hints, 0, sizeof hints);\n                memset(&server_buf, 0, sizeof(server_buf));\n                hints.ai_family = AF_UNSPEC;  /* use IPv4 or IPv6, whichever */\n                hints.ai_socktype = SOCK_STREAM;\n\n                if (strlen(*argv + 7) >= sizeof(server_buf)) {\n                    _pam_log(LOG_ERR, \"server address too long, sorry\");\n                    continue;\n                }\n                strcpy(server_buf, *argv + 7);\n\n                if (*server_buf == '[' &&\n                    (close_bracket = strchr(server_buf, ']')) != NULL) { /* Check for URI syntax */\n                    server_name = server_buf + 1;\n                    _pam_log (LOG_ERR,\n                        \"reading server address as: %s \",\n                        server_name);\n                    port = strchr(close_bracket, ':');\n                    *close_bracket = '\\0';\n                } else { /* Fall back to traditional syntax */\n                    server_name = server_buf;\n                    port = strchr(server_buf, ':');\n                }\n                if (port != NULL) {\n                    *port = '\\0';\n                    port++;\n                }\n                _pam_log (LOG_DEBUG,\n                        \"sending server address to getaddrinfo as: %s \",\n                        server_name);\n                if ((rv = getaddrinfo(server_name, (port == NULL) ? \"49\" : port, &hints, &servers)) == 0) {\n                    for (server = servers;\n                         server != NULL && tac_srv_no < TAC_PLUS_MAXSERVERS; server = server->ai_next) {\n                        set_tac_srv_addr(tac_srv_no, server);\n                        set_tac_srv_key(tac_srv_no, current_secret);\n                        tac_srv_no++;\n                    }\n                    _pam_log(LOG_DEBUG, \"%s: server index %d \", __FUNCTION__, tac_srv_no);\n                    freeaddrinfo (servers);\n                } else {\n                    _pam_log(LOG_ERR,\n                             \"skip invalid server: %s (getaddrinfo: %s)\",\n                             server_name, gai_strerror(rv));\n                }\n            } else {\n                _pam_log(LOG_ERR, \"maximum number of servers (%d) exceeded, skipping\",\n                         TAC_PLUS_MAXSERVERS);\n            }\n        } else if (!strncmp(*argv, \"secret=\", 7)) {\n            current_secret = *argv + 7;     /* points right into argv (which is const) */\n\n            // this is possible because server structure is initialized only on the server= occurence\n            if (tac_srv_no == 0) {\n                _pam_log(LOG_ERR, \"secret set but no servers configured yet\");\n            } else {\n                // set secret for the last server configured\n                set_tac_srv_key(tac_srv_no - 1, current_secret);\n            }\n        } else if (!strncmp(*argv, \"timeout=\", 8)) {\n\n#ifdef HAVE_STRTOL\n            tac_timeout = strtol(*argv + 8, NULL, 10);\n\n#else\n            tac_timeout = atoi(*argv + 8);\n#endif\n            if (tac_timeout == LONG_MAX) {\n                _pam_log(LOG_ERR, \"timeout parameter cannot be parsed as integer: %s\", *argv);\n                tac_timeout = 0;\n            } else {\n                tac_readtimeout_enable = 1;\n            }\n        } else {\n            _pam_log(LOG_WARNING, \"unrecognized option: %s\", *argv);\n        }\n    }\n\n    if (ctrl & PAM_TAC_DEBUG) {\n        unsigned long n;\n\n        _pam_log(LOG_DEBUG, \"%d servers defined\", tac_srv_no);\n\n        for (n = 0; n < tac_srv_no; n++) {\n            _pam_log(LOG_DEBUG, \"server[%lu] { addr=%s, key='%s' }\", n, tac_ntop(tac_srv[n].addr->ai_addr),\n                     tac_srv[n].key);\n        }\n\n        _pam_log(LOG_DEBUG, \"tac_service='%s'\", tac_service);\n        _pam_log(LOG_DEBUG, \"tac_protocol='%s'\", tac_protocol);\n        _pam_log(LOG_DEBUG, \"tac_prompt='%s'\", tac_prompt);\n        _pam_log(LOG_DEBUG, \"tac_login='%s'\", tac_login);\n    }\n\n    return ctrl;\n}",
        "func": "int _pam_parse(int argc, const char **argv) {\n    int ctrl = 0;\n    const char *current_secret = NULL;\n\n    /* otherwise the list will grow with each call */\n    memset(tac_srv, 0, sizeof(tacplus_server_t) * TAC_PLUS_MAXSERVERS);\n    memset(&tac_srv_addr, 0, sizeof(struct addrinfo) * TAC_PLUS_MAXSERVERS);\n    memset(&tac_sock_addr, 0, sizeof(struct sockaddr) * TAC_PLUS_MAXSERVERS);\n    memset(&tac_sock6_addr, 0, sizeof(struct sockaddr_in6) * TAC_PLUS_MAXSERVERS);\n    tac_srv_no = 0;\n\n    tac_service[0] = 0;\n    tac_protocol[0] = 0;\n    tac_prompt[0] = 0;\n    tac_login[0] = 0;\n\n    for (ctrl = 0; argc-- > 0; ++argv) {\n        if (!strcmp(*argv, \"debug\")) { /* all */\n            ctrl |= PAM_TAC_DEBUG;\n        } else if (!strcmp(*argv, \"use_first_pass\")) {\n            ctrl |= PAM_TAC_USE_FIRST_PASS;\n        } else if (!strcmp(*argv, \"try_first_pass\")) {\n            ctrl |= PAM_TAC_TRY_FIRST_PASS;\n        } else if (!strncmp(*argv, \"service=\", 8)) { /* author & acct */\n            xstrcpy(tac_service, *argv + 8, sizeof(tac_service));\n        } else if (!strncmp(*argv, \"protocol=\", 9)) { /* author & acct */\n            xstrcpy(tac_protocol, *argv + 9, sizeof(tac_protocol));\n        } else if (!strncmp(*argv, \"prompt=\", 7)) { /* authentication */\n            xstrcpy(tac_prompt, *argv + 7, sizeof(tac_prompt));\n            /* Replace _ with space */\n            unsigned long chr;\n            for (chr = 0; chr < strlen(tac_prompt); chr++) {\n                if (tac_prompt[chr] == '_') {\n                    tac_prompt[chr] = ' ';\n                }\n            }\n        } else if (!strncmp(*argv, \"login=\", 6)) {\n            xstrcpy(tac_login, *argv + 6, sizeof(tac_login));\n        } else if (!strcmp(*argv, \"acct_all\")) {\n            ctrl |= PAM_TAC_ACCT;\n        } else if (!strncmp(*argv, \"server=\", 7)) { /* authen & acct */\n            if (tac_srv_no < TAC_PLUS_MAXSERVERS) {\n                struct addrinfo hints, *servers, *server;\n                int rv;\n                char *close_bracket, *server_name, *port, server_buf[256];\n\n                memset(&hints, 0, sizeof hints);\n                memset(&server_buf, 0, sizeof(server_buf));\n                hints.ai_family = AF_UNSPEC;  /* use IPv4 or IPv6, whichever */\n                hints.ai_socktype = SOCK_STREAM;\n\n                if (strlen(*argv + 7) >= sizeof(server_buf)) {\n                    _pam_log(LOG_ERR, \"server address too long, sorry\");\n                    continue;\n                }\n                strcpy(server_buf, *argv + 7);\n\n                if (*server_buf == '[' &&\n                    (close_bracket = strchr(server_buf, ']')) != NULL) { /* Check for URI syntax */\n                    server_name = server_buf + 1;\n                    _pam_log (LOG_ERR,\n                        \"reading server address as: %s \",\n                        server_name);\n                    port = strchr(close_bracket, ':');\n                    *close_bracket = '\\0';\n                } else { /* Fall back to traditional syntax */\n                    server_name = server_buf;\n                    port = strchr(server_buf, ':');\n                }\n                if (port != NULL) {\n                    *port = '\\0';\n                    port++;\n                }\n                _pam_log (LOG_DEBUG,\n                        \"sending server address to getaddrinfo as: %s \",\n                        server_name);\n                if ((rv = getaddrinfo(server_name, (port == NULL) ? \"49\" : port, &hints, &servers)) == 0) {\n                    for (server = servers;\n                         server != NULL && tac_srv_no < TAC_PLUS_MAXSERVERS; server = server->ai_next) {\n                        set_tac_srv_addr(tac_srv_no, server);\n                        set_tac_srv_key(tac_srv_no, current_secret);\n                        tac_srv_no++;\n                    }\n                    _pam_log(LOG_DEBUG, \"%s: server index %d \", __FUNCTION__, tac_srv_no);\n                    freeaddrinfo (servers);\n                } else {\n                    _pam_log(LOG_ERR,\n                             \"skip invalid server: %s (getaddrinfo: %s)\",\n                             server_name, gai_strerror(rv));\n                }\n            } else {\n                _pam_log(LOG_ERR, \"maximum number of servers (%d) exceeded, skipping\",\n                         TAC_PLUS_MAXSERVERS);\n            }\n        } else if (!strncmp(*argv, \"secret=\", 7)) {\n            current_secret = *argv + 7;     /* points right into argv (which is const) */\n\n            // this is possible because server structure is initialized only on the server= occurence\n            if (tac_srv_no == 0) {\n                _pam_log(LOG_ERR, \"secret set but no servers configured yet\");\n            } else {\n                // set secret for the last server configured\n                set_tac_srv_key(tac_srv_no - 1, current_secret);\n            }\n        } else if (!strncmp(*argv, \"timeout=\", 8)) {\n\n#ifdef HAVE_STRTOL\n            tac_timeout = strtol(*argv + 8, NULL, 10);\n\n#else\n            tac_timeout = atoi(*argv + 8);\n#endif\n            if (tac_timeout == LONG_MAX) {\n                _pam_log(LOG_ERR, \"timeout parameter cannot be parsed as integer: %s\", *argv);\n                tac_timeout = 0;\n            } else {\n                tac_readtimeout_enable = 1;\n            }\n        } else {\n            _pam_log(LOG_WARNING, \"unrecognized option: %s\", *argv);\n        }\n    }\n\n    if (ctrl & PAM_TAC_DEBUG) {\n        unsigned long n;\n\n        _pam_log(LOG_DEBUG, \"%d servers defined\", tac_srv_no);\n\n        for (n = 0; n < tac_srv_no; n++) {\n            _pam_log(LOG_DEBUG, \"server[%lu] { addr=%s, key='********' }\", n,\n\t\t\t    tac_ntop(tac_srv[n].addr->ai_addr));\n        }\n\n        _pam_log(LOG_DEBUG, \"tac_service='%s'\", tac_service);\n        _pam_log(LOG_DEBUG, \"tac_protocol='%s'\", tac_protocol);\n        _pam_log(LOG_DEBUG, \"tac_prompt='%s'\", tac_prompt);\n        _pam_log(LOG_DEBUG, \"tac_login='%s'\", tac_login);\n    }\n\n    return ctrl;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -127,8 +127,8 @@\n         _pam_log(LOG_DEBUG, \"%d servers defined\", tac_srv_no);\n \n         for (n = 0; n < tac_srv_no; n++) {\n-            _pam_log(LOG_DEBUG, \"server[%lu] { addr=%s, key='%s' }\", n, tac_ntop(tac_srv[n].addr->ai_addr),\n-                     tac_srv[n].key);\n+            _pam_log(LOG_DEBUG, \"server[%lu] { addr=%s, key='********' }\", n,\n+\t\t\t    tac_ntop(tac_srv[n].addr->ai_addr));\n         }\n \n         _pam_log(LOG_DEBUG, \"tac_service='%s'\", tac_service);",
        "diff_line_info": {
            "deleted_lines": [
                "            _pam_log(LOG_DEBUG, \"server[%lu] { addr=%s, key='%s' }\", n, tac_ntop(tac_srv[n].addr->ai_addr),",
                "                     tac_srv[n].key);"
            ],
            "added_lines": [
                "            _pam_log(LOG_DEBUG, \"server[%lu] { addr=%s, key='********' }\", n,",
                "\t\t\t    tac_ntop(tac_srv[n].addr->ai_addr));"
            ]
        }
    }
]