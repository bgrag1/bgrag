[
    {
        "cve_id": "CVE-2019-16346",
        "func_name": "miniupnp/ngiflib/WritePixel",
        "description": "ngiflib 0.4 has a heap-based buffer overflow in WritePixel() in ngiflib.c when called from DecodeGifImg, because deinterlacing for small pictures is mishandled.",
        "git_url": "https://github.com/miniupnp/ngiflib/commit/37d939a6f511d16d4c95678025c235fe62e6417a",
        "commit_title": "fix deinterlacing for small pictures",
        "commit_text": " fixes #12",
        "func_before": "static void WritePixel(struct ngiflib_img * i, struct ngiflib_decode_context * context, u8 v) {\n\tstruct ngiflib_gif * p = i->parent;\n\n\tif(v!=i->gce.transparent_color || !i->gce.transparent_flag) {\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\tif(p->mode & NGIFLIB_MODE_INDEXED) {\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\t*context->frbuff_p.p8 = v;\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t} else\n\t\t\t*context->frbuff_p.p32 =\n\t\t\t   GifIndexToTrueColor(i->palette, v);\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t}\n\tif(--(context->Xtogo) <= 0) {\n\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\tif(p->line_cb) p->line_cb(p, context->line_p, context->curY);\n\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t\tcontext->Xtogo = i->width;\n\t\tswitch(context->pass) {\n\t\tcase 0:\n\t\t\tcontext->curY++;\n\t\t\tbreak;\n\t\tcase 1:\t/* 1st pass : every eighth row starting from 0 */\n\t\t\tcontext->curY += 8;\n\t\t\tif(context->curY >= p->height) {\n\t\t\t\tcontext->pass++;\n\t\t\t\tcontext->curY = i->posY + 4;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\t/* 2nd pass : every eighth row starting from 4 */\n\t\t\tcontext->curY += 8;\n\t\t\tif(context->curY >= p->height) {\n\t\t\t\tcontext->pass++;\n\t\t\t\tcontext->curY = i->posY + 2;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\t/* 3rd pass : every fourth row starting from 2 */\n\t\t\tcontext->curY += 4;\n\t\t\tif(context->curY >= p->height) {\n\t\t\t\tcontext->pass++;\n\t\t\t\tcontext->curY = i->posY + 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\t/* 4th pass : every odd row */\n\t\t\tcontext->curY += 2;\n\t\t\tbreak;\n\t\t}\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\tif(p->mode & NGIFLIB_MODE_INDEXED) {\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\t\tcontext->line_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width;\n\t\t\tcontext->frbuff_p.p8 = context->line_p.p8 + i->posX;\n\t\t\t#else\n\t\t\tcontext->frbuff_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width + i->posX;\n\t\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t} else {\n\t\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\t\tcontext->line_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width;\n\t\t\tcontext->frbuff_p.p32 = context->line_p.p32 + i->posX;\n\t\t\t#else\n\t\t\tcontext->frbuff_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width + i->posX;\n\t\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t} else {\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\tif(p->mode & NGIFLIB_MODE_INDEXED) {\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\tcontext->frbuff_p.p8++;\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t} else {\n\t\t\tcontext->frbuff_p.p32++;\n\t\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t}\n}",
        "func": "static void WritePixel(struct ngiflib_img * i, struct ngiflib_decode_context * context, u8 v) {\n\tstruct ngiflib_gif * p = i->parent;\n\n\tif(v!=i->gce.transparent_color || !i->gce.transparent_flag) {\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\tif(p->mode & NGIFLIB_MODE_INDEXED) {\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\t*context->frbuff_p.p8 = v;\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t} else\n\t\t\t*context->frbuff_p.p32 =\n\t\t\t   GifIndexToTrueColor(i->palette, v);\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t}\n\tif(--(context->Xtogo) <= 0) {\n\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\tif(p->line_cb) p->line_cb(p, context->line_p, context->curY);\n\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t\tcontext->Xtogo = i->width;\n\t\tswitch(context->pass) {\n\t\tcase 0:\n\t\t\tcontext->curY++;\n\t\t\tbreak;\n\t\tcase 1:\t/* 1st pass : every eighth row starting from 0 */\n\t\t\tcontext->curY += 8;\n\t\t\tbreak;\n\t\tcase 2:\t/* 2nd pass : every eighth row starting from 4 */\n\t\t\tcontext->curY += 8;\n\t\t\tbreak;\n\t\tcase 3:\t/* 3rd pass : every fourth row starting from 2 */\n\t\t\tcontext->curY += 4;\n\t\t\tbreak;\n\t\tcase 4:\t/* 4th pass : every odd row */\n\t\t\tcontext->curY += 2;\n\t\t\tbreak;\n\t\t}\n\t\twhile(context->pass > 0 && context->pass < 4 &&\n\t\t      context->curY >= p->height) {\n\t\t\tswitch(++context->pass) {\n\t\t\tcase 2:\t/* 2nd pass : every eighth row starting from 4 */\n\t\t\t\tcontext->curY = i->posY + 4;\n\t\t\t\tbreak;\n\t\t\tcase 3:\t/* 3rd pass : every fourth row starting from 2 */\n\t\t\t\tcontext->curY = i->posY + 2;\n\t\t\t\tbreak;\n\t\t\tcase 4:\t/* 4th pass : every odd row */\n\t\t\t\tcontext->curY = i->posY + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\tif(p->mode & NGIFLIB_MODE_INDEXED) {\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\t\tcontext->line_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width;\n\t\t\tcontext->frbuff_p.p8 = context->line_p.p8 + i->posX;\n\t\t\t#else\n\t\t\tcontext->frbuff_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width + i->posX;\n\t\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t} else {\n\t\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\t\tcontext->line_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width;\n\t\t\tcontext->frbuff_p.p32 = context->line_p.p32 + i->posX;\n\t\t\t#else\n\t\t\tcontext->frbuff_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width + i->posX;\n\t\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t} else {\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\tif(p->mode & NGIFLIB_MODE_INDEXED) {\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\tcontext->frbuff_p.p8++;\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t} else {\n\t\t\tcontext->frbuff_p.p32++;\n\t\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,28 +23,30 @@\n \t\t\tbreak;\n \t\tcase 1:\t/* 1st pass : every eighth row starting from 0 */\n \t\t\tcontext->curY += 8;\n-\t\t\tif(context->curY >= p->height) {\n-\t\t\t\tcontext->pass++;\n-\t\t\t\tcontext->curY = i->posY + 4;\n-\t\t\t}\n \t\t\tbreak;\n \t\tcase 2:\t/* 2nd pass : every eighth row starting from 4 */\n \t\t\tcontext->curY += 8;\n-\t\t\tif(context->curY >= p->height) {\n-\t\t\t\tcontext->pass++;\n-\t\t\t\tcontext->curY = i->posY + 2;\n-\t\t\t}\n \t\t\tbreak;\n \t\tcase 3:\t/* 3rd pass : every fourth row starting from 2 */\n \t\t\tcontext->curY += 4;\n-\t\t\tif(context->curY >= p->height) {\n-\t\t\t\tcontext->pass++;\n-\t\t\t\tcontext->curY = i->posY + 1;\n-\t\t\t}\n \t\t\tbreak;\n \t\tcase 4:\t/* 4th pass : every odd row */\n \t\t\tcontext->curY += 2;\n \t\t\tbreak;\n+\t\t}\n+\t\twhile(context->pass > 0 && context->pass < 4 &&\n+\t\t      context->curY >= p->height) {\n+\t\t\tswitch(++context->pass) {\n+\t\t\tcase 2:\t/* 2nd pass : every eighth row starting from 4 */\n+\t\t\t\tcontext->curY = i->posY + 4;\n+\t\t\t\tbreak;\n+\t\t\tcase 3:\t/* 3rd pass : every fourth row starting from 2 */\n+\t\t\t\tcontext->curY = i->posY + 2;\n+\t\t\t\tbreak;\n+\t\t\tcase 4:\t/* 4th pass : every odd row */\n+\t\t\t\tcontext->curY = i->posY + 1;\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t}\n #ifndef NGIFLIB_INDEXED_ONLY\n \t\tif(p->mode & NGIFLIB_MODE_INDEXED) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tif(context->curY >= p->height) {",
                "\t\t\t\tcontext->pass++;",
                "\t\t\t\tcontext->curY = i->posY + 4;",
                "\t\t\t}",
                "\t\t\tif(context->curY >= p->height) {",
                "\t\t\t\tcontext->pass++;",
                "\t\t\t\tcontext->curY = i->posY + 2;",
                "\t\t\t}",
                "\t\t\tif(context->curY >= p->height) {",
                "\t\t\t\tcontext->pass++;",
                "\t\t\t\tcontext->curY = i->posY + 1;",
                "\t\t\t}"
            ],
            "added_lines": [
                "\t\t}",
                "\t\twhile(context->pass > 0 && context->pass < 4 &&",
                "\t\t      context->curY >= p->height) {",
                "\t\t\tswitch(++context->pass) {",
                "\t\t\tcase 2:\t/* 2nd pass : every eighth row starting from 4 */",
                "\t\t\t\tcontext->curY = i->posY + 4;",
                "\t\t\t\tbreak;",
                "\t\t\tcase 3:\t/* 3rd pass : every fourth row starting from 2 */",
                "\t\t\t\tcontext->curY = i->posY + 2;",
                "\t\t\t\tbreak;",
                "\t\t\tcase 4:\t/* 4th pass : every odd row */",
                "\t\t\t\tcontext->curY = i->posY + 1;",
                "\t\t\t\tbreak;",
                "\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16346",
        "func_name": "miniupnp/ngiflib/WritePixels",
        "description": "ngiflib 0.4 has a heap-based buffer overflow in WritePixel() in ngiflib.c when called from DecodeGifImg, because deinterlacing for small pictures is mishandled.",
        "git_url": "https://github.com/miniupnp/ngiflib/commit/37d939a6f511d16d4c95678025c235fe62e6417a",
        "commit_title": "fix deinterlacing for small pictures",
        "commit_text": " fixes #12",
        "func_before": "static void WritePixels(struct ngiflib_img * i, struct ngiflib_decode_context * context, const u8 * pixels, u16 n) {\n\tu16 tocopy;\t\n\tstruct ngiflib_gif * p = i->parent;\n\n\twhile(n > 0) {\n\t\ttocopy = (context->Xtogo < n) ? context->Xtogo : n;\n\t\tif(!i->gce.transparent_flag) {\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t\tif(p->mode & NGIFLIB_MODE_INDEXED) {\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\t\tngiflib_memcpy(context->frbuff_p.p8, pixels, tocopy);\n\t\t\t\tpixels += tocopy;\n\t\t\t\tcontext->frbuff_p.p8 += tocopy;\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t\t} else {\n\t\t\t\tint j;\n\t\t\t\tfor(j = (int)tocopy; j > 0; j--) {\n\t\t\t\t\t*(context->frbuff_p.p32++) =\n\t\t\t\t\t   GifIndexToTrueColor(i->palette, *pixels++);\n\t\t\t\t}\n\t\t\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t} else {\n\t\t\tint j;\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t\tif(p->mode & NGIFLIB_MODE_INDEXED) {\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\t\tfor(j = (int)tocopy; j > 0; j--) {\n\t\t\t\t\tif(*pixels != i->gce.transparent_color) *context->frbuff_p.p8 = *pixels;\n\t\t\t\t\tpixels++;\n\t\t\t\t\tcontext->frbuff_p.p8++;\n\t\t\t\t}\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t\t} else {\n\t\t\t\tfor(j = (int)tocopy; j > 0; j--) {\n\t\t\t\t\tif(*pixels != i->gce.transparent_color) {\n\t\t\t\t\t\t*context->frbuff_p.p32 = GifIndexToTrueColor(i->palette, *pixels);\n\t\t\t\t\t}\n\t\t\t\t\tpixels++;\n\t\t\t\t\tcontext->frbuff_p.p32++;\n\t\t\t\t}\n\t\t\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t}\n\t\tcontext->Xtogo -= tocopy;\n\t\tif(context->Xtogo == 0) {\n\t\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\t\tif(p->line_cb) p->line_cb(p, context->line_p, context->curY);\n\t\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t\t\tcontext->Xtogo = i->width;\n\t\t\tswitch(context->pass) {\n\t\t\tcase 0:\n\t\t\t\tcontext->curY++;\n\t\t\t\tbreak;\n\t\t\tcase 1:\t/* 1st pass : every eighth row starting from 0 */\n\t\t\t\tcontext->curY += 8;\n\t\t\t\tif(context->curY >= p->height) {\n\t\t\t\t\tcontext->pass++;\n\t\t\t\t\tcontext->curY = i->posY + 4;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\t/* 2nd pass : every eighth row starting from 4 */\n\t\t\t\tcontext->curY += 8;\n\t\t\t\tif(context->curY >= p->height) {\n\t\t\t\t\tcontext->pass++;\n\t\t\t\t\tcontext->curY = i->posY + 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\t/* 3rd pass : every fourth row starting from 2 */\n\t\t\t\tcontext->curY += 4;\n\t\t\t\tif(context->curY >= p->height) {\n\t\t\t\t\tcontext->pass++;\n\t\t\t\t\tcontext->curY = i->posY + 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\t/* 4th pass : every odd row */\n\t\t\t\tcontext->curY += 2;\n\t\t\t\tbreak;\n\t\t\t}\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t\tif(p->mode & NGIFLIB_MODE_INDEXED) {\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\t\t\tcontext->line_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width;\n\t\t\t\tcontext->frbuff_p.p8 = context->line_p.p8 + i->posX;\n\t\t\t\t#else\n\t\t\t\tcontext->frbuff_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width + i->posX;\n\t\t\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t\t} else {\n\t\t\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\t\t\tcontext->line_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width;\n\t\t\t\tcontext->frbuff_p.p32 = context->line_p.p32 + i->posX;\n\t\t\t\t#else\n\t\t\t\tcontext->frbuff_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width + i->posX;\n\t\t\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t\t\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t}\n\t\tn -= tocopy;\n\t}\n}",
        "func": "static void WritePixels(struct ngiflib_img * i, struct ngiflib_decode_context * context, const u8 * pixels, u16 n) {\n\tu16 tocopy;\t\n\tstruct ngiflib_gif * p = i->parent;\n\n\twhile(n > 0) {\n\t\ttocopy = (context->Xtogo < n) ? context->Xtogo : n;\n\t\tif(!i->gce.transparent_flag) {\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t\tif(p->mode & NGIFLIB_MODE_INDEXED) {\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\t\tngiflib_memcpy(context->frbuff_p.p8, pixels, tocopy);\n\t\t\t\tpixels += tocopy;\n\t\t\t\tcontext->frbuff_p.p8 += tocopy;\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t\t} else {\n\t\t\t\tint j;\n\t\t\t\tfor(j = (int)tocopy; j > 0; j--) {\n\t\t\t\t\t*(context->frbuff_p.p32++) =\n\t\t\t\t\t   GifIndexToTrueColor(i->palette, *pixels++);\n\t\t\t\t}\n\t\t\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t} else {\n\t\t\tint j;\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t\tif(p->mode & NGIFLIB_MODE_INDEXED) {\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\t\tfor(j = (int)tocopy; j > 0; j--) {\n\t\t\t\t\tif(*pixels != i->gce.transparent_color) *context->frbuff_p.p8 = *pixels;\n\t\t\t\t\tpixels++;\n\t\t\t\t\tcontext->frbuff_p.p8++;\n\t\t\t\t}\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t\t} else {\n\t\t\t\tfor(j = (int)tocopy; j > 0; j--) {\n\t\t\t\t\tif(*pixels != i->gce.transparent_color) {\n\t\t\t\t\t\t*context->frbuff_p.p32 = GifIndexToTrueColor(i->palette, *pixels);\n\t\t\t\t\t}\n\t\t\t\t\tpixels++;\n\t\t\t\t\tcontext->frbuff_p.p32++;\n\t\t\t\t}\n\t\t\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t}\n\t\tcontext->Xtogo -= tocopy;\n\t\tif(context->Xtogo == 0) {\n\t\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\t\tif(p->line_cb) p->line_cb(p, context->line_p, context->curY);\n\t\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t\t\tcontext->Xtogo = i->width;\n\t\t\tswitch(context->pass) {\n\t\t\tcase 0:\n\t\t\t\tcontext->curY++;\n\t\t\t\tbreak;\n\t\t\tcase 1:\t/* 1st pass : every eighth row starting from 0 */\n\t\t\t\tcontext->curY += 8;\n\t\t\t\tbreak;\n\t\t\tcase 2:\t/* 2nd pass : every eighth row starting from 4 */\n\t\t\t\tcontext->curY += 8;\n\t\t\t\tbreak;\n\t\t\tcase 3:\t/* 3rd pass : every fourth row starting from 2 */\n\t\t\t\tcontext->curY += 4;\n\t\t\t\tbreak;\n\t\t\tcase 4:\t/* 4th pass : every odd row */\n\t\t\t\tcontext->curY += 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile(context->pass > 0 && context->pass < 4 &&\n\t\t\t      context->curY >= p->height) {\n\t\t\t\tswitch(++context->pass) {\n\t\t\t\tcase 2:\t/* 2nd pass : every eighth row starting from 4 */\n\t\t\t\t\tcontext->curY = i->posY + 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\t/* 3rd pass : every fourth row starting from 2 */\n\t\t\t\t\tcontext->curY = i->posY + 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\t/* 4th pass : every odd row */\n\t\t\t\t\tcontext->curY = i->posY + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t\tif(p->mode & NGIFLIB_MODE_INDEXED) {\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\t\t\tcontext->line_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width;\n\t\t\t\tcontext->frbuff_p.p8 = context->line_p.p8 + i->posX;\n\t\t\t\t#else\n\t\t\t\tcontext->frbuff_p.p8 = p->frbuff.p8 + (u32)context->curY*p->width + i->posX;\n\t\t\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n#ifndef NGIFLIB_INDEXED_ONLY\n\t\t\t} else {\n\t\t\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\t\t\tcontext->line_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width;\n\t\t\t\tcontext->frbuff_p.p32 = context->line_p.p32 + i->posX;\n\t\t\t\t#else\n\t\t\t\tcontext->frbuff_p.p32 = p->frbuff.p32 + (u32)context->curY*p->width + i->posX;\n\t\t\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t\t\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\t\t}\n\t\tn -= tocopy;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -54,28 +54,30 @@\n \t\t\t\tbreak;\n \t\t\tcase 1:\t/* 1st pass : every eighth row starting from 0 */\n \t\t\t\tcontext->curY += 8;\n-\t\t\t\tif(context->curY >= p->height) {\n-\t\t\t\t\tcontext->pass++;\n-\t\t\t\t\tcontext->curY = i->posY + 4;\n-\t\t\t\t}\n \t\t\t\tbreak;\n \t\t\tcase 2:\t/* 2nd pass : every eighth row starting from 4 */\n \t\t\t\tcontext->curY += 8;\n-\t\t\t\tif(context->curY >= p->height) {\n-\t\t\t\t\tcontext->pass++;\n-\t\t\t\t\tcontext->curY = i->posY + 2;\n-\t\t\t\t}\n \t\t\t\tbreak;\n \t\t\tcase 3:\t/* 3rd pass : every fourth row starting from 2 */\n \t\t\t\tcontext->curY += 4;\n-\t\t\t\tif(context->curY >= p->height) {\n-\t\t\t\t\tcontext->pass++;\n-\t\t\t\t\tcontext->curY = i->posY + 1;\n-\t\t\t\t}\n \t\t\t\tbreak;\n \t\t\tcase 4:\t/* 4th pass : every odd row */\n \t\t\t\tcontext->curY += 2;\n \t\t\t\tbreak;\n+\t\t\t}\n+\t\t\twhile(context->pass > 0 && context->pass < 4 &&\n+\t\t\t      context->curY >= p->height) {\n+\t\t\t\tswitch(++context->pass) {\n+\t\t\t\tcase 2:\t/* 2nd pass : every eighth row starting from 4 */\n+\t\t\t\t\tcontext->curY = i->posY + 4;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 3:\t/* 3rd pass : every fourth row starting from 2 */\n+\t\t\t\t\tcontext->curY = i->posY + 2;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 4:\t/* 4th pass : every odd row */\n+\t\t\t\t\tcontext->curY = i->posY + 1;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t}\n #ifndef NGIFLIB_INDEXED_ONLY\n \t\t\tif(p->mode & NGIFLIB_MODE_INDEXED) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\tif(context->curY >= p->height) {",
                "\t\t\t\t\tcontext->pass++;",
                "\t\t\t\t\tcontext->curY = i->posY + 4;",
                "\t\t\t\t}",
                "\t\t\t\tif(context->curY >= p->height) {",
                "\t\t\t\t\tcontext->pass++;",
                "\t\t\t\t\tcontext->curY = i->posY + 2;",
                "\t\t\t\t}",
                "\t\t\t\tif(context->curY >= p->height) {",
                "\t\t\t\t\tcontext->pass++;",
                "\t\t\t\t\tcontext->curY = i->posY + 1;",
                "\t\t\t\t}"
            ],
            "added_lines": [
                "\t\t\t}",
                "\t\t\twhile(context->pass > 0 && context->pass < 4 &&",
                "\t\t\t      context->curY >= p->height) {",
                "\t\t\t\tswitch(++context->pass) {",
                "\t\t\t\tcase 2:\t/* 2nd pass : every eighth row starting from 4 */",
                "\t\t\t\t\tcontext->curY = i->posY + 4;",
                "\t\t\t\t\tbreak;",
                "\t\t\t\tcase 3:\t/* 3rd pass : every fourth row starting from 2 */",
                "\t\t\t\t\tcontext->curY = i->posY + 2;",
                "\t\t\t\t\tbreak;",
                "\t\t\t\tcase 4:\t/* 4th pass : every odd row */",
                "\t\t\t\t\tcontext->curY = i->posY + 1;",
                "\t\t\t\t\tbreak;",
                "\t\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-0819",
        "func_name": "android/ihevcd_decode",
        "description": "A vulnerability in the Android media framework (n/a). Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0. Android ID: A-63045918.",
        "git_url": "https://android.googlesource.com/platform/external/libhevc/+/87fb7909c49e6a4510ba86ace1ffc83459c7e1b9",
        "commit_title": "Fix slice decrement for skipped slices",
        "commit_text": " Test: run the poc with and without the patch Bug: 63045918 (cherry picked from commit 272f2c23c8ba8579adb0618b4124163b9bf086fb) ",
        "func_before": "WORD32 ihevcd_decode(iv_obj_t *ps_codec_obj, void *pv_api_ip, void *pv_api_op)\n{\n    WORD32 ret = IV_SUCCESS;\n    codec_t *ps_codec = (codec_t *)(ps_codec_obj->pv_codec_handle);\n    ivd_video_decode_ip_t *ps_dec_ip;\n    ivd_video_decode_op_t *ps_dec_op;\n\n    WORD32 proc_idx = 0;\n    WORD32 prev_proc_idx = 0;\n\n    /* Initialize error code */\n    ps_codec->i4_error_code = 0;\n\n    ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;\n    ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;\n\n    {\n        UWORD32 u4_size = ps_dec_op->u4_size;\n        memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));\n        ps_dec_op->u4_size = u4_size; //Restore size field\n    }\n    if(ps_codec->i4_init_done != 1)\n    {\n        ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;\n        ps_dec_op->u4_error_code |= IHEVCD_INIT_NOT_DONE;\n        return IV_FAIL;\n    }\n\n    if(ps_codec->u4_pic_cnt >= NUM_FRAMES_LIMIT)\n    {\n        ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;\n        ps_dec_op->u4_error_code |= IHEVCD_NUM_FRAMES_LIMIT_REACHED;\n        return IV_FAIL;\n    }\n\n    /* If reset flag is set, flush the existing buffers */\n    if(ps_codec->i4_reset_flag)\n    {\n        ps_codec->i4_flush_mode = 1;\n    }\n\n    /*Data memory barries instruction,so that bitstream write by the application is complete*/\n    //arm_dsb();\n    /* In case the decoder is not in flush mode check for input buffer validity */\n    if(0 == ps_codec->i4_flush_mode)\n    {\n        if(ps_dec_ip->pv_stream_buffer == NULL)\n        {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;\n            return IV_FAIL;\n        }\n        if(ps_dec_ip->u4_num_Bytes <= MIN_START_CODE_LEN)\n        {\n            if((WORD32)ps_dec_ip->u4_num_Bytes > 0)\n                ps_dec_op->u4_num_bytes_consumed = ps_dec_ip->u4_num_Bytes;\n            else\n                ps_dec_op->u4_num_bytes_consumed = 0;\n\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;\n            return IV_FAIL;\n\n        }\n    }\n\n#ifdef APPLY_CONCEALMENT\n    {\n        WORD32 num_mbs;\n\n        num_mbs = (ps_codec->i4_wd * ps_codec->i4_ht + 255) >> 8;\n        /* Reset MB Count at the beginning of every process call */\n        ps_codec->mb_count = 0;\n        memset(ps_codec->mb_map, 0, ((num_mbs + 7) >> 3));\n    }\n#endif\n\n    if(0 == ps_codec->i4_share_disp_buf && ps_codec->i4_header_mode == 0)\n    {\n        UWORD32 i;\n        if(ps_dec_ip->s_out_buffer.u4_num_bufs == 0)\n        {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;\n            return IV_FAIL;\n        }\n\n        for(i = 0; i < ps_dec_ip->s_out_buffer.u4_num_bufs; i++)\n        {\n            if(ps_dec_ip->s_out_buffer.pu1_bufs[i] == NULL)\n            {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;\n                return IV_FAIL;\n            }\n\n            if(ps_dec_ip->s_out_buffer.u4_min_out_buf_size[i] == 0)\n            {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE;\n                return IV_FAIL;\n            }\n        }\n    }\n\n    ps_codec->ps_out_buffer = &ps_dec_ip->s_out_buffer;\n    ps_codec->u4_ts = ps_dec_ip->u4_ts;\n    if(ps_codec->i4_flush_mode)\n    {\n\n        ps_dec_op->u4_pic_wd = ps_codec->i4_disp_wd;\n        ps_dec_op->u4_pic_ht = ps_codec->i4_disp_ht;\n\n        ps_dec_op->u4_new_seq = 0;\n\n        ps_codec->ps_disp_buf = (pic_buf_t *)ihevc_disp_mgr_get(\n                        (disp_mgr_t *)ps_codec->pv_disp_buf_mgr, &ps_codec->i4_disp_buf_id);\n        /* In case of non-shared mode, then convert/copy the frame to output buffer */\n        /* Only if the codec is in non-shared mode or in shared mode but needs 420P output */\n        if((ps_codec->ps_disp_buf)\n                        && ((0 == ps_codec->i4_share_disp_buf)\n                                        || (IV_YUV_420P\n                                                        == ps_codec->e_chroma_fmt)))\n        {\n\n            process_ctxt_t *ps_proc = &ps_codec->as_process[prev_proc_idx];\n            if(0 == ps_proc->i4_init_done)\n            {\n                ihevcd_init_proc_ctxt(ps_proc, 0);\n            }\n\n            /* Output buffer check */\n            ret = ihevcd_check_out_buf_size(ps_codec);\n            RETURN_IF((ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS), ret);\n\n            /* Set remaining number of rows to be processed */\n            ret = ihevcd_fmt_conv(ps_codec, &ps_codec->as_process[prev_proc_idx],\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[0],\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[1],\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[2], 0,\n                                  ps_codec->i4_disp_ht);\n\n            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,\n                                  ps_codec->i4_disp_buf_id, BUF_MGR_DISP);\n        }\n\n        ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);\n\n        if(1 == ps_dec_op->u4_output_present)\n        {\n            WORD32 xpos = ps_codec->i4_disp_wd - 32 - LOGO_WD;\n            WORD32 ypos = ps_codec->i4_disp_ht - 32 - LOGO_HT;\n\n            if(ypos < 0)\n                ypos = 0;\n\n            if(xpos < 0)\n                xpos = 0;\n\n            INSERT_LOGO(ps_dec_ip->s_out_buffer.pu1_bufs[0],\n                        ps_dec_ip->s_out_buffer.pu1_bufs[1],\n                        ps_dec_ip->s_out_buffer.pu1_bufs[2], ps_codec->i4_disp_strd,\n                        xpos,\n                        ypos,\n                        ps_codec->e_chroma_fmt,\n                        ps_codec->i4_disp_wd,\n                        ps_codec->i4_disp_ht);\n        }\n\n\n        if(NULL == ps_codec->ps_disp_buf)\n        {\n            /* If in flush mode and there are no more buffers to flush,\n             * check for the reset flag and reset the decoder */\n            if(ps_codec->i4_reset_flag)\n            {\n                ihevcd_init(ps_codec);\n            }\n            return (IV_FAIL);\n        }\n\n        return (IV_SUCCESS);\n\n    }\n    /* In case of shared mode, check if there is a free buffer for reconstruction */\n    if((0 == ps_codec->i4_header_mode) && (1 == ps_codec->i4_share_disp_buf))\n    {\n        WORD32 buf_status;\n        buf_status = 1;\n        if(ps_codec->pv_pic_buf_mgr)\n            buf_status = ihevc_buf_mgr_check_free((buf_mgr_t *)ps_codec->pv_pic_buf_mgr);\n\n        /* If there is no free buffer, then return with an error code */\n        if(0 == buf_status)\n        {\n            ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\n            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n            return IV_FAIL;\n        }\n    }\n    ps_codec->i4_bytes_remaining = ps_dec_ip->u4_num_Bytes;\n    ps_codec->pu1_inp_bitsbuf = (UWORD8 *)ps_dec_ip->pv_stream_buffer;\n    ps_codec->s_parse.i4_end_of_frame = 0;\n\n    ps_codec->i4_pic_present = 0;\n    ps_codec->i4_slice_error = 0;\n    ps_codec->ps_disp_buf = NULL;\n\n    if(ps_codec->i4_num_cores > 1)\n    {\n        ithread_set_affinity(0);\n    }\n    while(MIN_START_CODE_LEN < ps_codec->i4_bytes_remaining)\n    {\n        WORD32 nal_len;\n        WORD32 nal_ofst;\n        WORD32 bits_len;\n\n        if(ps_codec->i4_slice_error)\n        {\n            slice_header_t *ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));\n            WORD32 next_slice_addr = ps_slice_hdr_next->i2_ctb_x +\n                            ps_slice_hdr_next->i2_ctb_y * ps_codec->s_parse.ps_sps->i2_pic_wd_in_ctb;\n            if(ps_codec->s_parse.i4_next_ctb_indx == next_slice_addr)\n                ps_codec->i4_slice_error = 0;\n        }\n\n        if(ps_codec->pu1_bitsbuf_dynamic)\n        {\n            ps_codec->pu1_bitsbuf = ps_codec->pu1_bitsbuf_dynamic;\n            ps_codec->u4_bitsbuf_size = ps_codec->u4_bitsbuf_size_dynamic;\n        }\n        else\n        {\n            ps_codec->pu1_bitsbuf = ps_codec->pu1_bitsbuf_static;\n            ps_codec->u4_bitsbuf_size = ps_codec->u4_bitsbuf_size_static;\n        }\n\n        nal_ofst = ihevcd_nal_search_start_code(ps_codec->pu1_inp_bitsbuf,\n                                                ps_codec->i4_bytes_remaining);\n\n        ps_codec->i4_nal_ofst = nal_ofst;\n        {\n            WORD32 bytes_remaining = ps_codec->i4_bytes_remaining - nal_ofst;\n\n            bytes_remaining = MIN((UWORD32)bytes_remaining, ps_codec->u4_bitsbuf_size);\n            ihevcd_nal_remv_emuln_bytes(ps_codec->pu1_inp_bitsbuf + nal_ofst,\n                                        ps_codec->pu1_bitsbuf,\n                                        bytes_remaining,\n                                        &nal_len, &bits_len);\n\n            /* Decoder may read upto 8 extra bytes at the end of frame */\n            /* These are not used, but still set them to zero to avoid uninitialized reads */\n            if(bits_len < (WORD32)(ps_codec->u4_bitsbuf_size - 8))\n            {\n                memset(ps_codec->pu1_bitsbuf + bits_len, 0, 2 * sizeof(UWORD32));\n            }\n        }\n        /* This may be used to update the offsets for tiles and entropy sync row offsets */\n        ps_codec->i4_num_emln_bytes = nal_len - bits_len;\n        ps_codec->i4_nal_len = nal_len;\n\n        ihevcd_bits_init(&ps_codec->s_parse.s_bitstrm, ps_codec->pu1_bitsbuf,\n                         bits_len);\n\n        ret = ihevcd_nal_unit(ps_codec);\n\n        /* If the frame is incomplete and\n         * the bytes remaining is zero or a header is received,\n         * complete the frame treating it to be in error */\n        if(ps_codec->i4_pic_present &&\n                        (ps_codec->s_parse.i4_next_ctb_indx != ps_codec->s_parse.ps_sps->i4_pic_size_in_ctb))\n        {\n            if((ps_codec->i4_bytes_remaining - (nal_len + nal_ofst) <= MIN_START_CODE_LEN) ||\n                            (ps_codec->i4_header_in_slice_mode))\n            {\n                slice_header_t *ps_slice_hdr_next;\n\n                ps_codec->s_parse.i4_cur_slice_idx--;\n                if(ps_codec->s_parse.i4_cur_slice_idx < 0)\n                    ps_codec->s_parse.i4_cur_slice_idx = 0;\n\n                ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));\n                ps_slice_hdr_next->i2_ctb_x = 0;\n                ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;\n                ps_codec->i4_slice_error = 1;\n                continue;\n            }\n        }\n\n        if(IHEVCD_IGNORE_SLICE == ret)\n        {\n            ps_codec->s_parse.i4_cur_slice_idx = MAX(0, (ps_codec->s_parse.i4_cur_slice_idx - 1));\n            ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len);\n            ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len);\n\n            continue;\n        }\n\n        if((IVD_RES_CHANGED == ret) ||\n           (IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED == ret))\n        {\n            break;\n        }\n\n        /* Update bytes remaining and bytes consumed and input bitstream pointer */\n        /* Do not consume the NAL in the following cases */\n        /* Slice header reached during header decode mode */\n        /* TODO: Next picture's slice reached */\n        if(ret != IHEVCD_SLICE_IN_HEADER_MODE)\n        {\n            if((0 == ps_codec->i4_slice_error) ||\n                            (ps_codec->i4_bytes_remaining - (nal_len + nal_ofst) <= MIN_START_CODE_LEN))\n            {\n                ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len);\n                ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len);\n            }\n            if(ret != IHEVCD_SUCCESS)\n                break;\n\n            if(ps_codec->s_parse.i4_end_of_frame)\n                break;\n        }\n        else\n        {\n            ret = IHEVCD_SUCCESS;\n            break;\n        }\n\n        /* Allocate dynamic bitstream buffer once SPS is decoded */\n        if((ps_codec->u4_allocate_dynamic_done == 0) && ps_codec->i4_sps_done)\n        {\n            WORD32 ret;\n            ret = ihevcd_allocate_dynamic_bufs(ps_codec);\n            if(ret != IV_SUCCESS)\n            {\n                /* Free any dynamic buffers that are allocated */\n                ihevcd_free_dynamic_bufs(ps_codec);\n                ps_codec->i4_error_code = IVD_MEM_ALLOC_FAILED;\n                ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;\n                ps_dec_op->u4_error_code |= IVD_MEM_ALLOC_FAILED;\n\n                return IV_FAIL;\n            }\n        }\n\n        BREAK_AFTER_SLICE_NAL();\n    }\n\n    if((ps_codec->u4_pic_cnt == 0) && (ret != IHEVCD_SUCCESS))\n    {\n        ps_codec->i4_error_code = ret;\n\n        ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);\n        return IV_FAIL;\n    }\n\n    if(1 == ps_codec->i4_pic_present)\n    {\n        WORD32 i;\n        sps_t *ps_sps = ps_codec->s_parse.ps_sps;\n        ps_codec->i4_first_pic_done = 1;\n\n        /*TODO temporary fix: end_of_frame is checked before adding format conversion to job queue         */\n        if(ps_codec->i4_num_cores > 1 && ps_codec->s_parse.i4_end_of_frame)\n        {\n\n            /* Add job queue for format conversion / frame copy for each ctb row */\n            /* Only if the codec is in non-shared mode or in shared mode but needs 420P output */\n            process_ctxt_t *ps_proc;\n\n            /* i4_num_cores - 1 contexts are currently being used by other threads */\n            ps_proc = &ps_codec->as_process[ps_codec->i4_num_cores - 1];\n\n            if((ps_codec->ps_disp_buf) &&\n               ((0 == ps_codec->i4_share_disp_buf) || (IV_YUV_420P == ps_codec->e_chroma_fmt)))\n            {\n                /* If format conversion jobs were not issued in pic_init() add them here */\n                if((0 == ps_codec->u4_enable_fmt_conv_ahead) ||\n                                (ps_codec->i4_disp_buf_id == ps_proc->i4_cur_pic_buf_id))\n                    for(i = 0; i < ps_sps->i2_pic_ht_in_ctb; i++)\n                    {\n                        proc_job_t s_job;\n                        IHEVCD_ERROR_T ret;\n                        s_job.i4_cmd = CMD_FMTCONV;\n                        s_job.i2_ctb_cnt = 0;\n                        s_job.i2_ctb_x = 0;\n                        s_job.i2_ctb_y = i;\n                        s_job.i2_slice_idx = 0;\n                        s_job.i4_tu_coeff_data_ofst = 0;\n                        ret = ihevcd_jobq_queue((jobq_t *)ps_codec->s_parse.pv_proc_jobq,\n                                                &s_job, sizeof(proc_job_t), 1);\n                        if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)\n                            return (WORD32)ret;\n                    }\n            }\n            /* Reached end of frame : Signal terminate */\n            /* The terminate flag is checked only after all the jobs are dequeued */\n            ret = ihevcd_jobq_terminate((jobq_t *)ps_codec->s_parse.pv_proc_jobq);\n\n            while(1)\n            {\n                IHEVCD_ERROR_T ret;\n                proc_job_t s_job;\n                process_ctxt_t *ps_proc;\n\n                /* i4_num_cores - 1 contexts are currently being used by other threads */\n                ps_proc = &ps_codec->as_process[ps_codec->i4_num_cores - 1];\n\n                ret = ihevcd_jobq_dequeue((jobq_t *)ps_proc->pv_proc_jobq, &s_job,\n                                          sizeof(proc_job_t), 1);\n                if((IHEVCD_ERROR_T)IHEVCD_SUCCESS != ret)\n                    break;\n\n                ps_proc->i4_ctb_cnt = s_job.i2_ctb_cnt;\n                ps_proc->i4_ctb_x = s_job.i2_ctb_x;\n                ps_proc->i4_ctb_y = s_job.i2_ctb_y;\n                ps_proc->i4_cur_slice_idx = s_job.i2_slice_idx;\n\n                if(CMD_PROCESS == s_job.i4_cmd)\n                {\n                    ihevcd_init_proc_ctxt(ps_proc, s_job.i4_tu_coeff_data_ofst);\n\n                    ihevcd_process(ps_proc);\n                }\n                else if(CMD_FMTCONV == s_job.i4_cmd)\n                {\n                    sps_t *ps_sps = ps_codec->s_parse.ps_sps;\n                    WORD32 num_rows = 1 << ps_sps->i1_log2_ctb_size;\n                    if(0 == ps_proc->i4_init_done)\n                    {\n                        ihevcd_init_proc_ctxt(ps_proc, 0);\n                    }\n\n                    num_rows = MIN(num_rows, (ps_codec->i4_disp_ht - (s_job.i2_ctb_y << ps_sps->i1_log2_ctb_size)));\n                    if(num_rows < 0)\n                        num_rows = 0;\n\n                    ihevcd_fmt_conv(ps_codec, ps_proc,\n                                    ps_dec_ip->s_out_buffer.pu1_bufs[0],\n                                    ps_dec_ip->s_out_buffer.pu1_bufs[1],\n                                    ps_dec_ip->s_out_buffer.pu1_bufs[2],\n                                    s_job.i2_ctb_y << ps_sps->i1_log2_ctb_size,\n                                    num_rows);\n                }\n            }\n        }\n        /* In case of non-shared mode and while running in single core mode, then convert/copy the frame to output buffer */\n        /* Only if the codec is in non-shared mode or in shared mode but needs 420P output */\n        else if((ps_codec->ps_disp_buf) && ((0 == ps_codec->i4_share_disp_buf) ||\n                                            (IV_YUV_420P == ps_codec->e_chroma_fmt)) &&\n                        (ps_codec->s_parse.i4_end_of_frame))\n        {\n            process_ctxt_t *ps_proc = &ps_codec->as_process[proc_idx];\n            /* Set remaining number of rows to be processed */\n            ps_codec->s_fmt_conv.i4_num_rows = ps_codec->i4_disp_ht\n                            - ps_codec->s_fmt_conv.i4_cur_row;\n            if(0 == ps_proc->i4_init_done)\n            {\n                ihevcd_init_proc_ctxt(ps_proc, 0);\n            }\n\n            if(ps_codec->s_fmt_conv.i4_num_rows < 0)\n                ps_codec->s_fmt_conv.i4_num_rows = 0;\n\n            ret = ihevcd_fmt_conv(ps_codec, ps_proc,\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[0],\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[1],\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[2],\n                                  ps_codec->s_fmt_conv.i4_cur_row,\n                                  ps_codec->s_fmt_conv.i4_num_rows);\n            ps_codec->s_fmt_conv.i4_cur_row += ps_codec->s_fmt_conv.i4_num_rows;\n\n        }\n\n\n        DEBUG_DUMP_MV_MAP(ps_codec);\n\n        /* Mark MV Buf as needed for reference */\n        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_mv_buf_mgr,\n                                 ps_codec->as_process[proc_idx].i4_cur_mv_bank_buf_id,\n                                 BUF_MGR_REF);\n\n        /* Mark pic buf as needed for reference */\n        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,\n                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id,\n                                 BUF_MGR_REF);\n\n        /* Mark pic buf as needed for display */\n        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,\n                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id,\n                                 BUF_MGR_DISP);\n\n        /* Insert the current picture as short term reference */\n        ihevc_dpb_mgr_insert_ref((dpb_mgr_t *)ps_codec->pv_dpb_mgr,\n                                 ps_codec->as_process[proc_idx].ps_cur_pic,\n                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id);\n\n        /* If a frame was displayed (in non-shared mode), then release it from display manager */\n        if((0 == ps_codec->i4_share_disp_buf) && (ps_codec->ps_disp_buf))\n            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,\n                                  ps_codec->i4_disp_buf_id, BUF_MGR_DISP);\n\n        /* Wait for threads */\n        for(i = 0; i < (ps_codec->i4_num_cores - 1); i++)\n        {\n            if(ps_codec->ai4_process_thread_created[i])\n            {\n                ithread_join(ps_codec->apv_process_thread_handle[i], NULL);\n                ps_codec->ai4_process_thread_created[i] = 0;\n            }\n        }\n\n        DEBUG_VALIDATE_PADDED_REGION(&ps_codec->as_process[proc_idx]);\n        if(ps_codec->u4_pic_cnt > 0)\n        {\n            DEBUG_DUMP_PIC_PU(ps_codec);\n        }\n        DEBUG_DUMP_PIC_BUFFERS(ps_codec);\n\n        /* Increment the number of pictures decoded */\n        ps_codec->u4_pic_cnt++;\n    }\n    ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);\n\n    if(1 == ps_dec_op->u4_output_present)\n    {\n        WORD32 xpos = ps_codec->i4_disp_wd - 32 - LOGO_WD;\n        WORD32 ypos = ps_codec->i4_disp_ht - 32 - LOGO_HT;\n\n        if(ypos < 0)\n            ypos = 0;\n\n        if(xpos < 0)\n            xpos = 0;\n\n        INSERT_LOGO(ps_dec_ip->s_out_buffer.pu1_bufs[0],\n                    ps_dec_ip->s_out_buffer.pu1_bufs[1],\n                    ps_dec_ip->s_out_buffer.pu1_bufs[2], ps_codec->i4_disp_strd,\n                    xpos,\n                    ypos,\n                    ps_codec->e_chroma_fmt,\n                    ps_codec->i4_disp_wd,\n                    ps_codec->i4_disp_ht);\n    }\n\n\n    return ret;\n}",
        "func": "WORD32 ihevcd_decode(iv_obj_t *ps_codec_obj, void *pv_api_ip, void *pv_api_op)\n{\n    WORD32 ret = IV_SUCCESS;\n    codec_t *ps_codec = (codec_t *)(ps_codec_obj->pv_codec_handle);\n    ivd_video_decode_ip_t *ps_dec_ip;\n    ivd_video_decode_op_t *ps_dec_op;\n\n    WORD32 proc_idx = 0;\n    WORD32 prev_proc_idx = 0;\n\n    /* Initialize error code */\n    ps_codec->i4_error_code = 0;\n\n    ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;\n    ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;\n\n    {\n        UWORD32 u4_size = ps_dec_op->u4_size;\n        memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));\n        ps_dec_op->u4_size = u4_size; //Restore size field\n    }\n    if(ps_codec->i4_init_done != 1)\n    {\n        ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;\n        ps_dec_op->u4_error_code |= IHEVCD_INIT_NOT_DONE;\n        return IV_FAIL;\n    }\n\n    if(ps_codec->u4_pic_cnt >= NUM_FRAMES_LIMIT)\n    {\n        ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;\n        ps_dec_op->u4_error_code |= IHEVCD_NUM_FRAMES_LIMIT_REACHED;\n        return IV_FAIL;\n    }\n\n    /* If reset flag is set, flush the existing buffers */\n    if(ps_codec->i4_reset_flag)\n    {\n        ps_codec->i4_flush_mode = 1;\n    }\n\n    /*Data memory barries instruction,so that bitstream write by the application is complete*/\n    //arm_dsb();\n    /* In case the decoder is not in flush mode check for input buffer validity */\n    if(0 == ps_codec->i4_flush_mode)\n    {\n        if(ps_dec_ip->pv_stream_buffer == NULL)\n        {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;\n            return IV_FAIL;\n        }\n        if(ps_dec_ip->u4_num_Bytes <= MIN_START_CODE_LEN)\n        {\n            if((WORD32)ps_dec_ip->u4_num_Bytes > 0)\n                ps_dec_op->u4_num_bytes_consumed = ps_dec_ip->u4_num_Bytes;\n            else\n                ps_dec_op->u4_num_bytes_consumed = 0;\n\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;\n            return IV_FAIL;\n\n        }\n    }\n\n#ifdef APPLY_CONCEALMENT\n    {\n        WORD32 num_mbs;\n\n        num_mbs = (ps_codec->i4_wd * ps_codec->i4_ht + 255) >> 8;\n        /* Reset MB Count at the beginning of every process call */\n        ps_codec->mb_count = 0;\n        memset(ps_codec->mb_map, 0, ((num_mbs + 7) >> 3));\n    }\n#endif\n\n    if(0 == ps_codec->i4_share_disp_buf && ps_codec->i4_header_mode == 0)\n    {\n        UWORD32 i;\n        if(ps_dec_ip->s_out_buffer.u4_num_bufs == 0)\n        {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;\n            return IV_FAIL;\n        }\n\n        for(i = 0; i < ps_dec_ip->s_out_buffer.u4_num_bufs; i++)\n        {\n            if(ps_dec_ip->s_out_buffer.pu1_bufs[i] == NULL)\n            {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;\n                return IV_FAIL;\n            }\n\n            if(ps_dec_ip->s_out_buffer.u4_min_out_buf_size[i] == 0)\n            {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE;\n                return IV_FAIL;\n            }\n        }\n    }\n\n    ps_codec->ps_out_buffer = &ps_dec_ip->s_out_buffer;\n    ps_codec->u4_ts = ps_dec_ip->u4_ts;\n    if(ps_codec->i4_flush_mode)\n    {\n\n        ps_dec_op->u4_pic_wd = ps_codec->i4_disp_wd;\n        ps_dec_op->u4_pic_ht = ps_codec->i4_disp_ht;\n\n        ps_dec_op->u4_new_seq = 0;\n\n        ps_codec->ps_disp_buf = (pic_buf_t *)ihevc_disp_mgr_get(\n                        (disp_mgr_t *)ps_codec->pv_disp_buf_mgr, &ps_codec->i4_disp_buf_id);\n        /* In case of non-shared mode, then convert/copy the frame to output buffer */\n        /* Only if the codec is in non-shared mode or in shared mode but needs 420P output */\n        if((ps_codec->ps_disp_buf)\n                        && ((0 == ps_codec->i4_share_disp_buf)\n                                        || (IV_YUV_420P\n                                                        == ps_codec->e_chroma_fmt)))\n        {\n\n            process_ctxt_t *ps_proc = &ps_codec->as_process[prev_proc_idx];\n            if(0 == ps_proc->i4_init_done)\n            {\n                ihevcd_init_proc_ctxt(ps_proc, 0);\n            }\n\n            /* Output buffer check */\n            ret = ihevcd_check_out_buf_size(ps_codec);\n            RETURN_IF((ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS), ret);\n\n            /* Set remaining number of rows to be processed */\n            ret = ihevcd_fmt_conv(ps_codec, &ps_codec->as_process[prev_proc_idx],\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[0],\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[1],\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[2], 0,\n                                  ps_codec->i4_disp_ht);\n\n            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,\n                                  ps_codec->i4_disp_buf_id, BUF_MGR_DISP);\n        }\n\n        ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);\n\n        if(1 == ps_dec_op->u4_output_present)\n        {\n            WORD32 xpos = ps_codec->i4_disp_wd - 32 - LOGO_WD;\n            WORD32 ypos = ps_codec->i4_disp_ht - 32 - LOGO_HT;\n\n            if(ypos < 0)\n                ypos = 0;\n\n            if(xpos < 0)\n                xpos = 0;\n\n            INSERT_LOGO(ps_dec_ip->s_out_buffer.pu1_bufs[0],\n                        ps_dec_ip->s_out_buffer.pu1_bufs[1],\n                        ps_dec_ip->s_out_buffer.pu1_bufs[2], ps_codec->i4_disp_strd,\n                        xpos,\n                        ypos,\n                        ps_codec->e_chroma_fmt,\n                        ps_codec->i4_disp_wd,\n                        ps_codec->i4_disp_ht);\n        }\n\n\n        if(NULL == ps_codec->ps_disp_buf)\n        {\n            /* If in flush mode and there are no more buffers to flush,\n             * check for the reset flag and reset the decoder */\n            if(ps_codec->i4_reset_flag)\n            {\n                ihevcd_init(ps_codec);\n            }\n            return (IV_FAIL);\n        }\n\n        return (IV_SUCCESS);\n\n    }\n    /* In case of shared mode, check if there is a free buffer for reconstruction */\n    if((0 == ps_codec->i4_header_mode) && (1 == ps_codec->i4_share_disp_buf))\n    {\n        WORD32 buf_status;\n        buf_status = 1;\n        if(ps_codec->pv_pic_buf_mgr)\n            buf_status = ihevc_buf_mgr_check_free((buf_mgr_t *)ps_codec->pv_pic_buf_mgr);\n\n        /* If there is no free buffer, then return with an error code */\n        if(0 == buf_status)\n        {\n            ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\n            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n            return IV_FAIL;\n        }\n    }\n    ps_codec->i4_bytes_remaining = ps_dec_ip->u4_num_Bytes;\n    ps_codec->pu1_inp_bitsbuf = (UWORD8 *)ps_dec_ip->pv_stream_buffer;\n    ps_codec->s_parse.i4_end_of_frame = 0;\n\n    ps_codec->i4_pic_present = 0;\n    ps_codec->i4_slice_error = 0;\n    ps_codec->ps_disp_buf = NULL;\n\n    if(ps_codec->i4_num_cores > 1)\n    {\n        ithread_set_affinity(0);\n    }\n    while(MIN_START_CODE_LEN < ps_codec->i4_bytes_remaining)\n    {\n        WORD32 nal_len;\n        WORD32 nal_ofst;\n        WORD32 bits_len;\n\n        if(ps_codec->i4_slice_error)\n        {\n            slice_header_t *ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));\n            WORD32 next_slice_addr = ps_slice_hdr_next->i2_ctb_x +\n                            ps_slice_hdr_next->i2_ctb_y * ps_codec->s_parse.ps_sps->i2_pic_wd_in_ctb;\n            if(ps_codec->s_parse.i4_next_ctb_indx == next_slice_addr)\n                ps_codec->i4_slice_error = 0;\n        }\n\n        if(ps_codec->pu1_bitsbuf_dynamic)\n        {\n            ps_codec->pu1_bitsbuf = ps_codec->pu1_bitsbuf_dynamic;\n            ps_codec->u4_bitsbuf_size = ps_codec->u4_bitsbuf_size_dynamic;\n        }\n        else\n        {\n            ps_codec->pu1_bitsbuf = ps_codec->pu1_bitsbuf_static;\n            ps_codec->u4_bitsbuf_size = ps_codec->u4_bitsbuf_size_static;\n        }\n\n        nal_ofst = ihevcd_nal_search_start_code(ps_codec->pu1_inp_bitsbuf,\n                                                ps_codec->i4_bytes_remaining);\n\n        ps_codec->i4_nal_ofst = nal_ofst;\n        {\n            WORD32 bytes_remaining = ps_codec->i4_bytes_remaining - nal_ofst;\n\n            bytes_remaining = MIN((UWORD32)bytes_remaining, ps_codec->u4_bitsbuf_size);\n            ihevcd_nal_remv_emuln_bytes(ps_codec->pu1_inp_bitsbuf + nal_ofst,\n                                        ps_codec->pu1_bitsbuf,\n                                        bytes_remaining,\n                                        &nal_len, &bits_len);\n\n            /* Decoder may read upto 8 extra bytes at the end of frame */\n            /* These are not used, but still set them to zero to avoid uninitialized reads */\n            if(bits_len < (WORD32)(ps_codec->u4_bitsbuf_size - 8))\n            {\n                memset(ps_codec->pu1_bitsbuf + bits_len, 0, 2 * sizeof(UWORD32));\n            }\n        }\n        /* This may be used to update the offsets for tiles and entropy sync row offsets */\n        ps_codec->i4_num_emln_bytes = nal_len - bits_len;\n        ps_codec->i4_nal_len = nal_len;\n\n        ihevcd_bits_init(&ps_codec->s_parse.s_bitstrm, ps_codec->pu1_bitsbuf,\n                         bits_len);\n\n        ret = ihevcd_nal_unit(ps_codec);\n\n        /* If the frame is incomplete and\n         * the bytes remaining is zero or a header is received,\n         * complete the frame treating it to be in error */\n        if(ps_codec->i4_pic_present &&\n                        (ps_codec->s_parse.i4_next_ctb_indx != ps_codec->s_parse.ps_sps->i4_pic_size_in_ctb))\n        {\n            if((ps_codec->i4_bytes_remaining - (nal_len + nal_ofst) <= MIN_START_CODE_LEN) ||\n                            (ps_codec->i4_header_in_slice_mode))\n            {\n                slice_header_t *ps_slice_hdr_next;\n\n                ps_codec->s_parse.i4_cur_slice_idx--;\n                if(ps_codec->s_parse.i4_cur_slice_idx < 0)\n                    ps_codec->s_parse.i4_cur_slice_idx = 0;\n\n                ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));\n                ps_slice_hdr_next->i2_ctb_x = 0;\n                ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;\n                ps_codec->i4_slice_error = 1;\n                continue;\n            }\n        }\n\n        if(IHEVCD_IGNORE_SLICE == ret)\n        {\n            ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len);\n            ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len);\n\n            continue;\n        }\n\n        if((IVD_RES_CHANGED == ret) ||\n           (IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED == ret))\n        {\n            break;\n        }\n\n        /* Update bytes remaining and bytes consumed and input bitstream pointer */\n        /* Do not consume the NAL in the following cases */\n        /* Slice header reached during header decode mode */\n        /* TODO: Next picture's slice reached */\n        if(ret != IHEVCD_SLICE_IN_HEADER_MODE)\n        {\n            if((0 == ps_codec->i4_slice_error) ||\n                            (ps_codec->i4_bytes_remaining - (nal_len + nal_ofst) <= MIN_START_CODE_LEN))\n            {\n                ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len);\n                ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len);\n            }\n            if(ret != IHEVCD_SUCCESS)\n                break;\n\n            if(ps_codec->s_parse.i4_end_of_frame)\n                break;\n        }\n        else\n        {\n            ret = IHEVCD_SUCCESS;\n            break;\n        }\n\n        /* Allocate dynamic bitstream buffer once SPS is decoded */\n        if((ps_codec->u4_allocate_dynamic_done == 0) && ps_codec->i4_sps_done)\n        {\n            WORD32 ret;\n            ret = ihevcd_allocate_dynamic_bufs(ps_codec);\n            if(ret != IV_SUCCESS)\n            {\n                /* Free any dynamic buffers that are allocated */\n                ihevcd_free_dynamic_bufs(ps_codec);\n                ps_codec->i4_error_code = IVD_MEM_ALLOC_FAILED;\n                ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;\n                ps_dec_op->u4_error_code |= IVD_MEM_ALLOC_FAILED;\n\n                return IV_FAIL;\n            }\n        }\n\n        BREAK_AFTER_SLICE_NAL();\n    }\n\n    if((ps_codec->u4_pic_cnt == 0) && (ret != IHEVCD_SUCCESS))\n    {\n        ps_codec->i4_error_code = ret;\n\n        ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);\n        return IV_FAIL;\n    }\n\n    if(1 == ps_codec->i4_pic_present)\n    {\n        WORD32 i;\n        sps_t *ps_sps = ps_codec->s_parse.ps_sps;\n        ps_codec->i4_first_pic_done = 1;\n\n        /*TODO temporary fix: end_of_frame is checked before adding format conversion to job queue         */\n        if(ps_codec->i4_num_cores > 1 && ps_codec->s_parse.i4_end_of_frame)\n        {\n\n            /* Add job queue for format conversion / frame copy for each ctb row */\n            /* Only if the codec is in non-shared mode or in shared mode but needs 420P output */\n            process_ctxt_t *ps_proc;\n\n            /* i4_num_cores - 1 contexts are currently being used by other threads */\n            ps_proc = &ps_codec->as_process[ps_codec->i4_num_cores - 1];\n\n            if((ps_codec->ps_disp_buf) &&\n               ((0 == ps_codec->i4_share_disp_buf) || (IV_YUV_420P == ps_codec->e_chroma_fmt)))\n            {\n                /* If format conversion jobs were not issued in pic_init() add them here */\n                if((0 == ps_codec->u4_enable_fmt_conv_ahead) ||\n                                (ps_codec->i4_disp_buf_id == ps_proc->i4_cur_pic_buf_id))\n                    for(i = 0; i < ps_sps->i2_pic_ht_in_ctb; i++)\n                    {\n                        proc_job_t s_job;\n                        IHEVCD_ERROR_T ret;\n                        s_job.i4_cmd = CMD_FMTCONV;\n                        s_job.i2_ctb_cnt = 0;\n                        s_job.i2_ctb_x = 0;\n                        s_job.i2_ctb_y = i;\n                        s_job.i2_slice_idx = 0;\n                        s_job.i4_tu_coeff_data_ofst = 0;\n                        ret = ihevcd_jobq_queue((jobq_t *)ps_codec->s_parse.pv_proc_jobq,\n                                                &s_job, sizeof(proc_job_t), 1);\n                        if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)\n                            return (WORD32)ret;\n                    }\n            }\n            /* Reached end of frame : Signal terminate */\n            /* The terminate flag is checked only after all the jobs are dequeued */\n            ret = ihevcd_jobq_terminate((jobq_t *)ps_codec->s_parse.pv_proc_jobq);\n\n            while(1)\n            {\n                IHEVCD_ERROR_T ret;\n                proc_job_t s_job;\n                process_ctxt_t *ps_proc;\n\n                /* i4_num_cores - 1 contexts are currently being used by other threads */\n                ps_proc = &ps_codec->as_process[ps_codec->i4_num_cores - 1];\n\n                ret = ihevcd_jobq_dequeue((jobq_t *)ps_proc->pv_proc_jobq, &s_job,\n                                          sizeof(proc_job_t), 1);\n                if((IHEVCD_ERROR_T)IHEVCD_SUCCESS != ret)\n                    break;\n\n                ps_proc->i4_ctb_cnt = s_job.i2_ctb_cnt;\n                ps_proc->i4_ctb_x = s_job.i2_ctb_x;\n                ps_proc->i4_ctb_y = s_job.i2_ctb_y;\n                ps_proc->i4_cur_slice_idx = s_job.i2_slice_idx;\n\n                if(CMD_PROCESS == s_job.i4_cmd)\n                {\n                    ihevcd_init_proc_ctxt(ps_proc, s_job.i4_tu_coeff_data_ofst);\n\n                    ihevcd_process(ps_proc);\n                }\n                else if(CMD_FMTCONV == s_job.i4_cmd)\n                {\n                    sps_t *ps_sps = ps_codec->s_parse.ps_sps;\n                    WORD32 num_rows = 1 << ps_sps->i1_log2_ctb_size;\n                    if(0 == ps_proc->i4_init_done)\n                    {\n                        ihevcd_init_proc_ctxt(ps_proc, 0);\n                    }\n\n                    num_rows = MIN(num_rows, (ps_codec->i4_disp_ht - (s_job.i2_ctb_y << ps_sps->i1_log2_ctb_size)));\n                    if(num_rows < 0)\n                        num_rows = 0;\n\n                    ihevcd_fmt_conv(ps_codec, ps_proc,\n                                    ps_dec_ip->s_out_buffer.pu1_bufs[0],\n                                    ps_dec_ip->s_out_buffer.pu1_bufs[1],\n                                    ps_dec_ip->s_out_buffer.pu1_bufs[2],\n                                    s_job.i2_ctb_y << ps_sps->i1_log2_ctb_size,\n                                    num_rows);\n                }\n            }\n        }\n        /* In case of non-shared mode and while running in single core mode, then convert/copy the frame to output buffer */\n        /* Only if the codec is in non-shared mode or in shared mode but needs 420P output */\n        else if((ps_codec->ps_disp_buf) && ((0 == ps_codec->i4_share_disp_buf) ||\n                                            (IV_YUV_420P == ps_codec->e_chroma_fmt)) &&\n                        (ps_codec->s_parse.i4_end_of_frame))\n        {\n            process_ctxt_t *ps_proc = &ps_codec->as_process[proc_idx];\n            /* Set remaining number of rows to be processed */\n            ps_codec->s_fmt_conv.i4_num_rows = ps_codec->i4_disp_ht\n                            - ps_codec->s_fmt_conv.i4_cur_row;\n            if(0 == ps_proc->i4_init_done)\n            {\n                ihevcd_init_proc_ctxt(ps_proc, 0);\n            }\n\n            if(ps_codec->s_fmt_conv.i4_num_rows < 0)\n                ps_codec->s_fmt_conv.i4_num_rows = 0;\n\n            ret = ihevcd_fmt_conv(ps_codec, ps_proc,\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[0],\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[1],\n                                  ps_dec_ip->s_out_buffer.pu1_bufs[2],\n                                  ps_codec->s_fmt_conv.i4_cur_row,\n                                  ps_codec->s_fmt_conv.i4_num_rows);\n            ps_codec->s_fmt_conv.i4_cur_row += ps_codec->s_fmt_conv.i4_num_rows;\n\n        }\n\n\n        DEBUG_DUMP_MV_MAP(ps_codec);\n\n        /* Mark MV Buf as needed for reference */\n        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_mv_buf_mgr,\n                                 ps_codec->as_process[proc_idx].i4_cur_mv_bank_buf_id,\n                                 BUF_MGR_REF);\n\n        /* Mark pic buf as needed for reference */\n        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,\n                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id,\n                                 BUF_MGR_REF);\n\n        /* Mark pic buf as needed for display */\n        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,\n                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id,\n                                 BUF_MGR_DISP);\n\n        /* Insert the current picture as short term reference */\n        ihevc_dpb_mgr_insert_ref((dpb_mgr_t *)ps_codec->pv_dpb_mgr,\n                                 ps_codec->as_process[proc_idx].ps_cur_pic,\n                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id);\n\n        /* If a frame was displayed (in non-shared mode), then release it from display manager */\n        if((0 == ps_codec->i4_share_disp_buf) && (ps_codec->ps_disp_buf))\n            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,\n                                  ps_codec->i4_disp_buf_id, BUF_MGR_DISP);\n\n        /* Wait for threads */\n        for(i = 0; i < (ps_codec->i4_num_cores - 1); i++)\n        {\n            if(ps_codec->ai4_process_thread_created[i])\n            {\n                ithread_join(ps_codec->apv_process_thread_handle[i], NULL);\n                ps_codec->ai4_process_thread_created[i] = 0;\n            }\n        }\n\n        DEBUG_VALIDATE_PADDED_REGION(&ps_codec->as_process[proc_idx]);\n        if(ps_codec->u4_pic_cnt > 0)\n        {\n            DEBUG_DUMP_PIC_PU(ps_codec);\n        }\n        DEBUG_DUMP_PIC_BUFFERS(ps_codec);\n\n        /* Increment the number of pictures decoded */\n        ps_codec->u4_pic_cnt++;\n    }\n    ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);\n\n    if(1 == ps_dec_op->u4_output_present)\n    {\n        WORD32 xpos = ps_codec->i4_disp_wd - 32 - LOGO_WD;\n        WORD32 ypos = ps_codec->i4_disp_ht - 32 - LOGO_HT;\n\n        if(ypos < 0)\n            ypos = 0;\n\n        if(xpos < 0)\n            xpos = 0;\n\n        INSERT_LOGO(ps_dec_ip->s_out_buffer.pu1_bufs[0],\n                    ps_dec_ip->s_out_buffer.pu1_bufs[1],\n                    ps_dec_ip->s_out_buffer.pu1_bufs[2], ps_codec->i4_disp_strd,\n                    xpos,\n                    ypos,\n                    ps_codec->e_chroma_fmt,\n                    ps_codec->i4_disp_wd,\n                    ps_codec->i4_disp_ht);\n    }\n\n\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -290,7 +290,6 @@\n \n         if(IHEVCD_IGNORE_SLICE == ret)\n         {\n-            ps_codec->s_parse.i4_cur_slice_idx = MAX(0, (ps_codec->s_parse.i4_cur_slice_idx - 1));\n             ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len);\n             ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "            ps_codec->s_parse.i4_cur_slice_idx = MAX(0, (ps_codec->s_parse.i4_cur_slice_idx - 1));"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2017-8326",
        "func_name": "jsummers/imageworsener/iw_get_ui32le",
        "description": "libimageworsener.a in ImageWorsener before 1.3.1 has \"left shift cannot be represented in type int\" undefined behavior issues, which might allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted image, related to imagew-bmp.c and imagew-util.c.",
        "git_url": "https://github.com/jsummers/imageworsener/commit/a00183107d4b84bc8a714290e824ca9c68dac738",
        "commit_title": "Trying to fix some invalid left shift operations",
        "commit_text": " Fixes issue #16",
        "func_before": "IW_IMPL(unsigned int) iw_get_ui32le(const iw_byte *b)\n{\n\treturn b[0] | (b[1]<<8) | (b[2]<<16) | (b[3]<<24);\n}",
        "func": "IW_IMPL(unsigned int) iw_get_ui32le(const iw_byte *b)\n{\n\treturn (unsigned int)b[0] | ((unsigned int)b[1]<<8) |\n\t\t((unsigned int)b[2]<<16) | ((unsigned int)b[3]<<24);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,5 @@\n IW_IMPL(unsigned int) iw_get_ui32le(const iw_byte *b)\n {\n-\treturn b[0] | (b[1]<<8) | (b[2]<<16) | (b[3]<<24);\n+\treturn (unsigned int)b[0] | ((unsigned int)b[1]<<8) |\n+\t\t((unsigned int)b[2]<<16) | ((unsigned int)b[3]<<24);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn b[0] | (b[1]<<8) | (b[2]<<16) | (b[3]<<24);"
            ],
            "added_lines": [
                "\treturn (unsigned int)b[0] | ((unsigned int)b[1]<<8) |",
                "\t\t((unsigned int)b[2]<<16) | ((unsigned int)b[3]<<24);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8326",
        "func_name": "jsummers/imageworsener/iw_get_i32le",
        "description": "libimageworsener.a in ImageWorsener before 1.3.1 has \"left shift cannot be represented in type int\" undefined behavior issues, which might allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted image, related to imagew-bmp.c and imagew-util.c.",
        "git_url": "https://github.com/jsummers/imageworsener/commit/a00183107d4b84bc8a714290e824ca9c68dac738",
        "commit_title": "Trying to fix some invalid left shift operations",
        "commit_text": " Fixes issue #16",
        "func_before": "IW_IMPL(int) iw_get_i32le(const iw_byte *b)\n{\n\treturn (iw_int32)(iw_uint32)(b[0] | (b[1]<<8) | (b[2]<<16) | (b[3]<<24));\n}",
        "func": "IW_IMPL(int) iw_get_i32le(const iw_byte *b)\n{\n\treturn (iw_int32)(iw_uint32)((unsigned int)b[0] | ((unsigned int)b[1]<<8) |\n\t\t((unsigned int)b[2]<<16) | ((unsigned int)b[3]<<24));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,5 @@\n IW_IMPL(int) iw_get_i32le(const iw_byte *b)\n {\n-\treturn (iw_int32)(iw_uint32)(b[0] | (b[1]<<8) | (b[2]<<16) | (b[3]<<24));\n+\treturn (iw_int32)(iw_uint32)((unsigned int)b[0] | ((unsigned int)b[1]<<8) |\n+\t\t((unsigned int)b[2]<<16) | ((unsigned int)b[3]<<24));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn (iw_int32)(iw_uint32)(b[0] | (b[1]<<8) | (b[2]<<16) | (b[3]<<24));"
            ],
            "added_lines": [
                "\treturn (iw_int32)(iw_uint32)((unsigned int)b[0] | ((unsigned int)b[1]<<8) |",
                "\t\t((unsigned int)b[2]<<16) | ((unsigned int)b[3]<<24));"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8326",
        "func_name": "jsummers/imageworsener/iw_get_ui32be",
        "description": "libimageworsener.a in ImageWorsener before 1.3.1 has \"left shift cannot be represented in type int\" undefined behavior issues, which might allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted image, related to imagew-bmp.c and imagew-util.c.",
        "git_url": "https://github.com/jsummers/imageworsener/commit/a00183107d4b84bc8a714290e824ca9c68dac738",
        "commit_title": "Trying to fix some invalid left shift operations",
        "commit_text": " Fixes issue #16",
        "func_before": "IW_IMPL(unsigned int) iw_get_ui32be(const iw_byte *b)\n{\n\treturn (b[0]<<24) | (b[1]<<16) | (b[2]<<8) | b[3];\n}",
        "func": "IW_IMPL(unsigned int) iw_get_ui32be(const iw_byte *b)\n{\n\treturn ((unsigned int)b[0]<<24) | ((unsigned int)b[1]<<16) |\n\t\t((unsigned int)b[2]<<8) | (unsigned int)b[3];\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,5 @@\n IW_IMPL(unsigned int) iw_get_ui32be(const iw_byte *b)\n {\n-\treturn (b[0]<<24) | (b[1]<<16) | (b[2]<<8) | b[3];\n+\treturn ((unsigned int)b[0]<<24) | ((unsigned int)b[1]<<16) |\n+\t\t((unsigned int)b[2]<<8) | (unsigned int)b[3];\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn (b[0]<<24) | (b[1]<<16) | (b[2]<<8) | b[3];"
            ],
            "added_lines": [
                "\treturn ((unsigned int)b[0]<<24) | ((unsigned int)b[1]<<16) |",
                "\t\t((unsigned int)b[2]<<8) | (unsigned int)b[3];"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8326",
        "func_name": "jsummers/imageworsener/iw_get_ui16be",
        "description": "libimageworsener.a in ImageWorsener before 1.3.1 has \"left shift cannot be represented in type int\" undefined behavior issues, which might allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted image, related to imagew-bmp.c and imagew-util.c.",
        "git_url": "https://github.com/jsummers/imageworsener/commit/a00183107d4b84bc8a714290e824ca9c68dac738",
        "commit_title": "Trying to fix some invalid left shift operations",
        "commit_text": " Fixes issue #16",
        "func_before": "IW_IMPL(unsigned int) iw_get_ui16be(const iw_byte *b)\n{\n\treturn (b[0]<<8) | b[1];\n}",
        "func": "IW_IMPL(unsigned int) iw_get_ui16be(const iw_byte *b)\n{\n\treturn ((unsigned int)b[0]<<8) | (unsigned int)b[1];\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n IW_IMPL(unsigned int) iw_get_ui16be(const iw_byte *b)\n {\n-\treturn (b[0]<<8) | b[1];\n+\treturn ((unsigned int)b[0]<<8) | (unsigned int)b[1];\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn (b[0]<<8) | b[1];"
            ],
            "added_lines": [
                "\treturn ((unsigned int)b[0]<<8) | (unsigned int)b[1];"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8326",
        "func_name": "jsummers/imageworsener/iw_get_ui16le",
        "description": "libimageworsener.a in ImageWorsener before 1.3.1 has \"left shift cannot be represented in type int\" undefined behavior issues, which might allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted image, related to imagew-bmp.c and imagew-util.c.",
        "git_url": "https://github.com/jsummers/imageworsener/commit/a00183107d4b84bc8a714290e824ca9c68dac738",
        "commit_title": "Trying to fix some invalid left shift operations",
        "commit_text": " Fixes issue #16",
        "func_before": "IW_IMPL(unsigned int) iw_get_ui16le(const iw_byte *b)\n{\n\treturn b[0] | (b[1]<<8);\n}",
        "func": "IW_IMPL(unsigned int) iw_get_ui16le(const iw_byte *b)\n{\n\treturn (unsigned int)b[0] | ((unsigned int)b[1]<<8);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n IW_IMPL(unsigned int) iw_get_ui16le(const iw_byte *b)\n {\n-\treturn b[0] | (b[1]<<8);\n+\treturn (unsigned int)b[0] | ((unsigned int)b[1]<<8);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn b[0] | (b[1]<<8);"
            ],
            "added_lines": [
                "\treturn (unsigned int)b[0] | ((unsigned int)b[1]<<8);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8326",
        "func_name": "jsummers/imageworsener/find_low_bit",
        "description": "libimageworsener.a in ImageWorsener before 1.3.1 has \"left shift cannot be represented in type int\" undefined behavior issues, which might allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted image, related to imagew-bmp.c and imagew-util.c.",
        "git_url": "https://github.com/jsummers/imageworsener/commit/a00183107d4b84bc8a714290e824ca9c68dac738",
        "commit_title": "Trying to fix some invalid left shift operations",
        "commit_text": " Fixes issue #16",
        "func_before": "static int find_low_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=0;i<=31;i++) {\n\t\tif(x&(1<<i)) return i;\n\t}\n\treturn 0;\n}",
        "func": "static int find_low_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=0;i<=31;i++) {\n\t\tif(x&(1U<<(unsigned int)i)) return i;\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n {\n \tint i;\n \tfor(i=0;i<=31;i++) {\n-\t\tif(x&(1<<i)) return i;\n+\t\tif(x&(1U<<(unsigned int)i)) return i;\n \t}\n \treturn 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif(x&(1<<i)) return i;"
            ],
            "added_lines": [
                "\t\tif(x&(1U<<(unsigned int)i)) return i;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8326",
        "func_name": "jsummers/imageworsener/find_high_bit",
        "description": "libimageworsener.a in ImageWorsener before 1.3.1 has \"left shift cannot be represented in type int\" undefined behavior issues, which might allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted image, related to imagew-bmp.c and imagew-util.c.",
        "git_url": "https://github.com/jsummers/imageworsener/commit/a00183107d4b84bc8a714290e824ca9c68dac738",
        "commit_title": "Trying to fix some invalid left shift operations",
        "commit_text": " Fixes issue #16",
        "func_before": "static int find_high_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=31;i>=0;i--) {\n\t\tif(x&(1<<i)) return i;\n\t}\n\treturn 0;\n}",
        "func": "static int find_high_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=31;i>=0;i--) {\n\t\tif(x&(1U<<(unsigned int)i)) return i;\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n {\n \tint i;\n \tfor(i=31;i>=0;i--) {\n-\t\tif(x&(1<<i)) return i;\n+\t\tif(x&(1U<<(unsigned int)i)) return i;\n \t}\n \treturn 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif(x&(1<<i)) return i;"
            ],
            "added_lines": [
                "\t\tif(x&(1U<<(unsigned int)i)) return i;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19578",
        "func_name": "xen-project/xen/_get_page_type",
        "description": "An issue was discovered in Xen through 4.12.x allowing x86 PV guest OS users to cause a denial of service via degenerate chains of linear pagetables, because of an incorrect fix for CVE-2017-15595. \"Linear pagetables\" is a technique which involves either pointing a pagetable at itself, or to another pagetable of the same or higher level. Xen has limited support for linear pagetables: A page may either point to itself, or point to another pagetable of the same level (i.e., L2 to L2, L3 to L3, and so on). XSA-240 introduced an additional restriction that limited the \"depth\" of such chains by allowing pages to either *point to* other pages of the same level, or *be pointed to* by other pages of the same level, but not both. To implement this, we keep track of the number of outstanding times a page points to or is pointed to another page table, to prevent both from happening at the same time. Unfortunately, the original commit introducing this reset this count when resuming validation of a partially-validated pagetable, incorrectly dropping some \"linear_pt_entry\" counts. If an attacker could engineer such a situation to occur, they might be able to make loops or other arbitrary chains of linear pagetables, as described in XSA-240. A malicious or buggy PV guest may cause the hypervisor to crash, resulting in Denial of Service (DoS) affecting the entire host. Privilege escalation and information leaks cannot be excluded. All versions of Xen are vulnerable. Only x86 systems are affected. Arm systems are not affected. Only x86 PV guests can leverage the vulnerability. x86 HVM and PVH guests cannot leverage the vulnerability. Only systems which have enabled linear pagetables are vulnerable. Systems which have disabled linear pagetables, either by selecting CONFIG_PV_LINEAR_PT=n when building the hypervisor, or adding pv-linear-pt=false on the command-line, are not vulnerable.",
        "git_url": "https://github.com/xen-project/xen/commit/7473efd12fb7a6548f5303f1f4c5cb521543a813",
        "commit_title": "x86/mm: Don't reset linear_pt_count on partial validation",
        "commit_text": " \"Linear pagetables\" is a technique which involves either pointing a pagetable at itself, or to another pagetable the same or higher level. Xen has limited support for linear pagetables: A page may either point to itself, or point to another page of the same level (i.e., L2 to L2, L3 to L3, and so on).  XSA-240 introduced an additional restriction that limited the \"depth\" of such chains by allowing pages to either *point to* other pages of the same level, or *be pointed to* by other pages of the same level, but not both.  To implement this, we keep track of the number of outstanding times a page points to or is pointed to another page table, to prevent both from happening at the same time.  Unfortunately, the original commit introducing this reset this count when resuming validation of a partially-validated pagetable, dropping some \"linear_pt_entry\" counts.  On debug builds on systems where guests used this feature, this might lead to crashes that look like this:      Assertion 'oc > 0' failed at mm.c:874  Worse, if an attacker could engineer such a situation to occur, they might be able to make loops or other abitrary chains of linear pagetables, leading to the denial-of-service situation outlined in XSA-240.  This is XSA-309. ",
        "func_before": "static int _get_page_type(struct page_info *page, unsigned long type,\n                          bool preemptible)\n{\n    unsigned long nx, x, y = page->u.inuse.type_info;\n    int rc = 0;\n\n    ASSERT(!(type & ~(PGT_type_mask | PGT_pae_xen_l2)));\n    ASSERT(!in_irq());\n\n    for ( ; ; )\n    {\n        x  = y;\n        nx = x + 1;\n        if ( unlikely((nx & PGT_count_mask) == 0) )\n        {\n            gdprintk(XENLOG_WARNING,\n                     \"Type count overflow on mfn %\"PRI_mfn\"\\n\",\n                     mfn_x(page_to_mfn(page)));\n            return -EINVAL;\n        }\n        else if ( unlikely((x & PGT_count_mask) == 0) )\n        {\n            struct domain *d = page_get_owner(page);\n\n            if ( d && shadow_mode_enabled(d) )\n               shadow_prepare_page_type_change(d, page, type);\n\n            ASSERT(!(x & PGT_pae_xen_l2));\n            if ( (x & PGT_type_mask) != type )\n            {\n                /*\n                 * On type change we check to flush stale TLB entries. It is\n                 * vital that no other CPUs are left with mappings of a frame\n                 * which is about to become writeable to the guest.\n                 */\n                cpumask_t *mask = this_cpu(scratch_cpumask);\n\n                BUG_ON(in_irq());\n                cpumask_copy(mask, d->dirty_cpumask);\n\n                /* Don't flush if the timestamp is old enough */\n                tlbflush_filter(mask, page->tlbflush_timestamp);\n\n                if ( unlikely(!cpumask_empty(mask)) &&\n                     /* Shadow mode: track only writable pages. */\n                     (!shadow_mode_enabled(page_get_owner(page)) ||\n                      ((nx & PGT_type_mask) == PGT_writable_page)) )\n                {\n                    perfc_incr(need_flush_tlb_flush);\n                    flush_tlb_mask(mask);\n                }\n\n                /* We lose existing type and validity. */\n                nx &= ~(PGT_type_mask | PGT_validated);\n                nx |= type;\n\n                /*\n                 * No special validation needed for writable pages.\n                 * Page tables and GDT/LDT need to be scanned for validity.\n                 */\n                if ( type == PGT_writable_page || type == PGT_shared_page )\n                    nx |= PGT_validated;\n            }\n        }\n        else if ( unlikely((x & (PGT_type_mask|PGT_pae_xen_l2)) != type) )\n        {\n            /* Don't log failure if it could be a recursive-mapping attempt. */\n            if ( ((x & PGT_type_mask) == PGT_l2_page_table) &&\n                 (type == PGT_l1_page_table) )\n                return -EINVAL;\n            if ( ((x & PGT_type_mask) == PGT_l3_page_table) &&\n                 (type == PGT_l2_page_table) )\n                return -EINVAL;\n            if ( ((x & PGT_type_mask) == PGT_l4_page_table) &&\n                 (type == PGT_l3_page_table) )\n                return -EINVAL;\n            gdprintk(XENLOG_WARNING,\n                     \"Bad type (saw %\" PRtype_info \" != exp %\" PRtype_info \") \"\n                     \"for mfn %\" PRI_mfn \" (pfn %\" PRI_pfn \")\\n\",\n                     x, type, mfn_x(page_to_mfn(page)),\n                     get_gpfn_from_mfn(mfn_x(page_to_mfn(page))));\n            return -EINVAL;\n        }\n        else if ( unlikely(!(x & PGT_validated)) )\n        {\n            if ( !(x & PGT_partial) )\n            {\n                /* Someone else is updating validation of this page. Wait... */\n                do {\n                    if ( preemptible && hypercall_preempt_check() )\n                        return -EINTR;\n                    cpu_relax();\n                } while ( (y = page->u.inuse.type_info) == x );\n                continue;\n            }\n            /* Type ref count was left at 1 when PGT_partial got set. */\n            ASSERT((x & PGT_count_mask) == 1);\n            nx = x & ~PGT_partial;\n        }\n\n        if ( likely((y = cmpxchg(&page->u.inuse.type_info, x, nx)) == x) )\n            break;\n\n        if ( preemptible && hypercall_preempt_check() )\n            return -EINTR;\n    }\n\n    if ( unlikely((x & PGT_type_mask) != type) )\n    {\n        /* Special pages should not be accessible from devices. */\n        struct domain *d = page_get_owner(page);\n        if ( d && is_pv_domain(d) && unlikely(need_iommu_pt_sync(d)) )\n        {\n            mfn_t mfn = page_to_mfn(page);\n\n            if ( (x & PGT_type_mask) == PGT_writable_page )\n                rc = iommu_legacy_unmap(d, _dfn(mfn_x(mfn)), PAGE_ORDER_4K);\n            else if ( type == PGT_writable_page )\n                rc = iommu_legacy_map(d, _dfn(mfn_x(mfn)), mfn, PAGE_ORDER_4K,\n                                      IOMMUF_readable | IOMMUF_writable);\n\n            if ( unlikely(rc) )\n            {\n                _put_page_type(page, 0, NULL);\n                goto out;\n            }\n        }\n    }\n\n    if ( unlikely(!(nx & PGT_validated)) )\n    {\n        if ( !(x & PGT_partial) )\n        {\n            page->nr_validated_ptes = 0;\n            page->partial_flags = 0;\n        }\n        page->linear_pt_count = 0;\n        rc = alloc_page_type(page, type, preemptible);\n    }\n\n out:\n    if ( (x & PGT_partial) && !(nx & PGT_partial) )\n        put_page(page);\n\n    return rc;\n}",
        "func": "static int _get_page_type(struct page_info *page, unsigned long type,\n                          bool preemptible)\n{\n    unsigned long nx, x, y = page->u.inuse.type_info;\n    int rc = 0;\n\n    ASSERT(!(type & ~(PGT_type_mask | PGT_pae_xen_l2)));\n    ASSERT(!in_irq());\n\n    for ( ; ; )\n    {\n        x  = y;\n        nx = x + 1;\n        if ( unlikely((nx & PGT_count_mask) == 0) )\n        {\n            gdprintk(XENLOG_WARNING,\n                     \"Type count overflow on mfn %\"PRI_mfn\"\\n\",\n                     mfn_x(page_to_mfn(page)));\n            return -EINVAL;\n        }\n        else if ( unlikely((x & PGT_count_mask) == 0) )\n        {\n            struct domain *d = page_get_owner(page);\n\n            if ( d && shadow_mode_enabled(d) )\n               shadow_prepare_page_type_change(d, page, type);\n\n            ASSERT(!(x & PGT_pae_xen_l2));\n            if ( (x & PGT_type_mask) != type )\n            {\n                /*\n                 * On type change we check to flush stale TLB entries. It is\n                 * vital that no other CPUs are left with mappings of a frame\n                 * which is about to become writeable to the guest.\n                 */\n                cpumask_t *mask = this_cpu(scratch_cpumask);\n\n                BUG_ON(in_irq());\n                cpumask_copy(mask, d->dirty_cpumask);\n\n                /* Don't flush if the timestamp is old enough */\n                tlbflush_filter(mask, page->tlbflush_timestamp);\n\n                if ( unlikely(!cpumask_empty(mask)) &&\n                     /* Shadow mode: track only writable pages. */\n                     (!shadow_mode_enabled(page_get_owner(page)) ||\n                      ((nx & PGT_type_mask) == PGT_writable_page)) )\n                {\n                    perfc_incr(need_flush_tlb_flush);\n                    flush_tlb_mask(mask);\n                }\n\n                /* We lose existing type and validity. */\n                nx &= ~(PGT_type_mask | PGT_validated);\n                nx |= type;\n\n                /*\n                 * No special validation needed for writable pages.\n                 * Page tables and GDT/LDT need to be scanned for validity.\n                 */\n                if ( type == PGT_writable_page || type == PGT_shared_page )\n                    nx |= PGT_validated;\n            }\n        }\n        else if ( unlikely((x & (PGT_type_mask|PGT_pae_xen_l2)) != type) )\n        {\n            /* Don't log failure if it could be a recursive-mapping attempt. */\n            if ( ((x & PGT_type_mask) == PGT_l2_page_table) &&\n                 (type == PGT_l1_page_table) )\n                return -EINVAL;\n            if ( ((x & PGT_type_mask) == PGT_l3_page_table) &&\n                 (type == PGT_l2_page_table) )\n                return -EINVAL;\n            if ( ((x & PGT_type_mask) == PGT_l4_page_table) &&\n                 (type == PGT_l3_page_table) )\n                return -EINVAL;\n            gdprintk(XENLOG_WARNING,\n                     \"Bad type (saw %\" PRtype_info \" != exp %\" PRtype_info \") \"\n                     \"for mfn %\" PRI_mfn \" (pfn %\" PRI_pfn \")\\n\",\n                     x, type, mfn_x(page_to_mfn(page)),\n                     get_gpfn_from_mfn(mfn_x(page_to_mfn(page))));\n            return -EINVAL;\n        }\n        else if ( unlikely(!(x & PGT_validated)) )\n        {\n            if ( !(x & PGT_partial) )\n            {\n                /* Someone else is updating validation of this page. Wait... */\n                do {\n                    if ( preemptible && hypercall_preempt_check() )\n                        return -EINTR;\n                    cpu_relax();\n                } while ( (y = page->u.inuse.type_info) == x );\n                continue;\n            }\n            /* Type ref count was left at 1 when PGT_partial got set. */\n            ASSERT((x & PGT_count_mask) == 1);\n            nx = x & ~PGT_partial;\n        }\n\n        if ( likely((y = cmpxchg(&page->u.inuse.type_info, x, nx)) == x) )\n            break;\n\n        if ( preemptible && hypercall_preempt_check() )\n            return -EINTR;\n    }\n\n    if ( unlikely((x & PGT_type_mask) != type) )\n    {\n        /* Special pages should not be accessible from devices. */\n        struct domain *d = page_get_owner(page);\n        if ( d && is_pv_domain(d) && unlikely(need_iommu_pt_sync(d)) )\n        {\n            mfn_t mfn = page_to_mfn(page);\n\n            if ( (x & PGT_type_mask) == PGT_writable_page )\n                rc = iommu_legacy_unmap(d, _dfn(mfn_x(mfn)), PAGE_ORDER_4K);\n            else if ( type == PGT_writable_page )\n                rc = iommu_legacy_map(d, _dfn(mfn_x(mfn)), mfn, PAGE_ORDER_4K,\n                                      IOMMUF_readable | IOMMUF_writable);\n\n            if ( unlikely(rc) )\n            {\n                _put_page_type(page, 0, NULL);\n                goto out;\n            }\n        }\n    }\n\n    if ( unlikely(!(nx & PGT_validated)) )\n    {\n        if ( !(x & PGT_partial) )\n        {\n            page->nr_validated_ptes = 0;\n            page->partial_flags = 0;\n            page->linear_pt_count = 0;\n        }\n        rc = alloc_page_type(page, type, preemptible);\n    }\n\n out:\n    if ( (x & PGT_partial) && !(nx & PGT_partial) )\n        put_page(page);\n\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -133,8 +133,8 @@\n         {\n             page->nr_validated_ptes = 0;\n             page->partial_flags = 0;\n+            page->linear_pt_count = 0;\n         }\n-        page->linear_pt_count = 0;\n         rc = alloc_page_type(page, type, preemptible);\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "        page->linear_pt_count = 0;"
            ],
            "added_lines": [
                "            page->linear_pt_count = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-18225",
        "func_name": "wireshark/dissect_coap_opt_object_security",
        "description": "In Wireshark 2.6.0 to 2.6.3, the CoAP dissector could crash. This was addressed in epan/dissectors/packet-coap.c by ensuring that the piv length is correctly computed.",
        "git_url": "https://github.com/wireshark/wireshark/commit/b2bbd9fdf209911d94b23cc33f4daccbceb7fa8a",
        "commit_title": "coap: ensure that piv_len matches piv",
        "commit_text": " In frame 121, piv_len was 1 while piv was NULL. Ensure that both piv and piv_len are reset to avoid this. Adjust another check to ensure that piv and piv_len are in sync (probably not necessary, but it seems the intention).  Bug: 15172 (cherry picked from commit 5a2aafef7a8ad4b3917823133c2e3534951fc4d3)",
        "func_before": "static void\ndissect_coap_opt_object_security(tvbuff_t *tvb, proto_item *head_item, proto_tree *subtree, gint offset, gint opt_length, packet_info *pinfo, coap_info *coinfo, coap_common_dissect_t *dissect_hf)\n{\n\tguint8 flag_byte = 0;\n\tgboolean non_compressed = FALSE;\n\tgboolean expand = FALSE;\n\tgboolean signature_present = FALSE;\n\tgboolean kid_context_present = FALSE;\n\tgboolean kid_present = FALSE;\n\tguint8 piv_len = 0;\n\tguint8 kid_context_len = 0;\n\tguint8 kid_len = 0;\n\n\tcoinfo->object_security = TRUE;\n\n\tcoinfo->oscore_info->piv = NULL;\n\tcoinfo->oscore_info->kid_context = NULL;\n\tcoinfo->oscore_info->kid = NULL;\n\n\tif (opt_length == 0) { /* option length is zero, means flag byte is 0x00*/\n\t\t/* add info to the head of the packet detail */\n\t\tproto_item_append_text(head_item, \": 00 (no Flag Byte)\");\n\t} else {\n\t\tflag_byte = tvb_get_guint8(tvb, offset);\n\n\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_non_compressed, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\tnon_compressed = flag_byte & COAP_OBJECT_SECURITY_NON_COMPRESSED_MASK;\n\n\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_expand, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\texpand = flag_byte & COAP_OBJECT_SECURITY_EXPAND_MASK;\n\n\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_signature, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\tsignature_present = flag_byte & COAP_OBJECT_SECURITY_SIGNATURE_MASK;\n\n\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_kid_context_present, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\tkid_context_present = flag_byte & COAP_OBJECT_SECURITY_KID_CONTEXT_MASK;\n\n\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_kid_present, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\tkid_present = flag_byte & COAP_OBJECT_SECURITY_KID_MASK;\n\n\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_piv_len, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\tpiv_len = (flag_byte & COAP_OBJECT_SECURITY_PIVLEN_MASK) >> 0;\n\n\t\t/* kid_len is what remains in the option after all other fields are parsed\n\t\twe calculate kid_len by subtracting from option length as we parse individual fields */\n\t\tkid_len = opt_length;\n\n\t\toffset += 1;\n\t\tkid_len -= 1;\n\n\t\tif (non_compressed || expand || signature_present) {\n\t\t\t/* how these bits are handled is not yet specified */\n\t\t\texpert_add_info_format(pinfo, subtree, &dissect_hf->ei.opt_object_security_bad, \"Unsupported format\");\n\t\t}\n\n\t\tif (piv_len > 0) {\n\t\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_piv, tvb, offset, piv_len, ENC_NA);\n\t\t\tcoinfo->oscore_info->piv = (guint8 *) tvb_memdup(wmem_packet_scope(), tvb, offset, piv_len);\n\t\t\tcoinfo->oscore_info->piv_len = piv_len;\n\n\t\t\toffset += piv_len;\n\t\t\tkid_len -= piv_len;\n\t\t}\n\n\t\tif (kid_context_present) {\n\t\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_kid_context_len, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\t\tkid_context_len = tvb_get_guint8(tvb, offset);\n\n\t\t\toffset += 1;\n\t\t\tkid_len -= 1;\n\n\t\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_kid_context, tvb, offset, kid_context_len, ENC_NA);\n\t\t\tcoinfo->oscore_info->kid_context = (guint8 *) tvb_memdup(wmem_packet_scope(), tvb, offset, kid_context_len);\n\t\t\tcoinfo->oscore_info->kid_context_len = kid_context_len;\n\n\t\t\toffset += kid_context_len;\n\t\t\tkid_len -= kid_context_len;\n\t\t}\n\n\t\tif (kid_present) {\n\t\t\tif(kid_len > 0) {\n\t\t\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_kid, tvb, offset, kid_len, ENC_NA);\n\t\t\t\tcoinfo->oscore_info->kid = (guint8 *) tvb_memdup(wmem_packet_scope(), tvb, offset, kid_len);\n\t\t\t\tcoinfo->oscore_info->kid_len = kid_len;\n\n\t\t\t} else {\n\t\t\t\texpert_add_info_format(pinfo, subtree, &dissect_hf->ei.opt_object_security_bad, \"Key ID flag is set but there are no remaining bytes to be processed\");\n\t\t\t}\n\t\t}\n\n\t\tproto_item_append_text(head_item, \": Key ID:%s, Key ID Context:%s, Partial IV:%s\",\n\t\t\t\t coinfo->oscore_info->kid == NULL ? nullstr : bytes_to_str(wmem_packet_scope(), coinfo->oscore_info->kid, coinfo->oscore_info->kid_len),\n\t\t\t\t coinfo->oscore_info->kid_context == NULL ? nullstr : bytes_to_str(wmem_packet_scope(), coinfo->oscore_info->kid_context, coinfo->oscore_info->kid_context_len),\n\t\t\t\t coinfo->oscore_info->piv == NULL ? nullstr : bytes_to_str(wmem_packet_scope(), coinfo->oscore_info->piv, coinfo->oscore_info->piv_len));\n\t}\n}",
        "func": "static void\ndissect_coap_opt_object_security(tvbuff_t *tvb, proto_item *head_item, proto_tree *subtree, gint offset, gint opt_length, packet_info *pinfo, coap_info *coinfo, coap_common_dissect_t *dissect_hf)\n{\n\tguint8 flag_byte = 0;\n\tgboolean non_compressed = FALSE;\n\tgboolean expand = FALSE;\n\tgboolean signature_present = FALSE;\n\tgboolean kid_context_present = FALSE;\n\tgboolean kid_present = FALSE;\n\tguint8 piv_len = 0;\n\tguint8 kid_context_len = 0;\n\tguint8 kid_len = 0;\n\n\tcoinfo->object_security = TRUE;\n\n\tcoinfo->oscore_info->piv = NULL;\n\tcoinfo->oscore_info->piv_len = 0;\n\tcoinfo->oscore_info->kid_context = NULL;\n\tcoinfo->oscore_info->kid_context_len = 0;\n\tcoinfo->oscore_info->kid = NULL;\n\tcoinfo->oscore_info->kid_len = 0;\n\n\tif (opt_length == 0) { /* option length is zero, means flag byte is 0x00*/\n\t\t/* add info to the head of the packet detail */\n\t\tproto_item_append_text(head_item, \": 00 (no Flag Byte)\");\n\t} else {\n\t\tflag_byte = tvb_get_guint8(tvb, offset);\n\n\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_non_compressed, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\tnon_compressed = flag_byte & COAP_OBJECT_SECURITY_NON_COMPRESSED_MASK;\n\n\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_expand, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\texpand = flag_byte & COAP_OBJECT_SECURITY_EXPAND_MASK;\n\n\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_signature, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\tsignature_present = flag_byte & COAP_OBJECT_SECURITY_SIGNATURE_MASK;\n\n\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_kid_context_present, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\tkid_context_present = flag_byte & COAP_OBJECT_SECURITY_KID_CONTEXT_MASK;\n\n\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_kid_present, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\tkid_present = flag_byte & COAP_OBJECT_SECURITY_KID_MASK;\n\n\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_piv_len, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\tpiv_len = (flag_byte & COAP_OBJECT_SECURITY_PIVLEN_MASK) >> 0;\n\n\t\t/* kid_len is what remains in the option after all other fields are parsed\n\t\twe calculate kid_len by subtracting from option length as we parse individual fields */\n\t\tkid_len = opt_length;\n\n\t\toffset += 1;\n\t\tkid_len -= 1;\n\n\t\tif (non_compressed || expand || signature_present) {\n\t\t\t/* how these bits are handled is not yet specified */\n\t\t\texpert_add_info_format(pinfo, subtree, &dissect_hf->ei.opt_object_security_bad, \"Unsupported format\");\n\t\t}\n\n\t\tif (piv_len > 0) {\n\t\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_piv, tvb, offset, piv_len, ENC_NA);\n\t\t\tcoinfo->oscore_info->piv = (guint8 *) tvb_memdup(wmem_packet_scope(), tvb, offset, piv_len);\n\t\t\tcoinfo->oscore_info->piv_len = piv_len;\n\n\t\t\toffset += piv_len;\n\t\t\tkid_len -= piv_len;\n\t\t}\n\n\t\tif (kid_context_present) {\n\t\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_kid_context_len, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\t\tkid_context_len = tvb_get_guint8(tvb, offset);\n\n\t\t\toffset += 1;\n\t\t\tkid_len -= 1;\n\n\t\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_kid_context, tvb, offset, kid_context_len, ENC_NA);\n\t\t\tcoinfo->oscore_info->kid_context = (guint8 *) tvb_memdup(wmem_packet_scope(), tvb, offset, kid_context_len);\n\t\t\tcoinfo->oscore_info->kid_context_len = kid_context_len;\n\n\t\t\toffset += kid_context_len;\n\t\t\tkid_len -= kid_context_len;\n\t\t}\n\n\t\tif (kid_present) {\n\t\t\tif(kid_len > 0) {\n\t\t\t\tproto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_kid, tvb, offset, kid_len, ENC_NA);\n\t\t\t\tcoinfo->oscore_info->kid = (guint8 *) tvb_memdup(wmem_packet_scope(), tvb, offset, kid_len);\n\t\t\t\tcoinfo->oscore_info->kid_len = kid_len;\n\n\t\t\t} else {\n\t\t\t\texpert_add_info_format(pinfo, subtree, &dissect_hf->ei.opt_object_security_bad, \"Key ID flag is set but there are no remaining bytes to be processed\");\n\t\t\t}\n\t\t}\n\n\t\tproto_item_append_text(head_item, \": Key ID:%s, Key ID Context:%s, Partial IV:%s\",\n\t\t\t\t coinfo->oscore_info->kid == NULL ? nullstr : bytes_to_str(wmem_packet_scope(), coinfo->oscore_info->kid, coinfo->oscore_info->kid_len),\n\t\t\t\t coinfo->oscore_info->kid_context == NULL ? nullstr : bytes_to_str(wmem_packet_scope(), coinfo->oscore_info->kid_context, coinfo->oscore_info->kid_context_len),\n\t\t\t\t coinfo->oscore_info->piv == NULL ? nullstr : bytes_to_str(wmem_packet_scope(), coinfo->oscore_info->piv, coinfo->oscore_info->piv_len));\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,8 +14,11 @@\n \tcoinfo->object_security = TRUE;\n \n \tcoinfo->oscore_info->piv = NULL;\n+\tcoinfo->oscore_info->piv_len = 0;\n \tcoinfo->oscore_info->kid_context = NULL;\n+\tcoinfo->oscore_info->kid_context_len = 0;\n \tcoinfo->oscore_info->kid = NULL;\n+\tcoinfo->oscore_info->kid_len = 0;\n \n \tif (opt_length == 0) { /* option length is zero, means flag byte is 0x00*/\n \t\t/* add info to the head of the packet detail */",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tcoinfo->oscore_info->piv_len = 0;",
                "\tcoinfo->oscore_info->kid_context_len = 0;",
                "\tcoinfo->oscore_info->kid_len = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-18225",
        "func_name": "wireshark/dissect_coap",
        "description": "In Wireshark 2.6.0 to 2.6.3, the CoAP dissector could crash. This was addressed in epan/dissectors/packet-coap.c by ensuring that the piv length is correctly computed.",
        "git_url": "https://github.com/wireshark/wireshark/commit/b2bbd9fdf209911d94b23cc33f4daccbceb7fa8a",
        "commit_title": "coap: ensure that piv_len matches piv",
        "commit_text": " In frame 121, piv_len was 1 while piv was NULL. Ensure that both piv and piv_len are reset to avoid this. Adjust another check to ensure that piv and piv_len are in sync (probably not necessary, but it seems the intention).  Bug: 15172 (cherry picked from commit 5a2aafef7a8ad4b3917823133c2e3534951fc4d3)",
        "func_before": "static int\ndissect_coap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void* data _U_)\n{\n\tgint              offset = 0;\n\tproto_item       *coap_root;\n\tproto_item       *pi;\n\tproto_tree       *coap_tree;\n\tguint8            ttype;\n\tguint8            token_len;\n\tguint8            code;\n\tguint8            code_class;\n\tguint16           mid;\n\tgint              coap_length;\n\tgchar            *coap_token_str;\n\tcoap_info        *coinfo;\n\tconversation_t   *conversation;\n\tcoap_conv_info   *ccinfo;\n\tcoap_transaction *coap_trans = NULL;\n\n\t/* Allocate information for upper layers */\n\tcoinfo = (coap_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_coap, 0);\n\n\tif (coinfo == NULL)\n\t{\n\t\tcoinfo = wmem_new0(wmem_file_scope(), coap_info);\n\t\tp_add_proto_data(wmem_file_scope(), pinfo, proto_coap, 0, coinfo);\n\t}\n\n\t/* initialize the CoAP length and the content-Format */\n\t/*\n\t * the length of CoAP message is not specified in the CoAP header.\n\t * It has to be from the lower layer.\n\t * Currently, the length is just copied from the reported length of the tvbuffer.\n\t */\n\tcoap_length = tvb_reported_length(tvb);\n\tcoinfo->ctype_str = \"\";\n\tcoinfo->ctype_value = DEFAULT_COAP_CTYPE_VALUE;\n\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"CoAP\");\n\tcol_clear(pinfo->cinfo, COL_INFO);\n\n\tcoap_root = proto_tree_add_item(parent_tree, proto_coap, tvb, offset, -1, ENC_NA);\n\tcoap_tree = proto_item_add_subtree(coap_root, ett_coap);\n\n\tproto_tree_add_item(coap_tree, hf_coap_version, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n\tproto_tree_add_item(coap_tree, hf_coap_ttype, tvb, offset, 1, ENC_BIG_ENDIAN);\n\tttype = (tvb_get_guint8(tvb, offset) & COAP_TYPE_MASK) >> 4;\n\n\tproto_tree_add_item(coap_tree, hf_coap_token_len, tvb, offset, 1, ENC_BIG_ENDIAN);\n\ttoken_len = tvb_get_guint8(tvb, offset) & COAP_TOKEN_LEN_MASK;\n\n\toffset += 1;\n\n\tcode = dissect_coap_code(tvb, coap_tree, &offset, &dissect_coap_hf, &code_class);\n\n\tproto_tree_add_item(coap_tree, hf_coap_mid, tvb, offset, 2, ENC_BIG_ENDIAN);\n\tmid = tvb_get_ntohs(tvb, offset);\n\n\tcol_add_fstr(pinfo->cinfo, COL_INFO,\n\t\t     \"%s, MID:%u, %s\",\n\t\t     val_to_str(ttype, vals_ttype_short, \"Unknown %u\"),\n\t\t     mid,\n\t\t     val_to_str_ext(code, &coap_vals_code_ext, \"Unknown %u\"));\n\n\t/* append the header information */\n\tproto_item_append_text(coap_root,\n\t\t\t       \", %s, %s, MID:%u\",\n\t\t\t       val_to_str(ttype, vals_ttype, \"Unknown %u\"),\n\t\t\t       val_to_str_ext(code, &coap_vals_code_ext, \"Unknown %u\"),\n\t\t\t       mid);\n\n\toffset += 2;\n\n\t/* initialize the external value */\n\tcoinfo->block_number = DEFAULT_COAP_BLOCK_NUMBER;\n\tcoinfo->block_mflag  = 0;\n\tcoinfo->uri_str_strbuf   = wmem_strbuf_sized_new(wmem_packet_scope(), 0, 1024);\n\tcoinfo->uri_query_strbuf = wmem_strbuf_sized_new(wmem_packet_scope(), 0, 1024);\n\t /* Allocate pointers and static elements of oscore_info_t, arrays are allocated only if object security option is found during option parsing */\n\tcoinfo->oscore_info = wmem_new0(wmem_packet_scope(), oscore_info_t);\n\tcoinfo->object_security = FALSE;\n\tcoap_token_str = NULL;\n\n\tif (token_len > 0)\n\t{\n\t\t/* This has to be file scope as the token string is stored in the map\n\t\t* for conversation lookup */\n\t\tcoap_token_str = tvb_bytes_to_str_punct(wmem_file_scope(), tvb, offset, token_len, ' ');\n\t\tproto_tree_add_item(coap_tree, hf_coap_token,\n\t\t\t\t    tvb, offset, token_len, ENC_NA);\n\t\toffset += token_len;\n\t}\n\n\t/* process options */\n\toffset = dissect_coap_options(tvb, pinfo, coap_tree, offset, coap_length, coinfo, &dissect_coap_hf);\n\tif (offset == -1)\n\t\treturn tvb_captured_length(tvb);\n\n\t/* Use conversations to track state for request/response */\n\tconversation = find_or_create_conversation_noaddrb(pinfo, (code_class == 0));\n\n\t/* Retrieve or create state structure for this conversation */\n\tccinfo = (coap_conv_info *)conversation_get_proto_data(conversation, proto_coap);\n\tif (!ccinfo) {\n\t\t/* No state structure - create it */\n\t\tccinfo = wmem_new(wmem_file_scope(), coap_conv_info);\n\t\tccinfo->messages = wmem_map_new(wmem_file_scope(), g_str_hash, g_str_equal);\n\t\tconversation_add_proto_data(conversation, proto_coap, ccinfo);\n\t}\n\n\t/* Everything based on tokens */\n\tif (coap_token_str != NULL) {\n\t\t/* Process request/response in conversation */\n\t\tif (code != 0) { /* Ignore empty messages */\n\t\t\t/* Try and look up a matching token. If it's the first\n\t\t\t* sight of a request, there shouldn't be one */\n\t\t\tcoap_trans = (coap_transaction *)wmem_map_lookup(ccinfo->messages, coap_token_str);\n\t\t\tif (!coap_trans) {\n\t\t\t\tif ((!PINFO_FD_VISITED(pinfo)) && (code_class == 0)) {\n\t\t\t\t\t/* New request - log it */\n\t\t\t\t\tcoap_trans = wmem_new0(wmem_file_scope(), coap_transaction);\n\t\t\t\t\tcoap_trans->req_frame = pinfo->num;\n\t\t\t\t\tcoap_trans->rsp_frame = 0;\n\t\t\t\t\tcoap_trans->req_time = pinfo->fd->abs_ts;\n\t\t\t\t\tif (coinfo->uri_str_strbuf) {\n\t\t\t\t\t\t/* Store the URI into CoAP transaction info */\n\t\t\t\t\t\tcoap_trans->uri_str_strbuf = wmem_strbuf_new(wmem_file_scope(), wmem_strbuf_get_str(coinfo->uri_str_strbuf));\n\t\t\t\t\t}\n\t\t\t\t\tif (coinfo->oscore_info) {\n\t\t\t\t\t\tcoap_trans->oscore_info = (oscore_info_t *) wmem_memdup(wmem_file_scope(), coinfo->oscore_info, sizeof(oscore_info_t));\n\t\t\t\t\t\tif (coinfo->oscore_info->kid) {\n\t\t\t\t\t\t\tcoap_trans->oscore_info->kid = (guint8 *) wmem_memdup(wmem_file_scope(), coinfo->oscore_info->kid, coinfo->oscore_info->kid_len);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (coinfo->oscore_info->kid_context) {\n\t\t\t\t\t\t\tcoap_trans->oscore_info->kid_context = (guint8 *) wmem_memdup(wmem_file_scope(), coinfo->oscore_info->kid_context, coinfo->oscore_info->kid_context_len);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (coinfo->oscore_info->piv) {\n\t\t\t\t\t\t\tcoap_trans->oscore_info->piv = (guint8 *) wmem_memdup(wmem_file_scope(), coinfo->oscore_info->piv, coinfo->oscore_info->piv_len);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\twmem_map_insert(ccinfo->messages, coap_token_str, (void *)coap_trans);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((code_class >= 2) && (code_class <= 5)) {\n\t\t\t\t\tif (!PINFO_FD_VISITED(pinfo)) {\n\t\t\t\t\t\t/* Log the first matching response frame */\n\t\t\t\t\t\tcoap_trans->rsp_frame = pinfo->num;\n\t\t\t\t\t}\n\t\t\t\t\tif (coap_trans->uri_str_strbuf) {\n\t\t\t\t\t\t/* Copy the URI stored in matching transaction info into CoAP packet info */\n\t\t\t\t\t\tcoinfo->uri_str_strbuf = wmem_strbuf_new(wmem_packet_scope(), wmem_strbuf_get_str(coap_trans->uri_str_strbuf));\n\t\t\t\t\t}\n\t\t\t\t\tif (coap_trans->oscore_info) {\n\t\t\t\t\t\t/* Copy OSCORE info in matching transaction info into CoAP packet info */\n\t\t\t\t\t\tif (coap_trans->oscore_info->kid) {\n\t\t\t\t\t\t\tcoinfo->oscore_info->kid = (guint8 *) wmem_memdup(wmem_packet_scope(), coap_trans->oscore_info->kid, coap_trans->oscore_info->kid_len);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcoinfo->oscore_info->kid_len = coap_trans->oscore_info->kid_len;\n\n\t\t\t\t\t\tif (coap_trans->oscore_info->kid_context) {\n\t\t\t\t\t\t\tcoinfo->oscore_info->kid_context = (guint8 *) wmem_memdup(wmem_packet_scope(), coap_trans->oscore_info->kid_context, coap_trans->oscore_info->kid_context_len);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcoinfo->oscore_info->kid_context_len = coap_trans->oscore_info->kid_context_len;\n\n\t\t\t\t\t\t/* If PIV is present within the response (current dissection), do not overwrite it! */\n\t\t\t\t\t\tif (coinfo->oscore_info->piv_len > 0) {\n\t\t\t\t\t\t\t/* Indicate to OSCORE that this response contains its own PIV */\n\t\t\t\t\t\t\tcoinfo->oscore_info->piv_in_response = TRUE;\n\t\t\t\t\t\t\tcoap_trans->oscore_info->piv_in_response = TRUE;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (coap_trans->oscore_info->piv) {\n\t\t\t\t\t\t\t\t/* Use the PIV from the request */\n\t\t\t\t\t\t\t\tcoinfo->oscore_info->piv = (guint8 *) wmem_memdup(wmem_packet_scope(), coap_trans->oscore_info->piv, coap_trans->oscore_info->piv_len);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcoinfo->oscore_info->piv_len = coap_trans->oscore_info->piv_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcoinfo->oscore_info->response = TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (coap_trans != NULL) {\n\t\t/* Print state tracking in the tree */\n\t\tif (code_class == 0) {\n\t\t\t/* This is a request */\n\t\t\tif (coap_trans->rsp_frame) {\n\t\t\t\tproto_item *it;\n\n\t\t\t\tit = proto_tree_add_uint(coap_tree, hf_coap_response_in,\n\t\t\t\t\t\ttvb, 0, 0, coap_trans->rsp_frame);\n\t\t\t\tPROTO_ITEM_SET_GENERATED(it);\n\t\t\t}\n\t\t} else if ((code_class >= 2) && (code_class <= 5)) {\n\t\t\t/* This is a reply */\n\t\t\tif (coap_trans->req_frame) {\n\t\t\t\tproto_item *it;\n\t\t\t\tnstime_t ns;\n\n\t\t\t\tit = proto_tree_add_uint(coap_tree, hf_coap_response_to,\n\t\t\t\t\t\ttvb, 0, 0, coap_trans->req_frame);\n\t\t\t\tPROTO_ITEM_SET_GENERATED(it);\n\n\t\t\t\tnstime_delta(&ns, &pinfo->fd->abs_ts, &coap_trans->req_time);\n\t\t\t\tit = proto_tree_add_time(coap_tree, hf_coap_response_time, tvb, 0, 0, &ns);\n\t\t\t\tPROTO_ITEM_SET_GENERATED(it);\n\t\t\t}\n\t\t\tif (coinfo->object_security && coap_trans->oscore_info) {\n\t\t\t\tproto_item *it;\n\n\t\t\t\tit = proto_tree_add_bytes(coap_tree, hf_coap_oscore_kid, tvb, 0, coap_trans->oscore_info->kid_len, coap_trans->oscore_info->kid);\n\t\t\t\tPROTO_ITEM_SET_GENERATED(it);\n\n\t\t\t\tit = proto_tree_add_bytes(coap_tree, hf_coap_oscore_kid_context, tvb, 0, coap_trans->oscore_info->kid_context_len, coap_trans->oscore_info->kid_context);\n\t\t\t\tPROTO_ITEM_SET_GENERATED(it);\n\n\t\t\t\tif (coap_trans->oscore_info->piv_in_response) {\n\t\t\t\t\tit = proto_tree_add_bytes(coap_tree, hf_coap_oscore_piv, tvb, 0, coinfo->oscore_info->piv_len, coinfo->oscore_info->piv);\n\t\t\t\t} else {\n\t\t\t\t\tit = proto_tree_add_bytes(coap_tree, hf_coap_oscore_piv, tvb, 0, coap_trans->oscore_info->piv_len, coap_trans->oscore_info->piv);\n\t\t\t\t}\n\t\t\t\tPROTO_ITEM_SET_GENERATED(it);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* add informations to the packet list */\n\tif (coap_token_str != NULL)\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", TKN:%s\", coap_token_str);\n\tif (coinfo->block_number != DEFAULT_COAP_BLOCK_NUMBER)\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %sBlock #%u\",\n\t\t\t\tcoinfo->block_mflag ? \"\" : \"End of \", coinfo->block_number);\n\tif (wmem_strbuf_get_len(coinfo->uri_str_strbuf) > 0) {\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", wmem_strbuf_get_str(coinfo->uri_str_strbuf));\n\t\t/* Add a generated protocol item as well */\n\t\tpi = proto_tree_add_string(coap_tree, dissect_coap_hf.hf.opt_uri_path_recon, tvb, 0, 0, wmem_strbuf_get_str(coinfo->uri_str_strbuf));\n\t\tPROTO_ITEM_SET_GENERATED(pi);\n\t}\n\tif (wmem_strbuf_get_len(coinfo->uri_query_strbuf) > 0)\n\t\tcol_append_str(pinfo->cinfo, COL_INFO, wmem_strbuf_get_str(coinfo->uri_query_strbuf));\n\n\t/* dissect the payload */\n\tif (coap_length > offset) {\n\t\tdissect_coap_payload(tvb, pinfo, coap_tree, parent_tree, offset, coap_length, code_class, coinfo, &dissect_coap_hf, FALSE);\n\t}\n\n\treturn tvb_captured_length(tvb);\n}",
        "func": "static int\ndissect_coap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void* data _U_)\n{\n\tgint              offset = 0;\n\tproto_item       *coap_root;\n\tproto_item       *pi;\n\tproto_tree       *coap_tree;\n\tguint8            ttype;\n\tguint8            token_len;\n\tguint8            code;\n\tguint8            code_class;\n\tguint16           mid;\n\tgint              coap_length;\n\tgchar            *coap_token_str;\n\tcoap_info        *coinfo;\n\tconversation_t   *conversation;\n\tcoap_conv_info   *ccinfo;\n\tcoap_transaction *coap_trans = NULL;\n\n\t/* Allocate information for upper layers */\n\tcoinfo = (coap_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_coap, 0);\n\n\tif (coinfo == NULL)\n\t{\n\t\tcoinfo = wmem_new0(wmem_file_scope(), coap_info);\n\t\tp_add_proto_data(wmem_file_scope(), pinfo, proto_coap, 0, coinfo);\n\t}\n\n\t/* initialize the CoAP length and the content-Format */\n\t/*\n\t * the length of CoAP message is not specified in the CoAP header.\n\t * It has to be from the lower layer.\n\t * Currently, the length is just copied from the reported length of the tvbuffer.\n\t */\n\tcoap_length = tvb_reported_length(tvb);\n\tcoinfo->ctype_str = \"\";\n\tcoinfo->ctype_value = DEFAULT_COAP_CTYPE_VALUE;\n\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"CoAP\");\n\tcol_clear(pinfo->cinfo, COL_INFO);\n\n\tcoap_root = proto_tree_add_item(parent_tree, proto_coap, tvb, offset, -1, ENC_NA);\n\tcoap_tree = proto_item_add_subtree(coap_root, ett_coap);\n\n\tproto_tree_add_item(coap_tree, hf_coap_version, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n\tproto_tree_add_item(coap_tree, hf_coap_ttype, tvb, offset, 1, ENC_BIG_ENDIAN);\n\tttype = (tvb_get_guint8(tvb, offset) & COAP_TYPE_MASK) >> 4;\n\n\tproto_tree_add_item(coap_tree, hf_coap_token_len, tvb, offset, 1, ENC_BIG_ENDIAN);\n\ttoken_len = tvb_get_guint8(tvb, offset) & COAP_TOKEN_LEN_MASK;\n\n\toffset += 1;\n\n\tcode = dissect_coap_code(tvb, coap_tree, &offset, &dissect_coap_hf, &code_class);\n\n\tproto_tree_add_item(coap_tree, hf_coap_mid, tvb, offset, 2, ENC_BIG_ENDIAN);\n\tmid = tvb_get_ntohs(tvb, offset);\n\n\tcol_add_fstr(pinfo->cinfo, COL_INFO,\n\t\t     \"%s, MID:%u, %s\",\n\t\t     val_to_str(ttype, vals_ttype_short, \"Unknown %u\"),\n\t\t     mid,\n\t\t     val_to_str_ext(code, &coap_vals_code_ext, \"Unknown %u\"));\n\n\t/* append the header information */\n\tproto_item_append_text(coap_root,\n\t\t\t       \", %s, %s, MID:%u\",\n\t\t\t       val_to_str(ttype, vals_ttype, \"Unknown %u\"),\n\t\t\t       val_to_str_ext(code, &coap_vals_code_ext, \"Unknown %u\"),\n\t\t\t       mid);\n\n\toffset += 2;\n\n\t/* initialize the external value */\n\tcoinfo->block_number = DEFAULT_COAP_BLOCK_NUMBER;\n\tcoinfo->block_mflag  = 0;\n\tcoinfo->uri_str_strbuf   = wmem_strbuf_sized_new(wmem_packet_scope(), 0, 1024);\n\tcoinfo->uri_query_strbuf = wmem_strbuf_sized_new(wmem_packet_scope(), 0, 1024);\n\t /* Allocate pointers and static elements of oscore_info_t, arrays are allocated only if object security option is found during option parsing */\n\tcoinfo->oscore_info = wmem_new0(wmem_packet_scope(), oscore_info_t);\n\tcoinfo->object_security = FALSE;\n\tcoap_token_str = NULL;\n\n\tif (token_len > 0)\n\t{\n\t\t/* This has to be file scope as the token string is stored in the map\n\t\t* for conversation lookup */\n\t\tcoap_token_str = tvb_bytes_to_str_punct(wmem_file_scope(), tvb, offset, token_len, ' ');\n\t\tproto_tree_add_item(coap_tree, hf_coap_token,\n\t\t\t\t    tvb, offset, token_len, ENC_NA);\n\t\toffset += token_len;\n\t}\n\n\t/* process options */\n\toffset = dissect_coap_options(tvb, pinfo, coap_tree, offset, coap_length, coinfo, &dissect_coap_hf);\n\tif (offset == -1)\n\t\treturn tvb_captured_length(tvb);\n\n\t/* Use conversations to track state for request/response */\n\tconversation = find_or_create_conversation_noaddrb(pinfo, (code_class == 0));\n\n\t/* Retrieve or create state structure for this conversation */\n\tccinfo = (coap_conv_info *)conversation_get_proto_data(conversation, proto_coap);\n\tif (!ccinfo) {\n\t\t/* No state structure - create it */\n\t\tccinfo = wmem_new(wmem_file_scope(), coap_conv_info);\n\t\tccinfo->messages = wmem_map_new(wmem_file_scope(), g_str_hash, g_str_equal);\n\t\tconversation_add_proto_data(conversation, proto_coap, ccinfo);\n\t}\n\n\t/* Everything based on tokens */\n\tif (coap_token_str != NULL) {\n\t\t/* Process request/response in conversation */\n\t\tif (code != 0) { /* Ignore empty messages */\n\t\t\t/* Try and look up a matching token. If it's the first\n\t\t\t* sight of a request, there shouldn't be one */\n\t\t\tcoap_trans = (coap_transaction *)wmem_map_lookup(ccinfo->messages, coap_token_str);\n\t\t\tif (!coap_trans) {\n\t\t\t\tif ((!PINFO_FD_VISITED(pinfo)) && (code_class == 0)) {\n\t\t\t\t\t/* New request - log it */\n\t\t\t\t\tcoap_trans = wmem_new0(wmem_file_scope(), coap_transaction);\n\t\t\t\t\tcoap_trans->req_frame = pinfo->num;\n\t\t\t\t\tcoap_trans->rsp_frame = 0;\n\t\t\t\t\tcoap_trans->req_time = pinfo->fd->abs_ts;\n\t\t\t\t\tif (coinfo->uri_str_strbuf) {\n\t\t\t\t\t\t/* Store the URI into CoAP transaction info */\n\t\t\t\t\t\tcoap_trans->uri_str_strbuf = wmem_strbuf_new(wmem_file_scope(), wmem_strbuf_get_str(coinfo->uri_str_strbuf));\n\t\t\t\t\t}\n\t\t\t\t\tif (coinfo->oscore_info) {\n\t\t\t\t\t\tcoap_trans->oscore_info = (oscore_info_t *) wmem_memdup(wmem_file_scope(), coinfo->oscore_info, sizeof(oscore_info_t));\n\t\t\t\t\t\tif (coinfo->oscore_info->kid) {\n\t\t\t\t\t\t\tcoap_trans->oscore_info->kid = (guint8 *) wmem_memdup(wmem_file_scope(), coinfo->oscore_info->kid, coinfo->oscore_info->kid_len);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (coinfo->oscore_info->kid_context) {\n\t\t\t\t\t\t\tcoap_trans->oscore_info->kid_context = (guint8 *) wmem_memdup(wmem_file_scope(), coinfo->oscore_info->kid_context, coinfo->oscore_info->kid_context_len);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (coinfo->oscore_info->piv) {\n\t\t\t\t\t\t\tcoap_trans->oscore_info->piv = (guint8 *) wmem_memdup(wmem_file_scope(), coinfo->oscore_info->piv, coinfo->oscore_info->piv_len);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\twmem_map_insert(ccinfo->messages, coap_token_str, (void *)coap_trans);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((code_class >= 2) && (code_class <= 5)) {\n\t\t\t\t\tif (!PINFO_FD_VISITED(pinfo)) {\n\t\t\t\t\t\t/* Log the first matching response frame */\n\t\t\t\t\t\tcoap_trans->rsp_frame = pinfo->num;\n\t\t\t\t\t}\n\t\t\t\t\tif (coap_trans->uri_str_strbuf) {\n\t\t\t\t\t\t/* Copy the URI stored in matching transaction info into CoAP packet info */\n\t\t\t\t\t\tcoinfo->uri_str_strbuf = wmem_strbuf_new(wmem_packet_scope(), wmem_strbuf_get_str(coap_trans->uri_str_strbuf));\n\t\t\t\t\t}\n\t\t\t\t\tif (coap_trans->oscore_info) {\n\t\t\t\t\t\t/* Copy OSCORE info in matching transaction info into CoAP packet info */\n\t\t\t\t\t\tif (coap_trans->oscore_info->kid) {\n\t\t\t\t\t\t\tcoinfo->oscore_info->kid = (guint8 *) wmem_memdup(wmem_packet_scope(), coap_trans->oscore_info->kid, coap_trans->oscore_info->kid_len);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcoinfo->oscore_info->kid_len = coap_trans->oscore_info->kid_len;\n\n\t\t\t\t\t\tif (coap_trans->oscore_info->kid_context) {\n\t\t\t\t\t\t\tcoinfo->oscore_info->kid_context = (guint8 *) wmem_memdup(wmem_packet_scope(), coap_trans->oscore_info->kid_context, coap_trans->oscore_info->kid_context_len);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcoinfo->oscore_info->kid_context_len = coap_trans->oscore_info->kid_context_len;\n\n\t\t\t\t\t\t/* If PIV is present within the response (current dissection), do not overwrite it! */\n\t\t\t\t\t\tif (coinfo->oscore_info->piv_len > 0) {\n\t\t\t\t\t\t\t/* Indicate to OSCORE that this response contains its own PIV */\n\t\t\t\t\t\t\tcoinfo->oscore_info->piv_in_response = TRUE;\n\t\t\t\t\t\t\tcoap_trans->oscore_info->piv_in_response = TRUE;\n\t\t\t\t\t\t} else if (coap_trans->oscore_info->piv_len > 0) {\n\t\t\t\t\t\t\t/* Use the PIV from the request */\n\t\t\t\t\t\t\tcoinfo->oscore_info->piv = (guint8 *) wmem_memdup(wmem_packet_scope(), coap_trans->oscore_info->piv, coap_trans->oscore_info->piv_len);\n\t\t\t\t\t\t\tcoinfo->oscore_info->piv_len = coap_trans->oscore_info->piv_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcoinfo->oscore_info->response = TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (coap_trans != NULL) {\n\t\t/* Print state tracking in the tree */\n\t\tif (code_class == 0) {\n\t\t\t/* This is a request */\n\t\t\tif (coap_trans->rsp_frame) {\n\t\t\t\tproto_item *it;\n\n\t\t\t\tit = proto_tree_add_uint(coap_tree, hf_coap_response_in,\n\t\t\t\t\t\ttvb, 0, 0, coap_trans->rsp_frame);\n\t\t\t\tPROTO_ITEM_SET_GENERATED(it);\n\t\t\t}\n\t\t} else if ((code_class >= 2) && (code_class <= 5)) {\n\t\t\t/* This is a reply */\n\t\t\tif (coap_trans->req_frame) {\n\t\t\t\tproto_item *it;\n\t\t\t\tnstime_t ns;\n\n\t\t\t\tit = proto_tree_add_uint(coap_tree, hf_coap_response_to,\n\t\t\t\t\t\ttvb, 0, 0, coap_trans->req_frame);\n\t\t\t\tPROTO_ITEM_SET_GENERATED(it);\n\n\t\t\t\tnstime_delta(&ns, &pinfo->fd->abs_ts, &coap_trans->req_time);\n\t\t\t\tit = proto_tree_add_time(coap_tree, hf_coap_response_time, tvb, 0, 0, &ns);\n\t\t\t\tPROTO_ITEM_SET_GENERATED(it);\n\t\t\t}\n\t\t\tif (coinfo->object_security && coap_trans->oscore_info) {\n\t\t\t\tproto_item *it;\n\n\t\t\t\tit = proto_tree_add_bytes(coap_tree, hf_coap_oscore_kid, tvb, 0, coap_trans->oscore_info->kid_len, coap_trans->oscore_info->kid);\n\t\t\t\tPROTO_ITEM_SET_GENERATED(it);\n\n\t\t\t\tit = proto_tree_add_bytes(coap_tree, hf_coap_oscore_kid_context, tvb, 0, coap_trans->oscore_info->kid_context_len, coap_trans->oscore_info->kid_context);\n\t\t\t\tPROTO_ITEM_SET_GENERATED(it);\n\n\t\t\t\tif (coap_trans->oscore_info->piv_in_response) {\n\t\t\t\t\tit = proto_tree_add_bytes(coap_tree, hf_coap_oscore_piv, tvb, 0, coinfo->oscore_info->piv_len, coinfo->oscore_info->piv);\n\t\t\t\t} else {\n\t\t\t\t\tit = proto_tree_add_bytes(coap_tree, hf_coap_oscore_piv, tvb, 0, coap_trans->oscore_info->piv_len, coap_trans->oscore_info->piv);\n\t\t\t\t}\n\t\t\t\tPROTO_ITEM_SET_GENERATED(it);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* add informations to the packet list */\n\tif (coap_token_str != NULL)\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", TKN:%s\", coap_token_str);\n\tif (coinfo->block_number != DEFAULT_COAP_BLOCK_NUMBER)\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %sBlock #%u\",\n\t\t\t\tcoinfo->block_mflag ? \"\" : \"End of \", coinfo->block_number);\n\tif (wmem_strbuf_get_len(coinfo->uri_str_strbuf) > 0) {\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", wmem_strbuf_get_str(coinfo->uri_str_strbuf));\n\t\t/* Add a generated protocol item as well */\n\t\tpi = proto_tree_add_string(coap_tree, dissect_coap_hf.hf.opt_uri_path_recon, tvb, 0, 0, wmem_strbuf_get_str(coinfo->uri_str_strbuf));\n\t\tPROTO_ITEM_SET_GENERATED(pi);\n\t}\n\tif (wmem_strbuf_get_len(coinfo->uri_query_strbuf) > 0)\n\t\tcol_append_str(pinfo->cinfo, COL_INFO, wmem_strbuf_get_str(coinfo->uri_query_strbuf));\n\n\t/* dissect the payload */\n\tif (coap_length > offset) {\n\t\tdissect_coap_payload(tvb, pinfo, coap_tree, parent_tree, offset, coap_length, code_class, coinfo, &dissect_coap_hf, FALSE);\n\t}\n\n\treturn tvb_captured_length(tvb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -168,11 +168,9 @@\n \t\t\t\t\t\t\t/* Indicate to OSCORE that this response contains its own PIV */\n \t\t\t\t\t\t\tcoinfo->oscore_info->piv_in_response = TRUE;\n \t\t\t\t\t\t\tcoap_trans->oscore_info->piv_in_response = TRUE;\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tif (coap_trans->oscore_info->piv) {\n-\t\t\t\t\t\t\t\t/* Use the PIV from the request */\n-\t\t\t\t\t\t\t\tcoinfo->oscore_info->piv = (guint8 *) wmem_memdup(wmem_packet_scope(), coap_trans->oscore_info->piv, coap_trans->oscore_info->piv_len);\n-\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t} else if (coap_trans->oscore_info->piv_len > 0) {\n+\t\t\t\t\t\t\t/* Use the PIV from the request */\n+\t\t\t\t\t\t\tcoinfo->oscore_info->piv = (guint8 *) wmem_memdup(wmem_packet_scope(), coap_trans->oscore_info->piv, coap_trans->oscore_info->piv_len);\n \t\t\t\t\t\t\tcoinfo->oscore_info->piv_len = coap_trans->oscore_info->piv_len;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcoinfo->oscore_info->response = TRUE;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t\t\t} else {",
                "\t\t\t\t\t\t\tif (coap_trans->oscore_info->piv) {",
                "\t\t\t\t\t\t\t\t/* Use the PIV from the request */",
                "\t\t\t\t\t\t\t\tcoinfo->oscore_info->piv = (guint8 *) wmem_memdup(wmem_packet_scope(), coap_trans->oscore_info->piv, coap_trans->oscore_info->piv_len);",
                "\t\t\t\t\t\t\t}"
            ],
            "added_lines": [
                "\t\t\t\t\t\t} else if (coap_trans->oscore_info->piv_len > 0) {",
                "\t\t\t\t\t\t\t/* Use the PIV from the request */",
                "\t\t\t\t\t\t\tcoinfo->oscore_info->piv = (guint8 *) wmem_memdup(wmem_packet_scope(), coap_trans->oscore_info->piv, coap_trans->oscore_info->piv_len);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-2163",
        "func_name": "torvalds/linux/backtrack_insn",
        "description": "Incorrect verifier pruningin BPF in Linux Kernel>=5.4leads to unsafe\ncode paths being incorrectly marked as safe, resulting inarbitrary read/write in\nkernel memory, lateral privilege escalation, and container escape.\n",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=71b547f561247897a0a14f3082730156c0533fed",
        "commit_title": "Juan Jose et al reported an issue found via fuzzing where the verifier's",
        "commit_text": "pruning logic prematurely marks a program path as safe.  Consider the following program:     0: (b7) r6 = 1024    1: (b7) r7 = 0    2: (b7) r8 = 0    3: (b7) r9 = -2147483648    4: (97) r6 %= 1025    5: (05) goto pc+0    6: (bd) if r6 <= r9 goto pc+2    7: (97) r6 %= 1    8: (b7) r9 = 0    9: (bd) if r6 <= r9 goto pc+1   10: (b7) r6 = 0   11: (b7) r0 = 0   12: (63) *(u32 *)(r10 -4) = r0   13: (18) r4 = 0xffff888103693400 // map_ptr(ks=4,vs=48)   15: (bf) r1 = r4   16: (bf) r2 = r10   17: (07) r2 += -4   18: (85) call bpf_map_lookup_elem#1   19: (55) if r0 != 0x0 goto pc+1   20: (95) exit   21: (77) r6 >>= 10   22: (27) r6 *= 8192   23: (bf) r1 = r0   24: (0f) r0 += r6   25: (79) r3 = *(u64 *)(r0 +0)   26: (7b) *(u64 *)(r1 +0) = r3   27: (95) exit  The verifier treats this as safe, leading to oob read/write access due to an incorrect verifier conclusion:    func#0 @0   0: R1=ctx(off=0,imm=0) R10=fp0   0: (b7) r6 = 1024                     ; R6_w=1024   1: (b7) r7 = 0                        ; R7_w=0   2: (b7) r8 = 0                        ; R8_w=0   3: (b7) r9 = -2147483648              ; R9_w=-2147483648   4: (97) r6 %= 1025                    ; R6_w=scalar()   5: (05) goto pc+0   6: (bd) if r6 <= r9 goto pc+2         ; R6_w=scalar(umin=18446744071562067969,var_off=(0xffffffff00000000; 0xffffffff)) R9_w=-2147483648   7: (97) r6 %= 1                       ; R6_w=scalar()   8: (b7) r9 = 0                        ; R9=0   9: (bd) if r6 <= r9 goto pc+1         ; R6=scalar(umin=1) R9=0   10: (b7) r6 = 0                       ; R6_w=0   11: (b7) r0 = 0                       ; R0_w=0   12: (63) *(u32 *)(r10 -4) = r0   last_idx 12 first_idx 9   regs=1 stack=0 before 11: (b7) r0 = 0   13: R0_w=0 R10=fp0 fp-8=0000????   13: (18) r4 = 0xffff8ad3886c2a00      ; R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)   15: (bf) r1 = r4                      ; R1_w=map_ptr(off=0,ks=4,vs=48,imm=0) R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)   16: (bf) r2 = r10                     ; R2_w=fp0 R10=fp0   17: (07) r2 += -4                     ; R2_w=fp-4   18: (85) call bpf_map_lookup_elem#1   ; R0=map_value_or_null(id=1,off=0,ks=4,vs=48,imm=0)   19: (55) if r0 != 0x0 goto pc+1       ; R0=0   20: (95) exit    from 19 to 21: R0=map_value(off=0,ks=4,vs=48,imm=0) R6=0 R7=0 R8=0 R9=0 R10=fp0 fp-8=mmmm????   21: (77) r6 >>= 10                    ; R6_w=0   22: (27) r6 *= 8192                   ; R6_w=0   23: (bf) r1 = r0                      ; R0=map_value(off=0,ks=4,vs=48,imm=0) R1_w=map_value(off=0,ks=4,vs=48,imm=0)   24: (0f) r0 += r6   last_idx 24 first_idx 19   regs=40 stack=0 before 23: (bf) r1 = r0   regs=40 stack=0 before 22: (27) r6 *= 8192   regs=40 stack=0 before 21: (77) r6 >>= 10   regs=40 stack=0 before 19: (55) if r0 != 0x0 goto pc+1   parent didn't have regs=40 stack=0 marks: R0_rw=map_value_or_null(id=1,off=0,ks=4,vs=48,imm=0) R6_rw=P0 R7=0 R8=0 R9=0 R10=fp0 fp-8=mmmm????   last_idx 18 first_idx 9   regs=40 stack=0 before 18: (85) call bpf_map_lookup_elem#1   regs=40 stack=0 before 17: (07) r2 += -4   regs=40 stack=0 before 16: (bf) r2 = r10   regs=40 stack=0 before 15: (bf) r1 = r4   regs=40 stack=0 before 13: (18) r4 = 0xffff8ad3886c2a00   regs=40 stack=0 before 12: (63) *(u32 *)(r10 -4) = r0   regs=40 stack=0 before 11: (b7) r0 = 0   regs=40 stack=0 before 10: (b7) r6 = 0   25: (79) r3 = *(u64 *)(r0 +0)         ; R0_w=map_value(off=0,ks=4,vs=48,imm=0) R3_w=scalar()   26: (7b) *(u64 *)(r1 +0) = r3         ; R1_w=map_value(off=0,ks=4,vs=48,imm=0) R3_w=scalar()   27: (95) exit    from 9 to 11: R1=ctx(off=0,imm=0) R6=0 R7=0 R8=0 R9=0 R10=fp0   11: (b7) r0 = 0                       ; R0_w=0   12: (63) *(u32 *)(r10 -4) = r0   last_idx 12 first_idx 11   regs=1 stack=0 before 11: (b7) r0 = 0   13: R0_w=0 R10=fp0 fp-8=0000????   13: (18) r4 = 0xffff8ad3886c2a00      ; R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)   15: (bf) r1 = r4                      ; R1_w=map_ptr(off=0,ks=4,vs=48,imm=0) R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)   16: (bf) r2 = r10                     ; R2_w=fp0 R10=fp0   17: (07) r2 += -4                     ; R2_w=fp-4   18: (85) call bpf_map_lookup_elem#1   frame 0: propagating r6   last_idx 19 first_idx 11   regs=40 stack=0 before 18: (85) call bpf_map_lookup_elem#1   regs=40 stack=0 before 17: (07) r2 += -4   regs=40 stack=0 before 16: (bf) r2 = r10   regs=40 stack=0 before 15: (bf) r1 = r4   regs=40 stack=0 before 13: (18) r4 = 0xffff8ad3886c2a00   regs=40 stack=0 before 12: (63) *(u32 *)(r10 -4) = r0   regs=40 stack=0 before 11: (b7) r0 = 0   parent didn't have regs=40 stack=0 marks: R1=ctx(off=0,imm=0) R6_r=P0 R7=0 R8=0 R9=0 R10=fp0   last_idx 9 first_idx 9   regs=40 stack=0 before 9: (bd) if r6 <= r9 goto pc+1   parent didn't have regs=40 stack=0 marks: R1=ctx(off=0,imm=0) R6_rw=Pscalar() R7_w=0 R8_w=0 R9_rw=0 R10=fp0   last_idx 8 first_idx 0   regs=40 stack=0 before 8: (b7) r9 = 0   regs=40 stack=0 before 7: (97) r6 %= 1   regs=40 stack=0 before 6: (bd) if r6 <= r9 goto pc+2   regs=40 stack=0 before 5: (05) goto pc+0   regs=40 stack=0 before 4: (97) r6 %= 1025   regs=40 stack=0 before 3: (b7) r9 = -2147483648   regs=40 stack=0 before 2: (b7) r8 = 0   regs=40 stack=0 before 1: (b7) r7 = 0   regs=40 stack=0 before 0: (b7) r6 = 1024   19: safe   frame 0: propagating r6   last_idx 9 first_idx 0   regs=40 stack=0 before 6: (bd) if r6 <= r9 goto pc+2   regs=40 stack=0 before 5: (05) goto pc+0   regs=40 stack=0 before 4: (97) r6 %= 1025   regs=40 stack=0 before 3: (b7) r9 = -2147483648   regs=40 stack=0 before 2: (b7) r8 = 0   regs=40 stack=0 before 1: (b7) r7 = 0   regs=40 stack=0 before 0: (b7) r6 = 1024    from 6 to 9: safe   verification time 110 usec   stack depth 4   processed 36 insns (limit 1000000) max_states_per_insn 0 total_states 3 peak_states 3 mark_read 2  The verifier considers this program as safe by mistakenly pruning unsafe code paths. In the above func#0, code lines 0-10 are of interest. In line 0-3 registers r6 to r9 are initialized with known scalar values. In line 4 the register r6 is reset to an unknown scalar given the verifier does not track modulo operations. Due to this, the verifier can also not determine precisely which branches in line 6 and 9 are taken, therefore it needs to explore them both.  As can be seen, the verifier starts with exploring the false/fall-through paths first. The 'from 19 to 21' path has both r6=0 and r9=0 and the pointer arithmetic on r0 += r6 is therefore considered safe. Given the arithmetic, r6 is correctly marked for precision tracking where backtracking kicks in where it walks back the current path all the way where r6 was set to 0 in the fall-through branch.  Next, the pruning logics pops the path 'from 9 to 11' from the stack. Also here, the state of the registers is the same, that is, r6=0 and r9=0, so that at line 19 the path can be pruned as it is considered safe. It is interesting to note that the conditional in line 9 turned r6 into a more precise state, that is, in the fall-through path at the beginning of line 10, it is R6=scalar(umin=1), and in the branch-taken path (which is analyzed here) at the beginning of line 11, r6 turned into a known const r6=0 as r9=0 prior to that and therefore (unsigned) r6 <= 0 concludes that r6 must be 0 (**):    [...]                                 ; R6_w=scalar()   9: (bd) if r6 <= r9 goto pc+1         ; R6=scalar(umin=1) R9=0   [...]    from 9 to 11: R1=ctx(off=0,imm=0) R6=0 R7=0 R8=0 R9=0 R10=fp0   [...]  The next path is 'from 6 to 9'. The verifier considers the old and current state equivalent, and therefore prunes the search incorrectly. Looking into the two states which are being compared by the pruning logic at line 9, the old state consists of R6_rwD=Pscalar() R9_rwD=0 R10=fp0 and the new state consists of R1=ctx(off=0,imm=0) R6_w=scalar(umax=18446744071562067968) R7_w=0 R8_w=0 R9_w=-2147483648 R10=fp0. While r6 had the reg->precise flag correctly set in the old state, r9 did not. Both r6'es are considered as equivalent given the old one is a superset of the current, more precise one, however, r9's actual values (0 vs 0x80000000) mismatch. Given the old r9 did not have reg->precise flag set, the verifier does not consider the register as contributing to the precision state of r6, and therefore it considered both r9 states as equivalent. However, for this specific pruned path (which is also the actual path taken at runtime), register r6 will be 0x400 and r9 0x80000000 when reaching line 21, thus oob-accessing the map.  The purpose of precision tracking is to initially mark registers (including spilled ones) as imprecise to help verifier's pruning logic finding equivalent states it can then prune if they don't contribute to the program's safety aspects. For example, if registers are used for pointer arithmetic or to pass constant length to a helper, then the verifier sets reg->precise flag and backtracks the BPF program instruction sequence and chain of verifier states to ensure that the given register or stack slot including their dependencies are marked as precisely tracked scalar. This also includes any other registers and slots that contribute to a tracked state of given registers/stack slot. This backtracking relies on recorded jmp_history and is able to traverse entire chain of parent states. This process ends only when all the necessary registers/slots and their transitive dependencies are marked as precise.  The backtrack_insn() is called from the current instruction up to the first instruction, and its purpose is to compute a bitmask of registers and stack slots that need precision tracking in the parent's verifier state. For example, if a current instruction is r6 = r7, then r6 needs precision after this instruction and r7 needs precision before this instruction, that is, in the parent state. Hence for the latter r7 is marked and r6 unmarked.  For the class of jmp/jmp32 instructions, backtrack_insn() today only looks at call and exit instructions and for all other conditionals the masks remain as-is. However, in the given situation register r6 has a dependency on r9 (as described above in **), so also that one needs to be marked for precision tracking. In other words, if an imprecise register influences a precise one, then the imprecise register should also be marked precise. Meaning, in the parent state both dest and src register need to be tracked for precision and therefore the marking must be more conservative by setting reg->precise flag for both. The precision propagation needs to cover both for the conditional: if the src reg was marked but not the dst reg and vice versa.  After the fix the program is correctly rejected:    func#0 @0   0: R1=ctx(off=0,imm=0) R10=fp0   0: (b7) r6 = 1024                     ; R6_w=1024   1: (b7) r7 = 0                        ; R7_w=0   2: (b7) r8 = 0                        ; R8_w=0   3: (b7) r9 = -2147483648              ; R9_w=-2147483648   4: (97) r6 %= 1025                    ; R6_w=scalar()   5: (05) goto pc+0   6: (bd) if r6 <= r9 goto pc+2         ; R6_w=scalar(umin=18446744071562067969,var_off=(0xffffffff80000000; 0x7fffffff),u32_min=-2147483648) R9_w=-2147483648   7: (97) r6 %= 1                       ; R6_w=scalar()   8: (b7) r9 = 0                        ; R9=0   9: (bd) if r6 <= r9 goto pc+1         ; R6=scalar(umin=1) R9=0   10: (b7) r6 = 0                       ; R6_w=0   11: (b7) r0 = 0                       ; R0_w=0   12: (63) *(u32 *)(r10 -4) = r0   last_idx 12 first_idx 9   regs=1 stack=0 before 11: (b7) r0 = 0   13: R0_w=0 R10=fp0 fp-8=0000????   13: (18) r4 = 0xffff9290dc5bfe00      ; R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)   15: (bf) r1 = r4                      ; R1_w=map_ptr(off=0,ks=4,vs=48,imm=0) R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)   16: (bf) r2 = r10                     ; R2_w=fp0 R10=fp0   17: (07) r2 += -4                     ; R2_w=fp-4   18: (85) call bpf_map_lookup_elem#1   ; R0=map_value_or_null(id=1,off=0,ks=4,vs=48,imm=0)   19: (55) if r0 != 0x0 goto pc+1       ; R0=0   20: (95) exit    from 19 to 21: R0=map_value(off=0,ks=4,vs=48,imm=0) R6=0 R7=0 R8=0 R9=0 R10=fp0 fp-8=mmmm????   21: (77) r6 >>= 10                    ; R6_w=0   22: (27) r6 *= 8192                   ; R6_w=0   23: (bf) r1 = r0                      ; R0=map_value(off=0,ks=4,vs=48,imm=0) R1_w=map_value(off=0,ks=4,vs=48,imm=0)   24: (0f) r0 += r6   last_idx 24 first_idx 19   regs=40 stack=0 before 23: (bf) r1 = r0   regs=40 stack=0 before 22: (27) r6 *= 8192   regs=40 stack=0 before 21: (77) r6 >>= 10   regs=40 stack=0 before 19: (55) if r0 != 0x0 goto pc+1   parent didn't have regs=40 stack=0 marks: R0_rw=map_value_or_null(id=1,off=0,ks=4,vs=48,imm=0) R6_rw=P0 R7=0 R8=0 R9=0 R10=fp0 fp-8=mmmm????   last_idx 18 first_idx 9   regs=40 stack=0 before 18: (85) call bpf_map_lookup_elem#1   regs=40 stack=0 before 17: (07) r2 += -4   regs=40 stack=0 before 16: (bf) r2 = r10   regs=40 stack=0 before 15: (bf) r1 = r4   regs=40 stack=0 before 13: (18) r4 = 0xffff9290dc5bfe00   regs=40 stack=0 before 12: (63) *(u32 *)(r10 -4) = r0   regs=40 stack=0 before 11: (b7) r0 = 0   regs=40 stack=0 before 10: (b7) r6 = 0   25: (79) r3 = *(u64 *)(r0 +0)         ; R0_w=map_value(off=0,ks=4,vs=48,imm=0) R3_w=scalar()   26: (7b) *(u64 *)(r1 +0) = r3         ; R1_w=map_value(off=0,ks=4,vs=48,imm=0) R3_w=scalar()   27: (95) exit    from 9 to 11: R1=ctx(off=0,imm=0) R6=0 R7=0 R8=0 R9=0 R10=fp0   11: (b7) r0 = 0                       ; R0_w=0   12: (63) *(u32 *)(r10 -4) = r0   last_idx 12 first_idx 11   regs=1 stack=0 before 11: (b7) r0 = 0   13: R0_w=0 R10=fp0 fp-8=0000????   13: (18) r4 = 0xffff9290dc5bfe00      ; R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)   15: (bf) r1 = r4                      ; R1_w=map_ptr(off=0,ks=4,vs=48,imm=0) R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)   16: (bf) r2 = r10                     ; R2_w=fp0 R10=fp0   17: (07) r2 += -4                     ; R2_w=fp-4   18: (85) call bpf_map_lookup_elem#1   frame 0: propagating r6   last_idx 19 first_idx 11   regs=40 stack=0 before 18: (85) call bpf_map_lookup_elem#1   regs=40 stack=0 before 17: (07) r2 += -4   regs=40 stack=0 before 16: (bf) r2 = r10   regs=40 stack=0 before 15: (bf) r1 = r4   regs=40 stack=0 before 13: (18) r4 = 0xffff9290dc5bfe00   regs=40 stack=0 before 12: (63) *(u32 *)(r10 -4) = r0   regs=40 stack=0 before 11: (b7) r0 = 0   parent didn't have regs=40 stack=0 marks: R1=ctx(off=0,imm=0) R6_r=P0 R7=0 R8=0 R9=0 R10=fp0   last_idx 9 first_idx 9   regs=40 stack=0 before 9: (bd) if r6 <= r9 goto pc+1   parent didn't have regs=240 stack=0 marks: R1=ctx(off=0,imm=0) R6_rw=Pscalar() R7_w=0 R8_w=0 R9_rw=P0 R10=fp0   last_idx 8 first_idx 0   regs=240 stack=0 before 8: (b7) r9 = 0   regs=40 stack=0 before 7: (97) r6 %= 1   regs=40 stack=0 before 6: (bd) if r6 <= r9 goto pc+2   regs=240 stack=0 before 5: (05) goto pc+0   regs=240 stack=0 before 4: (97) r6 %= 1025   regs=240 stack=0 before 3: (b7) r9 = -2147483648   regs=40 stack=0 before 2: (b7) r8 = 0   regs=40 stack=0 before 1: (b7) r7 = 0   regs=40 stack=0 before 0: (b7) r6 = 1024   19: safe    from 6 to 9: R1=ctx(off=0,imm=0) R6_w=scalar(umax=18446744071562067968) R7_w=0 R8_w=0 R9_w=-2147483648 R10=fp0   9: (bd) if r6 <= r9 goto pc+1   last_idx 9 first_idx 0   regs=40 stack=0 before 6: (bd) if r6 <= r9 goto pc+2   regs=240 stack=0 before 5: (05) goto pc+0   regs=240 stack=0 before 4: (97) r6 %= 1025   regs=240 stack=0 before 3: (b7) r9 = -2147483648   regs=40 stack=0 before 2: (b7) r8 = 0   regs=40 stack=0 before 1: (b7) r7 = 0   regs=40 stack=0 before 0: (b7) r6 = 1024   last_idx 9 first_idx 0   regs=200 stack=0 before 6: (bd) if r6 <= r9 goto pc+2   regs=240 stack=0 before 5: (05) goto pc+0   regs=240 stack=0 before 4: (97) r6 %= 1025   regs=240 stack=0 before 3: (b7) r9 = -2147483648   regs=40 stack=0 before 2: (b7) r8 = 0   regs=40 stack=0 before 1: (b7) r7 = 0   regs=40 stack=0 before 0: (b7) r6 = 1024   11: R6=scalar(umax=18446744071562067968) R9=-2147483648   11: (b7) r0 = 0                       ; R0_w=0   12: (63) *(u32 *)(r10 -4) = r0   last_idx 12 first_idx 11   regs=1 stack=0 before 11: (b7) r0 = 0   13: R0_w=0 R10=fp0 fp-8=0000????   13: (18) r4 = 0xffff9290dc5bfe00      ; R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)   15: (bf) r1 = r4                      ; R1_w=map_ptr(off=0,ks=4,vs=48,imm=0) R4_w=map_ptr(off=0,ks=4,vs=48,imm=0)   16: (bf) r2 = r10                     ; R2_w=fp0 R10=fp0   17: (07) r2 += -4                     ; R2_w=fp-4   18: (85) call bpf_map_lookup_elem#1   ; R0_w=map_value_or_null(id=3,off=0,ks=4,vs=48,imm=0)   19: (55) if r0 != 0x0 goto pc+1       ; R0_w=0   20: (95) exit    from 19 to 21: R0=map_value(off=0,ks=4,vs=48,imm=0) R6=scalar(umax=18446744071562067968) R7=0 R8=0 R9=-2147483648 R10=fp0 fp-8=mmmm????   21: (77) r6 >>= 10                    ; R6_w=scalar(umax=18014398507384832,var_off=(0x0; 0x3fffffffffffff))   22: (27) r6 *= 8192                   ; R6_w=scalar(smax=9223372036854767616,umax=18446744073709543424,var_off=(0x0; 0xffffffffffffe000),s32_max=2147475456,u32_max=-8192)   23: (bf) r1 = r0                      ; R0=map_value(off=0,ks=4,vs=48,imm=0) R1_w=map_value(off=0,ks=4,vs=48,imm=0)   24: (0f) r0 += r6   last_idx 24 first_idx 21   regs=40 stack=0 before 23: (bf) r1 = r0   regs=40 stack=0 before 22: (27) r6 *= 8192   regs=40 stack=0 before 21: (77) r6 >>= 10   parent didn't have regs=40 stack=0 marks: R0_rw=map_value(off=0,ks=4,vs=48,imm=0) R6_r=Pscalar(umax=18446744071562067968) R7=0 R8=0 R9=-2147483648 R10=fp0 fp-8=mmmm????   last_idx 19 first_idx 11   regs=40 stack=0 before 19: (55) if r0 != 0x0 goto pc+1   regs=40 stack=0 before 18: (85) call bpf_map_lookup_elem#1   regs=40 stack=0 before 17: (07) r2 += -4   regs=40 stack=0 before 16: (bf) r2 = r10   regs=40 stack=0 before 15: (bf) r1 = r4   regs=40 stack=0 before 13: (18) r4 = 0xffff9290dc5bfe00   regs=40 stack=0 before 12: (63) *(u32 *)(r10 -4) = r0   regs=40 stack=0 before 11: (b7) r0 = 0   parent didn't have regs=40 stack=0 marks: R1=ctx(off=0,imm=0) R6_rw=Pscalar(umax=18446744071562067968) R7_w=0 R8_w=0 R9_w=-2147483648 R10=fp0   last_idx 9 first_idx 0   regs=40 stack=0 before 9: (bd) if r6 <= r9 goto pc+1   regs=240 stack=0 before 6: (bd) if r6 <= r9 goto pc+2   regs=240 stack=0 before 5: (05) goto pc+0   regs=240 stack=0 before 4: (97) r6 %= 1025   regs=240 stack=0 before 3: (b7) r9 = -2147483648   regs=40 stack=0 before 2: (b7) r8 = 0   regs=40 stack=0 before 1: (b7) r7 = 0   regs=40 stack=0 before 0: (b7) r6 = 1024   math between map_value pointer and register with unbounded min value is not allowed   verification time 886 usec   stack depth 4   processed 49 insns (limit 1000000) max_states_per_insn 1 total_states 5 peak_states 5 mark_read 2  Co-developed-by: Andrii Nakryiko <andrii@kernel.org> ",
        "func_before": "static int backtrack_insn(struct bpf_verifier_env *env, int idx,\n\t\t\t  u32 *reg_mask, u64 *stack_mask)\n{\n\tconst struct bpf_insn_cbs cbs = {\n\t\t.cb_call\t= disasm_kfunc_name,\n\t\t.cb_print\t= verbose,\n\t\t.private_data\t= env,\n\t};\n\tstruct bpf_insn *insn = env->prog->insnsi + idx;\n\tu8 class = BPF_CLASS(insn->code);\n\tu8 opcode = BPF_OP(insn->code);\n\tu8 mode = BPF_MODE(insn->code);\n\tu32 dreg = 1u << insn->dst_reg;\n\tu32 sreg = 1u << insn->src_reg;\n\tu32 spi;\n\n\tif (insn->code == 0)\n\t\treturn 0;\n\tif (env->log.level & BPF_LOG_LEVEL2) {\n\t\tverbose(env, \"regs=%x stack=%llx before \", *reg_mask, *stack_mask);\n\t\tverbose(env, \"%d: \", idx);\n\t\tprint_bpf_insn(&cbs, insn, env->allow_ptr_leaks);\n\t}\n\n\tif (class == BPF_ALU || class == BPF_ALU64) {\n\t\tif (!(*reg_mask & dreg))\n\t\t\treturn 0;\n\t\tif (opcode == BPF_MOV) {\n\t\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\t\t/* dreg = sreg\n\t\t\t\t * dreg needs precision after this insn\n\t\t\t\t * sreg needs precision before this insn\n\t\t\t\t */\n\t\t\t\t*reg_mask &= ~dreg;\n\t\t\t\t*reg_mask |= sreg;\n\t\t\t} else {\n\t\t\t\t/* dreg = K\n\t\t\t\t * dreg needs precision after this insn.\n\t\t\t\t * Corresponding register is already marked\n\t\t\t\t * as precise=true in this verifier state.\n\t\t\t\t * No further markings in parent are necessary\n\t\t\t\t */\n\t\t\t\t*reg_mask &= ~dreg;\n\t\t\t}\n\t\t} else {\n\t\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\t\t/* dreg += sreg\n\t\t\t\t * both dreg and sreg need precision\n\t\t\t\t * before this insn\n\t\t\t\t */\n\t\t\t\t*reg_mask |= sreg;\n\t\t\t} /* else dreg += K\n\t\t\t   * dreg still needs precision before this insn\n\t\t\t   */\n\t\t}\n\t} else if (class == BPF_LDX) {\n\t\tif (!(*reg_mask & dreg))\n\t\t\treturn 0;\n\t\t*reg_mask &= ~dreg;\n\n\t\t/* scalars can only be spilled into stack w/o losing precision.\n\t\t * Load from any other memory can be zero extended.\n\t\t * The desire to keep that precision is already indicated\n\t\t * by 'precise' mark in corresponding register of this state.\n\t\t * No further tracking necessary.\n\t\t */\n\t\tif (insn->src_reg != BPF_REG_FP)\n\t\t\treturn 0;\n\n\t\t/* dreg = *(u64 *)[fp - off] was a fill from the stack.\n\t\t * that [fp - off] slot contains scalar that needs to be\n\t\t * tracked with precision\n\t\t */\n\t\tspi = (-insn->off - 1) / BPF_REG_SIZE;\n\t\tif (spi >= 64) {\n\t\t\tverbose(env, \"BUG spi %d\\n\", spi);\n\t\t\tWARN_ONCE(1, \"verifier backtracking bug\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t\t*stack_mask |= 1ull << spi;\n\t} else if (class == BPF_STX || class == BPF_ST) {\n\t\tif (*reg_mask & dreg)\n\t\t\t/* stx & st shouldn't be using _scalar_ dst_reg\n\t\t\t * to access memory. It means backtracking\n\t\t\t * encountered a case of pointer subtraction.\n\t\t\t */\n\t\t\treturn -ENOTSUPP;\n\t\t/* scalars can only be spilled into stack */\n\t\tif (insn->dst_reg != BPF_REG_FP)\n\t\t\treturn 0;\n\t\tspi = (-insn->off - 1) / BPF_REG_SIZE;\n\t\tif (spi >= 64) {\n\t\t\tverbose(env, \"BUG spi %d\\n\", spi);\n\t\t\tWARN_ONCE(1, \"verifier backtracking bug\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (!(*stack_mask & (1ull << spi)))\n\t\t\treturn 0;\n\t\t*stack_mask &= ~(1ull << spi);\n\t\tif (class == BPF_STX)\n\t\t\t*reg_mask |= sreg;\n\t} else if (class == BPF_JMP || class == BPF_JMP32) {\n\t\tif (opcode == BPF_CALL) {\n\t\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\t\treturn -ENOTSUPP;\n\t\t\t/* BPF helpers that invoke callback subprogs are\n\t\t\t * equivalent to BPF_PSEUDO_CALL above\n\t\t\t */\n\t\t\tif (insn->src_reg == 0 && is_callback_calling_function(insn->imm))\n\t\t\t\treturn -ENOTSUPP;\n\t\t\t/* kfunc with imm==0 is invalid and fixup_kfunc_call will\n\t\t\t * catch this error later. Make backtracking conservative\n\t\t\t * with ENOTSUPP.\n\t\t\t */\n\t\t\tif (insn->src_reg == BPF_PSEUDO_KFUNC_CALL && insn->imm == 0)\n\t\t\t\treturn -ENOTSUPP;\n\t\t\t/* regular helper call sets R0 */\n\t\t\t*reg_mask &= ~1;\n\t\t\tif (*reg_mask & 0x3f) {\n\t\t\t\t/* if backtracing was looking for registers R1-R5\n\t\t\t\t * they should have been found already.\n\t\t\t\t */\n\t\t\t\tverbose(env, \"BUG regs %x\\n\", *reg_mask);\n\t\t\t\tWARN_ONCE(1, \"verifier backtracking bug\");\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else if (opcode == BPF_EXIT) {\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t} else if (class == BPF_LD) {\n\t\tif (!(*reg_mask & dreg))\n\t\t\treturn 0;\n\t\t*reg_mask &= ~dreg;\n\t\t/* It's ld_imm64 or ld_abs or ld_ind.\n\t\t * For ld_imm64 no further tracking of precision\n\t\t * into parent is necessary\n\t\t */\n\t\tif (mode == BPF_IND || mode == BPF_ABS)\n\t\t\t/* to be analyzed */\n\t\t\treturn -ENOTSUPP;\n\t}\n\treturn 0;\n}",
        "func": "static int backtrack_insn(struct bpf_verifier_env *env, int idx,\n\t\t\t  u32 *reg_mask, u64 *stack_mask)\n{\n\tconst struct bpf_insn_cbs cbs = {\n\t\t.cb_call\t= disasm_kfunc_name,\n\t\t.cb_print\t= verbose,\n\t\t.private_data\t= env,\n\t};\n\tstruct bpf_insn *insn = env->prog->insnsi + idx;\n\tu8 class = BPF_CLASS(insn->code);\n\tu8 opcode = BPF_OP(insn->code);\n\tu8 mode = BPF_MODE(insn->code);\n\tu32 dreg = 1u << insn->dst_reg;\n\tu32 sreg = 1u << insn->src_reg;\n\tu32 spi;\n\n\tif (insn->code == 0)\n\t\treturn 0;\n\tif (env->log.level & BPF_LOG_LEVEL2) {\n\t\tverbose(env, \"regs=%x stack=%llx before \", *reg_mask, *stack_mask);\n\t\tverbose(env, \"%d: \", idx);\n\t\tprint_bpf_insn(&cbs, insn, env->allow_ptr_leaks);\n\t}\n\n\tif (class == BPF_ALU || class == BPF_ALU64) {\n\t\tif (!(*reg_mask & dreg))\n\t\t\treturn 0;\n\t\tif (opcode == BPF_MOV) {\n\t\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\t\t/* dreg = sreg\n\t\t\t\t * dreg needs precision after this insn\n\t\t\t\t * sreg needs precision before this insn\n\t\t\t\t */\n\t\t\t\t*reg_mask &= ~dreg;\n\t\t\t\t*reg_mask |= sreg;\n\t\t\t} else {\n\t\t\t\t/* dreg = K\n\t\t\t\t * dreg needs precision after this insn.\n\t\t\t\t * Corresponding register is already marked\n\t\t\t\t * as precise=true in this verifier state.\n\t\t\t\t * No further markings in parent are necessary\n\t\t\t\t */\n\t\t\t\t*reg_mask &= ~dreg;\n\t\t\t}\n\t\t} else {\n\t\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\t\t/* dreg += sreg\n\t\t\t\t * both dreg and sreg need precision\n\t\t\t\t * before this insn\n\t\t\t\t */\n\t\t\t\t*reg_mask |= sreg;\n\t\t\t} /* else dreg += K\n\t\t\t   * dreg still needs precision before this insn\n\t\t\t   */\n\t\t}\n\t} else if (class == BPF_LDX) {\n\t\tif (!(*reg_mask & dreg))\n\t\t\treturn 0;\n\t\t*reg_mask &= ~dreg;\n\n\t\t/* scalars can only be spilled into stack w/o losing precision.\n\t\t * Load from any other memory can be zero extended.\n\t\t * The desire to keep that precision is already indicated\n\t\t * by 'precise' mark in corresponding register of this state.\n\t\t * No further tracking necessary.\n\t\t */\n\t\tif (insn->src_reg != BPF_REG_FP)\n\t\t\treturn 0;\n\n\t\t/* dreg = *(u64 *)[fp - off] was a fill from the stack.\n\t\t * that [fp - off] slot contains scalar that needs to be\n\t\t * tracked with precision\n\t\t */\n\t\tspi = (-insn->off - 1) / BPF_REG_SIZE;\n\t\tif (spi >= 64) {\n\t\t\tverbose(env, \"BUG spi %d\\n\", spi);\n\t\t\tWARN_ONCE(1, \"verifier backtracking bug\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t\t*stack_mask |= 1ull << spi;\n\t} else if (class == BPF_STX || class == BPF_ST) {\n\t\tif (*reg_mask & dreg)\n\t\t\t/* stx & st shouldn't be using _scalar_ dst_reg\n\t\t\t * to access memory. It means backtracking\n\t\t\t * encountered a case of pointer subtraction.\n\t\t\t */\n\t\t\treturn -ENOTSUPP;\n\t\t/* scalars can only be spilled into stack */\n\t\tif (insn->dst_reg != BPF_REG_FP)\n\t\t\treturn 0;\n\t\tspi = (-insn->off - 1) / BPF_REG_SIZE;\n\t\tif (spi >= 64) {\n\t\t\tverbose(env, \"BUG spi %d\\n\", spi);\n\t\t\tWARN_ONCE(1, \"verifier backtracking bug\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (!(*stack_mask & (1ull << spi)))\n\t\t\treturn 0;\n\t\t*stack_mask &= ~(1ull << spi);\n\t\tif (class == BPF_STX)\n\t\t\t*reg_mask |= sreg;\n\t} else if (class == BPF_JMP || class == BPF_JMP32) {\n\t\tif (opcode == BPF_CALL) {\n\t\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\t\treturn -ENOTSUPP;\n\t\t\t/* BPF helpers that invoke callback subprogs are\n\t\t\t * equivalent to BPF_PSEUDO_CALL above\n\t\t\t */\n\t\t\tif (insn->src_reg == 0 && is_callback_calling_function(insn->imm))\n\t\t\t\treturn -ENOTSUPP;\n\t\t\t/* kfunc with imm==0 is invalid and fixup_kfunc_call will\n\t\t\t * catch this error later. Make backtracking conservative\n\t\t\t * with ENOTSUPP.\n\t\t\t */\n\t\t\tif (insn->src_reg == BPF_PSEUDO_KFUNC_CALL && insn->imm == 0)\n\t\t\t\treturn -ENOTSUPP;\n\t\t\t/* regular helper call sets R0 */\n\t\t\t*reg_mask &= ~1;\n\t\t\tif (*reg_mask & 0x3f) {\n\t\t\t\t/* if backtracing was looking for registers R1-R5\n\t\t\t\t * they should have been found already.\n\t\t\t\t */\n\t\t\t\tverbose(env, \"BUG regs %x\\n\", *reg_mask);\n\t\t\t\tWARN_ONCE(1, \"verifier backtracking bug\");\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else if (opcode == BPF_EXIT) {\n\t\t\treturn -ENOTSUPP;\n\t\t} else if (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (!(*reg_mask & (dreg | sreg)))\n\t\t\t\treturn 0;\n\t\t\t/* dreg <cond> sreg\n\t\t\t * Both dreg and sreg need precision before\n\t\t\t * this insn. If only sreg was marked precise\n\t\t\t * before it would be equally necessary to\n\t\t\t * propagate it to dreg.\n\t\t\t */\n\t\t\t*reg_mask |= (sreg | dreg);\n\t\t\t /* else dreg <cond> K\n\t\t\t  * Only dreg still needs precision before\n\t\t\t  * this insn, so for the K-based conditional\n\t\t\t  * there is nothing new to be marked.\n\t\t\t  */\n\t\t}\n\t} else if (class == BPF_LD) {\n\t\tif (!(*reg_mask & dreg))\n\t\t\treturn 0;\n\t\t*reg_mask &= ~dreg;\n\t\t/* It's ld_imm64 or ld_abs or ld_ind.\n\t\t * For ld_imm64 no further tracking of precision\n\t\t * into parent is necessary\n\t\t */\n\t\tif (mode == BPF_IND || mode == BPF_ABS)\n\t\t\t/* to be analyzed */\n\t\t\treturn -ENOTSUPP;\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -126,6 +126,21 @@\n \t\t\t}\n \t\t} else if (opcode == BPF_EXIT) {\n \t\t\treturn -ENOTSUPP;\n+\t\t} else if (BPF_SRC(insn->code) == BPF_X) {\n+\t\t\tif (!(*reg_mask & (dreg | sreg)))\n+\t\t\t\treturn 0;\n+\t\t\t/* dreg <cond> sreg\n+\t\t\t * Both dreg and sreg need precision before\n+\t\t\t * this insn. If only sreg was marked precise\n+\t\t\t * before it would be equally necessary to\n+\t\t\t * propagate it to dreg.\n+\t\t\t */\n+\t\t\t*reg_mask |= (sreg | dreg);\n+\t\t\t /* else dreg <cond> K\n+\t\t\t  * Only dreg still needs precision before\n+\t\t\t  * this insn, so for the K-based conditional\n+\t\t\t  * there is nothing new to be marked.\n+\t\t\t  */\n \t\t}\n \t} else if (class == BPF_LD) {\n \t\tif (!(*reg_mask & dreg))",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t} else if (BPF_SRC(insn->code) == BPF_X) {",
                "\t\t\tif (!(*reg_mask & (dreg | sreg)))",
                "\t\t\t\treturn 0;",
                "\t\t\t/* dreg <cond> sreg",
                "\t\t\t * Both dreg and sreg need precision before",
                "\t\t\t * this insn. If only sreg was marked precise",
                "\t\t\t * before it would be equally necessary to",
                "\t\t\t * propagate it to dreg.",
                "\t\t\t */",
                "\t\t\t*reg_mask |= (sreg | dreg);",
                "\t\t\t /* else dreg <cond> K",
                "\t\t\t  * Only dreg still needs precision before",
                "\t\t\t  * this insn, so for the K-based conditional",
                "\t\t\t  * there is nothing new to be marked.",
                "\t\t\t  */"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-31440",
        "func_name": "torvalds/linux/__reg_combine_64_into_32",
        "description": "This vulnerability allows local attackers to escalate privileges on affected installations of Linux Kernel 5.11.15. An attacker must first obtain the ability to execute low-privileged code on the target system in order to exploit this vulnerability. The specific flaw exists within the handling of eBPF programs. The issue results from the lack of proper validation of user-supplied eBPF programs prior to executing them. An attacker can leverage this vulnerability to escalate privileges and execute arbitrary code in the context of the kernel. Was ZDI-CAN-13661.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=10bf4e83167cc68595b85fd73bb91e8f2c086e36",
        "commit_title": "Similarly as b02709587ea3 (\"bpf: Fix propagation of 32-bit signed bounds",
        "commit_text": "from 64-bit bounds.\"), we also need to fix the propagation of 32 bit unsigned bounds from 64 bit counterparts. That is, really only set the u32_{min,max}_value when /both/ {umin,umax}_value safely fit in 32 bit space. For example, the register with a umin_value == 1 does /not/ imply that u32_min_value is also equal to 1, since umax_value could be much larger than 32 bit subregister can hold, and thus u32_min_value is in the interval [0,1] instead.  Before fix, invalid tracking result of R2_w=inv1:    [...]   5: R0_w=inv1337 R1=ctx(id=0,off=0,imm=0) R2_w=inv(id=0) R10=fp0   5: (35) if r2 >= 0x1 goto pc+1   [...] // goto path   7: R0=inv1337 R1=ctx(id=0,off=0,imm=0) R2=inv(id=0,umin_value=1) R10=fp0   7: (b6) if w2 <= 0x1 goto pc+1   [...] // goto path   9: R0=inv1337 R1=ctx(id=0,off=0,imm=0) R2=inv(id=0,smin_value=-9223372036854775807,smax_value=9223372032559808513,umin_value=1,umax_value=18446744069414584321,var_off=(0x1; 0xffffffff00000000),s32_min_value=1,s32_max_value=1,u32_max_value=1) R10=fp0   9: (bc) w2 = w2   10: R0=inv1337 R1=ctx(id=0,off=0,imm=0) R2_w=inv1 R10=fp0   [...]  After fix, correct tracking result of R2_w=inv(id=0,umax_value=1,var_off=(0x0; 0x1)):    [...]   5: R0_w=inv1337 R1=ctx(id=0,off=0,imm=0) R2_w=inv(id=0) R10=fp0   5: (35) if r2 >= 0x1 goto pc+1   [...] // goto path   7: R0=inv1337 R1=ctx(id=0,off=0,imm=0) R2=inv(id=0,umin_value=1) R10=fp0   7: (b6) if w2 <= 0x1 goto pc+1   [...] // goto path   9: R0=inv1337 R1=ctx(id=0,off=0,imm=0) R2=inv(id=0,smax_value=9223372032559808513,umax_value=18446744069414584321,var_off=(0x0; 0xffffffff00000001),s32_min_value=0,s32_max_value=1,u32_max_value=1) R10=fp0   9: (bc) w2 = w2   10: R0=inv1337 R1=ctx(id=0,off=0,imm=0) R2_w=inv(id=0,umax_value=1,var_off=(0x0; 0x1)) R10=fp0   [...]  Thus, same issue as in b02709587ea3 holds for unsigned subregister tracking. Also, align __reg64_bound_u32() similarly to __reg64_bound_s32() as done in b02709587ea3 to make them uniform again.  ",
        "func_before": "static void __reg_combine_64_into_32(struct bpf_reg_state *reg)\n{\n\t__mark_reg32_unbounded(reg);\n\n\tif (__reg64_bound_s32(reg->smin_value) && __reg64_bound_s32(reg->smax_value)) {\n\t\treg->s32_min_value = (s32)reg->smin_value;\n\t\treg->s32_max_value = (s32)reg->smax_value;\n\t}\n\tif (__reg64_bound_u32(reg->umin_value))\n\t\treg->u32_min_value = (u32)reg->umin_value;\n\tif (__reg64_bound_u32(reg->umax_value))\n\t\treg->u32_max_value = (u32)reg->umax_value;\n\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__reg_deduce_bounds(reg);\n\t__reg_bound_offset(reg);\n\t__update_reg_bounds(reg);\n}",
        "func": "static void __reg_combine_64_into_32(struct bpf_reg_state *reg)\n{\n\t__mark_reg32_unbounded(reg);\n\n\tif (__reg64_bound_s32(reg->smin_value) && __reg64_bound_s32(reg->smax_value)) {\n\t\treg->s32_min_value = (s32)reg->smin_value;\n\t\treg->s32_max_value = (s32)reg->smax_value;\n\t}\n\tif (__reg64_bound_u32(reg->umin_value) && __reg64_bound_u32(reg->umax_value)) {\n\t\treg->u32_min_value = (u32)reg->umin_value;\n\t\treg->u32_max_value = (u32)reg->umax_value;\n\t}\n\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__reg_deduce_bounds(reg);\n\t__reg_bound_offset(reg);\n\t__update_reg_bounds(reg);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,10 +6,10 @@\n \t\treg->s32_min_value = (s32)reg->smin_value;\n \t\treg->s32_max_value = (s32)reg->smax_value;\n \t}\n-\tif (__reg64_bound_u32(reg->umin_value))\n+\tif (__reg64_bound_u32(reg->umin_value) && __reg64_bound_u32(reg->umax_value)) {\n \t\treg->u32_min_value = (u32)reg->umin_value;\n-\tif (__reg64_bound_u32(reg->umax_value))\n \t\treg->u32_max_value = (u32)reg->umax_value;\n+\t}\n \n \t/* Intersecting with the old var_off might have improved our bounds\n \t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (__reg64_bound_u32(reg->umin_value))",
                "\tif (__reg64_bound_u32(reg->umax_value))"
            ],
            "added_lines": [
                "\tif (__reg64_bound_u32(reg->umin_value) && __reg64_bound_u32(reg->umax_value)) {",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-31440",
        "func_name": "torvalds/linux/__reg64_bound_u32",
        "description": "This vulnerability allows local attackers to escalate privileges on affected installations of Linux Kernel 5.11.15. An attacker must first obtain the ability to execute low-privileged code on the target system in order to exploit this vulnerability. The specific flaw exists within the handling of eBPF programs. The issue results from the lack of proper validation of user-supplied eBPF programs prior to executing them. An attacker can leverage this vulnerability to escalate privileges and execute arbitrary code in the context of the kernel. Was ZDI-CAN-13661.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=10bf4e83167cc68595b85fd73bb91e8f2c086e36",
        "commit_title": "Similarly as b02709587ea3 (\"bpf: Fix propagation of 32-bit signed bounds",
        "commit_text": "from 64-bit bounds.\"), we also need to fix the propagation of 32 bit unsigned bounds from 64 bit counterparts. That is, really only set the u32_{min,max}_value when /both/ {umin,umax}_value safely fit in 32 bit space. For example, the register with a umin_value == 1 does /not/ imply that u32_min_value is also equal to 1, since umax_value could be much larger than 32 bit subregister can hold, and thus u32_min_value is in the interval [0,1] instead.  Before fix, invalid tracking result of R2_w=inv1:    [...]   5: R0_w=inv1337 R1=ctx(id=0,off=0,imm=0) R2_w=inv(id=0) R10=fp0   5: (35) if r2 >= 0x1 goto pc+1   [...] // goto path   7: R0=inv1337 R1=ctx(id=0,off=0,imm=0) R2=inv(id=0,umin_value=1) R10=fp0   7: (b6) if w2 <= 0x1 goto pc+1   [...] // goto path   9: R0=inv1337 R1=ctx(id=0,off=0,imm=0) R2=inv(id=0,smin_value=-9223372036854775807,smax_value=9223372032559808513,umin_value=1,umax_value=18446744069414584321,var_off=(0x1; 0xffffffff00000000),s32_min_value=1,s32_max_value=1,u32_max_value=1) R10=fp0   9: (bc) w2 = w2   10: R0=inv1337 R1=ctx(id=0,off=0,imm=0) R2_w=inv1 R10=fp0   [...]  After fix, correct tracking result of R2_w=inv(id=0,umax_value=1,var_off=(0x0; 0x1)):    [...]   5: R0_w=inv1337 R1=ctx(id=0,off=0,imm=0) R2_w=inv(id=0) R10=fp0   5: (35) if r2 >= 0x1 goto pc+1   [...] // goto path   7: R0=inv1337 R1=ctx(id=0,off=0,imm=0) R2=inv(id=0,umin_value=1) R10=fp0   7: (b6) if w2 <= 0x1 goto pc+1   [...] // goto path   9: R0=inv1337 R1=ctx(id=0,off=0,imm=0) R2=inv(id=0,smax_value=9223372032559808513,umax_value=18446744069414584321,var_off=(0x0; 0xffffffff00000001),s32_min_value=0,s32_max_value=1,u32_max_value=1) R10=fp0   9: (bc) w2 = w2   10: R0=inv1337 R1=ctx(id=0,off=0,imm=0) R2_w=inv(id=0,umax_value=1,var_off=(0x0; 0x1)) R10=fp0   [...]  Thus, same issue as in b02709587ea3 holds for unsigned subregister tracking. Also, align __reg64_bound_u32() similarly to __reg64_bound_s32() as done in b02709587ea3 to make them uniform again.  ",
        "func_before": "static bool __reg64_bound_u32(u64 a)\n{\n\tif (a > U32_MIN && a < U32_MAX)\n\t\treturn true;\n\treturn false;\n}",
        "func": "static bool __reg64_bound_u32(u64 a)\n{\n\treturn a > U32_MIN && a < U32_MAX;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,4 @@\n static bool __reg64_bound_u32(u64 a)\n {\n-\tif (a > U32_MIN && a < U32_MAX)\n-\t\treturn true;\n-\treturn false;\n+\treturn a > U32_MIN && a < U32_MAX;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (a > U32_MIN && a < U32_MAX)",
                "\t\treturn true;",
                "\treturn false;"
            ],
            "added_lines": [
                "\treturn a > U32_MIN && a < U32_MAX;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-3161",
        "func_name": "torvalds/linux/fbcon_set_font",
        "description": "A flaw was found in the Framebuffer Console (fbcon) in the Linux Kernel. When providing font->width and font->height greater than 32 to fbcon_set_font, since there are no checks in place, a shift-out-of-bounds occurs leading to undefined behavior and possible denial of service.",
        "git_url": "https://github.com/torvalds/linux/commit/2b09d5d364986f724f17001ccfe4126b9b43a0be",
        "commit_title": "fbcon: Check font dimension limits",
        "commit_text": " blit_x and blit_y are u32, so fbcon currently cannot support fonts larger than 32x32.  The 32x32 case also needs shifting an unsigned int, to properly set bit 31, otherwise we get \"UBSAN: shift-out-of-bounds in fbcon_set_font\", as reported on:  http://lore.kernel.org/all/IA1PR07MB98308653E259A6F2CE94A4AFABCE9@IA1PR07MB9830.namprd07.prod.outlook.com Kernel Branch: 6.2.0-rc5-next-20230124 Kernel config: https://drive.google.com/file/d/1F-LszDAizEEH0ZX0HcSR06v5q8FPl2Uv/view?usp=sharing Reproducer: https://drive.google.com/file/d/1mP1jcLBY7vWCNM60OMf-ogw-urQRjNrm/view?usp=sharing  Cc: stable@vger.kernel.org",
        "func_before": "static int fbcon_set_font(struct vc_data *vc, struct console_font *font,\n\t\t\t  unsigned int flags)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tunsigned charcount = font->charcount;\n\tint w = font->width;\n\tint h = font->height;\n\tint size;\n\tint i, csum;\n\tu8 *new_data, *data = font->data;\n\tint pitch = PITCH(font->width);\n\n\t/* Is there a reason why fbconsole couldn't handle any charcount >256?\n\t * If not this check should be changed to charcount < 256 */\n\tif (charcount != 256 && charcount != 512)\n\t\treturn -EINVAL;\n\n\t/* font bigger than screen resolution ? */\n\tif (w > FBCON_SWAP(info->var.rotate, info->var.xres, info->var.yres) ||\n\t    h > FBCON_SWAP(info->var.rotate, info->var.yres, info->var.xres))\n\t\treturn -EINVAL;\n\n\t/* Make sure drawing engine can handle the font */\n\tif (!(info->pixmap.blit_x & (1 << (font->width - 1))) ||\n\t    !(info->pixmap.blit_y & (1 << (font->height - 1))))\n\t\treturn -EINVAL;\n\n\t/* Make sure driver can handle the font length */\n\tif (fbcon_invalid_charcount(info, charcount))\n\t\treturn -EINVAL;\n\n\tsize = CALC_FONTSZ(h, pitch, charcount);\n\n\tnew_data = kmalloc(FONT_EXTRA_WORDS * sizeof(int) + size, GFP_USER);\n\n\tif (!new_data)\n\t\treturn -ENOMEM;\n\n\tmemset(new_data, 0, FONT_EXTRA_WORDS * sizeof(int));\n\n\tnew_data += FONT_EXTRA_WORDS * sizeof(int);\n\tFNTSIZE(new_data) = size;\n\tREFCOUNT(new_data) = 0;\t/* usage counter */\n\tfor (i=0; i< charcount; i++) {\n\t\tmemcpy(new_data + i*h*pitch, data +  i*32*pitch, h*pitch);\n\t}\n\n\t/* Since linux has a nice crc32 function use it for counting font\n\t * checksums. */\n\tcsum = crc32(0, new_data, size);\n\n\tFNTSUM(new_data) = csum;\n\t/* Check if the same font is on some other console already */\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\tstruct vc_data *tmp = vc_cons[i].d;\n\t\t\n\t\tif (fb_display[i].userfont &&\n\t\t    fb_display[i].fontdata &&\n\t\t    FNTSUM(fb_display[i].fontdata) == csum &&\n\t\t    FNTSIZE(fb_display[i].fontdata) == size &&\n\t\t    tmp->vc_font.width == w &&\n\t\t    !memcmp(fb_display[i].fontdata, new_data, size)) {\n\t\t\tkfree(new_data - FONT_EXTRA_WORDS * sizeof(int));\n\t\t\tnew_data = (u8 *)fb_display[i].fontdata;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn fbcon_do_set_font(vc, font->width, font->height, charcount, new_data, 1);\n}",
        "func": "static int fbcon_set_font(struct vc_data *vc, struct console_font *font,\n\t\t\t  unsigned int flags)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tunsigned charcount = font->charcount;\n\tint w = font->width;\n\tint h = font->height;\n\tint size;\n\tint i, csum;\n\tu8 *new_data, *data = font->data;\n\tint pitch = PITCH(font->width);\n\n\t/* Is there a reason why fbconsole couldn't handle any charcount >256?\n\t * If not this check should be changed to charcount < 256 */\n\tif (charcount != 256 && charcount != 512)\n\t\treturn -EINVAL;\n\n\t/* font bigger than screen resolution ? */\n\tif (w > FBCON_SWAP(info->var.rotate, info->var.xres, info->var.yres) ||\n\t    h > FBCON_SWAP(info->var.rotate, info->var.yres, info->var.xres))\n\t\treturn -EINVAL;\n\n\tif (font->width > 32 || font->height > 32)\n\t\treturn -EINVAL;\n\n\t/* Make sure drawing engine can handle the font */\n\tif (!(info->pixmap.blit_x & BIT(font->width - 1)) ||\n\t    !(info->pixmap.blit_y & BIT(font->height - 1)))\n\t\treturn -EINVAL;\n\n\t/* Make sure driver can handle the font length */\n\tif (fbcon_invalid_charcount(info, charcount))\n\t\treturn -EINVAL;\n\n\tsize = CALC_FONTSZ(h, pitch, charcount);\n\n\tnew_data = kmalloc(FONT_EXTRA_WORDS * sizeof(int) + size, GFP_USER);\n\n\tif (!new_data)\n\t\treturn -ENOMEM;\n\n\tmemset(new_data, 0, FONT_EXTRA_WORDS * sizeof(int));\n\n\tnew_data += FONT_EXTRA_WORDS * sizeof(int);\n\tFNTSIZE(new_data) = size;\n\tREFCOUNT(new_data) = 0;\t/* usage counter */\n\tfor (i=0; i< charcount; i++) {\n\t\tmemcpy(new_data + i*h*pitch, data +  i*32*pitch, h*pitch);\n\t}\n\n\t/* Since linux has a nice crc32 function use it for counting font\n\t * checksums. */\n\tcsum = crc32(0, new_data, size);\n\n\tFNTSUM(new_data) = csum;\n\t/* Check if the same font is on some other console already */\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\tstruct vc_data *tmp = vc_cons[i].d;\n\t\t\n\t\tif (fb_display[i].userfont &&\n\t\t    fb_display[i].fontdata &&\n\t\t    FNTSUM(fb_display[i].fontdata) == csum &&\n\t\t    FNTSIZE(fb_display[i].fontdata) == size &&\n\t\t    tmp->vc_font.width == w &&\n\t\t    !memcmp(fb_display[i].fontdata, new_data, size)) {\n\t\t\tkfree(new_data - FONT_EXTRA_WORDS * sizeof(int));\n\t\t\tnew_data = (u8 *)fb_display[i].fontdata;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn fbcon_do_set_font(vc, font->width, font->height, charcount, new_data, 1);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,9 +20,12 @@\n \t    h > FBCON_SWAP(info->var.rotate, info->var.yres, info->var.xres))\n \t\treturn -EINVAL;\n \n+\tif (font->width > 32 || font->height > 32)\n+\t\treturn -EINVAL;\n+\n \t/* Make sure drawing engine can handle the font */\n-\tif (!(info->pixmap.blit_x & (1 << (font->width - 1))) ||\n-\t    !(info->pixmap.blit_y & (1 << (font->height - 1))))\n+\tif (!(info->pixmap.blit_x & BIT(font->width - 1)) ||\n+\t    !(info->pixmap.blit_y & BIT(font->height - 1)))\n \t\treturn -EINVAL;\n \n \t/* Make sure driver can handle the font length */",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!(info->pixmap.blit_x & (1 << (font->width - 1))) ||",
                "\t    !(info->pixmap.blit_y & (1 << (font->height - 1))))"
            ],
            "added_lines": [
                "\tif (font->width > 32 || font->height > 32)",
                "\t\treturn -EINVAL;",
                "",
                "\tif (!(info->pixmap.blit_x & BIT(font->width - 1)) ||",
                "\t    !(info->pixmap.blit_y & BIT(font->height - 1)))"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11537",
        "func_name": "ImageMagick/WritePALMImage",
        "description": "When ImageMagick 7.0.6-1 processes a crafted file in convert, it can lead to a Floating Point Exception (FPE) in the WritePALMImage() function in coders/palm.c, related to an incorrect bits-per-pixel calculation.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/bac384563f557d1ac7413d2eaec00dd59c3cc29b",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/560",
        "commit_text": "",
        "func_before": "static MagickBooleanType WritePALMImage(const ImageInfo *image_info,\n  Image *image)\n{\n  ExceptionInfo\n    *exception;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    currentOffset,\n    offset,\n    scene;\n\n  MagickSizeType\n    cc;\n\n  PixelPacket\n    transpix;\n\n  QuantizeInfo\n    *quantize_info;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *p;\n\n  ssize_t\n    y;\n\n  size_t\n    count,\n    bits_per_pixel,\n    bytes_per_row,\n    nextDepthOffset,\n    one;\n\n  unsigned char\n    bit,\n    byte,\n    color,\n    *lastrow,\n    *one_row,\n    *ptr,\n    version;\n\n  unsigned int\n    transparentIndex;\n\n  unsigned short\n    color16,\n    flags;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  exception=AcquireExceptionInfo();\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  quantize_info=AcquireQuantizeInfo(image_info);\n  flags=0;\n  currentOffset=0;\n  transparentIndex=0;\n  transpix.red=0;\n  transpix.green=0;\n  transpix.blue=0;\n  transpix.opacity=0;\n  one=1;\n  version=0;\n  scene=0;\n  do\n  {\n    (void) TransformImageColorspace(image,sRGBColorspace);\n    count=GetNumberColors(image,NULL,exception);\n    for (bits_per_pixel=1;  (one << bits_per_pixel) < count; bits_per_pixel*=2) ;\n    if (image_info->depth > 100)\n      bits_per_pixel=image_info->depth-100;\n    if (bits_per_pixel < 16)\n      (void) TransformImageColorspace(image,image->colorspace);\n    if (bits_per_pixel < 8)\n      {\n        (void) TransformImageColorspace(image,GRAYColorspace);\n        (void) SetImageType(image,PaletteType);\n        (void) SortColormapByIntensity(image);\n      }\n    if ((image->storage_class == PseudoClass) && (image->colors > 256))\n      (void) SetImageStorageClass(image,DirectClass);\n    if (image->storage_class == PseudoClass)\n      flags|=PALM_HAS_COLORMAP_FLAG;\n    else\n      flags|=PALM_IS_DIRECT_COLOR;\n    (void) WriteBlobMSBShort(image,(unsigned short) image->columns); /* width */\n    (void) WriteBlobMSBShort(image,(unsigned short) image->rows);  /* height */\n    bytes_per_row=((image->columns+(16/bits_per_pixel-1))/(16/\n      bits_per_pixel))*2;\n    (void) WriteBlobMSBShort(image,(unsigned short) bytes_per_row);\n    if ((image_info->compression == RLECompression) ||\n        (image_info->compression == FaxCompression))\n      flags|=PALM_IS_COMPRESSED_FLAG;\n    (void) WriteBlobMSBShort(image, flags);\n    (void) WriteBlobByte(image,(unsigned char) bits_per_pixel);\n    if (bits_per_pixel > 1)\n      version=1;\n    if ((image_info->compression == RLECompression) ||\n        (image_info->compression == FaxCompression))\n      version=2;\n    (void) WriteBlobByte(image,version);\n    (void) WriteBlobMSBShort(image,0);  /* nextDepthOffset */\n    (void) WriteBlobByte(image,(unsigned char) transparentIndex);\n    if (image_info->compression == RLECompression)\n      (void) WriteBlobByte(image,PALM_COMPRESSION_RLE);\n    else\n      if (image_info->compression == FaxCompression)\n        (void) WriteBlobByte(image,PALM_COMPRESSION_SCANLINE);\n      else\n        (void) WriteBlobByte(image,PALM_COMPRESSION_NONE);\n    (void) WriteBlobMSBShort(image,0);  /* reserved */\n    offset=16;\n    if (bits_per_pixel == 16)\n      {\n        (void) WriteBlobByte(image,5);  /* # of bits of red */\n        (void) WriteBlobByte(image,6);  /* # of bits of green */\n        (void) WriteBlobByte(image,5);  /* # of bits of blue */\n        (void) WriteBlobByte(image,0);  /* reserved by Palm */\n        (void) WriteBlobMSBLong(image,0);  /* no transparent color, YET */\n        offset+=8;\n      }\n    if (bits_per_pixel == 8)\n      {\n        if (flags & PALM_HAS_COLORMAP_FLAG)  /* Write out colormap */\n          {\n            quantize_info->dither=IsPaletteImage(image,&image->exception);\n            quantize_info->number_colors=image->colors;\n            (void) QuantizeImage(quantize_info,image);\n            (void) WriteBlobMSBShort(image,(unsigned short) image->colors);\n            for (count = 0; count < image->colors; count++)\n            {\n              (void) WriteBlobByte(image,(unsigned char) count);\n              (void) WriteBlobByte(image,ScaleQuantumToChar(\n                image->colormap[count].red));\n              (void) WriteBlobByte(image,\n                ScaleQuantumToChar(image->colormap[count].green));\n              (void) WriteBlobByte(image,\n                ScaleQuantumToChar(image->colormap[count].blue));\n            }\n            offset+=2+count*4;\n          }\n      else  /* Map colors to Palm standard colormap */\n        {\n          Image\n            *affinity_image;\n\n          affinity_image=ConstituteImage(256,1,\"RGB\",CharPixel,&PalmPalette,\n            exception);\n          (void) TransformImageColorspace(affinity_image,\n            affinity_image->colorspace);\n          (void) RemapImage(quantize_info,image,affinity_image);\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            indexes=GetAuthenticIndexQueue(image);\n            for (x=0; x < (ssize_t) image->columns; x++)\n              SetPixelIndex(indexes+x,FindColor(&image->colormap[\n                (ssize_t) GetPixelIndex(indexes+x)]));\n          }\n          affinity_image=DestroyImage(affinity_image);\n        }\n      }\n    if (flags & PALM_IS_COMPRESSED_FLAG)\n      (void) WriteBlobMSBShort(image,0);  /* fill in size later */\n    lastrow=(unsigned char *) NULL;\n    if (image_info->compression == FaxCompression)\n      lastrow=(unsigned char *) AcquireQuantumMemory(bytes_per_row,\n        sizeof(*lastrow));\n      /* TODO check whether memory really was acquired? */\n    one_row=(unsigned char *) AcquireQuantumMemory(bytes_per_row,\n      sizeof(*one_row));\n    if (one_row == (unsigned char *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      ptr=one_row;\n      (void) ResetMagickMemory(ptr,0,bytes_per_row);\n      p=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (p == (PixelPacket *) NULL)\n        break;\n      indexes=GetAuthenticIndexQueue(image);\n      if (bits_per_pixel == 16)\n        {\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            color16=(unsigned short) ((((31*(size_t) GetPixelRed(p))/\n              (size_t) QuantumRange) << 11) |\n              (((63*(size_t) GetPixelGreen(p))/(size_t) QuantumRange) << 5) |\n              ((31*(size_t) GetPixelBlue(p))/(size_t) QuantumRange));\n            if (GetPixelOpacity(p) == (Quantum) TransparentOpacity)\n              {\n                transpix.red=GetPixelRed(p);\n                transpix.green=GetPixelGreen(p);\n                transpix.blue=GetPixelBlue(p);\n                transpix.opacity=GetPixelOpacity(p);\n                flags|=PALM_HAS_TRANSPARENCY_FLAG;\n              }\n            *ptr++=(unsigned char) ((color16 >> 8) & 0xff);\n            *ptr++=(unsigned char) (color16 & 0xff);\n            p++;\n          }\n        }\n      else\n        {\n          byte=0x00;\n          bit=(unsigned char) (8-bits_per_pixel);\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (bits_per_pixel >= 8)\n              color=(unsigned char) GetPixelIndex(indexes+x);\n            else\n              color=(unsigned char) (GetPixelIndex(indexes+x)*\n                ((one << bits_per_pixel)-1)/MagickMax(1*image->colors-1,1));\n            byte|=color << bit;\n            if (bit != 0)\n              bit-=(unsigned char) bits_per_pixel;\n            else\n              {\n                *ptr++=byte;\n                byte=0x00;\n                bit=(unsigned char) (8-bits_per_pixel);\n              }\n          }\n          if ((image->columns % (8/bits_per_pixel)) != 0)\n            *ptr++=byte;\n        }\n      if (image_info->compression == RLECompression)\n        {\n          x=0;\n          while (x < (ssize_t) bytes_per_row)\n          {\n            byte=one_row[x];\n            count=1;\n            while ((one_row[++x] == byte) && (count < 255) &&\n                   (x < (ssize_t) bytes_per_row))\n              count++;\n            (void) WriteBlobByte(image,(unsigned char) count);\n            (void) WriteBlobByte(image,(unsigned char) byte);\n          }\n        }\n      else\n        if (image_info->compression == FaxCompression)\n          {\n            char\n              tmpbuf[8],\n              *tptr;\n\n            for (x = 0;  x < (ssize_t) bytes_per_row;  x += 8)\n            {\n              tptr = tmpbuf;\n              for (bit=0, byte=0; bit < (unsigned char) MagickMin(8,(ssize_t) bytes_per_row-x); bit++)\n              {\n                if ((y == 0) || (lastrow[x + bit] != one_row[x + bit]))\n                  {\n                    byte |= (1 << (7 - bit));\n                    *tptr++ = (char) one_row[x + bit];\n                  }\n              }\n              (void) WriteBlobByte(image, byte);\n              (void) WriteBlob(image,tptr-tmpbuf,(unsigned char *) tmpbuf);\n            }\n            (void) CopyMagickMemory(lastrow,one_row,bytes_per_row);\n          }\n        else\n          (void) WriteBlob(image,bytes_per_row,one_row);\n      }\n    if (flags & PALM_HAS_TRANSPARENCY_FLAG)\n      {\n        offset=SeekBlob(image,currentOffset+6,SEEK_SET);\n        (void) WriteBlobMSBShort(image,flags);\n        offset=SeekBlob(image,currentOffset+12,SEEK_SET);\n        (void) WriteBlobByte(image,(unsigned char) transparentIndex);  /* trans index */\n      }\n    if (bits_per_pixel == 16)\n      {\n        offset=SeekBlob(image,currentOffset+20,SEEK_SET);\n        (void) WriteBlobByte(image,0);  /* reserved by Palm */\n        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.red)/QuantumRange));\n        (void) WriteBlobByte(image,(unsigned char) ((63*transpix.green)/QuantumRange));\n        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.blue)/QuantumRange));\n      }\n    if (flags & PALM_IS_COMPRESSED_FLAG)  /* fill in size now */\n      {\n        offset=SeekBlob(image,currentOffset+offset,SEEK_SET);\n        (void) WriteBlobMSBShort(image,(unsigned short) (GetBlobSize(image)-\n          currentOffset-offset));\n      }\n    if (one_row != (unsigned char *) NULL)\n      one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n    if (lastrow != (unsigned char *) NULL)\n      lastrow=(unsigned char *) RelinquishMagickMemory(lastrow);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    /* padding to 4 byte word */\n    for (cc=(GetBlobSize(image)) % 4; cc > 0; cc--)\n      (void) WriteBlobByte(image,0);\n    /* write nextDepthOffset and return to end of image */\n    (void) SeekBlob(image,currentOffset+10,SEEK_SET);\n    nextDepthOffset=(size_t) ((GetBlobSize(image)-currentOffset)/4);\n    (void) WriteBlobMSBShort(image,(unsigned short) nextDepthOffset);\n    currentOffset=(MagickOffsetType) GetBlobSize(image);\n    (void) SeekBlob(image,currentOffset,SEEK_SET);\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  quantize_info=DestroyQuantizeInfo(quantize_info);\n  (void) CloseBlob(image);\n  (void) DestroyExceptionInfo(exception);\n  return(MagickTrue);\n}",
        "func": "static MagickBooleanType WritePALMImage(const ImageInfo *image_info,\n  Image *image)\n{\n  ExceptionInfo\n    *exception;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    currentOffset,\n    offset,\n    scene;\n\n  MagickSizeType\n    cc;\n\n  PixelPacket\n    transpix;\n\n  QuantizeInfo\n    *quantize_info;\n\n  register IndexPacket\n    *indexes;\n\n  register ssize_t\n    x;\n\n  register PixelPacket\n    *p;\n\n  ssize_t\n    y;\n\n  size_t\n    count,\n    bits_per_pixel,\n    bytes_per_row,\n    nextDepthOffset,\n    one;\n\n  unsigned char\n    bit,\n    byte,\n    color,\n    *lastrow,\n    *one_row,\n    *ptr,\n    version;\n\n  unsigned int\n    transparentIndex;\n\n  unsigned short\n    color16,\n    flags;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  exception=AcquireExceptionInfo();\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  quantize_info=AcquireQuantizeInfo(image_info);\n  flags=0;\n  currentOffset=0;\n  transparentIndex=0;\n  transpix.red=0;\n  transpix.green=0;\n  transpix.blue=0;\n  transpix.opacity=0;\n  one=1;\n  version=0;\n  scene=0;\n  do\n  {\n    (void) TransformImageColorspace(image,sRGBColorspace);\n    count=GetNumberColors(image,NULL,exception);\n    for (bits_per_pixel=1;  (one << bits_per_pixel) < count; bits_per_pixel*=2) ;\n    if (bits_per_pixel > 16)\n      bits_per_pixel=16;\n    else\n      if (bits_per_pixel < 16)\n        (void) TransformImageColorspace(image,image->colorspace);\n    if (bits_per_pixel < 8)\n      {\n        (void) TransformImageColorspace(image,GRAYColorspace);\n        (void) SetImageType(image,PaletteType);\n        (void) SortColormapByIntensity(image);\n      }\n    if ((image->storage_class == PseudoClass) && (image->colors > 256))\n      (void) SetImageStorageClass(image,DirectClass);\n    if (image->storage_class == PseudoClass)\n      flags|=PALM_HAS_COLORMAP_FLAG;\n    else\n      flags|=PALM_IS_DIRECT_COLOR;\n    (void) WriteBlobMSBShort(image,(unsigned short) image->columns); /* width */\n    (void) WriteBlobMSBShort(image,(unsigned short) image->rows);  /* height */\n    bytes_per_row=((image->columns+(16/bits_per_pixel-1))/(16/\n      bits_per_pixel))*2;\n    (void) WriteBlobMSBShort(image,(unsigned short) bytes_per_row);\n    if ((image_info->compression == RLECompression) ||\n        (image_info->compression == FaxCompression))\n      flags|=PALM_IS_COMPRESSED_FLAG;\n    (void) WriteBlobMSBShort(image, flags);\n    (void) WriteBlobByte(image,(unsigned char) bits_per_pixel);\n    if (bits_per_pixel > 1)\n      version=1;\n    if ((image_info->compression == RLECompression) ||\n        (image_info->compression == FaxCompression))\n      version=2;\n    (void) WriteBlobByte(image,version);\n    (void) WriteBlobMSBShort(image,0);  /* nextDepthOffset */\n    (void) WriteBlobByte(image,(unsigned char) transparentIndex);\n    if (image_info->compression == RLECompression)\n      (void) WriteBlobByte(image,PALM_COMPRESSION_RLE);\n    else\n      if (image_info->compression == FaxCompression)\n        (void) WriteBlobByte(image,PALM_COMPRESSION_SCANLINE);\n      else\n        (void) WriteBlobByte(image,PALM_COMPRESSION_NONE);\n    (void) WriteBlobMSBShort(image,0);  /* reserved */\n    offset=16;\n    if (bits_per_pixel == 16)\n      {\n        (void) WriteBlobByte(image,5);  /* # of bits of red */\n        (void) WriteBlobByte(image,6);  /* # of bits of green */\n        (void) WriteBlobByte(image,5);  /* # of bits of blue */\n        (void) WriteBlobByte(image,0);  /* reserved by Palm */\n        (void) WriteBlobMSBLong(image,0);  /* no transparent color, YET */\n        offset+=8;\n      }\n    if (bits_per_pixel == 8)\n      {\n        if (flags & PALM_HAS_COLORMAP_FLAG)  /* Write out colormap */\n          {\n            quantize_info->dither=IsPaletteImage(image,&image->exception);\n            quantize_info->number_colors=image->colors;\n            (void) QuantizeImage(quantize_info,image);\n            (void) WriteBlobMSBShort(image,(unsigned short) image->colors);\n            for (count = 0; count < image->colors; count++)\n            {\n              (void) WriteBlobByte(image,(unsigned char) count);\n              (void) WriteBlobByte(image,ScaleQuantumToChar(\n                image->colormap[count].red));\n              (void) WriteBlobByte(image,\n                ScaleQuantumToChar(image->colormap[count].green));\n              (void) WriteBlobByte(image,\n                ScaleQuantumToChar(image->colormap[count].blue));\n            }\n            offset+=2+count*4;\n          }\n      else  /* Map colors to Palm standard colormap */\n        {\n          Image\n            *affinity_image;\n\n          affinity_image=ConstituteImage(256,1,\"RGB\",CharPixel,&PalmPalette,\n            exception);\n          (void) TransformImageColorspace(affinity_image,\n            affinity_image->colorspace);\n          (void) RemapImage(quantize_info,image,affinity_image);\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n            indexes=GetAuthenticIndexQueue(image);\n            for (x=0; x < (ssize_t) image->columns; x++)\n              SetPixelIndex(indexes+x,FindColor(&image->colormap[\n                (ssize_t) GetPixelIndex(indexes+x)]));\n          }\n          affinity_image=DestroyImage(affinity_image);\n        }\n      }\n    if (flags & PALM_IS_COMPRESSED_FLAG)\n      (void) WriteBlobMSBShort(image,0);  /* fill in size later */\n    lastrow=(unsigned char *) NULL;\n    if (image_info->compression == FaxCompression)\n      lastrow=(unsigned char *) AcquireQuantumMemory(bytes_per_row,\n        sizeof(*lastrow));\n      /* TODO check whether memory really was acquired? */\n    one_row=(unsigned char *) AcquireQuantumMemory(bytes_per_row,\n      sizeof(*one_row));\n    if (one_row == (unsigned char *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      ptr=one_row;\n      (void) ResetMagickMemory(ptr,0,bytes_per_row);\n      p=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n      if (p == (PixelPacket *) NULL)\n        break;\n      indexes=GetAuthenticIndexQueue(image);\n      if (bits_per_pixel == 16)\n        {\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            color16=(unsigned short) ((((31*(size_t) GetPixelRed(p))/\n              (size_t) QuantumRange) << 11) |\n              (((63*(size_t) GetPixelGreen(p))/(size_t) QuantumRange) << 5) |\n              ((31*(size_t) GetPixelBlue(p))/(size_t) QuantumRange));\n            if (GetPixelOpacity(p) == (Quantum) TransparentOpacity)\n              {\n                transpix.red=GetPixelRed(p);\n                transpix.green=GetPixelGreen(p);\n                transpix.blue=GetPixelBlue(p);\n                transpix.opacity=GetPixelOpacity(p);\n                flags|=PALM_HAS_TRANSPARENCY_FLAG;\n              }\n            *ptr++=(unsigned char) ((color16 >> 8) & 0xff);\n            *ptr++=(unsigned char) (color16 & 0xff);\n            p++;\n          }\n        }\n      else\n        {\n          byte=0x00;\n          bit=(unsigned char) (8-bits_per_pixel);\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            if (bits_per_pixel >= 8)\n              color=(unsigned char) GetPixelIndex(indexes+x);\n            else\n              color=(unsigned char) (GetPixelIndex(indexes+x)*\n                ((one << bits_per_pixel)-1)/MagickMax(1*image->colors-1,1));\n            byte|=color << bit;\n            if (bit != 0)\n              bit-=(unsigned char) bits_per_pixel;\n            else\n              {\n                *ptr++=byte;\n                byte=0x00;\n                bit=(unsigned char) (8-bits_per_pixel);\n              }\n          }\n          if ((image->columns % (8/bits_per_pixel)) != 0)\n            *ptr++=byte;\n        }\n      if (image_info->compression == RLECompression)\n        {\n          x=0;\n          while (x < (ssize_t) bytes_per_row)\n          {\n            byte=one_row[x];\n            count=1;\n            while ((one_row[++x] == byte) && (count < 255) &&\n                   (x < (ssize_t) bytes_per_row))\n              count++;\n            (void) WriteBlobByte(image,(unsigned char) count);\n            (void) WriteBlobByte(image,(unsigned char) byte);\n          }\n        }\n      else\n        if (image_info->compression == FaxCompression)\n          {\n            char\n              tmpbuf[8],\n              *tptr;\n\n            for (x = 0;  x < (ssize_t) bytes_per_row;  x += 8)\n            {\n              tptr = tmpbuf;\n              for (bit=0, byte=0; bit < (unsigned char) MagickMin(8,(ssize_t) bytes_per_row-x); bit++)\n              {\n                if ((y == 0) || (lastrow[x + bit] != one_row[x + bit]))\n                  {\n                    byte |= (1 << (7 - bit));\n                    *tptr++ = (char) one_row[x + bit];\n                  }\n              }\n              (void) WriteBlobByte(image, byte);\n              (void) WriteBlob(image,tptr-tmpbuf,(unsigned char *) tmpbuf);\n            }\n            (void) CopyMagickMemory(lastrow,one_row,bytes_per_row);\n          }\n        else\n          (void) WriteBlob(image,bytes_per_row,one_row);\n      }\n    if (flags & PALM_HAS_TRANSPARENCY_FLAG)\n      {\n        offset=SeekBlob(image,currentOffset+6,SEEK_SET);\n        (void) WriteBlobMSBShort(image,flags);\n        offset=SeekBlob(image,currentOffset+12,SEEK_SET);\n        (void) WriteBlobByte(image,(unsigned char) transparentIndex);  /* trans index */\n      }\n    if (bits_per_pixel == 16)\n      {\n        offset=SeekBlob(image,currentOffset+20,SEEK_SET);\n        (void) WriteBlobByte(image,0);  /* reserved by Palm */\n        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.red)/QuantumRange));\n        (void) WriteBlobByte(image,(unsigned char) ((63*transpix.green)/QuantumRange));\n        (void) WriteBlobByte(image,(unsigned char) ((31*transpix.blue)/QuantumRange));\n      }\n    if (flags & PALM_IS_COMPRESSED_FLAG)  /* fill in size now */\n      {\n        offset=SeekBlob(image,currentOffset+offset,SEEK_SET);\n        (void) WriteBlobMSBShort(image,(unsigned short) (GetBlobSize(image)-\n          currentOffset-offset));\n      }\n    if (one_row != (unsigned char *) NULL)\n      one_row=(unsigned char *) RelinquishMagickMemory(one_row);\n    if (lastrow != (unsigned char *) NULL)\n      lastrow=(unsigned char *) RelinquishMagickMemory(lastrow);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    /* padding to 4 byte word */\n    for (cc=(GetBlobSize(image)) % 4; cc > 0; cc--)\n      (void) WriteBlobByte(image,0);\n    /* write nextDepthOffset and return to end of image */\n    (void) SeekBlob(image,currentOffset+10,SEEK_SET);\n    nextDepthOffset=(size_t) ((GetBlobSize(image)-currentOffset)/4);\n    (void) WriteBlobMSBShort(image,(unsigned short) nextDepthOffset);\n    currentOffset=(MagickOffsetType) GetBlobSize(image);\n    (void) SeekBlob(image,currentOffset,SEEK_SET);\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  quantize_info=DestroyQuantizeInfo(quantize_info);\n  (void) CloseBlob(image);\n  (void) DestroyExceptionInfo(exception);\n  return(MagickTrue);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -85,10 +85,11 @@\n     (void) TransformImageColorspace(image,sRGBColorspace);\n     count=GetNumberColors(image,NULL,exception);\n     for (bits_per_pixel=1;  (one << bits_per_pixel) < count; bits_per_pixel*=2) ;\n-    if (image_info->depth > 100)\n-      bits_per_pixel=image_info->depth-100;\n-    if (bits_per_pixel < 16)\n-      (void) TransformImageColorspace(image,image->colorspace);\n+    if (bits_per_pixel > 16)\n+      bits_per_pixel=16;\n+    else\n+      if (bits_per_pixel < 16)\n+        (void) TransformImageColorspace(image,image->colorspace);\n     if (bits_per_pixel < 8)\n       {\n         (void) TransformImageColorspace(image,GRAYColorspace);",
        "diff_line_info": {
            "deleted_lines": [
                "    if (image_info->depth > 100)",
                "      bits_per_pixel=image_info->depth-100;",
                "    if (bits_per_pixel < 16)",
                "      (void) TransformImageColorspace(image,image->colorspace);"
            ],
            "added_lines": [
                "    if (bits_per_pixel > 16)",
                "      bits_per_pixel=16;",
                "    else",
                "      if (bits_per_pixel < 16)",
                "        (void) TransformImageColorspace(image,image->colorspace);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41222",
        "func_name": "tensorflow/ComputeEasyCases",
        "description": "TensorFlow is an open source platform for machine learning. In affected versions the implementation of `SplitV` can trigger a segfault is an attacker supplies negative arguments. This occurs whenever `size_splits` contains more than one value and at least one value is negative. The fix will be included in TensorFlow 2.7.0. We will also cherrypick this commit on TensorFlow 2.6.1, TensorFlow 2.5.2, and TensorFlow 2.4.4, as these are also affected and still in supported range.",
        "git_url": "https://github.com/tensorflow/tensorflow/commit/25d622ffc432acc736b14ca3904177579e733cc6",
        "commit_title": "A negative size in one of the split sizes allowed the computed size of another",
        "commit_text": "to exceed the total dimension, leading to a segfault and security vulnerability. Adding a check for negative sizes prevents this.  PiperOrigin-RevId: 401035665",
        "func_before": "void ComputeEasyCases(OpKernelContext* context, bool* done,\n                        std::vector<Tlen>* split_sizes_vec) {\n    const int32_t num_split = context->num_outputs();\n    const Tensor& input = context->input(0);\n    const TensorShape& input_shape = input.shape();\n    const Tensor& split_tensor = context->input(1);\n    const Tensor& split_dim_tensor = context->input(2);\n\n    OP_REQUIRES(context, split_dim_tensor.NumElements() == 1,\n                errors::InvalidArgument(\"split_dim_tensor must have \"\n                                        \"exactly one element.\"));\n\n    const int32_t split_dim_orig = split_dim_tensor.flat<int32>()(0);\n    const int32_t split_dim =\n        split_dim_orig < 0 ? split_dim_orig + input.dims() : split_dim_orig;\n\n    OP_REQUIRES(\n        context,\n        split_tensor.dims() == 1 && split_tensor.NumElements() == num_split,\n        errors::InvalidArgument(\"size of the split_tensor must be 1-D and have \"\n                                \"the same elements as outputs got \",\n                                split_tensor.dims(), \" -D and \",\n                                split_tensor.NumElements(), \" elements\"));\n\n    auto split_sizes_d = split_tensor.vec<Tlen>();\n\n    split_sizes_vec->resize(split_sizes_d.size());\n\n    std::copy(split_sizes_d.data(), split_sizes_d.data() + split_sizes_d.size(),\n              split_sizes_vec->begin());\n\n    OP_REQUIRES(\n        context, num_split > 0,\n        errors::InvalidArgument(\n            \"Number of ways to split should be > 0, but got \", num_split));\n\n    OP_REQUIRES(\n        context, 0 <= split_dim && split_dim < input.dims(),\n        errors::InvalidArgument(\"-input rank(-\", input.dims(),\n                                \") <= split_dim < input rank (\", input.dims(),\n                                \"), but got \", split_dim_orig));\n\n    Tlen input_size_split_dim = input_shape.dim_size(split_dim);\n\n    // Special case 1: num_split == 1. Nothing to do.\n    if (num_split == 1) {\n      context->set_output(0, context->input(0));\n      OP_REQUIRES(\n          context, (*split_sizes_vec)[0] == input_size_split_dim,\n          errors::InvalidArgument(\"If there is only one output, it must have \"\n                                  \"the same size as the input. Input size: \",\n                                  input_size_split_dim,\n                                  \" output size: \", (*split_sizes_vec)[0]));\n      *done = true;\n      return;\n    }\n\n    // Determine sizes of output, in case of a -1 input value\n    int neg_one_dim = -1;\n    Tlen determined_size = 0;\n    for (int d = 0; d < split_sizes_vec->size(); ++d) {\n      Tlen size = (*split_sizes_vec)[d];\n\n      if (size == -1) {\n        OP_REQUIRES(context, neg_one_dim == -1,\n                    errors::InvalidArgument(\"There can only be one -1 in the \"\n                                            \"input.\"));\n        neg_one_dim = d;\n      } else {\n        determined_size += size;\n      }\n    }\n\n    OP_REQUIRES(\n        context,\n        (neg_one_dim == -1 && determined_size == input_size_split_dim) ||\n            (neg_one_dim >= 0 && determined_size <= input_size_split_dim),\n        errors::InvalidArgument(\"Determined shape must either match \"\n                                \"input shape along split_dim exactly if \"\n                                \"fully specified, or be less than the size of \"\n                                \"the input along split_dim if not fully \"\n                                \"specified.  Got: \",\n                                determined_size));\n\n    if (neg_one_dim >= 0) {\n      (*split_sizes_vec)[neg_one_dim] = input_size_split_dim - determined_size;\n    }\n\n    // Special case 2: split along the 1st dimension. The requirements are that\n    // either we are splitting the outer dimension of two or more such that\n    // every outer subpart is aligned or that the split sizes mean that they are\n    // always aligned. In these cases, we can share the underlying buffer.\n    //\n    // Apply this optimization conservatively: if input is aligned,\n    // the resulting tensors must be aligned. It's conservative\n    // because if the immediate consumer of the resulting tensors are\n    // not using eigen for computation, its perfectly fine to avoid\n    // the copying.\n    if (SplitHasAlignedOutputsInFirstDimension(\n            input_shape, split_dim, absl::MakeConstSpan(*split_sizes_vec))) {\n      Tlen start = 0;\n      for (int i = 0; i < num_split; ++i) {\n        context->set_output(i,\n                            input.Slice(start, start + (*split_sizes_vec)[i]));\n        start += (*split_sizes_vec)[i];\n      }\n      *done = true;\n      return;\n    }\n  }",
        "func": "void ComputeEasyCases(OpKernelContext* context, bool* done,\n                        std::vector<Tlen>* split_sizes_vec) {\n    const int32_t num_split = context->num_outputs();\n    const Tensor& input = context->input(0);\n    const TensorShape& input_shape = input.shape();\n    const Tensor& split_tensor = context->input(1);\n    const Tensor& split_dim_tensor = context->input(2);\n\n    OP_REQUIRES(context, split_dim_tensor.NumElements() == 1,\n                errors::InvalidArgument(\"split_dim_tensor must have \"\n                                        \"exactly one element.\"));\n\n    const int32_t split_dim_orig = split_dim_tensor.flat<int32>()(0);\n    const int32_t split_dim =\n        split_dim_orig < 0 ? split_dim_orig + input.dims() : split_dim_orig;\n\n    OP_REQUIRES(\n        context,\n        split_tensor.dims() == 1 && split_tensor.NumElements() == num_split,\n        errors::InvalidArgument(\"size of the split_tensor must be 1-D and have \"\n                                \"the same elements as outputs got \",\n                                split_tensor.dims(), \" -D and \",\n                                split_tensor.NumElements(), \" elements\"));\n\n    auto split_sizes_d = split_tensor.vec<Tlen>();\n\n    split_sizes_vec->resize(split_sizes_d.size());\n\n    std::copy(split_sizes_d.data(), split_sizes_d.data() + split_sizes_d.size(),\n              split_sizes_vec->begin());\n\n    OP_REQUIRES(\n        context, num_split > 0,\n        errors::InvalidArgument(\n            \"Number of ways to split should be > 0, but got \", num_split));\n\n    OP_REQUIRES(\n        context, 0 <= split_dim && split_dim < input.dims(),\n        errors::InvalidArgument(\"-input rank(-\", input.dims(),\n                                \") <= split_dim < input rank (\", input.dims(),\n                                \"), but got \", split_dim_orig));\n\n    Tlen input_size_split_dim = input_shape.dim_size(split_dim);\n\n    // Special case 1: num_split == 1. Nothing to do.\n    if (num_split == 1) {\n      context->set_output(0, context->input(0));\n      OP_REQUIRES(\n          context, (*split_sizes_vec)[0] == input_size_split_dim,\n          errors::InvalidArgument(\"If there is only one output, it must have \"\n                                  \"the same size as the input. Input size: \",\n                                  input_size_split_dim,\n                                  \" output size: \", (*split_sizes_vec)[0]));\n      *done = true;\n      return;\n    }\n\n    // Determine sizes of output, in case of a -1 input value\n    int neg_one_dim = -1;\n    Tlen determined_size = 0;\n    for (int d = 0; d < split_sizes_vec->size(); ++d) {\n      Tlen size = (*split_sizes_vec)[d];\n\n      if (size == -1) {\n        OP_REQUIRES(context, neg_one_dim == -1,\n                    errors::InvalidArgument(\"There can only be one -1 in the \"\n                                            \"input.\"));\n        neg_one_dim = d;\n      } else {\n        determined_size += size;\n      }\n    }\n\n    OP_REQUIRES(\n        context,\n        (neg_one_dim == -1 && determined_size == input_size_split_dim) ||\n            (neg_one_dim >= 0 && determined_size <= input_size_split_dim),\n        errors::InvalidArgument(\"Determined shape must either match \"\n                                \"input shape along split_dim exactly if \"\n                                \"fully specified, or be less than the size of \"\n                                \"the input along split_dim if not fully \"\n                                \"specified.  Got: \",\n                                determined_size));\n\n    if (neg_one_dim >= 0) {\n      (*split_sizes_vec)[neg_one_dim] = input_size_split_dim - determined_size;\n    }\n\n    for (int i = 0; i < split_sizes_vec->size(); ++i) {\n      const Tlen& split_size = (*split_sizes_vec)[i];\n      OP_REQUIRES(context, split_size >= Tlen(0),\n                  errors::InvalidArgument(\"Split size at index \", i,\n                                          \" must be >= 0. Got: \", split_size));\n    }\n\n    // Special case 2: split along the 1st dimension. The requirements are that\n    // either we are splitting the outer dimension of two or more such that\n    // every outer subpart is aligned or that the split sizes mean that they are\n    // always aligned. In these cases, we can share the underlying buffer.\n    //\n    // Apply this optimization conservatively: if input is aligned,\n    // the resulting tensors must be aligned. It's conservative\n    // because if the immediate consumer of the resulting tensors are\n    // not using eigen for computation, its perfectly fine to avoid\n    // the copying.\n    if (SplitHasAlignedOutputsInFirstDimension(\n            input_shape, split_dim, absl::MakeConstSpan(*split_sizes_vec))) {\n      Tlen start = 0;\n      for (int i = 0; i < num_split; ++i) {\n        context->set_output(i,\n                            input.Slice(start, start + (*split_sizes_vec)[i]));\n        start += (*split_sizes_vec)[i];\n      }\n      *done = true;\n      return;\n    }\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -86,6 +86,13 @@\n       (*split_sizes_vec)[neg_one_dim] = input_size_split_dim - determined_size;\n     }\n \n+    for (int i = 0; i < split_sizes_vec->size(); ++i) {\n+      const Tlen& split_size = (*split_sizes_vec)[i];\n+      OP_REQUIRES(context, split_size >= Tlen(0),\n+                  errors::InvalidArgument(\"Split size at index \", i,\n+                                          \" must be >= 0. Got: \", split_size));\n+    }\n+\n     // Special case 2: split along the 1st dimension. The requirements are that\n     // either we are splitting the outer dimension of two or more such that\n     // every outer subpart is aligned or that the split sizes mean that they are",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    for (int i = 0; i < split_sizes_vec->size(); ++i) {",
                "      const Tlen& split_size = (*split_sizes_vec)[i];",
                "      OP_REQUIRES(context, split_size >= Tlen(0),",
                "                  errors::InvalidArgument(\"Split size at index \", i,",
                "                                          \" must be >= 0. Got: \", split_size));",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-45960",
        "func_name": "libexpat/storeAtts",
        "description": "In Expat (aka libexpat) before 2.4.3, a left shift by 29 (or more) places in the storeAtts function in xmlparse.c can lead to realloc misbehavior (e.g., allocating too few bytes, or only freeing memory).",
        "git_url": "https://github.com/libexpat/libexpat/commit/0adcb34c49bee5b19bd29b16a578c510c23597ea",
        "commit_title": "lib: Detect and prevent troublesome left shifts in function storeAtts (CVE-2021-45960)",
        "commit_text": "",
        "func_before": "static enum XML_Error\nstoreAtts(XML_Parser parser, const ENCODING *enc, const char *attStr,\n          TAG_NAME *tagNamePtr, BINDING **bindingsPtr,\n          enum XML_Account account) {\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  ELEMENT_TYPE *elementType;\n  int nDefaultAtts;\n  const XML_Char **appAtts; /* the attribute list for the application */\n  int attIndex = 0;\n  int prefixLen;\n  int i;\n  int n;\n  XML_Char *uri;\n  int nPrefixes = 0;\n  BINDING *binding;\n  const XML_Char *localPart;\n\n  /* lookup the element type name */\n  elementType\n      = (ELEMENT_TYPE *)lookup(parser, &dtd->elementTypes, tagNamePtr->str, 0);\n  if (! elementType) {\n    const XML_Char *name = poolCopyString(&dtd->pool, tagNamePtr->str);\n    if (! name)\n      return XML_ERROR_NO_MEMORY;\n    elementType = (ELEMENT_TYPE *)lookup(parser, &dtd->elementTypes, name,\n                                         sizeof(ELEMENT_TYPE));\n    if (! elementType)\n      return XML_ERROR_NO_MEMORY;\n    if (parser->m_ns && ! setElementTypePrefix(parser, elementType))\n      return XML_ERROR_NO_MEMORY;\n  }\n  nDefaultAtts = elementType->nDefaultAtts;\n\n  /* get the attributes from the tokenizer */\n  n = XmlGetAttributes(enc, attStr, parser->m_attsSize, parser->m_atts);\n  if (n + nDefaultAtts > parser->m_attsSize) {\n    int oldAttsSize = parser->m_attsSize;\n    ATTRIBUTE *temp;\n#ifdef XML_ATTR_INFO\n    XML_AttrInfo *temp2;\n#endif\n    parser->m_attsSize = n + nDefaultAtts + INIT_ATTS_SIZE;\n    temp = (ATTRIBUTE *)REALLOC(parser, (void *)parser->m_atts,\n                                parser->m_attsSize * sizeof(ATTRIBUTE));\n    if (temp == NULL) {\n      parser->m_attsSize = oldAttsSize;\n      return XML_ERROR_NO_MEMORY;\n    }\n    parser->m_atts = temp;\n#ifdef XML_ATTR_INFO\n    temp2 = (XML_AttrInfo *)REALLOC(parser, (void *)parser->m_attInfo,\n                                    parser->m_attsSize * sizeof(XML_AttrInfo));\n    if (temp2 == NULL) {\n      parser->m_attsSize = oldAttsSize;\n      return XML_ERROR_NO_MEMORY;\n    }\n    parser->m_attInfo = temp2;\n#endif\n    if (n > oldAttsSize)\n      XmlGetAttributes(enc, attStr, n, parser->m_atts);\n  }\n\n  appAtts = (const XML_Char **)parser->m_atts;\n  for (i = 0; i < n; i++) {\n    ATTRIBUTE *currAtt = &parser->m_atts[i];\n#ifdef XML_ATTR_INFO\n    XML_AttrInfo *currAttInfo = &parser->m_attInfo[i];\n#endif\n    /* add the name and value to the attribute list */\n    ATTRIBUTE_ID *attId\n        = getAttributeId(parser, enc, currAtt->name,\n                         currAtt->name + XmlNameLength(enc, currAtt->name));\n    if (! attId)\n      return XML_ERROR_NO_MEMORY;\n#ifdef XML_ATTR_INFO\n    currAttInfo->nameStart\n        = parser->m_parseEndByteIndex - (parser->m_parseEndPtr - currAtt->name);\n    currAttInfo->nameEnd\n        = currAttInfo->nameStart + XmlNameLength(enc, currAtt->name);\n    currAttInfo->valueStart = parser->m_parseEndByteIndex\n                              - (parser->m_parseEndPtr - currAtt->valuePtr);\n    currAttInfo->valueEnd = parser->m_parseEndByteIndex\n                            - (parser->m_parseEndPtr - currAtt->valueEnd);\n#endif\n    /* Detect duplicate attributes by their QNames. This does not work when\n       namespace processing is turned on and different prefixes for the same\n       namespace are used. For this case we have a check further down.\n    */\n    if ((attId->name)[-1]) {\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = parser->m_atts[i].name;\n      return XML_ERROR_DUPLICATE_ATTRIBUTE;\n    }\n    (attId->name)[-1] = 1;\n    appAtts[attIndex++] = attId->name;\n    if (! parser->m_atts[i].normalized) {\n      enum XML_Error result;\n      XML_Bool isCdata = XML_TRUE;\n\n      /* figure out whether declared as other than CDATA */\n      if (attId->maybeTokenized) {\n        int j;\n        for (j = 0; j < nDefaultAtts; j++) {\n          if (attId == elementType->defaultAtts[j].id) {\n            isCdata = elementType->defaultAtts[j].isCdata;\n            break;\n          }\n        }\n      }\n\n      /* normalize the attribute value */\n      result = storeAttributeValue(\n          parser, enc, isCdata, parser->m_atts[i].valuePtr,\n          parser->m_atts[i].valueEnd, &parser->m_tempPool, account);\n      if (result)\n        return result;\n      appAtts[attIndex] = poolStart(&parser->m_tempPool);\n      poolFinish(&parser->m_tempPool);\n    } else {\n      /* the value did not need normalizing */\n      appAtts[attIndex] = poolStoreString(&parser->m_tempPool, enc,\n                                          parser->m_atts[i].valuePtr,\n                                          parser->m_atts[i].valueEnd);\n      if (appAtts[attIndex] == 0)\n        return XML_ERROR_NO_MEMORY;\n      poolFinish(&parser->m_tempPool);\n    }\n    /* handle prefixed attribute names */\n    if (attId->prefix) {\n      if (attId->xmlns) {\n        /* deal with namespace declarations here */\n        enum XML_Error result = addBinding(parser, attId->prefix, attId,\n                                           appAtts[attIndex], bindingsPtr);\n        if (result)\n          return result;\n        --attIndex;\n      } else {\n        /* deal with other prefixed names later */\n        attIndex++;\n        nPrefixes++;\n        (attId->name)[-1] = 2;\n      }\n    } else\n      attIndex++;\n  }\n\n  /* set-up for XML_GetSpecifiedAttributeCount and XML_GetIdAttributeIndex */\n  parser->m_nSpecifiedAtts = attIndex;\n  if (elementType->idAtt && (elementType->idAtt->name)[-1]) {\n    for (i = 0; i < attIndex; i += 2)\n      if (appAtts[i] == elementType->idAtt->name) {\n        parser->m_idAttIndex = i;\n        break;\n      }\n  } else\n    parser->m_idAttIndex = -1;\n\n  /* do attribute defaulting */\n  for (i = 0; i < nDefaultAtts; i++) {\n    const DEFAULT_ATTRIBUTE *da = elementType->defaultAtts + i;\n    if (! (da->id->name)[-1] && da->value) {\n      if (da->id->prefix) {\n        if (da->id->xmlns) {\n          enum XML_Error result = addBinding(parser, da->id->prefix, da->id,\n                                             da->value, bindingsPtr);\n          if (result)\n            return result;\n        } else {\n          (da->id->name)[-1] = 2;\n          nPrefixes++;\n          appAtts[attIndex++] = da->id->name;\n          appAtts[attIndex++] = da->value;\n        }\n      } else {\n        (da->id->name)[-1] = 1;\n        appAtts[attIndex++] = da->id->name;\n        appAtts[attIndex++] = da->value;\n      }\n    }\n  }\n  appAtts[attIndex] = 0;\n\n  /* expand prefixed attribute names, check for duplicates,\n     and clear flags that say whether attributes were specified */\n  i = 0;\n  if (nPrefixes) {\n    int j; /* hash table index */\n    unsigned long version = parser->m_nsAttsVersion;\n    int nsAttsSize = (int)1 << parser->m_nsAttsPower;\n    unsigned char oldNsAttsPower = parser->m_nsAttsPower;\n    /* size of hash table must be at least 2 * (# of prefixed attributes) */\n    if ((nPrefixes << 1)\n        >> parser->m_nsAttsPower) { /* true for m_nsAttsPower = 0 */\n      NS_ATT *temp;\n      /* hash table size must also be a power of 2 and >= 8 */\n      while (nPrefixes >> parser->m_nsAttsPower++)\n        ;\n      if (parser->m_nsAttsPower < 3)\n        parser->m_nsAttsPower = 3;\n      nsAttsSize = (int)1 << parser->m_nsAttsPower;\n      temp = (NS_ATT *)REALLOC(parser, parser->m_nsAtts,\n                               nsAttsSize * sizeof(NS_ATT));\n      if (! temp) {\n        /* Restore actual size of memory in m_nsAtts */\n        parser->m_nsAttsPower = oldNsAttsPower;\n        return XML_ERROR_NO_MEMORY;\n      }\n      parser->m_nsAtts = temp;\n      version = 0; /* force re-initialization of m_nsAtts hash table */\n    }\n    /* using a version flag saves us from initializing m_nsAtts every time */\n    if (! version) { /* initialize version flags when version wraps around */\n      version = INIT_ATTS_VERSION;\n      for (j = nsAttsSize; j != 0;)\n        parser->m_nsAtts[--j].version = version;\n    }\n    parser->m_nsAttsVersion = --version;\n\n    /* expand prefixed names and check for duplicates */\n    for (; i < attIndex; i += 2) {\n      const XML_Char *s = appAtts[i];\n      if (s[-1] == 2) { /* prefixed */\n        ATTRIBUTE_ID *id;\n        const BINDING *b;\n        unsigned long uriHash;\n        struct siphash sip_state;\n        struct sipkey sip_key;\n\n        copy_salt_to_sipkey(parser, &sip_key);\n        sip24_init(&sip_state, &sip_key);\n\n        ((XML_Char *)s)[-1] = 0; /* clear flag */\n        id = (ATTRIBUTE_ID *)lookup(parser, &dtd->attributeIds, s, 0);\n        if (! id || ! id->prefix) {\n          /* This code is walking through the appAtts array, dealing\n           * with (in this case) a prefixed attribute name.  To be in\n           * the array, the attribute must have already been bound, so\n           * has to have passed through the hash table lookup once\n           * already.  That implies that an entry for it already\n           * exists, so the lookup above will return a pointer to\n           * already allocated memory.  There is no opportunaity for\n           * the allocator to fail, so the condition above cannot be\n           * fulfilled.\n           *\n           * Since it is difficult to be certain that the above\n           * analysis is complete, we retain the test and merely\n           * remove the code from coverage tests.\n           */\n          return XML_ERROR_NO_MEMORY; /* LCOV_EXCL_LINE */\n        }\n        b = id->prefix->binding;\n        if (! b)\n          return XML_ERROR_UNBOUND_PREFIX;\n\n        for (j = 0; j < b->uriLen; j++) {\n          const XML_Char c = b->uri[j];\n          if (! poolAppendChar(&parser->m_tempPool, c))\n            return XML_ERROR_NO_MEMORY;\n        }\n\n        sip24_update(&sip_state, b->uri, b->uriLen * sizeof(XML_Char));\n\n        while (*s++ != XML_T(ASCII_COLON))\n          ;\n\n        sip24_update(&sip_state, s, keylen(s) * sizeof(XML_Char));\n\n        do { /* copies null terminator */\n          if (! poolAppendChar(&parser->m_tempPool, *s))\n            return XML_ERROR_NO_MEMORY;\n        } while (*s++);\n\n        uriHash = (unsigned long)sip24_final(&sip_state);\n\n        { /* Check hash table for duplicate of expanded name (uriName).\n             Derived from code in lookup(parser, HASH_TABLE *table, ...).\n          */\n          unsigned char step = 0;\n          unsigned long mask = nsAttsSize - 1;\n          j = uriHash & mask; /* index into hash table */\n          while (parser->m_nsAtts[j].version == version) {\n            /* for speed we compare stored hash values first */\n            if (uriHash == parser->m_nsAtts[j].hash) {\n              const XML_Char *s1 = poolStart(&parser->m_tempPool);\n              const XML_Char *s2 = parser->m_nsAtts[j].uriName;\n              /* s1 is null terminated, but not s2 */\n              for (; *s1 == *s2 && *s1 != 0; s1++, s2++)\n                ;\n              if (*s1 == 0)\n                return XML_ERROR_DUPLICATE_ATTRIBUTE;\n            }\n            if (! step)\n              step = PROBE_STEP(uriHash, mask, parser->m_nsAttsPower);\n            j < step ? (j += nsAttsSize - step) : (j -= step);\n          }\n        }\n\n        if (parser->m_ns_triplets) { /* append namespace separator and prefix */\n          parser->m_tempPool.ptr[-1] = parser->m_namespaceSeparator;\n          s = b->prefix->name;\n          do {\n            if (! poolAppendChar(&parser->m_tempPool, *s))\n              return XML_ERROR_NO_MEMORY;\n          } while (*s++);\n        }\n\n        /* store expanded name in attribute list */\n        s = poolStart(&parser->m_tempPool);\n        poolFinish(&parser->m_tempPool);\n        appAtts[i] = s;\n\n        /* fill empty slot with new version, uriName and hash value */\n        parser->m_nsAtts[j].version = version;\n        parser->m_nsAtts[j].hash = uriHash;\n        parser->m_nsAtts[j].uriName = s;\n\n        if (! --nPrefixes) {\n          i += 2;\n          break;\n        }\n      } else                     /* not prefixed */\n        ((XML_Char *)s)[-1] = 0; /* clear flag */\n    }\n  }\n  /* clear flags for the remaining attributes */\n  for (; i < attIndex; i += 2)\n    ((XML_Char *)(appAtts[i]))[-1] = 0;\n  for (binding = *bindingsPtr; binding; binding = binding->nextTagBinding)\n    binding->attId->name[-1] = 0;\n\n  if (! parser->m_ns)\n    return XML_ERROR_NONE;\n\n  /* expand the element type name */\n  if (elementType->prefix) {\n    binding = elementType->prefix->binding;\n    if (! binding)\n      return XML_ERROR_UNBOUND_PREFIX;\n    localPart = tagNamePtr->str;\n    while (*localPart++ != XML_T(ASCII_COLON))\n      ;\n  } else if (dtd->defaultPrefix.binding) {\n    binding = dtd->defaultPrefix.binding;\n    localPart = tagNamePtr->str;\n  } else\n    return XML_ERROR_NONE;\n  prefixLen = 0;\n  if (parser->m_ns_triplets && binding->prefix->name) {\n    for (; binding->prefix->name[prefixLen++];)\n      ; /* prefixLen includes null terminator */\n  }\n  tagNamePtr->localPart = localPart;\n  tagNamePtr->uriLen = binding->uriLen;\n  tagNamePtr->prefix = binding->prefix->name;\n  tagNamePtr->prefixLen = prefixLen;\n  for (i = 0; localPart[i++];)\n    ; /* i includes null terminator */\n  n = i + binding->uriLen + prefixLen;\n  if (n > binding->uriAlloc) {\n    TAG *p;\n    uri = (XML_Char *)MALLOC(parser, (n + EXPAND_SPARE) * sizeof(XML_Char));\n    if (! uri)\n      return XML_ERROR_NO_MEMORY;\n    binding->uriAlloc = n + EXPAND_SPARE;\n    memcpy(uri, binding->uri, binding->uriLen * sizeof(XML_Char));\n    for (p = parser->m_tagStack; p; p = p->parent)\n      if (p->name.str == binding->uri)\n        p->name.str = uri;\n    FREE(parser, binding->uri);\n    binding->uri = uri;\n  }\n  /* if m_namespaceSeparator != '\\0' then uri includes it already */\n  uri = binding->uri + binding->uriLen;\n  memcpy(uri, localPart, i * sizeof(XML_Char));\n  /* we always have a namespace separator between localPart and prefix */\n  if (prefixLen) {\n    uri += i - 1;\n    *uri = parser->m_namespaceSeparator; /* replace null terminator */\n    memcpy(uri + 1, binding->prefix->name, prefixLen * sizeof(XML_Char));\n  }\n  tagNamePtr->str = binding->uri;\n  return XML_ERROR_NONE;\n}",
        "func": "static enum XML_Error\nstoreAtts(XML_Parser parser, const ENCODING *enc, const char *attStr,\n          TAG_NAME *tagNamePtr, BINDING **bindingsPtr,\n          enum XML_Account account) {\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  ELEMENT_TYPE *elementType;\n  int nDefaultAtts;\n  const XML_Char **appAtts; /* the attribute list for the application */\n  int attIndex = 0;\n  int prefixLen;\n  int i;\n  int n;\n  XML_Char *uri;\n  int nPrefixes = 0;\n  BINDING *binding;\n  const XML_Char *localPart;\n\n  /* lookup the element type name */\n  elementType\n      = (ELEMENT_TYPE *)lookup(parser, &dtd->elementTypes, tagNamePtr->str, 0);\n  if (! elementType) {\n    const XML_Char *name = poolCopyString(&dtd->pool, tagNamePtr->str);\n    if (! name)\n      return XML_ERROR_NO_MEMORY;\n    elementType = (ELEMENT_TYPE *)lookup(parser, &dtd->elementTypes, name,\n                                         sizeof(ELEMENT_TYPE));\n    if (! elementType)\n      return XML_ERROR_NO_MEMORY;\n    if (parser->m_ns && ! setElementTypePrefix(parser, elementType))\n      return XML_ERROR_NO_MEMORY;\n  }\n  nDefaultAtts = elementType->nDefaultAtts;\n\n  /* get the attributes from the tokenizer */\n  n = XmlGetAttributes(enc, attStr, parser->m_attsSize, parser->m_atts);\n  if (n + nDefaultAtts > parser->m_attsSize) {\n    int oldAttsSize = parser->m_attsSize;\n    ATTRIBUTE *temp;\n#ifdef XML_ATTR_INFO\n    XML_AttrInfo *temp2;\n#endif\n    parser->m_attsSize = n + nDefaultAtts + INIT_ATTS_SIZE;\n    temp = (ATTRIBUTE *)REALLOC(parser, (void *)parser->m_atts,\n                                parser->m_attsSize * sizeof(ATTRIBUTE));\n    if (temp == NULL) {\n      parser->m_attsSize = oldAttsSize;\n      return XML_ERROR_NO_MEMORY;\n    }\n    parser->m_atts = temp;\n#ifdef XML_ATTR_INFO\n    temp2 = (XML_AttrInfo *)REALLOC(parser, (void *)parser->m_attInfo,\n                                    parser->m_attsSize * sizeof(XML_AttrInfo));\n    if (temp2 == NULL) {\n      parser->m_attsSize = oldAttsSize;\n      return XML_ERROR_NO_MEMORY;\n    }\n    parser->m_attInfo = temp2;\n#endif\n    if (n > oldAttsSize)\n      XmlGetAttributes(enc, attStr, n, parser->m_atts);\n  }\n\n  appAtts = (const XML_Char **)parser->m_atts;\n  for (i = 0; i < n; i++) {\n    ATTRIBUTE *currAtt = &parser->m_atts[i];\n#ifdef XML_ATTR_INFO\n    XML_AttrInfo *currAttInfo = &parser->m_attInfo[i];\n#endif\n    /* add the name and value to the attribute list */\n    ATTRIBUTE_ID *attId\n        = getAttributeId(parser, enc, currAtt->name,\n                         currAtt->name + XmlNameLength(enc, currAtt->name));\n    if (! attId)\n      return XML_ERROR_NO_MEMORY;\n#ifdef XML_ATTR_INFO\n    currAttInfo->nameStart\n        = parser->m_parseEndByteIndex - (parser->m_parseEndPtr - currAtt->name);\n    currAttInfo->nameEnd\n        = currAttInfo->nameStart + XmlNameLength(enc, currAtt->name);\n    currAttInfo->valueStart = parser->m_parseEndByteIndex\n                              - (parser->m_parseEndPtr - currAtt->valuePtr);\n    currAttInfo->valueEnd = parser->m_parseEndByteIndex\n                            - (parser->m_parseEndPtr - currAtt->valueEnd);\n#endif\n    /* Detect duplicate attributes by their QNames. This does not work when\n       namespace processing is turned on and different prefixes for the same\n       namespace are used. For this case we have a check further down.\n    */\n    if ((attId->name)[-1]) {\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = parser->m_atts[i].name;\n      return XML_ERROR_DUPLICATE_ATTRIBUTE;\n    }\n    (attId->name)[-1] = 1;\n    appAtts[attIndex++] = attId->name;\n    if (! parser->m_atts[i].normalized) {\n      enum XML_Error result;\n      XML_Bool isCdata = XML_TRUE;\n\n      /* figure out whether declared as other than CDATA */\n      if (attId->maybeTokenized) {\n        int j;\n        for (j = 0; j < nDefaultAtts; j++) {\n          if (attId == elementType->defaultAtts[j].id) {\n            isCdata = elementType->defaultAtts[j].isCdata;\n            break;\n          }\n        }\n      }\n\n      /* normalize the attribute value */\n      result = storeAttributeValue(\n          parser, enc, isCdata, parser->m_atts[i].valuePtr,\n          parser->m_atts[i].valueEnd, &parser->m_tempPool, account);\n      if (result)\n        return result;\n      appAtts[attIndex] = poolStart(&parser->m_tempPool);\n      poolFinish(&parser->m_tempPool);\n    } else {\n      /* the value did not need normalizing */\n      appAtts[attIndex] = poolStoreString(&parser->m_tempPool, enc,\n                                          parser->m_atts[i].valuePtr,\n                                          parser->m_atts[i].valueEnd);\n      if (appAtts[attIndex] == 0)\n        return XML_ERROR_NO_MEMORY;\n      poolFinish(&parser->m_tempPool);\n    }\n    /* handle prefixed attribute names */\n    if (attId->prefix) {\n      if (attId->xmlns) {\n        /* deal with namespace declarations here */\n        enum XML_Error result = addBinding(parser, attId->prefix, attId,\n                                           appAtts[attIndex], bindingsPtr);\n        if (result)\n          return result;\n        --attIndex;\n      } else {\n        /* deal with other prefixed names later */\n        attIndex++;\n        nPrefixes++;\n        (attId->name)[-1] = 2;\n      }\n    } else\n      attIndex++;\n  }\n\n  /* set-up for XML_GetSpecifiedAttributeCount and XML_GetIdAttributeIndex */\n  parser->m_nSpecifiedAtts = attIndex;\n  if (elementType->idAtt && (elementType->idAtt->name)[-1]) {\n    for (i = 0; i < attIndex; i += 2)\n      if (appAtts[i] == elementType->idAtt->name) {\n        parser->m_idAttIndex = i;\n        break;\n      }\n  } else\n    parser->m_idAttIndex = -1;\n\n  /* do attribute defaulting */\n  for (i = 0; i < nDefaultAtts; i++) {\n    const DEFAULT_ATTRIBUTE *da = elementType->defaultAtts + i;\n    if (! (da->id->name)[-1] && da->value) {\n      if (da->id->prefix) {\n        if (da->id->xmlns) {\n          enum XML_Error result = addBinding(parser, da->id->prefix, da->id,\n                                             da->value, bindingsPtr);\n          if (result)\n            return result;\n        } else {\n          (da->id->name)[-1] = 2;\n          nPrefixes++;\n          appAtts[attIndex++] = da->id->name;\n          appAtts[attIndex++] = da->value;\n        }\n      } else {\n        (da->id->name)[-1] = 1;\n        appAtts[attIndex++] = da->id->name;\n        appAtts[attIndex++] = da->value;\n      }\n    }\n  }\n  appAtts[attIndex] = 0;\n\n  /* expand prefixed attribute names, check for duplicates,\n     and clear flags that say whether attributes were specified */\n  i = 0;\n  if (nPrefixes) {\n    int j; /* hash table index */\n    unsigned long version = parser->m_nsAttsVersion;\n\n    /* Detect and prevent invalid shift */\n    if (parser->m_nsAttsPower >= sizeof(unsigned int) * 8 /* bits per byte */) {\n      return XML_ERROR_NO_MEMORY;\n    }\n\n    unsigned int nsAttsSize = 1u << parser->m_nsAttsPower;\n    unsigned char oldNsAttsPower = parser->m_nsAttsPower;\n    /* size of hash table must be at least 2 * (# of prefixed attributes) */\n    if ((nPrefixes << 1)\n        >> parser->m_nsAttsPower) { /* true for m_nsAttsPower = 0 */\n      NS_ATT *temp;\n      /* hash table size must also be a power of 2 and >= 8 */\n      while (nPrefixes >> parser->m_nsAttsPower++)\n        ;\n      if (parser->m_nsAttsPower < 3)\n        parser->m_nsAttsPower = 3;\n\n      /* Detect and prevent invalid shift */\n      if (parser->m_nsAttsPower >= sizeof(nsAttsSize) * 8 /* bits per byte */) {\n        /* Restore actual size of memory in m_nsAtts */\n        parser->m_nsAttsPower = oldNsAttsPower;\n        return XML_ERROR_NO_MEMORY;\n      }\n\n      nsAttsSize = 1u << parser->m_nsAttsPower;\n\n      /* Detect and prevent integer overflow.\n       * The preprocessor guard addresses the \"always false\" warning\n       * from -Wtype-limits on platforms where\n       * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n      if (nsAttsSize > (size_t)(-1) / sizeof(NS_ATT)) {\n        /* Restore actual size of memory in m_nsAtts */\n        parser->m_nsAttsPower = oldNsAttsPower;\n        return XML_ERROR_NO_MEMORY;\n      }\n#endif\n\n      temp = (NS_ATT *)REALLOC(parser, parser->m_nsAtts,\n                               nsAttsSize * sizeof(NS_ATT));\n      if (! temp) {\n        /* Restore actual size of memory in m_nsAtts */\n        parser->m_nsAttsPower = oldNsAttsPower;\n        return XML_ERROR_NO_MEMORY;\n      }\n      parser->m_nsAtts = temp;\n      version = 0; /* force re-initialization of m_nsAtts hash table */\n    }\n    /* using a version flag saves us from initializing m_nsAtts every time */\n    if (! version) { /* initialize version flags when version wraps around */\n      version = INIT_ATTS_VERSION;\n      for (j = nsAttsSize; j != 0;)\n        parser->m_nsAtts[--j].version = version;\n    }\n    parser->m_nsAttsVersion = --version;\n\n    /* expand prefixed names and check for duplicates */\n    for (; i < attIndex; i += 2) {\n      const XML_Char *s = appAtts[i];\n      if (s[-1] == 2) { /* prefixed */\n        ATTRIBUTE_ID *id;\n        const BINDING *b;\n        unsigned long uriHash;\n        struct siphash sip_state;\n        struct sipkey sip_key;\n\n        copy_salt_to_sipkey(parser, &sip_key);\n        sip24_init(&sip_state, &sip_key);\n\n        ((XML_Char *)s)[-1] = 0; /* clear flag */\n        id = (ATTRIBUTE_ID *)lookup(parser, &dtd->attributeIds, s, 0);\n        if (! id || ! id->prefix) {\n          /* This code is walking through the appAtts array, dealing\n           * with (in this case) a prefixed attribute name.  To be in\n           * the array, the attribute must have already been bound, so\n           * has to have passed through the hash table lookup once\n           * already.  That implies that an entry for it already\n           * exists, so the lookup above will return a pointer to\n           * already allocated memory.  There is no opportunaity for\n           * the allocator to fail, so the condition above cannot be\n           * fulfilled.\n           *\n           * Since it is difficult to be certain that the above\n           * analysis is complete, we retain the test and merely\n           * remove the code from coverage tests.\n           */\n          return XML_ERROR_NO_MEMORY; /* LCOV_EXCL_LINE */\n        }\n        b = id->prefix->binding;\n        if (! b)\n          return XML_ERROR_UNBOUND_PREFIX;\n\n        for (j = 0; j < b->uriLen; j++) {\n          const XML_Char c = b->uri[j];\n          if (! poolAppendChar(&parser->m_tempPool, c))\n            return XML_ERROR_NO_MEMORY;\n        }\n\n        sip24_update(&sip_state, b->uri, b->uriLen * sizeof(XML_Char));\n\n        while (*s++ != XML_T(ASCII_COLON))\n          ;\n\n        sip24_update(&sip_state, s, keylen(s) * sizeof(XML_Char));\n\n        do { /* copies null terminator */\n          if (! poolAppendChar(&parser->m_tempPool, *s))\n            return XML_ERROR_NO_MEMORY;\n        } while (*s++);\n\n        uriHash = (unsigned long)sip24_final(&sip_state);\n\n        { /* Check hash table for duplicate of expanded name (uriName).\n             Derived from code in lookup(parser, HASH_TABLE *table, ...).\n          */\n          unsigned char step = 0;\n          unsigned long mask = nsAttsSize - 1;\n          j = uriHash & mask; /* index into hash table */\n          while (parser->m_nsAtts[j].version == version) {\n            /* for speed we compare stored hash values first */\n            if (uriHash == parser->m_nsAtts[j].hash) {\n              const XML_Char *s1 = poolStart(&parser->m_tempPool);\n              const XML_Char *s2 = parser->m_nsAtts[j].uriName;\n              /* s1 is null terminated, but not s2 */\n              for (; *s1 == *s2 && *s1 != 0; s1++, s2++)\n                ;\n              if (*s1 == 0)\n                return XML_ERROR_DUPLICATE_ATTRIBUTE;\n            }\n            if (! step)\n              step = PROBE_STEP(uriHash, mask, parser->m_nsAttsPower);\n            j < step ? (j += nsAttsSize - step) : (j -= step);\n          }\n        }\n\n        if (parser->m_ns_triplets) { /* append namespace separator and prefix */\n          parser->m_tempPool.ptr[-1] = parser->m_namespaceSeparator;\n          s = b->prefix->name;\n          do {\n            if (! poolAppendChar(&parser->m_tempPool, *s))\n              return XML_ERROR_NO_MEMORY;\n          } while (*s++);\n        }\n\n        /* store expanded name in attribute list */\n        s = poolStart(&parser->m_tempPool);\n        poolFinish(&parser->m_tempPool);\n        appAtts[i] = s;\n\n        /* fill empty slot with new version, uriName and hash value */\n        parser->m_nsAtts[j].version = version;\n        parser->m_nsAtts[j].hash = uriHash;\n        parser->m_nsAtts[j].uriName = s;\n\n        if (! --nPrefixes) {\n          i += 2;\n          break;\n        }\n      } else                     /* not prefixed */\n        ((XML_Char *)s)[-1] = 0; /* clear flag */\n    }\n  }\n  /* clear flags for the remaining attributes */\n  for (; i < attIndex; i += 2)\n    ((XML_Char *)(appAtts[i]))[-1] = 0;\n  for (binding = *bindingsPtr; binding; binding = binding->nextTagBinding)\n    binding->attId->name[-1] = 0;\n\n  if (! parser->m_ns)\n    return XML_ERROR_NONE;\n\n  /* expand the element type name */\n  if (elementType->prefix) {\n    binding = elementType->prefix->binding;\n    if (! binding)\n      return XML_ERROR_UNBOUND_PREFIX;\n    localPart = tagNamePtr->str;\n    while (*localPart++ != XML_T(ASCII_COLON))\n      ;\n  } else if (dtd->defaultPrefix.binding) {\n    binding = dtd->defaultPrefix.binding;\n    localPart = tagNamePtr->str;\n  } else\n    return XML_ERROR_NONE;\n  prefixLen = 0;\n  if (parser->m_ns_triplets && binding->prefix->name) {\n    for (; binding->prefix->name[prefixLen++];)\n      ; /* prefixLen includes null terminator */\n  }\n  tagNamePtr->localPart = localPart;\n  tagNamePtr->uriLen = binding->uriLen;\n  tagNamePtr->prefix = binding->prefix->name;\n  tagNamePtr->prefixLen = prefixLen;\n  for (i = 0; localPart[i++];)\n    ; /* i includes null terminator */\n  n = i + binding->uriLen + prefixLen;\n  if (n > binding->uriAlloc) {\n    TAG *p;\n    uri = (XML_Char *)MALLOC(parser, (n + EXPAND_SPARE) * sizeof(XML_Char));\n    if (! uri)\n      return XML_ERROR_NO_MEMORY;\n    binding->uriAlloc = n + EXPAND_SPARE;\n    memcpy(uri, binding->uri, binding->uriLen * sizeof(XML_Char));\n    for (p = parser->m_tagStack; p; p = p->parent)\n      if (p->name.str == binding->uri)\n        p->name.str = uri;\n    FREE(parser, binding->uri);\n    binding->uri = uri;\n  }\n  /* if m_namespaceSeparator != '\\0' then uri includes it already */\n  uri = binding->uri + binding->uriLen;\n  memcpy(uri, localPart, i * sizeof(XML_Char));\n  /* we always have a namespace separator between localPart and prefix */\n  if (prefixLen) {\n    uri += i - 1;\n    *uri = parser->m_namespaceSeparator; /* replace null terminator */\n    memcpy(uri + 1, binding->prefix->name, prefixLen * sizeof(XML_Char));\n  }\n  tagNamePtr->str = binding->uri;\n  return XML_ERROR_NONE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -186,7 +186,13 @@\n   if (nPrefixes) {\n     int j; /* hash table index */\n     unsigned long version = parser->m_nsAttsVersion;\n-    int nsAttsSize = (int)1 << parser->m_nsAttsPower;\n+\n+    /* Detect and prevent invalid shift */\n+    if (parser->m_nsAttsPower >= sizeof(unsigned int) * 8 /* bits per byte */) {\n+      return XML_ERROR_NO_MEMORY;\n+    }\n+\n+    unsigned int nsAttsSize = 1u << parser->m_nsAttsPower;\n     unsigned char oldNsAttsPower = parser->m_nsAttsPower;\n     /* size of hash table must be at least 2 * (# of prefixed attributes) */\n     if ((nPrefixes << 1)\n@@ -197,7 +203,28 @@\n         ;\n       if (parser->m_nsAttsPower < 3)\n         parser->m_nsAttsPower = 3;\n-      nsAttsSize = (int)1 << parser->m_nsAttsPower;\n+\n+      /* Detect and prevent invalid shift */\n+      if (parser->m_nsAttsPower >= sizeof(nsAttsSize) * 8 /* bits per byte */) {\n+        /* Restore actual size of memory in m_nsAtts */\n+        parser->m_nsAttsPower = oldNsAttsPower;\n+        return XML_ERROR_NO_MEMORY;\n+      }\n+\n+      nsAttsSize = 1u << parser->m_nsAttsPower;\n+\n+      /* Detect and prevent integer overflow.\n+       * The preprocessor guard addresses the \"always false\" warning\n+       * from -Wtype-limits on platforms where\n+       * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n+#if UINT_MAX >= SIZE_MAX\n+      if (nsAttsSize > (size_t)(-1) / sizeof(NS_ATT)) {\n+        /* Restore actual size of memory in m_nsAtts */\n+        parser->m_nsAttsPower = oldNsAttsPower;\n+        return XML_ERROR_NO_MEMORY;\n+      }\n+#endif\n+\n       temp = (NS_ATT *)REALLOC(parser, parser->m_nsAtts,\n                                nsAttsSize * sizeof(NS_ATT));\n       if (! temp) {",
        "diff_line_info": {
            "deleted_lines": [
                "    int nsAttsSize = (int)1 << parser->m_nsAttsPower;",
                "      nsAttsSize = (int)1 << parser->m_nsAttsPower;"
            ],
            "added_lines": [
                "",
                "    /* Detect and prevent invalid shift */",
                "    if (parser->m_nsAttsPower >= sizeof(unsigned int) * 8 /* bits per byte */) {",
                "      return XML_ERROR_NO_MEMORY;",
                "    }",
                "",
                "    unsigned int nsAttsSize = 1u << parser->m_nsAttsPower;",
                "",
                "      /* Detect and prevent invalid shift */",
                "      if (parser->m_nsAttsPower >= sizeof(nsAttsSize) * 8 /* bits per byte */) {",
                "        /* Restore actual size of memory in m_nsAtts */",
                "        parser->m_nsAttsPower = oldNsAttsPower;",
                "        return XML_ERROR_NO_MEMORY;",
                "      }",
                "",
                "      nsAttsSize = 1u << parser->m_nsAttsPower;",
                "",
                "      /* Detect and prevent integer overflow.",
                "       * The preprocessor guard addresses the \"always false\" warning",
                "       * from -Wtype-limits on platforms where",
                "       * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */",
                "#if UINT_MAX >= SIZE_MAX",
                "      if (nsAttsSize > (size_t)(-1) / sizeof(NS_ATT)) {",
                "        /* Restore actual size of memory in m_nsAtts */",
                "        parser->m_nsAttsPower = oldNsAttsPower;",
                "        return XML_ERROR_NO_MEMORY;",
                "      }",
                "#endif",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-35846",
        "func_name": "virtualsquare/picotcp/ipfilter",
        "description": "VirtualSquare picoTCP (aka PicoTCP-NG) through 2.1 does not check the transport layer length in a frame before performing port filtering.",
        "git_url": "https://github.com/virtualsquare/picotcp/commit/d561990a358899178115e156871cc054a1c55ffe",
        "commit_title": "[ipfilter] Check transport layer length in frame before filtering ports",
        "commit_text": "",
        "func_before": "int ipfilter(struct pico_frame *f)\n{\n    struct filter_node temp;\n    struct pico_ipv4_hdr *ipv4_hdr = (struct pico_ipv4_hdr *) f->net_hdr;\n    struct pico_trans *trans;\n    struct pico_icmp4_hdr *icmp_hdr;\n\n    memset(&temp, 0u, sizeof(struct filter_node));\n\n    temp.fdev = f->dev;\n    temp.out_addr = ipv4_hdr->dst.addr;\n    temp.in_addr = ipv4_hdr->src.addr;\n    if ((ipv4_hdr->proto == PICO_PROTO_TCP) || (ipv4_hdr->proto == PICO_PROTO_UDP)) {\n        trans = (struct pico_trans *) f->transport_hdr;\n        temp.out_port = short_be(trans->dport);\n        temp.in_port = short_be(trans->sport);\n    }\n    else if(ipv4_hdr->proto == PICO_PROTO_ICMP4) {\n        icmp_hdr = (struct pico_icmp4_hdr *) f->transport_hdr;\n        if(icmp_hdr->type == PICO_ICMP_UNREACH && icmp_hdr->code == PICO_ICMP_UNREACH_FILTER_PROHIB)\n            return 0;\n    }\n\n    temp.proto = ipv4_hdr->proto;\n    temp.priority = f->priority;\n    temp.tos = ipv4_hdr->tos;\n    return ipfilter_apply_filter(f, &temp);\n}",
        "func": "int ipfilter(struct pico_frame *f)\n{\n    struct filter_node temp;\n    struct pico_ipv4_hdr *ipv4_hdr = (struct pico_ipv4_hdr *) f->net_hdr;\n    struct pico_trans *trans;\n    struct pico_icmp4_hdr *icmp_hdr;\n\n    memset(&temp, 0u, sizeof(struct filter_node));\n\n    temp.fdev = f->dev;\n    temp.out_addr = ipv4_hdr->dst.addr;\n    temp.in_addr = ipv4_hdr->src.addr;\n    if ((f->transport_hdr + sizeof(struct pico_trans)) <= (f->buffer + f->buffer_len)) {\n        if ((ipv4_hdr->proto == PICO_PROTO_TCP) || (ipv4_hdr->proto == PICO_PROTO_UDP)) {\n                trans = (struct pico_trans *) f->transport_hdr;\n                temp.out_port = short_be(trans->dport);\n                temp.in_port = short_be(trans->sport);\n        } else if(ipv4_hdr->proto == PICO_PROTO_ICMP4) {\n            icmp_hdr = (struct pico_icmp4_hdr *) f->transport_hdr;\n            if(icmp_hdr->type == PICO_ICMP_UNREACH && icmp_hdr->code == PICO_ICMP_UNREACH_FILTER_PROHIB)\n                return 0;\n        }\n        temp.proto = ipv4_hdr->proto;\n    }\n    temp.priority = f->priority;\n    temp.tos = ipv4_hdr->tos;\n    return ipfilter_apply_filter(f, &temp);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,18 +10,18 @@\n     temp.fdev = f->dev;\n     temp.out_addr = ipv4_hdr->dst.addr;\n     temp.in_addr = ipv4_hdr->src.addr;\n-    if ((ipv4_hdr->proto == PICO_PROTO_TCP) || (ipv4_hdr->proto == PICO_PROTO_UDP)) {\n-        trans = (struct pico_trans *) f->transport_hdr;\n-        temp.out_port = short_be(trans->dport);\n-        temp.in_port = short_be(trans->sport);\n+    if ((f->transport_hdr + sizeof(struct pico_trans)) <= (f->buffer + f->buffer_len)) {\n+        if ((ipv4_hdr->proto == PICO_PROTO_TCP) || (ipv4_hdr->proto == PICO_PROTO_UDP)) {\n+                trans = (struct pico_trans *) f->transport_hdr;\n+                temp.out_port = short_be(trans->dport);\n+                temp.in_port = short_be(trans->sport);\n+        } else if(ipv4_hdr->proto == PICO_PROTO_ICMP4) {\n+            icmp_hdr = (struct pico_icmp4_hdr *) f->transport_hdr;\n+            if(icmp_hdr->type == PICO_ICMP_UNREACH && icmp_hdr->code == PICO_ICMP_UNREACH_FILTER_PROHIB)\n+                return 0;\n+        }\n+        temp.proto = ipv4_hdr->proto;\n     }\n-    else if(ipv4_hdr->proto == PICO_PROTO_ICMP4) {\n-        icmp_hdr = (struct pico_icmp4_hdr *) f->transport_hdr;\n-        if(icmp_hdr->type == PICO_ICMP_UNREACH && icmp_hdr->code == PICO_ICMP_UNREACH_FILTER_PROHIB)\n-            return 0;\n-    }\n-\n-    temp.proto = ipv4_hdr->proto;\n     temp.priority = f->priority;\n     temp.tos = ipv4_hdr->tos;\n     return ipfilter_apply_filter(f, &temp);",
        "diff_line_info": {
            "deleted_lines": [
                "    if ((ipv4_hdr->proto == PICO_PROTO_TCP) || (ipv4_hdr->proto == PICO_PROTO_UDP)) {",
                "        trans = (struct pico_trans *) f->transport_hdr;",
                "        temp.out_port = short_be(trans->dport);",
                "        temp.in_port = short_be(trans->sport);",
                "    else if(ipv4_hdr->proto == PICO_PROTO_ICMP4) {",
                "        icmp_hdr = (struct pico_icmp4_hdr *) f->transport_hdr;",
                "        if(icmp_hdr->type == PICO_ICMP_UNREACH && icmp_hdr->code == PICO_ICMP_UNREACH_FILTER_PROHIB)",
                "            return 0;",
                "    }",
                "",
                "    temp.proto = ipv4_hdr->proto;"
            ],
            "added_lines": [
                "    if ((f->transport_hdr + sizeof(struct pico_trans)) <= (f->buffer + f->buffer_len)) {",
                "        if ((ipv4_hdr->proto == PICO_PROTO_TCP) || (ipv4_hdr->proto == PICO_PROTO_UDP)) {",
                "                trans = (struct pico_trans *) f->transport_hdr;",
                "                temp.out_port = short_be(trans->dport);",
                "                temp.in_port = short_be(trans->sport);",
                "        } else if(ipv4_hdr->proto == PICO_PROTO_ICMP4) {",
                "            icmp_hdr = (struct pico_icmp4_hdr *) f->transport_hdr;",
                "            if(icmp_hdr->type == PICO_ICMP_UNREACH && icmp_hdr->code == PICO_ICMP_UNREACH_FILTER_PROHIB)",
                "                return 0;",
                "        }",
                "        temp.proto = ipv4_hdr->proto;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-35847",
        "func_name": "virtualsquare/picotcp/pico_tcp_open",
        "description": "VirtualSquare picoTCP (aka PicoTCP-NG) through 2.1 does not have an MSS lower bound (e.g., it could be zero).",
        "git_url": "https://github.com/virtualsquare/picotcp/commit/eaf166009e44641e6570c576ba071217f100fd99",
        "commit_title": "TCP: Fixed MSS size calculation. Set MSS lower bound.",
        "commit_text": "",
        "func_before": "struct pico_socket *pico_tcp_open(struct pico_stack *S, uint16_t family)\n{\n    struct pico_socket_tcp *t = PICO_ZALLOC(sizeof(struct pico_socket_tcp));\n    if (!t)\n        return NULL;\n\n    t->sock.stack = S;\n    t->sock.timestamp = TCP_TIME;\n    pico_socket_set_family(&t->sock, family);\n    t->mss = (uint16_t)(pico_socket_get_mss(&t->sock) - PICO_SIZE_TCPHDR);\n    t->tcpq_in.pool.root = t->tcpq_hold.pool.root = t->tcpq_out.pool.root = &LEAF;\n    t->tcpq_hold.pool.compare = t->tcpq_out.pool.compare = segment_compare;\n    t->tcpq_in.pool.compare = input_segment_compare;\n    t->tcpq_in.max_size = PICO_DEFAULT_SOCKETQ;\n    t->tcpq_out.max_size = PICO_DEFAULT_SOCKETQ;\n    t->tcpq_hold.max_size = 2u * t->mss;\n    rto_set(t, PICO_TCP_RTO_MIN);\n\n    /* Uncomment next line and disable Nagle by default */\n    t->sock.opt_flags |= (1 << PICO_SOCKET_OPT_TCPNODELAY);\n\n    /* Uncomment next line and Nagle is enabled by default */\n    /* t->sock.opt_flags &= (uint16_t) ~(1 << PICO_SOCKET_OPT_TCPNODELAY); */\n\n    /* Set default linger for the socket */\n    t->linger_timeout = PICO_SOCKET_LINGER_TIMEOUT;\n\n\n#ifdef PICO_TCP_SUPPORT_SOCKET_STATS\n    if (!pico_timer_add(t->sock.stack, 2000, sock_stats, t)) {\n        tcp_dbg(\"TCP: Failed to start socket statistics timer\\n\");\n        PICO_FREE(t);\n        return NULL;\n    }\n#endif\n\n    t->keepalive_tmr = pico_timer_add(t->sock.stack, 1000, pico_tcp_keepalive, t);\n    if (!t->keepalive_tmr) {\n        tcp_dbg(\"TCP: Failed to start keepalive timer\\n\");\n        PICO_FREE(t);\n        return NULL;\n    }\n    tcp_set_space(t);\n    return &t->sock;\n}",
        "func": "struct pico_socket *pico_tcp_open(struct pico_stack *S, uint16_t family)\n{\n    struct pico_socket_tcp *t = PICO_ZALLOC(sizeof(struct pico_socket_tcp));\n    if (!t)\n        return NULL;\n\n    t->sock.stack = S;\n    t->sock.timestamp = TCP_TIME;\n    pico_socket_set_family(&t->sock, family);\n    t->mss = (uint16_t)(pico_socket_get_mss(&t->sock));\n    if (t->mss > PICO_SIZE_TCPHDR + PICO_TCP_MIN_MSS)\n        t->mss -= (uint16_t)PICO_SIZE_TCPHDR;\n    else\n        t->mss = PICO_TCP_MIN_MSS;\n    t->tcpq_in.pool.root = t->tcpq_hold.pool.root = t->tcpq_out.pool.root = &LEAF;\n    t->tcpq_hold.pool.compare = t->tcpq_out.pool.compare = segment_compare;\n    t->tcpq_in.pool.compare = input_segment_compare;\n    t->tcpq_in.max_size = PICO_DEFAULT_SOCKETQ;\n    t->tcpq_out.max_size = PICO_DEFAULT_SOCKETQ;\n    t->tcpq_hold.max_size = 2u * t->mss;\n    rto_set(t, PICO_TCP_RTO_MIN);\n\n    /* Uncomment next line and disable Nagle by default */\n    t->sock.opt_flags |= (1 << PICO_SOCKET_OPT_TCPNODELAY);\n\n    /* Uncomment next line and Nagle is enabled by default */\n    /* t->sock.opt_flags &= (uint16_t) ~(1 << PICO_SOCKET_OPT_TCPNODELAY); */\n\n    /* Set default linger for the socket */\n    t->linger_timeout = PICO_SOCKET_LINGER_TIMEOUT;\n\n\n#ifdef PICO_TCP_SUPPORT_SOCKET_STATS\n    if (!pico_timer_add(t->sock.stack, 2000, sock_stats, t)) {\n        tcp_dbg(\"TCP: Failed to start socket statistics timer\\n\");\n        PICO_FREE(t);\n        return NULL;\n    }\n#endif\n\n    t->keepalive_tmr = pico_timer_add(t->sock.stack, 1000, pico_tcp_keepalive, t);\n    if (!t->keepalive_tmr) {\n        tcp_dbg(\"TCP: Failed to start keepalive timer\\n\");\n        PICO_FREE(t);\n        return NULL;\n    }\n    tcp_set_space(t);\n    return &t->sock;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,11 @@\n     t->sock.stack = S;\n     t->sock.timestamp = TCP_TIME;\n     pico_socket_set_family(&t->sock, family);\n-    t->mss = (uint16_t)(pico_socket_get_mss(&t->sock) - PICO_SIZE_TCPHDR);\n+    t->mss = (uint16_t)(pico_socket_get_mss(&t->sock));\n+    if (t->mss > PICO_SIZE_TCPHDR + PICO_TCP_MIN_MSS)\n+        t->mss -= (uint16_t)PICO_SIZE_TCPHDR;\n+    else\n+        t->mss = PICO_TCP_MIN_MSS;\n     t->tcpq_in.pool.root = t->tcpq_hold.pool.root = t->tcpq_out.pool.root = &LEAF;\n     t->tcpq_hold.pool.compare = t->tcpq_out.pool.compare = segment_compare;\n     t->tcpq_in.pool.compare = input_segment_compare;",
        "diff_line_info": {
            "deleted_lines": [
                "    t->mss = (uint16_t)(pico_socket_get_mss(&t->sock) - PICO_SIZE_TCPHDR);"
            ],
            "added_lines": [
                "    t->mss = (uint16_t)(pico_socket_get_mss(&t->sock));",
                "    if (t->mss > PICO_SIZE_TCPHDR + PICO_TCP_MIN_MSS)",
                "        t->mss -= (uint16_t)PICO_SIZE_TCPHDR;",
                "    else",
                "        t->mss = PICO_TCP_MIN_MSS;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-35847",
        "func_name": "virtualsquare/picotcp/pico_tcp_initconn",
        "description": "VirtualSquare picoTCP (aka PicoTCP-NG) through 2.1 does not have an MSS lower bound (e.g., it could be zero).",
        "git_url": "https://github.com/virtualsquare/picotcp/commit/eaf166009e44641e6570c576ba071217f100fd99",
        "commit_title": "TCP: Fixed MSS size calculation. Set MSS lower bound.",
        "commit_text": "",
        "func_before": "int pico_tcp_initconn(struct pico_socket *s)\n{\n    struct pico_socket_tcp *ts = TCP_SOCK(s);\n    struct pico_frame *syn;\n    struct pico_tcp_hdr *hdr;\n    uint16_t mtu, opt_len = tcp_options_size(ts, PICO_TCP_SYN);\n\n    syn = s->net->alloc(s->stack, s->net, NULL, (uint16_t)(PICO_SIZE_TCPHDR + opt_len));\n    if (!syn)\n        return -1;\n\n    hdr = (struct pico_tcp_hdr *) syn->transport_hdr;\n\n    if (!ts->snd_nxt)\n        ts->snd_nxt = long_be(pico_paws());\n\n    ts->snd_last = ts->snd_nxt;\n    ts->cwnd = PICO_TCP_IW;\n    mtu = (uint16_t)pico_socket_get_mss(s);\n    ts->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);\n    ts->ssthresh = (uint16_t)((uint16_t)(PICO_DEFAULT_SOCKETQ / ts->mss) -  (((uint16_t)(PICO_DEFAULT_SOCKETQ / ts->mss)) >> 3u));\n    syn->sock = s;\n    hdr->seq = long_be(ts->snd_nxt);\n    hdr->len = (uint8_t)((PICO_SIZE_TCPHDR + opt_len) << 2);\n    hdr->flags = PICO_TCP_SYN;\n    tcp_set_space(ts);\n    hdr->rwnd = short_be(ts->wnd);\n    tcp_add_options(ts, syn, PICO_TCP_SYN, opt_len);\n    hdr->trans.sport = ts->sock.local_port;\n    hdr->trans.dport = ts->sock.remote_port;\n\n    hdr->crc = 0;\n    hdr->crc = short_be(pico_tcp_checksum(syn));\n\n    /* TCP: ENQUEUE to PROTO ( SYN ) */\n    tcp_dbg(\"Sending SYN... (ports: %d - %d) size: %d\\n\", short_be(ts->sock.local_port), short_be(ts->sock.remote_port), syn->buffer_len);\n    ts->retrans_tmr = pico_timer_add(s->stack, PICO_TCP_SYN_TO << ts->backoff, initconn_retry, ts);\n    if (!ts->retrans_tmr) {\n        tcp_dbg(\"TCP: Failed to start initconn_retry timer\\n\");\n        PICO_FREE(syn);\n        return -1;\n    }\n    pico_enqueue(&s->stack->q_tcp.out, syn);\n    return 0;\n}",
        "func": "int pico_tcp_initconn(struct pico_socket *s)\n{\n    struct pico_socket_tcp *ts = TCP_SOCK(s);\n    struct pico_frame *syn;\n    struct pico_tcp_hdr *hdr;\n    uint16_t mtu, opt_len = tcp_options_size(ts, PICO_TCP_SYN);\n\n    syn = s->net->alloc(s->stack, s->net, NULL, (uint16_t)(PICO_SIZE_TCPHDR + opt_len));\n    if (!syn)\n        return -1;\n\n    hdr = (struct pico_tcp_hdr *) syn->transport_hdr;\n\n    if (!ts->snd_nxt)\n        ts->snd_nxt = long_be(pico_paws());\n\n    ts->snd_last = ts->snd_nxt;\n    ts->cwnd = PICO_TCP_IW;\n    mtu = (uint16_t)pico_socket_get_mss(s);\n    if (mtu > PICO_SIZE_TCPHDR + PICO_TCP_MIN_MSS)\n        ts->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);\n    else\n        ts->mss = PICO_TCP_MIN_MSS;\n    ts->ssthresh = (uint16_t)((uint16_t)(PICO_DEFAULT_SOCKETQ / ts->mss) -  (((uint16_t)(PICO_DEFAULT_SOCKETQ / ts->mss)) >> 3u));\n    syn->sock = s;\n    hdr->seq = long_be(ts->snd_nxt);\n    hdr->len = (uint8_t)((PICO_SIZE_TCPHDR + opt_len) << 2);\n    hdr->flags = PICO_TCP_SYN;\n    tcp_set_space(ts);\n    hdr->rwnd = short_be(ts->wnd);\n    tcp_add_options(ts, syn, PICO_TCP_SYN, opt_len);\n    hdr->trans.sport = ts->sock.local_port;\n    hdr->trans.dport = ts->sock.remote_port;\n\n    hdr->crc = 0;\n    hdr->crc = short_be(pico_tcp_checksum(syn));\n\n    /* TCP: ENQUEUE to PROTO ( SYN ) */\n    tcp_dbg(\"Sending SYN... (ports: %d - %d) size: %d\\n\", short_be(ts->sock.local_port), short_be(ts->sock.remote_port), syn->buffer_len);\n    ts->retrans_tmr = pico_timer_add(s->stack, PICO_TCP_SYN_TO << ts->backoff, initconn_retry, ts);\n    if (!ts->retrans_tmr) {\n        tcp_dbg(\"TCP: Failed to start initconn_retry timer\\n\");\n        PICO_FREE(syn);\n        return -1;\n    }\n    pico_enqueue(&s->stack->q_tcp.out, syn);\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,10 @@\n     ts->snd_last = ts->snd_nxt;\n     ts->cwnd = PICO_TCP_IW;\n     mtu = (uint16_t)pico_socket_get_mss(s);\n-    ts->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);\n+    if (mtu > PICO_SIZE_TCPHDR + PICO_TCP_MIN_MSS)\n+        ts->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);\n+    else\n+        ts->mss = PICO_TCP_MIN_MSS;\n     ts->ssthresh = (uint16_t)((uint16_t)(PICO_DEFAULT_SOCKETQ / ts->mss) -  (((uint16_t)(PICO_DEFAULT_SOCKETQ / ts->mss)) >> 3u));\n     syn->sock = s;\n     hdr->seq = long_be(ts->snd_nxt);",
        "diff_line_info": {
            "deleted_lines": [
                "    ts->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);"
            ],
            "added_lines": [
                "    if (mtu > PICO_SIZE_TCPHDR + PICO_TCP_MIN_MSS)",
                "        ts->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);",
                "    else",
                "        ts->mss = PICO_TCP_MIN_MSS;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-35847",
        "func_name": "virtualsquare/picotcp/tcp_syn",
        "description": "VirtualSquare picoTCP (aka PicoTCP-NG) through 2.1 does not have an MSS lower bound (e.g., it could be zero).",
        "git_url": "https://github.com/virtualsquare/picotcp/commit/eaf166009e44641e6570c576ba071217f100fd99",
        "commit_title": "TCP: Fixed MSS size calculation. Set MSS lower bound.",
        "commit_text": "",
        "func_before": "static int tcp_syn(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *new = NULL;\n    struct pico_tcp_hdr *hdr = NULL;\n    uint16_t mtu;\n    if(s->number_of_pending_conn >= s->max_backlog)\n        return -1;\n\n    new = (struct pico_socket_tcp *)pico_socket_clone(s);\n    hdr = (struct pico_tcp_hdr *)f->transport_hdr;\n    if (!new)\n        return -1;\n\n#ifdef PICO_TCP_SUPPORT_SOCKET_STATS\n    if (!pico_timer_add(t->sock.stack, 2000, sock_stats, s)) {\n        tcp_dbg(\"TCP: Failed to start socket statistics timer\\n\");\n        return -1;\n    }\n#endif\n\n    new->sock.remote_port = ((struct pico_trans *)f->transport_hdr)->sport;\n#ifdef PICO_SUPPORT_IPV4\n    if (IS_IPV4(f)) {\n        new->sock.remote_addr.ip4.addr = ((struct pico_ipv4_hdr *)(f->net_hdr))->src.addr;\n        new->sock.local_addr.ip4.addr = ((struct pico_ipv4_hdr *)(f->net_hdr))->dst.addr;\n    }\n\n#endif\n#ifdef PICO_SUPPORT_IPV6\n    if (IS_IPV6(f)) {\n        new->sock.remote_addr.ip6 = ((struct pico_ipv6_hdr *)(f->net_hdr))->src;\n        new->sock.local_addr.ip6 = ((struct pico_ipv6_hdr *)(f->net_hdr))->dst;\n    }\n\n#endif\n    f->sock = &new->sock;\n    mtu = (uint16_t)pico_socket_get_mss(&new->sock);\n    new->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);\n    if (tcp_parse_options(f) < 0)\n        return -1;\n    new->sock.stack = s->stack;\n    new->tcpq_in.max_size = PICO_DEFAULT_SOCKETQ;\n    new->tcpq_out.max_size = PICO_DEFAULT_SOCKETQ;\n    new->tcpq_hold.max_size = 2u * mtu;\n    new->rcv_nxt = long_be(hdr->seq) + 1;\n    new->snd_nxt = long_be(pico_paws());\n    new->snd_last = new->snd_nxt;\n    new->cwnd = PICO_TCP_IW;\n    new->ssthresh = (uint16_t)((uint16_t)(PICO_DEFAULT_SOCKETQ / new->mss) -  (((uint16_t)(PICO_DEFAULT_SOCKETQ / new->mss)) >> 3u));\n    new->recv_wnd = short_be(hdr->rwnd);\n    new->linger_timeout = PICO_SOCKET_LINGER_TIMEOUT;\n    s->number_of_pending_conn++;\n    new->sock.parent = s;\n    new->sock.wakeup = s->wakeup;\n    rto_set(new, PICO_TCP_RTO_MIN);\n    /* Initialize timestamp values */\n    new->sock.state = PICO_SOCKET_STATE_BOUND | PICO_SOCKET_STATE_CONNECTED | PICO_SOCKET_STATE_TCP_SYN_RECV;\n    pico_socket_add(&new->sock);\n    tcp_send_synack(&new->sock);\n    tcp_dbg(\"SYNACK sent, socket added. snd_nxt is %08x\\n\", new->snd_nxt);\n    return 0;\n}",
        "func": "static int tcp_syn(struct pico_socket *s, struct pico_frame *f)\n{\n    struct pico_socket_tcp *new = NULL;\n    struct pico_tcp_hdr *hdr = NULL;\n    uint16_t mtu;\n    if(s->number_of_pending_conn >= s->max_backlog)\n        return -1;\n\n    new = (struct pico_socket_tcp *)pico_socket_clone(s);\n    hdr = (struct pico_tcp_hdr *)f->transport_hdr;\n    if (!new)\n        return -1;\n\n#ifdef PICO_TCP_SUPPORT_SOCKET_STATS\n    if (!pico_timer_add(t->sock.stack, 2000, sock_stats, s)) {\n        tcp_dbg(\"TCP: Failed to start socket statistics timer\\n\");\n        return -1;\n    }\n#endif\n\n    new->sock.remote_port = ((struct pico_trans *)f->transport_hdr)->sport;\n#ifdef PICO_SUPPORT_IPV4\n    if (IS_IPV4(f)) {\n        new->sock.remote_addr.ip4.addr = ((struct pico_ipv4_hdr *)(f->net_hdr))->src.addr;\n        new->sock.local_addr.ip4.addr = ((struct pico_ipv4_hdr *)(f->net_hdr))->dst.addr;\n    }\n\n#endif\n#ifdef PICO_SUPPORT_IPV6\n    if (IS_IPV6(f)) {\n        new->sock.remote_addr.ip6 = ((struct pico_ipv6_hdr *)(f->net_hdr))->src;\n        new->sock.local_addr.ip6 = ((struct pico_ipv6_hdr *)(f->net_hdr))->dst;\n    }\n\n#endif\n    f->sock = &new->sock;\n    mtu = (uint16_t)pico_socket_get_mss(&new->sock);\n    if (mtu > PICO_SIZE_TCPHDR + PICO_TCP_MIN_MSS)\n        new->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);\n    else\n        new->mss = PICO_TCP_MIN_MSS;\n    if (tcp_parse_options(f) < 0)\n        return -1;\n    new->sock.stack = s->stack;\n    new->tcpq_in.max_size = PICO_DEFAULT_SOCKETQ;\n    new->tcpq_out.max_size = PICO_DEFAULT_SOCKETQ;\n    new->tcpq_hold.max_size = 2u * mtu;\n    new->rcv_nxt = long_be(hdr->seq) + 1;\n    new->snd_nxt = long_be(pico_paws());\n    new->snd_last = new->snd_nxt;\n    new->cwnd = PICO_TCP_IW;\n    new->ssthresh = (uint16_t)((uint16_t)(PICO_DEFAULT_SOCKETQ / new->mss) -  (((uint16_t)(PICO_DEFAULT_SOCKETQ / new->mss)) >> 3u));\n    new->recv_wnd = short_be(hdr->rwnd);\n    new->linger_timeout = PICO_SOCKET_LINGER_TIMEOUT;\n    s->number_of_pending_conn++;\n    new->sock.parent = s;\n    new->sock.wakeup = s->wakeup;\n    rto_set(new, PICO_TCP_RTO_MIN);\n    /* Initialize timestamp values */\n    new->sock.state = PICO_SOCKET_STATE_BOUND | PICO_SOCKET_STATE_CONNECTED | PICO_SOCKET_STATE_TCP_SYN_RECV;\n    pico_socket_add(&new->sock);\n    tcp_send_synack(&new->sock);\n    tcp_dbg(\"SYNACK sent, socket added. snd_nxt is %08x\\n\", new->snd_nxt);\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -35,7 +35,10 @@\n #endif\n     f->sock = &new->sock;\n     mtu = (uint16_t)pico_socket_get_mss(&new->sock);\n-    new->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);\n+    if (mtu > PICO_SIZE_TCPHDR + PICO_TCP_MIN_MSS)\n+        new->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);\n+    else\n+        new->mss = PICO_TCP_MIN_MSS;\n     if (tcp_parse_options(f) < 0)\n         return -1;\n     new->sock.stack = s->stack;",
        "diff_line_info": {
            "deleted_lines": [
                "    new->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);"
            ],
            "added_lines": [
                "    if (mtu > PICO_SIZE_TCPHDR + PICO_TCP_MIN_MSS)",
                "        new->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);",
                "    else",
                "        new->mss = PICO_TCP_MIN_MSS;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-35848",
        "func_name": "virtualsquare/picotcp/pico_ipv4_process_in",
        "description": "VirtualSquare picoTCP (aka PicoTCP-NG) through 2.1 lacks certain size calculations before attempting to set a value of an mss structure member.",
        "git_url": "https://github.com/virtualsquare/picotcp/commit/4b9a16764f2b12b611de9c34a50b4713d10ca401",
        "commit_title": "More checks for correct header sizes",
        "commit_text": "",
        "func_before": "static int pico_ipv4_process_in(struct pico_stack *S, struct pico_protocol *self, struct pico_frame *f)\n{\n    uint8_t option_len = 0;\n    int ret = 0;\n    struct pico_ipv4_hdr *hdr = (struct pico_ipv4_hdr *) f->net_hdr;\n    uint16_t max_allowed = (uint16_t) ((int)f->buffer_len - (f->net_hdr - f->buffer) - (int)PICO_SIZE_IP4HDR);\n\n    if (!hdr)\n        return -1;\n\n    (void)self;\n\n    /* NAT needs transport header information */\n    if (((hdr->vhl) & 0x0F) > 5) {\n        option_len =  (uint8_t)(4 * (((hdr->vhl) & 0x0F) - 5));\n    }\n\n    f->transport_hdr = ((uint8_t *)f->net_hdr) + PICO_SIZE_IP4HDR + option_len;\n    f->transport_len = (uint16_t)(short_be(hdr->len) - PICO_SIZE_IP4HDR - option_len);\n    f->net_len = (uint16_t)(PICO_SIZE_IP4HDR + option_len);\n#if defined(PICO_SUPPORT_IPV4FRAG) || defined(PICO_SUPPORT_IPV6FRAG)\n    f->frag = short_be(hdr->frag);\n#endif\n\n    if (f->transport_len > max_allowed) {\n        pico_frame_discard(f);\n        return 0; /* Packet is discarded due to unfeasible length */\n    }\n\n#ifdef PICO_SUPPORT_IPFILTER\n    if (ipfilter(f)) {\n        /*pico_frame is discarded as result of the filtering*/\n        return 0;\n    }\n\n#endif\n    /* ret == 1 indicates to continue the function */\n    ret = pico_ipv4_crc_check(f);\n    if (ret < 1)\n        return ret;\n\n    /* Validate source IP address. Discard quietly if invalid */\n    if (!pico_ipv4_is_valid_src(S, hdr->src.addr, f->dev)) {\n        pico_frame_discard(f);\n        return 0;\n    }\n\n#if defined(PICO_SUPPORT_IPV4FRAG) || defined(PICO_SUPPORT_IPV6FRAG)\n    if (f->frag & PICO_IPV4_EVIL) {\n        (void)pico_icmp4_param_problem(S, f, 0);\n        pico_frame_discard(f); /* RFC 3514 */\n        return 0;\n    }\n#endif\n\n    if ((hdr->vhl & 0x0f) < 5) {\n        /* RFC 791: IHL minimum value is 5 */\n        (void)pico_icmp4_param_problem(S, f, 0);\n        pico_frame_discard(f);\n        return 0;\n    }\n\n#if defined(PICO_SUPPORT_IPV4FRAG) || defined(PICO_SUPPORT_IPV6FRAG)\n    if (f->frag & (PICO_IPV4_MOREFRAG | PICO_IPV4_FRAG_MASK))\n    {\n#ifdef PICO_SUPPORT_IPV4FRAG\n        pico_ipv4_process_frag(hdr, f, hdr->proto);\n        /* Frame can be discarded, frag will handle its own copy */\n#endif\n        /* We do not support fragmentation, discard quietly */\n        pico_frame_discard(f);\n        return 0;\n    }\n#endif\n\n#ifdef PICO_SUPPORT_RAWSOCKETS\n    pico_socket_ipv4_process_in(f);\n#endif\n\n    if (pico_ipv4_process_bcast_in(S, f) > 0)\n        return 0;\n\n    if (pico_ipv4_process_mcast_in(f) > 0)\n        return 0;\n\n    if (pico_ipv4_process_local_unicast_in(S, f) > 0)\n        return 0;\n\n    pico_ipv4_process_finally_try_forward(S, f);\n\n    return 0;\n}",
        "func": "static int pico_ipv4_process_in(struct pico_stack *S, struct pico_protocol *self, struct pico_frame *f)\n{\n    uint8_t option_len = 0;\n    int ret = 0;\n    struct pico_ipv4_hdr *hdr = (struct pico_ipv4_hdr *) f->net_hdr;\n    uint16_t max_allowed = (uint16_t) ((int)f->buffer_len - (f->net_hdr - f->buffer) - (int)PICO_SIZE_IP4HDR);\n\n    if (!hdr)\n        return -1;\n\n    (void)self;\n\n    /* NAT needs transport header information */\n    if (((hdr->vhl) & 0x0F) > 5) {\n        option_len =  (uint8_t)(4 * (((hdr->vhl) & 0x0F) - 5));\n    }\n\n    f->transport_hdr = ((uint8_t *)f->net_hdr) + PICO_SIZE_IP4HDR + option_len;\n    f->transport_len = (uint16_t)(short_be(hdr->len) - PICO_SIZE_IP4HDR - option_len);\n    f->net_len = (uint16_t)(PICO_SIZE_IP4HDR + option_len);\n\n    if ((f->net_hdr + f->net_len) > (f->buffer + f->buffer_len)) {\n        pico_frame_discard(f);\n        return 0;\n    }\n#if defined(PICO_SUPPORT_IPV4FRAG) || defined(PICO_SUPPORT_IPV6FRAG)\n    f->frag = short_be(hdr->frag);\n#endif\n\n    if (f->transport_len > max_allowed) {\n        pico_frame_discard(f);\n        return 0; /* Packet is discarded due to unfeasible length */\n    }\n\n#ifdef PICO_SUPPORT_IPFILTER\n    if (ipfilter(f)) {\n        /*pico_frame is discarded as result of the filtering*/\n        return 0;\n    }\n\n#endif\n    /* ret == 1 indicates to continue the function */\n    ret = pico_ipv4_crc_check(f);\n    if (ret < 1)\n        return ret;\n\n    /* Validate source IP address. Discard quietly if invalid */\n    if (!pico_ipv4_is_valid_src(S, hdr->src.addr, f->dev)) {\n        pico_frame_discard(f);\n        return 0;\n    }\n\n#if defined(PICO_SUPPORT_IPV4FRAG) || defined(PICO_SUPPORT_IPV6FRAG)\n    if (f->frag & PICO_IPV4_EVIL) {\n        (void)pico_icmp4_param_problem(S, f, 0);\n        pico_frame_discard(f); /* RFC 3514 */\n        return 0;\n    }\n#endif\n\n    if ((hdr->vhl & 0x0f) < 5) {\n        /* RFC 791: IHL minimum value is 5 */\n        (void)pico_icmp4_param_problem(S, f, 0);\n        pico_frame_discard(f);\n        return 0;\n    }\n\n#if defined(PICO_SUPPORT_IPV4FRAG) || defined(PICO_SUPPORT_IPV6FRAG)\n    if (f->frag & (PICO_IPV4_MOREFRAG | PICO_IPV4_FRAG_MASK))\n    {\n#ifdef PICO_SUPPORT_IPV4FRAG\n        pico_ipv4_process_frag(hdr, f, hdr->proto);\n        /* Frame can be discarded, frag will handle its own copy */\n#endif\n        /* We do not support fragmentation, discard quietly */\n        pico_frame_discard(f);\n        return 0;\n    }\n#endif\n\n#ifdef PICO_SUPPORT_RAWSOCKETS\n    pico_socket_ipv4_process_in(f);\n#endif\n\n    if (pico_ipv4_process_bcast_in(S, f) > 0)\n        return 0;\n\n    if (pico_ipv4_process_mcast_in(f) > 0)\n        return 0;\n\n    if (pico_ipv4_process_local_unicast_in(S, f) > 0)\n        return 0;\n\n    pico_ipv4_process_finally_try_forward(S, f);\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,6 +18,11 @@\n     f->transport_hdr = ((uint8_t *)f->net_hdr) + PICO_SIZE_IP4HDR + option_len;\n     f->transport_len = (uint16_t)(short_be(hdr->len) - PICO_SIZE_IP4HDR - option_len);\n     f->net_len = (uint16_t)(PICO_SIZE_IP4HDR + option_len);\n+\n+    if ((f->net_hdr + f->net_len) > (f->buffer + f->buffer_len)) {\n+        pico_frame_discard(f);\n+        return 0;\n+    }\n #if defined(PICO_SUPPORT_IPV4FRAG) || defined(PICO_SUPPORT_IPV6FRAG)\n     f->frag = short_be(hdr->frag);\n #endif",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    if ((f->net_hdr + f->net_len) > (f->buffer + f->buffer_len)) {",
                "        pico_frame_discard(f);",
                "        return 0;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-35848",
        "func_name": "virtualsquare/picotcp/tcp_parse_options",
        "description": "VirtualSquare picoTCP (aka PicoTCP-NG) through 2.1 lacks certain size calculations before attempting to set a value of an mss structure member.",
        "git_url": "https://github.com/virtualsquare/picotcp/commit/4b9a16764f2b12b611de9c34a50b4713d10ca401",
        "commit_title": "More checks for correct header sizes",
        "commit_text": "",
        "func_before": "static int tcp_parse_options(struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)f->sock;\n    uint8_t *opt = f->transport_hdr + PICO_SIZE_TCPHDR;\n    uint32_t i = 0;\n    f->timestamp = 0;\n    while (i < (f->transport_len - PICO_SIZE_TCPHDR)) {\n        uint8_t type =  opt[i++];\n        uint8_t len;\n        if(i < (f->transport_len - PICO_SIZE_TCPHDR) && (type > 1))\n            len =  opt[i++];\n        else\n            len = 1;\n\n        if (f->payload && ((opt + i) > f->payload))\n            break;\n\n        if (len == 0) {\n            return -1;\n        }\n\n        tcp_dbg_options(\"Received option '%d', len = %d \\n\", type, len);\n        switch (type) {\n        case PICO_TCP_OPTION_NOOP:\n        case PICO_TCP_OPTION_END:\n            break;\n        case PICO_TCP_OPTION_WS:\n            tcp_parse_option_ws(t, len, opt, &i);\n            break;\n        case PICO_TCP_OPTION_SACK_OK:\n            tcp_parse_option_sack_ok(t, f, len, &i);\n            break;\n        case PICO_TCP_OPTION_MSS:\n            tcp_parse_option_mss(t, len, opt, &i);\n            break;\n        case PICO_TCP_OPTION_TIMESTAMP:\n            tcp_parse_option_timestamp(t, f, len, opt, &i);\n            break;\n\n        case PICO_TCP_OPTION_SACK:\n            tcp_rcv_sack(t, opt + i, len - 2);\n            i = i + len - 2;\n            break;\n        default:\n            tcp_dbg_options(\"TCP: received unsupported option %u\\n\", type);\n            i = i + len - 2;\n        }\n    }\n    return 0;\n}",
        "func": "static int tcp_parse_options(struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)f->sock;\n    uint8_t *opt = f->transport_hdr + PICO_SIZE_TCPHDR;\n    uint32_t i = 0;\n    f->timestamp = 0;\n\n    if (f->buffer + f->buffer_len > f->transport_hdr + f->transport_len)\n        return -1;\n\n    while (i < (f->transport_len - PICO_SIZE_TCPHDR)) {\n        uint8_t type =  opt[i++];\n        uint8_t len;\n        if(i < (f->transport_len - PICO_SIZE_TCPHDR) && (type > 1))\n            len =  opt[i++];\n        else\n            len = 1;\n\n        if (f->payload && ((opt + i) > f->payload))\n            break;\n\n        if (len == 0) {\n            return -1;\n        }\n\n        tcp_dbg_options(\"Received option '%d', len = %d \\n\", type, len);\n        switch (type) {\n        case PICO_TCP_OPTION_NOOP:\n        case PICO_TCP_OPTION_END:\n            break;\n        case PICO_TCP_OPTION_WS:\n            tcp_parse_option_ws(t, len, opt, &i);\n            break;\n        case PICO_TCP_OPTION_SACK_OK:\n            tcp_parse_option_sack_ok(t, f, len, &i);\n            break;\n        case PICO_TCP_OPTION_MSS:\n            tcp_parse_option_mss(t, len, opt, &i);\n            break;\n        case PICO_TCP_OPTION_TIMESTAMP:\n            tcp_parse_option_timestamp(t, f, len, opt, &i);\n            break;\n\n        case PICO_TCP_OPTION_SACK:\n            tcp_rcv_sack(t, opt + i, len - 2);\n            i = i + len - 2;\n            break;\n        default:\n            tcp_dbg_options(\"TCP: received unsupported option %u\\n\", type);\n            i = i + len - 2;\n        }\n    }\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,10 @@\n     uint8_t *opt = f->transport_hdr + PICO_SIZE_TCPHDR;\n     uint32_t i = 0;\n     f->timestamp = 0;\n+\n+    if (f->buffer + f->buffer_len > f->transport_hdr + f->transport_len)\n+        return -1;\n+\n     while (i < (f->transport_len - PICO_SIZE_TCPHDR)) {\n         uint8_t type =  opt[i++];\n         uint8_t len;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    if (f->buffer + f->buffer_len > f->transport_hdr + f->transport_len)",
                "        return -1;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-35848",
        "func_name": "virtualsquare/picotcp/tcp_parse_option_mss",
        "description": "VirtualSquare picoTCP (aka PicoTCP-NG) through 2.1 lacks certain size calculations before attempting to set a value of an mss structure member.",
        "git_url": "https://github.com/virtualsquare/picotcp/commit/4b9a16764f2b12b611de9c34a50b4713d10ca401",
        "commit_title": "More checks for correct header sizes",
        "commit_text": "",
        "func_before": "static inline void tcp_parse_option_mss(struct pico_socket_tcp *t, uint8_t len, uint8_t *opt, uint32_t *idx)\n{\n    uint16_t mss;\n    if (tcpopt_len_check(idx, len, PICO_TCPOPTLEN_MSS) < 0)\n        return;\n\n    t->mss_ok = 1;\n    mss = short_from(opt + *idx);\n    *idx += (uint32_t)sizeof(uint16_t);\n    if (t->mss > short_be(mss))\n        t->mss = short_be(mss);\n}",
        "func": "static inline void tcp_parse_option_mss(struct pico_socket_tcp *t, uint8_t len, uint8_t *opt, uint32_t *idx)\n{\n    uint16_t mss;\n    if (tcpopt_len_check(idx, len, PICO_TCPOPTLEN_MSS) < 0)\n        return;\n\n    if ((*idx + PICO_TCPOPTLEN_MSS) > len)\n        return;\n\n    t->mss_ok = 1;\n    mss = short_from(opt + *idx);\n    *idx += (uint32_t)sizeof(uint16_t);\n    if (t->mss > short_be(mss))\n        t->mss = short_be(mss);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,9 @@\n {\n     uint16_t mss;\n     if (tcpopt_len_check(idx, len, PICO_TCPOPTLEN_MSS) < 0)\n+        return;\n+\n+    if ((*idx + PICO_TCPOPTLEN_MSS) > len)\n         return;\n \n     t->mss_ok = 1;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        return;",
                "",
                "    if ((*idx + PICO_TCPOPTLEN_MSS) > len)"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-28030",
        "func_name": "wireshark/dissect_fb_zero_tag",
        "description": "In Wireshark 3.2.0 to 3.2.7, the GQUIC dissector could crash. This was addressed in epan/dissectors/packet-gquic.c by correcting the implementation of offset advancement.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/3ff940652962c099b73ae3233322b8697b0d10ab",
        "commit_title": "FBZERO: Make sure our offset advances.",
        "commit_text": " Make sure our offset advances so that we don't infinitely loop. Fixes #16887. ",
        "func_before": "static guint32\ndissect_fb_zero_tag(tvbuff_t *tvb, packet_info *pinfo, proto_tree *fb_zero_tree, guint offset, guint32 tag_number){\n    guint32 tag_offset_start = offset + tag_number*4*2;\n    guint32 tag_offset = 0, total_tag_len = 0;\n    gint32 tag_len;\n\n    while(tag_number){\n        proto_tree *tag_tree, *ti_len, *ti_tag, *ti_type;\n        guint32 offset_end, tag;\n        const guint8* tag_str;\n\n        ti_tag = proto_tree_add_item(fb_zero_tree, hf_fb_zero_tags, tvb, offset, 8, ENC_NA);\n        tag_tree = proto_item_add_subtree(ti_tag, ett_fb_zero_tag_value);\n        ti_type = proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_type, tvb, offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n        tag = tvb_get_ntohl(tvb, offset);\n        proto_item_append_text(ti_type, \" (%s)\", val_to_str(tag, tag_vals, \"Unknown\"));\n        proto_item_append_text(ti_tag, \": %s (%s)\", tag_str, val_to_str(tag, tag_vals, \"Unknown\"));\n        offset += 4;\n\n        proto_tree_add_item(tag_tree, hf_fb_zero_tag_offset_end, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset_end = tvb_get_letohl(tvb, offset);\n\n        tag_len = offset_end - tag_offset;\n        total_tag_len += tag_len;\n        ti_len = proto_tree_add_uint(tag_tree, hf_fb_zero_tag_length, tvb, offset, 4, tag_len);\n        proto_item_append_text(ti_tag, \" (l=%u)\", tag_len);\n        proto_item_set_generated(ti_len);\n        offset += 4;\n\n        /* Fix issue with CRT.. (Fragmentation ?) */\n        if( tag_len > tvb_reported_length_remaining(tvb, tag_offset_start + tag_offset)){\n            tag_len = tvb_reported_length_remaining(tvb, tag_offset_start + tag_offset);\n            offset_end = tag_offset + tag_len;\n            expert_add_info(pinfo, ti_len, &ei_fb_zero_tag_length);\n        }\n\n        proto_tree_add_item(tag_tree, hf_fb_zero_tag_value, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n\n        switch(tag){\n            case TAG_SNI:\n                proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_sni, tvb, tag_offset_start + tag_offset, tag_len, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += tag_len;\n            break;\n            case TAG_VERS:\n                proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_vers, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += 4;\n            break;\n            case TAG_SNO:\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_sno, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_AEAD:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree *ti_aead;\n                    ti_aead = proto_tree_add_item(tag_tree, hf_fb_zero_tag_aead, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    proto_item_append_text(ti_aead, \" (%s)\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_aead_vals, \"Unknown\"));\n                    proto_item_append_text(ti_tag, \", %s\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_aead_vals, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_SCID:\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_scid, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_TIME:\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_time, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_letohl(tvb, tag_offset_start + tag_offset));\n                tag_offset += 4;\n            break;\n            case TAG_ALPN:\n                proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_alpn, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += 4;\n            break;\n            case TAG_PUBS:\n                /*TODO FIX: 24 Length + Pubs key?.. ! */\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_pubs, tvb, tag_offset_start + tag_offset, 2, ENC_LITTLE_ENDIAN);\n                tag_offset += 2;\n                while(offset_end - tag_offset >= 3){\n                    proto_tree_add_item(tag_tree, hf_fb_zero_tag_pubs, tvb, tag_offset_start + tag_offset, 3, ENC_LITTLE_ENDIAN);\n                    tag_offset += 3;\n                }\n            break;\n            case TAG_KEXS:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree *ti_kexs;\n                    ti_kexs = proto_tree_add_item(tag_tree, hf_fb_zero_tag_kexs, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    proto_item_append_text(ti_kexs, \" (%s)\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_kexs_vals, \"Unknown\"));\n                    proto_item_append_text(ti_tag, \", %s\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_kexs_vals, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_NONC:\n                /*TODO: Enhance display: 32 bytes consisting of 4 bytes of timestamp (big-endian, UNIX epoch seconds), 8 bytes of server orbit and 20 bytes of random data. */\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_nonc, tvb, tag_offset_start + tag_offset, 32, ENC_NA);\n                tag_offset += 32;\n            break;\n\n            default:\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_unknown, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                expert_add_info_format(pinfo, ti_tag, &ei_fb_zero_tag_undecoded,\n                                 \"Dissector for FB Zero Tag\"\n                                 \" %s (%s) code not implemented, Contact\"\n                                 \" Wireshark developers if you want this supported\", tvb_get_string_enc(wmem_packet_scope(), tvb, offset-8, 4, ENC_ASCII|ENC_NA), val_to_str(tag, tag_vals, \"Unknown\"));\n                tag_offset += tag_len;\n            break;\n        }\n\n        if(tag_offset != offset_end){\n            /* Wrong Tag len... */\n            proto_tree_add_expert(tag_tree, pinfo, &ei_fb_zero_tag_unknown, tvb, tag_offset_start + tag_offset, offset_end - tag_offset);\n            tag_offset = offset_end;\n        }\n\n        tag_number--;\n    }\n    return offset + total_tag_len;\n\n}",
        "func": "static guint32\ndissect_fb_zero_tag(tvbuff_t *tvb, packet_info *pinfo, proto_tree *fb_zero_tree, guint offset, guint32 tag_number){\n    guint32 tag_offset_start = offset + tag_number*4*2;\n    guint32 tag_offset = 0, total_tag_len = 0;\n    gint32 tag_len;\n\n    while(tag_number){\n        proto_tree *tag_tree, *ti_len, *ti_tag, *ti_type;\n        guint32 offset_end, tag;\n        const guint8* tag_str;\n\n        ti_tag = proto_tree_add_item(fb_zero_tree, hf_fb_zero_tags, tvb, offset, 8, ENC_NA);\n        tag_tree = proto_item_add_subtree(ti_tag, ett_fb_zero_tag_value);\n        ti_type = proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_type, tvb, offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n        tag = tvb_get_ntohl(tvb, offset);\n        proto_item_append_text(ti_type, \" (%s)\", val_to_str(tag, tag_vals, \"Unknown\"));\n        proto_item_append_text(ti_tag, \": %s (%s)\", tag_str, val_to_str(tag, tag_vals, \"Unknown\"));\n        offset += 4;\n\n        proto_tree_add_item(tag_tree, hf_fb_zero_tag_offset_end, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset_end = tvb_get_letohl(tvb, offset);\n\n        tag_len = offset_end - tag_offset;\n        total_tag_len += tag_len;\n        ti_len = proto_tree_add_uint(tag_tree, hf_fb_zero_tag_length, tvb, offset, 4, tag_len);\n        proto_item_append_text(ti_tag, \" (l=%u)\", tag_len);\n        proto_item_set_generated(ti_len);\n        offset += 4;\n\n        /* Fix issue with CRT.. (Fragmentation ?) */\n        if( tag_len > tvb_reported_length_remaining(tvb, tag_offset_start + tag_offset)){\n            tag_len = tvb_reported_length_remaining(tvb, tag_offset_start + tag_offset);\n            offset_end = tag_offset + tag_len;\n            expert_add_info(pinfo, ti_len, &ei_fb_zero_tag_length);\n        }\n\n        proto_tree_add_item(tag_tree, hf_fb_zero_tag_value, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n\n        switch(tag){\n            case TAG_SNI:\n                proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_sni, tvb, tag_offset_start + tag_offset, tag_len, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += tag_len;\n            break;\n            case TAG_VERS:\n                proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_vers, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += 4;\n            break;\n            case TAG_SNO:\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_sno, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_AEAD:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree *ti_aead;\n                    ti_aead = proto_tree_add_item(tag_tree, hf_fb_zero_tag_aead, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    proto_item_append_text(ti_aead, \" (%s)\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_aead_vals, \"Unknown\"));\n                    proto_item_append_text(ti_tag, \", %s\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_aead_vals, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_SCID:\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_scid, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_TIME:\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_time, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_letohl(tvb, tag_offset_start + tag_offset));\n                tag_offset += 4;\n            break;\n            case TAG_ALPN:\n                proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_alpn, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += 4;\n            break;\n            case TAG_PUBS:\n                /*TODO FIX: 24 Length + Pubs key?.. ! */\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_pubs, tvb, tag_offset_start + tag_offset, 2, ENC_LITTLE_ENDIAN);\n                tag_offset += 2;\n                while(offset_end - tag_offset >= 3){\n                    proto_tree_add_item(tag_tree, hf_fb_zero_tag_pubs, tvb, tag_offset_start + tag_offset, 3, ENC_LITTLE_ENDIAN);\n                    tag_offset += 3;\n                }\n            break;\n            case TAG_KEXS:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree *ti_kexs;\n                    ti_kexs = proto_tree_add_item(tag_tree, hf_fb_zero_tag_kexs, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    proto_item_append_text(ti_kexs, \" (%s)\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_kexs_vals, \"Unknown\"));\n                    proto_item_append_text(ti_tag, \", %s\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_kexs_vals, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_NONC:\n                /*TODO: Enhance display: 32 bytes consisting of 4 bytes of timestamp (big-endian, UNIX epoch seconds), 8 bytes of server orbit and 20 bytes of random data. */\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_nonc, tvb, tag_offset_start + tag_offset, 32, ENC_NA);\n                tag_offset += 32;\n            break;\n\n            default:\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_unknown, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                expert_add_info_format(pinfo, ti_tag, &ei_fb_zero_tag_undecoded,\n                                 \"Dissector for FB Zero Tag\"\n                                 \" %s (%s) code not implemented, Contact\"\n                                 \" Wireshark developers if you want this supported\", tvb_get_string_enc(wmem_packet_scope(), tvb, offset-8, 4, ENC_ASCII|ENC_NA), val_to_str(tag, tag_vals, \"Unknown\"));\n                goto end;\n            break;\n        }\n\n        if(tag_offset != offset_end){\n            /* Wrong Tag len... */\n            proto_tree_add_expert(tag_tree, pinfo, &ei_fb_zero_tag_unknown, tvb, tag_offset_start + tag_offset, offset_end - tag_offset);\n            // XXX Return instead?\n            goto end;\n        }\n\n        tag_number--;\n    }\n\n    end:\n    if (offset + total_tag_len <= offset) {\n        expert_add_info_format(pinfo, fb_zero_tree, &ei_fb_zero_length_invalid,\n                         \"Invalid total tag length: %u\", total_tag_len);\n        return offset + tvb_reported_length_remaining(tvb, offset);\n    }\n    return offset + total_tag_len;\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -104,18 +104,26 @@\n                                  \"Dissector for FB Zero Tag\"\n                                  \" %s (%s) code not implemented, Contact\"\n                                  \" Wireshark developers if you want this supported\", tvb_get_string_enc(wmem_packet_scope(), tvb, offset-8, 4, ENC_ASCII|ENC_NA), val_to_str(tag, tag_vals, \"Unknown\"));\n-                tag_offset += tag_len;\n+                goto end;\n             break;\n         }\n \n         if(tag_offset != offset_end){\n             /* Wrong Tag len... */\n             proto_tree_add_expert(tag_tree, pinfo, &ei_fb_zero_tag_unknown, tvb, tag_offset_start + tag_offset, offset_end - tag_offset);\n-            tag_offset = offset_end;\n+            // XXX Return instead?\n+            goto end;\n         }\n \n         tag_number--;\n     }\n+\n+    end:\n+    if (offset + total_tag_len <= offset) {\n+        expert_add_info_format(pinfo, fb_zero_tree, &ei_fb_zero_length_invalid,\n+                         \"Invalid total tag length: %u\", total_tag_len);\n+        return offset + tvb_reported_length_remaining(tvb, offset);\n+    }\n     return offset + total_tag_len;\n \n }",
        "diff_line_info": {
            "deleted_lines": [
                "                tag_offset += tag_len;",
                "            tag_offset = offset_end;"
            ],
            "added_lines": [
                "                goto end;",
                "            // XXX Return instead?",
                "            goto end;",
                "",
                "    end:",
                "    if (offset + total_tag_len <= offset) {",
                "        expert_add_info_format(pinfo, fb_zero_tree, &ei_fb_zero_length_invalid,",
                "                         \"Invalid total tag length: %u\", total_tag_len);",
                "        return offset + tvb_reported_length_remaining(tvb, offset);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-28030",
        "func_name": "wireshark/proto_register_fb_zero",
        "description": "In Wireshark 3.2.0 to 3.2.7, the GQUIC dissector could crash. This was addressed in epan/dissectors/packet-gquic.c by correcting the implementation of offset advancement.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/3ff940652962c099b73ae3233322b8697b0d10ab",
        "commit_title": "FBZERO: Make sure our offset advances.",
        "commit_text": " Make sure our offset advances so that we don't infinitely loop. Fixes #16887. ",
        "func_before": "void\nproto_register_fb_zero(void)\n{\n    static hf_register_info hf[] = {\n        { &hf_fb_zero_puflags,\n            { \"Public Flags\", \"fb_zero.puflags\",\n              FT_UINT8, BASE_HEX, NULL, 0x0,\n              \"Specifying per-packet public flags\", HFILL }\n        },\n        { &hf_fb_zero_puflags_vrsn,\n            { \"Version\", \"fb_zero.puflags.version\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_VRSN,\n              \"Signifies that this packet also contains the version of the FB Zero protocol\", HFILL }\n        },\n        { &hf_fb_zero_puflags_unknown,\n            { \"Unknown\", \"fb_zero.puflags.unknown\",\n              FT_UINT8, BASE_HEX, NULL, PUFLAGS_UNKN,\n              NULL, HFILL }\n        },\n\n        { &hf_fb_zero_version,\n            { \"Version\", \"fb_zero.version\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"32 bit opaque tag that represents the version of the ZB Zero (Always QTV)\", HFILL }\n        },\n        { &hf_fb_zero_length,\n            { \"Length\", \"fb_zero.length\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag,\n            { \"Tag\", \"fb_zero.tag\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_number,\n            { \"Tag Number\", \"fb_zero.tag_number\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tags,\n            { \"Tag/value\", \"fb_zero.tags\",\n              FT_NONE, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_type,\n            { \"Tag Type\", \"fb_zero.tag_type\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_offset_end,\n            { \"Tag offset end\", \"fb_zero.tag_offset_end\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_length,\n            { \"Tag length\", \"fb_zero.tag_offset_length\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_value,\n            { \"Tag/value\", \"fb_zero.tag_value\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_sni,\n            { \"Server Name Indication\", \"fb_zero.tag.sni\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"The fully qualified DNS name of the server, canonicalised to lowercase with no trailing period\", HFILL }\n        },\n        { &hf_fb_zero_tag_vers,\n            { \"Version\", \"fb_zero.tag.version\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"Version of FB Zero supported\", HFILL }\n        },\n        { &hf_fb_zero_tag_sno,\n            { \"Server nonce\", \"fb_zero.tag.sno\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_aead,\n            { \"Authenticated encryption algorithms\", \"fb_zero.tag.aead\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"A list of tags, in preference order, specifying the AEAD primitives supported by the server\", HFILL }\n        },\n        { &hf_fb_zero_tag_scid,\n            { \"Server Config ID\", \"fb_zero.tag.scid\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"An opaque, 16-byte identifier for this server config\", HFILL }\n        },\n        { &hf_fb_zero_tag_time,\n            { \"Time\", \"fb_zero.tag.time\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_alpn,\n            { \"ALPN\", \"fb_zero.tag.alpn\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"Application-Layer Protocol Negotiation supported\", HFILL }\n        },\n        { &hf_fb_zero_tag_pubs,\n            { \"Public value\", \"fb_zero.tag.pubs\",\n              FT_UINT24, BASE_DEC_HEX, NULL, 0x0,\n              \"A list of public values, 24-bit, little-endian length prefixed\", HFILL }\n        },\n        { &hf_fb_zero_tag_kexs,\n            { \"Key exchange algorithms\", \"fb_zero.tag.kexs\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"A list of tags, in preference order, specifying the key exchange algorithms that the server supports\", HFILL }\n        },\n        { &hf_fb_zero_tag_nonc,\n            { \"Client nonce\", \"fb_zero.tag.nonc\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"32 bytes consisting of 4 bytes of timestamp (big-endian, UNIX epoch seconds), 8 bytes of server orbit and 20 bytes of random data\", HFILL }\n        },\n        { &hf_fb_zero_tag_unknown,\n            { \"Unknown tag\", \"fb_zero.tag.unknown\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_padding,\n            { \"Padding\", \"fb_zero.padding\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_payload,\n            { \"Payload\", \"fb_zero.payload\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"Fb Zero Payload..\", HFILL }\n        },\n        { &hf_fb_zero_unknown,\n            { \"Unknown\", \"fb_zero.unknown\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"Unknown Data\", HFILL }\n        },\n    };\n\n\n    static gint *ett[] = {\n        &ett_fb_zero,\n        &ett_fb_zero_puflags,\n        &ett_fb_zero_prflags,\n        &ett_fb_zero_ft,\n        &ett_fb_zero_ftflags,\n        &ett_fb_zero_tag_value\n    };\n\n    static ei_register_info ei[] = {\n        { &ei_fb_zero_tag_undecoded, { \"fb_zero.tag.undecoded\", PI_UNDECODED, PI_NOTE, \"Dissector for FB Zero Tag code not implemented, Contact Wireshark developers if you want this supported\", EXPFILL }},\n        { &ei_fb_zero_tag_length, { \"fb_zero.tag.length.truncated\", PI_MALFORMED, PI_NOTE, \"Truncated Tag Length...\", EXPFILL }},\n        { &ei_fb_zero_tag_unknown, { \"fb_zero.tag.unknown.data\", PI_UNDECODED, PI_NOTE, \"Unknown Data\", EXPFILL }},\n    };\n\n    expert_module_t *expert_fb_zero;\n\n    proto_fb_zero = proto_register_protocol(\"(Facebook) Zero Protocol\", \"FBZERO\", \"fb_zero\");\n\n    fb_zero_handle = register_dissector(\"fb_zero\", dissect_fb_zero, proto_fb_zero);\n\n    proto_register_field_array(proto_fb_zero, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n\n    expert_fb_zero = expert_register_protocol(proto_fb_zero);\n    expert_register_field_array(expert_fb_zero, ei, array_length(ei));\n}",
        "func": "void\nproto_register_fb_zero(void)\n{\n    static hf_register_info hf[] = {\n        { &hf_fb_zero_puflags,\n            { \"Public Flags\", \"fb_zero.puflags\",\n              FT_UINT8, BASE_HEX, NULL, 0x0,\n              \"Specifying per-packet public flags\", HFILL }\n        },\n        { &hf_fb_zero_puflags_vrsn,\n            { \"Version\", \"fb_zero.puflags.version\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_VRSN,\n              \"Signifies that this packet also contains the version of the FB Zero protocol\", HFILL }\n        },\n        { &hf_fb_zero_puflags_unknown,\n            { \"Unknown\", \"fb_zero.puflags.unknown\",\n              FT_UINT8, BASE_HEX, NULL, PUFLAGS_UNKN,\n              NULL, HFILL }\n        },\n\n        { &hf_fb_zero_version,\n            { \"Version\", \"fb_zero.version\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"32 bit opaque tag that represents the version of the ZB Zero (Always QTV)\", HFILL }\n        },\n        { &hf_fb_zero_length,\n            { \"Length\", \"fb_zero.length\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag,\n            { \"Tag\", \"fb_zero.tag\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_number,\n            { \"Tag Number\", \"fb_zero.tag_number\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tags,\n            { \"Tag/value\", \"fb_zero.tags\",\n              FT_NONE, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_type,\n            { \"Tag Type\", \"fb_zero.tag_type\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_offset_end,\n            { \"Tag offset end\", \"fb_zero.tag_offset_end\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_length,\n            { \"Tag length\", \"fb_zero.tag_offset_length\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_value,\n            { \"Tag/value\", \"fb_zero.tag_value\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_sni,\n            { \"Server Name Indication\", \"fb_zero.tag.sni\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"The fully qualified DNS name of the server, canonicalised to lowercase with no trailing period\", HFILL }\n        },\n        { &hf_fb_zero_tag_vers,\n            { \"Version\", \"fb_zero.tag.version\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"Version of FB Zero supported\", HFILL }\n        },\n        { &hf_fb_zero_tag_sno,\n            { \"Server nonce\", \"fb_zero.tag.sno\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_aead,\n            { \"Authenticated encryption algorithms\", \"fb_zero.tag.aead\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"A list of tags, in preference order, specifying the AEAD primitives supported by the server\", HFILL }\n        },\n        { &hf_fb_zero_tag_scid,\n            { \"Server Config ID\", \"fb_zero.tag.scid\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"An opaque, 16-byte identifier for this server config\", HFILL }\n        },\n        { &hf_fb_zero_tag_time,\n            { \"Time\", \"fb_zero.tag.time\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_alpn,\n            { \"ALPN\", \"fb_zero.tag.alpn\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"Application-Layer Protocol Negotiation supported\", HFILL }\n        },\n        { &hf_fb_zero_tag_pubs,\n            { \"Public value\", \"fb_zero.tag.pubs\",\n              FT_UINT24, BASE_DEC_HEX, NULL, 0x0,\n              \"A list of public values, 24-bit, little-endian length prefixed\", HFILL }\n        },\n        { &hf_fb_zero_tag_kexs,\n            { \"Key exchange algorithms\", \"fb_zero.tag.kexs\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"A list of tags, in preference order, specifying the key exchange algorithms that the server supports\", HFILL }\n        },\n        { &hf_fb_zero_tag_nonc,\n            { \"Client nonce\", \"fb_zero.tag.nonc\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"32 bytes consisting of 4 bytes of timestamp (big-endian, UNIX epoch seconds), 8 bytes of server orbit and 20 bytes of random data\", HFILL }\n        },\n        { &hf_fb_zero_tag_unknown,\n            { \"Unknown tag\", \"fb_zero.tag.unknown\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_padding,\n            { \"Padding\", \"fb_zero.padding\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_payload,\n            { \"Payload\", \"fb_zero.payload\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"Fb Zero Payload..\", HFILL }\n        },\n        { &hf_fb_zero_unknown,\n            { \"Unknown\", \"fb_zero.unknown\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"Unknown Data\", HFILL }\n        },\n    };\n\n\n    static gint *ett[] = {\n        &ett_fb_zero,\n        &ett_fb_zero_puflags,\n        &ett_fb_zero_prflags,\n        &ett_fb_zero_ft,\n        &ett_fb_zero_ftflags,\n        &ett_fb_zero_tag_value\n    };\n\n    static ei_register_info ei[] = {\n        { &ei_fb_zero_tag_undecoded, { \"fb_zero.tag.undecoded\", PI_UNDECODED, PI_NOTE, \"Dissector for FB Zero Tag code not implemented, Contact Wireshark developers if you want this supported\", EXPFILL }},\n        { &ei_fb_zero_tag_length, { \"fb_zero.tag.length.truncated\", PI_MALFORMED, PI_NOTE, \"Truncated Tag Length...\", EXPFILL }},\n        { &ei_fb_zero_tag_unknown, { \"fb_zero.tag.unknown.data\", PI_UNDECODED, PI_NOTE, \"Unknown Data\", EXPFILL }},\n        { &ei_fb_zero_length_invalid, { \"fb_zero.length.invalid\", PI_PROTOCOL, PI_WARN, \"Invalid length\", EXPFILL }},\n    };\n\n    expert_module_t *expert_fb_zero;\n\n    proto_fb_zero = proto_register_protocol(\"(Facebook) Zero Protocol\", \"FBZERO\", \"fb_zero\");\n\n    fb_zero_handle = register_dissector(\"fb_zero\", dissect_fb_zero, proto_fb_zero);\n\n    proto_register_field_array(proto_fb_zero, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n\n    expert_fb_zero = expert_register_protocol(proto_fb_zero);\n    expert_register_field_array(expert_fb_zero, ei, array_length(ei));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -149,6 +149,7 @@\n         { &ei_fb_zero_tag_undecoded, { \"fb_zero.tag.undecoded\", PI_UNDECODED, PI_NOTE, \"Dissector for FB Zero Tag code not implemented, Contact Wireshark developers if you want this supported\", EXPFILL }},\n         { &ei_fb_zero_tag_length, { \"fb_zero.tag.length.truncated\", PI_MALFORMED, PI_NOTE, \"Truncated Tag Length...\", EXPFILL }},\n         { &ei_fb_zero_tag_unknown, { \"fb_zero.tag.unknown.data\", PI_UNDECODED, PI_NOTE, \"Unknown Data\", EXPFILL }},\n+        { &ei_fb_zero_length_invalid, { \"fb_zero.length.invalid\", PI_PROTOCOL, PI_WARN, \"Invalid length\", EXPFILL }},\n     };\n \n     expert_module_t *expert_fb_zero;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        { &ei_fb_zero_length_invalid, { \"fb_zero.length.invalid\", PI_PROTOCOL, PI_WARN, \"Invalid length\", EXPFILL }},"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-28030",
        "func_name": "wireshark/proto_register_gquic",
        "description": "In Wireshark 3.2.0 to 3.2.7, the GQUIC dissector could crash. This was addressed in epan/dissectors/packet-gquic.c by correcting the implementation of offset advancement.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/b287e7165e8aa89cde6ae37e7c257c5d87d16b9b",
        "commit_title": "GQUIC: make sure our tag offset advances.",
        "commit_text": " Make sure gquic tag offset advances so that we don't infinitely loop. ",
        "func_before": "void\nproto_register_gquic(void)\n{\n    module_t *gquic_module;\n\n    static hf_register_info hf[] = {\n        /* Long/Short header for Q046 */\n        { &hf_gquic_header_form,\n          { \"Header Form\", \"gquic.header_form\",\n            FT_UINT8, BASE_DEC, VALS(gquic_short_long_header_vals), 0x80,\n            \"The most significant bit (0x80) of the first octet is set to 1 for long headers and 0 for short headers.\", HFILL }\n        },\n        { &hf_gquic_fixed_bit,\n          { \"Fixed Bit\", \"gquic.fixed_bit\",\n            FT_BOOLEAN, 8, NULL, 0x40,\n            \"Must be 1\", HFILL }\n        },\n        { &hf_gquic_long_packet_type,\n          { \"Packet Type\", \"gquic.long.packet_type\",\n            FT_UINT8, BASE_DEC, VALS(gquic_long_packet_type_vals), 0x30,\n            \"Long Header Packet Type\", HFILL }\n        },\n        { &hf_gquic_long_reserved,\n          { \"Reserved\", \"gquic.long.reserved\",\n            FT_UINT8, BASE_DEC, NULL, 0x0c,\n            \"Reserved bits\", HFILL }\n        },\n        { &hf_gquic_packet_number_length,\n          { \"Packet Number Length\", \"gquic.packet_number_length\",\n            FT_UINT8, BASE_DEC, VALS(gquic_packet_number_lengths), 0x03,\n            \"Packet Number field length\", HFILL }\n\t},\n        { &hf_gquic_dcil,\n          { \"Destination Connection ID Length\", \"gquic.dcil\",\n            FT_UINT8, BASE_DEC, VALS(quic_cid_lengths), 0xF0,\n            NULL, HFILL }\n        },\n        { &hf_gquic_scil,\n          { \"Source Connection ID Length\", \"gquic.scil\",\n            FT_UINT8, BASE_DEC, VALS(quic_cid_lengths), 0x0F,\n            NULL, HFILL }\n        },\n\n        /* Public header for < Q046 */\n        { &hf_gquic_puflags,\n            { \"Public Flags\", \"gquic.puflags\",\n              FT_UINT8, BASE_HEX, NULL, 0x0,\n              \"Specifying per-packet public flags\", HFILL }\n        },\n        { &hf_gquic_puflags_vrsn,\n            { \"Version\", \"gquic.puflags.version\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_VRSN,\n              \"Signifies that this packet also contains the version of the (Google)QUIC protocol\", HFILL }\n        },\n        { &hf_gquic_puflags_rst,\n            { \"Reset\", \"gquic.puflags.reset\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_RST,\n              \"Signifies that this packet is a public reset packet\", HFILL }\n        },\n        { &hf_gquic_puflags_dnonce,\n            { \"Diversification nonce\", \"gquic.puflags.nonce\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_DNONCE,\n              \"Indicates the presence of a 32 byte diversification nonce\", HFILL }\n        },\n        { &hf_gquic_puflags_cid,\n            { \"CID Length\", \"gquic.puflags.cid\",\n              FT_BOOLEAN, 8, TFS(&puflags_cid_tfs), PUFLAGS_CID,\n              \"Indicates the full 8 byte Connection ID is present\", HFILL }\n        },\n        { &hf_gquic_puflags_cid_old,\n            { \"CID Length\", \"gquic.puflags.cid.old\",\n              FT_UINT8, BASE_HEX, VALS(puflags_cid_old_vals), PUFLAGS_CID_OLD,\n              \"Signifies the Length of CID\", HFILL }\n        },\n        { &hf_gquic_puflags_pkn,\n            { \"Packet Number Length\", \"gquic.puflags.pkn\",\n              FT_UINT8, BASE_HEX, VALS(puflags_pkn_vals), PUFLAGS_PKN,\n              \"Signifies the Length of packet number\", HFILL }\n        },\n        { &hf_gquic_puflags_mpth,\n            { \"Multipath\", \"gquic.puflags.mpth\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_MPTH,\n              \"Reserved for multipath use\", HFILL }\n        },\n        { &hf_gquic_puflags_rsv,\n            { \"Reserved\", \"gquic.puflags.rsv\",\n              FT_UINT8, BASE_HEX, NULL, PUFLAGS_RSV,\n              \"Must be Zero\", HFILL }\n        },\n        { &hf_gquic_cid,\n            { \"CID\", \"gquic.cid\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Connection ID 64 bit pseudo random number\", HFILL }\n        },\n        { &hf_gquic_version,\n            { \"Version\", \"gquic.version\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"32 bit opaque tag that represents the version of the (Google)QUIC\", HFILL }\n        },\n        { &hf_gquic_diversification_nonce,\n            { \"Diversification nonce\", \"gquic.diversification_nonce\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_packet_number,\n            { \"Packet Number\", \"gquic.packet_number\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"The lower 8, 16, 32, or 48 bits of the packet number\", HFILL }\n        },\n\n        { &hf_gquic_prflags,\n            { \"Private Flags\", \"gquic.prflags\",\n              FT_UINT8, BASE_HEX, NULL, 0x0,\n              \"Specifying per-packet Private flags\", HFILL }\n        },\n\n        { &hf_gquic_prflags_entropy,\n            { \"Entropy\", \"gquic.prflags.entropy\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PRFLAGS_ENTROPY,\n              \"For data packets, signifies that this packet contains the 1 bit of entropy, for fec packets, contains the xor of the entropy of protected packets\", HFILL }\n        },\n        { &hf_gquic_prflags_fecg,\n            { \"FEC Group\", \"gquic.prflags.fecg\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PRFLAGS_FECG,\n              \"Indicates whether the fec byte is present.\", HFILL }\n        },\n        { &hf_gquic_prflags_fec,\n            { \"FEC\", \"gquic.prflags.fec\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PRFLAGS_FEC,\n              \"Signifies that this packet represents an FEC packet\", HFILL }\n        },\n        { &hf_gquic_prflags_rsv,\n            { \"Reserved\", \"gquic.prflags.rsv\",\n              FT_UINT8, BASE_HEX, NULL, PRFLAGS_RSV,\n              \"Must be Zero\", HFILL }\n        },\n\n        { &hf_gquic_message_authentication_hash,\n            { \"Message Authentication Hash\", \"gquic.message_authentication_hash\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"The hash is an FNV1a-128 hash, serialized in little endian order\", HFILL }\n        },\n        { &hf_gquic_frame,\n            { \"Frame\", \"gquic.frame\",\n              FT_NONE, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type,\n            { \"Frame Type\", \"gquic.frame_type\",\n              FT_UINT8 ,BASE_RANGE_STRING | BASE_HEX, RVALS(frame_type_vals), 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_padding_length,\n            { \"Padding Length\", \"gquic.frame_type.padding.length\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_padding,\n            { \"Padding\", \"gquic.frame_type.padding\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"Must be zero\", HFILL }\n        },\n        { &hf_gquic_frame_type_rsts_stream_id,\n            { \"Stream ID\", \"gquic.frame_type.rsts.stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"Stream ID of the stream being terminated\", HFILL }\n        },\n        { &hf_gquic_frame_type_rsts_byte_offset,\n            { \"Byte offset\", \"gquic.frame_type.rsts.byte_offset\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Indicating the absolute byte offset of the end of data for this stream\", HFILL }\n        },\n        { &hf_gquic_frame_type_rsts_error_code,\n            { \"Error code\", \"gquic.frame_type.rsts.error_code\",\n              FT_UINT32, BASE_DEC|BASE_EXT_STRING, &rststream_error_code_vals_ext, 0x0,\n              \"Indicates why the stream is being closed\", HFILL }\n        },\n        { &hf_gquic_frame_type_cc_error_code,\n            { \"Error code\", \"gquic.frame_type.cc.error_code\",\n              FT_UINT32, BASE_DEC|BASE_EXT_STRING, &error_code_vals_ext, 0x0,\n              \"Indicates the reason for closing this connection\", HFILL }\n        },\n        { &hf_gquic_frame_type_cc_reason_phrase_length,\n            { \"Reason phrase Length\", \"gquic.frame_type.cc.reason_phrase.length\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"Specifying the length of the reason phrase\", HFILL }\n        },\n        { &hf_gquic_frame_type_cc_reason_phrase,\n            { \"Reason phrase\", \"gquic.frame_type.cc.reason_phrase\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"An optional human-readable explanation for why the connection was closed\", HFILL }\n        },\n        { &hf_gquic_frame_type_goaway_error_code,\n            { \"Error code\", \"gquic.frame_type.goaway.error_code\",\n              FT_UINT32, BASE_DEC|BASE_EXT_STRING, &error_code_vals_ext, 0x0,\n              \"Indicates the reason for closing this connection\", HFILL }\n        },\n        { &hf_gquic_frame_type_goaway_last_good_stream_id,\n            { \"Last Good Stream ID\", \"gquic.frame_type.goaway.last_good_stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"last Stream ID which was accepted by the sender of the GOAWAY message\", HFILL }\n        },\n        { &hf_gquic_frame_type_goaway_reason_phrase_length,\n            { \"Reason phrase Length\", \"gquic.frame_type.goaway.reason_phrase.length\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"Specifying the length of the reason phrase\", HFILL }\n        },\n        { &hf_gquic_frame_type_goaway_reason_phrase,\n            { \"Reason phrase\", \"gquic.frame_type.goaway.reason_phrase\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"An optional human-readable explanation for why the connection was closed\", HFILL }\n        },\n        { &hf_gquic_frame_type_wu_stream_id,\n            { \"Stream ID\", \"gquic.frame_type.wu.stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"ID of the stream whose flow control windows is begin updated, or 0 to specify the connection-level flow control window\", HFILL }\n        },\n        { &hf_gquic_frame_type_wu_byte_offset,\n            { \"Byte offset\", \"gquic.frame_type.wu.byte_offset\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Indicating the absolute byte offset of data which can be sent on the given stream\", HFILL }\n        },\n        { &hf_gquic_frame_type_blocked_stream_id,\n            { \"Stream ID\", \"gquic.frame_type.blocked.stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"Indicating the stream which is flow control blocked\", HFILL }\n        },\n        { &hf_gquic_frame_type_sw_send_entropy,\n            { \"Send Entropy\", \"gquic.frame_type.sw.send_entropy\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the cumulative hash of entropy in all sent packets up to the packet with packet number one less than the least unacked packet\", HFILL }\n        },\n        { &hf_gquic_frame_type_sw_least_unacked_delta,\n            { \"Least unacked delta\", \"gquic.frame_type.sw.least_unacked_delta\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"A variable length packet number delta with the same length as the packet header's packet number\", HFILL }\n        },\n        { &hf_gquic_crypto_offset,\n            { \"Offset\", \"gquic.crypto.offset\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Byte offset into the stream\", HFILL }\n        },\n        { &hf_gquic_crypto_length,\n            { \"Length\", \"gquic.crypto.length\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Length of the Crypto Data field\", HFILL }\n        },\n        { &hf_gquic_crypto_crypto_data,\n            { \"Crypto Data\", \"gquic.crypto.crypto_data\",\n              FT_NONE, BASE_NONE, NULL, 0x0,\n              \"The cryptographic message data\", HFILL }\n        },\n        { &hf_gquic_frame_type_stream,\n            { \"Stream\", \"gquic.frame_type.stream\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_STREAM,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_stream_f,\n            { \"FIN\", \"gquic.frame_type.stream.f\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_STREAM_F,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_stream_d,\n            { \"Data Length\", \"gquic.frame_type.stream.d\",\n              FT_BOOLEAN, 8, TFS(&len_data_vals), FTFLAGS_STREAM_D,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_stream_ooo,\n            { \"Offset Length\", \"gquic.frame_type.stream.ooo\",\n              FT_UINT8, BASE_DEC, VALS(len_offset_vals), FTFLAGS_STREAM_OOO,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_stream_ss,\n            { \"Stream Length\", \"gquic.frame_type.stream.ss\",\n              FT_UINT8, BASE_DEC, VALS(len_stream_vals), FTFLAGS_STREAM_SS,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack,\n            { \"ACK\", \"gquic.frame_type.ack\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_ACK,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_n,\n            { \"NACK\", \"gquic.frame_type.ack.n\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_ACK_N,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_u,\n            { \"Unused\", \"gquic.frame_type.ack.u\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_ACK_U,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_t,\n            { \"Truncated\", \"gquic.frame_type.ack.t\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_ACK_T,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_ll,\n            { \"Largest Observed Length\", \"gquic.frame_type.ack.ll\",\n              FT_UINT8, BASE_DEC, VALS(len_largest_observed_vals), FTFLAGS_ACK_LL,\n              \"Length of the Largest Observed field as 1, 2, 4, or 6 bytes long\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_mm,\n            { \"Missing Packet Length\", \"gquic.frame_type.ack.mm\",\n              FT_UINT8, BASE_DEC, VALS(len_missing_packet_vals), FTFLAGS_ACK_MM,\n              \"Length of the Missing Packet Number Delta field as 1, 2, 4, or 6 bytes long\", HFILL }\n        },\n        /* ACK before Q034 */\n        { &hf_gquic_frame_type_ack_received_entropy,\n            { \"Received Entropy\", \"gquic.frame_type.ack.received_entropy\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the cumulative hash of entropy in all received packets up to the largest observed packet\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_largest_observed,\n            { \"Largest Observed\", \"gquic.frame_type.ack.largest_observed\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Representing the largest packet number the peer has observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_ack_delay_time,\n            { \"Ack Delay time\", \"gquic.frame_type.ack.ack_delay_time\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"Specifying the time elapsed in microseconds from when largest observed was received until this Ack frame was sent\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_num_timestamp,\n            { \"Num Timestamp\", \"gquic.frame_type.ack.num_timestamp\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the number of TCP timestamps that are included in this frame\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_delta_largest_observed,\n            { \"Delta Largest Observed\", \"gquic.frame_type.ack.delta_largest_observed\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the packet number delta from the first timestamp to the largest observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_first_timestamp,\n            { \"First Timestamp\", \"gquic.frame_type.ack.first_timestamp\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"Specifying the time delta in microseconds, from the beginning of the connection of the arrival of the packet specified by Largest Observed minus Delta Largest Observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_time_since_previous_timestamp,\n            { \"Time since Previous timestamp\", \"gquic.frame_type.ack.time_since_previous_timestamp\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"This is the time delta from the previous timestamp\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_num_ranges,\n            { \"Num Ranges\", \"gquic.frame_type.ack.num_ranges\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the number of missing packet ranges between largest observed and least unacked\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_missing_packet,\n            { \"Missing Packet Packet Number Delta\", \"gquic.frame_type.ack.missing_packet\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_range_length,\n            { \"Range Length\", \"gquic.frame_type.ack.range_length\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying one less than the number of sequential nacks in the range\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_num_revived,\n            { \"Num Revived\", \"gquic.frame_type.ack.num_revived\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the number of revived packets, recovered via FEC\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_revived_packet,\n            { \"Revived Packet Packet Number\", \"gquic.frame_type.ack.revived_packet\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Representing a packet the peer has revived via FEC\", HFILL }\n        },\n        /* ACK after Q034 */\n        { &hf_gquic_frame_type_ack_largest_acked,\n            { \"Largest Acked\", \"gquic.frame_type.ack.largest_acked\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Representing the largest packet number the peer has observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_largest_acked_delta_time,\n            { \"Largest Acked Delta Time\", \"gquic.frame_type.ack.largest_acked_delta_time\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"Specifying the time elapsed in microseconds from when largest acked was received until this Ack frame was sent\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_num_blocks,\n            { \"Num blocks\", \"gquic.frame_type.ack.num_blocks\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying one less than the number of ack blocks\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_first_ack_block_length,\n            { \"First Ack block length\", \"gquic.frame_type.ack.first_ack_block_length\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_gap_to_next_block,\n            { \"Gap to next block\", \"gquic.frame_type.ack.gap_to_next_block\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the number of packets between ack blocks\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_ack_block_length,\n            { \"Ack block length\", \"gquic.frame_type.ack.ack_block_length\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_delta_largest_acked,\n            { \"Delta Largest Observed\", \"gquic.frame_type.ack.delta_largest_acked\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the packet number delta from the first timestamp to the largest observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_time_since_largest_acked,\n            { \"Time Since Largest Acked\", \"gquic.frame_type.ack.time_since_largest_acked\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"Specifying the time delta in microseconds, from the beginning of the connection of the arrival of the packet specified by Largest Observed minus Delta Largest Observed\", HFILL }\n        },\n\n\n\n        { &hf_gquic_stream_id,\n            { \"Stream ID\", \"gquic.stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_offset,\n            { \"Offset\", \"gquic.offset\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_data_len,\n            { \"Data Length\", \"gquic.data_len\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag,\n            { \"Tag\", \"gquic.tag\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_number,\n            { \"Tag Number\", \"gquic.tag_number\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tags,\n            { \"Tag/value\", \"gquic.tags\",\n              FT_NONE, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_type,\n            { \"Tag Type\", \"gquic.tag_type\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_offset_end,\n            { \"Tag offset end\", \"gquic.tag_offset_end\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_length,\n            { \"Tag length\", \"gquic.tag_offset_length\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_value,\n            { \"Tag/value\", \"gquic.tag_value\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_sni,\n            { \"Server Name Indication\", \"gquic.tag.sni\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"The fully qualified DNS name of the server, canonicalised to lowercase with no trailing period\", HFILL }\n        },\n        { &hf_gquic_tag_pad,\n            { \"Padding\", \"gquic.tag.pad\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"Pad.....\", HFILL }\n        },\n        { &hf_gquic_tag_ver,\n            { \"Version\", \"gquic.tag.version\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"Version of gquic supported\", HFILL }\n        },\n        { &hf_gquic_tag_pdmd,\n            { \"Proof demand\", \"gquic.tag.pdmd\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"a list of tags describing the types of proof acceptable to the client, in preference order\", HFILL }\n        },\n        { &hf_gquic_tag_ccs,\n            { \"Common certificate sets\", \"gquic.tag.ccs\",\n              FT_UINT64, BASE_HEX, NULL, 0x0,\n              \"A series of 64-bit, FNV-1a hashes of sets of common certificates that the client possesses\", HFILL }\n        },\n        { &hf_gquic_tag_uaid,\n            { \"Client's User Agent ID\", \"gquic.tag.uaid\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_stk,\n            { \"Source-address token\", \"gquic.tag.stk\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_sno,\n            { \"Server nonce\", \"gquic.tag.sno\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_prof,\n            { \"Proof (Signature)\", \"gquic.tag.prof\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_scfg,\n            { \"Server Config Tag\", \"gquic.tag.scfg\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_scfg_number,\n            { \"Number Server Config Tag\", \"gquic.tag.scfg.number\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_rrej,\n            { \"Reasons for server sending\", \"gquic.tag.rrej\",\n              FT_UINT32, BASE_DEC|BASE_EXT_STRING, &handshake_failure_reason_vals_ext, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_crt,\n            { \"Certificate chain\", \"gquic.tag.crt\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_aead,\n            { \"Authenticated encryption algorithms\", \"gquic.tag.aead\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"A list of tags, in preference order, specifying the AEAD primitives supported by the server\", HFILL }\n        },\n        { &hf_gquic_tag_scid,\n            { \"Server Config ID\", \"gquic.tag.scid\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"An opaque, 16-byte identifier for this server config\", HFILL }\n        },\n        { &hf_gquic_tag_pubs,\n            { \"Public value\", \"gquic.tag.pubs\",\n              FT_UINT24, BASE_DEC_HEX, NULL, 0x0,\n              \"A list of public values, 24-bit, little-endian length prefixed\", HFILL }\n        },\n        { &hf_gquic_tag_kexs,\n            { \"Key exchange algorithms\", \"gquic.tag.kexs\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"A list of tags, in preference order, specifying the key exchange algorithms that the server supports\", HFILL }\n        },\n        { &hf_gquic_tag_obit,\n            { \"Server orbit\", \"gquic.tag.obit\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_expy,\n            { \"Expiry\", \"gquic.tag.expy\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"a 64-bit expiry time for the server config in UNIX epoch seconds\", HFILL }\n        },\n        { &hf_gquic_tag_nonc,\n            { \"Client nonce\", \"gquic.tag.nonc\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"32 bytes consisting of 4 bytes of timestamp (big-endian, UNIX epoch seconds), 8 bytes of server orbit and 20 bytes of random data\", HFILL }\n        },\n        { &hf_gquic_tag_mspc,\n            { \"Max streams per connection\", \"gquic.tag.mspc\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_tcid,\n            { \"Connection ID truncation\", \"gquic.tag.tcid\",\n              FT_UINT32, BASE_DEC_HEX, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_srbf,\n            { \"Socket receive buffer\", \"gquic.tag.srbf\",\n              FT_UINT32, BASE_DEC_HEX, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_icsl,\n            { \"Idle connection state\", \"gquic.tag.icsl\",\n              FT_UINT32, BASE_DEC_HEX, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_scls,\n            { \"Silently close on timeout\", \"gquic.tag.scls\",\n              FT_UINT32, BASE_DEC_HEX, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_copt,\n            { \"Connection options\", \"gquic.tag.copt\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_ccrt,\n            { \"Cached certificates\", \"gquic.tag.ccrt\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_irtt,\n            { \"Estimated initial RTT\", \"gquic.tag.irtt\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"in us\", HFILL }\n        },\n        { &hf_gquic_tag_cfcw,\n            { \"Initial session/connection\", \"gquic.tag.cfcw\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_sfcw,\n            { \"Initial stream flow control\", \"gquic.tag.sfcw\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cetv,\n            { \"Client encrypted tag-value\", \"gquic.tag.cetv\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_xlct,\n            { \"Expected leaf certificate\", \"gquic.tag.xlct\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_nonp,\n            { \"Client Proof nonce\", \"gquic.tag.nonp\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_csct,\n            { \"Signed cert timestamp\", \"gquic.tag.csct\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_ctim,\n            { \"Client Timestamp\", \"gquic.tag.ctim\",\n              FT_ABSOLUTE_TIME, ABSOLUTE_TIME_UTC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_rnon,\n            { \"Public reset nonce proof\", \"gquic.tag.rnon\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_rseq,\n            { \"Rejected Packet Number\", \"gquic.tag.rseq\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"a 64-bit packet number\", HFILL }\n        },\n        { &hf_gquic_tag_cadr_addr_type,\n            { \"Client IP Address Type\", \"gquic.tag.caddr.addr.type\",\n              FT_UINT16, BASE_DEC, VALS(cadr_type_vals), 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cadr_addr_ipv4,\n            { \"Client IP Address\", \"gquic.tag.caddr.addr.ipv4\",\n              FT_IPv4, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cadr_addr_ipv6,\n            { \"Client IP Address\", \"gquic.tag.caddr.addr.ipv6\",\n              FT_IPv6, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cadr_addr,\n            { \"Client IP Address\", \"gquic.tag.caddr.addr\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cadr_port,\n            { \"Client Port (Source)\", \"gquic.tag.caddr.port\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_mids,\n            { \"Max incoming dynamic streams\", \"gquic.tag.mids\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_fhol,\n            { \"Force Head Of Line blocking\", \"gquic.tag.fhol\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_sttl,\n            { \"Server Config TTL\", \"gquic.tag.sttl\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_smhl,\n            { \"Support Max Header List (size)\", \"gquic.tag.smhl\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_tbkp,\n            { \"Token Binding Key Params.\", \"gquic.tag.tbkp\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_mad0,\n            { \"Max Ack Delay\", \"gquic.tag.mad0\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n\n        { &hf_gquic_tag_unknown,\n            { \"Unknown tag\", \"gquic.tag.unknown\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_padding,\n            { \"Padding\", \"gquic.padding\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_stream_data,\n            { \"Stream Data\", \"gquic.stream_data\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_payload,\n            { \"Payload\", \"gquic.payload\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"(Google) QUIC Payload..\", HFILL }\n        },\n    };\n\n\n    static gint *ett[] = {\n        &ett_gquic,\n        &ett_gquic_puflags,\n        &ett_gquic_prflags,\n        &ett_gquic_ft,\n        &ett_gquic_ftflags,\n        &ett_gquic_tag_value\n    };\n\n    static ei_register_info ei[] = {\n        { &ei_gquic_tag_undecoded, { \"gquic.tag.undecoded\", PI_UNDECODED, PI_NOTE, \"Dissector for (Google)QUIC Tag code not implemented, Contact Wireshark developers if you want this supported\", EXPFILL }},\n        { &ei_gquic_tag_length, { \"gquic.tag.length.truncated\", PI_MALFORMED, PI_NOTE, \"Truncated Tag Length...\", EXPFILL }},\n        { &ei_gquic_tag_unknown, { \"gquic.tag.unknown.data\", PI_UNDECODED, PI_NOTE, \"Unknown Data\", EXPFILL }},\n        { &ei_gquic_version_invalid, { \"gquic.version.invalid\", PI_MALFORMED, PI_ERROR, \"Invalid Version\", EXPFILL }},\n        { &ei_gquic_invalid_parameter, { \"gquic.invalid.parameter\", PI_MALFORMED, PI_ERROR, \"Invalid Parameter\", EXPFILL }}\n    };\n\n    expert_module_t *expert_gquic;\n\n    proto_gquic = proto_register_protocol(\"GQUIC (Google Quick UDP Internet Connections)\", \"GQUIC\", \"gquic\");\n\n    proto_register_field_array(proto_gquic, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n\n    gquic_module = prefs_register_protocol(proto_gquic, NULL);\n\n    prefs_register_bool_preference(gquic_module, \"debug.quic\",\n                       \"Force decode of all (Google) QUIC Payload\",\n                       \"Help for debug...\",\n                       &g_gquic_debug);\n\n    expert_gquic = expert_register_protocol(proto_gquic);\n    expert_register_field_array(expert_gquic, ei, array_length(ei));\n\n    gquic_handle = register_dissector(\"gquic\", dissect_gquic, proto_gquic);\n}",
        "func": "void\nproto_register_gquic(void)\n{\n    module_t *gquic_module;\n\n    static hf_register_info hf[] = {\n        /* Long/Short header for Q046 */\n        { &hf_gquic_header_form,\n          { \"Header Form\", \"gquic.header_form\",\n            FT_UINT8, BASE_DEC, VALS(gquic_short_long_header_vals), 0x80,\n            \"The most significant bit (0x80) of the first octet is set to 1 for long headers and 0 for short headers.\", HFILL }\n        },\n        { &hf_gquic_fixed_bit,\n          { \"Fixed Bit\", \"gquic.fixed_bit\",\n            FT_BOOLEAN, 8, NULL, 0x40,\n            \"Must be 1\", HFILL }\n        },\n        { &hf_gquic_long_packet_type,\n          { \"Packet Type\", \"gquic.long.packet_type\",\n            FT_UINT8, BASE_DEC, VALS(gquic_long_packet_type_vals), 0x30,\n            \"Long Header Packet Type\", HFILL }\n        },\n        { &hf_gquic_long_reserved,\n          { \"Reserved\", \"gquic.long.reserved\",\n            FT_UINT8, BASE_DEC, NULL, 0x0c,\n            \"Reserved bits\", HFILL }\n        },\n        { &hf_gquic_packet_number_length,\n          { \"Packet Number Length\", \"gquic.packet_number_length\",\n            FT_UINT8, BASE_DEC, VALS(gquic_packet_number_lengths), 0x03,\n            \"Packet Number field length\", HFILL }\n\t},\n        { &hf_gquic_dcil,\n          { \"Destination Connection ID Length\", \"gquic.dcil\",\n            FT_UINT8, BASE_DEC, VALS(quic_cid_lengths), 0xF0,\n            NULL, HFILL }\n        },\n        { &hf_gquic_scil,\n          { \"Source Connection ID Length\", \"gquic.scil\",\n            FT_UINT8, BASE_DEC, VALS(quic_cid_lengths), 0x0F,\n            NULL, HFILL }\n        },\n\n        /* Public header for < Q046 */\n        { &hf_gquic_puflags,\n            { \"Public Flags\", \"gquic.puflags\",\n              FT_UINT8, BASE_HEX, NULL, 0x0,\n              \"Specifying per-packet public flags\", HFILL }\n        },\n        { &hf_gquic_puflags_vrsn,\n            { \"Version\", \"gquic.puflags.version\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_VRSN,\n              \"Signifies that this packet also contains the version of the (Google)QUIC protocol\", HFILL }\n        },\n        { &hf_gquic_puflags_rst,\n            { \"Reset\", \"gquic.puflags.reset\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_RST,\n              \"Signifies that this packet is a public reset packet\", HFILL }\n        },\n        { &hf_gquic_puflags_dnonce,\n            { \"Diversification nonce\", \"gquic.puflags.nonce\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_DNONCE,\n              \"Indicates the presence of a 32 byte diversification nonce\", HFILL }\n        },\n        { &hf_gquic_puflags_cid,\n            { \"CID Length\", \"gquic.puflags.cid\",\n              FT_BOOLEAN, 8, TFS(&puflags_cid_tfs), PUFLAGS_CID,\n              \"Indicates the full 8 byte Connection ID is present\", HFILL }\n        },\n        { &hf_gquic_puflags_cid_old,\n            { \"CID Length\", \"gquic.puflags.cid.old\",\n              FT_UINT8, BASE_HEX, VALS(puflags_cid_old_vals), PUFLAGS_CID_OLD,\n              \"Signifies the Length of CID\", HFILL }\n        },\n        { &hf_gquic_puflags_pkn,\n            { \"Packet Number Length\", \"gquic.puflags.pkn\",\n              FT_UINT8, BASE_HEX, VALS(puflags_pkn_vals), PUFLAGS_PKN,\n              \"Signifies the Length of packet number\", HFILL }\n        },\n        { &hf_gquic_puflags_mpth,\n            { \"Multipath\", \"gquic.puflags.mpth\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_MPTH,\n              \"Reserved for multipath use\", HFILL }\n        },\n        { &hf_gquic_puflags_rsv,\n            { \"Reserved\", \"gquic.puflags.rsv\",\n              FT_UINT8, BASE_HEX, NULL, PUFLAGS_RSV,\n              \"Must be Zero\", HFILL }\n        },\n        { &hf_gquic_cid,\n            { \"CID\", \"gquic.cid\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Connection ID 64 bit pseudo random number\", HFILL }\n        },\n        { &hf_gquic_version,\n            { \"Version\", \"gquic.version\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"32 bit opaque tag that represents the version of the (Google)QUIC\", HFILL }\n        },\n        { &hf_gquic_diversification_nonce,\n            { \"Diversification nonce\", \"gquic.diversification_nonce\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_packet_number,\n            { \"Packet Number\", \"gquic.packet_number\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"The lower 8, 16, 32, or 48 bits of the packet number\", HFILL }\n        },\n\n        { &hf_gquic_prflags,\n            { \"Private Flags\", \"gquic.prflags\",\n              FT_UINT8, BASE_HEX, NULL, 0x0,\n              \"Specifying per-packet Private flags\", HFILL }\n        },\n\n        { &hf_gquic_prflags_entropy,\n            { \"Entropy\", \"gquic.prflags.entropy\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PRFLAGS_ENTROPY,\n              \"For data packets, signifies that this packet contains the 1 bit of entropy, for fec packets, contains the xor of the entropy of protected packets\", HFILL }\n        },\n        { &hf_gquic_prflags_fecg,\n            { \"FEC Group\", \"gquic.prflags.fecg\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PRFLAGS_FECG,\n              \"Indicates whether the fec byte is present.\", HFILL }\n        },\n        { &hf_gquic_prflags_fec,\n            { \"FEC\", \"gquic.prflags.fec\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PRFLAGS_FEC,\n              \"Signifies that this packet represents an FEC packet\", HFILL }\n        },\n        { &hf_gquic_prflags_rsv,\n            { \"Reserved\", \"gquic.prflags.rsv\",\n              FT_UINT8, BASE_HEX, NULL, PRFLAGS_RSV,\n              \"Must be Zero\", HFILL }\n        },\n\n        { &hf_gquic_message_authentication_hash,\n            { \"Message Authentication Hash\", \"gquic.message_authentication_hash\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"The hash is an FNV1a-128 hash, serialized in little endian order\", HFILL }\n        },\n        { &hf_gquic_frame,\n            { \"Frame\", \"gquic.frame\",\n              FT_NONE, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type,\n            { \"Frame Type\", \"gquic.frame_type\",\n              FT_UINT8 ,BASE_RANGE_STRING | BASE_HEX, RVALS(frame_type_vals), 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_padding_length,\n            { \"Padding Length\", \"gquic.frame_type.padding.length\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_padding,\n            { \"Padding\", \"gquic.frame_type.padding\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"Must be zero\", HFILL }\n        },\n        { &hf_gquic_frame_type_rsts_stream_id,\n            { \"Stream ID\", \"gquic.frame_type.rsts.stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"Stream ID of the stream being terminated\", HFILL }\n        },\n        { &hf_gquic_frame_type_rsts_byte_offset,\n            { \"Byte offset\", \"gquic.frame_type.rsts.byte_offset\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Indicating the absolute byte offset of the end of data for this stream\", HFILL }\n        },\n        { &hf_gquic_frame_type_rsts_error_code,\n            { \"Error code\", \"gquic.frame_type.rsts.error_code\",\n              FT_UINT32, BASE_DEC|BASE_EXT_STRING, &rststream_error_code_vals_ext, 0x0,\n              \"Indicates why the stream is being closed\", HFILL }\n        },\n        { &hf_gquic_frame_type_cc_error_code,\n            { \"Error code\", \"gquic.frame_type.cc.error_code\",\n              FT_UINT32, BASE_DEC|BASE_EXT_STRING, &error_code_vals_ext, 0x0,\n              \"Indicates the reason for closing this connection\", HFILL }\n        },\n        { &hf_gquic_frame_type_cc_reason_phrase_length,\n            { \"Reason phrase Length\", \"gquic.frame_type.cc.reason_phrase.length\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"Specifying the length of the reason phrase\", HFILL }\n        },\n        { &hf_gquic_frame_type_cc_reason_phrase,\n            { \"Reason phrase\", \"gquic.frame_type.cc.reason_phrase\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"An optional human-readable explanation for why the connection was closed\", HFILL }\n        },\n        { &hf_gquic_frame_type_goaway_error_code,\n            { \"Error code\", \"gquic.frame_type.goaway.error_code\",\n              FT_UINT32, BASE_DEC|BASE_EXT_STRING, &error_code_vals_ext, 0x0,\n              \"Indicates the reason for closing this connection\", HFILL }\n        },\n        { &hf_gquic_frame_type_goaway_last_good_stream_id,\n            { \"Last Good Stream ID\", \"gquic.frame_type.goaway.last_good_stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"last Stream ID which was accepted by the sender of the GOAWAY message\", HFILL }\n        },\n        { &hf_gquic_frame_type_goaway_reason_phrase_length,\n            { \"Reason phrase Length\", \"gquic.frame_type.goaway.reason_phrase.length\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"Specifying the length of the reason phrase\", HFILL }\n        },\n        { &hf_gquic_frame_type_goaway_reason_phrase,\n            { \"Reason phrase\", \"gquic.frame_type.goaway.reason_phrase\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"An optional human-readable explanation for why the connection was closed\", HFILL }\n        },\n        { &hf_gquic_frame_type_wu_stream_id,\n            { \"Stream ID\", \"gquic.frame_type.wu.stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"ID of the stream whose flow control windows is begin updated, or 0 to specify the connection-level flow control window\", HFILL }\n        },\n        { &hf_gquic_frame_type_wu_byte_offset,\n            { \"Byte offset\", \"gquic.frame_type.wu.byte_offset\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Indicating the absolute byte offset of data which can be sent on the given stream\", HFILL }\n        },\n        { &hf_gquic_frame_type_blocked_stream_id,\n            { \"Stream ID\", \"gquic.frame_type.blocked.stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"Indicating the stream which is flow control blocked\", HFILL }\n        },\n        { &hf_gquic_frame_type_sw_send_entropy,\n            { \"Send Entropy\", \"gquic.frame_type.sw.send_entropy\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the cumulative hash of entropy in all sent packets up to the packet with packet number one less than the least unacked packet\", HFILL }\n        },\n        { &hf_gquic_frame_type_sw_least_unacked_delta,\n            { \"Least unacked delta\", \"gquic.frame_type.sw.least_unacked_delta\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"A variable length packet number delta with the same length as the packet header's packet number\", HFILL }\n        },\n        { &hf_gquic_crypto_offset,\n            { \"Offset\", \"gquic.crypto.offset\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Byte offset into the stream\", HFILL }\n        },\n        { &hf_gquic_crypto_length,\n            { \"Length\", \"gquic.crypto.length\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Length of the Crypto Data field\", HFILL }\n        },\n        { &hf_gquic_crypto_crypto_data,\n            { \"Crypto Data\", \"gquic.crypto.crypto_data\",\n              FT_NONE, BASE_NONE, NULL, 0x0,\n              \"The cryptographic message data\", HFILL }\n        },\n        { &hf_gquic_frame_type_stream,\n            { \"Stream\", \"gquic.frame_type.stream\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_STREAM,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_stream_f,\n            { \"FIN\", \"gquic.frame_type.stream.f\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_STREAM_F,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_stream_d,\n            { \"Data Length\", \"gquic.frame_type.stream.d\",\n              FT_BOOLEAN, 8, TFS(&len_data_vals), FTFLAGS_STREAM_D,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_stream_ooo,\n            { \"Offset Length\", \"gquic.frame_type.stream.ooo\",\n              FT_UINT8, BASE_DEC, VALS(len_offset_vals), FTFLAGS_STREAM_OOO,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_stream_ss,\n            { \"Stream Length\", \"gquic.frame_type.stream.ss\",\n              FT_UINT8, BASE_DEC, VALS(len_stream_vals), FTFLAGS_STREAM_SS,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack,\n            { \"ACK\", \"gquic.frame_type.ack\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_ACK,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_n,\n            { \"NACK\", \"gquic.frame_type.ack.n\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_ACK_N,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_u,\n            { \"Unused\", \"gquic.frame_type.ack.u\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_ACK_U,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_t,\n            { \"Truncated\", \"gquic.frame_type.ack.t\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_ACK_T,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_ll,\n            { \"Largest Observed Length\", \"gquic.frame_type.ack.ll\",\n              FT_UINT8, BASE_DEC, VALS(len_largest_observed_vals), FTFLAGS_ACK_LL,\n              \"Length of the Largest Observed field as 1, 2, 4, or 6 bytes long\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_mm,\n            { \"Missing Packet Length\", \"gquic.frame_type.ack.mm\",\n              FT_UINT8, BASE_DEC, VALS(len_missing_packet_vals), FTFLAGS_ACK_MM,\n              \"Length of the Missing Packet Number Delta field as 1, 2, 4, or 6 bytes long\", HFILL }\n        },\n        /* ACK before Q034 */\n        { &hf_gquic_frame_type_ack_received_entropy,\n            { \"Received Entropy\", \"gquic.frame_type.ack.received_entropy\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the cumulative hash of entropy in all received packets up to the largest observed packet\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_largest_observed,\n            { \"Largest Observed\", \"gquic.frame_type.ack.largest_observed\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Representing the largest packet number the peer has observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_ack_delay_time,\n            { \"Ack Delay time\", \"gquic.frame_type.ack.ack_delay_time\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"Specifying the time elapsed in microseconds from when largest observed was received until this Ack frame was sent\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_num_timestamp,\n            { \"Num Timestamp\", \"gquic.frame_type.ack.num_timestamp\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the number of TCP timestamps that are included in this frame\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_delta_largest_observed,\n            { \"Delta Largest Observed\", \"gquic.frame_type.ack.delta_largest_observed\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the packet number delta from the first timestamp to the largest observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_first_timestamp,\n            { \"First Timestamp\", \"gquic.frame_type.ack.first_timestamp\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"Specifying the time delta in microseconds, from the beginning of the connection of the arrival of the packet specified by Largest Observed minus Delta Largest Observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_time_since_previous_timestamp,\n            { \"Time since Previous timestamp\", \"gquic.frame_type.ack.time_since_previous_timestamp\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"This is the time delta from the previous timestamp\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_num_ranges,\n            { \"Num Ranges\", \"gquic.frame_type.ack.num_ranges\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the number of missing packet ranges between largest observed and least unacked\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_missing_packet,\n            { \"Missing Packet Packet Number Delta\", \"gquic.frame_type.ack.missing_packet\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_range_length,\n            { \"Range Length\", \"gquic.frame_type.ack.range_length\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying one less than the number of sequential nacks in the range\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_num_revived,\n            { \"Num Revived\", \"gquic.frame_type.ack.num_revived\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the number of revived packets, recovered via FEC\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_revived_packet,\n            { \"Revived Packet Packet Number\", \"gquic.frame_type.ack.revived_packet\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Representing a packet the peer has revived via FEC\", HFILL }\n        },\n        /* ACK after Q034 */\n        { &hf_gquic_frame_type_ack_largest_acked,\n            { \"Largest Acked\", \"gquic.frame_type.ack.largest_acked\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Representing the largest packet number the peer has observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_largest_acked_delta_time,\n            { \"Largest Acked Delta Time\", \"gquic.frame_type.ack.largest_acked_delta_time\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"Specifying the time elapsed in microseconds from when largest acked was received until this Ack frame was sent\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_num_blocks,\n            { \"Num blocks\", \"gquic.frame_type.ack.num_blocks\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying one less than the number of ack blocks\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_first_ack_block_length,\n            { \"First Ack block length\", \"gquic.frame_type.ack.first_ack_block_length\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_gap_to_next_block,\n            { \"Gap to next block\", \"gquic.frame_type.ack.gap_to_next_block\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the number of packets between ack blocks\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_ack_block_length,\n            { \"Ack block length\", \"gquic.frame_type.ack.ack_block_length\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_delta_largest_acked,\n            { \"Delta Largest Observed\", \"gquic.frame_type.ack.delta_largest_acked\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the packet number delta from the first timestamp to the largest observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_time_since_largest_acked,\n            { \"Time Since Largest Acked\", \"gquic.frame_type.ack.time_since_largest_acked\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"Specifying the time delta in microseconds, from the beginning of the connection of the arrival of the packet specified by Largest Observed minus Delta Largest Observed\", HFILL }\n        },\n\n\n\n        { &hf_gquic_stream_id,\n            { \"Stream ID\", \"gquic.stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_offset,\n            { \"Offset\", \"gquic.offset\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_data_len,\n            { \"Data Length\", \"gquic.data_len\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag,\n            { \"Tag\", \"gquic.tag\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_number,\n            { \"Tag Number\", \"gquic.tag_number\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tags,\n            { \"Tag/value\", \"gquic.tags\",\n              FT_NONE, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_type,\n            { \"Tag Type\", \"gquic.tag_type\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_offset_end,\n            { \"Tag offset end\", \"gquic.tag_offset_end\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_length,\n            { \"Tag length\", \"gquic.tag_offset_length\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_value,\n            { \"Tag/value\", \"gquic.tag_value\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_sni,\n            { \"Server Name Indication\", \"gquic.tag.sni\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"The fully qualified DNS name of the server, canonicalised to lowercase with no trailing period\", HFILL }\n        },\n        { &hf_gquic_tag_pad,\n            { \"Padding\", \"gquic.tag.pad\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"Pad.....\", HFILL }\n        },\n        { &hf_gquic_tag_ver,\n            { \"Version\", \"gquic.tag.version\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"Version of gquic supported\", HFILL }\n        },\n        { &hf_gquic_tag_pdmd,\n            { \"Proof demand\", \"gquic.tag.pdmd\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"a list of tags describing the types of proof acceptable to the client, in preference order\", HFILL }\n        },\n        { &hf_gquic_tag_ccs,\n            { \"Common certificate sets\", \"gquic.tag.ccs\",\n              FT_UINT64, BASE_HEX, NULL, 0x0,\n              \"A series of 64-bit, FNV-1a hashes of sets of common certificates that the client possesses\", HFILL }\n        },\n        { &hf_gquic_tag_uaid,\n            { \"Client's User Agent ID\", \"gquic.tag.uaid\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_stk,\n            { \"Source-address token\", \"gquic.tag.stk\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_sno,\n            { \"Server nonce\", \"gquic.tag.sno\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_prof,\n            { \"Proof (Signature)\", \"gquic.tag.prof\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_scfg,\n            { \"Server Config Tag\", \"gquic.tag.scfg\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_scfg_number,\n            { \"Number Server Config Tag\", \"gquic.tag.scfg.number\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_rrej,\n            { \"Reasons for server sending\", \"gquic.tag.rrej\",\n              FT_UINT32, BASE_DEC|BASE_EXT_STRING, &handshake_failure_reason_vals_ext, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_crt,\n            { \"Certificate chain\", \"gquic.tag.crt\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_aead,\n            { \"Authenticated encryption algorithms\", \"gquic.tag.aead\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"A list of tags, in preference order, specifying the AEAD primitives supported by the server\", HFILL }\n        },\n        { &hf_gquic_tag_scid,\n            { \"Server Config ID\", \"gquic.tag.scid\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"An opaque, 16-byte identifier for this server config\", HFILL }\n        },\n        { &hf_gquic_tag_pubs,\n            { \"Public value\", \"gquic.tag.pubs\",\n              FT_UINT24, BASE_DEC_HEX, NULL, 0x0,\n              \"A list of public values, 24-bit, little-endian length prefixed\", HFILL }\n        },\n        { &hf_gquic_tag_kexs,\n            { \"Key exchange algorithms\", \"gquic.tag.kexs\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"A list of tags, in preference order, specifying the key exchange algorithms that the server supports\", HFILL }\n        },\n        { &hf_gquic_tag_obit,\n            { \"Server orbit\", \"gquic.tag.obit\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_expy,\n            { \"Expiry\", \"gquic.tag.expy\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"a 64-bit expiry time for the server config in UNIX epoch seconds\", HFILL }\n        },\n        { &hf_gquic_tag_nonc,\n            { \"Client nonce\", \"gquic.tag.nonc\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"32 bytes consisting of 4 bytes of timestamp (big-endian, UNIX epoch seconds), 8 bytes of server orbit and 20 bytes of random data\", HFILL }\n        },\n        { &hf_gquic_tag_mspc,\n            { \"Max streams per connection\", \"gquic.tag.mspc\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_tcid,\n            { \"Connection ID truncation\", \"gquic.tag.tcid\",\n              FT_UINT32, BASE_DEC_HEX, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_srbf,\n            { \"Socket receive buffer\", \"gquic.tag.srbf\",\n              FT_UINT32, BASE_DEC_HEX, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_icsl,\n            { \"Idle connection state\", \"gquic.tag.icsl\",\n              FT_UINT32, BASE_DEC_HEX, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_scls,\n            { \"Silently close on timeout\", \"gquic.tag.scls\",\n              FT_UINT32, BASE_DEC_HEX, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_copt,\n            { \"Connection options\", \"gquic.tag.copt\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_ccrt,\n            { \"Cached certificates\", \"gquic.tag.ccrt\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_irtt,\n            { \"Estimated initial RTT\", \"gquic.tag.irtt\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"in us\", HFILL }\n        },\n        { &hf_gquic_tag_cfcw,\n            { \"Initial session/connection\", \"gquic.tag.cfcw\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_sfcw,\n            { \"Initial stream flow control\", \"gquic.tag.sfcw\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cetv,\n            { \"Client encrypted tag-value\", \"gquic.tag.cetv\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_xlct,\n            { \"Expected leaf certificate\", \"gquic.tag.xlct\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_nonp,\n            { \"Client Proof nonce\", \"gquic.tag.nonp\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_csct,\n            { \"Signed cert timestamp\", \"gquic.tag.csct\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_ctim,\n            { \"Client Timestamp\", \"gquic.tag.ctim\",\n              FT_ABSOLUTE_TIME, ABSOLUTE_TIME_UTC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_rnon,\n            { \"Public reset nonce proof\", \"gquic.tag.rnon\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_rseq,\n            { \"Rejected Packet Number\", \"gquic.tag.rseq\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"a 64-bit packet number\", HFILL }\n        },\n        { &hf_gquic_tag_cadr_addr_type,\n            { \"Client IP Address Type\", \"gquic.tag.caddr.addr.type\",\n              FT_UINT16, BASE_DEC, VALS(cadr_type_vals), 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cadr_addr_ipv4,\n            { \"Client IP Address\", \"gquic.tag.caddr.addr.ipv4\",\n              FT_IPv4, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cadr_addr_ipv6,\n            { \"Client IP Address\", \"gquic.tag.caddr.addr.ipv6\",\n              FT_IPv6, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cadr_addr,\n            { \"Client IP Address\", \"gquic.tag.caddr.addr\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cadr_port,\n            { \"Client Port (Source)\", \"gquic.tag.caddr.port\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_mids,\n            { \"Max incoming dynamic streams\", \"gquic.tag.mids\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_fhol,\n            { \"Force Head Of Line blocking\", \"gquic.tag.fhol\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_sttl,\n            { \"Server Config TTL\", \"gquic.tag.sttl\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_smhl,\n            { \"Support Max Header List (size)\", \"gquic.tag.smhl\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_tbkp,\n            { \"Token Binding Key Params.\", \"gquic.tag.tbkp\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_mad0,\n            { \"Max Ack Delay\", \"gquic.tag.mad0\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n\n        { &hf_gquic_tag_unknown,\n            { \"Unknown tag\", \"gquic.tag.unknown\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_padding,\n            { \"Padding\", \"gquic.padding\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_stream_data,\n            { \"Stream Data\", \"gquic.stream_data\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_payload,\n            { \"Payload\", \"gquic.payload\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"(Google) QUIC Payload..\", HFILL }\n        },\n    };\n\n\n    static gint *ett[] = {\n        &ett_gquic,\n        &ett_gquic_puflags,\n        &ett_gquic_prflags,\n        &ett_gquic_ft,\n        &ett_gquic_ftflags,\n        &ett_gquic_tag_value\n    };\n\n    static ei_register_info ei[] = {\n        { &ei_gquic_tag_undecoded, { \"gquic.tag.undecoded\", PI_UNDECODED, PI_NOTE, \"Dissector for (Google)QUIC Tag code not implemented, Contact Wireshark developers if you want this supported\", EXPFILL }},\n        { &ei_gquic_tag_length, { \"gquic.tag.length.truncated\", PI_MALFORMED, PI_NOTE, \"Truncated Tag Length...\", EXPFILL }},\n        { &ei_gquic_tag_unknown, { \"gquic.tag.unknown.data\", PI_UNDECODED, PI_NOTE, \"Unknown Data\", EXPFILL }},\n        { &ei_gquic_version_invalid, { \"gquic.version.invalid\", PI_MALFORMED, PI_ERROR, \"Invalid Version\", EXPFILL }},\n        { &ei_gquic_invalid_parameter, { \"gquic.invalid.parameter\", PI_MALFORMED, PI_ERROR, \"Invalid Parameter\", EXPFILL }},\n        { &ei_gquic_length_invalid, { \"gquic.length.invalid\", PI_PROTOCOL, PI_WARN, \"Invalid Length\", EXPFILL }}\n    };\n\n    expert_module_t *expert_gquic;\n\n    proto_gquic = proto_register_protocol(\"GQUIC (Google Quick UDP Internet Connections)\", \"GQUIC\", \"gquic\");\n\n    proto_register_field_array(proto_gquic, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n\n    gquic_module = prefs_register_protocol(proto_gquic, NULL);\n\n    prefs_register_bool_preference(gquic_module, \"debug.quic\",\n                       \"Force decode of all (Google) QUIC Payload\",\n                       \"Help for debug...\",\n                       &g_gquic_debug);\n\n    expert_gquic = expert_register_protocol(proto_gquic);\n    expert_register_field_array(expert_gquic, ei, array_length(ei));\n\n    gquic_handle = register_dissector(\"gquic\", dissect_gquic, proto_gquic);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -738,7 +738,8 @@\n         { &ei_gquic_tag_length, { \"gquic.tag.length.truncated\", PI_MALFORMED, PI_NOTE, \"Truncated Tag Length...\", EXPFILL }},\n         { &ei_gquic_tag_unknown, { \"gquic.tag.unknown.data\", PI_UNDECODED, PI_NOTE, \"Unknown Data\", EXPFILL }},\n         { &ei_gquic_version_invalid, { \"gquic.version.invalid\", PI_MALFORMED, PI_ERROR, \"Invalid Version\", EXPFILL }},\n-        { &ei_gquic_invalid_parameter, { \"gquic.invalid.parameter\", PI_MALFORMED, PI_ERROR, \"Invalid Parameter\", EXPFILL }}\n+        { &ei_gquic_invalid_parameter, { \"gquic.invalid.parameter\", PI_MALFORMED, PI_ERROR, \"Invalid Parameter\", EXPFILL }},\n+        { &ei_gquic_length_invalid, { \"gquic.length.invalid\", PI_PROTOCOL, PI_WARN, \"Invalid Length\", EXPFILL }}\n     };\n \n     expert_module_t *expert_gquic;",
        "diff_line_info": {
            "deleted_lines": [
                "        { &ei_gquic_invalid_parameter, { \"gquic.invalid.parameter\", PI_MALFORMED, PI_ERROR, \"Invalid Parameter\", EXPFILL }}"
            ],
            "added_lines": [
                "        { &ei_gquic_invalid_parameter, { \"gquic.invalid.parameter\", PI_MALFORMED, PI_ERROR, \"Invalid Parameter\", EXPFILL }},",
                "        { &ei_gquic_length_invalid, { \"gquic.length.invalid\", PI_PROTOCOL, PI_WARN, \"Invalid Length\", EXPFILL }}"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-28030",
        "func_name": "wireshark/dissect_gquic_tag",
        "description": "In Wireshark 3.2.0 to 3.2.7, the GQUIC dissector could crash. This was addressed in epan/dissectors/packet-gquic.c by correcting the implementation of offset advancement.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/b287e7165e8aa89cde6ae37e7c257c5d87d16b9b",
        "commit_title": "GQUIC: make sure our tag offset advances.",
        "commit_text": " Make sure gquic tag offset advances so that we don't infinitely loop. ",
        "func_before": "static guint32\ndissect_gquic_tag(tvbuff_t *tvb, packet_info *pinfo, proto_tree *gquic_tree, guint offset, guint32 tag_number){\n    guint32 tag_offset_start = offset + tag_number*4*2;\n    guint32 tag_offset = 0, total_tag_len = 0;\n    gint32 tag_len;\n\n    while(tag_number){\n        proto_tree *tag_tree, *ti_len, *ti_tag, *ti_type;\n        guint32 offset_end, tag;\n        const guint8* tag_str;\n\n        ti_tag = proto_tree_add_item(gquic_tree, hf_gquic_tags, tvb, offset, 8, ENC_NA);\n        tag_tree = proto_item_add_subtree(ti_tag, ett_gquic_tag_value);\n        ti_type = proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_type, tvb, offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n        tag = tvb_get_ntohl(tvb, offset);\n        proto_item_append_text(ti_type, \" (%s)\", val_to_str(tag, tag_vals, \"Unknown\"));\n        proto_item_append_text(ti_tag, \": %s (%s)\", tag_str, val_to_str(tag, tag_vals, \"Unknown\"));\n        offset += 4;\n\n        proto_tree_add_item(tag_tree, hf_gquic_tag_offset_end, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset_end = tvb_get_guint32(tvb, offset, ENC_LITTLE_ENDIAN);\n\n        tag_len = offset_end - tag_offset;\n        total_tag_len += tag_len;\n        ti_len = proto_tree_add_uint(tag_tree, hf_gquic_tag_length, tvb, offset, 4, tag_len);\n        proto_item_append_text(ti_tag, \" (l=%u)\", tag_len);\n        proto_item_set_generated(ti_len);\n        offset += 4;\n\n        /* Fix issue with CRT.. (Fragmentation ?) */\n        if( tag_len > tvb_reported_length_remaining(tvb, tag_offset_start + tag_offset)){\n            tag_len = tvb_reported_length_remaining(tvb, tag_offset_start + tag_offset);\n            offset_end = tag_offset + tag_len;\n            expert_add_info(pinfo, ti_len, &ei_gquic_tag_length);\n        }\n\n        proto_tree_add_item(tag_tree, hf_gquic_tag_value, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n\n        switch(tag){\n            case TAG_PAD:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_pad, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_SNI:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_sni, tvb, tag_offset_start + tag_offset, tag_len, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += tag_len;\n            break;\n            case TAG_VER:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_ver, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += 4;\n            break;\n            case TAG_CCS:\n                while(offset_end - tag_offset >= 8){\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_ccs, tvb, tag_offset_start + tag_offset, 8, ENC_NA);\n                    tag_offset += 8;\n                }\n            break;\n            case TAG_PDMD:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_pdmd, tvb, tag_offset_start + tag_offset, tag_len, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += tag_len;\n            break;\n            case TAG_UAID:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_uaid, tvb, tag_offset_start + tag_offset, tag_len, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += tag_len;\n            break;\n            case TAG_STK:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_stk, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_SNO:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_sno, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_PROF:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_prof, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_SCFG:{\n                guint32 scfg_tag_number;\n\n                proto_tree_add_item(tag_tree, hf_gquic_tag_scfg, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                tag_offset += 4;\n                proto_tree_add_item(tag_tree, hf_gquic_tag_scfg_number, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                scfg_tag_number = tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n\n                dissect_gquic_tag(tvb, pinfo, tag_tree, tag_offset_start + tag_offset, scfg_tag_number);\n                tag_offset += tag_len - 4 - 4;\n                }\n            break;\n            case TAG_RREJ:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_rrej, tvb, tag_offset_start + tag_offset, 4,  ENC_LITTLE_ENDIAN);\n                    proto_item_append_text(ti_tag, \", Code %s\", val_to_str_ext(tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN), &handshake_failure_reason_vals_ext, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_CRT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_crt, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_AEAD:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree *ti_aead;\n                    ti_aead = proto_tree_add_item(tag_tree, hf_gquic_tag_aead, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    proto_item_append_text(ti_aead, \" (%s)\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_aead_vals, \"Unknown\"));\n                    proto_item_append_text(ti_tag, \", %s\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_aead_vals, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_SCID:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_scid, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_PUBS:\n                /*TODO FIX: 24 Length + Pubs key?.. ! */\n                proto_tree_add_item(tag_tree, hf_gquic_tag_pubs, tvb, tag_offset_start + tag_offset, 2, ENC_LITTLE_ENDIAN);\n                tag_offset += 2;\n                while(offset_end - tag_offset >= 3){\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_pubs, tvb, tag_offset_start + tag_offset, 3, ENC_LITTLE_ENDIAN);\n                    tag_offset += 3;\n                }\n            break;\n            case TAG_KEXS:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree *ti_kexs;\n                    ti_kexs = proto_tree_add_item(tag_tree, hf_gquic_tag_kexs, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    proto_item_append_text(ti_kexs, \" (%s)\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_kexs_vals, \"Unknown\"));\n                    proto_item_append_text(ti_tag, \", %s\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_kexs_vals, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_OBIT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_obit, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_EXPY:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_expy, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN);\n                tag_offset += 8;\n            break;\n            case TAG_NONC:\n                /*TODO: Enhance display: 32 bytes consisting of 4 bytes of timestamp (big-endian, UNIX epoch seconds), 8 bytes of server orbit and 20 bytes of random data. */\n                proto_tree_add_item(tag_tree, hf_gquic_tag_nonc, tvb, tag_offset_start + tag_offset, 32, ENC_NA);\n                tag_offset += 32;\n            break;\n            case TAG_MSPC:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_mspc, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_TCID:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_tcid, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n            break;\n            case TAG_SRBF:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_srbf, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n            break;\n            case TAG_ICSL:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_icsl, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n            break;\n            case TAG_SCLS:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_scls, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n            break;\n            case TAG_COPT:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_copt, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_CCRT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_ccrt, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_IRTT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_irtt, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_CFCW:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_cfcw, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_SFCW:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_sfcw, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_CETV:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_cetv, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_XLCT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_xlct, tvb, tag_offset_start + tag_offset, 8, ENC_NA);\n                tag_offset += 8;\n            break;\n            case TAG_NONP:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_nonp, tvb, tag_offset_start + tag_offset, 32, ENC_NA);\n                tag_offset += 32;\n            break;\n            case TAG_CSCT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_csct, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_CTIM:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_ctim, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN|ENC_TIME_SECS_NSECS);\n                tag_offset += 8;\n            break;\n            case TAG_RNON: /* Public Reset Tag */\n                proto_tree_add_item(tag_tree, hf_gquic_tag_rnon, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN);\n                tag_offset += 8;\n            break;\n            case TAG_RSEQ: /* Public Reset Tag */\n                proto_tree_add_item(tag_tree, hf_gquic_tag_rseq, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN);\n                tag_offset += 8;\n            break;\n            case TAG_CADR: /* Public Reset Tag */{\n                guint32 addr_type;\n                proto_tree_add_item_ret_uint(tag_tree, hf_gquic_tag_cadr_addr_type, tvb, tag_offset_start + tag_offset, 2, ENC_LITTLE_ENDIAN, &addr_type);\n                tag_offset += 2;\n                switch(addr_type){\n                    case 2: /* IPv4 */\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_cadr_addr_ipv4, tvb, tag_offset_start + tag_offset, 4, ENC_NA);\n                    tag_offset += 4;\n                    break;\n                    case 10: /* IPv6 */\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_cadr_addr_ipv6, tvb, tag_offset_start + tag_offset, 16, ENC_NA);\n                    tag_offset += 16;\n                    break;\n                    default: /* Unknown */\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_cadr_addr, tvb, tag_offset_start + tag_offset, tag_len - 2 - 2, ENC_NA);\n                    tag_offset += tag_len + 2 + 2 ;\n                    break;\n                }\n                proto_tree_add_item(tag_tree, hf_gquic_tag_cadr_port, tvb, tag_offset_start + tag_offset, 2, ENC_LITTLE_ENDIAN);\n                tag_offset += 2;\n            }\n            break;\n            case TAG_MIDS:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_mids, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_FHOL:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_fhol, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_STTL:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_sttl, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN);\n                tag_offset += 8;\n            break;\n            case TAG_SMHL:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_smhl, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_TBKP:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_tbkp, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += 4;\n            break;\n            case TAG_MAD0:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_mad0, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            default:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_unknown, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                expert_add_info_format(pinfo, ti_tag, &ei_gquic_tag_undecoded,\n                                 \"Dissector for (Google) QUIC Tag\"\n                                 \" %s (%s) code not implemented, Contact\"\n                                 \" Wireshark developers if you want this supported\", tvb_get_string_enc(wmem_packet_scope(), tvb, offset-8, 4, ENC_ASCII|ENC_NA), val_to_str(tag, tag_vals, \"Unknown\"));\n                tag_offset += tag_len;\n            break;\n        }\n        if(tag_offset != offset_end){\n            /* Wrong Tag len... */\n            proto_tree_add_expert(tag_tree, pinfo, &ei_gquic_tag_unknown, tvb, tag_offset_start + tag_offset, tag_len);\n            tag_offset = offset_end;\n        }\n\n        tag_number--;\n    }\n    return offset + total_tag_len;\n\n}",
        "func": "static guint32\ndissect_gquic_tag(tvbuff_t *tvb, packet_info *pinfo, proto_tree *gquic_tree, guint offset, guint32 tag_number){\n    guint32 tag_offset_start = offset + tag_number*4*2;\n    guint32 tag_offset = 0, total_tag_len = 0;\n    gint32 tag_len;\n\n    while(tag_number){\n        proto_tree *tag_tree, *ti_len, *ti_tag, *ti_type;\n        guint32 offset_end, tag;\n        const guint8* tag_str;\n\n        ti_tag = proto_tree_add_item(gquic_tree, hf_gquic_tags, tvb, offset, 8, ENC_NA);\n        tag_tree = proto_item_add_subtree(ti_tag, ett_gquic_tag_value);\n        ti_type = proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_type, tvb, offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n        tag = tvb_get_ntohl(tvb, offset);\n        proto_item_append_text(ti_type, \" (%s)\", val_to_str(tag, tag_vals, \"Unknown\"));\n        proto_item_append_text(ti_tag, \": %s (%s)\", tag_str, val_to_str(tag, tag_vals, \"Unknown\"));\n        offset += 4;\n\n        proto_tree_add_item(tag_tree, hf_gquic_tag_offset_end, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset_end = tvb_get_guint32(tvb, offset, ENC_LITTLE_ENDIAN);\n\n        tag_len = offset_end - tag_offset;\n        total_tag_len += tag_len;\n        ti_len = proto_tree_add_uint(tag_tree, hf_gquic_tag_length, tvb, offset, 4, tag_len);\n        proto_item_append_text(ti_tag, \" (l=%u)\", tag_len);\n        proto_item_set_generated(ti_len);\n        offset += 4;\n\n        /* Fix issue with CRT.. (Fragmentation ?) */\n        if( tag_len > tvb_reported_length_remaining(tvb, tag_offset_start + tag_offset)){\n            tag_len = tvb_reported_length_remaining(tvb, tag_offset_start + tag_offset);\n            offset_end = tag_offset + tag_len;\n            expert_add_info(pinfo, ti_len, &ei_gquic_tag_length);\n        }\n\n        proto_tree_add_item(tag_tree, hf_gquic_tag_value, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n\n        switch(tag){\n            case TAG_PAD:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_pad, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_SNI:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_sni, tvb, tag_offset_start + tag_offset, tag_len, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += tag_len;\n            break;\n            case TAG_VER:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_ver, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += 4;\n            break;\n            case TAG_CCS:\n                while(offset_end - tag_offset >= 8){\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_ccs, tvb, tag_offset_start + tag_offset, 8, ENC_NA);\n                    tag_offset += 8;\n                }\n            break;\n            case TAG_PDMD:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_pdmd, tvb, tag_offset_start + tag_offset, tag_len, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += tag_len;\n            break;\n            case TAG_UAID:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_uaid, tvb, tag_offset_start + tag_offset, tag_len, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += tag_len;\n            break;\n            case TAG_STK:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_stk, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_SNO:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_sno, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_PROF:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_prof, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_SCFG:{\n                guint32 scfg_tag_number;\n\n                proto_tree_add_item(tag_tree, hf_gquic_tag_scfg, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                tag_offset += 4;\n                proto_tree_add_item(tag_tree, hf_gquic_tag_scfg_number, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                scfg_tag_number = tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n\n                dissect_gquic_tag(tvb, pinfo, tag_tree, tag_offset_start + tag_offset, scfg_tag_number);\n                tag_offset += tag_len - 4 - 4;\n                }\n            break;\n            case TAG_RREJ:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_rrej, tvb, tag_offset_start + tag_offset, 4,  ENC_LITTLE_ENDIAN);\n                    proto_item_append_text(ti_tag, \", Code %s\", val_to_str_ext(tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN), &handshake_failure_reason_vals_ext, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_CRT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_crt, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_AEAD:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree *ti_aead;\n                    ti_aead = proto_tree_add_item(tag_tree, hf_gquic_tag_aead, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    proto_item_append_text(ti_aead, \" (%s)\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_aead_vals, \"Unknown\"));\n                    proto_item_append_text(ti_tag, \", %s\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_aead_vals, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_SCID:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_scid, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_PUBS:\n                /*TODO FIX: 24 Length + Pubs key?.. ! */\n                proto_tree_add_item(tag_tree, hf_gquic_tag_pubs, tvb, tag_offset_start + tag_offset, 2, ENC_LITTLE_ENDIAN);\n                tag_offset += 2;\n                while(offset_end - tag_offset >= 3){\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_pubs, tvb, tag_offset_start + tag_offset, 3, ENC_LITTLE_ENDIAN);\n                    tag_offset += 3;\n                }\n            break;\n            case TAG_KEXS:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree *ti_kexs;\n                    ti_kexs = proto_tree_add_item(tag_tree, hf_gquic_tag_kexs, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    proto_item_append_text(ti_kexs, \" (%s)\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_kexs_vals, \"Unknown\"));\n                    proto_item_append_text(ti_tag, \", %s\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_kexs_vals, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_OBIT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_obit, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_EXPY:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_expy, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN);\n                tag_offset += 8;\n            break;\n            case TAG_NONC:\n                /*TODO: Enhance display: 32 bytes consisting of 4 bytes of timestamp (big-endian, UNIX epoch seconds), 8 bytes of server orbit and 20 bytes of random data. */\n                proto_tree_add_item(tag_tree, hf_gquic_tag_nonc, tvb, tag_offset_start + tag_offset, 32, ENC_NA);\n                tag_offset += 32;\n            break;\n            case TAG_MSPC:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_mspc, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_TCID:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_tcid, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n            break;\n            case TAG_SRBF:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_srbf, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n            break;\n            case TAG_ICSL:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_icsl, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n            break;\n            case TAG_SCLS:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_scls, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n            break;\n            case TAG_COPT:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_copt, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_CCRT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_ccrt, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_IRTT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_irtt, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_CFCW:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_cfcw, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_SFCW:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_sfcw, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_CETV:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_cetv, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_XLCT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_xlct, tvb, tag_offset_start + tag_offset, 8, ENC_NA);\n                tag_offset += 8;\n            break;\n            case TAG_NONP:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_nonp, tvb, tag_offset_start + tag_offset, 32, ENC_NA);\n                tag_offset += 32;\n            break;\n            case TAG_CSCT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_csct, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_CTIM:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_ctim, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN|ENC_TIME_SECS_NSECS);\n                tag_offset += 8;\n            break;\n            case TAG_RNON: /* Public Reset Tag */\n                proto_tree_add_item(tag_tree, hf_gquic_tag_rnon, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN);\n                tag_offset += 8;\n            break;\n            case TAG_RSEQ: /* Public Reset Tag */\n                proto_tree_add_item(tag_tree, hf_gquic_tag_rseq, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN);\n                tag_offset += 8;\n            break;\n            case TAG_CADR: /* Public Reset Tag */{\n                guint32 addr_type;\n                proto_tree_add_item_ret_uint(tag_tree, hf_gquic_tag_cadr_addr_type, tvb, tag_offset_start + tag_offset, 2, ENC_LITTLE_ENDIAN, &addr_type);\n                tag_offset += 2;\n                switch(addr_type){\n                    case 2: /* IPv4 */\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_cadr_addr_ipv4, tvb, tag_offset_start + tag_offset, 4, ENC_NA);\n                    tag_offset += 4;\n                    break;\n                    case 10: /* IPv6 */\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_cadr_addr_ipv6, tvb, tag_offset_start + tag_offset, 16, ENC_NA);\n                    tag_offset += 16;\n                    break;\n                    default: /* Unknown */\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_cadr_addr, tvb, tag_offset_start + tag_offset, tag_len - 2 - 2, ENC_NA);\n                    tag_offset += tag_len + 2 + 2 ;\n                    break;\n                }\n                proto_tree_add_item(tag_tree, hf_gquic_tag_cadr_port, tvb, tag_offset_start + tag_offset, 2, ENC_LITTLE_ENDIAN);\n                tag_offset += 2;\n            }\n            break;\n            case TAG_MIDS:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_mids, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_FHOL:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_fhol, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_STTL:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_sttl, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN);\n                tag_offset += 8;\n            break;\n            case TAG_SMHL:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_smhl, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_TBKP:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_tbkp, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += 4;\n            break;\n            case TAG_MAD0:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_mad0, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            default:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_unknown, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                expert_add_info_format(pinfo, ti_tag, &ei_gquic_tag_undecoded,\n                                 \"Dissector for (Google) QUIC Tag\"\n                                 \" %s (%s) code not implemented, Contact\"\n                                 \" Wireshark developers if you want this supported\", tvb_get_string_enc(wmem_packet_scope(), tvb, offset-8, 4, ENC_ASCII|ENC_NA), val_to_str(tag, tag_vals, \"Unknown\"));\n                goto end;\n            break;\n        }\n        if(tag_offset != offset_end){\n            /* Wrong Tag len... */\n            proto_tree_add_expert(tag_tree, pinfo, &ei_gquic_tag_unknown, tvb, tag_offset_start + tag_offset, tag_len);\n            tag_offset = offset_end;\n        }\n\n        tag_number--;\n    }\n\n    end:\n    if (offset + total_tag_len <= offset) {\n        expert_add_info_format(pinfo, gquic_tree, &ei_gquic_length_invalid,\n                                \"Invalid total tag length: %u\", total_tag_len);\n        return offset + tvb_reported_length_remaining(tvb, offset);\n    }\n    return offset + total_tag_len;\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -278,7 +278,7 @@\n                                  \"Dissector for (Google) QUIC Tag\"\n                                  \" %s (%s) code not implemented, Contact\"\n                                  \" Wireshark developers if you want this supported\", tvb_get_string_enc(wmem_packet_scope(), tvb, offset-8, 4, ENC_ASCII|ENC_NA), val_to_str(tag, tag_vals, \"Unknown\"));\n-                tag_offset += tag_len;\n+                goto end;\n             break;\n         }\n         if(tag_offset != offset_end){\n@@ -289,6 +289,13 @@\n \n         tag_number--;\n     }\n+\n+    end:\n+    if (offset + total_tag_len <= offset) {\n+        expert_add_info_format(pinfo, gquic_tree, &ei_gquic_length_invalid,\n+                                \"Invalid total tag length: %u\", total_tag_len);\n+        return offset + tvb_reported_length_remaining(tvb, offset);\n+    }\n     return offset + total_tag_len;\n \n }",
        "diff_line_info": {
            "deleted_lines": [
                "                tag_offset += tag_len;"
            ],
            "added_lines": [
                "                goto end;",
                "",
                "    end:",
                "    if (offset + total_tag_len <= offset) {",
                "        expert_add_info_format(pinfo, gquic_tree, &ei_gquic_length_invalid,",
                "                                \"Invalid total tag length: %u\", total_tag_len);",
                "        return offset + tvb_reported_length_remaining(tvb, offset);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-1573",
        "func_name": "torvalds/linux/sctp_make_init_ack",
        "description": "net/sctp/sm_make_chunk.c in the Linux kernel before 2.6.34, when addip_enable and auth_enable are used, does not consider the amount of zero padding during calculation of chunk lengths for (1) INIT and (2) INIT ACK chunks, which allows remote attackers to cause a denial of service (OOPS) via crafted packet data.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=a8170c35e738d62e9919ce5b109cf4ed66e95bde",
        "commit_title": "When calculating the INIT/INIT-ACK chunk length, we should not",
        "commit_text": "only account the length of parameters, but also the parameters zero padding length, such as AUTH HMACS parameter and CHUNKS parameter. Without the parameters zero padding length we may get following oops.  skb_over_panic: text:ce2068d2 len:130 put:6 head:cac3fe00 data:cac3fe00 tail:0xcac3fe82 end:0xcac3fe80 dev:<NULL> ------------[ cut here ]------------ kernel BUG at net/core/skbuff.c:127! invalid opcode: 0000 [#2] SMP last sysfs file: /sys/module/aes_generic/initstate Modules linked in: authenc ......  Pid: 4102, comm: sctp_darn Tainted: G      D    2.6.34-rc2 #6 EIP: 0060:[<c0607630>] EFLAGS: 00010282 CPU: 0 EIP is at skb_over_panic+0x37/0x3e EAX: 00000078 EBX: c07c024b ECX: c07c02b9 EDX: cb607b78 ESI: 00000000 EDI: cac3fe7a EBP: 00000002 ESP: cb607b74  DS: 007b ES: 007b FS: 00d8 GS: 0033 SS: 0068 Process sctp_darn (pid: 4102, ti=cb607000 task=cabdc990 task.ti=cb607000) Stack:  c07c02b9 ce2068d2 00000082 00000006 cac3fe00 cac3fe00 cac3fe82 cac3fe80 <0> c07c024b cac3fe7c cac3fe7a c0608dec ca986e80 ce2068d2 00000006 0000007a <0> cb8120ca ca986e80 cb812000 00000003 cb8120c4 ce208a25 cb8120ca cadd9400 Call Trace:  [<ce2068d2>] ? sctp_addto_chunk+0x45/0x85 [sctp]  [<c0608dec>] ? skb_put+0x2e/0x32  [<ce2068d2>] ? sctp_addto_chunk+0x45/0x85 [sctp]  [<ce208a25>] ? sctp_make_init+0x279/0x28c [sctp]  [<c0686a92>] ? apic_timer_interrupt+0x2a/0x30  [<ce1fdc0b>] ? sctp_sf_do_prm_asoc+0x2b/0x7b [sctp]  [<ce202823>] ? sctp_do_sm+0xa0/0x14a [sctp]  [<ce2133b9>] ? sctp_pname+0x0/0x14 [sctp]  [<ce211d72>] ? sctp_primitive_ASSOCIATE+0x2b/0x31 [sctp]  [<ce20f3cf>] ? sctp_sendmsg+0x7a0/0x9eb [sctp]  [<c064eb1e>] ? inet_sendmsg+0x3b/0x43  [<c04244b7>] ? task_tick_fair+0x2d/0xd9  [<c06031e1>] ? sock_sendmsg+0xa7/0xc1  [<c0416afe>] ? smp_apic_timer_interrupt+0x6b/0x75  [<c0425123>] ? dequeue_task_fair+0x34/0x19b  [<c0446abb>] ? sched_clock_local+0x17/0x11e  [<c052ea87>] ? _copy_from_user+0x2b/0x10c  [<c060ab3a>] ? verify_iovec+0x3c/0x6a  [<c06035ca>] ? sys_sendmsg+0x186/0x1e2  [<c042176b>] ? __wake_up_common+0x34/0x5b  [<c04240c2>] ? __wake_up+0x2c/0x3b  [<c057e35c>] ? tty_wakeup+0x43/0x47  [<c04430f2>] ? remove_wait_queue+0x16/0x24  [<c0580c94>] ? n_tty_read+0x5b8/0x65e  [<c042be02>] ? default_wake_function+0x0/0x8  [<c0604e0e>] ? sys_socketcall+0x17f/0x1cd  [<c040264c>] ? sysenter_do_call+0x12/0x22 Code: 0f 45 de 53 ff b0 98 00 00 00 ff b0 94 ...... EIP: [<c0607630>] skb_over_panic+0x37/0x3e SS:ESP 0068:cb607b74  To reproduce:  # modprobe sctp # echo 1 > /proc/sys/net/sctp/addip_enable # echo 1 > /proc/sys/net/sctp/auth_enable # sctp_test -H 3ffe:501:ffff:100:20c:29ff:fe4d:f37e -P 800 -l # sctp_darn -H 3ffe:501:ffff:100:20c:29ff:fe4d:f37e -P 900 -h 192.168.0.21 -p 800 -I -s -t sctp_darn ready to send... 3ffe:501:ffff:100:20c:29ff:fe4d:f37e:900-192.168.0.21:800 Interactive mode> bindx-add=192.168.0.21 3ffe:501:ffff:100:20c:29ff:fe4d:f37e:900-192.168.0.21:800 Interactive mode> bindx-add=192.168.1.21 3ffe:501:ffff:100:20c:29ff:fe4d:f37e:900-192.168.0.21:800 Interactive mode> snd=10  ------------------------------------------------------------------ eth0 has addresses: 3ffe:501:ffff:100:20c:29ff:fe4d:f37e and 192.168.0.21 eth1 has addresses: 192.168.1.21 ------------------------------------------------------------------  ",
        "func_before": "struct sctp_chunk *sctp_make_init_ack(const struct sctp_association *asoc,\n\t\t\t\t const struct sctp_chunk *chunk,\n\t\t\t\t gfp_t gfp, int unkparam_len)\n{\n\tsctp_inithdr_t initack;\n\tstruct sctp_chunk *retval;\n\tunion sctp_params addrs;\n\tstruct sctp_sock *sp;\n\tint addrs_len;\n\tsctp_cookie_param_t *cookie;\n\tint cookie_len;\n\tsize_t chunksize;\n\tsctp_adaptation_ind_param_t aiparam;\n\tsctp_supported_ext_param_t ext_param;\n\tint num_ext = 0;\n\t__u8 extensions[3];\n\tsctp_paramhdr_t *auth_chunks = NULL,\n\t\t\t*auth_hmacs = NULL,\n\t\t\t*auth_random = NULL;\n\n\tretval = NULL;\n\n\t/* Note: there may be no addresses to embed. */\n\taddrs = sctp_bind_addrs_to_raw(&asoc->base.bind_addr, &addrs_len, gfp);\n\n\tinitack.init_tag\t        = htonl(asoc->c.my_vtag);\n\tinitack.a_rwnd\t\t\t= htonl(asoc->rwnd);\n\tinitack.num_outbound_streams\t= htons(asoc->c.sinit_num_ostreams);\n\tinitack.num_inbound_streams\t= htons(asoc->c.sinit_max_instreams);\n\tinitack.initial_tsn\t\t= htonl(asoc->c.initial_tsn);\n\n\t/* FIXME:  We really ought to build the cookie right\n\t * into the packet instead of allocating more fresh memory.\n\t */\n\tcookie = sctp_pack_cookie(asoc->ep, asoc, chunk, &cookie_len,\n\t\t\t\t  addrs.v, addrs_len);\n\tif (!cookie)\n\t\tgoto nomem_cookie;\n\n\t/* Calculate the total size of allocation, include the reserved\n\t * space for reporting unknown parameters if it is specified.\n\t */\n\tsp = sctp_sk(asoc->base.sk);\n\tchunksize = sizeof(initack) + addrs_len + cookie_len + unkparam_len;\n\n\t/* Tell peer that we'll do ECN only if peer advertised such cap.  */\n\tif (asoc->peer.ecn_capable)\n\t\tchunksize += sizeof(ecap_param);\n\n\tif (asoc->peer.prsctp_capable)\n\t\tchunksize += sizeof(prsctp_param);\n\n\tif (asoc->peer.asconf_capable) {\n\t\textensions[num_ext] = SCTP_CID_ASCONF;\n\t\textensions[num_ext+1] = SCTP_CID_ASCONF_ACK;\n\t\tnum_ext += 2;\n\t}\n\n\tif (sp->adaptation_ind)\n\t\tchunksize += sizeof(aiparam);\n\n\tif (asoc->peer.auth_capable) {\n\t\tauth_random = (sctp_paramhdr_t *)asoc->c.auth_random;\n\t\tchunksize += ntohs(auth_random->length);\n\n\t\tauth_hmacs = (sctp_paramhdr_t *)asoc->c.auth_hmacs;\n\t\tif (auth_hmacs->length)\n\t\t\tchunksize += ntohs(auth_hmacs->length);\n\t\telse\n\t\t\tauth_hmacs = NULL;\n\n\t\tauth_chunks = (sctp_paramhdr_t *)asoc->c.auth_chunks;\n\t\tif (auth_chunks->length)\n\t\t\tchunksize += ntohs(auth_chunks->length);\n\t\telse\n\t\t\tauth_chunks = NULL;\n\n\t\textensions[num_ext] = SCTP_CID_AUTH;\n\t\tnum_ext += 1;\n\t}\n\n\tif (num_ext)\n\t\tchunksize += sizeof(sctp_supported_ext_param_t) + num_ext;\n\n\t/* Now allocate and fill out the chunk.  */\n\tretval = sctp_make_chunk(asoc, SCTP_CID_INIT_ACK, 0, chunksize);\n\tif (!retval)\n\t\tgoto nomem_chunk;\n\n\t/* Per the advice in RFC 2960 6.4, send this reply to\n\t * the source of the INIT packet.\n\t */\n\tretval->transport = chunk->transport;\n\tretval->subh.init_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(initack), &initack);\n\tretval->param_hdr.v = sctp_addto_chunk(retval, addrs_len, addrs.v);\n\tsctp_addto_chunk(retval, cookie_len, cookie);\n\tif (asoc->peer.ecn_capable)\n\t\tsctp_addto_chunk(retval, sizeof(ecap_param), &ecap_param);\n\tif (num_ext) {\n\t\text_param.param_hdr.type = SCTP_PARAM_SUPPORTED_EXT;\n\t\text_param.param_hdr.length =\n\t\t\t    htons(sizeof(sctp_supported_ext_param_t) + num_ext);\n\t\tsctp_addto_chunk(retval, sizeof(sctp_supported_ext_param_t),\n\t\t\t\t &ext_param);\n\t\tsctp_addto_param(retval, num_ext, extensions);\n\t}\n\tif (asoc->peer.prsctp_capable)\n\t\tsctp_addto_chunk(retval, sizeof(prsctp_param), &prsctp_param);\n\n\tif (sp->adaptation_ind) {\n\t\taiparam.param_hdr.type = SCTP_PARAM_ADAPTATION_LAYER_IND;\n\t\taiparam.param_hdr.length = htons(sizeof(aiparam));\n\t\taiparam.adaptation_ind = htonl(sp->adaptation_ind);\n\t\tsctp_addto_chunk(retval, sizeof(aiparam), &aiparam);\n\t}\n\n\tif (asoc->peer.auth_capable) {\n\t\tsctp_addto_chunk(retval, ntohs(auth_random->length),\n\t\t\t\t auth_random);\n\t\tif (auth_hmacs)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_hmacs->length),\n\t\t\t\t\tauth_hmacs);\n\t\tif (auth_chunks)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_chunks->length),\n\t\t\t\t\tauth_chunks);\n\t}\n\n\t/* We need to remove the const qualifier at this point.  */\n\tretval->asoc = (struct sctp_association *) asoc;\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, * etc.) to the same destination transport\n\t * address from which it received the DATA or control chunk\n\t * to which it is replying.\n\t *\n\t * [INIT ACK back to where the INIT came from.]\n\t */\n\tif (chunk)\n\t\tretval->transport = chunk->transport;\n\nnomem_chunk:\n\tkfree(cookie);\nnomem_cookie:\n\tkfree(addrs.v);\n\treturn retval;\n}",
        "func": "struct sctp_chunk *sctp_make_init_ack(const struct sctp_association *asoc,\n\t\t\t\t const struct sctp_chunk *chunk,\n\t\t\t\t gfp_t gfp, int unkparam_len)\n{\n\tsctp_inithdr_t initack;\n\tstruct sctp_chunk *retval;\n\tunion sctp_params addrs;\n\tstruct sctp_sock *sp;\n\tint addrs_len;\n\tsctp_cookie_param_t *cookie;\n\tint cookie_len;\n\tsize_t chunksize;\n\tsctp_adaptation_ind_param_t aiparam;\n\tsctp_supported_ext_param_t ext_param;\n\tint num_ext = 0;\n\t__u8 extensions[3];\n\tsctp_paramhdr_t *auth_chunks = NULL,\n\t\t\t*auth_hmacs = NULL,\n\t\t\t*auth_random = NULL;\n\n\tretval = NULL;\n\n\t/* Note: there may be no addresses to embed. */\n\taddrs = sctp_bind_addrs_to_raw(&asoc->base.bind_addr, &addrs_len, gfp);\n\n\tinitack.init_tag\t        = htonl(asoc->c.my_vtag);\n\tinitack.a_rwnd\t\t\t= htonl(asoc->rwnd);\n\tinitack.num_outbound_streams\t= htons(asoc->c.sinit_num_ostreams);\n\tinitack.num_inbound_streams\t= htons(asoc->c.sinit_max_instreams);\n\tinitack.initial_tsn\t\t= htonl(asoc->c.initial_tsn);\n\n\t/* FIXME:  We really ought to build the cookie right\n\t * into the packet instead of allocating more fresh memory.\n\t */\n\tcookie = sctp_pack_cookie(asoc->ep, asoc, chunk, &cookie_len,\n\t\t\t\t  addrs.v, addrs_len);\n\tif (!cookie)\n\t\tgoto nomem_cookie;\n\n\t/* Calculate the total size of allocation, include the reserved\n\t * space for reporting unknown parameters if it is specified.\n\t */\n\tsp = sctp_sk(asoc->base.sk);\n\tchunksize = sizeof(initack) + addrs_len + cookie_len + unkparam_len;\n\n\t/* Tell peer that we'll do ECN only if peer advertised such cap.  */\n\tif (asoc->peer.ecn_capable)\n\t\tchunksize += sizeof(ecap_param);\n\n\tif (asoc->peer.prsctp_capable)\n\t\tchunksize += sizeof(prsctp_param);\n\n\tif (asoc->peer.asconf_capable) {\n\t\textensions[num_ext] = SCTP_CID_ASCONF;\n\t\textensions[num_ext+1] = SCTP_CID_ASCONF_ACK;\n\t\tnum_ext += 2;\n\t}\n\n\tif (sp->adaptation_ind)\n\t\tchunksize += sizeof(aiparam);\n\n\tif (asoc->peer.auth_capable) {\n\t\tauth_random = (sctp_paramhdr_t *)asoc->c.auth_random;\n\t\tchunksize += ntohs(auth_random->length);\n\n\t\tauth_hmacs = (sctp_paramhdr_t *)asoc->c.auth_hmacs;\n\t\tif (auth_hmacs->length)\n\t\t\tchunksize += WORD_ROUND(ntohs(auth_hmacs->length));\n\t\telse\n\t\t\tauth_hmacs = NULL;\n\n\t\tauth_chunks = (sctp_paramhdr_t *)asoc->c.auth_chunks;\n\t\tif (auth_chunks->length)\n\t\t\tchunksize += WORD_ROUND(ntohs(auth_chunks->length));\n\t\telse\n\t\t\tauth_chunks = NULL;\n\n\t\textensions[num_ext] = SCTP_CID_AUTH;\n\t\tnum_ext += 1;\n\t}\n\n\tif (num_ext)\n\t\tchunksize += WORD_ROUND(sizeof(sctp_supported_ext_param_t) +\n\t\t\t\t\tnum_ext);\n\n\t/* Now allocate and fill out the chunk.  */\n\tretval = sctp_make_chunk(asoc, SCTP_CID_INIT_ACK, 0, chunksize);\n\tif (!retval)\n\t\tgoto nomem_chunk;\n\n\t/* Per the advice in RFC 2960 6.4, send this reply to\n\t * the source of the INIT packet.\n\t */\n\tretval->transport = chunk->transport;\n\tretval->subh.init_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(initack), &initack);\n\tretval->param_hdr.v = sctp_addto_chunk(retval, addrs_len, addrs.v);\n\tsctp_addto_chunk(retval, cookie_len, cookie);\n\tif (asoc->peer.ecn_capable)\n\t\tsctp_addto_chunk(retval, sizeof(ecap_param), &ecap_param);\n\tif (num_ext) {\n\t\text_param.param_hdr.type = SCTP_PARAM_SUPPORTED_EXT;\n\t\text_param.param_hdr.length =\n\t\t\t    htons(sizeof(sctp_supported_ext_param_t) + num_ext);\n\t\tsctp_addto_chunk(retval, sizeof(sctp_supported_ext_param_t),\n\t\t\t\t &ext_param);\n\t\tsctp_addto_param(retval, num_ext, extensions);\n\t}\n\tif (asoc->peer.prsctp_capable)\n\t\tsctp_addto_chunk(retval, sizeof(prsctp_param), &prsctp_param);\n\n\tif (sp->adaptation_ind) {\n\t\taiparam.param_hdr.type = SCTP_PARAM_ADAPTATION_LAYER_IND;\n\t\taiparam.param_hdr.length = htons(sizeof(aiparam));\n\t\taiparam.adaptation_ind = htonl(sp->adaptation_ind);\n\t\tsctp_addto_chunk(retval, sizeof(aiparam), &aiparam);\n\t}\n\n\tif (asoc->peer.auth_capable) {\n\t\tsctp_addto_chunk(retval, ntohs(auth_random->length),\n\t\t\t\t auth_random);\n\t\tif (auth_hmacs)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_hmacs->length),\n\t\t\t\t\tauth_hmacs);\n\t\tif (auth_chunks)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_chunks->length),\n\t\t\t\t\tauth_chunks);\n\t}\n\n\t/* We need to remove the const qualifier at this point.  */\n\tretval->asoc = (struct sctp_association *) asoc;\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, * etc.) to the same destination transport\n\t * address from which it received the DATA or control chunk\n\t * to which it is replying.\n\t *\n\t * [INIT ACK back to where the INIT came from.]\n\t */\n\tif (chunk)\n\t\tretval->transport = chunk->transport;\n\nnomem_chunk:\n\tkfree(cookie);\nnomem_cookie:\n\tkfree(addrs.v);\n\treturn retval;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -65,13 +65,13 @@\n \n \t\tauth_hmacs = (sctp_paramhdr_t *)asoc->c.auth_hmacs;\n \t\tif (auth_hmacs->length)\n-\t\t\tchunksize += ntohs(auth_hmacs->length);\n+\t\t\tchunksize += WORD_ROUND(ntohs(auth_hmacs->length));\n \t\telse\n \t\t\tauth_hmacs = NULL;\n \n \t\tauth_chunks = (sctp_paramhdr_t *)asoc->c.auth_chunks;\n \t\tif (auth_chunks->length)\n-\t\t\tchunksize += ntohs(auth_chunks->length);\n+\t\t\tchunksize += WORD_ROUND(ntohs(auth_chunks->length));\n \t\telse\n \t\t\tauth_chunks = NULL;\n \n@@ -80,7 +80,8 @@\n \t}\n \n \tif (num_ext)\n-\t\tchunksize += sizeof(sctp_supported_ext_param_t) + num_ext;\n+\t\tchunksize += WORD_ROUND(sizeof(sctp_supported_ext_param_t) +\n+\t\t\t\t\tnum_ext);\n \n \t/* Now allocate and fill out the chunk.  */\n \tretval = sctp_make_chunk(asoc, SCTP_CID_INIT_ACK, 0, chunksize);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tchunksize += ntohs(auth_hmacs->length);",
                "\t\t\tchunksize += ntohs(auth_chunks->length);",
                "\t\tchunksize += sizeof(sctp_supported_ext_param_t) + num_ext;"
            ],
            "added_lines": [
                "\t\t\tchunksize += WORD_ROUND(ntohs(auth_hmacs->length));",
                "\t\t\tchunksize += WORD_ROUND(ntohs(auth_chunks->length));",
                "\t\tchunksize += WORD_ROUND(sizeof(sctp_supported_ext_param_t) +",
                "\t\t\t\t\tnum_ext);"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-1573",
        "func_name": "torvalds/linux/sctp_make_init",
        "description": "net/sctp/sm_make_chunk.c in the Linux kernel before 2.6.34, when addip_enable and auth_enable are used, does not consider the amount of zero padding during calculation of chunk lengths for (1) INIT and (2) INIT ACK chunks, which allows remote attackers to cause a denial of service (OOPS) via crafted packet data.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=a8170c35e738d62e9919ce5b109cf4ed66e95bde",
        "commit_title": "When calculating the INIT/INIT-ACK chunk length, we should not",
        "commit_text": "only account the length of parameters, but also the parameters zero padding length, such as AUTH HMACS parameter and CHUNKS parameter. Without the parameters zero padding length we may get following oops.  skb_over_panic: text:ce2068d2 len:130 put:6 head:cac3fe00 data:cac3fe00 tail:0xcac3fe82 end:0xcac3fe80 dev:<NULL> ------------[ cut here ]------------ kernel BUG at net/core/skbuff.c:127! invalid opcode: 0000 [#2] SMP last sysfs file: /sys/module/aes_generic/initstate Modules linked in: authenc ......  Pid: 4102, comm: sctp_darn Tainted: G      D    2.6.34-rc2 #6 EIP: 0060:[<c0607630>] EFLAGS: 00010282 CPU: 0 EIP is at skb_over_panic+0x37/0x3e EAX: 00000078 EBX: c07c024b ECX: c07c02b9 EDX: cb607b78 ESI: 00000000 EDI: cac3fe7a EBP: 00000002 ESP: cb607b74  DS: 007b ES: 007b FS: 00d8 GS: 0033 SS: 0068 Process sctp_darn (pid: 4102, ti=cb607000 task=cabdc990 task.ti=cb607000) Stack:  c07c02b9 ce2068d2 00000082 00000006 cac3fe00 cac3fe00 cac3fe82 cac3fe80 <0> c07c024b cac3fe7c cac3fe7a c0608dec ca986e80 ce2068d2 00000006 0000007a <0> cb8120ca ca986e80 cb812000 00000003 cb8120c4 ce208a25 cb8120ca cadd9400 Call Trace:  [<ce2068d2>] ? sctp_addto_chunk+0x45/0x85 [sctp]  [<c0608dec>] ? skb_put+0x2e/0x32  [<ce2068d2>] ? sctp_addto_chunk+0x45/0x85 [sctp]  [<ce208a25>] ? sctp_make_init+0x279/0x28c [sctp]  [<c0686a92>] ? apic_timer_interrupt+0x2a/0x30  [<ce1fdc0b>] ? sctp_sf_do_prm_asoc+0x2b/0x7b [sctp]  [<ce202823>] ? sctp_do_sm+0xa0/0x14a [sctp]  [<ce2133b9>] ? sctp_pname+0x0/0x14 [sctp]  [<ce211d72>] ? sctp_primitive_ASSOCIATE+0x2b/0x31 [sctp]  [<ce20f3cf>] ? sctp_sendmsg+0x7a0/0x9eb [sctp]  [<c064eb1e>] ? inet_sendmsg+0x3b/0x43  [<c04244b7>] ? task_tick_fair+0x2d/0xd9  [<c06031e1>] ? sock_sendmsg+0xa7/0xc1  [<c0416afe>] ? smp_apic_timer_interrupt+0x6b/0x75  [<c0425123>] ? dequeue_task_fair+0x34/0x19b  [<c0446abb>] ? sched_clock_local+0x17/0x11e  [<c052ea87>] ? _copy_from_user+0x2b/0x10c  [<c060ab3a>] ? verify_iovec+0x3c/0x6a  [<c06035ca>] ? sys_sendmsg+0x186/0x1e2  [<c042176b>] ? __wake_up_common+0x34/0x5b  [<c04240c2>] ? __wake_up+0x2c/0x3b  [<c057e35c>] ? tty_wakeup+0x43/0x47  [<c04430f2>] ? remove_wait_queue+0x16/0x24  [<c0580c94>] ? n_tty_read+0x5b8/0x65e  [<c042be02>] ? default_wake_function+0x0/0x8  [<c0604e0e>] ? sys_socketcall+0x17f/0x1cd  [<c040264c>] ? sysenter_do_call+0x12/0x22 Code: 0f 45 de 53 ff b0 98 00 00 00 ff b0 94 ...... EIP: [<c0607630>] skb_over_panic+0x37/0x3e SS:ESP 0068:cb607b74  To reproduce:  # modprobe sctp # echo 1 > /proc/sys/net/sctp/addip_enable # echo 1 > /proc/sys/net/sctp/auth_enable # sctp_test -H 3ffe:501:ffff:100:20c:29ff:fe4d:f37e -P 800 -l # sctp_darn -H 3ffe:501:ffff:100:20c:29ff:fe4d:f37e -P 900 -h 192.168.0.21 -p 800 -I -s -t sctp_darn ready to send... 3ffe:501:ffff:100:20c:29ff:fe4d:f37e:900-192.168.0.21:800 Interactive mode> bindx-add=192.168.0.21 3ffe:501:ffff:100:20c:29ff:fe4d:f37e:900-192.168.0.21:800 Interactive mode> bindx-add=192.168.1.21 3ffe:501:ffff:100:20c:29ff:fe4d:f37e:900-192.168.0.21:800 Interactive mode> snd=10  ------------------------------------------------------------------ eth0 has addresses: 3ffe:501:ffff:100:20c:29ff:fe4d:f37e and 192.168.0.21 eth1 has addresses: 192.168.1.21 ------------------------------------------------------------------  ",
        "func_before": "struct sctp_chunk *sctp_make_init(const struct sctp_association *asoc,\n\t\t\t     const struct sctp_bind_addr *bp,\n\t\t\t     gfp_t gfp, int vparam_len)\n{\n\tsctp_inithdr_t init;\n\tunion sctp_params addrs;\n\tsize_t chunksize;\n\tstruct sctp_chunk *retval = NULL;\n\tint num_types, addrs_len = 0;\n\tstruct sctp_sock *sp;\n\tsctp_supported_addrs_param_t sat;\n\t__be16 types[2];\n\tsctp_adaptation_ind_param_t aiparam;\n\tsctp_supported_ext_param_t ext_param;\n\tint num_ext = 0;\n\t__u8 extensions[3];\n\tsctp_paramhdr_t *auth_chunks = NULL,\n\t\t\t*auth_hmacs = NULL;\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 1: The INIT chunks can contain multiple addresses that\n\t * can be IPv4 and/or IPv6 in any combination.\n\t */\n\tretval = NULL;\n\n\t/* Convert the provided bind address list to raw format. */\n\taddrs = sctp_bind_addrs_to_raw(bp, &addrs_len, gfp);\n\n\tinit.init_tag\t\t   = htonl(asoc->c.my_vtag);\n\tinit.a_rwnd\t\t   = htonl(asoc->rwnd);\n\tinit.num_outbound_streams  = htons(asoc->c.sinit_num_ostreams);\n\tinit.num_inbound_streams   = htons(asoc->c.sinit_max_instreams);\n\tinit.initial_tsn\t   = htonl(asoc->c.initial_tsn);\n\n\t/* How many address types are needed? */\n\tsp = sctp_sk(asoc->base.sk);\n\tnum_types = sp->pf->supported_addrs(sp, types);\n\n\tchunksize = sizeof(init) + addrs_len + SCTP_SAT_LEN(num_types);\n\tchunksize += sizeof(ecap_param);\n\n\tif (sctp_prsctp_enable)\n\t\tchunksize += sizeof(prsctp_param);\n\n\t/* ADDIP: Section 4.2.7:\n\t *  An implementation supporting this extension [ADDIP] MUST list\n\t *  the ASCONF,the ASCONF-ACK, and the AUTH  chunks in its INIT and\n\t *  INIT-ACK parameters.\n\t */\n\tif (sctp_addip_enable) {\n\t\textensions[num_ext] = SCTP_CID_ASCONF;\n\t\textensions[num_ext+1] = SCTP_CID_ASCONF_ACK;\n\t\tnum_ext += 2;\n\t}\n\n\tif (sp->adaptation_ind)\n\t\tchunksize += sizeof(aiparam);\n\n\tchunksize += vparam_len;\n\n\t/* Account for AUTH related parameters */\n\tif (sctp_auth_enable) {\n\t\t/* Add random parameter length*/\n\t\tchunksize += sizeof(asoc->c.auth_random);\n\n\t\t/* Add HMACS parameter length if any were defined */\n\t\tauth_hmacs = (sctp_paramhdr_t *)asoc->c.auth_hmacs;\n\t\tif (auth_hmacs->length)\n\t\t\tchunksize += ntohs(auth_hmacs->length);\n\t\telse\n\t\t\tauth_hmacs = NULL;\n\n\t\t/* Add CHUNKS parameter length */\n\t\tauth_chunks = (sctp_paramhdr_t *)asoc->c.auth_chunks;\n\t\tif (auth_chunks->length)\n\t\t\tchunksize += ntohs(auth_chunks->length);\n\t\telse\n\t\t\tauth_chunks = NULL;\n\n\t\textensions[num_ext] = SCTP_CID_AUTH;\n\t\tnum_ext += 1;\n\t}\n\n\t/* If we have any extensions to report, account for that */\n\tif (num_ext)\n\t\tchunksize += sizeof(sctp_supported_ext_param_t) + num_ext;\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 3: An INIT chunk MUST NOT contain more than one Host\n\t * Name address parameter. Moreover, the sender of the INIT\n\t * MUST NOT combine any other address types with the Host Name\n\t * address in the INIT. The receiver of INIT MUST ignore any\n\t * other address types if the Host Name address parameter is\n\t * present in the received INIT chunk.\n\t *\n\t * PLEASE DO NOT FIXME [This version does not support Host Name.]\n\t */\n\n\tretval = sctp_make_chunk(asoc, SCTP_CID_INIT, 0, chunksize);\n\tif (!retval)\n\t\tgoto nodata;\n\n\tretval->subh.init_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(init), &init);\n\tretval->param_hdr.v =\n\t\tsctp_addto_chunk(retval, addrs_len, addrs.v);\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 4: This parameter, when present, specifies all the\n\t * address types the sending endpoint can support. The absence\n\t * of this parameter indicates that the sending endpoint can\n\t * support any address type.\n\t */\n\tsat.param_hdr.type = SCTP_PARAM_SUPPORTED_ADDRESS_TYPES;\n\tsat.param_hdr.length = htons(SCTP_SAT_LEN(num_types));\n\tsctp_addto_chunk(retval, sizeof(sat), &sat);\n\tsctp_addto_chunk(retval, num_types * sizeof(__u16), &types);\n\n\tsctp_addto_chunk(retval, sizeof(ecap_param), &ecap_param);\n\n\t/* Add the supported extensions parameter.  Be nice and add this\n\t * fist before addiding the parameters for the extensions themselves\n\t */\n\tif (num_ext) {\n\t\text_param.param_hdr.type = SCTP_PARAM_SUPPORTED_EXT;\n\t\text_param.param_hdr.length =\n\t\t\t    htons(sizeof(sctp_supported_ext_param_t) + num_ext);\n\t\tsctp_addto_chunk(retval, sizeof(sctp_supported_ext_param_t),\n\t\t\t\t&ext_param);\n\t\tsctp_addto_param(retval, num_ext, extensions);\n\t}\n\n\tif (sctp_prsctp_enable)\n\t\tsctp_addto_chunk(retval, sizeof(prsctp_param), &prsctp_param);\n\n\tif (sp->adaptation_ind) {\n\t\taiparam.param_hdr.type = SCTP_PARAM_ADAPTATION_LAYER_IND;\n\t\taiparam.param_hdr.length = htons(sizeof(aiparam));\n\t\taiparam.adaptation_ind = htonl(sp->adaptation_ind);\n\t\tsctp_addto_chunk(retval, sizeof(aiparam), &aiparam);\n\t}\n\n\t/* Add SCTP-AUTH chunks to the parameter list */\n\tif (sctp_auth_enable) {\n\t\tsctp_addto_chunk(retval, sizeof(asoc->c.auth_random),\n\t\t\t\t asoc->c.auth_random);\n\t\tif (auth_hmacs)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_hmacs->length),\n\t\t\t\t\tauth_hmacs);\n\t\tif (auth_chunks)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_chunks->length),\n\t\t\t\t\tauth_chunks);\n\t}\nnodata:\n\tkfree(addrs.v);\n\treturn retval;\n}",
        "func": "struct sctp_chunk *sctp_make_init(const struct sctp_association *asoc,\n\t\t\t     const struct sctp_bind_addr *bp,\n\t\t\t     gfp_t gfp, int vparam_len)\n{\n\tsctp_inithdr_t init;\n\tunion sctp_params addrs;\n\tsize_t chunksize;\n\tstruct sctp_chunk *retval = NULL;\n\tint num_types, addrs_len = 0;\n\tstruct sctp_sock *sp;\n\tsctp_supported_addrs_param_t sat;\n\t__be16 types[2];\n\tsctp_adaptation_ind_param_t aiparam;\n\tsctp_supported_ext_param_t ext_param;\n\tint num_ext = 0;\n\t__u8 extensions[3];\n\tsctp_paramhdr_t *auth_chunks = NULL,\n\t\t\t*auth_hmacs = NULL;\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 1: The INIT chunks can contain multiple addresses that\n\t * can be IPv4 and/or IPv6 in any combination.\n\t */\n\tretval = NULL;\n\n\t/* Convert the provided bind address list to raw format. */\n\taddrs = sctp_bind_addrs_to_raw(bp, &addrs_len, gfp);\n\n\tinit.init_tag\t\t   = htonl(asoc->c.my_vtag);\n\tinit.a_rwnd\t\t   = htonl(asoc->rwnd);\n\tinit.num_outbound_streams  = htons(asoc->c.sinit_num_ostreams);\n\tinit.num_inbound_streams   = htons(asoc->c.sinit_max_instreams);\n\tinit.initial_tsn\t   = htonl(asoc->c.initial_tsn);\n\n\t/* How many address types are needed? */\n\tsp = sctp_sk(asoc->base.sk);\n\tnum_types = sp->pf->supported_addrs(sp, types);\n\n\tchunksize = sizeof(init) + addrs_len;\n\tchunksize += WORD_ROUND(SCTP_SAT_LEN(num_types));\n\tchunksize += sizeof(ecap_param);\n\n\tif (sctp_prsctp_enable)\n\t\tchunksize += sizeof(prsctp_param);\n\n\t/* ADDIP: Section 4.2.7:\n\t *  An implementation supporting this extension [ADDIP] MUST list\n\t *  the ASCONF,the ASCONF-ACK, and the AUTH  chunks in its INIT and\n\t *  INIT-ACK parameters.\n\t */\n\tif (sctp_addip_enable) {\n\t\textensions[num_ext] = SCTP_CID_ASCONF;\n\t\textensions[num_ext+1] = SCTP_CID_ASCONF_ACK;\n\t\tnum_ext += 2;\n\t}\n\n\tif (sp->adaptation_ind)\n\t\tchunksize += sizeof(aiparam);\n\n\tchunksize += vparam_len;\n\n\t/* Account for AUTH related parameters */\n\tif (sctp_auth_enable) {\n\t\t/* Add random parameter length*/\n\t\tchunksize += sizeof(asoc->c.auth_random);\n\n\t\t/* Add HMACS parameter length if any were defined */\n\t\tauth_hmacs = (sctp_paramhdr_t *)asoc->c.auth_hmacs;\n\t\tif (auth_hmacs->length)\n\t\t\tchunksize += WORD_ROUND(ntohs(auth_hmacs->length));\n\t\telse\n\t\t\tauth_hmacs = NULL;\n\n\t\t/* Add CHUNKS parameter length */\n\t\tauth_chunks = (sctp_paramhdr_t *)asoc->c.auth_chunks;\n\t\tif (auth_chunks->length)\n\t\t\tchunksize += WORD_ROUND(ntohs(auth_chunks->length));\n\t\telse\n\t\t\tauth_chunks = NULL;\n\n\t\textensions[num_ext] = SCTP_CID_AUTH;\n\t\tnum_ext += 1;\n\t}\n\n\t/* If we have any extensions to report, account for that */\n\tif (num_ext)\n\t\tchunksize += WORD_ROUND(sizeof(sctp_supported_ext_param_t) +\n\t\t\t\t\tnum_ext);\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 3: An INIT chunk MUST NOT contain more than one Host\n\t * Name address parameter. Moreover, the sender of the INIT\n\t * MUST NOT combine any other address types with the Host Name\n\t * address in the INIT. The receiver of INIT MUST ignore any\n\t * other address types if the Host Name address parameter is\n\t * present in the received INIT chunk.\n\t *\n\t * PLEASE DO NOT FIXME [This version does not support Host Name.]\n\t */\n\n\tretval = sctp_make_chunk(asoc, SCTP_CID_INIT, 0, chunksize);\n\tif (!retval)\n\t\tgoto nodata;\n\n\tretval->subh.init_hdr =\n\t\tsctp_addto_chunk(retval, sizeof(init), &init);\n\tretval->param_hdr.v =\n\t\tsctp_addto_chunk(retval, addrs_len, addrs.v);\n\n\t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n\t *\n\t * Note 4: This parameter, when present, specifies all the\n\t * address types the sending endpoint can support. The absence\n\t * of this parameter indicates that the sending endpoint can\n\t * support any address type.\n\t */\n\tsat.param_hdr.type = SCTP_PARAM_SUPPORTED_ADDRESS_TYPES;\n\tsat.param_hdr.length = htons(SCTP_SAT_LEN(num_types));\n\tsctp_addto_chunk(retval, sizeof(sat), &sat);\n\tsctp_addto_chunk(retval, num_types * sizeof(__u16), &types);\n\n\tsctp_addto_chunk(retval, sizeof(ecap_param), &ecap_param);\n\n\t/* Add the supported extensions parameter.  Be nice and add this\n\t * fist before addiding the parameters for the extensions themselves\n\t */\n\tif (num_ext) {\n\t\text_param.param_hdr.type = SCTP_PARAM_SUPPORTED_EXT;\n\t\text_param.param_hdr.length =\n\t\t\t    htons(sizeof(sctp_supported_ext_param_t) + num_ext);\n\t\tsctp_addto_chunk(retval, sizeof(sctp_supported_ext_param_t),\n\t\t\t\t&ext_param);\n\t\tsctp_addto_param(retval, num_ext, extensions);\n\t}\n\n\tif (sctp_prsctp_enable)\n\t\tsctp_addto_chunk(retval, sizeof(prsctp_param), &prsctp_param);\n\n\tif (sp->adaptation_ind) {\n\t\taiparam.param_hdr.type = SCTP_PARAM_ADAPTATION_LAYER_IND;\n\t\taiparam.param_hdr.length = htons(sizeof(aiparam));\n\t\taiparam.adaptation_ind = htonl(sp->adaptation_ind);\n\t\tsctp_addto_chunk(retval, sizeof(aiparam), &aiparam);\n\t}\n\n\t/* Add SCTP-AUTH chunks to the parameter list */\n\tif (sctp_auth_enable) {\n\t\tsctp_addto_chunk(retval, sizeof(asoc->c.auth_random),\n\t\t\t\t asoc->c.auth_random);\n\t\tif (auth_hmacs)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_hmacs->length),\n\t\t\t\t\tauth_hmacs);\n\t\tif (auth_chunks)\n\t\t\tsctp_addto_chunk(retval, ntohs(auth_chunks->length),\n\t\t\t\t\tauth_chunks);\n\t}\nnodata:\n\tkfree(addrs.v);\n\treturn retval;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -37,7 +37,8 @@\n \tsp = sctp_sk(asoc->base.sk);\n \tnum_types = sp->pf->supported_addrs(sp, types);\n \n-\tchunksize = sizeof(init) + addrs_len + SCTP_SAT_LEN(num_types);\n+\tchunksize = sizeof(init) + addrs_len;\n+\tchunksize += WORD_ROUND(SCTP_SAT_LEN(num_types));\n \tchunksize += sizeof(ecap_param);\n \n \tif (sctp_prsctp_enable)\n@@ -67,14 +68,14 @@\n \t\t/* Add HMACS parameter length if any were defined */\n \t\tauth_hmacs = (sctp_paramhdr_t *)asoc->c.auth_hmacs;\n \t\tif (auth_hmacs->length)\n-\t\t\tchunksize += ntohs(auth_hmacs->length);\n+\t\t\tchunksize += WORD_ROUND(ntohs(auth_hmacs->length));\n \t\telse\n \t\t\tauth_hmacs = NULL;\n \n \t\t/* Add CHUNKS parameter length */\n \t\tauth_chunks = (sctp_paramhdr_t *)asoc->c.auth_chunks;\n \t\tif (auth_chunks->length)\n-\t\t\tchunksize += ntohs(auth_chunks->length);\n+\t\t\tchunksize += WORD_ROUND(ntohs(auth_chunks->length));\n \t\telse\n \t\t\tauth_chunks = NULL;\n \n@@ -84,7 +85,8 @@\n \n \t/* If we have any extensions to report, account for that */\n \tif (num_ext)\n-\t\tchunksize += sizeof(sctp_supported_ext_param_t) + num_ext;\n+\t\tchunksize += WORD_ROUND(sizeof(sctp_supported_ext_param_t) +\n+\t\t\t\t\tnum_ext);\n \n \t/* RFC 2960 3.3.2 Initiation (INIT) (1)\n \t *",
        "diff_line_info": {
            "deleted_lines": [
                "\tchunksize = sizeof(init) + addrs_len + SCTP_SAT_LEN(num_types);",
                "\t\t\tchunksize += ntohs(auth_hmacs->length);",
                "\t\t\tchunksize += ntohs(auth_chunks->length);",
                "\t\tchunksize += sizeof(sctp_supported_ext_param_t) + num_ext;"
            ],
            "added_lines": [
                "\tchunksize = sizeof(init) + addrs_len;",
                "\tchunksize += WORD_ROUND(SCTP_SAT_LEN(num_types));",
                "\t\t\tchunksize += WORD_ROUND(ntohs(auth_hmacs->length));",
                "\t\t\tchunksize += WORD_ROUND(ntohs(auth_chunks->length));",
                "\t\tchunksize += WORD_ROUND(sizeof(sctp_supported_ext_param_t) +",
                "\t\t\t\t\tnum_ext);"
            ]
        }
    }
]