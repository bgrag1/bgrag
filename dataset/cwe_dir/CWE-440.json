[
    {
        "cve_id": "CVE-2020-10766",
        "func_name": "torvalds/linux/__speculation_ctrl_update",
        "description": "A logic bug flaw was found in Linux kernel before 5.8-rc1 in the implementation of SSBD. A bug in the logic handling allows an attacker with a local account to disable SSBD protection during a context switch when additional speculative execution mitigations are in place. This issue was introduced when the per task/process conditional STIPB switching was added on top of the existing SSBD switching. The highest threat from this vulnerability is to confidentiality.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=dbbe2ad02e9df26e372f38cc3e70dab9222c832e",
        "commit_title": "On context switch the change of TIF_SSBD and TIF_SPEC_IB are evaluated",
        "commit_text": "to adjust the mitigations accordingly. This is optimized to avoid the expensive MSR write if not needed.  This optimization is buggy and allows an attacker to shutdown the SSBD protection of a victim process.  The update logic reads the cached base value for the speculation control MSR which has neither the SSBD nor the STIBP bit set. It then OR's the SSBD bit only when TIF_SSBD is different and requests the MSR update.  That means if TIF_SSBD of the previous and next task are the same, then the base value is not updated, even if TIF_SSBD is set. The MSR write is not requested.  Subsequently if the TIF_STIBP bit differs then the STIBP bit is updated in the base value and the MSR is written with a wrong SSBD value.  This was introduced when the per task/process conditional STIPB switching was added on top of the existing SSBD switching.  It is exploitable if the attacker creates a process which enforces SSBD and has the contrary value of STIBP than the victim process (i.e. if the victim process enforces STIBP, the attacker process must not enforce it; if the victim process does not enforce STIBP, the attacker process must enforce it) and schedule it on the same core as the victim process. If the victim runs after the attacker the victim becomes vulnerable to Spectre V4.  To fix this, update the MSR value independent of the TIF_SSBD difference and dependent on the SSBD mitigation method available. This ensures that a subsequent STIPB initiated MSR write has the correct state of SSBD.  [ tglx: Handle X86_FEATURE_VIRT_SSBD & X86_FEATURE_VIRT_SSBD correctly         and massaged changelog ]  Cc: stable@vger.kernel.org  ",
        "func_before": "static __always_inline void __speculation_ctrl_update(unsigned long tifp,\n\t\t\t\t\t\t      unsigned long tifn)\n{\n\tunsigned long tif_diff = tifp ^ tifn;\n\tu64 msr = x86_spec_ctrl_base;\n\tbool updmsr = false;\n\n\tlockdep_assert_irqs_disabled();\n\n\t/*\n\t * If TIF_SSBD is different, select the proper mitigation\n\t * method. Note that if SSBD mitigation is disabled or permanentely\n\t * enabled this branch can't be taken because nothing can set\n\t * TIF_SSBD.\n\t */\n\tif (tif_diff & _TIF_SSBD) {\n\t\tif (static_cpu_has(X86_FEATURE_VIRT_SSBD)) {\n\t\t\tamd_set_ssb_virt_state(tifn);\n\t\t} else if (static_cpu_has(X86_FEATURE_LS_CFG_SSBD)) {\n\t\t\tamd_set_core_ssb_state(tifn);\n\t\t} else if (static_cpu_has(X86_FEATURE_SPEC_CTRL_SSBD) ||\n\t\t\t   static_cpu_has(X86_FEATURE_AMD_SSBD)) {\n\t\t\tmsr |= ssbd_tif_to_spec_ctrl(tifn);\n\t\t\tupdmsr  = true;\n\t\t}\n\t}\n\n\t/*\n\t * Only evaluate TIF_SPEC_IB if conditional STIBP is enabled,\n\t * otherwise avoid the MSR write.\n\t */\n\tif (IS_ENABLED(CONFIG_SMP) &&\n\t    static_branch_unlikely(&switch_to_cond_stibp)) {\n\t\tupdmsr |= !!(tif_diff & _TIF_SPEC_IB);\n\t\tmsr |= stibp_tif_to_spec_ctrl(tifn);\n\t}\n\n\tif (updmsr)\n\t\twrmsrl(MSR_IA32_SPEC_CTRL, msr);\n}",
        "func": "static __always_inline void __speculation_ctrl_update(unsigned long tifp,\n\t\t\t\t\t\t      unsigned long tifn)\n{\n\tunsigned long tif_diff = tifp ^ tifn;\n\tu64 msr = x86_spec_ctrl_base;\n\tbool updmsr = false;\n\n\tlockdep_assert_irqs_disabled();\n\n\t/* Handle change of TIF_SSBD depending on the mitigation method. */\n\tif (static_cpu_has(X86_FEATURE_VIRT_SSBD)) {\n\t\tif (tif_diff & _TIF_SSBD)\n\t\t\tamd_set_ssb_virt_state(tifn);\n\t} else if (static_cpu_has(X86_FEATURE_LS_CFG_SSBD)) {\n\t\tif (tif_diff & _TIF_SSBD)\n\t\t\tamd_set_core_ssb_state(tifn);\n\t} else if (static_cpu_has(X86_FEATURE_SPEC_CTRL_SSBD) ||\n\t\t   static_cpu_has(X86_FEATURE_AMD_SSBD)) {\n\t\tupdmsr |= !!(tif_diff & _TIF_SSBD);\n\t\tmsr |= ssbd_tif_to_spec_ctrl(tifn);\n\t}\n\n\t/* Only evaluate TIF_SPEC_IB if conditional STIBP is enabled. */\n\tif (IS_ENABLED(CONFIG_SMP) &&\n\t    static_branch_unlikely(&switch_to_cond_stibp)) {\n\t\tupdmsr |= !!(tif_diff & _TIF_SPEC_IB);\n\t\tmsr |= stibp_tif_to_spec_ctrl(tifn);\n\t}\n\n\tif (updmsr)\n\t\twrmsrl(MSR_IA32_SPEC_CTRL, msr);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,28 +7,20 @@\n \n \tlockdep_assert_irqs_disabled();\n \n-\t/*\n-\t * If TIF_SSBD is different, select the proper mitigation\n-\t * method. Note that if SSBD mitigation is disabled or permanentely\n-\t * enabled this branch can't be taken because nothing can set\n-\t * TIF_SSBD.\n-\t */\n-\tif (tif_diff & _TIF_SSBD) {\n-\t\tif (static_cpu_has(X86_FEATURE_VIRT_SSBD)) {\n+\t/* Handle change of TIF_SSBD depending on the mitigation method. */\n+\tif (static_cpu_has(X86_FEATURE_VIRT_SSBD)) {\n+\t\tif (tif_diff & _TIF_SSBD)\n \t\t\tamd_set_ssb_virt_state(tifn);\n-\t\t} else if (static_cpu_has(X86_FEATURE_LS_CFG_SSBD)) {\n+\t} else if (static_cpu_has(X86_FEATURE_LS_CFG_SSBD)) {\n+\t\tif (tif_diff & _TIF_SSBD)\n \t\t\tamd_set_core_ssb_state(tifn);\n-\t\t} else if (static_cpu_has(X86_FEATURE_SPEC_CTRL_SSBD) ||\n-\t\t\t   static_cpu_has(X86_FEATURE_AMD_SSBD)) {\n-\t\t\tmsr |= ssbd_tif_to_spec_ctrl(tifn);\n-\t\t\tupdmsr  = true;\n-\t\t}\n+\t} else if (static_cpu_has(X86_FEATURE_SPEC_CTRL_SSBD) ||\n+\t\t   static_cpu_has(X86_FEATURE_AMD_SSBD)) {\n+\t\tupdmsr |= !!(tif_diff & _TIF_SSBD);\n+\t\tmsr |= ssbd_tif_to_spec_ctrl(tifn);\n \t}\n \n-\t/*\n-\t * Only evaluate TIF_SPEC_IB if conditional STIBP is enabled,\n-\t * otherwise avoid the MSR write.\n-\t */\n+\t/* Only evaluate TIF_SPEC_IB if conditional STIBP is enabled. */\n \tif (IS_ENABLED(CONFIG_SMP) &&\n \t    static_branch_unlikely(&switch_to_cond_stibp)) {\n \t\tupdmsr |= !!(tif_diff & _TIF_SPEC_IB);",
        "diff_line_info": {
            "deleted_lines": [
                "\t/*",
                "\t * If TIF_SSBD is different, select the proper mitigation",
                "\t * method. Note that if SSBD mitigation is disabled or permanentely",
                "\t * enabled this branch can't be taken because nothing can set",
                "\t * TIF_SSBD.",
                "\t */",
                "\tif (tif_diff & _TIF_SSBD) {",
                "\t\tif (static_cpu_has(X86_FEATURE_VIRT_SSBD)) {",
                "\t\t} else if (static_cpu_has(X86_FEATURE_LS_CFG_SSBD)) {",
                "\t\t} else if (static_cpu_has(X86_FEATURE_SPEC_CTRL_SSBD) ||",
                "\t\t\t   static_cpu_has(X86_FEATURE_AMD_SSBD)) {",
                "\t\t\tmsr |= ssbd_tif_to_spec_ctrl(tifn);",
                "\t\t\tupdmsr  = true;",
                "\t\t}",
                "\t/*",
                "\t * Only evaluate TIF_SPEC_IB if conditional STIBP is enabled,",
                "\t * otherwise avoid the MSR write.",
                "\t */"
            ],
            "added_lines": [
                "\t/* Handle change of TIF_SSBD depending on the mitigation method. */",
                "\tif (static_cpu_has(X86_FEATURE_VIRT_SSBD)) {",
                "\t\tif (tif_diff & _TIF_SSBD)",
                "\t} else if (static_cpu_has(X86_FEATURE_LS_CFG_SSBD)) {",
                "\t\tif (tif_diff & _TIF_SSBD)",
                "\t} else if (static_cpu_has(X86_FEATURE_SPEC_CTRL_SSBD) ||",
                "\t\t   static_cpu_has(X86_FEATURE_AMD_SSBD)) {",
                "\t\tupdmsr |= !!(tif_diff & _TIF_SSBD);",
                "\t\tmsr |= ssbd_tif_to_spec_ctrl(tifn);",
                "\t/* Only evaluate TIF_SPEC_IB if conditional STIBP is enabled. */"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-10767",
        "func_name": "torvalds/linux/ib_prctl_get",
        "description": "A flaw was found in the Linux kernel before 5.8-rc1 in the implementation of the Enhanced IBPB (Indirect Branch Prediction Barrier). The IBPB mitigation will be disabled when STIBP is not available or when the Enhanced Indirect Branch Restricted Speculation (IBRS) is available. This flaw allows a local attacker to perform a Spectre V2 style attack when this configuration is active. The highest threat from this vulnerability is to confidentiality.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=21998a351512eba4ed5969006f0c55882d995ada",
        "commit_title": "When STIBP is unavailable or enhanced IBRS is available, Linux",
        "commit_text": "force-disables the IBPB mitigation of Spectre-BTB even when simultaneous multithreading is disabled. While attempts to enable IBPB using prctl(PR_SET_SPECULATION_CTRL, PR_SPEC_INDIRECT_BRANCH, ...) fail with EPERM, the seccomp syscall (or its prctl(PR_SET_SECCOMP, ...) equivalent) which are used e.g. by Chromium or OpenSSH succeed with no errors but the application remains silently vulnerable to cross-process Spectre v2 attacks (classical BTB poisoning). At the same time the SYSFS reporting (/sys/devices/system/cpu/vulnerabilities/spectre_v2) displays that IBPB is conditionally enabled when in fact it is unconditionally disabled.  STIBP is useful only when SMT is enabled. When SMT is disabled and STIBP is unavailable, it makes no sense to force-disable also IBPB, because IBPB protects against cross-process Spectre-BTB attacks regardless of the SMT state. At the same time since missing STIBP was only observed on AMD CPUs, AMD does not recommend using STIBP, but recommends using IBPB, so disabling IBPB because of missing STIBP goes directly against AMD's advice: https://developer.amd.com/wp-content/resources/Architecture_Guidelines_Update_Indirect_Branch_Control.pdf  Similarly, enhanced IBRS is designed to protect cross-core BTB poisoning and BTB-poisoning attacks from user space against kernel (and BTB-poisoning attacks from guest against hypervisor), it is not designed to prevent cross-process (or cross-VM) BTB poisoning between processes (or VMs) running on the same core. Therefore, even with enhanced IBRS it is necessary to flush the BTB during context-switches, so there is no reason to force disable IBPB when enhanced IBRS is available.  Enable the prctl control of IBPB even when STIBP is unavailable or enhanced IBRS is available.  Cc: stable@vger.kernel.org ",
        "func_before": "static int ib_prctl_get(struct task_struct *task)\n{\n\tif (!boot_cpu_has_bug(X86_BUG_SPECTRE_V2))\n\t\treturn PR_SPEC_NOT_AFFECTED;\n\n\tswitch (spectre_v2_user) {\n\tcase SPECTRE_V2_USER_NONE:\n\t\treturn PR_SPEC_ENABLE;\n\tcase SPECTRE_V2_USER_PRCTL:\n\tcase SPECTRE_V2_USER_SECCOMP:\n\t\tif (task_spec_ib_force_disable(task))\n\t\t\treturn PR_SPEC_PRCTL | PR_SPEC_FORCE_DISABLE;\n\t\tif (task_spec_ib_disable(task))\n\t\t\treturn PR_SPEC_PRCTL | PR_SPEC_DISABLE;\n\t\treturn PR_SPEC_PRCTL | PR_SPEC_ENABLE;\n\tcase SPECTRE_V2_USER_STRICT:\n\tcase SPECTRE_V2_USER_STRICT_PREFERRED:\n\t\treturn PR_SPEC_DISABLE;\n\tdefault:\n\t\treturn PR_SPEC_NOT_AFFECTED;\n\t}\n}",
        "func": "static int ib_prctl_get(struct task_struct *task)\n{\n\tif (!boot_cpu_has_bug(X86_BUG_SPECTRE_V2))\n\t\treturn PR_SPEC_NOT_AFFECTED;\n\n\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_NONE &&\n\t    spectre_v2_user_stibp == SPECTRE_V2_USER_NONE)\n\t\treturn PR_SPEC_ENABLE;\n\telse if (spectre_v2_user_ibpb == SPECTRE_V2_USER_STRICT ||\n\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT ||\n\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT_PREFERRED)\n\t\treturn PR_SPEC_DISABLE;\n\telse if (spectre_v2_user_ibpb == SPECTRE_V2_USER_PRCTL ||\n\t    spectre_v2_user_ibpb == SPECTRE_V2_USER_SECCOMP ||\n\t    spectre_v2_user_stibp == SPECTRE_V2_USER_PRCTL ||\n\t    spectre_v2_user_stibp == SPECTRE_V2_USER_SECCOMP) {\n\t\tif (task_spec_ib_force_disable(task))\n\t\t\treturn PR_SPEC_PRCTL | PR_SPEC_FORCE_DISABLE;\n\t\tif (task_spec_ib_disable(task))\n\t\t\treturn PR_SPEC_PRCTL | PR_SPEC_DISABLE;\n\t\treturn PR_SPEC_PRCTL | PR_SPEC_ENABLE;\n\t} else\n\t\treturn PR_SPEC_NOT_AFFECTED;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,20 +3,22 @@\n \tif (!boot_cpu_has_bug(X86_BUG_SPECTRE_V2))\n \t\treturn PR_SPEC_NOT_AFFECTED;\n \n-\tswitch (spectre_v2_user) {\n-\tcase SPECTRE_V2_USER_NONE:\n+\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_NONE &&\n+\t    spectre_v2_user_stibp == SPECTRE_V2_USER_NONE)\n \t\treturn PR_SPEC_ENABLE;\n-\tcase SPECTRE_V2_USER_PRCTL:\n-\tcase SPECTRE_V2_USER_SECCOMP:\n+\telse if (spectre_v2_user_ibpb == SPECTRE_V2_USER_STRICT ||\n+\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT ||\n+\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT_PREFERRED)\n+\t\treturn PR_SPEC_DISABLE;\n+\telse if (spectre_v2_user_ibpb == SPECTRE_V2_USER_PRCTL ||\n+\t    spectre_v2_user_ibpb == SPECTRE_V2_USER_SECCOMP ||\n+\t    spectre_v2_user_stibp == SPECTRE_V2_USER_PRCTL ||\n+\t    spectre_v2_user_stibp == SPECTRE_V2_USER_SECCOMP) {\n \t\tif (task_spec_ib_force_disable(task))\n \t\t\treturn PR_SPEC_PRCTL | PR_SPEC_FORCE_DISABLE;\n \t\tif (task_spec_ib_disable(task))\n \t\t\treturn PR_SPEC_PRCTL | PR_SPEC_DISABLE;\n \t\treturn PR_SPEC_PRCTL | PR_SPEC_ENABLE;\n-\tcase SPECTRE_V2_USER_STRICT:\n-\tcase SPECTRE_V2_USER_STRICT_PREFERRED:\n-\t\treturn PR_SPEC_DISABLE;\n-\tdefault:\n+\t} else\n \t\treturn PR_SPEC_NOT_AFFECTED;\n-\t}\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tswitch (spectre_v2_user) {",
                "\tcase SPECTRE_V2_USER_NONE:",
                "\tcase SPECTRE_V2_USER_PRCTL:",
                "\tcase SPECTRE_V2_USER_SECCOMP:",
                "\tcase SPECTRE_V2_USER_STRICT:",
                "\tcase SPECTRE_V2_USER_STRICT_PREFERRED:",
                "\t\treturn PR_SPEC_DISABLE;",
                "\tdefault:",
                "\t}"
            ],
            "added_lines": [
                "\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_NONE &&",
                "\t    spectre_v2_user_stibp == SPECTRE_V2_USER_NONE)",
                "\telse if (spectre_v2_user_ibpb == SPECTRE_V2_USER_STRICT ||",
                "\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT ||",
                "\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT_PREFERRED)",
                "\t\treturn PR_SPEC_DISABLE;",
                "\telse if (spectre_v2_user_ibpb == SPECTRE_V2_USER_PRCTL ||",
                "\t    spectre_v2_user_ibpb == SPECTRE_V2_USER_SECCOMP ||",
                "\t    spectre_v2_user_stibp == SPECTRE_V2_USER_PRCTL ||",
                "\t    spectre_v2_user_stibp == SPECTRE_V2_USER_SECCOMP) {",
                "\t} else"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-10767",
        "func_name": "torvalds/linux/stibp_state",
        "description": "A flaw was found in the Linux kernel before 5.8-rc1 in the implementation of the Enhanced IBPB (Indirect Branch Prediction Barrier). The IBPB mitigation will be disabled when STIBP is not available or when the Enhanced Indirect Branch Restricted Speculation (IBRS) is available. This flaw allows a local attacker to perform a Spectre V2 style attack when this configuration is active. The highest threat from this vulnerability is to confidentiality.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=21998a351512eba4ed5969006f0c55882d995ada",
        "commit_title": "When STIBP is unavailable or enhanced IBRS is available, Linux",
        "commit_text": "force-disables the IBPB mitigation of Spectre-BTB even when simultaneous multithreading is disabled. While attempts to enable IBPB using prctl(PR_SET_SPECULATION_CTRL, PR_SPEC_INDIRECT_BRANCH, ...) fail with EPERM, the seccomp syscall (or its prctl(PR_SET_SECCOMP, ...) equivalent) which are used e.g. by Chromium or OpenSSH succeed with no errors but the application remains silently vulnerable to cross-process Spectre v2 attacks (classical BTB poisoning). At the same time the SYSFS reporting (/sys/devices/system/cpu/vulnerabilities/spectre_v2) displays that IBPB is conditionally enabled when in fact it is unconditionally disabled.  STIBP is useful only when SMT is enabled. When SMT is disabled and STIBP is unavailable, it makes no sense to force-disable also IBPB, because IBPB protects against cross-process Spectre-BTB attacks regardless of the SMT state. At the same time since missing STIBP was only observed on AMD CPUs, AMD does not recommend using STIBP, but recommends using IBPB, so disabling IBPB because of missing STIBP goes directly against AMD's advice: https://developer.amd.com/wp-content/resources/Architecture_Guidelines_Update_Indirect_Branch_Control.pdf  Similarly, enhanced IBRS is designed to protect cross-core BTB poisoning and BTB-poisoning attacks from user space against kernel (and BTB-poisoning attacks from guest against hypervisor), it is not designed to prevent cross-process (or cross-VM) BTB poisoning between processes (or VMs) running on the same core. Therefore, even with enhanced IBRS it is necessary to flush the BTB during context-switches, so there is no reason to force disable IBPB when enhanced IBRS is available.  Enable the prctl control of IBPB even when STIBP is unavailable or enhanced IBRS is available.  Cc: stable@vger.kernel.org ",
        "func_before": "static char *stibp_state(void)\n{\n\tif (spectre_v2_enabled == SPECTRE_V2_IBRS_ENHANCED)\n\t\treturn \"\";\n\n\tswitch (spectre_v2_user) {\n\tcase SPECTRE_V2_USER_NONE:\n\t\treturn \", STIBP: disabled\";\n\tcase SPECTRE_V2_USER_STRICT:\n\t\treturn \", STIBP: forced\";\n\tcase SPECTRE_V2_USER_STRICT_PREFERRED:\n\t\treturn \", STIBP: always-on\";\n\tcase SPECTRE_V2_USER_PRCTL:\n\tcase SPECTRE_V2_USER_SECCOMP:\n\t\tif (static_key_enabled(&switch_to_cond_stibp))\n\t\t\treturn \", STIBP: conditional\";\n\t}\n\treturn \"\";\n}",
        "func": "static char *stibp_state(void)\n{\n\tif (spectre_v2_enabled == SPECTRE_V2_IBRS_ENHANCED)\n\t\treturn \"\";\n\n\tswitch (spectre_v2_user_stibp) {\n\tcase SPECTRE_V2_USER_NONE:\n\t\treturn \", STIBP: disabled\";\n\tcase SPECTRE_V2_USER_STRICT:\n\t\treturn \", STIBP: forced\";\n\tcase SPECTRE_V2_USER_STRICT_PREFERRED:\n\t\treturn \", STIBP: always-on\";\n\tcase SPECTRE_V2_USER_PRCTL:\n\tcase SPECTRE_V2_USER_SECCOMP:\n\t\tif (static_key_enabled(&switch_to_cond_stibp))\n\t\t\treturn \", STIBP: conditional\";\n\t}\n\treturn \"\";\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n \tif (spectre_v2_enabled == SPECTRE_V2_IBRS_ENHANCED)\n \t\treturn \"\";\n \n-\tswitch (spectre_v2_user) {\n+\tswitch (spectre_v2_user_stibp) {\n \tcase SPECTRE_V2_USER_NONE:\n \t\treturn \", STIBP: disabled\";\n \tcase SPECTRE_V2_USER_STRICT:",
        "diff_line_info": {
            "deleted_lines": [
                "\tswitch (spectre_v2_user) {"
            ],
            "added_lines": [
                "\tswitch (spectre_v2_user_stibp) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-10767",
        "func_name": "torvalds/linux/ib_prctl_set",
        "description": "A flaw was found in the Linux kernel before 5.8-rc1 in the implementation of the Enhanced IBPB (Indirect Branch Prediction Barrier). The IBPB mitigation will be disabled when STIBP is not available or when the Enhanced Indirect Branch Restricted Speculation (IBRS) is available. This flaw allows a local attacker to perform a Spectre V2 style attack when this configuration is active. The highest threat from this vulnerability is to confidentiality.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=21998a351512eba4ed5969006f0c55882d995ada",
        "commit_title": "When STIBP is unavailable or enhanced IBRS is available, Linux",
        "commit_text": "force-disables the IBPB mitigation of Spectre-BTB even when simultaneous multithreading is disabled. While attempts to enable IBPB using prctl(PR_SET_SPECULATION_CTRL, PR_SPEC_INDIRECT_BRANCH, ...) fail with EPERM, the seccomp syscall (or its prctl(PR_SET_SECCOMP, ...) equivalent) which are used e.g. by Chromium or OpenSSH succeed with no errors but the application remains silently vulnerable to cross-process Spectre v2 attacks (classical BTB poisoning). At the same time the SYSFS reporting (/sys/devices/system/cpu/vulnerabilities/spectre_v2) displays that IBPB is conditionally enabled when in fact it is unconditionally disabled.  STIBP is useful only when SMT is enabled. When SMT is disabled and STIBP is unavailable, it makes no sense to force-disable also IBPB, because IBPB protects against cross-process Spectre-BTB attacks regardless of the SMT state. At the same time since missing STIBP was only observed on AMD CPUs, AMD does not recommend using STIBP, but recommends using IBPB, so disabling IBPB because of missing STIBP goes directly against AMD's advice: https://developer.amd.com/wp-content/resources/Architecture_Guidelines_Update_Indirect_Branch_Control.pdf  Similarly, enhanced IBRS is designed to protect cross-core BTB poisoning and BTB-poisoning attacks from user space against kernel (and BTB-poisoning attacks from guest against hypervisor), it is not designed to prevent cross-process (or cross-VM) BTB poisoning between processes (or VMs) running on the same core. Therefore, even with enhanced IBRS it is necessary to flush the BTB during context-switches, so there is no reason to force disable IBPB when enhanced IBRS is available.  Enable the prctl control of IBPB even when STIBP is unavailable or enhanced IBRS is available.  Cc: stable@vger.kernel.org ",
        "func_before": "static int ib_prctl_set(struct task_struct *task, unsigned long ctrl)\n{\n\tswitch (ctrl) {\n\tcase PR_SPEC_ENABLE:\n\t\tif (spectre_v2_user == SPECTRE_V2_USER_NONE)\n\t\t\treturn 0;\n\t\t/*\n\t\t * Indirect branch speculation is always disabled in strict\n\t\t * mode.\n\t\t */\n\t\tif (spectre_v2_user == SPECTRE_V2_USER_STRICT ||\n\t\t    spectre_v2_user == SPECTRE_V2_USER_STRICT_PREFERRED)\n\t\t\treturn -EPERM;\n\t\ttask_clear_spec_ib_disable(task);\n\t\ttask_update_spec_tif(task);\n\t\tbreak;\n\tcase PR_SPEC_DISABLE:\n\tcase PR_SPEC_FORCE_DISABLE:\n\t\t/*\n\t\t * Indirect branch speculation is always allowed when\n\t\t * mitigation is force disabled.\n\t\t */\n\t\tif (spectre_v2_user == SPECTRE_V2_USER_NONE)\n\t\t\treturn -EPERM;\n\t\tif (spectre_v2_user == SPECTRE_V2_USER_STRICT ||\n\t\t    spectre_v2_user == SPECTRE_V2_USER_STRICT_PREFERRED)\n\t\t\treturn 0;\n\t\ttask_set_spec_ib_disable(task);\n\t\tif (ctrl == PR_SPEC_FORCE_DISABLE)\n\t\t\ttask_set_spec_ib_force_disable(task);\n\t\ttask_update_spec_tif(task);\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\treturn 0;\n}",
        "func": "static int ib_prctl_set(struct task_struct *task, unsigned long ctrl)\n{\n\tswitch (ctrl) {\n\tcase PR_SPEC_ENABLE:\n\t\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_NONE &&\n\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_NONE)\n\t\t\treturn 0;\n\t\t/*\n\t\t * Indirect branch speculation is always disabled in strict\n\t\t * mode.\n\t\t */\n\t\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_STRICT ||\n\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT ||\n\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT_PREFERRED)\n\t\t\treturn -EPERM;\n\t\ttask_clear_spec_ib_disable(task);\n\t\ttask_update_spec_tif(task);\n\t\tbreak;\n\tcase PR_SPEC_DISABLE:\n\tcase PR_SPEC_FORCE_DISABLE:\n\t\t/*\n\t\t * Indirect branch speculation is always allowed when\n\t\t * mitigation is force disabled.\n\t\t */\n\t\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_NONE &&\n\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_NONE)\n\t\t\treturn -EPERM;\n\t\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_STRICT ||\n\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT ||\n\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT_PREFERRED)\n\t\t\treturn 0;\n\t\ttask_set_spec_ib_disable(task);\n\t\tif (ctrl == PR_SPEC_FORCE_DISABLE)\n\t\t\ttask_set_spec_ib_force_disable(task);\n\t\ttask_update_spec_tif(task);\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,14 +2,16 @@\n {\n \tswitch (ctrl) {\n \tcase PR_SPEC_ENABLE:\n-\t\tif (spectre_v2_user == SPECTRE_V2_USER_NONE)\n+\t\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_NONE &&\n+\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_NONE)\n \t\t\treturn 0;\n \t\t/*\n \t\t * Indirect branch speculation is always disabled in strict\n \t\t * mode.\n \t\t */\n-\t\tif (spectre_v2_user == SPECTRE_V2_USER_STRICT ||\n-\t\t    spectre_v2_user == SPECTRE_V2_USER_STRICT_PREFERRED)\n+\t\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_STRICT ||\n+\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT ||\n+\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT_PREFERRED)\n \t\t\treturn -EPERM;\n \t\ttask_clear_spec_ib_disable(task);\n \t\ttask_update_spec_tif(task);\n@@ -20,10 +22,12 @@\n \t\t * Indirect branch speculation is always allowed when\n \t\t * mitigation is force disabled.\n \t\t */\n-\t\tif (spectre_v2_user == SPECTRE_V2_USER_NONE)\n+\t\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_NONE &&\n+\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_NONE)\n \t\t\treturn -EPERM;\n-\t\tif (spectre_v2_user == SPECTRE_V2_USER_STRICT ||\n-\t\t    spectre_v2_user == SPECTRE_V2_USER_STRICT_PREFERRED)\n+\t\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_STRICT ||\n+\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT ||\n+\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT_PREFERRED)\n \t\t\treturn 0;\n \t\ttask_set_spec_ib_disable(task);\n \t\tif (ctrl == PR_SPEC_FORCE_DISABLE)",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (spectre_v2_user == SPECTRE_V2_USER_NONE)",
                "\t\tif (spectre_v2_user == SPECTRE_V2_USER_STRICT ||",
                "\t\t    spectre_v2_user == SPECTRE_V2_USER_STRICT_PREFERRED)",
                "\t\tif (spectre_v2_user == SPECTRE_V2_USER_NONE)",
                "\t\tif (spectre_v2_user == SPECTRE_V2_USER_STRICT ||",
                "\t\t    spectre_v2_user == SPECTRE_V2_USER_STRICT_PREFERRED)"
            ],
            "added_lines": [
                "\t\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_NONE &&",
                "\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_NONE)",
                "\t\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_STRICT ||",
                "\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT ||",
                "\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT_PREFERRED)",
                "\t\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_NONE &&",
                "\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_NONE)",
                "\t\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_STRICT ||",
                "\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT ||",
                "\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT_PREFERRED)"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-10767",
        "func_name": "torvalds/linux/spectre_v2_user_select_mitigation",
        "description": "A flaw was found in the Linux kernel before 5.8-rc1 in the implementation of the Enhanced IBPB (Indirect Branch Prediction Barrier). The IBPB mitigation will be disabled when STIBP is not available or when the Enhanced Indirect Branch Restricted Speculation (IBRS) is available. This flaw allows a local attacker to perform a Spectre V2 style attack when this configuration is active. The highest threat from this vulnerability is to confidentiality.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=21998a351512eba4ed5969006f0c55882d995ada",
        "commit_title": "When STIBP is unavailable or enhanced IBRS is available, Linux",
        "commit_text": "force-disables the IBPB mitigation of Spectre-BTB even when simultaneous multithreading is disabled. While attempts to enable IBPB using prctl(PR_SET_SPECULATION_CTRL, PR_SPEC_INDIRECT_BRANCH, ...) fail with EPERM, the seccomp syscall (or its prctl(PR_SET_SECCOMP, ...) equivalent) which are used e.g. by Chromium or OpenSSH succeed with no errors but the application remains silently vulnerable to cross-process Spectre v2 attacks (classical BTB poisoning). At the same time the SYSFS reporting (/sys/devices/system/cpu/vulnerabilities/spectre_v2) displays that IBPB is conditionally enabled when in fact it is unconditionally disabled.  STIBP is useful only when SMT is enabled. When SMT is disabled and STIBP is unavailable, it makes no sense to force-disable also IBPB, because IBPB protects against cross-process Spectre-BTB attacks regardless of the SMT state. At the same time since missing STIBP was only observed on AMD CPUs, AMD does not recommend using STIBP, but recommends using IBPB, so disabling IBPB because of missing STIBP goes directly against AMD's advice: https://developer.amd.com/wp-content/resources/Architecture_Guidelines_Update_Indirect_Branch_Control.pdf  Similarly, enhanced IBRS is designed to protect cross-core BTB poisoning and BTB-poisoning attacks from user space against kernel (and BTB-poisoning attacks from guest against hypervisor), it is not designed to prevent cross-process (or cross-VM) BTB poisoning between processes (or VMs) running on the same core. Therefore, even with enhanced IBRS it is necessary to flush the BTB during context-switches, so there is no reason to force disable IBPB when enhanced IBRS is available.  Enable the prctl control of IBPB even when STIBP is unavailable or enhanced IBRS is available.  Cc: stable@vger.kernel.org ",
        "func_before": "static void __init\nspectre_v2_user_select_mitigation(enum spectre_v2_mitigation_cmd v2_cmd)\n{\n\tenum spectre_v2_user_mitigation mode = SPECTRE_V2_USER_NONE;\n\tbool smt_possible = IS_ENABLED(CONFIG_SMP);\n\tenum spectre_v2_user_cmd cmd;\n\n\tif (!boot_cpu_has(X86_FEATURE_IBPB) && !boot_cpu_has(X86_FEATURE_STIBP))\n\t\treturn;\n\n\tif (cpu_smt_control == CPU_SMT_FORCE_DISABLED ||\n\t    cpu_smt_control == CPU_SMT_NOT_SUPPORTED)\n\t\tsmt_possible = false;\n\n\tcmd = spectre_v2_parse_user_cmdline(v2_cmd);\n\tswitch (cmd) {\n\tcase SPECTRE_V2_USER_CMD_NONE:\n\t\tgoto set_mode;\n\tcase SPECTRE_V2_USER_CMD_FORCE:\n\t\tmode = SPECTRE_V2_USER_STRICT;\n\t\tbreak;\n\tcase SPECTRE_V2_USER_CMD_PRCTL:\n\tcase SPECTRE_V2_USER_CMD_PRCTL_IBPB:\n\t\tmode = SPECTRE_V2_USER_PRCTL;\n\t\tbreak;\n\tcase SPECTRE_V2_USER_CMD_AUTO:\n\tcase SPECTRE_V2_USER_CMD_SECCOMP:\n\tcase SPECTRE_V2_USER_CMD_SECCOMP_IBPB:\n\t\tif (IS_ENABLED(CONFIG_SECCOMP))\n\t\t\tmode = SPECTRE_V2_USER_SECCOMP;\n\t\telse\n\t\t\tmode = SPECTRE_V2_USER_PRCTL;\n\t\tbreak;\n\t}\n\n\t/*\n\t * At this point, an STIBP mode other than \"off\" has been set.\n\t * If STIBP support is not being forced, check if STIBP always-on\n\t * is preferred.\n\t */\n\tif (mode != SPECTRE_V2_USER_STRICT &&\n\t    boot_cpu_has(X86_FEATURE_AMD_STIBP_ALWAYS_ON))\n\t\tmode = SPECTRE_V2_USER_STRICT_PREFERRED;\n\n\t/* Initialize Indirect Branch Prediction Barrier */\n\tif (boot_cpu_has(X86_FEATURE_IBPB)) {\n\t\tsetup_force_cpu_cap(X86_FEATURE_USE_IBPB);\n\n\t\tswitch (cmd) {\n\t\tcase SPECTRE_V2_USER_CMD_FORCE:\n\t\tcase SPECTRE_V2_USER_CMD_PRCTL_IBPB:\n\t\tcase SPECTRE_V2_USER_CMD_SECCOMP_IBPB:\n\t\t\tstatic_branch_enable(&switch_mm_always_ibpb);\n\t\t\tbreak;\n\t\tcase SPECTRE_V2_USER_CMD_PRCTL:\n\t\tcase SPECTRE_V2_USER_CMD_AUTO:\n\t\tcase SPECTRE_V2_USER_CMD_SECCOMP:\n\t\t\tstatic_branch_enable(&switch_mm_cond_ibpb);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tpr_info(\"mitigation: Enabling %s Indirect Branch Prediction Barrier\\n\",\n\t\t\tstatic_key_enabled(&switch_mm_always_ibpb) ?\n\t\t\t\"always-on\" : \"conditional\");\n\t}\n\n\t/* If enhanced IBRS is enabled no STIBP required */\n\tif (spectre_v2_enabled == SPECTRE_V2_IBRS_ENHANCED)\n\t\treturn;\n\n\t/*\n\t * If SMT is not possible or STIBP is not available clear the STIBP\n\t * mode.\n\t */\n\tif (!smt_possible || !boot_cpu_has(X86_FEATURE_STIBP))\n\t\tmode = SPECTRE_V2_USER_NONE;\nset_mode:\n\tspectre_v2_user = mode;\n\t/* Only print the STIBP mode when SMT possible */\n\tif (smt_possible)\n\t\tpr_info(\"%s\\n\", spectre_v2_user_strings[mode]);\n}",
        "func": "static void __init\nspectre_v2_user_select_mitigation(enum spectre_v2_mitigation_cmd v2_cmd)\n{\n\tenum spectre_v2_user_mitigation mode = SPECTRE_V2_USER_NONE;\n\tbool smt_possible = IS_ENABLED(CONFIG_SMP);\n\tenum spectre_v2_user_cmd cmd;\n\n\tif (!boot_cpu_has(X86_FEATURE_IBPB) && !boot_cpu_has(X86_FEATURE_STIBP))\n\t\treturn;\n\n\tif (cpu_smt_control == CPU_SMT_FORCE_DISABLED ||\n\t    cpu_smt_control == CPU_SMT_NOT_SUPPORTED)\n\t\tsmt_possible = false;\n\n\tcmd = spectre_v2_parse_user_cmdline(v2_cmd);\n\tswitch (cmd) {\n\tcase SPECTRE_V2_USER_CMD_NONE:\n\t\tgoto set_mode;\n\tcase SPECTRE_V2_USER_CMD_FORCE:\n\t\tmode = SPECTRE_V2_USER_STRICT;\n\t\tbreak;\n\tcase SPECTRE_V2_USER_CMD_PRCTL:\n\tcase SPECTRE_V2_USER_CMD_PRCTL_IBPB:\n\t\tmode = SPECTRE_V2_USER_PRCTL;\n\t\tbreak;\n\tcase SPECTRE_V2_USER_CMD_AUTO:\n\tcase SPECTRE_V2_USER_CMD_SECCOMP:\n\tcase SPECTRE_V2_USER_CMD_SECCOMP_IBPB:\n\t\tif (IS_ENABLED(CONFIG_SECCOMP))\n\t\t\tmode = SPECTRE_V2_USER_SECCOMP;\n\t\telse\n\t\t\tmode = SPECTRE_V2_USER_PRCTL;\n\t\tbreak;\n\t}\n\n\t/* Initialize Indirect Branch Prediction Barrier */\n\tif (boot_cpu_has(X86_FEATURE_IBPB)) {\n\t\tsetup_force_cpu_cap(X86_FEATURE_USE_IBPB);\n\n\t\tswitch (cmd) {\n\t\tcase SPECTRE_V2_USER_CMD_FORCE:\n\t\tcase SPECTRE_V2_USER_CMD_PRCTL_IBPB:\n\t\tcase SPECTRE_V2_USER_CMD_SECCOMP_IBPB:\n\t\t\tstatic_branch_enable(&switch_mm_always_ibpb);\n\t\t\tbreak;\n\t\tcase SPECTRE_V2_USER_CMD_PRCTL:\n\t\tcase SPECTRE_V2_USER_CMD_AUTO:\n\t\tcase SPECTRE_V2_USER_CMD_SECCOMP:\n\t\t\tstatic_branch_enable(&switch_mm_cond_ibpb);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tpr_info(\"mitigation: Enabling %s Indirect Branch Prediction Barrier\\n\",\n\t\t\tstatic_key_enabled(&switch_mm_always_ibpb) ?\n\t\t\t\"always-on\" : \"conditional\");\n\n\t\tspectre_v2_user_ibpb = mode;\n\t}\n\n\t/*\n\t * If enhanced IBRS is enabled or SMT impossible, STIBP is not\n\t * required.\n\t */\n\tif (!smt_possible || spectre_v2_enabled == SPECTRE_V2_IBRS_ENHANCED)\n\t\treturn;\n\n\t/*\n\t * At this point, an STIBP mode other than \"off\" has been set.\n\t * If STIBP support is not being forced, check if STIBP always-on\n\t * is preferred.\n\t */\n\tif (mode != SPECTRE_V2_USER_STRICT &&\n\t    boot_cpu_has(X86_FEATURE_AMD_STIBP_ALWAYS_ON))\n\t\tmode = SPECTRE_V2_USER_STRICT_PREFERRED;\n\n\t/*\n\t * If STIBP is not available, clear the STIBP mode.\n\t */\n\tif (!boot_cpu_has(X86_FEATURE_STIBP))\n\t\tmode = SPECTRE_V2_USER_NONE;\n\n\tspectre_v2_user_stibp = mode;\n\nset_mode:\n\tpr_info(\"%s\\n\", spectre_v2_user_strings[mode]);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -33,15 +33,6 @@\n \t\tbreak;\n \t}\n \n-\t/*\n-\t * At this point, an STIBP mode other than \"off\" has been set.\n-\t * If STIBP support is not being forced, check if STIBP always-on\n-\t * is preferred.\n-\t */\n-\tif (mode != SPECTRE_V2_USER_STRICT &&\n-\t    boot_cpu_has(X86_FEATURE_AMD_STIBP_ALWAYS_ON))\n-\t\tmode = SPECTRE_V2_USER_STRICT_PREFERRED;\n-\n \t/* Initialize Indirect Branch Prediction Barrier */\n \tif (boot_cpu_has(X86_FEATURE_IBPB)) {\n \t\tsetup_force_cpu_cap(X86_FEATURE_USE_IBPB);\n@@ -64,21 +55,34 @@\n \t\tpr_info(\"mitigation: Enabling %s Indirect Branch Prediction Barrier\\n\",\n \t\t\tstatic_key_enabled(&switch_mm_always_ibpb) ?\n \t\t\t\"always-on\" : \"conditional\");\n+\n+\t\tspectre_v2_user_ibpb = mode;\n \t}\n \n-\t/* If enhanced IBRS is enabled no STIBP required */\n-\tif (spectre_v2_enabled == SPECTRE_V2_IBRS_ENHANCED)\n+\t/*\n+\t * If enhanced IBRS is enabled or SMT impossible, STIBP is not\n+\t * required.\n+\t */\n+\tif (!smt_possible || spectre_v2_enabled == SPECTRE_V2_IBRS_ENHANCED)\n \t\treturn;\n \n \t/*\n-\t * If SMT is not possible or STIBP is not available clear the STIBP\n-\t * mode.\n+\t * At this point, an STIBP mode other than \"off\" has been set.\n+\t * If STIBP support is not being forced, check if STIBP always-on\n+\t * is preferred.\n \t */\n-\tif (!smt_possible || !boot_cpu_has(X86_FEATURE_STIBP))\n+\tif (mode != SPECTRE_V2_USER_STRICT &&\n+\t    boot_cpu_has(X86_FEATURE_AMD_STIBP_ALWAYS_ON))\n+\t\tmode = SPECTRE_V2_USER_STRICT_PREFERRED;\n+\n+\t/*\n+\t * If STIBP is not available, clear the STIBP mode.\n+\t */\n+\tif (!boot_cpu_has(X86_FEATURE_STIBP))\n \t\tmode = SPECTRE_V2_USER_NONE;\n+\n+\tspectre_v2_user_stibp = mode;\n+\n set_mode:\n-\tspectre_v2_user = mode;\n-\t/* Only print the STIBP mode when SMT possible */\n-\tif (smt_possible)\n-\t\tpr_info(\"%s\\n\", spectre_v2_user_strings[mode]);\n+\tpr_info(\"%s\\n\", spectre_v2_user_strings[mode]);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t/*",
                "\t * At this point, an STIBP mode other than \"off\" has been set.",
                "\t * If STIBP support is not being forced, check if STIBP always-on",
                "\t * is preferred.",
                "\t */",
                "\tif (mode != SPECTRE_V2_USER_STRICT &&",
                "\t    boot_cpu_has(X86_FEATURE_AMD_STIBP_ALWAYS_ON))",
                "\t\tmode = SPECTRE_V2_USER_STRICT_PREFERRED;",
                "",
                "\t/* If enhanced IBRS is enabled no STIBP required */",
                "\tif (spectre_v2_enabled == SPECTRE_V2_IBRS_ENHANCED)",
                "\t * If SMT is not possible or STIBP is not available clear the STIBP",
                "\t * mode.",
                "\tif (!smt_possible || !boot_cpu_has(X86_FEATURE_STIBP))",
                "\tspectre_v2_user = mode;",
                "\t/* Only print the STIBP mode when SMT possible */",
                "\tif (smt_possible)",
                "\t\tpr_info(\"%s\\n\", spectre_v2_user_strings[mode]);"
            ],
            "added_lines": [
                "",
                "\t\tspectre_v2_user_ibpb = mode;",
                "\t/*",
                "\t * If enhanced IBRS is enabled or SMT impossible, STIBP is not",
                "\t * required.",
                "\t */",
                "\tif (!smt_possible || spectre_v2_enabled == SPECTRE_V2_IBRS_ENHANCED)",
                "\t * At this point, an STIBP mode other than \"off\" has been set.",
                "\t * If STIBP support is not being forced, check if STIBP always-on",
                "\t * is preferred.",
                "\tif (mode != SPECTRE_V2_USER_STRICT &&",
                "\t    boot_cpu_has(X86_FEATURE_AMD_STIBP_ALWAYS_ON))",
                "\t\tmode = SPECTRE_V2_USER_STRICT_PREFERRED;",
                "",
                "\t/*",
                "\t * If STIBP is not available, clear the STIBP mode.",
                "\t */",
                "\tif (!boot_cpu_has(X86_FEATURE_STIBP))",
                "",
                "\tspectre_v2_user_stibp = mode;",
                "",
                "\tpr_info(\"%s\\n\", spectre_v2_user_strings[mode]);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-10767",
        "func_name": "torvalds/linux/arch_seccomp_spec_mitigate",
        "description": "A flaw was found in the Linux kernel before 5.8-rc1 in the implementation of the Enhanced IBPB (Indirect Branch Prediction Barrier). The IBPB mitigation will be disabled when STIBP is not available or when the Enhanced Indirect Branch Restricted Speculation (IBRS) is available. This flaw allows a local attacker to perform a Spectre V2 style attack when this configuration is active. The highest threat from this vulnerability is to confidentiality.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=21998a351512eba4ed5969006f0c55882d995ada",
        "commit_title": "When STIBP is unavailable or enhanced IBRS is available, Linux",
        "commit_text": "force-disables the IBPB mitigation of Spectre-BTB even when simultaneous multithreading is disabled. While attempts to enable IBPB using prctl(PR_SET_SPECULATION_CTRL, PR_SPEC_INDIRECT_BRANCH, ...) fail with EPERM, the seccomp syscall (or its prctl(PR_SET_SECCOMP, ...) equivalent) which are used e.g. by Chromium or OpenSSH succeed with no errors but the application remains silently vulnerable to cross-process Spectre v2 attacks (classical BTB poisoning). At the same time the SYSFS reporting (/sys/devices/system/cpu/vulnerabilities/spectre_v2) displays that IBPB is conditionally enabled when in fact it is unconditionally disabled.  STIBP is useful only when SMT is enabled. When SMT is disabled and STIBP is unavailable, it makes no sense to force-disable also IBPB, because IBPB protects against cross-process Spectre-BTB attacks regardless of the SMT state. At the same time since missing STIBP was only observed on AMD CPUs, AMD does not recommend using STIBP, but recommends using IBPB, so disabling IBPB because of missing STIBP goes directly against AMD's advice: https://developer.amd.com/wp-content/resources/Architecture_Guidelines_Update_Indirect_Branch_Control.pdf  Similarly, enhanced IBRS is designed to protect cross-core BTB poisoning and BTB-poisoning attacks from user space against kernel (and BTB-poisoning attacks from guest against hypervisor), it is not designed to prevent cross-process (or cross-VM) BTB poisoning between processes (or VMs) running on the same core. Therefore, even with enhanced IBRS it is necessary to flush the BTB during context-switches, so there is no reason to force disable IBPB when enhanced IBRS is available.  Enable the prctl control of IBPB even when STIBP is unavailable or enhanced IBRS is available.  Cc: stable@vger.kernel.org ",
        "func_before": "void arch_seccomp_spec_mitigate(struct task_struct *task)\n{\n\tif (ssb_mode == SPEC_STORE_BYPASS_SECCOMP)\n\t\tssb_prctl_set(task, PR_SPEC_FORCE_DISABLE);\n\tif (spectre_v2_user == SPECTRE_V2_USER_SECCOMP)\n\t\tib_prctl_set(task, PR_SPEC_FORCE_DISABLE);\n}",
        "func": "void arch_seccomp_spec_mitigate(struct task_struct *task)\n{\n\tif (ssb_mode == SPEC_STORE_BYPASS_SECCOMP)\n\t\tssb_prctl_set(task, PR_SPEC_FORCE_DISABLE);\n\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_SECCOMP ||\n\t    spectre_v2_user_stibp == SPECTRE_V2_USER_SECCOMP)\n\t\tib_prctl_set(task, PR_SPEC_FORCE_DISABLE);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,7 @@\n {\n \tif (ssb_mode == SPEC_STORE_BYPASS_SECCOMP)\n \t\tssb_prctl_set(task, PR_SPEC_FORCE_DISABLE);\n-\tif (spectre_v2_user == SPECTRE_V2_USER_SECCOMP)\n+\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_SECCOMP ||\n+\t    spectre_v2_user_stibp == SPECTRE_V2_USER_SECCOMP)\n \t\tib_prctl_set(task, PR_SPEC_FORCE_DISABLE);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (spectre_v2_user == SPECTRE_V2_USER_SECCOMP)"
            ],
            "added_lines": [
                "\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_SECCOMP ||",
                "\t    spectre_v2_user_stibp == SPECTRE_V2_USER_SECCOMP)"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-10767",
        "func_name": "torvalds/linux/cpu_bugs_smt_update",
        "description": "A flaw was found in the Linux kernel before 5.8-rc1 in the implementation of the Enhanced IBPB (Indirect Branch Prediction Barrier). The IBPB mitigation will be disabled when STIBP is not available or when the Enhanced Indirect Branch Restricted Speculation (IBRS) is available. This flaw allows a local attacker to perform a Spectre V2 style attack when this configuration is active. The highest threat from this vulnerability is to confidentiality.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=21998a351512eba4ed5969006f0c55882d995ada",
        "commit_title": "When STIBP is unavailable or enhanced IBRS is available, Linux",
        "commit_text": "force-disables the IBPB mitigation of Spectre-BTB even when simultaneous multithreading is disabled. While attempts to enable IBPB using prctl(PR_SET_SPECULATION_CTRL, PR_SPEC_INDIRECT_BRANCH, ...) fail with EPERM, the seccomp syscall (or its prctl(PR_SET_SECCOMP, ...) equivalent) which are used e.g. by Chromium or OpenSSH succeed with no errors but the application remains silently vulnerable to cross-process Spectre v2 attacks (classical BTB poisoning). At the same time the SYSFS reporting (/sys/devices/system/cpu/vulnerabilities/spectre_v2) displays that IBPB is conditionally enabled when in fact it is unconditionally disabled.  STIBP is useful only when SMT is enabled. When SMT is disabled and STIBP is unavailable, it makes no sense to force-disable also IBPB, because IBPB protects against cross-process Spectre-BTB attacks regardless of the SMT state. At the same time since missing STIBP was only observed on AMD CPUs, AMD does not recommend using STIBP, but recommends using IBPB, so disabling IBPB because of missing STIBP goes directly against AMD's advice: https://developer.amd.com/wp-content/resources/Architecture_Guidelines_Update_Indirect_Branch_Control.pdf  Similarly, enhanced IBRS is designed to protect cross-core BTB poisoning and BTB-poisoning attacks from user space against kernel (and BTB-poisoning attacks from guest against hypervisor), it is not designed to prevent cross-process (or cross-VM) BTB poisoning between processes (or VMs) running on the same core. Therefore, even with enhanced IBRS it is necessary to flush the BTB during context-switches, so there is no reason to force disable IBPB when enhanced IBRS is available.  Enable the prctl control of IBPB even when STIBP is unavailable or enhanced IBRS is available.  Cc: stable@vger.kernel.org ",
        "func_before": "void cpu_bugs_smt_update(void)\n{\n\tmutex_lock(&spec_ctrl_mutex);\n\n\tswitch (spectre_v2_user) {\n\tcase SPECTRE_V2_USER_NONE:\n\t\tbreak;\n\tcase SPECTRE_V2_USER_STRICT:\n\tcase SPECTRE_V2_USER_STRICT_PREFERRED:\n\t\tupdate_stibp_strict();\n\t\tbreak;\n\tcase SPECTRE_V2_USER_PRCTL:\n\tcase SPECTRE_V2_USER_SECCOMP:\n\t\tupdate_indir_branch_cond();\n\t\tbreak;\n\t}\n\n\tswitch (mds_mitigation) {\n\tcase MDS_MITIGATION_FULL:\n\tcase MDS_MITIGATION_VMWERV:\n\t\tif (sched_smt_active() && !boot_cpu_has(X86_BUG_MSBDS_ONLY))\n\t\t\tpr_warn_once(MDS_MSG_SMT);\n\t\tupdate_mds_branch_idle();\n\t\tbreak;\n\tcase MDS_MITIGATION_OFF:\n\t\tbreak;\n\t}\n\n\tswitch (taa_mitigation) {\n\tcase TAA_MITIGATION_VERW:\n\tcase TAA_MITIGATION_UCODE_NEEDED:\n\t\tif (sched_smt_active())\n\t\t\tpr_warn_once(TAA_MSG_SMT);\n\t\tbreak;\n\tcase TAA_MITIGATION_TSX_DISABLED:\n\tcase TAA_MITIGATION_OFF:\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&spec_ctrl_mutex);\n}",
        "func": "void cpu_bugs_smt_update(void)\n{\n\tmutex_lock(&spec_ctrl_mutex);\n\n\tswitch (spectre_v2_user_stibp) {\n\tcase SPECTRE_V2_USER_NONE:\n\t\tbreak;\n\tcase SPECTRE_V2_USER_STRICT:\n\tcase SPECTRE_V2_USER_STRICT_PREFERRED:\n\t\tupdate_stibp_strict();\n\t\tbreak;\n\tcase SPECTRE_V2_USER_PRCTL:\n\tcase SPECTRE_V2_USER_SECCOMP:\n\t\tupdate_indir_branch_cond();\n\t\tbreak;\n\t}\n\n\tswitch (mds_mitigation) {\n\tcase MDS_MITIGATION_FULL:\n\tcase MDS_MITIGATION_VMWERV:\n\t\tif (sched_smt_active() && !boot_cpu_has(X86_BUG_MSBDS_ONLY))\n\t\t\tpr_warn_once(MDS_MSG_SMT);\n\t\tupdate_mds_branch_idle();\n\t\tbreak;\n\tcase MDS_MITIGATION_OFF:\n\t\tbreak;\n\t}\n\n\tswitch (taa_mitigation) {\n\tcase TAA_MITIGATION_VERW:\n\tcase TAA_MITIGATION_UCODE_NEEDED:\n\t\tif (sched_smt_active())\n\t\t\tpr_warn_once(TAA_MSG_SMT);\n\t\tbreak;\n\tcase TAA_MITIGATION_TSX_DISABLED:\n\tcase TAA_MITIGATION_OFF:\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&spec_ctrl_mutex);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n {\n \tmutex_lock(&spec_ctrl_mutex);\n \n-\tswitch (spectre_v2_user) {\n+\tswitch (spectre_v2_user_stibp) {\n \tcase SPECTRE_V2_USER_NONE:\n \t\tbreak;\n \tcase SPECTRE_V2_USER_STRICT:",
        "diff_line_info": {
            "deleted_lines": [
                "\tswitch (spectre_v2_user) {"
            ],
            "added_lines": [
                "\tswitch (spectre_v2_user_stibp) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-10768",
        "func_name": "torvalds/linux/ib_prctl_set",
        "description": "A flaw was found in the Linux Kernel before 5.8-rc1 in the prctl() function, where it can be used to enable indirect branch speculation after it has been disabled. This call incorrectly reports it as being 'force disabled' when it is not and opens the system to Spectre v2 attacks. The highest threat from this vulnerability is to confidentiality.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=4d8df8cbb9156b0a0ab3f802b80cb5db57acc0bf",
        "commit_title": "Currently, it is possible to enable indirect branch speculation even after",
        "commit_text": "it was force-disabled using the PR_SPEC_FORCE_DISABLE option. Moreover, the PR_GET_SPECULATION_CTRL command gives afterwards an incorrect result (force-disabled when it is in fact enabled). This also is inconsistent vs. STIBP and the documention which cleary states that PR_SPEC_FORCE_DISABLE cannot be undone.  Fix this by actually enforcing force-disabled indirect branch speculation. PR_SPEC_ENABLE called after PR_SPEC_FORCE_DISABLE now fails with -EPERM as described in the documentation.  Cc: stable@vger.kernel.org ",
        "func_before": "static int ib_prctl_set(struct task_struct *task, unsigned long ctrl)\n{\n\tswitch (ctrl) {\n\tcase PR_SPEC_ENABLE:\n\t\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_NONE &&\n\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_NONE)\n\t\t\treturn 0;\n\t\t/*\n\t\t * Indirect branch speculation is always disabled in strict\n\t\t * mode.\n\t\t */\n\t\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_STRICT ||\n\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT ||\n\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT_PREFERRED)\n\t\t\treturn -EPERM;\n\t\ttask_clear_spec_ib_disable(task);\n\t\ttask_update_spec_tif(task);\n\t\tbreak;\n\tcase PR_SPEC_DISABLE:\n\tcase PR_SPEC_FORCE_DISABLE:\n\t\t/*\n\t\t * Indirect branch speculation is always allowed when\n\t\t * mitigation is force disabled.\n\t\t */\n\t\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_NONE &&\n\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_NONE)\n\t\t\treturn -EPERM;\n\t\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_STRICT ||\n\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT ||\n\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT_PREFERRED)\n\t\t\treturn 0;\n\t\ttask_set_spec_ib_disable(task);\n\t\tif (ctrl == PR_SPEC_FORCE_DISABLE)\n\t\t\ttask_set_spec_ib_force_disable(task);\n\t\ttask_update_spec_tif(task);\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\treturn 0;\n}",
        "func": "static int ib_prctl_set(struct task_struct *task, unsigned long ctrl)\n{\n\tswitch (ctrl) {\n\tcase PR_SPEC_ENABLE:\n\t\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_NONE &&\n\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_NONE)\n\t\t\treturn 0;\n\t\t/*\n\t\t * Indirect branch speculation is always disabled in strict\n\t\t * mode. It can neither be enabled if it was force-disabled\n\t\t * by a  previous prctl call.\n\n\t\t */\n\t\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_STRICT ||\n\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT ||\n\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT_PREFERRED ||\n\t\t    task_spec_ib_force_disable(task))\n\t\t\treturn -EPERM;\n\t\ttask_clear_spec_ib_disable(task);\n\t\ttask_update_spec_tif(task);\n\t\tbreak;\n\tcase PR_SPEC_DISABLE:\n\tcase PR_SPEC_FORCE_DISABLE:\n\t\t/*\n\t\t * Indirect branch speculation is always allowed when\n\t\t * mitigation is force disabled.\n\t\t */\n\t\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_NONE &&\n\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_NONE)\n\t\t\treturn -EPERM;\n\t\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_STRICT ||\n\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT ||\n\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT_PREFERRED)\n\t\t\treturn 0;\n\t\ttask_set_spec_ib_disable(task);\n\t\tif (ctrl == PR_SPEC_FORCE_DISABLE)\n\t\t\ttask_set_spec_ib_force_disable(task);\n\t\ttask_update_spec_tif(task);\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,11 +7,14 @@\n \t\t\treturn 0;\n \t\t/*\n \t\t * Indirect branch speculation is always disabled in strict\n-\t\t * mode.\n+\t\t * mode. It can neither be enabled if it was force-disabled\n+\t\t * by a  previous prctl call.\n+\n \t\t */\n \t\tif (spectre_v2_user_ibpb == SPECTRE_V2_USER_STRICT ||\n \t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT ||\n-\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT_PREFERRED)\n+\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT_PREFERRED ||\n+\t\t    task_spec_ib_force_disable(task))\n \t\t\treturn -EPERM;\n \t\ttask_clear_spec_ib_disable(task);\n \t\ttask_update_spec_tif(task);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t * mode.",
                "\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT_PREFERRED)"
            ],
            "added_lines": [
                "\t\t * mode. It can neither be enabled if it was force-disabled",
                "\t\t * by a  previous prctl call.",
                "",
                "\t\t    spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT_PREFERRED ||",
                "\t\t    task_spec_ib_force_disable(task))"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-32732",
        "func_name": "grpc/HandleMetadataSizeLimitExceeded",
        "description": "gRPC contains a vulnerability whereby a client can cause a termination of connection between a HTTP2 proxy and a gRPC server: a base64 encoding error for `-bin` suffixed headers will result in a disconnection by the gRPC server, but is typically allowed by HTTP2 proxies. We recommend upgrading beyond the commit in https://github.com/grpc/grpc/pull/32309 https://www.google.com/url \n",
        "git_url": "https://github.com/grpc/grpc/commit/6a7850ef4f042ac26559854266dddc79bfbc75b2",
        "commit_title": "[http] Dont drop connections on metadata limit exceeded",
        "commit_text": "",
        "func_before": "GPR_ATTRIBUTE_NOINLINE\n  bool HandleMetadataSizeLimitExceeded(const HPackTable::Memento& md) {\n    // Collect a summary of sizes so far for debugging\n    // Do not collect contents, for fear of exposing PII.\n    std::string summary;\n    if (metadata_buffer_ != nullptr) {\n      MetadataSizeLimitExceededEncoder encoder(summary);\n      metadata_buffer_->Encode(&encoder);\n    }\n    summary =\n        absl::StrCat(\"; adding \", md.key(), \" (length \", md.transport_size(),\n                     \"B)\", summary.empty() ? \"\" : \" to \", summary);\n    if (metadata_buffer_ != nullptr) metadata_buffer_->Clear();\n    return input_->MaybeSetErrorAndReturn(\n        [this, summary = std::move(summary)] {\n          return grpc_error_set_int(\n              GRPC_ERROR_CREATE(absl::StrCat(\n                  \"received initial metadata size exceeds limit (\",\n                  *frame_length_, \" vs. \", metadata_size_limit_, \")\", summary)),\n              StatusIntProperty::kRpcStatus, GRPC_STATUS_RESOURCE_EXHAUSTED);\n        },\n        false);\n  }",
        "func": "GPR_ATTRIBUTE_NOINLINE\n  bool HandleMetadataSizeLimitExceeded(const HPackTable::Memento& md) {\n    // Collect a summary of sizes so far for debugging\n    // Do not collect contents, for fear of exposing PII.\n    std::string summary;\n    if (metadata_buffer_ != nullptr) {\n      MetadataSizeLimitExceededEncoder encoder(summary);\n      metadata_buffer_->Encode(&encoder);\n    }\n    summary =\n        absl::StrCat(\"; adding \", md.key(), \" (length \", md.transport_size(),\n                     \"B)\", summary.empty() ? \"\" : \" to \", summary);\n    if (metadata_buffer_ != nullptr) metadata_buffer_->Clear();\n    // StreamId is used as a signal to skip this stream but keep the connection\n    // alive\n    return input_->MaybeSetErrorAndReturn(\n        [this, summary = std::move(summary)] {\n          return grpc_error_set_int(\n              grpc_error_set_int(\n                  GRPC_ERROR_CREATE(absl::StrCat(\n                      \"received initial metadata size exceeds limit (\",\n                      *frame_length_, \" vs. \", metadata_size_limit_, \")\",\n                      summary)),\n                  StatusIntProperty::kRpcStatus,\n                  GRPC_STATUS_RESOURCE_EXHAUSTED),\n              StatusIntProperty::kStreamId, 0);\n        },\n        false);\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,13 +11,19 @@\n         absl::StrCat(\"; adding \", md.key(), \" (length \", md.transport_size(),\n                      \"B)\", summary.empty() ? \"\" : \" to \", summary);\n     if (metadata_buffer_ != nullptr) metadata_buffer_->Clear();\n+    // StreamId is used as a signal to skip this stream but keep the connection\n+    // alive\n     return input_->MaybeSetErrorAndReturn(\n         [this, summary = std::move(summary)] {\n           return grpc_error_set_int(\n-              GRPC_ERROR_CREATE(absl::StrCat(\n-                  \"received initial metadata size exceeds limit (\",\n-                  *frame_length_, \" vs. \", metadata_size_limit_, \")\", summary)),\n-              StatusIntProperty::kRpcStatus, GRPC_STATUS_RESOURCE_EXHAUSTED);\n+              grpc_error_set_int(\n+                  GRPC_ERROR_CREATE(absl::StrCat(\n+                      \"received initial metadata size exceeds limit (\",\n+                      *frame_length_, \" vs. \", metadata_size_limit_, \")\",\n+                      summary)),\n+                  StatusIntProperty::kRpcStatus,\n+                  GRPC_STATUS_RESOURCE_EXHAUSTED),\n+              StatusIntProperty::kStreamId, 0);\n         },\n         false);\n   }",
        "diff_line_info": {
            "deleted_lines": [
                "              GRPC_ERROR_CREATE(absl::StrCat(",
                "                  \"received initial metadata size exceeds limit (\",",
                "                  *frame_length_, \" vs. \", metadata_size_limit_, \")\", summary)),",
                "              StatusIntProperty::kRpcStatus, GRPC_STATUS_RESOURCE_EXHAUSTED);"
            ],
            "added_lines": [
                "    // StreamId is used as a signal to skip this stream but keep the connection",
                "    // alive",
                "              grpc_error_set_int(",
                "                  GRPC_ERROR_CREATE(absl::StrCat(",
                "                      \"received initial metadata size exceeds limit (\",",
                "                      *frame_length_, \" vs. \", metadata_size_limit_, \")\",",
                "                      summary)),",
                "                  StatusIntProperty::kRpcStatus,",
                "                  GRPC_STATUS_RESOURCE_EXHAUSTED),",
                "              StatusIntProperty::kStreamId, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-32732",
        "func_name": "grpc/parse_frame_slice",
        "description": "gRPC contains a vulnerability whereby a client can cause a termination of connection between a HTTP2 proxy and a gRPC server: a base64 encoding error for `-bin` suffixed headers will result in a disconnection by the gRPC server, but is typically allowed by HTTP2 proxies. We recommend upgrading beyond the commit in https://github.com/grpc/grpc/pull/32309 https://www.google.com/url \n",
        "git_url": "https://github.com/grpc/grpc/commit/6a7850ef4f042ac26559854266dddc79bfbc75b2",
        "commit_title": "[http] Dont drop connections on metadata limit exceeded",
        "commit_text": "",
        "func_before": "static grpc_error_handle parse_frame_slice(grpc_chttp2_transport* t,\n                                           const grpc_slice& slice,\n                                           int is_last) {\n  grpc_chttp2_stream* s = t->incoming_stream;\n  if (grpc_http_trace.enabled()) {\n    gpr_log(GPR_DEBUG,\n            \"INCOMING[%p;%p]: Parse %\" PRIdPTR \"b %sframe fragment with %s\", t,\n            s, GRPC_SLICE_LENGTH(slice), is_last ? \"last \" : \"\",\n            t->parser.name);\n  }\n  grpc_error_handle err =\n      t->parser.parser(t->parser.user_data, t, s, slice, is_last);\n  intptr_t unused;\n  if (GPR_LIKELY(err.ok())) {\n    return err;\n  }\n  if (grpc_http_trace.enabled()) {\n    gpr_log(GPR_ERROR, \"INCOMING[%p;%p]: Parse failed with %s\", t, s,\n            err.ToString().c_str());\n  }\n  if (grpc_error_get_int(err, grpc_core::StatusIntProperty::kStreamId,\n                         &unused)) {\n    grpc_chttp2_parsing_become_skip_parser(t);\n    if (s) {\n      s->forced_close_error = err;\n      grpc_chttp2_add_rst_stream_to_next_write(t, t->incoming_stream_id,\n                                               GRPC_HTTP2_PROTOCOL_ERROR,\n                                               &s->stats.outgoing);\n    }\n  }\n  return err;\n}",
        "func": "static grpc_error_handle parse_frame_slice(grpc_chttp2_transport* t,\n                                           const grpc_slice& slice,\n                                           int is_last) {\n  grpc_chttp2_stream* s = t->incoming_stream;\n  if (grpc_http_trace.enabled()) {\n    gpr_log(GPR_DEBUG,\n            \"INCOMING[%p;%p]: Parse %\" PRIdPTR \"b %sframe fragment with %s\", t,\n            s, GRPC_SLICE_LENGTH(slice), is_last ? \"last \" : \"\",\n            t->parser.name);\n  }\n  grpc_error_handle err =\n      t->parser.parser(t->parser.user_data, t, s, slice, is_last);\n  intptr_t unused;\n  if (GPR_LIKELY(err.ok())) {\n    return err;\n  }\n  if (grpc_http_trace.enabled()) {\n    gpr_log(GPR_ERROR, \"INCOMING[%p;%p]: Parse failed with %s\", t, s,\n            err.ToString().c_str());\n  }\n  if (grpc_error_get_int(err, grpc_core::StatusIntProperty::kStreamId,\n                         &unused)) {\n    grpc_chttp2_parsing_become_skip_parser(t);\n    if (s) {\n      grpc_chttp2_cancel_stream(t, s, std::exchange(err, absl::OkStatus()));\n    }\n  }\n  return err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,10 +22,7 @@\n                          &unused)) {\n     grpc_chttp2_parsing_become_skip_parser(t);\n     if (s) {\n-      s->forced_close_error = err;\n-      grpc_chttp2_add_rst_stream_to_next_write(t, t->incoming_stream_id,\n-                                               GRPC_HTTP2_PROTOCOL_ERROR,\n-                                               &s->stats.outgoing);\n+      grpc_chttp2_cancel_stream(t, s, std::exchange(err, absl::OkStatus()));\n     }\n   }\n   return err;",
        "diff_line_info": {
            "deleted_lines": [
                "      s->forced_close_error = err;",
                "      grpc_chttp2_add_rst_stream_to_next_write(t, t->incoming_stream_id,",
                "                                               GRPC_HTTP2_PROTOCOL_ERROR,",
                "                                               &s->stats.outgoing);"
            ],
            "added_lines": [
                "      grpc_chttp2_cancel_stream(t, s, std::exchange(err, absl::OkStatus()));"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41035",
        "func_name": "eclipse-openj9/openj9/Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex",
        "description": "In Eclipse Openj9 before version 0.29.0, the JVM does not throw IllegalAccessError for MethodHandles that invoke inaccessible interface methods.",
        "git_url": "https://github.com/eclipse-openj9/openj9/commit/c6e0d9296ff9a3084965d83e207403de373c0bad",
        "commit_title": "Throw IAE when an InterfaceHandle thunk finds a non-public method",
        "commit_text": " The interface dispatch implemented by InterfaceHandle is supposed to throw IllegalAccessError (IAE) when the dispatched callee is not public, just like the dispatch performed by invokeinterface.",
        "func_before": "JNIEXPORT jint JNICALL Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex\n  (JNIEnv *env, jclass InterfaceMethodHandle, jlong interfaceArg, jint itableIndex, jlong receiverClassArg)\n   {\n   J9Class  *interfaceClass = (J9Class*)(intptr_t)interfaceArg;\n   J9Class  *receiverClass  = (J9Class*)(intptr_t)receiverClassArg;\n   J9ITable *itableEntry;\n   for (itableEntry = (J9ITable*)receiverClass->iTable; itableEntry; itableEntry = itableEntry->next)\n      if (itableEntry->interfaceClass == interfaceClass)\n         break;\n   TR_ASSERT(itableEntry, \"Shouldn't call convertITableIndexToVTableIndex without first ensuring the receiver implements the interface\");\n   UDATA *itableArray = (UDATA*)(itableEntry+1);\n   return (itableArray[itableIndex] - sizeof(J9Class))/sizeof(intptr_t);\n#if 0 // TODO:JSR292: We probably want to do something more like this instead, so it will properly handle exceptional cases\n   struct\n      {\n      UDATA interfaceClass;\n      UDATA methodIndex;\n      } indexAndLiterals =\n      {\n      (UDATA)interfaceClass,\n      (UDATA)itableIndex\n      };\n   J9Object *receiver = (J9Object*)receiverArg;\n   return (jint)jitLookupInterfaceMethod(receiver->clazz, &indexAndLiterals, 0);\n#endif\n   }",
        "func": "JNIEXPORT jint JNICALL Java_java_lang_invoke_InterfaceHandle_convertITableIndexToVTableIndex\n  (JNIEnv *env, jclass InterfaceMethodHandle, jlong interfaceArg, jint itableIndex, jlong receiverClassArg)\n   {\n   J9Class  *interfaceClass = (J9Class*)(intptr_t)interfaceArg;\n   J9Class  *receiverClass  = (J9Class*)(intptr_t)receiverClassArg;\n   J9ITable *itableEntry;\n   for (itableEntry = (J9ITable*)receiverClass->iTable; itableEntry; itableEntry = itableEntry->next)\n      if (itableEntry->interfaceClass == interfaceClass)\n         break;\n   TR_ASSERT(itableEntry, \"Shouldn't call convertITableIndexToVTableIndex without first ensuring the receiver implements the interface\");\n   UDATA *itableArray = (UDATA*)(itableEntry+1);\n   UDATA vTableOffset = itableArray[itableIndex];\n   J9Method *method = *(J9Method**)((UDATA)receiverClass + vTableOffset);\n   if ((J9_ROM_METHOD_FROM_RAM_METHOD(method)->modifiers & J9AccPublic) == 0)\n      return -1;\n\n   return (vTableOffset - sizeof(J9Class))/sizeof(intptr_t);\n#if 0 // TODO:JSR292: We probably want to do something more like this instead, so it will properly handle exceptional cases\n   struct\n      {\n      UDATA interfaceClass;\n      UDATA methodIndex;\n      } indexAndLiterals =\n      {\n      (UDATA)interfaceClass,\n      (UDATA)itableIndex\n      };\n   J9Object *receiver = (J9Object*)receiverArg;\n   return (jint)jitLookupInterfaceMethod(receiver->clazz, &indexAndLiterals, 0);\n#endif\n   }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,12 @@\n          break;\n    TR_ASSERT(itableEntry, \"Shouldn't call convertITableIndexToVTableIndex without first ensuring the receiver implements the interface\");\n    UDATA *itableArray = (UDATA*)(itableEntry+1);\n-   return (itableArray[itableIndex] - sizeof(J9Class))/sizeof(intptr_t);\n+   UDATA vTableOffset = itableArray[itableIndex];\n+   J9Method *method = *(J9Method**)((UDATA)receiverClass + vTableOffset);\n+   if ((J9_ROM_METHOD_FROM_RAM_METHOD(method)->modifiers & J9AccPublic) == 0)\n+      return -1;\n+\n+   return (vTableOffset - sizeof(J9Class))/sizeof(intptr_t);\n #if 0 // TODO:JSR292: We probably want to do something more like this instead, so it will properly handle exceptional cases\n    struct\n       {",
        "diff_line_info": {
            "deleted_lines": [
                "   return (itableArray[itableIndex] - sizeof(J9Class))/sizeof(intptr_t);"
            ],
            "added_lines": [
                "   UDATA vTableOffset = itableArray[itableIndex];",
                "   J9Method *method = *(J9Method**)((UDATA)receiverClass + vTableOffset);",
                "   if ((J9_ROM_METHOD_FROM_RAM_METHOD(method)->modifiers & J9AccPublic) == 0)",
                "      return -1;",
                "",
                "   return (vTableOffset - sizeof(J9Class))/sizeof(intptr_t);"
            ]
        }
    }
]