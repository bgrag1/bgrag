[
    {
        "cve_id": "CVE-2017-5473",
        "func_name": "ntop/ntopng/Lua::handle_script_request",
        "description": "Cross-site request forgery (CSRF) vulnerability in ntopng through 2.4 allows remote attackers to hijack the authentication of arbitrary users, as demonstrated by admin/add_user.lua, admin/change_user_prefs.lua, admin/delete_user.lua, and admin/password_reset.lua.",
        "git_url": "https://github.com/ntop/ntopng/commit/f91fbe3d94c8346884271838ae3406ae633f6f15",
        "commit_title": "Check for presence of crsf in admin scripts",
        "commit_text": "",
        "func_before": "int Lua::handle_script_request(struct mg_connection *conn,\n\t\t\t       const struct mg_request_info *request_info,\n\t\t\t       char *script_path) {\n  char buf[64], key[64], ifname[MAX_INTERFACE_NAME_LEN];\n  char *_cookies, user[64] = { '\\0' }, outbuf[FILENAME_MAX];\n  AddressTree ptree;\n  int rc;\n\n  if(!L) return(-1);\n\n  luaL_openlibs(L); /* Load base libraries */\n  lua_register_classes(L, true); /* Load custom classes */\n\n  lua_pushlightuserdata(L, (char*)conn);\n  lua_setglobal(L, CONST_HTTP_CONN);\n\n  /* Put the GET params into the environment */\n  lua_newtable(L);\n  if(request_info->query_string != NULL) {\n    char *query_string = strdup(request_info->query_string);\n\n    if(query_string) {\n      char *where;\n      char *tok;\n\n      // ntop->getTrace()->traceEvent(TRACE_WARNING, \"[HTTP] %s\", query_string);\n\n      tok = strtok_r(query_string, \"&\", &where);\n\n      while(tok != NULL) {\n\t/* key=val */\n\tchar *_equal = strchr(tok, '=');\n\n\tif(_equal) {\n\t  char *equal;\n\t  int len;\n\n\t  _equal[0] = '\\0';\n\t  _equal = &_equal[1];\n\t  len = strlen(_equal);\n\n\t  purifyHTTPParameter(tok), purifyHTTPParameter(_equal);\n\n\t  // ntop->getTrace()->traceEvent(TRACE_WARNING, \"%s = %s\", tok, _equal);\n\n\t  if((equal = (char*)malloc(len+1)) != NULL) {\n\t    char *decoded_buf;\n\n\t    Utils::urlDecode(_equal, equal, len+1);\n\n\t    if((decoded_buf = http_decode(equal)) != NULL) {\n\t      FILE *fd;\n\n\t      Utils::purifyHTTPparam(tok, true, false);\n\t      Utils::purifyHTTPparam(decoded_buf, false, false);\n\n\t      /* Now make sure that decoded_buf is not a file path */\n\t      if((decoded_buf[0] == '.')\n\t\t && ((fd = fopen(decoded_buf, \"r\"))\n\t\t     || (fd = fopen(realpath(decoded_buf, outbuf), \"r\")))) {\n\t\tntop->getTrace()->traceEvent(TRACE_WARNING, \"Discarded '%s'='%s' as argument is a valid file path\",\n\t\t\t\t\t     tok, decoded_buf);\n\n\t\tdecoded_buf[0] = '\\0';\n\t\tfclose(fd);\n\t      }\n\n\t      /* ntop->getTrace()->traceEvent(TRACE_WARNING, \"'%s'='%s'\", tok, decoded_buf); */\n\n\t      if(strcmp(tok, \"csrf\") == 0) {\n\t\tchar rsp[32], user[64] = { '\\0' };\n\n\t\tmg_get_cookie(conn, \"user\", user, sizeof(user));\n\n\t\tif((ntop->getRedis()->get(decoded_buf, rsp, sizeof(rsp)) == -1)\n\t\t   || (strcmp(rsp, user) != 0)) {\n\t\t  const char *msg = \"The submitted form is expired. Please reload the page and try again\";\n\n\t\t  ntop->getTrace()->traceEvent(TRACE_WARNING,\n\t\t\t\t\t       \"Invalid CSRF parameter specified [%s][%s][%s][%s]: page expired?\",\n\t\t\t\t\t       decoded_buf, rsp, user, tok);\n\t\t  free(equal);\n\t\t  return(send_error(conn, 500 /* Internal server error */,\n\t\t\t\t    msg, PAGE_ERROR, query_string, msg));\n\t\t} else\n\t\t  ntop->getRedis()->delKey(decoded_buf);\n\t      }\n\n\t      lua_push_str_table_entry(L, tok, decoded_buf);\n\t      free(decoded_buf);\n\t    }\n\n\t    free(equal);\n\t  } else\n\t    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");\n\t}\n\n\ttok = strtok_r(NULL, \"&\", &where);\n      } /* while */\n\n      free(query_string);\n    } else\n      ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");\n  }\n  lua_setglobal(L, \"_GET\"); /* Like in php */\n\n  /* _SERVER */\n  lua_newtable(L);\n  lua_push_str_table_entry(L, \"HTTP_REFERER\", (char*)mg_get_header(conn, \"Referer\"));\n  lua_push_str_table_entry(L, \"HTTP_USER_AGENT\", (char*)mg_get_header(conn, \"User-Agent\"));\n  lua_push_str_table_entry(L, \"SERVER_NAME\", (char*)mg_get_header(conn, \"Host\"));\n  lua_setglobal(L, \"_SERVER\"); /* Like in php */\n\n  /* Cookies */\n  lua_newtable(L);\n  if((_cookies = (char*)mg_get_header(conn, \"Cookie\")) != NULL) {\n    char *cookies = strdup(_cookies);\n    char *tok, *where;\n\n    // ntop->getTrace()->traceEvent(TRACE_WARNING, \"=> '%s'\", cookies);\n    tok = strtok_r(cookies, \"=\", &where);\n    while(tok != NULL) {\n      char *val;\n\n      while(tok[0] == ' ') tok++;\n\n      if((val = strtok_r(NULL, \";\", &where)) != NULL) {\n\tlua_push_str_table_entry(L, tok, val);\n\t// ntop->getTrace()->traceEvent(TRACE_WARNING, \"'%s'='%s'\", tok, val);\n      } else\n\tbreak;\n\n      tok = strtok_r(NULL, \"=\", &where);\n    }\n\n    free(cookies);\n  }\n  lua_setglobal(L, \"_COOKIE\"); /* Like in php */\n\n  /* Put the _SESSION params into the environment */\n  lua_newtable(L);\n\n  mg_get_cookie(conn, \"user\", user, sizeof(user));\n  lua_push_str_table_entry(L, \"user\", user);\n  mg_get_cookie(conn, \"session\", buf, sizeof(buf));\n  lua_push_str_table_entry(L, \"session\", buf);\n\n  // now it's time to set the interface.\n  setInterface(user);\n\n  lua_setglobal(L, \"_SESSION\"); /* Like in php */\n\n  if(user[0] != '\\0') {\n    char val[255];\n\n    lua_pushlightuserdata(L, user);\n    lua_setglobal(L, \"user\");\n\n    snprintf(key, sizeof(key), \"ntopng.user.%s.allowed_nets\", user);\n    if((ntop->getRedis()->get(key, val, sizeof(val)) != -1)\n       && (val[0] != '\\0')) {\n      ptree.addAddresses(val);\n      lua_pushlightuserdata(L, &ptree);\n      lua_setglobal(L, CONST_ALLOWED_NETS);\n      // ntop->getTrace()->traceEvent(TRACE_WARNING, \"SET %p\", ptree);\n    }\n\n    snprintf(key, sizeof(key), CONST_STR_USER_ALLOWED_IFNAME, user);\n    if(snprintf(key, sizeof(key), CONST_STR_USER_ALLOWED_IFNAME, user)\n       && !ntop->getRedis()->get(key, ifname, sizeof(ifname))) {\n      lua_pushlightuserdata(L, ifname);\n      lua_setglobal(L, CONST_ALLOWED_IFNAME);\n    }\n  }\n\n#ifndef NTOPNG_PRO\n  rc = luaL_dofile(L, script_path);\n#else\n  if(ntop->getPro()->has_valid_license())\n    rc = __ntop_lua_handlefile(L, script_path, true);\n  else\n    rc = luaL_dofile(L, script_path);\n#endif\n\n  if(rc != 0) {\n    const char *err = lua_tostring(L, -1);\n\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Script failure [%s][%s]\", script_path, err);\n    return(send_error(conn, 500 /* Internal server error */,\n\t\t      \"Internal server error\", PAGE_ERROR, script_path, err));\n  }\n\n  return(CONST_LUA_OK);\n}",
        "func": "int Lua::handle_script_request(struct mg_connection *conn,\n\t\t\t       const struct mg_request_info *request_info,\n\t\t\t       char *script_path) {\n  char buf[64], key[64], ifname[MAX_INTERFACE_NAME_LEN];\n  char *_cookies, user[64] = { '\\0' }, outbuf[FILENAME_MAX];\n  AddressTree ptree;\n  int rc;\n  bool csrf_found = false;\n  \n  if(!L) return(-1);\n\n  luaL_openlibs(L); /* Load base libraries */\n  lua_register_classes(L, true); /* Load custom classes */\n\n  lua_pushlightuserdata(L, (char*)conn);\n  lua_setglobal(L, CONST_HTTP_CONN);\n\n  /* Put the GET params into the environment */\n  lua_newtable(L);\n  if(request_info->query_string != NULL) {\n    char *query_string = strdup(request_info->query_string);\n    \n    if(query_string) {\n      char *where;\n      char *tok;\n      \n      // ntop->getTrace()->traceEvent(TRACE_WARNING, \"[HTTP] %s\", query_string);\n\n      tok = strtok_r(query_string, \"&\", &where);\n\n      while(tok != NULL) {\n\t/* key=val */\n\tchar *_equal = strchr(tok, '=');\n\n\tif(_equal) {\n\t  char *equal;\n\t  int len;\n\n\t  _equal[0] = '\\0';\n\t  _equal = &_equal[1];\n\t  len = strlen(_equal);\n\n\t  purifyHTTPParameter(tok), purifyHTTPParameter(_equal);\n\n\t  // ntop->getTrace()->traceEvent(TRACE_WARNING, \"%s = %s\", tok, _equal);\n\n\t  if((equal = (char*)malloc(len+1)) != NULL) {\n\t    char *decoded_buf;\n\n\t    Utils::urlDecode(_equal, equal, len+1);\n\n\t    if((decoded_buf = http_decode(equal)) != NULL) {\n\t      FILE *fd;\n\n\t      Utils::purifyHTTPparam(tok, true, false);\n\t      Utils::purifyHTTPparam(decoded_buf, false, false);\n\n\t      /* Now make sure that decoded_buf is not a file path */\n\t      if((decoded_buf[0] == '.')\n\t\t && ((fd = fopen(decoded_buf, \"r\"))\n\t\t     || (fd = fopen(realpath(decoded_buf, outbuf), \"r\")))) {\n\t\tntop->getTrace()->traceEvent(TRACE_WARNING, \"Discarded '%s'='%s' as argument is a valid file path\",\n\t\t\t\t\t     tok, decoded_buf);\n\n\t\tdecoded_buf[0] = '\\0';\n\t\tfclose(fd);\n\t      }\n\n\t      /* ntop->getTrace()->traceEvent(TRACE_WARNING, \"'%s'='%s'\", tok, decoded_buf); */\n\n\t      if(strcmp(tok, \"csrf\") == 0) {\n\t\tchar rsp[32], user[64] = { '\\0' };\n\n\t\tmg_get_cookie(conn, \"user\", user, sizeof(user));\n\n\t\tif((ntop->getRedis()->get(decoded_buf, rsp, sizeof(rsp)) == -1)\n\t\t   || (strcmp(rsp, user) != 0)) {\n\t\t  const char *msg = \"The submitted form is expired. Please reload the page and try again\";\n\n\t\t  ntop->getTrace()->traceEvent(TRACE_WARNING,\n\t\t\t\t\t       \"Invalid CSRF parameter specified [%s][%s][%s][%s]: page expired?\",\n\t\t\t\t\t       decoded_buf, rsp, user, tok);\n\t\t  free(equal);\n\t\t  return(send_error(conn, 500 /* Internal server error */,\n\t\t\t\t    msg, PAGE_ERROR, query_string, msg));\n\t\t} else\n\t\t  ntop->getRedis()->delKey(decoded_buf);\n\n\t\tcsrf_found = true;\n\t      }\n\n\t      lua_push_str_table_entry(L, tok, decoded_buf);\n\t      free(decoded_buf);\n\t    }\n\n\t    free(equal);\n\t  } else\n\t    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");\n\t}\n\n\ttok = strtok_r(NULL, \"&\", &where);\n      } /* while */\n\n      free(query_string);\n    } else\n      ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");\n  }\n\n  if(strstr(request_info->uri, \"/admin/\") && (!csrf_found)) {\n    const char *msg = \"Missing CSRF parameter\";\n    \n    return(send_error(conn, 500 /* Internal server error */, msg, PAGE_ERROR, request_info->uri, msg));\n  }\n  \n  lua_setglobal(L, \"_GET\"); /* Like in php */\n\n  /* _SERVER */\n  lua_newtable(L);\n  lua_push_str_table_entry(L, \"HTTP_REFERER\", (char*)mg_get_header(conn, \"Referer\"));\n  lua_push_str_table_entry(L, \"HTTP_USER_AGENT\", (char*)mg_get_header(conn, \"User-Agent\"));\n  lua_push_str_table_entry(L, \"SERVER_NAME\", (char*)mg_get_header(conn, \"Host\"));\n  lua_setglobal(L, \"_SERVER\"); /* Like in php */\n\n  /* Cookies */\n  lua_newtable(L);\n  if((_cookies = (char*)mg_get_header(conn, \"Cookie\")) != NULL) {\n    char *cookies = strdup(_cookies);\n    char *tok, *where;\n\n    // ntop->getTrace()->traceEvent(TRACE_WARNING, \"=> '%s'\", cookies);\n    tok = strtok_r(cookies, \"=\", &where);\n    while(tok != NULL) {\n      char *val;\n\n      while(tok[0] == ' ') tok++;\n\n      if((val = strtok_r(NULL, \";\", &where)) != NULL) {\n\tlua_push_str_table_entry(L, tok, val);\n\t// ntop->getTrace()->traceEvent(TRACE_WARNING, \"'%s'='%s'\", tok, val);\n      } else\n\tbreak;\n\n      tok = strtok_r(NULL, \"=\", &where);\n    }\n\n    free(cookies);\n  }\n  lua_setglobal(L, \"_COOKIE\"); /* Like in php */\n\n  /* Put the _SESSION params into the environment */\n  lua_newtable(L);\n\n  mg_get_cookie(conn, \"user\", user, sizeof(user));\n  lua_push_str_table_entry(L, \"user\", user);\n  mg_get_cookie(conn, \"session\", buf, sizeof(buf));\n  lua_push_str_table_entry(L, \"session\", buf);\n\n  // now it's time to set the interface.\n  setInterface(user);\n\n  lua_setglobal(L, \"_SESSION\"); /* Like in php */\n\n  if(user[0] != '\\0') {\n    char val[255];\n\n    lua_pushlightuserdata(L, user);\n    lua_setglobal(L, \"user\");\n\n    snprintf(key, sizeof(key), \"ntopng.user.%s.allowed_nets\", user);\n    if((ntop->getRedis()->get(key, val, sizeof(val)) != -1)\n       && (val[0] != '\\0')) {\n      ptree.addAddresses(val);\n      lua_pushlightuserdata(L, &ptree);\n      lua_setglobal(L, CONST_ALLOWED_NETS);\n      // ntop->getTrace()->traceEvent(TRACE_WARNING, \"SET %p\", ptree);\n    }\n\n    snprintf(key, sizeof(key), CONST_STR_USER_ALLOWED_IFNAME, user);\n    if(snprintf(key, sizeof(key), CONST_STR_USER_ALLOWED_IFNAME, user)\n       && !ntop->getRedis()->get(key, ifname, sizeof(ifname))) {\n      lua_pushlightuserdata(L, ifname);\n      lua_setglobal(L, CONST_ALLOWED_IFNAME);\n    }\n  }\n\n#ifndef NTOPNG_PRO\n  rc = luaL_dofile(L, script_path);\n#else\n  if(ntop->getPro()->has_valid_license())\n    rc = __ntop_lua_handlefile(L, script_path, true);\n  else\n    rc = luaL_dofile(L, script_path);\n#endif\n\n  if(rc != 0) {\n    const char *err = lua_tostring(L, -1);\n\n    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Script failure [%s][%s]\", script_path, err);\n    return(send_error(conn, 500 /* Internal server error */,\n\t\t      \"Internal server error\", PAGE_ERROR, script_path, err));\n  }\n\n  return(CONST_LUA_OK);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,8 @@\n   char *_cookies, user[64] = { '\\0' }, outbuf[FILENAME_MAX];\n   AddressTree ptree;\n   int rc;\n-\n+  bool csrf_found = false;\n+  \n   if(!L) return(-1);\n \n   luaL_openlibs(L); /* Load base libraries */\n@@ -18,11 +19,11 @@\n   lua_newtable(L);\n   if(request_info->query_string != NULL) {\n     char *query_string = strdup(request_info->query_string);\n-\n+    \n     if(query_string) {\n       char *where;\n       char *tok;\n-\n+      \n       // ntop->getTrace()->traceEvent(TRACE_WARNING, \"[HTTP] %s\", query_string);\n \n       tok = strtok_r(query_string, \"&\", &where);\n@@ -84,6 +85,8 @@\n \t\t\t\t    msg, PAGE_ERROR, query_string, msg));\n \t\t} else\n \t\t  ntop->getRedis()->delKey(decoded_buf);\n+\n+\t\tcsrf_found = true;\n \t      }\n \n \t      lua_push_str_table_entry(L, tok, decoded_buf);\n@@ -102,6 +105,13 @@\n     } else\n       ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");\n   }\n+\n+  if(strstr(request_info->uri, \"/admin/\") && (!csrf_found)) {\n+    const char *msg = \"Missing CSRF parameter\";\n+    \n+    return(send_error(conn, 500 /* Internal server error */, msg, PAGE_ERROR, request_info->uri, msg));\n+  }\n+  \n   lua_setglobal(L, \"_GET\"); /* Like in php */\n \n   /* _SERVER */",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "",
                ""
            ],
            "added_lines": [
                "  bool csrf_found = false;",
                "  ",
                "    ",
                "      ",
                "",
                "\t\tcsrf_found = true;",
                "",
                "  if(strstr(request_info->uri, \"/admin/\") && (!csrf_found)) {",
                "    const char *msg = \"Missing CSRF parameter\";",
                "    ",
                "    return(send_error(conn, 500 /* Internal server error */, msg, PAGE_ERROR, request_info->uri, msg));",
                "  }",
                "  "
            ]
        }
    }
]