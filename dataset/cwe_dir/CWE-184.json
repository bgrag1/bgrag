[
    {
        "cve_id": "CVE-2018-16863",
        "func_name": "ArtifexSoftware/ghostpdl/z2restore",
        "description": "It was found that RHSA-2018:2918 did not fully fix CVE-2018-16509. An attacker could possibly exploit another variant of the flaw and bypass the -dSAFER protection to, for example, execute arbitrary shell commands via a specially crafted PostScript document. This only affects ghostscript 9.07 as shipped with Red Hat Enterprise Linux 7.",
        "git_url": "https://github.com/ArtifexSoftware/ghostpdl/commit/78911a01b67d590b4a91afac2e8417360b934156",
        "commit_title": "Bug 699654: Check the restore operand type",
        "commit_text": " The primary function that implements restore correctly checked its parameter, but a function that does some preliminary work for the restore (gstate and device handling) did not check.  So, even though the restore correctly errored out, it left things partially done and, in particular, the device in partially restored state. Meaning the LockSafetyParams was not correctly set.",
        "func_before": "static int\nz2restore(i_ctx_t *i_ctx_p)\n{\n    while (gs_gstate_saved(gs_gstate_saved(igs))) {\n        if (restore_page_device(igs, gs_gstate_saved(igs)))\n            return push_callout(i_ctx_p, \"%restore1pagedevice\");\n        gs_grestore(igs);\n    }\n    if (restore_page_device(igs, gs_gstate_saved(igs)))\n        return push_callout(i_ctx_p, \"%restorepagedevice\");\n    return zrestore(i_ctx_p);\n}",
        "func": "static int\nz2restore(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    check_type(*op, t_save);\n\n    while (gs_gstate_saved(gs_gstate_saved(igs))) {\n        if (restore_page_device(igs, gs_gstate_saved(igs)))\n            return push_callout(i_ctx_p, \"%restore1pagedevice\");\n        gs_grestore(igs);\n    }\n    if (restore_page_device(igs, gs_gstate_saved(igs)))\n        return push_callout(i_ctx_p, \"%restorepagedevice\");\n    return zrestore(i_ctx_p);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,9 @@\n static int\n z2restore(i_ctx_t *i_ctx_p)\n {\n+    os_ptr op = osp;\n+    check_type(*op, t_save);\n+\n     while (gs_gstate_saved(gs_gstate_saved(igs))) {\n         if (restore_page_device(igs, gs_gstate_saved(igs)))\n             return push_callout(i_ctx_p, \"%restore1pagedevice\");",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    os_ptr op = osp;",
                "    check_type(*op, t_save);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2018-16863",
        "func_name": "ArtifexSoftware/ghostpdl/zrestore",
        "description": "It was found that RHSA-2018:2918 did not fully fix CVE-2018-16509. An attacker could possibly exploit another variant of the flaw and bypass the -dSAFER protection to, for example, execute arbitrary shell commands via a specially crafted PostScript document. This only affects ghostscript 9.07 as shipped with Red Hat Enterprise Linux 7.",
        "git_url": "https://github.com/ArtifexSoftware/ghostpdl/commit/5516c614dc33662a2afdc377159f70218e67bde5",
        "commit_title": "Improve restore robustness",
        "commit_text": " Prompted by looking at Bug 699654:  There are two variants of the restore operator in Ghostscript: one is Level 1 (restoring VM), the other is Level 2+ (adding page device restoring to the Level operator).  This was implemented by the Level 2+ version restoring the device in the graphics state, then calling the Level 1 implementation to handle actually restoring the VM state.  The problem was that the operand checking, and sanity of the save object was only done by the Level 1 variant, thus meaning an invalid save object could leave a (Level 2+) restore partially complete - with the page device part restored, but not VM, and the page device not configured.  To solve that, this commit splits the operand and sanity checking, and the core of the restore operation into separate functions, so the relevant operators can validate the operand *before* taking any further action. That reduces the chances of an invalid restore leaving the interpreter in an unknown state.  If an error occurs during the actual VM restore it is essentially fatal, and the interpreter cannot continue, but as an extra surety for security, in the event of such an error, we'll explicitly preserve the LockSafetyParams of the device, rather than rely on the post-restore device configuration (which won't happen in the event of an error).",
        "func_before": "int\nzrestore(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    alloc_save_t *asave;\n    bool last;\n    vm_save_t *vmsave;\n    int code = restore_check_operand(op, &asave, idmemory);\n\n    if (code < 0)\n        return code;\n    if_debug2m('u', imemory, \"[u]vmrestore 0x%lx, id = %lu\\n\",\n               (ulong) alloc_save_client_data(asave),\n               (ulong) op->value.saveid);\n    if (I_VALIDATE_BEFORE_RESTORE)\n        ivalidate_clean_spaces(i_ctx_p);\n    /* Check the contents of the stacks. */\n    osp--;\n    {\n        int code;\n\n        if ((code = restore_check_stack(i_ctx_p, &o_stack, asave, false)) < 0 ||\n            (code = restore_check_stack(i_ctx_p, &e_stack, asave, true)) < 0 ||\n            (code = restore_check_stack(i_ctx_p, &d_stack, asave, false)) < 0\n            ) {\n            osp++;\n            return code;\n        }\n    }\n    /* Reset l_new in all stack entries if the new save level is zero. */\n    /* Also do some special fixing on the e-stack. */\n    restore_fix_stack(i_ctx_p, &o_stack, asave, false);\n    restore_fix_stack(i_ctx_p, &e_stack, asave, true);\n    restore_fix_stack(i_ctx_p, &d_stack, asave, false);\n    /* Iteratively restore the state of memory, */\n    /* also doing a grestoreall at each step. */\n    do {\n        vmsave = alloc_save_client_data(alloc_save_current(idmemory));\n        /* Restore the graphics state. */\n        gs_grestoreall_for_restore(igs, vmsave->gsave);\n        /*\n         * If alloc_save_space decided to do a second save, the vmsave\n         * object was allocated one save level less deep than the\n         * current level, so ifree_object won't actually free it;\n         * however, it points to a gsave object that definitely\n         * *has* been freed.  In order not to trip up the garbage\n         * collector, we clear the gsave pointer now.\n         */\n        vmsave->gsave = 0;\n        /* Now it's safe to restore the state of memory. */\n        code = alloc_restore_step_in(idmemory, asave);\n        if (code < 0)\n            return code;\n        last = code;\n    }\n    while (!last);\n    {\n        uint space = icurrent_space;\n\n        ialloc_set_space(idmemory, avm_local);\n        ifree_object(vmsave, \"zrestore\");\n        ialloc_set_space(idmemory, space);\n    }\n    dict_set_top();\t\t/* reload dict stack cache */\n    if (I_VALIDATE_AFTER_RESTORE)\n        ivalidate_clean_spaces(i_ctx_p);\n    /* If the i_ctx_p LockFilePermissions is true, but the userparams */\n    /* we just restored is false, we need to make sure that we do not */\n    /* cause an 'invalidaccess' in setuserparams. Temporarily set     */\n    /* LockFilePermissions false until the gs_lev2.ps can do a        */\n    /* setuserparams from the restored userparam dictionary.          */\n    i_ctx_p->LockFilePermissions = false;\n    return 0;\n}",
        "func": "int\nzrestore(i_ctx_t *i_ctx_p)\n{\n    alloc_save_t *asave;\n    int code = restore_check_save(i_ctx_p, &asave);\n    if (code < 0)\n        return code;\n\n    return dorestore(i_ctx_p, asave);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,74 +1,10 @@\n int\n zrestore(i_ctx_t *i_ctx_p)\n {\n-    os_ptr op = osp;\n     alloc_save_t *asave;\n-    bool last;\n-    vm_save_t *vmsave;\n-    int code = restore_check_operand(op, &asave, idmemory);\n-\n+    int code = restore_check_save(i_ctx_p, &asave);\n     if (code < 0)\n         return code;\n-    if_debug2m('u', imemory, \"[u]vmrestore 0x%lx, id = %lu\\n\",\n-               (ulong) alloc_save_client_data(asave),\n-               (ulong) op->value.saveid);\n-    if (I_VALIDATE_BEFORE_RESTORE)\n-        ivalidate_clean_spaces(i_ctx_p);\n-    /* Check the contents of the stacks. */\n-    osp--;\n-    {\n-        int code;\n \n-        if ((code = restore_check_stack(i_ctx_p, &o_stack, asave, false)) < 0 ||\n-            (code = restore_check_stack(i_ctx_p, &e_stack, asave, true)) < 0 ||\n-            (code = restore_check_stack(i_ctx_p, &d_stack, asave, false)) < 0\n-            ) {\n-            osp++;\n-            return code;\n-        }\n-    }\n-    /* Reset l_new in all stack entries if the new save level is zero. */\n-    /* Also do some special fixing on the e-stack. */\n-    restore_fix_stack(i_ctx_p, &o_stack, asave, false);\n-    restore_fix_stack(i_ctx_p, &e_stack, asave, true);\n-    restore_fix_stack(i_ctx_p, &d_stack, asave, false);\n-    /* Iteratively restore the state of memory, */\n-    /* also doing a grestoreall at each step. */\n-    do {\n-        vmsave = alloc_save_client_data(alloc_save_current(idmemory));\n-        /* Restore the graphics state. */\n-        gs_grestoreall_for_restore(igs, vmsave->gsave);\n-        /*\n-         * If alloc_save_space decided to do a second save, the vmsave\n-         * object was allocated one save level less deep than the\n-         * current level, so ifree_object won't actually free it;\n-         * however, it points to a gsave object that definitely\n-         * *has* been freed.  In order not to trip up the garbage\n-         * collector, we clear the gsave pointer now.\n-         */\n-        vmsave->gsave = 0;\n-        /* Now it's safe to restore the state of memory. */\n-        code = alloc_restore_step_in(idmemory, asave);\n-        if (code < 0)\n-            return code;\n-        last = code;\n-    }\n-    while (!last);\n-    {\n-        uint space = icurrent_space;\n-\n-        ialloc_set_space(idmemory, avm_local);\n-        ifree_object(vmsave, \"zrestore\");\n-        ialloc_set_space(idmemory, space);\n-    }\n-    dict_set_top();\t\t/* reload dict stack cache */\n-    if (I_VALIDATE_AFTER_RESTORE)\n-        ivalidate_clean_spaces(i_ctx_p);\n-    /* If the i_ctx_p LockFilePermissions is true, but the userparams */\n-    /* we just restored is false, we need to make sure that we do not */\n-    /* cause an 'invalidaccess' in setuserparams. Temporarily set     */\n-    /* LockFilePermissions false until the gs_lev2.ps can do a        */\n-    /* setuserparams from the restored userparam dictionary.          */\n-    i_ctx_p->LockFilePermissions = false;\n-    return 0;\n+    return dorestore(i_ctx_p, asave);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    os_ptr op = osp;",
                "    bool last;",
                "    vm_save_t *vmsave;",
                "    int code = restore_check_operand(op, &asave, idmemory);",
                "",
                "    if_debug2m('u', imemory, \"[u]vmrestore 0x%lx, id = %lu\\n\",",
                "               (ulong) alloc_save_client_data(asave),",
                "               (ulong) op->value.saveid);",
                "    if (I_VALIDATE_BEFORE_RESTORE)",
                "        ivalidate_clean_spaces(i_ctx_p);",
                "    /* Check the contents of the stacks. */",
                "    osp--;",
                "    {",
                "        int code;",
                "        if ((code = restore_check_stack(i_ctx_p, &o_stack, asave, false)) < 0 ||",
                "            (code = restore_check_stack(i_ctx_p, &e_stack, asave, true)) < 0 ||",
                "            (code = restore_check_stack(i_ctx_p, &d_stack, asave, false)) < 0",
                "            ) {",
                "            osp++;",
                "            return code;",
                "        }",
                "    }",
                "    /* Reset l_new in all stack entries if the new save level is zero. */",
                "    /* Also do some special fixing on the e-stack. */",
                "    restore_fix_stack(i_ctx_p, &o_stack, asave, false);",
                "    restore_fix_stack(i_ctx_p, &e_stack, asave, true);",
                "    restore_fix_stack(i_ctx_p, &d_stack, asave, false);",
                "    /* Iteratively restore the state of memory, */",
                "    /* also doing a grestoreall at each step. */",
                "    do {",
                "        vmsave = alloc_save_client_data(alloc_save_current(idmemory));",
                "        /* Restore the graphics state. */",
                "        gs_grestoreall_for_restore(igs, vmsave->gsave);",
                "        /*",
                "         * If alloc_save_space decided to do a second save, the vmsave",
                "         * object was allocated one save level less deep than the",
                "         * current level, so ifree_object won't actually free it;",
                "         * however, it points to a gsave object that definitely",
                "         * *has* been freed.  In order not to trip up the garbage",
                "         * collector, we clear the gsave pointer now.",
                "         */",
                "        vmsave->gsave = 0;",
                "        /* Now it's safe to restore the state of memory. */",
                "        code = alloc_restore_step_in(idmemory, asave);",
                "        if (code < 0)",
                "            return code;",
                "        last = code;",
                "    }",
                "    while (!last);",
                "    {",
                "        uint space = icurrent_space;",
                "",
                "        ialloc_set_space(idmemory, avm_local);",
                "        ifree_object(vmsave, \"zrestore\");",
                "        ialloc_set_space(idmemory, space);",
                "    }",
                "    dict_set_top();\t\t/* reload dict stack cache */",
                "    if (I_VALIDATE_AFTER_RESTORE)",
                "        ivalidate_clean_spaces(i_ctx_p);",
                "    /* If the i_ctx_p LockFilePermissions is true, but the userparams */",
                "    /* we just restored is false, we need to make sure that we do not */",
                "    /* cause an 'invalidaccess' in setuserparams. Temporarily set     */",
                "    /* LockFilePermissions false until the gs_lev2.ps can do a        */",
                "    /* setuserparams from the restored userparam dictionary.          */",
                "    i_ctx_p->LockFilePermissions = false;",
                "    return 0;"
            ],
            "added_lines": [
                "    int code = restore_check_save(i_ctx_p, &asave);",
                "    return dorestore(i_ctx_p, asave);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-16863",
        "func_name": "ArtifexSoftware/ghostpdl/z2restore",
        "description": "It was found that RHSA-2018:2918 did not fully fix CVE-2018-16509. An attacker could possibly exploit another variant of the flaw and bypass the -dSAFER protection to, for example, execute arbitrary shell commands via a specially crafted PostScript document. This only affects ghostscript 9.07 as shipped with Red Hat Enterprise Linux 7.",
        "git_url": "https://github.com/ArtifexSoftware/ghostpdl/commit/5516c614dc33662a2afdc377159f70218e67bde5",
        "commit_title": "Improve restore robustness",
        "commit_text": " Prompted by looking at Bug 699654:  There are two variants of the restore operator in Ghostscript: one is Level 1 (restoring VM), the other is Level 2+ (adding page device restoring to the Level operator).  This was implemented by the Level 2+ version restoring the device in the graphics state, then calling the Level 1 implementation to handle actually restoring the VM state.  The problem was that the operand checking, and sanity of the save object was only done by the Level 1 variant, thus meaning an invalid save object could leave a (Level 2+) restore partially complete - with the page device part restored, but not VM, and the page device not configured.  To solve that, this commit splits the operand and sanity checking, and the core of the restore operation into separate functions, so the relevant operators can validate the operand *before* taking any further action. That reduces the chances of an invalid restore leaving the interpreter in an unknown state.  If an error occurs during the actual VM restore it is essentially fatal, and the interpreter cannot continue, but as an extra surety for security, in the event of such an error, we'll explicitly preserve the LockSafetyParams of the device, rather than rely on the post-restore device configuration (which won't happen in the event of an error).",
        "func_before": "static int\nz2restore(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    check_type(*op, t_save);\n\n    while (gs_gstate_saved(gs_gstate_saved(igs))) {\n        if (restore_page_device(igs, gs_gstate_saved(igs)))\n            return push_callout(i_ctx_p, \"%restore1pagedevice\");\n        gs_grestore(igs);\n    }\n    if (restore_page_device(igs, gs_gstate_saved(igs)))\n        return push_callout(i_ctx_p, \"%restorepagedevice\");\n    return zrestore(i_ctx_p);\n}",
        "func": "static int\nz2restore(i_ctx_t *i_ctx_p)\n{\n    alloc_save_t *asave;\n    bool saveLockSafety = gs_currentdevice_inline(igs)->LockSafetyParams;\n    int code = restore_check_save(i_ctx_p, &asave);\n\n    if (code < 0) return code;\n\n    while (gs_gstate_saved(gs_gstate_saved(igs))) {\n        if (restore_page_device(igs, gs_gstate_saved(igs)))\n            return push_callout(i_ctx_p, \"%restore1pagedevice\");\n        gs_grestore(igs);\n    }\n    if (restore_page_device(igs, gs_gstate_saved(igs)))\n        return push_callout(i_ctx_p, \"%restorepagedevice\");\n\n    code = dorestore(i_ctx_p, asave);\n\n    if (code < 0) {\n        /* An error here is basically fatal, but....\n           restore_page_device() has to set LockSafetyParams false so it can\n           configure the restored device correctly - in normal operation, that\n           gets reset by that configuration. If we hit an error, though, that\n           may not happen -  at least ensure we keep the setting through the\n           error.\n         */\n        gs_currentdevice_inline(igs)->LockSafetyParams = saveLockSafety;\n    }\n    return code;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,11 @@\n static int\n z2restore(i_ctx_t *i_ctx_p)\n {\n-    os_ptr op = osp;\n-    check_type(*op, t_save);\n+    alloc_save_t *asave;\n+    bool saveLockSafety = gs_currentdevice_inline(igs)->LockSafetyParams;\n+    int code = restore_check_save(i_ctx_p, &asave);\n+\n+    if (code < 0) return code;\n \n     while (gs_gstate_saved(gs_gstate_saved(igs))) {\n         if (restore_page_device(igs, gs_gstate_saved(igs)))\n@@ -11,5 +14,18 @@\n     }\n     if (restore_page_device(igs, gs_gstate_saved(igs)))\n         return push_callout(i_ctx_p, \"%restorepagedevice\");\n-    return zrestore(i_ctx_p);\n+\n+    code = dorestore(i_ctx_p, asave);\n+\n+    if (code < 0) {\n+        /* An error here is basically fatal, but....\n+           restore_page_device() has to set LockSafetyParams false so it can\n+           configure the restored device correctly - in normal operation, that\n+           gets reset by that configuration. If we hit an error, though, that\n+           may not happen -  at least ensure we keep the setting through the\n+           error.\n+         */\n+        gs_currentdevice_inline(igs)->LockSafetyParams = saveLockSafety;\n+    }\n+    return code;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    os_ptr op = osp;",
                "    check_type(*op, t_save);",
                "    return zrestore(i_ctx_p);"
            ],
            "added_lines": [
                "    alloc_save_t *asave;",
                "    bool saveLockSafety = gs_currentdevice_inline(igs)->LockSafetyParams;",
                "    int code = restore_check_save(i_ctx_p, &asave);",
                "",
                "    if (code < 0) return code;",
                "",
                "    code = dorestore(i_ctx_p, asave);",
                "",
                "    if (code < 0) {",
                "        /* An error here is basically fatal, but....",
                "           restore_page_device() has to set LockSafetyParams false so it can",
                "           configure the restored device correctly - in normal operation, that",
                "           gets reset by that configuration. If we hit an error, though, that",
                "           may not happen -  at least ensure we keep the setting through the",
                "           error.",
                "         */",
                "        gs_currentdevice_inline(igs)->LockSafetyParams = saveLockSafety;",
                "    }",
                "    return code;"
            ]
        }
    }
]