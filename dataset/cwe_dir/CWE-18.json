[
    {
        "cve_id": "CVE-2015-2696",
        "func_name": "krb5/krb5_gss_set_sec_context_option",
        "description": "lib/gssapi/krb5/iakerb.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted IAKERB packet that is mishandled during a gss_inquire_context call.",
        "git_url": "https://github.com/krb5/krb5/commit/e04f0283516e80d2f93366e0d479d13c9b5c8c2a",
        "commit_title": "Fix IAKERB context aliasing bugs [CVE-2015-2696]",
        "commit_text": " The IAKERB mechanism currently replaces its context handle with the krb5 mechanism handle upon establishment, under the assumption that most GSS functions are only called after context establishment.  This assumption is incorrect, and can lead to aliasing violations for some programs.  Maintain the IAKERB context structure after context establishment and add new IAKERB entry points to refer to it with that type.  Add initiate and established flags to the IAKERB context structure for use in gss_inquire_context() prior to context establishment.  CVE-2015-2696:  In MIT krb5 1.9 and later, applications which call gss_inquire_context() on a partially-established IAKERB context can cause the GSS-API library to read from a pointer using the wrong type, generally causing a process crash.  Java server applications using the native JGSS provider are vulnerable to this bug.  A carefully crafted IAKERB packet might allow the gss_inquire_context() call to succeed with attacker-determined results, but applications should not make access control decisions based on gss_inquire_context() results prior to context establishment.      CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C  [ghudson@mit.edu: several bugfixes, style changes, and edge-case behavior changes; commit message and CVE description]  ticket: 8244 target_version: 1.14 tags: pullup",
        "func_before": "static OM_uint32 KRB5_CALLCONV\nkrb5_gss_set_sec_context_option (OM_uint32 *minor_status,\n                                 gss_ctx_id_t *context_handle,\n                                 const gss_OID desired_object,\n                                 const gss_buffer_t value)\n{\n#if 0\n    size_t i;\n#endif\n\n    if (minor_status == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    *minor_status = 0;\n\n    if (context_handle == NULL)\n        return GSS_S_CALL_INACCESSIBLE_READ;\n\n    if (desired_object == GSS_C_NO_OID)\n        return GSS_S_CALL_INACCESSIBLE_READ;\n\n#if 0\n    for (i = 0; i < sizeof(krb5_gss_set_sec_context_option_ops)/\n             sizeof(krb5_gss_set_sec_context_option_ops[0]); i++) {\n        if (g_OID_prefix_equal(desired_object, &krb5_gss_set_sec_context_option_ops[i].oid)) {\n            return (*krb5_gss_set_sec_context_option_ops[i].func)(minor_status,\n                                                                  context_handle,\n                                                                  desired_object,\n                                                                  value);\n        }\n    }\n#endif\n\n    *minor_status = EINVAL;\n\n    return GSS_S_UNAVAILABLE;\n}",
        "func": "OM_uint32 KRB5_CALLCONV\nkrb5_gss_set_sec_context_option (OM_uint32 *minor_status,\n                                 gss_ctx_id_t *context_handle,\n                                 const gss_OID desired_object,\n                                 const gss_buffer_t value)\n{\n#if 0\n    size_t i;\n#endif\n\n    if (minor_status == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    *minor_status = 0;\n\n    if (context_handle == NULL)\n        return GSS_S_CALL_INACCESSIBLE_READ;\n\n    if (desired_object == GSS_C_NO_OID)\n        return GSS_S_CALL_INACCESSIBLE_READ;\n\n#if 0\n    for (i = 0; i < sizeof(krb5_gss_set_sec_context_option_ops)/\n             sizeof(krb5_gss_set_sec_context_option_ops[0]); i++) {\n        if (g_OID_prefix_equal(desired_object, &krb5_gss_set_sec_context_option_ops[i].oid)) {\n            return (*krb5_gss_set_sec_context_option_ops[i].func)(minor_status,\n                                                                  context_handle,\n                                                                  desired_object,\n                                                                  value);\n        }\n    }\n#endif\n\n    *minor_status = EINVAL;\n\n    return GSS_S_UNAVAILABLE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static OM_uint32 KRB5_CALLCONV\n+OM_uint32 KRB5_CALLCONV\n krb5_gss_set_sec_context_option (OM_uint32 *minor_status,\n                                  gss_ctx_id_t *context_handle,\n                                  const gss_OID desired_object,",
        "diff_line_info": {
            "deleted_lines": [
                "static OM_uint32 KRB5_CALLCONV"
            ],
            "added_lines": [
                "OM_uint32 KRB5_CALLCONV"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-2696",
        "func_name": "krb5/gss_iakerbmechglue_init",
        "description": "lib/gssapi/krb5/iakerb.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted IAKERB packet that is mishandled during a gss_inquire_context call.",
        "git_url": "https://github.com/krb5/krb5/commit/e04f0283516e80d2f93366e0d479d13c9b5c8c2a",
        "commit_title": "Fix IAKERB context aliasing bugs [CVE-2015-2696]",
        "commit_text": " The IAKERB mechanism currently replaces its context handle with the krb5 mechanism handle upon establishment, under the assumption that most GSS functions are only called after context establishment.  This assumption is incorrect, and can lead to aliasing violations for some programs.  Maintain the IAKERB context structure after context establishment and add new IAKERB entry points to refer to it with that type.  Add initiate and established flags to the IAKERB context structure for use in gss_inquire_context() prior to context establishment.  CVE-2015-2696:  In MIT krb5 1.9 and later, applications which call gss_inquire_context() on a partially-established IAKERB context can cause the GSS-API library to read from a pointer using the wrong type, generally causing a process crash.  Java server applications using the native JGSS provider are vulnerable to this bug.  A carefully crafted IAKERB packet might allow the gss_inquire_context() call to succeed with attacker-determined results, but applications should not make access control decisions based on gss_inquire_context() results prior to context establishment.      CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C  [ghudson@mit.edu: several bugfixes, style changes, and edge-case behavior changes; commit message and CVE description]  ticket: 8244 target_version: 1.14 tags: pullup",
        "func_before": "static int gss_iakerbmechglue_init(void)\n{\n    struct gss_mech_config mech_iakerb;\n    struct gss_config iakerb_mechanism = krb5_mechanism;\n\n    /* IAKERB mechanism mirrors krb5, but with different context SPIs */\n    iakerb_mechanism.gss_accept_sec_context = iakerb_gss_accept_sec_context;\n    iakerb_mechanism.gss_init_sec_context   = iakerb_gss_init_sec_context;\n    iakerb_mechanism.gss_delete_sec_context = iakerb_gss_delete_sec_context;\n    iakerb_mechanism.gss_acquire_cred       = iakerb_gss_acquire_cred;\n    iakerb_mechanism.gssspi_acquire_cred_with_password\n                                    = iakerb_gss_acquire_cred_with_password;\n\n    memset(&mech_iakerb, 0, sizeof(mech_iakerb));\n    mech_iakerb.mech = &iakerb_mechanism;\n\n    mech_iakerb.mechNameStr = \"iakerb\";\n    mech_iakerb.mech_type = (gss_OID)gss_mech_iakerb;\n    gssint_register_mechinfo(&mech_iakerb);\n\n    return 0;\n}",
        "func": "static int gss_iakerbmechglue_init(void)\n{\n    struct gss_mech_config mech_iakerb;\n\n    memset(&mech_iakerb, 0, sizeof(mech_iakerb));\n    mech_iakerb.mech = &iakerb_mechanism;\n\n    mech_iakerb.mechNameStr = \"iakerb\";\n    mech_iakerb.mech_type = (gss_OID)gss_mech_iakerb;\n    gssint_register_mechinfo(&mech_iakerb);\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,15 +1,6 @@\n static int gss_iakerbmechglue_init(void)\n {\n     struct gss_mech_config mech_iakerb;\n-    struct gss_config iakerb_mechanism = krb5_mechanism;\n-\n-    /* IAKERB mechanism mirrors krb5, but with different context SPIs */\n-    iakerb_mechanism.gss_accept_sec_context = iakerb_gss_accept_sec_context;\n-    iakerb_mechanism.gss_init_sec_context   = iakerb_gss_init_sec_context;\n-    iakerb_mechanism.gss_delete_sec_context = iakerb_gss_delete_sec_context;\n-    iakerb_mechanism.gss_acquire_cred       = iakerb_gss_acquire_cred;\n-    iakerb_mechanism.gssspi_acquire_cred_with_password\n-                                    = iakerb_gss_acquire_cred_with_password;\n \n     memset(&mech_iakerb, 0, sizeof(mech_iakerb));\n     mech_iakerb.mech = &iakerb_mechanism;",
        "diff_line_info": {
            "deleted_lines": [
                "    struct gss_config iakerb_mechanism = krb5_mechanism;",
                "",
                "    /* IAKERB mechanism mirrors krb5, but with different context SPIs */",
                "    iakerb_mechanism.gss_accept_sec_context = iakerb_gss_accept_sec_context;",
                "    iakerb_mechanism.gss_init_sec_context   = iakerb_gss_init_sec_context;",
                "    iakerb_mechanism.gss_delete_sec_context = iakerb_gss_delete_sec_context;",
                "    iakerb_mechanism.gss_acquire_cred       = iakerb_gss_acquire_cred;",
                "    iakerb_mechanism.gssspi_acquire_cred_with_password",
                "                                    = iakerb_gss_acquire_cred_with_password;"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2015-2696",
        "func_name": "krb5/krb5_gss_inquire_sec_context_by_oid",
        "description": "lib/gssapi/krb5/iakerb.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted IAKERB packet that is mishandled during a gss_inquire_context call.",
        "git_url": "https://github.com/krb5/krb5/commit/e04f0283516e80d2f93366e0d479d13c9b5c8c2a",
        "commit_title": "Fix IAKERB context aliasing bugs [CVE-2015-2696]",
        "commit_text": " The IAKERB mechanism currently replaces its context handle with the krb5 mechanism handle upon establishment, under the assumption that most GSS functions are only called after context establishment.  This assumption is incorrect, and can lead to aliasing violations for some programs.  Maintain the IAKERB context structure after context establishment and add new IAKERB entry points to refer to it with that type.  Add initiate and established flags to the IAKERB context structure for use in gss_inquire_context() prior to context establishment.  CVE-2015-2696:  In MIT krb5 1.9 and later, applications which call gss_inquire_context() on a partially-established IAKERB context can cause the GSS-API library to read from a pointer using the wrong type, generally causing a process crash.  Java server applications using the native JGSS provider are vulnerable to this bug.  A carefully crafted IAKERB packet might allow the gss_inquire_context() call to succeed with attacker-determined results, but applications should not make access control decisions based on gss_inquire_context() results prior to context establishment.      CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C  [ghudson@mit.edu: several bugfixes, style changes, and edge-case behavior changes; commit message and CVE description]  ticket: 8244 target_version: 1.14 tags: pullup",
        "func_before": "static OM_uint32 KRB5_CALLCONV\nkrb5_gss_inquire_sec_context_by_oid (OM_uint32 *minor_status,\n                                     const gss_ctx_id_t context_handle,\n                                     const gss_OID desired_object,\n                                     gss_buffer_set_t *data_set)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    size_t i;\n\n    if (minor_status == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    *minor_status = 0;\n\n    if (desired_object == GSS_C_NO_OID)\n        return GSS_S_CALL_INACCESSIBLE_READ;\n\n    if (data_set == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    *data_set = GSS_C_NO_BUFFER_SET;\n\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n\n    if (ctx->terminated || !ctx->established)\n        return GSS_S_NO_CONTEXT;\n\n    for (i = 0; i < sizeof(krb5_gss_inquire_sec_context_by_oid_ops)/\n             sizeof(krb5_gss_inquire_sec_context_by_oid_ops[0]); i++) {\n        if (g_OID_prefix_equal(desired_object, &krb5_gss_inquire_sec_context_by_oid_ops[i].oid)) {\n            return (*krb5_gss_inquire_sec_context_by_oid_ops[i].func)(minor_status,\n                                                                      context_handle,\n                                                                      desired_object,\n                                                                      data_set);\n        }\n    }\n\n    *minor_status = EINVAL;\n\n    return GSS_S_UNAVAILABLE;\n}",
        "func": "OM_uint32 KRB5_CALLCONV\nkrb5_gss_inquire_sec_context_by_oid (OM_uint32 *minor_status,\n                                     const gss_ctx_id_t context_handle,\n                                     const gss_OID desired_object,\n                                     gss_buffer_set_t *data_set)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    size_t i;\n\n    if (minor_status == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    *minor_status = 0;\n\n    if (desired_object == GSS_C_NO_OID)\n        return GSS_S_CALL_INACCESSIBLE_READ;\n\n    if (data_set == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    *data_set = GSS_C_NO_BUFFER_SET;\n\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n\n    if (ctx->terminated || !ctx->established)\n        return GSS_S_NO_CONTEXT;\n\n    for (i = 0; i < sizeof(krb5_gss_inquire_sec_context_by_oid_ops)/\n             sizeof(krb5_gss_inquire_sec_context_by_oid_ops[0]); i++) {\n        if (g_OID_prefix_equal(desired_object, &krb5_gss_inquire_sec_context_by_oid_ops[i].oid)) {\n            return (*krb5_gss_inquire_sec_context_by_oid_ops[i].func)(minor_status,\n                                                                      context_handle,\n                                                                      desired_object,\n                                                                      data_set);\n        }\n    }\n\n    *minor_status = EINVAL;\n\n    return GSS_S_UNAVAILABLE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static OM_uint32 KRB5_CALLCONV\n+OM_uint32 KRB5_CALLCONV\n krb5_gss_inquire_sec_context_by_oid (OM_uint32 *minor_status,\n                                      const gss_ctx_id_t context_handle,\n                                      const gss_OID desired_object,",
        "diff_line_info": {
            "deleted_lines": [
                "static OM_uint32 KRB5_CALLCONV"
            ],
            "added_lines": [
                "OM_uint32 KRB5_CALLCONV"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-2696",
        "func_name": "krb5/iakerb_gss_init_sec_context",
        "description": "lib/gssapi/krb5/iakerb.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted IAKERB packet that is mishandled during a gss_inquire_context call.",
        "git_url": "https://github.com/krb5/krb5/commit/e04f0283516e80d2f93366e0d479d13c9b5c8c2a",
        "commit_title": "Fix IAKERB context aliasing bugs [CVE-2015-2696]",
        "commit_text": " The IAKERB mechanism currently replaces its context handle with the krb5 mechanism handle upon establishment, under the assumption that most GSS functions are only called after context establishment.  This assumption is incorrect, and can lead to aliasing violations for some programs.  Maintain the IAKERB context structure after context establishment and add new IAKERB entry points to refer to it with that type.  Add initiate and established flags to the IAKERB context structure for use in gss_inquire_context() prior to context establishment.  CVE-2015-2696:  In MIT krb5 1.9 and later, applications which call gss_inquire_context() on a partially-established IAKERB context can cause the GSS-API library to read from a pointer using the wrong type, generally causing a process crash.  Java server applications using the native JGSS provider are vulnerable to this bug.  A carefully crafted IAKERB packet might allow the gss_inquire_context() call to succeed with attacker-determined results, but applications should not make access control decisions based on gss_inquire_context() results prior to context establishment.      CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C  [ghudson@mit.edu: several bugfixes, style changes, and edge-case behavior changes; commit message and CVE description]  ticket: 8244 target_version: 1.14 tags: pullup",
        "func_before": "OM_uint32 KRB5_CALLCONV\niakerb_gss_init_sec_context(OM_uint32 *minor_status,\n                            gss_cred_id_t claimant_cred_handle,\n                            gss_ctx_id_t *context_handle,\n                            gss_name_t target_name,\n                            gss_OID mech_type,\n                            OM_uint32 req_flags,\n                            OM_uint32 time_req,\n                            gss_channel_bindings_t input_chan_bindings,\n                            gss_buffer_t input_token,\n                            gss_OID *actual_mech_type,\n                            gss_buffer_t output_token,\n                            OM_uint32 *ret_flags,\n                            OM_uint32 *time_rec)\n{\n    OM_uint32 major_status = GSS_S_FAILURE;\n    krb5_error_code code;\n    iakerb_ctx_id_t ctx;\n    krb5_gss_cred_id_t kcred;\n    krb5_gss_name_t kname;\n    krb5_boolean cred_locked = FALSE;\n    int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);\n\n    if (initialContextToken) {\n        code = iakerb_alloc_context(&ctx);\n        if (code != 0) {\n            *minor_status = code;\n            goto cleanup;\n        }\n        if (claimant_cred_handle == GSS_C_NO_CREDENTIAL) {\n            major_status = iakerb_gss_acquire_cred(minor_status, NULL,\n                                                   GSS_C_INDEFINITE,\n                                                   GSS_C_NULL_OID_SET,\n                                                   GSS_C_INITIATE,\n                                                   &ctx->defcred, NULL, NULL);\n            if (GSS_ERROR(major_status))\n                goto cleanup;\n            claimant_cred_handle = ctx->defcred;\n        }\n    } else {\n        ctx = (iakerb_ctx_id_t)*context_handle;\n        if (claimant_cred_handle == GSS_C_NO_CREDENTIAL)\n            claimant_cred_handle = ctx->defcred;\n    }\n\n    kname = (krb5_gss_name_t)target_name;\n\n    major_status = kg_cred_resolve(minor_status, ctx->k5c,\n                                   claimant_cred_handle, target_name);\n    if (GSS_ERROR(major_status))\n        goto cleanup;\n    cred_locked = TRUE;\n    kcred = (krb5_gss_cred_id_t)claimant_cred_handle;\n\n    major_status = GSS_S_FAILURE;\n\n    if (initialContextToken) {\n        code = iakerb_get_initial_state(ctx, kcred, kname, time_req,\n                                        &ctx->state);\n        if (code != 0) {\n            *minor_status = code;\n            goto cleanup;\n        }\n        *context_handle = (gss_ctx_id_t)ctx;\n    }\n\n    if (ctx->state != IAKERB_AP_REQ) {\n        /* We need to do IAKERB. */\n        code = iakerb_initiator_step(ctx,\n                                     kcred,\n                                     kname,\n                                     time_req,\n                                     input_token,\n                                     output_token);\n        if (code == KRB5_BAD_MSIZE)\n            major_status = GSS_S_DEFECTIVE_TOKEN;\n        if (code != 0) {\n            *minor_status = code;\n            goto cleanup;\n        }\n    }\n\n    if (ctx->state == IAKERB_AP_REQ) {\n        krb5_gss_ctx_ext_rec exts;\n\n        if (cred_locked) {\n            k5_mutex_unlock(&kcred->lock);\n            cred_locked = FALSE;\n        }\n\n        iakerb_make_exts(ctx, &exts);\n\n        if (ctx->gssc == GSS_C_NO_CONTEXT)\n            input_token = GSS_C_NO_BUFFER;\n\n        /* IAKERB is finished, or we skipped to Kerberos directly. */\n        major_status = krb5_gss_init_sec_context_ext(minor_status,\n                                                     (gss_cred_id_t) kcred,\n                                                     &ctx->gssc,\n                                                     target_name,\n                                                     (gss_OID)gss_mech_iakerb,\n                                                     req_flags,\n                                                     time_req,\n                                                     input_chan_bindings,\n                                                     input_token,\n                                                     NULL,\n                                                     output_token,\n                                                     ret_flags,\n                                                     time_rec,\n                                                     &exts);\n        if (major_status == GSS_S_COMPLETE) {\n            *context_handle = ctx->gssc;\n            ctx->gssc = GSS_C_NO_CONTEXT;\n            iakerb_release_context(ctx);\n        }\n        if (actual_mech_type != NULL)\n            *actual_mech_type = (gss_OID)gss_mech_krb5;\n    } else {\n        if (actual_mech_type != NULL)\n            *actual_mech_type = (gss_OID)gss_mech_iakerb;\n        if (ret_flags != NULL)\n            *ret_flags = 0;\n        if (time_rec != NULL)\n            *time_rec = 0;\n        major_status = GSS_S_CONTINUE_NEEDED;\n    }\n\ncleanup:\n    if (cred_locked)\n        k5_mutex_unlock(&kcred->lock);\n    if (initialContextToken && GSS_ERROR(major_status)) {\n        iakerb_release_context(ctx);\n        *context_handle = GSS_C_NO_CONTEXT;\n    }\n\n    return major_status;\n}",
        "func": "OM_uint32 KRB5_CALLCONV\niakerb_gss_init_sec_context(OM_uint32 *minor_status,\n                            gss_cred_id_t claimant_cred_handle,\n                            gss_ctx_id_t *context_handle,\n                            gss_name_t target_name,\n                            gss_OID mech_type,\n                            OM_uint32 req_flags,\n                            OM_uint32 time_req,\n                            gss_channel_bindings_t input_chan_bindings,\n                            gss_buffer_t input_token,\n                            gss_OID *actual_mech_type,\n                            gss_buffer_t output_token,\n                            OM_uint32 *ret_flags,\n                            OM_uint32 *time_rec)\n{\n    OM_uint32 major_status = GSS_S_FAILURE;\n    krb5_error_code code;\n    iakerb_ctx_id_t ctx;\n    krb5_gss_cred_id_t kcred;\n    krb5_gss_name_t kname;\n    krb5_boolean cred_locked = FALSE;\n    int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);\n\n    if (initialContextToken) {\n        code = iakerb_alloc_context(&ctx, 1);\n        if (code != 0) {\n            *minor_status = code;\n            goto cleanup;\n        }\n        if (claimant_cred_handle == GSS_C_NO_CREDENTIAL) {\n            major_status = iakerb_gss_acquire_cred(minor_status, NULL,\n                                                   GSS_C_INDEFINITE,\n                                                   GSS_C_NULL_OID_SET,\n                                                   GSS_C_INITIATE,\n                                                   &ctx->defcred, NULL, NULL);\n            if (GSS_ERROR(major_status))\n                goto cleanup;\n            claimant_cred_handle = ctx->defcred;\n        }\n    } else {\n        ctx = (iakerb_ctx_id_t)*context_handle;\n        if (claimant_cred_handle == GSS_C_NO_CREDENTIAL)\n            claimant_cred_handle = ctx->defcred;\n    }\n\n    kname = (krb5_gss_name_t)target_name;\n\n    major_status = kg_cred_resolve(minor_status, ctx->k5c,\n                                   claimant_cred_handle, target_name);\n    if (GSS_ERROR(major_status))\n        goto cleanup;\n    cred_locked = TRUE;\n    kcred = (krb5_gss_cred_id_t)claimant_cred_handle;\n\n    major_status = GSS_S_FAILURE;\n\n    if (initialContextToken) {\n        code = iakerb_get_initial_state(ctx, kcred, kname, time_req,\n                                        &ctx->state);\n        if (code != 0) {\n            *minor_status = code;\n            goto cleanup;\n        }\n        *context_handle = (gss_ctx_id_t)ctx;\n    }\n\n    if (ctx->state != IAKERB_AP_REQ) {\n        /* We need to do IAKERB. */\n        code = iakerb_initiator_step(ctx,\n                                     kcred,\n                                     kname,\n                                     time_req,\n                                     input_token,\n                                     output_token);\n        if (code == KRB5_BAD_MSIZE)\n            major_status = GSS_S_DEFECTIVE_TOKEN;\n        if (code != 0) {\n            *minor_status = code;\n            goto cleanup;\n        }\n    }\n\n    if (ctx->state == IAKERB_AP_REQ) {\n        krb5_gss_ctx_ext_rec exts;\n\n        if (cred_locked) {\n            k5_mutex_unlock(&kcred->lock);\n            cred_locked = FALSE;\n        }\n\n        iakerb_make_exts(ctx, &exts);\n\n        if (ctx->gssc == GSS_C_NO_CONTEXT)\n            input_token = GSS_C_NO_BUFFER;\n\n        /* IAKERB is finished, or we skipped to Kerberos directly. */\n        major_status = krb5_gss_init_sec_context_ext(minor_status,\n                                                     (gss_cred_id_t) kcred,\n                                                     &ctx->gssc,\n                                                     target_name,\n                                                     (gss_OID)gss_mech_iakerb,\n                                                     req_flags,\n                                                     time_req,\n                                                     input_chan_bindings,\n                                                     input_token,\n                                                     NULL,\n                                                     output_token,\n                                                     ret_flags,\n                                                     time_rec,\n                                                     &exts);\n        if (major_status == GSS_S_COMPLETE)\n            ctx->established = 1;\n        if (actual_mech_type != NULL)\n            *actual_mech_type = (gss_OID)gss_mech_krb5;\n    } else {\n        if (actual_mech_type != NULL)\n            *actual_mech_type = (gss_OID)gss_mech_iakerb;\n        if (ret_flags != NULL)\n            *ret_flags = 0;\n        if (time_rec != NULL)\n            *time_rec = 0;\n        major_status = GSS_S_CONTINUE_NEEDED;\n    }\n\ncleanup:\n    if (cred_locked)\n        k5_mutex_unlock(&kcred->lock);\n    if (initialContextToken && GSS_ERROR(major_status)) {\n        iakerb_release_context(ctx);\n        *context_handle = GSS_C_NO_CONTEXT;\n    }\n\n    return major_status;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,7 +22,7 @@\n     int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);\n \n     if (initialContextToken) {\n-        code = iakerb_alloc_context(&ctx);\n+        code = iakerb_alloc_context(&ctx, 1);\n         if (code != 0) {\n             *minor_status = code;\n             goto cleanup;\n@@ -108,11 +108,8 @@\n                                                      ret_flags,\n                                                      time_rec,\n                                                      &exts);\n-        if (major_status == GSS_S_COMPLETE) {\n-            *context_handle = ctx->gssc;\n-            ctx->gssc = GSS_C_NO_CONTEXT;\n-            iakerb_release_context(ctx);\n-        }\n+        if (major_status == GSS_S_COMPLETE)\n+            ctx->established = 1;\n         if (actual_mech_type != NULL)\n             *actual_mech_type = (gss_OID)gss_mech_krb5;\n     } else {",
        "diff_line_info": {
            "deleted_lines": [
                "        code = iakerb_alloc_context(&ctx);",
                "        if (major_status == GSS_S_COMPLETE) {",
                "            *context_handle = ctx->gssc;",
                "            ctx->gssc = GSS_C_NO_CONTEXT;",
                "            iakerb_release_context(ctx);",
                "        }"
            ],
            "added_lines": [
                "        code = iakerb_alloc_context(&ctx, 1);",
                "        if (major_status == GSS_S_COMPLETE)",
                "            ctx->established = 1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-2696",
        "func_name": "krb5/iakerb_gss_accept_sec_context",
        "description": "lib/gssapi/krb5/iakerb.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted IAKERB packet that is mishandled during a gss_inquire_context call.",
        "git_url": "https://github.com/krb5/krb5/commit/e04f0283516e80d2f93366e0d479d13c9b5c8c2a",
        "commit_title": "Fix IAKERB context aliasing bugs [CVE-2015-2696]",
        "commit_text": " The IAKERB mechanism currently replaces its context handle with the krb5 mechanism handle upon establishment, under the assumption that most GSS functions are only called after context establishment.  This assumption is incorrect, and can lead to aliasing violations for some programs.  Maintain the IAKERB context structure after context establishment and add new IAKERB entry points to refer to it with that type.  Add initiate and established flags to the IAKERB context structure for use in gss_inquire_context() prior to context establishment.  CVE-2015-2696:  In MIT krb5 1.9 and later, applications which call gss_inquire_context() on a partially-established IAKERB context can cause the GSS-API library to read from a pointer using the wrong type, generally causing a process crash.  Java server applications using the native JGSS provider are vulnerable to this bug.  A carefully crafted IAKERB packet might allow the gss_inquire_context() call to succeed with attacker-determined results, but applications should not make access control decisions based on gss_inquire_context() results prior to context establishment.      CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C  [ghudson@mit.edu: several bugfixes, style changes, and edge-case behavior changes; commit message and CVE description]  ticket: 8244 target_version: 1.14 tags: pullup",
        "func_before": "OM_uint32 KRB5_CALLCONV\niakerb_gss_accept_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_cred_id_t verifier_cred_handle,\n                              gss_buffer_t input_token,\n                              gss_channel_bindings_t input_chan_bindings,\n                              gss_name_t *src_name,\n                              gss_OID *mech_type,\n                              gss_buffer_t output_token,\n                              OM_uint32 *ret_flags,\n                              OM_uint32 *time_rec,\n                              gss_cred_id_t *delegated_cred_handle)\n{\n    OM_uint32 major_status = GSS_S_FAILURE;\n    OM_uint32 code;\n    iakerb_ctx_id_t ctx;\n    int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);\n\n    if (initialContextToken) {\n        code = iakerb_alloc_context(&ctx);\n        if (code != 0)\n            goto cleanup;\n\n    } else\n        ctx = (iakerb_ctx_id_t)*context_handle;\n\n    if (iakerb_is_iakerb_token(input_token)) {\n        if (ctx->gssc != GSS_C_NO_CONTEXT) {\n            /* We shouldn't get an IAKERB token now. */\n            code = G_WRONG_TOKID;\n            major_status = GSS_S_DEFECTIVE_TOKEN;\n            goto cleanup;\n        }\n        code = iakerb_acceptor_step(ctx, initialContextToken,\n                                    input_token, output_token);\n        if (code == (OM_uint32)KRB5_BAD_MSIZE)\n            major_status = GSS_S_DEFECTIVE_TOKEN;\n        if (code != 0)\n            goto cleanup;\n        if (initialContextToken) {\n            *context_handle = (gss_ctx_id_t)ctx;\n            ctx = NULL;\n        }\n        if (src_name != NULL)\n            *src_name = GSS_C_NO_NAME;\n        if (mech_type != NULL)\n            *mech_type = (gss_OID)gss_mech_iakerb;\n        if (ret_flags != NULL)\n            *ret_flags = 0;\n        if (time_rec != NULL)\n            *time_rec = 0;\n        if (delegated_cred_handle != NULL)\n            *delegated_cred_handle = GSS_C_NO_CREDENTIAL;\n        major_status = GSS_S_CONTINUE_NEEDED;\n    } else {\n        krb5_gss_ctx_ext_rec exts;\n\n        iakerb_make_exts(ctx, &exts);\n\n        major_status = krb5_gss_accept_sec_context_ext(&code,\n                                                       &ctx->gssc,\n                                                       verifier_cred_handle,\n                                                       input_token,\n                                                       input_chan_bindings,\n                                                       src_name,\n                                                       NULL,\n                                                       output_token,\n                                                       ret_flags,\n                                                       time_rec,\n                                                       delegated_cred_handle,\n                                                       &exts);\n        if (major_status == GSS_S_COMPLETE) {\n            *context_handle = ctx->gssc;\n            ctx->gssc = NULL;\n            iakerb_release_context(ctx);\n        }\n        if (mech_type != NULL)\n            *mech_type = (gss_OID)gss_mech_krb5;\n    }\n\ncleanup:\n    if (initialContextToken && GSS_ERROR(major_status)) {\n        iakerb_release_context(ctx);\n        *context_handle = GSS_C_NO_CONTEXT;\n    }\n\n    *minor_status = code;\n    return major_status;\n}",
        "func": "OM_uint32 KRB5_CALLCONV\niakerb_gss_accept_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_cred_id_t verifier_cred_handle,\n                              gss_buffer_t input_token,\n                              gss_channel_bindings_t input_chan_bindings,\n                              gss_name_t *src_name,\n                              gss_OID *mech_type,\n                              gss_buffer_t output_token,\n                              OM_uint32 *ret_flags,\n                              OM_uint32 *time_rec,\n                              gss_cred_id_t *delegated_cred_handle)\n{\n    OM_uint32 major_status = GSS_S_FAILURE;\n    OM_uint32 code;\n    iakerb_ctx_id_t ctx;\n    int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);\n\n    if (initialContextToken) {\n        code = iakerb_alloc_context(&ctx, 0);\n        if (code != 0)\n            goto cleanup;\n\n    } else\n        ctx = (iakerb_ctx_id_t)*context_handle;\n\n    if (iakerb_is_iakerb_token(input_token)) {\n        if (ctx->gssc != GSS_C_NO_CONTEXT) {\n            /* We shouldn't get an IAKERB token now. */\n            code = G_WRONG_TOKID;\n            major_status = GSS_S_DEFECTIVE_TOKEN;\n            goto cleanup;\n        }\n        code = iakerb_acceptor_step(ctx, initialContextToken,\n                                    input_token, output_token);\n        if (code == (OM_uint32)KRB5_BAD_MSIZE)\n            major_status = GSS_S_DEFECTIVE_TOKEN;\n        if (code != 0)\n            goto cleanup;\n        if (initialContextToken) {\n            *context_handle = (gss_ctx_id_t)ctx;\n            ctx = NULL;\n        }\n        if (src_name != NULL)\n            *src_name = GSS_C_NO_NAME;\n        if (mech_type != NULL)\n            *mech_type = (gss_OID)gss_mech_iakerb;\n        if (ret_flags != NULL)\n            *ret_flags = 0;\n        if (time_rec != NULL)\n            *time_rec = 0;\n        if (delegated_cred_handle != NULL)\n            *delegated_cred_handle = GSS_C_NO_CREDENTIAL;\n        major_status = GSS_S_CONTINUE_NEEDED;\n    } else {\n        krb5_gss_ctx_ext_rec exts;\n\n        iakerb_make_exts(ctx, &exts);\n\n        major_status = krb5_gss_accept_sec_context_ext(&code,\n                                                       &ctx->gssc,\n                                                       verifier_cred_handle,\n                                                       input_token,\n                                                       input_chan_bindings,\n                                                       src_name,\n                                                       NULL,\n                                                       output_token,\n                                                       ret_flags,\n                                                       time_rec,\n                                                       delegated_cred_handle,\n                                                       &exts);\n        if (major_status == GSS_S_COMPLETE)\n            ctx->established = 1;\n        if (mech_type != NULL)\n            *mech_type = (gss_OID)gss_mech_krb5;\n    }\n\ncleanup:\n    if (initialContextToken && GSS_ERROR(major_status)) {\n        iakerb_release_context(ctx);\n        *context_handle = GSS_C_NO_CONTEXT;\n    }\n\n    *minor_status = code;\n    return major_status;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n     int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);\n \n     if (initialContextToken) {\n-        code = iakerb_alloc_context(&ctx);\n+        code = iakerb_alloc_context(&ctx, 0);\n         if (code != 0)\n             goto cleanup;\n \n@@ -69,11 +69,8 @@\n                                                        time_rec,\n                                                        delegated_cred_handle,\n                                                        &exts);\n-        if (major_status == GSS_S_COMPLETE) {\n-            *context_handle = ctx->gssc;\n-            ctx->gssc = NULL;\n-            iakerb_release_context(ctx);\n-        }\n+        if (major_status == GSS_S_COMPLETE)\n+            ctx->established = 1;\n         if (mech_type != NULL)\n             *mech_type = (gss_OID)gss_mech_krb5;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "        code = iakerb_alloc_context(&ctx);",
                "        if (major_status == GSS_S_COMPLETE) {",
                "            *context_handle = ctx->gssc;",
                "            ctx->gssc = NULL;",
                "            iakerb_release_context(ctx);",
                "        }"
            ],
            "added_lines": [
                "        code = iakerb_alloc_context(&ctx, 0);",
                "        if (major_status == GSS_S_COMPLETE)",
                "            ctx->established = 1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-2696",
        "func_name": "krb5/iakerb_gss_delete_sec_context",
        "description": "lib/gssapi/krb5/iakerb.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted IAKERB packet that is mishandled during a gss_inquire_context call.",
        "git_url": "https://github.com/krb5/krb5/commit/e04f0283516e80d2f93366e0d479d13c9b5c8c2a",
        "commit_title": "Fix IAKERB context aliasing bugs [CVE-2015-2696]",
        "commit_text": " The IAKERB mechanism currently replaces its context handle with the krb5 mechanism handle upon establishment, under the assumption that most GSS functions are only called after context establishment.  This assumption is incorrect, and can lead to aliasing violations for some programs.  Maintain the IAKERB context structure after context establishment and add new IAKERB entry points to refer to it with that type.  Add initiate and established flags to the IAKERB context structure for use in gss_inquire_context() prior to context establishment.  CVE-2015-2696:  In MIT krb5 1.9 and later, applications which call gss_inquire_context() on a partially-established IAKERB context can cause the GSS-API library to read from a pointer using the wrong type, generally causing a process crash.  Java server applications using the native JGSS provider are vulnerable to this bug.  A carefully crafted IAKERB packet might allow the gss_inquire_context() call to succeed with attacker-determined results, but applications should not make access control decisions based on gss_inquire_context() results prior to context establishment.      CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C  [ghudson@mit.edu: several bugfixes, style changes, and edge-case behavior changes; commit message and CVE description]  ticket: 8244 target_version: 1.14 tags: pullup",
        "func_before": "OM_uint32 KRB5_CALLCONV\niakerb_gss_delete_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t output_token)\n{\n    OM_uint32 major_status = GSS_S_COMPLETE;\n\n    if (output_token != GSS_C_NO_BUFFER) {\n        output_token->length = 0;\n        output_token->value = NULL;\n    }\n\n    *minor_status = 0;\n\n    if (*context_handle != GSS_C_NO_CONTEXT) {\n        iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;\n\n        if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {\n            iakerb_release_context(iakerb_ctx);\n            *context_handle = GSS_C_NO_CONTEXT;\n        } else {\n            assert(iakerb_ctx->magic == KG_CONTEXT);\n\n            major_status = krb5_gss_delete_sec_context(minor_status,\n                                                       context_handle,\n                                                       output_token);\n        }\n    }\n\n    return major_status;\n}",
        "func": "OM_uint32 KRB5_CALLCONV\niakerb_gss_delete_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t output_token)\n{\n    iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;\n\n    if (output_token != GSS_C_NO_BUFFER) {\n        output_token->length = 0;\n        output_token->value = NULL;\n    }\n\n    *minor_status = 0;\n    *context_handle = GSS_C_NO_CONTEXT;\n    iakerb_release_context(iakerb_ctx);\n\n    return GSS_S_COMPLETE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n                               gss_ctx_id_t *context_handle,\n                               gss_buffer_t output_token)\n {\n-    OM_uint32 major_status = GSS_S_COMPLETE;\n+    iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;\n \n     if (output_token != GSS_C_NO_BUFFER) {\n         output_token->length = 0;\n@@ -11,21 +11,8 @@\n     }\n \n     *minor_status = 0;\n+    *context_handle = GSS_C_NO_CONTEXT;\n+    iakerb_release_context(iakerb_ctx);\n \n-    if (*context_handle != GSS_C_NO_CONTEXT) {\n-        iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;\n-\n-        if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {\n-            iakerb_release_context(iakerb_ctx);\n-            *context_handle = GSS_C_NO_CONTEXT;\n-        } else {\n-            assert(iakerb_ctx->magic == KG_CONTEXT);\n-\n-            major_status = krb5_gss_delete_sec_context(minor_status,\n-                                                       context_handle,\n-                                                       output_token);\n-        }\n-    }\n-\n-    return major_status;\n+    return GSS_S_COMPLETE;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    OM_uint32 major_status = GSS_S_COMPLETE;",
                "    if (*context_handle != GSS_C_NO_CONTEXT) {",
                "        iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;",
                "",
                "        if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {",
                "            iakerb_release_context(iakerb_ctx);",
                "            *context_handle = GSS_C_NO_CONTEXT;",
                "        } else {",
                "            assert(iakerb_ctx->magic == KG_CONTEXT);",
                "",
                "            major_status = krb5_gss_delete_sec_context(minor_status,",
                "                                                       context_handle,",
                "                                                       output_token);",
                "        }",
                "    }",
                "",
                "    return major_status;"
            ],
            "added_lines": [
                "    iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;",
                "    *context_handle = GSS_C_NO_CONTEXT;",
                "    iakerb_release_context(iakerb_ctx);",
                "    return GSS_S_COMPLETE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-2696",
        "func_name": "krb5/iakerb_alloc_context",
        "description": "lib/gssapi/krb5/iakerb.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted IAKERB packet that is mishandled during a gss_inquire_context call.",
        "git_url": "https://github.com/krb5/krb5/commit/e04f0283516e80d2f93366e0d479d13c9b5c8c2a",
        "commit_title": "Fix IAKERB context aliasing bugs [CVE-2015-2696]",
        "commit_text": " The IAKERB mechanism currently replaces its context handle with the krb5 mechanism handle upon establishment, under the assumption that most GSS functions are only called after context establishment.  This assumption is incorrect, and can lead to aliasing violations for some programs.  Maintain the IAKERB context structure after context establishment and add new IAKERB entry points to refer to it with that type.  Add initiate and established flags to the IAKERB context structure for use in gss_inquire_context() prior to context establishment.  CVE-2015-2696:  In MIT krb5 1.9 and later, applications which call gss_inquire_context() on a partially-established IAKERB context can cause the GSS-API library to read from a pointer using the wrong type, generally causing a process crash.  Java server applications using the native JGSS provider are vulnerable to this bug.  A carefully crafted IAKERB packet might allow the gss_inquire_context() call to succeed with attacker-determined results, but applications should not make access control decisions based on gss_inquire_context() results prior to context establishment.      CVSSv2 Vector: AV:N/AC:M/Au:N/C:N/I:N/A:C/E:POC/RL:OF/RC:C  [ghudson@mit.edu: several bugfixes, style changes, and edge-case behavior changes; commit message and CVE description]  ticket: 8244 target_version: 1.14 tags: pullup",
        "func_before": "static krb5_error_code\niakerb_alloc_context(iakerb_ctx_id_t *pctx)\n{\n    iakerb_ctx_id_t ctx;\n    krb5_error_code code;\n\n    *pctx = NULL;\n\n    ctx = k5alloc(sizeof(*ctx), &code);\n    if (ctx == NULL)\n        goto cleanup;\n    ctx->defcred = GSS_C_NO_CREDENTIAL;\n    ctx->magic = KG_IAKERB_CONTEXT;\n    ctx->state = IAKERB_AS_REQ;\n    ctx->count = 0;\n\n    code = krb5_gss_init_context(&ctx->k5c);\n    if (code != 0)\n        goto cleanup;\n\n    *pctx = ctx;\n\ncleanup:\n    if (code != 0)\n        iakerb_release_context(ctx);\n\n    return code;\n}",
        "func": "static krb5_error_code\niakerb_alloc_context(iakerb_ctx_id_t *pctx, int initiate)\n{\n    iakerb_ctx_id_t ctx;\n    krb5_error_code code;\n\n    *pctx = NULL;\n\n    ctx = k5alloc(sizeof(*ctx), &code);\n    if (ctx == NULL)\n        goto cleanup;\n    ctx->defcred = GSS_C_NO_CREDENTIAL;\n    ctx->magic = KG_IAKERB_CONTEXT;\n    ctx->state = IAKERB_AS_REQ;\n    ctx->count = 0;\n    ctx->initiate = initiate;\n    ctx->established = 0;\n\n    code = krb5_gss_init_context(&ctx->k5c);\n    if (code != 0)\n        goto cleanup;\n\n    *pctx = ctx;\n\ncleanup:\n    if (code != 0)\n        iakerb_release_context(ctx);\n\n    return code;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n static krb5_error_code\n-iakerb_alloc_context(iakerb_ctx_id_t *pctx)\n+iakerb_alloc_context(iakerb_ctx_id_t *pctx, int initiate)\n {\n     iakerb_ctx_id_t ctx;\n     krb5_error_code code;\n@@ -13,6 +13,8 @@\n     ctx->magic = KG_IAKERB_CONTEXT;\n     ctx->state = IAKERB_AS_REQ;\n     ctx->count = 0;\n+    ctx->initiate = initiate;\n+    ctx->established = 0;\n \n     code = krb5_gss_init_context(&ctx->k5c);\n     if (code != 0)",
        "diff_line_info": {
            "deleted_lines": [
                "iakerb_alloc_context(iakerb_ctx_id_t *pctx)"
            ],
            "added_lines": [
                "iakerb_alloc_context(iakerb_ctx_id_t *pctx, int initiate)",
                "    ctx->initiate = initiate;",
                "    ctx->established = 0;"
            ]
        }
    }
]