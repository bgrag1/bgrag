[
    {
        "cve_id": "CVE-2017-13083",
        "func_name": "pbatard/rufus/NewVersionCallback",
        "description": "Akeo Consulting Rufus prior to version 2.17.1187 does not adequately validate the integrity of updates downloaded over HTTP, allowing an attacker to easily convince a user to execute arbitrary code",
        "git_url": "https://github.com/pbatard/rufus/commit/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb",
        "commit_title": "[pki] fix https://www.kb.cert.org/vuls/id/403768",
        "commit_text": " * This commit effectively fixes https://www.kb.cert.org/vuls/id/403768 (CVE-2017-13083) as   it is described per its revision 11, which is the latest revision at the time of this commit,   by disabling Windows prompts, enacted during signature validation, that allow the user to   bypass the intended signature verification checks. * It needs to be pointed out that the vulnerability (\"allow(ing) the use of a self-signed   certificate\"), which relies on the end-user actively ignoring a Windows prompt that tells   them that the update failed the signature validation whilst also advising against running it,   is being fully addressed, even as the update protocol remains HTTP. * It also need to be pointed out that the extended delay (48 hours) between the time the   vulnerability was reported and the moment it is fixed in our codebase has to do with   the fact that the reporter chose to deviate from standard security practices by not   disclosing the details of the vulnerability with us, be it publicly or privately,   before creating the cert.org report. The only advance notification we received was a   generic note about the use of HTTP vs HTTPS, which, as have established, is not   immediately relevant to addressing the reported vulnerability. * Closes #1009 * Note: The other vulnerability scenario described towards the end of #1009, which   doesn't have to do with the \"lack of CA checking\", will be addressed separately.",
        "func_before": "INT_PTR CALLBACK NewVersionCallback(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)\n{\n\tchar cmdline[] = APPLICATION_NAME \" -w 150\";\n\tstatic char* filepath = NULL;\n\tstatic int download_status = 0;\n\tLONG i;\n\tHWND hNotes;\n\tSTARTUPINFOA si;\n\tPROCESS_INFORMATION pi;\n\tHFONT hyperlink_font = NULL;\n\tEXT_DECL(dl_ext, NULL, __VA_GROUP__(\"*.exe\"), __VA_GROUP__(lmprintf(MSG_037)));\n\n\tswitch (message) {\n\tcase WM_INITDIALOG:\n\t\tapply_localization(IDD_NEW_VERSION, hDlg);\n\t\tdownload_status = 0;\n\t\tSetTitleBarIcon(hDlg);\n\t\tCenterDialog(hDlg);\n\t\t// Subclass the callback so that we can change the cursor\n\t\tupdate_original_proc = (WNDPROC)SetWindowLongPtr(hDlg, GWLP_WNDPROC, (LONG_PTR)update_subclass_callback);\n\t\thNotes = GetDlgItem(hDlg, IDC_RELEASE_NOTES);\n\t\tSendMessage(hNotes, EM_AUTOURLDETECT, 1, 0);\n\t\tSendMessageA(hNotes, EM_SETTEXTEX, (WPARAM)&friggin_microsoft_unicode_amateurs, (LPARAM)update.release_notes);\n\t\tSendMessage(hNotes, EM_SETSEL, -1, -1);\n\t\tSendMessage(hNotes, EM_SETEVENTMASK, 0, ENM_LINK);\n\t\tSetWindowTextU(GetDlgItem(hDlg, IDC_YOUR_VERSION), lmprintf(MSG_018,\n\t\t\trufus_version[0], rufus_version[1], rufus_version[2]));\n\t\tSetWindowTextU(GetDlgItem(hDlg, IDC_LATEST_VERSION), lmprintf(MSG_019,\n\t\t\tupdate.version[0], update.version[1], update.version[2]));\n\t\tSetWindowTextU(GetDlgItem(hDlg, IDC_DOWNLOAD_URL), update.download_url);\n\t\tSendMessage(GetDlgItem(hDlg, IDC_PROGRESS), PBM_SETRANGE, 0, (MAX_PROGRESS<<16) & 0xFFFF0000);\n\t\tif (update.download_url == NULL)\n\t\t\tEnableWindow(GetDlgItem(hDlg, IDC_DOWNLOAD), FALSE);\n\t\tbreak;\n\tcase WM_CTLCOLORSTATIC:\n\t\tif ((HWND)lParam != GetDlgItem(hDlg, IDC_WEBSITE))\n\t\t\treturn FALSE;\n\t\t// Change the font for the hyperlink\n\t\tSetBkMode((HDC)wParam, TRANSPARENT);\n\t\tCreateStaticFont((HDC)wParam, &hyperlink_font);\n\t\tSelectObject((HDC)wParam, hyperlink_font);\n\t\tSetTextColor((HDC)wParam, RGB(0,0,125));\t// DARK_BLUE\n\t\treturn (INT_PTR)CreateSolidBrush(GetSysColor(COLOR_BTNFACE));\n\tcase WM_COMMAND:\n\t\tswitch (LOWORD(wParam)) {\n\t\tcase IDCLOSE:\n\t\tcase IDCANCEL:\n\t\t\tif (download_status != 1) {\n\t\t\t\treset_localization(IDD_NEW_VERSION);\n\t\t\t\tsafe_free(filepath);\n\t\t\t\tEndDialog(hDlg, LOWORD(wParam));\n\t\t\t}\n\t\t\treturn (INT_PTR)TRUE;\n\t\tcase IDC_WEBSITE:\n\t\t\tShellExecuteA(hDlg, \"open\", RUFUS_URL, NULL, NULL, SW_SHOWNORMAL);\n\t\t\tbreak;\n\t\tcase IDC_DOWNLOAD:\t// Also doubles as abort and launch function\n\t\t\tswitch(download_status) {\n\t\t\tcase 1:\t\t// Abort\n\t\t\t\tFormatStatus = ERROR_SEVERITY_ERROR|FAC(FACILITY_STORAGE)|ERROR_CANCELLED;\n\t\t\t\tdownload_status = 0;\n\t\t\t\tbreak;\n\t\t\tcase 2:\t\t// Launch newer version and close this one\n\t\t\t\tSleep(1000);\t// Add a delay on account of antivirus scanners\n\n\t\t\t\tif (ValidateSignature(hDlg, filepath) != NO_ERROR)\n\t\t\t\t\tbreak;\n\n\t\t\t\tmemset(&si, 0, sizeof(si));\n\t\t\t\tmemset(&pi, 0, sizeof(pi));\n\t\t\t\tsi.cb = sizeof(si);\n\t\t\t\tif (!CreateProcessU(filepath, cmdline, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {\n\t\t\t\t\tPrintInfo(0, MSG_214);\n\t\t\t\t\tuprintf(\"Failed to launch new application: %s\\n\", WindowsErrorString());\n\t\t\t\t} else {\n\t\t\t\t\tPrintInfo(0, MSG_213);\n\t\t\t\t\tPostMessage(hDlg, WM_COMMAND, (WPARAM)IDCLOSE, 0);\n\t\t\t\t\tPostMessage(hMainDialog, WM_CLOSE, 0, 0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\t// Download\n\t\t\t\tif (update.download_url == NULL) {\n\t\t\t\t\tuprintf(\"Could not get download URL\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (i=(int)strlen(update.download_url); (i>0)&&(update.download_url[i]!='/'); i--);\n\t\t\t\tdl_ext.filename = &update.download_url[i+1];\n\t\t\t\tfilepath = FileDialog(TRUE, app_dir, &dl_ext, OFN_NOCHANGEDIR);\n\t\t\t\tif (filepath == NULL) {\n\t\t\t\t\tuprintf(\"Could not get save path\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// Opening the File Dialog will make us lose tabbing focus - set it back\n\t\t\t\tSendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, IDC_DOWNLOAD), TRUE);\n\t\t\t\tDownloadFileThreaded(update.download_url, filepath, hDlg);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn (INT_PTR)TRUE;\n\t\t}\n\t\tbreak;\n\tcase UM_PROGRESS_INIT:\n\t\tEnableWindow(GetDlgItem(hDlg, IDCANCEL), FALSE);\n\t\tSetWindowTextU(GetDlgItem(hDlg, IDC_DOWNLOAD), lmprintf(MSG_038));\n\t\tFormatStatus = 0;\n\t\tdownload_status = 1;\n\t\treturn (INT_PTR)TRUE;\n\tcase UM_PROGRESS_EXIT:\n\t\tEnableWindow(GetDlgItem(hDlg, IDCANCEL), TRUE);\n\t\tif (wParam) {\n\t\t\tSetWindowTextU(GetDlgItem(hDlg, IDC_DOWNLOAD), lmprintf(MSG_039));\n\t\t\tdownload_status = 2;\n\t\t} else {\n\t\t\tSetWindowTextU(GetDlgItem(hDlg, IDC_DOWNLOAD), lmprintf(MSG_040));\n\t\t\tdownload_status = 0;\n\t\t}\n\t\treturn (INT_PTR)TRUE;\n\t}\n\treturn (INT_PTR)FALSE;\n}",
        "func": "INT_PTR CALLBACK NewVersionCallback(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)\n{\n\tchar cmdline[] = APPLICATION_NAME \" -w 150\";\n\tstatic char* filepath = NULL;\n\tstatic int download_status = 0;\n\tLONG i;\n\tHWND hNotes;\n\tSTARTUPINFOA si;\n\tPROCESS_INFORMATION pi;\n\tHFONT hyperlink_font = NULL;\n\tEXT_DECL(dl_ext, NULL, __VA_GROUP__(\"*.exe\"), __VA_GROUP__(lmprintf(MSG_037)));\n\n\tswitch (message) {\n\tcase WM_INITDIALOG:\n\t\tapply_localization(IDD_NEW_VERSION, hDlg);\n\t\tdownload_status = 0;\n\t\tSetTitleBarIcon(hDlg);\n\t\tCenterDialog(hDlg);\n\t\t// Subclass the callback so that we can change the cursor\n\t\tupdate_original_proc = (WNDPROC)SetWindowLongPtr(hDlg, GWLP_WNDPROC, (LONG_PTR)update_subclass_callback);\n\t\thNotes = GetDlgItem(hDlg, IDC_RELEASE_NOTES);\n\t\tSendMessage(hNotes, EM_AUTOURLDETECT, 1, 0);\n\t\tSendMessageA(hNotes, EM_SETTEXTEX, (WPARAM)&friggin_microsoft_unicode_amateurs, (LPARAM)update.release_notes);\n\t\tSendMessage(hNotes, EM_SETSEL, -1, -1);\n\t\tSendMessage(hNotes, EM_SETEVENTMASK, 0, ENM_LINK);\n\t\tSetWindowTextU(GetDlgItem(hDlg, IDC_YOUR_VERSION), lmprintf(MSG_018,\n\t\t\trufus_version[0], rufus_version[1], rufus_version[2]));\n\t\tSetWindowTextU(GetDlgItem(hDlg, IDC_LATEST_VERSION), lmprintf(MSG_019,\n\t\t\tupdate.version[0], update.version[1], update.version[2]));\n\t\tSetWindowTextU(GetDlgItem(hDlg, IDC_DOWNLOAD_URL), update.download_url);\n\t\tSendMessage(GetDlgItem(hDlg, IDC_PROGRESS), PBM_SETRANGE, 0, (MAX_PROGRESS<<16) & 0xFFFF0000);\n\t\tif (update.download_url == NULL)\n\t\t\tEnableWindow(GetDlgItem(hDlg, IDC_DOWNLOAD), FALSE);\n\t\tbreak;\n\tcase WM_CTLCOLORSTATIC:\n\t\tif ((HWND)lParam != GetDlgItem(hDlg, IDC_WEBSITE))\n\t\t\treturn FALSE;\n\t\t// Change the font for the hyperlink\n\t\tSetBkMode((HDC)wParam, TRANSPARENT);\n\t\tCreateStaticFont((HDC)wParam, &hyperlink_font);\n\t\tSelectObject((HDC)wParam, hyperlink_font);\n\t\tSetTextColor((HDC)wParam, RGB(0,0,125));\t// DARK_BLUE\n\t\treturn (INT_PTR)CreateSolidBrush(GetSysColor(COLOR_BTNFACE));\n\tcase WM_COMMAND:\n\t\tswitch (LOWORD(wParam)) {\n\t\tcase IDCLOSE:\n\t\tcase IDCANCEL:\n\t\t\tif (download_status != 1) {\n\t\t\t\treset_localization(IDD_NEW_VERSION);\n\t\t\t\tsafe_free(filepath);\n\t\t\t\tEndDialog(hDlg, LOWORD(wParam));\n\t\t\t}\n\t\t\treturn (INT_PTR)TRUE;\n\t\tcase IDC_WEBSITE:\n\t\t\tShellExecuteA(hDlg, \"open\", RUFUS_URL, NULL, NULL, SW_SHOWNORMAL);\n\t\t\tbreak;\n\t\tcase IDC_DOWNLOAD:\t// Also doubles as abort and launch function\n\t\t\tswitch(download_status) {\n\t\t\tcase 1:\t\t// Abort\n\t\t\t\tFormatStatus = ERROR_SEVERITY_ERROR|FAC(FACILITY_STORAGE)|ERROR_CANCELLED;\n\t\t\t\tdownload_status = 0;\n\t\t\t\tbreak;\n\t\t\tcase 2:\t\t// Launch newer version and close this one\n\t\t\t\tSleep(1000);\t// Add a delay on account of antivirus scanners\n\n\t\t\t\tif (ValidateSignature(hDlg, filepath) != NO_ERROR) {\n\t\t\t\t\t// Unconditionally delete the download and disable the \"Launch\" control\n\t\t\t\t\t_unlinkU(filepath);\n\t\t\t\t\tEnableWindow(GetDlgItem(hDlg, IDC_DOWNLOAD), FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tmemset(&si, 0, sizeof(si));\n\t\t\t\tmemset(&pi, 0, sizeof(pi));\n\t\t\t\tsi.cb = sizeof(si);\n\t\t\t\tif (!CreateProcessU(filepath, cmdline, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {\n\t\t\t\t\tPrintInfo(0, MSG_214);\n\t\t\t\t\tuprintf(\"Failed to launch new application: %s\\n\", WindowsErrorString());\n\t\t\t\t} else {\n\t\t\t\t\tPrintInfo(0, MSG_213);\n\t\t\t\t\tPostMessage(hDlg, WM_COMMAND, (WPARAM)IDCLOSE, 0);\n\t\t\t\t\tPostMessage(hMainDialog, WM_CLOSE, 0, 0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\t// Download\n\t\t\t\tif (update.download_url == NULL) {\n\t\t\t\t\tuprintf(\"Could not get download URL\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (i=(int)strlen(update.download_url); (i>0)&&(update.download_url[i]!='/'); i--);\n\t\t\t\tdl_ext.filename = &update.download_url[i+1];\n\t\t\t\tfilepath = FileDialog(TRUE, app_dir, &dl_ext, OFN_NOCHANGEDIR);\n\t\t\t\tif (filepath == NULL) {\n\t\t\t\t\tuprintf(\"Could not get save path\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// Opening the File Dialog will make us lose tabbing focus - set it back\n\t\t\t\tSendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, IDC_DOWNLOAD), TRUE);\n\t\t\t\tDownloadFileThreaded(update.download_url, filepath, hDlg);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn (INT_PTR)TRUE;\n\t\t}\n\t\tbreak;\n\tcase UM_PROGRESS_INIT:\n\t\tEnableWindow(GetDlgItem(hDlg, IDCANCEL), FALSE);\n\t\tSetWindowTextU(GetDlgItem(hDlg, IDC_DOWNLOAD), lmprintf(MSG_038));\n\t\tFormatStatus = 0;\n\t\tdownload_status = 1;\n\t\treturn (INT_PTR)TRUE;\n\tcase UM_PROGRESS_EXIT:\n\t\tEnableWindow(GetDlgItem(hDlg, IDCANCEL), TRUE);\n\t\tif (wParam) {\n\t\t\tSetWindowTextU(GetDlgItem(hDlg, IDC_DOWNLOAD), lmprintf(MSG_039));\n\t\t\tdownload_status = 2;\n\t\t} else {\n\t\t\tSetWindowTextU(GetDlgItem(hDlg, IDC_DOWNLOAD), lmprintf(MSG_040));\n\t\t\tdownload_status = 0;\n\t\t}\n\t\treturn (INT_PTR)TRUE;\n\t}\n\treturn (INT_PTR)FALSE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -63,8 +63,12 @@\n \t\t\tcase 2:\t\t// Launch newer version and close this one\n \t\t\t\tSleep(1000);\t// Add a delay on account of antivirus scanners\n \n-\t\t\t\tif (ValidateSignature(hDlg, filepath) != NO_ERROR)\n+\t\t\t\tif (ValidateSignature(hDlg, filepath) != NO_ERROR) {\n+\t\t\t\t\t// Unconditionally delete the download and disable the \"Launch\" control\n+\t\t\t\t\t_unlinkU(filepath);\n+\t\t\t\t\tEnableWindow(GetDlgItem(hDlg, IDC_DOWNLOAD), FALSE);\n \t\t\t\t\tbreak;\n+\t\t\t\t}\n \n \t\t\t\tmemset(&si, 0, sizeof(si));\n \t\t\t\tmemset(&pi, 0, sizeof(pi));",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\tif (ValidateSignature(hDlg, filepath) != NO_ERROR)"
            ],
            "added_lines": [
                "\t\t\t\tif (ValidateSignature(hDlg, filepath) != NO_ERROR) {",
                "\t\t\t\t\t// Unconditionally delete the download and disable the \"Launch\" control",
                "\t\t\t\t\t_unlinkU(filepath);",
                "\t\t\t\t\tEnableWindow(GetDlgItem(hDlg, IDC_DOWNLOAD), FALSE);",
                "\t\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-13083",
        "func_name": "pbatard/rufus/ValidateSignature",
        "description": "Akeo Consulting Rufus prior to version 2.17.1187 does not adequately validate the integrity of updates downloaded over HTTP, allowing an attacker to easily convince a user to execute arbitrary code",
        "git_url": "https://github.com/pbatard/rufus/commit/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb",
        "commit_title": "[pki] fix https://www.kb.cert.org/vuls/id/403768",
        "commit_text": " * This commit effectively fixes https://www.kb.cert.org/vuls/id/403768 (CVE-2017-13083) as   it is described per its revision 11, which is the latest revision at the time of this commit,   by disabling Windows prompts, enacted during signature validation, that allow the user to   bypass the intended signature verification checks. * It needs to be pointed out that the vulnerability (\"allow(ing) the use of a self-signed   certificate\"), which relies on the end-user actively ignoring a Windows prompt that tells   them that the update failed the signature validation whilst also advising against running it,   is being fully addressed, even as the update protocol remains HTTP. * It also need to be pointed out that the extended delay (48 hours) between the time the   vulnerability was reported and the moment it is fixed in our codebase has to do with   the fact that the reporter chose to deviate from standard security practices by not   disclosing the details of the vulnerability with us, be it publicly or privately,   before creating the cert.org report. The only advance notification we received was a   generic note about the use of HTTP vs HTTPS, which, as have established, is not   immediately relevant to addressing the reported vulnerability. * Closes #1009 * Note: The other vulnerability scenario described towards the end of #1009, which   doesn't have to do with the \"lack of CA checking\", will be addressed separately.",
        "func_before": "LONG ValidateSignature(HWND hDlg, const char* path)\n{\n\tLONG r;\n\tWINTRUST_DATA trust_data = { 0 };\n\tWINTRUST_FILE_INFO trust_file = { 0 };\n\tGUID guid_generic_verify =\t// WINTRUST_ACTION_GENERIC_VERIFY_V2\n\t\t{ 0xaac56b, 0xcd44, 0x11d0,{ 0x8c, 0xc2, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee } };\n\tchar *signature_name;\n\tsize_t i, len;\n\n\t// Check the signature name. Make it specific enough (i.e. don't simply check for \"Akeo\")\n\t// so that, besides hacking our server, it'll place an extra hurdle on any malicious entity\n\t// into also fooling a C.A. to issue a certificate that passes our test.\n\tsignature_name = GetSignatureName(path);\n\tif (signature_name == NULL) {\n\t\tuprintf(\"PKI: Could not get signature name\");\n\t\tMessageBoxExU(hDlg, lmprintf(MSG_284), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);\n\t\treturn TRUST_E_NOSIGNATURE;\n\t}\n\tfor (i = 0; i < ARRAYSIZE(cert_name); i++) {\n\t\tlen = strlen(cert_name[i]);\n\t\tif (strncmp(signature_name, cert_name[i], len) == 0) {\n\t\t\t// Test for whitespace after the part we match, for added safety\n\t\t\tif ((len >= strlen(signature_name)) || isspace(signature_name[len]))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= ARRAYSIZE(cert_name)) {\n\t\tuprintf(\"PKI: Signature '%s' is unexpected...\", signature_name);\n\t\tif (MessageBoxExU(hDlg, lmprintf(MSG_285, signature_name), lmprintf(MSG_283),\n\t\t\tMB_YESNO | MB_ICONWARNING | MB_IS_RTL, selected_langid) != IDYES)\n\t\t\treturn TRUST_E_EXPLICIT_DISTRUST;\n\t}\n\n\ttrust_file.cbStruct = sizeof(trust_file);\n\ttrust_file.pcwszFilePath = utf8_to_wchar(path);\n\tif (trust_file.pcwszFilePath == NULL) {\n\t\tuprintf(\"PKI: Unable to convert '%s' to UTF16\", path);\n\t\treturn ERROR_SEVERITY_ERROR | FAC(FACILITY_CERT) | ERROR_NOT_ENOUGH_MEMORY;\n\t}\n\n\ttrust_data.cbStruct = sizeof(trust_data);\n\ttrust_data.dwUIChoice = WTD_UI_ALL;\n\t// We just downloaded from the Internet, so we should be able to check revocation\n\ttrust_data.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;\n\t// 0x400 = WTD_MOTW  for Windows 8.1 or later\n\ttrust_data.dwProvFlags = WTD_REVOCATION_CHECK_CHAIN | 0x400;\n\ttrust_data.dwUnionChoice = WTD_CHOICE_FILE;\n\ttrust_data.pFile = &trust_file;\n\n\tr = WinVerifyTrust(NULL, &guid_generic_verify, &trust_data);\n\tsafe_free(trust_file.pcwszFilePath);\n\n\treturn r;\n}",
        "func": "LONG ValidateSignature(HWND hDlg, const char* path)\n{\n\tLONG r;\n\tWINTRUST_DATA trust_data = { 0 };\n\tWINTRUST_FILE_INFO trust_file = { 0 };\n\tGUID guid_generic_verify =\t// WINTRUST_ACTION_GENERIC_VERIFY_V2\n\t\t{ 0xaac56b, 0xcd44, 0x11d0,{ 0x8c, 0xc2, 0x0, 0xc0, 0x4f, 0xc2, 0x95, 0xee } };\n\tchar *signature_name;\n\tsize_t i, len;\n\n\t// Check the signature name. Make it specific enough (i.e. don't simply check for \"Akeo\")\n\t// so that, besides hacking our server, it'll place an extra hurdle on any malicious entity\n\t// into also fooling a C.A. to issue a certificate that passes our test.\n\tsignature_name = GetSignatureName(path);\n\tif (signature_name == NULL) {\n\t\tuprintf(\"PKI: Could not get signature name\");\n\t\tMessageBoxExU(hDlg, lmprintf(MSG_284), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);\n\t\treturn TRUST_E_NOSIGNATURE;\n\t}\n\tfor (i = 0; i < ARRAYSIZE(cert_name); i++) {\n\t\tlen = strlen(cert_name[i]);\n\t\tif (strncmp(signature_name, cert_name[i], len) == 0) {\n\t\t\t// Test for whitespace after the part we match, for added safety\n\t\t\tif ((len >= strlen(signature_name)) || isspace(signature_name[len]))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (i >= ARRAYSIZE(cert_name)) {\n\t\tuprintf(\"PKI: Signature '%s' is unexpected...\", signature_name);\n\t\tif (MessageBoxExU(hDlg, lmprintf(MSG_285, signature_name), lmprintf(MSG_283),\n\t\t\tMB_YESNO | MB_ICONWARNING | MB_IS_RTL, selected_langid) != IDYES)\n\t\t\treturn TRUST_E_EXPLICIT_DISTRUST;\n\t}\n\n\ttrust_file.cbStruct = sizeof(trust_file);\n\ttrust_file.pcwszFilePath = utf8_to_wchar(path);\n\tif (trust_file.pcwszFilePath == NULL) {\n\t\tuprintf(\"PKI: Unable to convert '%s' to UTF16\", path);\n\t\treturn ERROR_SEVERITY_ERROR | FAC(FACILITY_CERT) | ERROR_NOT_ENOUGH_MEMORY;\n\t}\n\n\ttrust_data.cbStruct = sizeof(trust_data);\n\t// NB: WTD_UI_ALL can result in ERROR_SUCCESS even if the signature validation fails,\n\t// because it still prompts the user to run untrusted software, even after explicitly\n\t// notifying them that the signature invalid (and of course Microsoft had to make\n\t// that UI prompt a bit too similar to the other benign prompt you get when running\n\t// trusted software, which, as per cert.org's assessment, may confuse non-security\n\t// conscious-users who decide to gloss over these kind of notifications).\n\ttrust_data.dwUIChoice = WTD_UI_NONE;\n\t// We just downloaded from the Internet, so we should be able to check revocation\n\ttrust_data.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;\n\t// 0x400 = WTD_MOTW  for Windows 8.1 or later\n\ttrust_data.dwProvFlags = WTD_REVOCATION_CHECK_CHAIN | 0x400;\n\ttrust_data.dwUnionChoice = WTD_CHOICE_FILE;\n\ttrust_data.pFile = &trust_file;\n\n\tr = WinVerifyTrust(NULL, &guid_generic_verify, &trust_data);\n\tsafe_free(trust_file.pcwszFilePath);\n\tswitch (r) {\n\tcase ERROR_SUCCESS:\n\t\tbreak;\n\tcase TRUST_E_NOSIGNATURE:\n\t\t// Should already have been reported, but since we have a custom message for it...\n\t\tuprintf(\"PKI: File does not appear to be signed: %s\", WinPKIErrorString());\n\t\tMessageBoxExU(hDlg, lmprintf(MSG_284), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);\n\t\tbreak;\n\tdefault:\n\t\tuprintf(\"PKI: Failed to validate signature: %s\", WinPKIErrorString());\n\t\tMessageBoxExU(hDlg, lmprintf(MSG_240), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);\n\t\tbreak;\n\t}\n\n\treturn r;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -40,7 +40,13 @@\n \t}\n \n \ttrust_data.cbStruct = sizeof(trust_data);\n-\ttrust_data.dwUIChoice = WTD_UI_ALL;\n+\t// NB: WTD_UI_ALL can result in ERROR_SUCCESS even if the signature validation fails,\n+\t// because it still prompts the user to run untrusted software, even after explicitly\n+\t// notifying them that the signature invalid (and of course Microsoft had to make\n+\t// that UI prompt a bit too similar to the other benign prompt you get when running\n+\t// trusted software, which, as per cert.org's assessment, may confuse non-security\n+\t// conscious-users who decide to gloss over these kind of notifications).\n+\ttrust_data.dwUIChoice = WTD_UI_NONE;\n \t// We just downloaded from the Internet, so we should be able to check revocation\n \ttrust_data.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;\n \t// 0x400 = WTD_MOTW  for Windows 8.1 or later\n@@ -50,6 +56,19 @@\n \n \tr = WinVerifyTrust(NULL, &guid_generic_verify, &trust_data);\n \tsafe_free(trust_file.pcwszFilePath);\n+\tswitch (r) {\n+\tcase ERROR_SUCCESS:\n+\t\tbreak;\n+\tcase TRUST_E_NOSIGNATURE:\n+\t\t// Should already have been reported, but since we have a custom message for it...\n+\t\tuprintf(\"PKI: File does not appear to be signed: %s\", WinPKIErrorString());\n+\t\tMessageBoxExU(hDlg, lmprintf(MSG_284), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);\n+\t\tbreak;\n+\tdefault:\n+\t\tuprintf(\"PKI: Failed to validate signature: %s\", WinPKIErrorString());\n+\t\tMessageBoxExU(hDlg, lmprintf(MSG_240), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);\n+\t\tbreak;\n+\t}\n \n \treturn r;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\ttrust_data.dwUIChoice = WTD_UI_ALL;"
            ],
            "added_lines": [
                "\t// NB: WTD_UI_ALL can result in ERROR_SUCCESS even if the signature validation fails,",
                "\t// because it still prompts the user to run untrusted software, even after explicitly",
                "\t// notifying them that the signature invalid (and of course Microsoft had to make",
                "\t// that UI prompt a bit too similar to the other benign prompt you get when running",
                "\t// trusted software, which, as per cert.org's assessment, may confuse non-security",
                "\t// conscious-users who decide to gloss over these kind of notifications).",
                "\ttrust_data.dwUIChoice = WTD_UI_NONE;",
                "\tswitch (r) {",
                "\tcase ERROR_SUCCESS:",
                "\t\tbreak;",
                "\tcase TRUST_E_NOSIGNATURE:",
                "\t\t// Should already have been reported, but since we have a custom message for it...",
                "\t\tuprintf(\"PKI: File does not appear to be signed: %s\", WinPKIErrorString());",
                "\t\tMessageBoxExU(hDlg, lmprintf(MSG_284), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);",
                "\t\tbreak;",
                "\tdefault:",
                "\t\tuprintf(\"PKI: Failed to validate signature: %s\", WinPKIErrorString());",
                "\t\tMessageBoxExU(hDlg, lmprintf(MSG_240), lmprintf(MSG_283), MB_OK | MB_ICONERROR | MB_IS_RTL, selected_langid);",
                "\t\tbreak;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-13083",
        "func_name": "pbatard/rufus/WinPKIErrorString",
        "description": "Akeo Consulting Rufus prior to version 2.17.1187 does not adequately validate the integrity of updates downloaded over HTTP, allowing an attacker to easily convince a user to execute arbitrary code",
        "git_url": "https://github.com/pbatard/rufus/commit/c3c39f7f8a11f612c4ebf7affce25ec6928eb1cb",
        "commit_title": "[pki] fix https://www.kb.cert.org/vuls/id/403768",
        "commit_text": " * This commit effectively fixes https://www.kb.cert.org/vuls/id/403768 (CVE-2017-13083) as   it is described per its revision 11, which is the latest revision at the time of this commit,   by disabling Windows prompts, enacted during signature validation, that allow the user to   bypass the intended signature verification checks. * It needs to be pointed out that the vulnerability (\"allow(ing) the use of a self-signed   certificate\"), which relies on the end-user actively ignoring a Windows prompt that tells   them that the update failed the signature validation whilst also advising against running it,   is being fully addressed, even as the update protocol remains HTTP. * It also need to be pointed out that the extended delay (48 hours) between the time the   vulnerability was reported and the moment it is fixed in our codebase has to do with   the fact that the reporter chose to deviate from standard security practices by not   disclosing the details of the vulnerability with us, be it publicly or privately,   before creating the cert.org report. The only advance notification we received was a   generic note about the use of HTTP vs HTTPS, which, as have established, is not   immediately relevant to addressing the reported vulnerability. * Closes #1009 * Note: The other vulnerability scenario described towards the end of #1009, which   doesn't have to do with the \"lack of CA checking\", will be addressed separately.",
        "func_before": "const char* WinPKIErrorString(void)\n{\n\tstatic char error_string[64];\n\tDWORD error_code = GetLastError();\n\n\tif ((error_code >> 16) != 0x8009)\n\t\treturn WindowsErrorString();\n\n\tswitch (error_code) {\n\tcase NTE_BAD_UID:\n\t\treturn \"Bad UID.\";\n\tcase CRYPT_E_MSG_ERROR:\n\t\treturn \"An error occurred while performing an operation on a cryptographic message.\";\n\tcase CRYPT_E_UNKNOWN_ALGO:\n\t\treturn \"Unknown cryptographic algorithm.\";\n\tcase CRYPT_E_INVALID_MSG_TYPE:\n\t\treturn \"Invalid cryptographic message type.\";\n\tcase CRYPT_E_HASH_VALUE:\n\t\treturn \"The hash value is not correct\";\n\tcase CRYPT_E_ISSUER_SERIALNUMBER:\n\t\treturn \"Invalid issuer and/or serial number.\";\n\tcase CRYPT_E_BAD_LEN:\n\t\treturn \"The length specified for the output data was insufficient.\";\n\tcase CRYPT_E_BAD_ENCODE:\n\t\treturn \"An error occurred during encode or decode operation.\";\n\tcase CRYPT_E_FILE_ERROR:\n\t\treturn \"An error occurred while reading or writing to a file.\";\n\tcase CRYPT_E_NOT_FOUND:\n\t\treturn \"Cannot find object or property.\";\n\tcase CRYPT_E_EXISTS:\n\t\treturn \"The object or property already exists.\";\n\tcase CRYPT_E_NO_PROVIDER:\n\t\treturn \"No provider was specified for the store or object.\";\n\tcase CRYPT_E_DELETED_PREV:\n\t\treturn \"The previous certificate or CRL context was deleted.\";\n\tcase CRYPT_E_NO_MATCH:\n\t\treturn \"Cannot find the requested object.\";\n\tcase CRYPT_E_UNEXPECTED_MSG_TYPE:\n\tcase CRYPT_E_NO_KEY_PROPERTY:\n\tcase CRYPT_E_NO_DECRYPT_CERT:\n\t\treturn \"Private key or certificate issue\";\n\tcase CRYPT_E_BAD_MSG:\n\t\treturn \"Not a cryptographic message.\";\n\tcase CRYPT_E_NO_SIGNER:\n\t\treturn \"The signed cryptographic message does not have a signer for the specified signer index.\";\n\tcase CRYPT_E_REVOKED:\n\t\treturn \"The certificate is revoked.\";\n\tcase CRYPT_E_NO_REVOCATION_DLL:\n\tcase CRYPT_E_NO_REVOCATION_CHECK:\n\tcase CRYPT_E_REVOCATION_OFFLINE:\n\tcase CRYPT_E_NOT_IN_REVOCATION_DATABASE:\n\t\treturn \"Cannot check certificate revocation.\";\n\tcase CRYPT_E_INVALID_NUMERIC_STRING:\n\tcase CRYPT_E_INVALID_PRINTABLE_STRING:\n\tcase CRYPT_E_INVALID_IA5_STRING:\n\tcase CRYPT_E_INVALID_X500_STRING:\n\tcase  CRYPT_E_NOT_CHAR_STRING:\n\t\treturn \"Invalid string.\";\n\tcase CRYPT_E_SECURITY_SETTINGS:\n\t\treturn \"The cryptographic operation failed due to a local security option setting.\";\n\tcase CRYPT_E_NO_VERIFY_USAGE_CHECK:\n\tcase CRYPT_E_VERIFY_USAGE_OFFLINE:\n\t\treturn \"Cannot complete usage check.\";\n\tcase CRYPT_E_NO_TRUSTED_SIGNER:\n\t\treturn \"None of the signers of the cryptographic message or certificate trust list is trusted.\";\n\tdefault:\n\t\tstatic_sprintf(error_string, \"Unknown PKI error 0x%08lX\", error_code);\n\t\treturn error_string;\n\t}\n}",
        "func": "const char* WinPKIErrorString(void)\n{\n\tstatic char error_string[64];\n\tDWORD error_code = GetLastError();\n\n\tif (((error_code >> 16) != 0x8009) && ((error_code >> 16) != 0x800B))\n\t\treturn WindowsErrorString();\n\n\tswitch (error_code) {\n\tcase NTE_BAD_UID:\n\t\treturn \"Bad UID.\";\n\tcase CRYPT_E_MSG_ERROR:\n\t\treturn \"An error occurred while performing an operation on a cryptographic message.\";\n\tcase CRYPT_E_UNKNOWN_ALGO:\n\t\treturn \"Unknown cryptographic algorithm.\";\n\tcase CRYPT_E_INVALID_MSG_TYPE:\n\t\treturn \"Invalid cryptographic message type.\";\n\tcase CRYPT_E_HASH_VALUE:\n\t\treturn \"The hash value is not correct\";\n\tcase CRYPT_E_ISSUER_SERIALNUMBER:\n\t\treturn \"Invalid issuer and/or serial number.\";\n\tcase CRYPT_E_BAD_LEN:\n\t\treturn \"The length specified for the output data was insufficient.\";\n\tcase CRYPT_E_BAD_ENCODE:\n\t\treturn \"An error occurred during encode or decode operation.\";\n\tcase CRYPT_E_FILE_ERROR:\n\t\treturn \"An error occurred while reading or writing to a file.\";\n\tcase CRYPT_E_NOT_FOUND:\n\t\treturn \"Cannot find object or property.\";\n\tcase CRYPT_E_EXISTS:\n\t\treturn \"The object or property already exists.\";\n\tcase CRYPT_E_NO_PROVIDER:\n\t\treturn \"No provider was specified for the store or object.\";\n\tcase CRYPT_E_DELETED_PREV:\n\t\treturn \"The previous certificate or CRL context was deleted.\";\n\tcase CRYPT_E_NO_MATCH:\n\t\treturn \"Cannot find the requested object.\";\n\tcase CRYPT_E_UNEXPECTED_MSG_TYPE:\n\tcase CRYPT_E_NO_KEY_PROPERTY:\n\tcase CRYPT_E_NO_DECRYPT_CERT:\n\t\treturn \"Private key or certificate issue\";\n\tcase CRYPT_E_BAD_MSG:\n\t\treturn \"Not a cryptographic message.\";\n\tcase CRYPT_E_NO_SIGNER:\n\t\treturn \"The signed cryptographic message does not have a signer for the specified signer index.\";\n\tcase CRYPT_E_REVOKED:\n\t\treturn \"The certificate is revoked.\";\n\tcase CRYPT_E_NO_REVOCATION_DLL:\n\tcase CRYPT_E_NO_REVOCATION_CHECK:\n\tcase CRYPT_E_REVOCATION_OFFLINE:\n\tcase CRYPT_E_NOT_IN_REVOCATION_DATABASE:\n\t\treturn \"Cannot check certificate revocation.\";\n\tcase CRYPT_E_INVALID_NUMERIC_STRING:\n\tcase CRYPT_E_INVALID_PRINTABLE_STRING:\n\tcase CRYPT_E_INVALID_IA5_STRING:\n\tcase CRYPT_E_INVALID_X500_STRING:\n\tcase  CRYPT_E_NOT_CHAR_STRING:\n\t\treturn \"Invalid string.\";\n\tcase CRYPT_E_SECURITY_SETTINGS:\n\t\treturn \"The cryptographic operation failed due to a local security option setting.\";\n\tcase CRYPT_E_NO_VERIFY_USAGE_CHECK:\n\tcase CRYPT_E_VERIFY_USAGE_OFFLINE:\n\t\treturn \"Cannot complete usage check.\";\n\tcase CRYPT_E_NO_TRUSTED_SIGNER:\n\t\treturn \"None of the signers of the cryptographic message or certificate trust list is trusted.\";\n\tcase CERT_E_UNTRUSTEDROOT:\n\t\treturn \"The root certificate is not trusted.\";\n\tcase TRUST_E_NOSIGNATURE:\n\t\treturn \"Not digitally signed.\";\n\tcase TRUST_E_EXPLICIT_DISTRUST:\n\t\treturn \"One of the certificates used was marked as untrusted by the user.\";\n\tdefault:\n\t\tstatic_sprintf(error_string, \"Unknown PKI error 0x%08lX\", error_code);\n\t\treturn error_string;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n \tstatic char error_string[64];\n \tDWORD error_code = GetLastError();\n \n-\tif ((error_code >> 16) != 0x8009)\n+\tif (((error_code >> 16) != 0x8009) && ((error_code >> 16) != 0x800B))\n \t\treturn WindowsErrorString();\n \n \tswitch (error_code) {\n@@ -63,6 +63,12 @@\n \t\treturn \"Cannot complete usage check.\";\n \tcase CRYPT_E_NO_TRUSTED_SIGNER:\n \t\treturn \"None of the signers of the cryptographic message or certificate trust list is trusted.\";\n+\tcase CERT_E_UNTRUSTEDROOT:\n+\t\treturn \"The root certificate is not trusted.\";\n+\tcase TRUST_E_NOSIGNATURE:\n+\t\treturn \"Not digitally signed.\";\n+\tcase TRUST_E_EXPLICIT_DISTRUST:\n+\t\treturn \"One of the certificates used was marked as untrusted by the user.\";\n \tdefault:\n \t\tstatic_sprintf(error_string, \"Unknown PKI error 0x%08lX\", error_code);\n \t\treturn error_string;",
        "diff_line_info": {
            "deleted_lines": [
                "\tif ((error_code >> 16) != 0x8009)"
            ],
            "added_lines": [
                "\tif (((error_code >> 16) != 0x8009) && ((error_code >> 16) != 0x800B))",
                "\tcase CERT_E_UNTRUSTEDROOT:",
                "\t\treturn \"The root certificate is not trusted.\";",
                "\tcase TRUST_E_NOSIGNATURE:",
                "\t\treturn \"Not digitally signed.\";",
                "\tcase TRUST_E_EXPLICIT_DISTRUST:",
                "\t\treturn \"One of the certificates used was marked as untrusted by the user.\";"
            ]
        }
    }
]