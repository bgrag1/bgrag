[
    {
        "cve_id": "CVE-2023-7008",
        "func_name": "systemd/dns_transaction_requires_rrsig",
        "description": "A vulnerability was found in systemd-resolved. This issue may allow systemd-resolved to accept records of DNSSEC-signed domains even when they have no signature, allowing man-in-the-middles (or the upstream DNS resolver) to manipulate records.",
        "git_url": "https://github.com/systemd/systemd/commit/f56136eb9f7e1bb0f34cd1bace60c4c02a0ed6ea",
        "commit_title": "resolved: actually check authenticated flag of SOA transaction",
        "commit_text": " Fixes #25676",
        "func_before": "static int dns_transaction_requires_rrsig(DnsTransaction *t, DnsResourceRecord *rr) {\n        int r;\n\n        assert(t);\n        assert(rr);\n\n        /* Checks if the RR we are looking for must be signed with an\n         * RRSIG. This is used for positive responses. */\n\n        if (t->scope->dnssec_mode == DNSSEC_NO)\n                return false;\n\n        if (dns_type_is_pseudo(rr->key->type))\n                return -EINVAL;\n\n        r = dns_transaction_negative_trust_anchor_lookup(t, dns_resource_key_name(rr->key));\n        if (r < 0)\n                return r;\n        if (r > 0)\n                return false;\n\n        switch (rr->key->type) {\n\n        case DNS_TYPE_RRSIG:\n                /* RRSIGs are the signatures themselves, they need no signing. */\n                return false;\n\n        case DNS_TYPE_SOA:\n        case DNS_TYPE_NS: {\n                DnsTransaction *dt;\n\n                /* For SOA or NS RRs we look for a matching DS transaction */\n\n                SET_FOREACH(dt, t->dnssec_transactions) {\n\n                        if (dns_transaction_key(dt)->class != rr->key->class)\n                                continue;\n                        if (dns_transaction_key(dt)->type != DNS_TYPE_DS)\n                                continue;\n\n                        r = dns_name_equal(dns_resource_key_name(dns_transaction_key(dt)), dns_resource_key_name(rr->key));\n                        if (r < 0)\n                                return r;\n                        if (r == 0)\n                                continue;\n\n                        /* We found a DS transactions for the SOA/NS\n                         * RRs we are looking at. If it discovered signed DS\n                         * RRs, then we need to be signed, too. */\n\n                        if (!FLAGS_SET(dt->answer_query_flags, SD_RESOLVED_AUTHENTICATED))\n                                return false;\n\n                        return dns_answer_match_key(dt->answer, dns_transaction_key(dt), NULL);\n                }\n\n                /* We found nothing that proves this is safe to leave\n                 * this unauthenticated, hence ask inist on\n                 * authentication. */\n                return true;\n        }\n\n        case DNS_TYPE_DS:\n        case DNS_TYPE_CNAME:\n        case DNS_TYPE_DNAME: {\n                const char *parent = NULL;\n                DnsTransaction *dt;\n\n                /*\n                 * CNAME/DNAME RRs cannot be located at a zone apex, hence look directly for the parent SOA.\n                 *\n                 * DS RRs are signed if the parent is signed, hence also look at the parent SOA\n                 */\n\n                SET_FOREACH(dt, t->dnssec_transactions) {\n\n                        if (dns_transaction_key(dt)->class != rr->key->class)\n                                continue;\n                        if (dns_transaction_key(dt)->type != DNS_TYPE_SOA)\n                                continue;\n\n                        if (!parent) {\n                                parent = dns_resource_key_name(rr->key);\n                                r = dns_name_parent(&parent);\n                                if (r < 0)\n                                        return r;\n                                if (r == 0) {\n                                        if (rr->key->type == DNS_TYPE_DS)\n                                                return true;\n\n                                        /* A CNAME/DNAME without a parent? That's sooo weird. */\n                                        return log_debug_errno(SYNTHETIC_ERRNO(EBADMSG),\n                                                               \"Transaction %\" PRIu16 \" claims CNAME/DNAME at root. Refusing.\", t->id);\n                                }\n                        }\n\n                        r = dns_name_equal(dns_resource_key_name(dns_transaction_key(dt)), parent);\n                        if (r < 0)\n                                return r;\n                        if (r == 0)\n                                continue;\n\n                        return FLAGS_SET(t->answer_query_flags, SD_RESOLVED_AUTHENTICATED);\n                }\n\n                return true;\n        }\n\n        default: {\n                DnsTransaction *dt;\n\n                /* Any other kind of RR (including DNSKEY/NSEC/NSEC3). Let's see if our SOA lookup was authenticated */\n\n                SET_FOREACH(dt, t->dnssec_transactions) {\n\n                        if (dns_transaction_key(dt)->class != rr->key->class)\n                                continue;\n                        if (dns_transaction_key(dt)->type != DNS_TYPE_SOA)\n                                continue;\n\n                        r = dns_name_equal(dns_resource_key_name(dns_transaction_key(dt)), dns_resource_key_name(rr->key));\n                        if (r < 0)\n                                return r;\n                        if (r == 0)\n                                continue;\n\n                        /* We found the transaction that was supposed to find the SOA RR for us. It was\n                         * successful, but found no RR for us. This means we are not at a zone cut. In this\n                         * case, we require authentication if the SOA lookup was authenticated too. */\n                        return FLAGS_SET(t->answer_query_flags, SD_RESOLVED_AUTHENTICATED);\n                }\n\n                return true;\n        }}\n}",
        "func": "static int dns_transaction_requires_rrsig(DnsTransaction *t, DnsResourceRecord *rr) {\n        int r;\n\n        assert(t);\n        assert(rr);\n\n        /* Checks if the RR we are looking for must be signed with an\n         * RRSIG. This is used for positive responses. */\n\n        if (t->scope->dnssec_mode == DNSSEC_NO)\n                return false;\n\n        if (dns_type_is_pseudo(rr->key->type))\n                return -EINVAL;\n\n        r = dns_transaction_negative_trust_anchor_lookup(t, dns_resource_key_name(rr->key));\n        if (r < 0)\n                return r;\n        if (r > 0)\n                return false;\n\n        switch (rr->key->type) {\n\n        case DNS_TYPE_RRSIG:\n                /* RRSIGs are the signatures themselves, they need no signing. */\n                return false;\n\n        case DNS_TYPE_SOA:\n        case DNS_TYPE_NS: {\n                DnsTransaction *dt;\n\n                /* For SOA or NS RRs we look for a matching DS transaction */\n\n                SET_FOREACH(dt, t->dnssec_transactions) {\n\n                        if (dns_transaction_key(dt)->class != rr->key->class)\n                                continue;\n                        if (dns_transaction_key(dt)->type != DNS_TYPE_DS)\n                                continue;\n\n                        r = dns_name_equal(dns_resource_key_name(dns_transaction_key(dt)), dns_resource_key_name(rr->key));\n                        if (r < 0)\n                                return r;\n                        if (r == 0)\n                                continue;\n\n                        /* We found a DS transactions for the SOA/NS\n                         * RRs we are looking at. If it discovered signed DS\n                         * RRs, then we need to be signed, too. */\n\n                        if (!FLAGS_SET(dt->answer_query_flags, SD_RESOLVED_AUTHENTICATED))\n                                return false;\n\n                        return dns_answer_match_key(dt->answer, dns_transaction_key(dt), NULL);\n                }\n\n                /* We found nothing that proves this is safe to leave\n                 * this unauthenticated, hence ask inist on\n                 * authentication. */\n                return true;\n        }\n\n        case DNS_TYPE_DS:\n        case DNS_TYPE_CNAME:\n        case DNS_TYPE_DNAME: {\n                const char *parent = NULL;\n                DnsTransaction *dt;\n\n                /*\n                 * CNAME/DNAME RRs cannot be located at a zone apex, hence look directly for the parent SOA.\n                 *\n                 * DS RRs are signed if the parent is signed, hence also look at the parent SOA\n                 */\n\n                SET_FOREACH(dt, t->dnssec_transactions) {\n\n                        if (dns_transaction_key(dt)->class != rr->key->class)\n                                continue;\n                        if (dns_transaction_key(dt)->type != DNS_TYPE_SOA)\n                                continue;\n\n                        if (!parent) {\n                                parent = dns_resource_key_name(rr->key);\n                                r = dns_name_parent(&parent);\n                                if (r < 0)\n                                        return r;\n                                if (r == 0) {\n                                        if (rr->key->type == DNS_TYPE_DS)\n                                                return true;\n\n                                        /* A CNAME/DNAME without a parent? That's sooo weird. */\n                                        return log_debug_errno(SYNTHETIC_ERRNO(EBADMSG),\n                                                               \"Transaction %\" PRIu16 \" claims CNAME/DNAME at root. Refusing.\", t->id);\n                                }\n                        }\n\n                        r = dns_name_equal(dns_resource_key_name(dns_transaction_key(dt)), parent);\n                        if (r < 0)\n                                return r;\n                        if (r == 0)\n                                continue;\n\n                        return FLAGS_SET(dt->answer_query_flags, SD_RESOLVED_AUTHENTICATED);\n                }\n\n                return true;\n        }\n\n        default: {\n                DnsTransaction *dt;\n\n                /* Any other kind of RR (including DNSKEY/NSEC/NSEC3). Let's see if our SOA lookup was authenticated */\n\n                SET_FOREACH(dt, t->dnssec_transactions) {\n\n                        if (dns_transaction_key(dt)->class != rr->key->class)\n                                continue;\n                        if (dns_transaction_key(dt)->type != DNS_TYPE_SOA)\n                                continue;\n\n                        r = dns_name_equal(dns_resource_key_name(dns_transaction_key(dt)), dns_resource_key_name(rr->key));\n                        if (r < 0)\n                                return r;\n                        if (r == 0)\n                                continue;\n\n                        /* We found the transaction that was supposed to find the SOA RR for us. It was\n                         * successful, but found no RR for us. This means we are not at a zone cut. In this\n                         * case, we require authentication if the SOA lookup was authenticated too. */\n                        return FLAGS_SET(dt->answer_query_flags, SD_RESOLVED_AUTHENTICATED);\n                }\n\n                return true;\n        }}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -100,7 +100,7 @@\n                         if (r == 0)\n                                 continue;\n \n-                        return FLAGS_SET(t->answer_query_flags, SD_RESOLVED_AUTHENTICATED);\n+                        return FLAGS_SET(dt->answer_query_flags, SD_RESOLVED_AUTHENTICATED);\n                 }\n \n                 return true;\n@@ -127,7 +127,7 @@\n                         /* We found the transaction that was supposed to find the SOA RR for us. It was\n                          * successful, but found no RR for us. This means we are not at a zone cut. In this\n                          * case, we require authentication if the SOA lookup was authenticated too. */\n-                        return FLAGS_SET(t->answer_query_flags, SD_RESOLVED_AUTHENTICATED);\n+                        return FLAGS_SET(dt->answer_query_flags, SD_RESOLVED_AUTHENTICATED);\n                 }\n \n                 return true;",
        "diff_line_info": {
            "deleted_lines": [
                "                        return FLAGS_SET(t->answer_query_flags, SD_RESOLVED_AUTHENTICATED);",
                "                        return FLAGS_SET(t->answer_query_flags, SD_RESOLVED_AUTHENTICATED);"
            ],
            "added_lines": [
                "                        return FLAGS_SET(dt->answer_query_flags, SD_RESOLVED_AUTHENTICATED);",
                "                        return FLAGS_SET(dt->answer_query_flags, SD_RESOLVED_AUTHENTICATED);"
            ]
        }
    }
]