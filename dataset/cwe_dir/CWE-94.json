[
    {
        "cve_id": "CVE-2018-18836",
        "func_name": "netdata/url_decode_r",
        "description": "An issue was discovered in Netdata 1.10.0. JSON injection exists via the api/v1/data tqx parameter because of web_client_api_request_v1_data in web/api/web_api_v1.c.",
        "git_url": "https://github.com/netdata/netdata/commit/92327c9ec211bd1616315abcb255861b130b97ca",
        "commit_title": "fixed vulnerabilities identified by red4sec.com (#4521)",
        "commit_text": "",
        "func_before": "char *url_decode_r(char *to, char *url, size_t size) {\n    char *s = url,           // source\n         *d = to,            // destination\n         *e = &to[size - 1]; // destination end\n\n    while(*s && d < e) {\n        if(unlikely(*s == '%')) {\n            if(likely(s[1] && s[2])) {\n                *d++ = from_hex(s[1]) << 4 | from_hex(s[2]);\n                s += 2;\n            }\n        }\n        else if(unlikely(*s == '+'))\n            *d++ = ' ';\n\n        else\n            *d++ = *s;\n\n        s++;\n    }\n\n    *d = '\\0';\n\n    return to;\n}",
        "func": "char *url_decode_r(char *to, char *url, size_t size) {\n    char *s = url,           // source\n         *d = to,            // destination\n         *e = &to[size - 1]; // destination end\n\n    while(*s && d < e) {\n        if(unlikely(*s == '%')) {\n            if(likely(s[1] && s[2])) {\n                char t = from_hex(s[1]) << 4 | from_hex(s[2]);\n                // avoid HTTP header injection\n                *d++ = (char)((isprint(t))? t : ' ');\n                s += 2;\n            }\n        }\n        else if(unlikely(*s == '+'))\n            *d++ = ' ';\n\n        else\n            *d++ = *s;\n\n        s++;\n    }\n\n    *d = '\\0';\n\n    return to;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,9 @@\n     while(*s && d < e) {\n         if(unlikely(*s == '%')) {\n             if(likely(s[1] && s[2])) {\n-                *d++ = from_hex(s[1]) << 4 | from_hex(s[2]);\n+                char t = from_hex(s[1]) << 4 | from_hex(s[2]);\n+                // avoid HTTP header injection\n+                *d++ = (char)((isprint(t))? t : ' ');\n                 s += 2;\n             }\n         }",
        "diff_line_info": {
            "deleted_lines": [
                "                *d++ = from_hex(s[1]) << 4 | from_hex(s[2]);"
            ],
            "added_lines": [
                "                char t = from_hex(s[1]) << 4 | from_hex(s[2]);",
                "                // avoid HTTP header injection",
                "                *d++ = (char)((isprint(t))? t : ' ');"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-18836",
        "func_name": "netdata/web_client_api_request_v1_data",
        "description": "An issue was discovered in Netdata 1.10.0. JSON injection exists via the api/v1/data tqx parameter because of web_client_api_request_v1_data in web/api/web_api_v1.c.",
        "git_url": "https://github.com/netdata/netdata/commit/92327c9ec211bd1616315abcb255861b130b97ca",
        "commit_title": "fixed vulnerabilities identified by red4sec.com (#4521)",
        "commit_text": "",
        "func_before": "inline int web_client_api_request_v1_data(RRDHOST *host, struct web_client *w, char *url) {\n    debug(D_WEB_CLIENT, \"%llu: API v1 data with URL '%s'\", w->id, url);\n\n    int ret = 400;\n    BUFFER *dimensions = NULL;\n\n    buffer_flush(w->response.data);\n\n    char    *google_version = \"0.6\",\n            *google_reqId = \"0\",\n            *google_sig = \"0\",\n            *google_out = \"json\",\n            *responseHandler = NULL,\n            *outFileName = NULL;\n\n    time_t last_timestamp_in_data = 0, google_timestamp = 0;\n\n    char *chart = NULL\n    , *before_str = NULL\n    , *after_str = NULL\n    , *group_time_str = NULL\n    , *points_str = NULL;\n\n    int group = RRDR_GROUPING_AVERAGE;\n    uint32_t format = DATASOURCE_JSON;\n    uint32_t options = 0x00000000;\n\n    while(url) {\n        char *value = mystrsep(&url, \"?&\");\n        if(!value || !*value) continue;\n\n        char *name = mystrsep(&value, \"=\");\n        if(!name || !*name) continue;\n        if(!value || !*value) continue;\n\n        debug(D_WEB_CLIENT, \"%llu: API v1 data query param '%s' with value '%s'\", w->id, name, value);\n\n        // name and value are now the parameters\n        // they are not null and not empty\n\n        if(!strcmp(name, \"chart\")) chart = value;\n        else if(!strcmp(name, \"dimension\") || !strcmp(name, \"dim\") || !strcmp(name, \"dimensions\") || !strcmp(name, \"dims\")) {\n            if(!dimensions) dimensions = buffer_create(100);\n            buffer_strcat(dimensions, \"|\");\n            buffer_strcat(dimensions, value);\n        }\n        else if(!strcmp(name, \"after\")) after_str = value;\n        else if(!strcmp(name, \"before\")) before_str = value;\n        else if(!strcmp(name, \"points\")) points_str = value;\n        else if(!strcmp(name, \"gtime\")) group_time_str = value;\n        else if(!strcmp(name, \"group\")) {\n            group = web_client_api_request_v1_data_group(value, RRDR_GROUPING_AVERAGE);\n        }\n        else if(!strcmp(name, \"format\")) {\n            format = web_client_api_request_v1_data_format(value);\n        }\n        else if(!strcmp(name, \"options\")) {\n            options |= web_client_api_request_v1_data_options(value);\n        }\n        else if(!strcmp(name, \"callback\")) {\n            responseHandler = value;\n        }\n        else if(!strcmp(name, \"filename\")) {\n            outFileName = value;\n        }\n        else if(!strcmp(name, \"tqx\")) {\n            // parse Google Visualization API options\n            // https://developers.google.com/chart/interactive/docs/dev/implementing_data_source\n            char *tqx_name, *tqx_value;\n\n            while(value) {\n                tqx_value = mystrsep(&value, \";\");\n                if(!tqx_value || !*tqx_value) continue;\n\n                tqx_name = mystrsep(&tqx_value, \":\");\n                if(!tqx_name || !*tqx_name) continue;\n                if(!tqx_value || !*tqx_value) continue;\n\n                if(!strcmp(tqx_name, \"version\"))\n                    google_version = tqx_value;\n                else if(!strcmp(tqx_name, \"reqId\"))\n                    google_reqId = tqx_value;\n                else if(!strcmp(tqx_name, \"sig\")) {\n                    google_sig = tqx_value;\n                    google_timestamp = strtoul(google_sig, NULL, 0);\n                }\n                else if(!strcmp(tqx_name, \"out\")) {\n                    google_out = tqx_value;\n                    format = web_client_api_request_v1_data_google_format(google_out);\n                }\n                else if(!strcmp(tqx_name, \"responseHandler\"))\n                    responseHandler = tqx_value;\n                else if(!strcmp(tqx_name, \"outFileName\"))\n                    outFileName = tqx_value;\n            }\n        }\n    }\n\n    if(!chart || !*chart) {\n        buffer_sprintf(w->response.data, \"No chart id is given at the request.\");\n        goto cleanup;\n    }\n\n    RRDSET *st = rrdset_find(host, chart);\n    if(!st) st = rrdset_find_byname(host, chart);\n    if(!st) {\n        buffer_strcat(w->response.data, \"Chart is not found: \");\n        buffer_strcat_htmlescape(w->response.data, chart);\n        ret = 404;\n        goto cleanup;\n    }\n    st->last_accessed_time = now_realtime_sec();\n\n    long long before = (before_str && *before_str)?str2l(before_str):0;\n    long long after  = (after_str  && *after_str) ?str2l(after_str):0;\n    int       points = (points_str && *points_str)?str2i(points_str):0;\n    long      group_time = (group_time_str && *group_time_str)?str2l(group_time_str):0;\n\n    debug(D_WEB_CLIENT, \"%llu: API command 'data' for chart '%s', dimensions '%s', after '%lld', before '%lld', points '%d', group '%d', format '%u', options '0x%08x'\"\n          , w->id\n          , chart\n          , (dimensions)?buffer_tostring(dimensions):\"\"\n          , after\n          , before\n          , points\n          , group\n          , format\n          , options\n    );\n\n    if(outFileName && *outFileName) {\n        buffer_sprintf(w->response.header, \"Content-Disposition: attachment; filename=\\\"%s\\\"\\r\\n\", outFileName);\n        debug(D_WEB_CLIENT, \"%llu: generating outfilename header: '%s'\", w->id, outFileName);\n    }\n\n    if(format == DATASOURCE_DATATABLE_JSONP) {\n        if(responseHandler == NULL)\n            responseHandler = \"google.visualization.Query.setResponse\";\n\n        debug(D_WEB_CLIENT_ACCESS, \"%llu: GOOGLE JSON/JSONP: version = '%s', reqId = '%s', sig = '%s', out = '%s', responseHandler = '%s', outFileName = '%s'\",\n                w->id, google_version, google_reqId, google_sig, google_out, responseHandler, outFileName\n        );\n\n        buffer_sprintf(w->response.data,\n                \"%s({version:'%s',reqId:'%s',status:'ok',sig:'%ld',table:\",\n                responseHandler, google_version, google_reqId, st->last_updated.tv_sec);\n    }\n    else if(format == DATASOURCE_JSONP) {\n        if(responseHandler == NULL)\n            responseHandler = \"callback\";\n\n        buffer_strcat(w->response.data, responseHandler);\n        buffer_strcat(w->response.data, \"(\");\n    }\n\n    ret = rrdset2anything_api_v1(st, w->response.data, dimensions, format, points, after, before, group, group_time\n                                 , options, &last_timestamp_in_data);\n\n    if(format == DATASOURCE_DATATABLE_JSONP) {\n        if(google_timestamp < last_timestamp_in_data)\n            buffer_strcat(w->response.data, \"});\");\n\n        else {\n            // the client already has the latest data\n            buffer_flush(w->response.data);\n            buffer_sprintf(w->response.data,\n                    \"%s({version:'%s',reqId:'%s',status:'error',errors:[{reason:'not_modified',message:'Data not modified'}]});\",\n                    responseHandler, google_version, google_reqId);\n        }\n    }\n    else if(format == DATASOURCE_JSONP)\n        buffer_strcat(w->response.data, \");\");\n\n    cleanup:\n    buffer_free(dimensions);\n    return ret;\n}",
        "func": "inline int web_client_api_request_v1_data(RRDHOST *host, struct web_client *w, char *url) {\n    debug(D_WEB_CLIENT, \"%llu: API v1 data with URL '%s'\", w->id, url);\n\n    int ret = 400;\n    BUFFER *dimensions = NULL;\n\n    buffer_flush(w->response.data);\n\n    char    *google_version = \"0.6\",\n            *google_reqId = \"0\",\n            *google_sig = \"0\",\n            *google_out = \"json\",\n            *responseHandler = NULL,\n            *outFileName = NULL;\n\n    time_t last_timestamp_in_data = 0, google_timestamp = 0;\n\n    char *chart = NULL\n    , *before_str = NULL\n    , *after_str = NULL\n    , *group_time_str = NULL\n    , *points_str = NULL;\n\n    int group = RRDR_GROUPING_AVERAGE;\n    uint32_t format = DATASOURCE_JSON;\n    uint32_t options = 0x00000000;\n\n    while(url) {\n        char *value = mystrsep(&url, \"?&\");\n        if(!value || !*value) continue;\n\n        char *name = mystrsep(&value, \"=\");\n        if(!name || !*name) continue;\n        if(!value || !*value) continue;\n\n        debug(D_WEB_CLIENT, \"%llu: API v1 data query param '%s' with value '%s'\", w->id, name, value);\n\n        // name and value are now the parameters\n        // they are not null and not empty\n\n        if(!strcmp(name, \"chart\")) chart = value;\n        else if(!strcmp(name, \"dimension\") || !strcmp(name, \"dim\") || !strcmp(name, \"dimensions\") || !strcmp(name, \"dims\")) {\n            if(!dimensions) dimensions = buffer_create(100);\n            buffer_strcat(dimensions, \"|\");\n            buffer_strcat(dimensions, value);\n        }\n        else if(!strcmp(name, \"after\")) after_str = value;\n        else if(!strcmp(name, \"before\")) before_str = value;\n        else if(!strcmp(name, \"points\")) points_str = value;\n        else if(!strcmp(name, \"gtime\")) group_time_str = value;\n        else if(!strcmp(name, \"group\")) {\n            group = web_client_api_request_v1_data_group(value, RRDR_GROUPING_AVERAGE);\n        }\n        else if(!strcmp(name, \"format\")) {\n            format = web_client_api_request_v1_data_format(value);\n        }\n        else if(!strcmp(name, \"options\")) {\n            options |= web_client_api_request_v1_data_options(value);\n        }\n        else if(!strcmp(name, \"callback\")) {\n            responseHandler = value;\n        }\n        else if(!strcmp(name, \"filename\")) {\n            outFileName = value;\n        }\n        else if(!strcmp(name, \"tqx\")) {\n            // parse Google Visualization API options\n            // https://developers.google.com/chart/interactive/docs/dev/implementing_data_source\n            char *tqx_name, *tqx_value;\n\n            while(value) {\n                tqx_value = mystrsep(&value, \";\");\n                if(!tqx_value || !*tqx_value) continue;\n\n                tqx_name = mystrsep(&tqx_value, \":\");\n                if(!tqx_name || !*tqx_name) continue;\n                if(!tqx_value || !*tqx_value) continue;\n\n                if(!strcmp(tqx_name, \"version\"))\n                    google_version = tqx_value;\n                else if(!strcmp(tqx_name, \"reqId\"))\n                    google_reqId = tqx_value;\n                else if(!strcmp(tqx_name, \"sig\")) {\n                    google_sig = tqx_value;\n                    google_timestamp = strtoul(google_sig, NULL, 0);\n                }\n                else if(!strcmp(tqx_name, \"out\")) {\n                    google_out = tqx_value;\n                    format = web_client_api_request_v1_data_google_format(google_out);\n                }\n                else if(!strcmp(tqx_name, \"responseHandler\"))\n                    responseHandler = tqx_value;\n                else if(!strcmp(tqx_name, \"outFileName\"))\n                    outFileName = tqx_value;\n            }\n        }\n    }\n\n    // validate the google parameters given\n    fix_google_param(google_out);\n    fix_google_param(google_sig);\n    fix_google_param(google_reqId);\n    fix_google_param(google_version);\n    fix_google_param(responseHandler);\n    fix_google_param(outFileName);\n\n    if(!chart || !*chart) {\n        buffer_sprintf(w->response.data, \"No chart id is given at the request.\");\n        goto cleanup;\n    }\n\n    RRDSET *st = rrdset_find(host, chart);\n    if(!st) st = rrdset_find_byname(host, chart);\n    if(!st) {\n        buffer_strcat(w->response.data, \"Chart is not found: \");\n        buffer_strcat_htmlescape(w->response.data, chart);\n        ret = 404;\n        goto cleanup;\n    }\n    st->last_accessed_time = now_realtime_sec();\n\n    long long before = (before_str && *before_str)?str2l(before_str):0;\n    long long after  = (after_str  && *after_str) ?str2l(after_str):0;\n    int       points = (points_str && *points_str)?str2i(points_str):0;\n    long      group_time = (group_time_str && *group_time_str)?str2l(group_time_str):0;\n\n    debug(D_WEB_CLIENT, \"%llu: API command 'data' for chart '%s', dimensions '%s', after '%lld', before '%lld', points '%d', group '%d', format '%u', options '0x%08x'\"\n          , w->id\n          , chart\n          , (dimensions)?buffer_tostring(dimensions):\"\"\n          , after\n          , before\n          , points\n          , group\n          , format\n          , options\n    );\n\n    if(outFileName && *outFileName) {\n        buffer_sprintf(w->response.header, \"Content-Disposition: attachment; filename=\\\"%s\\\"\\r\\n\", outFileName);\n        debug(D_WEB_CLIENT, \"%llu: generating outfilename header: '%s'\", w->id, outFileName);\n    }\n\n    if(format == DATASOURCE_DATATABLE_JSONP) {\n        if(responseHandler == NULL)\n            responseHandler = \"google.visualization.Query.setResponse\";\n\n        debug(D_WEB_CLIENT_ACCESS, \"%llu: GOOGLE JSON/JSONP: version = '%s', reqId = '%s', sig = '%s', out = '%s', responseHandler = '%s', outFileName = '%s'\",\n                w->id, google_version, google_reqId, google_sig, google_out, responseHandler, outFileName\n        );\n\n        buffer_sprintf(w->response.data,\n                \"%s({version:'%s',reqId:'%s',status:'ok',sig:'%ld',table:\",\n                responseHandler, google_version, google_reqId, st->last_updated.tv_sec);\n    }\n    else if(format == DATASOURCE_JSONP) {\n        if(responseHandler == NULL)\n            responseHandler = \"callback\";\n\n        buffer_strcat(w->response.data, responseHandler);\n        buffer_strcat(w->response.data, \"(\");\n    }\n\n    ret = rrdset2anything_api_v1(st, w->response.data, dimensions, format, points, after, before, group, group_time\n                                 , options, &last_timestamp_in_data);\n\n    if(format == DATASOURCE_DATATABLE_JSONP) {\n        if(google_timestamp < last_timestamp_in_data)\n            buffer_strcat(w->response.data, \"});\");\n\n        else {\n            // the client already has the latest data\n            buffer_flush(w->response.data);\n            buffer_sprintf(w->response.data,\n                    \"%s({version:'%s',reqId:'%s',status:'error',errors:[{reason:'not_modified',message:'Data not modified'}]});\",\n                    responseHandler, google_version, google_reqId);\n        }\n    }\n    else if(format == DATASOURCE_JSONP)\n        buffer_strcat(w->response.data, \");\");\n\n    cleanup:\n    buffer_free(dimensions);\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -96,6 +96,14 @@\n         }\n     }\n \n+    // validate the google parameters given\n+    fix_google_param(google_out);\n+    fix_google_param(google_sig);\n+    fix_google_param(google_reqId);\n+    fix_google_param(google_version);\n+    fix_google_param(responseHandler);\n+    fix_google_param(outFileName);\n+\n     if(!chart || !*chart) {\n         buffer_sprintf(w->response.data, \"No chart id is given at the request.\");\n         goto cleanup;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    // validate the google parameters given",
                "    fix_google_param(google_out);",
                "    fix_google_param(google_sig);",
                "    fix_google_param(google_reqId);",
                "    fix_google_param(google_version);",
                "    fix_google_param(responseHandler);",
                "    fix_google_param(outFileName);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2014-4043",
        "func_name": "glibc/posix_spawn_file_actions_addopen",
        "description": "The posix_spawn_file_actions_addopen function in glibc before 2.20 does not copy its path argument in accordance with the POSIX specification, which allows context-dependent attackers to trigger use-after-free vulnerabilities.",
        "git_url": "https://sourceware.org/git/gitweb.cgi?p=glibc.git;h=89e435f3559c53084498e9baad22172b64429362",
        "commit_title": "",
        "commit_text": "posix_spawn_file_actions_addopen needs to copy the path argument (BZ 17048)  POSIX requires that we make a copy, so we allocate a new string and free it in posix_spawn_file_actions_destroy.  Reported by David Reid, Alex Gaynor, and Glyph Lefkowitz.  This bug may have security implications. ",
        "func_before": "int\nposix_spawn_file_actions_addopen (posix_spawn_file_actions_t *file_actions,\n\t\t\t\t  int fd, const char *path, int oflag,\n\t\t\t\t  mode_t mode)\n{\n  int maxfd = __sysconf (_SC_OPEN_MAX);\n  struct __spawn_action *rec;\n\n  /* Test for the validity of the file descriptor.  */\n  if (fd < 0 || fd >= maxfd)\n    return EBADF;\n\n  /* Allocate more memory if needed.  */\n  if (file_actions->__used == file_actions->__allocated\n      && __posix_spawn_file_actions_realloc (file_actions) != 0)\n    /* This can only mean we ran out of memory.  */\n    return ENOMEM;\n\n  /* Add the new value.  */\n  rec = &file_actions->__actions[file_actions->__used];\n  rec->tag = spawn_do_open;\n  rec->action.open_action.fd = fd;\n  rec->action.open_action.path = path;\n  rec->action.open_action.oflag = oflag;\n  rec->action.open_action.mode = mode;\n\n  /* Account for the new entry.  */\n  ++file_actions->__used;\n\n  return 0;\n}",
        "func": "int\nposix_spawn_file_actions_addopen (posix_spawn_file_actions_t *file_actions,\n\t\t\t\t  int fd, const char *path, int oflag,\n\t\t\t\t  mode_t mode)\n{\n  int maxfd = __sysconf (_SC_OPEN_MAX);\n  struct __spawn_action *rec;\n\n  /* Test for the validity of the file descriptor.  */\n  if (fd < 0 || fd >= maxfd)\n    return EBADF;\n\n  char *path_copy = strdup (path);\n  if (path_copy == NULL)\n    return ENOMEM;\n\n  /* Allocate more memory if needed.  */\n  if (file_actions->__used == file_actions->__allocated\n      && __posix_spawn_file_actions_realloc (file_actions) != 0)\n    {\n      /* This can only mean we ran out of memory.  */\n      free (path_copy);\n      return ENOMEM;\n    }\n\n  /* Add the new value.  */\n  rec = &file_actions->__actions[file_actions->__used];\n  rec->tag = spawn_do_open;\n  rec->action.open_action.fd = fd;\n  rec->action.open_action.path = path_copy;\n  rec->action.open_action.oflag = oflag;\n  rec->action.open_action.mode = mode;\n\n  /* Account for the new entry.  */\n  ++file_actions->__used;\n\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,17 +10,24 @@\n   if (fd < 0 || fd >= maxfd)\n     return EBADF;\n \n+  char *path_copy = strdup (path);\n+  if (path_copy == NULL)\n+    return ENOMEM;\n+\n   /* Allocate more memory if needed.  */\n   if (file_actions->__used == file_actions->__allocated\n       && __posix_spawn_file_actions_realloc (file_actions) != 0)\n-    /* This can only mean we ran out of memory.  */\n-    return ENOMEM;\n+    {\n+      /* This can only mean we ran out of memory.  */\n+      free (path_copy);\n+      return ENOMEM;\n+    }\n \n   /* Add the new value.  */\n   rec = &file_actions->__actions[file_actions->__used];\n   rec->tag = spawn_do_open;\n   rec->action.open_action.fd = fd;\n-  rec->action.open_action.path = path;\n+  rec->action.open_action.path = path_copy;\n   rec->action.open_action.oflag = oflag;\n   rec->action.open_action.mode = mode;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    /* This can only mean we ran out of memory.  */",
                "    return ENOMEM;",
                "  rec->action.open_action.path = path;"
            ],
            "added_lines": [
                "  char *path_copy = strdup (path);",
                "  if (path_copy == NULL)",
                "    return ENOMEM;",
                "",
                "    {",
                "      /* This can only mean we ran out of memory.  */",
                "      free (path_copy);",
                "      return ENOMEM;",
                "    }",
                "  rec->action.open_action.path = path_copy;"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-4043",
        "func_name": "glibc/posix_spawn_file_actions_destroy",
        "description": "The posix_spawn_file_actions_addopen function in glibc before 2.20 does not copy its path argument in accordance with the POSIX specification, which allows context-dependent attackers to trigger use-after-free vulnerabilities.",
        "git_url": "https://sourceware.org/git/gitweb.cgi?p=glibc.git;h=89e435f3559c53084498e9baad22172b64429362",
        "commit_title": "",
        "commit_text": "posix_spawn_file_actions_addopen needs to copy the path argument (BZ 17048)  POSIX requires that we make a copy, so we allocate a new string and free it in posix_spawn_file_actions_destroy.  Reported by David Reid, Alex Gaynor, and Glyph Lefkowitz.  This bug may have security implications. ",
        "func_before": "int\nposix_spawn_file_actions_destroy (posix_spawn_file_actions_t *file_actions)\n{\n  /* Free the memory allocated.  */\n  free (file_actions->__actions);\n  return 0;\n}",
        "func": "int\nposix_spawn_file_actions_destroy (posix_spawn_file_actions_t *file_actions)\n{\n  /* Free the paths in the open actions.  */\n  for (int i = 0; i < file_actions->__used; ++i)\n    {\n      struct __spawn_action *sa = &file_actions->__actions[i];\n      switch (sa->tag)\n\t{\n\tcase spawn_do_open:\n\t  free (sa->action.open_action.path);\n\t  break;\n\tcase spawn_do_close:\n\tcase spawn_do_dup2:\n\t  /* No cleanup required.  */\n\t  break;\n\t}\n    }\n\n  /* Free the array of actions.  */\n  free (file_actions->__actions);\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,23 @@\n int\n posix_spawn_file_actions_destroy (posix_spawn_file_actions_t *file_actions)\n {\n-  /* Free the memory allocated.  */\n+  /* Free the paths in the open actions.  */\n+  for (int i = 0; i < file_actions->__used; ++i)\n+    {\n+      struct __spawn_action *sa = &file_actions->__actions[i];\n+      switch (sa->tag)\n+\t{\n+\tcase spawn_do_open:\n+\t  free (sa->action.open_action.path);\n+\t  break;\n+\tcase spawn_do_close:\n+\tcase spawn_do_dup2:\n+\t  /* No cleanup required.  */\n+\t  break;\n+\t}\n+    }\n+\n+  /* Free the array of actions.  */\n   free (file_actions->__actions);\n   return 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  /* Free the memory allocated.  */"
            ],
            "added_lines": [
                "  /* Free the paths in the open actions.  */",
                "  for (int i = 0; i < file_actions->__used; ++i)",
                "    {",
                "      struct __spawn_action *sa = &file_actions->__actions[i];",
                "      switch (sa->tag)",
                "\t{",
                "\tcase spawn_do_open:",
                "\t  free (sa->action.open_action.path);",
                "\t  break;",
                "\tcase spawn_do_close:",
                "\tcase spawn_do_dup2:",
                "\t  /* No cleanup required.  */",
                "\t  break;",
                "\t}",
                "    }",
                "",
                "  /* Free the array of actions.  */"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-3379",
        "func_name": "php/php-src/is_a_impl",
        "description": "The is_a function in PHP 5.3.7 and 5.3.8 triggers a call to the __autoload function, which makes it easier for remote attackers to execute arbitrary code by providing a crafted URL and leveraging potentially unsafe behavior in certain PEAR packages and custom autoloaders.",
        "git_url": "https://github.com/php/php-src/commit/10f20585fcbd524016e439c17bf01a0fd5191107",
        "commit_title": "fix bug #55475 - implement is_a BC solution",
        "commit_text": "",
        "func_before": "static void is_a_impl(INTERNAL_FUNCTION_PARAMETERS, zend_bool only_subclass)\n{\n\tzval *obj;\n\tchar *class_name;\n\tint class_name_len;\n\tzend_class_entry *instance_ce;\n\tzend_class_entry **ce;\n\tzend_bool retval;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"zs\", &obj, &class_name, &class_name_len) == FAILURE) {\n\t\treturn;\n\t}\n\t\n\tif (Z_TYPE_P(obj) == IS_STRING) {\n\t\tzend_class_entry **the_ce;\n\t\tif (zend_lookup_class(Z_STRVAL_P(obj), Z_STRLEN_P(obj), &the_ce TSRMLS_CC) == FAILURE) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tinstance_ce = *the_ce;\n\t} else if (Z_TYPE_P(obj) == IS_OBJECT && HAS_CLASS_ENTRY(*obj)) {\n\t\tinstance_ce = Z_OBJCE_P(obj);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zend_lookup_class_ex(class_name, class_name_len, NULL, 0, &ce TSRMLS_CC) == FAILURE) {\n\t\tretval = 0;\n\t} else {\n\t\tif (only_subclass && instance_ce == *ce) {\n\t\t\tretval = 0;\n \t\t} else {\n\t\t\tretval = instanceof_function(instance_ce, *ce TSRMLS_CC);\n\t\t}\n\t}\n\n\tRETURN_BOOL(retval);\n}",
        "func": "static void is_a_impl(INTERNAL_FUNCTION_PARAMETERS, zend_bool only_subclass)\n{\n\tzval *obj;\n\tchar *class_name;\n\tint class_name_len;\n\tzend_class_entry *instance_ce;\n\tzend_class_entry **ce;\n\tzend_bool allow_string = only_subclass;\n\tzend_bool retval;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"zs|b\", &obj, &class_name, &class_name_len, &allow_string) == FAILURE) {\n\t\treturn;\n\t}\n\t/*\n\t * allow_string - is_a default is no, is_subclass_of is yes. \n\t *   if it's allowed, then the autoloader will be called if the class does not exist.\n\t *   default behaviour is different, as 'is_a' used to be used to test mixed return values\n\t *   and there is no easy way to deprecate this.\n\t */\n\n\tif (allow_string && Z_TYPE_P(obj) == IS_STRING) {\n\t\tzend_class_entry **the_ce;\n\t\tif (zend_lookup_class(Z_STRVAL_P(obj), Z_STRLEN_P(obj), &the_ce TSRMLS_CC) == FAILURE) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tinstance_ce = *the_ce;\n\t} else if (Z_TYPE_P(obj) == IS_OBJECT && HAS_CLASS_ENTRY(*obj)) {\n\t\tinstance_ce = Z_OBJCE_P(obj);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (zend_lookup_class_ex(class_name, class_name_len, NULL, 0, &ce TSRMLS_CC) == FAILURE) {\n\t\tretval = 0;\n\t} else {\n\t\tif (only_subclass && instance_ce == *ce) {\n\t\t\tretval = 0;\n \t\t} else {\n\t\t\tretval = instanceof_function(instance_ce, *ce TSRMLS_CC);\n\t\t}\n\t}\n\n\tRETURN_BOOL(retval);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,13 +5,20 @@\n \tint class_name_len;\n \tzend_class_entry *instance_ce;\n \tzend_class_entry **ce;\n+\tzend_bool allow_string = only_subclass;\n \tzend_bool retval;\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"zs\", &obj, &class_name, &class_name_len) == FAILURE) {\n+\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"zs|b\", &obj, &class_name, &class_name_len, &allow_string) == FAILURE) {\n \t\treturn;\n \t}\n-\t\n-\tif (Z_TYPE_P(obj) == IS_STRING) {\n+\t/*\n+\t * allow_string - is_a default is no, is_subclass_of is yes. \n+\t *   if it's allowed, then the autoloader will be called if the class does not exist.\n+\t *   default behaviour is different, as 'is_a' used to be used to test mixed return values\n+\t *   and there is no easy way to deprecate this.\n+\t */\n+\n+\tif (allow_string && Z_TYPE_P(obj) == IS_STRING) {\n \t\tzend_class_entry **the_ce;\n \t\tif (zend_lookup_class(Z_STRVAL_P(obj), Z_STRLEN_P(obj), &the_ce TSRMLS_CC) == FAILURE) {\n \t\t\tRETURN_FALSE;",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"zs\", &obj, &class_name, &class_name_len) == FAILURE) {",
                "\t",
                "\tif (Z_TYPE_P(obj) == IS_STRING) {"
            ],
            "added_lines": [
                "\tzend_bool allow_string = only_subclass;",
                "\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"zs|b\", &obj, &class_name, &class_name_len, &allow_string) == FAILURE) {",
                "\t/*",
                "\t * allow_string - is_a default is no, is_subclass_of is yes. ",
                "\t *   if it's allowed, then the autoloader will be called if the class does not exist.",
                "\t *   default behaviour is different, as 'is_a' used to be used to test mixed return values",
                "\t *   and there is no easy way to deprecate this.",
                "\t */",
                "",
                "\tif (allow_string && Z_TYPE_P(obj) == IS_STRING) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5149",
        "func_name": "chromium/ScriptContextSet::GetExtensionFromFrameAndWorld",
        "description": "The extensions subsystem in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux relies on an IFRAME source URL to identify an associated extension, which allows remote attackers to conduct extension-bindings injection attacks by leveraging script access to a resource that initially has the about:blank URL.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/79b64c3e741cc9c6afbb23885945831a45c6baa5",
        "commit_title": "Fix extension bindings injection for iframes (reland)",
        "commit_text": " For iframes, we don't want to use the source url for determining the associated extension because it starts out with an about:blank context that is scriptable by its parent.  This originally landed in codereview.chromium.org/2151693002/ but was reverted because of bug 630928 as well as the test failing under DrMemory (not with memory errors; just not succeeding which likely indicates some kind of race condition in the test). I've added a fix for bug 630928 but haven't been able to locally reproduce the test failure under DrMemory, so I've added some extra logging to the test to hopefully better understand what might be going wrong.  Memory sheriffs: If the FramesExtensionBindingsApiTest.FramesBeforeNavigation test fails again without any actual memory errors, please do not revert the entire CL (since it is an important security fix); instead just disable the test or add it to a suppression file so I can iterate on a fix.   Review-Url: https://codereview.chromium.org/2208483002 ",
        "func_before": "const Extension* ScriptContextSet::GetExtensionFromFrameAndWorld(\n    const blink::WebLocalFrame* frame,\n    int world_id,\n    bool use_effective_url) {\n  std::string extension_id;\n  if (world_id != 0) {\n    // Isolated worlds (content script).\n    extension_id = ScriptInjection::GetHostIdForIsolatedWorld(world_id);\n  } else {\n    // Extension pages (chrome-extension:// URLs).\n    GURL frame_url = ScriptContext::GetDataSourceURLForFrame(frame);\n    frame_url = ScriptContext::GetEffectiveDocumentURL(frame, frame_url,\n                                                       use_effective_url);\n    extension_id =\n        RendererExtensionRegistry::Get()->GetExtensionOrAppIDByURL(frame_url);\n  }\n\n  // There are conditions where despite a context being associated with an\n  // extension, no extension actually gets found. Ignore \"invalid\" because CSP\n  // blocks extension page loading by switching the extension ID to \"invalid\".\n  const Extension* extension =\n      RendererExtensionRegistry::Get()->GetByID(extension_id);\n  if (!extension && !extension_id.empty() && extension_id != \"invalid\") {\n    // TODO(kalman): Do something here?\n  }\n  return extension;\n}",
        "func": "const Extension* ScriptContextSet::GetExtensionFromFrameAndWorld(\n    const blink::WebLocalFrame* frame,\n    int world_id,\n    bool use_effective_url) {\n  std::string extension_id;\n  if (world_id != 0) {\n    // Isolated worlds (content script).\n    extension_id = ScriptInjection::GetHostIdForIsolatedWorld(world_id);\n  } else {\n    // For looking up the extension associated with this frame, we either want\n    // to use the current url or possibly the data source url (which this frame\n    // may be navigating to shortly), depending on the security origin of the\n    // frame. We don't always want to use the data source url because some\n    // frames (eg iframes and windows created via window.open) briefly contain\n    // an about:blank script context that is scriptable by their parent/opener\n    // before they finish navigating.\n    GURL frame_url = ScriptContext::GetAccessCheckedFrameURL(frame);\n    frame_url = ScriptContext::GetEffectiveDocumentURL(frame, frame_url,\n                                                       use_effective_url);\n    extension_id =\n        RendererExtensionRegistry::Get()->GetExtensionOrAppIDByURL(frame_url);\n  }\n\n  // There are conditions where despite a context being associated with an\n  // extension, no extension actually gets found. Ignore \"invalid\" because CSP\n  // blocks extension page loading by switching the extension ID to \"invalid\".\n  const Extension* extension =\n      RendererExtensionRegistry::Get()->GetByID(extension_id);\n  if (!extension && !extension_id.empty() && extension_id != \"invalid\") {\n    // TODO(kalman): Do something here?\n  }\n  return extension;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,8 +7,14 @@\n     // Isolated worlds (content script).\n     extension_id = ScriptInjection::GetHostIdForIsolatedWorld(world_id);\n   } else {\n-    // Extension pages (chrome-extension:// URLs).\n-    GURL frame_url = ScriptContext::GetDataSourceURLForFrame(frame);\n+    // For looking up the extension associated with this frame, we either want\n+    // to use the current url or possibly the data source url (which this frame\n+    // may be navigating to shortly), depending on the security origin of the\n+    // frame. We don't always want to use the data source url because some\n+    // frames (eg iframes and windows created via window.open) briefly contain\n+    // an about:blank script context that is scriptable by their parent/opener\n+    // before they finish navigating.\n+    GURL frame_url = ScriptContext::GetAccessCheckedFrameURL(frame);\n     frame_url = ScriptContext::GetEffectiveDocumentURL(frame, frame_url,\n                                                        use_effective_url);\n     extension_id =",
        "diff_line_info": {
            "deleted_lines": [
                "    // Extension pages (chrome-extension:// URLs).",
                "    GURL frame_url = ScriptContext::GetDataSourceURLForFrame(frame);"
            ],
            "added_lines": [
                "    // For looking up the extension associated with this frame, we either want",
                "    // to use the current url or possibly the data source url (which this frame",
                "    // may be navigating to shortly), depending on the security origin of the",
                "    // frame. We don't always want to use the data source url because some",
                "    // frames (eg iframes and windows created via window.open) briefly contain",
                "    // an about:blank script context that is scriptable by their parent/opener",
                "    // before they finish navigating.",
                "    GURL frame_url = ScriptContext::GetAccessCheckedFrameURL(frame);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5149",
        "func_name": "chromium/ScriptContext::ScriptContext",
        "description": "The extensions subsystem in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux relies on an IFRAME source URL to identify an associated extension, which allows remote attackers to conduct extension-bindings injection attacks by leveraging script access to a resource that initially has the about:blank URL.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/79b64c3e741cc9c6afbb23885945831a45c6baa5",
        "commit_title": "Fix extension bindings injection for iframes (reland)",
        "commit_text": " For iframes, we don't want to use the source url for determining the associated extension because it starts out with an about:blank context that is scriptable by its parent.  This originally landed in codereview.chromium.org/2151693002/ but was reverted because of bug 630928 as well as the test failing under DrMemory (not with memory errors; just not succeeding which likely indicates some kind of race condition in the test). I've added a fix for bug 630928 but haven't been able to locally reproduce the test failure under DrMemory, so I've added some extra logging to the test to hopefully better understand what might be going wrong.  Memory sheriffs: If the FramesExtensionBindingsApiTest.FramesBeforeNavigation test fails again without any actual memory errors, please do not revert the entire CL (since it is an important security fix); instead just disable the test or add it to a suppression file so I can iterate on a fix.   Review-Url: https://codereview.chromium.org/2208483002 ",
        "func_before": "ScriptContext::ScriptContext(const v8::Local<v8::Context>& v8_context,\n                             blink::WebLocalFrame* web_frame,\n                             const Extension* extension,\n                             Feature::Context context_type,\n                             const Extension* effective_extension,\n                             Feature::Context effective_context_type)\n    : is_valid_(true),\n      v8_context_(v8_context->GetIsolate(), v8_context),\n      web_frame_(web_frame),\n      extension_(extension),\n      context_type_(context_type),\n      effective_extension_(effective_extension),\n      effective_context_type_(effective_context_type),\n      safe_builtins_(this),\n      isolate_(v8_context->GetIsolate()),\n      url_(web_frame_ ? GetDataSourceURLForFrame(web_frame_) : GURL()),\n      runner_(new Runner(this)) {\n  VLOG(1) << \"Created context:\\n\" << GetDebugString();\n  gin::PerContextData* gin_data = gin::PerContextData::From(v8_context);\n  CHECK(gin_data);\n  gin_data->set_runner(runner_.get());\n}",
        "func": "ScriptContext::ScriptContext(const v8::Local<v8::Context>& v8_context,\n                             blink::WebLocalFrame* web_frame,\n                             const Extension* extension,\n                             Feature::Context context_type,\n                             const Extension* effective_extension,\n                             Feature::Context effective_context_type)\n    : is_valid_(true),\n      v8_context_(v8_context->GetIsolate(), v8_context),\n      web_frame_(web_frame),\n      extension_(extension),\n      context_type_(context_type),\n      effective_extension_(effective_extension),\n      effective_context_type_(effective_context_type),\n      safe_builtins_(this),\n      isolate_(v8_context->GetIsolate()),\n      runner_(new Runner(this)) {\n  VLOG(1) << \"Created context:\\n\" << GetDebugString();\n  gin::PerContextData* gin_data = gin::PerContextData::From(v8_context);\n  CHECK(gin_data);\n  gin_data->set_runner(runner_.get());\n  if (web_frame_)\n    url_ = GetAccessCheckedFrameURL(web_frame_);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,10 +13,11 @@\n       effective_context_type_(effective_context_type),\n       safe_builtins_(this),\n       isolate_(v8_context->GetIsolate()),\n-      url_(web_frame_ ? GetDataSourceURLForFrame(web_frame_) : GURL()),\n       runner_(new Runner(this)) {\n   VLOG(1) << \"Created context:\\n\" << GetDebugString();\n   gin::PerContextData* gin_data = gin::PerContextData::From(v8_context);\n   CHECK(gin_data);\n   gin_data->set_runner(runner_.get());\n+  if (web_frame_)\n+    url_ = GetAccessCheckedFrameURL(web_frame_);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "      url_(web_frame_ ? GetDataSourceURLForFrame(web_frame_) : GURL()),"
            ],
            "added_lines": [
                "  if (web_frame_)",
                "    url_ = GetAccessCheckedFrameURL(web_frame_);"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-4151",
        "func_name": "qemu/virtio_load",
        "description": "The virtio_load function in virtio/virtio.c in QEMU 1.x before 1.7.2 allows remote attackers to execute arbitrary code via a crafted savevm image, which triggers an out-of-bounds write.",
        "git_url": "https://github.com/qemu/qemu/commit/cc45995294b92d95319b4782750a3580cabdbc0c",
        "commit_title": "virtio: out-of-bounds buffer write on invalid state load",
        "commit_text": " CVE-2013-4151 QEMU 1.0 out-of-bounds buffer write in virtio_load@hw/virtio/virtio.c  So we have this code since way back when:      num = qemu_get_be32(f);      for (i = 0; i < num; i++) {         vdev->vq[i].vring.num = qemu_get_be32(f);  array of vqs has size VIRTIO_PCI_QUEUE_MAX, so on invalid input this will write beyond end of buffer. ",
        "func_before": "int virtio_load(VirtIODevice *vdev, QEMUFile *f)\n{\n    int num, i, ret;\n    uint32_t features;\n    uint32_t supported_features;\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    if (k->load_config) {\n        ret = k->load_config(qbus->parent, f);\n        if (ret)\n            return ret;\n    }\n\n    qemu_get_8s(f, &vdev->status);\n    qemu_get_8s(f, &vdev->isr);\n    qemu_get_be16s(f, &vdev->queue_sel);\n    qemu_get_be32s(f, &features);\n\n    if (virtio_set_features(vdev, features) < 0) {\n        supported_features = k->get_features(qbus->parent);\n        error_report(\"Features 0x%x unsupported. Allowed features: 0x%x\",\n                     features, supported_features);\n        return -1;\n    }\n    vdev->config_len = qemu_get_be32(f);\n    qemu_get_buffer(f, vdev->config, vdev->config_len);\n\n    num = qemu_get_be32(f);\n\n    for (i = 0; i < num; i++) {\n        vdev->vq[i].vring.num = qemu_get_be32(f);\n        if (k->has_variable_vring_alignment) {\n            vdev->vq[i].vring.align = qemu_get_be32(f);\n        }\n        vdev->vq[i].pa = qemu_get_be64(f);\n        qemu_get_be16s(f, &vdev->vq[i].last_avail_idx);\n        vdev->vq[i].signalled_used_valid = false;\n        vdev->vq[i].notification = true;\n\n        if (vdev->vq[i].pa) {\n            uint16_t nheads;\n            virtqueue_init(&vdev->vq[i]);\n            nheads = vring_avail_idx(&vdev->vq[i]) - vdev->vq[i].last_avail_idx;\n            /* Check it isn't doing very strange things with descriptor numbers. */\n            if (nheads > vdev->vq[i].vring.num) {\n                error_report(\"VQ %d size 0x%x Guest index 0x%x \"\n                             \"inconsistent with Host index 0x%x: delta 0x%x\",\n                             i, vdev->vq[i].vring.num,\n                             vring_avail_idx(&vdev->vq[i]),\n                             vdev->vq[i].last_avail_idx, nheads);\n                return -1;\n            }\n        } else if (vdev->vq[i].last_avail_idx) {\n            error_report(\"VQ %d address 0x0 \"\n                         \"inconsistent with Host index 0x%x\",\n                         i, vdev->vq[i].last_avail_idx);\n                return -1;\n\t}\n        if (k->load_queue) {\n            ret = k->load_queue(qbus->parent, i, f);\n            if (ret)\n                return ret;\n        }\n    }\n\n    virtio_notify_vector(vdev, VIRTIO_NO_VECTOR);\n    return 0;\n}",
        "func": "int virtio_load(VirtIODevice *vdev, QEMUFile *f)\n{\n    int i, ret;\n    uint32_t num;\n    uint32_t features;\n    uint32_t supported_features;\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    if (k->load_config) {\n        ret = k->load_config(qbus->parent, f);\n        if (ret)\n            return ret;\n    }\n\n    qemu_get_8s(f, &vdev->status);\n    qemu_get_8s(f, &vdev->isr);\n    qemu_get_be16s(f, &vdev->queue_sel);\n    qemu_get_be32s(f, &features);\n\n    if (virtio_set_features(vdev, features) < 0) {\n        supported_features = k->get_features(qbus->parent);\n        error_report(\"Features 0x%x unsupported. Allowed features: 0x%x\",\n                     features, supported_features);\n        return -1;\n    }\n    vdev->config_len = qemu_get_be32(f);\n    qemu_get_buffer(f, vdev->config, vdev->config_len);\n\n    num = qemu_get_be32(f);\n\n    if (num > VIRTIO_PCI_QUEUE_MAX) {\n        error_report(\"Invalid number of PCI queues: 0x%x\", num);\n        return -1;\n    }\n\n    for (i = 0; i < num; i++) {\n        vdev->vq[i].vring.num = qemu_get_be32(f);\n        if (k->has_variable_vring_alignment) {\n            vdev->vq[i].vring.align = qemu_get_be32(f);\n        }\n        vdev->vq[i].pa = qemu_get_be64(f);\n        qemu_get_be16s(f, &vdev->vq[i].last_avail_idx);\n        vdev->vq[i].signalled_used_valid = false;\n        vdev->vq[i].notification = true;\n\n        if (vdev->vq[i].pa) {\n            uint16_t nheads;\n            virtqueue_init(&vdev->vq[i]);\n            nheads = vring_avail_idx(&vdev->vq[i]) - vdev->vq[i].last_avail_idx;\n            /* Check it isn't doing very strange things with descriptor numbers. */\n            if (nheads > vdev->vq[i].vring.num) {\n                error_report(\"VQ %d size 0x%x Guest index 0x%x \"\n                             \"inconsistent with Host index 0x%x: delta 0x%x\",\n                             i, vdev->vq[i].vring.num,\n                             vring_avail_idx(&vdev->vq[i]),\n                             vdev->vq[i].last_avail_idx, nheads);\n                return -1;\n            }\n        } else if (vdev->vq[i].last_avail_idx) {\n            error_report(\"VQ %d address 0x0 \"\n                         \"inconsistent with Host index 0x%x\",\n                         i, vdev->vq[i].last_avail_idx);\n                return -1;\n\t}\n        if (k->load_queue) {\n            ret = k->load_queue(qbus->parent, i, f);\n            if (ret)\n                return ret;\n        }\n    }\n\n    virtio_notify_vector(vdev, VIRTIO_NO_VECTOR);\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,7 @@\n int virtio_load(VirtIODevice *vdev, QEMUFile *f)\n {\n-    int num, i, ret;\n+    int i, ret;\n+    uint32_t num;\n     uint32_t features;\n     uint32_t supported_features;\n     BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n@@ -27,6 +28,11 @@\n     qemu_get_buffer(f, vdev->config, vdev->config_len);\n \n     num = qemu_get_be32(f);\n+\n+    if (num > VIRTIO_PCI_QUEUE_MAX) {\n+        error_report(\"Invalid number of PCI queues: 0x%x\", num);\n+        return -1;\n+    }\n \n     for (i = 0; i < num; i++) {\n         vdev->vq[i].vring.num = qemu_get_be32(f);",
        "diff_line_info": {
            "deleted_lines": [
                "    int num, i, ret;"
            ],
            "added_lines": [
                "    int i, ret;",
                "    uint32_t num;",
                "",
                "    if (num > VIRTIO_PCI_QUEUE_MAX) {",
                "        error_report(\"Invalid number of PCI queues: 0x%x\", num);",
                "        return -1;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-4537",
        "func_name": "qemu/ssi_sd_load",
        "description": "The ssi_sd_transfer function in hw/sd/ssi-sd.c in QEMU before 1.7.2 allows remote attackers to execute arbitrary code via a crafted arglen value in a savevm image.",
        "git_url": "https://github.com/qemu/qemu/commit/a9c380db3b8c6af19546a68145c8d1438a09c92b",
        "commit_title": "ssi-sd: fix buffer overrun on invalid state load",
        "commit_text": " CVE-2013-4537  s->arglen is taken from wire and used as idx in ssi_sd_transfer().  Validate it before access. ",
        "func_before": "static int ssi_sd_load(QEMUFile *f, void *opaque, int version_id)\n{\n    SSISlave *ss = SSI_SLAVE(opaque);\n    ssi_sd_state *s = (ssi_sd_state *)opaque;\n    int i;\n\n    if (version_id != 1)\n        return -EINVAL;\n\n    s->mode = qemu_get_be32(f);\n    s->cmd = qemu_get_be32(f);\n    for (i = 0; i < 4; i++)\n        s->cmdarg[i] = qemu_get_be32(f);\n    for (i = 0; i < 5; i++)\n        s->response[i] = qemu_get_be32(f);\n    s->arglen = qemu_get_be32(f);\n    s->response_pos = qemu_get_be32(f);\n    s->stopping = qemu_get_be32(f);\n\n    ss->cs = qemu_get_be32(f);\n\n    return 0;\n}",
        "func": "static int ssi_sd_load(QEMUFile *f, void *opaque, int version_id)\n{\n    SSISlave *ss = SSI_SLAVE(opaque);\n    ssi_sd_state *s = (ssi_sd_state *)opaque;\n    int i;\n\n    if (version_id != 1)\n        return -EINVAL;\n\n    s->mode = qemu_get_be32(f);\n    s->cmd = qemu_get_be32(f);\n    for (i = 0; i < 4; i++)\n        s->cmdarg[i] = qemu_get_be32(f);\n    for (i = 0; i < 5; i++)\n        s->response[i] = qemu_get_be32(f);\n    s->arglen = qemu_get_be32(f);\n    if (s->mode == SSI_SD_CMDARG &&\n        (s->arglen < 0 || s->arglen >= ARRAY_SIZE(s->cmdarg))) {\n        return -EINVAL;\n    }\n    s->response_pos = qemu_get_be32(f);\n    s->stopping = qemu_get_be32(f);\n    if (s->mode == SSI_SD_RESPONSE &&\n        (s->response_pos < 0 || s->response_pos >= ARRAY_SIZE(s->response) ||\n        (!s->stopping && s->arglen > ARRAY_SIZE(s->response)))) {\n        return -EINVAL;\n    }\n\n    ss->cs = qemu_get_be32(f);\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,8 +14,17 @@\n     for (i = 0; i < 5; i++)\n         s->response[i] = qemu_get_be32(f);\n     s->arglen = qemu_get_be32(f);\n+    if (s->mode == SSI_SD_CMDARG &&\n+        (s->arglen < 0 || s->arglen >= ARRAY_SIZE(s->cmdarg))) {\n+        return -EINVAL;\n+    }\n     s->response_pos = qemu_get_be32(f);\n     s->stopping = qemu_get_be32(f);\n+    if (s->mode == SSI_SD_RESPONSE &&\n+        (s->response_pos < 0 || s->response_pos >= ARRAY_SIZE(s->response) ||\n+        (!s->stopping && s->arglen > ARRAY_SIZE(s->response)))) {\n+        return -EINVAL;\n+    }\n \n     ss->cs = qemu_get_be32(f);\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (s->mode == SSI_SD_CMDARG &&",
                "        (s->arglen < 0 || s->arglen >= ARRAY_SIZE(s->cmdarg))) {",
                "        return -EINVAL;",
                "    }",
                "    if (s->mode == SSI_SD_RESPONSE &&",
                "        (s->response_pos < 0 || s->response_pos >= ARRAY_SIZE(s->response) ||",
                "        (!s->stopping && s->arglen > ARRAY_SIZE(s->response)))) {",
                "        return -EINVAL;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-6399",
        "func_name": "qemu/virtio_load",
        "description": "Array index error in the virtio_load function in hw/virtio/virtio.c in QEMU before 1.7.2 allows remote attackers to execute arbitrary code via a crafted savevm image.",
        "git_url": "https://github.com/qemu/qemu/commit/4b53c2c72cb5541cf394033b528a6fe2a86c0ac1",
        "commit_title": "virtio: avoid buffer overrun on incoming migration",
        "commit_text": " CVE-2013-6399  vdev->queue_sel is read from the wire, and later used in the emulation code as an index into vdev->vq[]. If the value of vdev->queue_sel exceeds the length of vdev->vq[], currently allocated to be VIRTIO_PCI_QUEUE_MAX elements, subsequent PIO operations such as VIRTIO_PCI_QUEUE_PFN can be used to overrun the buffer with arbitrary data originating from the source.  Fix this by failing migration if the value from the wire exceeds VIRTIO_PCI_QUEUE_MAX. ",
        "func_before": "int virtio_load(VirtIODevice *vdev, QEMUFile *f)\n{\n    int i, ret;\n    uint32_t num;\n    uint32_t features;\n    uint32_t supported_features;\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    if (k->load_config) {\n        ret = k->load_config(qbus->parent, f);\n        if (ret)\n            return ret;\n    }\n\n    qemu_get_8s(f, &vdev->status);\n    qemu_get_8s(f, &vdev->isr);\n    qemu_get_be16s(f, &vdev->queue_sel);\n    qemu_get_be32s(f, &features);\n\n    if (virtio_set_features(vdev, features) < 0) {\n        supported_features = k->get_features(qbus->parent);\n        error_report(\"Features 0x%x unsupported. Allowed features: 0x%x\",\n                     features, supported_features);\n        return -1;\n    }\n    vdev->config_len = qemu_get_be32(f);\n    qemu_get_buffer(f, vdev->config, vdev->config_len);\n\n    num = qemu_get_be32(f);\n\n    if (num > VIRTIO_PCI_QUEUE_MAX) {\n        error_report(\"Invalid number of PCI queues: 0x%x\", num);\n        return -1;\n    }\n\n    for (i = 0; i < num; i++) {\n        vdev->vq[i].vring.num = qemu_get_be32(f);\n        if (k->has_variable_vring_alignment) {\n            vdev->vq[i].vring.align = qemu_get_be32(f);\n        }\n        vdev->vq[i].pa = qemu_get_be64(f);\n        qemu_get_be16s(f, &vdev->vq[i].last_avail_idx);\n        vdev->vq[i].signalled_used_valid = false;\n        vdev->vq[i].notification = true;\n\n        if (vdev->vq[i].pa) {\n            uint16_t nheads;\n            virtqueue_init(&vdev->vq[i]);\n            nheads = vring_avail_idx(&vdev->vq[i]) - vdev->vq[i].last_avail_idx;\n            /* Check it isn't doing very strange things with descriptor numbers. */\n            if (nheads > vdev->vq[i].vring.num) {\n                error_report(\"VQ %d size 0x%x Guest index 0x%x \"\n                             \"inconsistent with Host index 0x%x: delta 0x%x\",\n                             i, vdev->vq[i].vring.num,\n                             vring_avail_idx(&vdev->vq[i]),\n                             vdev->vq[i].last_avail_idx, nheads);\n                return -1;\n            }\n        } else if (vdev->vq[i].last_avail_idx) {\n            error_report(\"VQ %d address 0x0 \"\n                         \"inconsistent with Host index 0x%x\",\n                         i, vdev->vq[i].last_avail_idx);\n                return -1;\n\t}\n        if (k->load_queue) {\n            ret = k->load_queue(qbus->parent, i, f);\n            if (ret)\n                return ret;\n        }\n    }\n\n    virtio_notify_vector(vdev, VIRTIO_NO_VECTOR);\n    return 0;\n}",
        "func": "int virtio_load(VirtIODevice *vdev, QEMUFile *f)\n{\n    int i, ret;\n    uint32_t num;\n    uint32_t features;\n    uint32_t supported_features;\n    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    if (k->load_config) {\n        ret = k->load_config(qbus->parent, f);\n        if (ret)\n            return ret;\n    }\n\n    qemu_get_8s(f, &vdev->status);\n    qemu_get_8s(f, &vdev->isr);\n    qemu_get_be16s(f, &vdev->queue_sel);\n    if (vdev->queue_sel >= VIRTIO_PCI_QUEUE_MAX) {\n        return -1;\n    }\n    qemu_get_be32s(f, &features);\n\n    if (virtio_set_features(vdev, features) < 0) {\n        supported_features = k->get_features(qbus->parent);\n        error_report(\"Features 0x%x unsupported. Allowed features: 0x%x\",\n                     features, supported_features);\n        return -1;\n    }\n    vdev->config_len = qemu_get_be32(f);\n    qemu_get_buffer(f, vdev->config, vdev->config_len);\n\n    num = qemu_get_be32(f);\n\n    if (num > VIRTIO_PCI_QUEUE_MAX) {\n        error_report(\"Invalid number of PCI queues: 0x%x\", num);\n        return -1;\n    }\n\n    for (i = 0; i < num; i++) {\n        vdev->vq[i].vring.num = qemu_get_be32(f);\n        if (k->has_variable_vring_alignment) {\n            vdev->vq[i].vring.align = qemu_get_be32(f);\n        }\n        vdev->vq[i].pa = qemu_get_be64(f);\n        qemu_get_be16s(f, &vdev->vq[i].last_avail_idx);\n        vdev->vq[i].signalled_used_valid = false;\n        vdev->vq[i].notification = true;\n\n        if (vdev->vq[i].pa) {\n            uint16_t nheads;\n            virtqueue_init(&vdev->vq[i]);\n            nheads = vring_avail_idx(&vdev->vq[i]) - vdev->vq[i].last_avail_idx;\n            /* Check it isn't doing very strange things with descriptor numbers. */\n            if (nheads > vdev->vq[i].vring.num) {\n                error_report(\"VQ %d size 0x%x Guest index 0x%x \"\n                             \"inconsistent with Host index 0x%x: delta 0x%x\",\n                             i, vdev->vq[i].vring.num,\n                             vring_avail_idx(&vdev->vq[i]),\n                             vdev->vq[i].last_avail_idx, nheads);\n                return -1;\n            }\n        } else if (vdev->vq[i].last_avail_idx) {\n            error_report(\"VQ %d address 0x0 \"\n                         \"inconsistent with Host index 0x%x\",\n                         i, vdev->vq[i].last_avail_idx);\n                return -1;\n\t}\n        if (k->load_queue) {\n            ret = k->load_queue(qbus->parent, i, f);\n            if (ret)\n                return ret;\n        }\n    }\n\n    virtio_notify_vector(vdev, VIRTIO_NO_VECTOR);\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,6 +16,9 @@\n     qemu_get_8s(f, &vdev->status);\n     qemu_get_8s(f, &vdev->isr);\n     qemu_get_be16s(f, &vdev->queue_sel);\n+    if (vdev->queue_sel >= VIRTIO_PCI_QUEUE_MAX) {\n+        return -1;\n+    }\n     qemu_get_be32s(f, &features);\n \n     if (virtio_set_features(vdev, features) < 0) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (vdev->queue_sel >= VIRTIO_PCI_QUEUE_MAX) {",
                "        return -1;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-8485",
        "func_name": "binutils-gdb/setup_group",
        "description": "The setup_group function in bfd/elf.c in libbfd in GNU binutils 2.24 and earlier allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via crafted section group headers in an ELF file.",
        "git_url": "https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;a=commit;h=493a33860c71cac998f1a56d6d87d6faa801fbaa",
        "commit_title": "",
        "commit_text": "This patch closes a potential security hole in applications that use the bfd library to parse binaries containing maliciously corrupt section group headers.  \tPR binutils/17510 \t* elf.c (setup_group): Improve handling of corrupt group \tsections. ",
        "func_before": "static bfd_boolean\nsetup_group (bfd *abfd, Elf_Internal_Shdr *hdr, asection *newsect)\n{\n  unsigned int num_group = elf_tdata (abfd)->num_group;\n\n  /* If num_group is zero, read in all SHT_GROUP sections.  The count\n     is set to -1 if there are no SHT_GROUP sections.  */\n  if (num_group == 0)\n    {\n      unsigned int i, shnum;\n\n      /* First count the number of groups.  If we have a SHT_GROUP\n\t section with just a flag word (ie. sh_size is 4), ignore it.  */\n      shnum = elf_numsections (abfd);\n      num_group = 0;\n\n#define IS_VALID_GROUP_SECTION_HEADER(shdr, minsize)\t\\\n\t(   (shdr)->sh_type == SHT_GROUP\t\t\\\n\t && (shdr)->sh_size >= minsize\t\t\t\\\n\t && (shdr)->sh_entsize == GRP_ENTRY_SIZE\t\\\n\t && ((shdr)->sh_size % GRP_ENTRY_SIZE) == 0)\n\n      for (i = 0; i < shnum; i++)\n\t{\n\t  Elf_Internal_Shdr *shdr = elf_elfsections (abfd)[i];\n\n\t  if (IS_VALID_GROUP_SECTION_HEADER (shdr, 2 * GRP_ENTRY_SIZE))\n\t    num_group += 1;\n\t}\n\n      if (num_group == 0)\n\t{\n\t  num_group = (unsigned) -1;\n\t  elf_tdata (abfd)->num_group = num_group;\n\t}\n      else\n\t{\n\t  /* We keep a list of elf section headers for group sections,\n\t     so we can find them quickly.  */\n\t  bfd_size_type amt;\n\n\t  elf_tdata (abfd)->num_group = num_group;\n\t  elf_tdata (abfd)->group_sect_ptr = (Elf_Internal_Shdr **)\n              bfd_alloc2 (abfd, num_group, sizeof (Elf_Internal_Shdr *));\n\t  if (elf_tdata (abfd)->group_sect_ptr == NULL)\n\t    return FALSE;\n\n\t  num_group = 0;\n\t  for (i = 0; i < shnum; i++)\n\t    {\n\t      Elf_Internal_Shdr *shdr = elf_elfsections (abfd)[i];\n\n\t      if (IS_VALID_GROUP_SECTION_HEADER (shdr, 2 * GRP_ENTRY_SIZE))\n\t\t{\n\t\t  unsigned char *src;\n\t\t  Elf_Internal_Group *dest;\n\n\t\t  /* Add to list of sections.  */\n\t\t  elf_tdata (abfd)->group_sect_ptr[num_group] = shdr;\n\t\t  num_group += 1;\n\n\t\t  /* Read the raw contents.  */\n\t\t  BFD_ASSERT (sizeof (*dest) >= 4);\n\t\t  amt = shdr->sh_size * sizeof (*dest) / 4;\n\t\t  shdr->contents = (unsigned char *)\n                      bfd_alloc2 (abfd, shdr->sh_size, sizeof (*dest) / 4);\n\t\t  /* PR binutils/4110: Handle corrupt group headers.  */\n\t\t  if (shdr->contents == NULL)\n\t\t    {\n\t\t      _bfd_error_handler\n\t\t\t(_(\"%B: Corrupt size field in group section header: 0x%lx\"), abfd, shdr->sh_size);\n\t\t      bfd_set_error (bfd_error_bad_value);\n\t\t      return FALSE;\n\t\t    }\n\n\t\t  memset (shdr->contents, 0, amt);\n\n\t\t  if (bfd_seek (abfd, shdr->sh_offset, SEEK_SET) != 0\n\t\t      || (bfd_bread (shdr->contents, shdr->sh_size, abfd)\n\t\t\t  != shdr->sh_size))\n\t\t    return FALSE;\n\n\t\t  /* Translate raw contents, a flag word followed by an\n\t\t     array of elf section indices all in target byte order,\n\t\t     to the flag word followed by an array of elf section\n\t\t     pointers.  */\n\t\t  src = shdr->contents + shdr->sh_size;\n\t\t  dest = (Elf_Internal_Group *) (shdr->contents + amt);\n\t\t  while (1)\n\t\t    {\n\t\t      unsigned int idx;\n\n\t\t      src -= 4;\n\t\t      --dest;\n\t\t      idx = H_GET_32 (abfd, src);\n\t\t      if (src == shdr->contents)\n\t\t\t{\n\t\t\t  dest->flags = idx;\n\t\t\t  if (shdr->bfd_section != NULL && (idx & GRP_COMDAT))\n\t\t\t    shdr->bfd_section->flags\n\t\t\t      |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;\n\t\t\t  break;\n\t\t\t}\n\t\t      if (idx >= shnum)\n\t\t\t{\n\t\t\t  ((*_bfd_error_handler)\n\t\t\t   (_(\"%B: invalid SHT_GROUP entry\"), abfd));\n\t\t\t  idx = 0;\n\t\t\t}\n\t\t      dest->shdr = elf_elfsections (abfd)[idx];\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n  if (num_group != (unsigned) -1)\n    {\n      unsigned int i;\n\n      for (i = 0; i < num_group; i++)\n\t{\n\t  Elf_Internal_Shdr *shdr = elf_tdata (abfd)->group_sect_ptr[i];\n\t  Elf_Internal_Group *idx = (Elf_Internal_Group *) shdr->contents;\n\t  unsigned int n_elt = shdr->sh_size / 4;\n\n\t  /* Look through this group's sections to see if current\n\t     section is a member.  */\n\t  while (--n_elt != 0)\n\t    if ((++idx)->shdr == hdr)\n\t      {\n\t\tasection *s = NULL;\n\n\t\t/* We are a member of this group.  Go looking through\n\t\t   other members to see if any others are linked via\n\t\t   next_in_group.  */\n\t\tidx = (Elf_Internal_Group *) shdr->contents;\n\t\tn_elt = shdr->sh_size / 4;\n\t\twhile (--n_elt != 0)\n\t\t  if ((s = (++idx)->shdr->bfd_section) != NULL\n\t\t      && elf_next_in_group (s) != NULL)\n\t\t    break;\n\t\tif (n_elt != 0)\n\t\t  {\n\t\t    /* Snarf the group name from other member, and\n\t\t       insert current section in circular list.  */\n\t\t    elf_group_name (newsect) = elf_group_name (s);\n\t\t    elf_next_in_group (newsect) = elf_next_in_group (s);\n\t\t    elf_next_in_group (s) = newsect;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    const char *gname;\n\n\t\t    gname = group_signature (abfd, shdr);\n\t\t    if (gname == NULL)\n\t\t      return FALSE;\n\t\t    elf_group_name (newsect) = gname;\n\n\t\t    /* Start a circular list with one element.  */\n\t\t    elf_next_in_group (newsect) = newsect;\n\t\t  }\n\n\t\t/* If the group section has been created, point to the\n\t\t   new member.  */\n\t\tif (shdr->bfd_section != NULL)\n\t\t  elf_next_in_group (shdr->bfd_section) = newsect;\n\n\t\ti = num_group - 1;\n\t\tbreak;\n\t      }\n\t}\n    }\n\n  if (elf_group_name (newsect) == NULL)\n    {\n      (*_bfd_error_handler) (_(\"%B: no group info for section %A\"),\n\t\t\t     abfd, newsect);\n    }\n  return TRUE;\n}",
        "func": "static bfd_boolean\nsetup_group (bfd *abfd, Elf_Internal_Shdr *hdr, asection *newsect)\n{\n  unsigned int num_group = elf_tdata (abfd)->num_group;\n\n  /* If num_group is zero, read in all SHT_GROUP sections.  The count\n     is set to -1 if there are no SHT_GROUP sections.  */\n  if (num_group == 0)\n    {\n      unsigned int i, shnum;\n\n      /* First count the number of groups.  If we have a SHT_GROUP\n\t section with just a flag word (ie. sh_size is 4), ignore it.  */\n      shnum = elf_numsections (abfd);\n      num_group = 0;\n\n#define IS_VALID_GROUP_SECTION_HEADER(shdr, minsize)\t\\\n\t(   (shdr)->sh_type == SHT_GROUP\t\t\\\n\t && (shdr)->sh_size >= minsize\t\t\t\\\n\t && (shdr)->sh_entsize == GRP_ENTRY_SIZE\t\\\n\t && ((shdr)->sh_size % GRP_ENTRY_SIZE) == 0)\n\n      for (i = 0; i < shnum; i++)\n\t{\n\t  Elf_Internal_Shdr *shdr = elf_elfsections (abfd)[i];\n\n\t  if (IS_VALID_GROUP_SECTION_HEADER (shdr, 2 * GRP_ENTRY_SIZE))\n\t    num_group += 1;\n\t}\n\n      if (num_group == 0)\n\t{\n\t  num_group = (unsigned) -1;\n\t  elf_tdata (abfd)->num_group = num_group;\n\t}\n      else\n\t{\n\t  /* We keep a list of elf section headers for group sections,\n\t     so we can find them quickly.  */\n\t  bfd_size_type amt;\n\n\t  elf_tdata (abfd)->num_group = num_group;\n\t  elf_tdata (abfd)->group_sect_ptr = (Elf_Internal_Shdr **)\n              bfd_alloc2 (abfd, num_group, sizeof (Elf_Internal_Shdr *));\n\t  if (elf_tdata (abfd)->group_sect_ptr == NULL)\n\t    return FALSE;\n\n\t  num_group = 0;\n\t  for (i = 0; i < shnum; i++)\n\t    {\n\t      Elf_Internal_Shdr *shdr = elf_elfsections (abfd)[i];\n\n\t      if (IS_VALID_GROUP_SECTION_HEADER (shdr, 2 * GRP_ENTRY_SIZE))\n\t\t{\n\t\t  unsigned char *src;\n\t\t  Elf_Internal_Group *dest;\n\n\t\t  /* Add to list of sections.  */\n\t\t  elf_tdata (abfd)->group_sect_ptr[num_group] = shdr;\n\t\t  num_group += 1;\n\n\t\t  /* Read the raw contents.  */\n\t\t  BFD_ASSERT (sizeof (*dest) >= 4);\n\t\t  amt = shdr->sh_size * sizeof (*dest) / 4;\n\t\t  shdr->contents = (unsigned char *)\n                      bfd_alloc2 (abfd, shdr->sh_size, sizeof (*dest) / 4);\n\t\t  /* PR binutils/4110: Handle corrupt group headers.  */\n\t\t  if (shdr->contents == NULL)\n\t\t    {\n\t\t      _bfd_error_handler\n\t\t\t(_(\"%B: corrupt size field in group section header: 0x%lx\"), abfd, shdr->sh_size);\n\t\t      bfd_set_error (bfd_error_bad_value);\n\t\t      -- num_group;\n\t\t      continue;\n\t\t    }\n\n\t\t  memset (shdr->contents, 0, amt);\n\n\t\t  if (bfd_seek (abfd, shdr->sh_offset, SEEK_SET) != 0\n\t\t      || (bfd_bread (shdr->contents, shdr->sh_size, abfd)\n\t\t\t  != shdr->sh_size))\n\t\t    {\n\t\t      _bfd_error_handler\n\t\t\t(_(\"%B: invalid size field in group section header: 0x%lx\"), abfd, shdr->sh_size);\n\t\t      bfd_set_error (bfd_error_bad_value);\n\t\t      -- num_group;\n\t\t      /* PR 17510: If the group contents are even partially\n\t\t\t corrupt, do not allow any of the contents to be used.  */\n\t\t      memset (shdr->contents, 0, amt);\n\t\t      continue;\n\t\t    }\n\t\t  \n\t\t  /* Translate raw contents, a flag word followed by an\n\t\t     array of elf section indices all in target byte order,\n\t\t     to the flag word followed by an array of elf section\n\t\t     pointers.  */\n\t\t  src = shdr->contents + shdr->sh_size;\n\t\t  dest = (Elf_Internal_Group *) (shdr->contents + amt);\n\t\t  while (1)\n\t\t    {\n\t\t      unsigned int idx;\n\n\t\t      src -= 4;\n\t\t      --dest;\n\t\t      idx = H_GET_32 (abfd, src);\n\t\t      if (src == shdr->contents)\n\t\t\t{\n\t\t\t  dest->flags = idx;\n\t\t\t  if (shdr->bfd_section != NULL && (idx & GRP_COMDAT))\n\t\t\t    shdr->bfd_section->flags\n\t\t\t      |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;\n\t\t\t  break;\n\t\t\t}\n\t\t      if (idx >= shnum)\n\t\t\t{\n\t\t\t  ((*_bfd_error_handler)\n\t\t\t   (_(\"%B: invalid SHT_GROUP entry\"), abfd));\n\t\t\t  idx = 0;\n\t\t\t}\n\t\t      dest->shdr = elf_elfsections (abfd)[idx];\n\t\t    }\n\t\t}\n\t    }\n\n\t  /* PR 17510: Corrupt binaries might contain invalid groups.  */\n\t  if (num_group != (unsigned) elf_tdata (abfd)->num_group)\n\t    {\n\t      elf_tdata (abfd)->num_group = num_group;\n\n\t      /* If all groups are invalid then fail.  */\n\t      if (num_group == 0)\n\t\t{\n\t\t  elf_tdata (abfd)->group_sect_ptr = NULL;\n\t\t  elf_tdata (abfd)->num_group = num_group = -1;\n\t\t  (*_bfd_error_handler) (_(\"%B: no valid group sections found\"), abfd);\n\t\t  bfd_set_error (bfd_error_bad_value);\n\t\t}\n\t    }\n\t}\n    }\n\n  if (num_group != (unsigned) -1)\n    {\n      unsigned int i;\n\n      for (i = 0; i < num_group; i++)\n\t{\n\t  Elf_Internal_Shdr *shdr = elf_tdata (abfd)->group_sect_ptr[i];\n\t  Elf_Internal_Group *idx = (Elf_Internal_Group *) shdr->contents;\n\t  unsigned int n_elt = shdr->sh_size / 4;\n\n\t  /* Look through this group's sections to see if current\n\t     section is a member.  */\n\t  while (--n_elt != 0)\n\t    if ((++idx)->shdr == hdr)\n\t      {\n\t\tasection *s = NULL;\n\n\t\t/* We are a member of this group.  Go looking through\n\t\t   other members to see if any others are linked via\n\t\t   next_in_group.  */\n\t\tidx = (Elf_Internal_Group *) shdr->contents;\n\t\tn_elt = shdr->sh_size / 4;\n\t\twhile (--n_elt != 0)\n\t\t  if ((s = (++idx)->shdr->bfd_section) != NULL\n\t\t      && elf_next_in_group (s) != NULL)\n\t\t    break;\n\t\tif (n_elt != 0)\n\t\t  {\n\t\t    /* Snarf the group name from other member, and\n\t\t       insert current section in circular list.  */\n\t\t    elf_group_name (newsect) = elf_group_name (s);\n\t\t    elf_next_in_group (newsect) = elf_next_in_group (s);\n\t\t    elf_next_in_group (s) = newsect;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    const char *gname;\n\n\t\t    gname = group_signature (abfd, shdr);\n\t\t    if (gname == NULL)\n\t\t      return FALSE;\n\t\t    elf_group_name (newsect) = gname;\n\n\t\t    /* Start a circular list with one element.  */\n\t\t    elf_next_in_group (newsect) = newsect;\n\t\t  }\n\n\t\t/* If the group section has been created, point to the\n\t\t   new member.  */\n\t\tif (shdr->bfd_section != NULL)\n\t\t  elf_next_in_group (shdr->bfd_section) = newsect;\n\n\t\ti = num_group - 1;\n\t\tbreak;\n\t      }\n\t}\n    }\n\n  if (elf_group_name (newsect) == NULL)\n    {\n      (*_bfd_error_handler) (_(\"%B: no group info for section %A\"),\n\t\t\t     abfd, newsect);\n      return FALSE;\n    }\n  return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -68,9 +68,10 @@\n \t\t  if (shdr->contents == NULL)\n \t\t    {\n \t\t      _bfd_error_handler\n-\t\t\t(_(\"%B: Corrupt size field in group section header: 0x%lx\"), abfd, shdr->sh_size);\n+\t\t\t(_(\"%B: corrupt size field in group section header: 0x%lx\"), abfd, shdr->sh_size);\n \t\t      bfd_set_error (bfd_error_bad_value);\n-\t\t      return FALSE;\n+\t\t      -- num_group;\n+\t\t      continue;\n \t\t    }\n \n \t\t  memset (shdr->contents, 0, amt);\n@@ -78,8 +79,17 @@\n \t\t  if (bfd_seek (abfd, shdr->sh_offset, SEEK_SET) != 0\n \t\t      || (bfd_bread (shdr->contents, shdr->sh_size, abfd)\n \t\t\t  != shdr->sh_size))\n-\t\t    return FALSE;\n-\n+\t\t    {\n+\t\t      _bfd_error_handler\n+\t\t\t(_(\"%B: invalid size field in group section header: 0x%lx\"), abfd, shdr->sh_size);\n+\t\t      bfd_set_error (bfd_error_bad_value);\n+\t\t      -- num_group;\n+\t\t      /* PR 17510: If the group contents are even partially\n+\t\t\t corrupt, do not allow any of the contents to be used.  */\n+\t\t      memset (shdr->contents, 0, amt);\n+\t\t      continue;\n+\t\t    }\n+\t\t  \n \t\t  /* Translate raw contents, a flag word followed by an\n \t\t     array of elf section indices all in target byte order,\n \t\t     to the flag word followed by an array of elf section\n@@ -111,6 +121,21 @@\n \t\t    }\n \t\t}\n \t    }\n+\n+\t  /* PR 17510: Corrupt binaries might contain invalid groups.  */\n+\t  if (num_group != (unsigned) elf_tdata (abfd)->num_group)\n+\t    {\n+\t      elf_tdata (abfd)->num_group = num_group;\n+\n+\t      /* If all groups are invalid then fail.  */\n+\t      if (num_group == 0)\n+\t\t{\n+\t\t  elf_tdata (abfd)->group_sect_ptr = NULL;\n+\t\t  elf_tdata (abfd)->num_group = num_group = -1;\n+\t\t  (*_bfd_error_handler) (_(\"%B: no valid group sections found\"), abfd);\n+\t\t  bfd_set_error (bfd_error_bad_value);\n+\t\t}\n+\t    }\n \t}\n     }\n \n@@ -176,6 +201,7 @@\n     {\n       (*_bfd_error_handler) (_(\"%B: no group info for section %A\"),\n \t\t\t     abfd, newsect);\n+      return FALSE;\n     }\n   return TRUE;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t(_(\"%B: Corrupt size field in group section header: 0x%lx\"), abfd, shdr->sh_size);",
                "\t\t      return FALSE;",
                "\t\t    return FALSE;",
                ""
            ],
            "added_lines": [
                "\t\t\t(_(\"%B: corrupt size field in group section header: 0x%lx\"), abfd, shdr->sh_size);",
                "\t\t      -- num_group;",
                "\t\t      continue;",
                "\t\t    {",
                "\t\t      _bfd_error_handler",
                "\t\t\t(_(\"%B: invalid size field in group section header: 0x%lx\"), abfd, shdr->sh_size);",
                "\t\t      bfd_set_error (bfd_error_bad_value);",
                "\t\t      -- num_group;",
                "\t\t      /* PR 17510: If the group contents are even partially",
                "\t\t\t corrupt, do not allow any of the contents to be used.  */",
                "\t\t      memset (shdr->contents, 0, amt);",
                "\t\t      continue;",
                "\t\t    }",
                "\t\t  ",
                "",
                "\t  /* PR 17510: Corrupt binaries might contain invalid groups.  */",
                "\t  if (num_group != (unsigned) elf_tdata (abfd)->num_group)",
                "\t    {",
                "\t      elf_tdata (abfd)->num_group = num_group;",
                "",
                "\t      /* If all groups are invalid then fail.  */",
                "\t      if (num_group == 0)",
                "\t\t{",
                "\t\t  elf_tdata (abfd)->group_sect_ptr = NULL;",
                "\t\t  elf_tdata (abfd)->num_group = num_group = -1;",
                "\t\t  (*_bfd_error_handler) (_(\"%B: no valid group sections found\"), abfd);",
                "\t\t  bfd_set_error (bfd_error_bad_value);",
                "\t\t}",
                "\t    }",
                "      return FALSE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-2240",
        "func_name": "torvalds/linux/do_anonymous_page",
        "description": "The do_anonymous_page function in mm/memory.c in the Linux kernel before 2.6.27.52, 2.6.32.x before 2.6.32.19, 2.6.34.x before 2.6.34.4, and 2.6.35.x before 2.6.35.2 does not properly separate the stack and the heap, which allows context-dependent attackers to execute arbitrary code by writing to the bottom page of a shared memory segment, as demonstrated by a memory-exhaustion attack against the X.Org X server.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=320b2b8de12698082609ebbc1a17165727f4c893",
        "commit_title": "This is a rather minimally invasive patch to solve the problem of the",
        "commit_text": "user stack growing into a memory mapped area below it.  Whenever we fill the first page of the stack segment, expand the segment down by one page.  Now, admittedly some odd application might _want_ the stack to grow down into the preceding memory mapping, and so we may at some point need to make this a process tunable (some people might also want to have more than a single page of guarding), but let's try the minimal approach first.  Tested with trivial application that maps a single page just below the stack, and then starts recursing.  Without this, we will get a SIGSEGV _after_ the stack has smashed the mapping.  With this patch, we'll get a nice SIGBUS just as the stack touches the page just above the mapping.  Requested-by: Keith Packard <keithp@keithp.com> ",
        "func_before": "static int do_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tunsigned int flags)\n{\n\tstruct page *page;\n\tspinlock_t *ptl;\n\tpte_t entry;\n\n\tif (!(flags & FAULT_FLAG_WRITE)) {\n\t\tentry = pte_mkspecial(pfn_pte(my_zero_pfn(address),\n\t\t\t\t\t\tvma->vm_page_prot));\n\t\tptl = pte_lockptr(mm, pmd);\n\t\tspin_lock(ptl);\n\t\tif (!pte_none(*page_table))\n\t\t\tgoto unlock;\n\t\tgoto setpte;\n\t}\n\n\t/* Allocate our own private page. */\n\tpte_unmap(page_table);\n\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\tgoto oom;\n\tpage = alloc_zeroed_user_highpage_movable(vma, address);\n\tif (!page)\n\t\tgoto oom;\n\t__SetPageUptodate(page);\n\n\tif (mem_cgroup_newpage_charge(page, mm, GFP_KERNEL))\n\t\tgoto oom_free_page;\n\n\tentry = mk_pte(page, vma->vm_page_prot);\n\tif (vma->vm_flags & VM_WRITE)\n\t\tentry = pte_mkwrite(pte_mkdirty(entry));\n\n\tpage_table = pte_offset_map_lock(mm, pmd, address, &ptl);\n\tif (!pte_none(*page_table))\n\t\tgoto release;\n\n\tinc_mm_counter_fast(mm, MM_ANONPAGES);\n\tpage_add_new_anon_rmap(page, vma, address);\nsetpte:\n\tset_pte_at(mm, address, page_table, entry);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(vma, address, page_table);\nunlock:\n\tpte_unmap_unlock(page_table, ptl);\n\treturn 0;\nrelease:\n\tmem_cgroup_uncharge_page(page);\n\tpage_cache_release(page);\n\tgoto unlock;\noom_free_page:\n\tpage_cache_release(page);\noom:\n\treturn VM_FAULT_OOM;\n}",
        "func": "static int do_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tunsigned int flags)\n{\n\tstruct page *page;\n\tspinlock_t *ptl;\n\tpte_t entry;\n\n\tif (check_stack_guard_page(vma, address) < 0)\n\t\treturn VM_FAULT_SIGBUS;\n\n\tif (!(flags & FAULT_FLAG_WRITE)) {\n\t\tentry = pte_mkspecial(pfn_pte(my_zero_pfn(address),\n\t\t\t\t\t\tvma->vm_page_prot));\n\t\tptl = pte_lockptr(mm, pmd);\n\t\tspin_lock(ptl);\n\t\tif (!pte_none(*page_table))\n\t\t\tgoto unlock;\n\t\tgoto setpte;\n\t}\n\n\t/* Allocate our own private page. */\n\tpte_unmap(page_table);\n\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\tgoto oom;\n\tpage = alloc_zeroed_user_highpage_movable(vma, address);\n\tif (!page)\n\t\tgoto oom;\n\t__SetPageUptodate(page);\n\n\tif (mem_cgroup_newpage_charge(page, mm, GFP_KERNEL))\n\t\tgoto oom_free_page;\n\n\tentry = mk_pte(page, vma->vm_page_prot);\n\tif (vma->vm_flags & VM_WRITE)\n\t\tentry = pte_mkwrite(pte_mkdirty(entry));\n\n\tpage_table = pte_offset_map_lock(mm, pmd, address, &ptl);\n\tif (!pte_none(*page_table))\n\t\tgoto release;\n\n\tinc_mm_counter_fast(mm, MM_ANONPAGES);\n\tpage_add_new_anon_rmap(page, vma, address);\nsetpte:\n\tset_pte_at(mm, address, page_table, entry);\n\n\t/* No need to invalidate - it was non-present before */\n\tupdate_mmu_cache(vma, address, page_table);\nunlock:\n\tpte_unmap_unlock(page_table, ptl);\n\treturn 0;\nrelease:\n\tmem_cgroup_uncharge_page(page);\n\tpage_cache_release(page);\n\tgoto unlock;\noom_free_page:\n\tpage_cache_release(page);\noom:\n\treturn VM_FAULT_OOM;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,6 +5,9 @@\n \tstruct page *page;\n \tspinlock_t *ptl;\n \tpte_t entry;\n+\n+\tif (check_stack_guard_page(vma, address) < 0)\n+\t\treturn VM_FAULT_SIGBUS;\n \n \tif (!(flags & FAULT_FLAG_WRITE)) {\n \t\tentry = pte_mkspecial(pfn_pte(my_zero_pfn(address),",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tif (check_stack_guard_page(vma, address) < 0)",
                "\t\treturn VM_FAULT_SIGBUS;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-41882",
        "func_name": "nextcloud/desktop/JsonApiJob::setBody",
        "description": "The Nextcloud Desktop Client is a tool to synchronize files from Nextcloud Server with your computer. In version 3.6.0, if a user received a malicious file share and has it synced locally or the virtual filesystem enabled and clicked a nc://open/ link it will open the default editor for the file type of the shared file, which on Windows can also sometimes mean that a file depending on the type, e.g. \"vbs\", is being executed. It is recommended that the Nextcloud Desktop client is upgraded to version 3.6.1. As a workaround, users can block the Nextcloud Desktop client 3.6.0 by setting the `minimum.supported.desktop.version` system config to `3.6.1` on the server, so new files designed to use this attack vector are not downloaded anymore. Already existing files can still be used. Another workaround would be to enforce shares to be accepted by setting the `sharing.force_share_accept` system config to `true` on the server, so new files designed to use this attack vector are not downloaded anymore. Already existing shares can still be abused.",
        "git_url": "https://github.com/nextcloud/desktop/commit/615c02e3d3ee5daa62f8780e43d28bb631b55df8",
        "commit_title": "makes JsonApiJob share common code with SimpleApiJob",
        "commit_text": "",
        "func_before": "void JsonApiJob::setBody(const QJsonDocument &body)\n{\n    _body = body.toJson();\n    qCDebug(lcJsonApiJob) << \"Set body for request:\" << _body;\n    if (!_body.isEmpty()) {\n        _request.setHeader(QNetworkRequest::ContentTypeHeader, \"application/json\");\n    }\n}",
        "func": "void JsonApiJob::setBody(const QJsonDocument &body)\n{\n    SimpleApiJob::setBody(body.toJson());\n    qCDebug(lcJsonApiJob) << \"Set body for request:\" << SimpleApiJob::body();\n    if (!SimpleApiJob::body().isEmpty()) {\n        request().setHeader(QNetworkRequest::ContentTypeHeader, \"application/json\");\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,8 @@\n void JsonApiJob::setBody(const QJsonDocument &body)\n {\n-    _body = body.toJson();\n-    qCDebug(lcJsonApiJob) << \"Set body for request:\" << _body;\n-    if (!_body.isEmpty()) {\n-        _request.setHeader(QNetworkRequest::ContentTypeHeader, \"application/json\");\n+    SimpleApiJob::setBody(body.toJson());\n+    qCDebug(lcJsonApiJob) << \"Set body for request:\" << SimpleApiJob::body();\n+    if (!SimpleApiJob::body().isEmpty()) {\n+        request().setHeader(QNetworkRequest::ContentTypeHeader, \"application/json\");\n     }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    _body = body.toJson();",
                "    qCDebug(lcJsonApiJob) << \"Set body for request:\" << _body;",
                "    if (!_body.isEmpty()) {",
                "        _request.setHeader(QNetworkRequest::ContentTypeHeader, \"application/json\");"
            ],
            "added_lines": [
                "    SimpleApiJob::setBody(body.toJson());",
                "    qCDebug(lcJsonApiJob) << \"Set body for request:\" << SimpleApiJob::body();",
                "    if (!SimpleApiJob::body().isEmpty()) {",
                "        request().setHeader(QNetworkRequest::ContentTypeHeader, \"application/json\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-41882",
        "func_name": "nextcloud/desktop/JsonApiJob::JsonApiJob",
        "description": "The Nextcloud Desktop Client is a tool to synchronize files from Nextcloud Server with your computer. In version 3.6.0, if a user received a malicious file share and has it synced locally or the virtual filesystem enabled and clicked a nc://open/ link it will open the default editor for the file type of the shared file, which on Windows can also sometimes mean that a file depending on the type, e.g. \"vbs\", is being executed. It is recommended that the Nextcloud Desktop client is upgraded to version 3.6.1. As a workaround, users can block the Nextcloud Desktop client 3.6.0 by setting the `minimum.supported.desktop.version` system config to `3.6.1` on the server, so new files designed to use this attack vector are not downloaded anymore. Already existing files can still be used. Another workaround would be to enforce shares to be accepted by setting the `sharing.force_share_accept` system config to `true` on the server, so new files designed to use this attack vector are not downloaded anymore. Already existing shares can still be abused.",
        "git_url": "https://github.com/nextcloud/desktop/commit/615c02e3d3ee5daa62f8780e43d28bb631b55df8",
        "commit_title": "makes JsonApiJob share common code with SimpleApiJob",
        "commit_text": "",
        "func_before": "JsonApiJob::JsonApiJob(const AccountPtr &account, const QString &path, QObject *parent)\n    : AbstractNetworkJob(account, path, parent)\n{\n}",
        "func": "JsonApiJob::JsonApiJob(const AccountPtr &account, const QString &path, QObject *parent)\n    : SimpleApiJob(account, path, parent)\n{\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n JsonApiJob::JsonApiJob(const AccountPtr &account, const QString &path, QObject *parent)\n-    : AbstractNetworkJob(account, path, parent)\n+    : SimpleApiJob(account, path, parent)\n {\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    : AbstractNetworkJob(account, path, parent)"
            ],
            "added_lines": [
                "    : SimpleApiJob(account, path, parent)"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-41882",
        "func_name": "nextcloud/desktop/SimpleApiJob::start",
        "description": "The Nextcloud Desktop Client is a tool to synchronize files from Nextcloud Server with your computer. In version 3.6.0, if a user received a malicious file share and has it synced locally or the virtual filesystem enabled and clicked a nc://open/ link it will open the default editor for the file type of the shared file, which on Windows can also sometimes mean that a file depending on the type, e.g. \"vbs\", is being executed. It is recommended that the Nextcloud Desktop client is upgraded to version 3.6.1. As a workaround, users can block the Nextcloud Desktop client 3.6.0 by setting the `minimum.supported.desktop.version` system config to `3.6.1` on the server, so new files designed to use this attack vector are not downloaded anymore. Already existing files can still be used. Another workaround would be to enforce shares to be accepted by setting the `sharing.force_share_accept` system config to `true` on the server, so new files designed to use this attack vector are not downloaded anymore. Already existing shares can still be abused.",
        "git_url": "https://github.com/nextcloud/desktop/commit/615c02e3d3ee5daa62f8780e43d28bb631b55df8",
        "commit_title": "makes JsonApiJob share common code with SimpleApiJob",
        "commit_text": "",
        "func_before": "void SimpleApiJob::start()\n{\n    qCDebug(lcSimpleApiJob) << \"send: \" << path() << _body;\n\n    _request.setRawHeader(\"OCS-APIREQUEST\", \"true\");\n    const auto url = Utility::concatUrlPath(account()->url(), path());\n    const auto httpVerb = verbToString();\n    if (!_body.isEmpty()) {\n        sendRequest(httpVerb, url, _request, _body);\n    } else {\n        sendRequest(httpVerb, url, _request);\n    }\n    AbstractNetworkJob::start();\n}",
        "func": "void SimpleApiJob::start()\n{\n    addRawHeader(\"OCS-APIREQUEST\", \"true\");\n    auto query = _additionalParams;\n    QUrl url = Utility::concatUrlPath(account()->url(), path(), query);\n    const auto httpVerb = verbToString();\n    if (!SimpleApiJob::body().isEmpty()) {\n        sendRequest(httpVerb, url, request(), SimpleApiJob::body());\n    } else {\n        sendRequest(httpVerb, url, request());\n    }\n    AbstractNetworkJob::start();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,14 +1,13 @@\n void SimpleApiJob::start()\n {\n-    qCDebug(lcSimpleApiJob) << \"send: \" << path() << _body;\n-\n-    _request.setRawHeader(\"OCS-APIREQUEST\", \"true\");\n-    const auto url = Utility::concatUrlPath(account()->url(), path());\n+    addRawHeader(\"OCS-APIREQUEST\", \"true\");\n+    auto query = _additionalParams;\n+    QUrl url = Utility::concatUrlPath(account()->url(), path(), query);\n     const auto httpVerb = verbToString();\n-    if (!_body.isEmpty()) {\n-        sendRequest(httpVerb, url, _request, _body);\n+    if (!SimpleApiJob::body().isEmpty()) {\n+        sendRequest(httpVerb, url, request(), SimpleApiJob::body());\n     } else {\n-        sendRequest(httpVerb, url, _request);\n+        sendRequest(httpVerb, url, request());\n     }\n     AbstractNetworkJob::start();\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    qCDebug(lcSimpleApiJob) << \"send: \" << path() << _body;",
                "",
                "    _request.setRawHeader(\"OCS-APIREQUEST\", \"true\");",
                "    const auto url = Utility::concatUrlPath(account()->url(), path());",
                "    if (!_body.isEmpty()) {",
                "        sendRequest(httpVerb, url, _request, _body);",
                "        sendRequest(httpVerb, url, _request);"
            ],
            "added_lines": [
                "    addRawHeader(\"OCS-APIREQUEST\", \"true\");",
                "    auto query = _additionalParams;",
                "    QUrl url = Utility::concatUrlPath(account()->url(), path(), query);",
                "    if (!SimpleApiJob::body().isEmpty()) {",
                "        sendRequest(httpVerb, url, request(), SimpleApiJob::body());",
                "        sendRequest(httpVerb, url, request());"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-41882",
        "func_name": "nextcloud/desktop/JsonApiJob::start",
        "description": "The Nextcloud Desktop Client is a tool to synchronize files from Nextcloud Server with your computer. In version 3.6.0, if a user received a malicious file share and has it synced locally or the virtual filesystem enabled and clicked a nc://open/ link it will open the default editor for the file type of the shared file, which on Windows can also sometimes mean that a file depending on the type, e.g. \"vbs\", is being executed. It is recommended that the Nextcloud Desktop client is upgraded to version 3.6.1. As a workaround, users can block the Nextcloud Desktop client 3.6.0 by setting the `minimum.supported.desktop.version` system config to `3.6.1` on the server, so new files designed to use this attack vector are not downloaded anymore. Already existing files can still be used. Another workaround would be to enforce shares to be accepted by setting the `sharing.force_share_accept` system config to `true` on the server, so new files designed to use this attack vector are not downloaded anymore. Already existing shares can still be abused.",
        "git_url": "https://github.com/nextcloud/desktop/commit/615c02e3d3ee5daa62f8780e43d28bb631b55df8",
        "commit_title": "makes JsonApiJob share common code with SimpleApiJob",
        "commit_text": "",
        "func_before": "void JsonApiJob::start()\n{\n    addRawHeader(\"OCS-APIREQUEST\", \"true\");\n    auto query = _additionalParams;\n    query.addQueryItem(QLatin1String(\"format\"), QLatin1String(\"json\"));\n    QUrl url = Utility::concatUrlPath(account()->url(), path(), query);\n    const auto httpVerb = verbToString();\n    if (!_body.isEmpty()) {\n        sendRequest(httpVerb, url, _request, _body);\n    } else {\n        sendRequest(httpVerb, url, _request);\n    }\n    AbstractNetworkJob::start();\n}",
        "func": "void JsonApiJob::start()\n{\n    additionalParams().addQueryItem(QLatin1String(\"format\"), QLatin1String(\"json\"));\n    SimpleApiJob::start();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,14 +1,5 @@\n void JsonApiJob::start()\n {\n-    addRawHeader(\"OCS-APIREQUEST\", \"true\");\n-    auto query = _additionalParams;\n-    query.addQueryItem(QLatin1String(\"format\"), QLatin1String(\"json\"));\n-    QUrl url = Utility::concatUrlPath(account()->url(), path(), query);\n-    const auto httpVerb = verbToString();\n-    if (!_body.isEmpty()) {\n-        sendRequest(httpVerb, url, _request, _body);\n-    } else {\n-        sendRequest(httpVerb, url, _request);\n-    }\n-    AbstractNetworkJob::start();\n+    additionalParams().addQueryItem(QLatin1String(\"format\"), QLatin1String(\"json\"));\n+    SimpleApiJob::start();\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    addRawHeader(\"OCS-APIREQUEST\", \"true\");",
                "    auto query = _additionalParams;",
                "    query.addQueryItem(QLatin1String(\"format\"), QLatin1String(\"json\"));",
                "    QUrl url = Utility::concatUrlPath(account()->url(), path(), query);",
                "    const auto httpVerb = verbToString();",
                "    if (!_body.isEmpty()) {",
                "        sendRequest(httpVerb, url, _request, _body);",
                "    } else {",
                "        sendRequest(httpVerb, url, _request);",
                "    }",
                "    AbstractNetworkJob::start();"
            ],
            "added_lines": [
                "    additionalParams().addQueryItem(QLatin1String(\"format\"), QLatin1String(\"json\"));",
                "    SimpleApiJob::start();"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-41882",
        "func_name": "nextcloud/desktop/FolderMan::editFileLocally",
        "description": "The Nextcloud Desktop Client is a tool to synchronize files from Nextcloud Server with your computer. In version 3.6.0, if a user received a malicious file share and has it synced locally or the virtual filesystem enabled and clicked a nc://open/ link it will open the default editor for the file type of the shared file, which on Windows can also sometimes mean that a file depending on the type, e.g. \"vbs\", is being executed. It is recommended that the Nextcloud Desktop client is upgraded to version 3.6.1. As a workaround, users can block the Nextcloud Desktop client 3.6.0 by setting the `minimum.supported.desktop.version` system config to `3.6.1` on the server, so new files designed to use this attack vector are not downloaded anymore. Already existing files can still be used. Another workaround would be to enforce shares to be accepted by setting the `sharing.force_share_accept` system config to `true` on the server, so new files designed to use this attack vector are not downloaded anymore. Already existing shares can still be abused.",
        "git_url": "https://github.com/nextcloud/desktop/commit/f9949ee0de1b8a42412f528dc1f64e080eb44316",
        "commit_title": "edit locally requires a valid token",
        "commit_text": " check on server that the token received during a request to open a local file is indeed a valid one ",
        "func_before": "void FolderMan::editFileLocally(const QString &accountDisplayName, const QString &relPath)\n{\n    const auto showError = [this](const OCC::AccountStatePtr accountState, const QString &errorMessage, const QString &subject) {\n        if (accountState && accountState->account()) {\n            const auto foundFolder = std::find_if(std::cbegin(map()), std::cend(map()), [accountState](const auto &folder) {\n                return accountState->account()->davUrl() == folder->remoteUrl();\n            });\n\n            if (foundFolder != std::cend(map())) {\n                (*foundFolder)->syncEngine().addErrorToGui(SyncFileItem::SoftError, errorMessage, subject);\n            }\n        }\n\n        // to make sure the error is not missed, show a message box in addition\n        const auto messageBox = new QMessageBox;\n        messageBox->setAttribute(Qt::WA_DeleteOnClose);\n        messageBox->setText(errorMessage);\n        messageBox->setInformativeText(subject);\n        messageBox->setIcon(QMessageBox::Warning);\n        messageBox->addButton(QMessageBox::StandardButton::Ok);\n        messageBox->show();\n        messageBox->activateWindow();\n        messageBox->raise();\n    };\n\n    const auto accountFound = AccountManager::instance()->account(accountDisplayName);\n\n    if (!accountFound) {\n        qCWarning(lcFolderMan) << \"Could not find an account \" << accountDisplayName << \" to edit file \" << relPath << \" locally.\";\n        showError(accountFound, tr(\"Could not find an account for local editing\"), accountDisplayName);\n        return;\n    }\n\n    const auto foundFiles = findFileInLocalFolders(relPath, accountFound->account());\n\n    if (foundFiles.isEmpty()) {\n        for (const auto &folder : map()) {\n            bool result = false;\n            const auto excludedThroughSelectiveSync = folder->journalDb()->getSelectiveSyncList(SyncJournalDb::SelectiveSyncBlackList, &result);\n            for (const auto &excludedPath : excludedThroughSelectiveSync) {\n                if (relPath.startsWith(excludedPath)) {\n                    showError(accountFound, tr(\"Could not find a file for local editing. Make sure it is not excluded via selective sync.\"), relPath);\n                    return;\n                }\n            }\n        }\n\n        showError(accountFound, tr(\"Could not find a file for local editing. Make sure its path is valid and it is synced locally.\"), relPath);\n        return;\n    }\n\n    const auto localFilePath = foundFiles.first();\n    const auto folderForFile = folderForPath(localFilePath);\n\n    if (!folderForFile) {\n        showError(accountFound, tr(\"Could not find a folder to sync.\"), relPath);\n        return;\n    }\n    \n    const auto relPathSplit = relPath.split(QLatin1Char('/'));\n    if (relPathSplit.size() > 0) {\n        Systray::instance()->createEditFileLocallyLoadingDialog(relPathSplit.last());\n    } else {\n        showError(accountFound, tr(\"Could not find a file for local editing. Make sure its path is valid and it is synced locally.\"), relPath);\n        return;\n    }\n    folderForFile->startSync();\n    _localFileEditingSyncFinishedConnections.insert(localFilePath, QObject::connect(folderForFile, &Folder::syncFinished, this,\n        [this, localFilePath](const OCC::SyncResult &result) {\n        Q_UNUSED(result);\n        const auto foundConnectionIt = _localFileEditingSyncFinishedConnections.find(localFilePath);\n        if (foundConnectionIt != std::end(_localFileEditingSyncFinishedConnections) && foundConnectionIt.value()) {\n            QObject::disconnect(foundConnectionIt.value());\n            _localFileEditingSyncFinishedConnections.erase(foundConnectionIt);\n        }\n        // In case the VFS mode is enabled and a file is not yet hydrated, we must call QDesktopServices::openUrl\n        // from a separate thread, or, there will be a freeze. To avoid searching for a specific folder and checking\n        // if the VFS is enabled - we just always call it from a separate thread.\n        QtConcurrent::run([localFilePath]() {\n            QDesktopServices::openUrl(QUrl::fromLocalFile(localFilePath));\n            Systray::instance()->destroyEditFileLocallyLoadingDialog();\n        });\n    }));\n}",
        "func": "void FolderMan::editFileLocally(const QString &accountDisplayName, const QString &relPath, const QString &token)\n{\n    const auto showError = [this](const OCC::AccountStatePtr accountState, const QString &errorMessage, const QString &subject) {\n        if (accountState && accountState->account()) {\n            const auto foundFolder = std::find_if(std::cbegin(map()), std::cend(map()), [accountState](const auto &folder) {\n                return accountState->account()->davUrl() == folder->remoteUrl();\n            });\n\n            if (foundFolder != std::cend(map())) {\n                (*foundFolder)->syncEngine().addErrorToGui(SyncFileItem::SoftError, errorMessage, subject);\n            }\n        }\n\n        // to make sure the error is not missed, show a message box in addition\n        const auto messageBox = new QMessageBox;\n        messageBox->setAttribute(Qt::WA_DeleteOnClose);\n        messageBox->setText(errorMessage);\n        messageBox->setInformativeText(subject);\n        messageBox->setIcon(QMessageBox::Warning);\n        messageBox->addButton(QMessageBox::StandardButton::Ok);\n        messageBox->show();\n        messageBox->activateWindow();\n        messageBox->raise();\n    };\n\n    if (token.isEmpty()) {\n        qCWarning(lcFolderMan) << \"Edit locally request is missing a valid token. Impossible to open the file.\";\n        showError({}, tr(\"Edit locally request is not valid. Opening the file is forbidden.\"), accountDisplayName);\n        return;\n    }\n\n    const auto accountFound = AccountManager::instance()->account(accountDisplayName);\n\n    if (!accountFound) {\n        qCWarning(lcFolderMan) << \"Could not find an account \" << accountDisplayName << \" to edit file \" << relPath << \" locally.\";\n        showError(accountFound, tr(\"Could not find an account for local editing\"), accountDisplayName);\n        return;\n    }\n\n    const auto foundFiles = findFileInLocalFolders(relPath, accountFound->account());\n\n    if (foundFiles.isEmpty()) {\n        for (const auto &folder : map()) {\n            bool result = false;\n            const auto excludedThroughSelectiveSync = folder->journalDb()->getSelectiveSyncList(SyncJournalDb::SelectiveSyncBlackList, &result);\n            for (const auto &excludedPath : excludedThroughSelectiveSync) {\n                if (relPath.startsWith(excludedPath)) {\n                    showError(accountFound, tr(\"Could not find a file for local editing. Make sure it is not excluded via selective sync.\"), relPath);\n                    return;\n                }\n            }\n        }\n\n        showError(accountFound, tr(\"Could not find a file for local editing. Make sure its path is valid and it is synced locally.\"), relPath);\n        return;\n    }\n\n    const auto localFilePath = foundFiles.first();\n    const auto folderForFile = folderForPath(localFilePath);\n\n    if (!folderForFile) {\n        showError(accountFound, tr(\"Could not find a folder to sync.\"), relPath);\n        return;\n    }\n    \n    const auto relPathSplit = relPath.split(QLatin1Char('/'));\n    if (relPathSplit.size() > 0) {\n        Systray::instance()->createEditFileLocallyLoadingDialog(relPathSplit.last());\n    } else {\n        showError(accountFound, tr(\"Could not find a file for local editing. Make sure its path is valid and it is synced locally.\"), relPath);\n        return;\n    }\n\n    const auto checkTokenForEditLocally = new SimpleApiJob(accountFound->account(), QStringLiteral(\"/ocs/v2.php/apps/files/api/v1/openlocaleditor/%1\").arg(token));\n    checkTokenForEditLocally->setVerb(SimpleApiJob::Verb::Post);\n    checkTokenForEditLocally->setBody(QByteArray{\"path=/\"}.append(relPath.toUtf8()));\n    connect(checkTokenForEditLocally, &SimpleApiJob::resultReceived, checkTokenForEditLocally, [this, folderForFile, localFilePath, showError, accountFound, relPath] (int statusCode) {\n        constexpr auto HTTP_OK_CODE = 200;\n        if (statusCode != HTTP_OK_CODE) {\n            Systray::instance()->destroyEditFileLocallyLoadingDialog();\n            showError(accountFound, tr(\"Could not validate the request to open a file from server.\"), relPath);\n            qCInfo(lcFolderMan()) << \"token check result\" << statusCode;\n            return;\n        }\n\n        folderForFile->startSync();\n        _localFileEditingSyncFinishedConnections.insert(localFilePath, QObject::connect(folderForFile, &Folder::syncFinished, this,\n                                                                                        [this, localFilePath](const OCC::SyncResult &result) {\n                                                                                            Q_UNUSED(result);\n                                                                                            const auto foundConnectionIt = _localFileEditingSyncFinishedConnections.find(localFilePath);\n                                                                                            if (foundConnectionIt != std::end(_localFileEditingSyncFinishedConnections) && foundConnectionIt.value()) {\n                                                                                                QObject::disconnect(foundConnectionIt.value());\n                                                                                                _localFileEditingSyncFinishedConnections.erase(foundConnectionIt);\n                                                                                            }\n                                                                                            // In case the VFS mode is enabled and a file is not yet hydrated, we must call QDesktopServices::openUrl\n                                                                                            // from a separate thread, or, there will be a freeze. To avoid searching for a specific folder and checking\n                                                                                            // if the VFS is enabled - we just always call it from a separate thread.\n                                                                                            QtConcurrent::run([localFilePath]() {\n                                                                                                QDesktopServices::openUrl(QUrl::fromLocalFile(localFilePath));\n                                                                                                Systray::instance()->destroyEditFileLocallyLoadingDialog();\n                                                                                            });\n                                                                                        }));\n    });\n    checkTokenForEditLocally->start();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-void FolderMan::editFileLocally(const QString &accountDisplayName, const QString &relPath)\n+void FolderMan::editFileLocally(const QString &accountDisplayName, const QString &relPath, const QString &token)\n {\n     const auto showError = [this](const OCC::AccountStatePtr accountState, const QString &errorMessage, const QString &subject) {\n         if (accountState && accountState->account()) {\n@@ -22,6 +22,12 @@\n         messageBox->activateWindow();\n         messageBox->raise();\n     };\n+\n+    if (token.isEmpty()) {\n+        qCWarning(lcFolderMan) << \"Edit locally request is missing a valid token. Impossible to open the file.\";\n+        showError({}, tr(\"Edit locally request is not valid. Opening the file is forbidden.\"), accountDisplayName);\n+        return;\n+    }\n \n     const auto accountFound = AccountManager::instance()->account(accountDisplayName);\n \n@@ -64,21 +70,36 @@\n         showError(accountFound, tr(\"Could not find a file for local editing. Make sure its path is valid and it is synced locally.\"), relPath);\n         return;\n     }\n-    folderForFile->startSync();\n-    _localFileEditingSyncFinishedConnections.insert(localFilePath, QObject::connect(folderForFile, &Folder::syncFinished, this,\n-        [this, localFilePath](const OCC::SyncResult &result) {\n-        Q_UNUSED(result);\n-        const auto foundConnectionIt = _localFileEditingSyncFinishedConnections.find(localFilePath);\n-        if (foundConnectionIt != std::end(_localFileEditingSyncFinishedConnections) && foundConnectionIt.value()) {\n-            QObject::disconnect(foundConnectionIt.value());\n-            _localFileEditingSyncFinishedConnections.erase(foundConnectionIt);\n+\n+    const auto checkTokenForEditLocally = new SimpleApiJob(accountFound->account(), QStringLiteral(\"/ocs/v2.php/apps/files/api/v1/openlocaleditor/%1\").arg(token));\n+    checkTokenForEditLocally->setVerb(SimpleApiJob::Verb::Post);\n+    checkTokenForEditLocally->setBody(QByteArray{\"path=/\"}.append(relPath.toUtf8()));\n+    connect(checkTokenForEditLocally, &SimpleApiJob::resultReceived, checkTokenForEditLocally, [this, folderForFile, localFilePath, showError, accountFound, relPath] (int statusCode) {\n+        constexpr auto HTTP_OK_CODE = 200;\n+        if (statusCode != HTTP_OK_CODE) {\n+            Systray::instance()->destroyEditFileLocallyLoadingDialog();\n+            showError(accountFound, tr(\"Could not validate the request to open a file from server.\"), relPath);\n+            qCInfo(lcFolderMan()) << \"token check result\" << statusCode;\n+            return;\n         }\n-        // In case the VFS mode is enabled and a file is not yet hydrated, we must call QDesktopServices::openUrl\n-        // from a separate thread, or, there will be a freeze. To avoid searching for a specific folder and checking\n-        // if the VFS is enabled - we just always call it from a separate thread.\n-        QtConcurrent::run([localFilePath]() {\n-            QDesktopServices::openUrl(QUrl::fromLocalFile(localFilePath));\n-            Systray::instance()->destroyEditFileLocallyLoadingDialog();\n-        });\n-    }));\n+\n+        folderForFile->startSync();\n+        _localFileEditingSyncFinishedConnections.insert(localFilePath, QObject::connect(folderForFile, &Folder::syncFinished, this,\n+                                                                                        [this, localFilePath](const OCC::SyncResult &result) {\n+                                                                                            Q_UNUSED(result);\n+                                                                                            const auto foundConnectionIt = _localFileEditingSyncFinishedConnections.find(localFilePath);\n+                                                                                            if (foundConnectionIt != std::end(_localFileEditingSyncFinishedConnections) && foundConnectionIt.value()) {\n+                                                                                                QObject::disconnect(foundConnectionIt.value());\n+                                                                                                _localFileEditingSyncFinishedConnections.erase(foundConnectionIt);\n+                                                                                            }\n+                                                                                            // In case the VFS mode is enabled and a file is not yet hydrated, we must call QDesktopServices::openUrl\n+                                                                                            // from a separate thread, or, there will be a freeze. To avoid searching for a specific folder and checking\n+                                                                                            // if the VFS is enabled - we just always call it from a separate thread.\n+                                                                                            QtConcurrent::run([localFilePath]() {\n+                                                                                                QDesktopServices::openUrl(QUrl::fromLocalFile(localFilePath));\n+                                                                                                Systray::instance()->destroyEditFileLocallyLoadingDialog();\n+                                                                                            });\n+                                                                                        }));\n+    });\n+    checkTokenForEditLocally->start();\n }",
        "diff_line_info": {
            "deleted_lines": [
                "void FolderMan::editFileLocally(const QString &accountDisplayName, const QString &relPath)",
                "    folderForFile->startSync();",
                "    _localFileEditingSyncFinishedConnections.insert(localFilePath, QObject::connect(folderForFile, &Folder::syncFinished, this,",
                "        [this, localFilePath](const OCC::SyncResult &result) {",
                "        Q_UNUSED(result);",
                "        const auto foundConnectionIt = _localFileEditingSyncFinishedConnections.find(localFilePath);",
                "        if (foundConnectionIt != std::end(_localFileEditingSyncFinishedConnections) && foundConnectionIt.value()) {",
                "            QObject::disconnect(foundConnectionIt.value());",
                "            _localFileEditingSyncFinishedConnections.erase(foundConnectionIt);",
                "        // In case the VFS mode is enabled and a file is not yet hydrated, we must call QDesktopServices::openUrl",
                "        // from a separate thread, or, there will be a freeze. To avoid searching for a specific folder and checking",
                "        // if the VFS is enabled - we just always call it from a separate thread.",
                "        QtConcurrent::run([localFilePath]() {",
                "            QDesktopServices::openUrl(QUrl::fromLocalFile(localFilePath));",
                "            Systray::instance()->destroyEditFileLocallyLoadingDialog();",
                "        });",
                "    }));"
            ],
            "added_lines": [
                "void FolderMan::editFileLocally(const QString &accountDisplayName, const QString &relPath, const QString &token)",
                "",
                "    if (token.isEmpty()) {",
                "        qCWarning(lcFolderMan) << \"Edit locally request is missing a valid token. Impossible to open the file.\";",
                "        showError({}, tr(\"Edit locally request is not valid. Opening the file is forbidden.\"), accountDisplayName);",
                "        return;",
                "    }",
                "",
                "    const auto checkTokenForEditLocally = new SimpleApiJob(accountFound->account(), QStringLiteral(\"/ocs/v2.php/apps/files/api/v1/openlocaleditor/%1\").arg(token));",
                "    checkTokenForEditLocally->setVerb(SimpleApiJob::Verb::Post);",
                "    checkTokenForEditLocally->setBody(QByteArray{\"path=/\"}.append(relPath.toUtf8()));",
                "    connect(checkTokenForEditLocally, &SimpleApiJob::resultReceived, checkTokenForEditLocally, [this, folderForFile, localFilePath, showError, accountFound, relPath] (int statusCode) {",
                "        constexpr auto HTTP_OK_CODE = 200;",
                "        if (statusCode != HTTP_OK_CODE) {",
                "            Systray::instance()->destroyEditFileLocallyLoadingDialog();",
                "            showError(accountFound, tr(\"Could not validate the request to open a file from server.\"), relPath);",
                "            qCInfo(lcFolderMan()) << \"token check result\" << statusCode;",
                "            return;",
                "",
                "        folderForFile->startSync();",
                "        _localFileEditingSyncFinishedConnections.insert(localFilePath, QObject::connect(folderForFile, &Folder::syncFinished, this,",
                "                                                                                        [this, localFilePath](const OCC::SyncResult &result) {",
                "                                                                                            Q_UNUSED(result);",
                "                                                                                            const auto foundConnectionIt = _localFileEditingSyncFinishedConnections.find(localFilePath);",
                "                                                                                            if (foundConnectionIt != std::end(_localFileEditingSyncFinishedConnections) && foundConnectionIt.value()) {",
                "                                                                                                QObject::disconnect(foundConnectionIt.value());",
                "                                                                                                _localFileEditingSyncFinishedConnections.erase(foundConnectionIt);",
                "                                                                                            }",
                "                                                                                            // In case the VFS mode is enabled and a file is not yet hydrated, we must call QDesktopServices::openUrl",
                "                                                                                            // from a separate thread, or, there will be a freeze. To avoid searching for a specific folder and checking",
                "                                                                                            // if the VFS is enabled - we just always call it from a separate thread.",
                "                                                                                            QtConcurrent::run([localFilePath]() {",
                "                                                                                                QDesktopServices::openUrl(QUrl::fromLocalFile(localFilePath));",
                "                                                                                                Systray::instance()->destroyEditFileLocallyLoadingDialog();",
                "                                                                                            });",
                "                                                                                        }));",
                "    });",
                "    checkTokenForEditLocally->start();"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-41882",
        "func_name": "nextcloud/desktop/Application::handleEditLocally",
        "description": "The Nextcloud Desktop Client is a tool to synchronize files from Nextcloud Server with your computer. In version 3.6.0, if a user received a malicious file share and has it synced locally or the virtual filesystem enabled and clicked a nc://open/ link it will open the default editor for the file type of the shared file, which on Windows can also sometimes mean that a file depending on the type, e.g. \"vbs\", is being executed. It is recommended that the Nextcloud Desktop client is upgraded to version 3.6.1. As a workaround, users can block the Nextcloud Desktop client 3.6.0 by setting the `minimum.supported.desktop.version` system config to `3.6.1` on the server, so new files designed to use this attack vector are not downloaded anymore. Already existing files can still be used. Another workaround would be to enforce shares to be accepted by setting the `sharing.force_share_accept` system config to `true` on the server, so new files designed to use this attack vector are not downloaded anymore. Already existing shares can still be abused.",
        "git_url": "https://github.com/nextcloud/desktop/commit/f9949ee0de1b8a42412f528dc1f64e080eb44316",
        "commit_title": "edit locally requires a valid token",
        "commit_text": " check on server that the token received during a request to open a local file is indeed a valid one ",
        "func_before": "void Application::handleEditLocally(const QUrl &url) const\n{\n    auto pathSplit = url.path().split('/', Qt::SkipEmptyParts);\n\n    if (pathSplit.size() < 2) {\n        qCWarning(lcApplication) << \"Invalid URL for file local editing: \" + pathSplit.join('/');\n        return;\n    }\n\n    // for a sample URL \"nc://open/admin@nextcloud.lan:8080/Photos/lovely.jpg\", QUrl::path would return \"admin@nextcloud.lan:8080/Photos/lovely.jpg\"\n    const auto accountDisplayName = pathSplit.takeFirst();\n    const auto fileRemotePath = pathSplit.join('/');\n\n    FolderMan::instance()->editFileLocally(accountDisplayName, fileRemotePath);\n}",
        "func": "void Application::handleEditLocally(const QUrl &url) const\n{\n    auto pathSplit = url.path().split('/', Qt::SkipEmptyParts);\n\n    if (pathSplit.size() < 2) {\n        qCWarning(lcApplication) << \"Invalid URL for file local editing: \" + pathSplit.join('/');\n        return;\n    }\n\n    // for a sample URL \"nc://open/admin@nextcloud.lan:8080/Photos/lovely.jpg\", QUrl::path would return \"admin@nextcloud.lan:8080/Photos/lovely.jpg\"\n    const auto accountDisplayName = pathSplit.takeFirst();\n    const auto fileRemotePath = pathSplit.join('/');\n    const auto urlQuery = QUrlQuery{url};\n\n    auto token = QString{};\n    if (urlQuery.hasQueryItem(QStringLiteral(\"token\"))) {\n        token = urlQuery.queryItemValue(QStringLiteral(\"token\"));\n    } else {\n        qCWarning(lcApplication) << \"Invalid URL for file local editing: missing token\";\n    }\n\n    FolderMan::instance()->editFileLocally(accountDisplayName, fileRemotePath, token);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,14 @@\n     // for a sample URL \"nc://open/admin@nextcloud.lan:8080/Photos/lovely.jpg\", QUrl::path would return \"admin@nextcloud.lan:8080/Photos/lovely.jpg\"\n     const auto accountDisplayName = pathSplit.takeFirst();\n     const auto fileRemotePath = pathSplit.join('/');\n+    const auto urlQuery = QUrlQuery{url};\n \n-    FolderMan::instance()->editFileLocally(accountDisplayName, fileRemotePath);\n+    auto token = QString{};\n+    if (urlQuery.hasQueryItem(QStringLiteral(\"token\"))) {\n+        token = urlQuery.queryItemValue(QStringLiteral(\"token\"));\n+    } else {\n+        qCWarning(lcApplication) << \"Invalid URL for file local editing: missing token\";\n+    }\n+\n+    FolderMan::instance()->editFileLocally(accountDisplayName, fileRemotePath, token);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    FolderMan::instance()->editFileLocally(accountDisplayName, fileRemotePath);"
            ],
            "added_lines": [
                "    const auto urlQuery = QUrlQuery{url};",
                "    auto token = QString{};",
                "    if (urlQuery.hasQueryItem(QStringLiteral(\"token\"))) {",
                "        token = urlQuery.queryItemValue(QStringLiteral(\"token\"));",
                "    } else {",
                "        qCWarning(lcApplication) << \"Invalid URL for file local editing: missing token\";",
                "    }",
                "",
                "    FolderMan::instance()->editFileLocally(accountDisplayName, fileRemotePath, token);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-45907",
        "func_name": "pytorch/ScriptTypeParser::evaluateDefaults",
        "description": "In PyTorch before trunk/89695, torch.jit.annotations.parse_type_line can cause arbitrary code execution because eval is used unsafely.",
        "git_url": "https://github.com/pytorch/pytorch/commit/767f6aa49fe20a2766b9843d01e3b7f7793df6a3",
        "commit_title": "[JIT][Security] Do not blindly eval input string (#89189)",
        "commit_text": " Introduce `_eval_no_call` method, that evaluates statement only if it does not contain any calls(done by examining the bytecode), thus preventing command injection exploit  Added simple unit test to check for that `torch.jit.annotations.get_signature` would not result in calling random code.  Although, this code path exists for Python-2 compatibility, and perhaps should be simply removed.  Fixes https://github.com/pytorch/pytorch/issues/88868  Pull Request resolved: https://github.com/pytorch/pytorch/pull/89189 Approved by: https://github.com/suo",
        "func_before": "std::vector<IValue> ScriptTypeParser::evaluateDefaults(\n    const SourceRange& r,\n    const std::vector<Expr>& default_types,\n    const std::vector<Expr>& default_exprs) {\n  std::vector<IValue> default_values;\n  if (default_exprs.empty())\n    return default_values;\n  // To evaluate the default expressions, we create a graph with no inputs,\n  // and whose returns are the default values we need.\n  // We then run constant prop on this graph and check the results are\n  // constant. This approach avoids having to have separate handling of\n  // default arguments from standard expressions by piecing together existing\n  // machinery for graph generation, constant propgation, and constant\n  // extraction.\n  auto tuple_type = Subscript::create(\n      r,\n      Var::create(r, Ident::create(r, \"Tuple\")),\n      List<Expr>::create(r, default_types));\n  auto blank_decl = Decl::create(\n      r, List<Param>::create(r, {}), Maybe<Expr>::create(r, tuple_type));\n\n  auto tuple_expr =\n      TupleLiteral::create(r, List<Expr>::create(r, default_exprs));\n  auto ret = Return::create(r, tuple_expr);\n  auto def = Def::create(\n      r,\n      Ident::create(r, \"defaults\"),\n      blank_decl,\n      List<Stmt>::create(r, {ret}));\n\n  CompilationUnit cu;\n  cu.define(\n      c10::nullopt,\n      /*properties=*/{},\n      /*propResolvers=*/{},\n      {def},\n      {resolver_},\n      nullptr);\n  Stack stack;\n  // XXX: We need to turn optimization off here because otherwise we try to\n  // recursively initialize stuff in DecomposeOps.\n  GraphOptimizerEnabledGuard guard(false);\n  cu.get_function(def.name().name()).run(stack);\n  return stack.at(0).toTupleRef().elements().vec();\n}",
        "func": "std::vector<IValue> ScriptTypeParser::evaluateDefaults(\n    const SourceRange& r,\n    const std::vector<Expr>& default_types,\n    const std::vector<Expr>& default_exprs) {\n  std::vector<IValue> default_values;\n  if (default_exprs.empty())\n    return default_values;\n  // To evaluate the default expressions, we create a graph with no inputs,\n  // and whose returns are the default values we need.\n  // We then run constant prop on this graph and check the results are\n  // constant. This approach avoids having to have separate handling of\n  // default arguments from standard expressions by piecing together existing\n  // machinery for graph generation, constant propagation, and constant\n  // extraction.\n  auto tuple_type = Subscript::create(\n      r,\n      Var::create(r, Ident::create(r, \"Tuple\")),\n      List<Expr>::create(r, default_types));\n  auto blank_decl = Decl::create(\n      r, List<Param>::create(r, {}), Maybe<Expr>::create(r, tuple_type));\n\n  auto tuple_expr =\n      TupleLiteral::create(r, List<Expr>::create(r, default_exprs));\n  auto ret = Return::create(r, tuple_expr);\n  auto def = Def::create(\n      r,\n      Ident::create(r, \"defaults\"),\n      blank_decl,\n      List<Stmt>::create(r, {ret}));\n\n  CompilationUnit cu;\n  cu.define(\n      c10::nullopt,\n      /*properties=*/{},\n      /*propResolvers=*/{},\n      {def},\n      {resolver_},\n      nullptr);\n  Stack stack;\n  // XXX: We need to turn optimization off here because otherwise we try to\n  // recursively initialize stuff in DecomposeOps.\n  GraphOptimizerEnabledGuard guard(false);\n  cu.get_function(def.name().name()).run(stack);\n  return stack.at(0).toTupleRef().elements().vec();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,7 @@\n   // We then run constant prop on this graph and check the results are\n   // constant. This approach avoids having to have separate handling of\n   // default arguments from standard expressions by piecing together existing\n-  // machinery for graph generation, constant propgation, and constant\n+  // machinery for graph generation, constant propagation, and constant\n   // extraction.\n   auto tuple_type = Subscript::create(\n       r,",
        "diff_line_info": {
            "deleted_lines": [
                "  // machinery for graph generation, constant propgation, and constant"
            ],
            "added_lines": [
                "  // machinery for graph generation, constant propagation, and constant"
            ]
        }
    }
]