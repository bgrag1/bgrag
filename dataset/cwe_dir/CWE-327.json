[
    {
        "cve_id": "CVE-2019-1563",
        "func_name": "openssl/cms_RecipientInfo_ktri_decrypt",
        "description": "In situations where an attacker receives automated notification of the success or failure of a decryption attempt an attacker, after sending a very large number of messages to be decrypted, can recover a CMS/PKCS7 transported encryption key or decrypt any RSA encrypted message that was encrypted with the public RSA key, using a Bleichenbacher padding oracle attack. Applications are not affected if they use a certificate together with the private RSA key to the CMS_decrypt or PKCS7_decrypt functions to select the correct recipient info to decrypt. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). Fixed in OpenSSL 1.1.0l (Affected 1.1.0-1.1.0k). Fixed in OpenSSL 1.0.2t (Affected 1.0.2-1.0.2s).",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=631f94db0065c78181ca9ba5546ebc8bb3884b97",
        "commit_title": "",
        "commit_text": "Fix a padding oracle in PKCS7_dataDecode and CMS_decrypt_set1_pkey  An attack is simple, if the first CMS_recipientInfo is valid but the second CMS_recipientInfo is chosen ciphertext. If the second recipientInfo decodes to PKCS #1 v1.5 form plaintext, the correct encryption key will be replaced by garbage, and the message cannot be decoded, but if the RSA decryption fails, the correct encryption key is used and the recipient will not notice the attack.  As a work around for this potential attack the length of the decrypted key must be equal to the cipher default key length, in case the certifiate is not given and all recipientInfo are tried out.  The old behaviour can be re-enabled in the CMS code by setting the CMS_DEBUG_DECRYPT flag.  (Merged from https://github.com/openssl/openssl/pull/9777)  (cherry picked from commit 5840ed0cd1e6487d247efbc1a04136a41d7b3a37) ",
        "func_before": "static int cms_RecipientInfo_ktri_decrypt(CMS_ContentInfo *cms,\n                                          CMS_RecipientInfo *ri)\n{\n    CMS_KeyTransRecipientInfo *ktri = ri->d.ktri;\n    EVP_PKEY *pkey = ktri->pkey;\n    unsigned char *ek = NULL;\n    size_t eklen;\n    int ret = 0;\n    CMS_EncryptedContentInfo *ec;\n    ec = cms->d.envelopedData->encryptedContentInfo;\n\n    if (ktri->pkey == NULL) {\n        CMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT, CMS_R_NO_PRIVATE_KEY);\n        return 0;\n    }\n\n    ktri->pctx = EVP_PKEY_CTX_new(pkey, NULL);\n    if (ktri->pctx == NULL)\n        return 0;\n\n    if (EVP_PKEY_decrypt_init(ktri->pctx) <= 0)\n        goto err;\n\n    if (!cms_env_asn1_ctrl(ri, 1))\n        goto err;\n\n    if (EVP_PKEY_CTX_ctrl(ktri->pctx, -1, EVP_PKEY_OP_DECRYPT,\n                          EVP_PKEY_CTRL_CMS_DECRYPT, 0, ri) <= 0) {\n        CMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT, CMS_R_CTRL_ERROR);\n        goto err;\n    }\n\n    if (EVP_PKEY_decrypt(ktri->pctx, NULL, &eklen,\n                         ktri->encryptedKey->data,\n                         ktri->encryptedKey->length) <= 0)\n        goto err;\n\n    ek = OPENSSL_malloc(eklen);\n\n    if (ek == NULL) {\n        CMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (EVP_PKEY_decrypt(ktri->pctx, ek, &eklen,\n                         ktri->encryptedKey->data,\n                         ktri->encryptedKey->length) <= 0) {\n        CMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT, CMS_R_CMS_LIB);\n        goto err;\n    }\n\n    ret = 1;\n\n    OPENSSL_clear_free(ec->key, ec->keylen);\n    ec->key = ek;\n    ec->keylen = eklen;\n\n err:\n    EVP_PKEY_CTX_free(ktri->pctx);\n    ktri->pctx = NULL;\n    if (!ret)\n        OPENSSL_free(ek);\n\n    return ret;\n}",
        "func": "static int cms_RecipientInfo_ktri_decrypt(CMS_ContentInfo *cms,\n                                          CMS_RecipientInfo *ri)\n{\n    CMS_KeyTransRecipientInfo *ktri = ri->d.ktri;\n    EVP_PKEY *pkey = ktri->pkey;\n    unsigned char *ek = NULL;\n    size_t eklen;\n    int ret = 0;\n    size_t fixlen = 0;\n    CMS_EncryptedContentInfo *ec;\n    ec = cms->d.envelopedData->encryptedContentInfo;\n\n    if (ktri->pkey == NULL) {\n        CMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT, CMS_R_NO_PRIVATE_KEY);\n        return 0;\n    }\n\n    if (cms->d.envelopedData->encryptedContentInfo->havenocert\n            && !cms->d.envelopedData->encryptedContentInfo->debug) {\n        X509_ALGOR *calg = ec->contentEncryptionAlgorithm;\n        const EVP_CIPHER *ciph = EVP_get_cipherbyobj(calg->algorithm);\n\n        if (ciph == NULL) {\n            CMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT, CMS_R_UNKNOWN_CIPHER);\n            return 0;\n        }\n\n        fixlen = EVP_CIPHER_key_length(ciph);\n    }\n\n    ktri->pctx = EVP_PKEY_CTX_new(pkey, NULL);\n    if (ktri->pctx == NULL)\n        return 0;\n\n    if (EVP_PKEY_decrypt_init(ktri->pctx) <= 0)\n        goto err;\n\n    if (!cms_env_asn1_ctrl(ri, 1))\n        goto err;\n\n    if (EVP_PKEY_CTX_ctrl(ktri->pctx, -1, EVP_PKEY_OP_DECRYPT,\n                          EVP_PKEY_CTRL_CMS_DECRYPT, 0, ri) <= 0) {\n        CMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT, CMS_R_CTRL_ERROR);\n        goto err;\n    }\n\n    if (EVP_PKEY_decrypt(ktri->pctx, NULL, &eklen,\n                         ktri->encryptedKey->data,\n                         ktri->encryptedKey->length) <= 0)\n        goto err;\n\n    ek = OPENSSL_malloc(eklen);\n\n    if (ek == NULL) {\n        CMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (EVP_PKEY_decrypt(ktri->pctx, ek, &eklen,\n                         ktri->encryptedKey->data,\n                         ktri->encryptedKey->length) <= 0\n            || eklen == 0\n            || (fixlen != 0 && eklen != fixlen)) {\n        CMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT, CMS_R_CMS_LIB);\n        goto err;\n    }\n\n    ret = 1;\n\n    OPENSSL_clear_free(ec->key, ec->keylen);\n    ec->key = ek;\n    ec->keylen = eklen;\n\n err:\n    EVP_PKEY_CTX_free(ktri->pctx);\n    ktri->pctx = NULL;\n    if (!ret)\n        OPENSSL_free(ek);\n\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,12 +6,26 @@\n     unsigned char *ek = NULL;\n     size_t eklen;\n     int ret = 0;\n+    size_t fixlen = 0;\n     CMS_EncryptedContentInfo *ec;\n     ec = cms->d.envelopedData->encryptedContentInfo;\n \n     if (ktri->pkey == NULL) {\n         CMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT, CMS_R_NO_PRIVATE_KEY);\n         return 0;\n+    }\n+\n+    if (cms->d.envelopedData->encryptedContentInfo->havenocert\n+            && !cms->d.envelopedData->encryptedContentInfo->debug) {\n+        X509_ALGOR *calg = ec->contentEncryptionAlgorithm;\n+        const EVP_CIPHER *ciph = EVP_get_cipherbyobj(calg->algorithm);\n+\n+        if (ciph == NULL) {\n+            CMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT, CMS_R_UNKNOWN_CIPHER);\n+            return 0;\n+        }\n+\n+        fixlen = EVP_CIPHER_key_length(ciph);\n     }\n \n     ktri->pctx = EVP_PKEY_CTX_new(pkey, NULL);\n@@ -44,7 +58,9 @@\n \n     if (EVP_PKEY_decrypt(ktri->pctx, ek, &eklen,\n                          ktri->encryptedKey->data,\n-                         ktri->encryptedKey->length) <= 0) {\n+                         ktri->encryptedKey->length) <= 0\n+            || eklen == 0\n+            || (fixlen != 0 && eklen != fixlen)) {\n         CMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT, CMS_R_CMS_LIB);\n         goto err;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "                         ktri->encryptedKey->length) <= 0) {"
            ],
            "added_lines": [
                "    size_t fixlen = 0;",
                "    }",
                "",
                "    if (cms->d.envelopedData->encryptedContentInfo->havenocert",
                "            && !cms->d.envelopedData->encryptedContentInfo->debug) {",
                "        X509_ALGOR *calg = ec->contentEncryptionAlgorithm;",
                "        const EVP_CIPHER *ciph = EVP_get_cipherbyobj(calg->algorithm);",
                "",
                "        if (ciph == NULL) {",
                "            CMSerr(CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT, CMS_R_UNKNOWN_CIPHER);",
                "            return 0;",
                "        }",
                "",
                "        fixlen = EVP_CIPHER_key_length(ciph);",
                "                         ktri->encryptedKey->length) <= 0",
                "            || eklen == 0",
                "            || (fixlen != 0 && eklen != fixlen)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-1563",
        "func_name": "openssl/CMS_decrypt",
        "description": "In situations where an attacker receives automated notification of the success or failure of a decryption attempt an attacker, after sending a very large number of messages to be decrypted, can recover a CMS/PKCS7 transported encryption key or decrypt any RSA encrypted message that was encrypted with the public RSA key, using a Bleichenbacher padding oracle attack. Applications are not affected if they use a certificate together with the private RSA key to the CMS_decrypt or PKCS7_decrypt functions to select the correct recipient info to decrypt. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). Fixed in OpenSSL 1.1.0l (Affected 1.1.0-1.1.0k). Fixed in OpenSSL 1.0.2t (Affected 1.0.2-1.0.2s).",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=631f94db0065c78181ca9ba5546ebc8bb3884b97",
        "commit_title": "",
        "commit_text": "Fix a padding oracle in PKCS7_dataDecode and CMS_decrypt_set1_pkey  An attack is simple, if the first CMS_recipientInfo is valid but the second CMS_recipientInfo is chosen ciphertext. If the second recipientInfo decodes to PKCS #1 v1.5 form plaintext, the correct encryption key will be replaced by garbage, and the message cannot be decoded, but if the RSA decryption fails, the correct encryption key is used and the recipient will not notice the attack.  As a work around for this potential attack the length of the decrypted key must be equal to the cipher default key length, in case the certifiate is not given and all recipientInfo are tried out.  The old behaviour can be re-enabled in the CMS code by setting the CMS_DEBUG_DECRYPT flag.  (Merged from https://github.com/openssl/openssl/pull/9777)  (cherry picked from commit 5840ed0cd1e6487d247efbc1a04136a41d7b3a37) ",
        "func_before": "int CMS_decrypt(CMS_ContentInfo *cms, EVP_PKEY *pk, X509 *cert,\n                BIO *dcont, BIO *out, unsigned int flags)\n{\n    int r;\n    BIO *cont;\n    if (OBJ_obj2nid(CMS_get0_type(cms)) != NID_pkcs7_enveloped) {\n        CMSerr(CMS_F_CMS_DECRYPT, CMS_R_TYPE_NOT_ENVELOPED_DATA);\n        return 0;\n    }\n    if (!dcont && !check_content(cms))\n        return 0;\n    if (flags & CMS_DEBUG_DECRYPT)\n        cms->d.envelopedData->encryptedContentInfo->debug = 1;\n    else\n        cms->d.envelopedData->encryptedContentInfo->debug = 0;\n    if (!pk && !cert && !dcont && !out)\n        return 1;\n    if (pk && !CMS_decrypt_set1_pkey(cms, pk, cert))\n        return 0;\n    cont = CMS_dataInit(cms, dcont);\n    if (!cont)\n        return 0;\n    r = cms_copy_content(out, cont, flags);\n    do_free_upto(cont, dcont);\n    return r;\n}",
        "func": "int CMS_decrypt(CMS_ContentInfo *cms, EVP_PKEY *pk, X509 *cert,\n                BIO *dcont, BIO *out, unsigned int flags)\n{\n    int r;\n    BIO *cont;\n    if (OBJ_obj2nid(CMS_get0_type(cms)) != NID_pkcs7_enveloped) {\n        CMSerr(CMS_F_CMS_DECRYPT, CMS_R_TYPE_NOT_ENVELOPED_DATA);\n        return 0;\n    }\n    if (!dcont && !check_content(cms))\n        return 0;\n    if (flags & CMS_DEBUG_DECRYPT)\n        cms->d.envelopedData->encryptedContentInfo->debug = 1;\n    else\n        cms->d.envelopedData->encryptedContentInfo->debug = 0;\n    if (!cert)\n        cms->d.envelopedData->encryptedContentInfo->havenocert = 1;\n    else\n        cms->d.envelopedData->encryptedContentInfo->havenocert = 0;\n    if (!pk && !cert && !dcont && !out)\n        return 1;\n    if (pk && !CMS_decrypt_set1_pkey(cms, pk, cert))\n        return 0;\n    cont = CMS_dataInit(cms, dcont);\n    if (!cont)\n        return 0;\n    r = cms_copy_content(out, cont, flags);\n    do_free_upto(cont, dcont);\n    return r;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,10 @@\n         cms->d.envelopedData->encryptedContentInfo->debug = 1;\n     else\n         cms->d.envelopedData->encryptedContentInfo->debug = 0;\n+    if (!cert)\n+        cms->d.envelopedData->encryptedContentInfo->havenocert = 1;\n+    else\n+        cms->d.envelopedData->encryptedContentInfo->havenocert = 0;\n     if (!pk && !cert && !dcont && !out)\n         return 1;\n     if (pk && !CMS_decrypt_set1_pkey(cms, pk, cert))",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (!cert)",
                "        cms->d.envelopedData->encryptedContentInfo->havenocert = 1;",
                "    else",
                "        cms->d.envelopedData->encryptedContentInfo->havenocert = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-1563",
        "func_name": "openssl/pkcs7_decrypt_rinfo",
        "description": "In situations where an attacker receives automated notification of the success or failure of a decryption attempt an attacker, after sending a very large number of messages to be decrypted, can recover a CMS/PKCS7 transported encryption key or decrypt any RSA encrypted message that was encrypted with the public RSA key, using a Bleichenbacher padding oracle attack. Applications are not affected if they use a certificate together with the private RSA key to the CMS_decrypt or PKCS7_decrypt functions to select the correct recipient info to decrypt. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). Fixed in OpenSSL 1.1.0l (Affected 1.1.0-1.1.0k). Fixed in OpenSSL 1.0.2t (Affected 1.0.2-1.0.2s).",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=631f94db0065c78181ca9ba5546ebc8bb3884b97",
        "commit_title": "",
        "commit_text": "Fix a padding oracle in PKCS7_dataDecode and CMS_decrypt_set1_pkey  An attack is simple, if the first CMS_recipientInfo is valid but the second CMS_recipientInfo is chosen ciphertext. If the second recipientInfo decodes to PKCS #1 v1.5 form plaintext, the correct encryption key will be replaced by garbage, and the message cannot be decoded, but if the RSA decryption fails, the correct encryption key is used and the recipient will not notice the attack.  As a work around for this potential attack the length of the decrypted key must be equal to the cipher default key length, in case the certifiate is not given and all recipientInfo are tried out.  The old behaviour can be re-enabled in the CMS code by setting the CMS_DEBUG_DECRYPT flag.  (Merged from https://github.com/openssl/openssl/pull/9777)  (cherry picked from commit 5840ed0cd1e6487d247efbc1a04136a41d7b3a37) ",
        "func_before": "static int pkcs7_decrypt_rinfo(unsigned char **pek, int *peklen,\n                               PKCS7_RECIP_INFO *ri, EVP_PKEY *pkey)\n{\n    EVP_PKEY_CTX *pctx = NULL;\n    unsigned char *ek = NULL;\n    size_t eklen;\n\n    int ret = -1;\n\n    pctx = EVP_PKEY_CTX_new(pkey, NULL);\n    if (!pctx)\n        return -1;\n\n    if (EVP_PKEY_decrypt_init(pctx) <= 0)\n        goto err;\n\n    if (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_DECRYPT,\n                          EVP_PKEY_CTRL_PKCS7_DECRYPT, 0, ri) <= 0) {\n        PKCS7err(PKCS7_F_PKCS7_DECRYPT_RINFO, PKCS7_R_CTRL_ERROR);\n        goto err;\n    }\n\n    if (EVP_PKEY_decrypt(pctx, NULL, &eklen,\n                         ri->enc_key->data, ri->enc_key->length) <= 0)\n        goto err;\n\n    ek = OPENSSL_malloc(eklen);\n\n    if (ek == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DECRYPT_RINFO, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (EVP_PKEY_decrypt(pctx, ek, &eklen,\n                         ri->enc_key->data, ri->enc_key->length) <= 0) {\n        ret = 0;\n        PKCS7err(PKCS7_F_PKCS7_DECRYPT_RINFO, ERR_R_EVP_LIB);\n        goto err;\n    }\n\n    ret = 1;\n\n    OPENSSL_clear_free(*pek, *peklen);\n    *pek = ek;\n    *peklen = eklen;\n\n err:\n    EVP_PKEY_CTX_free(pctx);\n    if (!ret)\n        OPENSSL_free(ek);\n\n    return ret;\n}",
        "func": "static int pkcs7_decrypt_rinfo(unsigned char **pek, int *peklen,\n                               PKCS7_RECIP_INFO *ri, EVP_PKEY *pkey,\n                               size_t fixlen)\n{\n    EVP_PKEY_CTX *pctx = NULL;\n    unsigned char *ek = NULL;\n    size_t eklen;\n\n    int ret = -1;\n\n    pctx = EVP_PKEY_CTX_new(pkey, NULL);\n    if (!pctx)\n        return -1;\n\n    if (EVP_PKEY_decrypt_init(pctx) <= 0)\n        goto err;\n\n    if (EVP_PKEY_CTX_ctrl(pctx, -1, EVP_PKEY_OP_DECRYPT,\n                          EVP_PKEY_CTRL_PKCS7_DECRYPT, 0, ri) <= 0) {\n        PKCS7err(PKCS7_F_PKCS7_DECRYPT_RINFO, PKCS7_R_CTRL_ERROR);\n        goto err;\n    }\n\n    if (EVP_PKEY_decrypt(pctx, NULL, &eklen,\n                         ri->enc_key->data, ri->enc_key->length) <= 0)\n        goto err;\n\n    ek = OPENSSL_malloc(eklen);\n\n    if (ek == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DECRYPT_RINFO, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n\n    if (EVP_PKEY_decrypt(pctx, ek, &eklen,\n                         ri->enc_key->data, ri->enc_key->length) <= 0\n            || eklen == 0\n            || (fixlen != 0 && eklen != fixlen)) {\n        ret = 0;\n        PKCS7err(PKCS7_F_PKCS7_DECRYPT_RINFO, ERR_R_EVP_LIB);\n        goto err;\n    }\n\n    ret = 1;\n\n    OPENSSL_clear_free(*pek, *peklen);\n    *pek = ek;\n    *peklen = eklen;\n\n err:\n    EVP_PKEY_CTX_free(pctx);\n    if (!ret)\n        OPENSSL_free(ek);\n\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n static int pkcs7_decrypt_rinfo(unsigned char **pek, int *peklen,\n-                               PKCS7_RECIP_INFO *ri, EVP_PKEY *pkey)\n+                               PKCS7_RECIP_INFO *ri, EVP_PKEY *pkey,\n+                               size_t fixlen)\n {\n     EVP_PKEY_CTX *pctx = NULL;\n     unsigned char *ek = NULL;\n@@ -32,7 +33,9 @@\n     }\n \n     if (EVP_PKEY_decrypt(pctx, ek, &eklen,\n-                         ri->enc_key->data, ri->enc_key->length) <= 0) {\n+                         ri->enc_key->data, ri->enc_key->length) <= 0\n+            || eklen == 0\n+            || (fixlen != 0 && eklen != fixlen)) {\n         ret = 0;\n         PKCS7err(PKCS7_F_PKCS7_DECRYPT_RINFO, ERR_R_EVP_LIB);\n         goto err;",
        "diff_line_info": {
            "deleted_lines": [
                "                               PKCS7_RECIP_INFO *ri, EVP_PKEY *pkey)",
                "                         ri->enc_key->data, ri->enc_key->length) <= 0) {"
            ],
            "added_lines": [
                "                               PKCS7_RECIP_INFO *ri, EVP_PKEY *pkey,",
                "                               size_t fixlen)",
                "                         ri->enc_key->data, ri->enc_key->length) <= 0",
                "            || eklen == 0",
                "            || (fixlen != 0 && eklen != fixlen)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-1563",
        "func_name": "openssl/PKCS7_dataDecode",
        "description": "In situations where an attacker receives automated notification of the success or failure of a decryption attempt an attacker, after sending a very large number of messages to be decrypted, can recover a CMS/PKCS7 transported encryption key or decrypt any RSA encrypted message that was encrypted with the public RSA key, using a Bleichenbacher padding oracle attack. Applications are not affected if they use a certificate together with the private RSA key to the CMS_decrypt or PKCS7_decrypt functions to select the correct recipient info to decrypt. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c). Fixed in OpenSSL 1.1.0l (Affected 1.1.0-1.1.0k). Fixed in OpenSSL 1.0.2t (Affected 1.0.2-1.0.2s).",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=631f94db0065c78181ca9ba5546ebc8bb3884b97",
        "commit_title": "",
        "commit_text": "Fix a padding oracle in PKCS7_dataDecode and CMS_decrypt_set1_pkey  An attack is simple, if the first CMS_recipientInfo is valid but the second CMS_recipientInfo is chosen ciphertext. If the second recipientInfo decodes to PKCS #1 v1.5 form plaintext, the correct encryption key will be replaced by garbage, and the message cannot be decoded, but if the RSA decryption fails, the correct encryption key is used and the recipient will not notice the attack.  As a work around for this potential attack the length of the decrypted key must be equal to the cipher default key length, in case the certifiate is not given and all recipientInfo are tried out.  The old behaviour can be re-enabled in the CMS code by setting the CMS_DEBUG_DECRYPT flag.  (Merged from https://github.com/openssl/openssl/pull/9777)  (cherry picked from commit 5840ed0cd1e6487d247efbc1a04136a41d7b3a37) ",
        "func_before": "BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)\n{\n    int i, j;\n    BIO *out = NULL, *btmp = NULL, *etmp = NULL, *bio = NULL;\n    X509_ALGOR *xa;\n    ASN1_OCTET_STRING *data_body = NULL;\n    const EVP_MD *evp_md;\n    const EVP_CIPHER *evp_cipher = NULL;\n    EVP_CIPHER_CTX *evp_ctx = NULL;\n    X509_ALGOR *enc_alg = NULL;\n    STACK_OF(X509_ALGOR) *md_sk = NULL;\n    STACK_OF(PKCS7_RECIP_INFO) *rsk = NULL;\n    PKCS7_RECIP_INFO *ri = NULL;\n    unsigned char *ek = NULL, *tkey = NULL;\n    int eklen = 0, tkeylen = 0;\n\n    if (p7 == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_INVALID_NULL_POINTER);\n        return NULL;\n    }\n\n    if (p7->d.ptr == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_CONTENT);\n        return NULL;\n    }\n\n    i = OBJ_obj2nid(p7->type);\n    p7->state = PKCS7_S_HEADER;\n\n    switch (i) {\n    case NID_pkcs7_signed:\n        /*\n         * p7->d.sign->contents is a PKCS7 structure consisting of a contentType\n         * field and optional content.\n         * data_body is NULL if that structure has no (=detached) content\n         * or if the contentType is wrong (i.e., not \"data\").\n         */\n        data_body = PKCS7_get_octet_string(p7->d.sign->contents);\n        if (!PKCS7_is_detached(p7) && data_body == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_INVALID_SIGNED_DATA_TYPE);\n            goto err;\n        }\n        md_sk = p7->d.sign->md_algs;\n        break;\n    case NID_pkcs7_signedAndEnveloped:\n        rsk = p7->d.signed_and_enveloped->recipientinfo;\n        md_sk = p7->d.signed_and_enveloped->md_algs;\n        /* data_body is NULL if the optional EncryptedContent is missing. */\n        data_body = p7->d.signed_and_enveloped->enc_data->enc_data;\n        enc_alg = p7->d.signed_and_enveloped->enc_data->algorithm;\n        evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);\n        if (evp_cipher == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_UNSUPPORTED_CIPHER_TYPE);\n            goto err;\n        }\n        break;\n    case NID_pkcs7_enveloped:\n        rsk = p7->d.enveloped->recipientinfo;\n        enc_alg = p7->d.enveloped->enc_data->algorithm;\n        /* data_body is NULL if the optional EncryptedContent is missing. */\n        data_body = p7->d.enveloped->enc_data->enc_data;\n        evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);\n        if (evp_cipher == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_UNSUPPORTED_CIPHER_TYPE);\n            goto err;\n        }\n        break;\n    default:\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);\n        goto err;\n    }\n\n    /* Detached content must be supplied via in_bio instead. */\n    if (data_body == NULL && in_bio == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_CONTENT);\n        goto err;\n    }\n\n    /* We will be checking the signature */\n    if (md_sk != NULL) {\n        for (i = 0; i < sk_X509_ALGOR_num(md_sk); i++) {\n            xa = sk_X509_ALGOR_value(md_sk, i);\n            if ((btmp = BIO_new(BIO_f_md())) == NULL) {\n                PKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_BIO_LIB);\n                goto err;\n            }\n\n            j = OBJ_obj2nid(xa->algorithm);\n            evp_md = EVP_get_digestbynid(j);\n            if (evp_md == NULL) {\n                PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                         PKCS7_R_UNKNOWN_DIGEST_TYPE);\n                goto err;\n            }\n\n            BIO_set_md(btmp, evp_md);\n            if (out == NULL)\n                out = btmp;\n            else\n                BIO_push(out, btmp);\n            btmp = NULL;\n        }\n    }\n\n    if (evp_cipher != NULL) {\n        if ((etmp = BIO_new(BIO_f_cipher())) == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_BIO_LIB);\n            goto err;\n        }\n\n        /*\n         * It was encrypted, we need to decrypt the secret key with the\n         * private key\n         */\n\n        /*\n         * Find the recipientInfo which matches the passed certificate (if\n         * any)\n         */\n\n        if (pcert) {\n            for (i = 0; i < sk_PKCS7_RECIP_INFO_num(rsk); i++) {\n                ri = sk_PKCS7_RECIP_INFO_value(rsk, i);\n                if (!pkcs7_cmp_ri(ri, pcert))\n                    break;\n                ri = NULL;\n            }\n            if (ri == NULL) {\n                PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                         PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE);\n                goto err;\n            }\n        }\n\n        /* If we haven't got a certificate try each ri in turn */\n        if (pcert == NULL) {\n            /*\n             * Always attempt to decrypt all rinfo even after success as a\n             * defence against MMA timing attacks.\n             */\n            for (i = 0; i < sk_PKCS7_RECIP_INFO_num(rsk); i++) {\n                ri = sk_PKCS7_RECIP_INFO_value(rsk, i);\n\n                if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey) < 0)\n                    goto err;\n                ERR_clear_error();\n            }\n        } else {\n            /* Only exit on fatal errors, not decrypt failure */\n            if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey) < 0)\n                goto err;\n            ERR_clear_error();\n        }\n\n        evp_ctx = NULL;\n        BIO_get_cipher_ctx(etmp, &evp_ctx);\n        if (EVP_CipherInit_ex(evp_ctx, evp_cipher, NULL, NULL, NULL, 0) <= 0)\n            goto err;\n        if (EVP_CIPHER_asn1_to_param(evp_ctx, enc_alg->parameter) < 0)\n            goto err;\n        /* Generate random key as MMA defence */\n        tkeylen = EVP_CIPHER_CTX_key_length(evp_ctx);\n        tkey = OPENSSL_malloc(tkeylen);\n        if (tkey == NULL)\n            goto err;\n        if (EVP_CIPHER_CTX_rand_key(evp_ctx, tkey) <= 0)\n            goto err;\n        if (ek == NULL) {\n            ek = tkey;\n            eklen = tkeylen;\n            tkey = NULL;\n        }\n\n        if (eklen != EVP_CIPHER_CTX_key_length(evp_ctx)) {\n            /*\n             * Some S/MIME clients don't use the same key and effective key\n             * length. The key length is determined by the size of the\n             * decrypted RSA key.\n             */\n            if (!EVP_CIPHER_CTX_set_key_length(evp_ctx, eklen)) {\n                /* Use random key as MMA defence */\n                OPENSSL_clear_free(ek, eklen);\n                ek = tkey;\n                eklen = tkeylen;\n                tkey = NULL;\n            }\n        }\n        /* Clear errors so we don't leak information useful in MMA */\n        ERR_clear_error();\n        if (EVP_CipherInit_ex(evp_ctx, NULL, NULL, ek, NULL, 0) <= 0)\n            goto err;\n\n        OPENSSL_clear_free(ek, eklen);\n        ek = NULL;\n        OPENSSL_clear_free(tkey, tkeylen);\n        tkey = NULL;\n\n        if (out == NULL)\n            out = etmp;\n        else\n            BIO_push(out, etmp);\n        etmp = NULL;\n    }\n    if (in_bio != NULL) {\n        bio = in_bio;\n    } else {\n        if (data_body->length > 0)\n            bio = BIO_new_mem_buf(data_body->data, data_body->length);\n        else {\n            bio = BIO_new(BIO_s_mem());\n            if (bio == NULL)\n                goto err;\n            BIO_set_mem_eof_return(bio, 0);\n        }\n        if (bio == NULL)\n            goto err;\n    }\n    BIO_push(out, bio);\n    bio = NULL;\n    return out;\n\n err:\n    OPENSSL_clear_free(ek, eklen);\n    OPENSSL_clear_free(tkey, tkeylen);\n    BIO_free_all(out);\n    BIO_free_all(btmp);\n    BIO_free_all(etmp);\n    BIO_free_all(bio);\n    return NULL;\n}",
        "func": "BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert)\n{\n    int i, j;\n    BIO *out = NULL, *btmp = NULL, *etmp = NULL, *bio = NULL;\n    X509_ALGOR *xa;\n    ASN1_OCTET_STRING *data_body = NULL;\n    const EVP_MD *evp_md;\n    const EVP_CIPHER *evp_cipher = NULL;\n    EVP_CIPHER_CTX *evp_ctx = NULL;\n    X509_ALGOR *enc_alg = NULL;\n    STACK_OF(X509_ALGOR) *md_sk = NULL;\n    STACK_OF(PKCS7_RECIP_INFO) *rsk = NULL;\n    PKCS7_RECIP_INFO *ri = NULL;\n    unsigned char *ek = NULL, *tkey = NULL;\n    int eklen = 0, tkeylen = 0;\n\n    if (p7 == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_INVALID_NULL_POINTER);\n        return NULL;\n    }\n\n    if (p7->d.ptr == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_CONTENT);\n        return NULL;\n    }\n\n    i = OBJ_obj2nid(p7->type);\n    p7->state = PKCS7_S_HEADER;\n\n    switch (i) {\n    case NID_pkcs7_signed:\n        /*\n         * p7->d.sign->contents is a PKCS7 structure consisting of a contentType\n         * field and optional content.\n         * data_body is NULL if that structure has no (=detached) content\n         * or if the contentType is wrong (i.e., not \"data\").\n         */\n        data_body = PKCS7_get_octet_string(p7->d.sign->contents);\n        if (!PKCS7_is_detached(p7) && data_body == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_INVALID_SIGNED_DATA_TYPE);\n            goto err;\n        }\n        md_sk = p7->d.sign->md_algs;\n        break;\n    case NID_pkcs7_signedAndEnveloped:\n        rsk = p7->d.signed_and_enveloped->recipientinfo;\n        md_sk = p7->d.signed_and_enveloped->md_algs;\n        /* data_body is NULL if the optional EncryptedContent is missing. */\n        data_body = p7->d.signed_and_enveloped->enc_data->enc_data;\n        enc_alg = p7->d.signed_and_enveloped->enc_data->algorithm;\n        evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);\n        if (evp_cipher == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_UNSUPPORTED_CIPHER_TYPE);\n            goto err;\n        }\n        break;\n    case NID_pkcs7_enveloped:\n        rsk = p7->d.enveloped->recipientinfo;\n        enc_alg = p7->d.enveloped->enc_data->algorithm;\n        /* data_body is NULL if the optional EncryptedContent is missing. */\n        data_body = p7->d.enveloped->enc_data->enc_data;\n        evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);\n        if (evp_cipher == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_UNSUPPORTED_CIPHER_TYPE);\n            goto err;\n        }\n        break;\n    default:\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);\n        goto err;\n    }\n\n    /* Detached content must be supplied via in_bio instead. */\n    if (data_body == NULL && in_bio == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_CONTENT);\n        goto err;\n    }\n\n    /* We will be checking the signature */\n    if (md_sk != NULL) {\n        for (i = 0; i < sk_X509_ALGOR_num(md_sk); i++) {\n            xa = sk_X509_ALGOR_value(md_sk, i);\n            if ((btmp = BIO_new(BIO_f_md())) == NULL) {\n                PKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_BIO_LIB);\n                goto err;\n            }\n\n            j = OBJ_obj2nid(xa->algorithm);\n            evp_md = EVP_get_digestbynid(j);\n            if (evp_md == NULL) {\n                PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                         PKCS7_R_UNKNOWN_DIGEST_TYPE);\n                goto err;\n            }\n\n            BIO_set_md(btmp, evp_md);\n            if (out == NULL)\n                out = btmp;\n            else\n                BIO_push(out, btmp);\n            btmp = NULL;\n        }\n    }\n\n    if (evp_cipher != NULL) {\n        if ((etmp = BIO_new(BIO_f_cipher())) == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_BIO_LIB);\n            goto err;\n        }\n\n        /*\n         * It was encrypted, we need to decrypt the secret key with the\n         * private key\n         */\n\n        /*\n         * Find the recipientInfo which matches the passed certificate (if\n         * any)\n         */\n\n        if (pcert) {\n            for (i = 0; i < sk_PKCS7_RECIP_INFO_num(rsk); i++) {\n                ri = sk_PKCS7_RECIP_INFO_value(rsk, i);\n                if (!pkcs7_cmp_ri(ri, pcert))\n                    break;\n                ri = NULL;\n            }\n            if (ri == NULL) {\n                PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                         PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE);\n                goto err;\n            }\n        }\n\n        /* If we haven't got a certificate try each ri in turn */\n        if (pcert == NULL) {\n            /*\n             * Always attempt to decrypt all rinfo even after success as a\n             * defence against MMA timing attacks.\n             */\n            for (i = 0; i < sk_PKCS7_RECIP_INFO_num(rsk); i++) {\n                ri = sk_PKCS7_RECIP_INFO_value(rsk, i);\n\n                if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey,\n                        EVP_CIPHER_key_length(evp_cipher)) < 0)\n                    goto err;\n                ERR_clear_error();\n            }\n        } else {\n            /* Only exit on fatal errors, not decrypt failure */\n            if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey, 0) < 0)\n                goto err;\n            ERR_clear_error();\n        }\n\n        evp_ctx = NULL;\n        BIO_get_cipher_ctx(etmp, &evp_ctx);\n        if (EVP_CipherInit_ex(evp_ctx, evp_cipher, NULL, NULL, NULL, 0) <= 0)\n            goto err;\n        if (EVP_CIPHER_asn1_to_param(evp_ctx, enc_alg->parameter) < 0)\n            goto err;\n        /* Generate random key as MMA defence */\n        tkeylen = EVP_CIPHER_CTX_key_length(evp_ctx);\n        tkey = OPENSSL_malloc(tkeylen);\n        if (tkey == NULL)\n            goto err;\n        if (EVP_CIPHER_CTX_rand_key(evp_ctx, tkey) <= 0)\n            goto err;\n        if (ek == NULL) {\n            ek = tkey;\n            eklen = tkeylen;\n            tkey = NULL;\n        }\n\n        if (eklen != EVP_CIPHER_CTX_key_length(evp_ctx)) {\n            /*\n             * Some S/MIME clients don't use the same key and effective key\n             * length. The key length is determined by the size of the\n             * decrypted RSA key.\n             */\n            if (!EVP_CIPHER_CTX_set_key_length(evp_ctx, eklen)) {\n                /* Use random key as MMA defence */\n                OPENSSL_clear_free(ek, eklen);\n                ek = tkey;\n                eklen = tkeylen;\n                tkey = NULL;\n            }\n        }\n        /* Clear errors so we don't leak information useful in MMA */\n        ERR_clear_error();\n        if (EVP_CipherInit_ex(evp_ctx, NULL, NULL, ek, NULL, 0) <= 0)\n            goto err;\n\n        OPENSSL_clear_free(ek, eklen);\n        ek = NULL;\n        OPENSSL_clear_free(tkey, tkeylen);\n        tkey = NULL;\n\n        if (out == NULL)\n            out = etmp;\n        else\n            BIO_push(out, etmp);\n        etmp = NULL;\n    }\n    if (in_bio != NULL) {\n        bio = in_bio;\n    } else {\n        if (data_body->length > 0)\n            bio = BIO_new_mem_buf(data_body->data, data_body->length);\n        else {\n            bio = BIO_new(BIO_s_mem());\n            if (bio == NULL)\n                goto err;\n            BIO_set_mem_eof_return(bio, 0);\n        }\n        if (bio == NULL)\n            goto err;\n    }\n    BIO_push(out, bio);\n    bio = NULL;\n    return out;\n\n err:\n    OPENSSL_clear_free(ek, eklen);\n    OPENSSL_clear_free(tkey, tkeylen);\n    BIO_free_all(out);\n    BIO_free_all(btmp);\n    BIO_free_all(etmp);\n    BIO_free_all(bio);\n    return NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -144,13 +144,14 @@\n             for (i = 0; i < sk_PKCS7_RECIP_INFO_num(rsk); i++) {\n                 ri = sk_PKCS7_RECIP_INFO_value(rsk, i);\n \n-                if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey) < 0)\n+                if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey,\n+                        EVP_CIPHER_key_length(evp_cipher)) < 0)\n                     goto err;\n                 ERR_clear_error();\n             }\n         } else {\n             /* Only exit on fatal errors, not decrypt failure */\n-            if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey) < 0)\n+            if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey, 0) < 0)\n                 goto err;\n             ERR_clear_error();\n         }",
        "diff_line_info": {
            "deleted_lines": [
                "                if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey) < 0)",
                "            if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey) < 0)"
            ],
            "added_lines": [
                "                if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey,",
                "                        EVP_CIPHER_key_length(evp_cipher)) < 0)",
                "            if (pkcs7_decrypt_rinfo(&ek, &eklen, ri, pkey, 0) < 0)"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-38493",
        "func_name": "babelouest/rhonabwy/rsa_oaep_sha1_decrypt",
        "description": "Rhonabwy 0.9.99 through 1.1.x before 1.1.7 doesn't check the RSA private key length before RSA-OAEP decryption. This allows attackers to cause a Denial of Service via a crafted JWE (JSON Web Encryption) token.",
        "git_url": "https://github.com/babelouest/rhonabwy/commit/dd528b3aabd13863f855a68e76966e4e019fc399",
        "commit_title": "Fix rsa oaep key length check before decryption",
        "commit_text": "",
        "func_before": "int\nrsa_oaep_sha1_decrypt(const struct rsa_private_key *key,\n\t    size_t label_length, const uint8_t *label,\n\t    size_t *length, uint8_t *message,\n\t    const mpz_t gibberish)\n{\n  mpz_t m;\n  int res;\n  struct sha1_ctx ctx;\n\n  mpz_init(m);\n  rsa_compute_root(key, m, gibberish);\n\n  res = pkcs1_oaep_decrypt (key->size, m, SHA1_DIGEST_SIZE,\n                            &ctx, &nettle_sha1, (nettle_hash_init_func*)&sha1_init, (nettle_hash_update_func*)&sha1_update, (nettle_hash_digest_func*)&sha1_digest,\n                            label_length, label, length, message);\n  mpz_clear(m);\n  return res;\n}",
        "func": "int\nrsa_oaep_sha1_decrypt(const struct rsa_private_key *key,\n\t    size_t label_length, const uint8_t *label,\n\t    size_t *length, uint8_t *message,\n\t    const mpz_t gibberish)\n{\n  mpz_t m;\n  int res;\n  struct sha1_ctx ctx;\n\n  if (nettle_mpz_sizeinbase_256_u (gibberish) > key->size ||\n      key->size < (2*SHA1_DIGEST_SIZE)+2) {\n    return 0;\n  }\n\n  mpz_init(m);\n  rsa_compute_root(key, m, gibberish);\n\n  res = pkcs1_oaep_decrypt (key->size, m, SHA1_DIGEST_SIZE,\n                            &ctx, &nettle_sha1, (nettle_hash_init_func*)&sha1_init, (nettle_hash_update_func*)&sha1_update, (nettle_hash_digest_func*)&sha1_digest,\n                            label_length, label, length, message);\n  mpz_clear(m);\n  return res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,11 @@\n   int res;\n   struct sha1_ctx ctx;\n \n+  if (nettle_mpz_sizeinbase_256_u (gibberish) > key->size ||\n+      key->size < (2*SHA1_DIGEST_SIZE)+2) {\n+    return 0;\n+  }\n+\n   mpz_init(m);\n   rsa_compute_root(key, m, gibberish);\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  if (nettle_mpz_sizeinbase_256_u (gibberish) > key->size ||",
                "      key->size < (2*SHA1_DIGEST_SIZE)+2) {",
                "    return 0;",
                "  }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-38493",
        "func_name": "babelouest/rhonabwy/rsa_oaep_sha256_decrypt",
        "description": "Rhonabwy 0.9.99 through 1.1.x before 1.1.7 doesn't check the RSA private key length before RSA-OAEP decryption. This allows attackers to cause a Denial of Service via a crafted JWE (JSON Web Encryption) token.",
        "git_url": "https://github.com/babelouest/rhonabwy/commit/dd528b3aabd13863f855a68e76966e4e019fc399",
        "commit_title": "Fix rsa oaep key length check before decryption",
        "commit_text": "",
        "func_before": "int\nrsa_oaep_sha256_decrypt(const struct rsa_private_key *key,\n\t    size_t label_length, const uint8_t *label,\n\t    size_t *length, uint8_t *message,\n\t    const mpz_t gibberish)\n{\n  mpz_t m;\n  int res;\n  struct sha256_ctx ctx;\n\n  mpz_init(m);\n  rsa_compute_root(key, m, gibberish);\n\n  res = pkcs1_oaep_decrypt (key->size, m, SHA256_DIGEST_SIZE,\n                            &ctx, &nettle_sha256, (nettle_hash_init_func*)&sha256_init, (nettle_hash_update_func*)&sha256_update, (nettle_hash_digest_func*)&sha256_digest,\n                            label_length, label, length, message);\n  mpz_clear(m);\n  return res;\n}",
        "func": "int\nrsa_oaep_sha256_decrypt(const struct rsa_private_key *key,\n\t    size_t label_length, const uint8_t *label,\n\t    size_t *length, uint8_t *message,\n\t    const mpz_t gibberish)\n{\n  mpz_t m;\n  int res;\n  struct sha256_ctx ctx;\n\n  if (nettle_mpz_sizeinbase_256_u (gibberish) > key->size ||\n      key->size < (2*SHA1_DIGEST_SIZE)+2) {\n    return 0;\n  }\n\n  mpz_init(m);\n  rsa_compute_root(key, m, gibberish);\n\n  res = pkcs1_oaep_decrypt (key->size, m, SHA256_DIGEST_SIZE,\n                            &ctx, &nettle_sha256, (nettle_hash_init_func*)&sha256_init, (nettle_hash_update_func*)&sha256_update, (nettle_hash_digest_func*)&sha256_digest,\n                            label_length, label, length, message);\n  mpz_clear(m);\n  return res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,11 @@\n   int res;\n   struct sha256_ctx ctx;\n \n+  if (nettle_mpz_sizeinbase_256_u (gibberish) > key->size ||\n+      key->size < (2*SHA1_DIGEST_SIZE)+2) {\n+    return 0;\n+  }\n+\n   mpz_init(m);\n   rsa_compute_root(key, m, gibberish);\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  if (nettle_mpz_sizeinbase_256_u (gibberish) > key->size ||",
                "      key->size < (2*SHA1_DIGEST_SIZE)+2) {",
                "    return 0;",
                "  }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-37464",
        "func_name": "OpenIDC/cjose/_cjose_jwe_decrypt_dat_aes_gcm",
        "description": "OpenIDC/cjose is a C library implementing the Javascript Object Signing and Encryption (JOSE). The AES GCM decryption routine incorrectly uses the Tag length from the actual Authentication Tag provided in the JWE. The spec  says that a fixed length of 16 octets must be applied. Therefore this bug allows an attacker to provide a truncated Authentication Tag and to modify the JWE accordingly. Users should upgrade to a version >= 0.6.2.2. Users unable to upgrade should avoid using AES GCM encryption and replace it with another encryption algorithm (e.g. AES CBC).",
        "git_url": "https://github.com/OpenIDC/cjose/commit/7325e9a5e71e2fc0e350487ecac7d84acdf0ed5e",
        "commit_title": "use fixed authentication tag length of 16 octets in AES GCM decryption",
        "commit_text": " see: https://github.com/cisco/cjose/issues/125 ",
        "func_before": "static bool _cjose_jwe_decrypt_dat_aes_gcm(cjose_jwe_t *jwe, cjose_err *err)\n{\n    EVP_CIPHER_CTX *ctx = NULL;\n\n    // make sure we have an enc header\n    json_t *enc_obj = json_object_get(jwe->hdr, CJOSE_HDR_ENC);\n    if (NULL == enc_obj)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n    const char *enc = json_string_value(enc_obj);\n\n    // get AES GCM cipher\n    const EVP_CIPHER *cipher = NULL;\n\n    if (strcmp(enc, CJOSE_HDR_ENC_A128GCM) == 0)\n        cipher = EVP_aes_128_gcm();\n    if (strcmp(enc, CJOSE_HDR_ENC_A192GCM) == 0)\n        cipher = EVP_aes_192_gcm();\n    if (strcmp(enc, CJOSE_HDR_ENC_A256GCM) == 0)\n        cipher = EVP_aes_256_gcm();\n\n    if (NULL == cipher)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // instantiate and initialize a new openssl cipher context\n    ctx = EVP_CIPHER_CTX_new();\n    if (NULL == ctx)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n    EVP_CIPHER_CTX_init(ctx);\n\n    // initialize context for decryption using AES GCM cipher and CEK and IV\n    if (EVP_DecryptInit_ex(ctx, cipher, NULL, jwe->cek, jwe->enc_iv.raw) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // set the expected GCM-mode authentication tag\n    if (EVP_CIPHER_CTX_ctrl(ctx, CJOSE_EVP_CTRL_GCM_SET_TAG, jwe->enc_auth_tag.raw_len, jwe->enc_auth_tag.raw) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // set GCM mode AAD data (hdr_b64u) by setting \"out\" to NULL\n    int bytes_decrypted = 0;\n    if (EVP_DecryptUpdate(ctx, NULL, &bytes_decrypted, (unsigned char *)jwe->enc_header.b64u, jwe->enc_header.b64u_len) != 1\n        || bytes_decrypted != jwe->enc_header.b64u_len)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // allocate buffer for the plaintext\n    cjose_get_dealloc()(jwe->dat);\n    jwe->dat_len = jwe->enc_ct.raw_len;\n    if (!_cjose_jwe_malloc(jwe->dat_len, false, &jwe->dat, err))\n    {\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // decrypt ciphertext to plaintext buffer\n    if (EVP_DecryptUpdate(ctx, jwe->dat, &bytes_decrypted, jwe->enc_ct.raw, jwe->enc_ct.raw_len) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n    jwe->dat_len = bytes_decrypted;\n\n    // finalize the decryption\n    if (EVP_DecryptFinal_ex(ctx, NULL, &bytes_decrypted) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    EVP_CIPHER_CTX_free(ctx);\n    return true;\n\n_cjose_jwe_decrypt_dat_aes_gcm_fail:\n    if (NULL != ctx)\n    {\n        EVP_CIPHER_CTX_free(ctx);\n    }\n    return false;\n}",
        "func": "static bool _cjose_jwe_decrypt_dat_aes_gcm(cjose_jwe_t *jwe, cjose_err *err)\n{\n    EVP_CIPHER_CTX *ctx = NULL;\n\n    // make sure we have an enc header\n    json_t *enc_obj = json_object_get(jwe->hdr, CJOSE_HDR_ENC);\n    if (NULL == enc_obj)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);\n        return false;\n    }\n    const char *enc = json_string_value(enc_obj);\n\n    // get AES GCM cipher\n    const EVP_CIPHER *cipher = NULL;\n\n    if (strcmp(enc, CJOSE_HDR_ENC_A128GCM) == 0)\n        cipher = EVP_aes_128_gcm();\n    if (strcmp(enc, CJOSE_HDR_ENC_A192GCM) == 0)\n        cipher = EVP_aes_192_gcm();\n    if (strcmp(enc, CJOSE_HDR_ENC_A256GCM) == 0)\n        cipher = EVP_aes_256_gcm();\n\n    if (NULL == cipher)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // instantiate and initialize a new openssl cipher context\n    ctx = EVP_CIPHER_CTX_new();\n    if (NULL == ctx)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n    EVP_CIPHER_CTX_init(ctx);\n\n    // initialize context for decryption using AES GCM cipher and CEK and IV\n    if (EVP_DecryptInit_ex(ctx, cipher, NULL, jwe->cek, jwe->enc_iv.raw) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    if (jwe->enc_auth_tag.raw_len != 16)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // set the expected GCM-mode authentication tag\n    if (EVP_CIPHER_CTX_ctrl(ctx, CJOSE_EVP_CTRL_GCM_SET_TAG, jwe->enc_auth_tag.raw_len, jwe->enc_auth_tag.raw) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // set GCM mode AAD data (hdr_b64u) by setting \"out\" to NULL\n    int bytes_decrypted = 0;\n    if (EVP_DecryptUpdate(ctx, NULL, &bytes_decrypted, (unsigned char *)jwe->enc_header.b64u, jwe->enc_header.b64u_len) != 1\n        || bytes_decrypted != jwe->enc_header.b64u_len)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // allocate buffer for the plaintext\n    cjose_get_dealloc()(jwe->dat);\n    jwe->dat_len = jwe->enc_ct.raw_len;\n    if (!_cjose_jwe_malloc(jwe->dat_len, false, &jwe->dat, err))\n    {\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    // decrypt ciphertext to plaintext buffer\n    if (EVP_DecryptUpdate(ctx, jwe->dat, &bytes_decrypted, jwe->enc_ct.raw, jwe->enc_ct.raw_len) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n    jwe->dat_len = bytes_decrypted;\n\n    // finalize the decryption\n    if (EVP_DecryptFinal_ex(ctx, NULL, &bytes_decrypted) != 1)\n    {\n        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n    }\n\n    EVP_CIPHER_CTX_free(ctx);\n    return true;\n\n_cjose_jwe_decrypt_dat_aes_gcm_fail:\n    if (NULL != ctx)\n    {\n        EVP_CIPHER_CTX_free(ctx);\n    }\n    return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -38,6 +38,12 @@\n \n     // initialize context for decryption using AES GCM cipher and CEK and IV\n     if (EVP_DecryptInit_ex(ctx, cipher, NULL, jwe->cek, jwe->enc_iv.raw) != 1)\n+    {\n+        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n+        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;\n+    }\n+\n+    if (jwe->enc_auth_tag.raw_len != 16)\n     {\n         CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);\n         goto _cjose_jwe_decrypt_dat_aes_gcm_fail;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    {",
                "        CJOSE_ERROR(err, CJOSE_ERR_CRYPTO);",
                "        goto _cjose_jwe_decrypt_dat_aes_gcm_fail;",
                "    }",
                "",
                "    if (jwe->enc_auth_tag.raw_len != 16)"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-5719",
        "func_name": "wireshark/dissect_transform",
        "description": "In Wireshark 2.6.0 to 2.6.5 and 2.4.0 to 2.4.11, the ISAKMP dissector could crash. This was addressed in epan/dissectors/packet-isakmp.c by properly handling the case of a missing decryption data block.",
        "git_url": "https://github.com/wireshark/wireshark/commit/b5b02f2a9b8772d8814096f86c60a32889d61f2c",
        "commit_title": "ISAKMP: Fix a crash when no decryption data block is there",
        "commit_text": " Don't try to (re)set parameters in a struct when its pointer points to NULL.  Bug: 15374 (cherry picked from commit c9cfae7fecd4bc21b8b4f48328d08e104d47dd52)",
        "func_before": "static void\ndissect_transform(tvbuff_t *tvb, packet_info *pinfo, int offset, int length, proto_tree *tree, int isakmp_version, int protocol_id, void* decr_data)\n{\n  if (isakmp_version == 1)\n  {\n    guint8              transform_id;\n    guint8              transform_num;\n    decrypt_data_t *decr = (decrypt_data_t *)decr_data;\n    int offset_end = 0;\n    offset_end = offset + length;\n\n    transform_num = tvb_get_guint8(tvb, offset);\n    proto_item_append_text(tree,\" # %d\",transform_num);\n\n    proto_tree_add_item(tree, hf_isakmp_trans_number, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n\n    transform_id = tvb_get_guint8(tvb, offset);\n    switch (protocol_id) {\n    case 1:     /* ISAKMP */\n      proto_tree_add_uint_format_value(tree, hf_isakmp_trans_id, tvb, offset, 1,\n                                 transform_id, \"%s (%u)\",\n                                 val_to_str_const(transform_id, vs_v1_trans_isakmp, \"UNKNOWN-TRANS-TYPE\"), transform_id);\n      break;\n    case 2:     /* AH */\n      proto_tree_add_uint_format_value(tree, hf_isakmp_trans_id, tvb, offset, 1,\n                                 transform_id, \"%s (%u)\",\n                                 val_to_str_const(transform_id, vs_v1_trans_ah, \"UNKNOWN-AH-TRANS-TYPE\"), transform_id);\n      break;\n    case 3:     /* ESP */\n      proto_tree_add_uint_format_value(tree, hf_isakmp_trans_id, tvb, offset, 1,\n                                 transform_id, \"%s (%u)\",\n                                 val_to_str_const(transform_id, vs_v1_trans_esp, \"UNKNOWN-ESP-TRANS-TYPE\"), transform_id);\n      break;\n    case 4:     /* IPCOMP */\n      proto_tree_add_uint_format_value(tree, hf_isakmp_trans_id, tvb, offset, 1,\n                                 transform_id, \"%s (%u)\",\n                                 val_to_str_const(transform_id, transform_id_ipcomp, \"UNKNOWN-IPCOMP-TRANS-TYPE\"), transform_id);\n      break;\n    default:\n      proto_tree_add_item(tree, hf_isakmp_trans_id, tvb, offset, 1, ENC_BIG_ENDIAN);\n      break;\n    }\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_isakmp_reserved, tvb, offset, 2, ENC_NA);\n    offset += 2;\n\n    if (protocol_id == 1 && transform_id == 1) {\n      /* Allow detection of missing IKE transform attributes:\n       * Make sure their values are not carried over from another transform\n       * dissected previously. */\n      decr->ike_encr_alg = 0;\n      decr->ike_encr_keylen = 0;\n      decr->ike_hash_alg = 0;\n      while (offset < offset_end) {\n        offset += dissect_ike_attribute(tvb, pinfo, tree, offset, decr);\n      }\n    }\n    else {\n       while (offset < offset_end) {\n         offset += dissect_ipsec_attribute(tvb, pinfo, tree, offset);\n       }\n    }\n  }\n  else if(isakmp_version == 2)\n  {\n    guint8 transform_type;\n    int offset_end = 0;\n    offset_end = offset + length;\n\n    transform_type = tvb_get_guint8(tvb, offset);\n    proto_tree_add_item(tree, hf_isakmp_trans_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_isakmp_reserved, tvb, offset, 1, ENC_NA);\n    offset += 1;\n\n    switch(transform_type){\n    case TF_IKE2_ENCR:\n      proto_tree_add_item(tree, hf_isakmp_trans_encr, tvb, offset, 2, ENC_BIG_ENDIAN);\n      break;\n    case TF_IKE2_PRF:\n      proto_tree_add_item(tree, hf_isakmp_trans_prf, tvb, offset, 2, ENC_BIG_ENDIAN);\n      break;\n    case TF_IKE2_INTEG:\n      proto_tree_add_item(tree, hf_isakmp_trans_integ, tvb, offset, 2, ENC_BIG_ENDIAN);\n      break;\n    case TF_IKE2_DH:\n      proto_tree_add_item(tree, hf_isakmp_trans_dh, tvb, offset, 2, ENC_BIG_ENDIAN);\n      break;\n    case TF_IKE2_ESN:\n      proto_tree_add_item(tree, hf_isakmp_trans_esn, tvb, offset, 2, ENC_BIG_ENDIAN);\n      break;\n    default:\n      proto_tree_add_item(tree, hf_isakmp_trans_id_v2, tvb, offset, 2, ENC_BIG_ENDIAN);\n      break;\n    }\n    offset += 2;\n\n    while (offset < offset_end) {\n      offset += dissect_ike2_transform_attribute(tvb, pinfo, tree, offset);\n    }\n  }\n}",
        "func": "static void\ndissect_transform(tvbuff_t *tvb, packet_info *pinfo, int offset, int length, proto_tree *tree, int isakmp_version, int protocol_id, void* decr_data)\n{\n  if (isakmp_version == 1)\n  {\n    guint8              transform_id;\n    guint8              transform_num;\n    decrypt_data_t *decr = (decrypt_data_t *)decr_data;\n    int offset_end = 0;\n    offset_end = offset + length;\n\n    transform_num = tvb_get_guint8(tvb, offset);\n    proto_item_append_text(tree,\" # %d\",transform_num);\n\n    proto_tree_add_item(tree, hf_isakmp_trans_number, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n\n    transform_id = tvb_get_guint8(tvb, offset);\n    switch (protocol_id) {\n    case 1:     /* ISAKMP */\n      proto_tree_add_uint_format_value(tree, hf_isakmp_trans_id, tvb, offset, 1,\n                                 transform_id, \"%s (%u)\",\n                                 val_to_str_const(transform_id, vs_v1_trans_isakmp, \"UNKNOWN-TRANS-TYPE\"), transform_id);\n      break;\n    case 2:     /* AH */\n      proto_tree_add_uint_format_value(tree, hf_isakmp_trans_id, tvb, offset, 1,\n                                 transform_id, \"%s (%u)\",\n                                 val_to_str_const(transform_id, vs_v1_trans_ah, \"UNKNOWN-AH-TRANS-TYPE\"), transform_id);\n      break;\n    case 3:     /* ESP */\n      proto_tree_add_uint_format_value(tree, hf_isakmp_trans_id, tvb, offset, 1,\n                                 transform_id, \"%s (%u)\",\n                                 val_to_str_const(transform_id, vs_v1_trans_esp, \"UNKNOWN-ESP-TRANS-TYPE\"), transform_id);\n      break;\n    case 4:     /* IPCOMP */\n      proto_tree_add_uint_format_value(tree, hf_isakmp_trans_id, tvb, offset, 1,\n                                 transform_id, \"%s (%u)\",\n                                 val_to_str_const(transform_id, transform_id_ipcomp, \"UNKNOWN-IPCOMP-TRANS-TYPE\"), transform_id);\n      break;\n    default:\n      proto_tree_add_item(tree, hf_isakmp_trans_id, tvb, offset, 1, ENC_BIG_ENDIAN);\n      break;\n    }\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_isakmp_reserved, tvb, offset, 2, ENC_NA);\n    offset += 2;\n\n    if (protocol_id == 1 && transform_id == 1) {\n      if (decr) {\n        /* Allow detection of missing IKE transform attributes:\n         * Make sure their values are not carried over from another transform\n         * dissected previously. */\n        decr->ike_encr_alg = 0;\n        decr->ike_encr_keylen = 0;\n        decr->ike_hash_alg = 0;\n      }\n      while (offset < offset_end) {\n        offset += dissect_ike_attribute(tvb, pinfo, tree, offset, decr);\n      }\n    }\n    else {\n       while (offset < offset_end) {\n         offset += dissect_ipsec_attribute(tvb, pinfo, tree, offset);\n       }\n    }\n  }\n  else if(isakmp_version == 2)\n  {\n    guint8 transform_type;\n    int offset_end = 0;\n    offset_end = offset + length;\n\n    transform_type = tvb_get_guint8(tvb, offset);\n    proto_tree_add_item(tree, hf_isakmp_trans_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_isakmp_reserved, tvb, offset, 1, ENC_NA);\n    offset += 1;\n\n    switch(transform_type){\n    case TF_IKE2_ENCR:\n      proto_tree_add_item(tree, hf_isakmp_trans_encr, tvb, offset, 2, ENC_BIG_ENDIAN);\n      break;\n    case TF_IKE2_PRF:\n      proto_tree_add_item(tree, hf_isakmp_trans_prf, tvb, offset, 2, ENC_BIG_ENDIAN);\n      break;\n    case TF_IKE2_INTEG:\n      proto_tree_add_item(tree, hf_isakmp_trans_integ, tvb, offset, 2, ENC_BIG_ENDIAN);\n      break;\n    case TF_IKE2_DH:\n      proto_tree_add_item(tree, hf_isakmp_trans_dh, tvb, offset, 2, ENC_BIG_ENDIAN);\n      break;\n    case TF_IKE2_ESN:\n      proto_tree_add_item(tree, hf_isakmp_trans_esn, tvb, offset, 2, ENC_BIG_ENDIAN);\n      break;\n    default:\n      proto_tree_add_item(tree, hf_isakmp_trans_id_v2, tvb, offset, 2, ENC_BIG_ENDIAN);\n      break;\n    }\n    offset += 2;\n\n    while (offset < offset_end) {\n      offset += dissect_ike2_transform_attribute(tvb, pinfo, tree, offset);\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -47,12 +47,14 @@\n     offset += 2;\n \n     if (protocol_id == 1 && transform_id == 1) {\n-      /* Allow detection of missing IKE transform attributes:\n-       * Make sure their values are not carried over from another transform\n-       * dissected previously. */\n-      decr->ike_encr_alg = 0;\n-      decr->ike_encr_keylen = 0;\n-      decr->ike_hash_alg = 0;\n+      if (decr) {\n+        /* Allow detection of missing IKE transform attributes:\n+         * Make sure their values are not carried over from another transform\n+         * dissected previously. */\n+        decr->ike_encr_alg = 0;\n+        decr->ike_encr_keylen = 0;\n+        decr->ike_hash_alg = 0;\n+      }\n       while (offset < offset_end) {\n         offset += dissect_ike_attribute(tvb, pinfo, tree, offset, decr);\n       }",
        "diff_line_info": {
            "deleted_lines": [
                "      /* Allow detection of missing IKE transform attributes:",
                "       * Make sure their values are not carried over from another transform",
                "       * dissected previously. */",
                "      decr->ike_encr_alg = 0;",
                "      decr->ike_encr_keylen = 0;",
                "      decr->ike_hash_alg = 0;"
            ],
            "added_lines": [
                "      if (decr) {",
                "        /* Allow detection of missing IKE transform attributes:",
                "         * Make sure their values are not carried over from another transform",
                "         * dissected previously. */",
                "        decr->ike_encr_alg = 0;",
                "        decr->ike_encr_keylen = 0;",
                "        decr->ike_hash_alg = 0;",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-5719",
        "func_name": "wireshark/dissect_ike_attribute",
        "description": "In Wireshark 2.6.0 to 2.6.5 and 2.4.0 to 2.4.11, the ISAKMP dissector could crash. This was addressed in epan/dissectors/packet-isakmp.c by properly handling the case of a missing decryption data block.",
        "git_url": "https://github.com/wireshark/wireshark/commit/b5b02f2a9b8772d8814096f86c60a32889d61f2c",
        "commit_title": "ISAKMP: Fix a crash when no decryption data block is there",
        "commit_text": " Don't try to (re)set parameters in a struct when its pointer points to NULL.  Bug: 15374 (cherry picked from commit c9cfae7fecd4bc21b8b4f48328d08e104d47dd52)",
        "func_before": "static int\ndissect_ike_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, decrypt_data_t *decr\n)\n{\n  guint headerlen, value_len, attr_type;\n  proto_item *attr_item;\n  proto_tree *attr_tree;\n\n  dissect_attribute_header(tvb, tree, offset,\n                           hf_isakmp_ike_attr, ike_attr_type,\n                           &headerlen, &value_len, &attr_type,\n                           &attr_item, &attr_tree);\n\n  offset += headerlen;\n\n  if (value_len == 0)\n  {\n    expert_add_info(pinfo, attr_item, &ei_isakmp_attribute_value_empty);\n    return headerlen;\n  }\n\n  switch(attr_type) {\n    case IKE_ATTR_ENCRYPTION_ALGORITHM:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_encryption_algorithm, tvb, offset, value_len, ENC_BIG_ENDIAN);\n      proto_item_append_text(attr_item, \": %s\", val_to_str(tvb_get_ntohs(tvb, offset), ike_attr_enc_algo, \"Unknown %d\"));\n      decr->ike_encr_alg = tvb_get_ntohs(tvb, offset);\n      break;\n    case IKE_ATTR_HASH_ALGORITHM:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_hash_algorithm, tvb, offset, value_len, ENC_BIG_ENDIAN);\n      proto_item_append_text(attr_item, \": %s\", val_to_str(tvb_get_ntohs(tvb, offset), ike_attr_hash_algo, \"Unknown %d\"));\n      decr->ike_hash_alg = tvb_get_ntohs(tvb, offset);\n      break;\n    case IKE_ATTR_AUTHENTICATION_METHOD:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_authentication_method, tvb, offset, value_len, ENC_BIG_ENDIAN);\n      proto_item_append_text(attr_item, \": %s\", val_to_str(tvb_get_ntohs(tvb, offset), ike_attr_authmeth, \"Unknown %d\"));\n      decr->is_psk = tvb_get_ntohs(tvb, offset) == 0x01 ? TRUE : FALSE;\n      break;\n    case IKE_ATTR_GROUP_DESCRIPTION:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_description, tvb, offset, value_len, ENC_BIG_ENDIAN);\n      proto_item_append_text(attr_item, \": %s\", val_to_str(tvb_get_ntohs(tvb, offset), dh_group, \"Unknown %d\"));\n      decr->group = tvb_get_ntohs(tvb, offset);\n      break;\n    case IKE_ATTR_GROUP_TYPE:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_type, tvb, offset, value_len, ENC_BIG_ENDIAN);\n      proto_item_append_text(attr_item, \": %s\", val_to_str(tvb_get_ntohs(tvb, offset), ike_attr_grp_type, \"Unknown %d\"));\n      break;\n    case IKE_ATTR_GROUP_PRIME:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_prime, tvb, offset, value_len, ENC_NA);\n      break;\n    case IKE_ATTR_GROUP_GENERATOR_ONE:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_generator_one, tvb, offset, value_len, ENC_NA);\n      break;\n    case IKE_ATTR_GROUP_GENERATOR_TWO:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_generator_two, tvb, offset, value_len, ENC_NA);\n      break;\n    case IKE_ATTR_GROUP_CURVE_A:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_curve_a, tvb, offset, value_len, ENC_NA);\n      break;\n    case IKE_ATTR_GROUP_CURVE_B:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_curve_b, tvb, offset, value_len, ENC_NA);\n      break;\n    case IKE_ATTR_LIFE_TYPE:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_life_type, tvb, offset, value_len, ENC_BIG_ENDIAN);\n      proto_item_append_text(attr_item, \": %s\", val_to_str(tvb_get_ntohs(tvb, offset), attr_life_type, \"Unknown %d\"));\n      break;\n    case IKE_ATTR_LIFE_DURATION:\n      dissect_life_duration(tvb, attr_tree, attr_item, hf_isakmp_ike_attr_life_duration_uint32, hf_isakmp_ike_attr_life_duration_uint64, hf_isakmp_ike_attr_life_duration_bytes, offset, value_len);\n      break;\n    case IKE_ATTR_PRF:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_prf, tvb, offset, value_len, ENC_NA);\n      break;\n    case IKE_ATTR_KEY_LENGTH:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_key_length, tvb, offset, value_len, ENC_BIG_ENDIAN);\n      proto_item_append_text(attr_item, \": %d\", tvb_get_ntohs(tvb, offset));\n      decr->ike_encr_keylen = tvb_get_ntohs(tvb, offset);\n      break;\n    case IKE_ATTR_FIELD_SIZE:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_field_size, tvb, offset, value_len, ENC_NA);\n      break;\n    case IKE_ATTR_GROUP_ORDER:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_order, tvb, offset, value_len, ENC_NA);\n      break;\n    default:\n      /* No Default Action */\n      break;\n  }\n\n  return headerlen + value_len;\n}",
        "func": "static int\ndissect_ike_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, decrypt_data_t *decr)\n{\n  guint headerlen, value_len, attr_type;\n  proto_item *attr_item;\n  proto_tree *attr_tree;\n\n  dissect_attribute_header(tvb, tree, offset,\n                           hf_isakmp_ike_attr, ike_attr_type,\n                           &headerlen, &value_len, &attr_type,\n                           &attr_item, &attr_tree);\n\n  offset += headerlen;\n\n  if (value_len == 0)\n  {\n    expert_add_info(pinfo, attr_item, &ei_isakmp_attribute_value_empty);\n    return headerlen;\n  }\n\n  switch(attr_type) {\n    case IKE_ATTR_ENCRYPTION_ALGORITHM:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_encryption_algorithm, tvb, offset, value_len, ENC_BIG_ENDIAN);\n      proto_item_append_text(attr_item, \": %s\", val_to_str(tvb_get_ntohs(tvb, offset), ike_attr_enc_algo, \"Unknown %d\"));\n      if (decr) decr->ike_encr_alg = tvb_get_ntohs(tvb, offset);\n      break;\n    case IKE_ATTR_HASH_ALGORITHM:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_hash_algorithm, tvb, offset, value_len, ENC_BIG_ENDIAN);\n      proto_item_append_text(attr_item, \": %s\", val_to_str(tvb_get_ntohs(tvb, offset), ike_attr_hash_algo, \"Unknown %d\"));\n      if (decr) decr->ike_hash_alg = tvb_get_ntohs(tvb, offset);\n      break;\n    case IKE_ATTR_AUTHENTICATION_METHOD:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_authentication_method, tvb, offset, value_len, ENC_BIG_ENDIAN);\n      proto_item_append_text(attr_item, \": %s\", val_to_str(tvb_get_ntohs(tvb, offset), ike_attr_authmeth, \"Unknown %d\"));\n      if (decr) decr->is_psk = tvb_get_ntohs(tvb, offset) == 0x01 ? TRUE : FALSE;\n      break;\n    case IKE_ATTR_GROUP_DESCRIPTION:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_description, tvb, offset, value_len, ENC_BIG_ENDIAN);\n      proto_item_append_text(attr_item, \": %s\", val_to_str(tvb_get_ntohs(tvb, offset), dh_group, \"Unknown %d\"));\n      if (decr) decr->group = tvb_get_ntohs(tvb, offset);\n      break;\n    case IKE_ATTR_GROUP_TYPE:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_type, tvb, offset, value_len, ENC_BIG_ENDIAN);\n      proto_item_append_text(attr_item, \": %s\", val_to_str(tvb_get_ntohs(tvb, offset), ike_attr_grp_type, \"Unknown %d\"));\n      break;\n    case IKE_ATTR_GROUP_PRIME:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_prime, tvb, offset, value_len, ENC_NA);\n      break;\n    case IKE_ATTR_GROUP_GENERATOR_ONE:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_generator_one, tvb, offset, value_len, ENC_NA);\n      break;\n    case IKE_ATTR_GROUP_GENERATOR_TWO:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_generator_two, tvb, offset, value_len, ENC_NA);\n      break;\n    case IKE_ATTR_GROUP_CURVE_A:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_curve_a, tvb, offset, value_len, ENC_NA);\n      break;\n    case IKE_ATTR_GROUP_CURVE_B:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_curve_b, tvb, offset, value_len, ENC_NA);\n      break;\n    case IKE_ATTR_LIFE_TYPE:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_life_type, tvb, offset, value_len, ENC_BIG_ENDIAN);\n      proto_item_append_text(attr_item, \": %s\", val_to_str(tvb_get_ntohs(tvb, offset), attr_life_type, \"Unknown %d\"));\n      break;\n    case IKE_ATTR_LIFE_DURATION:\n      dissect_life_duration(tvb, attr_tree, attr_item, hf_isakmp_ike_attr_life_duration_uint32, hf_isakmp_ike_attr_life_duration_uint64, hf_isakmp_ike_attr_life_duration_bytes, offset, value_len);\n      break;\n    case IKE_ATTR_PRF:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_prf, tvb, offset, value_len, ENC_NA);\n      break;\n    case IKE_ATTR_KEY_LENGTH:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_key_length, tvb, offset, value_len, ENC_BIG_ENDIAN);\n      proto_item_append_text(attr_item, \": %d\", tvb_get_ntohs(tvb, offset));\n      if (decr) decr->ike_encr_keylen = tvb_get_ntohs(tvb, offset);\n      break;\n    case IKE_ATTR_FIELD_SIZE:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_field_size, tvb, offset, value_len, ENC_NA);\n      break;\n    case IKE_ATTR_GROUP_ORDER:\n      proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_order, tvb, offset, value_len, ENC_NA);\n      break;\n    default:\n      /* No Default Action */\n      break;\n  }\n\n  return headerlen + value_len;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,5 @@\n static int\n-dissect_ike_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, decrypt_data_t *decr\n-)\n+dissect_ike_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, decrypt_data_t *decr)\n {\n   guint headerlen, value_len, attr_type;\n   proto_item *attr_item;\n@@ -23,22 +22,22 @@\n     case IKE_ATTR_ENCRYPTION_ALGORITHM:\n       proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_encryption_algorithm, tvb, offset, value_len, ENC_BIG_ENDIAN);\n       proto_item_append_text(attr_item, \": %s\", val_to_str(tvb_get_ntohs(tvb, offset), ike_attr_enc_algo, \"Unknown %d\"));\n-      decr->ike_encr_alg = tvb_get_ntohs(tvb, offset);\n+      if (decr) decr->ike_encr_alg = tvb_get_ntohs(tvb, offset);\n       break;\n     case IKE_ATTR_HASH_ALGORITHM:\n       proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_hash_algorithm, tvb, offset, value_len, ENC_BIG_ENDIAN);\n       proto_item_append_text(attr_item, \": %s\", val_to_str(tvb_get_ntohs(tvb, offset), ike_attr_hash_algo, \"Unknown %d\"));\n-      decr->ike_hash_alg = tvb_get_ntohs(tvb, offset);\n+      if (decr) decr->ike_hash_alg = tvb_get_ntohs(tvb, offset);\n       break;\n     case IKE_ATTR_AUTHENTICATION_METHOD:\n       proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_authentication_method, tvb, offset, value_len, ENC_BIG_ENDIAN);\n       proto_item_append_text(attr_item, \": %s\", val_to_str(tvb_get_ntohs(tvb, offset), ike_attr_authmeth, \"Unknown %d\"));\n-      decr->is_psk = tvb_get_ntohs(tvb, offset) == 0x01 ? TRUE : FALSE;\n+      if (decr) decr->is_psk = tvb_get_ntohs(tvb, offset) == 0x01 ? TRUE : FALSE;\n       break;\n     case IKE_ATTR_GROUP_DESCRIPTION:\n       proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_description, tvb, offset, value_len, ENC_BIG_ENDIAN);\n       proto_item_append_text(attr_item, \": %s\", val_to_str(tvb_get_ntohs(tvb, offset), dh_group, \"Unknown %d\"));\n-      decr->group = tvb_get_ntohs(tvb, offset);\n+      if (decr) decr->group = tvb_get_ntohs(tvb, offset);\n       break;\n     case IKE_ATTR_GROUP_TYPE:\n       proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_group_type, tvb, offset, value_len, ENC_BIG_ENDIAN);\n@@ -72,7 +71,7 @@\n     case IKE_ATTR_KEY_LENGTH:\n       proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_key_length, tvb, offset, value_len, ENC_BIG_ENDIAN);\n       proto_item_append_text(attr_item, \": %d\", tvb_get_ntohs(tvb, offset));\n-      decr->ike_encr_keylen = tvb_get_ntohs(tvb, offset);\n+      if (decr) decr->ike_encr_keylen = tvb_get_ntohs(tvb, offset);\n       break;\n     case IKE_ATTR_FIELD_SIZE:\n       proto_tree_add_item(attr_tree, hf_isakmp_ike_attr_field_size, tvb, offset, value_len, ENC_NA);",
        "diff_line_info": {
            "deleted_lines": [
                "dissect_ike_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, decrypt_data_t *decr",
                ")",
                "      decr->ike_encr_alg = tvb_get_ntohs(tvb, offset);",
                "      decr->ike_hash_alg = tvb_get_ntohs(tvb, offset);",
                "      decr->is_psk = tvb_get_ntohs(tvb, offset) == 0x01 ? TRUE : FALSE;",
                "      decr->group = tvb_get_ntohs(tvb, offset);",
                "      decr->ike_encr_keylen = tvb_get_ntohs(tvb, offset);"
            ],
            "added_lines": [
                "dissect_ike_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, decrypt_data_t *decr)",
                "      if (decr) decr->ike_encr_alg = tvb_get_ntohs(tvb, offset);",
                "      if (decr) decr->ike_hash_alg = tvb_get_ntohs(tvb, offset);",
                "      if (decr) decr->is_psk = tvb_get_ntohs(tvb, offset) == 0x01 ? TRUE : FALSE;",
                "      if (decr) decr->group = tvb_get_ntohs(tvb, offset);",
                "      if (decr) decr->ike_encr_keylen = tvb_get_ntohs(tvb, offset);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-1543",
        "func_name": "openssl/chacha20_poly1305_ctrl",
        "description": "ChaCha20-Poly1305 is an AEAD cipher, and requires a unique nonce input for every encryption operation. RFC 7539 specifies that the nonce value (IV) should be 96 bits (12 bytes). OpenSSL allows a variable nonce length and front pads the nonce with 0 bytes if it is less than 12 bytes. However it also incorrectly allows a nonce to be set of up to 16 bytes. In this case only the last 12 bytes are significant and any additional leading bytes are ignored. It is a requirement of using this cipher that nonce values are unique. Messages encrypted using a reused nonce value are susceptible to serious confidentiality and integrity attacks. If an application changes the default nonce length to be longer than 12 bytes and then makes a change to the leading bytes of the nonce expecting the new value to be a new unique nonce then such an application could inadvertently encrypt messages with a reused nonce. Additionally the ignored bytes in a long nonce are not covered by the integrity guarantee of this cipher. Any application that relies on the integrity of these ignored leading bytes of a long nonce may be further affected. Any OpenSSL internal use of this cipher, including in SSL/TLS, is safe because no such use sets such a long nonce value. However user applications that use this cipher directly and set a non-default nonce length to be longer than 12 bytes may be vulnerable. OpenSSL versions 1.1.1 and 1.1.0 are affected by this issue. Due to the limited scope of affected deployments this has been assessed as low severity and therefore we are not creating new releases at this time. Fixed in OpenSSL 1.1.1c (Affected 1.1.1-1.1.1b). Fixed in OpenSSL 1.1.0k (Affected 1.1.0-1.1.0j).",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=f426625b6ae9a7831010750490a5f0ad689c5ba3",
        "commit_title": "",
        "commit_text": "Prevent over long nonces in ChaCha20-Poly1305  ChaCha20-Poly1305 is an AEAD cipher, and requires a unique nonce input for every encryption operation. RFC 7539 specifies that the nonce value (IV) should be 96 bits (12 bytes). OpenSSL allows a variable nonce length and front pads the nonce with 0 bytes if it is less than 12 bytes. However it also incorrectly allows a nonce to be set of up to 16 bytes. In this case only the last 12 bytes are significant and any additional leading bytes are ignored.  It is a requirement of using this cipher that nonce values are unique. Messages encrypted using a reused nonce value are susceptible to serious confidentiality and integrity attacks. If an application changes the default nonce length to be longer than 12 bytes and then makes a change to the leading bytes of the nonce expecting the new value to be a new unique nonce then such an application could inadvertently encrypt messages with a reused nonce.  Additionally the ignored bytes in a long nonce are not covered by the integrity guarantee of this cipher. Any application that relies on the integrity of these ignored leading bytes of a long nonce may be further affected.  Any OpenSSL internal use of this cipher, including in SSL/TLS, is safe because no such use sets such a long nonce value. However user applications that use this cipher directly and set a non-default nonce length to be longer than 12 bytes may be vulnerable.  CVE-2019-1543  Fixes #8345  (Merged from https://github.com/openssl/openssl/pull/8406)  (cherry picked from commit 2a3d0ee9d59156c48973592331404471aca886d6) ",
        "func_before": "static int chacha20_poly1305_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,\n                                  void *ptr)\n{\n    EVP_CHACHA_AEAD_CTX *actx = aead_data(ctx);\n\n    switch(type) {\n    case EVP_CTRL_INIT:\n        if (actx == NULL)\n            actx = ctx->cipher_data\n                 = OPENSSL_zalloc(sizeof(*actx) + Poly1305_ctx_size());\n        if (actx == NULL) {\n            EVPerr(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_INITIALIZATION_ERROR);\n            return 0;\n        }\n        actx->len.aad = 0;\n        actx->len.text = 0;\n        actx->aad = 0;\n        actx->mac_inited = 0;\n        actx->tag_len = 0;\n        actx->nonce_len = 12;\n        actx->tls_payload_length = NO_TLS_PAYLOAD_LENGTH;\n        memset(actx->tls_aad, 0, POLY1305_BLOCK_SIZE);\n        return 1;\n\n    case EVP_CTRL_COPY:\n        if (actx) {\n            EVP_CIPHER_CTX *dst = (EVP_CIPHER_CTX *)ptr;\n\n            dst->cipher_data =\n                   OPENSSL_memdup(actx, sizeof(*actx) + Poly1305_ctx_size());\n            if (dst->cipher_data == NULL) {\n                EVPerr(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_COPY_ERROR);\n                return 0;\n            }\n        }\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_IVLEN:\n        if (arg <= 0 || arg > CHACHA_CTR_SIZE)\n            return 0;\n        actx->nonce_len = arg;\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_IV_FIXED:\n        if (arg != 12)\n            return 0;\n        actx->nonce[0] = actx->key.counter[1]\n                       = CHACHA_U8TOU32((unsigned char *)ptr);\n        actx->nonce[1] = actx->key.counter[2]\n                       = CHACHA_U8TOU32((unsigned char *)ptr+4);\n        actx->nonce[2] = actx->key.counter[3]\n                       = CHACHA_U8TOU32((unsigned char *)ptr+8);\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_TAG:\n        if (arg <= 0 || arg > POLY1305_BLOCK_SIZE)\n            return 0;\n        if (ptr != NULL) {\n            memcpy(actx->tag, ptr, arg);\n            actx->tag_len = arg;\n        }\n        return 1;\n\n    case EVP_CTRL_AEAD_GET_TAG:\n        if (arg <= 0 || arg > POLY1305_BLOCK_SIZE || !ctx->encrypt)\n            return 0;\n        memcpy(ptr, actx->tag, arg);\n        return 1;\n\n    case EVP_CTRL_AEAD_TLS1_AAD:\n        if (arg != EVP_AEAD_TLS1_AAD_LEN)\n            return 0;\n        {\n            unsigned int len;\n            unsigned char *aad = ptr;\n\n            memcpy(actx->tls_aad, ptr, EVP_AEAD_TLS1_AAD_LEN);\n            len = aad[EVP_AEAD_TLS1_AAD_LEN - 2] << 8 |\n                  aad[EVP_AEAD_TLS1_AAD_LEN - 1];\n            aad = actx->tls_aad;\n            if (!ctx->encrypt) {\n                if (len < POLY1305_BLOCK_SIZE)\n                    return 0;\n                len -= POLY1305_BLOCK_SIZE;     /* discount attached tag */\n                aad[EVP_AEAD_TLS1_AAD_LEN - 2] = (unsigned char)(len >> 8);\n                aad[EVP_AEAD_TLS1_AAD_LEN - 1] = (unsigned char)len;\n            }\n            actx->tls_payload_length = len;\n\n            /*\n             * merge record sequence number as per RFC7905\n             */\n            actx->key.counter[1] = actx->nonce[0];\n            actx->key.counter[2] = actx->nonce[1] ^ CHACHA_U8TOU32(aad);\n            actx->key.counter[3] = actx->nonce[2] ^ CHACHA_U8TOU32(aad+4);\n            actx->mac_inited = 0;\n\n            return POLY1305_BLOCK_SIZE;         /* tag length */\n        }\n\n    case EVP_CTRL_AEAD_SET_MAC_KEY:\n        /* no-op */\n        return 1;\n\n    default:\n        return -1;\n    }\n}",
        "func": "static int chacha20_poly1305_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,\n                                  void *ptr)\n{\n    EVP_CHACHA_AEAD_CTX *actx = aead_data(ctx);\n\n    switch(type) {\n    case EVP_CTRL_INIT:\n        if (actx == NULL)\n            actx = ctx->cipher_data\n                 = OPENSSL_zalloc(sizeof(*actx) + Poly1305_ctx_size());\n        if (actx == NULL) {\n            EVPerr(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_INITIALIZATION_ERROR);\n            return 0;\n        }\n        actx->len.aad = 0;\n        actx->len.text = 0;\n        actx->aad = 0;\n        actx->mac_inited = 0;\n        actx->tag_len = 0;\n        actx->nonce_len = 12;\n        actx->tls_payload_length = NO_TLS_PAYLOAD_LENGTH;\n        memset(actx->tls_aad, 0, POLY1305_BLOCK_SIZE);\n        return 1;\n\n    case EVP_CTRL_COPY:\n        if (actx) {\n            EVP_CIPHER_CTX *dst = (EVP_CIPHER_CTX *)ptr;\n\n            dst->cipher_data =\n                   OPENSSL_memdup(actx, sizeof(*actx) + Poly1305_ctx_size());\n            if (dst->cipher_data == NULL) {\n                EVPerr(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_COPY_ERROR);\n                return 0;\n            }\n        }\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_IVLEN:\n        if (arg <= 0 || arg > CHACHA20_POLY1305_MAX_IVLEN)\n            return 0;\n        actx->nonce_len = arg;\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_IV_FIXED:\n        if (arg != 12)\n            return 0;\n        actx->nonce[0] = actx->key.counter[1]\n                       = CHACHA_U8TOU32((unsigned char *)ptr);\n        actx->nonce[1] = actx->key.counter[2]\n                       = CHACHA_U8TOU32((unsigned char *)ptr+4);\n        actx->nonce[2] = actx->key.counter[3]\n                       = CHACHA_U8TOU32((unsigned char *)ptr+8);\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_TAG:\n        if (arg <= 0 || arg > POLY1305_BLOCK_SIZE)\n            return 0;\n        if (ptr != NULL) {\n            memcpy(actx->tag, ptr, arg);\n            actx->tag_len = arg;\n        }\n        return 1;\n\n    case EVP_CTRL_AEAD_GET_TAG:\n        if (arg <= 0 || arg > POLY1305_BLOCK_SIZE || !ctx->encrypt)\n            return 0;\n        memcpy(ptr, actx->tag, arg);\n        return 1;\n\n    case EVP_CTRL_AEAD_TLS1_AAD:\n        if (arg != EVP_AEAD_TLS1_AAD_LEN)\n            return 0;\n        {\n            unsigned int len;\n            unsigned char *aad = ptr;\n\n            memcpy(actx->tls_aad, ptr, EVP_AEAD_TLS1_AAD_LEN);\n            len = aad[EVP_AEAD_TLS1_AAD_LEN - 2] << 8 |\n                  aad[EVP_AEAD_TLS1_AAD_LEN - 1];\n            aad = actx->tls_aad;\n            if (!ctx->encrypt) {\n                if (len < POLY1305_BLOCK_SIZE)\n                    return 0;\n                len -= POLY1305_BLOCK_SIZE;     /* discount attached tag */\n                aad[EVP_AEAD_TLS1_AAD_LEN - 2] = (unsigned char)(len >> 8);\n                aad[EVP_AEAD_TLS1_AAD_LEN - 1] = (unsigned char)len;\n            }\n            actx->tls_payload_length = len;\n\n            /*\n             * merge record sequence number as per RFC7905\n             */\n            actx->key.counter[1] = actx->nonce[0];\n            actx->key.counter[2] = actx->nonce[1] ^ CHACHA_U8TOU32(aad);\n            actx->key.counter[3] = actx->nonce[2] ^ CHACHA_U8TOU32(aad+4);\n            actx->mac_inited = 0;\n\n            return POLY1305_BLOCK_SIZE;         /* tag length */\n        }\n\n    case EVP_CTRL_AEAD_SET_MAC_KEY:\n        /* no-op */\n        return 1;\n\n    default:\n        return -1;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -36,7 +36,7 @@\n         return 1;\n \n     case EVP_CTRL_AEAD_SET_IVLEN:\n-        if (arg <= 0 || arg > CHACHA_CTR_SIZE)\n+        if (arg <= 0 || arg > CHACHA20_POLY1305_MAX_IVLEN)\n             return 0;\n         actx->nonce_len = arg;\n         return 1;",
        "diff_line_info": {
            "deleted_lines": [
                "        if (arg <= 0 || arg > CHACHA_CTR_SIZE)"
            ],
            "added_lines": [
                "        if (arg <= 0 || arg > CHACHA20_POLY1305_MAX_IVLEN)"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-25052",
        "func_name": "OP-TEE/optee_os/syscall_authenc_update_aad",
        "description": "In Linaro OP-TEE before 3.7.0, by using inconsistent or malformed data, it is possible to call update and final cryptographic functions directly, causing a crash that could leak sensitive information.",
        "git_url": "https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6",
        "commit_title": "cryp: prevent direct calls to update and final functions",
        "commit_text": " With inconsistent or malformed data it has been possible to call \"update\" and \"final\" crypto functions directly. Using a fuzzer tool [1] we have seen that this results in asserts, i.e., a crash that potentially could leak sensitive information.  By setting the state (initialized) in the crypto context (i.e., the tee_cryp_state) at the end of all syscall_*_init functions and then add a check of the state at the beginning of all update and final functions,   we prevent direct entrance to the \"update\" and \"final\" functions.  [1] https://github.com/MartijnB/optee_fuzzer  ",
        "func_before": "TEE_Result syscall_authenc_update_aad(unsigned long state,\n\t\t\tconst void *aad_data, size_t aad_data_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t) aad_data,\n\t\t\t\t\t  aad_data_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = crypto_authenc_update_aad(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\taad_data, aad_data_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\treturn TEE_SUCCESS;\n}",
        "func": "TEE_Result syscall_authenc_update_aad(unsigned long state,\n\t\t\tconst void *aad_data, size_t aad_data_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t) aad_data,\n\t\t\t\t\t  aad_data_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = crypto_authenc_update_aad(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\taad_data, aad_data_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\treturn TEE_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,6 +21,9 @@\n \tif (res != TEE_SUCCESS)\n \t\treturn res;\n \n+\tif (cs->state != CRYP_STATE_INITIALIZED)\n+\t\treturn TEE_ERROR_BAD_STATE;\n+\n \tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n \t\treturn TEE_ERROR_BAD_STATE;\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (cs->state != CRYP_STATE_INITIALIZED)",
                "\t\treturn TEE_ERROR_BAD_STATE;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-25052",
        "func_name": "OP-TEE/optee_os/syscall_authenc_dec_final",
        "description": "In Linaro OP-TEE before 3.7.0, by using inconsistent or malformed data, it is possible to call update and final cryptographic functions directly, causing a crash that could leak sensitive information.",
        "git_url": "https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6",
        "commit_title": "cryp: prevent direct calls to update and final functions",
        "commit_text": " With inconsistent or malformed data it has been possible to call \"update\" and \"final\" crypto functions directly. Using a fuzzer tool [1] we have seen that this results in asserts, i.e., a crash that potentially could leak sensitive information.  By setting the state (initialized) in the crypto context (i.e., the tee_cryp_state) at the end of all syscall_*_init functions and then add a check of the state at the beginning of all update and final functions,   we prevent direct entrance to the \"update\" and \"final\" functions.  [1] https://github.com/MartijnB/optee_fuzzer  ",
        "func_before": "TEE_Result syscall_authenc_dec_final(unsigned long state,\n\t\t\tconst void *src_data, size_t src_len, void *dst_data,\n\t\t\tuint64_t *dst_len, const void *tag, size_t tag_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->mode != TEE_MODE_DECRYPT)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (!dst_len) {\n\t\tdlen = 0;\n\t} else {\n\t\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t\t  (uaddr_t)dst_data, dlen);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)tag, tag_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = crypto_authenc_dec_final(cs->ctx, cs->algo, src_data, src_len,\n\t\t\t\t       dst_data, &dlen, tag, tag_len);\n\nout:\n\tif ((res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) &&\n\t    dst_len != NULL) {\n\t\tTEE_Result res2 = put_user_u64(dst_len, dlen);\n\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}",
        "func": "TEE_Result syscall_authenc_dec_final(unsigned long state,\n\t\t\tconst void *src_data, size_t src_len, void *dst_data,\n\t\t\tuint64_t *dst_len, const void *tag, size_t tag_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tif (cs->mode != TEE_MODE_DECRYPT)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (!dst_len) {\n\t\tdlen = 0;\n\t} else {\n\t\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t\t  (uaddr_t)dst_data, dlen);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)tag, tag_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = crypto_authenc_dec_final(cs->ctx, cs->algo, src_data, src_len,\n\t\t\t\t       dst_data, &dlen, tag, tag_len);\n\nout:\n\tif ((res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) &&\n\t    dst_len != NULL) {\n\t\tTEE_Result res2 = put_user_u64(dst_len, dlen);\n\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,9 @@\n \tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n \tif (res != TEE_SUCCESS)\n \t\treturn res;\n+\n+\tif (cs->state != CRYP_STATE_INITIALIZED)\n+\t\treturn TEE_ERROR_BAD_STATE;\n \n \tif (cs->mode != TEE_MODE_DECRYPT)\n \t\treturn TEE_ERROR_BAD_PARAMETERS;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tif (cs->state != CRYP_STATE_INITIALIZED)",
                "\t\treturn TEE_ERROR_BAD_STATE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-25052",
        "func_name": "OP-TEE/optee_os/syscall_authenc_update_payload",
        "description": "In Linaro OP-TEE before 3.7.0, by using inconsistent or malformed data, it is possible to call update and final cryptographic functions directly, causing a crash that could leak sensitive information.",
        "git_url": "https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6",
        "commit_title": "cryp: prevent direct calls to update and final functions",
        "commit_text": " With inconsistent or malformed data it has been possible to call \"update\" and \"final\" crypto functions directly. Using a fuzzer tool [1] we have seen that this results in asserts, i.e., a crash that potentially could leak sensitive information.  By setting the state (initialized) in the crypto context (i.e., the tee_cryp_state) at the end of all syscall_*_init functions and then add a check of the state at the beginning of all update and final functions,   we prevent direct entrance to the \"update\" and \"final\" functions.  [1] https://github.com/MartijnB/optee_fuzzer  ",
        "func_before": "TEE_Result syscall_authenc_update_payload(unsigned long state,\n\t\t\tconst void *src_data, size_t src_len, void *dst_data,\n\t\t\tuint64_t *dst_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t) src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)dst_data, dlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = crypto_authenc_update_payload(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t    src_data, src_len, dst_data,\n\t\t\t\t\t    &dlen);\nout:\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2 = put_user_u64(dst_len, dlen);\n\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\tres = res2;\n\t}\n\n\treturn res;\n}",
        "func": "TEE_Result syscall_authenc_update_payload(unsigned long state,\n\t\t\tconst void *src_data, size_t src_len, void *dst_data,\n\t\t\tuint64_t *dst_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t) src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)dst_data, dlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = crypto_authenc_update_payload(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t    src_data, src_len, dst_data,\n\t\t\t\t\t    &dlen);\nout:\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2 = put_user_u64(dst_len, dlen);\n\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\tres = res2;\n\t}\n\n\treturn res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,9 @@\n \tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n \tif (res != TEE_SUCCESS)\n \t\treturn res;\n+\n+\tif (cs->state != CRYP_STATE_INITIALIZED)\n+\t\treturn TEE_ERROR_BAD_STATE;\n \n \tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n \t\treturn TEE_ERROR_BAD_STATE;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tif (cs->state != CRYP_STATE_INITIALIZED)",
                "\t\treturn TEE_ERROR_BAD_STATE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-25052",
        "func_name": "OP-TEE/optee_os/syscall_cryp_state_copy",
        "description": "In Linaro OP-TEE before 3.7.0, by using inconsistent or malformed data, it is possible to call update and final cryptographic functions directly, causing a crash that could leak sensitive information.",
        "git_url": "https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6",
        "commit_title": "cryp: prevent direct calls to update and final functions",
        "commit_text": " With inconsistent or malformed data it has been possible to call \"update\" and \"final\" crypto functions directly. Using a fuzzer tool [1] we have seen that this results in asserts, i.e., a crash that potentially could leak sensitive information.  By setting the state (initialized) in the crypto context (i.e., the tee_cryp_state) at the end of all syscall_*_init functions and then add a check of the state at the beginning of all update and final functions,   we prevent direct entrance to the \"update\" and \"final\" functions.  [1] https://github.com/MartijnB/optee_fuzzer  ",
        "func_before": "TEE_Result syscall_cryp_state_copy(unsigned long dst, unsigned long src)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs_dst;\n\tstruct tee_cryp_state *cs_src;\n\tstruct tee_ta_session *sess;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(dst), &cs_dst);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(src), &cs_src);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (cs_dst->algo != cs_src->algo || cs_dst->mode != cs_src->mode)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tswitch (TEE_ALG_GET_CLASS(cs_src->algo)) {\n\tcase TEE_OPERATION_CIPHER:\n\t\tcrypto_cipher_copy_state(cs_dst->ctx, cs_src->ctx,\n\t\t\t\t\t cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tcrypto_authenc_copy_state(cs_dst->ctx, cs_src->ctx,\n\t\t\t\t\t  cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tcrypto_hash_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tcrypto_mac_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_STATE;\n\t}\n\n\treturn TEE_SUCCESS;\n}",
        "func": "TEE_Result syscall_cryp_state_copy(unsigned long dst, unsigned long src)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs_dst;\n\tstruct tee_cryp_state *cs_src;\n\tstruct tee_ta_session *sess;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(dst), &cs_dst);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(src), &cs_src);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (cs_dst->algo != cs_src->algo || cs_dst->mode != cs_src->mode)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tswitch (TEE_ALG_GET_CLASS(cs_src->algo)) {\n\tcase TEE_OPERATION_CIPHER:\n\t\tcrypto_cipher_copy_state(cs_dst->ctx, cs_src->ctx,\n\t\t\t\t\t cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tcrypto_authenc_copy_state(cs_dst->ctx, cs_src->ctx,\n\t\t\t\t\t  cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tcrypto_hash_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tcrypto_mac_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_STATE;\n\t}\n\n\tcs_dst->state = cs_src->state;\n\n\treturn TEE_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -38,5 +38,7 @@\n \t\treturn TEE_ERROR_BAD_STATE;\n \t}\n \n+\tcs_dst->state = cs_src->state;\n+\n \treturn TEE_SUCCESS;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tcs_dst->state = cs_src->state;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-25052",
        "func_name": "OP-TEE/optee_os/syscall_cipher_init",
        "description": "In Linaro OP-TEE before 3.7.0, by using inconsistent or malformed data, it is possible to call update and final cryptographic functions directly, causing a crash that could leak sensitive information.",
        "git_url": "https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6",
        "commit_title": "cryp: prevent direct calls to update and final functions",
        "commit_text": " With inconsistent or malformed data it has been possible to call \"update\" and \"final\" crypto functions directly. Using a fuzzer tool [1] we have seen that this results in asserts, i.e., a crash that potentially could leak sensitive information.  By setting the state (initialized) in the crypto context (i.e., the tee_cryp_state) at the end of all syscall_*_init functions and then add a check of the state at the beginning of all update and final functions,   we prevent direct entrance to the \"update\" and \"final\" functions.  [1] https://github.com/MartijnB/optee_fuzzer  ",
        "func_before": "TEE_Result syscall_cipher_init(unsigned long state, const void *iv,\n\t\t\tsize_t iv_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key1;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_CIPHER)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(utc,\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t) iv, iv_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tkey1 = o->attr;\n\n\tif (tee_obj_get(utc, cs->key2, &o) == TEE_SUCCESS) {\n\t\tstruct tee_cryp_obj_secret *key2 = o->attr;\n\n\t\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\tres = crypto_cipher_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t (uint8_t *)(key1 + 1), key1->key_size,\n\t\t\t\t\t (uint8_t *)(key2 + 1), key2->key_size,\n\t\t\t\t\t iv, iv_len);\n\t} else {\n\t\tres = crypto_cipher_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t (uint8_t *)(key1 + 1), key1->key_size,\n\t\t\t\t\t NULL, 0, iv, iv_len);\n\t}\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tcs->ctx_finalize = crypto_cipher_final;\n\treturn TEE_SUCCESS;\n}",
        "func": "TEE_Result syscall_cipher_init(unsigned long state, const void *iv,\n\t\t\tsize_t iv_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key1;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_CIPHER)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(utc,\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t) iv, iv_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tkey1 = o->attr;\n\n\tif (tee_obj_get(utc, cs->key2, &o) == TEE_SUCCESS) {\n\t\tstruct tee_cryp_obj_secret *key2 = o->attr;\n\n\t\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\tres = crypto_cipher_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t (uint8_t *)(key1 + 1), key1->key_size,\n\t\t\t\t\t (uint8_t *)(key2 + 1), key2->key_size,\n\t\t\t\t\t iv, iv_len);\n\t} else {\n\t\tres = crypto_cipher_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t (uint8_t *)(key1 + 1), key1->key_size,\n\t\t\t\t\t NULL, 0, iv, iv_len);\n\t}\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tcs->ctx_finalize = crypto_cipher_final;\n\tcs->state = CRYP_STATE_INITIALIZED;\n\n\treturn TEE_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -54,5 +54,7 @@\n \t\treturn res;\n \n \tcs->ctx_finalize = crypto_cipher_final;\n+\tcs->state = CRYP_STATE_INITIALIZED;\n+\n \treturn TEE_SUCCESS;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tcs->state = CRYP_STATE_INITIALIZED;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-25052",
        "func_name": "OP-TEE/optee_os/syscall_hash_update",
        "description": "In Linaro OP-TEE before 3.7.0, by using inconsistent or malformed data, it is possible to call update and final cryptographic functions directly, causing a crash that could leak sensitive information.",
        "git_url": "https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6",
        "commit_title": "cryp: prevent direct calls to update and final functions",
        "commit_text": " With inconsistent or malformed data it has been possible to call \"update\" and \"final\" crypto functions directly. Using a fuzzer tool [1] we have seen that this results in asserts, i.e., a crash that potentially could leak sensitive information.  By setting the state (initialized) in the crypto context (i.e., the tee_cryp_state) at the end of all syscall_*_init functions and then add a check of the state at the beginning of all update and final functions,   we prevent direct entrance to the \"update\" and \"final\" functions.  [1] https://github.com/MartijnB/optee_fuzzer  ",
        "func_before": "TEE_Result syscall_hash_update(unsigned long state, const void *chunk,\n\t\t\tsize_t chunk_size)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\t/* No data, but size provided isn't valid parameters. */\n\tif (!chunk && chunk_size)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Zero length hash is valid, but nothing we need to do. */\n\tif (!chunk_size)\n\t\treturn TEE_SUCCESS;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)chunk, chunk_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = crypto_hash_update(cs->ctx, cs->algo, chunk, chunk_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tres = crypto_mac_update(cs->ctx, cs->algo, chunk, chunk_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\treturn TEE_SUCCESS;\n}",
        "func": "TEE_Result syscall_hash_update(unsigned long state, const void *chunk,\n\t\t\tsize_t chunk_size)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\t/* No data, but size provided isn't valid parameters. */\n\tif (!chunk && chunk_size)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t/* Zero length hash is valid, but nothing we need to do. */\n\tif (!chunk_size)\n\t\treturn TEE_SUCCESS;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)chunk, chunk_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = crypto_hash_update(cs->ctx, cs->algo, chunk, chunk_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tres = crypto_mac_update(cs->ctx, cs->algo, chunk, chunk_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\treturn TEE_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,6 +28,9 @@\n \tif (res != TEE_SUCCESS)\n \t\treturn res;\n \n+\tif (cs->state != CRYP_STATE_INITIALIZED)\n+\t\treturn TEE_ERROR_BAD_STATE;\n+\n \tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n \tcase TEE_OPERATION_DIGEST:\n \t\tres = crypto_hash_update(cs->ctx, cs->algo, chunk, chunk_size);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (cs->state != CRYP_STATE_INITIALIZED)",
                "\t\treturn TEE_ERROR_BAD_STATE;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-25052",
        "func_name": "OP-TEE/optee_os/syscall_hash_final",
        "description": "In Linaro OP-TEE before 3.7.0, by using inconsistent or malformed data, it is possible to call update and final cryptographic functions directly, causing a crash that could leak sensitive information.",
        "git_url": "https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6",
        "commit_title": "cryp: prevent direct calls to update and final functions",
        "commit_text": " With inconsistent or malformed data it has been possible to call \"update\" and \"final\" crypto functions directly. Using a fuzzer tool [1] we have seen that this results in asserts, i.e., a crash that potentially could leak sensitive information.  By setting the state (initialized) in the crypto context (i.e., the tee_cryp_state) at the end of all syscall_*_init functions and then add a check of the state at the beginning of all update and final functions,   we prevent direct entrance to the \"update\" and \"final\" functions.  [1] https://github.com/MartijnB/optee_fuzzer  ",
        "func_before": "TEE_Result syscall_hash_final(unsigned long state, const void *chunk,\n\t\t\tsize_t chunk_size, void *hash, uint64_t *hash_len)\n{\n\tTEE_Result res, res2;\n\tsize_t hash_size;\n\tsize_t hlen = 0;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\t/* No data, but size provided isn't valid parameters. */\n\tif (!chunk && chunk_size)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)chunk, chunk_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = get_user_u64_as_size_t(&hlen, hash_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)hash, hlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = tee_hash_get_digest_size(cs->algo, &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (hlen < hash_size) {\n\t\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (chunk_size) {\n\t\t\tres = crypto_hash_update(cs->ctx, cs->algo, chunk,\n\t\t\t\t\t\t chunk_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\n\t\tres = crypto_hash_final(cs->ctx, cs->algo, hash, hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\n\tcase TEE_OPERATION_MAC:\n\t\tres = tee_mac_get_digest_size(cs->algo, &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (hlen < hash_size) {\n\t\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (chunk_size) {\n\t\t\tres = crypto_mac_update(cs->ctx, cs->algo, chunk,\n\t\t\t\t\t\tchunk_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\n\t\tres = crypto_mac_final(cs->ctx, cs->algo, hash, hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\nout:\n\tres2 = put_user_u64(hash_len, hash_size);\n\tif (res2 != TEE_SUCCESS)\n\t\treturn res2;\n\treturn res;\n}",
        "func": "TEE_Result syscall_hash_final(unsigned long state, const void *chunk,\n\t\t\tsize_t chunk_size, void *hash, uint64_t *hash_len)\n{\n\tTEE_Result res, res2;\n\tsize_t hash_size;\n\tsize_t hlen = 0;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\t/* No data, but size provided isn't valid parameters. */\n\tif (!chunk && chunk_size)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)chunk, chunk_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = get_user_u64_as_size_t(&hlen, hash_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)hash, hlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = tee_hash_get_digest_size(cs->algo, &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (hlen < hash_size) {\n\t\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (chunk_size) {\n\t\t\tres = crypto_hash_update(cs->ctx, cs->algo, chunk,\n\t\t\t\t\t\t chunk_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\n\t\tres = crypto_hash_final(cs->ctx, cs->algo, hash, hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\n\tcase TEE_OPERATION_MAC:\n\t\tres = tee_mac_get_digest_size(cs->algo, &hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (hlen < hash_size) {\n\t\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (chunk_size) {\n\t\t\tres = crypto_mac_update(cs->ctx, cs->algo, chunk,\n\t\t\t\t\t\tchunk_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t}\n\n\t\tres = crypto_mac_final(cs->ctx, cs->algo, hash, hash_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\nout:\n\tres2 = put_user_u64(hash_len, hash_size);\n\tif (res2 != TEE_SUCCESS)\n\t\treturn res2;\n\treturn res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -37,6 +37,9 @@\n \tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n \tif (res != TEE_SUCCESS)\n \t\treturn res;\n+\n+\tif (cs->state != CRYP_STATE_INITIALIZED)\n+\t\treturn TEE_ERROR_BAD_STATE;\n \n \tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n \tcase TEE_OPERATION_DIGEST:",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tif (cs->state != CRYP_STATE_INITIALIZED)",
                "\t\treturn TEE_ERROR_BAD_STATE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-25052",
        "func_name": "OP-TEE/optee_os/tee_svc_cipher_update_helper",
        "description": "In Linaro OP-TEE before 3.7.0, by using inconsistent or malformed data, it is possible to call update and final cryptographic functions directly, causing a crash that could leak sensitive information.",
        "git_url": "https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6",
        "commit_title": "cryp: prevent direct calls to update and final functions",
        "commit_text": " With inconsistent or malformed data it has been possible to call \"update\" and \"final\" crypto functions directly. Using a fuzzer tool [1] we have seen that this results in asserts, i.e., a crash that potentially could leak sensitive information.  By setting the state (initialized) in the crypto context (i.e., the tee_cryp_state) at the end of all syscall_*_init functions and then add a check of the state at the beginning of all update and final functions,   we prevent direct entrance to the \"update\" and \"final\" functions.  [1] https://github.com/MartijnB/optee_fuzzer  ",
        "func_before": "static TEE_Result tee_svc_cipher_update_helper(unsigned long state,\n\t\t\tbool last_block, const void *src, size_t src_len,\n\t\t\tvoid *dst, uint64_t *dst_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)src, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (!dst_len) {\n\t\tdlen = 0;\n\t} else {\n\t\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t\t  (uaddr_t)dst, dlen);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tif (src_len > 0) {\n\t\t/* Permit src_len == 0 to finalize the operation */\n\t\tres = tee_do_cipher_update(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t   last_block, src, src_len, dst);\n\t}\n\n\tif (last_block && cs->ctx_finalize != NULL) {\n\t\tcs->ctx_finalize(cs->ctx, cs->algo);\n\t\tcs->ctx_finalize = NULL;\n\t}\n\nout:\n\tif ((res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) &&\n\t    dst_len != NULL) {\n\t\tTEE_Result res2;\n\n\t\tres2 = put_user_u64(dst_len, src_len);\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\tres = res2;\n\t}\n\n\treturn res;\n}",
        "func": "static TEE_Result tee_svc_cipher_update_helper(unsigned long state,\n\t\t\tbool last_block, const void *src, size_t src_len,\n\t\t\tvoid *dst, uint64_t *dst_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)src, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (!dst_len) {\n\t\tdlen = 0;\n\t} else {\n\t\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t\t  (uaddr_t)dst, dlen);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tif (src_len > 0) {\n\t\t/* Permit src_len == 0 to finalize the operation */\n\t\tres = tee_do_cipher_update(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t   last_block, src, src_len, dst);\n\t}\n\n\tif (last_block && cs->ctx_finalize != NULL) {\n\t\tcs->ctx_finalize(cs->ctx, cs->algo);\n\t\tcs->ctx_finalize = NULL;\n\t}\n\nout:\n\tif ((res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) &&\n\t    dst_len != NULL) {\n\t\tTEE_Result res2;\n\n\t\tres2 = put_user_u64(dst_len, src_len);\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\tres = res2;\n\t}\n\n\treturn res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,9 @@\n \tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n \tif (res != TEE_SUCCESS)\n \t\treturn res;\n+\n+\tif (cs->state != CRYP_STATE_INITIALIZED)\n+\t\treturn TEE_ERROR_BAD_STATE;\n \n \tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n \t\t\t\t\t  TEE_MEMORY_ACCESS_READ |",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tif (cs->state != CRYP_STATE_INITIALIZED)",
                "\t\treturn TEE_ERROR_BAD_STATE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-25052",
        "func_name": "OP-TEE/optee_os/syscall_authenc_init",
        "description": "In Linaro OP-TEE before 3.7.0, by using inconsistent or malformed data, it is possible to call update and final cryptographic functions directly, causing a crash that could leak sensitive information.",
        "git_url": "https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6",
        "commit_title": "cryp: prevent direct calls to update and final functions",
        "commit_text": " With inconsistent or malformed data it has been possible to call \"update\" and \"final\" crypto functions directly. Using a fuzzer tool [1] we have seen that this results in asserts, i.e., a crash that potentially could leak sensitive information.  By setting the state (initialized) in the crypto context (i.e., the tee_cryp_state) at the end of all syscall_*_init functions and then add a check of the state at the beginning of all update and final functions,   we prevent direct entrance to the \"update\" and \"final\" functions.  [1] https://github.com/MartijnB/optee_fuzzer  ",
        "func_before": "TEE_Result syscall_authenc_init(unsigned long state, const void *nonce,\n\t\t\tsize_t nonce_len, size_t tag_len,\n\t\t\tsize_t aad_len, size_t payload_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)nonce, nonce_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx), cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tkey = o->attr;\n\tres = crypto_authenc_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t  (uint8_t *)(key + 1), key->key_size,\n\t\t\t\t  nonce, nonce_len, tag_len, aad_len,\n\t\t\t\t  payload_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tcs->ctx_finalize = (tee_cryp_ctx_finalize_func_t)crypto_authenc_final;\n\treturn TEE_SUCCESS;\n}",
        "func": "TEE_Result syscall_authenc_init(unsigned long state, const void *nonce,\n\t\t\tsize_t nonce_len, size_t tag_len,\n\t\t\tsize_t aad_len, size_t payload_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)nonce, nonce_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx), cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tkey = o->attr;\n\tres = crypto_authenc_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t  (uint8_t *)(key + 1), key->key_size,\n\t\t\t\t  nonce, nonce_len, tag_len, aad_len,\n\t\t\t\t  payload_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tcs->ctx_finalize = (tee_cryp_ctx_finalize_func_t)crypto_authenc_final;\n\tcs->state = CRYP_STATE_INITIALIZED;\n\n\treturn TEE_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -38,5 +38,7 @@\n \t\treturn res;\n \n \tcs->ctx_finalize = (tee_cryp_ctx_finalize_func_t)crypto_authenc_final;\n+\tcs->state = CRYP_STATE_INITIALIZED;\n+\n \treturn TEE_SUCCESS;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tcs->state = CRYP_STATE_INITIALIZED;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-25052",
        "func_name": "OP-TEE/optee_os/syscall_hash_init",
        "description": "In Linaro OP-TEE before 3.7.0, by using inconsistent or malformed data, it is possible to call update and final cryptographic functions directly, causing a crash that could leak sensitive information.",
        "git_url": "https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6",
        "commit_title": "cryp: prevent direct calls to update and final functions",
        "commit_text": " With inconsistent or malformed data it has been possible to call \"update\" and \"final\" crypto functions directly. Using a fuzzer tool [1] we have seen that this results in asserts, i.e., a crash that potentially could leak sensitive information.  By setting the state (initialized) in the crypto context (i.e., the tee_cryp_state) at the end of all syscall_*_init functions and then add a check of the state at the beginning of all update and final functions,   we prevent direct entrance to the \"update\" and \"final\" functions.  [1] https://github.com/MartijnB/optee_fuzzer  ",
        "func_before": "TEE_Result syscall_hash_init(unsigned long state,\n\t\t\t     const void *iv __maybe_unused,\n\t\t\t     size_t iv_len __maybe_unused)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = crypto_hash_init(cs->ctx, cs->algo);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\t{\n\t\t\tstruct tee_obj *o;\n\t\t\tstruct tee_cryp_obj_secret *key;\n\n\t\t\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  cs->key1, &o);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tif ((o->info.handleFlags &\n\t\t\t     TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\t\tres = crypto_mac_init(cs->ctx, cs->algo,\n\t\t\t\t\t      (void *)(key + 1), key->key_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\treturn TEE_SUCCESS;\n}",
        "func": "TEE_Result syscall_hash_init(unsigned long state,\n\t\t\t     const void *iv __maybe_unused,\n\t\t\t     size_t iv_len __maybe_unused)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = crypto_hash_init(cs->ctx, cs->algo);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\t{\n\t\t\tstruct tee_obj *o;\n\t\t\tstruct tee_cryp_obj_secret *key;\n\n\t\t\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  cs->key1, &o);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tif ((o->info.handleFlags &\n\t\t\t     TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\t\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\t\tres = crypto_mac_init(cs->ctx, cs->algo,\n\t\t\t\t\t      (void *)(key + 1), key->key_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\n\tcs->state = CRYP_STATE_INITIALIZED;\n\n\treturn TEE_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -44,5 +44,7 @@\n \t\treturn TEE_ERROR_BAD_PARAMETERS;\n \t}\n \n+\tcs->state = CRYP_STATE_INITIALIZED;\n+\n \treturn TEE_SUCCESS;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tcs->state = CRYP_STATE_INITIALIZED;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-25052",
        "func_name": "OP-TEE/optee_os/syscall_authenc_enc_final",
        "description": "In Linaro OP-TEE before 3.7.0, by using inconsistent or malformed data, it is possible to call update and final cryptographic functions directly, causing a crash that could leak sensitive information.",
        "git_url": "https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6",
        "commit_title": "cryp: prevent direct calls to update and final functions",
        "commit_text": " With inconsistent or malformed data it has been possible to call \"update\" and \"final\" crypto functions directly. Using a fuzzer tool [1] we have seen that this results in asserts, i.e., a crash that potentially could leak sensitive information.  By setting the state (initialized) in the crypto context (i.e., the tee_cryp_state) at the end of all syscall_*_init functions and then add a check of the state at the beginning of all update and final functions,   we prevent direct entrance to the \"update\" and \"final\" functions.  [1] https://github.com/MartijnB/optee_fuzzer  ",
        "func_before": "TEE_Result syscall_authenc_enc_final(unsigned long state,\n\t\t\tconst void *src_data, size_t src_len, void *dst_data,\n\t\t\tuint64_t *dst_len, void *tag, uint64_t *tag_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\tsize_t tlen = 0;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->mode != TEE_MODE_ENCRYPT)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (!dst_len) {\n\t\tdlen = 0;\n\t} else {\n\t\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t\t  (uaddr_t)dst_data, dlen);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = get_user_u64_as_size_t(&tlen, tag_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)tag, tlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = crypto_authenc_enc_final(cs->ctx, cs->algo, src_data,\n\t\t\t\t       src_len, dst_data, &dlen, tag, &tlen);\n\nout:\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2;\n\n\t\tif (dst_len != NULL) {\n\t\t\tres2 = put_user_u64(dst_len, dlen);\n\t\t\tif (res2 != TEE_SUCCESS)\n\t\t\t\treturn res2;\n\t\t}\n\n\t\tres2 = put_user_u64(tag_len, tlen);\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}",
        "func": "TEE_Result syscall_authenc_enc_final(unsigned long state,\n\t\t\tconst void *src_data, size_t src_len, void *dst_data,\n\t\t\tuint64_t *dst_len, void *tag, uint64_t *tag_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\tsize_t tlen = 0;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tif (cs->mode != TEE_MODE_ENCRYPT)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tif (!dst_len) {\n\t\tdlen = 0;\n\t} else {\n\t\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t\t  (uaddr_t)dst_data, dlen);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\n\tres = get_user_u64_as_size_t(&tlen, tag_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)tag, tlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = crypto_authenc_enc_final(cs->ctx, cs->algo, src_data,\n\t\t\t\t       src_len, dst_data, &dlen, tag, &tlen);\n\nout:\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2;\n\n\t\tif (dst_len != NULL) {\n\t\t\tres2 = put_user_u64(dst_len, dlen);\n\t\t\tif (res2 != TEE_SUCCESS)\n\t\t\t\treturn res2;\n\t\t}\n\n\t\tres2 = put_user_u64(tag_len, tlen);\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\treturn res2;\n\t}\n\n\treturn res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,6 +15,9 @@\n \tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n \tif (res != TEE_SUCCESS)\n \t\treturn res;\n+\n+\tif (cs->state != CRYP_STATE_INITIALIZED)\n+\t\treturn TEE_ERROR_BAD_STATE;\n \n \tif (cs->mode != TEE_MODE_ENCRYPT)\n \t\treturn TEE_ERROR_BAD_PARAMETERS;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tif (cs->state != CRYP_STATE_INITIALIZED)",
                "\t\treturn TEE_ERROR_BAD_STATE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-25052",
        "func_name": "OP-TEE/optee_os/syscall_cryp_state_alloc",
        "description": "In Linaro OP-TEE before 3.7.0, by using inconsistent or malformed data, it is possible to call update and final cryptographic functions directly, causing a crash that could leak sensitive information.",
        "git_url": "https://github.com/OP-TEE/optee_os/commit/34a08bec755670ea0490cb53bbc68058cafc69b6",
        "commit_title": "cryp: prevent direct calls to update and final functions",
        "commit_text": " With inconsistent or malformed data it has been possible to call \"update\" and \"final\" crypto functions directly. Using a fuzzer tool [1] we have seen that this results in asserts, i.e., a crash that potentially could leak sensitive information.  By setting the state (initialized) in the crypto context (i.e., the tee_cryp_state) at the end of all syscall_*_init functions and then add a check of the state at the beginning of all update and final functions,   we prevent direct entrance to the \"update\" and \"final\" functions.  [1] https://github.com/MartijnB/optee_fuzzer  ",
        "func_before": "TEE_Result syscall_cryp_state_alloc(unsigned long algo, unsigned long mode,\n\t\t\tunsigned long key1, unsigned long key2,\n\t\t\tuint32_t *state)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o1 = NULL;\n\tstruct tee_obj *o2 = NULL;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tif (key1 != 0) {\n\t\tres = tee_obj_get(utc, tee_svc_uref_to_vaddr(key1), &o1);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (o1->busy)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tres = tee_svc_cryp_check_key_type(o1, algo, mode);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\tif (key2 != 0) {\n\t\tres = tee_obj_get(utc, tee_svc_uref_to_vaddr(key2), &o2);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (o2->busy)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tres = tee_svc_cryp_check_key_type(o2, algo, mode);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tcs = calloc(1, sizeof(struct tee_cryp_state));\n\tif (!cs)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tTAILQ_INSERT_TAIL(&utc->cryp_states, cs, link);\n\tcs->algo = algo;\n\tcs->mode = mode;\n\n\tswitch (TEE_ALG_GET_CLASS(algo)) {\n\tcase TEE_OPERATION_EXTENSION:\n#ifdef CFG_CRYPTO_RSASSA_NA1\n\t\tif (algo == TEE_ALG_RSASSA_PKCS1_V1_5)\n\t\t\tgoto rsassa_na1;\n#endif\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tbreak;\n\tcase TEE_OPERATION_CIPHER:\n\t\tif ((algo == TEE_ALG_AES_XTS && (key1 == 0 || key2 == 0)) ||\n\t\t    (algo != TEE_ALG_AES_XTS && (key1 == 0 || key2 != 0))) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_cipher_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tif (key1 == 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_authenc_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tif (key1 == 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_mac_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tif (key1 != 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_hash_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_ASYMMETRIC_CIPHER:\n\tcase TEE_OPERATION_ASYMMETRIC_SIGNATURE:\nrsassa_na1: __maybe_unused\n\t\tif (key1 == 0 || key2 != 0)\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tcase TEE_OPERATION_KEY_DERIVATION:\n\t\tif (key1 == 0 || key2 != 0)\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tdefault:\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tbreak;\n\t}\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_copy_kaddr_to_uref(state, cs);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/* Register keys */\n\tif (o1 != NULL) {\n\t\to1->busy = true;\n\t\tcs->key1 = (vaddr_t)o1;\n\t}\n\tif (o2 != NULL) {\n\t\to2->busy = true;\n\t\tcs->key2 = (vaddr_t)o2;\n\t}\n\nout:\n\tif (res != TEE_SUCCESS)\n\t\tcryp_state_free(utc, cs);\n\treturn res;\n}",
        "func": "TEE_Result syscall_cryp_state_alloc(unsigned long algo, unsigned long mode,\n\t\t\tunsigned long key1, unsigned long key2,\n\t\t\tuint32_t *state)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o1 = NULL;\n\tstruct tee_obj *o2 = NULL;\n\tstruct user_ta_ctx *utc;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\n\tif (key1 != 0) {\n\t\tres = tee_obj_get(utc, tee_svc_uref_to_vaddr(key1), &o1);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (o1->busy)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tres = tee_svc_cryp_check_key_type(o1, algo, mode);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\tif (key2 != 0) {\n\t\tres = tee_obj_get(utc, tee_svc_uref_to_vaddr(key2), &o2);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif (o2->busy)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tres = tee_svc_cryp_check_key_type(o2, algo, mode);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t}\n\n\tcs = calloc(1, sizeof(struct tee_cryp_state));\n\tif (!cs)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tTAILQ_INSERT_TAIL(&utc->cryp_states, cs, link);\n\tcs->algo = algo;\n\tcs->mode = mode;\n\tcs->state = CRYP_STATE_UNINITIALIZED;\n\n\tswitch (TEE_ALG_GET_CLASS(algo)) {\n\tcase TEE_OPERATION_EXTENSION:\n#ifdef CFG_CRYPTO_RSASSA_NA1\n\t\tif (algo == TEE_ALG_RSASSA_PKCS1_V1_5)\n\t\t\tgoto rsassa_na1;\n#endif\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tbreak;\n\tcase TEE_OPERATION_CIPHER:\n\t\tif ((algo == TEE_ALG_AES_XTS && (key1 == 0 || key2 == 0)) ||\n\t\t    (algo != TEE_ALG_AES_XTS && (key1 == 0 || key2 != 0))) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_cipher_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tif (key1 == 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_authenc_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tif (key1 == 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_mac_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tif (key1 != 0 || key2 != 0) {\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\t} else {\n\t\t\tres = crypto_hash_alloc_ctx(&cs->ctx, algo);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase TEE_OPERATION_ASYMMETRIC_CIPHER:\n\tcase TEE_OPERATION_ASYMMETRIC_SIGNATURE:\nrsassa_na1: __maybe_unused\n\t\tif (key1 == 0 || key2 != 0)\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tcase TEE_OPERATION_KEY_DERIVATION:\n\t\tif (key1 == 0 || key2 != 0)\n\t\t\tres = TEE_ERROR_BAD_PARAMETERS;\n\t\tbreak;\n\tdefault:\n\t\tres = TEE_ERROR_NOT_SUPPORTED;\n\t\tbreak;\n\t}\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\tres = tee_svc_copy_kaddr_to_uref(state, cs);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\n\t/* Register keys */\n\tif (o1 != NULL) {\n\t\to1->busy = true;\n\t\tcs->key1 = (vaddr_t)o1;\n\t}\n\tif (o2 != NULL) {\n\t\to2->busy = true;\n\t\tcs->key2 = (vaddr_t)o2;\n\t}\n\nout:\n\tif (res != TEE_SUCCESS)\n\t\tcryp_state_free(utc, cs);\n\treturn res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -41,6 +41,7 @@\n \tTAILQ_INSERT_TAIL(&utc->cryp_states, cs, link);\n \tcs->algo = algo;\n \tcs->mode = mode;\n+\tcs->state = CRYP_STATE_UNINITIALIZED;\n \n \tswitch (TEE_ALG_GET_CLASS(algo)) {\n \tcase TEE_OPERATION_EXTENSION:",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tcs->state = CRYP_STATE_UNINITIALIZED;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-40529",
        "func_name": "randombit/botan/ElGamal_Encryption_Operation::raw_encrypt",
        "description": "The ElGamal implementation in Botan through 2.18.1, as used in Thunderbird and other products, allows plaintext recovery because, during interaction between two cryptographic libraries, a certain dangerous combination of the prime defined by the receiver's public key, the generator defined by the receiver's public key, and the sender's ephemeral exponents can lead to a cross-configuration attack against OpenPGP.",
        "git_url": "https://github.com/randombit/botan/commit/9a23e4e3bc3966340531f2ff608fa9d33b5185a2",
        "commit_title": "Avoid using short exponents with ElGamal",
        "commit_text": " Some off-brand PGP implementation generates keys where p - 1 is smooth, as a result short exponents can leak enough information about k to allow decryption.",
        "func_before": "secure_vector<uint8_t>\nElGamal_Encryption_Operation::raw_encrypt(const uint8_t msg[], size_t msg_len,\n                                          RandomNumberGenerator& rng)\n   {\n   BigInt m(msg, msg_len);\n\n   if(m >= m_group.get_p())\n      throw Invalid_Argument(\"ElGamal encryption: Input is too large\");\n\n   const size_t k_bits = m_group.exponent_bits();\n   const BigInt k(rng, k_bits);\n\n   const BigInt a = m_group.power_g_p(k, k_bits);\n   const BigInt b = m_group.multiply_mod_p(m, monty_execute(*m_monty_y_p, k, k_bits));\n\n   return BigInt::encode_fixed_length_int_pair(a, b, m_group.p_bytes());\n   }",
        "func": "secure_vector<uint8_t>\nElGamal_Encryption_Operation::raw_encrypt(const uint8_t msg[], size_t msg_len,\n                                          RandomNumberGenerator& rng)\n   {\n   BigInt m(msg, msg_len);\n\n   if(m >= m_group.get_p())\n      throw Invalid_Argument(\"ElGamal encryption: Input is too large\");\n\n   /*\n   Some ElGamal implementations foolishly use prime fields where p - 1 is\n   smooth, as a result it is unsafe to use short exponents.\n   */\n   const size_t k_bits = m_group.p_bits() - 1;\n   const BigInt k(rng, k_bits, false);\n\n   const BigInt a = m_group.power_g_p(k, k_bits);\n   const BigInt b = m_group.multiply_mod_p(m, monty_execute(*m_monty_y_p, k, k_bits));\n\n   return BigInt::encode_fixed_length_int_pair(a, b, m_group.p_bytes());\n   }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,8 +7,12 @@\n    if(m >= m_group.get_p())\n       throw Invalid_Argument(\"ElGamal encryption: Input is too large\");\n \n-   const size_t k_bits = m_group.exponent_bits();\n-   const BigInt k(rng, k_bits);\n+   /*\n+   Some ElGamal implementations foolishly use prime fields where p - 1 is\n+   smooth, as a result it is unsafe to use short exponents.\n+   */\n+   const size_t k_bits = m_group.p_bits() - 1;\n+   const BigInt k(rng, k_bits, false);\n \n    const BigInt a = m_group.power_g_p(k, k_bits);\n    const BigInt b = m_group.multiply_mod_p(m, monty_execute(*m_monty_y_p, k, k_bits));",
        "diff_line_info": {
            "deleted_lines": [
                "   const size_t k_bits = m_group.exponent_bits();",
                "   const BigInt k(rng, k_bits);"
            ],
            "added_lines": [
                "   /*",
                "   Some ElGamal implementations foolishly use prime fields where p - 1 is",
                "   smooth, as a result it is unsafe to use short exponents.",
                "   */",
                "   const size_t k_bits = m_group.p_bits() - 1;",
                "   const BigInt k(rng, k_bits, false);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1434",
        "func_name": "openssl/rc4_hmac_md5_set_ctx_params",
        "description": "The OpenSSL 3.0 implementation of the RC4-MD5 ciphersuite incorrectly uses the AAD data as the MAC key. This makes the MAC key trivially predictable. An attacker could exploit this issue by performing a man-in-the-middle attack to modify data being sent from one endpoint to an OpenSSL 3.0 recipient such that the modified data would still pass the MAC integrity check. Note that data sent from an OpenSSL 3.0 endpoint to a non-OpenSSL 3.0 endpoint will always be rejected by the recipient and the connection will fail at that point. Many application protocols require data to be sent from the client to the server first. Therefore, in such a case, only an OpenSSL 3.0 server would be impacted when talking to a non-OpenSSL 3.0 client. If both endpoints are OpenSSL 3.0 then the attacker could modify data being sent in both directions. In this case both clients and servers could be affected, regardless of the application protocol. Note that in the absence of an attacker this bug means that an OpenSSL 3.0 endpoint communicating with a non-OpenSSL 3.0 endpoint will fail to complete the handshake when using this ciphersuite. The confidentiality of data is not impacted by this issue, i.e. an attacker cannot decrypt data that has been encrypted using this ciphersuite - they can only modify it. In order for this attack to work both endpoints must legitimately negotiate the RC4-MD5 ciphersuite. This ciphersuite is not compiled by default in OpenSSL 3.0, and is not available within the default provider or the default ciphersuite list. This ciphersuite will never be used if TLSv1.3 has been negotiated. In order for an OpenSSL 3.0 endpoint to use this ciphersuite the following must have occurred: 1) OpenSSL must have been compiled with the (non-default) compile time option enable-weak-ssl-ciphers 2) OpenSSL must have had the legacy provider explicitly loaded (either through application code or via configuration) 3) The ciphersuite must have been explicitly added to the ciphersuite list 4) The libssl security level must have been set to 0 (default is 1) 5) A version of SSL/TLS below TLSv1.3 must have been negotiated 6) Both endpoints must negotiate the RC4-MD5 ciphersuite in preference to any others that both endpoints have in common Fixed in OpenSSL 3.0.3 (Affected 3.0.0,3.0.1,3.0.2).",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=7d56a74a96828985db7354a55227a511615f732b",
        "commit_title": "",
        "commit_text": "Fix the RC4-MD5 cipher  A copy&paste error meant that the RC4-MD5 cipher (used in TLS) used the TLS AAD data as the MAC key.  CVE-2022-1434  Fixes #18112  ",
        "func_before": "static int rc4_hmac_md5_set_ctx_params(void *vctx, const OSSL_PARAM params[])\n{\n    PROV_RC4_HMAC_MD5_CTX *ctx = (PROV_RC4_HMAC_MD5_CTX *)vctx;\n    const OSSL_PARAM *p;\n    size_t sz;\n\n    if (params == NULL)\n        return 1;\n\n    p = OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_KEYLEN);\n    if (p != NULL) {\n        if (!OSSL_PARAM_get_size_t(p, &sz)) {\n            ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_GET_PARAMETER);\n            return 0;\n        }\n        if (ctx->base.keylen != sz) {\n            ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_KEY_LENGTH);\n            return 0;\n        }\n    }\n\n    p = OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_IVLEN);\n    if (p != NULL) {\n        if (!OSSL_PARAM_get_size_t(p, &sz)) {\n            ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_GET_PARAMETER);\n            return 0;\n        }\n        if (ctx->base.ivlen != sz) {\n            ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_IV_LENGTH);\n            return 0;\n        }\n    }\n\n    p = OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_AEAD_TLS1_AAD);\n    if (p != NULL) {\n        if (p->data_type != OSSL_PARAM_OCTET_STRING) {\n            ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_GET_PARAMETER);\n            return 0;\n        }\n        sz = GET_HW(ctx)->tls_init(&ctx->base, p->data, p->data_size);\n        if (sz == 0) {\n            ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_DATA);\n            return 0;\n        }\n        ctx->tls_aad_pad_sz = sz;\n    }\n    p = OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_AEAD_TLS1_AAD);\n    if (p != NULL) {\n        if (p->data_type != OSSL_PARAM_OCTET_STRING) {\n            ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_GET_PARAMETER);\n            return 0;\n        }\n        GET_HW(ctx)->init_mackey(&ctx->base, p->data, p->data_size);\n    }\n    p = OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_TLS_VERSION);\n    if (p != NULL) {\n        if (!OSSL_PARAM_get_uint(p, &ctx->base.tlsversion)) {\n            ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_GET_PARAMETER);\n            return 0;\n        }\n    }\n\n    return 1;\n}",
        "func": "static int rc4_hmac_md5_set_ctx_params(void *vctx, const OSSL_PARAM params[])\n{\n    PROV_RC4_HMAC_MD5_CTX *ctx = (PROV_RC4_HMAC_MD5_CTX *)vctx;\n    const OSSL_PARAM *p;\n    size_t sz;\n\n    if (params == NULL)\n        return 1;\n\n    p = OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_KEYLEN);\n    if (p != NULL) {\n        if (!OSSL_PARAM_get_size_t(p, &sz)) {\n            ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_GET_PARAMETER);\n            return 0;\n        }\n        if (ctx->base.keylen != sz) {\n            ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_KEY_LENGTH);\n            return 0;\n        }\n    }\n\n    p = OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_IVLEN);\n    if (p != NULL) {\n        if (!OSSL_PARAM_get_size_t(p, &sz)) {\n            ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_GET_PARAMETER);\n            return 0;\n        }\n        if (ctx->base.ivlen != sz) {\n            ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_IV_LENGTH);\n            return 0;\n        }\n    }\n\n    p = OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_AEAD_TLS1_AAD);\n    if (p != NULL) {\n        if (p->data_type != OSSL_PARAM_OCTET_STRING) {\n            ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_GET_PARAMETER);\n            return 0;\n        }\n        sz = GET_HW(ctx)->tls_init(&ctx->base, p->data, p->data_size);\n        if (sz == 0) {\n            ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_DATA);\n            return 0;\n        }\n        ctx->tls_aad_pad_sz = sz;\n    }\n    p = OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_AEAD_MAC_KEY);\n    if (p != NULL) {\n        if (p->data_type != OSSL_PARAM_OCTET_STRING) {\n            ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_GET_PARAMETER);\n            return 0;\n        }\n        GET_HW(ctx)->init_mackey(&ctx->base, p->data, p->data_size);\n    }\n    p = OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_TLS_VERSION);\n    if (p != NULL) {\n        if (!OSSL_PARAM_get_uint(p, &ctx->base.tlsversion)) {\n            ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_GET_PARAMETER);\n            return 0;\n        }\n    }\n\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -44,7 +44,7 @@\n         }\n         ctx->tls_aad_pad_sz = sz;\n     }\n-    p = OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_AEAD_TLS1_AAD);\n+    p = OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_AEAD_MAC_KEY);\n     if (p != NULL) {\n         if (p->data_type != OSSL_PARAM_OCTET_STRING) {\n             ERR_raise(ERR_LIB_PROV, PROV_R_FAILED_TO_GET_PARAMETER);",
        "diff_line_info": {
            "deleted_lines": [
                "    p = OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_AEAD_TLS1_AAD);"
            ],
            "added_lines": [
                "    p = OSSL_PARAM_locate_const(params, OSSL_CIPHER_PARAM_AEAD_MAC_KEY);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-0734",
        "func_name": "openssl/dsa_sign_setup",
        "description": "The OpenSSL DSA signature algorithm has been shown to be vulnerable to a timing side channel attack. An attacker could use variations in the signing algorithm to recover the private key. Fixed in OpenSSL 1.1.1a (Affected 1.1.1). Fixed in OpenSSL 1.1.0j (Affected 1.1.0-1.1.0i). Fixed in OpenSSL 1.0.2q (Affected 1.0.2-1.0.2p).",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=8abfe72e8c1de1b95f50aa0d9134803b4d00070f",
        "commit_title": "",
        "commit_text": "Timing vulnerability in DSA signature generation (CVE-2018-0734).  Avoid a timing attack that leaks information via a side channel that triggers when a BN is resized.  Increasing the size of the BNs prior to doing anything with them suppresses the attack.  Thanks due to Samuel Weiser for finding and locating this.  (Merged from https://github.com/openssl/openssl/pull/7486)  (cherry picked from commit a9cfb8c2aa7254a4aa6a1716909e3f8cb78049b6) ",
        "func_before": "static int dsa_sign_setup(DSA *dsa, BN_CTX *ctx_in,\n                          BIGNUM **kinvp, BIGNUM **rp,\n                          const unsigned char *dgst, int dlen)\n{\n    BN_CTX *ctx = NULL;\n    BIGNUM *k, *kinv = NULL, *r = *rp;\n    BIGNUM *l, *m;\n    int ret = 0;\n    int q_bits;\n\n    if (!dsa->p || !dsa->q || !dsa->g) {\n        DSAerr(DSA_F_DSA_SIGN_SETUP, DSA_R_MISSING_PARAMETERS);\n        return 0;\n    }\n\n    k = BN_new();\n    l = BN_new();\n    m = BN_new();\n    if (k == NULL || l == NULL || m == NULL)\n        goto err;\n\n    if (ctx_in == NULL) {\n        if ((ctx = BN_CTX_new()) == NULL)\n            goto err;\n    } else\n        ctx = ctx_in;\n\n    /* Preallocate space */\n    q_bits = BN_num_bits(dsa->q);\n    if (!BN_set_bit(k, q_bits)\n        || !BN_set_bit(l, q_bits)\n        || !BN_set_bit(m, q_bits))\n        goto err;\n\n    /* Get random k */\n    do {\n        if (dgst != NULL) {\n            /*\n             * We calculate k from SHA512(private_key + H(message) + random).\n             * This protects the private key from a weak PRNG.\n             */\n            if (!BN_generate_dsa_nonce(k, dsa->q, dsa->priv_key, dgst,\n                                       dlen, ctx))\n                goto err;\n        } else if (!BN_priv_rand_range(k, dsa->q))\n            goto err;\n    } while (BN_is_zero(k));\n\n    BN_set_flags(k, BN_FLG_CONSTTIME);\n\n    if (dsa->flags & DSA_FLAG_CACHE_MONT_P) {\n        if (!BN_MONT_CTX_set_locked(&dsa->method_mont_p,\n                                    dsa->lock, dsa->p, ctx))\n            goto err;\n    }\n\n    /* Compute r = (g^k mod p) mod q */\n\n    /*\n     * We do not want timing information to leak the length of k, so we\n     * compute G^k using an equivalent scalar of fixed bit-length.\n     *\n     * We unconditionally perform both of these additions to prevent a\n     * small timing information leakage.  We then choose the sum that is\n     * one bit longer than the modulus.\n     *\n     * TODO: revisit the BN_copy aiming for a memory access agnostic\n     * conditional copy.\n     */\n    if (!BN_add(l, k, dsa->q)\n        || !BN_add(m, l, dsa->q)\n        || !BN_copy(k, BN_num_bits(l) > q_bits ? l : m))\n        goto err;\n\n    if ((dsa)->meth->bn_mod_exp != NULL) {\n            if (!dsa->meth->bn_mod_exp(dsa, r, dsa->g, k, dsa->p, ctx,\n                                       dsa->method_mont_p))\n                goto err;\n    } else {\n            if (!BN_mod_exp_mont(r, dsa->g, k, dsa->p, ctx, dsa->method_mont_p))\n                goto err;\n    }\n\n    if (!BN_mod(r, r, dsa->q, ctx))\n        goto err;\n\n    /* Compute  part of 's = inv(k) (m + xr) mod q' */\n    if ((kinv = dsa_mod_inverse_fermat(k, dsa->q, ctx)) == NULL)\n        goto err;\n\n    BN_clear_free(*kinvp);\n    *kinvp = kinv;\n    kinv = NULL;\n    ret = 1;\n err:\n    if (!ret)\n        DSAerr(DSA_F_DSA_SIGN_SETUP, ERR_R_BN_LIB);\n    if (ctx != ctx_in)\n        BN_CTX_free(ctx);\n    BN_clear_free(k);\n    BN_clear_free(l);\n    BN_clear_free(m);\n    return ret;\n}",
        "func": "static int dsa_sign_setup(DSA *dsa, BN_CTX *ctx_in,\n                          BIGNUM **kinvp, BIGNUM **rp,\n                          const unsigned char *dgst, int dlen)\n{\n    BN_CTX *ctx = NULL;\n    BIGNUM *k, *kinv = NULL, *r = *rp;\n    BIGNUM *l;\n    int ret = 0;\n    int q_bits, q_words;\n\n    if (!dsa->p || !dsa->q || !dsa->g) {\n        DSAerr(DSA_F_DSA_SIGN_SETUP, DSA_R_MISSING_PARAMETERS);\n        return 0;\n    }\n\n    k = BN_new();\n    l = BN_new();\n    if (k == NULL || l == NULL)\n        goto err;\n\n    if (ctx_in == NULL) {\n        if ((ctx = BN_CTX_new()) == NULL)\n            goto err;\n    } else\n        ctx = ctx_in;\n\n    /* Preallocate space */\n    q_bits = BN_num_bits(dsa->q);\n    q_words = bn_get_top(dsa->q);\n    if (!bn_wexpand(k, q_words + 2)\n        || !bn_wexpand(l, q_words + 2))\n        goto err;\n\n    /* Get random k */\n    do {\n        if (dgst != NULL) {\n            /*\n             * We calculate k from SHA512(private_key + H(message) + random).\n             * This protects the private key from a weak PRNG.\n             */\n            if (!BN_generate_dsa_nonce(k, dsa->q, dsa->priv_key, dgst,\n                                       dlen, ctx))\n                goto err;\n        } else if (!BN_priv_rand_range(k, dsa->q))\n            goto err;\n    } while (BN_is_zero(k));\n\n    BN_set_flags(k, BN_FLG_CONSTTIME);\n\n    if (dsa->flags & DSA_FLAG_CACHE_MONT_P) {\n        if (!BN_MONT_CTX_set_locked(&dsa->method_mont_p,\n                                    dsa->lock, dsa->p, ctx))\n            goto err;\n    }\n\n    /* Compute r = (g^k mod p) mod q */\n\n    /*\n     * We do not want timing information to leak the length of k, so we\n     * compute G^k using an equivalent scalar of fixed bit-length.\n     *\n     * We unconditionally perform both of these additions to prevent a\n     * small timing information leakage.  We then choose the sum that is\n     * one bit longer than the modulus.\n     *\n     * There are some concerns about the efficacy of doing this.  More\n     * specificly refer to the discussion starting with:\n     *     https://github.com/openssl/openssl/pull/7486#discussion_r228323705\n     * The fix is to rework BN so these gymnastics aren't required.\n     */\n    if (!BN_add(l, k, dsa->q)\n        || !BN_add(k, l, dsa->q))\n        goto err;\n\n    BN_consttime_swap(BN_is_bit_set(l, q_bits), k, l, q_words + 2);\n\n    if ((dsa)->meth->bn_mod_exp != NULL) {\n            if (!dsa->meth->bn_mod_exp(dsa, r, dsa->g, k, dsa->p, ctx,\n                                       dsa->method_mont_p))\n                goto err;\n    } else {\n            if (!BN_mod_exp_mont(r, dsa->g, k, dsa->p, ctx, dsa->method_mont_p))\n                goto err;\n    }\n\n    if (!BN_mod(r, r, dsa->q, ctx))\n        goto err;\n\n    /* Compute part of 's = inv(k) (m + xr) mod q' */\n    if ((kinv = dsa_mod_inverse_fermat(k, dsa->q, ctx)) == NULL)\n        goto err;\n\n    BN_clear_free(*kinvp);\n    *kinvp = kinv;\n    kinv = NULL;\n    ret = 1;\n err:\n    if (!ret)\n        DSAerr(DSA_F_DSA_SIGN_SETUP, ERR_R_BN_LIB);\n    if (ctx != ctx_in)\n        BN_CTX_free(ctx);\n    BN_clear_free(k);\n    BN_clear_free(l);\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,9 +4,9 @@\n {\n     BN_CTX *ctx = NULL;\n     BIGNUM *k, *kinv = NULL, *r = *rp;\n-    BIGNUM *l, *m;\n+    BIGNUM *l;\n     int ret = 0;\n-    int q_bits;\n+    int q_bits, q_words;\n \n     if (!dsa->p || !dsa->q || !dsa->g) {\n         DSAerr(DSA_F_DSA_SIGN_SETUP, DSA_R_MISSING_PARAMETERS);\n@@ -15,8 +15,7 @@\n \n     k = BN_new();\n     l = BN_new();\n-    m = BN_new();\n-    if (k == NULL || l == NULL || m == NULL)\n+    if (k == NULL || l == NULL)\n         goto err;\n \n     if (ctx_in == NULL) {\n@@ -27,9 +26,9 @@\n \n     /* Preallocate space */\n     q_bits = BN_num_bits(dsa->q);\n-    if (!BN_set_bit(k, q_bits)\n-        || !BN_set_bit(l, q_bits)\n-        || !BN_set_bit(m, q_bits))\n+    q_words = bn_get_top(dsa->q);\n+    if (!bn_wexpand(k, q_words + 2)\n+        || !bn_wexpand(l, q_words + 2))\n         goto err;\n \n     /* Get random k */\n@@ -64,13 +63,16 @@\n      * small timing information leakage.  We then choose the sum that is\n      * one bit longer than the modulus.\n      *\n-     * TODO: revisit the BN_copy aiming for a memory access agnostic\n-     * conditional copy.\n+     * There are some concerns about the efficacy of doing this.  More\n+     * specificly refer to the discussion starting with:\n+     *     https://github.com/openssl/openssl/pull/7486#discussion_r228323705\n+     * The fix is to rework BN so these gymnastics aren't required.\n      */\n     if (!BN_add(l, k, dsa->q)\n-        || !BN_add(m, l, dsa->q)\n-        || !BN_copy(k, BN_num_bits(l) > q_bits ? l : m))\n+        || !BN_add(k, l, dsa->q))\n         goto err;\n+\n+    BN_consttime_swap(BN_is_bit_set(l, q_bits), k, l, q_words + 2);\n \n     if ((dsa)->meth->bn_mod_exp != NULL) {\n             if (!dsa->meth->bn_mod_exp(dsa, r, dsa->g, k, dsa->p, ctx,\n@@ -84,7 +86,7 @@\n     if (!BN_mod(r, r, dsa->q, ctx))\n         goto err;\n \n-    /* Compute  part of 's = inv(k) (m + xr) mod q' */\n+    /* Compute part of 's = inv(k) (m + xr) mod q' */\n     if ((kinv = dsa_mod_inverse_fermat(k, dsa->q, ctx)) == NULL)\n         goto err;\n \n@@ -99,6 +101,5 @@\n         BN_CTX_free(ctx);\n     BN_clear_free(k);\n     BN_clear_free(l);\n-    BN_clear_free(m);\n     return ret;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    BIGNUM *l, *m;",
                "    int q_bits;",
                "    m = BN_new();",
                "    if (k == NULL || l == NULL || m == NULL)",
                "    if (!BN_set_bit(k, q_bits)",
                "        || !BN_set_bit(l, q_bits)",
                "        || !BN_set_bit(m, q_bits))",
                "     * TODO: revisit the BN_copy aiming for a memory access agnostic",
                "     * conditional copy.",
                "        || !BN_add(m, l, dsa->q)",
                "        || !BN_copy(k, BN_num_bits(l) > q_bits ? l : m))",
                "    /* Compute  part of 's = inv(k) (m + xr) mod q' */",
                "    BN_clear_free(m);"
            ],
            "added_lines": [
                "    BIGNUM *l;",
                "    int q_bits, q_words;",
                "    if (k == NULL || l == NULL)",
                "    q_words = bn_get_top(dsa->q);",
                "    if (!bn_wexpand(k, q_words + 2)",
                "        || !bn_wexpand(l, q_words + 2))",
                "     * There are some concerns about the efficacy of doing this.  More",
                "     * specificly refer to the discussion starting with:",
                "     *     https://github.com/openssl/openssl/pull/7486#discussion_r228323705",
                "     * The fix is to rework BN so these gymnastics aren't required.",
                "        || !BN_add(k, l, dsa->q))",
                "",
                "    BN_consttime_swap(BN_is_bit_set(l, q_bits), k, l, q_words + 2);",
                "    /* Compute part of 's = inv(k) (m + xr) mod q' */"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-0734",
        "func_name": "openssl/dsa_sign_setup",
        "description": "The OpenSSL DSA signature algorithm has been shown to be vulnerable to a timing side channel attack. An attacker could use variations in the signing algorithm to recover the private key. Fixed in OpenSSL 1.1.1a (Affected 1.1.1). Fixed in OpenSSL 1.1.0j (Affected 1.1.0-1.1.0i). Fixed in OpenSSL 1.0.2q (Affected 1.0.2-1.0.2p).",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=ef11e19d1365eea2b1851e6f540a0bf365d303e7",
        "commit_title": "",
        "commit_text": "Timing vulnerability in DSA signature generation (CVE-2018-0734).  Avoid a timing attack that leaks information via a side channel that triggers when a BN is resized.  Increasing the size of the BNs prior to doing anything with them suppresses the attack.  Thanks due to Samuel Weiser for finding and locating this.  (Merged from https://github.com/openssl/openssl/pull/7486)  (cherry picked from commit a9cfb8c2aa7254a4aa6a1716909e3f8cb78049b6) ",
        "func_before": "static int dsa_sign_setup(DSA *dsa, BN_CTX *ctx_in,\n                          BIGNUM **kinvp, BIGNUM **rp,\n                          const unsigned char *dgst, int dlen)\n{\n    BN_CTX *ctx = NULL;\n    BIGNUM *k, *kinv = NULL, *r = *rp;\n    BIGNUM *l, *m;\n    int ret = 0;\n    int q_bits;\n\n    if (!dsa->p || !dsa->q || !dsa->g) {\n        DSAerr(DSA_F_DSA_SIGN_SETUP, DSA_R_MISSING_PARAMETERS);\n        return 0;\n    }\n\n    k = BN_new();\n    l = BN_new();\n    m = BN_new();\n    if (k == NULL || l == NULL || m == NULL)\n        goto err;\n\n    if (ctx_in == NULL) {\n        if ((ctx = BN_CTX_new()) == NULL)\n            goto err;\n    } else\n        ctx = ctx_in;\n\n    /* Preallocate space */\n    q_bits = BN_num_bits(dsa->q);\n    if (!BN_set_bit(k, q_bits)\n        || !BN_set_bit(l, q_bits)\n        || !BN_set_bit(m, q_bits))\n        goto err;\n\n    /* Get random k */\n    do {\n        if (dgst != NULL) {\n            /*\n             * We calculate k from SHA512(private_key + H(message) + random).\n             * This protects the private key from a weak PRNG.\n             */\n            if (!BN_generate_dsa_nonce(k, dsa->q, dsa->priv_key, dgst,\n                                       dlen, ctx))\n                goto err;\n        } else if (!BN_rand_range(k, dsa->q))\n            goto err;\n    } while (BN_is_zero(k));\n\n    BN_set_flags(k, BN_FLG_CONSTTIME);\n\n    if (dsa->flags & DSA_FLAG_CACHE_MONT_P) {\n        if (!BN_MONT_CTX_set_locked(&dsa->method_mont_p,\n                                    dsa->lock, dsa->p, ctx))\n            goto err;\n    }\n\n    /* Compute r = (g^k mod p) mod q */\n\n    /*\n     * We do not want timing information to leak the length of k, so we\n     * compute G^k using an equivalent scalar of fixed bit-length.\n     *\n     * We unconditionally perform both of these additions to prevent a\n     * small timing information leakage.  We then choose the sum that is\n     * one bit longer than the modulus.\n     *\n     * TODO: revisit the BN_copy aiming for a memory access agnostic\n     * conditional copy.\n     */\n    if (!BN_add(l, k, dsa->q)\n        || !BN_add(m, l, dsa->q)\n        || !BN_copy(k, BN_num_bits(l) > q_bits ? l : m))\n        goto err;\n\n    if ((dsa)->meth->bn_mod_exp != NULL) {\n            if (!dsa->meth->bn_mod_exp(dsa, r, dsa->g, k, dsa->p, ctx,\n                                       dsa->method_mont_p))\n                goto err;\n    } else {\n            if (!BN_mod_exp_mont(r, dsa->g, k, dsa->p, ctx, dsa->method_mont_p))\n                goto err;\n    }\n\n    if (!BN_mod(r, r, dsa->q, ctx))\n        goto err;\n\n    /* Compute  part of 's = inv(k) (m + xr) mod q' */\n    if ((kinv = dsa_mod_inverse_fermat(k, dsa->q, ctx)) == NULL)\n        goto err;\n\n    BN_clear_free(*kinvp);\n    *kinvp = kinv;\n    kinv = NULL;\n    ret = 1;\n err:\n    if (!ret)\n        DSAerr(DSA_F_DSA_SIGN_SETUP, ERR_R_BN_LIB);\n    if (ctx != ctx_in)\n        BN_CTX_free(ctx);\n    BN_clear_free(k);\n    BN_clear_free(l);\n    BN_clear_free(m);\n    return ret;\n}",
        "func": "static int dsa_sign_setup(DSA *dsa, BN_CTX *ctx_in,\n                          BIGNUM **kinvp, BIGNUM **rp,\n                          const unsigned char *dgst, int dlen)\n{\n    BN_CTX *ctx = NULL;\n    BIGNUM *k, *kinv = NULL, *r = *rp;\n    BIGNUM *l;\n    int ret = 0;\n    int q_bits, q_words;\n\n    if (!dsa->p || !dsa->q || !dsa->g) {\n        DSAerr(DSA_F_DSA_SIGN_SETUP, DSA_R_MISSING_PARAMETERS);\n        return 0;\n    }\n\n    k = BN_new();\n    l = BN_new();\n    if (k == NULL || l == NULL)\n        goto err;\n\n    if (ctx_in == NULL) {\n        if ((ctx = BN_CTX_new()) == NULL)\n            goto err;\n    } else\n        ctx = ctx_in;\n\n    /* Preallocate space */\n    q_bits = BN_num_bits(dsa->q);\n    q_words = bn_get_top(dsa->q);\n    if (!bn_wexpand(k, q_words + 2)\n        || !bn_wexpand(l, q_words + 2))\n        goto err;\n\n    /* Get random k */\n    do {\n        if (dgst != NULL) {\n            /*\n             * We calculate k from SHA512(private_key + H(message) + random).\n             * This protects the private key from a weak PRNG.\n             */\n            if (!BN_generate_dsa_nonce(k, dsa->q, dsa->priv_key, dgst,\n                                       dlen, ctx))\n                goto err;\n        } else if (!BN_rand_range(k, dsa->q))\n            goto err;\n    } while (BN_is_zero(k));\n\n    BN_set_flags(k, BN_FLG_CONSTTIME);\n\n    if (dsa->flags & DSA_FLAG_CACHE_MONT_P) {\n        if (!BN_MONT_CTX_set_locked(&dsa->method_mont_p,\n                                    dsa->lock, dsa->p, ctx))\n            goto err;\n    }\n\n    /* Compute r = (g^k mod p) mod q */\n\n    /*\n     * We do not want timing information to leak the length of k, so we\n     * compute G^k using an equivalent scalar of fixed bit-length.\n     *\n     * We unconditionally perform both of these additions to prevent a\n     * small timing information leakage.  We then choose the sum that is\n     * one bit longer than the modulus.\n     *\n     * There are some concerns about the efficacy of doing this.  More\n     * specificly refer to the discussion starting with:\n     *     https://github.com/openssl/openssl/pull/7486#discussion_r228323705\n     * The fix is to rework BN so these gymnastics aren't required.\n     */\n    if (!BN_add(l, k, dsa->q)\n        || !BN_add(k, l, dsa->q))\n        goto err;\n\n    BN_consttime_swap(BN_is_bit_set(l, q_bits), k, l, q_words + 2);\n\n    if ((dsa)->meth->bn_mod_exp != NULL) {\n            if (!dsa->meth->bn_mod_exp(dsa, r, dsa->g, k, dsa->p, ctx,\n                                       dsa->method_mont_p))\n                goto err;\n    } else {\n            if (!BN_mod_exp_mont(r, dsa->g, k, dsa->p, ctx, dsa->method_mont_p))\n                goto err;\n    }\n\n    if (!BN_mod(r, r, dsa->q, ctx))\n        goto err;\n\n    /* Compute part of 's = inv(k) (m + xr) mod q' */\n    if ((kinv = dsa_mod_inverse_fermat(k, dsa->q, ctx)) == NULL)\n        goto err;\n\n    BN_clear_free(*kinvp);\n    *kinvp = kinv;\n    kinv = NULL;\n    ret = 1;\n err:\n    if (!ret)\n        DSAerr(DSA_F_DSA_SIGN_SETUP, ERR_R_BN_LIB);\n    if (ctx != ctx_in)\n        BN_CTX_free(ctx);\n    BN_clear_free(k);\n    BN_clear_free(l);\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,9 +4,9 @@\n {\n     BN_CTX *ctx = NULL;\n     BIGNUM *k, *kinv = NULL, *r = *rp;\n-    BIGNUM *l, *m;\n+    BIGNUM *l;\n     int ret = 0;\n-    int q_bits;\n+    int q_bits, q_words;\n \n     if (!dsa->p || !dsa->q || !dsa->g) {\n         DSAerr(DSA_F_DSA_SIGN_SETUP, DSA_R_MISSING_PARAMETERS);\n@@ -15,8 +15,7 @@\n \n     k = BN_new();\n     l = BN_new();\n-    m = BN_new();\n-    if (k == NULL || l == NULL || m == NULL)\n+    if (k == NULL || l == NULL)\n         goto err;\n \n     if (ctx_in == NULL) {\n@@ -27,9 +26,9 @@\n \n     /* Preallocate space */\n     q_bits = BN_num_bits(dsa->q);\n-    if (!BN_set_bit(k, q_bits)\n-        || !BN_set_bit(l, q_bits)\n-        || !BN_set_bit(m, q_bits))\n+    q_words = bn_get_top(dsa->q);\n+    if (!bn_wexpand(k, q_words + 2)\n+        || !bn_wexpand(l, q_words + 2))\n         goto err;\n \n     /* Get random k */\n@@ -64,13 +63,16 @@\n      * small timing information leakage.  We then choose the sum that is\n      * one bit longer than the modulus.\n      *\n-     * TODO: revisit the BN_copy aiming for a memory access agnostic\n-     * conditional copy.\n+     * There are some concerns about the efficacy of doing this.  More\n+     * specificly refer to the discussion starting with:\n+     *     https://github.com/openssl/openssl/pull/7486#discussion_r228323705\n+     * The fix is to rework BN so these gymnastics aren't required.\n      */\n     if (!BN_add(l, k, dsa->q)\n-        || !BN_add(m, l, dsa->q)\n-        || !BN_copy(k, BN_num_bits(l) > q_bits ? l : m))\n+        || !BN_add(k, l, dsa->q))\n         goto err;\n+\n+    BN_consttime_swap(BN_is_bit_set(l, q_bits), k, l, q_words + 2);\n \n     if ((dsa)->meth->bn_mod_exp != NULL) {\n             if (!dsa->meth->bn_mod_exp(dsa, r, dsa->g, k, dsa->p, ctx,\n@@ -84,7 +86,7 @@\n     if (!BN_mod(r, r, dsa->q, ctx))\n         goto err;\n \n-    /* Compute  part of 's = inv(k) (m + xr) mod q' */\n+    /* Compute part of 's = inv(k) (m + xr) mod q' */\n     if ((kinv = dsa_mod_inverse_fermat(k, dsa->q, ctx)) == NULL)\n         goto err;\n \n@@ -99,6 +101,5 @@\n         BN_CTX_free(ctx);\n     BN_clear_free(k);\n     BN_clear_free(l);\n-    BN_clear_free(m);\n     return ret;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    BIGNUM *l, *m;",
                "    int q_bits;",
                "    m = BN_new();",
                "    if (k == NULL || l == NULL || m == NULL)",
                "    if (!BN_set_bit(k, q_bits)",
                "        || !BN_set_bit(l, q_bits)",
                "        || !BN_set_bit(m, q_bits))",
                "     * TODO: revisit the BN_copy aiming for a memory access agnostic",
                "     * conditional copy.",
                "        || !BN_add(m, l, dsa->q)",
                "        || !BN_copy(k, BN_num_bits(l) > q_bits ? l : m))",
                "    /* Compute  part of 's = inv(k) (m + xr) mod q' */",
                "    BN_clear_free(m);"
            ],
            "added_lines": [
                "    BIGNUM *l;",
                "    int q_bits, q_words;",
                "    if (k == NULL || l == NULL)",
                "    q_words = bn_get_top(dsa->q);",
                "    if (!bn_wexpand(k, q_words + 2)",
                "        || !bn_wexpand(l, q_words + 2))",
                "     * There are some concerns about the efficacy of doing this.  More",
                "     * specificly refer to the discussion starting with:",
                "     *     https://github.com/openssl/openssl/pull/7486#discussion_r228323705",
                "     * The fix is to rework BN so these gymnastics aren't required.",
                "        || !BN_add(k, l, dsa->q))",
                "",
                "    BN_consttime_swap(BN_is_bit_set(l, q_bits), k, l, q_words + 2);",
                "    /* Compute part of 's = inv(k) (m + xr) mod q' */"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-0734",
        "func_name": "openssl/dsa_sign_setup",
        "description": "The OpenSSL DSA signature algorithm has been shown to be vulnerable to a timing side channel attack. An attacker could use variations in the signing algorithm to recover the private key. Fixed in OpenSSL 1.1.1a (Affected 1.1.1). Fixed in OpenSSL 1.1.0j (Affected 1.1.0-1.1.0i). Fixed in OpenSSL 1.0.2q (Affected 1.0.2-1.0.2p).",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=43e6a58d4991a451daf4891ff05a48735df871ac",
        "commit_title": "",
        "commit_text": "Merge DSA reallocation timing fix CVE-2018-0734.  (Merged from https://github.com/openssl/openssl/pull/7513) ",
        "func_before": "static int dsa_sign_setup(DSA *dsa, BN_CTX *ctx_in, BIGNUM **kinvp,\n                          BIGNUM **rp)\n{\n    BN_CTX *ctx;\n    BIGNUM k, kq, *K, *kinv = NULL, *r = NULL;\n    BIGNUM l, m;\n    int ret = 0;\n    int q_bits;\n\n    if (!dsa->p || !dsa->q || !dsa->g) {\n        DSAerr(DSA_F_DSA_SIGN_SETUP, DSA_R_MISSING_PARAMETERS);\n        return 0;\n    }\n\n    BN_init(&k);\n    BN_init(&kq);\n    BN_init(&l);\n    BN_init(&m);\n\n    if (ctx_in == NULL) {\n        if ((ctx = BN_CTX_new()) == NULL)\n            goto err;\n    } else\n        ctx = ctx_in;\n\n    if ((r = BN_new()) == NULL)\n        goto err;\n\n    /* Preallocate space */\n    q_bits = BN_num_bits(dsa->q);\n    if (!BN_set_bit(&k, q_bits)\n        || !BN_set_bit(&l, q_bits)\n        || !BN_set_bit(&m, q_bits))\n        goto err;\n\n    /* Get random k */\n    do\n        if (!BN_rand_range(&k, dsa->q))\n            goto err;\n    while (BN_is_zero(&k));\n\n    if ((dsa->flags & DSA_FLAG_NO_EXP_CONSTTIME) == 0) {\n        BN_set_flags(&k, BN_FLG_CONSTTIME);\n    }\n\n\n    if (dsa->flags & DSA_FLAG_CACHE_MONT_P) {\n        if (!BN_MONT_CTX_set_locked(&dsa->method_mont_p,\n                                    CRYPTO_LOCK_DSA, dsa->p, ctx))\n            goto err;\n    }\n\n    /* Compute r = (g^k mod p) mod q */\n\n    if ((dsa->flags & DSA_FLAG_NO_EXP_CONSTTIME) == 0) {\n        /*\n         * We do not want timing information to leak the length of k, so we\n         * compute G^k using an equivalent scalar of fixed bit-length.\n         *\n         * We unconditionally perform both of these additions to prevent a\n         * small timing information leakage.  We then choose the sum that is\n         * one bit longer than the modulus.\n         *\n         * TODO: revisit the BN_copy aiming for a memory access agnostic\n         * conditional copy.\n         */\n        if (!BN_add(&l, &k, dsa->q)\n            || !BN_add(&m, &l, dsa->q)\n            || !BN_copy(&kq, BN_num_bits(&l) > q_bits ? &l : &m))\n            goto err;\n\n        BN_set_flags(&kq, BN_FLG_CONSTTIME);\n\n        K = &kq;\n    } else {\n        K = &k;\n    }\n\n    DSA_BN_MOD_EXP(goto err, dsa, r, dsa->g, K, dsa->p, ctx,\n                   dsa->method_mont_p);\n    if (!BN_mod(r, r, dsa->q, ctx))\n        goto err;\n\n    /* Compute  part of 's = inv(k) (m + xr) mod q' */\n    if ((kinv = BN_mod_inverse(NULL, &k, dsa->q, ctx)) == NULL)\n        goto err;\n\n    if (*kinvp != NULL)\n        BN_clear_free(*kinvp);\n    *kinvp = kinv;\n    kinv = NULL;\n    if (*rp != NULL)\n        BN_clear_free(*rp);\n    *rp = r;\n    ret = 1;\n err:\n    if (!ret) {\n        DSAerr(DSA_F_DSA_SIGN_SETUP, ERR_R_BN_LIB);\n        if (r != NULL)\n            BN_clear_free(r);\n    }\n    if (ctx_in == NULL)\n        BN_CTX_free(ctx);\n    BN_clear_free(&k);\n    BN_clear_free(&kq);\n    BN_clear_free(&l);\n    BN_clear_free(&m);\n    return ret;\n}",
        "func": "static int dsa_sign_setup(DSA *dsa, BN_CTX *ctx_in, BIGNUM **kinvp,\n                          BIGNUM **rp)\n{\n    BN_CTX *ctx;\n    BIGNUM k, kq, *K, *kinv = NULL, *r = NULL;\n    BIGNUM l, m;\n    int ret = 0;\n    int q_bits;\n\n    if (!dsa->p || !dsa->q || !dsa->g) {\n        DSAerr(DSA_F_DSA_SIGN_SETUP, DSA_R_MISSING_PARAMETERS);\n        return 0;\n    }\n\n    BN_init(&k);\n    BN_init(&kq);\n    BN_init(&l);\n    BN_init(&m);\n\n    if (ctx_in == NULL) {\n        if ((ctx = BN_CTX_new()) == NULL)\n            goto err;\n    } else\n        ctx = ctx_in;\n\n    if ((r = BN_new()) == NULL)\n        goto err;\n\n    /* Preallocate space */\n    q_bits = BN_num_bits(dsa->q) + sizeof(dsa->q->d[0]) * 16;\n    if (!BN_set_bit(&k, q_bits)\n        || !BN_set_bit(&l, q_bits)\n        || !BN_set_bit(&m, q_bits))\n        goto err;\n\n    /* Get random k */\n    do\n        if (!BN_rand_range(&k, dsa->q))\n            goto err;\n    while (BN_is_zero(&k));\n\n    if ((dsa->flags & DSA_FLAG_NO_EXP_CONSTTIME) == 0) {\n        BN_set_flags(&k, BN_FLG_CONSTTIME);\n    }\n\n\n    if (dsa->flags & DSA_FLAG_CACHE_MONT_P) {\n        if (!BN_MONT_CTX_set_locked(&dsa->method_mont_p,\n                                    CRYPTO_LOCK_DSA, dsa->p, ctx))\n            goto err;\n    }\n\n    /* Compute r = (g^k mod p) mod q */\n\n    if ((dsa->flags & DSA_FLAG_NO_EXP_CONSTTIME) == 0) {\n        /*\n         * We do not want timing information to leak the length of k, so we\n         * compute G^k using an equivalent scalar of fixed bit-length.\n         *\n         * We unconditionally perform both of these additions to prevent a\n         * small timing information leakage.  We then choose the sum that is\n         * one bit longer than the modulus.\n         *\n         * TODO: revisit the BN_copy aiming for a memory access agnostic\n         * conditional copy.\n         */\n        if (!BN_add(&l, &k, dsa->q)\n            || !BN_add(&m, &l, dsa->q)\n            || !BN_copy(&kq, BN_num_bits(&l) > q_bits ? &l : &m))\n            goto err;\n\n        BN_set_flags(&kq, BN_FLG_CONSTTIME);\n\n        K = &kq;\n    } else {\n        K = &k;\n    }\n\n    DSA_BN_MOD_EXP(goto err, dsa, r, dsa->g, K, dsa->p, ctx,\n                   dsa->method_mont_p);\n    if (!BN_mod(r, r, dsa->q, ctx))\n        goto err;\n\n    /* Compute  part of 's = inv(k) (m + xr) mod q' */\n    if ((kinv = BN_mod_inverse(NULL, &k, dsa->q, ctx)) == NULL)\n        goto err;\n\n    if (*kinvp != NULL)\n        BN_clear_free(*kinvp);\n    *kinvp = kinv;\n    kinv = NULL;\n    if (*rp != NULL)\n        BN_clear_free(*rp);\n    *rp = r;\n    ret = 1;\n err:\n    if (!ret) {\n        DSAerr(DSA_F_DSA_SIGN_SETUP, ERR_R_BN_LIB);\n        if (r != NULL)\n            BN_clear_free(r);\n    }\n    if (ctx_in == NULL)\n        BN_CTX_free(ctx);\n    BN_clear_free(&k);\n    BN_clear_free(&kq);\n    BN_clear_free(&l);\n    BN_clear_free(&m);\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -27,7 +27,7 @@\n         goto err;\n \n     /* Preallocate space */\n-    q_bits = BN_num_bits(dsa->q);\n+    q_bits = BN_num_bits(dsa->q) + sizeof(dsa->q->d[0]) * 16;\n     if (!BN_set_bit(&k, q_bits)\n         || !BN_set_bit(&l, q_bits)\n         || !BN_set_bit(&m, q_bits))",
        "diff_line_info": {
            "deleted_lines": [
                "    q_bits = BN_num_bits(dsa->q);"
            ],
            "added_lines": [
                "    q_bits = BN_num_bits(dsa->q) + sizeof(dsa->q->d[0]) * 16;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-45485",
        "func_name": "torvalds/linux/__ipv6_select_ident",
        "description": "In the IPv6 implementation in the Linux kernel before 5.13.3, net/ipv6/output_core.c has an information leak because of certain use of a hash table which, although big, doesn't properly consider that IPv6-based attackers can typically choose among many IPv6 source addresses.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=62f20e068ccc50d6ab66fdb72ba90da2b9418c99",
        "commit_title": "This is a complement to commit aa6dd211e4b1 (\"inet: use bigger hash",
        "commit_text": "table for IP ID generation\"), but focusing on some specific aspects of IPv6.  Contary to IPv4, IPv6 only uses packet IDs with fragments, and with a minimum MTU of 1280, it's much less easy to force a remote peer to produce many fragments to explore its ID sequence. In addition packet IDs are 32-bit in IPv6, which further complicates their analysis. On the other hand, it is often easier to choose among plenty of possible source addresses and partially work around the bigger hash table the commit above permits, which leaves IPv6 partially exposed to some possibilities of remote analysis at the risk of weakening some protocols like DNS if some IDs can be predicted with a good enough probability.  Given the wide range of permitted IDs, the risk of collision is extremely low so there's no need to rely on the positive increment algorithm that is shared with the IPv4 code via ip_idents_reserve(). We have a fast PRNG, so let's simply call prandom_u32() and be done with it.  Performance measurements at 10 Gbps couldn't show any difference with the previous code, even when using a single core, because due to the large fragments, we're limited to only ~930 kpps at 10 Gbps and the cost of the random generation is completely offset by other operations and by the network transfer time. In addition, this change removes the need to update a shared entry in the idents table so it may even end up being slightly faster on large scale systems where this matters.  The risk of at least one collision here is about 1/80 million among 10 IDs, 1/850k among 100 IDs, and still only 1/8.5k among 1000 IDs, which remains very low compared to IPv4 where all IDs are reused every 4 to 80ms on a 10 Gbps flow depending on packet sizes.  Link: https://lore.kernel.org/r/20210529110746.6796-1-w@1wt.eu ",
        "func_before": "static u32 __ipv6_select_ident(struct net *net,\n\t\t\t       const struct in6_addr *dst,\n\t\t\t       const struct in6_addr *src)\n{\n\tconst struct {\n\t\tstruct in6_addr dst;\n\t\tstruct in6_addr src;\n\t} __aligned(SIPHASH_ALIGNMENT) combined = {\n\t\t.dst = *dst,\n\t\t.src = *src,\n\t};\n\tu32 hash, id;\n\n\t/* Note the following code is not safe, but this is okay. */\n\tif (unlikely(siphash_key_is_zero(&net->ipv4.ip_id_key)))\n\t\tget_random_bytes(&net->ipv4.ip_id_key,\n\t\t\t\t sizeof(net->ipv4.ip_id_key));\n\n\thash = siphash(&combined, sizeof(combined), &net->ipv4.ip_id_key);\n\n\t/* Treat id of 0 as unset and if we get 0 back from ip_idents_reserve,\n\t * set the hight order instead thus minimizing possible future\n\t * collisions.\n\t */\n\tid = ip_idents_reserve(hash, 1);\n\tif (unlikely(!id))\n\t\tid = 1 << 31;\n\n\treturn id;\n}",
        "func": "static u32 __ipv6_select_ident(struct net *net,\n\t\t\t       const struct in6_addr *dst,\n\t\t\t       const struct in6_addr *src)\n{\n\tu32 id;\n\n\tdo {\n\t\tid = prandom_u32();\n\t} while (!id);\n\n\treturn id;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,29 +2,11 @@\n \t\t\t       const struct in6_addr *dst,\n \t\t\t       const struct in6_addr *src)\n {\n-\tconst struct {\n-\t\tstruct in6_addr dst;\n-\t\tstruct in6_addr src;\n-\t} __aligned(SIPHASH_ALIGNMENT) combined = {\n-\t\t.dst = *dst,\n-\t\t.src = *src,\n-\t};\n-\tu32 hash, id;\n+\tu32 id;\n \n-\t/* Note the following code is not safe, but this is okay. */\n-\tif (unlikely(siphash_key_is_zero(&net->ipv4.ip_id_key)))\n-\t\tget_random_bytes(&net->ipv4.ip_id_key,\n-\t\t\t\t sizeof(net->ipv4.ip_id_key));\n-\n-\thash = siphash(&combined, sizeof(combined), &net->ipv4.ip_id_key);\n-\n-\t/* Treat id of 0 as unset and if we get 0 back from ip_idents_reserve,\n-\t * set the hight order instead thus minimizing possible future\n-\t * collisions.\n-\t */\n-\tid = ip_idents_reserve(hash, 1);\n-\tif (unlikely(!id))\n-\t\tid = 1 << 31;\n+\tdo {\n+\t\tid = prandom_u32();\n+\t} while (!id);\n \n \treturn id;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tconst struct {",
                "\t\tstruct in6_addr dst;",
                "\t\tstruct in6_addr src;",
                "\t} __aligned(SIPHASH_ALIGNMENT) combined = {",
                "\t\t.dst = *dst,",
                "\t\t.src = *src,",
                "\t};",
                "\tu32 hash, id;",
                "\t/* Note the following code is not safe, but this is okay. */",
                "\tif (unlikely(siphash_key_is_zero(&net->ipv4.ip_id_key)))",
                "\t\tget_random_bytes(&net->ipv4.ip_id_key,",
                "\t\t\t\t sizeof(net->ipv4.ip_id_key));",
                "",
                "\thash = siphash(&combined, sizeof(combined), &net->ipv4.ip_id_key);",
                "",
                "\t/* Treat id of 0 as unset and if we get 0 back from ip_idents_reserve,",
                "\t * set the hight order instead thus minimizing possible future",
                "\t * collisions.",
                "\t */",
                "\tid = ip_idents_reserve(hash, 1);",
                "\tif (unlikely(!id))",
                "\t\tid = 1 << 31;"
            ],
            "added_lines": [
                "\tu32 id;",
                "\tdo {",
                "\t\tid = prandom_u32();",
                "\t} while (!id);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-45486",
        "func_name": "torvalds/linux/ip_idents_reserve",
        "description": "In the IPv4 implementation in the Linux kernel before 5.12.4, net/ipv4/route.c has an information leak because the hash table is very small.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/net/ipv4/route.c?h=aa6dd211e4b1dde9d5dc25d699d35f789ae7eeba",
        "commit_title": "In commit 73f156a6e8c1 (\"inetpeer: get rid of ip_id_count\")",
        "commit_text": "I used a very small hash table that could be abused by patient attackers to reveal sensitive information.  Switch to a dynamic sizing, depending on RAM size.  Typical big hosts will now use 128x more storage (2 MB) to get a similar increase in security and reduction of hash collisions.  As a bonus, use of alloc_large_system_hash() spreads allocated memory among all NUMA nodes.  Cc: Willy Tarreau <w@1wt.eu> ",
        "func_before": "u32 ip_idents_reserve(u32 hash, int segs)\n{\n\tu32 *p_tstamp = ip_tstamps + hash % IP_IDENTS_SZ;\n\tatomic_t *p_id = ip_idents + hash % IP_IDENTS_SZ;\n\tu32 old = READ_ONCE(*p_tstamp);\n\tu32 now = (u32)jiffies;\n\tu32 delta = 0;\n\n\tif (old != now && cmpxchg(p_tstamp, old, now) == old)\n\t\tdelta = prandom_u32_max(now - old);\n\n\t/* If UBSAN reports an error there, please make sure your compiler\n\t * supports -fno-strict-overflow before reporting it that was a bug\n\t * in UBSAN, and it has been fixed in GCC-8.\n\t */\n\treturn atomic_add_return(segs + delta, p_id) - segs;\n}",
        "func": "u32 ip_idents_reserve(u32 hash, int segs)\n{\n\tu32 bucket, old, now = (u32)jiffies;\n\tatomic_t *p_id;\n\tu32 *p_tstamp;\n\tu32 delta = 0;\n\n\tbucket = hash & ip_idents_mask;\n\tp_tstamp = ip_tstamps + bucket;\n\tp_id = ip_idents + bucket;\n\told = READ_ONCE(*p_tstamp);\n\n\tif (old != now && cmpxchg(p_tstamp, old, now) == old)\n\t\tdelta = prandom_u32_max(now - old);\n\n\t/* If UBSAN reports an error there, please make sure your compiler\n\t * supports -fno-strict-overflow before reporting it that was a bug\n\t * in UBSAN, and it has been fixed in GCC-8.\n\t */\n\treturn atomic_add_return(segs + delta, p_id) - segs;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,14 @@\n u32 ip_idents_reserve(u32 hash, int segs)\n {\n-\tu32 *p_tstamp = ip_tstamps + hash % IP_IDENTS_SZ;\n-\tatomic_t *p_id = ip_idents + hash % IP_IDENTS_SZ;\n-\tu32 old = READ_ONCE(*p_tstamp);\n-\tu32 now = (u32)jiffies;\n+\tu32 bucket, old, now = (u32)jiffies;\n+\tatomic_t *p_id;\n+\tu32 *p_tstamp;\n \tu32 delta = 0;\n+\n+\tbucket = hash & ip_idents_mask;\n+\tp_tstamp = ip_tstamps + bucket;\n+\tp_id = ip_idents + bucket;\n+\told = READ_ONCE(*p_tstamp);\n \n \tif (old != now && cmpxchg(p_tstamp, old, now) == old)\n \t\tdelta = prandom_u32_max(now - old);",
        "diff_line_info": {
            "deleted_lines": [
                "\tu32 *p_tstamp = ip_tstamps + hash % IP_IDENTS_SZ;",
                "\tatomic_t *p_id = ip_idents + hash % IP_IDENTS_SZ;",
                "\tu32 old = READ_ONCE(*p_tstamp);",
                "\tu32 now = (u32)jiffies;"
            ],
            "added_lines": [
                "\tu32 bucket, old, now = (u32)jiffies;",
                "\tatomic_t *p_id;",
                "\tu32 *p_tstamp;",
                "",
                "\tbucket = hash & ip_idents_mask;",
                "\tp_tstamp = ip_tstamps + bucket;",
                "\tp_id = ip_idents + bucket;",
                "\told = READ_ONCE(*p_tstamp);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-45486",
        "func_name": "torvalds/linux/ip_rt_init",
        "description": "In the IPv4 implementation in the Linux kernel before 5.12.4, net/ipv4/route.c has an information leak because the hash table is very small.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/net/ipv4/route.c?h=aa6dd211e4b1dde9d5dc25d699d35f789ae7eeba",
        "commit_title": "In commit 73f156a6e8c1 (\"inetpeer: get rid of ip_id_count\")",
        "commit_text": "I used a very small hash table that could be abused by patient attackers to reveal sensitive information.  Switch to a dynamic sizing, depending on RAM size.  Typical big hosts will now use 128x more storage (2 MB) to get a similar increase in security and reduction of hash collisions.  As a bonus, use of alloc_large_system_hash() spreads allocated memory among all NUMA nodes.  Cc: Willy Tarreau <w@1wt.eu> ",
        "func_before": "int __init ip_rt_init(void)\n{\n\tint cpu;\n\n\tip_idents = kmalloc_array(IP_IDENTS_SZ, sizeof(*ip_idents),\n\t\t\t\t  GFP_KERNEL);\n\tif (!ip_idents)\n\t\tpanic(\"IP: failed to allocate ip_idents\\n\");\n\n\tprandom_bytes(ip_idents, IP_IDENTS_SZ * sizeof(*ip_idents));\n\n\tip_tstamps = kcalloc(IP_IDENTS_SZ, sizeof(*ip_tstamps), GFP_KERNEL);\n\tif (!ip_tstamps)\n\t\tpanic(\"IP: failed to allocate ip_tstamps\\n\");\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct uncached_list *ul = &per_cpu(rt_uncached_list, cpu);\n\n\t\tINIT_LIST_HEAD(&ul->head);\n\t\tspin_lock_init(&ul->lock);\n\t}\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tip_rt_acct = __alloc_percpu(256 * sizeof(struct ip_rt_acct), __alignof__(struct ip_rt_acct));\n\tif (!ip_rt_acct)\n\t\tpanic(\"IP: failed to allocate ip_rt_acct\\n\");\n#endif\n\n\tipv4_dst_ops.kmem_cachep =\n\t\tkmem_cache_create(\"ip_dst_cache\", sizeof(struct rtable), 0,\n\t\t\t\t  SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n\n\tipv4_dst_blackhole_ops.kmem_cachep = ipv4_dst_ops.kmem_cachep;\n\n\tif (dst_entries_init(&ipv4_dst_ops) < 0)\n\t\tpanic(\"IP: failed to allocate ipv4_dst_ops counter\\n\");\n\n\tif (dst_entries_init(&ipv4_dst_blackhole_ops) < 0)\n\t\tpanic(\"IP: failed to allocate ipv4_dst_blackhole_ops counter\\n\");\n\n\tipv4_dst_ops.gc_thresh = ~0;\n\tip_rt_max_size = INT_MAX;\n\n\tdevinet_init();\n\tip_fib_init();\n\n\tif (ip_rt_proc_init())\n\t\tpr_err(\"Unable to create route proc files\\n\");\n#ifdef CONFIG_XFRM\n\txfrm_init();\n\txfrm4_init();\n#endif\n\trtnl_register(PF_INET, RTM_GETROUTE, inet_rtm_getroute, NULL,\n\t\t      RTNL_FLAG_DOIT_UNLOCKED);\n\n#ifdef CONFIG_SYSCTL\n\tregister_pernet_subsys(&sysctl_route_ops);\n#endif\n\tregister_pernet_subsys(&rt_genid_ops);\n\tregister_pernet_subsys(&ipv4_inetpeer_ops);\n\treturn 0;\n}",
        "func": "int __init ip_rt_init(void)\n{\n\tvoid *idents_hash;\n\tint cpu;\n\n\t/* For modern hosts, this will use 2 MB of memory */\n\tidents_hash = alloc_large_system_hash(\"IP idents\",\n\t\t\t\t\t      sizeof(*ip_idents) + sizeof(*ip_tstamps),\n\t\t\t\t\t      0,\n\t\t\t\t\t      16, /* one bucket per 64 KB */\n\t\t\t\t\t      HASH_ZERO,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      &ip_idents_mask,\n\t\t\t\t\t      2048,\n\t\t\t\t\t      256*1024);\n\n\tip_idents = idents_hash;\n\n\tprandom_bytes(ip_idents, (ip_idents_mask + 1) * sizeof(*ip_idents));\n\n\tip_tstamps = idents_hash + (ip_idents_mask + 1) * sizeof(*ip_idents);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct uncached_list *ul = &per_cpu(rt_uncached_list, cpu);\n\n\t\tINIT_LIST_HEAD(&ul->head);\n\t\tspin_lock_init(&ul->lock);\n\t}\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tip_rt_acct = __alloc_percpu(256 * sizeof(struct ip_rt_acct), __alignof__(struct ip_rt_acct));\n\tif (!ip_rt_acct)\n\t\tpanic(\"IP: failed to allocate ip_rt_acct\\n\");\n#endif\n\n\tipv4_dst_ops.kmem_cachep =\n\t\tkmem_cache_create(\"ip_dst_cache\", sizeof(struct rtable), 0,\n\t\t\t\t  SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n\n\tipv4_dst_blackhole_ops.kmem_cachep = ipv4_dst_ops.kmem_cachep;\n\n\tif (dst_entries_init(&ipv4_dst_ops) < 0)\n\t\tpanic(\"IP: failed to allocate ipv4_dst_ops counter\\n\");\n\n\tif (dst_entries_init(&ipv4_dst_blackhole_ops) < 0)\n\t\tpanic(\"IP: failed to allocate ipv4_dst_blackhole_ops counter\\n\");\n\n\tipv4_dst_ops.gc_thresh = ~0;\n\tip_rt_max_size = INT_MAX;\n\n\tdevinet_init();\n\tip_fib_init();\n\n\tif (ip_rt_proc_init())\n\t\tpr_err(\"Unable to create route proc files\\n\");\n#ifdef CONFIG_XFRM\n\txfrm_init();\n\txfrm4_init();\n#endif\n\trtnl_register(PF_INET, RTM_GETROUTE, inet_rtm_getroute, NULL,\n\t\t      RTNL_FLAG_DOIT_UNLOCKED);\n\n#ifdef CONFIG_SYSCTL\n\tregister_pernet_subsys(&sysctl_route_ops);\n#endif\n\tregister_pernet_subsys(&rt_genid_ops);\n\tregister_pernet_subsys(&ipv4_inetpeer_ops);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,17 +1,24 @@\n int __init ip_rt_init(void)\n {\n+\tvoid *idents_hash;\n \tint cpu;\n \n-\tip_idents = kmalloc_array(IP_IDENTS_SZ, sizeof(*ip_idents),\n-\t\t\t\t  GFP_KERNEL);\n-\tif (!ip_idents)\n-\t\tpanic(\"IP: failed to allocate ip_idents\\n\");\n+\t/* For modern hosts, this will use 2 MB of memory */\n+\tidents_hash = alloc_large_system_hash(\"IP idents\",\n+\t\t\t\t\t      sizeof(*ip_idents) + sizeof(*ip_tstamps),\n+\t\t\t\t\t      0,\n+\t\t\t\t\t      16, /* one bucket per 64 KB */\n+\t\t\t\t\t      HASH_ZERO,\n+\t\t\t\t\t      NULL,\n+\t\t\t\t\t      &ip_idents_mask,\n+\t\t\t\t\t      2048,\n+\t\t\t\t\t      256*1024);\n \n-\tprandom_bytes(ip_idents, IP_IDENTS_SZ * sizeof(*ip_idents));\n+\tip_idents = idents_hash;\n \n-\tip_tstamps = kcalloc(IP_IDENTS_SZ, sizeof(*ip_tstamps), GFP_KERNEL);\n-\tif (!ip_tstamps)\n-\t\tpanic(\"IP: failed to allocate ip_tstamps\\n\");\n+\tprandom_bytes(ip_idents, (ip_idents_mask + 1) * sizeof(*ip_idents));\n+\n+\tip_tstamps = idents_hash + (ip_idents_mask + 1) * sizeof(*ip_idents);\n \n \tfor_each_possible_cpu(cpu) {\n \t\tstruct uncached_list *ul = &per_cpu(rt_uncached_list, cpu);",
        "diff_line_info": {
            "deleted_lines": [
                "\tip_idents = kmalloc_array(IP_IDENTS_SZ, sizeof(*ip_idents),",
                "\t\t\t\t  GFP_KERNEL);",
                "\tif (!ip_idents)",
                "\t\tpanic(\"IP: failed to allocate ip_idents\\n\");",
                "\tprandom_bytes(ip_idents, IP_IDENTS_SZ * sizeof(*ip_idents));",
                "\tip_tstamps = kcalloc(IP_IDENTS_SZ, sizeof(*ip_tstamps), GFP_KERNEL);",
                "\tif (!ip_tstamps)",
                "\t\tpanic(\"IP: failed to allocate ip_tstamps\\n\");"
            ],
            "added_lines": [
                "\tvoid *idents_hash;",
                "\t/* For modern hosts, this will use 2 MB of memory */",
                "\tidents_hash = alloc_large_system_hash(\"IP idents\",",
                "\t\t\t\t\t      sizeof(*ip_idents) + sizeof(*ip_tstamps),",
                "\t\t\t\t\t      0,",
                "\t\t\t\t\t      16, /* one bucket per 64 KB */",
                "\t\t\t\t\t      HASH_ZERO,",
                "\t\t\t\t\t      NULL,",
                "\t\t\t\t\t      &ip_idents_mask,",
                "\t\t\t\t\t      2048,",
                "\t\t\t\t\t      256*1024);",
                "\tip_idents = idents_hash;",
                "\tprandom_bytes(ip_idents, (ip_idents_mask + 1) * sizeof(*ip_idents));",
                "",
                "\tip_tstamps = idents_hash + (ip_idents_mask + 1) * sizeof(*ip_idents);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-0737",
        "func_name": "openssl/rsa_builtin_keygen",
        "description": "The OpenSSL RSA Key generation algorithm has been shown to be vulnerable to a cache timing side channel attack. An attacker with sufficient access to mount cache timing attacks during the RSA key generation process could recover the private key. Fixed in OpenSSL 1.1.0i-dev (Affected 1.1.0-1.1.0h). Fixed in OpenSSL 1.0.2p-dev (Affected 1.0.2b-1.0.2o).",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=349a41da1ad88ad87825414752a8ff5fdd6a6c3f",
        "commit_title": "",
        "commit_text": "RSA key generation: ensure BN_mod_inverse and BN_mod_exp_mont both get called with BN_FLG_CONSTTIME flag set.  CVE-2018-0737  (cherry picked from commit 6939eab03a6e23d2bd2c3f5e34fe1d48e542e787) ",
        "func_before": "static int rsa_builtin_keygen(RSA *rsa, int bits, BIGNUM *e_value,\n                              BN_GENCB *cb)\n{\n    BIGNUM *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *tmp;\n    BIGNUM local_r0, local_d, local_p;\n    BIGNUM *pr0, *d, *p;\n    int bitsp, bitsq, ok = -1, n = 0;\n    BN_CTX *ctx = NULL;\n    unsigned long error = 0;\n\n    /*\n     * When generating ridiculously small keys, we can get stuck\n     * continually regenerating the same prime values.\n     */\n    if (bits < 16) {\n        ok = 0;             /* we set our own err */\n        RSAerr(RSA_F_RSA_BUILTIN_KEYGEN, RSA_R_KEY_SIZE_TOO_SMALL);\n        goto err;\n    }\n\n    ctx = BN_CTX_new();\n    if (ctx == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    r0 = BN_CTX_get(ctx);\n    r1 = BN_CTX_get(ctx);\n    r2 = BN_CTX_get(ctx);\n    r3 = BN_CTX_get(ctx);\n    if (r3 == NULL)\n        goto err;\n\n    bitsp = (bits + 1) / 2;\n    bitsq = bits - bitsp;\n\n    /* We need the RSA components non-NULL */\n    if (!rsa->n && ((rsa->n = BN_new()) == NULL))\n        goto err;\n    if (!rsa->d && ((rsa->d = BN_new()) == NULL))\n        goto err;\n    if (!rsa->e && ((rsa->e = BN_new()) == NULL))\n        goto err;\n    if (!rsa->p && ((rsa->p = BN_new()) == NULL))\n        goto err;\n    if (!rsa->q && ((rsa->q = BN_new()) == NULL))\n        goto err;\n    if (!rsa->dmp1 && ((rsa->dmp1 = BN_new()) == NULL))\n        goto err;\n    if (!rsa->dmq1 && ((rsa->dmq1 = BN_new()) == NULL))\n        goto err;\n    if (!rsa->iqmp && ((rsa->iqmp = BN_new()) == NULL))\n        goto err;\n\n    if (BN_copy(rsa->e, e_value) == NULL)\n        goto err;\n\n    BN_set_flags(r2, BN_FLG_CONSTTIME);\n    /* generate p and q */\n    for (;;) {\n        if (!BN_generate_prime_ex(rsa->p, bitsp, 0, NULL, NULL, cb))\n            goto err;\n        if (!BN_sub(r2, rsa->p, BN_value_one()))\n            goto err;\n        ERR_set_mark();\n        if (BN_mod_inverse(r1, r2, rsa->e, ctx) != NULL) {\n            /* GCD == 1 since inverse exists */\n            break;\n        }\n        error = ERR_peek_last_error();\n        if (ERR_GET_LIB(error) == ERR_LIB_BN\n            && ERR_GET_REASON(error) == BN_R_NO_INVERSE) {\n            /* GCD != 1 */\n            ERR_pop_to_mark();\n        } else {\n            goto err;\n        }\n        if (!BN_GENCB_call(cb, 2, n++))\n            goto err;\n    }\n    if (!BN_GENCB_call(cb, 3, 0))\n        goto err;\n    for (;;) {\n        do {\n            if (!BN_generate_prime_ex(rsa->q, bitsq, 0, NULL, NULL, cb))\n                goto err;\n        } while (BN_cmp(rsa->p, rsa->q) == 0);\n        if (!BN_sub(r2, rsa->q, BN_value_one()))\n            goto err;\n        ERR_set_mark();\n        if (BN_mod_inverse(r1, r2, rsa->e, ctx) != NULL) {\n            /* GCD == 1 since inverse exists */\n            break;\n        }\n        error = ERR_peek_last_error();\n        if (ERR_GET_LIB(error) == ERR_LIB_BN\n            && ERR_GET_REASON(error) == BN_R_NO_INVERSE) {\n            /* GCD != 1 */\n            ERR_pop_to_mark();\n        } else {\n            goto err;\n        }\n        if (!BN_GENCB_call(cb, 2, n++))\n            goto err;\n    }\n    if (!BN_GENCB_call(cb, 3, 1))\n        goto err;\n    if (BN_cmp(rsa->p, rsa->q) < 0) {\n        tmp = rsa->p;\n        rsa->p = rsa->q;\n        rsa->q = tmp;\n    }\n\n    /* calculate n */\n    if (!BN_mul(rsa->n, rsa->p, rsa->q, ctx))\n        goto err;\n\n    /* calculate d */\n    if (!BN_sub(r1, rsa->p, BN_value_one()))\n        goto err;               /* p-1 */\n    if (!BN_sub(r2, rsa->q, BN_value_one()))\n        goto err;               /* q-1 */\n    if (!BN_mul(r0, r1, r2, ctx))\n        goto err;               /* (p-1)(q-1) */\n    if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME)) {\n        pr0 = &local_r0;\n        BN_with_flags(pr0, r0, BN_FLG_CONSTTIME);\n    } else\n        pr0 = r0;\n    if (!BN_mod_inverse(rsa->d, rsa->e, pr0, ctx))\n        goto err;               /* d */\n\n    /* set up d for correct BN_FLG_CONSTTIME flag */\n    if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME)) {\n        d = &local_d;\n        BN_with_flags(d, rsa->d, BN_FLG_CONSTTIME);\n    } else\n        d = rsa->d;\n\n    /* calculate d mod (p-1) */\n    if (!BN_mod(rsa->dmp1, d, r1, ctx))\n        goto err;\n\n    /* calculate d mod (q-1) */\n    if (!BN_mod(rsa->dmq1, d, r2, ctx))\n        goto err;\n\n    /* calculate inverse of q mod p */\n    if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME)) {\n        p = &local_p;\n        BN_with_flags(p, rsa->p, BN_FLG_CONSTTIME);\n    } else\n        p = rsa->p;\n    if (!BN_mod_inverse(rsa->iqmp, rsa->q, p, ctx))\n        goto err;\n\n    ok = 1;\n err:\n    if (ok == -1) {\n        RSAerr(RSA_F_RSA_BUILTIN_KEYGEN, ERR_LIB_BN);\n        ok = 0;\n    }\n    if (ctx != NULL) {\n        BN_CTX_end(ctx);\n        BN_CTX_free(ctx);\n    }\n\n    return ok;\n}",
        "func": "static int rsa_builtin_keygen(RSA *rsa, int bits, BIGNUM *e_value,\n                              BN_GENCB *cb)\n{\n    BIGNUM *r0 = NULL, *r1 = NULL, *r2 = NULL, *r3 = NULL, *tmp;\n    BIGNUM local_r0, local_d, local_p;\n    BIGNUM *pr0, *d, *p;\n    int bitsp, bitsq, ok = -1, n = 0;\n    BN_CTX *ctx = NULL;\n    unsigned long error = 0;\n\n    /*\n     * When generating ridiculously small keys, we can get stuck\n     * continually regenerating the same prime values.\n     */\n    if (bits < 16) {\n        ok = 0;             /* we set our own err */\n        RSAerr(RSA_F_RSA_BUILTIN_KEYGEN, RSA_R_KEY_SIZE_TOO_SMALL);\n        goto err;\n    }\n\n    ctx = BN_CTX_new();\n    if (ctx == NULL)\n        goto err;\n    BN_CTX_start(ctx);\n    r0 = BN_CTX_get(ctx);\n    r1 = BN_CTX_get(ctx);\n    r2 = BN_CTX_get(ctx);\n    r3 = BN_CTX_get(ctx);\n    if (r3 == NULL)\n        goto err;\n\n    bitsp = (bits + 1) / 2;\n    bitsq = bits - bitsp;\n\n    /* We need the RSA components non-NULL */\n    if (!rsa->n && ((rsa->n = BN_new()) == NULL))\n        goto err;\n    if (!rsa->d && ((rsa->d = BN_new()) == NULL))\n        goto err;\n    if (!rsa->e && ((rsa->e = BN_new()) == NULL))\n        goto err;\n    if (!rsa->p && ((rsa->p = BN_new()) == NULL))\n        goto err;\n    if (!rsa->q && ((rsa->q = BN_new()) == NULL))\n        goto err;\n    if (!rsa->dmp1 && ((rsa->dmp1 = BN_new()) == NULL))\n        goto err;\n    if (!rsa->dmq1 && ((rsa->dmq1 = BN_new()) == NULL))\n        goto err;\n    if (!rsa->iqmp && ((rsa->iqmp = BN_new()) == NULL))\n        goto err;\n\n    if (BN_copy(rsa->e, e_value) == NULL)\n        goto err;\n\n    BN_set_flags(rsa->p, BN_FLG_CONSTTIME);\n    BN_set_flags(rsa->q, BN_FLG_CONSTTIME);\n    BN_set_flags(r2, BN_FLG_CONSTTIME);\n    /* generate p and q */\n    for (;;) {\n        if (!BN_generate_prime_ex(rsa->p, bitsp, 0, NULL, NULL, cb))\n            goto err;\n        if (!BN_sub(r2, rsa->p, BN_value_one()))\n            goto err;\n        ERR_set_mark();\n        if (BN_mod_inverse(r1, r2, rsa->e, ctx) != NULL) {\n            /* GCD == 1 since inverse exists */\n            break;\n        }\n        error = ERR_peek_last_error();\n        if (ERR_GET_LIB(error) == ERR_LIB_BN\n            && ERR_GET_REASON(error) == BN_R_NO_INVERSE) {\n            /* GCD != 1 */\n            ERR_pop_to_mark();\n        } else {\n            goto err;\n        }\n        if (!BN_GENCB_call(cb, 2, n++))\n            goto err;\n    }\n    if (!BN_GENCB_call(cb, 3, 0))\n        goto err;\n    for (;;) {\n        do {\n            if (!BN_generate_prime_ex(rsa->q, bitsq, 0, NULL, NULL, cb))\n                goto err;\n        } while (BN_cmp(rsa->p, rsa->q) == 0);\n        if (!BN_sub(r2, rsa->q, BN_value_one()))\n            goto err;\n        ERR_set_mark();\n        if (BN_mod_inverse(r1, r2, rsa->e, ctx) != NULL) {\n            /* GCD == 1 since inverse exists */\n            break;\n        }\n        error = ERR_peek_last_error();\n        if (ERR_GET_LIB(error) == ERR_LIB_BN\n            && ERR_GET_REASON(error) == BN_R_NO_INVERSE) {\n            /* GCD != 1 */\n            ERR_pop_to_mark();\n        } else {\n            goto err;\n        }\n        if (!BN_GENCB_call(cb, 2, n++))\n            goto err;\n    }\n    if (!BN_GENCB_call(cb, 3, 1))\n        goto err;\n    if (BN_cmp(rsa->p, rsa->q) < 0) {\n        tmp = rsa->p;\n        rsa->p = rsa->q;\n        rsa->q = tmp;\n    }\n\n    /* calculate n */\n    if (!BN_mul(rsa->n, rsa->p, rsa->q, ctx))\n        goto err;\n\n    /* calculate d */\n    if (!BN_sub(r1, rsa->p, BN_value_one()))\n        goto err;               /* p-1 */\n    if (!BN_sub(r2, rsa->q, BN_value_one()))\n        goto err;               /* q-1 */\n    if (!BN_mul(r0, r1, r2, ctx))\n        goto err;               /* (p-1)(q-1) */\n    if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME)) {\n        pr0 = &local_r0;\n        BN_with_flags(pr0, r0, BN_FLG_CONSTTIME);\n    } else\n        pr0 = r0;\n    if (!BN_mod_inverse(rsa->d, rsa->e, pr0, ctx))\n        goto err;               /* d */\n\n    /* set up d for correct BN_FLG_CONSTTIME flag */\n    if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME)) {\n        d = &local_d;\n        BN_with_flags(d, rsa->d, BN_FLG_CONSTTIME);\n    } else\n        d = rsa->d;\n\n    /* calculate d mod (p-1) */\n    if (!BN_mod(rsa->dmp1, d, r1, ctx))\n        goto err;\n\n    /* calculate d mod (q-1) */\n    if (!BN_mod(rsa->dmq1, d, r2, ctx))\n        goto err;\n\n    /* calculate inverse of q mod p */\n    if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME)) {\n        p = &local_p;\n        BN_with_flags(p, rsa->p, BN_FLG_CONSTTIME);\n    } else\n        p = rsa->p;\n    if (!BN_mod_inverse(rsa->iqmp, rsa->q, p, ctx))\n        goto err;\n\n    ok = 1;\n err:\n    if (ok == -1) {\n        RSAerr(RSA_F_RSA_BUILTIN_KEYGEN, ERR_LIB_BN);\n        ok = 0;\n    }\n    if (ctx != NULL) {\n        BN_CTX_end(ctx);\n        BN_CTX_free(ctx);\n    }\n\n    return ok;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -53,6 +53,8 @@\n     if (BN_copy(rsa->e, e_value) == NULL)\n         goto err;\n \n+    BN_set_flags(rsa->p, BN_FLG_CONSTTIME);\n+    BN_set_flags(rsa->q, BN_FLG_CONSTTIME);\n     BN_set_flags(r2, BN_FLG_CONSTTIME);\n     /* generate p and q */\n     for (;;) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    BN_set_flags(rsa->p, BN_FLG_CONSTTIME);",
                "    BN_set_flags(rsa->q, BN_FLG_CONSTTIME);"
            ]
        }
    }
]