[
    {
        "cve_id": "CVE-2019-12904",
        "func_name": "gpg/libgcrypt/prefetch_enc",
        "description": "In Libgcrypt 1.8.4, the C implementation of AES is vulnerable to a flush-and-reload side-channel attack because physical addresses are available to other processes. (The C implementation is used on platforms where an assembly-language implementation is unavailable.) NOTE: the vendor's position is that the issue report cannot be validated because there is no description of an attack",
        "git_url": "https://github.com/gpg/libgcrypt/commit/daedbbb5541cd8ecda1459d3b843ea4d92788762",
        "commit_title": "AES: move look-up tables to .data section and unshare between processes",
        "commit_text": " * cipher/rijndael-internal.h (ATTR_ALIGNED_64): New. * cipher/rijndael-tables.h (encT): Move to 'enc_tables' structure. (enc_tables): New structure for encryption table with counters before and after. (encT): New macro. (dec_tables): Add counters before and after encryption table; Move from .rodata to .data section. (do_encrypt): Change 'encT' to 'enc_tables.T'. (do_decrypt): Change '&dec_tables' to 'dec_tables.T'. * cipher/cipher-gcm.c (prefetch_table): Make inline; Handle input with length not multiple of 256. (prefetch_enc, prefetch_dec): Modify pre- and post-table counters to unshare look-up table pages between processes. --  GnuPG-bug-id: 4541",
        "func_before": "static void prefetch_enc(void)\n{\n  prefetch_table((const void *)encT, sizeof(encT));\n}",
        "func": "static void prefetch_enc(void)\n{\n  /* Modify counters to trigger copy-on-write and unsharing if physical pages\n   * of look-up table are shared between processes.  Modifying counters also\n   * causes checksums for pages to change and hint same-page merging algorithm\n   * that these pages are frequently changing.  */\n  enc_tables.counter_head++;\n  enc_tables.counter_tail++;\n\n  /* Prefetch look-up tables to cache.  */\n  prefetch_table((const void *)&enc_tables, sizeof(enc_tables));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,12 @@\n static void prefetch_enc(void)\n {\n-  prefetch_table((const void *)encT, sizeof(encT));\n+  /* Modify counters to trigger copy-on-write and unsharing if physical pages\n+   * of look-up table are shared between processes.  Modifying counters also\n+   * causes checksums for pages to change and hint same-page merging algorithm\n+   * that these pages are frequently changing.  */\n+  enc_tables.counter_head++;\n+  enc_tables.counter_tail++;\n+\n+  /* Prefetch look-up tables to cache.  */\n+  prefetch_table((const void *)&enc_tables, sizeof(enc_tables));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  prefetch_table((const void *)encT, sizeof(encT));"
            ],
            "added_lines": [
                "  /* Modify counters to trigger copy-on-write and unsharing if physical pages",
                "   * of look-up table are shared between processes.  Modifying counters also",
                "   * causes checksums for pages to change and hint same-page merging algorithm",
                "   * that these pages are frequently changing.  */",
                "  enc_tables.counter_head++;",
                "  enc_tables.counter_tail++;",
                "",
                "  /* Prefetch look-up tables to cache.  */",
                "  prefetch_table((const void *)&enc_tables, sizeof(enc_tables));"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-12904",
        "func_name": "gpg/libgcrypt/prefetch_table",
        "description": "In Libgcrypt 1.8.4, the C implementation of AES is vulnerable to a flush-and-reload side-channel attack because physical addresses are available to other processes. (The C implementation is used on platforms where an assembly-language implementation is unavailable.) NOTE: the vendor's position is that the issue report cannot be validated because there is no description of an attack",
        "git_url": "https://github.com/gpg/libgcrypt/commit/daedbbb5541cd8ecda1459d3b843ea4d92788762",
        "commit_title": "AES: move look-up tables to .data section and unshare between processes",
        "commit_text": " * cipher/rijndael-internal.h (ATTR_ALIGNED_64): New. * cipher/rijndael-tables.h (encT): Move to 'enc_tables' structure. (enc_tables): New structure for encryption table with counters before and after. (encT): New macro. (dec_tables): Add counters before and after encryption table; Move from .rodata to .data section. (do_encrypt): Change 'encT' to 'enc_tables.T'. (do_decrypt): Change '&dec_tables' to 'dec_tables.T'. * cipher/cipher-gcm.c (prefetch_table): Make inline; Handle input with length not multiple of 256. (prefetch_enc, prefetch_dec): Modify pre- and post-table counters to unshare look-up table pages between processes. --  GnuPG-bug-id: 4541",
        "func_before": "static void prefetch_table(const volatile byte *tab, size_t len)\n{\n  size_t i;\n\n  for (i = 0; i < len; i += 8 * 32)\n    {\n      (void)tab[i + 0 * 32];\n      (void)tab[i + 1 * 32];\n      (void)tab[i + 2 * 32];\n      (void)tab[i + 3 * 32];\n      (void)tab[i + 4 * 32];\n      (void)tab[i + 5 * 32];\n      (void)tab[i + 6 * 32];\n      (void)tab[i + 7 * 32];\n    }\n\n  (void)tab[len - 1];\n}",
        "func": "static inline void prefetch_table(const volatile byte *tab, size_t len)\n{\n  size_t i;\n\n  for (i = 0; len - i >= 8 * 32; i += 8 * 32)\n    {\n      (void)tab[i + 0 * 32];\n      (void)tab[i + 1 * 32];\n      (void)tab[i + 2 * 32];\n      (void)tab[i + 3 * 32];\n      (void)tab[i + 4 * 32];\n      (void)tab[i + 5 * 32];\n      (void)tab[i + 6 * 32];\n      (void)tab[i + 7 * 32];\n    }\n  for (; i < len; i += 32)\n    {\n      (void)tab[i];\n    }\n\n  (void)tab[len - 1];\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,8 @@\n-static void prefetch_table(const volatile byte *tab, size_t len)\n+static inline void prefetch_table(const volatile byte *tab, size_t len)\n {\n   size_t i;\n \n-  for (i = 0; i < len; i += 8 * 32)\n+  for (i = 0; len - i >= 8 * 32; i += 8 * 32)\n     {\n       (void)tab[i + 0 * 32];\n       (void)tab[i + 1 * 32];\n@@ -13,6 +13,10 @@\n       (void)tab[i + 6 * 32];\n       (void)tab[i + 7 * 32];\n     }\n+  for (; i < len; i += 32)\n+    {\n+      (void)tab[i];\n+    }\n \n   (void)tab[len - 1];\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static void prefetch_table(const volatile byte *tab, size_t len)",
                "  for (i = 0; i < len; i += 8 * 32)"
            ],
            "added_lines": [
                "static inline void prefetch_table(const volatile byte *tab, size_t len)",
                "  for (i = 0; len - i >= 8 * 32; i += 8 * 32)",
                "  for (; i < len; i += 32)",
                "    {",
                "      (void)tab[i];",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-12904",
        "func_name": "gpg/libgcrypt/do_decrypt",
        "description": "In Libgcrypt 1.8.4, the C implementation of AES is vulnerable to a flush-and-reload side-channel attack because physical addresses are available to other processes. (The C implementation is used on platforms where an assembly-language implementation is unavailable.) NOTE: the vendor's position is that the issue report cannot be validated because there is no description of an attack",
        "git_url": "https://github.com/gpg/libgcrypt/commit/daedbbb5541cd8ecda1459d3b843ea4d92788762",
        "commit_title": "AES: move look-up tables to .data section and unshare between processes",
        "commit_text": " * cipher/rijndael-internal.h (ATTR_ALIGNED_64): New. * cipher/rijndael-tables.h (encT): Move to 'enc_tables' structure. (enc_tables): New structure for encryption table with counters before and after. (encT): New macro. (dec_tables): Add counters before and after encryption table; Move from .rodata to .data section. (do_encrypt): Change 'encT' to 'enc_tables.T'. (do_decrypt): Change '&dec_tables' to 'dec_tables.T'. * cipher/cipher-gcm.c (prefetch_table): Make inline; Handle input with length not multiple of 256. (prefetch_enc, prefetch_dec): Modify pre- and post-table counters to unshare look-up table pages between processes. --  GnuPG-bug-id: 4541",
        "func_before": "static unsigned int\ndo_decrypt (const RIJNDAEL_context *ctx, unsigned char *bx,\n            const unsigned char *ax)\n{\n#ifdef USE_AMD64_ASM\n  return _gcry_aes_amd64_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n\t\t\t\t       &dec_tables);\n#elif defined(USE_ARM_ASM)\n  return _gcry_aes_arm_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n\t\t\t\t     &dec_tables);\n#else\n  return do_decrypt_fn (ctx, bx, ax);\n#endif /*!USE_ARM_ASM && !USE_AMD64_ASM*/\n}",
        "func": "static unsigned int\ndo_decrypt (const RIJNDAEL_context *ctx, unsigned char *bx,\n            const unsigned char *ax)\n{\n#ifdef USE_AMD64_ASM\n  return _gcry_aes_amd64_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n\t\t\t\t       dec_tables.T);\n#elif defined(USE_ARM_ASM)\n  return _gcry_aes_arm_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n\t\t\t\t     dec_tables.T);\n#else\n  return do_decrypt_fn (ctx, bx, ax);\n#endif /*!USE_ARM_ASM && !USE_AMD64_ASM*/\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,10 +4,10 @@\n {\n #ifdef USE_AMD64_ASM\n   return _gcry_aes_amd64_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n-\t\t\t\t       &dec_tables);\n+\t\t\t\t       dec_tables.T);\n #elif defined(USE_ARM_ASM)\n   return _gcry_aes_arm_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n-\t\t\t\t     &dec_tables);\n+\t\t\t\t     dec_tables.T);\n #else\n   return do_decrypt_fn (ctx, bx, ax);\n #endif /*!USE_ARM_ASM && !USE_AMD64_ASM*/",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t       &dec_tables);",
                "\t\t\t\t     &dec_tables);"
            ],
            "added_lines": [
                "\t\t\t\t       dec_tables.T);",
                "\t\t\t\t     dec_tables.T);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-12904",
        "func_name": "gpg/libgcrypt/prefetch_dec",
        "description": "In Libgcrypt 1.8.4, the C implementation of AES is vulnerable to a flush-and-reload side-channel attack because physical addresses are available to other processes. (The C implementation is used on platforms where an assembly-language implementation is unavailable.) NOTE: the vendor's position is that the issue report cannot be validated because there is no description of an attack",
        "git_url": "https://github.com/gpg/libgcrypt/commit/daedbbb5541cd8ecda1459d3b843ea4d92788762",
        "commit_title": "AES: move look-up tables to .data section and unshare between processes",
        "commit_text": " * cipher/rijndael-internal.h (ATTR_ALIGNED_64): New. * cipher/rijndael-tables.h (encT): Move to 'enc_tables' structure. (enc_tables): New structure for encryption table with counters before and after. (encT): New macro. (dec_tables): Add counters before and after encryption table; Move from .rodata to .data section. (do_encrypt): Change 'encT' to 'enc_tables.T'. (do_decrypt): Change '&dec_tables' to 'dec_tables.T'. * cipher/cipher-gcm.c (prefetch_table): Make inline; Handle input with length not multiple of 256. (prefetch_enc, prefetch_dec): Modify pre- and post-table counters to unshare look-up table pages between processes. --  GnuPG-bug-id: 4541",
        "func_before": "static void prefetch_dec(void)\n{\n  prefetch_table((const void *)&dec_tables, sizeof(dec_tables));\n}",
        "func": "static void prefetch_dec(void)\n{\n  /* Modify counters to trigger copy-on-write and unsharing if physical pages\n   * of look-up table are shared between processes.  Modifying counters also\n   * causes checksums for pages to change and hint same-page merging algorithm\n   * that these pages are frequently changing.  */\n  dec_tables.counter_head++;\n  dec_tables.counter_tail++;\n\n  /* Prefetch look-up tables to cache.  */\n  prefetch_table((const void *)&dec_tables, sizeof(dec_tables));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,12 @@\n static void prefetch_dec(void)\n {\n+  /* Modify counters to trigger copy-on-write and unsharing if physical pages\n+   * of look-up table are shared between processes.  Modifying counters also\n+   * causes checksums for pages to change and hint same-page merging algorithm\n+   * that these pages are frequently changing.  */\n+  dec_tables.counter_head++;\n+  dec_tables.counter_tail++;\n+\n+  /* Prefetch look-up tables to cache.  */\n   prefetch_table((const void *)&dec_tables, sizeof(dec_tables));\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  /* Modify counters to trigger copy-on-write and unsharing if physical pages",
                "   * of look-up table are shared between processes.  Modifying counters also",
                "   * causes checksums for pages to change and hint same-page merging algorithm",
                "   * that these pages are frequently changing.  */",
                "  dec_tables.counter_head++;",
                "  dec_tables.counter_tail++;",
                "",
                "  /* Prefetch look-up tables to cache.  */"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-12904",
        "func_name": "gpg/libgcrypt/do_encrypt",
        "description": "In Libgcrypt 1.8.4, the C implementation of AES is vulnerable to a flush-and-reload side-channel attack because physical addresses are available to other processes. (The C implementation is used on platforms where an assembly-language implementation is unavailable.) NOTE: the vendor's position is that the issue report cannot be validated because there is no description of an attack",
        "git_url": "https://github.com/gpg/libgcrypt/commit/daedbbb5541cd8ecda1459d3b843ea4d92788762",
        "commit_title": "AES: move look-up tables to .data section and unshare between processes",
        "commit_text": " * cipher/rijndael-internal.h (ATTR_ALIGNED_64): New. * cipher/rijndael-tables.h (encT): Move to 'enc_tables' structure. (enc_tables): New structure for encryption table with counters before and after. (encT): New macro. (dec_tables): Add counters before and after encryption table; Move from .rodata to .data section. (do_encrypt): Change 'encT' to 'enc_tables.T'. (do_decrypt): Change '&dec_tables' to 'dec_tables.T'. * cipher/cipher-gcm.c (prefetch_table): Make inline; Handle input with length not multiple of 256. (prefetch_enc, prefetch_dec): Modify pre- and post-table counters to unshare look-up table pages between processes. --  GnuPG-bug-id: 4541",
        "func_before": "static unsigned int\ndo_encrypt (const RIJNDAEL_context *ctx,\n            unsigned char *bx, const unsigned char *ax)\n{\n#ifdef USE_AMD64_ASM\n  return _gcry_aes_amd64_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,\n\t\t\t\t       encT);\n#elif defined(USE_ARM_ASM)\n  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, encT);\n#else\n  return do_encrypt_fn (ctx, bx, ax);\n#endif /* !USE_ARM_ASM && !USE_AMD64_ASM*/\n}",
        "func": "static unsigned int\ndo_encrypt (const RIJNDAEL_context *ctx,\n            unsigned char *bx, const unsigned char *ax)\n{\n#ifdef USE_AMD64_ASM\n  return _gcry_aes_amd64_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,\n\t\t\t\t       enc_tables.T);\n#elif defined(USE_ARM_ASM)\n  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,\n\t\t\t\t     enc_tables.T);\n#else\n  return do_encrypt_fn (ctx, bx, ax);\n#endif /* !USE_ARM_ASM && !USE_AMD64_ASM*/\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,9 +4,10 @@\n {\n #ifdef USE_AMD64_ASM\n   return _gcry_aes_amd64_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,\n-\t\t\t\t       encT);\n+\t\t\t\t       enc_tables.T);\n #elif defined(USE_ARM_ASM)\n-  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, encT);\n+  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,\n+\t\t\t\t     enc_tables.T);\n #else\n   return do_encrypt_fn (ctx, bx, ax);\n #endif /* !USE_ARM_ASM && !USE_AMD64_ASM*/",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t       encT);",
                "  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, encT);"
            ],
            "added_lines": [
                "\t\t\t\t       enc_tables.T);",
                "  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,",
                "\t\t\t\t     enc_tables.T);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-12904",
        "func_name": "gpg/libgcrypt/prefetch_table",
        "description": "In Libgcrypt 1.8.4, the C implementation of AES is vulnerable to a flush-and-reload side-channel attack because physical addresses are available to other processes. (The C implementation is used on platforms where an assembly-language implementation is unavailable.) NOTE: the vendor's position is that the issue report cannot be validated because there is no description of an attack",
        "git_url": "https://github.com/gpg/libgcrypt/commit/a4c561aab1014c3630bc88faf6f5246fee16b020",
        "commit_title": "GCM: move look-up table to .data section and unshare between processes",
        "commit_text": " * cipher/cipher-gcm.c (ATTR_ALIGNED_64): New. (gcmR): Move to 'gcm_table' structure. (gcm_table): New structure for look-up table with counters before and after. (gcmR): New macro. (prefetch_table): Handle input with length not multiple of 256. (do_prefetch_tables): Modify pre- and post-table counters to unshare look-up table pages between processes. --  GnuPG-bug-id: 4541",
        "func_before": "static inline\nvoid prefetch_table(const void *tab, size_t len)\n{\n  const volatile byte *vtab = tab;\n  size_t i;\n\n  for (i = 0; i < len; i += 8 * 32)\n    {\n      (void)vtab[i + 0 * 32];\n      (void)vtab[i + 1 * 32];\n      (void)vtab[i + 2 * 32];\n      (void)vtab[i + 3 * 32];\n      (void)vtab[i + 4 * 32];\n      (void)vtab[i + 5 * 32];\n      (void)vtab[i + 6 * 32];\n      (void)vtab[i + 7 * 32];\n    }\n\n  (void)vtab[len - 1];\n}",
        "func": "static inline\nvoid prefetch_table(const void *tab, size_t len)\n{\n  const volatile byte *vtab = tab;\n  size_t i;\n\n  for (i = 0; len - i >= 8 * 32; i += 8 * 32)\n    {\n      (void)vtab[i + 0 * 32];\n      (void)vtab[i + 1 * 32];\n      (void)vtab[i + 2 * 32];\n      (void)vtab[i + 3 * 32];\n      (void)vtab[i + 4 * 32];\n      (void)vtab[i + 5 * 32];\n      (void)vtab[i + 6 * 32];\n      (void)vtab[i + 7 * 32];\n    }\n  for (; i < len; i += 32)\n    {\n      (void)vtab[i];\n    }\n\n  (void)vtab[len - 1];\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n   const volatile byte *vtab = tab;\n   size_t i;\n \n-  for (i = 0; i < len; i += 8 * 32)\n+  for (i = 0; len - i >= 8 * 32; i += 8 * 32)\n     {\n       (void)vtab[i + 0 * 32];\n       (void)vtab[i + 1 * 32];\n@@ -15,6 +15,10 @@\n       (void)vtab[i + 6 * 32];\n       (void)vtab[i + 7 * 32];\n     }\n+  for (; i < len; i += 32)\n+    {\n+      (void)vtab[i];\n+    }\n \n   (void)vtab[len - 1];\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  for (i = 0; i < len; i += 8 * 32)"
            ],
            "added_lines": [
                "  for (i = 0; len - i >= 8 * 32; i += 8 * 32)",
                "  for (; i < len; i += 32)",
                "    {",
                "      (void)vtab[i];",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-12904",
        "func_name": "gpg/libgcrypt/do_prefetch_tables",
        "description": "In Libgcrypt 1.8.4, the C implementation of AES is vulnerable to a flush-and-reload side-channel attack because physical addresses are available to other processes. (The C implementation is used on platforms where an assembly-language implementation is unavailable.) NOTE: the vendor's position is that the issue report cannot be validated because there is no description of an attack",
        "git_url": "https://github.com/gpg/libgcrypt/commit/a4c561aab1014c3630bc88faf6f5246fee16b020",
        "commit_title": "GCM: move look-up table to .data section and unshare between processes",
        "commit_text": " * cipher/cipher-gcm.c (ATTR_ALIGNED_64): New. (gcmR): Move to 'gcm_table' structure. (gcm_table): New structure for look-up table with counters before and after. (gcmR): New macro. (prefetch_table): Handle input with length not multiple of 256. (do_prefetch_tables): Modify pre- and post-table counters to unshare look-up table pages between processes. --  GnuPG-bug-id: 4541",
        "func_before": "static inline void\ndo_prefetch_tables (const void *gcmM, size_t gcmM_size)\n{\n  prefetch_table(gcmM, gcmM_size);\n  prefetch_table(gcmR, sizeof(gcmR));\n}",
        "func": "static inline void\ndo_prefetch_tables (const void *gcmM, size_t gcmM_size)\n{\n  /* Modify counters to trigger copy-on-write and unsharing if physical pages\n   * of look-up table are shared between processes.  Modifying counters also\n   * causes checksums for pages to change and hint same-page merging algorithm\n   * that these pages are frequently changing.  */\n  gcm_table.counter_head++;\n  gcm_table.counter_tail++;\n\n  /* Prefetch look-up tables to cache.  */\n  prefetch_table(gcmM, gcmM_size);\n  prefetch_table(&gcm_table, sizeof(gcm_table));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,14 @@\n static inline void\n do_prefetch_tables (const void *gcmM, size_t gcmM_size)\n {\n+  /* Modify counters to trigger copy-on-write and unsharing if physical pages\n+   * of look-up table are shared between processes.  Modifying counters also\n+   * causes checksums for pages to change and hint same-page merging algorithm\n+   * that these pages are frequently changing.  */\n+  gcm_table.counter_head++;\n+  gcm_table.counter_tail++;\n+\n+  /* Prefetch look-up tables to cache.  */\n   prefetch_table(gcmM, gcmM_size);\n-  prefetch_table(gcmR, sizeof(gcmR));\n+  prefetch_table(&gcm_table, sizeof(gcm_table));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  prefetch_table(gcmR, sizeof(gcmR));"
            ],
            "added_lines": [
                "  /* Modify counters to trigger copy-on-write and unsharing if physical pages",
                "   * of look-up table are shared between processes.  Modifying counters also",
                "   * causes checksums for pages to change and hint same-page merging algorithm",
                "   * that these pages are frequently changing.  */",
                "  gcm_table.counter_head++;",
                "  gcm_table.counter_tail++;",
                "",
                "  /* Prefetch look-up tables to cache.  */",
                "  prefetch_table(&gcm_table, sizeof(gcm_table));"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-3569",
        "func_name": "facebook/hhvm/FastCGIServer::FastCGIServer",
        "description": "HHVM, when used with FastCGI, would bind by default to all available interfaces. This behavior could allow a malicious individual unintended direct access to the application, which could result in information disclosure. This issue affects versions 4.3.0, 4.4.0, 4.5.0, 4.6.0, 4.7.0, 4.8.0, versions 3.30.5 and below, and all versions in the 4.0, 4.1, and 4.2 series.",
        "git_url": "https://github.com/facebook/hhvm/commit/97ef580ec2cca9a54da6f9bd9fdd9a455f6d74ed",
        "commit_title": "Fix default FastCGI interface",
        "commit_text": " Reviewed By: alexeyt  Differential Revision: D15567393  fbshipit-source-id: ffab228f689d4ddca9ea4835c70aecf16da2aa9f",
        "func_before": "FastCGIServer::FastCGIServer(const std::string &address,\n                             int port,\n                             int workers,\n                             bool useFileSocket)\n  : Server(address, port),\n    m_worker(&m_eventBaseManager),\n    m_dispatcher(workers, workers,\n                 RuntimeOption::ServerThreadDropCacheTimeoutSeconds,\n                 RuntimeOption::ServerThreadDropStack,\n                 this,\n                 RuntimeOption::ServerThreadJobLIFOSwitchThreshold,\n                 RuntimeOption::ServerThreadJobMaxQueuingMilliSeconds,\n                 RequestPriority::k_numPriorities) {\n  folly::SocketAddress sock_addr;\n  if (useFileSocket) {\n    sock_addr.setFromPath(address);\n  } else if (address.empty()) {\n    sock_addr.setFromLocalPort(port);\n  } else {\n    sock_addr.setFromHostPort(address, port);\n  }\n  m_socketConfig.bindAddress = sock_addr;\n  m_socketConfig.acceptBacklog = RuntimeOption::ServerBacklog;\n  std::chrono::seconds timeout;\n  if (RuntimeOption::ConnectionTimeoutSeconds >= 0) {\n    timeout = std::chrono::seconds(RuntimeOption::ConnectionTimeoutSeconds);\n  } else {\n    // default to 2 minutes\n    timeout = std::chrono::seconds(120);\n  }\n  m_socketConfig.connectionIdleTimeout = timeout;\n}",
        "func": "FastCGIServer::FastCGIServer(const std::string &address,\n                             int port,\n                             int workers,\n                             bool useFileSocket)\n  : Server(address, port),\n    m_worker(&m_eventBaseManager),\n    m_dispatcher(workers, workers,\n                 RuntimeOption::ServerThreadDropCacheTimeoutSeconds,\n                 RuntimeOption::ServerThreadDropStack,\n                 this,\n                 RuntimeOption::ServerThreadJobLIFOSwitchThreshold,\n                 RuntimeOption::ServerThreadJobMaxQueuingMilliSeconds,\n                 RequestPriority::k_numPriorities) {\n  folly::SocketAddress sock_addr;\n  if (useFileSocket) {\n    sock_addr.setFromPath(address);\n  } else if (address.empty()) {\n    sock_addr.setFromHostPort(\"localhost\", port);\n    assert(sock_addr.isLoopbackAddress());\n  } else {\n    sock_addr.setFromHostPort(address, port);\n  }\n  m_socketConfig.bindAddress = sock_addr;\n  m_socketConfig.acceptBacklog = RuntimeOption::ServerBacklog;\n  std::chrono::seconds timeout;\n  if (RuntimeOption::ConnectionTimeoutSeconds >= 0) {\n    timeout = std::chrono::seconds(RuntimeOption::ConnectionTimeoutSeconds);\n  } else {\n    // default to 2 minutes\n    timeout = std::chrono::seconds(120);\n  }\n  m_socketConfig.connectionIdleTimeout = timeout;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,8 @@\n   if (useFileSocket) {\n     sock_addr.setFromPath(address);\n   } else if (address.empty()) {\n-    sock_addr.setFromLocalPort(port);\n+    sock_addr.setFromHostPort(\"localhost\", port);\n+    assert(sock_addr.isLoopbackAddress());\n   } else {\n     sock_addr.setFromHostPort(address, port);\n   }",
        "diff_line_info": {
            "deleted_lines": [
                "    sock_addr.setFromLocalPort(port);"
            ],
            "added_lines": [
                "    sock_addr.setFromHostPort(\"localhost\", port);",
                "    assert(sock_addr.isLoopbackAddress());"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-45402",
        "func_name": "kernel/git/netdev/net/__reg_assign_32_into_64",
        "description": "The check_alu_op() function in kernel/bpf/verifier.c in the Linux kernel through v5.16-rc5 did not properly update bounds while handling the mov32 instruction, which allows local users to obtain potentially sensitive address information, aka a \"pointer leak.\"",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git/commit/?h=e572ff80f05c33cd0cb4860f864f5c9c044280b6",
        "commit_title": "Make the bounds propagation in __reg_assign_32_into_64() slightly more",
        "commit_text": "robust and readable by aligning it similarly as we did back in the __reg_combine_64_into_32() counterpart. Meaning, only propagate or pessimize them as a smin/smax pair.  ",
        "func_before": "static void __reg_assign_32_into_64(struct bpf_reg_state *reg)\n{\n\treg->umin_value = reg->u32_min_value;\n\treg->umax_value = reg->u32_max_value;\n\t/* Attempt to pull 32-bit signed bounds into 64-bit bounds\n\t * but must be positive otherwise set to worse case bounds\n\t * and refine later from tnum.\n\t */\n\tif (reg->s32_min_value >= 0 && reg->s32_max_value >= 0)\n\t\treg->smax_value = reg->s32_max_value;\n\telse\n\t\treg->smax_value = U32_MAX;\n\tif (reg->s32_min_value >= 0)\n\t\treg->smin_value = reg->s32_min_value;\n\telse\n\t\treg->smin_value = 0;\n}",
        "func": "static void __reg_assign_32_into_64(struct bpf_reg_state *reg)\n{\n\treg->umin_value = reg->u32_min_value;\n\treg->umax_value = reg->u32_max_value;\n\n\t/* Attempt to pull 32-bit signed bounds into 64-bit bounds but must\n\t * be positive otherwise set to worse case bounds and refine later\n\t * from tnum.\n\t */\n\tif (__reg32_bound_s64(reg->s32_min_value) &&\n\t    __reg32_bound_s64(reg->s32_max_value)) {\n\t\treg->smin_value = reg->s32_min_value;\n\t\treg->smax_value = reg->s32_max_value;\n\t} else {\n\t\treg->smin_value = 0;\n\t\treg->smax_value = U32_MAX;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,16 +2,17 @@\n {\n \treg->umin_value = reg->u32_min_value;\n \treg->umax_value = reg->u32_max_value;\n-\t/* Attempt to pull 32-bit signed bounds into 64-bit bounds\n-\t * but must be positive otherwise set to worse case bounds\n-\t * and refine later from tnum.\n+\n+\t/* Attempt to pull 32-bit signed bounds into 64-bit bounds but must\n+\t * be positive otherwise set to worse case bounds and refine later\n+\t * from tnum.\n \t */\n-\tif (reg->s32_min_value >= 0 && reg->s32_max_value >= 0)\n+\tif (__reg32_bound_s64(reg->s32_min_value) &&\n+\t    __reg32_bound_s64(reg->s32_max_value)) {\n+\t\treg->smin_value = reg->s32_min_value;\n \t\treg->smax_value = reg->s32_max_value;\n-\telse\n+\t} else {\n+\t\treg->smin_value = 0;\n \t\treg->smax_value = U32_MAX;\n-\tif (reg->s32_min_value >= 0)\n-\t\treg->smin_value = reg->s32_min_value;\n-\telse\n-\t\treg->smin_value = 0;\n+\t}\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t/* Attempt to pull 32-bit signed bounds into 64-bit bounds",
                "\t * but must be positive otherwise set to worse case bounds",
                "\t * and refine later from tnum.",
                "\tif (reg->s32_min_value >= 0 && reg->s32_max_value >= 0)",
                "\telse",
                "\tif (reg->s32_min_value >= 0)",
                "\t\treg->smin_value = reg->s32_min_value;",
                "\telse",
                "\t\treg->smin_value = 0;"
            ],
            "added_lines": [
                "",
                "\t/* Attempt to pull 32-bit signed bounds into 64-bit bounds but must",
                "\t * be positive otherwise set to worse case bounds and refine later",
                "\t * from tnum.",
                "\tif (__reg32_bound_s64(reg->s32_min_value) &&",
                "\t    __reg32_bound_s64(reg->s32_max_value)) {",
                "\t\treg->smin_value = reg->s32_min_value;",
                "\t} else {",
                "\t\treg->smin_value = 0;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-45402",
        "func_name": "kernel/git/netdev/net/check_alu_op",
        "description": "The check_alu_op() function in kernel/bpf/verifier.c in the Linux kernel through v5.16-rc5 did not properly update bounds while handling the mov32 instruction, which allows local users to obtain potentially sensitive address information, aka a \"pointer leak.\"",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git/commit/?h=3cf2b61eb06765e27fec6799292d9fb46d0b7e60",
        "commit_title": "For the case where both s32_{min,max}_value bounds are positive, the",
        "commit_text": "__reg_assign_32_into_64() directly propagates them to their 64 bit counterparts, otherwise it pessimises them into [0,u32_max] universe and tries to refine them later on by learning through the tnum as per comment in mentioned function. However, that does not always happen, for example, in mov32 operation we call zext_32_to_64(dst_reg) which invokes the __reg_assign_32_into_64() as is without subsequent bounds update as elsewhere thus no refinement based on tnum takes place.  Thus, not calling into the __update_reg_bounds() / __reg_deduce_bounds() / __reg_bound_offset() triplet as we do, for example, in case of ALU ops via adjust_scalar_min_max_vals(), will lead to more pessimistic bounds when dumping the full register state:  Before fix:    0: (b4) w0 = -1   1: R0_w=invP4294967295      (id=0,imm=ffffffff,       smin_value=4294967295,smax_value=4294967295,       umin_value=4294967295,umax_value=4294967295,       var_off=(0xffffffff; 0x0),       s32_min_value=-1,s32_max_value=-1,       u32_min_value=-1,u32_max_value=-1)    1: (bc) w0 = w0   2: R0_w=invP4294967295      (id=0,imm=ffffffff,       smin_value=0,smax_value=4294967295,       umin_value=4294967295,umax_value=4294967295,       var_off=(0xffffffff; 0x0),       s32_min_value=-1,s32_max_value=-1,       u32_min_value=-1,u32_max_value=-1)  Technically, the smin_value=0 and smax_value=4294967295 bounds are not incorrect, but given the register is still a constant, they break assumptions about const scalars that smin_value == smax_value and umin_value == umax_value.  After fix:    0: (b4) w0 = -1   1: R0_w=invP4294967295      (id=0,imm=ffffffff,       smin_value=4294967295,smax_value=4294967295,       umin_value=4294967295,umax_value=4294967295,       var_off=(0xffffffff; 0x0),       s32_min_value=-1,s32_max_value=-1,       u32_min_value=-1,u32_max_value=-1)    1: (bc) w0 = w0   2: R0_w=invP4294967295      (id=0,imm=ffffffff,       smin_value=4294967295,smax_value=4294967295,       umin_value=4294967295,umax_value=4294967295,       var_off=(0xffffffff; 0x0),       s32_min_value=-1,s32_max_value=-1,       u32_min_value=-1,u32_max_value=-1)  Without the smin_value == smax_value and umin_value == umax_value invariant being intact for const scalars, it is possible to leak out kernel pointers from unprivileged user space if the latter is enabled. For example, when such registers are involved in pointer arithmtics, then adjust_ptr_min_max_vals() will taint the destination register into an unknown scalar, and the latter can be exported and stored e.g. into a BPF map value.  ",
        "func_before": "static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tint err;\n\n\tif (opcode == BPF_END || opcode == BPF_NEG) {\n\t\tif (opcode == BPF_NEG) {\n\t\t\tif (BPF_SRC(insn->code) != 0 ||\n\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t    insn->off != 0 || insn->imm != 0) {\n\t\t\t\tverbose(env, \"BPF_NEG uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0 ||\n\t\t\t    (insn->imm != 16 && insn->imm != 32 && insn->imm != 64) ||\n\t\t\t    BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\tverbose(env, \"BPF_END uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_pointer_value(env, insn->dst_reg)) {\n\t\t\tverbose(env, \"R%d pointer arithmetic prohibited\\n\",\n\t\t\t\tinsn->dst_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t} else if (opcode == BPF_MOV) {\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand, mark as required later */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP_NO_MARK);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tstruct bpf_reg_state *src_reg = regs + insn->src_reg;\n\t\t\tstruct bpf_reg_state *dst_reg = regs + insn->dst_reg;\n\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t/* case: R1 = R2\n\t\t\t\t * copy register state to dest reg\n\t\t\t\t */\n\t\t\t\tif (src_reg->type == SCALAR_VALUE && !src_reg->id)\n\t\t\t\t\t/* Assign src and dst registers the same ID\n\t\t\t\t\t * that will be used by find_equal_scalars()\n\t\t\t\t\t * to propagate min/max range.\n\t\t\t\t\t */\n\t\t\t\t\tsrc_reg->id = ++env->id_gen;\n\t\t\t\t*dst_reg = *src_reg;\n\t\t\t\tdst_reg->live |= REG_LIVE_WRITTEN;\n\t\t\t\tdst_reg->subreg_def = DEF_NOT_SUBREG;\n\t\t\t} else {\n\t\t\t\t/* R1 = (u32) R2 */\n\t\t\t\tif (is_pointer_value(env, insn->src_reg)) {\n\t\t\t\t\tverbose(env,\n\t\t\t\t\t\t\"R%d partial copy of pointer\\n\",\n\t\t\t\t\t\tinsn->src_reg);\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t} else if (src_reg->type == SCALAR_VALUE) {\n\t\t\t\t\t*dst_reg = *src_reg;\n\t\t\t\t\t/* Make sure ID is cleared otherwise\n\t\t\t\t\t * dst_reg min/max could be incorrectly\n\t\t\t\t\t * propagated into src_reg by find_equal_scalars()\n\t\t\t\t\t */\n\t\t\t\t\tdst_reg->id = 0;\n\t\t\t\t\tdst_reg->live |= REG_LIVE_WRITTEN;\n\t\t\t\t\tdst_reg->subreg_def = env->insn_idx + 1;\n\t\t\t\t} else {\n\t\t\t\t\tmark_reg_unknown(env, regs,\n\t\t\t\t\t\t\t insn->dst_reg);\n\t\t\t\t}\n\t\t\t\tzext_32_to_64(dst_reg);\n\t\t\t}\n\t\t} else {\n\t\t\t/* case: R = imm\n\t\t\t * remember the value we stored into this reg\n\t\t\t */\n\t\t\t/* clear any state __mark_reg_known doesn't set */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tregs[insn->dst_reg].type = SCALAR_VALUE;\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t insn->imm);\n\t\t\t} else {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t (u32)insn->imm);\n\t\t\t}\n\t\t}\n\n\t} else if (opcode > BPF_END) {\n\t\tverbose(env, \"invalid BPF_ALU opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\n\t} else {\t/* all other ALU ops: and, sub, xor, add, ... */\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* check src1 operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src2 operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif ((opcode == BPF_MOD || opcode == BPF_DIV) &&\n\t\t    BPF_SRC(insn->code) == BPF_K && insn->imm == 0) {\n\t\t\tverbose(env, \"div by zero\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif ((opcode == BPF_LSH || opcode == BPF_RSH ||\n\t\t     opcode == BPF_ARSH) && BPF_SRC(insn->code) == BPF_K) {\n\t\t\tint size = BPF_CLASS(insn->code) == BPF_ALU64 ? 64 : 32;\n\n\t\t\tif (insn->imm < 0 || insn->imm >= size) {\n\t\t\t\tverbose(env, \"invalid shift %d\\n\", insn->imm);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP_NO_MARK);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn adjust_reg_min_max_vals(env, insn);\n\t}\n\n\treturn 0;\n}",
        "func": "static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tint err;\n\n\tif (opcode == BPF_END || opcode == BPF_NEG) {\n\t\tif (opcode == BPF_NEG) {\n\t\t\tif (BPF_SRC(insn->code) != 0 ||\n\t\t\t    insn->src_reg != BPF_REG_0 ||\n\t\t\t    insn->off != 0 || insn->imm != 0) {\n\t\t\t\tverbose(env, \"BPF_NEG uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0 ||\n\t\t\t    (insn->imm != 16 && insn->imm != 32 && insn->imm != 64) ||\n\t\t\t    BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\tverbose(env, \"BPF_END uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (is_pointer_value(env, insn->dst_reg)) {\n\t\t\tverbose(env, \"R%d pointer arithmetic prohibited\\n\",\n\t\t\t\tinsn->dst_reg);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t} else if (opcode == BPF_MOV) {\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t/* check src operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_MOV uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand, mark as required later */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP_NO_MARK);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tstruct bpf_reg_state *src_reg = regs + insn->src_reg;\n\t\t\tstruct bpf_reg_state *dst_reg = regs + insn->dst_reg;\n\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t/* case: R1 = R2\n\t\t\t\t * copy register state to dest reg\n\t\t\t\t */\n\t\t\t\tif (src_reg->type == SCALAR_VALUE && !src_reg->id)\n\t\t\t\t\t/* Assign src and dst registers the same ID\n\t\t\t\t\t * that will be used by find_equal_scalars()\n\t\t\t\t\t * to propagate min/max range.\n\t\t\t\t\t */\n\t\t\t\t\tsrc_reg->id = ++env->id_gen;\n\t\t\t\t*dst_reg = *src_reg;\n\t\t\t\tdst_reg->live |= REG_LIVE_WRITTEN;\n\t\t\t\tdst_reg->subreg_def = DEF_NOT_SUBREG;\n\t\t\t} else {\n\t\t\t\t/* R1 = (u32) R2 */\n\t\t\t\tif (is_pointer_value(env, insn->src_reg)) {\n\t\t\t\t\tverbose(env,\n\t\t\t\t\t\t\"R%d partial copy of pointer\\n\",\n\t\t\t\t\t\tinsn->src_reg);\n\t\t\t\t\treturn -EACCES;\n\t\t\t\t} else if (src_reg->type == SCALAR_VALUE) {\n\t\t\t\t\t*dst_reg = *src_reg;\n\t\t\t\t\t/* Make sure ID is cleared otherwise\n\t\t\t\t\t * dst_reg min/max could be incorrectly\n\t\t\t\t\t * propagated into src_reg by find_equal_scalars()\n\t\t\t\t\t */\n\t\t\t\t\tdst_reg->id = 0;\n\t\t\t\t\tdst_reg->live |= REG_LIVE_WRITTEN;\n\t\t\t\t\tdst_reg->subreg_def = env->insn_idx + 1;\n\t\t\t\t} else {\n\t\t\t\t\tmark_reg_unknown(env, regs,\n\t\t\t\t\t\t\t insn->dst_reg);\n\t\t\t\t}\n\t\t\t\tzext_32_to_64(dst_reg);\n\n\t\t\t\t__update_reg_bounds(dst_reg);\n\t\t\t\t__reg_deduce_bounds(dst_reg);\n\t\t\t\t__reg_bound_offset(dst_reg);\n\t\t\t}\n\t\t} else {\n\t\t\t/* case: R = imm\n\t\t\t * remember the value we stored into this reg\n\t\t\t */\n\t\t\t/* clear any state __mark_reg_known doesn't set */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tregs[insn->dst_reg].type = SCALAR_VALUE;\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t insn->imm);\n\t\t\t} else {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t (u32)insn->imm);\n\t\t\t}\n\t\t}\n\n\t} else if (opcode > BPF_END) {\n\t\tverbose(env, \"invalid BPF_ALU opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\n\t} else {\t/* all other ALU ops: and, sub, xor, add, ... */\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\t/* check src1 operand */\n\t\t\terr = check_reg_arg(env, insn->src_reg, SRC_OP);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tif (insn->src_reg != BPF_REG_0 || insn->off != 0) {\n\t\t\t\tverbose(env, \"BPF_ALU uses reserved fields\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check src2 operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, SRC_OP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif ((opcode == BPF_MOD || opcode == BPF_DIV) &&\n\t\t    BPF_SRC(insn->code) == BPF_K && insn->imm == 0) {\n\t\t\tverbose(env, \"div by zero\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif ((opcode == BPF_LSH || opcode == BPF_RSH ||\n\t\t     opcode == BPF_ARSH) && BPF_SRC(insn->code) == BPF_K) {\n\t\t\tint size = BPF_CLASS(insn->code) == BPF_ALU64 ? 64 : 32;\n\n\t\t\tif (insn->imm < 0 || insn->imm >= size) {\n\t\t\t\tverbose(env, \"invalid shift %d\\n\", insn->imm);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t/* check dest operand */\n\t\terr = check_reg_arg(env, insn->dst_reg, DST_OP_NO_MARK);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn adjust_reg_min_max_vals(env, insn);\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -99,6 +99,10 @@\n \t\t\t\t\t\t\t insn->dst_reg);\n \t\t\t\t}\n \t\t\t\tzext_32_to_64(dst_reg);\n+\n+\t\t\t\t__update_reg_bounds(dst_reg);\n+\t\t\t\t__reg_deduce_bounds(dst_reg);\n+\t\t\t\t__reg_bound_offset(dst_reg);\n \t\t\t}\n \t\t} else {\n \t\t\t/* case: R = imm",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\t\t\t\t__update_reg_bounds(dst_reg);",
                "\t\t\t\t__reg_deduce_bounds(dst_reg);",
                "\t\t\t\t__reg_bound_offset(dst_reg);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-25236",
        "func_name": "libexpat/XML_ExternalEntityParserCreate",
        "description": "xmlparse.c in Expat (aka libexpat) before 2.4.5 allows attackers to insert namespace-separator characters into namespace URIs.",
        "git_url": "https://github.com/libexpat/libexpat/commit/6881a4fc8596307ab9ff2e85e605afa2e413ab71",
        "commit_title": "lib: Fix (harmless) use of uninitialized memory",
        "commit_text": "",
        "func_before": "XML_Parser XMLCALL\nXML_ExternalEntityParserCreate(XML_Parser oldParser, const XML_Char *context,\n                               const XML_Char *encodingName) {\n  XML_Parser parser = oldParser;\n  DTD *newDtd = NULL;\n  DTD *oldDtd;\n  XML_StartElementHandler oldStartElementHandler;\n  XML_EndElementHandler oldEndElementHandler;\n  XML_CharacterDataHandler oldCharacterDataHandler;\n  XML_ProcessingInstructionHandler oldProcessingInstructionHandler;\n  XML_CommentHandler oldCommentHandler;\n  XML_StartCdataSectionHandler oldStartCdataSectionHandler;\n  XML_EndCdataSectionHandler oldEndCdataSectionHandler;\n  XML_DefaultHandler oldDefaultHandler;\n  XML_UnparsedEntityDeclHandler oldUnparsedEntityDeclHandler;\n  XML_NotationDeclHandler oldNotationDeclHandler;\n  XML_StartNamespaceDeclHandler oldStartNamespaceDeclHandler;\n  XML_EndNamespaceDeclHandler oldEndNamespaceDeclHandler;\n  XML_NotStandaloneHandler oldNotStandaloneHandler;\n  XML_ExternalEntityRefHandler oldExternalEntityRefHandler;\n  XML_SkippedEntityHandler oldSkippedEntityHandler;\n  XML_UnknownEncodingHandler oldUnknownEncodingHandler;\n  XML_ElementDeclHandler oldElementDeclHandler;\n  XML_AttlistDeclHandler oldAttlistDeclHandler;\n  XML_EntityDeclHandler oldEntityDeclHandler;\n  XML_XmlDeclHandler oldXmlDeclHandler;\n  ELEMENT_TYPE *oldDeclElementType;\n\n  void *oldUserData;\n  void *oldHandlerArg;\n  XML_Bool oldDefaultExpandInternalEntities;\n  XML_Parser oldExternalEntityRefHandlerArg;\n#ifdef XML_DTD\n  enum XML_ParamEntityParsing oldParamEntityParsing;\n  int oldInEntityValue;\n#endif\n  XML_Bool oldns_triplets;\n  /* Note that the new parser shares the same hash secret as the old\n     parser, so that dtdCopy and copyEntityTable can lookup values\n     from hash tables associated with either parser without us having\n     to worry which hash secrets each table has.\n  */\n  unsigned long oldhash_secret_salt;\n\n  /* Validate the oldParser parameter before we pull everything out of it */\n  if (oldParser == NULL)\n    return NULL;\n\n  /* Stash the original parser contents on the stack */\n  oldDtd = parser->m_dtd;\n  oldStartElementHandler = parser->m_startElementHandler;\n  oldEndElementHandler = parser->m_endElementHandler;\n  oldCharacterDataHandler = parser->m_characterDataHandler;\n  oldProcessingInstructionHandler = parser->m_processingInstructionHandler;\n  oldCommentHandler = parser->m_commentHandler;\n  oldStartCdataSectionHandler = parser->m_startCdataSectionHandler;\n  oldEndCdataSectionHandler = parser->m_endCdataSectionHandler;\n  oldDefaultHandler = parser->m_defaultHandler;\n  oldUnparsedEntityDeclHandler = parser->m_unparsedEntityDeclHandler;\n  oldNotationDeclHandler = parser->m_notationDeclHandler;\n  oldStartNamespaceDeclHandler = parser->m_startNamespaceDeclHandler;\n  oldEndNamespaceDeclHandler = parser->m_endNamespaceDeclHandler;\n  oldNotStandaloneHandler = parser->m_notStandaloneHandler;\n  oldExternalEntityRefHandler = parser->m_externalEntityRefHandler;\n  oldSkippedEntityHandler = parser->m_skippedEntityHandler;\n  oldUnknownEncodingHandler = parser->m_unknownEncodingHandler;\n  oldElementDeclHandler = parser->m_elementDeclHandler;\n  oldAttlistDeclHandler = parser->m_attlistDeclHandler;\n  oldEntityDeclHandler = parser->m_entityDeclHandler;\n  oldXmlDeclHandler = parser->m_xmlDeclHandler;\n  oldDeclElementType = parser->m_declElementType;\n\n  oldUserData = parser->m_userData;\n  oldHandlerArg = parser->m_handlerArg;\n  oldDefaultExpandInternalEntities = parser->m_defaultExpandInternalEntities;\n  oldExternalEntityRefHandlerArg = parser->m_externalEntityRefHandlerArg;\n#ifdef XML_DTD\n  oldParamEntityParsing = parser->m_paramEntityParsing;\n  oldInEntityValue = parser->m_prologState.inEntityValue;\n#endif\n  oldns_triplets = parser->m_ns_triplets;\n  /* Note that the new parser shares the same hash secret as the old\n     parser, so that dtdCopy and copyEntityTable can lookup values\n     from hash tables associated with either parser without us having\n     to worry which hash secrets each table has.\n  */\n  oldhash_secret_salt = parser->m_hash_secret_salt;\n\n#ifdef XML_DTD\n  if (! context)\n    newDtd = oldDtd;\n#endif /* XML_DTD */\n\n  /* Note that the magical uses of the pre-processor to make field\n     access look more like C++ require that `parser' be overwritten\n     here.  This makes this function more painful to follow than it\n     would be otherwise.\n  */\n  if (parser->m_ns) {\n    XML_Char tmp[2];\n    *tmp = parser->m_namespaceSeparator;\n    parser = parserCreate(encodingName, &parser->m_mem, tmp, newDtd);\n  } else {\n    parser = parserCreate(encodingName, &parser->m_mem, NULL, newDtd);\n  }\n\n  if (! parser)\n    return NULL;\n\n  parser->m_startElementHandler = oldStartElementHandler;\n  parser->m_endElementHandler = oldEndElementHandler;\n  parser->m_characterDataHandler = oldCharacterDataHandler;\n  parser->m_processingInstructionHandler = oldProcessingInstructionHandler;\n  parser->m_commentHandler = oldCommentHandler;\n  parser->m_startCdataSectionHandler = oldStartCdataSectionHandler;\n  parser->m_endCdataSectionHandler = oldEndCdataSectionHandler;\n  parser->m_defaultHandler = oldDefaultHandler;\n  parser->m_unparsedEntityDeclHandler = oldUnparsedEntityDeclHandler;\n  parser->m_notationDeclHandler = oldNotationDeclHandler;\n  parser->m_startNamespaceDeclHandler = oldStartNamespaceDeclHandler;\n  parser->m_endNamespaceDeclHandler = oldEndNamespaceDeclHandler;\n  parser->m_notStandaloneHandler = oldNotStandaloneHandler;\n  parser->m_externalEntityRefHandler = oldExternalEntityRefHandler;\n  parser->m_skippedEntityHandler = oldSkippedEntityHandler;\n  parser->m_unknownEncodingHandler = oldUnknownEncodingHandler;\n  parser->m_elementDeclHandler = oldElementDeclHandler;\n  parser->m_attlistDeclHandler = oldAttlistDeclHandler;\n  parser->m_entityDeclHandler = oldEntityDeclHandler;\n  parser->m_xmlDeclHandler = oldXmlDeclHandler;\n  parser->m_declElementType = oldDeclElementType;\n  parser->m_userData = oldUserData;\n  if (oldUserData == oldHandlerArg)\n    parser->m_handlerArg = parser->m_userData;\n  else\n    parser->m_handlerArg = parser;\n  if (oldExternalEntityRefHandlerArg != oldParser)\n    parser->m_externalEntityRefHandlerArg = oldExternalEntityRefHandlerArg;\n  parser->m_defaultExpandInternalEntities = oldDefaultExpandInternalEntities;\n  parser->m_ns_triplets = oldns_triplets;\n  parser->m_hash_secret_salt = oldhash_secret_salt;\n  parser->m_parentParser = oldParser;\n#ifdef XML_DTD\n  parser->m_paramEntityParsing = oldParamEntityParsing;\n  parser->m_prologState.inEntityValue = oldInEntityValue;\n  if (context) {\n#endif /* XML_DTD */\n    if (! dtdCopy(oldParser, parser->m_dtd, oldDtd, &parser->m_mem)\n        || ! setContext(parser, context)) {\n      XML_ParserFree(parser);\n      return NULL;\n    }\n    parser->m_processor = externalEntityInitProcessor;\n#ifdef XML_DTD\n  } else {\n    /* The DTD instance referenced by parser->m_dtd is shared between the\n       document's root parser and external PE parsers, therefore one does not\n       need to call setContext. In addition, one also *must* not call\n       setContext, because this would overwrite existing prefix->binding\n       pointers in parser->m_dtd with ones that get destroyed with the external\n       PE parser. This would leave those prefixes with dangling pointers.\n    */\n    parser->m_isParamEntity = XML_TRUE;\n    XmlPrologStateInitExternalEntity(&parser->m_prologState);\n    parser->m_processor = externalParEntInitProcessor;\n  }\n#endif /* XML_DTD */\n  return parser;\n}",
        "func": "XML_Parser XMLCALL\nXML_ExternalEntityParserCreate(XML_Parser oldParser, const XML_Char *context,\n                               const XML_Char *encodingName) {\n  XML_Parser parser = oldParser;\n  DTD *newDtd = NULL;\n  DTD *oldDtd;\n  XML_StartElementHandler oldStartElementHandler;\n  XML_EndElementHandler oldEndElementHandler;\n  XML_CharacterDataHandler oldCharacterDataHandler;\n  XML_ProcessingInstructionHandler oldProcessingInstructionHandler;\n  XML_CommentHandler oldCommentHandler;\n  XML_StartCdataSectionHandler oldStartCdataSectionHandler;\n  XML_EndCdataSectionHandler oldEndCdataSectionHandler;\n  XML_DefaultHandler oldDefaultHandler;\n  XML_UnparsedEntityDeclHandler oldUnparsedEntityDeclHandler;\n  XML_NotationDeclHandler oldNotationDeclHandler;\n  XML_StartNamespaceDeclHandler oldStartNamespaceDeclHandler;\n  XML_EndNamespaceDeclHandler oldEndNamespaceDeclHandler;\n  XML_NotStandaloneHandler oldNotStandaloneHandler;\n  XML_ExternalEntityRefHandler oldExternalEntityRefHandler;\n  XML_SkippedEntityHandler oldSkippedEntityHandler;\n  XML_UnknownEncodingHandler oldUnknownEncodingHandler;\n  XML_ElementDeclHandler oldElementDeclHandler;\n  XML_AttlistDeclHandler oldAttlistDeclHandler;\n  XML_EntityDeclHandler oldEntityDeclHandler;\n  XML_XmlDeclHandler oldXmlDeclHandler;\n  ELEMENT_TYPE *oldDeclElementType;\n\n  void *oldUserData;\n  void *oldHandlerArg;\n  XML_Bool oldDefaultExpandInternalEntities;\n  XML_Parser oldExternalEntityRefHandlerArg;\n#ifdef XML_DTD\n  enum XML_ParamEntityParsing oldParamEntityParsing;\n  int oldInEntityValue;\n#endif\n  XML_Bool oldns_triplets;\n  /* Note that the new parser shares the same hash secret as the old\n     parser, so that dtdCopy and copyEntityTable can lookup values\n     from hash tables associated with either parser without us having\n     to worry which hash secrets each table has.\n  */\n  unsigned long oldhash_secret_salt;\n\n  /* Validate the oldParser parameter before we pull everything out of it */\n  if (oldParser == NULL)\n    return NULL;\n\n  /* Stash the original parser contents on the stack */\n  oldDtd = parser->m_dtd;\n  oldStartElementHandler = parser->m_startElementHandler;\n  oldEndElementHandler = parser->m_endElementHandler;\n  oldCharacterDataHandler = parser->m_characterDataHandler;\n  oldProcessingInstructionHandler = parser->m_processingInstructionHandler;\n  oldCommentHandler = parser->m_commentHandler;\n  oldStartCdataSectionHandler = parser->m_startCdataSectionHandler;\n  oldEndCdataSectionHandler = parser->m_endCdataSectionHandler;\n  oldDefaultHandler = parser->m_defaultHandler;\n  oldUnparsedEntityDeclHandler = parser->m_unparsedEntityDeclHandler;\n  oldNotationDeclHandler = parser->m_notationDeclHandler;\n  oldStartNamespaceDeclHandler = parser->m_startNamespaceDeclHandler;\n  oldEndNamespaceDeclHandler = parser->m_endNamespaceDeclHandler;\n  oldNotStandaloneHandler = parser->m_notStandaloneHandler;\n  oldExternalEntityRefHandler = parser->m_externalEntityRefHandler;\n  oldSkippedEntityHandler = parser->m_skippedEntityHandler;\n  oldUnknownEncodingHandler = parser->m_unknownEncodingHandler;\n  oldElementDeclHandler = parser->m_elementDeclHandler;\n  oldAttlistDeclHandler = parser->m_attlistDeclHandler;\n  oldEntityDeclHandler = parser->m_entityDeclHandler;\n  oldXmlDeclHandler = parser->m_xmlDeclHandler;\n  oldDeclElementType = parser->m_declElementType;\n\n  oldUserData = parser->m_userData;\n  oldHandlerArg = parser->m_handlerArg;\n  oldDefaultExpandInternalEntities = parser->m_defaultExpandInternalEntities;\n  oldExternalEntityRefHandlerArg = parser->m_externalEntityRefHandlerArg;\n#ifdef XML_DTD\n  oldParamEntityParsing = parser->m_paramEntityParsing;\n  oldInEntityValue = parser->m_prologState.inEntityValue;\n#endif\n  oldns_triplets = parser->m_ns_triplets;\n  /* Note that the new parser shares the same hash secret as the old\n     parser, so that dtdCopy and copyEntityTable can lookup values\n     from hash tables associated with either parser without us having\n     to worry which hash secrets each table has.\n  */\n  oldhash_secret_salt = parser->m_hash_secret_salt;\n\n#ifdef XML_DTD\n  if (! context)\n    newDtd = oldDtd;\n#endif /* XML_DTD */\n\n  /* Note that the magical uses of the pre-processor to make field\n     access look more like C++ require that `parser' be overwritten\n     here.  This makes this function more painful to follow than it\n     would be otherwise.\n  */\n  if (parser->m_ns) {\n    XML_Char tmp[2] = {parser->m_namespaceSeparator, 0};\n    parser = parserCreate(encodingName, &parser->m_mem, tmp, newDtd);\n  } else {\n    parser = parserCreate(encodingName, &parser->m_mem, NULL, newDtd);\n  }\n\n  if (! parser)\n    return NULL;\n\n  parser->m_startElementHandler = oldStartElementHandler;\n  parser->m_endElementHandler = oldEndElementHandler;\n  parser->m_characterDataHandler = oldCharacterDataHandler;\n  parser->m_processingInstructionHandler = oldProcessingInstructionHandler;\n  parser->m_commentHandler = oldCommentHandler;\n  parser->m_startCdataSectionHandler = oldStartCdataSectionHandler;\n  parser->m_endCdataSectionHandler = oldEndCdataSectionHandler;\n  parser->m_defaultHandler = oldDefaultHandler;\n  parser->m_unparsedEntityDeclHandler = oldUnparsedEntityDeclHandler;\n  parser->m_notationDeclHandler = oldNotationDeclHandler;\n  parser->m_startNamespaceDeclHandler = oldStartNamespaceDeclHandler;\n  parser->m_endNamespaceDeclHandler = oldEndNamespaceDeclHandler;\n  parser->m_notStandaloneHandler = oldNotStandaloneHandler;\n  parser->m_externalEntityRefHandler = oldExternalEntityRefHandler;\n  parser->m_skippedEntityHandler = oldSkippedEntityHandler;\n  parser->m_unknownEncodingHandler = oldUnknownEncodingHandler;\n  parser->m_elementDeclHandler = oldElementDeclHandler;\n  parser->m_attlistDeclHandler = oldAttlistDeclHandler;\n  parser->m_entityDeclHandler = oldEntityDeclHandler;\n  parser->m_xmlDeclHandler = oldXmlDeclHandler;\n  parser->m_declElementType = oldDeclElementType;\n  parser->m_userData = oldUserData;\n  if (oldUserData == oldHandlerArg)\n    parser->m_handlerArg = parser->m_userData;\n  else\n    parser->m_handlerArg = parser;\n  if (oldExternalEntityRefHandlerArg != oldParser)\n    parser->m_externalEntityRefHandlerArg = oldExternalEntityRefHandlerArg;\n  parser->m_defaultExpandInternalEntities = oldDefaultExpandInternalEntities;\n  parser->m_ns_triplets = oldns_triplets;\n  parser->m_hash_secret_salt = oldhash_secret_salt;\n  parser->m_parentParser = oldParser;\n#ifdef XML_DTD\n  parser->m_paramEntityParsing = oldParamEntityParsing;\n  parser->m_prologState.inEntityValue = oldInEntityValue;\n  if (context) {\n#endif /* XML_DTD */\n    if (! dtdCopy(oldParser, parser->m_dtd, oldDtd, &parser->m_mem)\n        || ! setContext(parser, context)) {\n      XML_ParserFree(parser);\n      return NULL;\n    }\n    parser->m_processor = externalEntityInitProcessor;\n#ifdef XML_DTD\n  } else {\n    /* The DTD instance referenced by parser->m_dtd is shared between the\n       document's root parser and external PE parsers, therefore one does not\n       need to call setContext. In addition, one also *must* not call\n       setContext, because this would overwrite existing prefix->binding\n       pointers in parser->m_dtd with ones that get destroyed with the external\n       PE parser. This would leave those prefixes with dangling pointers.\n    */\n    parser->m_isParamEntity = XML_TRUE;\n    XmlPrologStateInitExternalEntity(&parser->m_prologState);\n    parser->m_processor = externalParEntInitProcessor;\n  }\n#endif /* XML_DTD */\n  return parser;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -97,8 +97,7 @@\n      would be otherwise.\n   */\n   if (parser->m_ns) {\n-    XML_Char tmp[2];\n-    *tmp = parser->m_namespaceSeparator;\n+    XML_Char tmp[2] = {parser->m_namespaceSeparator, 0};\n     parser = parserCreate(encodingName, &parser->m_mem, tmp, newDtd);\n   } else {\n     parser = parserCreate(encodingName, &parser->m_mem, NULL, newDtd);",
        "diff_line_info": {
            "deleted_lines": [
                "    XML_Char tmp[2];",
                "    *tmp = parser->m_namespaceSeparator;"
            ],
            "added_lines": [
                "    XML_Char tmp[2] = {parser->m_namespaceSeparator, 0};"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-25236",
        "func_name": "libexpat/XML_ParserCreateNS",
        "description": "xmlparse.c in Expat (aka libexpat) before 2.4.5 allows attackers to insert namespace-separator characters into namespace URIs.",
        "git_url": "https://github.com/libexpat/libexpat/commit/6881a4fc8596307ab9ff2e85e605afa2e413ab71",
        "commit_title": "lib: Fix (harmless) use of uninitialized memory",
        "commit_text": "",
        "func_before": "XML_Parser XMLCALL\nXML_ParserCreateNS(const XML_Char *encodingName, XML_Char nsSep) {\n  XML_Char tmp[2];\n  *tmp = nsSep;\n  return XML_ParserCreate_MM(encodingName, NULL, tmp);\n}",
        "func": "XML_Parser XMLCALL\nXML_ParserCreateNS(const XML_Char *encodingName, XML_Char nsSep) {\n  XML_Char tmp[2] = {nsSep, 0};\n  return XML_ParserCreate_MM(encodingName, NULL, tmp);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,5 @@\n XML_Parser XMLCALL\n XML_ParserCreateNS(const XML_Char *encodingName, XML_Char nsSep) {\n-  XML_Char tmp[2];\n-  *tmp = nsSep;\n+  XML_Char tmp[2] = {nsSep, 0};\n   return XML_ParserCreate_MM(encodingName, NULL, tmp);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  XML_Char tmp[2];",
                "  *tmp = nsSep;"
            ],
            "added_lines": [
                "  XML_Char tmp[2] = {nsSep, 0};"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-25236",
        "func_name": "libexpat/addBinding",
        "description": "xmlparse.c in Expat (aka libexpat) before 2.4.5 allows attackers to insert namespace-separator characters into namespace URIs.",
        "git_url": "https://github.com/libexpat/libexpat/commit/a2fe525e660badd64b6c557c2b1ec26ddc07f6e4",
        "commit_title": "lib: Protect against malicious namespace declarations (CVE-2022-25236)",
        "commit_text": "",
        "func_before": "static enum XML_Error\naddBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId,\n           const XML_Char *uri, BINDING **bindingsPtr) {\n  static const XML_Char xmlNamespace[]\n      = {ASCII_h,      ASCII_t,     ASCII_t,     ASCII_p,      ASCII_COLON,\n         ASCII_SLASH,  ASCII_SLASH, ASCII_w,     ASCII_w,      ASCII_w,\n         ASCII_PERIOD, ASCII_w,     ASCII_3,     ASCII_PERIOD, ASCII_o,\n         ASCII_r,      ASCII_g,     ASCII_SLASH, ASCII_X,      ASCII_M,\n         ASCII_L,      ASCII_SLASH, ASCII_1,     ASCII_9,      ASCII_9,\n         ASCII_8,      ASCII_SLASH, ASCII_n,     ASCII_a,      ASCII_m,\n         ASCII_e,      ASCII_s,     ASCII_p,     ASCII_a,      ASCII_c,\n         ASCII_e,      '\\0'};\n  static const int xmlLen = (int)sizeof(xmlNamespace) / sizeof(XML_Char) - 1;\n  static const XML_Char xmlnsNamespace[]\n      = {ASCII_h,     ASCII_t,      ASCII_t, ASCII_p, ASCII_COLON,  ASCII_SLASH,\n         ASCII_SLASH, ASCII_w,      ASCII_w, ASCII_w, ASCII_PERIOD, ASCII_w,\n         ASCII_3,     ASCII_PERIOD, ASCII_o, ASCII_r, ASCII_g,      ASCII_SLASH,\n         ASCII_2,     ASCII_0,      ASCII_0, ASCII_0, ASCII_SLASH,  ASCII_x,\n         ASCII_m,     ASCII_l,      ASCII_n, ASCII_s, ASCII_SLASH,  '\\0'};\n  static const int xmlnsLen\n      = (int)sizeof(xmlnsNamespace) / sizeof(XML_Char) - 1;\n\n  XML_Bool mustBeXML = XML_FALSE;\n  XML_Bool isXML = XML_TRUE;\n  XML_Bool isXMLNS = XML_TRUE;\n\n  BINDING *b;\n  int len;\n\n  /* empty URI is only valid for default namespace per XML NS 1.0 (not 1.1) */\n  if (*uri == XML_T('\\0') && prefix->name)\n    return XML_ERROR_UNDECLARING_PREFIX;\n\n  if (prefix->name && prefix->name[0] == XML_T(ASCII_x)\n      && prefix->name[1] == XML_T(ASCII_m)\n      && prefix->name[2] == XML_T(ASCII_l)) {\n    /* Not allowed to bind xmlns */\n    if (prefix->name[3] == XML_T(ASCII_n) && prefix->name[4] == XML_T(ASCII_s)\n        && prefix->name[5] == XML_T('\\0'))\n      return XML_ERROR_RESERVED_PREFIX_XMLNS;\n\n    if (prefix->name[3] == XML_T('\\0'))\n      mustBeXML = XML_TRUE;\n  }\n\n  for (len = 0; uri[len]; len++) {\n    if (isXML && (len > xmlLen || uri[len] != xmlNamespace[len]))\n      isXML = XML_FALSE;\n\n    if (! mustBeXML && isXMLNS\n        && (len > xmlnsLen || uri[len] != xmlnsNamespace[len]))\n      isXMLNS = XML_FALSE;\n  }\n  isXML = isXML && len == xmlLen;\n  isXMLNS = isXMLNS && len == xmlnsLen;\n\n  if (mustBeXML != isXML)\n    return mustBeXML ? XML_ERROR_RESERVED_PREFIX_XML\n                     : XML_ERROR_RESERVED_NAMESPACE_URI;\n\n  if (isXMLNS)\n    return XML_ERROR_RESERVED_NAMESPACE_URI;\n\n  if (parser->m_namespaceSeparator)\n    len++;\n  if (parser->m_freeBindingList) {\n    b = parser->m_freeBindingList;\n    if (len > b->uriAlloc) {\n      /* Detect and prevent integer overflow */\n      if (len > INT_MAX - EXPAND_SPARE) {\n        return XML_ERROR_NO_MEMORY;\n      }\n\n      /* Detect and prevent integer overflow.\n       * The preprocessor guard addresses the \"always false\" warning\n       * from -Wtype-limits on platforms where\n       * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n      if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n        return XML_ERROR_NO_MEMORY;\n      }\n#endif\n\n      XML_Char *temp = (XML_Char *)REALLOC(\n          parser, b->uri, sizeof(XML_Char) * (len + EXPAND_SPARE));\n      if (temp == NULL)\n        return XML_ERROR_NO_MEMORY;\n      b->uri = temp;\n      b->uriAlloc = len + EXPAND_SPARE;\n    }\n    parser->m_freeBindingList = b->nextTagBinding;\n  } else {\n    b = (BINDING *)MALLOC(parser, sizeof(BINDING));\n    if (! b)\n      return XML_ERROR_NO_MEMORY;\n\n    /* Detect and prevent integer overflow */\n    if (len > INT_MAX - EXPAND_SPARE) {\n      return XML_ERROR_NO_MEMORY;\n    }\n    /* Detect and prevent integer overflow.\n     * The preprocessor guard addresses the \"always false\" warning\n     * from -Wtype-limits on platforms where\n     * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n    if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n      return XML_ERROR_NO_MEMORY;\n    }\n#endif\n\n    b->uri\n        = (XML_Char *)MALLOC(parser, sizeof(XML_Char) * (len + EXPAND_SPARE));\n    if (! b->uri) {\n      FREE(parser, b);\n      return XML_ERROR_NO_MEMORY;\n    }\n    b->uriAlloc = len + EXPAND_SPARE;\n  }\n  b->uriLen = len;\n  memcpy(b->uri, uri, len * sizeof(XML_Char));\n  if (parser->m_namespaceSeparator)\n    b->uri[len - 1] = parser->m_namespaceSeparator;\n  b->prefix = prefix;\n  b->attId = attId;\n  b->prevPrefixBinding = prefix->binding;\n  /* NULL binding when default namespace undeclared */\n  if (*uri == XML_T('\\0') && prefix == &parser->m_dtd->defaultPrefix)\n    prefix->binding = NULL;\n  else\n    prefix->binding = b;\n  b->nextTagBinding = *bindingsPtr;\n  *bindingsPtr = b;\n  /* if attId == NULL then we are not starting a namespace scope */\n  if (attId && parser->m_startNamespaceDeclHandler)\n    parser->m_startNamespaceDeclHandler(parser->m_handlerArg, prefix->name,\n                                        prefix->binding ? uri : 0);\n  return XML_ERROR_NONE;\n}",
        "func": "static enum XML_Error\naddBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId,\n           const XML_Char *uri, BINDING **bindingsPtr) {\n  static const XML_Char xmlNamespace[]\n      = {ASCII_h,      ASCII_t,     ASCII_t,     ASCII_p,      ASCII_COLON,\n         ASCII_SLASH,  ASCII_SLASH, ASCII_w,     ASCII_w,      ASCII_w,\n         ASCII_PERIOD, ASCII_w,     ASCII_3,     ASCII_PERIOD, ASCII_o,\n         ASCII_r,      ASCII_g,     ASCII_SLASH, ASCII_X,      ASCII_M,\n         ASCII_L,      ASCII_SLASH, ASCII_1,     ASCII_9,      ASCII_9,\n         ASCII_8,      ASCII_SLASH, ASCII_n,     ASCII_a,      ASCII_m,\n         ASCII_e,      ASCII_s,     ASCII_p,     ASCII_a,      ASCII_c,\n         ASCII_e,      '\\0'};\n  static const int xmlLen = (int)sizeof(xmlNamespace) / sizeof(XML_Char) - 1;\n  static const XML_Char xmlnsNamespace[]\n      = {ASCII_h,     ASCII_t,      ASCII_t, ASCII_p, ASCII_COLON,  ASCII_SLASH,\n         ASCII_SLASH, ASCII_w,      ASCII_w, ASCII_w, ASCII_PERIOD, ASCII_w,\n         ASCII_3,     ASCII_PERIOD, ASCII_o, ASCII_r, ASCII_g,      ASCII_SLASH,\n         ASCII_2,     ASCII_0,      ASCII_0, ASCII_0, ASCII_SLASH,  ASCII_x,\n         ASCII_m,     ASCII_l,      ASCII_n, ASCII_s, ASCII_SLASH,  '\\0'};\n  static const int xmlnsLen\n      = (int)sizeof(xmlnsNamespace) / sizeof(XML_Char) - 1;\n\n  XML_Bool mustBeXML = XML_FALSE;\n  XML_Bool isXML = XML_TRUE;\n  XML_Bool isXMLNS = XML_TRUE;\n\n  BINDING *b;\n  int len;\n\n  /* empty URI is only valid for default namespace per XML NS 1.0 (not 1.1) */\n  if (*uri == XML_T('\\0') && prefix->name)\n    return XML_ERROR_UNDECLARING_PREFIX;\n\n  if (prefix->name && prefix->name[0] == XML_T(ASCII_x)\n      && prefix->name[1] == XML_T(ASCII_m)\n      && prefix->name[2] == XML_T(ASCII_l)) {\n    /* Not allowed to bind xmlns */\n    if (prefix->name[3] == XML_T(ASCII_n) && prefix->name[4] == XML_T(ASCII_s)\n        && prefix->name[5] == XML_T('\\0'))\n      return XML_ERROR_RESERVED_PREFIX_XMLNS;\n\n    if (prefix->name[3] == XML_T('\\0'))\n      mustBeXML = XML_TRUE;\n  }\n\n  for (len = 0; uri[len]; len++) {\n    if (isXML && (len > xmlLen || uri[len] != xmlNamespace[len]))\n      isXML = XML_FALSE;\n\n    if (! mustBeXML && isXMLNS\n        && (len > xmlnsLen || uri[len] != xmlnsNamespace[len]))\n      isXMLNS = XML_FALSE;\n\n    // NOTE: While Expat does not validate namespace URIs against RFC 3986,\n    //       we have to at least make sure that the XML processor on top of\n    //       Expat (that is splitting tag names by namespace separator into\n    //       2- or 3-tuples (uri-local or uri-local-prefix)) cannot be confused\n    //       by an attacker putting additional namespace separator characters\n    //       into namespace declarations.  That would be ambiguous and not to\n    //       be expected.\n    if (parser->m_ns && (uri[len] == parser->m_namespaceSeparator)) {\n      return XML_ERROR_SYNTAX;\n    }\n  }\n  isXML = isXML && len == xmlLen;\n  isXMLNS = isXMLNS && len == xmlnsLen;\n\n  if (mustBeXML != isXML)\n    return mustBeXML ? XML_ERROR_RESERVED_PREFIX_XML\n                     : XML_ERROR_RESERVED_NAMESPACE_URI;\n\n  if (isXMLNS)\n    return XML_ERROR_RESERVED_NAMESPACE_URI;\n\n  if (parser->m_namespaceSeparator)\n    len++;\n  if (parser->m_freeBindingList) {\n    b = parser->m_freeBindingList;\n    if (len > b->uriAlloc) {\n      /* Detect and prevent integer overflow */\n      if (len > INT_MAX - EXPAND_SPARE) {\n        return XML_ERROR_NO_MEMORY;\n      }\n\n      /* Detect and prevent integer overflow.\n       * The preprocessor guard addresses the \"always false\" warning\n       * from -Wtype-limits on platforms where\n       * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n      if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n        return XML_ERROR_NO_MEMORY;\n      }\n#endif\n\n      XML_Char *temp = (XML_Char *)REALLOC(\n          parser, b->uri, sizeof(XML_Char) * (len + EXPAND_SPARE));\n      if (temp == NULL)\n        return XML_ERROR_NO_MEMORY;\n      b->uri = temp;\n      b->uriAlloc = len + EXPAND_SPARE;\n    }\n    parser->m_freeBindingList = b->nextTagBinding;\n  } else {\n    b = (BINDING *)MALLOC(parser, sizeof(BINDING));\n    if (! b)\n      return XML_ERROR_NO_MEMORY;\n\n    /* Detect and prevent integer overflow */\n    if (len > INT_MAX - EXPAND_SPARE) {\n      return XML_ERROR_NO_MEMORY;\n    }\n    /* Detect and prevent integer overflow.\n     * The preprocessor guard addresses the \"always false\" warning\n     * from -Wtype-limits on platforms where\n     * sizeof(unsigned int) < sizeof(size_t), e.g. on x86_64. */\n#if UINT_MAX >= SIZE_MAX\n    if ((unsigned)(len + EXPAND_SPARE) > (size_t)(-1) / sizeof(XML_Char)) {\n      return XML_ERROR_NO_MEMORY;\n    }\n#endif\n\n    b->uri\n        = (XML_Char *)MALLOC(parser, sizeof(XML_Char) * (len + EXPAND_SPARE));\n    if (! b->uri) {\n      FREE(parser, b);\n      return XML_ERROR_NO_MEMORY;\n    }\n    b->uriAlloc = len + EXPAND_SPARE;\n  }\n  b->uriLen = len;\n  memcpy(b->uri, uri, len * sizeof(XML_Char));\n  if (parser->m_namespaceSeparator)\n    b->uri[len - 1] = parser->m_namespaceSeparator;\n  b->prefix = prefix;\n  b->attId = attId;\n  b->prevPrefixBinding = prefix->binding;\n  /* NULL binding when default namespace undeclared */\n  if (*uri == XML_T('\\0') && prefix == &parser->m_dtd->defaultPrefix)\n    prefix->binding = NULL;\n  else\n    prefix->binding = b;\n  b->nextTagBinding = *bindingsPtr;\n  *bindingsPtr = b;\n  /* if attId == NULL then we are not starting a namespace scope */\n  if (attId && parser->m_startNamespaceDeclHandler)\n    parser->m_startNamespaceDeclHandler(parser->m_handlerArg, prefix->name,\n                                        prefix->binding ? uri : 0);\n  return XML_ERROR_NONE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -50,6 +50,17 @@\n     if (! mustBeXML && isXMLNS\n         && (len > xmlnsLen || uri[len] != xmlnsNamespace[len]))\n       isXMLNS = XML_FALSE;\n+\n+    // NOTE: While Expat does not validate namespace URIs against RFC 3986,\n+    //       we have to at least make sure that the XML processor on top of\n+    //       Expat (that is splitting tag names by namespace separator into\n+    //       2- or 3-tuples (uri-local or uri-local-prefix)) cannot be confused\n+    //       by an attacker putting additional namespace separator characters\n+    //       into namespace declarations.  That would be ambiguous and not to\n+    //       be expected.\n+    if (parser->m_ns && (uri[len] == parser->m_namespaceSeparator)) {\n+      return XML_ERROR_SYNTAX;\n+    }\n   }\n   isXML = isXML && len == xmlLen;\n   isXMLNS = isXMLNS && len == xmlnsLen;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    // NOTE: While Expat does not validate namespace URIs against RFC 3986,",
                "    //       we have to at least make sure that the XML processor on top of",
                "    //       Expat (that is splitting tag names by namespace separator into",
                "    //       2- or 3-tuples (uri-local or uri-local-prefix)) cannot be confused",
                "    //       by an attacker putting additional namespace separator characters",
                "    //       into namespace declarations.  That would be ambiguous and not to",
                "    //       be expected.",
                "    if (parser->m_ns && (uri[len] == parser->m_namespaceSeparator)) {",
                "      return XML_ERROR_SYNTAX;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-15592",
        "func_name": "xen-project/xen/sh_guess_wrmap",
        "description": "An issue was discovered in Xen through 4.9.x allowing x86 HVM guest OS users to cause a denial of service (hypervisor crash) or possibly gain privileges because self-linear shadow mappings are mishandled for translated guests.",
        "git_url": "https://github.com/xen-project/xen/commit/d20daf4294adbdb9316850566013edb98db7bfbc",
        "commit_title": "x86/shadow: correct SH_LINEAR mapping detection in sh_guess_wrmap()",
        "commit_text": " The fix for XSA-243 / CVE-2017-15592 (c/s bf2b4eadcf379) introduced a change in behaviour for sh_guest_wrmap(), where it had to cope with no shadow linear mapping being present.  As the name suggests, guest_vtable is a mapping of the guests pagetable, not Xen's pagetable, meaning that it isn't the pagetable we need to check for the shadow linear slot in.  The practical upshot is that a shadow HVM vcpu which switches into 4-level paging mode, with an L4 pagetable that contains a mapping which aliases Xen's SH_LINEAR_PT_VIRT_START will fool the safety check for whether a SHADOW_LINEAR mapping is present.  As the check passes (when it should have failed), Xen subsequently falls over the missing mapping with a pagefault such as:      (XEN) Pagetable walk from ffff8140a0503880:     (XEN)  L4[0x102] = 000000046c218063 ffffffffffffffff     (XEN)  L3[0x102] = 000000046c218063 ffffffffffffffff     (XEN)  L2[0x102] = 000000046c218063 ffffffffffffffff     (XEN)  L1[0x103] = 0000000000000000 ffffffffffffffff  This is part of XSA-243. ",
        "func_before": "static int sh_guess_wrmap(struct vcpu *v, unsigned long vaddr, mfn_t gmfn)\n/* Look up this vaddr in the current shadow and see if it's a writeable\n * mapping of this gmfn.  If so, remove it.  Returns 1 if it worked. */\n{\n    struct domain *d = v->domain;\n    shadow_l1e_t sl1e, *sl1p;\n    shadow_l2e_t *sl2p;\n    shadow_l3e_t *sl3p;\n#if SHADOW_PAGING_LEVELS >= 4\n    shadow_l4e_t *sl4p;\n#endif\n    mfn_t sl1mfn;\n    int r;\n\n    /* Carefully look in the shadow linear map for the l1e we expect */\n#if SHADOW_PAGING_LEVELS >= 4\n    /* Is a shadow linear map is installed in the first place? */\n    sl4p  = v->arch.paging.shadow.guest_vtable;\n    sl4p += shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START);\n    if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )\n        return 0;\n    sl4p = sh_linear_l4_table(v) + shadow_l4_linear_offset(vaddr);\n    if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )\n        return 0;\n    sl3p = sh_linear_l3_table(v) + shadow_l3_linear_offset(vaddr);\n    if ( !(shadow_l3e_get_flags(*sl3p) & _PAGE_PRESENT) )\n        return 0;\n#else /* SHADOW_PAGING_LEVELS == 3 */\n    sl3p = ((shadow_l3e_t *) v->arch.paging.shadow.l3table)\n        + shadow_l3_linear_offset(vaddr);\n    if ( !(shadow_l3e_get_flags(*sl3p) & _PAGE_PRESENT) )\n        return 0;\n#endif\n    sl2p = sh_linear_l2_table(v) + shadow_l2_linear_offset(vaddr);\n    if ( !(shadow_l2e_get_flags(*sl2p) & _PAGE_PRESENT) )\n        return 0;\n    sl1p = sh_linear_l1_table(v) + shadow_l1_linear_offset(vaddr);\n    sl1e = *sl1p;\n    if ( ((shadow_l1e_get_flags(sl1e) & (_PAGE_PRESENT|_PAGE_RW))\n          != (_PAGE_PRESENT|_PAGE_RW))\n         || (mfn_x(shadow_l1e_get_mfn(sl1e)) != mfn_x(gmfn)) )\n        return 0;\n\n    /* Found it!  Need to remove its write permissions. */\n    sl1mfn = shadow_l2e_get_mfn(*sl2p);\n    sl1e = shadow_l1e_remove_flags(sl1e, _PAGE_RW);\n    r = shadow_set_l1e(d, sl1p, sl1e, p2m_ram_rw, sl1mfn);\n    if ( r & SHADOW_SET_ERROR ) {\n        /* Can only currently happen if we found a grant-mapped\n         * page.  Just make the guess fail. */\n        return 0;\n    }\n    TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_WRMAP_GUESS_FOUND);\n    return 1;\n}",
        "func": "static int sh_guess_wrmap(struct vcpu *v, unsigned long vaddr, mfn_t gmfn)\n/* Look up this vaddr in the current shadow and see if it's a writeable\n * mapping of this gmfn.  If so, remove it.  Returns 1 if it worked. */\n{\n    struct domain *d = v->domain;\n    shadow_l1e_t sl1e, *sl1p;\n    shadow_l2e_t *sl2p;\n    shadow_l3e_t *sl3p;\n#if SHADOW_PAGING_LEVELS >= 4\n    shadow_l4e_t *sl4p;\n#endif\n    mfn_t sl1mfn;\n    int r;\n\n    /* Carefully look in the shadow linear map for the l1e we expect */\n#if SHADOW_PAGING_LEVELS >= 4\n    /*\n     * Non-external guests (i.e. PV) have a SHADOW_LINEAR mapping from the\n     * moment their shadows are created.  External guests (i.e. HVM) may not,\n     * but always have a regular linear mapping, which we can use to observe\n     * whether a SHADOW_LINEAR mapping is present.\n     */\n    if ( paging_mode_external(d) )\n    {\n        sl4p =  __linear_l4_table + l4_linear_offset(SH_LINEAR_PT_VIRT_START);\n        if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )\n            return 0;\n    }\n    sl4p = sh_linear_l4_table(v) + shadow_l4_linear_offset(vaddr);\n    if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )\n        return 0;\n    sl3p = sh_linear_l3_table(v) + shadow_l3_linear_offset(vaddr);\n    if ( !(shadow_l3e_get_flags(*sl3p) & _PAGE_PRESENT) )\n        return 0;\n#else /* SHADOW_PAGING_LEVELS == 3 */\n    sl3p = ((shadow_l3e_t *) v->arch.paging.shadow.l3table)\n        + shadow_l3_linear_offset(vaddr);\n    if ( !(shadow_l3e_get_flags(*sl3p) & _PAGE_PRESENT) )\n        return 0;\n#endif\n    sl2p = sh_linear_l2_table(v) + shadow_l2_linear_offset(vaddr);\n    if ( !(shadow_l2e_get_flags(*sl2p) & _PAGE_PRESENT) )\n        return 0;\n    sl1p = sh_linear_l1_table(v) + shadow_l1_linear_offset(vaddr);\n    sl1e = *sl1p;\n    if ( ((shadow_l1e_get_flags(sl1e) & (_PAGE_PRESENT|_PAGE_RW))\n          != (_PAGE_PRESENT|_PAGE_RW))\n         || (mfn_x(shadow_l1e_get_mfn(sl1e)) != mfn_x(gmfn)) )\n        return 0;\n\n    /* Found it!  Need to remove its write permissions. */\n    sl1mfn = shadow_l2e_get_mfn(*sl2p);\n    sl1e = shadow_l1e_remove_flags(sl1e, _PAGE_RW);\n    r = shadow_set_l1e(d, sl1p, sl1e, p2m_ram_rw, sl1mfn);\n    if ( r & SHADOW_SET_ERROR ) {\n        /* Can only currently happen if we found a grant-mapped\n         * page.  Just make the guess fail. */\n        return 0;\n    }\n    TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_WRMAP_GUESS_FOUND);\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,11 +14,18 @@\n \n     /* Carefully look in the shadow linear map for the l1e we expect */\n #if SHADOW_PAGING_LEVELS >= 4\n-    /* Is a shadow linear map is installed in the first place? */\n-    sl4p  = v->arch.paging.shadow.guest_vtable;\n-    sl4p += shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START);\n-    if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )\n-        return 0;\n+    /*\n+     * Non-external guests (i.e. PV) have a SHADOW_LINEAR mapping from the\n+     * moment their shadows are created.  External guests (i.e. HVM) may not,\n+     * but always have a regular linear mapping, which we can use to observe\n+     * whether a SHADOW_LINEAR mapping is present.\n+     */\n+    if ( paging_mode_external(d) )\n+    {\n+        sl4p =  __linear_l4_table + l4_linear_offset(SH_LINEAR_PT_VIRT_START);\n+        if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )\n+            return 0;\n+    }\n     sl4p = sh_linear_l4_table(v) + shadow_l4_linear_offset(vaddr);\n     if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )\n         return 0;",
        "diff_line_info": {
            "deleted_lines": [
                "    /* Is a shadow linear map is installed in the first place? */",
                "    sl4p  = v->arch.paging.shadow.guest_vtable;",
                "    sl4p += shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START);",
                "    if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )",
                "        return 0;"
            ],
            "added_lines": [
                "    /*",
                "     * Non-external guests (i.e. PV) have a SHADOW_LINEAR mapping from the",
                "     * moment their shadows are created.  External guests (i.e. HVM) may not,",
                "     * but always have a regular linear mapping, which we can use to observe",
                "     * whether a SHADOW_LINEAR mapping is present.",
                "     */",
                "    if ( paging_mode_external(d) )",
                "    {",
                "        sl4p =  __linear_l4_table + l4_linear_offset(SH_LINEAR_PT_VIRT_START);",
                "        if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )",
                "            return 0;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-15592",
        "func_name": "xen-project/xen/sh_guess_wrmap",
        "description": "An issue was discovered in Xen through 4.9.x allowing x86 HVM guest OS users to cause a denial of service (hypervisor crash) or possibly gain privileges because self-linear shadow mappings are mishandled for translated guests.",
        "git_url": "https://github.com/xen-project/xen/commit/bf2b4eadcf379d0361b38de9725ea5f7a18a5205",
        "commit_title": "x86/shadow: Don't create self-linear shadow mappings for 4-level translated guests",
        "commit_text": " When initially creating a monitor table for 4-level translated guests, don't install a shadow-linear mapping.  This mapping is actually self-linear, and trips up the writeable heuristic logic into following Xen's mappings, not the guests' shadows it was expecting to follow.  A consequence of this is that sh_guess_wrmap() needs to cope with there being no shadow-linear mapping present, which in practice occurs once each time a vcpu switches to 4-level paging from a different paging mode.  An appropriate shadow-linear slot will be inserted into the monitor table either while constructing lower level monitor tables, or by sh_update_cr3().  While fixing this, clarify the safety of the other mappings.  Despite appearing unsafe, it is correct to create a guest-linear mapping for translated domains; this is self-linear and doesn't point into the translated domain.  Drop a dead clause for translate != external guests.  This is XSA-243. ",
        "func_before": "static int sh_guess_wrmap(struct vcpu *v, unsigned long vaddr, mfn_t gmfn)\n/* Look up this vaddr in the current shadow and see if it's a writeable\n * mapping of this gmfn.  If so, remove it.  Returns 1 if it worked. */\n{\n    struct domain *d = v->domain;\n    shadow_l1e_t sl1e, *sl1p;\n    shadow_l2e_t *sl2p;\n    shadow_l3e_t *sl3p;\n#if SHADOW_PAGING_LEVELS >= 4\n    shadow_l4e_t *sl4p;\n#endif\n    mfn_t sl1mfn;\n    int r;\n\n    /* Carefully look in the shadow linear map for the l1e we expect */\n#if SHADOW_PAGING_LEVELS >= 4\n    sl4p = sh_linear_l4_table(v) + shadow_l4_linear_offset(vaddr);\n    if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )\n        return 0;\n    sl3p = sh_linear_l3_table(v) + shadow_l3_linear_offset(vaddr);\n    if ( !(shadow_l3e_get_flags(*sl3p) & _PAGE_PRESENT) )\n        return 0;\n#else /* SHADOW_PAGING_LEVELS == 3 */\n    sl3p = ((shadow_l3e_t *) v->arch.paging.shadow.l3table)\n        + shadow_l3_linear_offset(vaddr);\n    if ( !(shadow_l3e_get_flags(*sl3p) & _PAGE_PRESENT) )\n        return 0;\n#endif\n    sl2p = sh_linear_l2_table(v) + shadow_l2_linear_offset(vaddr);\n    if ( !(shadow_l2e_get_flags(*sl2p) & _PAGE_PRESENT) )\n        return 0;\n    sl1p = sh_linear_l1_table(v) + shadow_l1_linear_offset(vaddr);\n    sl1e = *sl1p;\n    if ( ((shadow_l1e_get_flags(sl1e) & (_PAGE_PRESENT|_PAGE_RW))\n          != (_PAGE_PRESENT|_PAGE_RW))\n         || (mfn_x(shadow_l1e_get_mfn(sl1e)) != mfn_x(gmfn)) )\n        return 0;\n\n    /* Found it!  Need to remove its write permissions. */\n    sl1mfn = shadow_l2e_get_mfn(*sl2p);\n    sl1e = shadow_l1e_remove_flags(sl1e, _PAGE_RW);\n    r = shadow_set_l1e(d, sl1p, sl1e, p2m_ram_rw, sl1mfn);\n    if ( r & SHADOW_SET_ERROR ) {\n        /* Can only currently happen if we found a grant-mapped\n         * page.  Just make the guess fail. */\n        return 0;\n    }\n    TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_WRMAP_GUESS_FOUND);\n    return 1;\n}",
        "func": "static int sh_guess_wrmap(struct vcpu *v, unsigned long vaddr, mfn_t gmfn)\n/* Look up this vaddr in the current shadow and see if it's a writeable\n * mapping of this gmfn.  If so, remove it.  Returns 1 if it worked. */\n{\n    struct domain *d = v->domain;\n    shadow_l1e_t sl1e, *sl1p;\n    shadow_l2e_t *sl2p;\n    shadow_l3e_t *sl3p;\n#if SHADOW_PAGING_LEVELS >= 4\n    shadow_l4e_t *sl4p;\n#endif\n    mfn_t sl1mfn;\n    int r;\n\n    /* Carefully look in the shadow linear map for the l1e we expect */\n#if SHADOW_PAGING_LEVELS >= 4\n    /* Is a shadow linear map is installed in the first place? */\n    sl4p  = v->arch.paging.shadow.guest_vtable;\n    sl4p += shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START);\n    if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )\n        return 0;\n    sl4p = sh_linear_l4_table(v) + shadow_l4_linear_offset(vaddr);\n    if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )\n        return 0;\n    sl3p = sh_linear_l3_table(v) + shadow_l3_linear_offset(vaddr);\n    if ( !(shadow_l3e_get_flags(*sl3p) & _PAGE_PRESENT) )\n        return 0;\n#else /* SHADOW_PAGING_LEVELS == 3 */\n    sl3p = ((shadow_l3e_t *) v->arch.paging.shadow.l3table)\n        + shadow_l3_linear_offset(vaddr);\n    if ( !(shadow_l3e_get_flags(*sl3p) & _PAGE_PRESENT) )\n        return 0;\n#endif\n    sl2p = sh_linear_l2_table(v) + shadow_l2_linear_offset(vaddr);\n    if ( !(shadow_l2e_get_flags(*sl2p) & _PAGE_PRESENT) )\n        return 0;\n    sl1p = sh_linear_l1_table(v) + shadow_l1_linear_offset(vaddr);\n    sl1e = *sl1p;\n    if ( ((shadow_l1e_get_flags(sl1e) & (_PAGE_PRESENT|_PAGE_RW))\n          != (_PAGE_PRESENT|_PAGE_RW))\n         || (mfn_x(shadow_l1e_get_mfn(sl1e)) != mfn_x(gmfn)) )\n        return 0;\n\n    /* Found it!  Need to remove its write permissions. */\n    sl1mfn = shadow_l2e_get_mfn(*sl2p);\n    sl1e = shadow_l1e_remove_flags(sl1e, _PAGE_RW);\n    r = shadow_set_l1e(d, sl1p, sl1e, p2m_ram_rw, sl1mfn);\n    if ( r & SHADOW_SET_ERROR ) {\n        /* Can only currently happen if we found a grant-mapped\n         * page.  Just make the guess fail. */\n        return 0;\n    }\n    TRACE_SHADOW_PATH_FLAG(TRCE_SFLAG_WRMAP_GUESS_FOUND);\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,11 @@\n \n     /* Carefully look in the shadow linear map for the l1e we expect */\n #if SHADOW_PAGING_LEVELS >= 4\n+    /* Is a shadow linear map is installed in the first place? */\n+    sl4p  = v->arch.paging.shadow.guest_vtable;\n+    sl4p += shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START);\n+    if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )\n+        return 0;\n     sl4p = sh_linear_l4_table(v) + shadow_l4_linear_offset(vaddr);\n     if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )\n         return 0;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    /* Is a shadow linear map is installed in the first place? */",
                "    sl4p  = v->arch.paging.shadow.guest_vtable;",
                "    sl4p += shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START);",
                "    if ( !(shadow_l4e_get_flags(*sl4p) & _PAGE_PRESENT) )",
                "        return 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-15592",
        "func_name": "xen-project/xen/sh_install_xen_entries_in_l4",
        "description": "An issue was discovered in Xen through 4.9.x allowing x86 HVM guest OS users to cause a denial of service (hypervisor crash) or possibly gain privileges because self-linear shadow mappings are mishandled for translated guests.",
        "git_url": "https://github.com/xen-project/xen/commit/bf2b4eadcf379d0361b38de9725ea5f7a18a5205",
        "commit_title": "x86/shadow: Don't create self-linear shadow mappings for 4-level translated guests",
        "commit_text": " When initially creating a monitor table for 4-level translated guests, don't install a shadow-linear mapping.  This mapping is actually self-linear, and trips up the writeable heuristic logic into following Xen's mappings, not the guests' shadows it was expecting to follow.  A consequence of this is that sh_guess_wrmap() needs to cope with there being no shadow-linear mapping present, which in practice occurs once each time a vcpu switches to 4-level paging from a different paging mode.  An appropriate shadow-linear slot will be inserted into the monitor table either while constructing lower level monitor tables, or by sh_update_cr3().  While fixing this, clarify the safety of the other mappings.  Despite appearing unsafe, it is correct to create a guest-linear mapping for translated domains; this is self-linear and doesn't point into the translated domain.  Drop a dead clause for translate != external guests.  This is XSA-243. ",
        "func_before": "void sh_install_xen_entries_in_l4(struct domain *d, mfn_t gl4mfn, mfn_t sl4mfn)\n{\n    shadow_l4e_t *sl4e;\n    unsigned int slots;\n\n    sl4e = map_domain_page(sl4mfn);\n    BUILD_BUG_ON(sizeof (l4_pgentry_t) != sizeof (shadow_l4e_t));\n\n    /* Copy the common Xen mappings from the idle domain */\n    slots = (shadow_mode_external(d)\n             ? ROOT_PAGETABLE_XEN_SLOTS\n             : ROOT_PAGETABLE_PV_XEN_SLOTS);\n    memcpy(&sl4e[ROOT_PAGETABLE_FIRST_XEN_SLOT],\n           &idle_pg_table[ROOT_PAGETABLE_FIRST_XEN_SLOT],\n           slots * sizeof(l4_pgentry_t));\n\n    /* Install the per-domain mappings for this domain */\n    sl4e[shadow_l4_table_offset(PERDOMAIN_VIRT_START)] =\n        shadow_l4e_from_mfn(page_to_mfn(d->arch.perdomain_l3_pg),\n                            __PAGE_HYPERVISOR_RW);\n\n    if ( !shadow_mode_external(d) && !is_pv_32bit_domain(d) &&\n         !VM_ASSIST(d, m2p_strict) )\n    {\n        /* open coded zap_ro_mpt(mfn_x(sl4mfn)): */\n        sl4e[shadow_l4_table_offset(RO_MPT_VIRT_START)] = shadow_l4e_empty();\n    }\n\n    /* Shadow linear mapping for 4-level shadows.  N.B. for 3-level\n     * shadows on 64-bit xen, this linear mapping is later replaced by the\n     * monitor pagetable structure, which is built in make_monitor_table\n     * and maintained by sh_update_linear_entries. */\n    sl4e[shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START)] =\n        shadow_l4e_from_mfn(sl4mfn, __PAGE_HYPERVISOR_RW);\n\n    /* Self linear mapping.  */\n    if ( shadow_mode_translate(d) && !shadow_mode_external(d) )\n    {\n        // linear tables may not be used with translated PV guests\n        sl4e[shadow_l4_table_offset(LINEAR_PT_VIRT_START)] =\n            shadow_l4e_empty();\n    }\n    else\n    {\n        sl4e[shadow_l4_table_offset(LINEAR_PT_VIRT_START)] =\n            shadow_l4e_from_mfn(gl4mfn, __PAGE_HYPERVISOR_RW);\n    }\n\n    unmap_domain_page(sl4e);\n}",
        "func": "void sh_install_xen_entries_in_l4(struct domain *d, mfn_t gl4mfn, mfn_t sl4mfn)\n{\n    shadow_l4e_t *sl4e;\n    unsigned int slots;\n\n    sl4e = map_domain_page(sl4mfn);\n    BUILD_BUG_ON(sizeof (l4_pgentry_t) != sizeof (shadow_l4e_t));\n\n    /* Copy the common Xen mappings from the idle domain */\n    slots = (shadow_mode_external(d)\n             ? ROOT_PAGETABLE_XEN_SLOTS\n             : ROOT_PAGETABLE_PV_XEN_SLOTS);\n    memcpy(&sl4e[ROOT_PAGETABLE_FIRST_XEN_SLOT],\n           &idle_pg_table[ROOT_PAGETABLE_FIRST_XEN_SLOT],\n           slots * sizeof(l4_pgentry_t));\n\n    /* Install the per-domain mappings for this domain */\n    sl4e[shadow_l4_table_offset(PERDOMAIN_VIRT_START)] =\n        shadow_l4e_from_mfn(page_to_mfn(d->arch.perdomain_l3_pg),\n                            __PAGE_HYPERVISOR_RW);\n\n    if ( !shadow_mode_external(d) && !is_pv_32bit_domain(d) &&\n         !VM_ASSIST(d, m2p_strict) )\n    {\n        /* open coded zap_ro_mpt(mfn_x(sl4mfn)): */\n        sl4e[shadow_l4_table_offset(RO_MPT_VIRT_START)] = shadow_l4e_empty();\n    }\n\n    /*\n     * Linear mapping slots:\n     *\n     * Calling this function with gl4mfn == sl4mfn is used to construct a\n     * monitor table for translated domains.  In this case, gl4mfn forms the\n     * self-linear mapping (i.e. not pointing into the translated domain), and\n     * the shadow-linear slot is skipped.  The shadow-linear slot is either\n     * filled when constructing lower level monitor tables, or via\n     * sh_update_cr3() for 4-level guests.\n     *\n     * Calling this function with gl4mfn != sl4mfn is used for non-translated\n     * guests, where the shadow-linear slot is actually self-linear, and the\n     * guest-linear slot points into the guests view of its pagetables.\n     */\n    if ( shadow_mode_translate(d) )\n    {\n        ASSERT(mfn_eq(gl4mfn, sl4mfn));\n\n        sl4e[shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START)] =\n            shadow_l4e_empty();\n    }\n    else\n    {\n        ASSERT(!mfn_eq(gl4mfn, sl4mfn));\n\n        sl4e[shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START)] =\n            shadow_l4e_from_mfn(sl4mfn, __PAGE_HYPERVISOR_RW);\n    }\n\n    sl4e[shadow_l4_table_offset(LINEAR_PT_VIRT_START)] =\n        shadow_l4e_from_mfn(gl4mfn, __PAGE_HYPERVISOR_RW);\n\n    unmap_domain_page(sl4e);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,25 +26,37 @@\n         sl4e[shadow_l4_table_offset(RO_MPT_VIRT_START)] = shadow_l4e_empty();\n     }\n \n-    /* Shadow linear mapping for 4-level shadows.  N.B. for 3-level\n-     * shadows on 64-bit xen, this linear mapping is later replaced by the\n-     * monitor pagetable structure, which is built in make_monitor_table\n-     * and maintained by sh_update_linear_entries. */\n-    sl4e[shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START)] =\n-        shadow_l4e_from_mfn(sl4mfn, __PAGE_HYPERVISOR_RW);\n+    /*\n+     * Linear mapping slots:\n+     *\n+     * Calling this function with gl4mfn == sl4mfn is used to construct a\n+     * monitor table for translated domains.  In this case, gl4mfn forms the\n+     * self-linear mapping (i.e. not pointing into the translated domain), and\n+     * the shadow-linear slot is skipped.  The shadow-linear slot is either\n+     * filled when constructing lower level monitor tables, or via\n+     * sh_update_cr3() for 4-level guests.\n+     *\n+     * Calling this function with gl4mfn != sl4mfn is used for non-translated\n+     * guests, where the shadow-linear slot is actually self-linear, and the\n+     * guest-linear slot points into the guests view of its pagetables.\n+     */\n+    if ( shadow_mode_translate(d) )\n+    {\n+        ASSERT(mfn_eq(gl4mfn, sl4mfn));\n \n-    /* Self linear mapping.  */\n-    if ( shadow_mode_translate(d) && !shadow_mode_external(d) )\n-    {\n-        // linear tables may not be used with translated PV guests\n-        sl4e[shadow_l4_table_offset(LINEAR_PT_VIRT_START)] =\n+        sl4e[shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START)] =\n             shadow_l4e_empty();\n     }\n     else\n     {\n-        sl4e[shadow_l4_table_offset(LINEAR_PT_VIRT_START)] =\n-            shadow_l4e_from_mfn(gl4mfn, __PAGE_HYPERVISOR_RW);\n+        ASSERT(!mfn_eq(gl4mfn, sl4mfn));\n+\n+        sl4e[shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START)] =\n+            shadow_l4e_from_mfn(sl4mfn, __PAGE_HYPERVISOR_RW);\n     }\n+\n+    sl4e[shadow_l4_table_offset(LINEAR_PT_VIRT_START)] =\n+        shadow_l4e_from_mfn(gl4mfn, __PAGE_HYPERVISOR_RW);\n \n     unmap_domain_page(sl4e);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    /* Shadow linear mapping for 4-level shadows.  N.B. for 3-level",
                "     * shadows on 64-bit xen, this linear mapping is later replaced by the",
                "     * monitor pagetable structure, which is built in make_monitor_table",
                "     * and maintained by sh_update_linear_entries. */",
                "    sl4e[shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START)] =",
                "        shadow_l4e_from_mfn(sl4mfn, __PAGE_HYPERVISOR_RW);",
                "    /* Self linear mapping.  */",
                "    if ( shadow_mode_translate(d) && !shadow_mode_external(d) )",
                "    {",
                "        // linear tables may not be used with translated PV guests",
                "        sl4e[shadow_l4_table_offset(LINEAR_PT_VIRT_START)] =",
                "        sl4e[shadow_l4_table_offset(LINEAR_PT_VIRT_START)] =",
                "            shadow_l4e_from_mfn(gl4mfn, __PAGE_HYPERVISOR_RW);"
            ],
            "added_lines": [
                "    /*",
                "     * Linear mapping slots:",
                "     *",
                "     * Calling this function with gl4mfn == sl4mfn is used to construct a",
                "     * monitor table for translated domains.  In this case, gl4mfn forms the",
                "     * self-linear mapping (i.e. not pointing into the translated domain), and",
                "     * the shadow-linear slot is skipped.  The shadow-linear slot is either",
                "     * filled when constructing lower level monitor tables, or via",
                "     * sh_update_cr3() for 4-level guests.",
                "     *",
                "     * Calling this function with gl4mfn != sl4mfn is used for non-translated",
                "     * guests, where the shadow-linear slot is actually self-linear, and the",
                "     * guest-linear slot points into the guests view of its pagetables.",
                "     */",
                "    if ( shadow_mode_translate(d) )",
                "    {",
                "        ASSERT(mfn_eq(gl4mfn, sl4mfn));",
                "        sl4e[shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START)] =",
                "        ASSERT(!mfn_eq(gl4mfn, sl4mfn));",
                "",
                "        sl4e[shadow_l4_table_offset(SH_LINEAR_PT_VIRT_START)] =",
                "            shadow_l4e_from_mfn(sl4mfn, __PAGE_HYPERVISOR_RW);",
                "",
                "    sl4e[shadow_l4_table_offset(LINEAR_PT_VIRT_START)] =",
                "        shadow_l4e_from_mfn(gl4mfn, __PAGE_HYPERVISOR_RW);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-39212",
        "func_name": "ImageMagick/OpenModule",
        "description": "ImageMagick is free software delivered as a ready-to-run binary distribution or as source code that you may use, copy, modify, and distribute in both open and proprietary applications. In affected versions and in certain cases, Postscript files could be read and written when specifically excluded by a `module` policy in `policy.xml`. ex. <policy domain=\"module\" rights=\"none\" pattern=\"PS\" />. The issue has been resolved in ImageMagick 7.1.0-7 and in 6.9.12-22. Fortunately, in the wild, few users utilize the `module` policy and instead use the `coder` policy that is also our workaround recommendation: <policy domain=\"coder\" rights=\"none\" pattern=\"{PS,EPI,EPS,EPSF,EPSI}\" />.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/01faddbe2711a4156180c4a92837e2f23683cc68",
        "commit_title": "Use the correct rights.",
        "commit_text": "",
        "func_before": "MagickPrivate MagickBooleanType OpenModule(const char *module,\n  ExceptionInfo *exception)\n{\n  char\n    module_name[MagickPathExtent],\n    name[MagickPathExtent],\n    path[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  ModuleHandle\n    handle;\n\n  ModuleInfo\n    *module_info;\n\n  PolicyRights\n    rights;\n\n  const CoderInfo\n    *p;\n\n  size_t\n    signature;\n\n  /*\n    Assign module name from alias.\n  */\n  assert(module != (const char *) NULL);\n  module_info=(ModuleInfo *) GetModuleInfo(module,exception);\n  if (module_info != (ModuleInfo *) NULL)\n    return(MagickTrue);\n  (void) CopyMagickString(module_name,module,MagickPathExtent);\n  p=GetCoderInfo(module,exception);\n  if (p != (CoderInfo *) NULL)\n    (void) CopyMagickString(module_name,p->name,MagickPathExtent);\n  rights=AllPolicyRights;\n  if (IsRightsAuthorized(ModulePolicyDomain,rights,module_name) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",module);\n      return(MagickFalse);\n    }\n  if (GetValueFromSplayTree(module_list,module_name) != (void *) NULL)\n    return(MagickTrue);  /* module already opened, return */\n  /*\n    Locate module.\n  */\n  handle=(ModuleHandle) NULL;\n  TagToCoderModuleName(module_name,name);\n  (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n    \"Searching for module \\\"%s\\\" using filename \\\"%s\\\"\",module_name,name);\n  *path='\\0';\n  status=GetMagickModulePath(name,MagickImageCoderModule,path,exception);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  /*\n    Load module\n  */\n  (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n    \"Opening module at path \\\"%s\\\"\",path);\n  handle=(ModuleHandle) lt_dlopen(path);\n  if (handle == (ModuleHandle) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n        \"UnableToLoadModule\",\"'%s': %s\",path,lt_dlerror());\n      return(MagickFalse);\n    }\n  /*\n    Register module.\n  */\n  module_info=AcquireModuleInfo(path,module_name);\n  module_info->handle=handle;\n  if (RegisterModule(module_info,exception) == (ModuleInfo *) NULL)\n    return(MagickFalse);\n  /*\n    Define RegisterFORMATImage method.\n  */\n  TagToModuleName(module_name,\"Register%sImage\",name);\n  module_info->register_module=(size_t (*)(void)) lt_dlsym(handle,name);\n  if (module_info->register_module == (size_t (*)(void)) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n        \"UnableToRegisterImageFormat\",\"'%s': %s\",module_name,lt_dlerror());\n      return(MagickFalse);\n    }\n  (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n    \"Method \\\"%s\\\" in module \\\"%s\\\" at address %p\",name,module_name,\n    (void *) module_info->register_module);\n  /*\n    Define UnregisterFORMATImage method.\n  */\n  TagToModuleName(module_name,\"Unregister%sImage\",name);\n  module_info->unregister_module=(void (*)(void)) lt_dlsym(handle,name);\n  if (module_info->unregister_module == (void (*)(void)) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n        \"UnableToRegisterImageFormat\",\"'%s': %s\",module_name,lt_dlerror());\n      return(MagickFalse);\n    }\n  (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n    \"Method \\\"%s\\\" in module \\\"%s\\\" at address %p\",name,module_name,\n    (void *) module_info->unregister_module);\n  signature=module_info->register_module();\n  if (signature != MagickImageCoderSignature)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n        \"ImageCoderSignatureMismatch\",\"'%s': %8lx != %8lx\",module_name,\n        (unsigned long) signature,(unsigned long) MagickImageCoderSignature);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}",
        "func": "MagickPrivate MagickBooleanType OpenModule(const char *module,\n  ExceptionInfo *exception)\n{\n  char\n    module_name[MagickPathExtent],\n    name[MagickPathExtent],\n    path[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  ModuleHandle\n    handle;\n\n  ModuleInfo\n    *module_info;\n\n  PolicyRights\n    rights;\n\n  const CoderInfo\n    *p;\n\n  size_t\n    signature;\n\n  /*\n    Assign module name from alias.\n  */\n  assert(module != (const char *) NULL);\n  module_info=(ModuleInfo *) GetModuleInfo(module,exception);\n  if (module_info != (ModuleInfo *) NULL)\n    return(MagickTrue);\n  (void) CopyMagickString(module_name,module,MagickPathExtent);\n  p=GetCoderInfo(module,exception);\n  if (p != (CoderInfo *) NULL)\n    (void) CopyMagickString(module_name,p->name,MagickPathExtent);\n  rights=ReadPolicyRights|WritePolicyRights;\n  if (IsRightsAuthorized(ModulePolicyDomain,rights,module_name) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",module);\n      return(MagickFalse);\n    }\n  if (GetValueFromSplayTree(module_list,module_name) != (void *) NULL)\n    return(MagickTrue);  /* module already opened, return */\n  /*\n    Locate module.\n  */\n  handle=(ModuleHandle) NULL;\n  TagToCoderModuleName(module_name,name);\n  (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n    \"Searching for module \\\"%s\\\" using filename \\\"%s\\\"\",module_name,name);\n  *path='\\0';\n  status=GetMagickModulePath(name,MagickImageCoderModule,path,exception);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  /*\n    Load module\n  */\n  (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n    \"Opening module at path \\\"%s\\\"\",path);\n  handle=(ModuleHandle) lt_dlopen(path);\n  if (handle == (ModuleHandle) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n        \"UnableToLoadModule\",\"'%s': %s\",path,lt_dlerror());\n      return(MagickFalse);\n    }\n  /*\n    Register module.\n  */\n  module_info=AcquireModuleInfo(path,module_name);\n  module_info->handle=handle;\n  if (RegisterModule(module_info,exception) == (ModuleInfo *) NULL)\n    return(MagickFalse);\n  /*\n    Define RegisterFORMATImage method.\n  */\n  TagToModuleName(module_name,\"Register%sImage\",name);\n  module_info->register_module=(size_t (*)(void)) lt_dlsym(handle,name);\n  if (module_info->register_module == (size_t (*)(void)) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n        \"UnableToRegisterImageFormat\",\"'%s': %s\",module_name,lt_dlerror());\n      return(MagickFalse);\n    }\n  (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n    \"Method \\\"%s\\\" in module \\\"%s\\\" at address %p\",name,module_name,\n    (void *) module_info->register_module);\n  /*\n    Define UnregisterFORMATImage method.\n  */\n  TagToModuleName(module_name,\"Unregister%sImage\",name);\n  module_info->unregister_module=(void (*)(void)) lt_dlsym(handle,name);\n  if (module_info->unregister_module == (void (*)(void)) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n        \"UnableToRegisterImageFormat\",\"'%s': %s\",module_name,lt_dlerror());\n      return(MagickFalse);\n    }\n  (void) LogMagickEvent(ModuleEvent,GetMagickModule(),\n    \"Method \\\"%s\\\" in module \\\"%s\\\" at address %p\",name,module_name,\n    (void *) module_info->unregister_module);\n  signature=module_info->register_module();\n  if (signature != MagickImageCoderSignature)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ModuleError,\n        \"ImageCoderSignatureMismatch\",\"'%s': %8lx != %8lx\",module_name,\n        (unsigned long) signature,(unsigned long) MagickImageCoderSignature);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -35,7 +35,7 @@\n   p=GetCoderInfo(module,exception);\n   if (p != (CoderInfo *) NULL)\n     (void) CopyMagickString(module_name,p->name,MagickPathExtent);\n-  rights=AllPolicyRights;\n+  rights=ReadPolicyRights|WritePolicyRights;\n   if (IsRightsAuthorized(ModulePolicyDomain,rights,module_name) == MagickFalse)\n     {\n       errno=EPERM;",
        "diff_line_info": {
            "deleted_lines": [
                "  rights=AllPolicyRights;"
            ],
            "added_lines": [
                "  rights=ReadPolicyRights|WritePolicyRights;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-39212",
        "func_name": "ImageMagick/RegisterStaticModule",
        "description": "ImageMagick is free software delivered as a ready-to-run binary distribution or as source code that you may use, copy, modify, and distribute in both open and proprietary applications. In affected versions and in certain cases, Postscript files could be read and written when specifically excluded by a `module` policy in `policy.xml`. ex. <policy domain=\"module\" rights=\"none\" pattern=\"PS\" />. The issue has been resolved in ImageMagick 7.1.0-7 and in 6.9.12-22. Fortunately, in the wild, few users utilize the `module` policy and instead use the `coder` policy that is also our workaround recommendation: <policy domain=\"coder\" rights=\"none\" pattern=\"{PS,EPI,EPS,EPSF,EPSI}\" />.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/01faddbe2711a4156180c4a92837e2f23683cc68",
        "commit_title": "Use the correct rights.",
        "commit_text": "",
        "func_before": "MagickExport MagickBooleanType RegisterStaticModule(const char *module,\n  ExceptionInfo *exception)\n{\n  char\n    module_name[MagickPathExtent];\n\n  PolicyRights\n    rights;\n\n  const CoderInfo\n    *p;\n\n  size_t\n    extent;\n\n  ssize_t\n    i;\n\n  /*\n    Assign module name from alias.\n  */\n  assert(module != (const char *) NULL);\n  (void) CopyMagickString(module_name,module,MagickPathExtent);\n  p=GetCoderInfo(module,exception);\n  if (p != (CoderInfo *) NULL)\n    (void) CopyMagickString(module_name,p->name,MagickPathExtent);\n  rights=AllPolicyRights;\n  if (IsRightsAuthorized(ModulePolicyDomain,rights,module_name) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",module);\n      return(MagickFalse);\n    }\n  extent=sizeof(MagickModules)/sizeof(MagickModules[0]);\n  for (i=0; i < (ssize_t) extent; i++)\n    if (LocaleCompare(MagickModules[i].module,module_name) == 0)\n      {\n        if (MagickModules[i].registered == MagickFalse)\n          {\n            (void) (MagickModules[i].register_module)();\n            MagickModules[i].registered=MagickTrue;\n          }\n        return(MagickTrue);\n      }\n  return(MagickFalse);\n}",
        "func": "MagickExport MagickBooleanType RegisterStaticModule(const char *module,\n  ExceptionInfo *exception)\n{\n  char\n    module_name[MagickPathExtent];\n\n  PolicyRights\n    rights;\n\n  const CoderInfo\n    *p;\n\n  size_t\n    extent;\n\n  ssize_t\n    i;\n\n  /*\n    Assign module name from alias.\n  */\n  assert(module != (const char *) NULL);\n  (void) CopyMagickString(module_name,module,MagickPathExtent);\n  p=GetCoderInfo(module,exception);\n  if (p != (CoderInfo *) NULL)\n    (void) CopyMagickString(module_name,p->name,MagickPathExtent);\n  rights=ReadPolicyRights|WritePolicyRights;\n  if (IsRightsAuthorized(ModulePolicyDomain,rights,module_name) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",module);\n      return(MagickFalse);\n    }\n  extent=sizeof(MagickModules)/sizeof(MagickModules[0]);\n  for (i=0; i < (ssize_t) extent; i++)\n    if (LocaleCompare(MagickModules[i].module,module_name) == 0)\n      {\n        if (MagickModules[i].registered == MagickFalse)\n          {\n            (void) (MagickModules[i].register_module)();\n            MagickModules[i].registered=MagickTrue;\n          }\n        return(MagickTrue);\n      }\n  return(MagickFalse);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,7 +24,7 @@\n   p=GetCoderInfo(module,exception);\n   if (p != (CoderInfo *) NULL)\n     (void) CopyMagickString(module_name,p->name,MagickPathExtent);\n-  rights=AllPolicyRights;\n+  rights=ReadPolicyRights|WritePolicyRights;\n   if (IsRightsAuthorized(ModulePolicyDomain,rights,module_name) == MagickFalse)\n     {\n       errno=EPERM;",
        "diff_line_info": {
            "deleted_lines": [
                "  rights=AllPolicyRights;"
            ],
            "added_lines": [
                "  rights=ReadPolicyRights|WritePolicyRights;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-39212",
        "func_name": "ImageMagick/RegisterStaticModules",
        "description": "ImageMagick is free software delivered as a ready-to-run binary distribution or as source code that you may use, copy, modify, and distribute in both open and proprietary applications. In affected versions and in certain cases, Postscript files could be read and written when specifically excluded by a `module` policy in `policy.xml`. ex. <policy domain=\"module\" rights=\"none\" pattern=\"PS\" />. The issue has been resolved in ImageMagick 7.1.0-7 and in 6.9.12-22. Fortunately, in the wild, few users utilize the `module` policy and instead use the `coder` policy that is also our workaround recommendation: <policy domain=\"coder\" rights=\"none\" pattern=\"{PS,EPI,EPS,EPSF,EPSI}\" />.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/01faddbe2711a4156180c4a92837e2f23683cc68",
        "commit_title": "Use the correct rights.",
        "commit_text": "",
        "func_before": "MagickExport void RegisterStaticModules(void)\n{\n  size_t\n    extent;\n\n  ssize_t\n    i;\n\n  extent=sizeof(MagickModules)/sizeof(MagickModules[0]);\n  for (i=0; i < (ssize_t) extent; i++)\n  {\n    if (MagickModules[i].registered == MagickFalse)\n      {\n        if (IsRightsAuthorized(ModulePolicyDomain,AllPolicyRights,\n              MagickModules[i].module) == MagickFalse)\n          continue;\n        (void) (MagickModules[i].register_module)();\n        MagickModules[i].registered=MagickTrue;\n      }\n  }\n}",
        "func": "MagickExport void RegisterStaticModules(void)\n{\n  PolicyRights\n    rights;\n\n  size_t\n    extent;\n\n  ssize_t\n    i;\n\n  rights=ReadPolicyRights|WritePolicyRights;\n  extent=sizeof(MagickModules)/sizeof(MagickModules[0]);\n  for (i=0; i < (ssize_t) extent; i++)\n  {\n    if (MagickModules[i].registered == MagickFalse)\n      {\n        if (IsRightsAuthorized(ModulePolicyDomain,rights,\n              MagickModules[i].module) == MagickFalse)\n          continue;\n        (void) (MagickModules[i].register_module)();\n        MagickModules[i].registered=MagickTrue;\n      }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,17 +1,21 @@\n MagickExport void RegisterStaticModules(void)\n {\n+  PolicyRights\n+    rights;\n+\n   size_t\n     extent;\n \n   ssize_t\n     i;\n \n+  rights=ReadPolicyRights|WritePolicyRights;\n   extent=sizeof(MagickModules)/sizeof(MagickModules[0]);\n   for (i=0; i < (ssize_t) extent; i++)\n   {\n     if (MagickModules[i].registered == MagickFalse)\n       {\n-        if (IsRightsAuthorized(ModulePolicyDomain,AllPolicyRights,\n+        if (IsRightsAuthorized(ModulePolicyDomain,rights,\n               MagickModules[i].module) == MagickFalse)\n           continue;\n         (void) (MagickModules[i].register_module)();",
        "diff_line_info": {
            "deleted_lines": [
                "        if (IsRightsAuthorized(ModulePolicyDomain,AllPolicyRights,"
            ],
            "added_lines": [
                "  PolicyRights",
                "    rights;",
                "",
                "  rights=ReadPolicyRights|WritePolicyRights;",
                "        if (IsRightsAuthorized(ModulePolicyDomain,rights,"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-39212",
        "func_name": "ImageMagick/RegisterStaticModule",
        "description": "ImageMagick is free software delivered as a ready-to-run binary distribution or as source code that you may use, copy, modify, and distribute in both open and proprietary applications. In affected versions and in certain cases, Postscript files could be read and written when specifically excluded by a `module` policy in `policy.xml`. ex. <policy domain=\"module\" rights=\"none\" pattern=\"PS\" />. The issue has been resolved in ImageMagick 7.1.0-7 and in 6.9.12-22. Fortunately, in the wild, few users utilize the `module` policy and instead use the `coder` policy that is also our workaround recommendation: <policy domain=\"coder\" rights=\"none\" pattern=\"{PS,EPI,EPS,EPSF,EPSI}\" />.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/35893e7cad78ce461fcaffa56076c11700ba5e4e",
        "commit_title": "Added missing policy checks in RegisterStaticModules.",
        "commit_text": "",
        "func_before": "MagickExport MagickBooleanType RegisterStaticModule(const char *module,\n  ExceptionInfo *exception)\n{\n  char\n    module_name[MagickPathExtent];\n\n  PolicyRights\n    rights;\n\n  const CoderInfo\n    *p;\n\n  size_t\n    extent;\n\n  ssize_t\n    i;\n\n  /*\n    Assign module name from alias.\n  */\n  assert(module != (const char *) NULL);\n  (void) CopyMagickString(module_name,module,MagickPathExtent);\n  p=GetCoderInfo(module,exception);\n  if (p != (CoderInfo *) NULL)\n    (void) CopyMagickString(module_name,p->name,MagickPathExtent);\n  rights=ReadPolicyRights;\n  if (IsRightsAuthorized(ModulePolicyDomain,rights,module_name) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",module);\n      return(MagickFalse);\n    }\n  extent=sizeof(MagickModules)/sizeof(MagickModules[0]);\n  for (i=0; i < (ssize_t) extent; i++)\n    if (LocaleCompare(MagickModules[i].module,module_name) == 0)\n      {\n        if (MagickModules[i].registered == MagickFalse)\n          {\n            (void) (MagickModules[i].register_module)();\n            MagickModules[i].registered=MagickTrue;\n          }\n        return(MagickTrue);\n      }\n  return(MagickFalse);\n}",
        "func": "MagickExport MagickBooleanType RegisterStaticModule(const char *module,\n  ExceptionInfo *exception)\n{\n  char\n    module_name[MagickPathExtent];\n\n  PolicyRights\n    rights;\n\n  const CoderInfo\n    *p;\n\n  size_t\n    extent;\n\n  ssize_t\n    i;\n\n  /*\n    Assign module name from alias.\n  */\n  assert(module != (const char *) NULL);\n  (void) CopyMagickString(module_name,module,MagickPathExtent);\n  p=GetCoderInfo(module,exception);\n  if (p != (CoderInfo *) NULL)\n    (void) CopyMagickString(module_name,p->name,MagickPathExtent);\n  rights=AllPolicyRights;\n  if (IsRightsAuthorized(ModulePolicyDomain,rights,module_name) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",module);\n      return(MagickFalse);\n    }\n  extent=sizeof(MagickModules)/sizeof(MagickModules[0]);\n  for (i=0; i < (ssize_t) extent; i++)\n    if (LocaleCompare(MagickModules[i].module,module_name) == 0)\n      {\n        if (MagickModules[i].registered == MagickFalse)\n          {\n            (void) (MagickModules[i].register_module)();\n            MagickModules[i].registered=MagickTrue;\n          }\n        return(MagickTrue);\n      }\n  return(MagickFalse);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,7 +24,7 @@\n   p=GetCoderInfo(module,exception);\n   if (p != (CoderInfo *) NULL)\n     (void) CopyMagickString(module_name,p->name,MagickPathExtent);\n-  rights=ReadPolicyRights;\n+  rights=AllPolicyRights;\n   if (IsRightsAuthorized(ModulePolicyDomain,rights,module_name) == MagickFalse)\n     {\n       errno=EPERM;",
        "diff_line_info": {
            "deleted_lines": [
                "  rights=ReadPolicyRights;"
            ],
            "added_lines": [
                "  rights=AllPolicyRights;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-39212",
        "func_name": "ImageMagick/RegisterStaticModules",
        "description": "ImageMagick is free software delivered as a ready-to-run binary distribution or as source code that you may use, copy, modify, and distribute in both open and proprietary applications. In affected versions and in certain cases, Postscript files could be read and written when specifically excluded by a `module` policy in `policy.xml`. ex. <policy domain=\"module\" rights=\"none\" pattern=\"PS\" />. The issue has been resolved in ImageMagick 7.1.0-7 and in 6.9.12-22. Fortunately, in the wild, few users utilize the `module` policy and instead use the `coder` policy that is also our workaround recommendation: <policy domain=\"coder\" rights=\"none\" pattern=\"{PS,EPI,EPS,EPSF,EPSI}\" />.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/35893e7cad78ce461fcaffa56076c11700ba5e4e",
        "commit_title": "Added missing policy checks in RegisterStaticModules.",
        "commit_text": "",
        "func_before": "MagickExport void RegisterStaticModules(void)\n{\n  size_t\n    extent;\n\n  ssize_t\n    i;\n\n  extent=sizeof(MagickModules)/sizeof(MagickModules[0]);\n  for (i=0; i < (ssize_t) extent; i++)\n  {\n    if (MagickModules[i].registered == MagickFalse)\n      {\n        (void) (MagickModules[i].register_module)();\n        MagickModules[i].registered=MagickTrue;\n      }\n  }\n}",
        "func": "MagickExport void RegisterStaticModules(void)\n{\n  size_t\n    extent;\n\n  ssize_t\n    i;\n\n  extent=sizeof(MagickModules)/sizeof(MagickModules[0]);\n  for (i=0; i < (ssize_t) extent; i++)\n  {\n    if (MagickModules[i].registered == MagickFalse)\n      {\n        if (IsRightsAuthorized(ModulePolicyDomain,AllPolicyRights,\n              MagickModules[i].module) == MagickFalse)\n          continue;\n        (void) (MagickModules[i].register_module)();\n        MagickModules[i].registered=MagickTrue;\n      }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,6 +11,9 @@\n   {\n     if (MagickModules[i].registered == MagickFalse)\n       {\n+        if (IsRightsAuthorized(ModulePolicyDomain,AllPolicyRights,\n+              MagickModules[i].module) == MagickFalse)\n+          continue;\n         (void) (MagickModules[i].register_module)();\n         MagickModules[i].registered=MagickTrue;\n       }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (IsRightsAuthorized(ModulePolicyDomain,AllPolicyRights,",
                "              MagickModules[i].module) == MagickFalse)",
                "          continue;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-48198",
        "func_name": "vooon/ntpd_driver/main",
        "description": "The ntpd_driver component before 1.3.0 and 2.x before 2.2.0 for Robot Operating System (ROS) allows attackers, who control the source code of a different node in the same ROS application, to change a robot's behavior. This occurs because a topic name depends on the attacker-controlled time_ref_topic parameter.",
        "git_url": "https://github.com/vooon/ntpd_driver/commit/063eb917c88f8a965d4988501a4ff54441440c42",
        "commit_title": "shm_driver: remove time_ref topic parameter to improve secutiry, please use remap",
        "commit_text": " Fixes #9",
        "func_before": "int main(int argc, char *argv[])\n{\n  ros::init(argc, argv, \"ntpd_shm\");\n\n  ros::NodeHandle nh(\"~\");\n  ros::Subscriber time_ref_sub;\n\n  int shm_unit;\n  std::string time_ref_topic;\n\n  // Override default ROS handler\n  signal(SIGINT, sig_handler);\n\n  // Read Parameters\n  nh.param(\"shm_unit\", shm_unit, 2);\n  nh.param(\"fixup_date\", g_set_date, false);\n  nh.param<std::string>(\"time_ref_topic\", time_ref_topic, \"time_ref\");\n\n  // Report settings\n  ROS_INFO_STREAM(\"NTP time source: \" << ros::names::resolve(time_ref_topic, true));\n  ROS_INFO_STREAM(\"NTP date fixup: \" << ((g_set_date) ? \"enabled\" : \"disabled\"));\n\n  g_shm = get_shmTime(shm_unit);\n  if (g_shm == NULL)\n    return 1;\n\n  // prefer to unreliable connection, but accept tcp too.\n  time_ref_sub = nh.subscribe(time_ref_topic, 10, time_ref_cb,\n      ros::TransportHints()\n      .unreliable().maxDatagramSize(1024)\n      .reliable().tcpNoDelay(true));\n\n  ros::spin();\n  put_shmTime(&g_shm);\n  return 0;\n}",
        "func": "int main(int argc, char *argv[])\n{\n  ros::init(argc, argv, \"ntpd_shm\");\n\n  ros::NodeHandle nh(\"~\");\n  ros::Subscriber time_ref_sub;\n\n  int shm_unit;\n\n  // Override default ROS handler\n  signal(SIGINT, sig_handler);\n\n  // Read Parameters\n  nh.param(\"shm_unit\", shm_unit, 2);\n  nh.param(\"fixup_date\", g_set_date, false);\n\n  // Report settings\n  ROS_INFO_STREAM(\"NTP date fixup: \" << ((g_set_date) ? \"enabled\" : \"disabled\"));\n\n  g_shm = get_shmTime(shm_unit);\n  if (g_shm == NULL)\n    return 1;\n\n  // prefer to unreliable connection, but accept tcp too.\n  time_ref_sub = nh.subscribe(\"time_ref\", 10, time_ref_cb,\n      ros::TransportHints()\n      .unreliable().maxDatagramSize(1024)\n      .reliable().tcpNoDelay(true));\n\n  ros::spin();\n  put_shmTime(&g_shm);\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,6 @@\n   ros::Subscriber time_ref_sub;\n \n   int shm_unit;\n-  std::string time_ref_topic;\n \n   // Override default ROS handler\n   signal(SIGINT, sig_handler);\n@@ -14,10 +13,8 @@\n   // Read Parameters\n   nh.param(\"shm_unit\", shm_unit, 2);\n   nh.param(\"fixup_date\", g_set_date, false);\n-  nh.param<std::string>(\"time_ref_topic\", time_ref_topic, \"time_ref\");\n \n   // Report settings\n-  ROS_INFO_STREAM(\"NTP time source: \" << ros::names::resolve(time_ref_topic, true));\n   ROS_INFO_STREAM(\"NTP date fixup: \" << ((g_set_date) ? \"enabled\" : \"disabled\"));\n \n   g_shm = get_shmTime(shm_unit);\n@@ -25,7 +22,7 @@\n     return 1;\n \n   // prefer to unreliable connection, but accept tcp too.\n-  time_ref_sub = nh.subscribe(time_ref_topic, 10, time_ref_cb,\n+  time_ref_sub = nh.subscribe(\"time_ref\", 10, time_ref_cb,\n       ros::TransportHints()\n       .unreliable().maxDatagramSize(1024)\n       .reliable().tcpNoDelay(true));",
        "diff_line_info": {
            "deleted_lines": [
                "  std::string time_ref_topic;",
                "  nh.param<std::string>(\"time_ref_topic\", time_ref_topic, \"time_ref\");",
                "  ROS_INFO_STREAM(\"NTP time source: \" << ros::names::resolve(time_ref_topic, true));",
                "  time_ref_sub = nh.subscribe(time_ref_topic, 10, time_ref_cb,"
            ],
            "added_lines": [
                "  time_ref_sub = nh.subscribe(\"time_ref\", 10, time_ref_cb,"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-25643",
        "func_name": "kennylevinsen/seatd/main",
        "description": "seatd-launch in seatd 0.6.x before 0.6.4 allows removing files with escalated privileges when installed setuid root. The attack vector is a user-supplied socket pathname.",
        "git_url": "https://github.com/kennylevinsen/seatd/commit/10658dc5439db429af0088295a051c53925a4416",
        "commit_title": "seatd-launch: Remove socket path command line arg",
        "commit_text": " This should not need to be configured, so remove the argument. If downstream prefers a different folder, the location can be made compile-time configurable like for seatd itself.",
        "func_before": "int main(int argc, char *argv[]) {\n\t(void)argc;\n\n\tconst char *usage = \"Usage: seatd-launch [options] [--] command\\n\"\n\t\t\t    \"\\n\"\n\t\t\t    \"  -h\t\tShow this help message\\n\"\n\t\t\t    \"  -s <path>\tWhere to create the seatd socket\\n\"\n\t\t\t    \"  -v\t\tShow the version number\\n\"\n\t\t\t    \"\\n\";\n\n\tint c;\n\tchar *sockpath = NULL;\n\twhile ((c = getopt(argc, argv, \"vhs:\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 's':\n\t\t\tsockpath = optarg;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tprintf(\"seatd-launch version %s\\n\", SEATD_VERSION);\n\t\t\treturn 0;\n\t\tcase 'h':\n\t\t\tprintf(\"%s\", usage);\n\t\t\treturn 0;\n\t\tcase '?':\n\t\t\tfprintf(stderr, \"Try '%s -h' for more information.\\n\", argv[0]);\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\tabort();\n\t\t}\n\t}\n\n\tif (optind >= argc) {\n\t\tfprintf(stderr, \"A command must be specified\\n\\n%s\", usage);\n\t\treturn 1;\n\t}\n\tchar **command = &argv[optind];\n\n\tchar sockbuf[256];\n\tif (sockpath == NULL) {\n\t\tsprintf(sockbuf, \"/tmp/seatd.%d.sock\", getpid());\n\t\tsockpath = sockbuf;\n\t}\n\n\tint fds[2];\n\tif (pipe(fds) == -1) {\n\t\tperror(\"Could not create pipe\");\n\t\tgoto error;\n\t}\n\n\tpid_t seatd_child = fork();\n\tif (seatd_child == -1) {\n\t\tperror(\"Could not fork seatd process\");\n\t\tgoto error;\n\t} else if (seatd_child == 0) {\n\t\tclose(fds[0]);\n\n\t\tchar pipebuf[16] = {0};\n\t\tsnprintf(pipebuf, sizeof pipebuf, \"%d\", fds[1]);\n\n\t\tchar *env[2] = {NULL, NULL};\n\t\tchar loglevelbuf[32] = {0};\n\t\tchar *cur_loglevel = getenv(\"SEATD_LOGLEVEL\");\n\t\tif (cur_loglevel != NULL) {\n\t\t\tsnprintf(loglevelbuf, sizeof loglevelbuf, \"SEATD_LOGLEVEL=%s\", cur_loglevel);\n\t\t\tenv[0] = loglevelbuf;\n\t\t}\n\n\t\tchar *command[] = {\"seatd\", \"-n\", pipebuf, \"-s\", sockpath, NULL};\n\t\texecve(SEATD_INSTALLPATH, command, env);\n\t\tperror(\"Could not start seatd\");\n\t\t_exit(1);\n\t}\n\tclose(fds[1]);\n\n\t// Wait for seatd to be ready\n\tchar buf[1] = {0};\n\twhile (true) {\n\t\tpid_t p = waitpid(seatd_child, NULL, WNOHANG);\n\t\tif (p == seatd_child) {\n\t\t\tfprintf(stderr, \"seatd exited prematurely\\n\");\n\t\t\tgoto error_seatd;\n\t\t} else if (p == -1 && (errno != EINTR && errno != ECHILD)) {\n\t\t\tperror(\"Could not wait for seatd process\");\n\t\t\tgoto error_seatd;\n\t\t}\n\n\t\tstruct pollfd fd = {\n\t\t\t.fd = fds[0],\n\t\t\t.events = POLLIN,\n\t\t};\n\n\t\t// We poll with timeout to avoid a racing on a blocking read\n\t\tif (poll(&fd, 1, 1000) == -1) {\n\t\t\tif (errno == EAGAIN || errno == EINTR) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tperror(\"Could not poll notification fd\");\n\t\t\t\tgoto error_seatd;\n\t\t\t}\n\t\t}\n\n\t\tif (fd.revents & POLLIN) {\n\t\t\tssize_t n = read(fds[0], buf, 1);\n\t\t\tif (n == -1 && errno != EINTR) {\n\t\t\t\tperror(\"Could not read from pipe\");\n\t\t\t\tgoto error_seatd;\n\t\t\t} else if (n > 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tclose(fds[0]);\n\n\tuid_t uid = getuid();\n\tgid_t gid = getgid();\n\n\t// Restrict access to the socket to just us\n\tif (chown(sockpath, uid, gid) == -1) {\n\t\tperror(\"Could not chown seatd socket\");\n\t\tgoto error_seatd;\n\t}\n\tif (chmod(sockpath, 0700) == -1) {\n\t\tperror(\"Could not chmod socket\");\n\t\tgoto error_seatd;\n\t}\n\n\t// Drop privileges\n\tif (setgid(gid) == -1) {\n\t\tperror(\"Could not set gid to drop privileges\");\n\t\tgoto error_seatd;\n\t}\n\tif (setuid(uid) == -1) {\n\t\tperror(\"Could not set uid to drop privileges\");\n\t\tgoto error_seatd;\n\t}\n\n\tpid_t child = fork();\n\tif (child == -1) {\n\t\tperror(\"Could not fork target process\");\n\t\tgoto error_seatd;\n\t} else if (child == 0) {\n\t\tsetenv(\"SEATD_SOCK\", sockpath, 1);\n\t\texecvp(command[0], command);\n\t\tperror(\"Could not start target\");\n\t\t_exit(1);\n\t}\n\n\tint status = 0;\n\twhile (true) {\n\t\tpid_t p = waitpid(child, &status, 0);\n\t\tif (p == child) {\n\t\t\tbreak;\n\t\t} else if (p == -1 && errno != EINTR) {\n\t\t\tperror(\"Could not wait for target process\");\n\t\t\tgoto error_seatd;\n\t\t}\n\t}\n\n\tif (kill(seatd_child, SIGTERM) != 0) {\n\t\tperror(\"Could not kill seatd\");\n\t}\n\n\tif (WIFEXITED(status)) {\n\t\treturn WEXITSTATUS(status);\n\t} else if (WIFSIGNALED(status)) {\n\t\treturn 128 + WTERMSIG(status);\n\t} else {\n\t\tabort(); // unreachable\n\t}\n\nerror_seatd:\n\tkill(seatd_child, SIGTERM);\nerror:\n\treturn 1;\n}",
        "func": "int main(int argc, char *argv[]) {\n\t(void)argc;\n\n\tconst char *usage = \"Usage: seatd-launch [options] [--] command\\n\"\n\t\t\t    \"\\n\"\n\t\t\t    \"  -h\tShow this help message\\n\"\n\t\t\t    \"  -v\tShow the version number\\n\"\n\t\t\t    \"\\n\";\n\n\tint c;\n\twhile ((c = getopt(argc, argv, \"vh\")) != -1) {\n\t\tswitch (c) {\n\t\tcase 'v':\n\t\t\tprintf(\"seatd-launch version %s\\n\", SEATD_VERSION);\n\t\t\treturn 0;\n\t\tcase 'h':\n\t\t\tprintf(\"%s\", usage);\n\t\t\treturn 0;\n\t\tcase '?':\n\t\t\tfprintf(stderr, \"Try '%s -h' for more information.\\n\", argv[0]);\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\tabort();\n\t\t}\n\t}\n\n\tif (optind >= argc) {\n\t\tfprintf(stderr, \"A command must be specified\\n\\n%s\", usage);\n\t\treturn 1;\n\t}\n\tchar **command = &argv[optind];\n\n\tchar sockpath[256];\n\tsprintf(sockpath, \"/tmp/seatd.%d.sock\", getpid());\n\n\tint fds[2];\n\tif (pipe(fds) == -1) {\n\t\tperror(\"Could not create pipe\");\n\t\tgoto error;\n\t}\n\n\tpid_t seatd_child = fork();\n\tif (seatd_child == -1) {\n\t\tperror(\"Could not fork seatd process\");\n\t\tgoto error;\n\t} else if (seatd_child == 0) {\n\t\tclose(fds[0]);\n\n\t\tchar pipebuf[16] = {0};\n\t\tsnprintf(pipebuf, sizeof pipebuf, \"%d\", fds[1]);\n\n\t\tchar *env[2] = {NULL, NULL};\n\t\tchar loglevelbuf[32] = {0};\n\t\tchar *cur_loglevel = getenv(\"SEATD_LOGLEVEL\");\n\t\tif (cur_loglevel != NULL) {\n\t\t\tsnprintf(loglevelbuf, sizeof loglevelbuf, \"SEATD_LOGLEVEL=%s\", cur_loglevel);\n\t\t\tenv[0] = loglevelbuf;\n\t\t}\n\n\t\tchar *command[] = {\"seatd\", \"-n\", pipebuf, \"-s\", sockpath, NULL};\n\t\texecve(SEATD_INSTALLPATH, command, env);\n\t\tperror(\"Could not start seatd\");\n\t\t_exit(1);\n\t}\n\tclose(fds[1]);\n\n\t// Wait for seatd to be ready\n\tchar buf[1] = {0};\n\twhile (true) {\n\t\tpid_t p = waitpid(seatd_child, NULL, WNOHANG);\n\t\tif (p == seatd_child) {\n\t\t\tfprintf(stderr, \"seatd exited prematurely\\n\");\n\t\t\tgoto error_seatd;\n\t\t} else if (p == -1 && (errno != EINTR && errno != ECHILD)) {\n\t\t\tperror(\"Could not wait for seatd process\");\n\t\t\tgoto error_seatd;\n\t\t}\n\n\t\tstruct pollfd fd = {\n\t\t\t.fd = fds[0],\n\t\t\t.events = POLLIN,\n\t\t};\n\n\t\t// We poll with timeout to avoid a racing on a blocking read\n\t\tif (poll(&fd, 1, 1000) == -1) {\n\t\t\tif (errno == EAGAIN || errno == EINTR) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tperror(\"Could not poll notification fd\");\n\t\t\t\tgoto error_seatd;\n\t\t\t}\n\t\t}\n\n\t\tif (fd.revents & POLLIN) {\n\t\t\tssize_t n = read(fds[0], buf, 1);\n\t\t\tif (n == -1 && errno != EINTR) {\n\t\t\t\tperror(\"Could not read from pipe\");\n\t\t\t\tgoto error_seatd;\n\t\t\t} else if (n > 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tclose(fds[0]);\n\n\tuid_t uid = getuid();\n\tgid_t gid = getgid();\n\n\t// Restrict access to the socket to just us\n\tif (chown(sockpath, uid, gid) == -1) {\n\t\tperror(\"Could not chown seatd socket\");\n\t\tgoto error_seatd;\n\t}\n\tif (chmod(sockpath, 0700) == -1) {\n\t\tperror(\"Could not chmod socket\");\n\t\tgoto error_seatd;\n\t}\n\n\t// Drop privileges\n\tif (setgid(gid) == -1) {\n\t\tperror(\"Could not set gid to drop privileges\");\n\t\tgoto error_seatd;\n\t}\n\tif (setuid(uid) == -1) {\n\t\tperror(\"Could not set uid to drop privileges\");\n\t\tgoto error_seatd;\n\t}\n\n\tpid_t child = fork();\n\tif (child == -1) {\n\t\tperror(\"Could not fork target process\");\n\t\tgoto error_seatd;\n\t} else if (child == 0) {\n\t\tsetenv(\"SEATD_SOCK\", sockpath, 1);\n\t\texecvp(command[0], command);\n\t\tperror(\"Could not start target\");\n\t\t_exit(1);\n\t}\n\n\tint status = 0;\n\twhile (true) {\n\t\tpid_t p = waitpid(child, &status, 0);\n\t\tif (p == child) {\n\t\t\tbreak;\n\t\t} else if (p == -1 && errno != EINTR) {\n\t\t\tperror(\"Could not wait for target process\");\n\t\t\tgoto error_seatd;\n\t\t}\n\t}\n\n\tif (kill(seatd_child, SIGTERM) != 0) {\n\t\tperror(\"Could not kill seatd\");\n\t}\n\n\tif (WIFEXITED(status)) {\n\t\treturn WEXITSTATUS(status);\n\t} else if (WIFSIGNALED(status)) {\n\t\treturn 128 + WTERMSIG(status);\n\t} else {\n\t\tabort(); // unreachable\n\t}\n\nerror_seatd:\n\tkill(seatd_child, SIGTERM);\nerror:\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,18 +3,13 @@\n \n \tconst char *usage = \"Usage: seatd-launch [options] [--] command\\n\"\n \t\t\t    \"\\n\"\n-\t\t\t    \"  -h\t\tShow this help message\\n\"\n-\t\t\t    \"  -s <path>\tWhere to create the seatd socket\\n\"\n-\t\t\t    \"  -v\t\tShow the version number\\n\"\n+\t\t\t    \"  -h\tShow this help message\\n\"\n+\t\t\t    \"  -v\tShow the version number\\n\"\n \t\t\t    \"\\n\";\n \n \tint c;\n-\tchar *sockpath = NULL;\n-\twhile ((c = getopt(argc, argv, \"vhs:\")) != -1) {\n+\twhile ((c = getopt(argc, argv, \"vh\")) != -1) {\n \t\tswitch (c) {\n-\t\tcase 's':\n-\t\t\tsockpath = optarg;\n-\t\t\tbreak;\n \t\tcase 'v':\n \t\t\tprintf(\"seatd-launch version %s\\n\", SEATD_VERSION);\n \t\t\treturn 0;\n@@ -35,11 +30,8 @@\n \t}\n \tchar **command = &argv[optind];\n \n-\tchar sockbuf[256];\n-\tif (sockpath == NULL) {\n-\t\tsprintf(sockbuf, \"/tmp/seatd.%d.sock\", getpid());\n-\t\tsockpath = sockbuf;\n-\t}\n+\tchar sockpath[256];\n+\tsprintf(sockpath, \"/tmp/seatd.%d.sock\", getpid());\n \n \tint fds[2];\n \tif (pipe(fds) == -1) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t    \"  -h\t\tShow this help message\\n\"",
                "\t\t\t    \"  -s <path>\tWhere to create the seatd socket\\n\"",
                "\t\t\t    \"  -v\t\tShow the version number\\n\"",
                "\tchar *sockpath = NULL;",
                "\twhile ((c = getopt(argc, argv, \"vhs:\")) != -1) {",
                "\t\tcase 's':",
                "\t\t\tsockpath = optarg;",
                "\t\t\tbreak;",
                "\tchar sockbuf[256];",
                "\tif (sockpath == NULL) {",
                "\t\tsprintf(sockbuf, \"/tmp/seatd.%d.sock\", getpid());",
                "\t\tsockpath = sockbuf;",
                "\t}"
            ],
            "added_lines": [
                "\t\t\t    \"  -h\tShow this help message\\n\"",
                "\t\t\t    \"  -v\tShow the version number\\n\"",
                "\twhile ((c = getopt(argc, argv, \"vh\")) != -1) {",
                "\tchar sockpath[256];",
                "\tsprintf(sockpath, \"/tmp/seatd.%d.sock\", getpid());"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-45145",
        "func_name": "redis/anetListen",
        "description": "Redis is an in-memory database that persists on disk. On startup, Redis begins listening on a Unix socket before adjusting its permissions to the user-provided configuration. If a permissive umask(2) is used, this creates a race condition that enables, during a short period of time, another process to establish an otherwise unauthorized connection. This problem has existed since Redis 2.6.0-RC1. This issue has been addressed in Redis versions 7.2.2, 7.0.14 and 6.2.14. Users are advised to upgrade. For users unable to upgrade, it is possible to work around the problem by disabling Unix sockets, starting Redis with a restrictive umask, or storing the Unix socket file in a protected directory.",
        "git_url": "https://github.com/redis/redis/commit/03345ddc7faf7af079485f2cbe5d17a1611cbce1",
        "commit_title": "Fix issue of listen before chmod on Unix sockets (CVE-2023-45145) (#12671)",
        "commit_text": " Before this commit, Unix socket setup performed chmod(2) on the socket\r file after calling listen(2). Depending on what umask is used, this\r could leave the file with the wrong permissions for a short period of\r time. As a result, another process could exploit this race condition and\r establish a connection that would otherwise not be possible.\r \r We now make sure the socket permissions are set up prior to calling\r listen(2).\r \r (cherry picked from commit 1119ecae6fd8796fa337df2212f09173ab6c7b0a)\r \r Co-authored-by: Yossi Gottlieb <yossigo@gmail.com>",
        "func_before": "static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog) {\n    if (bind(s,sa,len) == -1) {\n        anetSetError(err, \"bind: %s\", strerror(errno));\n        close(s);\n        return ANET_ERR;\n    }\n\n    if (listen(s, backlog) == -1) {\n        anetSetError(err, \"listen: %s\", strerror(errno));\n        close(s);\n        return ANET_ERR;\n    }\n    return ANET_OK;\n}",
        "func": "static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog, mode_t perm) {\n    if (bind(s,sa,len) == -1) {\n        anetSetError(err, \"bind: %s\", strerror(errno));\n        close(s);\n        return ANET_ERR;\n    }\n\n    if (sa->sa_family == AF_LOCAL && perm)\n        chmod(((struct sockaddr_un *) sa)->sun_path, perm);\n\n    if (listen(s, backlog) == -1) {\n        anetSetError(err, \"listen: %s\", strerror(errno));\n        close(s);\n        return ANET_ERR;\n    }\n    return ANET_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,9 +1,12 @@\n-static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog) {\n+static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog, mode_t perm) {\n     if (bind(s,sa,len) == -1) {\n         anetSetError(err, \"bind: %s\", strerror(errno));\n         close(s);\n         return ANET_ERR;\n     }\n+\n+    if (sa->sa_family == AF_LOCAL && perm)\n+        chmod(((struct sockaddr_un *) sa)->sun_path, perm);\n \n     if (listen(s, backlog) == -1) {\n         anetSetError(err, \"listen: %s\", strerror(errno));",
        "diff_line_info": {
            "deleted_lines": [
                "static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog) {"
            ],
            "added_lines": [
                "static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog, mode_t perm) {",
                "",
                "    if (sa->sa_family == AF_LOCAL && perm)",
                "        chmod(((struct sockaddr_un *) sa)->sun_path, perm);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-45145",
        "func_name": "redis/anetUnixServer",
        "description": "Redis is an in-memory database that persists on disk. On startup, Redis begins listening on a Unix socket before adjusting its permissions to the user-provided configuration. If a permissive umask(2) is used, this creates a race condition that enables, during a short period of time, another process to establish an otherwise unauthorized connection. This problem has existed since Redis 2.6.0-RC1. This issue has been addressed in Redis versions 7.2.2, 7.0.14 and 6.2.14. Users are advised to upgrade. For users unable to upgrade, it is possible to work around the problem by disabling Unix sockets, starting Redis with a restrictive umask, or storing the Unix socket file in a protected directory.",
        "git_url": "https://github.com/redis/redis/commit/03345ddc7faf7af079485f2cbe5d17a1611cbce1",
        "commit_title": "Fix issue of listen before chmod on Unix sockets (CVE-2023-45145) (#12671)",
        "commit_text": " Before this commit, Unix socket setup performed chmod(2) on the socket\r file after calling listen(2). Depending on what umask is used, this\r could leave the file with the wrong permissions for a short period of\r time. As a result, another process could exploit this race condition and\r establish a connection that would otherwise not be possible.\r \r We now make sure the socket permissions are set up prior to calling\r listen(2).\r \r (cherry picked from commit 1119ecae6fd8796fa337df2212f09173ab6c7b0a)\r \r Co-authored-by: Yossi Gottlieb <yossigo@gmail.com>",
        "func_before": "int anetUnixServer(char *err, char *path, mode_t perm, int backlog)\n{\n    int s;\n    struct sockaddr_un sa;\n\n    if (strlen(path) > sizeof(sa.sun_path)-1) {\n        anetSetError(err,\"unix socket path too long (%zu), must be under %zu\", strlen(path), sizeof(sa.sun_path));\n        return ANET_ERR;\n    }\n    if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR)\n        return ANET_ERR;\n\n    memset(&sa,0,sizeof(sa));\n    sa.sun_family = AF_LOCAL;\n    redis_strlcpy(sa.sun_path,path,sizeof(sa.sun_path));\n    if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog) == ANET_ERR)\n        return ANET_ERR;\n    if (perm)\n        chmod(sa.sun_path, perm);\n    return s;\n}",
        "func": "int anetUnixServer(char *err, char *path, mode_t perm, int backlog)\n{\n    int s;\n    struct sockaddr_un sa;\n\n    if (strlen(path) > sizeof(sa.sun_path)-1) {\n        anetSetError(err,\"unix socket path too long (%zu), must be under %zu\", strlen(path), sizeof(sa.sun_path));\n        return ANET_ERR;\n    }\n    if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR)\n        return ANET_ERR;\n\n    memset(&sa,0,sizeof(sa));\n    sa.sun_family = AF_LOCAL;\n    redis_strlcpy(sa.sun_path,path,sizeof(sa.sun_path));\n    if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog,perm) == ANET_ERR)\n        return ANET_ERR;\n    return s;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,9 +13,7 @@\n     memset(&sa,0,sizeof(sa));\n     sa.sun_family = AF_LOCAL;\n     redis_strlcpy(sa.sun_path,path,sizeof(sa.sun_path));\n-    if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog) == ANET_ERR)\n+    if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog,perm) == ANET_ERR)\n         return ANET_ERR;\n-    if (perm)\n-        chmod(sa.sun_path, perm);\n     return s;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog) == ANET_ERR)",
                "    if (perm)",
                "        chmod(sa.sun_path, perm);"
            ],
            "added_lines": [
                "    if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog,perm) == ANET_ERR)"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-45145",
        "func_name": "redis/_anetTcpServer",
        "description": "Redis is an in-memory database that persists on disk. On startup, Redis begins listening on a Unix socket before adjusting its permissions to the user-provided configuration. If a permissive umask(2) is used, this creates a race condition that enables, during a short period of time, another process to establish an otherwise unauthorized connection. This problem has existed since Redis 2.6.0-RC1. This issue has been addressed in Redis versions 7.2.2, 7.0.14 and 6.2.14. Users are advised to upgrade. For users unable to upgrade, it is possible to work around the problem by disabling Unix sockets, starting Redis with a restrictive umask, or storing the Unix socket file in a protected directory.",
        "git_url": "https://github.com/redis/redis/commit/03345ddc7faf7af079485f2cbe5d17a1611cbce1",
        "commit_title": "Fix issue of listen before chmod on Unix sockets (CVE-2023-45145) (#12671)",
        "commit_text": " Before this commit, Unix socket setup performed chmod(2) on the socket\r file after calling listen(2). Depending on what umask is used, this\r could leave the file with the wrong permissions for a short period of\r time. As a result, another process could exploit this race condition and\r establish a connection that would otherwise not be possible.\r \r We now make sure the socket permissions are set up prior to calling\r listen(2).\r \r (cherry picked from commit 1119ecae6fd8796fa337df2212f09173ab6c7b0a)\r \r Co-authored-by: Yossi Gottlieb <yossigo@gmail.com>",
        "func_before": "static int _anetTcpServer(char *err, int port, char *bindaddr, int af, int backlog)\n{\n    int s = -1, rv;\n    char _port[6];  /* strlen(\"65535\") */\n    struct addrinfo hints, *servinfo, *p;\n\n    snprintf(_port,6,\"%d\",port);\n    memset(&hints,0,sizeof(hints));\n    hints.ai_family = af;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_flags = AI_PASSIVE;    /* No effect if bindaddr != NULL */\n    if (bindaddr && !strcmp(\"*\", bindaddr))\n        bindaddr = NULL;\n    if (af == AF_INET6 && bindaddr && !strcmp(\"::*\", bindaddr))\n        bindaddr = NULL;\n\n    if ((rv = getaddrinfo(bindaddr,_port,&hints,&servinfo)) != 0) {\n        anetSetError(err, \"%s\", gai_strerror(rv));\n        return ANET_ERR;\n    }\n    for (p = servinfo; p != NULL; p = p->ai_next) {\n        if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)\n            continue;\n\n        if (af == AF_INET6 && anetV6Only(err,s) == ANET_ERR) goto error;\n        if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;\n        if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog) == ANET_ERR) s = ANET_ERR;\n        goto end;\n    }\n    if (p == NULL) {\n        anetSetError(err, \"unable to bind socket, errno: %d\", errno);\n        goto error;\n    }\n\nerror:\n    if (s != -1) close(s);\n    s = ANET_ERR;\nend:\n    freeaddrinfo(servinfo);\n    return s;\n}",
        "func": "static int _anetTcpServer(char *err, int port, char *bindaddr, int af, int backlog)\n{\n    int s = -1, rv;\n    char _port[6];  /* strlen(\"65535\") */\n    struct addrinfo hints, *servinfo, *p;\n\n    snprintf(_port,6,\"%d\",port);\n    memset(&hints,0,sizeof(hints));\n    hints.ai_family = af;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_flags = AI_PASSIVE;    /* No effect if bindaddr != NULL */\n    if (bindaddr && !strcmp(\"*\", bindaddr))\n        bindaddr = NULL;\n    if (af == AF_INET6 && bindaddr && !strcmp(\"::*\", bindaddr))\n        bindaddr = NULL;\n\n    if ((rv = getaddrinfo(bindaddr,_port,&hints,&servinfo)) != 0) {\n        anetSetError(err, \"%s\", gai_strerror(rv));\n        return ANET_ERR;\n    }\n    for (p = servinfo; p != NULL; p = p->ai_next) {\n        if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)\n            continue;\n\n        if (af == AF_INET6 && anetV6Only(err,s) == ANET_ERR) goto error;\n        if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;\n        if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog,0) == ANET_ERR) s = ANET_ERR;\n        goto end;\n    }\n    if (p == NULL) {\n        anetSetError(err, \"unable to bind socket, errno: %d\", errno);\n        goto error;\n    }\n\nerror:\n    if (s != -1) close(s);\n    s = ANET_ERR;\nend:\n    freeaddrinfo(servinfo);\n    return s;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,7 +24,7 @@\n \n         if (af == AF_INET6 && anetV6Only(err,s) == ANET_ERR) goto error;\n         if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;\n-        if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog) == ANET_ERR) s = ANET_ERR;\n+        if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog,0) == ANET_ERR) s = ANET_ERR;\n         goto end;\n     }\n     if (p == NULL) {",
        "diff_line_info": {
            "deleted_lines": [
                "        if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog) == ANET_ERR) s = ANET_ERR;"
            ],
            "added_lines": [
                "        if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog,0) == ANET_ERR) s = ANET_ERR;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22549",
        "func_name": "google/asylo/TrustedPrimitives::UntrustedCall",
        "description": "An attacker can modify the address to point to trusted memory to overwrite arbitrary trusted memory. It is recommended to update past 0.6.2 or git commit https://github.com/google/asylo/commit/53ed5d8fd8118ced1466e509606dd2f473707a5c",
        "git_url": "https://github.com/google/asylo/commit/ecfcd0008b6f8f63c6fa3cc1b62fcd4a52f2c0ad",
        "commit_title": "Store untrusted input to enclave variable",
        "commit_text": " The untrusted input pointer should be stored to trusted variable before checking to avoid unexpected modifications after checking.  PiperOrigin-RevId: 362553830",
        "func_before": "PrimitiveStatus TrustedPrimitives::UntrustedCall(uint64_t untrusted_selector,\n                                                 MessageWriter *input,\n                                                 MessageReader *output) {\n  int ret;\n\n  UntrustedCacheMalloc *untrusted_cache = UntrustedCacheMalloc::Instance();\n\n  SgxParams *const sgx_params =\n      reinterpret_cast<SgxParams *>(untrusted_cache->Malloc(sizeof(SgxParams)));\n  if (!TrustedPrimitives::IsOutsideEnclave(sgx_params, sizeof(SgxParams))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param should be in untrusted memory\");\n  }\n  Cleanup clean_up(\n      [sgx_params, untrusted_cache] { untrusted_cache->Free(sgx_params); });\n  sgx_params->input_size = 0;\n  sgx_params->input = nullptr;\n  if (input) {\n    sgx_params->input_size = input->MessageSize();\n    if (sgx_params->input_size > 0) {\n      // Allocate and copy data to |input_buffer|.\n      sgx_params->input = untrusted_cache->Malloc(sgx_params->input_size);\n      if (!TrustedPrimitives::IsOutsideEnclave(sgx_params->input,\n                                               sgx_params->input_size)) {\n        TrustedPrimitives::BestEffortAbort(\n            \"UntrustedCall: sgx_param input should be in untrusted memory\");\n      }\n      input->Serialize(const_cast<void *>(sgx_params->input));\n    }\n  }\n  sgx_params->output_size = 0;\n  sgx_params->output = nullptr;\n  CHECK_OCALL(\n      ocall_dispatch_untrusted_call(&ret, untrusted_selector, sgx_params));\n  if (sgx_params->input) {\n    untrusted_cache->Free(const_cast<void *>(sgx_params->input));\n  }\n  if (!TrustedPrimitives::IsOutsideEnclave(sgx_params->output,\n                                           sgx_params->output_size)) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param output should be in untrusted memory\");\n  }\n  if (sgx_params->output) {\n    // For the results obtained in |output_buffer|, copy them to |output|\n    // before freeing the buffer.\n    output->Deserialize(sgx_params->output, sgx_params->output_size);\n    TrustedPrimitives::UntrustedLocalFree(sgx_params->output);\n  }\n  return PrimitiveStatus::OkStatus();\n}",
        "func": "PrimitiveStatus TrustedPrimitives::UntrustedCall(uint64_t untrusted_selector,\n                                                 MessageWriter *input,\n                                                 MessageReader *output) {\n  int ret;\n\n  UntrustedCacheMalloc *untrusted_cache = UntrustedCacheMalloc::Instance();\n\n  SgxParams *const sgx_params =\n      reinterpret_cast<SgxParams *>(untrusted_cache->Malloc(sizeof(SgxParams)));\n  if (!TrustedPrimitives::IsOutsideEnclave(sgx_params, sizeof(SgxParams))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param should be in untrusted memory\");\n  }\n  Cleanup clean_up(\n      [sgx_params, untrusted_cache] { untrusted_cache->Free(sgx_params); });\n  sgx_params->input_size = 0;\n  sgx_params->input = nullptr;\n  if (input) {\n    sgx_params->input_size = input->MessageSize();\n    if (sgx_params->input_size > 0) {\n      // Allocate and copy data to |input_buffer|.\n      sgx_params->input = untrusted_cache->Malloc(sgx_params->input_size);\n      const void *input_pointer = sgx_params->input;\n      uint64_t input_size = sgx_params->input_size;\n      if (!TrustedPrimitives::IsOutsideEnclave(input_pointer, input_size)) {\n        TrustedPrimitives::BestEffortAbort(\n            \"UntrustedCall: sgx_param input should be in untrusted memory\");\n      }\n      input->Serialize(const_cast<void *>(input_pointer));\n    }\n  }\n  sgx_params->output_size = 0;\n  sgx_params->output = nullptr;\n  CHECK_OCALL(\n      ocall_dispatch_untrusted_call(&ret, untrusted_selector, sgx_params));\n  if (sgx_params->input) {\n    untrusted_cache->Free(const_cast<void *>(sgx_params->input));\n  }\n  if (!TrustedPrimitives::IsOutsideEnclave(sgx_params->output,\n                                           sgx_params->output_size)) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param output should be in untrusted memory\");\n  }\n  if (sgx_params->output) {\n    // For the results obtained in |output_buffer|, copy them to |output|\n    // before freeing the buffer.\n    output->Deserialize(sgx_params->output, sgx_params->output_size);\n    TrustedPrimitives::UntrustedLocalFree(sgx_params->output);\n  }\n  return PrimitiveStatus::OkStatus();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,12 +20,13 @@\n     if (sgx_params->input_size > 0) {\n       // Allocate and copy data to |input_buffer|.\n       sgx_params->input = untrusted_cache->Malloc(sgx_params->input_size);\n-      if (!TrustedPrimitives::IsOutsideEnclave(sgx_params->input,\n-                                               sgx_params->input_size)) {\n+      const void *input_pointer = sgx_params->input;\n+      uint64_t input_size = sgx_params->input_size;\n+      if (!TrustedPrimitives::IsOutsideEnclave(input_pointer, input_size)) {\n         TrustedPrimitives::BestEffortAbort(\n             \"UntrustedCall: sgx_param input should be in untrusted memory\");\n       }\n-      input->Serialize(const_cast<void *>(sgx_params->input));\n+      input->Serialize(const_cast<void *>(input_pointer));\n     }\n   }\n   sgx_params->output_size = 0;",
        "diff_line_info": {
            "deleted_lines": [
                "      if (!TrustedPrimitives::IsOutsideEnclave(sgx_params->input,",
                "                                               sgx_params->input_size)) {",
                "      input->Serialize(const_cast<void *>(sgx_params->input));"
            ],
            "added_lines": [
                "      const void *input_pointer = sgx_params->input;",
                "      uint64_t input_size = sgx_params->input_size;",
                "      if (!TrustedPrimitives::IsOutsideEnclave(input_pointer, input_size)) {",
                "      input->Serialize(const_cast<void *>(input_pointer));"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22550",
        "func_name": "google/asylo/UntrustedCacheMalloc::GetBuffer",
        "description": "An attacker can modify the pointers in enclave memory to overwrite arbitrary memory addresses within the secure enclave. It is recommended to update past 0.6.3 or git commit https://github.com/google/asylo/commit/a47ef55db2337d29de19c50cd29b0deb2871d31c",
        "git_url": "https://github.com/google/asylo/commit/a47ef55db2337d29de19c50cd29b0deb2871d31c",
        "commit_title": "Fix vulnerability in UntrustedCacheMalloc",
        "commit_text": " The pointer array is stored in untrusted memory, so we cannot trust the value even after validation. We should validate the pointer is pointing to untrusted memory after it's stored inside the enclave.  PiperOrigin-RevId: 358474391",
        "func_before": "void *UntrustedCacheMalloc::GetBuffer() {\n  void **buffers = nullptr;\n  void *buffer;\n  bool is_pool_empty;\n\n  {\n    LockGuard spin_lock(&lock_);\n    is_pool_empty = buffer_pool_.empty();\n    if (is_pool_empty) {\n      buffers =\n          primitives::AllocateUntrustedBuffers(kPoolIncrement, kPoolEntrySize);\n      for (int i = 0; i < kPoolIncrement; i++) {\n        if (!buffers[i] ||\n            !TrustedPrimitives::IsOutsideEnclave(buffers[i], kPoolEntrySize)) {\n          abort();\n        }\n        buffer_pool_.push(buffers[i]);\n      }\n    }\n    buffer = buffer_pool_.top();\n    buffer_pool_.pop();\n    busy_buffers_.insert(buffer);\n  }\n\n  if (is_pool_empty) {\n    // Free memory held by the array of buffer pointers returned by\n    // AllocateUntrustedBuffers.\n    Free(buffers);\n  }\n  return buffer;\n}",
        "func": "void *UntrustedCacheMalloc::GetBuffer() {\n  void **buffers = nullptr;\n  void *buffer;\n  bool is_pool_empty;\n\n  {\n    LockGuard spin_lock(&lock_);\n    is_pool_empty = buffer_pool_.empty();\n    if (is_pool_empty) {\n      buffers =\n          primitives::AllocateUntrustedBuffers(kPoolIncrement, kPoolEntrySize);\n      for (int i = 0; i < kPoolIncrement; i++) {\n        void *buf = buffers[i];\n        if (!buf || !TrustedPrimitives::IsOutsideEnclave(buf, kPoolEntrySize)) {\n          TrustedPrimitives::BestEffortAbort(\n              \"Cached buffer is not outside the enclave\");\n        }\n        buffer_pool_.push(buf);\n      }\n    }\n    buffer = buffer_pool_.top();\n    buffer_pool_.pop();\n    busy_buffers_.insert(buffer);\n  }\n\n  if (is_pool_empty) {\n    // Free memory held by the array of buffer pointers returned by\n    // AllocateUntrustedBuffers.\n    Free(buffers);\n  }\n  return buffer;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,11 +10,12 @@\n       buffers =\n           primitives::AllocateUntrustedBuffers(kPoolIncrement, kPoolEntrySize);\n       for (int i = 0; i < kPoolIncrement; i++) {\n-        if (!buffers[i] ||\n-            !TrustedPrimitives::IsOutsideEnclave(buffers[i], kPoolEntrySize)) {\n-          abort();\n+        void *buf = buffers[i];\n+        if (!buf || !TrustedPrimitives::IsOutsideEnclave(buf, kPoolEntrySize)) {\n+          TrustedPrimitives::BestEffortAbort(\n+              \"Cached buffer is not outside the enclave\");\n         }\n-        buffer_pool_.push(buffers[i]);\n+        buffer_pool_.push(buf);\n       }\n     }\n     buffer = buffer_pool_.top();",
        "diff_line_info": {
            "deleted_lines": [
                "        if (!buffers[i] ||",
                "            !TrustedPrimitives::IsOutsideEnclave(buffers[i], kPoolEntrySize)) {",
                "          abort();",
                "        buffer_pool_.push(buffers[i]);"
            ],
            "added_lines": [
                "        void *buf = buffers[i];",
                "        if (!buf || !TrustedPrimitives::IsOutsideEnclave(buf, kPoolEntrySize)) {",
                "          TrustedPrimitives::BestEffortAbort(",
                "              \"Cached buffer is not outside the enclave\");",
                "        buffer_pool_.push(buf);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22897",
        "func_name": "curl/schannel_connect_step1",
        "description": "curl 7.61.0 through 7.76.1 suffers from exposure of data element to wrong session due to a mistake in the code for CURLOPT_SSL_CIPHER_LIST when libcurl is built to use the Schannel TLS library. The selected cipher set was stored in a single \"static\" variable in the library, which has the surprising side-effect that if an application sets up multiple concurrent transfers, the last one that sets the ciphers will accidentally control the set used by all transfers. In a worst-case scenario, this weakens transport security significantly.",
        "git_url": "https://github.com/curl/curl/commit/bbb71507b7bab52002f9b1e0880bed6a32834511",
        "commit_title": "schannel: don't use static to store selected ciphers",
        "commit_text": " CVE-2021-22897  Bug: https://curl.se/docs/CVE-2021-22897.html",
        "func_before": "static CURLcode\nschannel_connect_step1(struct Curl_easy *data, struct connectdata *conn,\n                       int sockindex)\n{\n  ssize_t written = -1;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  SecBuffer outbuf;\n  SecBufferDesc outbuf_desc;\n  SecBuffer inbuf;\n  SecBufferDesc inbuf_desc;\n#ifdef HAS_ALPN\n  unsigned char alpn_buffer[128];\n#endif\n  SCHANNEL_CRED schannel_cred;\n  PCCERT_CONTEXT client_certs[1] = { NULL };\n  SECURITY_STATUS sspi_status = SEC_E_OK;\n  struct Curl_schannel_cred *old_cred = NULL;\n  struct in_addr addr;\n#ifdef ENABLE_IPV6\n  struct in6_addr addr6;\n#endif\n  TCHAR *host_name;\n  CURLcode result;\n  char * const hostname = SSL_HOST_NAME();\n\n  DEBUGF(infof(data,\n               \"schannel: SSL/TLS connection with %s port %hu (step 1/3)\\n\",\n               hostname, conn->remote_port));\n\n  if(curlx_verify_windows_version(5, 1, PLATFORM_WINNT,\n                                  VERSION_LESS_THAN_EQUAL)) {\n    /* Schannel in Windows XP (OS version 5.1) uses legacy handshakes and\n       algorithms that may not be supported by all servers. */\n    infof(data, \"schannel: Windows version is old and may not be able to \"\n          \"connect to some servers due to lack of SNI, algorithms, etc.\\n\");\n  }\n\n#ifdef HAS_ALPN\n  /* ALPN is only supported on Windows 8.1 / Server 2012 R2 and above.\n     Also it doesn't seem to be supported for Wine, see curl bug #983. */\n  BACKEND->use_alpn = conn->bits.tls_enable_alpn &&\n    !GetProcAddress(GetModuleHandle(TEXT(\"ntdll\")),\n                    \"wine_get_version\") &&\n    curlx_verify_windows_version(6, 3, PLATFORM_WINNT,\n                                 VERSION_GREATER_THAN_EQUAL);\n#else\n  BACKEND->use_alpn = false;\n#endif\n\n#ifdef _WIN32_WCE\n#ifdef HAS_MANUAL_VERIFY_API\n  /* certificate validation on CE doesn't seem to work right; we'll\n   * do it following a more manual process. */\n  BACKEND->use_manual_cred_validation = true;\n#else\n#error \"compiler too old to support requisite manual cert verify for Win CE\"\n#endif\n#else\n#ifdef HAS_MANUAL_VERIFY_API\n  if(SSL_CONN_CONFIG(CAfile) || SSL_CONN_CONFIG(ca_info_blob)) {\n    if(curlx_verify_windows_version(6, 1, PLATFORM_WINNT,\n                                    VERSION_GREATER_THAN_EQUAL)) {\n      BACKEND->use_manual_cred_validation = true;\n    }\n    else {\n      failf(data, \"schannel: this version of Windows is too old to support \"\n            \"certificate verification via CA bundle file.\");\n      return CURLE_SSL_CACERT_BADFILE;\n    }\n  }\n  else\n    BACKEND->use_manual_cred_validation = false;\n#else\n  if(SSL_CONN_CONFIG(CAfile) || SSL_CONN_CONFIG(ca_info_blob)) {\n    failf(data, \"schannel: CA cert support not built in\");\n    return CURLE_NOT_BUILT_IN;\n  }\n#endif\n#endif\n\n  BACKEND->cred = NULL;\n\n  /* check for an existing re-usable credential handle */\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    Curl_ssl_sessionid_lock(data);\n    if(!Curl_ssl_getsessionid(data, conn,\n                              SSL_IS_PROXY() ? TRUE : FALSE,\n                              (void **)&old_cred, NULL, sockindex)) {\n      BACKEND->cred = old_cred;\n      DEBUGF(infof(data, \"schannel: re-using existing credential handle\\n\"));\n\n      /* increment the reference counter of the credential/session handle */\n      BACKEND->cred->refcount++;\n      DEBUGF(infof(data,\n                   \"schannel: incremented credential handle refcount = %d\\n\",\n                   BACKEND->cred->refcount));\n    }\n    Curl_ssl_sessionid_unlock(data);\n  }\n\n  if(!BACKEND->cred) {\n    /* setup Schannel API options */\n    memset(&schannel_cred, 0, sizeof(schannel_cred));\n    schannel_cred.dwVersion = SCHANNEL_CRED_VERSION;\n\n    if(conn->ssl_config.verifypeer) {\n#ifdef HAS_MANUAL_VERIFY_API\n      if(BACKEND->use_manual_cred_validation)\n        schannel_cred.dwFlags = SCH_CRED_MANUAL_CRED_VALIDATION;\n      else\n#endif\n        schannel_cred.dwFlags = SCH_CRED_AUTO_CRED_VALIDATION;\n\n      if(SSL_SET_OPTION(no_revoke)) {\n        schannel_cred.dwFlags |= SCH_CRED_IGNORE_NO_REVOCATION_CHECK |\n          SCH_CRED_IGNORE_REVOCATION_OFFLINE;\n\n        DEBUGF(infof(data, \"schannel: disabled server certificate revocation \"\n                     \"checks\\n\"));\n      }\n      else if(SSL_SET_OPTION(revoke_best_effort)) {\n        schannel_cred.dwFlags |= SCH_CRED_IGNORE_NO_REVOCATION_CHECK |\n          SCH_CRED_IGNORE_REVOCATION_OFFLINE | SCH_CRED_REVOCATION_CHECK_CHAIN;\n\n        DEBUGF(infof(data, \"schannel: ignore revocation offline errors\"));\n      }\n      else {\n        schannel_cred.dwFlags |= SCH_CRED_REVOCATION_CHECK_CHAIN;\n\n        DEBUGF(infof(data,\n                     \"schannel: checking server certificate revocation\\n\"));\n      }\n    }\n    else {\n      schannel_cred.dwFlags = SCH_CRED_MANUAL_CRED_VALIDATION |\n        SCH_CRED_IGNORE_NO_REVOCATION_CHECK |\n        SCH_CRED_IGNORE_REVOCATION_OFFLINE;\n      DEBUGF(infof(data,\n                   \"schannel: disabled server cert revocation checks\\n\"));\n    }\n\n    if(!conn->ssl_config.verifyhost) {\n      schannel_cred.dwFlags |= SCH_CRED_NO_SERVERNAME_CHECK;\n      DEBUGF(infof(data, \"schannel: verifyhost setting prevents Schannel from \"\n                   \"comparing the supplied target name with the subject \"\n                   \"names in server certificates.\\n\"));\n    }\n\n    if(!SSL_SET_OPTION(auto_client_cert)) {\n      schannel_cred.dwFlags &= ~SCH_CRED_USE_DEFAULT_CREDS;\n      schannel_cred.dwFlags |= SCH_CRED_NO_DEFAULT_CREDS;\n      infof(data, \"schannel: disabled automatic use of client certificate\\n\");\n    }\n    else\n      infof(data, \"schannel: enabled automatic use of client certificate\\n\");\n\n    switch(conn->ssl_config.version) {\n    case CURL_SSLVERSION_DEFAULT:\n    case CURL_SSLVERSION_TLSv1:\n    case CURL_SSLVERSION_TLSv1_0:\n    case CURL_SSLVERSION_TLSv1_1:\n    case CURL_SSLVERSION_TLSv1_2:\n    case CURL_SSLVERSION_TLSv1_3:\n    {\n      result = set_ssl_version_min_max(&schannel_cred, data, conn);\n      if(result != CURLE_OK)\n        return result;\n      break;\n    }\n    case CURL_SSLVERSION_SSLv3:\n    case CURL_SSLVERSION_SSLv2:\n      failf(data, \"SSL versions not supported\");\n      return CURLE_NOT_BUILT_IN;\n    default:\n      failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n\n    if(SSL_CONN_CONFIG(cipher_list)) {\n      result = set_ssl_ciphers(&schannel_cred, SSL_CONN_CONFIG(cipher_list));\n      if(CURLE_OK != result) {\n        failf(data, \"Unable to set ciphers to passed via SSL_CONN_CONFIG\");\n        return result;\n      }\n    }\n\n\n#ifdef HAS_CLIENT_CERT_PATH\n    /* client certificate */\n    if(data->set.ssl.primary.clientcert || data->set.ssl.primary.cert_blob) {\n      DWORD cert_store_name = 0;\n      TCHAR *cert_store_path = NULL;\n      TCHAR *cert_thumbprint_str = NULL;\n      CRYPT_HASH_BLOB cert_thumbprint;\n      BYTE cert_thumbprint_data[CERT_THUMBPRINT_DATA_LEN];\n      HCERTSTORE cert_store = NULL;\n      FILE *fInCert = NULL;\n      void *certdata = NULL;\n      size_t certsize = 0;\n      bool blob = data->set.ssl.primary.cert_blob != NULL;\n      TCHAR *cert_path = NULL;\n      if(blob) {\n        certdata = data->set.ssl.primary.cert_blob->data;\n        certsize = data->set.ssl.primary.cert_blob->len;\n      }\n      else {\n        cert_path = curlx_convert_UTF8_to_tchar(\n          data->set.ssl.primary.clientcert);\n        if(!cert_path)\n          return CURLE_OUT_OF_MEMORY;\n\n        result = get_cert_location(cert_path, &cert_store_name,\n          &cert_store_path, &cert_thumbprint_str);\n\n        if(result && (data->set.ssl.primary.clientcert[0]!='\\0'))\n          fInCert = fopen(data->set.ssl.primary.clientcert, \"rb\");\n\n        if(result && !fInCert) {\n          failf(data, \"schannel: Failed to get certificate location\"\n                \" or file for %s\",\n                data->set.ssl.primary.clientcert);\n          curlx_unicodefree(cert_path);\n          return result;\n        }\n      }\n\n      if((fInCert || blob) && (data->set.ssl.cert_type) &&\n          (!strcasecompare(data->set.ssl.cert_type, \"P12\"))) {\n        failf(data, \"schannel: certificate format compatibility error \"\n                \" for %s\",\n                blob ? \"(memory blob)\" : data->set.ssl.primary.clientcert);\n        curlx_unicodefree(cert_path);\n        return CURLE_SSL_CERTPROBLEM;\n      }\n\n      if(fInCert || blob) {\n        /* Reading a .P12 or .pfx file, like the example at bottom of\n             https://social.msdn.microsoft.com/Forums/windowsdesktop/\n                            en-US/3e7bc95f-b21a-4bcd-bd2c-7f996718cae5\n        */\n        CRYPT_DATA_BLOB datablob;\n        WCHAR* pszPassword;\n        size_t pwd_len = 0;\n        int str_w_len = 0;\n        const char *cert_showfilename_error = blob ?\n          \"(memory blob)\" : data->set.ssl.primary.clientcert;\n        curlx_unicodefree(cert_path);\n        if(fInCert) {\n          long cert_tell = 0;\n          bool continue_reading = fseek(fInCert, 0, SEEK_END) == 0;\n          if(continue_reading)\n            cert_tell = ftell(fInCert);\n          if(cert_tell < 0)\n            continue_reading = FALSE;\n          else\n            certsize = (size_t)cert_tell;\n          if(continue_reading)\n            continue_reading = fseek(fInCert, 0, SEEK_SET) == 0;\n          if(continue_reading)\n            certdata = malloc(certsize + 1);\n          if((!certdata) ||\n             ((int) fread(certdata, certsize, 1, fInCert) != 1))\n            continue_reading = FALSE;\n          fclose(fInCert);\n          if(!continue_reading) {\n            failf(data, \"schannel: Failed to read cert file %s\",\n                data->set.ssl.primary.clientcert);\n            free(certdata);\n            return CURLE_SSL_CERTPROBLEM;\n          }\n        }\n\n        /* Convert key-pair data to the in-memory certificate store */\n        datablob.pbData = (BYTE*)certdata;\n        datablob.cbData = (DWORD)certsize;\n\n        if(data->set.ssl.key_passwd != NULL)\n          pwd_len = strlen(data->set.ssl.key_passwd);\n        pszPassword = (WCHAR*)malloc(sizeof(WCHAR)*(pwd_len + 1));\n        if(pszPassword) {\n          if(pwd_len > 0)\n            str_w_len = MultiByteToWideChar(CP_UTF8,\n               MB_ERR_INVALID_CHARS,\n               data->set.ssl.key_passwd, (int)pwd_len,\n               pszPassword, (int)(pwd_len + 1));\n\n          if((str_w_len >= 0) && (str_w_len <= (int)pwd_len))\n            pszPassword[str_w_len] = 0;\n          else\n            pszPassword[0] = 0;\n\n          cert_store = PFXImportCertStore(&datablob, pszPassword, 0);\n          free(pszPassword);\n        }\n        if(!blob)\n          free(certdata);\n        if(!cert_store) {\n          DWORD errorcode = GetLastError();\n          if(errorcode == ERROR_INVALID_PASSWORD)\n            failf(data, \"schannel: Failed to import cert file %s, \"\n                  \"password is bad\",\n                  cert_showfilename_error);\n          else\n            failf(data, \"schannel: Failed to import cert file %s, \"\n                  \"last error is 0x%x\",\n                  cert_showfilename_error, errorcode);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n\n        client_certs[0] = CertFindCertificateInStore(\n          cert_store, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0,\n          CERT_FIND_ANY, NULL, NULL);\n\n        if(!client_certs[0]) {\n          failf(data, \"schannel: Failed to get certificate from file %s\"\n                \", last error is 0x%x\",\n                cert_showfilename_error, GetLastError());\n          CertCloseStore(cert_store, 0);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n\n        schannel_cred.cCreds = 1;\n        schannel_cred.paCred = client_certs;\n      }\n      else {\n        cert_store =\n          CertOpenStore(CURL_CERT_STORE_PROV_SYSTEM, 0,\n                        (HCRYPTPROV)NULL,\n                        CERT_STORE_OPEN_EXISTING_FLAG | cert_store_name,\n                        cert_store_path);\n        if(!cert_store) {\n          failf(data, \"schannel: Failed to open cert store %x %s, \"\n                \"last error is 0x%x\",\n                cert_store_name, cert_store_path, GetLastError());\n          free(cert_store_path);\n          curlx_unicodefree(cert_path);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n        free(cert_store_path);\n\n        cert_thumbprint.pbData = cert_thumbprint_data;\n        cert_thumbprint.cbData = CERT_THUMBPRINT_DATA_LEN;\n\n        if(!CryptStringToBinary(cert_thumbprint_str,\n                                CERT_THUMBPRINT_STR_LEN,\n                                CRYPT_STRING_HEX,\n                                cert_thumbprint_data,\n                                &cert_thumbprint.cbData,\n                                NULL, NULL)) {\n          curlx_unicodefree(cert_path);\n          CertCloseStore(cert_store, 0);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n\n        client_certs[0] = CertFindCertificateInStore(\n          cert_store, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0,\n          CERT_FIND_HASH, &cert_thumbprint, NULL);\n\n        curlx_unicodefree(cert_path);\n\n        if(client_certs[0]) {\n          schannel_cred.cCreds = 1;\n          schannel_cred.paCred = client_certs;\n        }\n        else {\n          /* CRYPT_E_NOT_FOUND / E_INVALIDARG */\n          CertCloseStore(cert_store, 0);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n      }\n      CertCloseStore(cert_store, 0);\n    }\n#else\n    if(data->set.ssl.primary.clientcert || data->set.ssl.primary.cert_blob) {\n      failf(data, \"schannel: client cert support not built in\");\n      return CURLE_NOT_BUILT_IN;\n    }\n#endif\n\n    /* allocate memory for the re-usable credential handle */\n    BACKEND->cred = (struct Curl_schannel_cred *)\n      calloc(1, sizeof(struct Curl_schannel_cred));\n    if(!BACKEND->cred) {\n      failf(data, \"schannel: unable to allocate memory\");\n\n      if(client_certs[0])\n        CertFreeCertificateContext(client_certs[0]);\n\n      return CURLE_OUT_OF_MEMORY;\n    }\n    BACKEND->cred->refcount = 1;\n\n    /* https://msdn.microsoft.com/en-us/library/windows/desktop/aa374716.aspx\n     */\n    sspi_status =\n      s_pSecFn->AcquireCredentialsHandle(NULL, (TCHAR *)UNISP_NAME,\n                                         SECPKG_CRED_OUTBOUND, NULL,\n                                         &schannel_cred, NULL, NULL,\n                                         &BACKEND->cred->cred_handle,\n                                         &BACKEND->cred->time_stamp);\n\n    if(client_certs[0])\n      CertFreeCertificateContext(client_certs[0]);\n\n    if(sspi_status != SEC_E_OK) {\n      char buffer[STRERROR_LEN];\n      failf(data, \"schannel: AcquireCredentialsHandle failed: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      Curl_safefree(BACKEND->cred);\n      switch(sspi_status) {\n      case SEC_E_INSUFFICIENT_MEMORY:\n        return CURLE_OUT_OF_MEMORY;\n      case SEC_E_NO_CREDENTIALS:\n      case SEC_E_SECPKG_NOT_FOUND:\n      case SEC_E_NOT_OWNER:\n      case SEC_E_UNKNOWN_CREDENTIALS:\n      case SEC_E_INTERNAL_ERROR:\n      default:\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n    }\n  }\n\n  /* Warn if SNI is disabled due to use of an IP address */\n  if(Curl_inet_pton(AF_INET, hostname, &addr)\n#ifdef ENABLE_IPV6\n     || Curl_inet_pton(AF_INET6, hostname, &addr6)\n#endif\n    ) {\n    infof(data, \"schannel: using IP address, SNI is not supported by OS.\\n\");\n  }\n\n#ifdef HAS_ALPN\n  if(BACKEND->use_alpn) {\n    int cur = 0;\n    int list_start_index = 0;\n    unsigned int *extension_len = NULL;\n    unsigned short* list_len = NULL;\n\n    /* The first four bytes will be an unsigned int indicating number\n       of bytes of data in the rest of the buffer. */\n    extension_len = (unsigned int *)(&alpn_buffer[cur]);\n    cur += sizeof(unsigned int);\n\n    /* The next four bytes are an indicator that this buffer will contain\n       ALPN data, as opposed to NPN, for example. */\n    *(unsigned int *)&alpn_buffer[cur] =\n      SecApplicationProtocolNegotiationExt_ALPN;\n    cur += sizeof(unsigned int);\n\n    /* The next two bytes will be an unsigned short indicating the number\n       of bytes used to list the preferred protocols. */\n    list_len = (unsigned short*)(&alpn_buffer[cur]);\n    cur += sizeof(unsigned short);\n\n    list_start_index = cur;\n\n#ifdef USE_HTTP2\n    if(data->state.httpwant >= CURL_HTTP_VERSION_2) {\n      memcpy(&alpn_buffer[cur], ALPN_H2, ALPN_H2_LENGTH);\n      cur += ALPN_H2_LENGTH;\n      infof(data, \"schannel: ALPN, offering %s\\n\", ALPN_H2);\n    }\n#endif\n\n    alpn_buffer[cur++] = ALPN_HTTP_1_1_LENGTH;\n    memcpy(&alpn_buffer[cur], ALPN_HTTP_1_1, ALPN_HTTP_1_1_LENGTH);\n    cur += ALPN_HTTP_1_1_LENGTH;\n    infof(data, \"schannel: ALPN, offering %s\\n\", ALPN_HTTP_1_1);\n\n    *list_len = curlx_uitous(cur - list_start_index);\n    *extension_len = *list_len + sizeof(unsigned int) + sizeof(unsigned short);\n\n    InitSecBuffer(&inbuf, SECBUFFER_APPLICATION_PROTOCOLS, alpn_buffer, cur);\n    InitSecBufferDesc(&inbuf_desc, &inbuf, 1);\n  }\n  else {\n    InitSecBuffer(&inbuf, SECBUFFER_EMPTY, NULL, 0);\n    InitSecBufferDesc(&inbuf_desc, &inbuf, 1);\n  }\n#else /* HAS_ALPN */\n  InitSecBuffer(&inbuf, SECBUFFER_EMPTY, NULL, 0);\n  InitSecBufferDesc(&inbuf_desc, &inbuf, 1);\n#endif\n\n  /* setup output buffer */\n  InitSecBuffer(&outbuf, SECBUFFER_EMPTY, NULL, 0);\n  InitSecBufferDesc(&outbuf_desc, &outbuf, 1);\n\n  /* security request flags */\n  BACKEND->req_flags = ISC_REQ_SEQUENCE_DETECT | ISC_REQ_REPLAY_DETECT |\n    ISC_REQ_CONFIDENTIALITY | ISC_REQ_ALLOCATE_MEMORY |\n    ISC_REQ_STREAM;\n\n  if(!SSL_SET_OPTION(auto_client_cert)) {\n    BACKEND->req_flags |= ISC_REQ_USE_SUPPLIED_CREDS;\n  }\n\n  /* allocate memory for the security context handle */\n  BACKEND->ctxt = (struct Curl_schannel_ctxt *)\n    calloc(1, sizeof(struct Curl_schannel_ctxt));\n  if(!BACKEND->ctxt) {\n    failf(data, \"schannel: unable to allocate memory\");\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  host_name = curlx_convert_UTF8_to_tchar(hostname);\n  if(!host_name)\n    return CURLE_OUT_OF_MEMORY;\n\n  /* Schannel InitializeSecurityContext:\n     https://msdn.microsoft.com/en-us/library/windows/desktop/aa375924.aspx\n\n     At the moment we don't pass inbuf unless we're using ALPN since we only\n     use it for that, and Wine (for which we currently disable ALPN) is giving\n     us problems with inbuf regardless. https://github.com/curl/curl/issues/983\n  */\n  sspi_status = s_pSecFn->InitializeSecurityContext(\n    &BACKEND->cred->cred_handle, NULL, host_name, BACKEND->req_flags, 0, 0,\n    (BACKEND->use_alpn ? &inbuf_desc : NULL),\n    0, &BACKEND->ctxt->ctxt_handle,\n    &outbuf_desc, &BACKEND->ret_flags, &BACKEND->ctxt->time_stamp);\n\n  curlx_unicodefree(host_name);\n\n  if(sspi_status != SEC_I_CONTINUE_NEEDED) {\n    char buffer[STRERROR_LEN];\n    Curl_safefree(BACKEND->ctxt);\n    switch(sspi_status) {\n    case SEC_E_INSUFFICIENT_MEMORY:\n      failf(data, \"schannel: initial InitializeSecurityContext failed: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      return CURLE_OUT_OF_MEMORY;\n    case SEC_E_WRONG_PRINCIPAL:\n      failf(data, \"schannel: SNI or certificate check failed: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      return CURLE_PEER_FAILED_VERIFICATION;\n      /*\n        case SEC_E_INVALID_HANDLE:\n        case SEC_E_INVALID_TOKEN:\n        case SEC_E_LOGON_DENIED:\n        case SEC_E_TARGET_UNKNOWN:\n        case SEC_E_NO_AUTHENTICATING_AUTHORITY:\n        case SEC_E_INTERNAL_ERROR:\n        case SEC_E_NO_CREDENTIALS:\n        case SEC_E_UNSUPPORTED_FUNCTION:\n        case SEC_E_APPLICATION_PROTOCOL_MISMATCH:\n      */\n    default:\n      failf(data, \"schannel: initial InitializeSecurityContext failed: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n\n  DEBUGF(infof(data, \"schannel: sending initial handshake data: \"\n               \"sending %lu bytes...\\n\", outbuf.cbBuffer));\n\n  /* send initial handshake data which is now stored in output buffer */\n  result = Curl_write_plain(data, conn->sock[sockindex], outbuf.pvBuffer,\n                            outbuf.cbBuffer, &written);\n  s_pSecFn->FreeContextBuffer(outbuf.pvBuffer);\n  if((result != CURLE_OK) || (outbuf.cbBuffer != (size_t) written)) {\n    failf(data, \"schannel: failed to send initial handshake data: \"\n          \"sent %zd of %lu bytes\", written, outbuf.cbBuffer);\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  DEBUGF(infof(data, \"schannel: sent initial handshake data: \"\n               \"sent %zd bytes\\n\", written));\n\n  BACKEND->recv_unrecoverable_err = CURLE_OK;\n  BACKEND->recv_sspi_close_notify = false;\n  BACKEND->recv_connection_closed = false;\n  BACKEND->encdata_is_incomplete = false;\n\n  /* continue to second handshake step */\n  connssl->connecting_state = ssl_connect_2;\n\n  return CURLE_OK;\n}",
        "func": "static CURLcode\nschannel_connect_step1(struct Curl_easy *data, struct connectdata *conn,\n                       int sockindex)\n{\n  ssize_t written = -1;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  SecBuffer outbuf;\n  SecBufferDesc outbuf_desc;\n  SecBuffer inbuf;\n  SecBufferDesc inbuf_desc;\n#ifdef HAS_ALPN\n  unsigned char alpn_buffer[128];\n#endif\n  SCHANNEL_CRED schannel_cred;\n  PCCERT_CONTEXT client_certs[1] = { NULL };\n  SECURITY_STATUS sspi_status = SEC_E_OK;\n  struct Curl_schannel_cred *old_cred = NULL;\n  struct in_addr addr;\n#ifdef ENABLE_IPV6\n  struct in6_addr addr6;\n#endif\n  TCHAR *host_name;\n  CURLcode result;\n  char * const hostname = SSL_HOST_NAME();\n\n  DEBUGF(infof(data,\n               \"schannel: SSL/TLS connection with %s port %hu (step 1/3)\\n\",\n               hostname, conn->remote_port));\n\n  if(curlx_verify_windows_version(5, 1, PLATFORM_WINNT,\n                                  VERSION_LESS_THAN_EQUAL)) {\n    /* Schannel in Windows XP (OS version 5.1) uses legacy handshakes and\n       algorithms that may not be supported by all servers. */\n    infof(data, \"schannel: Windows version is old and may not be able to \"\n          \"connect to some servers due to lack of SNI, algorithms, etc.\\n\");\n  }\n\n#ifdef HAS_ALPN\n  /* ALPN is only supported on Windows 8.1 / Server 2012 R2 and above.\n     Also it doesn't seem to be supported for Wine, see curl bug #983. */\n  BACKEND->use_alpn = conn->bits.tls_enable_alpn &&\n    !GetProcAddress(GetModuleHandle(TEXT(\"ntdll\")),\n                    \"wine_get_version\") &&\n    curlx_verify_windows_version(6, 3, PLATFORM_WINNT,\n                                 VERSION_GREATER_THAN_EQUAL);\n#else\n  BACKEND->use_alpn = false;\n#endif\n\n#ifdef _WIN32_WCE\n#ifdef HAS_MANUAL_VERIFY_API\n  /* certificate validation on CE doesn't seem to work right; we'll\n   * do it following a more manual process. */\n  BACKEND->use_manual_cred_validation = true;\n#else\n#error \"compiler too old to support requisite manual cert verify for Win CE\"\n#endif\n#else\n#ifdef HAS_MANUAL_VERIFY_API\n  if(SSL_CONN_CONFIG(CAfile) || SSL_CONN_CONFIG(ca_info_blob)) {\n    if(curlx_verify_windows_version(6, 1, PLATFORM_WINNT,\n                                    VERSION_GREATER_THAN_EQUAL)) {\n      BACKEND->use_manual_cred_validation = true;\n    }\n    else {\n      failf(data, \"schannel: this version of Windows is too old to support \"\n            \"certificate verification via CA bundle file.\");\n      return CURLE_SSL_CACERT_BADFILE;\n    }\n  }\n  else\n    BACKEND->use_manual_cred_validation = false;\n#else\n  if(SSL_CONN_CONFIG(CAfile) || SSL_CONN_CONFIG(ca_info_blob)) {\n    failf(data, \"schannel: CA cert support not built in\");\n    return CURLE_NOT_BUILT_IN;\n  }\n#endif\n#endif\n\n  BACKEND->cred = NULL;\n\n  /* check for an existing re-usable credential handle */\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    Curl_ssl_sessionid_lock(data);\n    if(!Curl_ssl_getsessionid(data, conn,\n                              SSL_IS_PROXY() ? TRUE : FALSE,\n                              (void **)&old_cred, NULL, sockindex)) {\n      BACKEND->cred = old_cred;\n      DEBUGF(infof(data, \"schannel: re-using existing credential handle\\n\"));\n\n      /* increment the reference counter of the credential/session handle */\n      BACKEND->cred->refcount++;\n      DEBUGF(infof(data,\n                   \"schannel: incremented credential handle refcount = %d\\n\",\n                   BACKEND->cred->refcount));\n    }\n    Curl_ssl_sessionid_unlock(data);\n  }\n\n  if(!BACKEND->cred) {\n    /* setup Schannel API options */\n    memset(&schannel_cred, 0, sizeof(schannel_cred));\n    schannel_cred.dwVersion = SCHANNEL_CRED_VERSION;\n\n    if(conn->ssl_config.verifypeer) {\n#ifdef HAS_MANUAL_VERIFY_API\n      if(BACKEND->use_manual_cred_validation)\n        schannel_cred.dwFlags = SCH_CRED_MANUAL_CRED_VALIDATION;\n      else\n#endif\n        schannel_cred.dwFlags = SCH_CRED_AUTO_CRED_VALIDATION;\n\n      if(SSL_SET_OPTION(no_revoke)) {\n        schannel_cred.dwFlags |= SCH_CRED_IGNORE_NO_REVOCATION_CHECK |\n          SCH_CRED_IGNORE_REVOCATION_OFFLINE;\n\n        DEBUGF(infof(data, \"schannel: disabled server certificate revocation \"\n                     \"checks\\n\"));\n      }\n      else if(SSL_SET_OPTION(revoke_best_effort)) {\n        schannel_cred.dwFlags |= SCH_CRED_IGNORE_NO_REVOCATION_CHECK |\n          SCH_CRED_IGNORE_REVOCATION_OFFLINE | SCH_CRED_REVOCATION_CHECK_CHAIN;\n\n        DEBUGF(infof(data, \"schannel: ignore revocation offline errors\"));\n      }\n      else {\n        schannel_cred.dwFlags |= SCH_CRED_REVOCATION_CHECK_CHAIN;\n\n        DEBUGF(infof(data,\n                     \"schannel: checking server certificate revocation\\n\"));\n      }\n    }\n    else {\n      schannel_cred.dwFlags = SCH_CRED_MANUAL_CRED_VALIDATION |\n        SCH_CRED_IGNORE_NO_REVOCATION_CHECK |\n        SCH_CRED_IGNORE_REVOCATION_OFFLINE;\n      DEBUGF(infof(data,\n                   \"schannel: disabled server cert revocation checks\\n\"));\n    }\n\n    if(!conn->ssl_config.verifyhost) {\n      schannel_cred.dwFlags |= SCH_CRED_NO_SERVERNAME_CHECK;\n      DEBUGF(infof(data, \"schannel: verifyhost setting prevents Schannel from \"\n                   \"comparing the supplied target name with the subject \"\n                   \"names in server certificates.\\n\"));\n    }\n\n    if(!SSL_SET_OPTION(auto_client_cert)) {\n      schannel_cred.dwFlags &= ~SCH_CRED_USE_DEFAULT_CREDS;\n      schannel_cred.dwFlags |= SCH_CRED_NO_DEFAULT_CREDS;\n      infof(data, \"schannel: disabled automatic use of client certificate\\n\");\n    }\n    else\n      infof(data, \"schannel: enabled automatic use of client certificate\\n\");\n\n    switch(conn->ssl_config.version) {\n    case CURL_SSLVERSION_DEFAULT:\n    case CURL_SSLVERSION_TLSv1:\n    case CURL_SSLVERSION_TLSv1_0:\n    case CURL_SSLVERSION_TLSv1_1:\n    case CURL_SSLVERSION_TLSv1_2:\n    case CURL_SSLVERSION_TLSv1_3:\n    {\n      result = set_ssl_version_min_max(&schannel_cred, data, conn);\n      if(result != CURLE_OK)\n        return result;\n      break;\n    }\n    case CURL_SSLVERSION_SSLv3:\n    case CURL_SSLVERSION_SSLv2:\n      failf(data, \"SSL versions not supported\");\n      return CURLE_NOT_BUILT_IN;\n    default:\n      failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n\n    if(SSL_CONN_CONFIG(cipher_list)) {\n      result = set_ssl_ciphers(&schannel_cred, SSL_CONN_CONFIG(cipher_list),\n                               BACKEND->algIds);\n      if(CURLE_OK != result) {\n        failf(data, \"Unable to set ciphers to passed via SSL_CONN_CONFIG\");\n        return result;\n      }\n    }\n\n\n#ifdef HAS_CLIENT_CERT_PATH\n    /* client certificate */\n    if(data->set.ssl.primary.clientcert || data->set.ssl.primary.cert_blob) {\n      DWORD cert_store_name = 0;\n      TCHAR *cert_store_path = NULL;\n      TCHAR *cert_thumbprint_str = NULL;\n      CRYPT_HASH_BLOB cert_thumbprint;\n      BYTE cert_thumbprint_data[CERT_THUMBPRINT_DATA_LEN];\n      HCERTSTORE cert_store = NULL;\n      FILE *fInCert = NULL;\n      void *certdata = NULL;\n      size_t certsize = 0;\n      bool blob = data->set.ssl.primary.cert_blob != NULL;\n      TCHAR *cert_path = NULL;\n      if(blob) {\n        certdata = data->set.ssl.primary.cert_blob->data;\n        certsize = data->set.ssl.primary.cert_blob->len;\n      }\n      else {\n        cert_path = curlx_convert_UTF8_to_tchar(\n          data->set.ssl.primary.clientcert);\n        if(!cert_path)\n          return CURLE_OUT_OF_MEMORY;\n\n        result = get_cert_location(cert_path, &cert_store_name,\n          &cert_store_path, &cert_thumbprint_str);\n\n        if(result && (data->set.ssl.primary.clientcert[0]!='\\0'))\n          fInCert = fopen(data->set.ssl.primary.clientcert, \"rb\");\n\n        if(result && !fInCert) {\n          failf(data, \"schannel: Failed to get certificate location\"\n                \" or file for %s\",\n                data->set.ssl.primary.clientcert);\n          curlx_unicodefree(cert_path);\n          return result;\n        }\n      }\n\n      if((fInCert || blob) && (data->set.ssl.cert_type) &&\n          (!strcasecompare(data->set.ssl.cert_type, \"P12\"))) {\n        failf(data, \"schannel: certificate format compatibility error \"\n                \" for %s\",\n                blob ? \"(memory blob)\" : data->set.ssl.primary.clientcert);\n        curlx_unicodefree(cert_path);\n        return CURLE_SSL_CERTPROBLEM;\n      }\n\n      if(fInCert || blob) {\n        /* Reading a .P12 or .pfx file, like the example at bottom of\n             https://social.msdn.microsoft.com/Forums/windowsdesktop/\n                            en-US/3e7bc95f-b21a-4bcd-bd2c-7f996718cae5\n        */\n        CRYPT_DATA_BLOB datablob;\n        WCHAR* pszPassword;\n        size_t pwd_len = 0;\n        int str_w_len = 0;\n        const char *cert_showfilename_error = blob ?\n          \"(memory blob)\" : data->set.ssl.primary.clientcert;\n        curlx_unicodefree(cert_path);\n        if(fInCert) {\n          long cert_tell = 0;\n          bool continue_reading = fseek(fInCert, 0, SEEK_END) == 0;\n          if(continue_reading)\n            cert_tell = ftell(fInCert);\n          if(cert_tell < 0)\n            continue_reading = FALSE;\n          else\n            certsize = (size_t)cert_tell;\n          if(continue_reading)\n            continue_reading = fseek(fInCert, 0, SEEK_SET) == 0;\n          if(continue_reading)\n            certdata = malloc(certsize + 1);\n          if((!certdata) ||\n             ((int) fread(certdata, certsize, 1, fInCert) != 1))\n            continue_reading = FALSE;\n          fclose(fInCert);\n          if(!continue_reading) {\n            failf(data, \"schannel: Failed to read cert file %s\",\n                data->set.ssl.primary.clientcert);\n            free(certdata);\n            return CURLE_SSL_CERTPROBLEM;\n          }\n        }\n\n        /* Convert key-pair data to the in-memory certificate store */\n        datablob.pbData = (BYTE*)certdata;\n        datablob.cbData = (DWORD)certsize;\n\n        if(data->set.ssl.key_passwd != NULL)\n          pwd_len = strlen(data->set.ssl.key_passwd);\n        pszPassword = (WCHAR*)malloc(sizeof(WCHAR)*(pwd_len + 1));\n        if(pszPassword) {\n          if(pwd_len > 0)\n            str_w_len = MultiByteToWideChar(CP_UTF8,\n               MB_ERR_INVALID_CHARS,\n               data->set.ssl.key_passwd, (int)pwd_len,\n               pszPassword, (int)(pwd_len + 1));\n\n          if((str_w_len >= 0) && (str_w_len <= (int)pwd_len))\n            pszPassword[str_w_len] = 0;\n          else\n            pszPassword[0] = 0;\n\n          cert_store = PFXImportCertStore(&datablob, pszPassword, 0);\n          free(pszPassword);\n        }\n        if(!blob)\n          free(certdata);\n        if(!cert_store) {\n          DWORD errorcode = GetLastError();\n          if(errorcode == ERROR_INVALID_PASSWORD)\n            failf(data, \"schannel: Failed to import cert file %s, \"\n                  \"password is bad\",\n                  cert_showfilename_error);\n          else\n            failf(data, \"schannel: Failed to import cert file %s, \"\n                  \"last error is 0x%x\",\n                  cert_showfilename_error, errorcode);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n\n        client_certs[0] = CertFindCertificateInStore(\n          cert_store, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0,\n          CERT_FIND_ANY, NULL, NULL);\n\n        if(!client_certs[0]) {\n          failf(data, \"schannel: Failed to get certificate from file %s\"\n                \", last error is 0x%x\",\n                cert_showfilename_error, GetLastError());\n          CertCloseStore(cert_store, 0);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n\n        schannel_cred.cCreds = 1;\n        schannel_cred.paCred = client_certs;\n      }\n      else {\n        cert_store =\n          CertOpenStore(CURL_CERT_STORE_PROV_SYSTEM, 0,\n                        (HCRYPTPROV)NULL,\n                        CERT_STORE_OPEN_EXISTING_FLAG | cert_store_name,\n                        cert_store_path);\n        if(!cert_store) {\n          failf(data, \"schannel: Failed to open cert store %x %s, \"\n                \"last error is 0x%x\",\n                cert_store_name, cert_store_path, GetLastError());\n          free(cert_store_path);\n          curlx_unicodefree(cert_path);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n        free(cert_store_path);\n\n        cert_thumbprint.pbData = cert_thumbprint_data;\n        cert_thumbprint.cbData = CERT_THUMBPRINT_DATA_LEN;\n\n        if(!CryptStringToBinary(cert_thumbprint_str,\n                                CERT_THUMBPRINT_STR_LEN,\n                                CRYPT_STRING_HEX,\n                                cert_thumbprint_data,\n                                &cert_thumbprint.cbData,\n                                NULL, NULL)) {\n          curlx_unicodefree(cert_path);\n          CertCloseStore(cert_store, 0);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n\n        client_certs[0] = CertFindCertificateInStore(\n          cert_store, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0,\n          CERT_FIND_HASH, &cert_thumbprint, NULL);\n\n        curlx_unicodefree(cert_path);\n\n        if(client_certs[0]) {\n          schannel_cred.cCreds = 1;\n          schannel_cred.paCred = client_certs;\n        }\n        else {\n          /* CRYPT_E_NOT_FOUND / E_INVALIDARG */\n          CertCloseStore(cert_store, 0);\n          return CURLE_SSL_CERTPROBLEM;\n        }\n      }\n      CertCloseStore(cert_store, 0);\n    }\n#else\n    if(data->set.ssl.primary.clientcert || data->set.ssl.primary.cert_blob) {\n      failf(data, \"schannel: client cert support not built in\");\n      return CURLE_NOT_BUILT_IN;\n    }\n#endif\n\n    /* allocate memory for the re-usable credential handle */\n    BACKEND->cred = (struct Curl_schannel_cred *)\n      calloc(1, sizeof(struct Curl_schannel_cred));\n    if(!BACKEND->cred) {\n      failf(data, \"schannel: unable to allocate memory\");\n\n      if(client_certs[0])\n        CertFreeCertificateContext(client_certs[0]);\n\n      return CURLE_OUT_OF_MEMORY;\n    }\n    BACKEND->cred->refcount = 1;\n\n    /* https://msdn.microsoft.com/en-us/library/windows/desktop/aa374716.aspx\n     */\n    sspi_status =\n      s_pSecFn->AcquireCredentialsHandle(NULL, (TCHAR *)UNISP_NAME,\n                                         SECPKG_CRED_OUTBOUND, NULL,\n                                         &schannel_cred, NULL, NULL,\n                                         &BACKEND->cred->cred_handle,\n                                         &BACKEND->cred->time_stamp);\n\n    if(client_certs[0])\n      CertFreeCertificateContext(client_certs[0]);\n\n    if(sspi_status != SEC_E_OK) {\n      char buffer[STRERROR_LEN];\n      failf(data, \"schannel: AcquireCredentialsHandle failed: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      Curl_safefree(BACKEND->cred);\n      switch(sspi_status) {\n      case SEC_E_INSUFFICIENT_MEMORY:\n        return CURLE_OUT_OF_MEMORY;\n      case SEC_E_NO_CREDENTIALS:\n      case SEC_E_SECPKG_NOT_FOUND:\n      case SEC_E_NOT_OWNER:\n      case SEC_E_UNKNOWN_CREDENTIALS:\n      case SEC_E_INTERNAL_ERROR:\n      default:\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n    }\n  }\n\n  /* Warn if SNI is disabled due to use of an IP address */\n  if(Curl_inet_pton(AF_INET, hostname, &addr)\n#ifdef ENABLE_IPV6\n     || Curl_inet_pton(AF_INET6, hostname, &addr6)\n#endif\n    ) {\n    infof(data, \"schannel: using IP address, SNI is not supported by OS.\\n\");\n  }\n\n#ifdef HAS_ALPN\n  if(BACKEND->use_alpn) {\n    int cur = 0;\n    int list_start_index = 0;\n    unsigned int *extension_len = NULL;\n    unsigned short* list_len = NULL;\n\n    /* The first four bytes will be an unsigned int indicating number\n       of bytes of data in the rest of the buffer. */\n    extension_len = (unsigned int *)(&alpn_buffer[cur]);\n    cur += sizeof(unsigned int);\n\n    /* The next four bytes are an indicator that this buffer will contain\n       ALPN data, as opposed to NPN, for example. */\n    *(unsigned int *)&alpn_buffer[cur] =\n      SecApplicationProtocolNegotiationExt_ALPN;\n    cur += sizeof(unsigned int);\n\n    /* The next two bytes will be an unsigned short indicating the number\n       of bytes used to list the preferred protocols. */\n    list_len = (unsigned short*)(&alpn_buffer[cur]);\n    cur += sizeof(unsigned short);\n\n    list_start_index = cur;\n\n#ifdef USE_HTTP2\n    if(data->state.httpwant >= CURL_HTTP_VERSION_2) {\n      memcpy(&alpn_buffer[cur], ALPN_H2, ALPN_H2_LENGTH);\n      cur += ALPN_H2_LENGTH;\n      infof(data, \"schannel: ALPN, offering %s\\n\", ALPN_H2);\n    }\n#endif\n\n    alpn_buffer[cur++] = ALPN_HTTP_1_1_LENGTH;\n    memcpy(&alpn_buffer[cur], ALPN_HTTP_1_1, ALPN_HTTP_1_1_LENGTH);\n    cur += ALPN_HTTP_1_1_LENGTH;\n    infof(data, \"schannel: ALPN, offering %s\\n\", ALPN_HTTP_1_1);\n\n    *list_len = curlx_uitous(cur - list_start_index);\n    *extension_len = *list_len + sizeof(unsigned int) + sizeof(unsigned short);\n\n    InitSecBuffer(&inbuf, SECBUFFER_APPLICATION_PROTOCOLS, alpn_buffer, cur);\n    InitSecBufferDesc(&inbuf_desc, &inbuf, 1);\n  }\n  else {\n    InitSecBuffer(&inbuf, SECBUFFER_EMPTY, NULL, 0);\n    InitSecBufferDesc(&inbuf_desc, &inbuf, 1);\n  }\n#else /* HAS_ALPN */\n  InitSecBuffer(&inbuf, SECBUFFER_EMPTY, NULL, 0);\n  InitSecBufferDesc(&inbuf_desc, &inbuf, 1);\n#endif\n\n  /* setup output buffer */\n  InitSecBuffer(&outbuf, SECBUFFER_EMPTY, NULL, 0);\n  InitSecBufferDesc(&outbuf_desc, &outbuf, 1);\n\n  /* security request flags */\n  BACKEND->req_flags = ISC_REQ_SEQUENCE_DETECT | ISC_REQ_REPLAY_DETECT |\n    ISC_REQ_CONFIDENTIALITY | ISC_REQ_ALLOCATE_MEMORY |\n    ISC_REQ_STREAM;\n\n  if(!SSL_SET_OPTION(auto_client_cert)) {\n    BACKEND->req_flags |= ISC_REQ_USE_SUPPLIED_CREDS;\n  }\n\n  /* allocate memory for the security context handle */\n  BACKEND->ctxt = (struct Curl_schannel_ctxt *)\n    calloc(1, sizeof(struct Curl_schannel_ctxt));\n  if(!BACKEND->ctxt) {\n    failf(data, \"schannel: unable to allocate memory\");\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  host_name = curlx_convert_UTF8_to_tchar(hostname);\n  if(!host_name)\n    return CURLE_OUT_OF_MEMORY;\n\n  /* Schannel InitializeSecurityContext:\n     https://msdn.microsoft.com/en-us/library/windows/desktop/aa375924.aspx\n\n     At the moment we don't pass inbuf unless we're using ALPN since we only\n     use it for that, and Wine (for which we currently disable ALPN) is giving\n     us problems with inbuf regardless. https://github.com/curl/curl/issues/983\n  */\n  sspi_status = s_pSecFn->InitializeSecurityContext(\n    &BACKEND->cred->cred_handle, NULL, host_name, BACKEND->req_flags, 0, 0,\n    (BACKEND->use_alpn ? &inbuf_desc : NULL),\n    0, &BACKEND->ctxt->ctxt_handle,\n    &outbuf_desc, &BACKEND->ret_flags, &BACKEND->ctxt->time_stamp);\n\n  curlx_unicodefree(host_name);\n\n  if(sspi_status != SEC_I_CONTINUE_NEEDED) {\n    char buffer[STRERROR_LEN];\n    Curl_safefree(BACKEND->ctxt);\n    switch(sspi_status) {\n    case SEC_E_INSUFFICIENT_MEMORY:\n      failf(data, \"schannel: initial InitializeSecurityContext failed: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      return CURLE_OUT_OF_MEMORY;\n    case SEC_E_WRONG_PRINCIPAL:\n      failf(data, \"schannel: SNI or certificate check failed: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      return CURLE_PEER_FAILED_VERIFICATION;\n      /*\n        case SEC_E_INVALID_HANDLE:\n        case SEC_E_INVALID_TOKEN:\n        case SEC_E_LOGON_DENIED:\n        case SEC_E_TARGET_UNKNOWN:\n        case SEC_E_NO_AUTHENTICATING_AUTHORITY:\n        case SEC_E_INTERNAL_ERROR:\n        case SEC_E_NO_CREDENTIALS:\n        case SEC_E_UNSUPPORTED_FUNCTION:\n        case SEC_E_APPLICATION_PROTOCOL_MISMATCH:\n      */\n    default:\n      failf(data, \"schannel: initial InitializeSecurityContext failed: %s\",\n            Curl_sspi_strerror(sspi_status, buffer, sizeof(buffer)));\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n  }\n\n  DEBUGF(infof(data, \"schannel: sending initial handshake data: \"\n               \"sending %lu bytes...\\n\", outbuf.cbBuffer));\n\n  /* send initial handshake data which is now stored in output buffer */\n  result = Curl_write_plain(data, conn->sock[sockindex], outbuf.pvBuffer,\n                            outbuf.cbBuffer, &written);\n  s_pSecFn->FreeContextBuffer(outbuf.pvBuffer);\n  if((result != CURLE_OK) || (outbuf.cbBuffer != (size_t) written)) {\n    failf(data, \"schannel: failed to send initial handshake data: \"\n          \"sent %zd of %lu bytes\", written, outbuf.cbBuffer);\n    return CURLE_SSL_CONNECT_ERROR;\n  }\n\n  DEBUGF(infof(data, \"schannel: sent initial handshake data: \"\n               \"sent %zd bytes\\n\", written));\n\n  BACKEND->recv_unrecoverable_err = CURLE_OK;\n  BACKEND->recv_sspi_close_notify = false;\n  BACKEND->recv_connection_closed = false;\n  BACKEND->encdata_is_incomplete = false;\n\n  /* continue to second handshake step */\n  connssl->connecting_state = ssl_connect_2;\n\n  return CURLE_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -177,7 +177,8 @@\n     }\n \n     if(SSL_CONN_CONFIG(cipher_list)) {\n-      result = set_ssl_ciphers(&schannel_cred, SSL_CONN_CONFIG(cipher_list));\n+      result = set_ssl_ciphers(&schannel_cred, SSL_CONN_CONFIG(cipher_list),\n+                               BACKEND->algIds);\n       if(CURLE_OK != result) {\n         failf(data, \"Unable to set ciphers to passed via SSL_CONN_CONFIG\");\n         return result;",
        "diff_line_info": {
            "deleted_lines": [
                "      result = set_ssl_ciphers(&schannel_cred, SSL_CONN_CONFIG(cipher_list));"
            ],
            "added_lines": [
                "      result = set_ssl_ciphers(&schannel_cred, SSL_CONN_CONFIG(cipher_list),",
                "                               BACKEND->algIds);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22897",
        "func_name": "curl/set_ssl_ciphers",
        "description": "curl 7.61.0 through 7.76.1 suffers from exposure of data element to wrong session due to a mistake in the code for CURLOPT_SSL_CIPHER_LIST when libcurl is built to use the Schannel TLS library. The selected cipher set was stored in a single \"static\" variable in the library, which has the surprising side-effect that if an application sets up multiple concurrent transfers, the last one that sets the ciphers will accidentally control the set used by all transfers. In a worst-case scenario, this weakens transport security significantly.",
        "git_url": "https://github.com/curl/curl/commit/bbb71507b7bab52002f9b1e0880bed6a32834511",
        "commit_title": "schannel: don't use static to store selected ciphers",
        "commit_text": " CVE-2021-22897  Bug: https://curl.se/docs/CVE-2021-22897.html",
        "func_before": "static CURLcode\nset_ssl_ciphers(SCHANNEL_CRED *schannel_cred, char *ciphers)\n{\n  char *startCur = ciphers;\n  int algCount = 0;\n  static ALG_ID algIds[45]; /*There are 45 listed in the MS headers*/\n  while(startCur && (0 != *startCur) && (algCount < 45)) {\n    long alg = strtol(startCur, 0, 0);\n    if(!alg)\n      alg = get_alg_id_by_name(startCur);\n    if(alg)\n      algIds[algCount++] = alg;\n    else if(!strncmp(startCur, \"USE_STRONG_CRYPTO\",\n                     sizeof(\"USE_STRONG_CRYPTO\") - 1) ||\n            !strncmp(startCur, \"SCH_USE_STRONG_CRYPTO\",\n                     sizeof(\"SCH_USE_STRONG_CRYPTO\") - 1))\n      schannel_cred->dwFlags |= SCH_USE_STRONG_CRYPTO;\n    else\n      return CURLE_SSL_CIPHER;\n    startCur = strchr(startCur, ':');\n    if(startCur)\n      startCur++;\n  }\n  schannel_cred->palgSupportedAlgs = algIds;\n  schannel_cred->cSupportedAlgs = algCount;\n  return CURLE_OK;\n}",
        "func": "static CURLcode\nset_ssl_ciphers(SCHANNEL_CRED *schannel_cred, char *ciphers,\n                int *algIds)\n{\n  char *startCur = ciphers;\n  int algCount = 0;\n  while(startCur && (0 != *startCur) && (algCount < NUMOF_CIPHERS)) {\n    long alg = strtol(startCur, 0, 0);\n    if(!alg)\n      alg = get_alg_id_by_name(startCur);\n    if(alg)\n      algIds[algCount++] = alg;\n    else if(!strncmp(startCur, \"USE_STRONG_CRYPTO\",\n                     sizeof(\"USE_STRONG_CRYPTO\") - 1) ||\n            !strncmp(startCur, \"SCH_USE_STRONG_CRYPTO\",\n                     sizeof(\"SCH_USE_STRONG_CRYPTO\") - 1))\n      schannel_cred->dwFlags |= SCH_USE_STRONG_CRYPTO;\n    else\n      return CURLE_SSL_CIPHER;\n    startCur = strchr(startCur, ':');\n    if(startCur)\n      startCur++;\n  }\n  schannel_cred->palgSupportedAlgs = algIds;\n  schannel_cred->cSupportedAlgs = algCount;\n  return CURLE_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,10 @@\n static CURLcode\n-set_ssl_ciphers(SCHANNEL_CRED *schannel_cred, char *ciphers)\n+set_ssl_ciphers(SCHANNEL_CRED *schannel_cred, char *ciphers,\n+                int *algIds)\n {\n   char *startCur = ciphers;\n   int algCount = 0;\n-  static ALG_ID algIds[45]; /*There are 45 listed in the MS headers*/\n-  while(startCur && (0 != *startCur) && (algCount < 45)) {\n+  while(startCur && (0 != *startCur) && (algCount < NUMOF_CIPHERS)) {\n     long alg = strtol(startCur, 0, 0);\n     if(!alg)\n       alg = get_alg_id_by_name(startCur);",
        "diff_line_info": {
            "deleted_lines": [
                "set_ssl_ciphers(SCHANNEL_CRED *schannel_cred, char *ciphers)",
                "  static ALG_ID algIds[45]; /*There are 45 listed in the MS headers*/",
                "  while(startCur && (0 != *startCur) && (algCount < 45)) {"
            ],
            "added_lines": [
                "set_ssl_ciphers(SCHANNEL_CRED *schannel_cred, char *ciphers,",
                "                int *algIds)",
                "  while(startCur && (0 != *startCur) && (algCount < NUMOF_CIPHERS)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-46917",
        "func_name": "torvalds/linux/disable_wq",
        "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndmaengine: idxd: fix wq cleanup of WQCFG registers\n\nA pre-release silicon erratum workaround where wq reset does not clear\nWQCFG registers was leaked into upstream code. Use wq reset command\ninstead of blasting the MMIO region. This also address an issue where\nwe clobber registers in future devices.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=e5eb9757fe4c2392e069246ae78badc573af1833",
        "commit_title": "[ Upstream commit ea9aadc06a9f10ad20a90edc0a484f1147d88a7a ]",
        "commit_text": " A pre-release silicon erratum workaround where wq reset does not clear WQCFG registers was leaked into upstream code. Use wq reset command instead of blasting the MMIO region. This also address an issue where we clobber registers in future devices.  Link: https://lore.kernel.org/r/161824330020.881560.16375921906426627033.stgit@djiang5-desk3.ch.intel.com ",
        "func_before": "static void disable_wq(struct idxd_wq *wq)\n{\n\tstruct idxd_device *idxd = wq->idxd;\n\tstruct device *dev = &idxd->pdev->dev;\n\tint rc;\n\n\tmutex_lock(&wq->wq_lock);\n\tdev_dbg(dev, \"%s removing WQ %s\\n\", __func__, dev_name(&wq->conf_dev));\n\tif (wq->state == IDXD_WQ_DISABLED) {\n\t\tmutex_unlock(&wq->wq_lock);\n\t\treturn;\n\t}\n\n\tif (is_idxd_wq_dmaengine(wq))\n\t\tidxd_unregister_dma_channel(wq);\n\telse if (is_idxd_wq_cdev(wq))\n\t\tidxd_wq_del_cdev(wq);\n\n\tif (idxd_wq_refcount(wq))\n\t\tdev_warn(dev, \"Clients has claim on wq %d: %d\\n\",\n\t\t\t wq->id, idxd_wq_refcount(wq));\n\n\tidxd_wq_unmap_portal(wq);\n\n\tidxd_wq_drain(wq);\n\trc = idxd_wq_disable(wq);\n\n\tidxd_wq_free_resources(wq);\n\twq->client_count = 0;\n\tmutex_unlock(&wq->wq_lock);\n\n\tif (rc < 0)\n\t\tdev_warn(dev, \"Failed to disable %s: %d\\n\",\n\t\t\t dev_name(&wq->conf_dev), rc);\n\telse\n\t\tdev_info(dev, \"wq %s disabled\\n\", dev_name(&wq->conf_dev));\n}",
        "func": "static void disable_wq(struct idxd_wq *wq)\n{\n\tstruct idxd_device *idxd = wq->idxd;\n\tstruct device *dev = &idxd->pdev->dev;\n\n\tmutex_lock(&wq->wq_lock);\n\tdev_dbg(dev, \"%s removing WQ %s\\n\", __func__, dev_name(&wq->conf_dev));\n\tif (wq->state == IDXD_WQ_DISABLED) {\n\t\tmutex_unlock(&wq->wq_lock);\n\t\treturn;\n\t}\n\n\tif (is_idxd_wq_dmaengine(wq))\n\t\tidxd_unregister_dma_channel(wq);\n\telse if (is_idxd_wq_cdev(wq))\n\t\tidxd_wq_del_cdev(wq);\n\n\tif (idxd_wq_refcount(wq))\n\t\tdev_warn(dev, \"Clients has claim on wq %d: %d\\n\",\n\t\t\t wq->id, idxd_wq_refcount(wq));\n\n\tidxd_wq_unmap_portal(wq);\n\n\tidxd_wq_drain(wq);\n\tidxd_wq_reset(wq);\n\n\tidxd_wq_free_resources(wq);\n\twq->client_count = 0;\n\tmutex_unlock(&wq->wq_lock);\n\n\tdev_info(dev, \"wq %s disabled\\n\", dev_name(&wq->conf_dev));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,6 @@\n {\n \tstruct idxd_device *idxd = wq->idxd;\n \tstruct device *dev = &idxd->pdev->dev;\n-\tint rc;\n \n \tmutex_lock(&wq->wq_lock);\n \tdev_dbg(dev, \"%s removing WQ %s\\n\", __func__, dev_name(&wq->conf_dev));\n@@ -23,15 +22,11 @@\n \tidxd_wq_unmap_portal(wq);\n \n \tidxd_wq_drain(wq);\n-\trc = idxd_wq_disable(wq);\n+\tidxd_wq_reset(wq);\n \n \tidxd_wq_free_resources(wq);\n \twq->client_count = 0;\n \tmutex_unlock(&wq->wq_lock);\n \n-\tif (rc < 0)\n-\t\tdev_warn(dev, \"Failed to disable %s: %d\\n\",\n-\t\t\t dev_name(&wq->conf_dev), rc);\n-\telse\n-\t\tdev_info(dev, \"wq %s disabled\\n\", dev_name(&wq->conf_dev));\n+\tdev_info(dev, \"wq %s disabled\\n\", dev_name(&wq->conf_dev));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tint rc;",
                "\trc = idxd_wq_disable(wq);",
                "\tif (rc < 0)",
                "\t\tdev_warn(dev, \"Failed to disable %s: %d\\n\",",
                "\t\t\t dev_name(&wq->conf_dev), rc);",
                "\telse",
                "\t\tdev_info(dev, \"wq %s disabled\\n\", dev_name(&wq->conf_dev));"
            ],
            "added_lines": [
                "\tidxd_wq_reset(wq);",
                "\tdev_info(dev, \"wq %s disabled\\n\", dev_name(&wq->conf_dev));"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-46917",
        "func_name": "torvalds/linux/idxd_wq_disable_cleanup",
        "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndmaengine: idxd: fix wq cleanup of WQCFG registers\n\nA pre-release silicon erratum workaround where wq reset does not clear\nWQCFG registers was leaked into upstream code. Use wq reset command\ninstead of blasting the MMIO region. This also address an issue where\nwe clobber registers in future devices.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=e5eb9757fe4c2392e069246ae78badc573af1833",
        "commit_title": "[ Upstream commit ea9aadc06a9f10ad20a90edc0a484f1147d88a7a ]",
        "commit_text": " A pre-release silicon erratum workaround where wq reset does not clear WQCFG registers was leaked into upstream code. Use wq reset command instead of blasting the MMIO region. This also address an issue where we clobber registers in future devices.  Link: https://lore.kernel.org/r/161824330020.881560.16375921906426627033.stgit@djiang5-desk3.ch.intel.com ",
        "func_before": "void idxd_wq_disable_cleanup(struct idxd_wq *wq)\n{\n\tstruct idxd_device *idxd = wq->idxd;\n\tstruct device *dev = &idxd->pdev->dev;\n\tint i, wq_offset;\n\n\tlockdep_assert_held(&idxd->dev_lock);\n\tmemset(wq->wqcfg, 0, idxd->wqcfg_size);\n\twq->type = IDXD_WQT_NONE;\n\twq->size = 0;\n\twq->group = NULL;\n\twq->threshold = 0;\n\twq->priority = 0;\n\tclear_bit(WQ_FLAG_DEDICATED, &wq->flags);\n\tmemset(wq->name, 0, WQ_NAME_SIZE);\n\n\tfor (i = 0; i < WQCFG_STRIDES(idxd); i++) {\n\t\twq_offset = WQCFG_OFFSET(idxd, wq->id, i);\n\t\tiowrite32(0, idxd->reg_base + wq_offset);\n\t\tdev_dbg(dev, \"WQ[%d][%d][%#x]: %#x\\n\",\n\t\t\twq->id, i, wq_offset,\n\t\t\tioread32(idxd->reg_base + wq_offset));\n\t}\n}",
        "func": "void idxd_wq_disable_cleanup(struct idxd_wq *wq)\n{\n\tstruct idxd_device *idxd = wq->idxd;\n\n\tlockdep_assert_held(&idxd->dev_lock);\n\tmemset(wq->wqcfg, 0, idxd->wqcfg_size);\n\twq->type = IDXD_WQT_NONE;\n\twq->size = 0;\n\twq->group = NULL;\n\twq->threshold = 0;\n\twq->priority = 0;\n\tclear_bit(WQ_FLAG_DEDICATED, &wq->flags);\n\tmemset(wq->name, 0, WQ_NAME_SIZE);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,6 @@\n void idxd_wq_disable_cleanup(struct idxd_wq *wq)\n {\n \tstruct idxd_device *idxd = wq->idxd;\n-\tstruct device *dev = &idxd->pdev->dev;\n-\tint i, wq_offset;\n \n \tlockdep_assert_held(&idxd->dev_lock);\n \tmemset(wq->wqcfg, 0, idxd->wqcfg_size);\n@@ -13,12 +11,4 @@\n \twq->priority = 0;\n \tclear_bit(WQ_FLAG_DEDICATED, &wq->flags);\n \tmemset(wq->name, 0, WQ_NAME_SIZE);\n-\n-\tfor (i = 0; i < WQCFG_STRIDES(idxd); i++) {\n-\t\twq_offset = WQCFG_OFFSET(idxd, wq->id, i);\n-\t\tiowrite32(0, idxd->reg_base + wq_offset);\n-\t\tdev_dbg(dev, \"WQ[%d][%d][%#x]: %#x\\n\",\n-\t\t\twq->id, i, wq_offset,\n-\t\t\tioread32(idxd->reg_base + wq_offset));\n-\t}\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tstruct device *dev = &idxd->pdev->dev;",
                "\tint i, wq_offset;",
                "",
                "\tfor (i = 0; i < WQCFG_STRIDES(idxd); i++) {",
                "\t\twq_offset = WQCFG_OFFSET(idxd, wq->id, i);",
                "\t\tiowrite32(0, idxd->reg_base + wq_offset);",
                "\t\tdev_dbg(dev, \"WQ[%d][%d][%#x]: %#x\\n\",",
                "\t\t\twq->id, i, wq_offset,",
                "\t\t\tioread32(idxd->reg_base + wq_offset));",
                "\t}"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2021-46917",
        "func_name": "torvalds/linux/idxd_wq_config_write",
        "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ndmaengine: idxd: fix wq cleanup of WQCFG registers\n\nA pre-release silicon erratum workaround where wq reset does not clear\nWQCFG registers was leaked into upstream code. Use wq reset command\ninstead of blasting the MMIO region. This also address an issue where\nwe clobber registers in future devices.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=e5eb9757fe4c2392e069246ae78badc573af1833",
        "commit_title": "[ Upstream commit ea9aadc06a9f10ad20a90edc0a484f1147d88a7a ]",
        "commit_text": " A pre-release silicon erratum workaround where wq reset does not clear WQCFG registers was leaked into upstream code. Use wq reset command instead of blasting the MMIO region. This also address an issue where we clobber registers in future devices.  Link: https://lore.kernel.org/r/161824330020.881560.16375921906426627033.stgit@djiang5-desk3.ch.intel.com ",
        "func_before": "static int idxd_wq_config_write(struct idxd_wq *wq)\n{\n\tstruct idxd_device *idxd = wq->idxd;\n\tstruct device *dev = &idxd->pdev->dev;\n\tu32 wq_offset;\n\tint i;\n\n\tif (!wq->group)\n\t\treturn 0;\n\n\tmemset(wq->wqcfg, 0, idxd->wqcfg_size);\n\n\t/* byte 0-3 */\n\twq->wqcfg->wq_size = wq->size;\n\n\tif (wq->size == 0) {\n\t\tdev_warn(dev, \"Incorrect work queue size: 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* bytes 4-7 */\n\twq->wqcfg->wq_thresh = wq->threshold;\n\n\t/* byte 8-11 */\n\twq->wqcfg->priv = !!(wq->type == IDXD_WQT_KERNEL);\n\twq->wqcfg->mode = 1;\n\twq->wqcfg->priority = wq->priority;\n\n\t/* bytes 12-15 */\n\twq->wqcfg->max_xfer_shift = ilog2(wq->max_xfer_bytes);\n\twq->wqcfg->max_batch_shift = ilog2(wq->max_batch_size);\n\n\tdev_dbg(dev, \"WQ %d CFGs\\n\", wq->id);\n\tfor (i = 0; i < WQCFG_STRIDES(idxd); i++) {\n\t\twq_offset = WQCFG_OFFSET(idxd, wq->id, i);\n\t\tiowrite32(wq->wqcfg->bits[i], idxd->reg_base + wq_offset);\n\t\tdev_dbg(dev, \"WQ[%d][%d][%#x]: %#x\\n\",\n\t\t\twq->id, i, wq_offset,\n\t\t\tioread32(idxd->reg_base + wq_offset));\n\t}\n\n\treturn 0;\n}",
        "func": "static int idxd_wq_config_write(struct idxd_wq *wq)\n{\n\tstruct idxd_device *idxd = wq->idxd;\n\tstruct device *dev = &idxd->pdev->dev;\n\tu32 wq_offset;\n\tint i;\n\n\tif (!wq->group)\n\t\treturn 0;\n\n\t/*\n\t * Instead of memset the entire shadow copy of WQCFG, copy from the hardware after\n\t * wq reset. This will copy back the sticky values that are present on some devices.\n\t */\n\tfor (i = 0; i < WQCFG_STRIDES(idxd); i++) {\n\t\twq_offset = WQCFG_OFFSET(idxd, wq->id, i);\n\t\twq->wqcfg->bits[i] = ioread32(idxd->reg_base + wq_offset);\n\t}\n\n\t/* byte 0-3 */\n\twq->wqcfg->wq_size = wq->size;\n\n\tif (wq->size == 0) {\n\t\tdev_warn(dev, \"Incorrect work queue size: 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* bytes 4-7 */\n\twq->wqcfg->wq_thresh = wq->threshold;\n\n\t/* byte 8-11 */\n\twq->wqcfg->priv = !!(wq->type == IDXD_WQT_KERNEL);\n\twq->wqcfg->mode = 1;\n\twq->wqcfg->priority = wq->priority;\n\n\t/* bytes 12-15 */\n\twq->wqcfg->max_xfer_shift = ilog2(wq->max_xfer_bytes);\n\twq->wqcfg->max_batch_shift = ilog2(wq->max_batch_size);\n\n\tdev_dbg(dev, \"WQ %d CFGs\\n\", wq->id);\n\tfor (i = 0; i < WQCFG_STRIDES(idxd); i++) {\n\t\twq_offset = WQCFG_OFFSET(idxd, wq->id, i);\n\t\tiowrite32(wq->wqcfg->bits[i], idxd->reg_base + wq_offset);\n\t\tdev_dbg(dev, \"WQ[%d][%d][%#x]: %#x\\n\",\n\t\t\twq->id, i, wq_offset,\n\t\t\tioread32(idxd->reg_base + wq_offset));\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,14 @@\n \tif (!wq->group)\n \t\treturn 0;\n \n-\tmemset(wq->wqcfg, 0, idxd->wqcfg_size);\n+\t/*\n+\t * Instead of memset the entire shadow copy of WQCFG, copy from the hardware after\n+\t * wq reset. This will copy back the sticky values that are present on some devices.\n+\t */\n+\tfor (i = 0; i < WQCFG_STRIDES(idxd); i++) {\n+\t\twq_offset = WQCFG_OFFSET(idxd, wq->id, i);\n+\t\twq->wqcfg->bits[i] = ioread32(idxd->reg_base + wq_offset);\n+\t}\n \n \t/* byte 0-3 */\n \twq->wqcfg->wq_size = wq->size;",
        "diff_line_info": {
            "deleted_lines": [
                "\tmemset(wq->wqcfg, 0, idxd->wqcfg_size);"
            ],
            "added_lines": [
                "\t/*",
                "\t * Instead of memset the entire shadow copy of WQCFG, copy from the hardware after",
                "\t * wq reset. This will copy back the sticky values that are present on some devices.",
                "\t */",
                "\tfor (i = 0; i < WQCFG_STRIDES(idxd); i++) {",
                "\t\twq_offset = WQCFG_OFFSET(idxd, wq->id, i);",
                "\t\twq->wqcfg->bits[i] = ioread32(idxd->reg_base + wq_offset);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-46937",
        "func_name": "torvalds/linux/dbgfs_target_ids_write",
        "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/damon/dbgfs: fix 'struct pid' leaks in 'dbgfs_target_ids_write()'\n\nDAMON debugfs interface increases the reference counts of 'struct pid's\nfor targets from the 'target_ids' file write callback\n('dbgfs_target_ids_write()'), but decreases the counts only in DAMON\nmonitoring termination callback ('dbgfs_before_terminate()').\n\nTherefore, when 'target_ids' file is repeatedly written without DAMON\nmonitoring start/termination, the reference count is not decreased and\ntherefore memory for the 'struct pid' cannot be freed.  This commit\nfixes this issue by decreasing the reference counts when 'target_ids' is\nwritten.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=ebb3f994dd92f8fb4d70c7541091216c1e10cb71",
        "commit_title": "DAMON debugfs interface increases the reference counts of 'struct pid's",
        "commit_text": "for targets from the 'target_ids' file write callback ('dbgfs_target_ids_write()'), but decreases the counts only in DAMON monitoring termination callback ('dbgfs_before_terminate()').  Therefore, when 'target_ids' file is repeatedly written without DAMON monitoring start/termination, the reference count is not decreased and therefore memory for the 'struct pid' cannot be freed.  This commit fixes this issue by decreasing the reference counts when 'target_ids' is written.  Link: https://lkml.kernel.org/r/20211229124029.23348-1-sj@kernel.org Cc: <stable@vger.kernel.org>\t[5.15+] ",
        "func_before": "static ssize_t dbgfs_target_ids_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct damon_ctx *ctx = file->private_data;\n\tbool id_is_pid = true;\n\tchar *kbuf, *nrs;\n\tunsigned long *targets;\n\tssize_t nr_targets;\n\tssize_t ret;\n\tint i;\n\n\tkbuf = user_input_str(buf, count, ppos);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\tnrs = kbuf;\n\tif (!strncmp(kbuf, \"paddr\\n\", count)) {\n\t\tid_is_pid = false;\n\t\t/* target id is meaningless here, but we set it just for fun */\n\t\tscnprintf(kbuf, count, \"42    \");\n\t}\n\n\ttargets = str_to_target_ids(nrs, count, &nr_targets);\n\tif (!targets) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (id_is_pid) {\n\t\tfor (i = 0; i < nr_targets; i++) {\n\t\t\ttargets[i] = (unsigned long)find_get_pid(\n\t\t\t\t\t(int)targets[i]);\n\t\t\tif (!targets[i]) {\n\t\t\t\tdbgfs_put_pids(targets, i);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto free_targets_out;\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_lock(&ctx->kdamond_lock);\n\tif (ctx->kdamond) {\n\t\tif (id_is_pid)\n\t\t\tdbgfs_put_pids(targets, nr_targets);\n\t\tret = -EBUSY;\n\t\tgoto unlock_out;\n\t}\n\n\t/* remove targets with previously-set primitive */\n\tdamon_set_targets(ctx, NULL, 0);\n\n\t/* Configure the context for the address space type */\n\tif (id_is_pid)\n\t\tdamon_va_set_primitives(ctx);\n\telse\n\t\tdamon_pa_set_primitives(ctx);\n\n\tret = damon_set_targets(ctx, targets, nr_targets);\n\tif (ret) {\n\t\tif (id_is_pid)\n\t\t\tdbgfs_put_pids(targets, nr_targets);\n\t} else {\n\t\tret = count;\n\t}\n\nunlock_out:\n\tmutex_unlock(&ctx->kdamond_lock);\nfree_targets_out:\n\tkfree(targets);\nout:\n\tkfree(kbuf);\n\treturn ret;\n}",
        "func": "static ssize_t dbgfs_target_ids_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct damon_ctx *ctx = file->private_data;\n\tstruct damon_target *t, *next_t;\n\tbool id_is_pid = true;\n\tchar *kbuf, *nrs;\n\tunsigned long *targets;\n\tssize_t nr_targets;\n\tssize_t ret;\n\tint i;\n\n\tkbuf = user_input_str(buf, count, ppos);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\tnrs = kbuf;\n\tif (!strncmp(kbuf, \"paddr\\n\", count)) {\n\t\tid_is_pid = false;\n\t\t/* target id is meaningless here, but we set it just for fun */\n\t\tscnprintf(kbuf, count, \"42    \");\n\t}\n\n\ttargets = str_to_target_ids(nrs, count, &nr_targets);\n\tif (!targets) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (id_is_pid) {\n\t\tfor (i = 0; i < nr_targets; i++) {\n\t\t\ttargets[i] = (unsigned long)find_get_pid(\n\t\t\t\t\t(int)targets[i]);\n\t\t\tif (!targets[i]) {\n\t\t\t\tdbgfs_put_pids(targets, i);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto free_targets_out;\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_lock(&ctx->kdamond_lock);\n\tif (ctx->kdamond) {\n\t\tif (id_is_pid)\n\t\t\tdbgfs_put_pids(targets, nr_targets);\n\t\tret = -EBUSY;\n\t\tgoto unlock_out;\n\t}\n\n\t/* remove previously set targets */\n\tdamon_for_each_target_safe(t, next_t, ctx) {\n\t\tif (targetid_is_pid(ctx))\n\t\t\tput_pid((struct pid *)t->id);\n\t\tdamon_destroy_target(t);\n\t}\n\n\t/* Configure the context for the address space type */\n\tif (id_is_pid)\n\t\tdamon_va_set_primitives(ctx);\n\telse\n\t\tdamon_pa_set_primitives(ctx);\n\n\tret = damon_set_targets(ctx, targets, nr_targets);\n\tif (ret) {\n\t\tif (id_is_pid)\n\t\t\tdbgfs_put_pids(targets, nr_targets);\n\t} else {\n\t\tret = count;\n\t}\n\nunlock_out:\n\tmutex_unlock(&ctx->kdamond_lock);\nfree_targets_out:\n\tkfree(targets);\nout:\n\tkfree(kbuf);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,7 @@\n \t\tconst char __user *buf, size_t count, loff_t *ppos)\n {\n \tstruct damon_ctx *ctx = file->private_data;\n+\tstruct damon_target *t, *next_t;\n \tbool id_is_pid = true;\n \tchar *kbuf, *nrs;\n \tunsigned long *targets;\n@@ -46,8 +47,12 @@\n \t\tgoto unlock_out;\n \t}\n \n-\t/* remove targets with previously-set primitive */\n-\tdamon_set_targets(ctx, NULL, 0);\n+\t/* remove previously set targets */\n+\tdamon_for_each_target_safe(t, next_t, ctx) {\n+\t\tif (targetid_is_pid(ctx))\n+\t\t\tput_pid((struct pid *)t->id);\n+\t\tdamon_destroy_target(t);\n+\t}\n \n \t/* Configure the context for the address space type */\n \tif (id_is_pid)",
        "diff_line_info": {
            "deleted_lines": [
                "\t/* remove targets with previously-set primitive */",
                "\tdamon_set_targets(ctx, NULL, 0);"
            ],
            "added_lines": [
                "\tstruct damon_target *t, *next_t;",
                "\t/* remove previously set targets */",
                "\tdamon_for_each_target_safe(t, next_t, ctx) {",
                "\t\tif (targetid_is_pid(ctx))",
                "\t\t\tput_pid((struct pid *)t->id);",
                "\t\tdamon_destroy_target(t);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-46937",
        "func_name": "torvalds/linux/dbgfs_target_ids_write",
        "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/damon/dbgfs: fix 'struct pid' leaks in 'dbgfs_target_ids_write()'\n\nDAMON debugfs interface increases the reference counts of 'struct pid's\nfor targets from the 'target_ids' file write callback\n('dbgfs_target_ids_write()'), but decreases the counts only in DAMON\nmonitoring termination callback ('dbgfs_before_terminate()').\n\nTherefore, when 'target_ids' file is repeatedly written without DAMON\nmonitoring start/termination, the reference count is not decreased and\ntherefore memory for the 'struct pid' cannot be freed.  This commit\nfixes this issue by decreasing the reference counts when 'target_ids' is\nwritten.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=ffe4a1ba1a82c416a6b3a09d46594f6a885ae141",
        "commit_title": "commit ebb3f994dd92f8fb4d70c7541091216c1e10cb71 upstream.",
        "commit_text": " DAMON debugfs interface increases the reference counts of 'struct pid's for targets from the 'target_ids' file write callback ('dbgfs_target_ids_write()'), but decreases the counts only in DAMON monitoring termination callback ('dbgfs_before_terminate()').  Therefore, when 'target_ids' file is repeatedly written without DAMON monitoring start/termination, the reference count is not decreased and therefore memory for the 'struct pid' cannot be freed.  This commit fixes this issue by decreasing the reference counts when 'target_ids' is written.  Link: https://lkml.kernel.org/r/20211229124029.23348-1-sj@kernel.org Cc: <stable@vger.kernel.org>\t[5.15+] ",
        "func_before": "static ssize_t dbgfs_target_ids_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct damon_ctx *ctx = file->private_data;\n\tchar *kbuf, *nrs;\n\tunsigned long *targets;\n\tssize_t nr_targets;\n\tssize_t ret = count;\n\tint i;\n\tint err;\n\n\tkbuf = user_input_str(buf, count, ppos);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\tnrs = kbuf;\n\n\ttargets = str_to_target_ids(nrs, ret, &nr_targets);\n\tif (!targets) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (targetid_is_pid(ctx)) {\n\t\tfor (i = 0; i < nr_targets; i++) {\n\t\t\ttargets[i] = (unsigned long)find_get_pid(\n\t\t\t\t\t(int)targets[i]);\n\t\t\tif (!targets[i]) {\n\t\t\t\tdbgfs_put_pids(targets, i);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto free_targets_out;\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_lock(&ctx->kdamond_lock);\n\tif (ctx->kdamond) {\n\t\tif (targetid_is_pid(ctx))\n\t\t\tdbgfs_put_pids(targets, nr_targets);\n\t\tret = -EBUSY;\n\t\tgoto unlock_out;\n\t}\n\n\terr = damon_set_targets(ctx, targets, nr_targets);\n\tif (err) {\n\t\tif (targetid_is_pid(ctx))\n\t\t\tdbgfs_put_pids(targets, nr_targets);\n\t\tret = err;\n\t}\n\nunlock_out:\n\tmutex_unlock(&ctx->kdamond_lock);\nfree_targets_out:\n\tkfree(targets);\nout:\n\tkfree(kbuf);\n\treturn ret;\n}",
        "func": "static ssize_t dbgfs_target_ids_write(struct file *file,\n\t\tconst char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct damon_ctx *ctx = file->private_data;\n\tstruct damon_target *t, *next_t;\n\tchar *kbuf, *nrs;\n\tunsigned long *targets;\n\tssize_t nr_targets;\n\tssize_t ret = count;\n\tint i;\n\tint err;\n\n\tkbuf = user_input_str(buf, count, ppos);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\tnrs = kbuf;\n\n\ttargets = str_to_target_ids(nrs, ret, &nr_targets);\n\tif (!targets) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (targetid_is_pid(ctx)) {\n\t\tfor (i = 0; i < nr_targets; i++) {\n\t\t\ttargets[i] = (unsigned long)find_get_pid(\n\t\t\t\t\t(int)targets[i]);\n\t\t\tif (!targets[i]) {\n\t\t\t\tdbgfs_put_pids(targets, i);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto free_targets_out;\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_lock(&ctx->kdamond_lock);\n\tif (ctx->kdamond) {\n\t\tif (targetid_is_pid(ctx))\n\t\t\tdbgfs_put_pids(targets, nr_targets);\n\t\tret = -EBUSY;\n\t\tgoto unlock_out;\n\t}\n\n\t/* remove previously set targets */\n\tdamon_for_each_target_safe(t, next_t, ctx) {\n\t\tif (targetid_is_pid(ctx))\n\t\t\tput_pid((struct pid *)t->id);\n\t\tdamon_destroy_target(t);\n\t}\n\n\terr = damon_set_targets(ctx, targets, nr_targets);\n\tif (err) {\n\t\tif (targetid_is_pid(ctx))\n\t\t\tdbgfs_put_pids(targets, nr_targets);\n\t\tret = err;\n\t}\n\nunlock_out:\n\tmutex_unlock(&ctx->kdamond_lock);\nfree_targets_out:\n\tkfree(targets);\nout:\n\tkfree(kbuf);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,7 @@\n \t\tconst char __user *buf, size_t count, loff_t *ppos)\n {\n \tstruct damon_ctx *ctx = file->private_data;\n+\tstruct damon_target *t, *next_t;\n \tchar *kbuf, *nrs;\n \tunsigned long *targets;\n \tssize_t nr_targets;\n@@ -41,6 +42,13 @@\n \t\tgoto unlock_out;\n \t}\n \n+\t/* remove previously set targets */\n+\tdamon_for_each_target_safe(t, next_t, ctx) {\n+\t\tif (targetid_is_pid(ctx))\n+\t\t\tput_pid((struct pid *)t->id);\n+\t\tdamon_destroy_target(t);\n+\t}\n+\n \terr = damon_set_targets(ctx, targets, nr_targets);\n \tif (err) {\n \t\tif (targetid_is_pid(ctx))",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tstruct damon_target *t, *next_t;",
                "\t/* remove previously set targets */",
                "\tdamon_for_each_target_safe(t, next_t, ctx) {",
                "\t\tif (targetid_is_pid(ctx))",
                "\t\t\tput_pid((struct pid *)t->id);",
                "\t\tdamon_destroy_target(t);",
                "\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26272",
        "func_name": "electron/WebContents::SendIPCMessageToFrame",
        "description": "The Electron framework lets you write cross-platform desktop applications using JavaScript, HTML and CSS. In affected versions of Electron IPC messages sent from the main process to a subframe in the renderer process, through webContents.sendToFrame, event.reply or when using the remote module, can in some cases be delivered to the wrong frame. If your app uses remote, calls webContents.sendToFrame, or calls event.reply in an IPC message handler then it is impacted by this issue. This has been fixed in versions 9.4.0, 10.2.0, 11.1.0, and 12.0.0-beta.9. There are no workarounds for this issue.",
        "git_url": "https://github.com/electron/electron/commit/07a1c2a3e5845901f7e2eda9506695be58edc73c",
        "commit_title": "fix: restrict sendToFrame to same-process frames by default (#26875)",
        "commit_text": "",
        "func_before": "bool WebContents::SendIPCMessageToFrame(bool internal,\n                                        int32_t frame_id,\n                                        const std::string& channel,\n                                        v8::Local<v8::Value> args) {\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  blink::CloneableMessage message;\n  if (!gin::ConvertFromV8(isolate, args, &message)) {\n    isolate->ThrowException(v8::Exception::Error(\n        gin::StringToV8(isolate, \"Failed to serialize arguments\")));\n    return false;\n  }\n  auto frames = web_contents()->GetAllFrames();\n  auto iter = std::find_if(frames.begin(), frames.end(), [frame_id](auto* f) {\n    return f->GetRoutingID() == frame_id;\n  });\n  if (iter == frames.end())\n    return false;\n  if (!(*iter)->IsRenderFrameLive())\n    return false;\n\n  mojo::AssociatedRemote<mojom::ElectronRenderer> electron_renderer;\n  (*iter)->GetRemoteAssociatedInterfaces()->GetInterface(&electron_renderer);\n  electron_renderer->Message(internal, channel, std::move(message),\n                             0 /* sender_id */);\n  return true;\n}",
        "func": "bool WebContents::SendIPCMessageToFrame(bool internal,\n                                        v8::Local<v8::Value> frame,\n                                        const std::string& channel,\n                                        v8::Local<v8::Value> args) {\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  blink::CloneableMessage message;\n  if (!gin::ConvertFromV8(isolate, args, &message)) {\n    isolate->ThrowException(v8::Exception::Error(\n        gin::StringToV8(isolate, \"Failed to serialize arguments\")));\n    return false;\n  }\n  int32_t frame_id;\n  int32_t process_id;\n  if (gin::ConvertFromV8(isolate, frame, &frame_id)) {\n    process_id = web_contents()->GetMainFrame()->GetProcess()->GetID();\n  } else {\n    std::vector<int32_t> id_pair;\n    if (gin::ConvertFromV8(isolate, frame, &id_pair) && id_pair.size() == 2) {\n      process_id = id_pair[0];\n      frame_id = id_pair[1];\n    } else {\n      isolate->ThrowException(v8::Exception::Error(gin::StringToV8(\n          isolate,\n          \"frameId must be a number or a pair of [processId, frameId]\")));\n      return false;\n    }\n  }\n\n  auto* rfh = content::RenderFrameHost::FromID(process_id, frame_id);\n  if (!rfh || !rfh->IsRenderFrameLive() ||\n      content::WebContents::FromRenderFrameHost(rfh) != web_contents())\n    return false;\n\n  mojo::AssociatedRemote<mojom::ElectronRenderer> electron_renderer;\n  rfh->GetRemoteAssociatedInterfaces()->GetInterface(&electron_renderer);\n  electron_renderer->Message(internal, channel, std::move(message),\n                             0 /* sender_id */);\n  return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n bool WebContents::SendIPCMessageToFrame(bool internal,\n-                                        int32_t frame_id,\n+                                        v8::Local<v8::Value> frame,\n                                         const std::string& channel,\n                                         v8::Local<v8::Value> args) {\n   v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n@@ -9,17 +9,30 @@\n         gin::StringToV8(isolate, \"Failed to serialize arguments\")));\n     return false;\n   }\n-  auto frames = web_contents()->GetAllFrames();\n-  auto iter = std::find_if(frames.begin(), frames.end(), [frame_id](auto* f) {\n-    return f->GetRoutingID() == frame_id;\n-  });\n-  if (iter == frames.end())\n-    return false;\n-  if (!(*iter)->IsRenderFrameLive())\n+  int32_t frame_id;\n+  int32_t process_id;\n+  if (gin::ConvertFromV8(isolate, frame, &frame_id)) {\n+    process_id = web_contents()->GetMainFrame()->GetProcess()->GetID();\n+  } else {\n+    std::vector<int32_t> id_pair;\n+    if (gin::ConvertFromV8(isolate, frame, &id_pair) && id_pair.size() == 2) {\n+      process_id = id_pair[0];\n+      frame_id = id_pair[1];\n+    } else {\n+      isolate->ThrowException(v8::Exception::Error(gin::StringToV8(\n+          isolate,\n+          \"frameId must be a number or a pair of [processId, frameId]\")));\n+      return false;\n+    }\n+  }\n+\n+  auto* rfh = content::RenderFrameHost::FromID(process_id, frame_id);\n+  if (!rfh || !rfh->IsRenderFrameLive() ||\n+      content::WebContents::FromRenderFrameHost(rfh) != web_contents())\n     return false;\n \n   mojo::AssociatedRemote<mojom::ElectronRenderer> electron_renderer;\n-  (*iter)->GetRemoteAssociatedInterfaces()->GetInterface(&electron_renderer);\n+  rfh->GetRemoteAssociatedInterfaces()->GetInterface(&electron_renderer);\n   electron_renderer->Message(internal, channel, std::move(message),\n                              0 /* sender_id */);\n   return true;",
        "diff_line_info": {
            "deleted_lines": [
                "                                        int32_t frame_id,",
                "  auto frames = web_contents()->GetAllFrames();",
                "  auto iter = std::find_if(frames.begin(), frames.end(), [frame_id](auto* f) {",
                "    return f->GetRoutingID() == frame_id;",
                "  });",
                "  if (iter == frames.end())",
                "    return false;",
                "  if (!(*iter)->IsRenderFrameLive())",
                "  (*iter)->GetRemoteAssociatedInterfaces()->GetInterface(&electron_renderer);"
            ],
            "added_lines": [
                "                                        v8::Local<v8::Value> frame,",
                "  int32_t frame_id;",
                "  int32_t process_id;",
                "  if (gin::ConvertFromV8(isolate, frame, &frame_id)) {",
                "    process_id = web_contents()->GetMainFrame()->GetProcess()->GetID();",
                "  } else {",
                "    std::vector<int32_t> id_pair;",
                "    if (gin::ConvertFromV8(isolate, frame, &id_pair) && id_pair.size() == 2) {",
                "      process_id = id_pair[0];",
                "      frame_id = id_pair[1];",
                "    } else {",
                "      isolate->ThrowException(v8::Exception::Error(gin::StringToV8(",
                "          isolate,",
                "          \"frameId must be a number or a pair of [processId, frameId]\")));",
                "      return false;",
                "    }",
                "  }",
                "",
                "  auto* rfh = content::RenderFrameHost::FromID(process_id, frame_id);",
                "  if (!rfh || !rfh->IsRenderFrameLive() ||",
                "      content::WebContents::FromRenderFrameHost(rfh) != web_contents())",
                "  rfh->GetRemoteAssociatedInterfaces()->GetInterface(&electron_renderer);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26272",
        "func_name": "electron/CreateNativeEvent",
        "description": "The Electron framework lets you write cross-platform desktop applications using JavaScript, HTML and CSS. In affected versions of Electron IPC messages sent from the main process to a subframe in the renderer process, through webContents.sendToFrame, event.reply or when using the remote module, can in some cases be delivered to the wrong frame. If your app uses remote, calls webContents.sendToFrame, or calls event.reply in an IPC message handler then it is impacted by this issue. This has been fixed in versions 9.4.0, 10.2.0, 11.1.0, and 12.0.0-beta.9. There are no workarounds for this issue.",
        "git_url": "https://github.com/electron/electron/commit/07a1c2a3e5845901f7e2eda9506695be58edc73c",
        "commit_title": "fix: restrict sendToFrame to same-process frames by default (#26875)",
        "commit_text": "",
        "func_before": "v8::Local<v8::Object> CreateNativeEvent(\n    v8::Isolate* isolate,\n    v8::Local<v8::Object> sender,\n    content::RenderFrameHost* frame,\n    electron::mojom::ElectronBrowser::MessageSyncCallback callback) {\n  v8::Local<v8::Object> event;\n  if (frame && callback) {\n    gin::Handle<Event> native_event = Event::Create(isolate);\n    native_event->SetCallback(std::move(callback));\n    event = v8::Local<v8::Object>::Cast(native_event.ToV8());\n  } else {\n    // No need to create native event if we do not need to send reply.\n    event = CreateEvent(isolate);\n  }\n\n  Dictionary dict(isolate, event);\n  dict.Set(\"sender\", sender);\n  // Should always set frameId even when callback is null.\n  if (frame)\n    dict.Set(\"frameId\", frame->GetRoutingID());\n  return event;\n}",
        "func": "v8::Local<v8::Object> CreateNativeEvent(\n    v8::Isolate* isolate,\n    v8::Local<v8::Object> sender,\n    content::RenderFrameHost* frame,\n    electron::mojom::ElectronBrowser::MessageSyncCallback callback) {\n  v8::Local<v8::Object> event;\n  if (frame && callback) {\n    gin::Handle<Event> native_event = Event::Create(isolate);\n    native_event->SetCallback(std::move(callback));\n    event = v8::Local<v8::Object>::Cast(native_event.ToV8());\n  } else {\n    // No need to create native event if we do not need to send reply.\n    event = CreateEvent(isolate);\n  }\n\n  Dictionary dict(isolate, event);\n  dict.Set(\"sender\", sender);\n  // Should always set frameId even when callback is null.\n  if (frame) {\n    dict.Set(\"frameId\", frame->GetRoutingID());\n    dict.Set(\"processId\", frame->GetProcess()->GetID());\n  }\n  return event;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,7 +16,9 @@\n   Dictionary dict(isolate, event);\n   dict.Set(\"sender\", sender);\n   // Should always set frameId even when callback is null.\n-  if (frame)\n+  if (frame) {\n     dict.Set(\"frameId\", frame->GetRoutingID());\n+    dict.Set(\"processId\", frame->GetProcess()->GetID());\n+  }\n   return event;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  if (frame)"
            ],
            "added_lines": [
                "  if (frame) {",
                "    dict.Set(\"processId\", frame->GetProcess()->GetID());",
                "  }"
            ]
        }
    }
]