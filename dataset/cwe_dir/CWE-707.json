[
    {
        "cve_id": "CVE-2020-11080",
        "func_name": "nghttp2/nghttp2_strerror",
        "description": "In nghttp2 before version 1.41.0, the overly large HTTP/2 SETTINGS frame payload causes denial of service. The proof of concept attack involves a malicious client constructing a SETTINGS frame with a length of 14,400 bytes (2400 individual settings entries) over and over again. The attack causes the CPU to spike at 100%. nghttp2 v1.41.0 fixes this vulnerability. There is a workaround to this vulnerability. Implement nghttp2_on_frame_recv_callback callback, and if received frame is SETTINGS frame and the number of settings entries are large (e.g., > 32), then drop the connection.",
        "git_url": "https://github.com/nghttp2/nghttp2/commit/336a98feb0d56b9ac54e12736b18785c27f75090",
        "commit_title": "Implement max settings option",
        "commit_text": "",
        "func_before": "const char *nghttp2_strerror(int error_code) {\n  switch (error_code) {\n  case 0:\n    return \"Success\";\n  case NGHTTP2_ERR_INVALID_ARGUMENT:\n    return \"Invalid argument\";\n  case NGHTTP2_ERR_BUFFER_ERROR:\n    return \"Out of buffer space\";\n  case NGHTTP2_ERR_UNSUPPORTED_VERSION:\n    return \"Unsupported SPDY version\";\n  case NGHTTP2_ERR_WOULDBLOCK:\n    return \"Operation would block\";\n  case NGHTTP2_ERR_PROTO:\n    return \"Protocol error\";\n  case NGHTTP2_ERR_INVALID_FRAME:\n    return \"Invalid frame octets\";\n  case NGHTTP2_ERR_EOF:\n    return \"EOF\";\n  case NGHTTP2_ERR_DEFERRED:\n    return \"Data transfer deferred\";\n  case NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE:\n    return \"No more Stream ID available\";\n  case NGHTTP2_ERR_STREAM_CLOSED:\n    return \"Stream was already closed or invalid\";\n  case NGHTTP2_ERR_STREAM_CLOSING:\n    return \"Stream is closing\";\n  case NGHTTP2_ERR_STREAM_SHUT_WR:\n    return \"The transmission is not allowed for this stream\";\n  case NGHTTP2_ERR_INVALID_STREAM_ID:\n    return \"Stream ID is invalid\";\n  case NGHTTP2_ERR_INVALID_STREAM_STATE:\n    return \"Invalid stream state\";\n  case NGHTTP2_ERR_DEFERRED_DATA_EXIST:\n    return \"Another DATA frame has already been deferred\";\n  case NGHTTP2_ERR_START_STREAM_NOT_ALLOWED:\n    return \"request HEADERS is not allowed\";\n  case NGHTTP2_ERR_GOAWAY_ALREADY_SENT:\n    return \"GOAWAY has already been sent\";\n  case NGHTTP2_ERR_INVALID_HEADER_BLOCK:\n    return \"Invalid header block\";\n  case NGHTTP2_ERR_INVALID_STATE:\n    return \"Invalid state\";\n  case NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE:\n    return \"The user callback function failed due to the temporal error\";\n  case NGHTTP2_ERR_FRAME_SIZE_ERROR:\n    return \"The length of the frame is invalid\";\n  case NGHTTP2_ERR_HEADER_COMP:\n    return \"Header compression/decompression error\";\n  case NGHTTP2_ERR_FLOW_CONTROL:\n    return \"Flow control error\";\n  case NGHTTP2_ERR_INSUFF_BUFSIZE:\n    return \"Insufficient buffer size given to function\";\n  case NGHTTP2_ERR_PAUSE:\n    return \"Callback was paused by the application\";\n  case NGHTTP2_ERR_TOO_MANY_INFLIGHT_SETTINGS:\n    return \"Too many inflight SETTINGS\";\n  case NGHTTP2_ERR_PUSH_DISABLED:\n    return \"Server push is disabled by peer\";\n  case NGHTTP2_ERR_DATA_EXIST:\n    return \"DATA or HEADERS frame has already been submitted for the stream\";\n  case NGHTTP2_ERR_SESSION_CLOSING:\n    return \"The current session is closing\";\n  case NGHTTP2_ERR_HTTP_HEADER:\n    return \"Invalid HTTP header field was received\";\n  case NGHTTP2_ERR_HTTP_MESSAGING:\n    return \"Violation in HTTP messaging rule\";\n  case NGHTTP2_ERR_REFUSED_STREAM:\n    return \"Stream was refused\";\n  case NGHTTP2_ERR_INTERNAL:\n    return \"Internal error\";\n  case NGHTTP2_ERR_CANCEL:\n    return \"Cancel\";\n  case NGHTTP2_ERR_SETTINGS_EXPECTED:\n    return \"When a local endpoint expects to receive SETTINGS frame, it \"\n           \"receives an other type of frame\";\n  case NGHTTP2_ERR_NOMEM:\n    return \"Out of memory\";\n  case NGHTTP2_ERR_CALLBACK_FAILURE:\n    return \"The user callback function failed\";\n  case NGHTTP2_ERR_BAD_CLIENT_MAGIC:\n    return \"Received bad client magic byte string\";\n  case NGHTTP2_ERR_FLOODED:\n    return \"Flooding was detected in this HTTP/2 session, and it must be \"\n           \"closed\";\n  default:\n    return \"Unknown error code\";\n  }\n}",
        "func": "const char *nghttp2_strerror(int error_code) {\n  switch (error_code) {\n  case 0:\n    return \"Success\";\n  case NGHTTP2_ERR_INVALID_ARGUMENT:\n    return \"Invalid argument\";\n  case NGHTTP2_ERR_BUFFER_ERROR:\n    return \"Out of buffer space\";\n  case NGHTTP2_ERR_UNSUPPORTED_VERSION:\n    return \"Unsupported SPDY version\";\n  case NGHTTP2_ERR_WOULDBLOCK:\n    return \"Operation would block\";\n  case NGHTTP2_ERR_PROTO:\n    return \"Protocol error\";\n  case NGHTTP2_ERR_INVALID_FRAME:\n    return \"Invalid frame octets\";\n  case NGHTTP2_ERR_EOF:\n    return \"EOF\";\n  case NGHTTP2_ERR_DEFERRED:\n    return \"Data transfer deferred\";\n  case NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE:\n    return \"No more Stream ID available\";\n  case NGHTTP2_ERR_STREAM_CLOSED:\n    return \"Stream was already closed or invalid\";\n  case NGHTTP2_ERR_STREAM_CLOSING:\n    return \"Stream is closing\";\n  case NGHTTP2_ERR_STREAM_SHUT_WR:\n    return \"The transmission is not allowed for this stream\";\n  case NGHTTP2_ERR_INVALID_STREAM_ID:\n    return \"Stream ID is invalid\";\n  case NGHTTP2_ERR_INVALID_STREAM_STATE:\n    return \"Invalid stream state\";\n  case NGHTTP2_ERR_DEFERRED_DATA_EXIST:\n    return \"Another DATA frame has already been deferred\";\n  case NGHTTP2_ERR_START_STREAM_NOT_ALLOWED:\n    return \"request HEADERS is not allowed\";\n  case NGHTTP2_ERR_GOAWAY_ALREADY_SENT:\n    return \"GOAWAY has already been sent\";\n  case NGHTTP2_ERR_INVALID_HEADER_BLOCK:\n    return \"Invalid header block\";\n  case NGHTTP2_ERR_INVALID_STATE:\n    return \"Invalid state\";\n  case NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE:\n    return \"The user callback function failed due to the temporal error\";\n  case NGHTTP2_ERR_FRAME_SIZE_ERROR:\n    return \"The length of the frame is invalid\";\n  case NGHTTP2_ERR_HEADER_COMP:\n    return \"Header compression/decompression error\";\n  case NGHTTP2_ERR_FLOW_CONTROL:\n    return \"Flow control error\";\n  case NGHTTP2_ERR_INSUFF_BUFSIZE:\n    return \"Insufficient buffer size given to function\";\n  case NGHTTP2_ERR_PAUSE:\n    return \"Callback was paused by the application\";\n  case NGHTTP2_ERR_TOO_MANY_INFLIGHT_SETTINGS:\n    return \"Too many inflight SETTINGS\";\n  case NGHTTP2_ERR_PUSH_DISABLED:\n    return \"Server push is disabled by peer\";\n  case NGHTTP2_ERR_DATA_EXIST:\n    return \"DATA or HEADERS frame has already been submitted for the stream\";\n  case NGHTTP2_ERR_SESSION_CLOSING:\n    return \"The current session is closing\";\n  case NGHTTP2_ERR_HTTP_HEADER:\n    return \"Invalid HTTP header field was received\";\n  case NGHTTP2_ERR_HTTP_MESSAGING:\n    return \"Violation in HTTP messaging rule\";\n  case NGHTTP2_ERR_REFUSED_STREAM:\n    return \"Stream was refused\";\n  case NGHTTP2_ERR_INTERNAL:\n    return \"Internal error\";\n  case NGHTTP2_ERR_CANCEL:\n    return \"Cancel\";\n  case NGHTTP2_ERR_SETTINGS_EXPECTED:\n    return \"When a local endpoint expects to receive SETTINGS frame, it \"\n           \"receives an other type of frame\";\n  case NGHTTP2_ERR_NOMEM:\n    return \"Out of memory\";\n  case NGHTTP2_ERR_CALLBACK_FAILURE:\n    return \"The user callback function failed\";\n  case NGHTTP2_ERR_BAD_CLIENT_MAGIC:\n    return \"Received bad client magic byte string\";\n  case NGHTTP2_ERR_FLOODED:\n    return \"Flooding was detected in this HTTP/2 session, and it must be \"\n           \"closed\";\n  case NGHTTP2_ERR_TOO_MANY_SETTINGS:\n    return \"SETTINGS frame contained more than the maximum allowed entries\";\n  default:\n    return \"Unknown error code\";\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -82,6 +82,8 @@\n   case NGHTTP2_ERR_FLOODED:\n     return \"Flooding was detected in this HTTP/2 session, and it must be \"\n            \"closed\";\n+  case NGHTTP2_ERR_TOO_MANY_SETTINGS:\n+    return \"SETTINGS frame contained more than the maximum allowed entries\";\n   default:\n     return \"Unknown error code\";\n   }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  case NGHTTP2_ERR_TOO_MANY_SETTINGS:",
                "    return \"SETTINGS frame contained more than the maximum allowed entries\";"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-11080",
        "func_name": "nghttp2/nghttp2_session_upgrade_internal",
        "description": "In nghttp2 before version 1.41.0, the overly large HTTP/2 SETTINGS frame payload causes denial of service. The proof of concept attack involves a malicious client constructing a SETTINGS frame with a length of 14,400 bytes (2400 individual settings entries) over and over again. The attack causes the CPU to spike at 100%. nghttp2 v1.41.0 fixes this vulnerability. There is a workaround to this vulnerability. Implement nghttp2_on_frame_recv_callback callback, and if received frame is SETTINGS frame and the number of settings entries are large (e.g., > 32), then drop the connection.",
        "git_url": "https://github.com/nghttp2/nghttp2/commit/336a98feb0d56b9ac54e12736b18785c27f75090",
        "commit_title": "Implement max settings option",
        "commit_text": "",
        "func_before": "static int nghttp2_session_upgrade_internal(nghttp2_session *session,\n                                            const uint8_t *settings_payload,\n                                            size_t settings_payloadlen,\n                                            void *stream_user_data) {\n  nghttp2_stream *stream;\n  nghttp2_frame frame;\n  nghttp2_settings_entry *iv;\n  size_t niv;\n  int rv;\n  nghttp2_priority_spec pri_spec;\n  nghttp2_mem *mem;\n\n  mem = &session->mem;\n\n  if ((!session->server && session->next_stream_id != 1) ||\n      (session->server && session->last_recv_stream_id >= 1)) {\n    return NGHTTP2_ERR_PROTO;\n  }\n  if (settings_payloadlen % NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n  rv = nghttp2_frame_unpack_settings_payload2(&iv, &niv, settings_payload,\n                                              settings_payloadlen, mem);\n  if (rv != 0) {\n    return rv;\n  }\n\n  if (session->server) {\n    nghttp2_frame_hd_init(&frame.hd, settings_payloadlen, NGHTTP2_SETTINGS,\n                          NGHTTP2_FLAG_NONE, 0);\n    frame.settings.iv = iv;\n    frame.settings.niv = niv;\n    rv = nghttp2_session_on_settings_received(session, &frame, 1 /* No ACK */);\n  } else {\n    rv = nghttp2_submit_settings(session, NGHTTP2_FLAG_NONE, iv, niv);\n  }\n  nghttp2_mem_free(mem, iv);\n  if (rv != 0) {\n    return rv;\n  }\n\n  nghttp2_priority_spec_default_init(&pri_spec);\n\n  stream = nghttp2_session_open_stream(\n      session, 1, NGHTTP2_STREAM_FLAG_NONE, &pri_spec, NGHTTP2_STREAM_OPENING,\n      session->server ? NULL : stream_user_data);\n  if (stream == NULL) {\n    return NGHTTP2_ERR_NOMEM;\n  }\n\n  /* We don't call nghttp2_session_adjust_closed_stream(), since this\n     should be the first stream open. */\n\n  if (session->server) {\n    nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_RD);\n    session->last_recv_stream_id = 1;\n    session->last_proc_stream_id = 1;\n  } else {\n    nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_WR);\n    session->last_sent_stream_id = 1;\n    session->next_stream_id += 2;\n  }\n  return 0;\n}",
        "func": "static int nghttp2_session_upgrade_internal(nghttp2_session *session,\n                                            const uint8_t *settings_payload,\n                                            size_t settings_payloadlen,\n                                            void *stream_user_data) {\n  nghttp2_stream *stream;\n  nghttp2_frame frame;\n  nghttp2_settings_entry *iv;\n  size_t niv;\n  int rv;\n  nghttp2_priority_spec pri_spec;\n  nghttp2_mem *mem;\n\n  mem = &session->mem;\n\n  if ((!session->server && session->next_stream_id != 1) ||\n      (session->server && session->last_recv_stream_id >= 1)) {\n    return NGHTTP2_ERR_PROTO;\n  }\n  if (settings_payloadlen % NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH) {\n    return NGHTTP2_ERR_INVALID_ARGUMENT;\n  }\n  /* SETTINGS frame contains too many settings */\n  if (settings_payloadlen / NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH\n        > session->max_settings) {\n    return NGHTTP2_ERR_TOO_MANY_SETTINGS;\n  }\n  rv = nghttp2_frame_unpack_settings_payload2(&iv, &niv, settings_payload,\n                                              settings_payloadlen, mem);\n  if (rv != 0) {\n    return rv;\n  }\n\n  if (session->server) {\n    nghttp2_frame_hd_init(&frame.hd, settings_payloadlen, NGHTTP2_SETTINGS,\n                          NGHTTP2_FLAG_NONE, 0);\n    frame.settings.iv = iv;\n    frame.settings.niv = niv;\n    rv = nghttp2_session_on_settings_received(session, &frame, 1 /* No ACK */);\n  } else {\n    rv = nghttp2_submit_settings(session, NGHTTP2_FLAG_NONE, iv, niv);\n  }\n  nghttp2_mem_free(mem, iv);\n  if (rv != 0) {\n    return rv;\n  }\n\n  nghttp2_priority_spec_default_init(&pri_spec);\n\n  stream = nghttp2_session_open_stream(\n      session, 1, NGHTTP2_STREAM_FLAG_NONE, &pri_spec, NGHTTP2_STREAM_OPENING,\n      session->server ? NULL : stream_user_data);\n  if (stream == NULL) {\n    return NGHTTP2_ERR_NOMEM;\n  }\n\n  /* We don't call nghttp2_session_adjust_closed_stream(), since this\n     should be the first stream open. */\n\n  if (session->server) {\n    nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_RD);\n    session->last_recv_stream_id = 1;\n    session->last_proc_stream_id = 1;\n  } else {\n    nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_WR);\n    session->last_sent_stream_id = 1;\n    session->next_stream_id += 2;\n  }\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,6 +18,11 @@\n   }\n   if (settings_payloadlen % NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH) {\n     return NGHTTP2_ERR_INVALID_ARGUMENT;\n+  }\n+  /* SETTINGS frame contains too many settings */\n+  if (settings_payloadlen / NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH\n+        > session->max_settings) {\n+    return NGHTTP2_ERR_TOO_MANY_SETTINGS;\n   }\n   rv = nghttp2_frame_unpack_settings_payload2(&iv, &niv, settings_payload,\n                                               settings_payloadlen, mem);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  }",
                "  /* SETTINGS frame contains too many settings */",
                "  if (settings_payloadlen / NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH",
                "        > session->max_settings) {",
                "    return NGHTTP2_ERR_TOO_MANY_SETTINGS;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-11080",
        "func_name": "nghttp2/session_new",
        "description": "In nghttp2 before version 1.41.0, the overly large HTTP/2 SETTINGS frame payload causes denial of service. The proof of concept attack involves a malicious client constructing a SETTINGS frame with a length of 14,400 bytes (2400 individual settings entries) over and over again. The attack causes the CPU to spike at 100%. nghttp2 v1.41.0 fixes this vulnerability. There is a workaround to this vulnerability. Implement nghttp2_on_frame_recv_callback callback, and if received frame is SETTINGS frame and the number of settings entries are large (e.g., > 32), then drop the connection.",
        "git_url": "https://github.com/nghttp2/nghttp2/commit/336a98feb0d56b9ac54e12736b18785c27f75090",
        "commit_title": "Implement max settings option",
        "commit_text": "",
        "func_before": "static int session_new(nghttp2_session **session_ptr,\n                       const nghttp2_session_callbacks *callbacks,\n                       void *user_data, int server,\n                       const nghttp2_option *option, nghttp2_mem *mem) {\n  int rv;\n  size_t nbuffer;\n  size_t max_deflate_dynamic_table_size =\n      NGHTTP2_HD_DEFAULT_MAX_DEFLATE_BUFFER_SIZE;\n\n  if (mem == NULL) {\n    mem = nghttp2_mem_default();\n  }\n\n  *session_ptr = nghttp2_mem_calloc(mem, 1, sizeof(nghttp2_session));\n  if (*session_ptr == NULL) {\n    rv = NGHTTP2_ERR_NOMEM;\n    goto fail_session;\n  }\n\n  (*session_ptr)->mem = *mem;\n  mem = &(*session_ptr)->mem;\n\n  /* next_stream_id is initialized in either\n     nghttp2_session_client_new2 or nghttp2_session_server_new2 */\n\n  nghttp2_stream_init(&(*session_ptr)->root, 0, NGHTTP2_STREAM_FLAG_NONE,\n                      NGHTTP2_STREAM_IDLE, NGHTTP2_DEFAULT_WEIGHT, 0, 0, NULL,\n                      mem);\n\n  (*session_ptr)->remote_window_size = NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE;\n  (*session_ptr)->recv_window_size = 0;\n  (*session_ptr)->consumed_size = 0;\n  (*session_ptr)->recv_reduction = 0;\n  (*session_ptr)->local_window_size = NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE;\n\n  (*session_ptr)->goaway_flags = NGHTTP2_GOAWAY_NONE;\n  (*session_ptr)->local_last_stream_id = (1u << 31) - 1;\n  (*session_ptr)->remote_last_stream_id = (1u << 31) - 1;\n\n  (*session_ptr)->pending_local_max_concurrent_stream =\n      NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS;\n  (*session_ptr)->pending_enable_push = 1;\n\n  if (server) {\n    (*session_ptr)->server = 1;\n  }\n\n  init_settings(&(*session_ptr)->remote_settings);\n  init_settings(&(*session_ptr)->local_settings);\n\n  (*session_ptr)->max_incoming_reserved_streams =\n      NGHTTP2_MAX_INCOMING_RESERVED_STREAMS;\n\n  /* Limit max outgoing concurrent streams to sensible value */\n  (*session_ptr)->remote_settings.max_concurrent_streams = 100;\n\n  (*session_ptr)->max_send_header_block_length = NGHTTP2_MAX_HEADERSLEN;\n  (*session_ptr)->max_outbound_ack = NGHTTP2_DEFAULT_MAX_OBQ_FLOOD_ITEM;\n\n  if (option) {\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_AUTO_WINDOW_UPDATE) &&\n        option->no_auto_window_update) {\n\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_PEER_MAX_CONCURRENT_STREAMS) {\n\n      (*session_ptr)->remote_settings.max_concurrent_streams =\n          option->peer_max_concurrent_streams;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_MAX_RESERVED_REMOTE_STREAMS) {\n\n      (*session_ptr)->max_incoming_reserved_streams =\n          option->max_reserved_remote_streams;\n    }\n\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_RECV_CLIENT_MAGIC) &&\n        option->no_recv_client_magic) {\n\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_RECV_CLIENT_MAGIC;\n    }\n\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_HTTP_MESSAGING) &&\n        option->no_http_messaging) {\n\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_HTTP_MESSAGING;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_USER_RECV_EXT_TYPES) {\n      memcpy((*session_ptr)->user_recv_ext_types, option->user_recv_ext_types,\n             sizeof((*session_ptr)->user_recv_ext_types));\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_BUILTIN_RECV_EXT_TYPES) {\n      (*session_ptr)->builtin_recv_ext_types = option->builtin_recv_ext_types;\n    }\n\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_AUTO_PING_ACK) &&\n        option->no_auto_ping_ack) {\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_AUTO_PING_ACK;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_MAX_SEND_HEADER_BLOCK_LENGTH) {\n      (*session_ptr)->max_send_header_block_length =\n          option->max_send_header_block_length;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_MAX_DEFLATE_DYNAMIC_TABLE_SIZE) {\n      max_deflate_dynamic_table_size = option->max_deflate_dynamic_table_size;\n    }\n\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_CLOSED_STREAMS) &&\n        option->no_closed_streams) {\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_CLOSED_STREAMS;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_MAX_OUTBOUND_ACK) {\n      (*session_ptr)->max_outbound_ack = option->max_outbound_ack;\n    }\n  }\n\n  rv = nghttp2_hd_deflate_init2(&(*session_ptr)->hd_deflater,\n                                max_deflate_dynamic_table_size, mem);\n  if (rv != 0) {\n    goto fail_hd_deflater;\n  }\n  rv = nghttp2_hd_inflate_init(&(*session_ptr)->hd_inflater, mem);\n  if (rv != 0) {\n    goto fail_hd_inflater;\n  }\n  rv = nghttp2_map_init(&(*session_ptr)->streams, mem);\n  if (rv != 0) {\n    goto fail_map;\n  }\n\n  nbuffer = ((*session_ptr)->max_send_header_block_length +\n             NGHTTP2_FRAMEBUF_CHUNKLEN - 1) /\n            NGHTTP2_FRAMEBUF_CHUNKLEN;\n\n  if (nbuffer == 0) {\n    nbuffer = 1;\n  }\n\n  /* 1 for Pad Field. */\n  rv = nghttp2_bufs_init3(&(*session_ptr)->aob.framebufs,\n                          NGHTTP2_FRAMEBUF_CHUNKLEN, nbuffer, 1,\n                          NGHTTP2_FRAME_HDLEN + 1, mem);\n  if (rv != 0) {\n    goto fail_aob_framebuf;\n  }\n\n  active_outbound_item_reset(&(*session_ptr)->aob, mem);\n\n  (*session_ptr)->callbacks = *callbacks;\n  (*session_ptr)->user_data = user_data;\n\n  session_inbound_frame_reset(*session_ptr);\n\n  if (nghttp2_enable_strict_preface) {\n    nghttp2_inbound_frame *iframe = &(*session_ptr)->iframe;\n\n    if (server && ((*session_ptr)->opt_flags &\n                   NGHTTP2_OPTMASK_NO_RECV_CLIENT_MAGIC) == 0) {\n      iframe->state = NGHTTP2_IB_READ_CLIENT_MAGIC;\n      iframe->payloadleft = NGHTTP2_CLIENT_MAGIC_LEN;\n    } else {\n      iframe->state = NGHTTP2_IB_READ_FIRST_SETTINGS;\n    }\n\n    if (!server) {\n      (*session_ptr)->aob.state = NGHTTP2_OB_SEND_CLIENT_MAGIC;\n      nghttp2_bufs_add(&(*session_ptr)->aob.framebufs, NGHTTP2_CLIENT_MAGIC,\n                       NGHTTP2_CLIENT_MAGIC_LEN);\n    }\n  }\n\n  return 0;\n\nfail_aob_framebuf:\n  nghttp2_map_free(&(*session_ptr)->streams);\nfail_map:\n  nghttp2_hd_inflate_free(&(*session_ptr)->hd_inflater);\nfail_hd_inflater:\n  nghttp2_hd_deflate_free(&(*session_ptr)->hd_deflater);\nfail_hd_deflater:\n  nghttp2_mem_free(mem, *session_ptr);\nfail_session:\n  return rv;\n}",
        "func": "static int session_new(nghttp2_session **session_ptr,\n                       const nghttp2_session_callbacks *callbacks,\n                       void *user_data, int server,\n                       const nghttp2_option *option, nghttp2_mem *mem) {\n  int rv;\n  size_t nbuffer;\n  size_t max_deflate_dynamic_table_size =\n      NGHTTP2_HD_DEFAULT_MAX_DEFLATE_BUFFER_SIZE;\n\n  if (mem == NULL) {\n    mem = nghttp2_mem_default();\n  }\n\n  *session_ptr = nghttp2_mem_calloc(mem, 1, sizeof(nghttp2_session));\n  if (*session_ptr == NULL) {\n    rv = NGHTTP2_ERR_NOMEM;\n    goto fail_session;\n  }\n\n  (*session_ptr)->mem = *mem;\n  mem = &(*session_ptr)->mem;\n\n  /* next_stream_id is initialized in either\n     nghttp2_session_client_new2 or nghttp2_session_server_new2 */\n\n  nghttp2_stream_init(&(*session_ptr)->root, 0, NGHTTP2_STREAM_FLAG_NONE,\n                      NGHTTP2_STREAM_IDLE, NGHTTP2_DEFAULT_WEIGHT, 0, 0, NULL,\n                      mem);\n\n  (*session_ptr)->remote_window_size = NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE;\n  (*session_ptr)->recv_window_size = 0;\n  (*session_ptr)->consumed_size = 0;\n  (*session_ptr)->recv_reduction = 0;\n  (*session_ptr)->local_window_size = NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE;\n\n  (*session_ptr)->goaway_flags = NGHTTP2_GOAWAY_NONE;\n  (*session_ptr)->local_last_stream_id = (1u << 31) - 1;\n  (*session_ptr)->remote_last_stream_id = (1u << 31) - 1;\n\n  (*session_ptr)->pending_local_max_concurrent_stream =\n      NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS;\n  (*session_ptr)->pending_enable_push = 1;\n\n  if (server) {\n    (*session_ptr)->server = 1;\n  }\n\n  init_settings(&(*session_ptr)->remote_settings);\n  init_settings(&(*session_ptr)->local_settings);\n\n  (*session_ptr)->max_incoming_reserved_streams =\n      NGHTTP2_MAX_INCOMING_RESERVED_STREAMS;\n\n  /* Limit max outgoing concurrent streams to sensible value */\n  (*session_ptr)->remote_settings.max_concurrent_streams = 100;\n\n  (*session_ptr)->max_send_header_block_length = NGHTTP2_MAX_HEADERSLEN;\n  (*session_ptr)->max_outbound_ack = NGHTTP2_DEFAULT_MAX_OBQ_FLOOD_ITEM;\n  (*session_ptr)->max_settings = NGHTTP2_DEFAULT_MAX_SETTINGS;\n\n  if (option) {\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_AUTO_WINDOW_UPDATE) &&\n        option->no_auto_window_update) {\n\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_PEER_MAX_CONCURRENT_STREAMS) {\n\n      (*session_ptr)->remote_settings.max_concurrent_streams =\n          option->peer_max_concurrent_streams;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_MAX_RESERVED_REMOTE_STREAMS) {\n\n      (*session_ptr)->max_incoming_reserved_streams =\n          option->max_reserved_remote_streams;\n    }\n\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_RECV_CLIENT_MAGIC) &&\n        option->no_recv_client_magic) {\n\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_RECV_CLIENT_MAGIC;\n    }\n\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_HTTP_MESSAGING) &&\n        option->no_http_messaging) {\n\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_HTTP_MESSAGING;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_USER_RECV_EXT_TYPES) {\n      memcpy((*session_ptr)->user_recv_ext_types, option->user_recv_ext_types,\n             sizeof((*session_ptr)->user_recv_ext_types));\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_BUILTIN_RECV_EXT_TYPES) {\n      (*session_ptr)->builtin_recv_ext_types = option->builtin_recv_ext_types;\n    }\n\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_AUTO_PING_ACK) &&\n        option->no_auto_ping_ack) {\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_AUTO_PING_ACK;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_MAX_SEND_HEADER_BLOCK_LENGTH) {\n      (*session_ptr)->max_send_header_block_length =\n          option->max_send_header_block_length;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_MAX_DEFLATE_DYNAMIC_TABLE_SIZE) {\n      max_deflate_dynamic_table_size = option->max_deflate_dynamic_table_size;\n    }\n\n    if ((option->opt_set_mask & NGHTTP2_OPT_NO_CLOSED_STREAMS) &&\n        option->no_closed_streams) {\n      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_CLOSED_STREAMS;\n    }\n\n    if (option->opt_set_mask & NGHTTP2_OPT_MAX_OUTBOUND_ACK) {\n      (*session_ptr)->max_outbound_ack = option->max_outbound_ack;\n    }\n\n    if ((option->opt_set_mask & NGHTTP2_OPT_MAX_SETTINGS) &&\n        option->max_settings) {\n      (*session_ptr)->max_settings = option->max_settings;\n    }\n  }\n\n  rv = nghttp2_hd_deflate_init2(&(*session_ptr)->hd_deflater,\n                                max_deflate_dynamic_table_size, mem);\n  if (rv != 0) {\n    goto fail_hd_deflater;\n  }\n  rv = nghttp2_hd_inflate_init(&(*session_ptr)->hd_inflater, mem);\n  if (rv != 0) {\n    goto fail_hd_inflater;\n  }\n  rv = nghttp2_map_init(&(*session_ptr)->streams, mem);\n  if (rv != 0) {\n    goto fail_map;\n  }\n\n  nbuffer = ((*session_ptr)->max_send_header_block_length +\n             NGHTTP2_FRAMEBUF_CHUNKLEN - 1) /\n            NGHTTP2_FRAMEBUF_CHUNKLEN;\n\n  if (nbuffer == 0) {\n    nbuffer = 1;\n  }\n\n  /* 1 for Pad Field. */\n  rv = nghttp2_bufs_init3(&(*session_ptr)->aob.framebufs,\n                          NGHTTP2_FRAMEBUF_CHUNKLEN, nbuffer, 1,\n                          NGHTTP2_FRAME_HDLEN + 1, mem);\n  if (rv != 0) {\n    goto fail_aob_framebuf;\n  }\n\n  active_outbound_item_reset(&(*session_ptr)->aob, mem);\n\n  (*session_ptr)->callbacks = *callbacks;\n  (*session_ptr)->user_data = user_data;\n\n  session_inbound_frame_reset(*session_ptr);\n\n  if (nghttp2_enable_strict_preface) {\n    nghttp2_inbound_frame *iframe = &(*session_ptr)->iframe;\n\n    if (server && ((*session_ptr)->opt_flags &\n                   NGHTTP2_OPTMASK_NO_RECV_CLIENT_MAGIC) == 0) {\n      iframe->state = NGHTTP2_IB_READ_CLIENT_MAGIC;\n      iframe->payloadleft = NGHTTP2_CLIENT_MAGIC_LEN;\n    } else {\n      iframe->state = NGHTTP2_IB_READ_FIRST_SETTINGS;\n    }\n\n    if (!server) {\n      (*session_ptr)->aob.state = NGHTTP2_OB_SEND_CLIENT_MAGIC;\n      nghttp2_bufs_add(&(*session_ptr)->aob.framebufs, NGHTTP2_CLIENT_MAGIC,\n                       NGHTTP2_CLIENT_MAGIC_LEN);\n    }\n  }\n\n  return 0;\n\nfail_aob_framebuf:\n  nghttp2_map_free(&(*session_ptr)->streams);\nfail_map:\n  nghttp2_hd_inflate_free(&(*session_ptr)->hd_inflater);\nfail_hd_inflater:\n  nghttp2_hd_deflate_free(&(*session_ptr)->hd_deflater);\nfail_hd_deflater:\n  nghttp2_mem_free(mem, *session_ptr);\nfail_session:\n  return rv;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -56,6 +56,7 @@\n \n   (*session_ptr)->max_send_header_block_length = NGHTTP2_MAX_HEADERSLEN;\n   (*session_ptr)->max_outbound_ack = NGHTTP2_DEFAULT_MAX_OBQ_FLOOD_ITEM;\n+  (*session_ptr)->max_settings = NGHTTP2_DEFAULT_MAX_SETTINGS;\n \n   if (option) {\n     if ((option->opt_set_mask & NGHTTP2_OPT_NO_AUTO_WINDOW_UPDATE) &&\n@@ -118,6 +119,11 @@\n \n     if (option->opt_set_mask & NGHTTP2_OPT_MAX_OUTBOUND_ACK) {\n       (*session_ptr)->max_outbound_ack = option->max_outbound_ack;\n+    }\n+\n+    if ((option->opt_set_mask & NGHTTP2_OPT_MAX_SETTINGS) &&\n+        option->max_settings) {\n+      (*session_ptr)->max_settings = option->max_settings;\n     }\n   }\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  (*session_ptr)->max_settings = NGHTTP2_DEFAULT_MAX_SETTINGS;",
                "    }",
                "",
                "    if ((option->opt_set_mask & NGHTTP2_OPT_MAX_SETTINGS) &&",
                "        option->max_settings) {",
                "      (*session_ptr)->max_settings = option->max_settings;"
            ]
        }
    }
]