[
    {
        "cve_id": "CVE-2019-3560",
        "func_name": "facebookincubator/fizz/PlaintextReadRecordLayer::read",
        "description": "An improperly performed length calculation on a buffer in PlaintextRecordLayer could lead to an infinite loop and denial-of-service based on user input. This issue affected versions of fizz prior to v2019.03.04.00.",
        "git_url": "https://github.com/facebookincubator/fizz/commit/40bbb161e72fb609608d53b9d64c56bb961a6ee2",
        "commit_title": "Avoid arithmetic operation on uint16 read from the wire.",
        "commit_text": " Summary: This could overflow previously.  CVE-2019-3560  Reviewed By: yfeldblum  Differential Revision: D14152362  fbshipit-source-id: c0ebb3fc59b49c7c23e6bcb90458c19cd891be65",
        "func_before": "folly::Optional<TLSMessage> PlaintextReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  while (true) {\n    folly::io::Cursor cursor(buf.front());\n\n    if (buf.empty() || !cursor.canAdvance(kPlaintextHeaderSize)) {\n      return folly::none;\n    }\n\n    TLSMessage msg;\n    msg.type = static_cast<ContentType>(cursor.readBE<ContentTypeType>());\n\n    if (skipEncryptedRecords_) {\n      if (msg.type == ContentType::application_data) {\n        cursor.skip(sizeof(ProtocolVersion));\n        auto length = cursor.readBE<uint16_t>();\n        if (buf.chainLength() < (cursor - buf.front()) + length) {\n          return folly::none;\n        }\n        length +=\n            sizeof(ContentType) + sizeof(ProtocolVersion) + sizeof(uint16_t);\n        buf.trimStart(length);\n        continue;\n      } else if (msg.type != ContentType::change_cipher_spec) {\n        skipEncryptedRecords_ = false;\n      }\n    }\n\n    switch (msg.type) {\n      case ContentType::handshake:\n      case ContentType::alert:\n        break;\n      case ContentType::change_cipher_spec:\n        break;\n      default:\n        throw std::runtime_error(folly::to<std::string>(\n            \"received plaintext content type \",\n            static_cast<ContentTypeType>(msg.type),\n            \", header: \",\n            folly::hexlify(buf.splitAtMost(10)->coalesce())));\n    }\n\n    receivedRecordVersion_ =\n        static_cast<ProtocolVersion>(cursor.readBE<ProtocolVersionType>());\n\n    auto length = cursor.readBE<uint16_t>();\n    if (length > kMaxPlaintextRecordSize) {\n      throw std::runtime_error(\"received too long plaintext record\");\n    }\n    if (length == 0) {\n      throw std::runtime_error(\"received empty plaintext record\");\n    }\n    if (buf.chainLength() < (cursor - buf.front()) + length) {\n      return folly::none;\n    }\n\n    cursor.clone(msg.fragment, length);\n\n    buf.trimStart(cursor - buf.front());\n\n    if (msg.type == ContentType::change_cipher_spec) {\n      msg.fragment->coalesce();\n      if (msg.fragment->length() == 1 && *msg.fragment->data() == 0x01) {\n        continue;\n      } else {\n        throw FizzException(\n            \"received ccs\", AlertDescription::illegal_parameter);\n      }\n    }\n\n    return std::move(msg);\n  }\n}",
        "func": "folly::Optional<TLSMessage> PlaintextReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  while (true) {\n    folly::io::Cursor cursor(buf.front());\n\n    if (buf.empty() || !cursor.canAdvance(kPlaintextHeaderSize)) {\n      return folly::none;\n    }\n\n    TLSMessage msg;\n    msg.type = static_cast<ContentType>(cursor.readBE<ContentTypeType>());\n\n    if (skipEncryptedRecords_) {\n      if (msg.type == ContentType::application_data) {\n        cursor.skip(sizeof(ProtocolVersion));\n        auto length = cursor.readBE<uint16_t>();\n        if (buf.chainLength() < (cursor - buf.front()) + length) {\n          return folly::none;\n        }\n        buf.trimStart(static_cast<size_t>(kPlaintextHeaderSize) + length);\n        continue;\n      } else if (msg.type != ContentType::change_cipher_spec) {\n        skipEncryptedRecords_ = false;\n      }\n    }\n\n    switch (msg.type) {\n      case ContentType::handshake:\n      case ContentType::alert:\n        break;\n      case ContentType::change_cipher_spec:\n        break;\n      default:\n        throw std::runtime_error(folly::to<std::string>(\n            \"received plaintext content type \",\n            static_cast<ContentTypeType>(msg.type),\n            \", header: \",\n            folly::hexlify(buf.splitAtMost(10)->coalesce())));\n    }\n\n    receivedRecordVersion_ =\n        static_cast<ProtocolVersion>(cursor.readBE<ProtocolVersionType>());\n\n    auto length = cursor.readBE<uint16_t>();\n    if (length > kMaxPlaintextRecordSize) {\n      throw std::runtime_error(\"received too long plaintext record\");\n    }\n    if (length == 0) {\n      throw std::runtime_error(\"received empty plaintext record\");\n    }\n    if (buf.chainLength() < (cursor - buf.front()) + length) {\n      return folly::none;\n    }\n\n    cursor.clone(msg.fragment, length);\n\n    buf.trimStart(cursor - buf.front());\n\n    if (msg.type == ContentType::change_cipher_spec) {\n      msg.fragment->coalesce();\n      if (msg.fragment->length() == 1 && *msg.fragment->data() == 0x01) {\n        continue;\n      } else {\n        throw FizzException(\n            \"received ccs\", AlertDescription::illegal_parameter);\n      }\n    }\n\n    return std::move(msg);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,9 +17,7 @@\n         if (buf.chainLength() < (cursor - buf.front()) + length) {\n           return folly::none;\n         }\n-        length +=\n-            sizeof(ContentType) + sizeof(ProtocolVersion) + sizeof(uint16_t);\n-        buf.trimStart(length);\n+        buf.trimStart(static_cast<size_t>(kPlaintextHeaderSize) + length);\n         continue;\n       } else if (msg.type != ContentType::change_cipher_spec) {\n         skipEncryptedRecords_ = false;",
        "diff_line_info": {
            "deleted_lines": [
                "        length +=",
                "            sizeof(ContentType) + sizeof(ProtocolVersion) + sizeof(uint16_t);",
                "        buf.trimStart(length);"
            ],
            "added_lines": [
                "        buf.trimStart(static_cast<size_t>(kPlaintextHeaderSize) + length);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-14241",
        "func_name": "haproxy/http_manage_server_side_cookies",
        "description": "HAProxy through 2.0.2 allows attackers to cause a denial of service (ha_panic) via vectors related to htx_manage_client_side_cookies in proto_htx.c.",
        "git_url": "https://github.com/haproxy/haproxy/commit/f0f42389772b2303b162e929449a36b33e181c5f",
        "commit_title": "BUG/CRITICAL: http_ana: Fix parsing of malformed cookies which start by a delimiter",
        "commit_text": " When client-side or server-side cookies are parsed, HAProxy enters in an infinite loop if a Cookie/Set-Cookie header value starts by a delimiter (a colon or a semicolon). Depending on the operating system, the service may become degraded, unresponsive, or may trigger haproxy's watchdog causing a service stop or automatic restart.  To fix this bug, in the loop parsing the attributes, we must be sure to always skip delimiters once the first attribute-value pair was parsed, empty or not. The credit for the fix goes to Olivier.  CVE-2019-14241 was assigned to this bug. This patch fixes the Github issue #181.  This patch must be backported to 2.0 and 1.9. However, the patch will have to be adapted.",
        "func_before": "static void http_manage_server_side_cookies(struct stream *s, struct channel *res)\n{\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct htx *htx;\n\tstruct http_hdr_ctx ctx;\n\tstruct server *srv;\n\tchar *hdr_beg, *hdr_end;\n\tchar *prev, *att_beg, *att_end, *equal, *val_beg, *val_end, *next;\n\tint is_cookie2 = 0;\n\n\thtx = htxbuf(&res->buf);\n\n\tctx.blk = NULL;\n\twhile (1) {\n\t\tif (!http_find_header(htx, ist(\"Set-Cookie\"), &ctx, 1)) {\n\t\t\tif (!http_find_header(htx, ist(\"Set-Cookie2\"), &ctx, 1))\n\t\t\t\tbreak;\n\t\t\tis_cookie2 = 1;\n\t\t}\n\n\t\t/* OK, right now we know we have a Set-Cookie* at hdr_beg, and\n\t\t * <prev> points to the colon.\n\t\t */\n\t\ttxn->flags |= TX_SCK_PRESENT;\n\n\t\t/* Maybe we only wanted to see if there was a Set-Cookie (eg:\n\t\t * check-cache is enabled) and we are not interested in checking\n\t\t * them. Warning, the cookie capture is declared in the frontend.\n\t\t */\n\t\tif (s->be->cookie_name == NULL && sess->fe->capture_name == NULL)\n\t\t\tbreak;\n\n\t\t/* OK so now we know we have to process this response cookie.\n\t\t * The format of the Set-Cookie header is slightly different\n\t\t * from the format of the Cookie header in that it does not\n\t\t * support the comma as a cookie delimiter (thus the header\n\t\t * cannot be folded) because the Expires attribute described in\n\t\t * the original Netscape's spec may contain an unquoted date\n\t\t * with a comma inside. We have to live with this because\n\t\t * many browsers don't support Max-Age and some browsers don't\n\t\t * support quoted strings. However the Set-Cookie2 header is\n\t\t * clean.\n\t\t *\n\t\t * We have to keep multiple pointers in order to support cookie\n\t\t * removal at the beginning, middle or end of header without\n\t\t * corrupting the header (in case of set-cookie2). A special\n\t\t * pointer, <scav> points to the beginning of the set-cookie-av\n\t\t * fields after the first semi-colon. The <next> pointer points\n\t\t * either to the end of line (set-cookie) or next unquoted comma\n\t\t * (set-cookie2). All of these headers are valid :\n\t\t *\n\t\t * hdr_beg                                                  hdr_end\n\t\t * |                                                           |\n\t\t * v                                                           |\n\t\t * NAME1  =  VALUE 1  ; Secure; Path=\"/\"                       |\n\t\t * NAME=VALUE; Secure; Expires=Thu, 01-Jan-1970 00:00:01 GMT   v\n\t\t * NAME = VALUE ; Secure; Expires=Thu, 01-Jan-1970 00:00:01 GMT\n\t\t * NAME1 = VALUE 1 ; Max-Age=0, NAME2=VALUE2; Discard\n\t\t * | |   | | |     | |          |\n\t\t * | |   | | |     | |          +-> next\n\t\t * | |   | | |     | +------------> scav\n\t\t * | |   | | |     +--------------> val_end\n\t\t * | |   | | +--------------------> val_beg\n\t\t * | |   | +----------------------> equal\n\t\t * | |   +------------------------> att_end\n\t\t * | +----------------------------> att_beg\n\t\t * +------------------------------> prev\n\t\t * -------------------------------> hdr_beg\n\t\t */\n\t\thdr_beg = ctx.value.ptr;\n\t\thdr_end = hdr_beg + ctx.value.len;\n\t\tfor (prev = hdr_beg; prev < hdr_end; prev = next) {\n\n\t\t\t/* Iterate through all cookies on this line */\n\n\t\t\t/* find att_beg */\n\t\t\tatt_beg = prev;\n\t\t\tif (prev > hdr_beg)\n\t\t\t\tatt_beg++;\n\n\t\t\twhile (att_beg < hdr_end && HTTP_IS_SPHT(*att_beg))\n\t\t\t\tatt_beg++;\n\n\t\t\t/* find att_end : this is the first character after the last non\n\t\t\t * space before the equal. It may be equal to hdr_end.\n\t\t\t */\n\t\t\tequal = att_end = att_beg;\n\n\t\t\twhile (equal < hdr_end) {\n\t\t\t\tif (*equal == '=' || *equal == ';' || (is_cookie2 && *equal == ','))\n\t\t\t\t\tbreak;\n\t\t\t\tif (HTTP_IS_SPHT(*equal++))\n\t\t\t\t\tcontinue;\n\t\t\t\tatt_end = equal;\n\t\t\t}\n\n\t\t\t/* here, <equal> points to '=', a delimitor or the end. <att_end>\n\t\t\t * is between <att_beg> and <equal>, both may be identical.\n\t\t\t */\n\n\t\t\t/* look for end of cookie if there is an equal sign */\n\t\t\tif (equal < hdr_end && *equal == '=') {\n\t\t\t\t/* look for the beginning of the value */\n\t\t\t\tval_beg = equal + 1;\n\t\t\t\twhile (val_beg < hdr_end && HTTP_IS_SPHT(*val_beg))\n\t\t\t\t\tval_beg++;\n\n\t\t\t\t/* find the end of the value, respecting quotes */\n\t\t\t\tnext = http_find_cookie_value_end(val_beg, hdr_end);\n\n\t\t\t\t/* make val_end point to the first white space or delimitor after the value */\n\t\t\t\tval_end = next;\n\t\t\t\twhile (val_end > val_beg && HTTP_IS_SPHT(*(val_end - 1)))\n\t\t\t\t\tval_end--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* <equal> points to next comma, semi-colon or EOL */\n\t\t\t\tval_beg = val_end = next = equal;\n\t\t\t}\n\n\t\t\tif (next < hdr_end) {\n\t\t\t\t/* Set-Cookie2 supports multiple cookies, and <next> points to\n\t\t\t\t * a colon or semi-colon before the end. So skip all attr-value\n\t\t\t\t * pairs and look for the next comma. For Set-Cookie, since\n\t\t\t\t * commas are permitted in values, skip to the end.\n\t\t\t\t */\n\t\t\t\tif (is_cookie2)\n\t\t\t\t\tnext = http_find_hdr_value_end(next, hdr_end);\n\t\t\t\telse\n\t\t\t\t\tnext = hdr_end;\n\t\t\t}\n\n\t\t\t/* Now everything is as on the diagram above */\n\n\t\t\t/* Ignore cookies with no equal sign */\n\t\t\tif (equal == val_end)\n\t\t\t\tcontinue;\n\n\t\t\t/* If there are spaces around the equal sign, we need to\n\t\t\t * strip them otherwise we'll get trouble for cookie captures,\n\t\t\t * or even for rewrites. Since this happens extremely rarely,\n\t\t\t * it does not hurt performance.\n\t\t\t */\n\t\t\tif (unlikely(att_end != equal || val_beg > equal + 1)) {\n\t\t\t\tint stripped_before = 0;\n\t\t\t\tint stripped_after = 0;\n\n\t\t\t\tif (att_end != equal) {\n\t\t\t\t\tmemmove(att_end, equal, hdr_end - equal);\n\t\t\t\t\tstripped_before = (att_end - equal);\n\t\t\t\t\tequal   += stripped_before;\n\t\t\t\t\tval_beg += stripped_before;\n\t\t\t\t}\n\n\t\t\t\tif (val_beg > equal + 1) {\n\t\t\t\t\tmemmove(equal + 1, val_beg, hdr_end + stripped_before - val_beg);\n\t\t\t\t\tstripped_after = (equal + 1) - val_beg;\n\t\t\t\t\tval_beg += stripped_after;\n\t\t\t\t\tstripped_before += stripped_after;\n\t\t\t\t}\n\n\t\t\t\tval_end      += stripped_before;\n\t\t\t\tnext         += stripped_before;\n\t\t\t\thdr_end      += stripped_before;\n\n\t\t\t\thtx_change_blk_value_len(htx, ctx.blk, hdr_end - hdr_beg);\n\t\t\t\tctx.value.len = hdr_end - hdr_beg;\n\t\t\t}\n\n\t\t\t/* First, let's see if we want to capture this cookie. We check\n\t\t\t * that we don't already have a server side cookie, because we\n\t\t\t * can only capture one. Also as an optimisation, we ignore\n\t\t\t * cookies shorter than the declared name.\n\t\t\t */\n\t\t\tif (sess->fe->capture_name != NULL &&\n\t\t\t    txn->srv_cookie == NULL &&\n\t\t\t    (val_end - att_beg >= sess->fe->capture_namelen) &&\n\t\t\t    memcmp(att_beg, sess->fe->capture_name, sess->fe->capture_namelen) == 0) {\n\t\t\t\tint log_len = val_end - att_beg;\n\t\t\t\tif ((txn->srv_cookie = pool_alloc(pool_head_capture)) == NULL) {\n\t\t\t\t\tha_alert(\"HTTP logging : out of memory.\\n\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (log_len > sess->fe->capture_len)\n\t\t\t\t\t\tlog_len = sess->fe->capture_len;\n\t\t\t\t\tmemcpy(txn->srv_cookie, att_beg, log_len);\n\t\t\t\t\ttxn->srv_cookie[log_len] = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsrv = objt_server(s->target);\n\t\t\t/* now check if we need to process it for persistence */\n\t\t\tif (!(s->flags & SF_IGNORE_PRST) &&\n\t\t\t    (att_end - att_beg == s->be->cookie_len) && (s->be->cookie_name != NULL) &&\n\t\t\t    (memcmp(att_beg, s->be->cookie_name, att_end - att_beg) == 0)) {\n\t\t\t\t/* assume passive cookie by default */\n\t\t\t\ttxn->flags &= ~TX_SCK_MASK;\n\t\t\t\ttxn->flags |= TX_SCK_FOUND;\n\n\t\t\t\t/* If the cookie is in insert mode on a known server, we'll delete\n\t\t\t\t * this occurrence because we'll insert another one later.\n\t\t\t\t * We'll delete it too if the \"indirect\" option is set and we're in\n\t\t\t\t * a direct access.\n\t\t\t\t */\n\t\t\t\tif (s->be->ck_opts & PR_CK_PSV) {\n\t\t\t\t\t/* The \"preserve\" flag was set, we don't want to touch the\n\t\t\t\t\t * server's cookie.\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t\telse if ((srv && (s->be->ck_opts & PR_CK_INS)) ||\n\t\t\t\t    ((s->flags & SF_DIRECT) && (s->be->ck_opts & PR_CK_IND))) {\n\t\t\t\t\t/* this cookie must be deleted */\n\t\t\t\t\tif (prev == hdr_beg && next == hdr_end) {\n\t\t\t\t\t\t/* whole header */\n\t\t\t\t\t\thttp_remove_header(htx, &ctx);\n\t\t\t\t\t\t/* note: while both invalid now, <next> and <hdr_end>\n\t\t\t\t\t\t * are still equal, so the for() will stop as expected.\n\t\t\t\t\t\t */\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* just remove the value */\n\t\t\t\t\t\tint delta = http_del_hdr_value(hdr_beg, hdr_end, &prev, next);\n\t\t\t\t\t\tnext      = prev;\n\t\t\t\t\t\thdr_end  += delta;\n\t\t\t\t\t}\n\t\t\t\t\ttxn->flags &= ~TX_SCK_MASK;\n\t\t\t\t\ttxn->flags |= TX_SCK_DELETED;\n\t\t\t\t\t/* and go on with next cookie */\n\t\t\t\t}\n\t\t\t\telse if (srv && srv->cookie && (s->be->ck_opts & PR_CK_RW)) {\n\t\t\t\t\t/* replace bytes val_beg->val_end with the cookie name associated\n\t\t\t\t\t * with this server since we know it.\n\t\t\t\t\t */\n\t\t\t\t\tint sliding, delta;\n\n\t\t\t\t\tctx.value = ist2(val_beg, val_end - val_beg);\n\t\t\t\t        ctx.lws_before = ctx.lws_after = 0;\n\t\t\t\t\thttp_replace_header_value(htx, &ctx, ist2(srv->cookie, srv->cklen));\n\t\t\t\t\tdelta     = srv->cklen - (val_end - val_beg);\n\t\t\t\t\tsliding   = (ctx.value.ptr - val_beg);\n\t\t\t\t\thdr_beg  += sliding;\n\t\t\t\t\tval_beg  += sliding;\n\t\t\t\t\tnext     += sliding + delta;\n\t\t\t\t\thdr_end  += sliding + delta;\n\n\t\t\t\t\ttxn->flags &= ~TX_SCK_MASK;\n\t\t\t\t\ttxn->flags |= TX_SCK_REPLACED;\n\t\t\t\t}\n\t\t\t\telse if (srv && srv->cookie && (s->be->ck_opts & PR_CK_PFX)) {\n\t\t\t\t\t/* insert the cookie name associated with this server\n\t\t\t\t\t * before existing cookie, and insert a delimiter between them..\n\t\t\t\t\t */\n\t\t\t\t\tint sliding, delta;\n\t\t\t\t\tctx.value = ist2(val_beg, 0);\n\t\t\t\t        ctx.lws_before = ctx.lws_after = 0;\n\t\t\t\t\thttp_replace_header_value(htx, &ctx, ist2(srv->cookie, srv->cklen + 1));\n\t\t\t\t\tdelta     = srv->cklen + 1;\n\t\t\t\t\tsliding   = (ctx.value.ptr - val_beg);\n\t\t\t\t\thdr_beg  += sliding;\n\t\t\t\t\tval_beg  += sliding;\n\t\t\t\t\tnext     += sliding + delta;\n\t\t\t\t\thdr_end  += sliding + delta;\n\n\t\t\t\t\tval_beg[srv->cklen] = COOKIE_DELIM;\n\t\t\t\t\ttxn->flags &= ~TX_SCK_MASK;\n\t\t\t\t\ttxn->flags |= TX_SCK_REPLACED;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* that's done for this cookie, check the next one on the same\n\t\t\t * line when next != hdr_end (only if is_cookie2).\n\t\t\t */\n\t\t}\n\t}\n}",
        "func": "static void http_manage_server_side_cookies(struct stream *s, struct channel *res)\n{\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct htx *htx;\n\tstruct http_hdr_ctx ctx;\n\tstruct server *srv;\n\tchar *hdr_beg, *hdr_end;\n\tchar *prev, *att_beg, *att_end, *equal, *val_beg, *val_end, *next;\n\tint is_cookie2 = 0;\n\n\thtx = htxbuf(&res->buf);\n\n\tctx.blk = NULL;\n\twhile (1) {\n\t\tint is_first = 1;\n\n\t\tif (!http_find_header(htx, ist(\"Set-Cookie\"), &ctx, 1)) {\n\t\t\tif (!http_find_header(htx, ist(\"Set-Cookie2\"), &ctx, 1))\n\t\t\t\tbreak;\n\t\t\tis_cookie2 = 1;\n\t\t}\n\n\t\t/* OK, right now we know we have a Set-Cookie* at hdr_beg, and\n\t\t * <prev> points to the colon.\n\t\t */\n\t\ttxn->flags |= TX_SCK_PRESENT;\n\n\t\t/* Maybe we only wanted to see if there was a Set-Cookie (eg:\n\t\t * check-cache is enabled) and we are not interested in checking\n\t\t * them. Warning, the cookie capture is declared in the frontend.\n\t\t */\n\t\tif (s->be->cookie_name == NULL && sess->fe->capture_name == NULL)\n\t\t\tbreak;\n\n\t\t/* OK so now we know we have to process this response cookie.\n\t\t * The format of the Set-Cookie header is slightly different\n\t\t * from the format of the Cookie header in that it does not\n\t\t * support the comma as a cookie delimiter (thus the header\n\t\t * cannot be folded) because the Expires attribute described in\n\t\t * the original Netscape's spec may contain an unquoted date\n\t\t * with a comma inside. We have to live with this because\n\t\t * many browsers don't support Max-Age and some browsers don't\n\t\t * support quoted strings. However the Set-Cookie2 header is\n\t\t * clean.\n\t\t *\n\t\t * We have to keep multiple pointers in order to support cookie\n\t\t * removal at the beginning, middle or end of header without\n\t\t * corrupting the header (in case of set-cookie2). A special\n\t\t * pointer, <scav> points to the beginning of the set-cookie-av\n\t\t * fields after the first semi-colon. The <next> pointer points\n\t\t * either to the end of line (set-cookie) or next unquoted comma\n\t\t * (set-cookie2). All of these headers are valid :\n\t\t *\n\t\t * hdr_beg                                                  hdr_end\n\t\t * |                                                           |\n\t\t * v                                                           |\n\t\t * NAME1  =  VALUE 1  ; Secure; Path=\"/\"                       |\n\t\t * NAME=VALUE; Secure; Expires=Thu, 01-Jan-1970 00:00:01 GMT   v\n\t\t * NAME = VALUE ; Secure; Expires=Thu, 01-Jan-1970 00:00:01 GMT\n\t\t * NAME1 = VALUE 1 ; Max-Age=0, NAME2=VALUE2; Discard\n\t\t * | |   | | |     | |          |\n\t\t * | |   | | |     | |          +-> next\n\t\t * | |   | | |     | +------------> scav\n\t\t * | |   | | |     +--------------> val_end\n\t\t * | |   | | +--------------------> val_beg\n\t\t * | |   | +----------------------> equal\n\t\t * | |   +------------------------> att_end\n\t\t * | +----------------------------> att_beg\n\t\t * +------------------------------> prev\n\t\t * -------------------------------> hdr_beg\n\t\t */\n\t\thdr_beg = ctx.value.ptr;\n\t\thdr_end = hdr_beg + ctx.value.len;\n\t\tfor (prev = hdr_beg; prev < hdr_end; prev = next) {\n\n\t\t\t/* Iterate through all cookies on this line */\n\n\t\t\t/* find att_beg */\n\t\t\tatt_beg = prev;\n\t\t\tif (!is_first)\n\t\t\t\tatt_beg++;\n\t\t\tis_first = 0;\n\n\t\t\twhile (att_beg < hdr_end && HTTP_IS_SPHT(*att_beg))\n\t\t\t\tatt_beg++;\n\n\t\t\t/* find att_end : this is the first character after the last non\n\t\t\t * space before the equal. It may be equal to hdr_end.\n\t\t\t */\n\t\t\tequal = att_end = att_beg;\n\n\t\t\twhile (equal < hdr_end) {\n\t\t\t\tif (*equal == '=' || *equal == ';' || (is_cookie2 && *equal == ','))\n\t\t\t\t\tbreak;\n\t\t\t\tif (HTTP_IS_SPHT(*equal++))\n\t\t\t\t\tcontinue;\n\t\t\t\tatt_end = equal;\n\t\t\t}\n\n\t\t\t/* here, <equal> points to '=', a delimitor or the end. <att_end>\n\t\t\t * is between <att_beg> and <equal>, both may be identical.\n\t\t\t */\n\n\t\t\t/* look for end of cookie if there is an equal sign */\n\t\t\tif (equal < hdr_end && *equal == '=') {\n\t\t\t\t/* look for the beginning of the value */\n\t\t\t\tval_beg = equal + 1;\n\t\t\t\twhile (val_beg < hdr_end && HTTP_IS_SPHT(*val_beg))\n\t\t\t\t\tval_beg++;\n\n\t\t\t\t/* find the end of the value, respecting quotes */\n\t\t\t\tnext = http_find_cookie_value_end(val_beg, hdr_end);\n\n\t\t\t\t/* make val_end point to the first white space or delimitor after the value */\n\t\t\t\tval_end = next;\n\t\t\t\twhile (val_end > val_beg && HTTP_IS_SPHT(*(val_end - 1)))\n\t\t\t\t\tval_end--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* <equal> points to next comma, semi-colon or EOL */\n\t\t\t\tval_beg = val_end = next = equal;\n\t\t\t}\n\n\t\t\tif (next < hdr_end) {\n\t\t\t\t/* Set-Cookie2 supports multiple cookies, and <next> points to\n\t\t\t\t * a colon or semi-colon before the end. So skip all attr-value\n\t\t\t\t * pairs and look for the next comma. For Set-Cookie, since\n\t\t\t\t * commas are permitted in values, skip to the end.\n\t\t\t\t */\n\t\t\t\tif (is_cookie2)\n\t\t\t\t\tnext = http_find_hdr_value_end(next, hdr_end);\n\t\t\t\telse\n\t\t\t\t\tnext = hdr_end;\n\t\t\t}\n\n\t\t\t/* Now everything is as on the diagram above */\n\n\t\t\t/* Ignore cookies with no equal sign */\n\t\t\tif (equal == val_end)\n\t\t\t\tcontinue;\n\n\t\t\t/* If there are spaces around the equal sign, we need to\n\t\t\t * strip them otherwise we'll get trouble for cookie captures,\n\t\t\t * or even for rewrites. Since this happens extremely rarely,\n\t\t\t * it does not hurt performance.\n\t\t\t */\n\t\t\tif (unlikely(att_end != equal || val_beg > equal + 1)) {\n\t\t\t\tint stripped_before = 0;\n\t\t\t\tint stripped_after = 0;\n\n\t\t\t\tif (att_end != equal) {\n\t\t\t\t\tmemmove(att_end, equal, hdr_end - equal);\n\t\t\t\t\tstripped_before = (att_end - equal);\n\t\t\t\t\tequal   += stripped_before;\n\t\t\t\t\tval_beg += stripped_before;\n\t\t\t\t}\n\n\t\t\t\tif (val_beg > equal + 1) {\n\t\t\t\t\tmemmove(equal + 1, val_beg, hdr_end + stripped_before - val_beg);\n\t\t\t\t\tstripped_after = (equal + 1) - val_beg;\n\t\t\t\t\tval_beg += stripped_after;\n\t\t\t\t\tstripped_before += stripped_after;\n\t\t\t\t}\n\n\t\t\t\tval_end      += stripped_before;\n\t\t\t\tnext         += stripped_before;\n\t\t\t\thdr_end      += stripped_before;\n\n\t\t\t\thtx_change_blk_value_len(htx, ctx.blk, hdr_end - hdr_beg);\n\t\t\t\tctx.value.len = hdr_end - hdr_beg;\n\t\t\t}\n\n\t\t\t/* First, let's see if we want to capture this cookie. We check\n\t\t\t * that we don't already have a server side cookie, because we\n\t\t\t * can only capture one. Also as an optimisation, we ignore\n\t\t\t * cookies shorter than the declared name.\n\t\t\t */\n\t\t\tif (sess->fe->capture_name != NULL &&\n\t\t\t    txn->srv_cookie == NULL &&\n\t\t\t    (val_end - att_beg >= sess->fe->capture_namelen) &&\n\t\t\t    memcmp(att_beg, sess->fe->capture_name, sess->fe->capture_namelen) == 0) {\n\t\t\t\tint log_len = val_end - att_beg;\n\t\t\t\tif ((txn->srv_cookie = pool_alloc(pool_head_capture)) == NULL) {\n\t\t\t\t\tha_alert(\"HTTP logging : out of memory.\\n\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (log_len > sess->fe->capture_len)\n\t\t\t\t\t\tlog_len = sess->fe->capture_len;\n\t\t\t\t\tmemcpy(txn->srv_cookie, att_beg, log_len);\n\t\t\t\t\ttxn->srv_cookie[log_len] = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsrv = objt_server(s->target);\n\t\t\t/* now check if we need to process it for persistence */\n\t\t\tif (!(s->flags & SF_IGNORE_PRST) &&\n\t\t\t    (att_end - att_beg == s->be->cookie_len) && (s->be->cookie_name != NULL) &&\n\t\t\t    (memcmp(att_beg, s->be->cookie_name, att_end - att_beg) == 0)) {\n\t\t\t\t/* assume passive cookie by default */\n\t\t\t\ttxn->flags &= ~TX_SCK_MASK;\n\t\t\t\ttxn->flags |= TX_SCK_FOUND;\n\n\t\t\t\t/* If the cookie is in insert mode on a known server, we'll delete\n\t\t\t\t * this occurrence because we'll insert another one later.\n\t\t\t\t * We'll delete it too if the \"indirect\" option is set and we're in\n\t\t\t\t * a direct access.\n\t\t\t\t */\n\t\t\t\tif (s->be->ck_opts & PR_CK_PSV) {\n\t\t\t\t\t/* The \"preserve\" flag was set, we don't want to touch the\n\t\t\t\t\t * server's cookie.\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t\telse if ((srv && (s->be->ck_opts & PR_CK_INS)) ||\n\t\t\t\t    ((s->flags & SF_DIRECT) && (s->be->ck_opts & PR_CK_IND))) {\n\t\t\t\t\t/* this cookie must be deleted */\n\t\t\t\t\tif (prev == hdr_beg && next == hdr_end) {\n\t\t\t\t\t\t/* whole header */\n\t\t\t\t\t\thttp_remove_header(htx, &ctx);\n\t\t\t\t\t\t/* note: while both invalid now, <next> and <hdr_end>\n\t\t\t\t\t\t * are still equal, so the for() will stop as expected.\n\t\t\t\t\t\t */\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* just remove the value */\n\t\t\t\t\t\tint delta = http_del_hdr_value(hdr_beg, hdr_end, &prev, next);\n\t\t\t\t\t\tnext      = prev;\n\t\t\t\t\t\thdr_end  += delta;\n\t\t\t\t\t}\n\t\t\t\t\ttxn->flags &= ~TX_SCK_MASK;\n\t\t\t\t\ttxn->flags |= TX_SCK_DELETED;\n\t\t\t\t\t/* and go on with next cookie */\n\t\t\t\t}\n\t\t\t\telse if (srv && srv->cookie && (s->be->ck_opts & PR_CK_RW)) {\n\t\t\t\t\t/* replace bytes val_beg->val_end with the cookie name associated\n\t\t\t\t\t * with this server since we know it.\n\t\t\t\t\t */\n\t\t\t\t\tint sliding, delta;\n\n\t\t\t\t\tctx.value = ist2(val_beg, val_end - val_beg);\n\t\t\t\t        ctx.lws_before = ctx.lws_after = 0;\n\t\t\t\t\thttp_replace_header_value(htx, &ctx, ist2(srv->cookie, srv->cklen));\n\t\t\t\t\tdelta     = srv->cklen - (val_end - val_beg);\n\t\t\t\t\tsliding   = (ctx.value.ptr - val_beg);\n\t\t\t\t\thdr_beg  += sliding;\n\t\t\t\t\tval_beg  += sliding;\n\t\t\t\t\tnext     += sliding + delta;\n\t\t\t\t\thdr_end  += sliding + delta;\n\n\t\t\t\t\ttxn->flags &= ~TX_SCK_MASK;\n\t\t\t\t\ttxn->flags |= TX_SCK_REPLACED;\n\t\t\t\t}\n\t\t\t\telse if (srv && srv->cookie && (s->be->ck_opts & PR_CK_PFX)) {\n\t\t\t\t\t/* insert the cookie name associated with this server\n\t\t\t\t\t * before existing cookie, and insert a delimiter between them..\n\t\t\t\t\t */\n\t\t\t\t\tint sliding, delta;\n\t\t\t\t\tctx.value = ist2(val_beg, 0);\n\t\t\t\t        ctx.lws_before = ctx.lws_after = 0;\n\t\t\t\t\thttp_replace_header_value(htx, &ctx, ist2(srv->cookie, srv->cklen + 1));\n\t\t\t\t\tdelta     = srv->cklen + 1;\n\t\t\t\t\tsliding   = (ctx.value.ptr - val_beg);\n\t\t\t\t\thdr_beg  += sliding;\n\t\t\t\t\tval_beg  += sliding;\n\t\t\t\t\tnext     += sliding + delta;\n\t\t\t\t\thdr_end  += sliding + delta;\n\n\t\t\t\t\tval_beg[srv->cklen] = COOKIE_DELIM;\n\t\t\t\t\ttxn->flags &= ~TX_SCK_MASK;\n\t\t\t\t\ttxn->flags |= TX_SCK_REPLACED;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* that's done for this cookie, check the next one on the same\n\t\t\t * line when next != hdr_end (only if is_cookie2).\n\t\t\t */\n\t\t}\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,8 @@\n \n \tctx.blk = NULL;\n \twhile (1) {\n+\t\tint is_first = 1;\n+\n \t\tif (!http_find_header(htx, ist(\"Set-Cookie\"), &ctx, 1)) {\n \t\t\tif (!http_find_header(htx, ist(\"Set-Cookie2\"), &ctx, 1))\n \t\t\t\tbreak;\n@@ -76,8 +78,9 @@\n \n \t\t\t/* find att_beg */\n \t\t\tatt_beg = prev;\n-\t\t\tif (prev > hdr_beg)\n+\t\t\tif (!is_first)\n \t\t\t\tatt_beg++;\n+\t\t\tis_first = 0;\n \n \t\t\twhile (att_beg < hdr_end && HTTP_IS_SPHT(*att_beg))\n \t\t\t\tatt_beg++;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tif (prev > hdr_beg)"
            ],
            "added_lines": [
                "\t\tint is_first = 1;",
                "",
                "\t\t\tif (!is_first)",
                "\t\t\tis_first = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-14241",
        "func_name": "haproxy/http_manage_client_side_cookies",
        "description": "HAProxy through 2.0.2 allows attackers to cause a denial of service (ha_panic) via vectors related to htx_manage_client_side_cookies in proto_htx.c.",
        "git_url": "https://github.com/haproxy/haproxy/commit/f0f42389772b2303b162e929449a36b33e181c5f",
        "commit_title": "BUG/CRITICAL: http_ana: Fix parsing of malformed cookies which start by a delimiter",
        "commit_text": " When client-side or server-side cookies are parsed, HAProxy enters in an infinite loop if a Cookie/Set-Cookie header value starts by a delimiter (a colon or a semicolon). Depending on the operating system, the service may become degraded, unresponsive, or may trigger haproxy's watchdog causing a service stop or automatic restart.  To fix this bug, in the loop parsing the attributes, we must be sure to always skip delimiters once the first attribute-value pair was parsed, empty or not. The credit for the fix goes to Olivier.  CVE-2019-14241 was assigned to this bug. This patch fixes the Github issue #181.  This patch must be backported to 2.0 and 1.9. However, the patch will have to be adapted.",
        "func_before": "static void http_manage_client_side_cookies(struct stream *s, struct channel *req)\n{\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct htx *htx;\n\tstruct http_hdr_ctx ctx;\n\tchar *hdr_beg, *hdr_end, *del_from;\n\tchar *prev, *att_beg, *att_end, *equal, *val_beg, *val_end, *next;\n\tint preserve_hdr;\n\n\thtx = htxbuf(&req->buf);\n\tctx.blk = NULL;\n\twhile (http_find_header(htx, ist(\"Cookie\"), &ctx, 1)) {\n\t\tdel_from = NULL;  /* nothing to be deleted */\n\t\tpreserve_hdr = 0; /* assume we may kill the whole header */\n\n\t\t/* Now look for cookies. Conforming to RFC2109, we have to support\n\t\t * attributes whose name begin with a '$', and associate them with\n\t\t * the right cookie, if we want to delete this cookie.\n\t\t * So there are 3 cases for each cookie read :\n\t\t * 1) it's a special attribute, beginning with a '$' : ignore it.\n\t\t * 2) it's a server id cookie that we *MAY* want to delete : save\n\t\t *    some pointers on it (last semi-colon, beginning of cookie...)\n\t\t * 3) it's an application cookie : we *MAY* have to delete a previous\n\t\t *    \"special\" cookie.\n\t\t * At the end of loop, if a \"special\" cookie remains, we may have to\n\t\t * remove it. If no application cookie persists in the header, we\n\t\t * *MUST* delete it.\n\t\t *\n\t\t * Note: RFC2965 is unclear about the processing of spaces around\n\t\t * the equal sign in the ATTR=VALUE form. A careful inspection of\n\t\t * the RFC explicitly allows spaces before it, and not within the\n\t\t * tokens (attrs or values). An inspection of RFC2109 allows that\n\t\t * too but section 10.1.3 lets one think that spaces may be allowed\n\t\t * after the equal sign too, resulting in some (rare) buggy\n\t\t * implementations trying to do that. So let's do what servers do.\n\t\t * Latest ietf draft forbids spaces all around. Also, earlier RFCs\n\t\t * allowed quoted strings in values, with any possible character\n\t\t * after a backslash, including control chars and delimitors, which\n\t\t * causes parsing to become ambiguous. Browsers also allow spaces\n\t\t * within values even without quotes.\n\t\t *\n\t\t * We have to keep multiple pointers in order to support cookie\n\t\t * removal at the beginning, middle or end of header without\n\t\t * corrupting the header. All of these headers are valid :\n\t\t *\n\t\t * hdr_beg                                               hdr_end\n\t\t * |                                                        |\n\t\t * v                                                        |\n\t\t * NAME1=VALUE1;NAME2=VALUE2;NAME3=VALUE3                   |\n\t\t * NAME1=VALUE1;NAME2_ONLY ;NAME3=VALUE3                    v\n\t\t *      NAME1  =  VALUE 1  ; NAME2 = VALUE2 ; NAME3 = VALUE3\n\t\t * |    |    | |  |      | |\n\t\t * |    |    | |  |      | |\n\t\t * |    |    | |  |      | +--> next\n\t\t * |    |    | |  |      +----> val_end\n\t\t * |    |    | |  +-----------> val_beg\n\t\t * |    |    | +--------------> equal\n\t\t * |    |    +----------------> att_end\n\t\t * |    +---------------------> att_beg\n\t\t * +--------------------------> prev\n\t\t *\n\t\t */\n\t\thdr_beg = ctx.value.ptr;\n\t\thdr_end = hdr_beg + ctx.value.len;\n\t\tfor (prev = hdr_beg; prev < hdr_end; prev = next) {\n\t\t\t/* Iterate through all cookies on this line */\n\n\t\t\t/* find att_beg */\n\t\t\tatt_beg = prev;\n\t\t\tif (prev > hdr_beg)\n\t\t\t\tatt_beg++;\n\n\t\t\twhile (att_beg < hdr_end && HTTP_IS_SPHT(*att_beg))\n\t\t\t\tatt_beg++;\n\n\t\t\t/* find att_end : this is the first character after the last non\n\t\t\t * space before the equal. It may be equal to hdr_end.\n\t\t\t */\n\t\t\tequal = att_end = att_beg;\n\t\t\twhile (equal < hdr_end) {\n\t\t\t\tif (*equal == '=' || *equal == ',' || *equal == ';')\n\t\t\t\t\tbreak;\n\t\t\t\tif (HTTP_IS_SPHT(*equal++))\n\t\t\t\t\tcontinue;\n\t\t\t\tatt_end = equal;\n\t\t\t}\n\n\t\t\t/* here, <equal> points to '=', a delimitor or the end. <att_end>\n\t\t\t * is between <att_beg> and <equal>, both may be identical.\n\t\t\t */\n\t\t\t/* look for end of cookie if there is an equal sign */\n\t\t\tif (equal < hdr_end && *equal == '=') {\n\t\t\t\t/* look for the beginning of the value */\n\t\t\t\tval_beg = equal + 1;\n\t\t\t\twhile (val_beg < hdr_end && HTTP_IS_SPHT(*val_beg))\n\t\t\t\t\tval_beg++;\n\n\t\t\t\t/* find the end of the value, respecting quotes */\n\t\t\t\tnext = http_find_cookie_value_end(val_beg, hdr_end);\n\n\t\t\t\t/* make val_end point to the first white space or delimitor after the value */\n\t\t\t\tval_end = next;\n\t\t\t\twhile (val_end > val_beg && HTTP_IS_SPHT(*(val_end - 1)))\n\t\t\t\t\tval_end--;\n\t\t\t}\n\t\t\telse\n\t\t\t\tval_beg = val_end = next = equal;\n\n\t\t\t/* We have nothing to do with attributes beginning with\n\t\t\t * '$'. However, they will automatically be removed if a\n\t\t\t * header before them is removed, since they're supposed\n\t\t\t * to be linked together.\n\t\t\t */\n\t\t\tif (*att_beg == '$')\n\t\t\t\tcontinue;\n\n\t\t\t/* Ignore cookies with no equal sign */\n\t\t\tif (equal == next) {\n\t\t\t\t/* This is not our cookie, so we must preserve it. But if we already\n\t\t\t\t * scheduled another cookie for removal, we cannot remove the\n\t\t\t\t * complete header, but we can remove the previous block itself.\n\t\t\t\t */\n\t\t\t\tpreserve_hdr = 1;\n\t\t\t\tif (del_from != NULL) {\n\t\t\t\t\tint delta = http_del_hdr_value(hdr_beg, hdr_end, &del_from, prev);\n\t\t\t\t\tval_end  += delta;\n\t\t\t\t\tnext     += delta;\n\t\t\t\t\thdr_end  += delta;\n\t\t\t\t\tprev     = del_from;\n\t\t\t\t\tdel_from = NULL;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* if there are spaces around the equal sign, we need to\n\t\t\t * strip them otherwise we'll get trouble for cookie captures,\n\t\t\t * or even for rewrites. Since this happens extremely rarely,\n\t\t\t * it does not hurt performance.\n\t\t\t */\n\t\t\tif (unlikely(att_end != equal || val_beg > equal + 1)) {\n\t\t\t\tint stripped_before = 0;\n\t\t\t\tint stripped_after = 0;\n\n\t\t\t\tif (att_end != equal) {\n\t\t\t\t\tmemmove(att_end, equal, hdr_end - equal);\n\t\t\t\t\tstripped_before = (att_end - equal);\n\t\t\t\t\tequal   += stripped_before;\n\t\t\t\t\tval_beg += stripped_before;\n\t\t\t\t}\n\n\t\t\t\tif (val_beg > equal + 1) {\n\t\t\t\t\tmemmove(equal + 1, val_beg, hdr_end + stripped_before - val_beg);\n\t\t\t\t\tstripped_after = (equal + 1) - val_beg;\n\t\t\t\t\tval_beg += stripped_after;\n\t\t\t\t\tstripped_before += stripped_after;\n\t\t\t\t}\n\n\t\t\t\tval_end      += stripped_before;\n\t\t\t\tnext         += stripped_before;\n\t\t\t\thdr_end      += stripped_before;\n\t\t\t}\n\t\t\t/* now everything is as on the diagram above */\n\n\t\t\t/* First, let's see if we want to capture this cookie. We check\n\t\t\t * that we don't already have a client side cookie, because we\n\t\t\t * can only capture one. Also as an optimisation, we ignore\n\t\t\t * cookies shorter than the declared name.\n\t\t\t */\n\t\t\tif (sess->fe->capture_name != NULL && txn->cli_cookie == NULL &&\n\t\t\t    (val_end - att_beg >= sess->fe->capture_namelen) &&\n\t\t\t    memcmp(att_beg, sess->fe->capture_name, sess->fe->capture_namelen) == 0) {\n\t\t\t\tint log_len = val_end - att_beg;\n\n\t\t\t\tif ((txn->cli_cookie = pool_alloc(pool_head_capture)) == NULL) {\n\t\t\t\t\tha_alert(\"HTTP logging : out of memory.\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tif (log_len > sess->fe->capture_len)\n\t\t\t\t\t\tlog_len = sess->fe->capture_len;\n\t\t\t\t\tmemcpy(txn->cli_cookie, att_beg, log_len);\n\t\t\t\t\ttxn->cli_cookie[log_len] = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Persistence cookies in passive, rewrite or insert mode have the\n\t\t\t * following form :\n\t\t\t *\n\t\t\t *    Cookie: NAME=SRV[|<lastseen>[|<firstseen>]]\n\t\t\t *\n\t\t\t * For cookies in prefix mode, the form is :\n\t\t\t *\n\t\t\t *    Cookie: NAME=SRV~VALUE\n\t\t\t */\n\t\t\tif ((att_end - att_beg == s->be->cookie_len) && (s->be->cookie_name != NULL) &&\n\t\t\t    (memcmp(att_beg, s->be->cookie_name, att_end - att_beg) == 0)) {\n\t\t\t\tstruct server *srv = s->be->srv;\n\t\t\t\tchar *delim;\n\n\t\t\t\t/* if we're in cookie prefix mode, we'll search the delimitor so that we\n\t\t\t\t * have the server ID between val_beg and delim, and the original cookie between\n\t\t\t\t * delim+1 and val_end. Otherwise, delim==val_end :\n\t\t\t\t *\n\t\t\t\t * hdr_beg\n\t\t\t\t * |\n\t\t\t\t * v\n\t\t\t\t * NAME=SRV;          # in all but prefix modes\n\t\t\t\t * NAME=SRV~OPAQUE ;  # in prefix mode\n\t\t\t\t * ||   ||  |      |+-> next\n\t\t\t\t * ||   ||  |      +--> val_end\n\t\t\t\t * ||   ||  +---------> delim\n\t\t\t\t * ||   |+------------> val_beg\n\t\t\t\t * ||   +-------------> att_end = equal\n\t\t\t\t * |+-----------------> att_beg\n\t\t\t\t * +------------------> prev\n\t\t\t\t *\n\t\t\t\t */\n\t\t\t\tif (s->be->ck_opts & PR_CK_PFX) {\n\t\t\t\t\tfor (delim = val_beg; delim < val_end; delim++)\n\t\t\t\t\t\tif (*delim == COOKIE_DELIM)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *vbar1;\n\t\t\t\t\tdelim = val_end;\n\t\t\t\t\t/* Now check if the cookie contains a date field, which would\n\t\t\t\t\t * appear after a vertical bar ('|') just after the server name\n\t\t\t\t\t * and before the delimiter.\n\t\t\t\t\t */\n\t\t\t\t\tvbar1 = memchr(val_beg, COOKIE_DELIM_DATE, val_end - val_beg);\n\t\t\t\t\tif (vbar1) {\n\t\t\t\t\t\t/* OK, so left of the bar is the server's cookie and\n\t\t\t\t\t\t * right is the last seen date. It is a base64 encoded\n\t\t\t\t\t\t * 30-bit value representing the UNIX date since the\n\t\t\t\t\t\t * epoch in 4-second quantities.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tint val;\n\t\t\t\t\t\tdelim = vbar1++;\n\t\t\t\t\t\tif (val_end - vbar1 >= 5) {\n\t\t\t\t\t\t\tval = b64tos30(vbar1);\n\t\t\t\t\t\t\tif (val > 0)\n\t\t\t\t\t\t\t\ttxn->cookie_last_date = val << 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* look for a second vertical bar */\n\t\t\t\t\t\tvbar1 = memchr(vbar1, COOKIE_DELIM_DATE, val_end - vbar1);\n\t\t\t\t\t\tif (vbar1 && (val_end - vbar1 > 5)) {\n\t\t\t\t\t\t\tval = b64tos30(vbar1 + 1);\n\t\t\t\t\t\t\tif (val > 0)\n\t\t\t\t\t\t\t\ttxn->cookie_first_date = val << 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* if the cookie has an expiration date and the proxy wants to check\n\t\t\t\t * it, then we do that now. We first check if the cookie is too old,\n\t\t\t\t * then only if it has expired. We detect strict overflow because the\n\t\t\t\t * time resolution here is not great (4 seconds). Cookies with dates\n\t\t\t\t * in the future are ignored if their offset is beyond one day. This\n\t\t\t\t * allows an admin to fix timezone issues without expiring everyone\n\t\t\t\t * and at the same time avoids keeping unwanted side effects for too\n\t\t\t\t * long.\n\t\t\t\t */\n\t\t\t\tif (txn->cookie_first_date && s->be->cookie_maxlife &&\n\t\t\t\t    (((signed)(date.tv_sec - txn->cookie_first_date) > (signed)s->be->cookie_maxlife) ||\n\t\t\t\t     ((signed)(txn->cookie_first_date - date.tv_sec) > 86400))) {\n\t\t\t\t\ttxn->flags &= ~TX_CK_MASK;\n\t\t\t\t\ttxn->flags |= TX_CK_OLD;\n\t\t\t\t\tdelim = val_beg; // let's pretend we have not found the cookie\n\t\t\t\t\ttxn->cookie_first_date = 0;\n\t\t\t\t\ttxn->cookie_last_date = 0;\n\t\t\t\t}\n\t\t\t\telse if (txn->cookie_last_date && s->be->cookie_maxidle &&\n\t\t\t\t\t (((signed)(date.tv_sec - txn->cookie_last_date) > (signed)s->be->cookie_maxidle) ||\n\t\t\t\t\t  ((signed)(txn->cookie_last_date - date.tv_sec) > 86400))) {\n\t\t\t\t\ttxn->flags &= ~TX_CK_MASK;\n\t\t\t\t\ttxn->flags |= TX_CK_EXPIRED;\n\t\t\t\t\tdelim = val_beg; // let's pretend we have not found the cookie\n\t\t\t\t\ttxn->cookie_first_date = 0;\n\t\t\t\t\ttxn->cookie_last_date = 0;\n\t\t\t\t}\n\n\t\t\t\t/* Here, we'll look for the first running server which supports the cookie.\n\t\t\t\t * This allows to share a same cookie between several servers, for example\n\t\t\t\t * to dedicate backup servers to specific servers only.\n\t\t\t\t * However, to prevent clients from sticking to cookie-less backup server\n\t\t\t\t * when they have incidentely learned an empty cookie, we simply ignore\n\t\t\t\t * empty cookies and mark them as invalid.\n\t\t\t\t * The same behaviour is applied when persistence must be ignored.\n\t\t\t\t */\n\t\t\t\tif ((delim == val_beg) || (s->flags & (SF_IGNORE_PRST | SF_ASSIGNED)))\n\t\t\t\t\tsrv = NULL;\n\n\t\t\t\twhile (srv) {\n\t\t\t\t\tif (srv->cookie && (srv->cklen == delim - val_beg) &&\n\t\t\t\t\t    !memcmp(val_beg, srv->cookie, delim - val_beg)) {\n\t\t\t\t\t\tif ((srv->cur_state != SRV_ST_STOPPED) ||\n\t\t\t\t\t\t    (s->be->options & PR_O_PERSIST) ||\n\t\t\t\t\t\t    (s->flags & SF_FORCE_PRST)) {\n\t\t\t\t\t\t\t/* we found the server and we can use it */\n\t\t\t\t\t\t\ttxn->flags &= ~TX_CK_MASK;\n\t\t\t\t\t\t\ttxn->flags |= (srv->cur_state != SRV_ST_STOPPED) ? TX_CK_VALID : TX_CK_DOWN;\n\t\t\t\t\t\t\ts->flags |= SF_DIRECT | SF_ASSIGNED;\n\t\t\t\t\t\t\ts->target = &srv->obj_type;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* we found a server, but it's down,\n\t\t\t\t\t\t\t * mark it as such and go on in case\n\t\t\t\t\t\t\t * another one is available.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\ttxn->flags &= ~TX_CK_MASK;\n\t\t\t\t\t\t\ttxn->flags |= TX_CK_DOWN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsrv = srv->next;\n\t\t\t\t}\n\n\t\t\t\tif (!srv && !(txn->flags & (TX_CK_DOWN|TX_CK_EXPIRED|TX_CK_OLD))) {\n\t\t\t\t\t/* no server matched this cookie or we deliberately skipped it */\n\t\t\t\t\ttxn->flags &= ~TX_CK_MASK;\n\t\t\t\t\tif ((s->flags & (SF_IGNORE_PRST | SF_ASSIGNED)))\n\t\t\t\t\t\ttxn->flags |= TX_CK_UNUSED;\n\t\t\t\t\telse\n\t\t\t\t\t\ttxn->flags |= TX_CK_INVALID;\n\t\t\t\t}\n\n\t\t\t\t/* depending on the cookie mode, we may have to either :\n\t\t\t\t * - delete the complete cookie if we're in insert+indirect mode, so that\n\t\t\t\t *   the server never sees it ;\n\t\t\t\t * - remove the server id from the cookie value, and tag the cookie as an\n\t\t\t\t *   application cookie so that it does not get accidentally removed later,\n\t\t\t\t *   if we're in cookie prefix mode\n\t\t\t\t */\n\t\t\t\tif ((s->be->ck_opts & PR_CK_PFX) && (delim != val_end)) {\n\t\t\t\t\tint delta; /* negative */\n\n\t\t\t\t\tmemmove(val_beg, delim + 1, hdr_end - (delim + 1));\n\t\t\t\t\tdelta = val_beg - (delim + 1);\n\t\t\t\t\tval_end  += delta;\n\t\t\t\t\tnext     += delta;\n\t\t\t\t\thdr_end  += delta;\n\t\t\t\t\tdel_from = NULL;\n\t\t\t\t\tpreserve_hdr = 1; /* we want to keep this cookie */\n\t\t\t\t}\n\t\t\t\telse if (del_from == NULL &&\n\t\t\t\t\t (s->be->ck_opts & (PR_CK_INS | PR_CK_IND)) == (PR_CK_INS | PR_CK_IND)) {\n\t\t\t\t\tdel_from = prev;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* This is not our cookie, so we must preserve it. But if we already\n\t\t\t\t * scheduled another cookie for removal, we cannot remove the\n\t\t\t\t * complete header, but we can remove the previous block itself.\n\t\t\t\t */\n\t\t\t\tpreserve_hdr = 1;\n\n\t\t\t\tif (del_from != NULL) {\n\t\t\t\t\tint delta = http_del_hdr_value(hdr_beg, hdr_end, &del_from, prev);\n\t\t\t\t\tif (att_beg >= del_from)\n\t\t\t\t\t\tatt_beg += delta;\n\t\t\t\t\tif (att_end >= del_from)\n\t\t\t\t\t\tatt_end += delta;\n\t\t\t\t\tval_beg  += delta;\n\t\t\t\t\tval_end  += delta;\n\t\t\t\t\tnext     += delta;\n\t\t\t\t\thdr_end  += delta;\n\t\t\t\t\tprev     = del_from;\n\t\t\t\t\tdel_from = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* continue with next cookie on this header line */\n\t\t\tatt_beg = next;\n\t\t} /* for each cookie */\n\n\n\t\t/* There are no more cookies on this line.\n\t\t * We may still have one (or several) marked for deletion at the\n\t\t * end of the line. We must do this now in two ways :\n\t\t *  - if some cookies must be preserved, we only delete from the\n\t\t *    mark to the end of line ;\n\t\t *  - if nothing needs to be preserved, simply delete the whole header\n\t\t */\n\t\tif (del_from) {\n\t\t\thdr_end = (preserve_hdr ? del_from : hdr_beg);\n\t\t}\n\t\tif ((hdr_end - hdr_beg) != ctx.value.len) {\n\t\t\tif (hdr_beg != hdr_end)\n\t\t\t\thtx_change_blk_value_len(htx, ctx.blk, hdr_end - hdr_beg);\n\t\t\telse\n\t\t\t\thttp_remove_header(htx, &ctx);\n\t\t}\n\t} /* for each \"Cookie header */\n}",
        "func": "static void http_manage_client_side_cookies(struct stream *s, struct channel *req)\n{\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct htx *htx;\n\tstruct http_hdr_ctx ctx;\n\tchar *hdr_beg, *hdr_end, *del_from;\n\tchar *prev, *att_beg, *att_end, *equal, *val_beg, *val_end, *next;\n\tint preserve_hdr;\n\n\thtx = htxbuf(&req->buf);\n\tctx.blk = NULL;\n\twhile (http_find_header(htx, ist(\"Cookie\"), &ctx, 1)) {\n\t\tint is_first = 1;\n\t\tdel_from = NULL;  /* nothing to be deleted */\n\t\tpreserve_hdr = 0; /* assume we may kill the whole header */\n\n\t\t/* Now look for cookies. Conforming to RFC2109, we have to support\n\t\t * attributes whose name begin with a '$', and associate them with\n\t\t * the right cookie, if we want to delete this cookie.\n\t\t * So there are 3 cases for each cookie read :\n\t\t * 1) it's a special attribute, beginning with a '$' : ignore it.\n\t\t * 2) it's a server id cookie that we *MAY* want to delete : save\n\t\t *    some pointers on it (last semi-colon, beginning of cookie...)\n\t\t * 3) it's an application cookie : we *MAY* have to delete a previous\n\t\t *    \"special\" cookie.\n\t\t * At the end of loop, if a \"special\" cookie remains, we may have to\n\t\t * remove it. If no application cookie persists in the header, we\n\t\t * *MUST* delete it.\n\t\t *\n\t\t * Note: RFC2965 is unclear about the processing of spaces around\n\t\t * the equal sign in the ATTR=VALUE form. A careful inspection of\n\t\t * the RFC explicitly allows spaces before it, and not within the\n\t\t * tokens (attrs or values). An inspection of RFC2109 allows that\n\t\t * too but section 10.1.3 lets one think that spaces may be allowed\n\t\t * after the equal sign too, resulting in some (rare) buggy\n\t\t * implementations trying to do that. So let's do what servers do.\n\t\t * Latest ietf draft forbids spaces all around. Also, earlier RFCs\n\t\t * allowed quoted strings in values, with any possible character\n\t\t * after a backslash, including control chars and delimitors, which\n\t\t * causes parsing to become ambiguous. Browsers also allow spaces\n\t\t * within values even without quotes.\n\t\t *\n\t\t * We have to keep multiple pointers in order to support cookie\n\t\t * removal at the beginning, middle or end of header without\n\t\t * corrupting the header. All of these headers are valid :\n\t\t *\n\t\t * hdr_beg                                               hdr_end\n\t\t * |                                                        |\n\t\t * v                                                        |\n\t\t * NAME1=VALUE1;NAME2=VALUE2;NAME3=VALUE3                   |\n\t\t * NAME1=VALUE1;NAME2_ONLY ;NAME3=VALUE3                    v\n\t\t *      NAME1  =  VALUE 1  ; NAME2 = VALUE2 ; NAME3 = VALUE3\n\t\t * |    |    | |  |      | |\n\t\t * |    |    | |  |      | |\n\t\t * |    |    | |  |      | +--> next\n\t\t * |    |    | |  |      +----> val_end\n\t\t * |    |    | |  +-----------> val_beg\n\t\t * |    |    | +--------------> equal\n\t\t * |    |    +----------------> att_end\n\t\t * |    +---------------------> att_beg\n\t\t * +--------------------------> prev\n\t\t *\n\t\t */\n\t\thdr_beg = ctx.value.ptr;\n\t\thdr_end = hdr_beg + ctx.value.len;\n\t\tfor (prev = hdr_beg; prev < hdr_end; prev = next) {\n\t\t\t/* Iterate through all cookies on this line */\n\n\t\t\t/* find att_beg */\n\t\t\tatt_beg = prev;\n\t\t\tif (!is_first)\n\t\t\t\tatt_beg++;\n\t\t\tis_first = 0;\n\n\t\t\twhile (att_beg < hdr_end && HTTP_IS_SPHT(*att_beg))\n\t\t\t\tatt_beg++;\n\n\t\t\t/* find att_end : this is the first character after the last non\n\t\t\t * space before the equal. It may be equal to hdr_end.\n\t\t\t */\n\t\t\tequal = att_end = att_beg;\n\t\t\twhile (equal < hdr_end) {\n\t\t\t\tif (*equal == '=' || *equal == ',' || *equal == ';')\n\t\t\t\t\tbreak;\n\t\t\t\tif (HTTP_IS_SPHT(*equal++))\n\t\t\t\t\tcontinue;\n\t\t\t\tatt_end = equal;\n\t\t\t}\n\n\t\t\t/* here, <equal> points to '=', a delimitor or the end. <att_end>\n\t\t\t * is between <att_beg> and <equal>, both may be identical.\n\t\t\t */\n\t\t\t/* look for end of cookie if there is an equal sign */\n\t\t\tif (equal < hdr_end && *equal == '=') {\n\t\t\t\t/* look for the beginning of the value */\n\t\t\t\tval_beg = equal + 1;\n\t\t\t\twhile (val_beg < hdr_end && HTTP_IS_SPHT(*val_beg))\n\t\t\t\t\tval_beg++;\n\n\t\t\t\t/* find the end of the value, respecting quotes */\n\t\t\t\tnext = http_find_cookie_value_end(val_beg, hdr_end);\n\n\t\t\t\t/* make val_end point to the first white space or delimitor after the value */\n\t\t\t\tval_end = next;\n\t\t\t\twhile (val_end > val_beg && HTTP_IS_SPHT(*(val_end - 1)))\n\t\t\t\t\tval_end--;\n\t\t\t}\n\t\t\telse\n\t\t\t\tval_beg = val_end = next = equal;\n\n\t\t\t/* We have nothing to do with attributes beginning with\n\t\t\t * '$'. However, they will automatically be removed if a\n\t\t\t * header before them is removed, since they're supposed\n\t\t\t * to be linked together.\n\t\t\t */\n\t\t\tif (*att_beg == '$')\n\t\t\t\tcontinue;\n\n\t\t\t/* Ignore cookies with no equal sign */\n\t\t\tif (equal == next) {\n\t\t\t\t/* This is not our cookie, so we must preserve it. But if we already\n\t\t\t\t * scheduled another cookie for removal, we cannot remove the\n\t\t\t\t * complete header, but we can remove the previous block itself.\n\t\t\t\t */\n\t\t\t\tpreserve_hdr = 1;\n\t\t\t\tif (del_from != NULL) {\n\t\t\t\t\tint delta = http_del_hdr_value(hdr_beg, hdr_end, &del_from, prev);\n\t\t\t\t\tval_end  += delta;\n\t\t\t\t\tnext     += delta;\n\t\t\t\t\thdr_end  += delta;\n\t\t\t\t\tprev     = del_from;\n\t\t\t\t\tdel_from = NULL;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* if there are spaces around the equal sign, we need to\n\t\t\t * strip them otherwise we'll get trouble for cookie captures,\n\t\t\t * or even for rewrites. Since this happens extremely rarely,\n\t\t\t * it does not hurt performance.\n\t\t\t */\n\t\t\tif (unlikely(att_end != equal || val_beg > equal + 1)) {\n\t\t\t\tint stripped_before = 0;\n\t\t\t\tint stripped_after = 0;\n\n\t\t\t\tif (att_end != equal) {\n\t\t\t\t\tmemmove(att_end, equal, hdr_end - equal);\n\t\t\t\t\tstripped_before = (att_end - equal);\n\t\t\t\t\tequal   += stripped_before;\n\t\t\t\t\tval_beg += stripped_before;\n\t\t\t\t}\n\n\t\t\t\tif (val_beg > equal + 1) {\n\t\t\t\t\tmemmove(equal + 1, val_beg, hdr_end + stripped_before - val_beg);\n\t\t\t\t\tstripped_after = (equal + 1) - val_beg;\n\t\t\t\t\tval_beg += stripped_after;\n\t\t\t\t\tstripped_before += stripped_after;\n\t\t\t\t}\n\n\t\t\t\tval_end      += stripped_before;\n\t\t\t\tnext         += stripped_before;\n\t\t\t\thdr_end      += stripped_before;\n\t\t\t}\n\t\t\t/* now everything is as on the diagram above */\n\n\t\t\t/* First, let's see if we want to capture this cookie. We check\n\t\t\t * that we don't already have a client side cookie, because we\n\t\t\t * can only capture one. Also as an optimisation, we ignore\n\t\t\t * cookies shorter than the declared name.\n\t\t\t */\n\t\t\tif (sess->fe->capture_name != NULL && txn->cli_cookie == NULL &&\n\t\t\t    (val_end - att_beg >= sess->fe->capture_namelen) &&\n\t\t\t    memcmp(att_beg, sess->fe->capture_name, sess->fe->capture_namelen) == 0) {\n\t\t\t\tint log_len = val_end - att_beg;\n\n\t\t\t\tif ((txn->cli_cookie = pool_alloc(pool_head_capture)) == NULL) {\n\t\t\t\t\tha_alert(\"HTTP logging : out of memory.\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tif (log_len > sess->fe->capture_len)\n\t\t\t\t\t\tlog_len = sess->fe->capture_len;\n\t\t\t\t\tmemcpy(txn->cli_cookie, att_beg, log_len);\n\t\t\t\t\ttxn->cli_cookie[log_len] = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Persistence cookies in passive, rewrite or insert mode have the\n\t\t\t * following form :\n\t\t\t *\n\t\t\t *    Cookie: NAME=SRV[|<lastseen>[|<firstseen>]]\n\t\t\t *\n\t\t\t * For cookies in prefix mode, the form is :\n\t\t\t *\n\t\t\t *    Cookie: NAME=SRV~VALUE\n\t\t\t */\n\t\t\tif ((att_end - att_beg == s->be->cookie_len) && (s->be->cookie_name != NULL) &&\n\t\t\t    (memcmp(att_beg, s->be->cookie_name, att_end - att_beg) == 0)) {\n\t\t\t\tstruct server *srv = s->be->srv;\n\t\t\t\tchar *delim;\n\n\t\t\t\t/* if we're in cookie prefix mode, we'll search the delimitor so that we\n\t\t\t\t * have the server ID between val_beg and delim, and the original cookie between\n\t\t\t\t * delim+1 and val_end. Otherwise, delim==val_end :\n\t\t\t\t *\n\t\t\t\t * hdr_beg\n\t\t\t\t * |\n\t\t\t\t * v\n\t\t\t\t * NAME=SRV;          # in all but prefix modes\n\t\t\t\t * NAME=SRV~OPAQUE ;  # in prefix mode\n\t\t\t\t * ||   ||  |      |+-> next\n\t\t\t\t * ||   ||  |      +--> val_end\n\t\t\t\t * ||   ||  +---------> delim\n\t\t\t\t * ||   |+------------> val_beg\n\t\t\t\t * ||   +-------------> att_end = equal\n\t\t\t\t * |+-----------------> att_beg\n\t\t\t\t * +------------------> prev\n\t\t\t\t *\n\t\t\t\t */\n\t\t\t\tif (s->be->ck_opts & PR_CK_PFX) {\n\t\t\t\t\tfor (delim = val_beg; delim < val_end; delim++)\n\t\t\t\t\t\tif (*delim == COOKIE_DELIM)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *vbar1;\n\t\t\t\t\tdelim = val_end;\n\t\t\t\t\t/* Now check if the cookie contains a date field, which would\n\t\t\t\t\t * appear after a vertical bar ('|') just after the server name\n\t\t\t\t\t * and before the delimiter.\n\t\t\t\t\t */\n\t\t\t\t\tvbar1 = memchr(val_beg, COOKIE_DELIM_DATE, val_end - val_beg);\n\t\t\t\t\tif (vbar1) {\n\t\t\t\t\t\t/* OK, so left of the bar is the server's cookie and\n\t\t\t\t\t\t * right is the last seen date. It is a base64 encoded\n\t\t\t\t\t\t * 30-bit value representing the UNIX date since the\n\t\t\t\t\t\t * epoch in 4-second quantities.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tint val;\n\t\t\t\t\t\tdelim = vbar1++;\n\t\t\t\t\t\tif (val_end - vbar1 >= 5) {\n\t\t\t\t\t\t\tval = b64tos30(vbar1);\n\t\t\t\t\t\t\tif (val > 0)\n\t\t\t\t\t\t\t\ttxn->cookie_last_date = val << 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* look for a second vertical bar */\n\t\t\t\t\t\tvbar1 = memchr(vbar1, COOKIE_DELIM_DATE, val_end - vbar1);\n\t\t\t\t\t\tif (vbar1 && (val_end - vbar1 > 5)) {\n\t\t\t\t\t\t\tval = b64tos30(vbar1 + 1);\n\t\t\t\t\t\t\tif (val > 0)\n\t\t\t\t\t\t\t\ttxn->cookie_first_date = val << 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* if the cookie has an expiration date and the proxy wants to check\n\t\t\t\t * it, then we do that now. We first check if the cookie is too old,\n\t\t\t\t * then only if it has expired. We detect strict overflow because the\n\t\t\t\t * time resolution here is not great (4 seconds). Cookies with dates\n\t\t\t\t * in the future are ignored if their offset is beyond one day. This\n\t\t\t\t * allows an admin to fix timezone issues without expiring everyone\n\t\t\t\t * and at the same time avoids keeping unwanted side effects for too\n\t\t\t\t * long.\n\t\t\t\t */\n\t\t\t\tif (txn->cookie_first_date && s->be->cookie_maxlife &&\n\t\t\t\t    (((signed)(date.tv_sec - txn->cookie_first_date) > (signed)s->be->cookie_maxlife) ||\n\t\t\t\t     ((signed)(txn->cookie_first_date - date.tv_sec) > 86400))) {\n\t\t\t\t\ttxn->flags &= ~TX_CK_MASK;\n\t\t\t\t\ttxn->flags |= TX_CK_OLD;\n\t\t\t\t\tdelim = val_beg; // let's pretend we have not found the cookie\n\t\t\t\t\ttxn->cookie_first_date = 0;\n\t\t\t\t\ttxn->cookie_last_date = 0;\n\t\t\t\t}\n\t\t\t\telse if (txn->cookie_last_date && s->be->cookie_maxidle &&\n\t\t\t\t\t (((signed)(date.tv_sec - txn->cookie_last_date) > (signed)s->be->cookie_maxidle) ||\n\t\t\t\t\t  ((signed)(txn->cookie_last_date - date.tv_sec) > 86400))) {\n\t\t\t\t\ttxn->flags &= ~TX_CK_MASK;\n\t\t\t\t\ttxn->flags |= TX_CK_EXPIRED;\n\t\t\t\t\tdelim = val_beg; // let's pretend we have not found the cookie\n\t\t\t\t\ttxn->cookie_first_date = 0;\n\t\t\t\t\ttxn->cookie_last_date = 0;\n\t\t\t\t}\n\n\t\t\t\t/* Here, we'll look for the first running server which supports the cookie.\n\t\t\t\t * This allows to share a same cookie between several servers, for example\n\t\t\t\t * to dedicate backup servers to specific servers only.\n\t\t\t\t * However, to prevent clients from sticking to cookie-less backup server\n\t\t\t\t * when they have incidentely learned an empty cookie, we simply ignore\n\t\t\t\t * empty cookies and mark them as invalid.\n\t\t\t\t * The same behaviour is applied when persistence must be ignored.\n\t\t\t\t */\n\t\t\t\tif ((delim == val_beg) || (s->flags & (SF_IGNORE_PRST | SF_ASSIGNED)))\n\t\t\t\t\tsrv = NULL;\n\n\t\t\t\twhile (srv) {\n\t\t\t\t\tif (srv->cookie && (srv->cklen == delim - val_beg) &&\n\t\t\t\t\t    !memcmp(val_beg, srv->cookie, delim - val_beg)) {\n\t\t\t\t\t\tif ((srv->cur_state != SRV_ST_STOPPED) ||\n\t\t\t\t\t\t    (s->be->options & PR_O_PERSIST) ||\n\t\t\t\t\t\t    (s->flags & SF_FORCE_PRST)) {\n\t\t\t\t\t\t\t/* we found the server and we can use it */\n\t\t\t\t\t\t\ttxn->flags &= ~TX_CK_MASK;\n\t\t\t\t\t\t\ttxn->flags |= (srv->cur_state != SRV_ST_STOPPED) ? TX_CK_VALID : TX_CK_DOWN;\n\t\t\t\t\t\t\ts->flags |= SF_DIRECT | SF_ASSIGNED;\n\t\t\t\t\t\t\ts->target = &srv->obj_type;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* we found a server, but it's down,\n\t\t\t\t\t\t\t * mark it as such and go on in case\n\t\t\t\t\t\t\t * another one is available.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\ttxn->flags &= ~TX_CK_MASK;\n\t\t\t\t\t\t\ttxn->flags |= TX_CK_DOWN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsrv = srv->next;\n\t\t\t\t}\n\n\t\t\t\tif (!srv && !(txn->flags & (TX_CK_DOWN|TX_CK_EXPIRED|TX_CK_OLD))) {\n\t\t\t\t\t/* no server matched this cookie or we deliberately skipped it */\n\t\t\t\t\ttxn->flags &= ~TX_CK_MASK;\n\t\t\t\t\tif ((s->flags & (SF_IGNORE_PRST | SF_ASSIGNED)))\n\t\t\t\t\t\ttxn->flags |= TX_CK_UNUSED;\n\t\t\t\t\telse\n\t\t\t\t\t\ttxn->flags |= TX_CK_INVALID;\n\t\t\t\t}\n\n\t\t\t\t/* depending on the cookie mode, we may have to either :\n\t\t\t\t * - delete the complete cookie if we're in insert+indirect mode, so that\n\t\t\t\t *   the server never sees it ;\n\t\t\t\t * - remove the server id from the cookie value, and tag the cookie as an\n\t\t\t\t *   application cookie so that it does not get accidentally removed later,\n\t\t\t\t *   if we're in cookie prefix mode\n\t\t\t\t */\n\t\t\t\tif ((s->be->ck_opts & PR_CK_PFX) && (delim != val_end)) {\n\t\t\t\t\tint delta; /* negative */\n\n\t\t\t\t\tmemmove(val_beg, delim + 1, hdr_end - (delim + 1));\n\t\t\t\t\tdelta = val_beg - (delim + 1);\n\t\t\t\t\tval_end  += delta;\n\t\t\t\t\tnext     += delta;\n\t\t\t\t\thdr_end  += delta;\n\t\t\t\t\tdel_from = NULL;\n\t\t\t\t\tpreserve_hdr = 1; /* we want to keep this cookie */\n\t\t\t\t}\n\t\t\t\telse if (del_from == NULL &&\n\t\t\t\t\t (s->be->ck_opts & (PR_CK_INS | PR_CK_IND)) == (PR_CK_INS | PR_CK_IND)) {\n\t\t\t\t\tdel_from = prev;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* This is not our cookie, so we must preserve it. But if we already\n\t\t\t\t * scheduled another cookie for removal, we cannot remove the\n\t\t\t\t * complete header, but we can remove the previous block itself.\n\t\t\t\t */\n\t\t\t\tpreserve_hdr = 1;\n\n\t\t\t\tif (del_from != NULL) {\n\t\t\t\t\tint delta = http_del_hdr_value(hdr_beg, hdr_end, &del_from, prev);\n\t\t\t\t\tif (att_beg >= del_from)\n\t\t\t\t\t\tatt_beg += delta;\n\t\t\t\t\tif (att_end >= del_from)\n\t\t\t\t\t\tatt_end += delta;\n\t\t\t\t\tval_beg  += delta;\n\t\t\t\t\tval_end  += delta;\n\t\t\t\t\tnext     += delta;\n\t\t\t\t\thdr_end  += delta;\n\t\t\t\t\tprev     = del_from;\n\t\t\t\t\tdel_from = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* continue with next cookie on this header line */\n\t\t\tatt_beg = next;\n\t\t} /* for each cookie */\n\n\n\t\t/* There are no more cookies on this line.\n\t\t * We may still have one (or several) marked for deletion at the\n\t\t * end of the line. We must do this now in two ways :\n\t\t *  - if some cookies must be preserved, we only delete from the\n\t\t *    mark to the end of line ;\n\t\t *  - if nothing needs to be preserved, simply delete the whole header\n\t\t */\n\t\tif (del_from) {\n\t\t\thdr_end = (preserve_hdr ? del_from : hdr_beg);\n\t\t}\n\t\tif ((hdr_end - hdr_beg) != ctx.value.len) {\n\t\t\tif (hdr_beg != hdr_end)\n\t\t\t\thtx_change_blk_value_len(htx, ctx.blk, hdr_end - hdr_beg);\n\t\t\telse\n\t\t\t\thttp_remove_header(htx, &ctx);\n\t\t}\n\t} /* for each \"Cookie header */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,6 +11,7 @@\n \thtx = htxbuf(&req->buf);\n \tctx.blk = NULL;\n \twhile (http_find_header(htx, ist(\"Cookie\"), &ctx, 1)) {\n+\t\tint is_first = 1;\n \t\tdel_from = NULL;  /* nothing to be deleted */\n \t\tpreserve_hdr = 0; /* assume we may kill the whole header */\n \n@@ -68,8 +69,9 @@\n \n \t\t\t/* find att_beg */\n \t\t\tatt_beg = prev;\n-\t\t\tif (prev > hdr_beg)\n+\t\t\tif (!is_first)\n \t\t\t\tatt_beg++;\n+\t\t\tis_first = 0;\n \n \t\t\twhile (att_beg < hdr_end && HTTP_IS_SPHT(*att_beg))\n \t\t\t\tatt_beg++;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tif (prev > hdr_beg)"
            ],
            "added_lines": [
                "\t\tint is_first = 1;",
                "\t\t\tif (!is_first)",
                "\t\t\tis_first = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15702",
        "func_name": "RIOT-OS/RIOT/_option_parse",
        "description": "In the TCP implementation (gnrc_tcp) in RIOT through 2019.07, the parser for TCP options does not terminate on all inputs, allowing a denial-of-service, because sys/net/gnrc/transport_layer/tcp/gnrc_tcp_option.c has an infinite loop for an unknown zero-length option.",
        "git_url": "https://github.com/RIOT-OS/RIOT/commit/9764697a3b21ea4c7c0d33ce4e3a83d2da620a1a",
        "commit_title": "gnrc_tcp: abort on unknown option",
        "commit_text": "",
        "func_before": "int _option_parse(gnrc_tcp_tcb_t *tcb, tcp_hdr_t *hdr)\n{\n    /* Extract offset value. Return if no options are set */\n    uint8_t offset = GET_OFFSET(byteorder_ntohs(hdr->off_ctl));\n    if (offset <= TCP_HDR_OFFSET_MIN) {\n        return 0;\n    }\n\n    /* Get pointer to option field and field size */\n    uint8_t *opt_ptr = (uint8_t *) hdr + sizeof(tcp_hdr_t);\n    uint8_t opt_left = (offset - TCP_HDR_OFFSET_MIN) * 4;\n\n    /* Parse options via tcp_hdr_opt_t */\n    while (opt_left > 0) {\n        tcp_hdr_opt_t *option = (tcp_hdr_opt_t *) opt_ptr;\n\n        /* Examine current option */\n        switch (option->kind) {\n            case TCP_OPTION_KIND_EOL:\n                DEBUG(\"gnrc_tcp_option.c : _option_parse() : EOL option found\\n\");\n                return 0;\n\n            case TCP_OPTION_KIND_NOP:\n                DEBUG(\"gnrc_tcp_option.c : _option_parse() : NOP option found\\n\");\n                opt_ptr += 1;\n                opt_left -= 1;\n                continue;\n\n            case TCP_OPTION_KIND_MSS:\n                if (option->length != TCP_OPTION_LENGTH_MSS) {\n                    DEBUG(\"gnrc_tcp_option.c : _option_parse() : invalid MSS Option length.\\n\");\n                    return -1;\n                }\n                tcb->mss = (option->value[0] << 8) | option->value[1];\n                DEBUG(\"gnrc_tcp_option.c : _option_parse() : MSS option found. MSS=%\"PRIu16\"\\n\",\n                      tcb->mss);\n                break;\n\n            default:\n                DEBUG(\"gnrc_tcp_option.c : _option_parse() : Unknown option found.\\\n                      KIND=%\"PRIu8\", LENGTH=%\"PRIu8\"\\n\", option->kind, option->length);\n        }\n\n        if (option->length > opt_left) {\n            DEBUG(\"gnrc_tcp_option.c : _option_parse() : invalid option length\\n\");\n            return 0;\n        }\n\n        opt_ptr += option->length;\n        opt_left -= option->length;\n    }\n    return 0;\n}",
        "func": "int _option_parse(gnrc_tcp_tcb_t *tcb, tcp_hdr_t *hdr)\n{\n    /* Extract offset value. Return if no options are set */\n    uint8_t offset = GET_OFFSET(byteorder_ntohs(hdr->off_ctl));\n    if (offset <= TCP_HDR_OFFSET_MIN) {\n        return 0;\n    }\n\n    /* Get pointer to option field and field size */\n    uint8_t *opt_ptr = (uint8_t *) hdr + sizeof(tcp_hdr_t);\n    uint8_t opt_left = (offset - TCP_HDR_OFFSET_MIN) * 4;\n\n    /* Parse options via tcp_hdr_opt_t */\n    while (opt_left > 0) {\n        tcp_hdr_opt_t *option = (tcp_hdr_opt_t *) opt_ptr;\n\n        /* Examine current option */\n        switch (option->kind) {\n            case TCP_OPTION_KIND_EOL:\n                DEBUG(\"gnrc_tcp_option.c : _option_parse() : EOL option found\\n\");\n                return 0;\n\n            case TCP_OPTION_KIND_NOP:\n                DEBUG(\"gnrc_tcp_option.c : _option_parse() : NOP option found\\n\");\n                opt_ptr += 1;\n                opt_left -= 1;\n                continue;\n\n            case TCP_OPTION_KIND_MSS:\n                if (option->length != TCP_OPTION_LENGTH_MSS) {\n                    DEBUG(\"gnrc_tcp_option.c : _option_parse() : invalid MSS Option length.\\n\");\n                    return -1;\n                }\n                tcb->mss = (option->value[0] << 8) | option->value[1];\n                DEBUG(\"gnrc_tcp_option.c : _option_parse() : MSS option found. MSS=%\"PRIu16\"\\n\",\n                      tcb->mss);\n                break;\n\n            default:\n                DEBUG(\"gnrc_tcp_option.c : _option_parse() : Unknown option found.\\\n                      KIND=%\"PRIu8\", LENGTH=%\"PRIu8\"\\n\", option->kind, option->length);\n                return -1;\n        }\n\n        if (option->length > opt_left) {\n            DEBUG(\"gnrc_tcp_option.c : _option_parse() : invalid option length\\n\");\n            return 0;\n        }\n\n        opt_ptr += option->length;\n        opt_left -= option->length;\n    }\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,6 +39,7 @@\n             default:\n                 DEBUG(\"gnrc_tcp_option.c : _option_parse() : Unknown option found.\\\n                       KIND=%\"PRIu8\", LENGTH=%\"PRIu8\"\\n\", option->kind, option->length);\n+                return -1;\n         }\n \n         if (option->length > opt_left) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "                return -1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16319",
        "func_name": "wireshark/dissect_gryphon_message_with_offset",
        "description": "In Wireshark 3.0.0 to 3.0.3 and 2.6.0 to 2.6.10, the Gryphon dissector could go into an infinite loop. This was addressed in plugins/epan/gryphon/packet-gryphon.c by checking for a message length of zero.",
        "git_url": "https://github.com/wireshark/wireshark/commit/02ddd49885c6a09e936a76aceb726ed06539704a",
        "commit_title": "Gryphon: Prevent endless loop",
        "commit_text": " Bug: 16020 (cherry picked from commit 627917faff4889f763bf8e6570f62d66656047bd)",
        "func_before": "static int\ndissect_gryphon_message_with_offset(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree, gboolean is_msgresp_add)\n{\n    proto_tree      *gryphon_tree;\n    proto_item      *ti;\n    proto_tree      *header_tree, *body_tree;\n    int             msgend;\n    int             msglen, msgpad;\n    unsigned int    src, dest, i, frmtyp;\n    guint8          flags;\n\n    if (!is_msgresp_add) {\n        col_set_str(pinfo->cinfo, COL_PROTOCOL, \"Gryphon\");\n        col_clear(pinfo->cinfo, COL_INFO);\n    }\n\n    if (!is_msgresp_add) {\n        ti = proto_tree_add_item(tree, proto_gryphon, tvb, 0, -1, ENC_NA);\n        gryphon_tree = proto_item_add_subtree(ti, ett_gryphon);\n    } else\n        gryphon_tree = tree;\n\n    src = tvb_get_guint8(tvb, offset + 0);\n    dest = tvb_get_guint8(tvb, offset + 2);\n    msglen = tvb_get_ntohs(tvb, offset + 4);\n    flags = tvb_get_guint8(tvb, offset + 6);\n    frmtyp = flags & ~RESPONSE_FLAGS;\n\n    if (!is_msgresp_add) {\n        /*\n         * This tvbuff includes padding to make its length a multiple\n         * of 4 bytes; set it to the actual length.\n         */\n\n        /* TODO 20171011 this is not correct. can't use msglen here, because there is also padding in the msg? */\n        msgpad = 3 - (msglen + 3) % 4;\n        set_actual_length(tvb, msglen + msgpad + GRYPHON_FRAME_HEADER_LEN);\n\n        /*\n         * Indicate what kind of message this is.\n         */\n        col_set_str(pinfo->cinfo, COL_INFO, val_to_str_const(frmtyp, frame_type, \"- Invalid -\"));\n    }\n\n    if (tree == NULL)\n        return offset;\n\n    if (try_val_to_str(frmtyp, frame_type) == NULL) {\n        /*\n         * Unknown message type.\n         */\n        proto_tree_add_item(gryphon_tree, hf_gryphon_data, tvb, offset, msglen, ENC_NA);\n        offset += msglen;\n        return offset;\n    }\n\n    header_tree = proto_tree_add_subtree(gryphon_tree, tvb, offset, MSG_HDR_SZ, ett_gryphon_header, NULL, \"Header\");\n\n    /* src */\n    proto_tree_add_item(header_tree, hf_gryphon_src, tvb, offset, 1, ENC_BIG_ENDIAN);\n    /* 20180306 20171012 */\n    /* srcchan */\n    if(is_special_client(src)) {\n        proto_tree_add_item(header_tree, hf_gryphon_srcchanclient, tvb, offset+1, 1, ENC_BIG_ENDIAN);\n    } else {\n        proto_tree_add_item(header_tree, hf_gryphon_srcchan, tvb, offset+1, 1, ENC_BIG_ENDIAN);\n    }\n\n    /* dest */\n    proto_tree_add_item(header_tree, hf_gryphon_dest, tvb, offset+2, 1, ENC_BIG_ENDIAN);\n    /* 20180306 20171012 */\n    /* destchan */\n    if(is_special_client(dest)) {\n            proto_tree_add_item(header_tree, hf_gryphon_destchanclient, tvb, offset+3, 1, ENC_BIG_ENDIAN);\n    } else {\n            proto_tree_add_item(header_tree, hf_gryphon_destchan, tvb, offset+3, 1, ENC_BIG_ENDIAN);\n    }\n\n    proto_tree_add_item(header_tree, hf_gryphon_data_length, tvb, offset+4, 2, ENC_BIG_ENDIAN);\n    proto_tree_add_item(header_tree, hf_gryphon_type, tvb, offset+6, 1, ENC_BIG_ENDIAN);\n\n    if (is_msgresp_add) {\n        static const int * wait_flags[] = {\n            &hf_gryphon_wait_resp,\n            &hf_gryphon_wait_prev_resp,\n            NULL\n        };\n\n        proto_tree_add_bitmask(header_tree, tvb, offset+6, hf_gryphon_wait_flags, ett_gryphon_flags, wait_flags, ENC_NA);\n    }\n    proto_tree_add_item(header_tree, hf_gryphon_reserved, tvb, offset+7, 1, ENC_NA);\n    offset += MSG_HDR_SZ;\n\n    msgpad = 3 - (msglen + 3) % 4;\n    msgend = offset + msglen + msgpad;\n\n    body_tree = proto_tree_add_subtree(gryphon_tree, tvb, offset, msglen , ett_gryphon_body, NULL, \"Body\");\n\n    switch (frmtyp) {\n    case GY_FT_CMD:\n        offset = decode_command(tvb, msglen, offset, dest, body_tree);\n        break;\n    case GY_FT_RESP:\n        offset = decode_response(tvb, offset, src, body_tree);\n        break;\n    case GY_FT_DATA:\n        offset = decode_data(tvb, offset, body_tree);\n        break;\n    case GY_FT_EVENT:\n        offset = decode_event(tvb, offset, body_tree);\n        break;\n    case GY_FT_MISC:\n        offset = decode_misc (tvb, offset, body_tree);\n        break;\n    case GY_FT_TEXT:\n        offset = decode_text (tvb, offset, msglen, body_tree);\n        break;\n    case GY_FT_SIG:\n        break;\n    default:\n        break;\n    }\n\n    /*debug*/\n    /*i = msgend - offset;*/\n    /*proto_tree_add_debug_text(gryphon_tree, \"debug offset=%d msgend=%d i=%d\",offset,msgend,i);*/\n\n    if (offset < msgend) {\n        i = msgend - offset;\n        /*\n         * worked when msglen=4, offset=8, msgend=12, get i=4\n         * did not work when msglen=5, offset=8, msgend=16, i is 8\n         */\n        proto_tree_add_item(gryphon_tree, hf_gryphon_padding, tvb, offset, i, ENC_NA);\n        offset += i;\n    }\n    return offset;\n}",
        "func": "static int\ndissect_gryphon_message_with_offset(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree, gboolean is_msgresp_add)\n{\n    proto_tree      *gryphon_tree;\n    proto_item      *ti;\n    proto_tree      *header_tree, *body_tree;\n    int             msgend;\n    int             msglen, msgpad;\n    unsigned int    src, dest, i, frmtyp;\n    guint8          flags;\n\n    if (!is_msgresp_add) {\n        col_set_str(pinfo->cinfo, COL_PROTOCOL, \"Gryphon\");\n        col_clear(pinfo->cinfo, COL_INFO);\n    }\n\n    if (!is_msgresp_add) {\n        ti = proto_tree_add_item(tree, proto_gryphon, tvb, 0, -1, ENC_NA);\n        gryphon_tree = proto_item_add_subtree(ti, ett_gryphon);\n    } else\n        gryphon_tree = tree;\n\n    src = tvb_get_guint8(tvb, offset + 0);\n    dest = tvb_get_guint8(tvb, offset + 2);\n    msglen = tvb_get_ntohs(tvb, offset + 4);\n    flags = tvb_get_guint8(tvb, offset + 6);\n    frmtyp = flags & ~RESPONSE_FLAGS;\n\n    if (!is_msgresp_add) {\n        /*\n         * This tvbuff includes padding to make its length a multiple\n         * of 4 bytes; set it to the actual length.\n         */\n\n        /* TODO 20171011 this is not correct. can't use msglen here, because there is also padding in the msg? */\n        msgpad = 3 - (msglen + 3) % 4;\n        set_actual_length(tvb, msglen + msgpad + GRYPHON_FRAME_HEADER_LEN);\n\n        /*\n         * Indicate what kind of message this is.\n         */\n        col_set_str(pinfo->cinfo, COL_INFO, val_to_str_const(frmtyp, frame_type, \"- Invalid -\"));\n    }\n\n    if (tree == NULL)\n        return offset;\n\n    if (try_val_to_str(frmtyp, frame_type) == NULL) {\n        /*\n         * Unknown message type.\n         */\n        proto_tree_add_item(gryphon_tree, hf_gryphon_data, tvb, offset, msglen, ENC_NA);\n        if (msglen != 0) {\n            offset += msglen;\n        } else {\n            offset = tvb_reported_length_remaining(tvb, offset);\n        }\n        return offset;\n    }\n\n    header_tree = proto_tree_add_subtree(gryphon_tree, tvb, offset, MSG_HDR_SZ, ett_gryphon_header, NULL, \"Header\");\n\n    /* src */\n    proto_tree_add_item(header_tree, hf_gryphon_src, tvb, offset, 1, ENC_BIG_ENDIAN);\n    /* 20180306 20171012 */\n    /* srcchan */\n    if(is_special_client(src)) {\n        proto_tree_add_item(header_tree, hf_gryphon_srcchanclient, tvb, offset+1, 1, ENC_BIG_ENDIAN);\n    } else {\n        proto_tree_add_item(header_tree, hf_gryphon_srcchan, tvb, offset+1, 1, ENC_BIG_ENDIAN);\n    }\n\n    /* dest */\n    proto_tree_add_item(header_tree, hf_gryphon_dest, tvb, offset+2, 1, ENC_BIG_ENDIAN);\n    /* 20180306 20171012 */\n    /* destchan */\n    if(is_special_client(dest)) {\n            proto_tree_add_item(header_tree, hf_gryphon_destchanclient, tvb, offset+3, 1, ENC_BIG_ENDIAN);\n    } else {\n            proto_tree_add_item(header_tree, hf_gryphon_destchan, tvb, offset+3, 1, ENC_BIG_ENDIAN);\n    }\n\n    proto_tree_add_item(header_tree, hf_gryphon_data_length, tvb, offset+4, 2, ENC_BIG_ENDIAN);\n    proto_tree_add_item(header_tree, hf_gryphon_type, tvb, offset+6, 1, ENC_BIG_ENDIAN);\n\n    if (is_msgresp_add) {\n        static const int * wait_flags[] = {\n            &hf_gryphon_wait_resp,\n            &hf_gryphon_wait_prev_resp,\n            NULL\n        };\n\n        proto_tree_add_bitmask(header_tree, tvb, offset+6, hf_gryphon_wait_flags, ett_gryphon_flags, wait_flags, ENC_NA);\n    }\n    proto_tree_add_item(header_tree, hf_gryphon_reserved, tvb, offset+7, 1, ENC_NA);\n    offset += MSG_HDR_SZ;\n\n    msgpad = 3 - (msglen + 3) % 4;\n    msgend = offset + msglen + msgpad;\n\n    body_tree = proto_tree_add_subtree(gryphon_tree, tvb, offset, msglen , ett_gryphon_body, NULL, \"Body\");\n\n    switch (frmtyp) {\n    case GY_FT_CMD:\n        offset = decode_command(tvb, msglen, offset, dest, body_tree);\n        break;\n    case GY_FT_RESP:\n        offset = decode_response(tvb, offset, src, body_tree);\n        break;\n    case GY_FT_DATA:\n        offset = decode_data(tvb, offset, body_tree);\n        break;\n    case GY_FT_EVENT:\n        offset = decode_event(tvb, offset, body_tree);\n        break;\n    case GY_FT_MISC:\n        offset = decode_misc (tvb, offset, body_tree);\n        break;\n    case GY_FT_TEXT:\n        offset = decode_text (tvb, offset, msglen, body_tree);\n        break;\n    case GY_FT_SIG:\n        break;\n    default:\n        break;\n    }\n\n    /*debug*/\n    /*i = msgend - offset;*/\n    /*proto_tree_add_debug_text(gryphon_tree, \"debug offset=%d msgend=%d i=%d\",offset,msgend,i);*/\n\n    if (offset < msgend) {\n        i = msgend - offset;\n        /*\n         * worked when msglen=4, offset=8, msgend=12, get i=4\n         * did not work when msglen=5, offset=8, msgend=16, i is 8\n         */\n        proto_tree_add_item(gryphon_tree, hf_gryphon_padding, tvb, offset, i, ENC_NA);\n        offset += i;\n    }\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -50,7 +50,11 @@\n          * Unknown message type.\n          */\n         proto_tree_add_item(gryphon_tree, hf_gryphon_data, tvb, offset, msglen, ENC_NA);\n-        offset += msglen;\n+        if (msglen != 0) {\n+            offset += msglen;\n+        } else {\n+            offset = tvb_reported_length_remaining(tvb, offset);\n+        }\n         return offset;\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "        offset += msglen;"
            ],
            "added_lines": [
                "        if (msglen != 0) {",
                "            offset += msglen;",
                "        } else {",
                "            offset = tvb_reported_length_remaining(tvb, offset);",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16413",
        "func_name": "torvalds/linux/v9fs_file_write_iter",
        "description": "An issue was discovered in the Linux kernel before 5.0.4. The 9p filesystem did not protect i_size_write() properly, which causes an i_size_read() infinite loop and denial of service on SMP systems.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f",
        "commit_title": "Use inode->i_lock to protect i_size_write(), else i_size_read() in",
        "commit_text": "generic_fillattr() may loop infinitely in read_seqcount_begin() when multiple processes invoke v9fs_vfs_getattr() or v9fs_vfs_getattr_dotl() simultaneously under 32-bit SMP environment, and a soft lockup will be triggered as show below:    watchdog: BUG: soft lockup - CPU#5 stuck for 22s! [stat:2217]   Modules linked in:   CPU: 5 PID: 2217 Comm: stat Not tainted 5.0.0-rc1-00005-g7f702faf5a9e #4   Hardware name: Generic DT based system   PC is at generic_fillattr+0x104/0x108   LR is at 0xec497f00   pc : [<802b8898>]    lr : [<ec497f00>]    psr: 200c0013   sp : ec497e20  ip : ed608030  fp : ec497e3c   r10: 00000000  r9 : ec497f00  r8 : ed608030   r7 : ec497ebc  r6 : ec497f00  r5 : ee5c1550  r4 : ee005780   r3 : 0000052d  r2 : 00000000  r1 : ec497f00  r0 : ed608030   Flags: nzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment none   Control: 10c5387d  Table: ac48006a  DAC: 00000051   CPU: 5 PID: 2217 Comm: stat Not tainted 5.0.0-rc1-00005-g7f702faf5a9e #4   Hardware name: Generic DT based system   Backtrace:   [<8010d974>] (dump_backtrace) from [<8010dc88>] (show_stack+0x20/0x24)   [<8010dc68>] (show_stack) from [<80a1d194>] (dump_stack+0xb0/0xdc)   [<80a1d0e4>] (dump_stack) from [<80109f34>] (show_regs+0x1c/0x20)   [<80109f18>] (show_regs) from [<801d0a80>] (watchdog_timer_fn+0x280/0x2f8)   [<801d0800>] (watchdog_timer_fn) from [<80198658>] (__hrtimer_run_queues+0x18c/0x380)   [<801984cc>] (__hrtimer_run_queues) from [<80198e60>] (hrtimer_run_queues+0xb8/0xf0)   [<80198da8>] (hrtimer_run_queues) from [<801973e8>] (run_local_timers+0x28/0x64)   [<801973c0>] (run_local_timers) from [<80197460>] (update_process_times+0x3c/0x6c)   [<80197424>] (update_process_times) from [<801ab2b8>] (tick_nohz_handler+0xe0/0x1bc)   [<801ab1d8>] (tick_nohz_handler) from [<80843050>] (arch_timer_handler_virt+0x38/0x48)   [<80843018>] (arch_timer_handler_virt) from [<80180a64>] (handle_percpu_devid_irq+0x8c/0x240)   [<801809d8>] (handle_percpu_devid_irq) from [<8017ac20>] (generic_handle_irq+0x34/0x44)   [<8017abec>] (generic_handle_irq) from [<8017b344>] (__handle_domain_irq+0x6c/0xc4)   [<8017b2d8>] (__handle_domain_irq) from [<801022e0>] (gic_handle_irq+0x4c/0x88)   [<80102294>] (gic_handle_irq) from [<80101a30>] (__irq_svc+0x70/0x98)   [<802b8794>] (generic_fillattr) from [<8056b284>] (v9fs_vfs_getattr_dotl+0x74/0xa4)   [<8056b210>] (v9fs_vfs_getattr_dotl) from [<802b8904>] (vfs_getattr_nosec+0x68/0x7c)   [<802b889c>] (vfs_getattr_nosec) from [<802b895c>] (vfs_getattr+0x44/0x48)   [<802b8918>] (vfs_getattr) from [<802b8a74>] (vfs_statx+0x9c/0xec)   [<802b89d8>] (vfs_statx) from [<802b9428>] (sys_lstat64+0x48/0x78)   [<802b93e0>] (sys_lstat64) from [<80101000>] (ret_fast_syscall+0x0/0x28)  [dominique.martinet@cea.fr: updated comment to not refer to a function in another subsystem] Link: http://lkml.kernel.org/r/20190124063514.8571-2-houtao1@huawei.com Cc: stable@vger.kernel.org ",
        "func_before": "static ssize_t\nv9fs_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tssize_t retval;\n\tloff_t origin;\n\tint err = 0;\n\n\tretval = generic_write_checks(iocb, from);\n\tif (retval <= 0)\n\t\treturn retval;\n\n\torigin = iocb->ki_pos;\n\tretval = p9_client_write(file->private_data, iocb->ki_pos, from, &err);\n\tif (retval > 0) {\n\t\tstruct inode *inode = file_inode(file);\n\t\tloff_t i_size;\n\t\tunsigned long pg_start, pg_end;\n\t\tpg_start = origin >> PAGE_SHIFT;\n\t\tpg_end = (origin + retval - 1) >> PAGE_SHIFT;\n\t\tif (inode->i_mapping && inode->i_mapping->nrpages)\n\t\t\tinvalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\t\t\t      pg_start, pg_end);\n\t\tiocb->ki_pos += retval;\n\t\ti_size = i_size_read(inode);\n\t\tif (iocb->ki_pos > i_size) {\n\t\t\tinode_add_bytes(inode, iocb->ki_pos - i_size);\n\t\t\ti_size_write(inode, iocb->ki_pos);\n\t\t}\n\t\treturn retval;\n\t}\n\treturn err;\n}",
        "func": "static ssize_t\nv9fs_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tssize_t retval;\n\tloff_t origin;\n\tint err = 0;\n\n\tretval = generic_write_checks(iocb, from);\n\tif (retval <= 0)\n\t\treturn retval;\n\n\torigin = iocb->ki_pos;\n\tretval = p9_client_write(file->private_data, iocb->ki_pos, from, &err);\n\tif (retval > 0) {\n\t\tstruct inode *inode = file_inode(file);\n\t\tloff_t i_size;\n\t\tunsigned long pg_start, pg_end;\n\t\tpg_start = origin >> PAGE_SHIFT;\n\t\tpg_end = (origin + retval - 1) >> PAGE_SHIFT;\n\t\tif (inode->i_mapping && inode->i_mapping->nrpages)\n\t\t\tinvalidate_inode_pages2_range(inode->i_mapping,\n\t\t\t\t\t\t      pg_start, pg_end);\n\t\tiocb->ki_pos += retval;\n\t\ti_size = i_size_read(inode);\n\t\tif (iocb->ki_pos > i_size) {\n\t\t\tinode_add_bytes(inode, iocb->ki_pos - i_size);\n\t\t\t/*\n\t\t\t * Need to serialize against i_size_write() in\n\t\t\t * v9fs_stat2inode()\n\t\t\t */\n\t\t\tv9fs_i_size_write(inode, iocb->ki_pos);\n\t\t}\n\t\treturn retval;\n\t}\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,7 +25,11 @@\n \t\ti_size = i_size_read(inode);\n \t\tif (iocb->ki_pos > i_size) {\n \t\t\tinode_add_bytes(inode, iocb->ki_pos - i_size);\n-\t\t\ti_size_write(inode, iocb->ki_pos);\n+\t\t\t/*\n+\t\t\t * Need to serialize against i_size_write() in\n+\t\t\t * v9fs_stat2inode()\n+\t\t\t */\n+\t\t\tv9fs_i_size_write(inode, iocb->ki_pos);\n \t\t}\n \t\treturn retval;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\ti_size_write(inode, iocb->ki_pos);"
            ],
            "added_lines": [
                "\t\t\t/*",
                "\t\t\t * Need to serialize against i_size_write() in",
                "\t\t\t * v9fs_stat2inode()",
                "\t\t\t */",
                "\t\t\tv9fs_i_size_write(inode, iocb->ki_pos);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16413",
        "func_name": "torvalds/linux/v9fs_refresh_inode_dotl",
        "description": "An issue was discovered in the Linux kernel before 5.0.4. The 9p filesystem did not protect i_size_write() properly, which causes an i_size_read() infinite loop and denial of service on SMP systems.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f",
        "commit_title": "Use inode->i_lock to protect i_size_write(), else i_size_read() in",
        "commit_text": "generic_fillattr() may loop infinitely in read_seqcount_begin() when multiple processes invoke v9fs_vfs_getattr() or v9fs_vfs_getattr_dotl() simultaneously under 32-bit SMP environment, and a soft lockup will be triggered as show below:    watchdog: BUG: soft lockup - CPU#5 stuck for 22s! [stat:2217]   Modules linked in:   CPU: 5 PID: 2217 Comm: stat Not tainted 5.0.0-rc1-00005-g7f702faf5a9e #4   Hardware name: Generic DT based system   PC is at generic_fillattr+0x104/0x108   LR is at 0xec497f00   pc : [<802b8898>]    lr : [<ec497f00>]    psr: 200c0013   sp : ec497e20  ip : ed608030  fp : ec497e3c   r10: 00000000  r9 : ec497f00  r8 : ed608030   r7 : ec497ebc  r6 : ec497f00  r5 : ee5c1550  r4 : ee005780   r3 : 0000052d  r2 : 00000000  r1 : ec497f00  r0 : ed608030   Flags: nzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment none   Control: 10c5387d  Table: ac48006a  DAC: 00000051   CPU: 5 PID: 2217 Comm: stat Not tainted 5.0.0-rc1-00005-g7f702faf5a9e #4   Hardware name: Generic DT based system   Backtrace:   [<8010d974>] (dump_backtrace) from [<8010dc88>] (show_stack+0x20/0x24)   [<8010dc68>] (show_stack) from [<80a1d194>] (dump_stack+0xb0/0xdc)   [<80a1d0e4>] (dump_stack) from [<80109f34>] (show_regs+0x1c/0x20)   [<80109f18>] (show_regs) from [<801d0a80>] (watchdog_timer_fn+0x280/0x2f8)   [<801d0800>] (watchdog_timer_fn) from [<80198658>] (__hrtimer_run_queues+0x18c/0x380)   [<801984cc>] (__hrtimer_run_queues) from [<80198e60>] (hrtimer_run_queues+0xb8/0xf0)   [<80198da8>] (hrtimer_run_queues) from [<801973e8>] (run_local_timers+0x28/0x64)   [<801973c0>] (run_local_timers) from [<80197460>] (update_process_times+0x3c/0x6c)   [<80197424>] (update_process_times) from [<801ab2b8>] (tick_nohz_handler+0xe0/0x1bc)   [<801ab1d8>] (tick_nohz_handler) from [<80843050>] (arch_timer_handler_virt+0x38/0x48)   [<80843018>] (arch_timer_handler_virt) from [<80180a64>] (handle_percpu_devid_irq+0x8c/0x240)   [<801809d8>] (handle_percpu_devid_irq) from [<8017ac20>] (generic_handle_irq+0x34/0x44)   [<8017abec>] (generic_handle_irq) from [<8017b344>] (__handle_domain_irq+0x6c/0xc4)   [<8017b2d8>] (__handle_domain_irq) from [<801022e0>] (gic_handle_irq+0x4c/0x88)   [<80102294>] (gic_handle_irq) from [<80101a30>] (__irq_svc+0x70/0x98)   [<802b8794>] (generic_fillattr) from [<8056b284>] (v9fs_vfs_getattr_dotl+0x74/0xa4)   [<8056b210>] (v9fs_vfs_getattr_dotl) from [<802b8904>] (vfs_getattr_nosec+0x68/0x7c)   [<802b889c>] (vfs_getattr_nosec) from [<802b895c>] (vfs_getattr+0x44/0x48)   [<802b8918>] (vfs_getattr) from [<802b8a74>] (vfs_statx+0x9c/0xec)   [<802b89d8>] (vfs_statx) from [<802b9428>] (sys_lstat64+0x48/0x78)   [<802b93e0>] (sys_lstat64) from [<80101000>] (ret_fast_syscall+0x0/0x28)  [dominique.martinet@cea.fr: updated comment to not refer to a function in another subsystem] Link: http://lkml.kernel.org/r/20190124063514.8571-2-houtao1@huawei.com Cc: stable@vger.kernel.org ",
        "func_before": "int v9fs_refresh_inode_dotl(struct p9_fid *fid, struct inode *inode)\n{\n\tloff_t i_size;\n\tstruct p9_stat_dotl *st;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tst = p9_client_getattr_dotl(fid, P9_STATS_ALL);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\t/*\n\t * Don't update inode if the file type is different\n\t */\n\tif ((inode->i_mode & S_IFMT) != (st->st_mode & S_IFMT))\n\t\tgoto out;\n\n\tspin_lock(&inode->i_lock);\n\t/*\n\t * We don't want to refresh inode->i_size,\n\t * because we may have cached data\n\t */\n\ti_size = inode->i_size;\n\tv9fs_stat2inode_dotl(st, inode);\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n\t\tinode->i_size = i_size;\n\tspin_unlock(&inode->i_lock);\nout:\n\tkfree(st);\n\treturn 0;\n}",
        "func": "int v9fs_refresh_inode_dotl(struct p9_fid *fid, struct inode *inode)\n{\n\tstruct p9_stat_dotl *st;\n\tstruct v9fs_session_info *v9ses;\n\tunsigned int flags;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tst = p9_client_getattr_dotl(fid, P9_STATS_ALL);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\t/*\n\t * Don't update inode if the file type is different\n\t */\n\tif ((inode->i_mode & S_IFMT) != (st->st_mode & S_IFMT))\n\t\tgoto out;\n\n\t/*\n\t * We don't want to refresh inode->i_size,\n\t * because we may have cached data\n\t */\n\tflags = (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) ?\n\t\tV9FS_STAT2INODE_KEEP_ISIZE : 0;\n\tv9fs_stat2inode_dotl(st, inode, flags);\nout:\n\tkfree(st);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,8 @@\n int v9fs_refresh_inode_dotl(struct p9_fid *fid, struct inode *inode)\n {\n-\tloff_t i_size;\n \tstruct p9_stat_dotl *st;\n \tstruct v9fs_session_info *v9ses;\n+\tunsigned int flags;\n \n \tv9ses = v9fs_inode2v9ses(inode);\n \tst = p9_client_getattr_dotl(fid, P9_STATS_ALL);\n@@ -14,16 +14,13 @@\n \tif ((inode->i_mode & S_IFMT) != (st->st_mode & S_IFMT))\n \t\tgoto out;\n \n-\tspin_lock(&inode->i_lock);\n \t/*\n \t * We don't want to refresh inode->i_size,\n \t * because we may have cached data\n \t */\n-\ti_size = inode->i_size;\n-\tv9fs_stat2inode_dotl(st, inode);\n-\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n-\t\tinode->i_size = i_size;\n-\tspin_unlock(&inode->i_lock);\n+\tflags = (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) ?\n+\t\tV9FS_STAT2INODE_KEEP_ISIZE : 0;\n+\tv9fs_stat2inode_dotl(st, inode, flags);\n out:\n \tkfree(st);\n \treturn 0;",
        "diff_line_info": {
            "deleted_lines": [
                "\tloff_t i_size;",
                "\tspin_lock(&inode->i_lock);",
                "\ti_size = inode->i_size;",
                "\tv9fs_stat2inode_dotl(st, inode);",
                "\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)",
                "\t\tinode->i_size = i_size;",
                "\tspin_unlock(&inode->i_lock);"
            ],
            "added_lines": [
                "\tunsigned int flags;",
                "\tflags = (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) ?",
                "\t\tV9FS_STAT2INODE_KEEP_ISIZE : 0;",
                "\tv9fs_stat2inode_dotl(st, inode, flags);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16413",
        "func_name": "torvalds/linux/v9fs_stat2inode_dotl",
        "description": "An issue was discovered in the Linux kernel before 5.0.4. The 9p filesystem did not protect i_size_write() properly, which causes an i_size_read() infinite loop and denial of service on SMP systems.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f",
        "commit_title": "Use inode->i_lock to protect i_size_write(), else i_size_read() in",
        "commit_text": "generic_fillattr() may loop infinitely in read_seqcount_begin() when multiple processes invoke v9fs_vfs_getattr() or v9fs_vfs_getattr_dotl() simultaneously under 32-bit SMP environment, and a soft lockup will be triggered as show below:    watchdog: BUG: soft lockup - CPU#5 stuck for 22s! [stat:2217]   Modules linked in:   CPU: 5 PID: 2217 Comm: stat Not tainted 5.0.0-rc1-00005-g7f702faf5a9e #4   Hardware name: Generic DT based system   PC is at generic_fillattr+0x104/0x108   LR is at 0xec497f00   pc : [<802b8898>]    lr : [<ec497f00>]    psr: 200c0013   sp : ec497e20  ip : ed608030  fp : ec497e3c   r10: 00000000  r9 : ec497f00  r8 : ed608030   r7 : ec497ebc  r6 : ec497f00  r5 : ee5c1550  r4 : ee005780   r3 : 0000052d  r2 : 00000000  r1 : ec497f00  r0 : ed608030   Flags: nzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment none   Control: 10c5387d  Table: ac48006a  DAC: 00000051   CPU: 5 PID: 2217 Comm: stat Not tainted 5.0.0-rc1-00005-g7f702faf5a9e #4   Hardware name: Generic DT based system   Backtrace:   [<8010d974>] (dump_backtrace) from [<8010dc88>] (show_stack+0x20/0x24)   [<8010dc68>] (show_stack) from [<80a1d194>] (dump_stack+0xb0/0xdc)   [<80a1d0e4>] (dump_stack) from [<80109f34>] (show_regs+0x1c/0x20)   [<80109f18>] (show_regs) from [<801d0a80>] (watchdog_timer_fn+0x280/0x2f8)   [<801d0800>] (watchdog_timer_fn) from [<80198658>] (__hrtimer_run_queues+0x18c/0x380)   [<801984cc>] (__hrtimer_run_queues) from [<80198e60>] (hrtimer_run_queues+0xb8/0xf0)   [<80198da8>] (hrtimer_run_queues) from [<801973e8>] (run_local_timers+0x28/0x64)   [<801973c0>] (run_local_timers) from [<80197460>] (update_process_times+0x3c/0x6c)   [<80197424>] (update_process_times) from [<801ab2b8>] (tick_nohz_handler+0xe0/0x1bc)   [<801ab1d8>] (tick_nohz_handler) from [<80843050>] (arch_timer_handler_virt+0x38/0x48)   [<80843018>] (arch_timer_handler_virt) from [<80180a64>] (handle_percpu_devid_irq+0x8c/0x240)   [<801809d8>] (handle_percpu_devid_irq) from [<8017ac20>] (generic_handle_irq+0x34/0x44)   [<8017abec>] (generic_handle_irq) from [<8017b344>] (__handle_domain_irq+0x6c/0xc4)   [<8017b2d8>] (__handle_domain_irq) from [<801022e0>] (gic_handle_irq+0x4c/0x88)   [<80102294>] (gic_handle_irq) from [<80101a30>] (__irq_svc+0x70/0x98)   [<802b8794>] (generic_fillattr) from [<8056b284>] (v9fs_vfs_getattr_dotl+0x74/0xa4)   [<8056b210>] (v9fs_vfs_getattr_dotl) from [<802b8904>] (vfs_getattr_nosec+0x68/0x7c)   [<802b889c>] (vfs_getattr_nosec) from [<802b895c>] (vfs_getattr+0x44/0x48)   [<802b8918>] (vfs_getattr) from [<802b8a74>] (vfs_statx+0x9c/0xec)   [<802b89d8>] (vfs_statx) from [<802b9428>] (sys_lstat64+0x48/0x78)   [<802b93e0>] (sys_lstat64) from [<80101000>] (ret_fast_syscall+0x0/0x28)  [dominique.martinet@cea.fr: updated comment to not refer to a function in another subsystem] Link: http://lkml.kernel.org/r/20190124063514.8571-2-houtao1@huawei.com Cc: stable@vger.kernel.org ",
        "func_before": "void\nv9fs_stat2inode_dotl(struct p9_stat_dotl *stat, struct inode *inode)\n{\n\tumode_t mode;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tif ((stat->st_result_mask & P9_STATS_BASIC) == P9_STATS_BASIC) {\n\t\tinode->i_atime.tv_sec = stat->st_atime_sec;\n\t\tinode->i_atime.tv_nsec = stat->st_atime_nsec;\n\t\tinode->i_mtime.tv_sec = stat->st_mtime_sec;\n\t\tinode->i_mtime.tv_nsec = stat->st_mtime_nsec;\n\t\tinode->i_ctime.tv_sec = stat->st_ctime_sec;\n\t\tinode->i_ctime.tv_nsec = stat->st_ctime_nsec;\n\t\tinode->i_uid = stat->st_uid;\n\t\tinode->i_gid = stat->st_gid;\n\t\tset_nlink(inode, stat->st_nlink);\n\n\t\tmode = stat->st_mode & S_IALLUGO;\n\t\tmode |= inode->i_mode & ~S_IALLUGO;\n\t\tinode->i_mode = mode;\n\n\t\ti_size_write(inode, stat->st_size);\n\t\tinode->i_blocks = stat->st_blocks;\n\t} else {\n\t\tif (stat->st_result_mask & P9_STATS_ATIME) {\n\t\t\tinode->i_atime.tv_sec = stat->st_atime_sec;\n\t\t\tinode->i_atime.tv_nsec = stat->st_atime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_MTIME) {\n\t\t\tinode->i_mtime.tv_sec = stat->st_mtime_sec;\n\t\t\tinode->i_mtime.tv_nsec = stat->st_mtime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_CTIME) {\n\t\t\tinode->i_ctime.tv_sec = stat->st_ctime_sec;\n\t\t\tinode->i_ctime.tv_nsec = stat->st_ctime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_UID)\n\t\t\tinode->i_uid = stat->st_uid;\n\t\tif (stat->st_result_mask & P9_STATS_GID)\n\t\t\tinode->i_gid = stat->st_gid;\n\t\tif (stat->st_result_mask & P9_STATS_NLINK)\n\t\t\tset_nlink(inode, stat->st_nlink);\n\t\tif (stat->st_result_mask & P9_STATS_MODE) {\n\t\t\tinode->i_mode = stat->st_mode;\n\t\t\tif ((S_ISBLK(inode->i_mode)) ||\n\t\t\t\t\t\t(S_ISCHR(inode->i_mode)))\n\t\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\t\t\t\t\tinode->i_rdev);\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_RDEV)\n\t\t\tinode->i_rdev = new_decode_dev(stat->st_rdev);\n\t\tif (stat->st_result_mask & P9_STATS_SIZE)\n\t\t\ti_size_write(inode, stat->st_size);\n\t\tif (stat->st_result_mask & P9_STATS_BLOCKS)\n\t\t\tinode->i_blocks = stat->st_blocks;\n\t}\n\tif (stat->st_result_mask & P9_STATS_GEN)\n\t\tinode->i_generation = stat->st_gen;\n\n\t/* Currently we don't support P9_STATS_BTIME and P9_STATS_DATA_VERSION\n\t * because the inode structure does not have fields for them.\n\t */\n\tv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\n}",
        "func": "void\nv9fs_stat2inode_dotl(struct p9_stat_dotl *stat, struct inode *inode,\n\t\t      unsigned int flags)\n{\n\tumode_t mode;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tif ((stat->st_result_mask & P9_STATS_BASIC) == P9_STATS_BASIC) {\n\t\tinode->i_atime.tv_sec = stat->st_atime_sec;\n\t\tinode->i_atime.tv_nsec = stat->st_atime_nsec;\n\t\tinode->i_mtime.tv_sec = stat->st_mtime_sec;\n\t\tinode->i_mtime.tv_nsec = stat->st_mtime_nsec;\n\t\tinode->i_ctime.tv_sec = stat->st_ctime_sec;\n\t\tinode->i_ctime.tv_nsec = stat->st_ctime_nsec;\n\t\tinode->i_uid = stat->st_uid;\n\t\tinode->i_gid = stat->st_gid;\n\t\tset_nlink(inode, stat->st_nlink);\n\n\t\tmode = stat->st_mode & S_IALLUGO;\n\t\tmode |= inode->i_mode & ~S_IALLUGO;\n\t\tinode->i_mode = mode;\n\n\t\tif (!(flags & V9FS_STAT2INODE_KEEP_ISIZE))\n\t\t\tv9fs_i_size_write(inode, stat->st_size);\n\t\tinode->i_blocks = stat->st_blocks;\n\t} else {\n\t\tif (stat->st_result_mask & P9_STATS_ATIME) {\n\t\t\tinode->i_atime.tv_sec = stat->st_atime_sec;\n\t\t\tinode->i_atime.tv_nsec = stat->st_atime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_MTIME) {\n\t\t\tinode->i_mtime.tv_sec = stat->st_mtime_sec;\n\t\t\tinode->i_mtime.tv_nsec = stat->st_mtime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_CTIME) {\n\t\t\tinode->i_ctime.tv_sec = stat->st_ctime_sec;\n\t\t\tinode->i_ctime.tv_nsec = stat->st_ctime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_UID)\n\t\t\tinode->i_uid = stat->st_uid;\n\t\tif (stat->st_result_mask & P9_STATS_GID)\n\t\t\tinode->i_gid = stat->st_gid;\n\t\tif (stat->st_result_mask & P9_STATS_NLINK)\n\t\t\tset_nlink(inode, stat->st_nlink);\n\t\tif (stat->st_result_mask & P9_STATS_MODE) {\n\t\t\tinode->i_mode = stat->st_mode;\n\t\t\tif ((S_ISBLK(inode->i_mode)) ||\n\t\t\t\t\t\t(S_ISCHR(inode->i_mode)))\n\t\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\t\t\t\t\tinode->i_rdev);\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_RDEV)\n\t\t\tinode->i_rdev = new_decode_dev(stat->st_rdev);\n\t\tif (!(flags & V9FS_STAT2INODE_KEEP_ISIZE) &&\n\t\t    stat->st_result_mask & P9_STATS_SIZE)\n\t\t\tv9fs_i_size_write(inode, stat->st_size);\n\t\tif (stat->st_result_mask & P9_STATS_BLOCKS)\n\t\t\tinode->i_blocks = stat->st_blocks;\n\t}\n\tif (stat->st_result_mask & P9_STATS_GEN)\n\t\tinode->i_generation = stat->st_gen;\n\n\t/* Currently we don't support P9_STATS_BTIME and P9_STATS_DATA_VERSION\n\t * because the inode structure does not have fields for them.\n\t */\n\tv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n void\n-v9fs_stat2inode_dotl(struct p9_stat_dotl *stat, struct inode *inode)\n+v9fs_stat2inode_dotl(struct p9_stat_dotl *stat, struct inode *inode,\n+\t\t      unsigned int flags)\n {\n \tumode_t mode;\n \tstruct v9fs_inode *v9inode = V9FS_I(inode);\n@@ -19,7 +20,8 @@\n \t\tmode |= inode->i_mode & ~S_IALLUGO;\n \t\tinode->i_mode = mode;\n \n-\t\ti_size_write(inode, stat->st_size);\n+\t\tif (!(flags & V9FS_STAT2INODE_KEEP_ISIZE))\n+\t\t\tv9fs_i_size_write(inode, stat->st_size);\n \t\tinode->i_blocks = stat->st_blocks;\n \t} else {\n \t\tif (stat->st_result_mask & P9_STATS_ATIME) {\n@@ -49,8 +51,9 @@\n \t\t}\n \t\tif (stat->st_result_mask & P9_STATS_RDEV)\n \t\t\tinode->i_rdev = new_decode_dev(stat->st_rdev);\n-\t\tif (stat->st_result_mask & P9_STATS_SIZE)\n-\t\t\ti_size_write(inode, stat->st_size);\n+\t\tif (!(flags & V9FS_STAT2INODE_KEEP_ISIZE) &&\n+\t\t    stat->st_result_mask & P9_STATS_SIZE)\n+\t\t\tv9fs_i_size_write(inode, stat->st_size);\n \t\tif (stat->st_result_mask & P9_STATS_BLOCKS)\n \t\t\tinode->i_blocks = stat->st_blocks;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "v9fs_stat2inode_dotl(struct p9_stat_dotl *stat, struct inode *inode)",
                "\t\ti_size_write(inode, stat->st_size);",
                "\t\tif (stat->st_result_mask & P9_STATS_SIZE)",
                "\t\t\ti_size_write(inode, stat->st_size);"
            ],
            "added_lines": [
                "v9fs_stat2inode_dotl(struct p9_stat_dotl *stat, struct inode *inode,",
                "\t\t      unsigned int flags)",
                "\t\tif (!(flags & V9FS_STAT2INODE_KEEP_ISIZE))",
                "\t\t\tv9fs_i_size_write(inode, stat->st_size);",
                "\t\tif (!(flags & V9FS_STAT2INODE_KEEP_ISIZE) &&",
                "\t\t    stat->st_result_mask & P9_STATS_SIZE)",
                "\t\t\tv9fs_i_size_write(inode, stat->st_size);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16413",
        "func_name": "torvalds/linux/v9fs_qid_iget_dotl",
        "description": "An issue was discovered in the Linux kernel before 5.0.4. The 9p filesystem did not protect i_size_write() properly, which causes an i_size_read() infinite loop and denial of service on SMP systems.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f",
        "commit_title": "Use inode->i_lock to protect i_size_write(), else i_size_read() in",
        "commit_text": "generic_fillattr() may loop infinitely in read_seqcount_begin() when multiple processes invoke v9fs_vfs_getattr() or v9fs_vfs_getattr_dotl() simultaneously under 32-bit SMP environment, and a soft lockup will be triggered as show below:    watchdog: BUG: soft lockup - CPU#5 stuck for 22s! [stat:2217]   Modules linked in:   CPU: 5 PID: 2217 Comm: stat Not tainted 5.0.0-rc1-00005-g7f702faf5a9e #4   Hardware name: Generic DT based system   PC is at generic_fillattr+0x104/0x108   LR is at 0xec497f00   pc : [<802b8898>]    lr : [<ec497f00>]    psr: 200c0013   sp : ec497e20  ip : ed608030  fp : ec497e3c   r10: 00000000  r9 : ec497f00  r8 : ed608030   r7 : ec497ebc  r6 : ec497f00  r5 : ee5c1550  r4 : ee005780   r3 : 0000052d  r2 : 00000000  r1 : ec497f00  r0 : ed608030   Flags: nzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment none   Control: 10c5387d  Table: ac48006a  DAC: 00000051   CPU: 5 PID: 2217 Comm: stat Not tainted 5.0.0-rc1-00005-g7f702faf5a9e #4   Hardware name: Generic DT based system   Backtrace:   [<8010d974>] (dump_backtrace) from [<8010dc88>] (show_stack+0x20/0x24)   [<8010dc68>] (show_stack) from [<80a1d194>] (dump_stack+0xb0/0xdc)   [<80a1d0e4>] (dump_stack) from [<80109f34>] (show_regs+0x1c/0x20)   [<80109f18>] (show_regs) from [<801d0a80>] (watchdog_timer_fn+0x280/0x2f8)   [<801d0800>] (watchdog_timer_fn) from [<80198658>] (__hrtimer_run_queues+0x18c/0x380)   [<801984cc>] (__hrtimer_run_queues) from [<80198e60>] (hrtimer_run_queues+0xb8/0xf0)   [<80198da8>] (hrtimer_run_queues) from [<801973e8>] (run_local_timers+0x28/0x64)   [<801973c0>] (run_local_timers) from [<80197460>] (update_process_times+0x3c/0x6c)   [<80197424>] (update_process_times) from [<801ab2b8>] (tick_nohz_handler+0xe0/0x1bc)   [<801ab1d8>] (tick_nohz_handler) from [<80843050>] (arch_timer_handler_virt+0x38/0x48)   [<80843018>] (arch_timer_handler_virt) from [<80180a64>] (handle_percpu_devid_irq+0x8c/0x240)   [<801809d8>] (handle_percpu_devid_irq) from [<8017ac20>] (generic_handle_irq+0x34/0x44)   [<8017abec>] (generic_handle_irq) from [<8017b344>] (__handle_domain_irq+0x6c/0xc4)   [<8017b2d8>] (__handle_domain_irq) from [<801022e0>] (gic_handle_irq+0x4c/0x88)   [<80102294>] (gic_handle_irq) from [<80101a30>] (__irq_svc+0x70/0x98)   [<802b8794>] (generic_fillattr) from [<8056b284>] (v9fs_vfs_getattr_dotl+0x74/0xa4)   [<8056b210>] (v9fs_vfs_getattr_dotl) from [<802b8904>] (vfs_getattr_nosec+0x68/0x7c)   [<802b889c>] (vfs_getattr_nosec) from [<802b895c>] (vfs_getattr+0x44/0x48)   [<802b8918>] (vfs_getattr) from [<802b8a74>] (vfs_statx+0x9c/0xec)   [<802b89d8>] (vfs_statx) from [<802b9428>] (sys_lstat64+0x48/0x78)   [<802b93e0>] (sys_lstat64) from [<80101000>] (ret_fast_syscall+0x0/0x28)  [dominique.martinet@cea.fr: updated comment to not refer to a function in another subsystem] Link: http://lkml.kernel.org/r/20190124063514.8571-2-houtao1@huawei.com Cc: stable@vger.kernel.org ",
        "func_before": "static struct inode *v9fs_qid_iget_dotl(struct super_block *sb,\n\t\t\t\t\tstruct p9_qid *qid,\n\t\t\t\t\tstruct p9_fid *fid,\n\t\t\t\t\tstruct p9_stat_dotl *st,\n\t\t\t\t\tint new)\n{\n\tint retval;\n\tunsigned long i_ino;\n\tstruct inode *inode;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\tint (*test)(struct inode *, void *);\n\n\tif (new)\n\t\ttest = v9fs_test_new_inode_dotl;\n\telse\n\t\ttest = v9fs_test_inode_dotl;\n\n\ti_ino = v9fs_qid2ino(qid);\n\tinode = iget5_locked(sb, i_ino, test, v9fs_set_inode_dotl, st);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\t/*\n\t * initialize the inode with the stat info\n\t * FIXME!! we may need support for stale inodes\n\t * later.\n\t */\n\tinode->i_ino = i_ino;\n\tretval = v9fs_init_inode(v9ses, inode,\n\t\t\t\t st->st_mode, new_decode_dev(st->st_rdev));\n\tif (retval)\n\t\tgoto error;\n\n\tv9fs_stat2inode_dotl(st, inode);\n\tv9fs_cache_inode_get_cookie(inode);\n\tretval = v9fs_get_acl(inode, fid);\n\tif (retval)\n\t\tgoto error;\n\n\tunlock_new_inode(inode);\n\treturn inode;\nerror:\n\tiget_failed(inode);\n\treturn ERR_PTR(retval);\n\n}",
        "func": "static struct inode *v9fs_qid_iget_dotl(struct super_block *sb,\n\t\t\t\t\tstruct p9_qid *qid,\n\t\t\t\t\tstruct p9_fid *fid,\n\t\t\t\t\tstruct p9_stat_dotl *st,\n\t\t\t\t\tint new)\n{\n\tint retval;\n\tunsigned long i_ino;\n\tstruct inode *inode;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\tint (*test)(struct inode *, void *);\n\n\tif (new)\n\t\ttest = v9fs_test_new_inode_dotl;\n\telse\n\t\ttest = v9fs_test_inode_dotl;\n\n\ti_ino = v9fs_qid2ino(qid);\n\tinode = iget5_locked(sb, i_ino, test, v9fs_set_inode_dotl, st);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\t/*\n\t * initialize the inode with the stat info\n\t * FIXME!! we may need support for stale inodes\n\t * later.\n\t */\n\tinode->i_ino = i_ino;\n\tretval = v9fs_init_inode(v9ses, inode,\n\t\t\t\t st->st_mode, new_decode_dev(st->st_rdev));\n\tif (retval)\n\t\tgoto error;\n\n\tv9fs_stat2inode_dotl(st, inode, 0);\n\tv9fs_cache_inode_get_cookie(inode);\n\tretval = v9fs_get_acl(inode, fid);\n\tif (retval)\n\t\tgoto error;\n\n\tunlock_new_inode(inode);\n\treturn inode;\nerror:\n\tiget_failed(inode);\n\treturn ERR_PTR(retval);\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,7 +32,7 @@\n \tif (retval)\n \t\tgoto error;\n \n-\tv9fs_stat2inode_dotl(st, inode);\n+\tv9fs_stat2inode_dotl(st, inode, 0);\n \tv9fs_cache_inode_get_cookie(inode);\n \tretval = v9fs_get_acl(inode, fid);\n \tif (retval)",
        "diff_line_info": {
            "deleted_lines": [
                "\tv9fs_stat2inode_dotl(st, inode);"
            ],
            "added_lines": [
                "\tv9fs_stat2inode_dotl(st, inode, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16413",
        "func_name": "torvalds/linux/v9fs_vfs_getattr_dotl",
        "description": "An issue was discovered in the Linux kernel before 5.0.4. The 9p filesystem did not protect i_size_write() properly, which causes an i_size_read() infinite loop and denial of service on SMP systems.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f",
        "commit_title": "Use inode->i_lock to protect i_size_write(), else i_size_read() in",
        "commit_text": "generic_fillattr() may loop infinitely in read_seqcount_begin() when multiple processes invoke v9fs_vfs_getattr() or v9fs_vfs_getattr_dotl() simultaneously under 32-bit SMP environment, and a soft lockup will be triggered as show below:    watchdog: BUG: soft lockup - CPU#5 stuck for 22s! [stat:2217]   Modules linked in:   CPU: 5 PID: 2217 Comm: stat Not tainted 5.0.0-rc1-00005-g7f702faf5a9e #4   Hardware name: Generic DT based system   PC is at generic_fillattr+0x104/0x108   LR is at 0xec497f00   pc : [<802b8898>]    lr : [<ec497f00>]    psr: 200c0013   sp : ec497e20  ip : ed608030  fp : ec497e3c   r10: 00000000  r9 : ec497f00  r8 : ed608030   r7 : ec497ebc  r6 : ec497f00  r5 : ee5c1550  r4 : ee005780   r3 : 0000052d  r2 : 00000000  r1 : ec497f00  r0 : ed608030   Flags: nzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment none   Control: 10c5387d  Table: ac48006a  DAC: 00000051   CPU: 5 PID: 2217 Comm: stat Not tainted 5.0.0-rc1-00005-g7f702faf5a9e #4   Hardware name: Generic DT based system   Backtrace:   [<8010d974>] (dump_backtrace) from [<8010dc88>] (show_stack+0x20/0x24)   [<8010dc68>] (show_stack) from [<80a1d194>] (dump_stack+0xb0/0xdc)   [<80a1d0e4>] (dump_stack) from [<80109f34>] (show_regs+0x1c/0x20)   [<80109f18>] (show_regs) from [<801d0a80>] (watchdog_timer_fn+0x280/0x2f8)   [<801d0800>] (watchdog_timer_fn) from [<80198658>] (__hrtimer_run_queues+0x18c/0x380)   [<801984cc>] (__hrtimer_run_queues) from [<80198e60>] (hrtimer_run_queues+0xb8/0xf0)   [<80198da8>] (hrtimer_run_queues) from [<801973e8>] (run_local_timers+0x28/0x64)   [<801973c0>] (run_local_timers) from [<80197460>] (update_process_times+0x3c/0x6c)   [<80197424>] (update_process_times) from [<801ab2b8>] (tick_nohz_handler+0xe0/0x1bc)   [<801ab1d8>] (tick_nohz_handler) from [<80843050>] (arch_timer_handler_virt+0x38/0x48)   [<80843018>] (arch_timer_handler_virt) from [<80180a64>] (handle_percpu_devid_irq+0x8c/0x240)   [<801809d8>] (handle_percpu_devid_irq) from [<8017ac20>] (generic_handle_irq+0x34/0x44)   [<8017abec>] (generic_handle_irq) from [<8017b344>] (__handle_domain_irq+0x6c/0xc4)   [<8017b2d8>] (__handle_domain_irq) from [<801022e0>] (gic_handle_irq+0x4c/0x88)   [<80102294>] (gic_handle_irq) from [<80101a30>] (__irq_svc+0x70/0x98)   [<802b8794>] (generic_fillattr) from [<8056b284>] (v9fs_vfs_getattr_dotl+0x74/0xa4)   [<8056b210>] (v9fs_vfs_getattr_dotl) from [<802b8904>] (vfs_getattr_nosec+0x68/0x7c)   [<802b889c>] (vfs_getattr_nosec) from [<802b895c>] (vfs_getattr+0x44/0x48)   [<802b8918>] (vfs_getattr) from [<802b8a74>] (vfs_statx+0x9c/0xec)   [<802b89d8>] (vfs_statx) from [<802b9428>] (sys_lstat64+0x48/0x78)   [<802b93e0>] (sys_lstat64) from [<80101000>] (ret_fast_syscall+0x0/0x28)  [dominique.martinet@cea.fr: updated comment to not refer to a function in another subsystem] Link: http://lkml.kernel.org/r/20190124063514.8571-2-houtao1@huawei.com Cc: stable@vger.kernel.org ",
        "func_before": "static int\nv9fs_vfs_getattr_dotl(const struct path *path, struct kstat *stat,\n\t\t u32 request_mask, unsigned int flags)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid;\n\tstruct p9_stat_dotl *st;\n\n\tp9_debug(P9_DEBUG_VFS, \"dentry: %p\\n\", dentry);\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {\n\t\tgeneric_fillattr(d_inode(dentry), stat);\n\t\treturn 0;\n\t}\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\t/* Ask for all the fields in stat structure. Server will return\n\t * whatever it supports\n\t */\n\n\tst = p9_client_getattr_dotl(fid, P9_STATS_ALL);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\n\tv9fs_stat2inode_dotl(st, d_inode(dentry));\n\tgeneric_fillattr(d_inode(dentry), stat);\n\t/* Change block size to what the server returned */\n\tstat->blksize = st->st_blksize;\n\n\tkfree(st);\n\treturn 0;\n}",
        "func": "static int\nv9fs_vfs_getattr_dotl(const struct path *path, struct kstat *stat,\n\t\t u32 request_mask, unsigned int flags)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid;\n\tstruct p9_stat_dotl *st;\n\n\tp9_debug(P9_DEBUG_VFS, \"dentry: %p\\n\", dentry);\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {\n\t\tgeneric_fillattr(d_inode(dentry), stat);\n\t\treturn 0;\n\t}\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\t/* Ask for all the fields in stat structure. Server will return\n\t * whatever it supports\n\t */\n\n\tst = p9_client_getattr_dotl(fid, P9_STATS_ALL);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\n\tv9fs_stat2inode_dotl(st, d_inode(dentry), 0);\n\tgeneric_fillattr(d_inode(dentry), stat);\n\t/* Change block size to what the server returned */\n\tstat->blksize = st->st_blksize;\n\n\tkfree(st);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,7 +25,7 @@\n \tif (IS_ERR(st))\n \t\treturn PTR_ERR(st);\n \n-\tv9fs_stat2inode_dotl(st, d_inode(dentry));\n+\tv9fs_stat2inode_dotl(st, d_inode(dentry), 0);\n \tgeneric_fillattr(d_inode(dentry), stat);\n \t/* Change block size to what the server returned */\n \tstat->blksize = st->st_blksize;",
        "diff_line_info": {
            "deleted_lines": [
                "\tv9fs_stat2inode_dotl(st, d_inode(dentry));"
            ],
            "added_lines": [
                "\tv9fs_stat2inode_dotl(st, d_inode(dentry), 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16413",
        "func_name": "torvalds/linux/v9fs_mount",
        "description": "An issue was discovered in the Linux kernel before 5.0.4. The 9p filesystem did not protect i_size_write() properly, which causes an i_size_read() infinite loop and denial of service on SMP systems.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f",
        "commit_title": "Use inode->i_lock to protect i_size_write(), else i_size_read() in",
        "commit_text": "generic_fillattr() may loop infinitely in read_seqcount_begin() when multiple processes invoke v9fs_vfs_getattr() or v9fs_vfs_getattr_dotl() simultaneously under 32-bit SMP environment, and a soft lockup will be triggered as show below:    watchdog: BUG: soft lockup - CPU#5 stuck for 22s! [stat:2217]   Modules linked in:   CPU: 5 PID: 2217 Comm: stat Not tainted 5.0.0-rc1-00005-g7f702faf5a9e #4   Hardware name: Generic DT based system   PC is at generic_fillattr+0x104/0x108   LR is at 0xec497f00   pc : [<802b8898>]    lr : [<ec497f00>]    psr: 200c0013   sp : ec497e20  ip : ed608030  fp : ec497e3c   r10: 00000000  r9 : ec497f00  r8 : ed608030   r7 : ec497ebc  r6 : ec497f00  r5 : ee5c1550  r4 : ee005780   r3 : 0000052d  r2 : 00000000  r1 : ec497f00  r0 : ed608030   Flags: nzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment none   Control: 10c5387d  Table: ac48006a  DAC: 00000051   CPU: 5 PID: 2217 Comm: stat Not tainted 5.0.0-rc1-00005-g7f702faf5a9e #4   Hardware name: Generic DT based system   Backtrace:   [<8010d974>] (dump_backtrace) from [<8010dc88>] (show_stack+0x20/0x24)   [<8010dc68>] (show_stack) from [<80a1d194>] (dump_stack+0xb0/0xdc)   [<80a1d0e4>] (dump_stack) from [<80109f34>] (show_regs+0x1c/0x20)   [<80109f18>] (show_regs) from [<801d0a80>] (watchdog_timer_fn+0x280/0x2f8)   [<801d0800>] (watchdog_timer_fn) from [<80198658>] (__hrtimer_run_queues+0x18c/0x380)   [<801984cc>] (__hrtimer_run_queues) from [<80198e60>] (hrtimer_run_queues+0xb8/0xf0)   [<80198da8>] (hrtimer_run_queues) from [<801973e8>] (run_local_timers+0x28/0x64)   [<801973c0>] (run_local_timers) from [<80197460>] (update_process_times+0x3c/0x6c)   [<80197424>] (update_process_times) from [<801ab2b8>] (tick_nohz_handler+0xe0/0x1bc)   [<801ab1d8>] (tick_nohz_handler) from [<80843050>] (arch_timer_handler_virt+0x38/0x48)   [<80843018>] (arch_timer_handler_virt) from [<80180a64>] (handle_percpu_devid_irq+0x8c/0x240)   [<801809d8>] (handle_percpu_devid_irq) from [<8017ac20>] (generic_handle_irq+0x34/0x44)   [<8017abec>] (generic_handle_irq) from [<8017b344>] (__handle_domain_irq+0x6c/0xc4)   [<8017b2d8>] (__handle_domain_irq) from [<801022e0>] (gic_handle_irq+0x4c/0x88)   [<80102294>] (gic_handle_irq) from [<80101a30>] (__irq_svc+0x70/0x98)   [<802b8794>] (generic_fillattr) from [<8056b284>] (v9fs_vfs_getattr_dotl+0x74/0xa4)   [<8056b210>] (v9fs_vfs_getattr_dotl) from [<802b8904>] (vfs_getattr_nosec+0x68/0x7c)   [<802b889c>] (vfs_getattr_nosec) from [<802b895c>] (vfs_getattr+0x44/0x48)   [<802b8918>] (vfs_getattr) from [<802b8a74>] (vfs_statx+0x9c/0xec)   [<802b89d8>] (vfs_statx) from [<802b9428>] (sys_lstat64+0x48/0x78)   [<802b93e0>] (sys_lstat64) from [<80101000>] (ret_fast_syscall+0x0/0x28)  [dominique.martinet@cea.fr: updated comment to not refer to a function in another subsystem] Link: http://lkml.kernel.org/r/20190124063514.8571-2-houtao1@huawei.com Cc: stable@vger.kernel.org ",
        "func_before": "static struct dentry *v9fs_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data)\n{\n\tstruct super_block *sb = NULL;\n\tstruct inode *inode = NULL;\n\tstruct dentry *root = NULL;\n\tstruct v9fs_session_info *v9ses = NULL;\n\tumode_t mode = S_IRWXUGO | S_ISVTX;\n\tstruct p9_fid *fid;\n\tint retval = 0;\n\n\tp9_debug(P9_DEBUG_VFS, \"\\n\");\n\n\tv9ses = kzalloc(sizeof(struct v9fs_session_info), GFP_KERNEL);\n\tif (!v9ses)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfid = v9fs_session_init(v9ses, dev_name, data);\n\tif (IS_ERR(fid)) {\n\t\tretval = PTR_ERR(fid);\n\t\tgoto free_session;\n\t}\n\n\tsb = sget(fs_type, NULL, v9fs_set_super, flags, v9ses);\n\tif (IS_ERR(sb)) {\n\t\tretval = PTR_ERR(sb);\n\t\tgoto clunk_fid;\n\t}\n\tretval = v9fs_fill_super(sb, v9ses, flags, data);\n\tif (retval)\n\t\tgoto release_sb;\n\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n\t\tsb->s_d_op = &v9fs_cached_dentry_operations;\n\telse\n\t\tsb->s_d_op = &v9fs_dentry_operations;\n\n\tinode = v9fs_get_inode(sb, S_IFDIR | mode, 0);\n\tif (IS_ERR(inode)) {\n\t\tretval = PTR_ERR(inode);\n\t\tgoto release_sb;\n\t}\n\n\troot = d_make_root(inode);\n\tif (!root) {\n\t\tretval = -ENOMEM;\n\t\tgoto release_sb;\n\t}\n\tsb->s_root = root;\n\tif (v9fs_proto_dotl(v9ses)) {\n\t\tstruct p9_stat_dotl *st = NULL;\n\t\tst = p9_client_getattr_dotl(fid, P9_STATS_BASIC);\n\t\tif (IS_ERR(st)) {\n\t\t\tretval = PTR_ERR(st);\n\t\t\tgoto release_sb;\n\t\t}\n\t\td_inode(root)->i_ino = v9fs_qid2ino(&st->qid);\n\t\tv9fs_stat2inode_dotl(st, d_inode(root));\n\t\tkfree(st);\n\t} else {\n\t\tstruct p9_wstat *st = NULL;\n\t\tst = p9_client_stat(fid);\n\t\tif (IS_ERR(st)) {\n\t\t\tretval = PTR_ERR(st);\n\t\t\tgoto release_sb;\n\t\t}\n\n\t\td_inode(root)->i_ino = v9fs_qid2ino(&st->qid);\n\t\tv9fs_stat2inode(st, d_inode(root), sb);\n\n\t\tp9stat_free(st);\n\t\tkfree(st);\n\t}\n\tretval = v9fs_get_acl(inode, fid);\n\tif (retval)\n\t\tgoto release_sb;\n\tv9fs_fid_add(root, fid);\n\n\tp9_debug(P9_DEBUG_VFS, \" simple set mount, return 0\\n\");\n\treturn dget(sb->s_root);\n\nclunk_fid:\n\tp9_client_clunk(fid);\n\tv9fs_session_close(v9ses);\nfree_session:\n\tkfree(v9ses);\n\treturn ERR_PTR(retval);\n\nrelease_sb:\n\t/*\n\t * we will do the session_close and root dentry release\n\t * in the below call. But we need to clunk fid, because we haven't\n\t * attached the fid to dentry so it won't get clunked\n\t * automatically.\n\t */\n\tp9_client_clunk(fid);\n\tdeactivate_locked_super(sb);\n\treturn ERR_PTR(retval);\n}",
        "func": "static struct dentry *v9fs_mount(struct file_system_type *fs_type, int flags,\n\t\t       const char *dev_name, void *data)\n{\n\tstruct super_block *sb = NULL;\n\tstruct inode *inode = NULL;\n\tstruct dentry *root = NULL;\n\tstruct v9fs_session_info *v9ses = NULL;\n\tumode_t mode = S_IRWXUGO | S_ISVTX;\n\tstruct p9_fid *fid;\n\tint retval = 0;\n\n\tp9_debug(P9_DEBUG_VFS, \"\\n\");\n\n\tv9ses = kzalloc(sizeof(struct v9fs_session_info), GFP_KERNEL);\n\tif (!v9ses)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfid = v9fs_session_init(v9ses, dev_name, data);\n\tif (IS_ERR(fid)) {\n\t\tretval = PTR_ERR(fid);\n\t\tgoto free_session;\n\t}\n\n\tsb = sget(fs_type, NULL, v9fs_set_super, flags, v9ses);\n\tif (IS_ERR(sb)) {\n\t\tretval = PTR_ERR(sb);\n\t\tgoto clunk_fid;\n\t}\n\tretval = v9fs_fill_super(sb, v9ses, flags, data);\n\tif (retval)\n\t\tgoto release_sb;\n\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n\t\tsb->s_d_op = &v9fs_cached_dentry_operations;\n\telse\n\t\tsb->s_d_op = &v9fs_dentry_operations;\n\n\tinode = v9fs_get_inode(sb, S_IFDIR | mode, 0);\n\tif (IS_ERR(inode)) {\n\t\tretval = PTR_ERR(inode);\n\t\tgoto release_sb;\n\t}\n\n\troot = d_make_root(inode);\n\tif (!root) {\n\t\tretval = -ENOMEM;\n\t\tgoto release_sb;\n\t}\n\tsb->s_root = root;\n\tif (v9fs_proto_dotl(v9ses)) {\n\t\tstruct p9_stat_dotl *st = NULL;\n\t\tst = p9_client_getattr_dotl(fid, P9_STATS_BASIC);\n\t\tif (IS_ERR(st)) {\n\t\t\tretval = PTR_ERR(st);\n\t\t\tgoto release_sb;\n\t\t}\n\t\td_inode(root)->i_ino = v9fs_qid2ino(&st->qid);\n\t\tv9fs_stat2inode_dotl(st, d_inode(root), 0);\n\t\tkfree(st);\n\t} else {\n\t\tstruct p9_wstat *st = NULL;\n\t\tst = p9_client_stat(fid);\n\t\tif (IS_ERR(st)) {\n\t\t\tretval = PTR_ERR(st);\n\t\t\tgoto release_sb;\n\t\t}\n\n\t\td_inode(root)->i_ino = v9fs_qid2ino(&st->qid);\n\t\tv9fs_stat2inode(st, d_inode(root), sb, 0);\n\n\t\tp9stat_free(st);\n\t\tkfree(st);\n\t}\n\tretval = v9fs_get_acl(inode, fid);\n\tif (retval)\n\t\tgoto release_sb;\n\tv9fs_fid_add(root, fid);\n\n\tp9_debug(P9_DEBUG_VFS, \" simple set mount, return 0\\n\");\n\treturn dget(sb->s_root);\n\nclunk_fid:\n\tp9_client_clunk(fid);\n\tv9fs_session_close(v9ses);\nfree_session:\n\tkfree(v9ses);\n\treturn ERR_PTR(retval);\n\nrelease_sb:\n\t/*\n\t * we will do the session_close and root dentry release\n\t * in the below call. But we need to clunk fid, because we haven't\n\t * attached the fid to dentry so it won't get clunked\n\t * automatically.\n\t */\n\tp9_client_clunk(fid);\n\tdeactivate_locked_super(sb);\n\treturn ERR_PTR(retval);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -55,7 +55,7 @@\n \t\t\tgoto release_sb;\n \t\t}\n \t\td_inode(root)->i_ino = v9fs_qid2ino(&st->qid);\n-\t\tv9fs_stat2inode_dotl(st, d_inode(root));\n+\t\tv9fs_stat2inode_dotl(st, d_inode(root), 0);\n \t\tkfree(st);\n \t} else {\n \t\tstruct p9_wstat *st = NULL;\n@@ -66,7 +66,7 @@\n \t\t}\n \n \t\td_inode(root)->i_ino = v9fs_qid2ino(&st->qid);\n-\t\tv9fs_stat2inode(st, d_inode(root), sb);\n+\t\tv9fs_stat2inode(st, d_inode(root), sb, 0);\n \n \t\tp9stat_free(st);\n \t\tkfree(st);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tv9fs_stat2inode_dotl(st, d_inode(root));",
                "\t\tv9fs_stat2inode(st, d_inode(root), sb);"
            ],
            "added_lines": [
                "\t\tv9fs_stat2inode_dotl(st, d_inode(root), 0);",
                "\t\tv9fs_stat2inode(st, d_inode(root), sb, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16413",
        "func_name": "torvalds/linux/v9fs_qid_iget",
        "description": "An issue was discovered in the Linux kernel before 5.0.4. The 9p filesystem did not protect i_size_write() properly, which causes an i_size_read() infinite loop and denial of service on SMP systems.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f",
        "commit_title": "Use inode->i_lock to protect i_size_write(), else i_size_read() in",
        "commit_text": "generic_fillattr() may loop infinitely in read_seqcount_begin() when multiple processes invoke v9fs_vfs_getattr() or v9fs_vfs_getattr_dotl() simultaneously under 32-bit SMP environment, and a soft lockup will be triggered as show below:    watchdog: BUG: soft lockup - CPU#5 stuck for 22s! [stat:2217]   Modules linked in:   CPU: 5 PID: 2217 Comm: stat Not tainted 5.0.0-rc1-00005-g7f702faf5a9e #4   Hardware name: Generic DT based system   PC is at generic_fillattr+0x104/0x108   LR is at 0xec497f00   pc : [<802b8898>]    lr : [<ec497f00>]    psr: 200c0013   sp : ec497e20  ip : ed608030  fp : ec497e3c   r10: 00000000  r9 : ec497f00  r8 : ed608030   r7 : ec497ebc  r6 : ec497f00  r5 : ee5c1550  r4 : ee005780   r3 : 0000052d  r2 : 00000000  r1 : ec497f00  r0 : ed608030   Flags: nzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment none   Control: 10c5387d  Table: ac48006a  DAC: 00000051   CPU: 5 PID: 2217 Comm: stat Not tainted 5.0.0-rc1-00005-g7f702faf5a9e #4   Hardware name: Generic DT based system   Backtrace:   [<8010d974>] (dump_backtrace) from [<8010dc88>] (show_stack+0x20/0x24)   [<8010dc68>] (show_stack) from [<80a1d194>] (dump_stack+0xb0/0xdc)   [<80a1d0e4>] (dump_stack) from [<80109f34>] (show_regs+0x1c/0x20)   [<80109f18>] (show_regs) from [<801d0a80>] (watchdog_timer_fn+0x280/0x2f8)   [<801d0800>] (watchdog_timer_fn) from [<80198658>] (__hrtimer_run_queues+0x18c/0x380)   [<801984cc>] (__hrtimer_run_queues) from [<80198e60>] (hrtimer_run_queues+0xb8/0xf0)   [<80198da8>] (hrtimer_run_queues) from [<801973e8>] (run_local_timers+0x28/0x64)   [<801973c0>] (run_local_timers) from [<80197460>] (update_process_times+0x3c/0x6c)   [<80197424>] (update_process_times) from [<801ab2b8>] (tick_nohz_handler+0xe0/0x1bc)   [<801ab1d8>] (tick_nohz_handler) from [<80843050>] (arch_timer_handler_virt+0x38/0x48)   [<80843018>] (arch_timer_handler_virt) from [<80180a64>] (handle_percpu_devid_irq+0x8c/0x240)   [<801809d8>] (handle_percpu_devid_irq) from [<8017ac20>] (generic_handle_irq+0x34/0x44)   [<8017abec>] (generic_handle_irq) from [<8017b344>] (__handle_domain_irq+0x6c/0xc4)   [<8017b2d8>] (__handle_domain_irq) from [<801022e0>] (gic_handle_irq+0x4c/0x88)   [<80102294>] (gic_handle_irq) from [<80101a30>] (__irq_svc+0x70/0x98)   [<802b8794>] (generic_fillattr) from [<8056b284>] (v9fs_vfs_getattr_dotl+0x74/0xa4)   [<8056b210>] (v9fs_vfs_getattr_dotl) from [<802b8904>] (vfs_getattr_nosec+0x68/0x7c)   [<802b889c>] (vfs_getattr_nosec) from [<802b895c>] (vfs_getattr+0x44/0x48)   [<802b8918>] (vfs_getattr) from [<802b8a74>] (vfs_statx+0x9c/0xec)   [<802b89d8>] (vfs_statx) from [<802b9428>] (sys_lstat64+0x48/0x78)   [<802b93e0>] (sys_lstat64) from [<80101000>] (ret_fast_syscall+0x0/0x28)  [dominique.martinet@cea.fr: updated comment to not refer to a function in another subsystem] Link: http://lkml.kernel.org/r/20190124063514.8571-2-houtao1@huawei.com Cc: stable@vger.kernel.org ",
        "func_before": "static struct inode *v9fs_qid_iget(struct super_block *sb,\n\t\t\t\t   struct p9_qid *qid,\n\t\t\t\t   struct p9_wstat *st,\n\t\t\t\t   int new)\n{\n\tdev_t rdev;\n\tint retval;\n\tumode_t umode;\n\tunsigned long i_ino;\n\tstruct inode *inode;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\tint (*test)(struct inode *, void *);\n\n\tif (new)\n\t\ttest = v9fs_test_new_inode;\n\telse\n\t\ttest = v9fs_test_inode;\n\n\ti_ino = v9fs_qid2ino(qid);\n\tinode = iget5_locked(sb, i_ino, test, v9fs_set_inode, st);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\t/*\n\t * initialize the inode with the stat info\n\t * FIXME!! we may need support for stale inodes\n\t * later.\n\t */\n\tinode->i_ino = i_ino;\n\tumode = p9mode2unixmode(v9ses, st, &rdev);\n\tretval = v9fs_init_inode(v9ses, inode, umode, rdev);\n\tif (retval)\n\t\tgoto error;\n\n\tv9fs_stat2inode(st, inode, sb);\n\tv9fs_cache_inode_get_cookie(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\nerror:\n\tiget_failed(inode);\n\treturn ERR_PTR(retval);\n\n}",
        "func": "static struct inode *v9fs_qid_iget(struct super_block *sb,\n\t\t\t\t   struct p9_qid *qid,\n\t\t\t\t   struct p9_wstat *st,\n\t\t\t\t   int new)\n{\n\tdev_t rdev;\n\tint retval;\n\tumode_t umode;\n\tunsigned long i_ino;\n\tstruct inode *inode;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\tint (*test)(struct inode *, void *);\n\n\tif (new)\n\t\ttest = v9fs_test_new_inode;\n\telse\n\t\ttest = v9fs_test_inode;\n\n\ti_ino = v9fs_qid2ino(qid);\n\tinode = iget5_locked(sb, i_ino, test, v9fs_set_inode, st);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\t/*\n\t * initialize the inode with the stat info\n\t * FIXME!! we may need support for stale inodes\n\t * later.\n\t */\n\tinode->i_ino = i_ino;\n\tumode = p9mode2unixmode(v9ses, st, &rdev);\n\tretval = v9fs_init_inode(v9ses, inode, umode, rdev);\n\tif (retval)\n\t\tgoto error;\n\n\tv9fs_stat2inode(st, inode, sb, 0);\n\tv9fs_cache_inode_get_cookie(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\nerror:\n\tiget_failed(inode);\n\treturn ERR_PTR(retval);\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -33,7 +33,7 @@\n \tif (retval)\n \t\tgoto error;\n \n-\tv9fs_stat2inode(st, inode, sb);\n+\tv9fs_stat2inode(st, inode, sb, 0);\n \tv9fs_cache_inode_get_cookie(inode);\n \tunlock_new_inode(inode);\n \treturn inode;",
        "diff_line_info": {
            "deleted_lines": [
                "\tv9fs_stat2inode(st, inode, sb);"
            ],
            "added_lines": [
                "\tv9fs_stat2inode(st, inode, sb, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16413",
        "func_name": "torvalds/linux/v9fs_vfs_getattr",
        "description": "An issue was discovered in the Linux kernel before 5.0.4. The 9p filesystem did not protect i_size_write() properly, which causes an i_size_read() infinite loop and denial of service on SMP systems.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f",
        "commit_title": "Use inode->i_lock to protect i_size_write(), else i_size_read() in",
        "commit_text": "generic_fillattr() may loop infinitely in read_seqcount_begin() when multiple processes invoke v9fs_vfs_getattr() or v9fs_vfs_getattr_dotl() simultaneously under 32-bit SMP environment, and a soft lockup will be triggered as show below:    watchdog: BUG: soft lockup - CPU#5 stuck for 22s! [stat:2217]   Modules linked in:   CPU: 5 PID: 2217 Comm: stat Not tainted 5.0.0-rc1-00005-g7f702faf5a9e #4   Hardware name: Generic DT based system   PC is at generic_fillattr+0x104/0x108   LR is at 0xec497f00   pc : [<802b8898>]    lr : [<ec497f00>]    psr: 200c0013   sp : ec497e20  ip : ed608030  fp : ec497e3c   r10: 00000000  r9 : ec497f00  r8 : ed608030   r7 : ec497ebc  r6 : ec497f00  r5 : ee5c1550  r4 : ee005780   r3 : 0000052d  r2 : 00000000  r1 : ec497f00  r0 : ed608030   Flags: nzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment none   Control: 10c5387d  Table: ac48006a  DAC: 00000051   CPU: 5 PID: 2217 Comm: stat Not tainted 5.0.0-rc1-00005-g7f702faf5a9e #4   Hardware name: Generic DT based system   Backtrace:   [<8010d974>] (dump_backtrace) from [<8010dc88>] (show_stack+0x20/0x24)   [<8010dc68>] (show_stack) from [<80a1d194>] (dump_stack+0xb0/0xdc)   [<80a1d0e4>] (dump_stack) from [<80109f34>] (show_regs+0x1c/0x20)   [<80109f18>] (show_regs) from [<801d0a80>] (watchdog_timer_fn+0x280/0x2f8)   [<801d0800>] (watchdog_timer_fn) from [<80198658>] (__hrtimer_run_queues+0x18c/0x380)   [<801984cc>] (__hrtimer_run_queues) from [<80198e60>] (hrtimer_run_queues+0xb8/0xf0)   [<80198da8>] (hrtimer_run_queues) from [<801973e8>] (run_local_timers+0x28/0x64)   [<801973c0>] (run_local_timers) from [<80197460>] (update_process_times+0x3c/0x6c)   [<80197424>] (update_process_times) from [<801ab2b8>] (tick_nohz_handler+0xe0/0x1bc)   [<801ab1d8>] (tick_nohz_handler) from [<80843050>] (arch_timer_handler_virt+0x38/0x48)   [<80843018>] (arch_timer_handler_virt) from [<80180a64>] (handle_percpu_devid_irq+0x8c/0x240)   [<801809d8>] (handle_percpu_devid_irq) from [<8017ac20>] (generic_handle_irq+0x34/0x44)   [<8017abec>] (generic_handle_irq) from [<8017b344>] (__handle_domain_irq+0x6c/0xc4)   [<8017b2d8>] (__handle_domain_irq) from [<801022e0>] (gic_handle_irq+0x4c/0x88)   [<80102294>] (gic_handle_irq) from [<80101a30>] (__irq_svc+0x70/0x98)   [<802b8794>] (generic_fillattr) from [<8056b284>] (v9fs_vfs_getattr_dotl+0x74/0xa4)   [<8056b210>] (v9fs_vfs_getattr_dotl) from [<802b8904>] (vfs_getattr_nosec+0x68/0x7c)   [<802b889c>] (vfs_getattr_nosec) from [<802b895c>] (vfs_getattr+0x44/0x48)   [<802b8918>] (vfs_getattr) from [<802b8a74>] (vfs_statx+0x9c/0xec)   [<802b89d8>] (vfs_statx) from [<802b9428>] (sys_lstat64+0x48/0x78)   [<802b93e0>] (sys_lstat64) from [<80101000>] (ret_fast_syscall+0x0/0x28)  [dominique.martinet@cea.fr: updated comment to not refer to a function in another subsystem] Link: http://lkml.kernel.org/r/20190124063514.8571-2-houtao1@huawei.com Cc: stable@vger.kernel.org ",
        "func_before": "static int\nv9fs_vfs_getattr(const struct path *path, struct kstat *stat,\n\t\t u32 request_mask, unsigned int flags)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid;\n\tstruct p9_wstat *st;\n\n\tp9_debug(P9_DEBUG_VFS, \"dentry: %p\\n\", dentry);\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {\n\t\tgeneric_fillattr(d_inode(dentry), stat);\n\t\treturn 0;\n\t}\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\tst = p9_client_stat(fid);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\n\tv9fs_stat2inode(st, d_inode(dentry), dentry->d_sb);\n\tgeneric_fillattr(d_inode(dentry), stat);\n\n\tp9stat_free(st);\n\tkfree(st);\n\treturn 0;\n}",
        "func": "static int\nv9fs_vfs_getattr(const struct path *path, struct kstat *stat,\n\t\t u32 request_mask, unsigned int flags)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid;\n\tstruct p9_wstat *st;\n\n\tp9_debug(P9_DEBUG_VFS, \"dentry: %p\\n\", dentry);\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {\n\t\tgeneric_fillattr(d_inode(dentry), stat);\n\t\treturn 0;\n\t}\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\tst = p9_client_stat(fid);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\n\tv9fs_stat2inode(st, d_inode(dentry), dentry->d_sb, 0);\n\tgeneric_fillattr(d_inode(dentry), stat);\n\n\tp9stat_free(st);\n\tkfree(st);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,7 +21,7 @@\n \tif (IS_ERR(st))\n \t\treturn PTR_ERR(st);\n \n-\tv9fs_stat2inode(st, d_inode(dentry), dentry->d_sb);\n+\tv9fs_stat2inode(st, d_inode(dentry), dentry->d_sb, 0);\n \tgeneric_fillattr(d_inode(dentry), stat);\n \n \tp9stat_free(st);",
        "diff_line_info": {
            "deleted_lines": [
                "\tv9fs_stat2inode(st, d_inode(dentry), dentry->d_sb);"
            ],
            "added_lines": [
                "\tv9fs_stat2inode(st, d_inode(dentry), dentry->d_sb, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16413",
        "func_name": "torvalds/linux/v9fs_stat2inode",
        "description": "An issue was discovered in the Linux kernel before 5.0.4. The 9p filesystem did not protect i_size_write() properly, which causes an i_size_read() infinite loop and denial of service on SMP systems.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f",
        "commit_title": "Use inode->i_lock to protect i_size_write(), else i_size_read() in",
        "commit_text": "generic_fillattr() may loop infinitely in read_seqcount_begin() when multiple processes invoke v9fs_vfs_getattr() or v9fs_vfs_getattr_dotl() simultaneously under 32-bit SMP environment, and a soft lockup will be triggered as show below:    watchdog: BUG: soft lockup - CPU#5 stuck for 22s! [stat:2217]   Modules linked in:   CPU: 5 PID: 2217 Comm: stat Not tainted 5.0.0-rc1-00005-g7f702faf5a9e #4   Hardware name: Generic DT based system   PC is at generic_fillattr+0x104/0x108   LR is at 0xec497f00   pc : [<802b8898>]    lr : [<ec497f00>]    psr: 200c0013   sp : ec497e20  ip : ed608030  fp : ec497e3c   r10: 00000000  r9 : ec497f00  r8 : ed608030   r7 : ec497ebc  r6 : ec497f00  r5 : ee5c1550  r4 : ee005780   r3 : 0000052d  r2 : 00000000  r1 : ec497f00  r0 : ed608030   Flags: nzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment none   Control: 10c5387d  Table: ac48006a  DAC: 00000051   CPU: 5 PID: 2217 Comm: stat Not tainted 5.0.0-rc1-00005-g7f702faf5a9e #4   Hardware name: Generic DT based system   Backtrace:   [<8010d974>] (dump_backtrace) from [<8010dc88>] (show_stack+0x20/0x24)   [<8010dc68>] (show_stack) from [<80a1d194>] (dump_stack+0xb0/0xdc)   [<80a1d0e4>] (dump_stack) from [<80109f34>] (show_regs+0x1c/0x20)   [<80109f18>] (show_regs) from [<801d0a80>] (watchdog_timer_fn+0x280/0x2f8)   [<801d0800>] (watchdog_timer_fn) from [<80198658>] (__hrtimer_run_queues+0x18c/0x380)   [<801984cc>] (__hrtimer_run_queues) from [<80198e60>] (hrtimer_run_queues+0xb8/0xf0)   [<80198da8>] (hrtimer_run_queues) from [<801973e8>] (run_local_timers+0x28/0x64)   [<801973c0>] (run_local_timers) from [<80197460>] (update_process_times+0x3c/0x6c)   [<80197424>] (update_process_times) from [<801ab2b8>] (tick_nohz_handler+0xe0/0x1bc)   [<801ab1d8>] (tick_nohz_handler) from [<80843050>] (arch_timer_handler_virt+0x38/0x48)   [<80843018>] (arch_timer_handler_virt) from [<80180a64>] (handle_percpu_devid_irq+0x8c/0x240)   [<801809d8>] (handle_percpu_devid_irq) from [<8017ac20>] (generic_handle_irq+0x34/0x44)   [<8017abec>] (generic_handle_irq) from [<8017b344>] (__handle_domain_irq+0x6c/0xc4)   [<8017b2d8>] (__handle_domain_irq) from [<801022e0>] (gic_handle_irq+0x4c/0x88)   [<80102294>] (gic_handle_irq) from [<80101a30>] (__irq_svc+0x70/0x98)   [<802b8794>] (generic_fillattr) from [<8056b284>] (v9fs_vfs_getattr_dotl+0x74/0xa4)   [<8056b210>] (v9fs_vfs_getattr_dotl) from [<802b8904>] (vfs_getattr_nosec+0x68/0x7c)   [<802b889c>] (vfs_getattr_nosec) from [<802b895c>] (vfs_getattr+0x44/0x48)   [<802b8918>] (vfs_getattr) from [<802b8a74>] (vfs_statx+0x9c/0xec)   [<802b89d8>] (vfs_statx) from [<802b9428>] (sys_lstat64+0x48/0x78)   [<802b93e0>] (sys_lstat64) from [<80101000>] (ret_fast_syscall+0x0/0x28)  [dominique.martinet@cea.fr: updated comment to not refer to a function in another subsystem] Link: http://lkml.kernel.org/r/20190124063514.8571-2-houtao1@huawei.com Cc: stable@vger.kernel.org ",
        "func_before": "void\nv9fs_stat2inode(struct p9_wstat *stat, struct inode *inode,\n\tstruct super_block *sb)\n{\n\tumode_t mode;\n\tchar ext[32];\n\tchar tag_name[14];\n\tunsigned int i_nlink;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tset_nlink(inode, 1);\n\n\tinode->i_atime.tv_sec = stat->atime;\n\tinode->i_mtime.tv_sec = stat->mtime;\n\tinode->i_ctime.tv_sec = stat->mtime;\n\n\tinode->i_uid = v9ses->dfltuid;\n\tinode->i_gid = v9ses->dfltgid;\n\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tinode->i_uid = stat->n_uid;\n\t\tinode->i_gid = stat->n_gid;\n\t}\n\tif ((S_ISREG(inode->i_mode)) || (S_ISDIR(inode->i_mode))) {\n\t\tif (v9fs_proto_dotu(v9ses) && (stat->extension[0] != '\\0')) {\n\t\t\t/*\n\t\t\t * Hadlink support got added later to\n\t\t\t * to the .u extension. So there can be\n\t\t\t * server out there that doesn't support\n\t\t\t * this even with .u extension. So check\n\t\t\t * for non NULL stat->extension\n\t\t\t */\n\t\t\tstrlcpy(ext, stat->extension, sizeof(ext));\n\t\t\t/* HARDLINKCOUNT %u */\n\t\t\tsscanf(ext, \"%13s %u\", tag_name, &i_nlink);\n\t\t\tif (!strncmp(tag_name, \"HARDLINKCOUNT\", 13))\n\t\t\t\tset_nlink(inode, i_nlink);\n\t\t}\n\t}\n\tmode = p9mode2perm(v9ses, stat);\n\tmode |= inode->i_mode & ~S_IALLUGO;\n\tinode->i_mode = mode;\n\ti_size_write(inode, stat->length);\n\n\t/* not real number of blocks, but 512 byte ones ... */\n\tinode->i_blocks = (i_size_read(inode) + 512 - 1) >> 9;\n\tv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\n}",
        "func": "void\nv9fs_stat2inode(struct p9_wstat *stat, struct inode *inode,\n\t\t struct super_block *sb, unsigned int flags)\n{\n\tumode_t mode;\n\tchar ext[32];\n\tchar tag_name[14];\n\tunsigned int i_nlink;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tset_nlink(inode, 1);\n\n\tinode->i_atime.tv_sec = stat->atime;\n\tinode->i_mtime.tv_sec = stat->mtime;\n\tinode->i_ctime.tv_sec = stat->mtime;\n\n\tinode->i_uid = v9ses->dfltuid;\n\tinode->i_gid = v9ses->dfltgid;\n\n\tif (v9fs_proto_dotu(v9ses)) {\n\t\tinode->i_uid = stat->n_uid;\n\t\tinode->i_gid = stat->n_gid;\n\t}\n\tif ((S_ISREG(inode->i_mode)) || (S_ISDIR(inode->i_mode))) {\n\t\tif (v9fs_proto_dotu(v9ses) && (stat->extension[0] != '\\0')) {\n\t\t\t/*\n\t\t\t * Hadlink support got added later to\n\t\t\t * to the .u extension. So there can be\n\t\t\t * server out there that doesn't support\n\t\t\t * this even with .u extension. So check\n\t\t\t * for non NULL stat->extension\n\t\t\t */\n\t\t\tstrlcpy(ext, stat->extension, sizeof(ext));\n\t\t\t/* HARDLINKCOUNT %u */\n\t\t\tsscanf(ext, \"%13s %u\", tag_name, &i_nlink);\n\t\t\tif (!strncmp(tag_name, \"HARDLINKCOUNT\", 13))\n\t\t\t\tset_nlink(inode, i_nlink);\n\t\t}\n\t}\n\tmode = p9mode2perm(v9ses, stat);\n\tmode |= inode->i_mode & ~S_IALLUGO;\n\tinode->i_mode = mode;\n\n\tif (!(flags & V9FS_STAT2INODE_KEEP_ISIZE))\n\t\tv9fs_i_size_write(inode, stat->length);\n\t/* not real number of blocks, but 512 byte ones ... */\n\tinode->i_blocks = (stat->length + 512 - 1) >> 9;\n\tv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n void\n v9fs_stat2inode(struct p9_wstat *stat, struct inode *inode,\n-\tstruct super_block *sb)\n+\t\t struct super_block *sb, unsigned int flags)\n {\n \tumode_t mode;\n \tchar ext[32];\n@@ -41,9 +41,10 @@\n \tmode = p9mode2perm(v9ses, stat);\n \tmode |= inode->i_mode & ~S_IALLUGO;\n \tinode->i_mode = mode;\n-\ti_size_write(inode, stat->length);\n \n+\tif (!(flags & V9FS_STAT2INODE_KEEP_ISIZE))\n+\t\tv9fs_i_size_write(inode, stat->length);\n \t/* not real number of blocks, but 512 byte ones ... */\n-\tinode->i_blocks = (i_size_read(inode) + 512 - 1) >> 9;\n+\tinode->i_blocks = (stat->length + 512 - 1) >> 9;\n \tv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tstruct super_block *sb)",
                "\ti_size_write(inode, stat->length);",
                "\tinode->i_blocks = (i_size_read(inode) + 512 - 1) >> 9;"
            ],
            "added_lines": [
                "\t\t struct super_block *sb, unsigned int flags)",
                "\tif (!(flags & V9FS_STAT2INODE_KEEP_ISIZE))",
                "\t\tv9fs_i_size_write(inode, stat->length);",
                "\tinode->i_blocks = (stat->length + 512 - 1) >> 9;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16413",
        "func_name": "torvalds/linux/v9fs_refresh_inode",
        "description": "An issue was discovered in the Linux kernel before 5.0.4. The 9p filesystem did not protect i_size_write() properly, which causes an i_size_read() infinite loop and denial of service on SMP systems.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f",
        "commit_title": "Use inode->i_lock to protect i_size_write(), else i_size_read() in",
        "commit_text": "generic_fillattr() may loop infinitely in read_seqcount_begin() when multiple processes invoke v9fs_vfs_getattr() or v9fs_vfs_getattr_dotl() simultaneously under 32-bit SMP environment, and a soft lockup will be triggered as show below:    watchdog: BUG: soft lockup - CPU#5 stuck for 22s! [stat:2217]   Modules linked in:   CPU: 5 PID: 2217 Comm: stat Not tainted 5.0.0-rc1-00005-g7f702faf5a9e #4   Hardware name: Generic DT based system   PC is at generic_fillattr+0x104/0x108   LR is at 0xec497f00   pc : [<802b8898>]    lr : [<ec497f00>]    psr: 200c0013   sp : ec497e20  ip : ed608030  fp : ec497e3c   r10: 00000000  r9 : ec497f00  r8 : ed608030   r7 : ec497ebc  r6 : ec497f00  r5 : ee5c1550  r4 : ee005780   r3 : 0000052d  r2 : 00000000  r1 : ec497f00  r0 : ed608030   Flags: nzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment none   Control: 10c5387d  Table: ac48006a  DAC: 00000051   CPU: 5 PID: 2217 Comm: stat Not tainted 5.0.0-rc1-00005-g7f702faf5a9e #4   Hardware name: Generic DT based system   Backtrace:   [<8010d974>] (dump_backtrace) from [<8010dc88>] (show_stack+0x20/0x24)   [<8010dc68>] (show_stack) from [<80a1d194>] (dump_stack+0xb0/0xdc)   [<80a1d0e4>] (dump_stack) from [<80109f34>] (show_regs+0x1c/0x20)   [<80109f18>] (show_regs) from [<801d0a80>] (watchdog_timer_fn+0x280/0x2f8)   [<801d0800>] (watchdog_timer_fn) from [<80198658>] (__hrtimer_run_queues+0x18c/0x380)   [<801984cc>] (__hrtimer_run_queues) from [<80198e60>] (hrtimer_run_queues+0xb8/0xf0)   [<80198da8>] (hrtimer_run_queues) from [<801973e8>] (run_local_timers+0x28/0x64)   [<801973c0>] (run_local_timers) from [<80197460>] (update_process_times+0x3c/0x6c)   [<80197424>] (update_process_times) from [<801ab2b8>] (tick_nohz_handler+0xe0/0x1bc)   [<801ab1d8>] (tick_nohz_handler) from [<80843050>] (arch_timer_handler_virt+0x38/0x48)   [<80843018>] (arch_timer_handler_virt) from [<80180a64>] (handle_percpu_devid_irq+0x8c/0x240)   [<801809d8>] (handle_percpu_devid_irq) from [<8017ac20>] (generic_handle_irq+0x34/0x44)   [<8017abec>] (generic_handle_irq) from [<8017b344>] (__handle_domain_irq+0x6c/0xc4)   [<8017b2d8>] (__handle_domain_irq) from [<801022e0>] (gic_handle_irq+0x4c/0x88)   [<80102294>] (gic_handle_irq) from [<80101a30>] (__irq_svc+0x70/0x98)   [<802b8794>] (generic_fillattr) from [<8056b284>] (v9fs_vfs_getattr_dotl+0x74/0xa4)   [<8056b210>] (v9fs_vfs_getattr_dotl) from [<802b8904>] (vfs_getattr_nosec+0x68/0x7c)   [<802b889c>] (vfs_getattr_nosec) from [<802b895c>] (vfs_getattr+0x44/0x48)   [<802b8918>] (vfs_getattr) from [<802b8a74>] (vfs_statx+0x9c/0xec)   [<802b89d8>] (vfs_statx) from [<802b9428>] (sys_lstat64+0x48/0x78)   [<802b93e0>] (sys_lstat64) from [<80101000>] (ret_fast_syscall+0x0/0x28)  [dominique.martinet@cea.fr: updated comment to not refer to a function in another subsystem] Link: http://lkml.kernel.org/r/20190124063514.8571-2-houtao1@huawei.com Cc: stable@vger.kernel.org ",
        "func_before": "int v9fs_refresh_inode(struct p9_fid *fid, struct inode *inode)\n{\n\tint umode;\n\tdev_t rdev;\n\tloff_t i_size;\n\tstruct p9_wstat *st;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tst = p9_client_stat(fid);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\t/*\n\t * Don't update inode if the file type is different\n\t */\n\tumode = p9mode2unixmode(v9ses, st, &rdev);\n\tif ((inode->i_mode & S_IFMT) != (umode & S_IFMT))\n\t\tgoto out;\n\n\tspin_lock(&inode->i_lock);\n\t/*\n\t * We don't want to refresh inode->i_size,\n\t * because we may have cached data\n\t */\n\ti_size = inode->i_size;\n\tv9fs_stat2inode(st, inode, inode->i_sb);\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n\t\tinode->i_size = i_size;\n\tspin_unlock(&inode->i_lock);\nout:\n\tp9stat_free(st);\n\tkfree(st);\n\treturn 0;\n}",
        "func": "int v9fs_refresh_inode(struct p9_fid *fid, struct inode *inode)\n{\n\tint umode;\n\tdev_t rdev;\n\tstruct p9_wstat *st;\n\tstruct v9fs_session_info *v9ses;\n\tunsigned int flags;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tst = p9_client_stat(fid);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\t/*\n\t * Don't update inode if the file type is different\n\t */\n\tumode = p9mode2unixmode(v9ses, st, &rdev);\n\tif ((inode->i_mode & S_IFMT) != (umode & S_IFMT))\n\t\tgoto out;\n\n\t/*\n\t * We don't want to refresh inode->i_size,\n\t * because we may have cached data\n\t */\n\tflags = (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) ?\n\t\tV9FS_STAT2INODE_KEEP_ISIZE : 0;\n\tv9fs_stat2inode(st, inode, inode->i_sb, flags);\nout:\n\tp9stat_free(st);\n\tkfree(st);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,9 +2,9 @@\n {\n \tint umode;\n \tdev_t rdev;\n-\tloff_t i_size;\n \tstruct p9_wstat *st;\n \tstruct v9fs_session_info *v9ses;\n+\tunsigned int flags;\n \n \tv9ses = v9fs_inode2v9ses(inode);\n \tst = p9_client_stat(fid);\n@@ -17,16 +17,13 @@\n \tif ((inode->i_mode & S_IFMT) != (umode & S_IFMT))\n \t\tgoto out;\n \n-\tspin_lock(&inode->i_lock);\n \t/*\n \t * We don't want to refresh inode->i_size,\n \t * because we may have cached data\n \t */\n-\ti_size = inode->i_size;\n-\tv9fs_stat2inode(st, inode, inode->i_sb);\n-\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n-\t\tinode->i_size = i_size;\n-\tspin_unlock(&inode->i_lock);\n+\tflags = (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) ?\n+\t\tV9FS_STAT2INODE_KEEP_ISIZE : 0;\n+\tv9fs_stat2inode(st, inode, inode->i_sb, flags);\n out:\n \tp9stat_free(st);\n \tkfree(st);",
        "diff_line_info": {
            "deleted_lines": [
                "\tloff_t i_size;",
                "\tspin_lock(&inode->i_lock);",
                "\ti_size = inode->i_size;",
                "\tv9fs_stat2inode(st, inode, inode->i_sb);",
                "\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)",
                "\t\tinode->i_size = i_size;",
                "\tspin_unlock(&inode->i_lock);"
            ],
            "added_lines": [
                "\tunsigned int flags;",
                "\tflags = (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) ?",
                "\t\tV9FS_STAT2INODE_KEEP_ISIZE : 0;",
                "\tv9fs_stat2inode(st, inode, inode->i_sb, flags);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-12068",
        "func_name": "qemu/lsi_reg_writeb",
        "description": "In QEMU 1:4.1-1, 1:2.1+dfsg-12+deb8u6, 1:2.8+dfsg-6+deb9u8, 1:3.1+dfsg-8~deb10u1, 1:3.1+dfsg-8+deb10u2, and 1:2.1+dfsg-12+deb8u12 (fixed), when executing script in lsi_execute_script(), the LSI scsi adapter emulator advances 's->dsp' index to read next opcode. This can lead to an infinite loop if the next opcode is empty. Move the existing loop exit after 10k iterations so that it covers no-op opcodes as well.",
        "git_url": "https://github.com/qemu/qemu/commit/de594e47659029316bbf9391efb79da0a1a08e08",
        "commit_title": "scsi: lsi: exit infinite loop while executing script (CVE-2019-12068)",
        "commit_text": " When executing script in lsi_execute_script(), the LSI scsi adapter emulator advances 's->dsp' index to read next opcode. This can lead to an infinite loop if the next opcode is empty. Move the existing loop exit after 10k iterations so that it covers no-op opcodes as well. ",
        "func_before": "static void lsi_reg_writeb(LSIState *s, int offset, uint8_t val)\n{\n#define CASE_SET_REG24(name, addr) \\\n    case addr    : s->name &= 0xffffff00; s->name |= val;       break; \\\n    case addr + 1: s->name &= 0xffff00ff; s->name |= val << 8;  break; \\\n    case addr + 2: s->name &= 0xff00ffff; s->name |= val << 16; break;\n\n#define CASE_SET_REG32(name, addr) \\\n    case addr    : s->name &= 0xffffff00; s->name |= val;       break; \\\n    case addr + 1: s->name &= 0xffff00ff; s->name |= val << 8;  break; \\\n    case addr + 2: s->name &= 0xff00ffff; s->name |= val << 16; break; \\\n    case addr + 3: s->name &= 0x00ffffff; s->name |= val << 24; break;\n\n    trace_lsi_reg_write(offset < ARRAY_SIZE(names) ? names[offset] : \"???\",\n                        offset, val);\n\n    switch (offset) {\n    case 0x00: /* SCNTL0 */\n        s->scntl0 = val;\n        if (val & LSI_SCNTL0_START) {\n            qemu_log_mask(LOG_UNIMP,\n                          \"lsi_scsi: Start sequence not implemented\\n\");\n        }\n        break;\n    case 0x01: /* SCNTL1 */\n        s->scntl1 = val & ~LSI_SCNTL1_SST;\n        if (val & LSI_SCNTL1_IARB) {\n            qemu_log_mask(LOG_UNIMP,\n                      \"lsi_scsi: Immediate Arbritration not implemented\\n\");\n        }\n        if (val & LSI_SCNTL1_RST) {\n            if (!(s->sstat0 & LSI_SSTAT0_RST)) {\n                qbus_reset_all(BUS(&s->bus));\n                s->sstat0 |= LSI_SSTAT0_RST;\n                lsi_script_scsi_interrupt(s, LSI_SIST0_RST, 0);\n            }\n        } else {\n            s->sstat0 &= ~LSI_SSTAT0_RST;\n        }\n        break;\n    case 0x02: /* SCNTL2 */\n        val &= ~(LSI_SCNTL2_WSR | LSI_SCNTL2_WSS);\n        s->scntl2 = val;\n        break;\n    case 0x03: /* SCNTL3 */\n        s->scntl3 = val;\n        break;\n    case 0x04: /* SCID */\n        s->scid = val;\n        break;\n    case 0x05: /* SXFER */\n        s->sxfer = val;\n        break;\n    case 0x06: /* SDID */\n        if ((s->ssid & 0x80) && (val & 0xf) != (s->ssid & 0xf)) {\n            qemu_log_mask(LOG_GUEST_ERROR,\n                          \"lsi_scsi: Destination ID does not match SSID\\n\");\n        }\n        s->sdid = val & 0xf;\n        break;\n    case 0x07: /* GPREG0 */\n        break;\n    case 0x08: /* SFBR */\n        /* The CPU is not allowed to write to this register.  However the\n           SCRIPTS register move instructions are.  */\n        s->sfbr = val;\n        break;\n    case 0x0a: case 0x0b:\n        /* Openserver writes to these readonly registers on startup */\n        return;\n    case 0x0c: case 0x0d: case 0x0e: case 0x0f:\n        /* Linux writes to these readonly registers on startup.  */\n        return;\n    CASE_SET_REG32(dsa, 0x10)\n    case 0x14: /* ISTAT0 */\n        s->istat0 = (s->istat0 & 0x0f) | (val & 0xf0);\n        if (val & LSI_ISTAT0_ABRT) {\n            lsi_script_dma_interrupt(s, LSI_DSTAT_ABRT);\n        }\n        if (val & LSI_ISTAT0_INTF) {\n            s->istat0 &= ~LSI_ISTAT0_INTF;\n            lsi_update_irq(s);\n        }\n        if (s->waiting == LSI_WAIT_RESELECT && val & LSI_ISTAT0_SIGP) {\n            trace_lsi_awoken();\n            s->waiting = LSI_NOWAIT;\n            s->dsp = s->dnad;\n            lsi_execute_script(s);\n        }\n        if (val & LSI_ISTAT0_SRST) {\n            qdev_reset_all(DEVICE(s));\n        }\n        break;\n    case 0x16: /* MBOX0 */\n        s->mbox0 = val;\n        break;\n    case 0x17: /* MBOX1 */\n        s->mbox1 = val;\n        break;\n    case 0x18: /* CTEST0 */\n        /* nothing to do */\n        break;\n    case 0x1a: /* CTEST2 */\n        s->ctest2 = val & LSI_CTEST2_PCICIE;\n        break;\n    case 0x1b: /* CTEST3 */\n        s->ctest3 = val & 0x0f;\n        break;\n    CASE_SET_REG32(temp, 0x1c)\n    case 0x21: /* CTEST4 */\n        if (val & 7) {\n            qemu_log_mask(LOG_UNIMP,\n                          \"lsi_scsi: Unimplemented CTEST4-FBL 0x%x\\n\", val);\n        }\n        s->ctest4 = val;\n        break;\n    case 0x22: /* CTEST5 */\n        if (val & (LSI_CTEST5_ADCK | LSI_CTEST5_BBCK)) {\n            qemu_log_mask(LOG_UNIMP,\n                          \"lsi_scsi: CTEST5 DMA increment not implemented\\n\");\n        }\n        s->ctest5 = val;\n        break;\n    CASE_SET_REG24(dbc, 0x24)\n    CASE_SET_REG32(dnad, 0x28)\n    case 0x2c: /* DSP[0:7] */\n        s->dsp &= 0xffffff00;\n        s->dsp |= val;\n        break;\n    case 0x2d: /* DSP[8:15] */\n        s->dsp &= 0xffff00ff;\n        s->dsp |= val << 8;\n        break;\n    case 0x2e: /* DSP[16:23] */\n        s->dsp &= 0xff00ffff;\n        s->dsp |= val << 16;\n        break;\n    case 0x2f: /* DSP[24:31] */\n        s->dsp &= 0x00ffffff;\n        s->dsp |= val << 24;\n        if ((s->dmode & LSI_DMODE_MAN) == 0\n            && (s->istat1 & LSI_ISTAT1_SRUN) == 0)\n            lsi_execute_script(s);\n        break;\n    CASE_SET_REG32(dsps, 0x30)\n    CASE_SET_REG32(scratch[0], 0x34)\n    case 0x38: /* DMODE */\n        s->dmode = val;\n        break;\n    case 0x39: /* DIEN */\n        s->dien = val;\n        lsi_update_irq(s);\n        break;\n    case 0x3a: /* SBR */\n        s->sbr = val;\n        break;\n    case 0x3b: /* DCNTL */\n        s->dcntl = val & ~(LSI_DCNTL_PFF | LSI_DCNTL_STD);\n        if ((val & LSI_DCNTL_STD) && (s->istat1 & LSI_ISTAT1_SRUN) == 0)\n            lsi_execute_script(s);\n        break;\n    case 0x40: /* SIEN0 */\n        s->sien0 = val;\n        lsi_update_irq(s);\n        break;\n    case 0x41: /* SIEN1 */\n        s->sien1 = val;\n        lsi_update_irq(s);\n        break;\n    case 0x47: /* GPCNTL0 */\n        break;\n    case 0x48: /* STIME0 */\n        s->stime0 = val;\n        break;\n    case 0x49: /* STIME1 */\n        if (val & 0xf) {\n            qemu_log_mask(LOG_UNIMP,\n                          \"lsi_scsi: General purpose timer not implemented\\n\");\n            /* ??? Raising the interrupt immediately seems to be sufficient\n               to keep the FreeBSD driver happy.  */\n            lsi_script_scsi_interrupt(s, 0, LSI_SIST1_GEN);\n        }\n        break;\n    case 0x4a: /* RESPID0 */\n        s->respid0 = val;\n        break;\n    case 0x4b: /* RESPID1 */\n        s->respid1 = val;\n        break;\n    case 0x4d: /* STEST1 */\n        s->stest1 = val;\n        break;\n    case 0x4e: /* STEST2 */\n        if (val & 1) {\n            qemu_log_mask(LOG_UNIMP,\n                          \"lsi_scsi: Low level mode not implemented\\n\");\n        }\n        s->stest2 = val;\n        break;\n    case 0x4f: /* STEST3 */\n        if (val & 0x41) {\n            qemu_log_mask(LOG_UNIMP,\n                          \"lsi_scsi: SCSI FIFO test mode not implemented\\n\");\n        }\n        s->stest3 = val;\n        break;\n    case 0x56: /* CCNTL0 */\n        s->ccntl0 = val;\n        break;\n    case 0x57: /* CCNTL1 */\n        s->ccntl1 = val;\n        break;\n    CASE_SET_REG32(mmrs, 0xa0)\n    CASE_SET_REG32(mmws, 0xa4)\n    CASE_SET_REG32(sfs, 0xa8)\n    CASE_SET_REG32(drs, 0xac)\n    CASE_SET_REG32(sbms, 0xb0)\n    CASE_SET_REG32(dbms, 0xb4)\n    CASE_SET_REG32(dnad64, 0xb8)\n    CASE_SET_REG32(pmjad1, 0xc0)\n    CASE_SET_REG32(pmjad2, 0xc4)\n    CASE_SET_REG32(rbc, 0xc8)\n    CASE_SET_REG32(ua, 0xcc)\n    CASE_SET_REG32(ia, 0xd4)\n    CASE_SET_REG32(sbc, 0xd8)\n    CASE_SET_REG32(csbc, 0xdc)\n    default:\n        if (offset >= 0x5c && offset < 0xa0) {\n            int n;\n            int shift;\n            n = (offset - 0x58) >> 2;\n            shift = (offset & 3) * 8;\n            s->scratch[n] = deposit32(s->scratch[n], shift, 8, val);\n        } else {\n            qemu_log_mask(LOG_GUEST_ERROR,\n                          \"lsi_scsi: invalid write to reg %s %x (0x%02x)\\n\",\n                          offset < ARRAY_SIZE(names) ? names[offset] : \"???\",\n                          offset, val);\n        }\n    }\n#undef CASE_SET_REG24\n#undef CASE_SET_REG32\n}",
        "func": "static void lsi_reg_writeb(LSIState *s, int offset, uint8_t val)\n{\n#define CASE_SET_REG24(name, addr) \\\n    case addr    : s->name &= 0xffffff00; s->name |= val;       break; \\\n    case addr + 1: s->name &= 0xffff00ff; s->name |= val << 8;  break; \\\n    case addr + 2: s->name &= 0xff00ffff; s->name |= val << 16; break;\n\n#define CASE_SET_REG32(name, addr) \\\n    case addr    : s->name &= 0xffffff00; s->name |= val;       break; \\\n    case addr + 1: s->name &= 0xffff00ff; s->name |= val << 8;  break; \\\n    case addr + 2: s->name &= 0xff00ffff; s->name |= val << 16; break; \\\n    case addr + 3: s->name &= 0x00ffffff; s->name |= val << 24; break;\n\n    trace_lsi_reg_write(offset < ARRAY_SIZE(names) ? names[offset] : \"???\",\n                        offset, val);\n\n    switch (offset) {\n    case 0x00: /* SCNTL0 */\n        s->scntl0 = val;\n        if (val & LSI_SCNTL0_START) {\n            qemu_log_mask(LOG_UNIMP,\n                          \"lsi_scsi: Start sequence not implemented\\n\");\n        }\n        break;\n    case 0x01: /* SCNTL1 */\n        s->scntl1 = val & ~LSI_SCNTL1_SST;\n        if (val & LSI_SCNTL1_IARB) {\n            qemu_log_mask(LOG_UNIMP,\n                      \"lsi_scsi: Immediate Arbritration not implemented\\n\");\n        }\n        if (val & LSI_SCNTL1_RST) {\n            if (!(s->sstat0 & LSI_SSTAT0_RST)) {\n                qbus_reset_all(BUS(&s->bus));\n                s->sstat0 |= LSI_SSTAT0_RST;\n                lsi_script_scsi_interrupt(s, LSI_SIST0_RST, 0);\n            }\n        } else {\n            s->sstat0 &= ~LSI_SSTAT0_RST;\n        }\n        break;\n    case 0x02: /* SCNTL2 */\n        val &= ~(LSI_SCNTL2_WSR | LSI_SCNTL2_WSS);\n        s->scntl2 = val;\n        break;\n    case 0x03: /* SCNTL3 */\n        s->scntl3 = val;\n        break;\n    case 0x04: /* SCID */\n        s->scid = val;\n        break;\n    case 0x05: /* SXFER */\n        s->sxfer = val;\n        break;\n    case 0x06: /* SDID */\n        if ((s->ssid & 0x80) && (val & 0xf) != (s->ssid & 0xf)) {\n            qemu_log_mask(LOG_GUEST_ERROR,\n                          \"lsi_scsi: Destination ID does not match SSID\\n\");\n        }\n        s->sdid = val & 0xf;\n        break;\n    case 0x07: /* GPREG0 */\n        break;\n    case 0x08: /* SFBR */\n        /* The CPU is not allowed to write to this register.  However the\n           SCRIPTS register move instructions are.  */\n        s->sfbr = val;\n        break;\n    case 0x0a: case 0x0b:\n        /* Openserver writes to these readonly registers on startup */\n        return;\n    case 0x0c: case 0x0d: case 0x0e: case 0x0f:\n        /* Linux writes to these readonly registers on startup.  */\n        return;\n    CASE_SET_REG32(dsa, 0x10)\n    case 0x14: /* ISTAT0 */\n        s->istat0 = (s->istat0 & 0x0f) | (val & 0xf0);\n        if (val & LSI_ISTAT0_ABRT) {\n            lsi_script_dma_interrupt(s, LSI_DSTAT_ABRT);\n        }\n        if (val & LSI_ISTAT0_INTF) {\n            s->istat0 &= ~LSI_ISTAT0_INTF;\n            lsi_update_irq(s);\n        }\n        if (s->waiting == LSI_WAIT_RESELECT && val & LSI_ISTAT0_SIGP) {\n            trace_lsi_awoken();\n            s->waiting = LSI_NOWAIT;\n            s->dsp = s->dnad;\n            lsi_execute_script(s);\n        }\n        if (val & LSI_ISTAT0_SRST) {\n            qdev_reset_all(DEVICE(s));\n        }\n        break;\n    case 0x16: /* MBOX0 */\n        s->mbox0 = val;\n        break;\n    case 0x17: /* MBOX1 */\n        s->mbox1 = val;\n        break;\n    case 0x18: /* CTEST0 */\n        /* nothing to do */\n        break;\n    case 0x1a: /* CTEST2 */\n        s->ctest2 = val & LSI_CTEST2_PCICIE;\n        break;\n    case 0x1b: /* CTEST3 */\n        s->ctest3 = val & 0x0f;\n        break;\n    CASE_SET_REG32(temp, 0x1c)\n    case 0x21: /* CTEST4 */\n        if (val & 7) {\n            qemu_log_mask(LOG_UNIMP,\n                          \"lsi_scsi: Unimplemented CTEST4-FBL 0x%x\\n\", val);\n        }\n        s->ctest4 = val;\n        break;\n    case 0x22: /* CTEST5 */\n        if (val & (LSI_CTEST5_ADCK | LSI_CTEST5_BBCK)) {\n            qemu_log_mask(LOG_UNIMP,\n                          \"lsi_scsi: CTEST5 DMA increment not implemented\\n\");\n        }\n        s->ctest5 = val;\n        break;\n    CASE_SET_REG24(dbc, 0x24)\n    CASE_SET_REG32(dnad, 0x28)\n    case 0x2c: /* DSP[0:7] */\n        s->dsp &= 0xffffff00;\n        s->dsp |= val;\n        break;\n    case 0x2d: /* DSP[8:15] */\n        s->dsp &= 0xffff00ff;\n        s->dsp |= val << 8;\n        break;\n    case 0x2e: /* DSP[16:23] */\n        s->dsp &= 0xff00ffff;\n        s->dsp |= val << 16;\n        break;\n    case 0x2f: /* DSP[24:31] */\n        s->dsp &= 0x00ffffff;\n        s->dsp |= val << 24;\n        /*\n         * FIXME: if s->waiting != LSI_NOWAIT, this will only execute one\n         * instruction.  Is this correct?\n         */\n        if ((s->dmode & LSI_DMODE_MAN) == 0\n            && (s->istat1 & LSI_ISTAT1_SRUN) == 0)\n            lsi_execute_script(s);\n        break;\n    CASE_SET_REG32(dsps, 0x30)\n    CASE_SET_REG32(scratch[0], 0x34)\n    case 0x38: /* DMODE */\n        s->dmode = val;\n        break;\n    case 0x39: /* DIEN */\n        s->dien = val;\n        lsi_update_irq(s);\n        break;\n    case 0x3a: /* SBR */\n        s->sbr = val;\n        break;\n    case 0x3b: /* DCNTL */\n        s->dcntl = val & ~(LSI_DCNTL_PFF | LSI_DCNTL_STD);\n        /*\n         * FIXME: if s->waiting != LSI_NOWAIT, this will only execute one\n         * instruction.  Is this correct?\n         */\n        if ((val & LSI_DCNTL_STD) && (s->istat1 & LSI_ISTAT1_SRUN) == 0)\n            lsi_execute_script(s);\n        break;\n    case 0x40: /* SIEN0 */\n        s->sien0 = val;\n        lsi_update_irq(s);\n        break;\n    case 0x41: /* SIEN1 */\n        s->sien1 = val;\n        lsi_update_irq(s);\n        break;\n    case 0x47: /* GPCNTL0 */\n        break;\n    case 0x48: /* STIME0 */\n        s->stime0 = val;\n        break;\n    case 0x49: /* STIME1 */\n        if (val & 0xf) {\n            qemu_log_mask(LOG_UNIMP,\n                          \"lsi_scsi: General purpose timer not implemented\\n\");\n            /* ??? Raising the interrupt immediately seems to be sufficient\n               to keep the FreeBSD driver happy.  */\n            lsi_script_scsi_interrupt(s, 0, LSI_SIST1_GEN);\n        }\n        break;\n    case 0x4a: /* RESPID0 */\n        s->respid0 = val;\n        break;\n    case 0x4b: /* RESPID1 */\n        s->respid1 = val;\n        break;\n    case 0x4d: /* STEST1 */\n        s->stest1 = val;\n        break;\n    case 0x4e: /* STEST2 */\n        if (val & 1) {\n            qemu_log_mask(LOG_UNIMP,\n                          \"lsi_scsi: Low level mode not implemented\\n\");\n        }\n        s->stest2 = val;\n        break;\n    case 0x4f: /* STEST3 */\n        if (val & 0x41) {\n            qemu_log_mask(LOG_UNIMP,\n                          \"lsi_scsi: SCSI FIFO test mode not implemented\\n\");\n        }\n        s->stest3 = val;\n        break;\n    case 0x56: /* CCNTL0 */\n        s->ccntl0 = val;\n        break;\n    case 0x57: /* CCNTL1 */\n        s->ccntl1 = val;\n        break;\n    CASE_SET_REG32(mmrs, 0xa0)\n    CASE_SET_REG32(mmws, 0xa4)\n    CASE_SET_REG32(sfs, 0xa8)\n    CASE_SET_REG32(drs, 0xac)\n    CASE_SET_REG32(sbms, 0xb0)\n    CASE_SET_REG32(dbms, 0xb4)\n    CASE_SET_REG32(dnad64, 0xb8)\n    CASE_SET_REG32(pmjad1, 0xc0)\n    CASE_SET_REG32(pmjad2, 0xc4)\n    CASE_SET_REG32(rbc, 0xc8)\n    CASE_SET_REG32(ua, 0xcc)\n    CASE_SET_REG32(ia, 0xd4)\n    CASE_SET_REG32(sbc, 0xd8)\n    CASE_SET_REG32(csbc, 0xdc)\n    default:\n        if (offset >= 0x5c && offset < 0xa0) {\n            int n;\n            int shift;\n            n = (offset - 0x58) >> 2;\n            shift = (offset & 3) * 8;\n            s->scratch[n] = deposit32(s->scratch[n], shift, 8, val);\n        } else {\n            qemu_log_mask(LOG_GUEST_ERROR,\n                          \"lsi_scsi: invalid write to reg %s %x (0x%02x)\\n\",\n                          offset < ARRAY_SIZE(names) ? names[offset] : \"???\",\n                          offset, val);\n        }\n    }\n#undef CASE_SET_REG24\n#undef CASE_SET_REG32\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -138,6 +138,10 @@\n     case 0x2f: /* DSP[24:31] */\n         s->dsp &= 0x00ffffff;\n         s->dsp |= val << 24;\n+        /*\n+         * FIXME: if s->waiting != LSI_NOWAIT, this will only execute one\n+         * instruction.  Is this correct?\n+         */\n         if ((s->dmode & LSI_DMODE_MAN) == 0\n             && (s->istat1 & LSI_ISTAT1_SRUN) == 0)\n             lsi_execute_script(s);\n@@ -156,6 +160,10 @@\n         break;\n     case 0x3b: /* DCNTL */\n         s->dcntl = val & ~(LSI_DCNTL_PFF | LSI_DCNTL_STD);\n+        /*\n+         * FIXME: if s->waiting != LSI_NOWAIT, this will only execute one\n+         * instruction.  Is this correct?\n+         */\n         if ((val & LSI_DCNTL_STD) && (s->istat1 & LSI_ISTAT1_SRUN) == 0)\n             lsi_execute_script(s);\n         break;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        /*",
                "         * FIXME: if s->waiting != LSI_NOWAIT, this will only execute one",
                "         * instruction.  Is this correct?",
                "         */",
                "        /*",
                "         * FIXME: if s->waiting != LSI_NOWAIT, this will only execute one",
                "         * instruction.  Is this correct?",
                "         */"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-12068",
        "func_name": "qemu/lsi_execute_script",
        "description": "In QEMU 1:4.1-1, 1:2.1+dfsg-12+deb8u6, 1:2.8+dfsg-6+deb9u8, 1:3.1+dfsg-8~deb10u1, 1:3.1+dfsg-8+deb10u2, and 1:2.1+dfsg-12+deb8u12 (fixed), when executing script in lsi_execute_script(), the LSI scsi adapter emulator advances 's->dsp' index to read next opcode. This can lead to an infinite loop if the next opcode is empty. Move the existing loop exit after 10k iterations so that it covers no-op opcodes as well.",
        "git_url": "https://github.com/qemu/qemu/commit/de594e47659029316bbf9391efb79da0a1a08e08",
        "commit_title": "scsi: lsi: exit infinite loop while executing script (CVE-2019-12068)",
        "commit_text": " When executing script in lsi_execute_script(), the LSI scsi adapter emulator advances 's->dsp' index to read next opcode. This can lead to an infinite loop if the next opcode is empty. Move the existing loop exit after 10k iterations so that it covers no-op opcodes as well. ",
        "func_before": "static void lsi_execute_script(LSIState *s)\n{\n    PCIDevice *pci_dev = PCI_DEVICE(s);\n    uint32_t insn;\n    uint32_t addr, addr_high;\n    int opcode;\n    int insn_processed = 0;\n\n    s->istat1 |= LSI_ISTAT1_SRUN;\nagain:\n    insn_processed++;\n    insn = read_dword(s, s->dsp);\n    if (!insn) {\n        /* If we receive an empty opcode increment the DSP by 4 bytes\n           instead of 8 and execute the next opcode at that location */\n        s->dsp += 4;\n        goto again;\n    }\n    addr = read_dword(s, s->dsp + 4);\n    addr_high = 0;\n    trace_lsi_execute_script(s->dsp, insn, addr);\n    s->dsps = addr;\n    s->dcmd = insn >> 24;\n    s->dsp += 8;\n    switch (insn >> 30) {\n    case 0: /* Block move.  */\n        if (s->sist1 & LSI_SIST1_STO) {\n            trace_lsi_execute_script_blockmove_delayed();\n            lsi_stop_script(s);\n            break;\n        }\n        s->dbc = insn & 0xffffff;\n        s->rbc = s->dbc;\n        /* ??? Set ESA.  */\n        s->ia = s->dsp - 8;\n        if (insn & (1 << 29)) {\n            /* Indirect addressing.  */\n            addr = read_dword(s, addr);\n        } else if (insn & (1 << 28)) {\n            uint32_t buf[2];\n            int32_t offset;\n            /* Table indirect addressing.  */\n\n            /* 32-bit Table indirect */\n            offset = sextract32(addr, 0, 24);\n            pci_dma_read(pci_dev, s->dsa + offset, buf, 8);\n            /* byte count is stored in bits 0:23 only */\n            s->dbc = cpu_to_le32(buf[0]) & 0xffffff;\n            s->rbc = s->dbc;\n            addr = cpu_to_le32(buf[1]);\n\n            /* 40-bit DMA, upper addr bits [39:32] stored in first DWORD of\n             * table, bits [31:24] */\n            if (lsi_dma_40bit(s))\n                addr_high = cpu_to_le32(buf[0]) >> 24;\n            else if (lsi_dma_ti64bit(s)) {\n                int selector = (cpu_to_le32(buf[0]) >> 24) & 0x1f;\n                switch (selector) {\n                case 0 ... 0x0f:\n                    /* offset index into scratch registers since\n                     * TI64 mode can use registers C to R */\n                    addr_high = s->scratch[2 + selector];\n                    break;\n                case 0x10:\n                    addr_high = s->mmrs;\n                    break;\n                case 0x11:\n                    addr_high = s->mmws;\n                    break;\n                case 0x12:\n                    addr_high = s->sfs;\n                    break;\n                case 0x13:\n                    addr_high = s->drs;\n                    break;\n                case 0x14:\n                    addr_high = s->sbms;\n                    break;\n                case 0x15:\n                    addr_high = s->dbms;\n                    break;\n                default:\n                    qemu_log_mask(LOG_GUEST_ERROR,\n                          \"lsi_scsi: Illegal selector specified (0x%x > 0x15) \"\n                          \"for 64-bit DMA block move\", selector);\n                    break;\n                }\n            }\n        } else if (lsi_dma_64bit(s)) {\n            /* fetch a 3rd dword if 64-bit direct move is enabled and\n               only if we're not doing table indirect or indirect addressing */\n            s->dbms = read_dword(s, s->dsp);\n            s->dsp += 4;\n            s->ia = s->dsp - 12;\n        }\n        if ((s->sstat1 & PHASE_MASK) != ((insn >> 24) & 7)) {\n            trace_lsi_execute_script_blockmove_badphase(\n                    scsi_phase_name(s->sstat1),\n                    scsi_phase_name(insn >> 24));\n            lsi_script_scsi_interrupt(s, LSI_SIST0_MA, 0);\n            break;\n        }\n        s->dnad = addr;\n        s->dnad64 = addr_high;\n        switch (s->sstat1 & 0x7) {\n        case PHASE_DO:\n            s->waiting = LSI_DMA_SCRIPTS;\n            lsi_do_dma(s, 1);\n            if (s->waiting)\n                s->waiting = LSI_DMA_IN_PROGRESS;\n            break;\n        case PHASE_DI:\n            s->waiting = LSI_DMA_SCRIPTS;\n            lsi_do_dma(s, 0);\n            if (s->waiting)\n                s->waiting = LSI_DMA_IN_PROGRESS;\n            break;\n        case PHASE_CMD:\n            lsi_do_command(s);\n            break;\n        case PHASE_ST:\n            lsi_do_status(s);\n            break;\n        case PHASE_MO:\n            lsi_do_msgout(s);\n            break;\n        case PHASE_MI:\n            lsi_do_msgin(s);\n            break;\n        default:\n            qemu_log_mask(LOG_UNIMP, \"lsi_scsi: Unimplemented phase %s\\n\",\n                          scsi_phase_name(s->sstat1));\n        }\n        s->dfifo = s->dbc & 0xff;\n        s->ctest5 = (s->ctest5 & 0xfc) | ((s->dbc >> 8) & 3);\n        s->sbc = s->dbc;\n        s->rbc -= s->dbc;\n        s->ua = addr + s->dbc;\n        break;\n\n    case 1: /* IO or Read/Write instruction.  */\n        opcode = (insn >> 27) & 7;\n        if (opcode < 5) {\n            uint32_t id;\n\n            if (insn & (1 << 25)) {\n                id = read_dword(s, s->dsa + sextract32(insn, 0, 24));\n            } else {\n                id = insn;\n            }\n            id = (id >> 16) & 0xf;\n            if (insn & (1 << 26)) {\n                addr = s->dsp + sextract32(addr, 0, 24);\n            }\n            s->dnad = addr;\n            switch (opcode) {\n            case 0: /* Select */\n                s->sdid = id;\n                if (s->scntl1 & LSI_SCNTL1_CON) {\n                    trace_lsi_execute_script_io_alreadyreselected();\n                    s->dsp = s->dnad;\n                    break;\n                }\n                s->sstat0 |= LSI_SSTAT0_WOA;\n                s->scntl1 &= ~LSI_SCNTL1_IARB;\n                if (!scsi_device_find(&s->bus, 0, id, 0)) {\n                    lsi_bad_selection(s, id);\n                    break;\n                }\n                trace_lsi_execute_script_io_selected(id,\n                                             insn & (1 << 3) ? \" ATN\" : \"\");\n                /* ??? Linux drivers compain when this is set.  Maybe\n                   it only applies in low-level mode (unimplemented).\n                lsi_script_scsi_interrupt(s, LSI_SIST0_CMP, 0); */\n                s->select_tag = id << 8;\n                s->scntl1 |= LSI_SCNTL1_CON;\n                if (insn & (1 << 3)) {\n                    s->socl |= LSI_SOCL_ATN;\n                    s->sbcl |= LSI_SBCL_ATN;\n                }\n                s->sbcl |= LSI_SBCL_BSY;\n                lsi_set_phase(s, PHASE_MO);\n                s->waiting = LSI_NOWAIT;\n                break;\n            case 1: /* Disconnect */\n                trace_lsi_execute_script_io_disconnect();\n                s->scntl1 &= ~LSI_SCNTL1_CON;\n                /* FIXME: this is not entirely correct; the target need not ask\n                 * for reselection until it has to send data, while here we force a\n                 * reselection as soon as the bus is free.  The correct flow would\n                 * reselect before lsi_transfer_data and disconnect as soon as\n                 * DMA ends.\n                 */\n                if (!s->current) {\n                    lsi_request *p = get_pending_req(s);\n                    if (p) {\n                        lsi_reselect(s, p);\n                    }\n                }\n                break;\n            case 2: /* Wait Reselect */\n                if (s->istat0 & LSI_ISTAT0_SIGP) {\n                    s->dsp = s->dnad;\n                } else if (!lsi_irq_on_rsl(s)) {\n                        lsi_wait_reselect(s);\n                }\n                break;\n            case 3: /* Set */\n                trace_lsi_execute_script_io_set(\n                        insn & (1 << 3) ? \" ATN\" : \"\",\n                        insn & (1 << 6) ? \" ACK\" : \"\",\n                        insn & (1 << 9) ? \" TM\" : \"\",\n                        insn & (1 << 10) ? \" CC\" : \"\");\n                if (insn & (1 << 3)) {\n                    s->socl |= LSI_SOCL_ATN;\n                    s->sbcl |= LSI_SBCL_ATN;\n                    lsi_set_phase(s, PHASE_MO);\n                }\n\n                if (insn & (1 << 6)) {\n                    s->sbcl |= LSI_SBCL_ACK;\n                }\n\n                if (insn & (1 << 9)) {\n                    qemu_log_mask(LOG_UNIMP,\n                        \"lsi_scsi: Target mode not implemented\\n\");\n                }\n                if (insn & (1 << 10))\n                    s->carry = 1;\n                break;\n            case 4: /* Clear */\n                trace_lsi_execute_script_io_clear(\n                        insn & (1 << 3) ? \" ATN\" : \"\",\n                        insn & (1 << 6) ? \" ACK\" : \"\",\n                        insn & (1 << 9) ? \" TM\" : \"\",\n                        insn & (1 << 10) ? \" CC\" : \"\");\n                if (insn & (1 << 3)) {\n                    s->socl &= ~LSI_SOCL_ATN;\n                    s->sbcl &= ~LSI_SBCL_ATN;\n                }\n\n                if (insn & (1 << 6)) {\n                    s->sbcl &= ~LSI_SBCL_ACK;\n                }\n\n                if (insn & (1 << 10))\n                    s->carry = 0;\n                break;\n            }\n        } else {\n            uint8_t op0;\n            uint8_t op1;\n            uint8_t data8;\n            int reg;\n            int operator;\n\n            static const char *opcode_names[3] =\n                {\"Write\", \"Read\", \"Read-Modify-Write\"};\n            static const char *operator_names[8] =\n                {\"MOV\", \"SHL\", \"OR\", \"XOR\", \"AND\", \"SHR\", \"ADD\", \"ADC\"};\n\n            reg = ((insn >> 16) & 0x7f) | (insn & 0x80);\n            data8 = (insn >> 8) & 0xff;\n            opcode = (insn >> 27) & 7;\n            operator = (insn >> 24) & 7;\n            trace_lsi_execute_script_io_opcode(\n                    opcode_names[opcode - 5], reg,\n                    operator_names[operator], data8, s->sfbr,\n                    (insn & (1 << 23)) ? \" SFBR\" : \"\");\n            op0 = op1 = 0;\n            switch (opcode) {\n            case 5: /* From SFBR */\n                op0 = s->sfbr;\n                op1 = data8;\n                break;\n            case 6: /* To SFBR */\n                if (operator)\n                    op0 = lsi_reg_readb(s, reg);\n                op1 = data8;\n                break;\n            case 7: /* Read-modify-write */\n                if (operator)\n                    op0 = lsi_reg_readb(s, reg);\n                if (insn & (1 << 23)) {\n                    op1 = s->sfbr;\n                } else {\n                    op1 = data8;\n                }\n                break;\n            }\n\n            switch (operator) {\n            case 0: /* move */\n                op0 = op1;\n                break;\n            case 1: /* Shift left */\n                op1 = op0 >> 7;\n                op0 = (op0 << 1) | s->carry;\n                s->carry = op1;\n                break;\n            case 2: /* OR */\n                op0 |= op1;\n                break;\n            case 3: /* XOR */\n                op0 ^= op1;\n                break;\n            case 4: /* AND */\n                op0 &= op1;\n                break;\n            case 5: /* SHR */\n                op1 = op0 & 1;\n                op0 = (op0 >> 1) | (s->carry << 7);\n                s->carry = op1;\n                break;\n            case 6: /* ADD */\n                op0 += op1;\n                s->carry = op0 < op1;\n                break;\n            case 7: /* ADC */\n                op0 += op1 + s->carry;\n                if (s->carry)\n                    s->carry = op0 <= op1;\n                else\n                    s->carry = op0 < op1;\n                break;\n            }\n\n            switch (opcode) {\n            case 5: /* From SFBR */\n            case 7: /* Read-modify-write */\n                lsi_reg_writeb(s, reg, op0);\n                break;\n            case 6: /* To SFBR */\n                s->sfbr = op0;\n                break;\n            }\n        }\n        break;\n\n    case 2: /* Transfer Control.  */\n        {\n            int cond;\n            int jmp;\n\n            if ((insn & 0x002e0000) == 0) {\n                trace_lsi_execute_script_tc_nop();\n                break;\n            }\n            if (s->sist1 & LSI_SIST1_STO) {\n                trace_lsi_execute_script_tc_delayedselect_timeout();\n                lsi_stop_script(s);\n                break;\n            }\n            cond = jmp = (insn & (1 << 19)) != 0;\n            if (cond == jmp && (insn & (1 << 21))) {\n                trace_lsi_execute_script_tc_compc(s->carry == jmp);\n                cond = s->carry != 0;\n            }\n            if (cond == jmp && (insn & (1 << 17))) {\n                trace_lsi_execute_script_tc_compp(scsi_phase_name(s->sstat1),\n                        jmp ? '=' : '!', scsi_phase_name(insn >> 24));\n                cond = (s->sstat1 & PHASE_MASK) == ((insn >> 24) & 7);\n            }\n            if (cond == jmp && (insn & (1 << 18))) {\n                uint8_t mask;\n\n                mask = (~insn >> 8) & 0xff;\n                trace_lsi_execute_script_tc_compd(\n                        s->sfbr, mask, jmp ? '=' : '!', insn & mask);\n                cond = (s->sfbr & mask) == (insn & mask);\n            }\n            if (cond == jmp) {\n                if (insn & (1 << 23)) {\n                    /* Relative address.  */\n                    addr = s->dsp + sextract32(addr, 0, 24);\n                }\n                switch ((insn >> 27) & 7) {\n                case 0: /* Jump */\n                    trace_lsi_execute_script_tc_jump(addr);\n                    s->adder = addr;\n                    s->dsp = addr;\n                    break;\n                case 1: /* Call */\n                    trace_lsi_execute_script_tc_call(addr);\n                    s->temp = s->dsp;\n                    s->dsp = addr;\n                    break;\n                case 2: /* Return */\n                    trace_lsi_execute_script_tc_return(s->temp);\n                    s->dsp = s->temp;\n                    break;\n                case 3: /* Interrupt */\n                    trace_lsi_execute_script_tc_interrupt(s->dsps);\n                    if ((insn & (1 << 20)) != 0) {\n                        s->istat0 |= LSI_ISTAT0_INTF;\n                        lsi_update_irq(s);\n                    } else {\n                        lsi_script_dma_interrupt(s, LSI_DSTAT_SIR);\n                    }\n                    break;\n                default:\n                    trace_lsi_execute_script_tc_illegal();\n                    lsi_script_dma_interrupt(s, LSI_DSTAT_IID);\n                    break;\n                }\n            } else {\n                trace_lsi_execute_script_tc_cc_failed();\n            }\n        }\n        break;\n\n    case 3:\n        if ((insn & (1 << 29)) == 0) {\n            /* Memory move.  */\n            uint32_t dest;\n            /* ??? The docs imply the destination address is loaded into\n               the TEMP register.  However the Linux drivers rely on\n               the value being presrved.  */\n            dest = read_dword(s, s->dsp);\n            s->dsp += 4;\n            lsi_memcpy(s, dest, addr, insn & 0xffffff);\n        } else {\n            uint8_t data[7];\n            int reg;\n            int n;\n            int i;\n\n            if (insn & (1 << 28)) {\n                addr = s->dsa + sextract32(addr, 0, 24);\n            }\n            n = (insn & 7);\n            reg = (insn >> 16) & 0xff;\n            if (insn & (1 << 24)) {\n                pci_dma_read(pci_dev, addr, data, n);\n                trace_lsi_execute_script_mm_load(reg, n, addr, *(int *)data);\n                for (i = 0; i < n; i++) {\n                    lsi_reg_writeb(s, reg + i, data[i]);\n                }\n            } else {\n                trace_lsi_execute_script_mm_store(reg, n, addr);\n                for (i = 0; i < n; i++) {\n                    data[i] = lsi_reg_readb(s, reg + i);\n                }\n                pci_dma_write(pci_dev, addr, data, n);\n            }\n        }\n    }\n    if (insn_processed > 10000 && s->waiting == LSI_NOWAIT) {\n        /* Some windows drivers make the device spin waiting for a memory\n           location to change.  If we have been executed a lot of code then\n           assume this is the case and force an unexpected device disconnect.\n           This is apparently sufficient to beat the drivers into submission.\n         */\n        if (!(s->sien0 & LSI_SIST0_UDC)) {\n            qemu_log_mask(LOG_GUEST_ERROR,\n                          \"lsi_scsi: inf. loop with UDC masked\");\n        }\n        lsi_script_scsi_interrupt(s, LSI_SIST0_UDC, 0);\n        lsi_disconnect(s);\n    } else if (s->istat1 & LSI_ISTAT1_SRUN && s->waiting == LSI_NOWAIT) {\n        if (s->dcntl & LSI_DCNTL_SSM) {\n            lsi_script_dma_interrupt(s, LSI_DSTAT_SSI);\n        } else {\n            goto again;\n        }\n    }\n    trace_lsi_execute_script_stop();\n}",
        "func": "static void lsi_execute_script(LSIState *s)\n{\n    PCIDevice *pci_dev = PCI_DEVICE(s);\n    uint32_t insn;\n    uint32_t addr, addr_high;\n    int opcode;\n    int insn_processed = 0;\n\n    s->istat1 |= LSI_ISTAT1_SRUN;\nagain:\n    if (++insn_processed > LSI_MAX_INSN) {\n        /* Some windows drivers make the device spin waiting for a memory\n           location to change.  If we have been executed a lot of code then\n           assume this is the case and force an unexpected device disconnect.\n           This is apparently sufficient to beat the drivers into submission.\n         */\n        if (!(s->sien0 & LSI_SIST0_UDC)) {\n            qemu_log_mask(LOG_GUEST_ERROR,\n                          \"lsi_scsi: inf. loop with UDC masked\");\n        }\n        lsi_script_scsi_interrupt(s, LSI_SIST0_UDC, 0);\n        lsi_disconnect(s);\n        trace_lsi_execute_script_stop();\n        return;\n    }\n    insn = read_dword(s, s->dsp);\n    if (!insn) {\n        /* If we receive an empty opcode increment the DSP by 4 bytes\n           instead of 8 and execute the next opcode at that location */\n        s->dsp += 4;\n        goto again;\n    }\n    addr = read_dword(s, s->dsp + 4);\n    addr_high = 0;\n    trace_lsi_execute_script(s->dsp, insn, addr);\n    s->dsps = addr;\n    s->dcmd = insn >> 24;\n    s->dsp += 8;\n    switch (insn >> 30) {\n    case 0: /* Block move.  */\n        if (s->sist1 & LSI_SIST1_STO) {\n            trace_lsi_execute_script_blockmove_delayed();\n            lsi_stop_script(s);\n            break;\n        }\n        s->dbc = insn & 0xffffff;\n        s->rbc = s->dbc;\n        /* ??? Set ESA.  */\n        s->ia = s->dsp - 8;\n        if (insn & (1 << 29)) {\n            /* Indirect addressing.  */\n            addr = read_dword(s, addr);\n        } else if (insn & (1 << 28)) {\n            uint32_t buf[2];\n            int32_t offset;\n            /* Table indirect addressing.  */\n\n            /* 32-bit Table indirect */\n            offset = sextract32(addr, 0, 24);\n            pci_dma_read(pci_dev, s->dsa + offset, buf, 8);\n            /* byte count is stored in bits 0:23 only */\n            s->dbc = cpu_to_le32(buf[0]) & 0xffffff;\n            s->rbc = s->dbc;\n            addr = cpu_to_le32(buf[1]);\n\n            /* 40-bit DMA, upper addr bits [39:32] stored in first DWORD of\n             * table, bits [31:24] */\n            if (lsi_dma_40bit(s))\n                addr_high = cpu_to_le32(buf[0]) >> 24;\n            else if (lsi_dma_ti64bit(s)) {\n                int selector = (cpu_to_le32(buf[0]) >> 24) & 0x1f;\n                switch (selector) {\n                case 0 ... 0x0f:\n                    /* offset index into scratch registers since\n                     * TI64 mode can use registers C to R */\n                    addr_high = s->scratch[2 + selector];\n                    break;\n                case 0x10:\n                    addr_high = s->mmrs;\n                    break;\n                case 0x11:\n                    addr_high = s->mmws;\n                    break;\n                case 0x12:\n                    addr_high = s->sfs;\n                    break;\n                case 0x13:\n                    addr_high = s->drs;\n                    break;\n                case 0x14:\n                    addr_high = s->sbms;\n                    break;\n                case 0x15:\n                    addr_high = s->dbms;\n                    break;\n                default:\n                    qemu_log_mask(LOG_GUEST_ERROR,\n                          \"lsi_scsi: Illegal selector specified (0x%x > 0x15) \"\n                          \"for 64-bit DMA block move\", selector);\n                    break;\n                }\n            }\n        } else if (lsi_dma_64bit(s)) {\n            /* fetch a 3rd dword if 64-bit direct move is enabled and\n               only if we're not doing table indirect or indirect addressing */\n            s->dbms = read_dword(s, s->dsp);\n            s->dsp += 4;\n            s->ia = s->dsp - 12;\n        }\n        if ((s->sstat1 & PHASE_MASK) != ((insn >> 24) & 7)) {\n            trace_lsi_execute_script_blockmove_badphase(\n                    scsi_phase_name(s->sstat1),\n                    scsi_phase_name(insn >> 24));\n            lsi_script_scsi_interrupt(s, LSI_SIST0_MA, 0);\n            break;\n        }\n        s->dnad = addr;\n        s->dnad64 = addr_high;\n        switch (s->sstat1 & 0x7) {\n        case PHASE_DO:\n            s->waiting = LSI_DMA_SCRIPTS;\n            lsi_do_dma(s, 1);\n            if (s->waiting)\n                s->waiting = LSI_DMA_IN_PROGRESS;\n            break;\n        case PHASE_DI:\n            s->waiting = LSI_DMA_SCRIPTS;\n            lsi_do_dma(s, 0);\n            if (s->waiting)\n                s->waiting = LSI_DMA_IN_PROGRESS;\n            break;\n        case PHASE_CMD:\n            lsi_do_command(s);\n            break;\n        case PHASE_ST:\n            lsi_do_status(s);\n            break;\n        case PHASE_MO:\n            lsi_do_msgout(s);\n            break;\n        case PHASE_MI:\n            lsi_do_msgin(s);\n            break;\n        default:\n            qemu_log_mask(LOG_UNIMP, \"lsi_scsi: Unimplemented phase %s\\n\",\n                          scsi_phase_name(s->sstat1));\n        }\n        s->dfifo = s->dbc & 0xff;\n        s->ctest5 = (s->ctest5 & 0xfc) | ((s->dbc >> 8) & 3);\n        s->sbc = s->dbc;\n        s->rbc -= s->dbc;\n        s->ua = addr + s->dbc;\n        break;\n\n    case 1: /* IO or Read/Write instruction.  */\n        opcode = (insn >> 27) & 7;\n        if (opcode < 5) {\n            uint32_t id;\n\n            if (insn & (1 << 25)) {\n                id = read_dword(s, s->dsa + sextract32(insn, 0, 24));\n            } else {\n                id = insn;\n            }\n            id = (id >> 16) & 0xf;\n            if (insn & (1 << 26)) {\n                addr = s->dsp + sextract32(addr, 0, 24);\n            }\n            s->dnad = addr;\n            switch (opcode) {\n            case 0: /* Select */\n                s->sdid = id;\n                if (s->scntl1 & LSI_SCNTL1_CON) {\n                    trace_lsi_execute_script_io_alreadyreselected();\n                    s->dsp = s->dnad;\n                    break;\n                }\n                s->sstat0 |= LSI_SSTAT0_WOA;\n                s->scntl1 &= ~LSI_SCNTL1_IARB;\n                if (!scsi_device_find(&s->bus, 0, id, 0)) {\n                    lsi_bad_selection(s, id);\n                    break;\n                }\n                trace_lsi_execute_script_io_selected(id,\n                                             insn & (1 << 3) ? \" ATN\" : \"\");\n                /* ??? Linux drivers compain when this is set.  Maybe\n                   it only applies in low-level mode (unimplemented).\n                lsi_script_scsi_interrupt(s, LSI_SIST0_CMP, 0); */\n                s->select_tag = id << 8;\n                s->scntl1 |= LSI_SCNTL1_CON;\n                if (insn & (1 << 3)) {\n                    s->socl |= LSI_SOCL_ATN;\n                    s->sbcl |= LSI_SBCL_ATN;\n                }\n                s->sbcl |= LSI_SBCL_BSY;\n                lsi_set_phase(s, PHASE_MO);\n                s->waiting = LSI_NOWAIT;\n                break;\n            case 1: /* Disconnect */\n                trace_lsi_execute_script_io_disconnect();\n                s->scntl1 &= ~LSI_SCNTL1_CON;\n                /* FIXME: this is not entirely correct; the target need not ask\n                 * for reselection until it has to send data, while here we force a\n                 * reselection as soon as the bus is free.  The correct flow would\n                 * reselect before lsi_transfer_data and disconnect as soon as\n                 * DMA ends.\n                 */\n                if (!s->current) {\n                    lsi_request *p = get_pending_req(s);\n                    if (p) {\n                        lsi_reselect(s, p);\n                    }\n                }\n                break;\n            case 2: /* Wait Reselect */\n                if (s->istat0 & LSI_ISTAT0_SIGP) {\n                    s->dsp = s->dnad;\n                } else if (!lsi_irq_on_rsl(s)) {\n                        lsi_wait_reselect(s);\n                }\n                break;\n            case 3: /* Set */\n                trace_lsi_execute_script_io_set(\n                        insn & (1 << 3) ? \" ATN\" : \"\",\n                        insn & (1 << 6) ? \" ACK\" : \"\",\n                        insn & (1 << 9) ? \" TM\" : \"\",\n                        insn & (1 << 10) ? \" CC\" : \"\");\n                if (insn & (1 << 3)) {\n                    s->socl |= LSI_SOCL_ATN;\n                    s->sbcl |= LSI_SBCL_ATN;\n                    lsi_set_phase(s, PHASE_MO);\n                }\n\n                if (insn & (1 << 6)) {\n                    s->sbcl |= LSI_SBCL_ACK;\n                }\n\n                if (insn & (1 << 9)) {\n                    qemu_log_mask(LOG_UNIMP,\n                        \"lsi_scsi: Target mode not implemented\\n\");\n                }\n                if (insn & (1 << 10))\n                    s->carry = 1;\n                break;\n            case 4: /* Clear */\n                trace_lsi_execute_script_io_clear(\n                        insn & (1 << 3) ? \" ATN\" : \"\",\n                        insn & (1 << 6) ? \" ACK\" : \"\",\n                        insn & (1 << 9) ? \" TM\" : \"\",\n                        insn & (1 << 10) ? \" CC\" : \"\");\n                if (insn & (1 << 3)) {\n                    s->socl &= ~LSI_SOCL_ATN;\n                    s->sbcl &= ~LSI_SBCL_ATN;\n                }\n\n                if (insn & (1 << 6)) {\n                    s->sbcl &= ~LSI_SBCL_ACK;\n                }\n\n                if (insn & (1 << 10))\n                    s->carry = 0;\n                break;\n            }\n        } else {\n            uint8_t op0;\n            uint8_t op1;\n            uint8_t data8;\n            int reg;\n            int operator;\n\n            static const char *opcode_names[3] =\n                {\"Write\", \"Read\", \"Read-Modify-Write\"};\n            static const char *operator_names[8] =\n                {\"MOV\", \"SHL\", \"OR\", \"XOR\", \"AND\", \"SHR\", \"ADD\", \"ADC\"};\n\n            reg = ((insn >> 16) & 0x7f) | (insn & 0x80);\n            data8 = (insn >> 8) & 0xff;\n            opcode = (insn >> 27) & 7;\n            operator = (insn >> 24) & 7;\n            trace_lsi_execute_script_io_opcode(\n                    opcode_names[opcode - 5], reg,\n                    operator_names[operator], data8, s->sfbr,\n                    (insn & (1 << 23)) ? \" SFBR\" : \"\");\n            op0 = op1 = 0;\n            switch (opcode) {\n            case 5: /* From SFBR */\n                op0 = s->sfbr;\n                op1 = data8;\n                break;\n            case 6: /* To SFBR */\n                if (operator)\n                    op0 = lsi_reg_readb(s, reg);\n                op1 = data8;\n                break;\n            case 7: /* Read-modify-write */\n                if (operator)\n                    op0 = lsi_reg_readb(s, reg);\n                if (insn & (1 << 23)) {\n                    op1 = s->sfbr;\n                } else {\n                    op1 = data8;\n                }\n                break;\n            }\n\n            switch (operator) {\n            case 0: /* move */\n                op0 = op1;\n                break;\n            case 1: /* Shift left */\n                op1 = op0 >> 7;\n                op0 = (op0 << 1) | s->carry;\n                s->carry = op1;\n                break;\n            case 2: /* OR */\n                op0 |= op1;\n                break;\n            case 3: /* XOR */\n                op0 ^= op1;\n                break;\n            case 4: /* AND */\n                op0 &= op1;\n                break;\n            case 5: /* SHR */\n                op1 = op0 & 1;\n                op0 = (op0 >> 1) | (s->carry << 7);\n                s->carry = op1;\n                break;\n            case 6: /* ADD */\n                op0 += op1;\n                s->carry = op0 < op1;\n                break;\n            case 7: /* ADC */\n                op0 += op1 + s->carry;\n                if (s->carry)\n                    s->carry = op0 <= op1;\n                else\n                    s->carry = op0 < op1;\n                break;\n            }\n\n            switch (opcode) {\n            case 5: /* From SFBR */\n            case 7: /* Read-modify-write */\n                lsi_reg_writeb(s, reg, op0);\n                break;\n            case 6: /* To SFBR */\n                s->sfbr = op0;\n                break;\n            }\n        }\n        break;\n\n    case 2: /* Transfer Control.  */\n        {\n            int cond;\n            int jmp;\n\n            if ((insn & 0x002e0000) == 0) {\n                trace_lsi_execute_script_tc_nop();\n                break;\n            }\n            if (s->sist1 & LSI_SIST1_STO) {\n                trace_lsi_execute_script_tc_delayedselect_timeout();\n                lsi_stop_script(s);\n                break;\n            }\n            cond = jmp = (insn & (1 << 19)) != 0;\n            if (cond == jmp && (insn & (1 << 21))) {\n                trace_lsi_execute_script_tc_compc(s->carry == jmp);\n                cond = s->carry != 0;\n            }\n            if (cond == jmp && (insn & (1 << 17))) {\n                trace_lsi_execute_script_tc_compp(scsi_phase_name(s->sstat1),\n                        jmp ? '=' : '!', scsi_phase_name(insn >> 24));\n                cond = (s->sstat1 & PHASE_MASK) == ((insn >> 24) & 7);\n            }\n            if (cond == jmp && (insn & (1 << 18))) {\n                uint8_t mask;\n\n                mask = (~insn >> 8) & 0xff;\n                trace_lsi_execute_script_tc_compd(\n                        s->sfbr, mask, jmp ? '=' : '!', insn & mask);\n                cond = (s->sfbr & mask) == (insn & mask);\n            }\n            if (cond == jmp) {\n                if (insn & (1 << 23)) {\n                    /* Relative address.  */\n                    addr = s->dsp + sextract32(addr, 0, 24);\n                }\n                switch ((insn >> 27) & 7) {\n                case 0: /* Jump */\n                    trace_lsi_execute_script_tc_jump(addr);\n                    s->adder = addr;\n                    s->dsp = addr;\n                    break;\n                case 1: /* Call */\n                    trace_lsi_execute_script_tc_call(addr);\n                    s->temp = s->dsp;\n                    s->dsp = addr;\n                    break;\n                case 2: /* Return */\n                    trace_lsi_execute_script_tc_return(s->temp);\n                    s->dsp = s->temp;\n                    break;\n                case 3: /* Interrupt */\n                    trace_lsi_execute_script_tc_interrupt(s->dsps);\n                    if ((insn & (1 << 20)) != 0) {\n                        s->istat0 |= LSI_ISTAT0_INTF;\n                        lsi_update_irq(s);\n                    } else {\n                        lsi_script_dma_interrupt(s, LSI_DSTAT_SIR);\n                    }\n                    break;\n                default:\n                    trace_lsi_execute_script_tc_illegal();\n                    lsi_script_dma_interrupt(s, LSI_DSTAT_IID);\n                    break;\n                }\n            } else {\n                trace_lsi_execute_script_tc_cc_failed();\n            }\n        }\n        break;\n\n    case 3:\n        if ((insn & (1 << 29)) == 0) {\n            /* Memory move.  */\n            uint32_t dest;\n            /* ??? The docs imply the destination address is loaded into\n               the TEMP register.  However the Linux drivers rely on\n               the value being presrved.  */\n            dest = read_dword(s, s->dsp);\n            s->dsp += 4;\n            lsi_memcpy(s, dest, addr, insn & 0xffffff);\n        } else {\n            uint8_t data[7];\n            int reg;\n            int n;\n            int i;\n\n            if (insn & (1 << 28)) {\n                addr = s->dsa + sextract32(addr, 0, 24);\n            }\n            n = (insn & 7);\n            reg = (insn >> 16) & 0xff;\n            if (insn & (1 << 24)) {\n                pci_dma_read(pci_dev, addr, data, n);\n                trace_lsi_execute_script_mm_load(reg, n, addr, *(int *)data);\n                for (i = 0; i < n; i++) {\n                    lsi_reg_writeb(s, reg + i, data[i]);\n                }\n            } else {\n                trace_lsi_execute_script_mm_store(reg, n, addr);\n                for (i = 0; i < n; i++) {\n                    data[i] = lsi_reg_readb(s, reg + i);\n                }\n                pci_dma_write(pci_dev, addr, data, n);\n            }\n        }\n    }\n    if (s->istat1 & LSI_ISTAT1_SRUN && s->waiting == LSI_NOWAIT) {\n        if (s->dcntl & LSI_DCNTL_SSM) {\n            lsi_script_dma_interrupt(s, LSI_DSTAT_SSI);\n        } else {\n            goto again;\n        }\n    }\n    trace_lsi_execute_script_stop();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,21 @@\n \n     s->istat1 |= LSI_ISTAT1_SRUN;\n again:\n-    insn_processed++;\n+    if (++insn_processed > LSI_MAX_INSN) {\n+        /* Some windows drivers make the device spin waiting for a memory\n+           location to change.  If we have been executed a lot of code then\n+           assume this is the case and force an unexpected device disconnect.\n+           This is apparently sufficient to beat the drivers into submission.\n+         */\n+        if (!(s->sien0 & LSI_SIST0_UDC)) {\n+            qemu_log_mask(LOG_GUEST_ERROR,\n+                          \"lsi_scsi: inf. loop with UDC masked\");\n+        }\n+        lsi_script_scsi_interrupt(s, LSI_SIST0_UDC, 0);\n+        lsi_disconnect(s);\n+        trace_lsi_execute_script_stop();\n+        return;\n+    }\n     insn = read_dword(s, s->dsp);\n     if (!insn) {\n         /* If we receive an empty opcode increment the DSP by 4 bytes\n@@ -445,19 +459,7 @@\n             }\n         }\n     }\n-    if (insn_processed > 10000 && s->waiting == LSI_NOWAIT) {\n-        /* Some windows drivers make the device spin waiting for a memory\n-           location to change.  If we have been executed a lot of code then\n-           assume this is the case and force an unexpected device disconnect.\n-           This is apparently sufficient to beat the drivers into submission.\n-         */\n-        if (!(s->sien0 & LSI_SIST0_UDC)) {\n-            qemu_log_mask(LOG_GUEST_ERROR,\n-                          \"lsi_scsi: inf. loop with UDC masked\");\n-        }\n-        lsi_script_scsi_interrupt(s, LSI_SIST0_UDC, 0);\n-        lsi_disconnect(s);\n-    } else if (s->istat1 & LSI_ISTAT1_SRUN && s->waiting == LSI_NOWAIT) {\n+    if (s->istat1 & LSI_ISTAT1_SRUN && s->waiting == LSI_NOWAIT) {\n         if (s->dcntl & LSI_DCNTL_SSM) {\n             lsi_script_dma_interrupt(s, LSI_DSTAT_SSI);\n         } else {",
        "diff_line_info": {
            "deleted_lines": [
                "    insn_processed++;",
                "    if (insn_processed > 10000 && s->waiting == LSI_NOWAIT) {",
                "        /* Some windows drivers make the device spin waiting for a memory",
                "           location to change.  If we have been executed a lot of code then",
                "           assume this is the case and force an unexpected device disconnect.",
                "           This is apparently sufficient to beat the drivers into submission.",
                "         */",
                "        if (!(s->sien0 & LSI_SIST0_UDC)) {",
                "            qemu_log_mask(LOG_GUEST_ERROR,",
                "                          \"lsi_scsi: inf. loop with UDC masked\");",
                "        }",
                "        lsi_script_scsi_interrupt(s, LSI_SIST0_UDC, 0);",
                "        lsi_disconnect(s);",
                "    } else if (s->istat1 & LSI_ISTAT1_SRUN && s->waiting == LSI_NOWAIT) {"
            ],
            "added_lines": [
                "    if (++insn_processed > LSI_MAX_INSN) {",
                "        /* Some windows drivers make the device spin waiting for a memory",
                "           location to change.  If we have been executed a lot of code then",
                "           assume this is the case and force an unexpected device disconnect.",
                "           This is apparently sufficient to beat the drivers into submission.",
                "         */",
                "        if (!(s->sien0 & LSI_SIST0_UDC)) {",
                "            qemu_log_mask(LOG_GUEST_ERROR,",
                "                          \"lsi_scsi: inf. loop with UDC masked\");",
                "        }",
                "        lsi_script_scsi_interrupt(s, LSI_SIST0_UDC, 0);",
                "        lsi_disconnect(s);",
                "        trace_lsi_execute_script_stop();",
                "        return;",
                "    }",
                "    if (s->istat1 & LSI_ISTAT1_SRUN && s->waiting == LSI_NOWAIT) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18217",
        "func_name": "proftpd/pr_netio_read",
        "description": "ProFTPD before 1.3.6b and 1.3.7rc before 1.3.7rc2 allows remote unauthenticated denial-of-service due to incorrect handling of overly long commands because main.c in a child process enters an infinite loop.",
        "git_url": "https://github.com/proftpd/proftpd/commit/518dc1a6e486291fa4f13d2caff0a8aec52d093e",
        "commit_title": "Issue #846: Handle the case where a client tries to send too-large commands",
        "commit_text": "in an effort to DoS the server.",
        "func_before": "int pr_netio_read(pr_netio_stream_t *nstrm, char *buf, size_t buflen,\n    int bufmin) {\n  int bread = 0, total = 0;\n  const char *nstrm_mode;\n  pr_buffer_t *pbuf;\n  pool *tmp_pool;\n\n  /* Sanity check. */\n  if (nstrm == NULL ||\n      buf == NULL ||\n      buflen == 0) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  if (nstrm->strm_fd == -1) {\n    errno = (nstrm->strm_errno ? nstrm->strm_errno : EBADF);\n    return -1;\n  }\n\n  if (bufmin < 1) {\n    bufmin = 1;\n  }\n\n  if (bufmin > 0 &&\n      (size_t) bufmin > buflen) {\n    bufmin = buflen;\n  }\n\n  nstrm_mode = netio_stream_mode(nstrm->strm_mode);\n\n  while (bufmin > 0) {\n    polling:\n\n    switch (pr_netio_poll(nstrm)) {\n      case 1:\n        return -2;\n\n      case -1:\n        return -1;\n\n      default:\n        do {\n          pr_signals_handle();\n\n          run_schedule();\n\n          switch (nstrm->strm_type) {\n            case PR_NETIO_STRM_CTRL:\n              if (ctrl_netio != NULL) {\n                pr_trace_msg(trace_channel, 19,\n                  \"using %s read() for control %s stream\",\n                  ctrl_netio->owner_name, nstrm_mode);\n                bread = (ctrl_netio->read)(nstrm, buf, buflen);\n\n              } else {\n                pr_trace_msg(trace_channel, 19,\n                  \"using %s read() for control %s stream\",\n                  default_ctrl_netio->owner_name, nstrm_mode);\n                bread = (default_ctrl_netio->read)(nstrm, buf, buflen);\n              }\n              break;\n\n            case PR_NETIO_STRM_DATA:\n              if (XFER_ABORTED) {\n                break;\n              }\n\n              if (data_netio != NULL) {\n                pr_trace_msg(trace_channel, 19,\n                  \"using %s read() for data %s stream\", data_netio->owner_name,\n                  nstrm_mode);\n                bread = (data_netio->read)(nstrm, buf, buflen);\n\n              } else {\n                pr_trace_msg(trace_channel, 19,\n                  \"using %s read() for data %s stream\",\n                  default_data_netio->owner_name, nstrm_mode);\n                bread = (default_data_netio->read)(nstrm, buf, buflen);\n              }\n              break;\n\n            case PR_NETIO_STRM_OTHR:\n              if (othr_netio != NULL) {\n                pr_trace_msg(trace_channel, 19,\n                  \"using %s read() for other %s stream\",\n                  othr_netio->owner_name, nstrm_mode);\n                bread = (othr_netio->read)(nstrm, buf, buflen);\n\n              } else {\n                pr_trace_msg(trace_channel, 19,\n                  \"using %s read() for other %s stream\",\n                  default_othr_netio->owner_name, nstrm_mode);\n                bread = (default_othr_netio->read)(nstrm, buf, buflen);\n              }\n              break;\n          }\n\n#ifdef EAGAIN\n\t  if (bread == -1 &&\n              errno == EAGAIN) {\n            int xerrno = EAGAIN;\n\n            /* Treat this as an interrupted call, call pr_signals_handle()\n             * (which will delay for a few msecs because of EINTR), and try\n             * again.\n             *\n             * This should avoid a tightly spinning loop if read(2) returns\n             * EAGAIN, as on a data transfer (Bug#3639).\n             */\n\n            errno = EINTR;\n            pr_signals_handle();\n\n            errno = xerrno;\n            goto polling;\n          }\n#endif\n\n        } while (bread == -1 && errno == EINTR);\n        break;\n    }\n\n    if (bread == -1) {\n      nstrm->strm_errno = errno;\n      return -1;\n    }\n\n    /* EOF? */\n    if (bread == 0) {\n      if (nstrm->strm_type == PR_NETIO_STRM_CTRL) {\n        pr_trace_msg(trace_channel, 7,\n          \"read %d bytes from control stream fd %d, handling as EOF\", bread,\n          nstrm->strm_fd);\n      }\n\n      nstrm->strm_errno = 0;\n      break;\n    }\n\n    /* Before we provide the data from the client, generate an event\n     * for any listeners which may want to examine this data.  To do this, we\n     * need to allocate a pr_buffer_t for sending the buffer data to the\n     * listeners.\n     *\n     * We could just use nstrm->strm_pool, but for a long-lived control\n     * connection, this would amount to a slow memory increase.  So instead,\n     * we create a subpool from the stream's pool, and allocate the\n     * pr_buffer_t out of that.  Then simply destroy the subpool when done.\n     */\n\n    tmp_pool = make_sub_pool(nstrm->strm_pool);\n    pbuf = pcalloc(tmp_pool, sizeof(pr_buffer_t));\n    pbuf->buf = buf;\n    pbuf->buflen = bread;\n    pbuf->current = pbuf->buf;\n    pbuf->remaining = 0;\n\n    switch (nstrm->strm_type) {\n      case PR_NETIO_STRM_CTRL:\n        pr_event_generate(\"core.ctrl-read\", pbuf);\n        break;\n\n      case PR_NETIO_STRM_DATA:\n        pr_event_generate(\"core.data-read\", pbuf);\n        break;\n\n      case PR_NETIO_STRM_OTHR:\n        pr_event_generate(\"core.othr-read\", pbuf);\n        break;\n    }\n\n    /* The event listeners may have changed the data read in out. */\n    buf = pbuf->buf;\n    bread = pbuf->buflen - pbuf->remaining;\n    destroy_pool(tmp_pool);\n\n    buf += bread;\n    total += bread;\n    bufmin -= bread;\n    buflen -= bread;\n  }\n\n  session.total_raw_in += total;\n  return total;\n}",
        "func": "int pr_netio_read(pr_netio_stream_t *nstrm, char *buf, size_t buflen,\n    int bufmin) {\n  int bread = 0, total = 0;\n  const char *nstrm_mode;\n  pr_buffer_t *pbuf;\n  pool *tmp_pool;\n\n  /* Sanity check. */\n  if (nstrm == NULL ||\n      buf == NULL ||\n      buflen == 0) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  if (nstrm->strm_fd == -1) {\n    errno = (nstrm->strm_errno ? nstrm->strm_errno : EBADF);\n    return -1;\n  }\n\n  if (bufmin < 1) {\n    bufmin = 1;\n  }\n\n  if (bufmin > 0 &&\n      (size_t) bufmin > buflen) {\n    bufmin = buflen;\n  }\n\n  nstrm_mode = netio_stream_mode(nstrm->strm_mode);\n\n  while (bufmin > 0) {\n    polling:\n\n    switch (pr_netio_poll(nstrm)) {\n      case 1:\n        return -2;\n\n      case -1:\n        return -1;\n\n      default:\n        do {\n          pr_signals_handle();\n\n          run_schedule();\n\n          switch (nstrm->strm_type) {\n            case PR_NETIO_STRM_CTRL:\n              if (ctrl_netio != NULL) {\n                pr_trace_msg(trace_channel, 19,\n                  \"using %s read() for control %s stream\",\n                  ctrl_netio->owner_name, nstrm_mode);\n                bread = (ctrl_netio->read)(nstrm, buf, buflen);\n\n              } else {\n                pr_trace_msg(trace_channel, 19,\n                  \"using %s read() for control %s stream\",\n                  default_ctrl_netio->owner_name, nstrm_mode);\n                bread = (default_ctrl_netio->read)(nstrm, buf, buflen);\n              }\n              break;\n\n            case PR_NETIO_STRM_DATA:\n              if (XFER_ABORTED) {\n                break;\n              }\n\n              if (data_netio != NULL) {\n                pr_trace_msg(trace_channel, 19,\n                  \"using %s read() for data %s stream\", data_netio->owner_name,\n                  nstrm_mode);\n                bread = (data_netio->read)(nstrm, buf, buflen);\n\n              } else {\n                pr_trace_msg(trace_channel, 19,\n                  \"using %s read() for data %s stream\",\n                  default_data_netio->owner_name, nstrm_mode);\n                bread = (default_data_netio->read)(nstrm, buf, buflen);\n              }\n              break;\n\n            case PR_NETIO_STRM_OTHR:\n              if (othr_netio != NULL) {\n                pr_trace_msg(trace_channel, 19,\n                  \"using %s read() for other %s stream\",\n                  othr_netio->owner_name, nstrm_mode);\n                bread = (othr_netio->read)(nstrm, buf, buflen);\n\n              } else {\n                pr_trace_msg(trace_channel, 19,\n                  \"using %s read() for other %s stream\",\n                  default_othr_netio->owner_name, nstrm_mode);\n                bread = (default_othr_netio->read)(nstrm, buf, buflen);\n              }\n              break;\n          }\n\n#ifdef EAGAIN\n\t  if (bread == -1 &&\n              errno == EAGAIN) {\n            int xerrno = EAGAIN;\n\n            /* Treat this as an interrupted call, call pr_signals_handle()\n             * (which will delay for a few msecs because of EINTR), and try\n             * again.\n             *\n             * This should avoid a tightly spinning loop if read(2) returns\n             * EAGAIN, as on a data transfer (Bug#3639).\n             */\n\n            errno = EINTR;\n            pr_signals_handle();\n\n            errno = xerrno;\n            goto polling;\n          }\n#endif\n\n        } while (bread == -1 && errno == EINTR);\n        break;\n    }\n\n    if (bread == -1) {\n      nstrm->strm_errno = errno;\n      return -1;\n    }\n\n    /* EOF? */\n    if (bread == 0) {\n      if (nstrm->strm_type == PR_NETIO_STRM_CTRL) {\n        pr_trace_msg(trace_channel, 7,\n          \"read %d bytes from control stream fd %d, handling as EOF\", bread,\n          nstrm->strm_fd);\n      }\n\n      nstrm->strm_errno = 0;\n      errno = EOF;\n      break;\n    }\n\n    /* Before we provide the data from the client, generate an event\n     * for any listeners which may want to examine this data.  To do this, we\n     * need to allocate a pr_buffer_t for sending the buffer data to the\n     * listeners.\n     *\n     * We could just use nstrm->strm_pool, but for a long-lived control\n     * connection, this would amount to a slow memory increase.  So instead,\n     * we create a subpool from the stream's pool, and allocate the\n     * pr_buffer_t out of that.  Then simply destroy the subpool when done.\n     */\n\n    tmp_pool = make_sub_pool(nstrm->strm_pool);\n    pbuf = pcalloc(tmp_pool, sizeof(pr_buffer_t));\n    pbuf->buf = buf;\n    pbuf->buflen = bread;\n    pbuf->current = pbuf->buf;\n    pbuf->remaining = 0;\n\n    switch (nstrm->strm_type) {\n      case PR_NETIO_STRM_CTRL:\n        pr_event_generate(\"core.ctrl-read\", pbuf);\n        break;\n\n      case PR_NETIO_STRM_DATA:\n        pr_event_generate(\"core.data-read\", pbuf);\n        break;\n\n      case PR_NETIO_STRM_OTHR:\n        pr_event_generate(\"core.othr-read\", pbuf);\n        break;\n    }\n\n    /* The event listeners may have changed the data read in out. */\n    buf = pbuf->buf;\n    bread = pbuf->buflen - pbuf->remaining;\n    destroy_pool(tmp_pool);\n\n    buf += bread;\n    total += bread;\n    bufmin -= bread;\n    buflen -= bread;\n  }\n\n  session.total_raw_in += total;\n  return total;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -135,6 +135,7 @@\n       }\n \n       nstrm->strm_errno = 0;\n+      errno = EOF;\n       break;\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      errno = EOF;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18217",
        "func_name": "proftpd/pr_cmd_read",
        "description": "ProFTPD before 1.3.6b and 1.3.7rc before 1.3.7rc2 allows remote unauthenticated denial-of-service due to incorrect handling of overly long commands because main.c in a child process enters an infinite loop.",
        "git_url": "https://github.com/proftpd/proftpd/commit/518dc1a6e486291fa4f13d2caff0a8aec52d093e",
        "commit_title": "Issue #846: Handle the case where a client tries to send too-large commands",
        "commit_text": "in an effort to DoS the server.",
        "func_before": "int pr_cmd_read(cmd_rec **res) {\n  static long cmd_bufsz = -1;\n  static char *cmd_buf = NULL;\n  int cmd_buflen;\n  char *ptr;\n\n  if (res == NULL) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  if (cmd_bufsz == -1) {\n    cmd_bufsz = get_max_cmd_sz();\n  }\n\n  if (cmd_buf == NULL) {\n    cmd_buf = pcalloc(session.pool, cmd_bufsz + 1);\n  }\n\n  while (TRUE) {\n    pr_signals_handle();\n\n    memset(cmd_buf, '\\0', cmd_bufsz);\n\n    cmd_buflen = pr_netio_telnet_gets2(cmd_buf, cmd_bufsz, session.c->instrm,\n      session.c->outstrm);\n    if (cmd_buflen < 0) {\n      if (errno == E2BIG) {\n        /* The client sent a too-long command which was ignored; give\n         * them another chance?\n         */\n        continue;\n      }\n\n      if (session.c->instrm->strm_errno == 0) {\n        pr_trace_msg(\"command\", 6,\n          \"client sent EOF, closing control connection\");\n      }\n\n      return -1;\n    }\n\n    break;\n  }\n\n  /* If the read length is less than the cmd_bufsz, then there is no need to\n   * truncate the buffer by inserting a NUL.\n   */\n  if (cmd_buflen > cmd_bufsz) {\n    pr_log_debug(DEBUG0, \"truncating incoming command length (%d bytes) to \"\n      \"CommandBufferSize %lu; use the CommandBufferSize directive to increase \"\n      \"the allowed command length\", cmd_buflen, (unsigned long) cmd_bufsz);\n    cmd_buf[cmd_bufsz-1] = '\\0';\n  }\n\n  if (cmd_buflen > 0 &&\n      (cmd_buf[cmd_buflen-1] == '\\n' || cmd_buf[cmd_buflen-1] == '\\r')) {\n    cmd_buf[cmd_buflen-1] = '\\0';\n    cmd_buflen--;\n\n    if (cmd_buflen > 0 &&\n        (cmd_buf[cmd_buflen-1] == '\\n' || cmd_buf[cmd_buflen-1] =='\\r')) {\n      cmd_buf[cmd_buflen-1] = '\\0';\n      cmd_buflen--;\n    }\n  }\n\n  ptr = cmd_buf;\n  if (*ptr == '\\r') {\n    ptr++;\n  }\n\n  if (*ptr) {\n    int flags = 0;\n    cmd_rec *cmd;\n\n    /* If this is a SITE command, preserve embedded whitespace in the\n     * command parameters, in order to handle file names that have multiple\n     * spaces in the names.  Arguably this should be handled in the SITE\n     * command handlers themselves, via cmd->arg.  This small hack\n     * reduces the burden on SITE module developers, however.\n     */\n    if (strncasecmp(ptr, C_SITE, 4) == 0) {\n      flags |= PR_STR_FL_PRESERVE_WHITESPACE;\n    }\n\n    cmd = make_ftp_cmd(session.pool, ptr, cmd_buflen, flags);\n    if (cmd != NULL) {\n      *res = cmd;\n\n      if (pr_cmd_is_http(cmd) == TRUE) {\n        cmd->is_ftp = FALSE;\n        cmd->protocol = \"HTTP\";\n\n      } else if (pr_cmd_is_ssh2(cmd) == TRUE) {\n        cmd->is_ftp = FALSE;\n        cmd->protocol = \"SSH2\";\n\n      } else if (pr_cmd_is_smtp(cmd) == TRUE) {\n        cmd->is_ftp = FALSE;\n        cmd->protocol = \"SMTP\";\n\n      } else {\n        /* Assume that the client is sending valid FTP commands. */\n        cmd->is_ftp = TRUE;\n        cmd->protocol = \"FTP\";\n      }\n    } \n  }\n\n  return 0;\n}",
        "func": "int pr_cmd_read(cmd_rec **res) {\n  static long cmd_bufsz = -1;\n  static char *cmd_buf = NULL;\n  int cmd_buflen;\n  unsigned int too_large_count = 0;\n  char *ptr;\n\n  if (res == NULL) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  if (cmd_bufsz == -1) {\n    cmd_bufsz = get_max_cmd_sz();\n  }\n\n  if (cmd_buf == NULL) {\n    cmd_buf = pcalloc(session.pool, cmd_bufsz + 1);\n  }\n\n  while (TRUE) {\n    pr_signals_handle();\n\n    memset(cmd_buf, '\\0', cmd_bufsz);\n\n    cmd_buflen = pr_netio_telnet_gets2(cmd_buf, cmd_bufsz, session.c->instrm,\n      session.c->outstrm);\n    if (cmd_buflen < 0) {\n      if (errno == E2BIG) {\n        /* The client sent a too-long command which was ignored; give\n         * them a few more chances, with minor delays?\n         */\n        too_large_count++;\n        pr_timer_usleep(250 * 1000);\n\n        if (too_large_count > 3) {\n          return -1;\n        }\n\n        continue;\n      }\n\n      if (session.c->instrm->strm_errno == 0) {\n        pr_trace_msg(\"command\", 6,\n          \"client sent EOF, closing control connection\");\n      }\n\n      return -1;\n    }\n\n    break;\n  }\n\n  /* If the read length is less than the cmd_bufsz, then there is no need to\n   * truncate the buffer by inserting a NUL.\n   */\n  if (cmd_buflen > cmd_bufsz) {\n    pr_log_debug(DEBUG0, \"truncating incoming command length (%d bytes) to \"\n      \"CommandBufferSize %lu; use the CommandBufferSize directive to increase \"\n      \"the allowed command length\", cmd_buflen, (unsigned long) cmd_bufsz);\n    cmd_buf[cmd_bufsz-1] = '\\0';\n  }\n\n  if (cmd_buflen > 0 &&\n      (cmd_buf[cmd_buflen-1] == '\\n' || cmd_buf[cmd_buflen-1] == '\\r')) {\n    cmd_buf[cmd_buflen-1] = '\\0';\n    cmd_buflen--;\n\n    if (cmd_buflen > 0 &&\n        (cmd_buf[cmd_buflen-1] == '\\n' || cmd_buf[cmd_buflen-1] =='\\r')) {\n      cmd_buf[cmd_buflen-1] = '\\0';\n      cmd_buflen--;\n    }\n  }\n\n  ptr = cmd_buf;\n  if (*ptr == '\\r') {\n    ptr++;\n  }\n\n  if (*ptr) {\n    int flags = 0;\n    cmd_rec *cmd;\n\n    /* If this is a SITE command, preserve embedded whitespace in the\n     * command parameters, in order to handle file names that have multiple\n     * spaces in the names.  Arguably this should be handled in the SITE\n     * command handlers themselves, via cmd->arg.  This small hack\n     * reduces the burden on SITE module developers, however.\n     */\n    if (strncasecmp(ptr, C_SITE, 4) == 0) {\n      flags |= PR_STR_FL_PRESERVE_WHITESPACE;\n    }\n\n    cmd = make_ftp_cmd(session.pool, ptr, cmd_buflen, flags);\n    if (cmd != NULL) {\n      *res = cmd;\n\n      if (pr_cmd_is_http(cmd) == TRUE) {\n        cmd->is_ftp = FALSE;\n        cmd->protocol = \"HTTP\";\n\n      } else if (pr_cmd_is_ssh2(cmd) == TRUE) {\n        cmd->is_ftp = FALSE;\n        cmd->protocol = \"SSH2\";\n\n      } else if (pr_cmd_is_smtp(cmd) == TRUE) {\n        cmd->is_ftp = FALSE;\n        cmd->protocol = \"SMTP\";\n\n      } else {\n        /* Assume that the client is sending valid FTP commands. */\n        cmd->is_ftp = TRUE;\n        cmd->protocol = \"FTP\";\n      }\n    } \n  }\n\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,7 @@\n   static long cmd_bufsz = -1;\n   static char *cmd_buf = NULL;\n   int cmd_buflen;\n+  unsigned int too_large_count = 0;\n   char *ptr;\n \n   if (res == NULL) {\n@@ -27,8 +28,15 @@\n     if (cmd_buflen < 0) {\n       if (errno == E2BIG) {\n         /* The client sent a too-long command which was ignored; give\n-         * them another chance?\n+         * them a few more chances, with minor delays?\n          */\n+        too_large_count++;\n+        pr_timer_usleep(250 * 1000);\n+\n+        if (too_large_count > 3) {\n+          return -1;\n+        }\n+\n         continue;\n       }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "         * them another chance?"
            ],
            "added_lines": [
                "  unsigned int too_large_count = 0;",
                "         * them a few more chances, with minor delays?",
                "        too_large_count++;",
                "        pr_timer_usleep(250 * 1000);",
                "",
                "        if (too_large_count > 3) {",
                "          return -1;",
                "        }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0586",
        "func_name": "wireshark/rtmpt_get_amf_length",
        "description": "Infinite loop in RTMPT protocol dissector in Wireshark 3.6.0 to 3.6.1 and 3.4.0 to 3.4.11 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/24403a9a35cd7fbe5ea6e596b1c6deb9d8633566",
        "commit_title": "rtmpt: limit the number of iterations in rtmpt_get_amf_length().",
        "commit_text": " This prevents a infinite-loop caused by crafted packets.  Fix: #17813. ",
        "func_before": "static gint\nrtmpt_get_amf_length(tvbuff_t *tvb, gint offset)\n{\n        guint8  iObjType;\n        gint    remain  = tvb_reported_length_remaining(tvb, offset);\n        guint32 depth   = 0;\n        gint    itemlen = 0;\n        gint    rv      = 0;\n\n        while (rv == 0 || depth > 0) {\n\n                if (depth > 0) {\n                        if (remain-rv < 2)\n                                return remain;\n                        itemlen = tvb_get_ntohs(tvb, offset+rv) + 2;\n                        if (remain-rv<itemlen+1)\n                                return remain;\n                        rv += itemlen;\n                }\n\n                if (remain-rv < 1)\n                        return remain;\n                iObjType = tvb_get_guint8(tvb, offset+rv);\n\n                if (depth > 0 && itemlen == 2 && iObjType == AMF0_END_OF_OBJECT) {\n                        rv++;\n                        depth--;\n                        continue;\n                }\n\n                switch (iObjType) {\n                case AMF0_NUMBER:\n                        itemlen = 9;\n                        break;\n                case AMF0_BOOLEAN:\n                        itemlen = 2;\n                        break;\n                case AMF0_STRING:\n                        if (remain-rv < 3)\n                                return remain;\n                        itemlen = tvb_get_ntohs(tvb, offset+rv+1) + 3;\n                        break;\n                case AMF0_NULL:\n                case AMF0_UNDEFINED:\n                case AMF0_UNSUPPORTED:\n                        itemlen= 1;\n                        break;\n                case AMF0_DATE:\n                        itemlen = 11;\n                        break;\n                case AMF0_LONG_STRING:\n                case AMF0_XML:\n                        if (remain-rv < 5)\n                                return remain;\n                        itemlen = tvb_get_ntohl(tvb, offset+rv+1) + 5;\n                        break;\n                case AMF0_INT64:\n                        itemlen = 9;\n                        break;\n                case AMF0_OBJECT:\n                        itemlen = 1;\n                        depth++;\n                        break;\n                case AMF0_ECMA_ARRAY:\n                        itemlen = 5;\n                        depth++;\n                        break;\n                default:\n                        return remain;\n                }\n\n                if (remain-rv < itemlen)\n                        return remain;\n                rv += itemlen;\n\n        }\n\n        return rv;\n}",
        "func": "static guint32\nrtmpt_get_amf_length(tvbuff_t *tvb, gint offset, proto_item* pi)\n{\n        guint8  iObjType;\n        gint    remain  = tvb_reported_length_remaining(tvb, offset);\n        guint32 depth   = 0;\n        guint32 itemlen = 0;\n        guint32 rv      = 0;\n        guint   iterations = MAX_AMF_ITERATIONS;\n\n        while (rv == 0 || depth > 0) {\n\n                if (--iterations) {\n                        expert_add_info(NULL, pi, &ei_amf_loop);\n                        return 0;\n                }\n\n                if (depth > 0) {\n                        if (remain-rv < 2)\n                                return remain;\n                        itemlen = tvb_get_ntohs(tvb, offset+rv) + 2;\n                        if (remain-rv<itemlen+1)\n                                return remain;\n                        rv += itemlen;\n                }\n\n                if (remain-rv < 1)\n                        return remain;\n                iObjType = tvb_get_guint8(tvb, offset+rv);\n\n                if (depth > 0 && itemlen == 2 && iObjType == AMF0_END_OF_OBJECT) {\n                        rv++;\n                        depth--;\n                        continue;\n                }\n\n                switch (iObjType) {\n                case AMF0_NUMBER:\n                        itemlen = 9;\n                        break;\n                case AMF0_BOOLEAN:\n                        itemlen = 2;\n                        break;\n                case AMF0_STRING:\n                        if (remain-rv < 3)\n                                return remain;\n                        itemlen = tvb_get_ntohs(tvb, offset+rv+1) + 3;\n                        break;\n                case AMF0_NULL:\n                case AMF0_UNDEFINED:\n                case AMF0_UNSUPPORTED:\n                        itemlen = 1;\n                        break;\n                case AMF0_DATE:\n                        itemlen = 11;\n                        break;\n                case AMF0_LONG_STRING:\n                case AMF0_XML:\n                        if (remain-rv < 5)\n                                return remain;\n                        itemlen = tvb_get_ntohl(tvb, offset+rv+1) + 5;\n                        break;\n                case AMF0_INT64:\n                        itemlen = 9;\n                        break;\n                case AMF0_OBJECT:\n                        itemlen = 1;\n                        depth++;\n                        break;\n                case AMF0_ECMA_ARRAY:\n                        itemlen = 5;\n                        depth++;\n                        break;\n                default:\n                        return remain;\n                }\n\n                if (remain-rv < itemlen)\n                        return remain;\n                rv += itemlen;\n\n        }\n\n        return rv;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,13 +1,19 @@\n-static gint\n-rtmpt_get_amf_length(tvbuff_t *tvb, gint offset)\n+static guint32\n+rtmpt_get_amf_length(tvbuff_t *tvb, gint offset, proto_item* pi)\n {\n         guint8  iObjType;\n         gint    remain  = tvb_reported_length_remaining(tvb, offset);\n         guint32 depth   = 0;\n-        gint    itemlen = 0;\n-        gint    rv      = 0;\n+        guint32 itemlen = 0;\n+        guint32 rv      = 0;\n+        guint   iterations = MAX_AMF_ITERATIONS;\n \n         while (rv == 0 || depth > 0) {\n+\n+                if (--iterations) {\n+                        expert_add_info(NULL, pi, &ei_amf_loop);\n+                        return 0;\n+                }\n \n                 if (depth > 0) {\n                         if (remain-rv < 2)\n@@ -43,7 +49,7 @@\n                 case AMF0_NULL:\n                 case AMF0_UNDEFINED:\n                 case AMF0_UNSUPPORTED:\n-                        itemlen= 1;\n+                        itemlen = 1;\n                         break;\n                 case AMF0_DATE:\n                         itemlen = 11;",
        "diff_line_info": {
            "deleted_lines": [
                "static gint",
                "rtmpt_get_amf_length(tvbuff_t *tvb, gint offset)",
                "        gint    itemlen = 0;",
                "        gint    rv      = 0;",
                "                        itemlen= 1;"
            ],
            "added_lines": [
                "static guint32",
                "rtmpt_get_amf_length(tvbuff_t *tvb, gint offset, proto_item* pi)",
                "        guint32 itemlen = 0;",
                "        guint32 rv      = 0;",
                "        guint   iterations = MAX_AMF_ITERATIONS;",
                "",
                "                if (--iterations) {",
                "                        expert_add_info(NULL, pi, &ei_amf_loop);",
                "                        return 0;",
                "                }",
                "                        itemlen = 1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0586",
        "func_name": "wireshark/proto_register_amf",
        "description": "Infinite loop in RTMPT protocol dissector in Wireshark 3.6.0 to 3.6.1 and 3.4.0 to 3.4.11 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/24403a9a35cd7fbe5ea6e596b1c6deb9d8633566",
        "commit_title": "rtmpt: limit the number of iterations in rtmpt_get_amf_length().",
        "commit_text": " This prevents a infinite-loop caused by crafted packets.  Fix: #17813. ",
        "func_before": "void\nproto_register_amf(void)\n{\n        static hf_register_info hf[] = {\n                { &hf_amf_version,\n                  { \"AMF version\", \"amf.version\", FT_UINT16, BASE_DEC,\n                    NULL, 0x0, NULL, HFILL }},\n\n                { &hf_amf_header_count,\n                  { \"Header count\", \"amf.header_count\", FT_UINT16, BASE_DEC,\n                    NULL, 0x0, NULL, HFILL }},\n\n                { &hf_amf_header_name,\n                  { \"Name\", \"amf.header.name\", FT_UINT_STRING, BASE_NONE,\n                    NULL, 0x0, NULL, HFILL }},\n\n                { &hf_amf_header_must_understand,\n                  { \"Must understand\", \"amf.header.must_understand\", FT_BOOLEAN, BASE_NONE,\n                    NULL, 0x0, NULL, HFILL }},\n\n                { &hf_amf_header_length,\n                  { \"Length\", \"amf.header.length\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, NULL, HFILL }},\n\n#if 0\n                { &hf_amf_header_value_type,\n                  { \"Value type\", \"amf.header.value_type\", FT_UINT32, BASE_HEX,\n                    VALS(rtmpt_type_vals), 0x0, NULL, HFILL }},\n#endif\n\n                { &hf_amf_message_count,\n                  { \"Message count\", \"amf.message_count\", FT_UINT16, BASE_DEC,\n                    NULL, 0x0, NULL, HFILL }},\n\n                { &hf_amf_message_target_uri,\n                  { \"Target URI\", \"amf.message.target_uri\", FT_UINT_STRING, BASE_NONE,\n                    NULL, 0x0, NULL, HFILL }},\n\n                { &hf_amf_message_response_uri,\n                  { \"Response URI\", \"amf.message.response_uri\", FT_UINT_STRING, BASE_NONE,\n                    NULL, 0x0, NULL, HFILL }},\n\n                { &hf_amf_message_length,\n                  { \"Length\", \"amf.message.length\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, NULL, HFILL }},\n\n\n/* AMF basic types */\n                { &hf_amf_amf0_type,\n                  { \"AMF0 type\", \"amf.amf0_type\", FT_UINT8, BASE_HEX,\n                    VALS(amf0_type_vals), 0x0, NULL, HFILL }},\n\n                { &hf_amf_amf3_type,\n                  { \"AMF3 type\", \"amf.amf3_type\", FT_UINT8, BASE_HEX,\n                    VALS(amf3_type_vals), 0x0, NULL, HFILL }},\n\n                { &hf_amf_number,\n                  { \"Number\", \"amf.number\", FT_DOUBLE, BASE_NONE,\n                    NULL, 0x0, \"AMF number\", HFILL }},\n\n                { &hf_amf_integer,\n                  { \"Integer\", \"amf.integer\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"RTMPT AMF3 integer\", HFILL }},\n\n                { &hf_amf_boolean,\n                  { \"Boolean\", \"amf.boolean\", FT_BOOLEAN, BASE_NONE,\n                    NULL, 0x0, \"AMF boolean\", HFILL }},\n\n                { &hf_amf_stringlength,\n                  { \"String length\", \"amf.stringlength\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF string length\", HFILL }},\n\n                { &hf_amf_string,\n                  { \"String\", \"amf.string\", FT_STRING, BASE_NONE,\n                    NULL, 0x0, \"AMF string\", HFILL }},\n\n                { &hf_amf_string_reference,\n                  { \"String reference\", \"amf.string_reference\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"RTMPT AMF3 string reference\", HFILL }},\n\n                { &hf_amf_object_reference,\n                  { \"Object reference\", \"amf.object_reference\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF object reference\", HFILL }},\n\n                { &hf_amf_date,\n                  { \"Date\", \"amf.date\", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL,\n                    NULL, 0x0, \"AMF date\", HFILL }},\n\n#if 0\n                { &hf_amf_longstringlength,\n                  { \"String length\", \"amf.longstringlength\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF long string length\", HFILL }},\n#endif\n\n                { &hf_amf_longstring,\n                  { \"Long string\", \"amf.longstring\", FT_STRING, BASE_NONE,\n                    NULL, 0x0, \"AMF long string\", HFILL }},\n\n                { &hf_amf_xml_doc,\n                  { \"XML document\", \"amf.xml_doc\", FT_STRING, BASE_NONE,\n                    NULL, 0x0, \"AMF XML document\", HFILL }},\n\n                { &hf_amf_xmllength,\n                  { \"XML text length\", \"amf.xmllength\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF E4X XML length\", HFILL }},\n\n                { &hf_amf_xml,\n                  { \"XML\", \"amf.xml\", FT_STRING, BASE_NONE,\n                    NULL, 0x0, \"AMF E4X XML\", HFILL }},\n\n                { &hf_amf_int64,\n                  { \"Int64\", \"amf.int64\", FT_INT64, BASE_DEC,\n                    NULL, 0x0, \"AMF int64\", HFILL }},\n\n                { &hf_amf_bytearraylength,\n                  { \"ByteArray length\", \"amf.bytearraylength\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"RTMPT AMF3 ByteArray length\", HFILL }},\n\n                { &hf_amf_bytearray,\n                  { \"ByteArray\", \"amf.bytearray\", FT_BYTES, BASE_NONE,\n                    NULL, 0x0, \"RTMPT AMF3 ByteArray\", HFILL }},\n\n/* AMF object types and subfields of the object types */\n                { &hf_amf_object,\n                  { \"Object\", \"amf.object\", FT_NONE, BASE_NONE,\n                    NULL, 0x0, \"AMF object\", HFILL }},\n\n                { &hf_amf_traitcount,\n                  { \"Trait count\", \"amf.traitcount\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF count of traits for an object\", HFILL }},\n\n                { &hf_amf_classnamelength,\n                  { \"Class name length\", \"amf.classnamelength\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF class name length\", HFILL }},\n\n                { &hf_amf_classname,\n                  { \"Class name\", \"amf.classname\", FT_STRING, BASE_NONE,\n                    NULL, 0x0, \"AMF class name\", HFILL }},\n\n                { &hf_amf_membernamelength,\n                  { \"Member name length\", \"amf.membernamelength\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF member name length\", HFILL }},\n\n                { &hf_amf_membername,\n                  { \"Member name\", \"amf.membername\", FT_STRING, BASE_NONE,\n                    NULL, 0x0, \"AMF member name\", HFILL }},\n\n                { &hf_amf_trait_reference,\n                  { \"Trait reference\", \"amf.trait_reference\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF trait reference\", HFILL }},\n\n                { &hf_amf_ecmaarray,\n                  { \"ECMA array\", \"amf.ecmaarray\", FT_NONE, BASE_NONE,\n                    NULL, 0x0, \"AMF ECMA array\", HFILL }},\n\n                { &hf_amf_strictarray,\n                  { \"Strict array\", \"amf.strictarray\", FT_NONE, BASE_NONE,\n                    NULL, 0x0, \"AMF strict array\", HFILL }},\n\n                { &hf_amf_array,\n                  { \"Array\", \"amf.array\", FT_NONE, BASE_NONE,\n                    NULL, 0x0, \"RTMPT AMF3 array\", HFILL }},\n\n                { &hf_amf_arraylength,\n                  { \"Array length\", \"amf.arraylength\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF array length\", HFILL }},\n\n                { &hf_amf_arraydenselength,\n                  { \"Length of dense portion\", \"amf.arraydenselength\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF length of dense portion of array\", HFILL }},\n\n                { &hf_amf_end_of_object_marker,\n                  { \"End Of Object Marker\", \"amf.end_of_object_marker\", FT_NONE, BASE_NONE,\n                    NULL, 0x0, NULL, HFILL }},\n\n                { &hf_amf_end_of_associative_part,\n                  { \"End of associative part\", \"amf.end_of_associative_part\", FT_NONE, BASE_NONE,\n                    NULL, 0x0, NULL, HFILL }},\n\n                { &hf_amf_end_of_dynamic_members,\n                  { \"End Of dynamic members\", \"amf.end_of_dynamic_members\", FT_NONE, BASE_NONE,\n                    NULL, 0x0, NULL, HFILL }},\n        };\n        static gint *ett[] = {\n                &ett_amf,\n                &ett_amf_headers,\n                &ett_amf_messages,\n                &ett_amf_value,\n                &ett_amf_property,\n                &ett_amf_string,\n                &ett_amf_array_element,\n                &ett_amf_traits,\n                &ett_amf_trait_member,\n        };\n\n        proto_amf = proto_register_protocol(\"Action Message Format\", \"AMF\", \"amf\");\n        proto_register_field_array(proto_amf, hf, array_length(hf));\n        proto_register_subtree_array(ett, array_length(ett));\n}",
        "func": "void\nproto_register_amf(void)\n{\n        static hf_register_info hf[] = {\n                { &hf_amf_version,\n                  { \"AMF version\", \"amf.version\", FT_UINT16, BASE_DEC,\n                    NULL, 0x0, NULL, HFILL }},\n\n                { &hf_amf_header_count,\n                  { \"Header count\", \"amf.header_count\", FT_UINT16, BASE_DEC,\n                    NULL, 0x0, NULL, HFILL }},\n\n                { &hf_amf_header_name,\n                  { \"Name\", \"amf.header.name\", FT_UINT_STRING, BASE_NONE,\n                    NULL, 0x0, NULL, HFILL }},\n\n                { &hf_amf_header_must_understand,\n                  { \"Must understand\", \"amf.header.must_understand\", FT_BOOLEAN, BASE_NONE,\n                    NULL, 0x0, NULL, HFILL }},\n\n                { &hf_amf_header_length,\n                  { \"Length\", \"amf.header.length\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, NULL, HFILL }},\n\n#if 0\n                { &hf_amf_header_value_type,\n                  { \"Value type\", \"amf.header.value_type\", FT_UINT32, BASE_HEX,\n                    VALS(rtmpt_type_vals), 0x0, NULL, HFILL }},\n#endif\n\n                { &hf_amf_message_count,\n                  { \"Message count\", \"amf.message_count\", FT_UINT16, BASE_DEC,\n                    NULL, 0x0, NULL, HFILL }},\n\n                { &hf_amf_message_target_uri,\n                  { \"Target URI\", \"amf.message.target_uri\", FT_UINT_STRING, BASE_NONE,\n                    NULL, 0x0, NULL, HFILL }},\n\n                { &hf_amf_message_response_uri,\n                  { \"Response URI\", \"amf.message.response_uri\", FT_UINT_STRING, BASE_NONE,\n                    NULL, 0x0, NULL, HFILL }},\n\n                { &hf_amf_message_length,\n                  { \"Length\", \"amf.message.length\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, NULL, HFILL }},\n\n\n/* AMF basic types */\n                { &hf_amf_amf0_type,\n                  { \"AMF0 type\", \"amf.amf0_type\", FT_UINT8, BASE_HEX,\n                    VALS(amf0_type_vals), 0x0, NULL, HFILL }},\n\n                { &hf_amf_amf3_type,\n                  { \"AMF3 type\", \"amf.amf3_type\", FT_UINT8, BASE_HEX,\n                    VALS(amf3_type_vals), 0x0, NULL, HFILL }},\n\n                { &hf_amf_number,\n                  { \"Number\", \"amf.number\", FT_DOUBLE, BASE_NONE,\n                    NULL, 0x0, \"AMF number\", HFILL }},\n\n                { &hf_amf_integer,\n                  { \"Integer\", \"amf.integer\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"RTMPT AMF3 integer\", HFILL }},\n\n                { &hf_amf_boolean,\n                  { \"Boolean\", \"amf.boolean\", FT_BOOLEAN, BASE_NONE,\n                    NULL, 0x0, \"AMF boolean\", HFILL }},\n\n                { &hf_amf_stringlength,\n                  { \"String length\", \"amf.stringlength\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF string length\", HFILL }},\n\n                { &hf_amf_string,\n                  { \"String\", \"amf.string\", FT_STRING, BASE_NONE,\n                    NULL, 0x0, \"AMF string\", HFILL }},\n\n                { &hf_amf_string_reference,\n                  { \"String reference\", \"amf.string_reference\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"RTMPT AMF3 string reference\", HFILL }},\n\n                { &hf_amf_object_reference,\n                  { \"Object reference\", \"amf.object_reference\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF object reference\", HFILL }},\n\n                { &hf_amf_date,\n                  { \"Date\", \"amf.date\", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL,\n                    NULL, 0x0, \"AMF date\", HFILL }},\n\n#if 0\n                { &hf_amf_longstringlength,\n                  { \"String length\", \"amf.longstringlength\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF long string length\", HFILL }},\n#endif\n\n                { &hf_amf_longstring,\n                  { \"Long string\", \"amf.longstring\", FT_STRING, BASE_NONE,\n                    NULL, 0x0, \"AMF long string\", HFILL }},\n\n                { &hf_amf_xml_doc,\n                  { \"XML document\", \"amf.xml_doc\", FT_STRING, BASE_NONE,\n                    NULL, 0x0, \"AMF XML document\", HFILL }},\n\n                { &hf_amf_xmllength,\n                  { \"XML text length\", \"amf.xmllength\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF E4X XML length\", HFILL }},\n\n                { &hf_amf_xml,\n                  { \"XML\", \"amf.xml\", FT_STRING, BASE_NONE,\n                    NULL, 0x0, \"AMF E4X XML\", HFILL }},\n\n                { &hf_amf_int64,\n                  { \"Int64\", \"amf.int64\", FT_INT64, BASE_DEC,\n                    NULL, 0x0, \"AMF int64\", HFILL }},\n\n                { &hf_amf_bytearraylength,\n                  { \"ByteArray length\", \"amf.bytearraylength\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"RTMPT AMF3 ByteArray length\", HFILL }},\n\n                { &hf_amf_bytearray,\n                  { \"ByteArray\", \"amf.bytearray\", FT_BYTES, BASE_NONE,\n                    NULL, 0x0, \"RTMPT AMF3 ByteArray\", HFILL }},\n\n/* AMF object types and subfields of the object types */\n                { &hf_amf_object,\n                  { \"Object\", \"amf.object\", FT_NONE, BASE_NONE,\n                    NULL, 0x0, \"AMF object\", HFILL }},\n\n                { &hf_amf_traitcount,\n                  { \"Trait count\", \"amf.traitcount\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF count of traits for an object\", HFILL }},\n\n                { &hf_amf_classnamelength,\n                  { \"Class name length\", \"amf.classnamelength\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF class name length\", HFILL }},\n\n                { &hf_amf_classname,\n                  { \"Class name\", \"amf.classname\", FT_STRING, BASE_NONE,\n                    NULL, 0x0, \"AMF class name\", HFILL }},\n\n                { &hf_amf_membernamelength,\n                  { \"Member name length\", \"amf.membernamelength\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF member name length\", HFILL }},\n\n                { &hf_amf_membername,\n                  { \"Member name\", \"amf.membername\", FT_STRING, BASE_NONE,\n                    NULL, 0x0, \"AMF member name\", HFILL }},\n\n                { &hf_amf_trait_reference,\n                  { \"Trait reference\", \"amf.trait_reference\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF trait reference\", HFILL }},\n\n                { &hf_amf_ecmaarray,\n                  { \"ECMA array\", \"amf.ecmaarray\", FT_NONE, BASE_NONE,\n                    NULL, 0x0, \"AMF ECMA array\", HFILL }},\n\n                { &hf_amf_strictarray,\n                  { \"Strict array\", \"amf.strictarray\", FT_NONE, BASE_NONE,\n                    NULL, 0x0, \"AMF strict array\", HFILL }},\n\n                { &hf_amf_array,\n                  { \"Array\", \"amf.array\", FT_NONE, BASE_NONE,\n                    NULL, 0x0, \"RTMPT AMF3 array\", HFILL }},\n\n                { &hf_amf_arraylength,\n                  { \"Array length\", \"amf.arraylength\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF array length\", HFILL }},\n\n                { &hf_amf_arraydenselength,\n                  { \"Length of dense portion\", \"amf.arraydenselength\", FT_UINT32, BASE_DEC,\n                    NULL, 0x0, \"AMF length of dense portion of array\", HFILL }},\n\n                { &hf_amf_end_of_object_marker,\n                  { \"End Of Object Marker\", \"amf.end_of_object_marker\", FT_NONE, BASE_NONE,\n                    NULL, 0x0, NULL, HFILL }},\n\n                { &hf_amf_end_of_associative_part,\n                  { \"End of associative part\", \"amf.end_of_associative_part\", FT_NONE, BASE_NONE,\n                    NULL, 0x0, NULL, HFILL }},\n\n                { &hf_amf_end_of_dynamic_members,\n                  { \"End Of dynamic members\", \"amf.end_of_dynamic_members\", FT_NONE, BASE_NONE,\n                    NULL, 0x0, NULL, HFILL }},\n        };\n\n        static ei_register_info ei[] = {\n                { &ei_amf_loop, { \"amf.loop\", PI_MALFORMED, PI_ERROR, \"Loop in AMF dissection\", EXPFILL }}\n        };\n\n\n        static gint *ett[] = {\n                &ett_amf,\n                &ett_amf_headers,\n                &ett_amf_messages,\n                &ett_amf_value,\n                &ett_amf_property,\n                &ett_amf_string,\n                &ett_amf_array_element,\n                &ett_amf_traits,\n                &ett_amf_trait_member,\n        };\n\n        expert_module_t* expert_amf;\n\n        proto_amf = proto_register_protocol(\"Action Message Format\", \"AMF\", \"amf\");\n        proto_register_field_array(proto_amf, hf, array_length(hf));\n        proto_register_subtree_array(ett, array_length(ett));\n        expert_amf = expert_register_protocol(proto_amf);\n        expert_register_field_array(expert_amf, ei, array_length(ei));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -181,6 +181,12 @@\n                   { \"End Of dynamic members\", \"amf.end_of_dynamic_members\", FT_NONE, BASE_NONE,\n                     NULL, 0x0, NULL, HFILL }},\n         };\n+\n+        static ei_register_info ei[] = {\n+                { &ei_amf_loop, { \"amf.loop\", PI_MALFORMED, PI_ERROR, \"Loop in AMF dissection\", EXPFILL }}\n+        };\n+\n+\n         static gint *ett[] = {\n                 &ett_amf,\n                 &ett_amf_headers,\n@@ -193,7 +199,11 @@\n                 &ett_amf_trait_member,\n         };\n \n+        expert_module_t* expert_amf;\n+\n         proto_amf = proto_register_protocol(\"Action Message Format\", \"AMF\", \"amf\");\n         proto_register_field_array(proto_amf, hf, array_length(hf));\n         proto_register_subtree_array(ett, array_length(ett));\n+        expert_amf = expert_register_protocol(proto_amf);\n+        expert_register_field_array(expert_amf, ei, array_length(ei));\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "        static ei_register_info ei[] = {",
                "                { &ei_amf_loop, { \"amf.loop\", PI_MALFORMED, PI_ERROR, \"Loop in AMF dissection\", EXPFILL }}",
                "        };",
                "",
                "",
                "        expert_module_t* expert_amf;",
                "",
                "        expert_amf = expert_register_protocol(proto_amf);",
                "        expert_register_field_array(expert_amf, ei, array_length(ei));"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0586",
        "func_name": "wireshark/rtmpt_get_amf_param",
        "description": "Infinite loop in RTMPT protocol dissector in Wireshark 3.6.0 to 3.6.1 and 3.4.0 to 3.4.11 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/24403a9a35cd7fbe5ea6e596b1c6deb9d8633566",
        "commit_title": "rtmpt: limit the number of iterations in rtmpt_get_amf_length().",
        "commit_text": " This prevents a infinite-loop caused by crafted packets.  Fix: #17813. ",
        "func_before": "static gchar *\nrtmpt_get_amf_param(tvbuff_t *tvb, gint offset, gint param, const gchar *prop)\n{\n        guint32 remain = tvb_reported_length_remaining(tvb, offset);\n        guint32 itemlen;\n        guint32 iStringLength;\n\n        while (remain > 0 && param > 0) {\n                itemlen = rtmpt_get_amf_length(tvb, offset);\n                offset += itemlen;\n                remain -= itemlen;\n                param--;\n        }\n\n        if (remain > 0 && param == 0) {\n                guint8 iObjType = tvb_get_guint8(tvb, offset);\n\n                if (!prop && iObjType == AMF0_STRING && remain >= 3) {\n                        iStringLength = tvb_get_ntohs(tvb, offset+1);\n                        if (remain >= iStringLength+3) {\n                                return tvb_get_string_enc(wmem_packet_scope(), tvb, offset+3, iStringLength, ENC_ASCII);\n                        }\n                }\n\n                if (prop && iObjType == AMF0_OBJECT) {\n                        offset++;\n                        remain--;\n\n                        while (remain > 2) {\n                                guint32 iPropLength = tvb_get_ntohs(tvb, offset);\n                                if (remain < 2+iPropLength+3)\n                                        break;\n\n                                if (tvb_strneql(tvb, offset+2, prop, strlen(prop)) == 0) {\n                                        if (tvb_get_guint8(tvb, offset+2+iPropLength) != AMF0_STRING)\n                                                break;\n\n                                        iStringLength = tvb_get_ntohs(tvb, offset+2+iPropLength+1);\n                                        if (remain < 2+iPropLength+3+iStringLength)\n                                                break;\n\n                                        return tvb_get_string_enc(wmem_packet_scope(), tvb, offset+2+iPropLength+3, iStringLength, ENC_ASCII);\n                                }\n\n                                itemlen = rtmpt_get_amf_length(tvb, offset+2+iPropLength);\n                                offset += 2+iPropLength+itemlen;\n                                remain -= 2+iPropLength+itemlen;\n                        }\n                }\n        }\n\n        return NULL;\n}",
        "func": "static gchar *\nrtmpt_get_amf_param(tvbuff_t *tvb, gint offset, proto_item* pi, gint param, const gchar *prop)\n{\n        guint32 remain = tvb_reported_length_remaining(tvb, offset);\n        guint32 itemlen;\n        guint32 iStringLength;\n\n        while (remain > 0 && param > 0) {\n                itemlen = rtmpt_get_amf_length(tvb, offset, pi);\n                if (itemlen == 0)\n                        break;\n                offset += itemlen;\n                remain -= itemlen;\n                param--;\n        }\n\n        if (remain > 0 && param == 0) {\n                guint8 iObjType = tvb_get_guint8(tvb, offset);\n\n                if (!prop && iObjType == AMF0_STRING && remain >= 3) {\n                        iStringLength = tvb_get_ntohs(tvb, offset+1);\n                        if (remain >= iStringLength+3) {\n                                return tvb_get_string_enc(wmem_packet_scope(), tvb, offset+3, iStringLength, ENC_ASCII);\n                        }\n                }\n\n                if (prop && iObjType == AMF0_OBJECT) {\n                        offset++;\n                        remain--;\n\n                        while (remain > 2) {\n                                guint32 iPropLength = tvb_get_ntohs(tvb, offset);\n                                if (remain < 2+iPropLength+3)\n                                        break;\n\n                                if (tvb_strneql(tvb, offset+2, prop, strlen(prop)) == 0) {\n                                        if (tvb_get_guint8(tvb, offset+2+iPropLength) != AMF0_STRING)\n                                                break;\n\n                                        iStringLength = tvb_get_ntohs(tvb, offset+2+iPropLength+1);\n                                        if (remain < 2+iPropLength+3+iStringLength)\n                                                break;\n\n                                        return tvb_get_string_enc(wmem_packet_scope(), tvb, offset+2+iPropLength+3, iStringLength, ENC_ASCII);\n                                }\n\n                                itemlen = rtmpt_get_amf_length(tvb, offset+2+iPropLength, pi);\n                                if (itemlen == 0)\n                                        break;\n                                offset += 2+iPropLength+itemlen;\n                                remain -= 2+iPropLength+itemlen;\n                        }\n                }\n        }\n\n        return NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,12 +1,14 @@\n static gchar *\n-rtmpt_get_amf_param(tvbuff_t *tvb, gint offset, gint param, const gchar *prop)\n+rtmpt_get_amf_param(tvbuff_t *tvb, gint offset, proto_item* pi, gint param, const gchar *prop)\n {\n         guint32 remain = tvb_reported_length_remaining(tvb, offset);\n         guint32 itemlen;\n         guint32 iStringLength;\n \n         while (remain > 0 && param > 0) {\n-                itemlen = rtmpt_get_amf_length(tvb, offset);\n+                itemlen = rtmpt_get_amf_length(tvb, offset, pi);\n+                if (itemlen == 0)\n+                        break;\n                 offset += itemlen;\n                 remain -= itemlen;\n                 param--;\n@@ -42,7 +44,9 @@\n                                         return tvb_get_string_enc(wmem_packet_scope(), tvb, offset+2+iPropLength+3, iStringLength, ENC_ASCII);\n                                 }\n \n-                                itemlen = rtmpt_get_amf_length(tvb, offset+2+iPropLength);\n+                                itemlen = rtmpt_get_amf_length(tvb, offset+2+iPropLength, pi);\n+                                if (itemlen == 0)\n+                                        break;\n                                 offset += 2+iPropLength+itemlen;\n                                 remain -= 2+iPropLength+itemlen;\n                         }",
        "diff_line_info": {
            "deleted_lines": [
                "rtmpt_get_amf_param(tvbuff_t *tvb, gint offset, gint param, const gchar *prop)",
                "                itemlen = rtmpt_get_amf_length(tvb, offset);",
                "                                itemlen = rtmpt_get_amf_length(tvb, offset+2+iPropLength);"
            ],
            "added_lines": [
                "rtmpt_get_amf_param(tvbuff_t *tvb, gint offset, proto_item* pi, gint param, const gchar *prop)",
                "                itemlen = rtmpt_get_amf_length(tvb, offset, pi);",
                "                if (itemlen == 0)",
                "                        break;",
                "                                itemlen = rtmpt_get_amf_length(tvb, offset+2+iPropLength, pi);",
                "                                if (itemlen == 0)",
                "                                        break;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0586",
        "func_name": "wireshark/rtmpt_get_amf_txid",
        "description": "Infinite loop in RTMPT protocol dissector in Wireshark 3.6.0 to 3.6.1 and 3.4.0 to 3.4.11 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/24403a9a35cd7fbe5ea6e596b1c6deb9d8633566",
        "commit_title": "rtmpt: limit the number of iterations in rtmpt_get_amf_length().",
        "commit_text": " This prevents a infinite-loop caused by crafted packets.  Fix: #17813. ",
        "func_before": "static guint32\nrtmpt_get_amf_txid(tvbuff_t *tvb, gint offset)\n{\n        guint32 remain = tvb_reported_length_remaining(tvb, offset);\n\n        if (remain > 0) {\n                guint32 itemlen = rtmpt_get_amf_length(tvb, offset);\n                if (remain<itemlen)\n                        return 0;\n                offset += itemlen;\n                remain -= itemlen;\n        }\n        if (remain >= 9) {\n                guint8 iObjType = tvb_get_guint8(tvb, offset);\n                if (iObjType == AMF0_NUMBER) {\n                        return (guint32)tvb_get_ntohieee_double(tvb, offset+1);\n                }\n        }\n\n        return 0;\n}",
        "func": "static guint32\nrtmpt_get_amf_txid(tvbuff_t *tvb, gint offset, proto_item* pi)\n{\n        guint32 remain = tvb_reported_length_remaining(tvb, offset);\n\n        if (remain > 0) {\n                guint32 itemlen = rtmpt_get_amf_length(tvb, offset, pi);\n                if (itemlen == 0 || remain < itemlen)\n                        return 0;\n                offset += itemlen;\n                remain -= itemlen;\n        }\n        if (remain >= 9) {\n                guint8 iObjType = tvb_get_guint8(tvb, offset);\n                if (iObjType == AMF0_NUMBER) {\n                        return (guint32)tvb_get_ntohieee_double(tvb, offset+1);\n                }\n        }\n\n        return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,11 +1,11 @@\n static guint32\n-rtmpt_get_amf_txid(tvbuff_t *tvb, gint offset)\n+rtmpt_get_amf_txid(tvbuff_t *tvb, gint offset, proto_item* pi)\n {\n         guint32 remain = tvb_reported_length_remaining(tvb, offset);\n \n         if (remain > 0) {\n-                guint32 itemlen = rtmpt_get_amf_length(tvb, offset);\n-                if (remain<itemlen)\n+                guint32 itemlen = rtmpt_get_amf_length(tvb, offset, pi);\n+                if (itemlen == 0 || remain < itemlen)\n                         return 0;\n                 offset += itemlen;\n                 remain -= itemlen;",
        "diff_line_info": {
            "deleted_lines": [
                "rtmpt_get_amf_txid(tvbuff_t *tvb, gint offset)",
                "                guint32 itemlen = rtmpt_get_amf_length(tvb, offset);",
                "                if (remain<itemlen)"
            ],
            "added_lines": [
                "rtmpt_get_amf_txid(tvbuff_t *tvb, gint offset, proto_item* pi)",
                "                guint32 itemlen = rtmpt_get_amf_length(tvb, offset, pi);",
                "                if (itemlen == 0 || remain < itemlen)"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0586",
        "func_name": "wireshark/rtmpt_get_packet_desc",
        "description": "Infinite loop in RTMPT protocol dissector in Wireshark 3.6.0 to 3.6.1 and 3.4.0 to 3.4.11 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/24403a9a35cd7fbe5ea6e596b1c6deb9d8633566",
        "commit_title": "rtmpt: limit the number of iterations in rtmpt_get_amf_length().",
        "commit_text": " This prevents a infinite-loop caused by crafted packets.  Fix: #17813. ",
        "func_before": "static gchar *\nrtmpt_get_packet_desc(tvbuff_t *tvb, guint32 offset, guint32 remain, rtmpt_conv_t *rconv, int cdir, rtmpt_packet_t *tp, gint *deschasopcode)\n{\n        if (tp->cmd == RTMPT_TYPE_CHUNK_SIZE || tp->cmd == RTMPT_TYPE_ABORT_MESSAGE ||\n            tp->cmd == RTMPT_TYPE_ACKNOWLEDGEMENT || tp->cmd == RTMPT_TYPE_WINDOW) {\n                if (tp->len >= 4 && remain >= 4) {\n                        *deschasopcode = TRUE;\n                        return wmem_strdup_printf(wmem_packet_scope(), \"%s %d\",\n                                                val_to_str(tp->cmd, rtmpt_opcode_vals, \"Unknown (0x%01x)\"),\n                                                tvb_get_ntohl(tvb, offset));\n                }\n\n        } else if (tp->cmd == RTMPT_TYPE_PEER_BANDWIDTH) {\n                if (tp->len >= 5 && remain >= 5) {\n                        *deschasopcode = TRUE;\n                        return wmem_strdup_printf(wmem_packet_scope(), \"%s %d,%s\",\n                                                val_to_str(tp->cmd, rtmpt_opcode_vals, \"Unknown (0x%01x)\"),\n                                                tvb_get_ntohl(tvb, offset),\n                                                val_to_str(tvb_get_guint8(tvb, offset+4), rtmpt_limit_vals, \"Unknown (%d)\"));\n                }\n\n        } else if (tp->cmd == RTMPT_TYPE_UCM) {\n                guint16 iUCM = -1;\n                const gchar *sFunc;\n                const gchar *sParam = \"\";\n\n                if (tp->len < 2 || remain < 2)\n                        return NULL;\n\n                iUCM = tvb_get_ntohs(tvb, offset);\n                sFunc = try_val_to_str(iUCM, rtmpt_ucm_vals);\n                if (sFunc == NULL) {\n                        *deschasopcode = TRUE;\n                        sFunc = wmem_strdup_printf(wmem_packet_scope(), \"User Control Message 0x%01x\", iUCM);\n                }\n\n                if (iUCM == RTMPT_UCM_STREAM_BEGIN || iUCM == RTMPT_UCM_STREAM_EOF ||\n                    iUCM == RTMPT_UCM_STREAM_DRY || iUCM == RTMPT_UCM_STREAM_ISRECORDED) {\n                        if (tp->len >= 6 && remain >= 6) {\n                                sParam = wmem_strdup_printf(wmem_packet_scope(), \" %d\", tvb_get_ntohl(tvb, offset+2));\n                        }\n                } else if (iUCM == RTMPT_UCM_SET_BUFFER) {\n                        if (tp->len >= 10 && remain >= 10) {\n                                sParam = wmem_strdup_printf(wmem_packet_scope(), \" %d,%dms\",\n                                                          tvb_get_ntohl(tvb, offset+2),\n                                                          tvb_get_ntohl(tvb, offset+6));\n                        }\n                }\n\n                return wmem_strdup_printf(wmem_packet_scope(), \"%s%s\", sFunc, sParam);\n\n        } else if (tp->cmd == RTMPT_TYPE_COMMAND_AMF0 || tp->cmd == RTMPT_TYPE_COMMAND_AMF3 ||\n                   tp->cmd == RTMPT_TYPE_DATA_AMF0 || tp->cmd == RTMPT_TYPE_DATA_AMF3) {\n                guint32 slen = 0;\n                guint32 soff = 0;\n                gchar *sFunc = NULL;\n                gchar *sParam = NULL;\n\n                if (tp->cmd == RTMPT_TYPE_COMMAND_AMF3 || tp->cmd == RTMPT_TYPE_DATA_AMF3) {\n                        soff = 1;\n                }\n                if (tp->len >= 3+soff && remain >= 3+soff) {\n                        slen = tvb_get_ntohs(tvb, offset+1+soff);\n                }\n                if (slen > 0) {\n                        sFunc = tvb_get_string_enc(wmem_packet_scope(), tvb, offset+3+soff, slen, ENC_ASCII);\n                        RTMPT_DEBUG(\"got function call '%s'\\n\", sFunc);\n\n                        if (strcmp(sFunc, \"connect\") == 0) {\n                                sParam = rtmpt_get_amf_param(tvb, offset+soff, 2, \"app\");\n                        } else if (strcmp(sFunc, \"play\") == 0) {\n                                sParam = rtmpt_get_amf_param(tvb, offset+soff, 3, NULL);\n                        } else if (strcmp(sFunc, \"play2\") == 0) {\n                                sParam = rtmpt_get_amf_param(tvb, offset+soff, 3, \"streamName\");\n                        } else if (strcmp(sFunc, \"releaseStream\") == 0) {\n                                sParam = rtmpt_get_amf_param(tvb, offset+soff, 3, NULL);\n                        } else if (strcmp(sFunc, \"FCPublish\") == 0) {\n                                sParam = rtmpt_get_amf_param(tvb, offset+soff, 3, NULL);\n                        } else if (strcmp(sFunc, \"publish\") == 0) {\n                                sParam = rtmpt_get_amf_param(tvb, offset+soff, 3, NULL);\n                        } else if (strcmp(sFunc, \"onStatus\") == 0) {\n                                if (tp->cmd == RTMPT_TYPE_COMMAND_AMF0 || tp->cmd == RTMPT_TYPE_COMMAND_AMF3) {\n                                        sParam = rtmpt_get_amf_param(tvb, offset+soff, 3, \"code\");\n                                } else {\n                                        sParam = rtmpt_get_amf_param(tvb, offset+soff, 1, \"code\");\n                                }\n                        } else if (strcmp(sFunc, \"onPlayStatus\") == 0) {\n                                sParam = rtmpt_get_amf_param(tvb, offset+soff, 1, \"code\");\n                        } else if (strcmp(sFunc, \"_result\") == 0) {\n                                sParam = rtmpt_get_amf_param(tvb, offset+soff, 3, \"code\");\n                                tp->isresponse = TRUE;\n                        } else if (strcmp(sFunc, \"_error\") == 0) {\n                                sParam = rtmpt_get_amf_param(tvb, offset+soff, 3, \"code\");\n                                tp->isresponse = TRUE;\n                        }\n\n                        if (tp->txid != 0 && tp->otherframe == 0) {\n                                tp->otherframe = GPOINTER_TO_INT(wmem_tree_lookup32(rconv->txids[cdir^1], tp->txid));\n                                if (tp->otherframe) {\n                                        RTMPT_DEBUG(\"got otherframe=%d\\n\", tp->otherframe);\n                                }\n                        }\n                }\n\n                if (sFunc) {\n                        if (sParam) {\n                                return wmem_strdup_printf(wmem_packet_scope(), \"%s('%s')\", sFunc, sParam);\n                        } else {\n                                return wmem_strdup_printf(wmem_packet_scope(), \"%s()\", sFunc);\n                        }\n                }\n        }\n\n        return NULL;\n}",
        "func": "static gchar *\nrtmpt_get_packet_desc(tvbuff_t *tvb, guint32 offset, proto_item* pi, guint32 remain, rtmpt_conv_t *rconv, int cdir,\n        rtmpt_packet_t *tp, gint *deschasopcode)\n{\n        if (tp->cmd == RTMPT_TYPE_CHUNK_SIZE || tp->cmd == RTMPT_TYPE_ABORT_MESSAGE ||\n            tp->cmd == RTMPT_TYPE_ACKNOWLEDGEMENT || tp->cmd == RTMPT_TYPE_WINDOW) {\n                if (tp->len >= 4 && remain >= 4) {\n                        *deschasopcode = TRUE;\n                        return wmem_strdup_printf(wmem_packet_scope(), \"%s %d\",\n                                                val_to_str(tp->cmd, rtmpt_opcode_vals, \"Unknown (0x%01x)\"),\n                                                tvb_get_ntohl(tvb, offset));\n                }\n\n        } else if (tp->cmd == RTMPT_TYPE_PEER_BANDWIDTH) {\n                if (tp->len >= 5 && remain >= 5) {\n                        *deschasopcode = TRUE;\n                        return wmem_strdup_printf(wmem_packet_scope(), \"%s %d,%s\",\n                                                val_to_str(tp->cmd, rtmpt_opcode_vals, \"Unknown (0x%01x)\"),\n                                                tvb_get_ntohl(tvb, offset),\n                                                val_to_str(tvb_get_guint8(tvb, offset+4), rtmpt_limit_vals, \"Unknown (%d)\"));\n                }\n\n        } else if (tp->cmd == RTMPT_TYPE_UCM) {\n                guint16 iUCM = -1;\n                const gchar *sFunc;\n                const gchar *sParam = \"\";\n\n                if (tp->len < 2 || remain < 2)\n                        return NULL;\n\n                iUCM = tvb_get_ntohs(tvb, offset);\n                sFunc = try_val_to_str(iUCM, rtmpt_ucm_vals);\n                if (sFunc == NULL) {\n                        *deschasopcode = TRUE;\n                        sFunc = wmem_strdup_printf(wmem_packet_scope(), \"User Control Message 0x%01x\", iUCM);\n                }\n\n                if (iUCM == RTMPT_UCM_STREAM_BEGIN || iUCM == RTMPT_UCM_STREAM_EOF ||\n                    iUCM == RTMPT_UCM_STREAM_DRY || iUCM == RTMPT_UCM_STREAM_ISRECORDED) {\n                        if (tp->len >= 6 && remain >= 6) {\n                                sParam = wmem_strdup_printf(wmem_packet_scope(), \" %d\", tvb_get_ntohl(tvb, offset+2));\n                        }\n                } else if (iUCM == RTMPT_UCM_SET_BUFFER) {\n                        if (tp->len >= 10 && remain >= 10) {\n                                sParam = wmem_strdup_printf(wmem_packet_scope(), \" %d,%dms\",\n                                                          tvb_get_ntohl(tvb, offset+2),\n                                                          tvb_get_ntohl(tvb, offset+6));\n                        }\n                }\n\n                return wmem_strdup_printf(wmem_packet_scope(), \"%s%s\", sFunc, sParam);\n\n        } else if (tp->cmd == RTMPT_TYPE_COMMAND_AMF0 || tp->cmd == RTMPT_TYPE_COMMAND_AMF3 ||\n                   tp->cmd == RTMPT_TYPE_DATA_AMF0 || tp->cmd == RTMPT_TYPE_DATA_AMF3) {\n                guint32 slen = 0;\n                guint32 soff = 0;\n                gchar *sFunc = NULL;\n                gchar *sParam = NULL;\n\n                if (tp->cmd == RTMPT_TYPE_COMMAND_AMF3 || tp->cmd == RTMPT_TYPE_DATA_AMF3) {\n                        soff = 1;\n                }\n                if (tp->len >= 3+soff && remain >= 3+soff) {\n                        slen = tvb_get_ntohs(tvb, offset+1+soff);\n                }\n                if (slen > 0) {\n                        sFunc = tvb_get_string_enc(wmem_packet_scope(), tvb, offset+3+soff, slen, ENC_ASCII);\n                        RTMPT_DEBUG(\"got function call '%s'\\n\", sFunc);\n\n                        if (strcmp(sFunc, \"connect\") == 0) {\n                                sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 2, \"app\");\n                        } else if (strcmp(sFunc, \"play\") == 0) {\n                                sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 3, NULL);\n                        } else if (strcmp(sFunc, \"play2\") == 0) {\n                                sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 3, \"streamName\");\n                        } else if (strcmp(sFunc, \"releaseStream\") == 0) {\n                                sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 3, NULL);\n                        } else if (strcmp(sFunc, \"FCPublish\") == 0) {\n                                sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 3, NULL);\n                        } else if (strcmp(sFunc, \"publish\") == 0) {\n                                sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 3, NULL);\n                        } else if (strcmp(sFunc, \"onStatus\") == 0) {\n                                if (tp->cmd == RTMPT_TYPE_COMMAND_AMF0 || tp->cmd == RTMPT_TYPE_COMMAND_AMF3) {\n                                        sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 3, \"code\");\n                                } else {\n                                        sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 1, \"code\");\n                                }\n                        } else if (strcmp(sFunc, \"onPlayStatus\") == 0) {\n                                sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 1, \"code\");\n                        } else if (strcmp(sFunc, \"_result\") == 0) {\n                                sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 3, \"code\");\n                                tp->isresponse = TRUE;\n                        } else if (strcmp(sFunc, \"_error\") == 0) {\n                                sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 3, \"code\");\n                                tp->isresponse = TRUE;\n                        }\n\n                        if (tp->txid != 0 && tp->otherframe == 0) {\n                                tp->otherframe = GPOINTER_TO_INT(wmem_tree_lookup32(rconv->txids[cdir^1], tp->txid));\n                                if (tp->otherframe) {\n                                        RTMPT_DEBUG(\"got otherframe=%d\\n\", tp->otherframe);\n                                }\n                        }\n                }\n\n                if (sFunc) {\n                        if (sParam) {\n                                return wmem_strdup_printf(wmem_packet_scope(), \"%s('%s')\", sFunc, sParam);\n                        } else {\n                                return wmem_strdup_printf(wmem_packet_scope(), \"%s()\", sFunc);\n                        }\n                }\n        }\n\n        return NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n static gchar *\n-rtmpt_get_packet_desc(tvbuff_t *tvb, guint32 offset, guint32 remain, rtmpt_conv_t *rconv, int cdir, rtmpt_packet_t *tp, gint *deschasopcode)\n+rtmpt_get_packet_desc(tvbuff_t *tvb, guint32 offset, proto_item* pi, guint32 remain, rtmpt_conv_t *rconv, int cdir,\n+        rtmpt_packet_t *tp, gint *deschasopcode)\n {\n         if (tp->cmd == RTMPT_TYPE_CHUNK_SIZE || tp->cmd == RTMPT_TYPE_ABORT_MESSAGE ||\n             tp->cmd == RTMPT_TYPE_ACKNOWLEDGEMENT || tp->cmd == RTMPT_TYPE_WINDOW) {\n@@ -67,30 +68,30 @@\n                         RTMPT_DEBUG(\"got function call '%s'\\n\", sFunc);\n \n                         if (strcmp(sFunc, \"connect\") == 0) {\n-                                sParam = rtmpt_get_amf_param(tvb, offset+soff, 2, \"app\");\n+                                sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 2, \"app\");\n                         } else if (strcmp(sFunc, \"play\") == 0) {\n-                                sParam = rtmpt_get_amf_param(tvb, offset+soff, 3, NULL);\n+                                sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 3, NULL);\n                         } else if (strcmp(sFunc, \"play2\") == 0) {\n-                                sParam = rtmpt_get_amf_param(tvb, offset+soff, 3, \"streamName\");\n+                                sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 3, \"streamName\");\n                         } else if (strcmp(sFunc, \"releaseStream\") == 0) {\n-                                sParam = rtmpt_get_amf_param(tvb, offset+soff, 3, NULL);\n+                                sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 3, NULL);\n                         } else if (strcmp(sFunc, \"FCPublish\") == 0) {\n-                                sParam = rtmpt_get_amf_param(tvb, offset+soff, 3, NULL);\n+                                sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 3, NULL);\n                         } else if (strcmp(sFunc, \"publish\") == 0) {\n-                                sParam = rtmpt_get_amf_param(tvb, offset+soff, 3, NULL);\n+                                sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 3, NULL);\n                         } else if (strcmp(sFunc, \"onStatus\") == 0) {\n                                 if (tp->cmd == RTMPT_TYPE_COMMAND_AMF0 || tp->cmd == RTMPT_TYPE_COMMAND_AMF3) {\n-                                        sParam = rtmpt_get_amf_param(tvb, offset+soff, 3, \"code\");\n+                                        sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 3, \"code\");\n                                 } else {\n-                                        sParam = rtmpt_get_amf_param(tvb, offset+soff, 1, \"code\");\n+                                        sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 1, \"code\");\n                                 }\n                         } else if (strcmp(sFunc, \"onPlayStatus\") == 0) {\n-                                sParam = rtmpt_get_amf_param(tvb, offset+soff, 1, \"code\");\n+                                sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 1, \"code\");\n                         } else if (strcmp(sFunc, \"_result\") == 0) {\n-                                sParam = rtmpt_get_amf_param(tvb, offset+soff, 3, \"code\");\n+                                sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 3, \"code\");\n                                 tp->isresponse = TRUE;\n                         } else if (strcmp(sFunc, \"_error\") == 0) {\n-                                sParam = rtmpt_get_amf_param(tvb, offset+soff, 3, \"code\");\n+                                sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 3, \"code\");\n                                 tp->isresponse = TRUE;\n                         }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "rtmpt_get_packet_desc(tvbuff_t *tvb, guint32 offset, guint32 remain, rtmpt_conv_t *rconv, int cdir, rtmpt_packet_t *tp, gint *deschasopcode)",
                "                                sParam = rtmpt_get_amf_param(tvb, offset+soff, 2, \"app\");",
                "                                sParam = rtmpt_get_amf_param(tvb, offset+soff, 3, NULL);",
                "                                sParam = rtmpt_get_amf_param(tvb, offset+soff, 3, \"streamName\");",
                "                                sParam = rtmpt_get_amf_param(tvb, offset+soff, 3, NULL);",
                "                                sParam = rtmpt_get_amf_param(tvb, offset+soff, 3, NULL);",
                "                                sParam = rtmpt_get_amf_param(tvb, offset+soff, 3, NULL);",
                "                                        sParam = rtmpt_get_amf_param(tvb, offset+soff, 3, \"code\");",
                "                                        sParam = rtmpt_get_amf_param(tvb, offset+soff, 1, \"code\");",
                "                                sParam = rtmpt_get_amf_param(tvb, offset+soff, 1, \"code\");",
                "                                sParam = rtmpt_get_amf_param(tvb, offset+soff, 3, \"code\");",
                "                                sParam = rtmpt_get_amf_param(tvb, offset+soff, 3, \"code\");"
            ],
            "added_lines": [
                "rtmpt_get_packet_desc(tvbuff_t *tvb, guint32 offset, proto_item* pi, guint32 remain, rtmpt_conv_t *rconv, int cdir,",
                "        rtmpt_packet_t *tp, gint *deschasopcode)",
                "                                sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 2, \"app\");",
                "                                sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 3, NULL);",
                "                                sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 3, \"streamName\");",
                "                                sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 3, NULL);",
                "                                sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 3, NULL);",
                "                                sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 3, NULL);",
                "                                        sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 3, \"code\");",
                "                                        sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 1, \"code\");",
                "                                sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 1, \"code\");",
                "                                sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 3, \"code\");",
                "                                sParam = rtmpt_get_amf_param(tvb, offset+soff, pi, 3, \"code\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0586",
        "func_name": "wireshark/dissect_rtmpt",
        "description": "Infinite loop in RTMPT protocol dissector in Wireshark 3.6.0 to 3.6.1 and 3.4.0 to 3.4.11 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/24403a9a35cd7fbe5ea6e596b1c6deb9d8633566",
        "commit_title": "rtmpt: limit the number of iterations in rtmpt_get_amf_length().",
        "commit_text": " This prevents a infinite-loop caused by crafted packets.  Fix: #17813. ",
        "func_before": "static void\ndissect_rtmpt(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, rtmpt_conv_t *rconv, int cdir, rtmpt_packet_t *tp)\n{\n        gint        offset         = 0;\n\n        gchar      *sDesc          = NULL;\n        gint        deschasopcode  = FALSE;\n        gboolean    haveETS        = FALSE;\n        guint32     iBodyOffset    = 0;\n        guint32     iBodyRemain    = 0;\n\n        col_set_str(pinfo->cinfo, COL_PROTOCOL, \"RTMP\");\n\n        RTMPT_DEBUG(\"Dissect: frame=%u visited=%d len=%d tree=%p\\n\",\n                    pinfo->num, pinfo->fd->visited,\n                    tvb_reported_length_remaining(tvb, offset), tree);\n\n        /* Clear any previous data in Info column (RTMP packets are protected by a \"fence\") */\n        col_clear(pinfo->cinfo, COL_INFO);\n\n        if (tvb_reported_length_remaining(tvb, offset) < 1) return;\n\n        if (tp->id <= RTMPT_ID_MAX) {\n                if (tp->fmt < 3\n                    && tvb_reported_length_remaining(tvb, offset) >= tp->bhlen+3\n                    && tvb_get_ntoh24(tvb, offset+tp->bhlen) == 0xffffff) {\n                        haveETS = TRUE;\n                }\n\n                iBodyOffset = offset + tp->bhlen + tp->mhlen;\n                iBodyRemain = tvb_reported_length_remaining(tvb, iBodyOffset);\n\n                if (tp->cmd == RTMPT_TYPE_CHUNK_SIZE && tp->len >= 4 && iBodyRemain >= 4) {\n                        guint32 newchunksize = tvb_get_ntohl(tvb, iBodyOffset);\n                        if (newchunksize < rtmpt_max_packet_size) {\n                                wmem_tree_insert32(rconv->chunksize[cdir], tp->lastseq, GINT_TO_POINTER(newchunksize));\n                        }\n                }\n\n                if (!PINFO_FD_VISITED(pinfo)) {\n                        if (tp->cmd == RTMPT_TYPE_COMMAND_AMF0 || tp->cmd == RTMPT_TYPE_COMMAND_AMF3 ||\n                            tp->cmd == RTMPT_TYPE_DATA_AMF0 || tp->cmd == RTMPT_TYPE_DATA_AMF3) {\n                                guint32 soff = 0;\n                                if (tp->cmd == RTMPT_TYPE_COMMAND_AMF3 || tp->cmd == RTMPT_TYPE_DATA_AMF3) {\n                                        soff = 1;\n                                }\n                                tp->txid = rtmpt_get_amf_txid(tvb, iBodyOffset+soff);\n                                if (tp->txid != 0) {\n                                        RTMPT_DEBUG(\"got txid=%d\\n\", tp->txid);\n                                        wmem_tree_insert32(rconv->txids[cdir], tp->txid, GINT_TO_POINTER(pinfo->num));\n                                }\n                        }\n                }\n        }\n\n        if (tp->id <= RTMPT_ID_MAX)\n        {\n                sDesc = rtmpt_get_packet_desc(tvb, iBodyOffset, iBodyRemain, rconv, cdir, tp, &deschasopcode);\n        }\n\n        if (tp->id>RTMPT_ID_MAX) {\n                col_append_sep_str(pinfo->cinfo, COL_INFO, \"|\",\n                                val_to_str(tp->id, rtmpt_handshake_vals, \"Unknown (0x%01x)\"));\n                col_set_fence(pinfo->cinfo, COL_INFO);\n        } else if (sDesc) {\n                col_append_sep_str(pinfo->cinfo, COL_INFO, \"|\", sDesc);\n                col_set_fence(pinfo->cinfo, COL_INFO);\n        } else {\n                col_append_sep_str(pinfo->cinfo, COL_INFO, \"|\",\n                                val_to_str(tp->cmd, rtmpt_opcode_vals, \"Unknown (0x%01x)\"));\n                col_set_fence(pinfo->cinfo, COL_INFO);\n        }\n\n        if (tree)\n        {\n                proto_tree *rtmpt_tree     = NULL;\n                proto_tree *rtmptroot_tree = NULL;\n                proto_item *ti;\n                ti = proto_tree_add_item(tree, proto_rtmpt, tvb, offset, -1, ENC_NA);\n\n                if (tp->id > RTMPT_ID_MAX) {\n                        /* Dissect handshake */\n                        proto_item_append_text(ti, \" (%s)\",\n                                               val_to_str(tp->id, rtmpt_handshake_vals, \"Unknown (0x%01x)\"));\n                        rtmptroot_tree = proto_item_add_subtree(ti, ett_rtmpt);\n                        rtmpt_tree = proto_tree_add_subtree(rtmptroot_tree, tvb, offset, -1, ett_rtmpt_handshake, NULL,\n                                                 val_to_str(tp->id, rtmpt_handshake_vals, \"Unknown (0x%01x)\"));\n\n                        if (tp->id == RTMPT_TYPE_HANDSHAKE_1)\n                        {\n                                proto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_c0, tvb, 0, 1, ENC_NA);\n                                proto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_c1, tvb, 1, 1536, ENC_NA);\n                        }\n                        else if (tp->id == RTMPT_TYPE_HANDSHAKE_2)\n                        {\n                                proto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_s0, tvb, 0, 1, ENC_NA);\n                                proto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_s1, tvb, 1, 1536, ENC_NA);\n                                proto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_s2, tvb, 1537, 1536, ENC_NA);\n                        }\n                        else if (tp->id == RTMPT_TYPE_HANDSHAKE_3)\n                        {\n                                proto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_c2, tvb, 0, 1536, ENC_NA);\n                        }\n\n                        return;\n                }\n\n                if (sDesc && deschasopcode) {\n                        proto_item_append_text(ti, \" (%s)\", sDesc);\n                } else if (sDesc) {\n                        proto_item_append_text(ti, \" (%s %s)\",\n                                               val_to_str(tp->cmd, rtmpt_opcode_vals, \"Unknown (0x%01x)\"), sDesc);\n                } else {\n                        proto_item_append_text(ti, \" (%s)\",\n                                               val_to_str(tp->cmd, rtmpt_opcode_vals, \"Unknown (0x%01x)\"));\n                }\n                rtmptroot_tree = proto_item_add_subtree(ti, ett_rtmpt);\n\n                /* Function call/response matching */\n                if (tp->otherframe != 0) {\n                        proto_tree_add_uint(rtmptroot_tree,\n                                            tp->isresponse ? hf_rtmpt_function_response : hf_rtmpt_function_call,\n                                            tvb, offset, tp->bhlen+tp->mhlen+tp->len,\n                                            tp->otherframe);\n                }\n\n                /* Dissect header fields */\n                rtmpt_tree = proto_tree_add_subtree(rtmptroot_tree, tvb, offset, tp->bhlen+tp->mhlen, ett_rtmpt_header, NULL, RTMPT_TEXT_RTMP_HEADER);\n/*                proto_item_append_text(ti, \" (%s)\", val_to_str(tp->cmd, rtmpt_opcode_vals, \"Unknown (0x%01x)\")); */\n\n                if (tp->fmt <= 3) proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_format, tvb, offset + 0, 1, ENC_BIG_ENDIAN);\n                if (tp->fmt <= 3) proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_csid, tvb, offset + 0, tp->bhlen, ENC_BIG_ENDIAN);\n                if (tp->fmt <= 2) {\n                        if (tp->fmt > 0) {\n                                proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_timestamp_delta, tvb, offset + tp->bhlen, 3, ENC_BIG_ENDIAN);\n                        } else {\n                                proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_timestamp, tvb, offset + tp->bhlen, 3, ENC_BIG_ENDIAN);\n                        }\n                        if (haveETS) {\n                                proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_ets, tvb, offset + tp->bhlen + tp->mhlen - 4, 4, ENC_BIG_ENDIAN);\n                        }\n                }\n                if ((tp->fmt>0 && !haveETS) || tp->fmt == 3) {\n                        proto_tree_add_uint_format_value(rtmpt_tree, hf_rtmpt_header_timestamp, tvb, offset + tp->bhlen, 0, tp->ts, \"%d (calculated)\", tp->ts);\n                }\n                if (tp->fmt <= 1) proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_body_size, tvb, offset + tp->bhlen + 3, 3, ENC_BIG_ENDIAN);\n                if (tp->fmt <= 1) proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_typeid, tvb, offset + tp->bhlen + 6, 1, ENC_BIG_ENDIAN);\n                if (tp->fmt <= 0) proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_streamid, tvb, offset + tp->bhlen + 7, 4, ENC_LITTLE_ENDIAN);\n\n                /* Dissect body */\n                if (tp->len == 0) return;\n                offset = iBodyOffset;\n\n                rtmpt_tree = proto_tree_add_subtree(rtmptroot_tree, tvb, offset, -1, ett_rtmpt_body, NULL, RTMPT_TEXT_RTMP_BODY);\n\n                switch (tp->cmd) {\n                case RTMPT_TYPE_CHUNK_SIZE:\n                case RTMPT_TYPE_ABORT_MESSAGE:\n                case RTMPT_TYPE_ACKNOWLEDGEMENT:\n                case RTMPT_TYPE_UCM:\n                case RTMPT_TYPE_WINDOW:\n                case RTMPT_TYPE_PEER_BANDWIDTH:\n                        dissect_rtmpt_body_scm(tvb, offset, rtmpt_tree, tp->cmd);\n                        break;\n                case RTMPT_TYPE_COMMAND_AMF0:\n                case RTMPT_TYPE_DATA_AMF0:\n                        dissect_rtmpt_body_command(tvb, offset, rtmpt_tree, FALSE);\n                        break;\n                case RTMPT_TYPE_COMMAND_AMF3:\n                case RTMPT_TYPE_DATA_AMF3:\n                        dissect_rtmpt_body_command(tvb, offset, rtmpt_tree, TRUE);\n                        break;\n                case RTMPT_TYPE_AUDIO_DATA:\n                        dissect_rtmpt_body_audio(tvb, offset, rtmpt_tree);\n                        break;\n                case RTMPT_TYPE_VIDEO_DATA:\n                        dissect_rtmpt_body_video(tvb, offset, rtmpt_tree);\n                        break;\n                case RTMPT_TYPE_AGGREGATE:\n                        dissect_rtmpt_body_aggregate(tvb, offset, rtmpt_tree);\n                        break;\n                }\n        }\n}",
        "func": "static void\ndissect_rtmpt(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, rtmpt_conv_t *rconv, int cdir, rtmpt_packet_t *tp)\n{\n        gint        offset         = 0;\n\n        gchar      *sDesc          = NULL;\n        gint        deschasopcode  = FALSE;\n        gboolean    haveETS        = FALSE;\n        guint32     iBodyOffset    = 0;\n        guint32     iBodyRemain    = 0;\n\n        col_set_str(pinfo->cinfo, COL_PROTOCOL, \"RTMP\");\n\n        RTMPT_DEBUG(\"Dissect: frame=%u visited=%d len=%d tree=%p\\n\",\n                    pinfo->num, pinfo->fd->visited,\n                    tvb_reported_length_remaining(tvb, offset), tree);\n\n        /* Clear any previous data in Info column (RTMP packets are protected by a \"fence\") */\n        col_clear(pinfo->cinfo, COL_INFO);\n\n        if (tvb_reported_length_remaining(tvb, offset) < 1) return;\n\n        if (tp->id <= RTMPT_ID_MAX) {\n                if (tp->fmt < 3\n                    && tvb_reported_length_remaining(tvb, offset) >= tp->bhlen+3\n                    && tvb_get_ntoh24(tvb, offset+tp->bhlen) == 0xffffff) {\n                        haveETS = TRUE;\n                }\n\n                iBodyOffset = offset + tp->bhlen + tp->mhlen;\n                iBodyRemain = tvb_reported_length_remaining(tvb, iBodyOffset);\n\n                if (tp->cmd == RTMPT_TYPE_CHUNK_SIZE && tp->len >= 4 && iBodyRemain >= 4) {\n                        guint32 newchunksize = tvb_get_ntohl(tvb, iBodyOffset);\n                        if (newchunksize < rtmpt_max_packet_size) {\n                                wmem_tree_insert32(rconv->chunksize[cdir], tp->lastseq, GINT_TO_POINTER(newchunksize));\n                        }\n                }\n\n                if (tp->cmd == RTMPT_TYPE_COMMAND_AMF0 || tp->cmd == RTMPT_TYPE_COMMAND_AMF3 ||\n                    tp->cmd == RTMPT_TYPE_DATA_AMF0 || tp->cmd == RTMPT_TYPE_DATA_AMF3) {\n                        guint32 soff = 0;\n                        if (tp->cmd == RTMPT_TYPE_COMMAND_AMF3 || tp->cmd == RTMPT_TYPE_DATA_AMF3) {\n                                soff = 1;\n                        }\n                        tp->txid = rtmpt_get_amf_txid(tvb, iBodyOffset+soff, tree);\n                        if (tp->txid != 0 && !PINFO_FD_VISITED(pinfo)) {\n                                RTMPT_DEBUG(\"got txid=%d\\n\", tp->txid);\n                                wmem_tree_insert32(rconv->txids[cdir], tp->txid, GINT_TO_POINTER(pinfo->num));\n                        }\n                }\n        }\n\n        if (tp->id <= RTMPT_ID_MAX)\n        {\n                sDesc = rtmpt_get_packet_desc(tvb, iBodyOffset, tree, iBodyRemain, rconv, cdir, tp, &deschasopcode);\n        }\n\n        if (tp->id>RTMPT_ID_MAX) {\n                col_append_sep_str(pinfo->cinfo, COL_INFO, \"|\",\n                                val_to_str(tp->id, rtmpt_handshake_vals, \"Unknown (0x%01x)\"));\n                col_set_fence(pinfo->cinfo, COL_INFO);\n        } else if (sDesc) {\n                col_append_sep_str(pinfo->cinfo, COL_INFO, \"|\", sDesc);\n                col_set_fence(pinfo->cinfo, COL_INFO);\n        } else {\n                col_append_sep_str(pinfo->cinfo, COL_INFO, \"|\",\n                                val_to_str(tp->cmd, rtmpt_opcode_vals, \"Unknown (0x%01x)\"));\n                col_set_fence(pinfo->cinfo, COL_INFO);\n        }\n\n        if (tree)\n        {\n                proto_tree *rtmpt_tree     = NULL;\n                proto_tree *rtmptroot_tree = NULL;\n                proto_item *ti;\n                ti = proto_tree_add_item(tree, proto_rtmpt, tvb, offset, -1, ENC_NA);\n\n                if (tp->id > RTMPT_ID_MAX) {\n                        /* Dissect handshake */\n                        proto_item_append_text(ti, \" (%s)\",\n                                               val_to_str(tp->id, rtmpt_handshake_vals, \"Unknown (0x%01x)\"));\n                        rtmptroot_tree = proto_item_add_subtree(ti, ett_rtmpt);\n                        rtmpt_tree = proto_tree_add_subtree(rtmptroot_tree, tvb, offset, -1, ett_rtmpt_handshake, NULL,\n                                                 val_to_str(tp->id, rtmpt_handshake_vals, \"Unknown (0x%01x)\"));\n\n                        if (tp->id == RTMPT_TYPE_HANDSHAKE_1)\n                        {\n                                proto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_c0, tvb, 0, 1, ENC_NA);\n                                proto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_c1, tvb, 1, 1536, ENC_NA);\n                        }\n                        else if (tp->id == RTMPT_TYPE_HANDSHAKE_2)\n                        {\n                                proto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_s0, tvb, 0, 1, ENC_NA);\n                                proto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_s1, tvb, 1, 1536, ENC_NA);\n                                proto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_s2, tvb, 1537, 1536, ENC_NA);\n                        }\n                        else if (tp->id == RTMPT_TYPE_HANDSHAKE_3)\n                        {\n                                proto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_c2, tvb, 0, 1536, ENC_NA);\n                        }\n\n                        return;\n                }\n\n                if (sDesc && deschasopcode) {\n                        proto_item_append_text(ti, \" (%s)\", sDesc);\n                } else if (sDesc) {\n                        proto_item_append_text(ti, \" (%s %s)\",\n                                               val_to_str(tp->cmd, rtmpt_opcode_vals, \"Unknown (0x%01x)\"), sDesc);\n                } else {\n                        proto_item_append_text(ti, \" (%s)\",\n                                               val_to_str(tp->cmd, rtmpt_opcode_vals, \"Unknown (0x%01x)\"));\n                }\n                rtmptroot_tree = proto_item_add_subtree(ti, ett_rtmpt);\n\n                /* Function call/response matching */\n                if (tp->otherframe != 0) {\n                        proto_tree_add_uint(rtmptroot_tree,\n                                            tp->isresponse ? hf_rtmpt_function_response : hf_rtmpt_function_call,\n                                            tvb, offset, tp->bhlen+tp->mhlen+tp->len,\n                                            tp->otherframe);\n                }\n\n                /* Dissect header fields */\n                rtmpt_tree = proto_tree_add_subtree(rtmptroot_tree, tvb, offset, tp->bhlen+tp->mhlen, ett_rtmpt_header, NULL, RTMPT_TEXT_RTMP_HEADER);\n/*                proto_item_append_text(ti, \" (%s)\", val_to_str(tp->cmd, rtmpt_opcode_vals, \"Unknown (0x%01x)\")); */\n\n                if (tp->fmt <= 3) proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_format, tvb, offset + 0, 1, ENC_BIG_ENDIAN);\n                if (tp->fmt <= 3) proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_csid, tvb, offset + 0, tp->bhlen, ENC_BIG_ENDIAN);\n                if (tp->fmt <= 2) {\n                        if (tp->fmt > 0) {\n                                proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_timestamp_delta, tvb, offset + tp->bhlen, 3, ENC_BIG_ENDIAN);\n                        } else {\n                                proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_timestamp, tvb, offset + tp->bhlen, 3, ENC_BIG_ENDIAN);\n                        }\n                        if (haveETS) {\n                                proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_ets, tvb, offset + tp->bhlen + tp->mhlen - 4, 4, ENC_BIG_ENDIAN);\n                        }\n                }\n                if ((tp->fmt>0 && !haveETS) || tp->fmt == 3) {\n                        proto_tree_add_uint_format_value(rtmpt_tree, hf_rtmpt_header_timestamp, tvb, offset + tp->bhlen, 0, tp->ts, \"%d (calculated)\", tp->ts);\n                }\n                if (tp->fmt <= 1) proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_body_size, tvb, offset + tp->bhlen + 3, 3, ENC_BIG_ENDIAN);\n                if (tp->fmt <= 1) proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_typeid, tvb, offset + tp->bhlen + 6, 1, ENC_BIG_ENDIAN);\n                if (tp->fmt <= 0) proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_streamid, tvb, offset + tp->bhlen + 7, 4, ENC_LITTLE_ENDIAN);\n\n                /* Dissect body */\n                if (tp->len == 0) return;\n                offset = iBodyOffset;\n\n                rtmpt_tree = proto_tree_add_subtree(rtmptroot_tree, tvb, offset, -1, ett_rtmpt_body, NULL, RTMPT_TEXT_RTMP_BODY);\n\n                switch (tp->cmd) {\n                case RTMPT_TYPE_CHUNK_SIZE:\n                case RTMPT_TYPE_ABORT_MESSAGE:\n                case RTMPT_TYPE_ACKNOWLEDGEMENT:\n                case RTMPT_TYPE_UCM:\n                case RTMPT_TYPE_WINDOW:\n                case RTMPT_TYPE_PEER_BANDWIDTH:\n                        dissect_rtmpt_body_scm(tvb, offset, rtmpt_tree, tp->cmd);\n                        break;\n                case RTMPT_TYPE_COMMAND_AMF0:\n                case RTMPT_TYPE_DATA_AMF0:\n                        dissect_rtmpt_body_command(tvb, offset, rtmpt_tree, FALSE);\n                        break;\n                case RTMPT_TYPE_COMMAND_AMF3:\n                case RTMPT_TYPE_DATA_AMF3:\n                        dissect_rtmpt_body_command(tvb, offset, rtmpt_tree, TRUE);\n                        break;\n                case RTMPT_TYPE_AUDIO_DATA:\n                        dissect_rtmpt_body_audio(tvb, offset, rtmpt_tree);\n                        break;\n                case RTMPT_TYPE_VIDEO_DATA:\n                        dissect_rtmpt_body_video(tvb, offset, rtmpt_tree);\n                        break;\n                case RTMPT_TYPE_AGGREGATE:\n                        dissect_rtmpt_body_aggregate(tvb, offset, rtmpt_tree);\n                        break;\n                }\n        }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -37,25 +37,23 @@\n                         }\n                 }\n \n-                if (!PINFO_FD_VISITED(pinfo)) {\n-                        if (tp->cmd == RTMPT_TYPE_COMMAND_AMF0 || tp->cmd == RTMPT_TYPE_COMMAND_AMF3 ||\n-                            tp->cmd == RTMPT_TYPE_DATA_AMF0 || tp->cmd == RTMPT_TYPE_DATA_AMF3) {\n-                                guint32 soff = 0;\n-                                if (tp->cmd == RTMPT_TYPE_COMMAND_AMF3 || tp->cmd == RTMPT_TYPE_DATA_AMF3) {\n-                                        soff = 1;\n-                                }\n-                                tp->txid = rtmpt_get_amf_txid(tvb, iBodyOffset+soff);\n-                                if (tp->txid != 0) {\n-                                        RTMPT_DEBUG(\"got txid=%d\\n\", tp->txid);\n-                                        wmem_tree_insert32(rconv->txids[cdir], tp->txid, GINT_TO_POINTER(pinfo->num));\n-                                }\n+                if (tp->cmd == RTMPT_TYPE_COMMAND_AMF0 || tp->cmd == RTMPT_TYPE_COMMAND_AMF3 ||\n+                    tp->cmd == RTMPT_TYPE_DATA_AMF0 || tp->cmd == RTMPT_TYPE_DATA_AMF3) {\n+                        guint32 soff = 0;\n+                        if (tp->cmd == RTMPT_TYPE_COMMAND_AMF3 || tp->cmd == RTMPT_TYPE_DATA_AMF3) {\n+                                soff = 1;\n+                        }\n+                        tp->txid = rtmpt_get_amf_txid(tvb, iBodyOffset+soff, tree);\n+                        if (tp->txid != 0 && !PINFO_FD_VISITED(pinfo)) {\n+                                RTMPT_DEBUG(\"got txid=%d\\n\", tp->txid);\n+                                wmem_tree_insert32(rconv->txids[cdir], tp->txid, GINT_TO_POINTER(pinfo->num));\n                         }\n                 }\n         }\n \n         if (tp->id <= RTMPT_ID_MAX)\n         {\n-                sDesc = rtmpt_get_packet_desc(tvb, iBodyOffset, iBodyRemain, rconv, cdir, tp, &deschasopcode);\n+                sDesc = rtmpt_get_packet_desc(tvb, iBodyOffset, tree, iBodyRemain, rconv, cdir, tp, &deschasopcode);\n         }\n \n         if (tp->id>RTMPT_ID_MAX) {",
        "diff_line_info": {
            "deleted_lines": [
                "                if (!PINFO_FD_VISITED(pinfo)) {",
                "                        if (tp->cmd == RTMPT_TYPE_COMMAND_AMF0 || tp->cmd == RTMPT_TYPE_COMMAND_AMF3 ||",
                "                            tp->cmd == RTMPT_TYPE_DATA_AMF0 || tp->cmd == RTMPT_TYPE_DATA_AMF3) {",
                "                                guint32 soff = 0;",
                "                                if (tp->cmd == RTMPT_TYPE_COMMAND_AMF3 || tp->cmd == RTMPT_TYPE_DATA_AMF3) {",
                "                                        soff = 1;",
                "                                }",
                "                                tp->txid = rtmpt_get_amf_txid(tvb, iBodyOffset+soff);",
                "                                if (tp->txid != 0) {",
                "                                        RTMPT_DEBUG(\"got txid=%d\\n\", tp->txid);",
                "                                        wmem_tree_insert32(rconv->txids[cdir], tp->txid, GINT_TO_POINTER(pinfo->num));",
                "                                }",
                "                sDesc = rtmpt_get_packet_desc(tvb, iBodyOffset, iBodyRemain, rconv, cdir, tp, &deschasopcode);"
            ],
            "added_lines": [
                "                if (tp->cmd == RTMPT_TYPE_COMMAND_AMF0 || tp->cmd == RTMPT_TYPE_COMMAND_AMF3 ||",
                "                    tp->cmd == RTMPT_TYPE_DATA_AMF0 || tp->cmd == RTMPT_TYPE_DATA_AMF3) {",
                "                        guint32 soff = 0;",
                "                        if (tp->cmd == RTMPT_TYPE_COMMAND_AMF3 || tp->cmd == RTMPT_TYPE_DATA_AMF3) {",
                "                                soff = 1;",
                "                        }",
                "                        tp->txid = rtmpt_get_amf_txid(tvb, iBodyOffset+soff, tree);",
                "                        if (tp->txid != 0 && !PINFO_FD_VISITED(pinfo)) {",
                "                                RTMPT_DEBUG(\"got txid=%d\\n\", tp->txid);",
                "                                wmem_tree_insert32(rconv->txids[cdir], tp->txid, GINT_TO_POINTER(pinfo->num));",
                "                sDesc = rtmpt_get_packet_desc(tvb, iBodyOffset, tree, iBodyRemain, rconv, cdir, tp, &deschasopcode);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-14394",
        "func_name": "qemu-project/qemu/xhci_ring_chain_length",
        "description": "An infinite loop flaw was found in the USB xHCI controller emulation of QEMU while computing the length of the Transfer Request Block (TRB) Ring. This flaw allows a privileged guest user to hang the QEMU process on the host, resulting in a denial of service.",
        "git_url": "https://gitlab.com/qemu-project/qemu/-/commit/effaf5a240e03020f4ae953e10b764622c3e87cc",
        "commit_title": "hw/usb/hcd-xhci: Fix unbounded loop in xhci_ring_chain_length() (CVE-2020-14394)",
        "commit_text": " The loop condition in xhci_ring_chain_length() is under control of the guest, and additionally the code does not check for failed DMA transfers (e.g. if reaching the end of the RAM), so the loop there could run for a very long time or even forever. Fix it by checking the return value of dma_memory_read() and by introducing a maximum loop length.  Resolves: https://gitlab.com/qemu-project/qemu/-/issues/646 Message-Id: <20220804131300.96368-1-thuth@redhat.com> ",
        "func_before": "static int xhci_ring_chain_length(XHCIState *xhci, const XHCIRing *ring)\n{\n    XHCITRB trb;\n    int length = 0;\n    dma_addr_t dequeue = ring->dequeue;\n    bool ccs = ring->ccs;\n    /* hack to bundle together the two/three TDs that make a setup transfer */\n    bool control_td_set = 0;\n    uint32_t link_cnt = 0;\n\n    while (1) {\n        TRBType type;\n        dma_memory_read(xhci->as, dequeue, &trb, TRB_SIZE,\n                        MEMTXATTRS_UNSPECIFIED);\n        le64_to_cpus(&trb.parameter);\n        le32_to_cpus(&trb.status);\n        le32_to_cpus(&trb.control);\n\n        if ((trb.control & TRB_C) != ccs) {\n            return -length;\n        }\n\n        type = TRB_TYPE(trb);\n\n        if (type == TR_LINK) {\n            if (++link_cnt > TRB_LINK_LIMIT) {\n                return -length;\n            }\n            dequeue = xhci_mask64(trb.parameter);\n            if (trb.control & TRB_LK_TC) {\n                ccs = !ccs;\n            }\n            continue;\n        }\n\n        length += 1;\n        dequeue += TRB_SIZE;\n\n        if (type == TR_SETUP) {\n            control_td_set = 1;\n        } else if (type == TR_STATUS) {\n            control_td_set = 0;\n        }\n\n        if (!control_td_set && !(trb.control & TRB_TR_CH)) {\n            return length;\n        }\n    }\n}",
        "func": "static int xhci_ring_chain_length(XHCIState *xhci, const XHCIRing *ring)\n{\n    XHCITRB trb;\n    int length = 0;\n    dma_addr_t dequeue = ring->dequeue;\n    bool ccs = ring->ccs;\n    /* hack to bundle together the two/three TDs that make a setup transfer */\n    bool control_td_set = 0;\n    uint32_t link_cnt = 0;\n\n    do {\n        TRBType type;\n        if (dma_memory_read(xhci->as, dequeue, &trb, TRB_SIZE,\n                        MEMTXATTRS_UNSPECIFIED) != MEMTX_OK) {\n            qemu_log_mask(LOG_GUEST_ERROR, \"%s: DMA memory access failed!\\n\",\n                          __func__);\n            return -1;\n        }\n        le64_to_cpus(&trb.parameter);\n        le32_to_cpus(&trb.status);\n        le32_to_cpus(&trb.control);\n\n        if ((trb.control & TRB_C) != ccs) {\n            return -length;\n        }\n\n        type = TRB_TYPE(trb);\n\n        if (type == TR_LINK) {\n            if (++link_cnt > TRB_LINK_LIMIT) {\n                return -length;\n            }\n            dequeue = xhci_mask64(trb.parameter);\n            if (trb.control & TRB_LK_TC) {\n                ccs = !ccs;\n            }\n            continue;\n        }\n\n        length += 1;\n        dequeue += TRB_SIZE;\n\n        if (type == TR_SETUP) {\n            control_td_set = 1;\n        } else if (type == TR_STATUS) {\n            control_td_set = 0;\n        }\n\n        if (!control_td_set && !(trb.control & TRB_TR_CH)) {\n            return length;\n        }\n\n        /*\n         * According to the xHCI spec, Transfer Ring segments should have\n         * a maximum size of 64 kB (see chapter \"6 Data Structures\")\n         */\n    } while (length < TRB_LINK_LIMIT * 65536 / TRB_SIZE);\n\n    qemu_log_mask(LOG_GUEST_ERROR, \"%s: exceeded maximum tranfer ring size!\\n\",\n                          __func__);\n\n    return -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,10 +8,14 @@\n     bool control_td_set = 0;\n     uint32_t link_cnt = 0;\n \n-    while (1) {\n+    do {\n         TRBType type;\n-        dma_memory_read(xhci->as, dequeue, &trb, TRB_SIZE,\n-                        MEMTXATTRS_UNSPECIFIED);\n+        if (dma_memory_read(xhci->as, dequeue, &trb, TRB_SIZE,\n+                        MEMTXATTRS_UNSPECIFIED) != MEMTX_OK) {\n+            qemu_log_mask(LOG_GUEST_ERROR, \"%s: DMA memory access failed!\\n\",\n+                          __func__);\n+            return -1;\n+        }\n         le64_to_cpus(&trb.parameter);\n         le32_to_cpus(&trb.status);\n         le32_to_cpus(&trb.control);\n@@ -45,5 +49,15 @@\n         if (!control_td_set && !(trb.control & TRB_TR_CH)) {\n             return length;\n         }\n-    }\n+\n+        /*\n+         * According to the xHCI spec, Transfer Ring segments should have\n+         * a maximum size of 64 kB (see chapter \"6 Data Structures\")\n+         */\n+    } while (length < TRB_LINK_LIMIT * 65536 / TRB_SIZE);\n+\n+    qemu_log_mask(LOG_GUEST_ERROR, \"%s: exceeded maximum tranfer ring size!\\n\",\n+                          __func__);\n+\n+    return -1;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    while (1) {",
                "        dma_memory_read(xhci->as, dequeue, &trb, TRB_SIZE,",
                "                        MEMTXATTRS_UNSPECIFIED);",
                "    }"
            ],
            "added_lines": [
                "    do {",
                "        if (dma_memory_read(xhci->as, dequeue, &trb, TRB_SIZE,",
                "                        MEMTXATTRS_UNSPECIFIED) != MEMTX_OK) {",
                "            qemu_log_mask(LOG_GUEST_ERROR, \"%s: DMA memory access failed!\\n\",",
                "                          __func__);",
                "            return -1;",
                "        }",
                "",
                "        /*",
                "         * According to the xHCI spec, Transfer Ring segments should have",
                "         * a maximum size of 64 kB (see chapter \"6 Data Structures\")",
                "         */",
                "    } while (length < TRB_LINK_LIMIT * 65536 / TRB_SIZE);",
                "",
                "    qemu_log_mask(LOG_GUEST_ERROR, \"%s: exceeded maximum tranfer ring size!\\n\",",
                "                          __func__);",
                "",
                "    return -1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3190",
        "func_name": "wireshark/dissect_old_trailer",
        "description": "Infinite loop in the F5 Ethernet Trailer protocol dissector in Wireshark 3.6.0 to 3.6.7 and 3.4.0 to 3.4.15 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/0f27a83c5692b2afebe6e6934c1051f76aa2ecf9",
        "commit_title": "f5ethtrailer: Improve \"old-style\" heuristic",
        "commit_text": " Remove a chance for an infinate loop in the disection heuristic. ",
        "func_before": "static gint\ndissect_old_trailer(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    proto_tree *type_tree   = NULL;\n    proto_item *ti          = NULL;\n    guint offset            = 0;\n    guint processed         = 0;\n    f5eth_tap_data_t *tdata = (f5eth_tap_data_t *)data;\n    guint8 type;\n    guint8 len;\n    guint8 ver;\n\n    /* While we still have data in the trailer.  For old format trailers, this needs\n     * type, length, version (3 bytes) and for new format trailers, the magic header (4 bytes).\n     * All old format trailers are at least 4 bytes long, so just check for length of magic.\n     */\n    while (tvb_reported_length_remaining(tvb, offset)) {\n        type = tvb_get_guint8(tvb, offset);\n        len = tvb_get_guint8(tvb, offset + F5_OFF_LENGTH) + F5_OFF_VERSION;\n        ver = tvb_get_guint8(tvb, offset + F5_OFF_VERSION);\n\n        if (len <= tvb_reported_length_remaining(tvb, offset) && type >= F5TYPE_LOW\n            && type <= F5TYPE_HIGH && len >= F5_MIN_SANE && len <= F5_MAX_SANE\n            && ver <= F5TRAILER_VER_MAX) {\n            /* Parse out the specified trailer. */\n            switch (type) {\n            case F5TYPE_LOW:\n                ti        = proto_tree_add_item(tree, hf_low_id, tvb, offset, len, ENC_NA);\n                type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_low);\n\n                processed = dissect_low_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);\n                if (processed > 0) {\n                    tdata->trailer_len += processed;\n                    tdata->noise_low = 1;\n                }\n                break;\n            case F5TYPE_MED:\n                ti        = proto_tree_add_item(tree, hf_med_id, tvb, offset, len, ENC_NA);\n                type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_med);\n\n                processed = dissect_med_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);\n                if (processed > 0) {\n                    tdata->trailer_len += processed;\n                    tdata->noise_med = 1;\n                }\n                break;\n            case F5TYPE_HIGH:\n                ti        = proto_tree_add_item(tree, hf_high_id, tvb, offset, len, ENC_NA);\n                type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_high);\n\n                processed =\n                    dissect_high_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);\n                if (processed > 0) {\n                    tdata->trailer_len += processed;\n                    tdata->noise_high = 1;\n                }\n                break;\n            }\n            if (processed == 0) {\n                proto_item_set_len(ti, 1);\n                return offset;\n            }\n        }\n        offset += processed;\n    }\nreturn offset;\n}",
        "func": "static gint\ndissect_old_trailer(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    guint offset            = 0;\n\n    /* While we still have data in the trailer.  For old format trailers, this needs\n     * type, length, version (3 bytes) and for new format trailers, the magic header (4 bytes).\n     * All old format trailers are at least 4 bytes long, so just check for length of magic.\n     */\n    while (tvb_reported_length_remaining(tvb, offset) >= F5_MIN_SANE) {\n        /* length field does not include the type and length bytes.  Add them back in */\n        guint8 len = tvb_get_guint8(tvb, offset + F5_OFF_LENGTH) + F5_OFF_VERSION;\n        if (len > tvb_reported_length_remaining(tvb, offset)\n            || len < F5_MIN_SANE || len > F5_MAX_SANE) {\n            /* Invalid length - either a malformed trailer, corrupt packet, or not f5ethtrailer */\n            return offset;\n        }\n        guint8 type = tvb_get_guint8(tvb, offset);\n        guint8 ver = tvb_get_guint8(tvb, offset + F5_OFF_VERSION);\n\n        /* Parse out the specified trailer. */\n        proto_tree *type_tree   = NULL;\n        proto_item *ti          = NULL;\n        f5eth_tap_data_t *tdata = (f5eth_tap_data_t *)data;\n        guint processed = 0;\n\n        switch (type) {\n        case F5TYPE_LOW:\n            ti        = proto_tree_add_item(tree, hf_low_id, tvb, offset, len, ENC_NA);\n            type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_low);\n\n            processed = dissect_low_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);\n            if (processed > 0) {\n                tdata->trailer_len += processed;\n                tdata->noise_low = 1;\n            }\n            break;\n        case F5TYPE_MED:\n            ti        = proto_tree_add_item(tree, hf_med_id, tvb, offset, len, ENC_NA);\n            type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_med);\n\n            processed = dissect_med_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);\n            if (processed > 0) {\n                tdata->trailer_len += processed;\n                tdata->noise_med = 1;\n            }\n            break;\n        case F5TYPE_HIGH:\n            ti        = proto_tree_add_item(tree, hf_high_id, tvb, offset, len, ENC_NA);\n            type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_high);\n\n            processed =\n                dissect_high_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);\n            if (processed > 0) {\n                tdata->trailer_len += processed;\n                tdata->noise_high = 1;\n            }\n            break;\n        default:\n            /* Unknown type - malformed trailer, corrupt packet, or not f5ethtrailer - bali out*/\n            return offset;\n        }\n        if (processed == 0) {\n            /* couldn't process trailer - bali out */\n            proto_item_set_len(ti, 1);\n            return offset;\n        }\n        offset += processed;\n    }\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,67 +1,71 @@\n static gint\n dissect_old_trailer(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n {\n-    proto_tree *type_tree   = NULL;\n-    proto_item *ti          = NULL;\n     guint offset            = 0;\n-    guint processed         = 0;\n-    f5eth_tap_data_t *tdata = (f5eth_tap_data_t *)data;\n-    guint8 type;\n-    guint8 len;\n-    guint8 ver;\n \n     /* While we still have data in the trailer.  For old format trailers, this needs\n      * type, length, version (3 bytes) and for new format trailers, the magic header (4 bytes).\n      * All old format trailers are at least 4 bytes long, so just check for length of magic.\n      */\n-    while (tvb_reported_length_remaining(tvb, offset)) {\n-        type = tvb_get_guint8(tvb, offset);\n-        len = tvb_get_guint8(tvb, offset + F5_OFF_LENGTH) + F5_OFF_VERSION;\n-        ver = tvb_get_guint8(tvb, offset + F5_OFF_VERSION);\n+    while (tvb_reported_length_remaining(tvb, offset) >= F5_MIN_SANE) {\n+        /* length field does not include the type and length bytes.  Add them back in */\n+        guint8 len = tvb_get_guint8(tvb, offset + F5_OFF_LENGTH) + F5_OFF_VERSION;\n+        if (len > tvb_reported_length_remaining(tvb, offset)\n+            || len < F5_MIN_SANE || len > F5_MAX_SANE) {\n+            /* Invalid length - either a malformed trailer, corrupt packet, or not f5ethtrailer */\n+            return offset;\n+        }\n+        guint8 type = tvb_get_guint8(tvb, offset);\n+        guint8 ver = tvb_get_guint8(tvb, offset + F5_OFF_VERSION);\n \n-        if (len <= tvb_reported_length_remaining(tvb, offset) && type >= F5TYPE_LOW\n-            && type <= F5TYPE_HIGH && len >= F5_MIN_SANE && len <= F5_MAX_SANE\n-            && ver <= F5TRAILER_VER_MAX) {\n-            /* Parse out the specified trailer. */\n-            switch (type) {\n-            case F5TYPE_LOW:\n-                ti        = proto_tree_add_item(tree, hf_low_id, tvb, offset, len, ENC_NA);\n-                type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_low);\n+        /* Parse out the specified trailer. */\n+        proto_tree *type_tree   = NULL;\n+        proto_item *ti          = NULL;\n+        f5eth_tap_data_t *tdata = (f5eth_tap_data_t *)data;\n+        guint processed = 0;\n \n-                processed = dissect_low_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);\n-                if (processed > 0) {\n-                    tdata->trailer_len += processed;\n-                    tdata->noise_low = 1;\n-                }\n-                break;\n-            case F5TYPE_MED:\n-                ti        = proto_tree_add_item(tree, hf_med_id, tvb, offset, len, ENC_NA);\n-                type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_med);\n+        switch (type) {\n+        case F5TYPE_LOW:\n+            ti        = proto_tree_add_item(tree, hf_low_id, tvb, offset, len, ENC_NA);\n+            type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_low);\n \n-                processed = dissect_med_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);\n-                if (processed > 0) {\n-                    tdata->trailer_len += processed;\n-                    tdata->noise_med = 1;\n-                }\n-                break;\n-            case F5TYPE_HIGH:\n-                ti        = proto_tree_add_item(tree, hf_high_id, tvb, offset, len, ENC_NA);\n-                type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_high);\n+            processed = dissect_low_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);\n+            if (processed > 0) {\n+                tdata->trailer_len += processed;\n+                tdata->noise_low = 1;\n+            }\n+            break;\n+        case F5TYPE_MED:\n+            ti        = proto_tree_add_item(tree, hf_med_id, tvb, offset, len, ENC_NA);\n+            type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_med);\n \n-                processed =\n-                    dissect_high_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);\n-                if (processed > 0) {\n-                    tdata->trailer_len += processed;\n-                    tdata->noise_high = 1;\n-                }\n-                break;\n+            processed = dissect_med_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);\n+            if (processed > 0) {\n+                tdata->trailer_len += processed;\n+                tdata->noise_med = 1;\n             }\n-            if (processed == 0) {\n-                proto_item_set_len(ti, 1);\n-                return offset;\n+            break;\n+        case F5TYPE_HIGH:\n+            ti        = proto_tree_add_item(tree, hf_high_id, tvb, offset, len, ENC_NA);\n+            type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_high);\n+\n+            processed =\n+                dissect_high_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);\n+            if (processed > 0) {\n+                tdata->trailer_len += processed;\n+                tdata->noise_high = 1;\n             }\n+            break;\n+        default:\n+            /* Unknown type - malformed trailer, corrupt packet, or not f5ethtrailer - bali out*/\n+            return offset;\n+        }\n+        if (processed == 0) {\n+            /* couldn't process trailer - bali out */\n+            proto_item_set_len(ti, 1);\n+            return offset;\n         }\n         offset += processed;\n     }\n-return offset;\n+    return offset;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    proto_tree *type_tree   = NULL;",
                "    proto_item *ti          = NULL;",
                "    guint processed         = 0;",
                "    f5eth_tap_data_t *tdata = (f5eth_tap_data_t *)data;",
                "    guint8 type;",
                "    guint8 len;",
                "    guint8 ver;",
                "    while (tvb_reported_length_remaining(tvb, offset)) {",
                "        type = tvb_get_guint8(tvb, offset);",
                "        len = tvb_get_guint8(tvb, offset + F5_OFF_LENGTH) + F5_OFF_VERSION;",
                "        ver = tvb_get_guint8(tvb, offset + F5_OFF_VERSION);",
                "        if (len <= tvb_reported_length_remaining(tvb, offset) && type >= F5TYPE_LOW",
                "            && type <= F5TYPE_HIGH && len >= F5_MIN_SANE && len <= F5_MAX_SANE",
                "            && ver <= F5TRAILER_VER_MAX) {",
                "            /* Parse out the specified trailer. */",
                "            switch (type) {",
                "            case F5TYPE_LOW:",
                "                ti        = proto_tree_add_item(tree, hf_low_id, tvb, offset, len, ENC_NA);",
                "                type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_low);",
                "                processed = dissect_low_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);",
                "                if (processed > 0) {",
                "                    tdata->trailer_len += processed;",
                "                    tdata->noise_low = 1;",
                "                }",
                "                break;",
                "            case F5TYPE_MED:",
                "                ti        = proto_tree_add_item(tree, hf_med_id, tvb, offset, len, ENC_NA);",
                "                type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_med);",
                "                processed = dissect_med_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);",
                "                if (processed > 0) {",
                "                    tdata->trailer_len += processed;",
                "                    tdata->noise_med = 1;",
                "                }",
                "                break;",
                "            case F5TYPE_HIGH:",
                "                ti        = proto_tree_add_item(tree, hf_high_id, tvb, offset, len, ENC_NA);",
                "                type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_high);",
                "                processed =",
                "                    dissect_high_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);",
                "                if (processed > 0) {",
                "                    tdata->trailer_len += processed;",
                "                    tdata->noise_high = 1;",
                "                }",
                "                break;",
                "            if (processed == 0) {",
                "                proto_item_set_len(ti, 1);",
                "                return offset;",
                "return offset;"
            ],
            "added_lines": [
                "    while (tvb_reported_length_remaining(tvb, offset) >= F5_MIN_SANE) {",
                "        /* length field does not include the type and length bytes.  Add them back in */",
                "        guint8 len = tvb_get_guint8(tvb, offset + F5_OFF_LENGTH) + F5_OFF_VERSION;",
                "        if (len > tvb_reported_length_remaining(tvb, offset)",
                "            || len < F5_MIN_SANE || len > F5_MAX_SANE) {",
                "            /* Invalid length - either a malformed trailer, corrupt packet, or not f5ethtrailer */",
                "            return offset;",
                "        }",
                "        guint8 type = tvb_get_guint8(tvb, offset);",
                "        guint8 ver = tvb_get_guint8(tvb, offset + F5_OFF_VERSION);",
                "        /* Parse out the specified trailer. */",
                "        proto_tree *type_tree   = NULL;",
                "        proto_item *ti          = NULL;",
                "        f5eth_tap_data_t *tdata = (f5eth_tap_data_t *)data;",
                "        guint processed = 0;",
                "        switch (type) {",
                "        case F5TYPE_LOW:",
                "            ti        = proto_tree_add_item(tree, hf_low_id, tvb, offset, len, ENC_NA);",
                "            type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_low);",
                "            processed = dissect_low_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);",
                "            if (processed > 0) {",
                "                tdata->trailer_len += processed;",
                "                tdata->noise_low = 1;",
                "            }",
                "            break;",
                "        case F5TYPE_MED:",
                "            ti        = proto_tree_add_item(tree, hf_med_id, tvb, offset, len, ENC_NA);",
                "            type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_med);",
                "            processed = dissect_med_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);",
                "            if (processed > 0) {",
                "                tdata->trailer_len += processed;",
                "                tdata->noise_med = 1;",
                "            break;",
                "        case F5TYPE_HIGH:",
                "            ti        = proto_tree_add_item(tree, hf_high_id, tvb, offset, len, ENC_NA);",
                "            type_tree = proto_item_add_subtree(ti, ett_f5ethtrailer_high);",
                "",
                "            processed =",
                "                dissect_high_trailer(tvb, pinfo, type_tree, offset, len, ver, tdata);",
                "            if (processed > 0) {",
                "                tdata->trailer_len += processed;",
                "                tdata->noise_high = 1;",
                "            break;",
                "        default:",
                "            /* Unknown type - malformed trailer, corrupt packet, or not f5ethtrailer - bali out*/",
                "            return offset;",
                "        }",
                "        if (processed == 0) {",
                "            /* couldn't process trailer - bali out */",
                "            proto_item_set_len(ti, 1);",
                "            return offset;",
                "    return offset;"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-0148",
        "func_name": "qemu/vhdx_parse_metadata",
        "description": "Qemu before 2.0 block driver for Hyper-V VHDX Images is vulnerable to infinite loops and other potential issues when calculating BAT entries, due to missing bounds checks for block_size and logical_sector_size variables. These are used to derive other fields like 'sectors_per_block' etc. A user able to alter the Qemu disk image could ise this flaw to crash the Qemu instance resulting in DoS.",
        "git_url": "https://github.com/qemu/qemu/commit/1d7678dec4761acdc43439da6ceda41a703ba1a6",
        "commit_title": "vhdx: Bounds checking for block_size and logical_sector_size (CVE-2014-0148)",
        "commit_text": " Other variables (e.g. sectors_per_block) are calculated using these variables, and if not range-checked illegal values could be obtained causing infinite loops and other potential issues when calculating BAT entries.  The 1.00 VHDX spec requires BlockSize to be min 1MB, max 256MB. LogicalSectorSize is required to be either 512 or 4096 bytes. ",
        "func_before": "static int vhdx_parse_metadata(BlockDriverState *bs, BDRVVHDXState *s)\n{\n    int ret = 0;\n    uint8_t *buffer;\n    int offset = 0;\n    uint32_t i = 0;\n    VHDXMetadataTableEntry md_entry;\n\n    buffer = qemu_blockalign(bs, VHDX_METADATA_TABLE_MAX_SIZE);\n\n    ret = bdrv_pread(bs->file, s->metadata_rt.file_offset, buffer,\n                     VHDX_METADATA_TABLE_MAX_SIZE);\n    if (ret < 0) {\n        goto exit;\n    }\n    memcpy(&s->metadata_hdr, buffer, sizeof(s->metadata_hdr));\n    offset += sizeof(s->metadata_hdr);\n\n    vhdx_metadata_header_le_import(&s->metadata_hdr);\n\n    if (memcmp(&s->metadata_hdr.signature, \"metadata\", 8)) {\n        ret = -EINVAL;\n        goto exit;\n    }\n\n    s->metadata_entries.present = 0;\n\n    if ((s->metadata_hdr.entry_count * sizeof(md_entry)) >\n        (VHDX_METADATA_TABLE_MAX_SIZE - offset)) {\n        ret = -EINVAL;\n        goto exit;\n    }\n\n    for (i = 0; i < s->metadata_hdr.entry_count; i++) {\n        memcpy(&md_entry, buffer + offset, sizeof(md_entry));\n        offset += sizeof(md_entry);\n\n        vhdx_metadata_entry_le_import(&md_entry);\n\n        if (guid_eq(md_entry.item_id, file_param_guid)) {\n            if (s->metadata_entries.present & META_FILE_PARAMETER_PRESENT) {\n                ret = -EINVAL;\n                goto exit;\n            }\n            s->metadata_entries.file_parameters_entry = md_entry;\n            s->metadata_entries.present |= META_FILE_PARAMETER_PRESENT;\n            continue;\n        }\n\n        if (guid_eq(md_entry.item_id, virtual_size_guid)) {\n            if (s->metadata_entries.present & META_VIRTUAL_DISK_SIZE_PRESENT) {\n                ret = -EINVAL;\n                goto exit;\n            }\n            s->metadata_entries.virtual_disk_size_entry = md_entry;\n            s->metadata_entries.present |= META_VIRTUAL_DISK_SIZE_PRESENT;\n            continue;\n        }\n\n        if (guid_eq(md_entry.item_id, page83_guid)) {\n            if (s->metadata_entries.present & META_PAGE_83_PRESENT) {\n                ret = -EINVAL;\n                goto exit;\n            }\n            s->metadata_entries.page83_data_entry = md_entry;\n            s->metadata_entries.present |= META_PAGE_83_PRESENT;\n            continue;\n        }\n\n        if (guid_eq(md_entry.item_id, logical_sector_guid)) {\n            if (s->metadata_entries.present &\n                META_LOGICAL_SECTOR_SIZE_PRESENT) {\n                ret = -EINVAL;\n                goto exit;\n            }\n            s->metadata_entries.logical_sector_size_entry = md_entry;\n            s->metadata_entries.present |= META_LOGICAL_SECTOR_SIZE_PRESENT;\n            continue;\n        }\n\n        if (guid_eq(md_entry.item_id, phys_sector_guid)) {\n            if (s->metadata_entries.present & META_PHYS_SECTOR_SIZE_PRESENT) {\n                ret = -EINVAL;\n                goto exit;\n            }\n            s->metadata_entries.phys_sector_size_entry = md_entry;\n            s->metadata_entries.present |= META_PHYS_SECTOR_SIZE_PRESENT;\n            continue;\n        }\n\n        if (guid_eq(md_entry.item_id, parent_locator_guid)) {\n            if (s->metadata_entries.present & META_PARENT_LOCATOR_PRESENT) {\n                ret = -EINVAL;\n                goto exit;\n            }\n            s->metadata_entries.parent_locator_entry = md_entry;\n            s->metadata_entries.present |= META_PARENT_LOCATOR_PRESENT;\n            continue;\n        }\n\n        if (md_entry.data_bits & VHDX_META_FLAGS_IS_REQUIRED) {\n            /* cannot read vhdx file - required region table entry that\n             * we do not understand.  per spec, we must fail to open */\n            ret = -ENOTSUP;\n            goto exit;\n        }\n    }\n\n    if (s->metadata_entries.present != META_ALL_PRESENT) {\n        ret = -ENOTSUP;\n        goto exit;\n    }\n\n    ret = bdrv_pread(bs->file,\n                     s->metadata_entries.file_parameters_entry.offset\n                                         + s->metadata_rt.file_offset,\n                     &s->params,\n                     sizeof(s->params));\n\n    if (ret < 0) {\n        goto exit;\n    }\n\n    le32_to_cpus(&s->params.block_size);\n    le32_to_cpus(&s->params.data_bits);\n\n\n    /* We now have the file parameters, so we can tell if this is a\n     * differencing file (i.e.. has_parent), is dynamic or fixed\n     * sized (leave_blocks_allocated), and the block size */\n\n    /* The parent locator required iff the file parameters has_parent set */\n    if (s->params.data_bits & VHDX_PARAMS_HAS_PARENT) {\n        if (s->metadata_entries.present & META_PARENT_LOCATOR_PRESENT) {\n            /* TODO: parse  parent locator fields */\n            ret = -ENOTSUP; /* temp, until differencing files are supported */\n            goto exit;\n        } else {\n            /* if has_parent is set, but there is not parent locator present,\n             * then that is an invalid combination */\n            ret = -EINVAL;\n            goto exit;\n        }\n    }\n\n    /* determine virtual disk size, logical sector size,\n     * and phys sector size */\n\n    ret = bdrv_pread(bs->file,\n                     s->metadata_entries.virtual_disk_size_entry.offset\n                                           + s->metadata_rt.file_offset,\n                     &s->virtual_disk_size,\n                     sizeof(uint64_t));\n    if (ret < 0) {\n        goto exit;\n    }\n    ret = bdrv_pread(bs->file,\n                     s->metadata_entries.logical_sector_size_entry.offset\n                                             + s->metadata_rt.file_offset,\n                     &s->logical_sector_size,\n                     sizeof(uint32_t));\n    if (ret < 0) {\n        goto exit;\n    }\n    ret = bdrv_pread(bs->file,\n                     s->metadata_entries.phys_sector_size_entry.offset\n                                          + s->metadata_rt.file_offset,\n                     &s->physical_sector_size,\n                     sizeof(uint32_t));\n    if (ret < 0) {\n        goto exit;\n    }\n\n    le64_to_cpus(&s->virtual_disk_size);\n    le32_to_cpus(&s->logical_sector_size);\n    le32_to_cpus(&s->physical_sector_size);\n\n    if (s->logical_sector_size == 0 || s->params.block_size == 0) {\n        ret = -EINVAL;\n        goto exit;\n    }\n\n    /* both block_size and sector_size are guaranteed powers of 2 */\n    s->sectors_per_block = s->params.block_size / s->logical_sector_size;\n    s->chunk_ratio = (VHDX_MAX_SECTORS_PER_BLOCK) *\n                     (uint64_t)s->logical_sector_size /\n                     (uint64_t)s->params.block_size;\n\n    /* These values are ones we will want to use for division / multiplication\n     * later on, and they are all guaranteed (per the spec) to be powers of 2,\n     * so we can take advantage of that for shift operations during\n     * reads/writes */\n    if (s->logical_sector_size & (s->logical_sector_size - 1)) {\n        ret = -EINVAL;\n        goto exit;\n    }\n    if (s->sectors_per_block & (s->sectors_per_block - 1)) {\n        ret = -EINVAL;\n        goto exit;\n    }\n    if (s->chunk_ratio & (s->chunk_ratio - 1)) {\n        ret = -EINVAL;\n        goto exit;\n    }\n    s->block_size = s->params.block_size;\n    if (s->block_size & (s->block_size - 1)) {\n        ret = -EINVAL;\n        goto exit;\n    }\n\n    vhdx_set_shift_bits(s);\n\n    ret = 0;\n\nexit:\n    qemu_vfree(buffer);\n    return ret;\n}",
        "func": "static int vhdx_parse_metadata(BlockDriverState *bs, BDRVVHDXState *s)\n{\n    int ret = 0;\n    uint8_t *buffer;\n    int offset = 0;\n    uint32_t i = 0;\n    VHDXMetadataTableEntry md_entry;\n\n    buffer = qemu_blockalign(bs, VHDX_METADATA_TABLE_MAX_SIZE);\n\n    ret = bdrv_pread(bs->file, s->metadata_rt.file_offset, buffer,\n                     VHDX_METADATA_TABLE_MAX_SIZE);\n    if (ret < 0) {\n        goto exit;\n    }\n    memcpy(&s->metadata_hdr, buffer, sizeof(s->metadata_hdr));\n    offset += sizeof(s->metadata_hdr);\n\n    vhdx_metadata_header_le_import(&s->metadata_hdr);\n\n    if (memcmp(&s->metadata_hdr.signature, \"metadata\", 8)) {\n        ret = -EINVAL;\n        goto exit;\n    }\n\n    s->metadata_entries.present = 0;\n\n    if ((s->metadata_hdr.entry_count * sizeof(md_entry)) >\n        (VHDX_METADATA_TABLE_MAX_SIZE - offset)) {\n        ret = -EINVAL;\n        goto exit;\n    }\n\n    for (i = 0; i < s->metadata_hdr.entry_count; i++) {\n        memcpy(&md_entry, buffer + offset, sizeof(md_entry));\n        offset += sizeof(md_entry);\n\n        vhdx_metadata_entry_le_import(&md_entry);\n\n        if (guid_eq(md_entry.item_id, file_param_guid)) {\n            if (s->metadata_entries.present & META_FILE_PARAMETER_PRESENT) {\n                ret = -EINVAL;\n                goto exit;\n            }\n            s->metadata_entries.file_parameters_entry = md_entry;\n            s->metadata_entries.present |= META_FILE_PARAMETER_PRESENT;\n            continue;\n        }\n\n        if (guid_eq(md_entry.item_id, virtual_size_guid)) {\n            if (s->metadata_entries.present & META_VIRTUAL_DISK_SIZE_PRESENT) {\n                ret = -EINVAL;\n                goto exit;\n            }\n            s->metadata_entries.virtual_disk_size_entry = md_entry;\n            s->metadata_entries.present |= META_VIRTUAL_DISK_SIZE_PRESENT;\n            continue;\n        }\n\n        if (guid_eq(md_entry.item_id, page83_guid)) {\n            if (s->metadata_entries.present & META_PAGE_83_PRESENT) {\n                ret = -EINVAL;\n                goto exit;\n            }\n            s->metadata_entries.page83_data_entry = md_entry;\n            s->metadata_entries.present |= META_PAGE_83_PRESENT;\n            continue;\n        }\n\n        if (guid_eq(md_entry.item_id, logical_sector_guid)) {\n            if (s->metadata_entries.present &\n                META_LOGICAL_SECTOR_SIZE_PRESENT) {\n                ret = -EINVAL;\n                goto exit;\n            }\n            s->metadata_entries.logical_sector_size_entry = md_entry;\n            s->metadata_entries.present |= META_LOGICAL_SECTOR_SIZE_PRESENT;\n            continue;\n        }\n\n        if (guid_eq(md_entry.item_id, phys_sector_guid)) {\n            if (s->metadata_entries.present & META_PHYS_SECTOR_SIZE_PRESENT) {\n                ret = -EINVAL;\n                goto exit;\n            }\n            s->metadata_entries.phys_sector_size_entry = md_entry;\n            s->metadata_entries.present |= META_PHYS_SECTOR_SIZE_PRESENT;\n            continue;\n        }\n\n        if (guid_eq(md_entry.item_id, parent_locator_guid)) {\n            if (s->metadata_entries.present & META_PARENT_LOCATOR_PRESENT) {\n                ret = -EINVAL;\n                goto exit;\n            }\n            s->metadata_entries.parent_locator_entry = md_entry;\n            s->metadata_entries.present |= META_PARENT_LOCATOR_PRESENT;\n            continue;\n        }\n\n        if (md_entry.data_bits & VHDX_META_FLAGS_IS_REQUIRED) {\n            /* cannot read vhdx file - required region table entry that\n             * we do not understand.  per spec, we must fail to open */\n            ret = -ENOTSUP;\n            goto exit;\n        }\n    }\n\n    if (s->metadata_entries.present != META_ALL_PRESENT) {\n        ret = -ENOTSUP;\n        goto exit;\n    }\n\n    ret = bdrv_pread(bs->file,\n                     s->metadata_entries.file_parameters_entry.offset\n                                         + s->metadata_rt.file_offset,\n                     &s->params,\n                     sizeof(s->params));\n\n    if (ret < 0) {\n        goto exit;\n    }\n\n    le32_to_cpus(&s->params.block_size);\n    le32_to_cpus(&s->params.data_bits);\n\n\n    /* We now have the file parameters, so we can tell if this is a\n     * differencing file (i.e.. has_parent), is dynamic or fixed\n     * sized (leave_blocks_allocated), and the block size */\n\n    /* The parent locator required iff the file parameters has_parent set */\n    if (s->params.data_bits & VHDX_PARAMS_HAS_PARENT) {\n        if (s->metadata_entries.present & META_PARENT_LOCATOR_PRESENT) {\n            /* TODO: parse  parent locator fields */\n            ret = -ENOTSUP; /* temp, until differencing files are supported */\n            goto exit;\n        } else {\n            /* if has_parent is set, but there is not parent locator present,\n             * then that is an invalid combination */\n            ret = -EINVAL;\n            goto exit;\n        }\n    }\n\n    /* determine virtual disk size, logical sector size,\n     * and phys sector size */\n\n    ret = bdrv_pread(bs->file,\n                     s->metadata_entries.virtual_disk_size_entry.offset\n                                           + s->metadata_rt.file_offset,\n                     &s->virtual_disk_size,\n                     sizeof(uint64_t));\n    if (ret < 0) {\n        goto exit;\n    }\n    ret = bdrv_pread(bs->file,\n                     s->metadata_entries.logical_sector_size_entry.offset\n                                             + s->metadata_rt.file_offset,\n                     &s->logical_sector_size,\n                     sizeof(uint32_t));\n    if (ret < 0) {\n        goto exit;\n    }\n    ret = bdrv_pread(bs->file,\n                     s->metadata_entries.phys_sector_size_entry.offset\n                                          + s->metadata_rt.file_offset,\n                     &s->physical_sector_size,\n                     sizeof(uint32_t));\n    if (ret < 0) {\n        goto exit;\n    }\n\n    le64_to_cpus(&s->virtual_disk_size);\n    le32_to_cpus(&s->logical_sector_size);\n    le32_to_cpus(&s->physical_sector_size);\n\n    if (s->params.block_size < VHDX_BLOCK_SIZE_MIN ||\n        s->params.block_size > VHDX_BLOCK_SIZE_MAX) {\n        ret = -EINVAL;\n        goto exit;\n    }\n\n    /* only 2 supported sector sizes */\n    if (s->logical_sector_size != 512 && s->logical_sector_size != 4096) {\n        ret = -EINVAL;\n        goto exit;\n    }\n\n    /* Both block_size and sector_size are guaranteed powers of 2, below.\n       Due to range checks above, s->sectors_per_block can never be < 256 */\n    s->sectors_per_block = s->params.block_size / s->logical_sector_size;\n    s->chunk_ratio = (VHDX_MAX_SECTORS_PER_BLOCK) *\n                     (uint64_t)s->logical_sector_size /\n                     (uint64_t)s->params.block_size;\n\n    /* These values are ones we will want to use for division / multiplication\n     * later on, and they are all guaranteed (per the spec) to be powers of 2,\n     * so we can take advantage of that for shift operations during\n     * reads/writes */\n    if (s->logical_sector_size & (s->logical_sector_size - 1)) {\n        ret = -EINVAL;\n        goto exit;\n    }\n    if (s->sectors_per_block & (s->sectors_per_block - 1)) {\n        ret = -EINVAL;\n        goto exit;\n    }\n    if (s->chunk_ratio & (s->chunk_ratio - 1)) {\n        ret = -EINVAL;\n        goto exit;\n    }\n    s->block_size = s->params.block_size;\n    if (s->block_size & (s->block_size - 1)) {\n        ret = -EINVAL;\n        goto exit;\n    }\n\n    vhdx_set_shift_bits(s);\n\n    ret = 0;\n\nexit:\n    qemu_vfree(buffer);\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -175,12 +175,20 @@\n     le32_to_cpus(&s->logical_sector_size);\n     le32_to_cpus(&s->physical_sector_size);\n \n-    if (s->logical_sector_size == 0 || s->params.block_size == 0) {\n-        ret = -EINVAL;\n-        goto exit;\n-    }\n-\n-    /* both block_size and sector_size are guaranteed powers of 2 */\n+    if (s->params.block_size < VHDX_BLOCK_SIZE_MIN ||\n+        s->params.block_size > VHDX_BLOCK_SIZE_MAX) {\n+        ret = -EINVAL;\n+        goto exit;\n+    }\n+\n+    /* only 2 supported sector sizes */\n+    if (s->logical_sector_size != 512 && s->logical_sector_size != 4096) {\n+        ret = -EINVAL;\n+        goto exit;\n+    }\n+\n+    /* Both block_size and sector_size are guaranteed powers of 2, below.\n+       Due to range checks above, s->sectors_per_block can never be < 256 */\n     s->sectors_per_block = s->params.block_size / s->logical_sector_size;\n     s->chunk_ratio = (VHDX_MAX_SECTORS_PER_BLOCK) *\n                      (uint64_t)s->logical_sector_size /",
        "diff_line_info": {
            "deleted_lines": [
                "    if (s->logical_sector_size == 0 || s->params.block_size == 0) {",
                "        ret = -EINVAL;",
                "        goto exit;",
                "    }",
                "",
                "    /* both block_size and sector_size are guaranteed powers of 2 */"
            ],
            "added_lines": [
                "    if (s->params.block_size < VHDX_BLOCK_SIZE_MIN ||",
                "        s->params.block_size > VHDX_BLOCK_SIZE_MAX) {",
                "        ret = -EINVAL;",
                "        goto exit;",
                "    }",
                "",
                "    /* only 2 supported sector sizes */",
                "    if (s->logical_sector_size != 512 && s->logical_sector_size != 4096) {",
                "        ret = -EINVAL;",
                "        goto exit;",
                "    }",
                "",
                "    /* Both block_size and sector_size are guaranteed powers of 2, below.",
                "       Due to range checks above, s->sectors_per_block can never be < 256 */"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-42721",
        "func_name": "kernel/git/wireless/wireless/cfg80211_add_nontrans_list",
        "description": "A list management bug in BSS handling in the mac80211 stack in the Linux kernel 5.1 through 5.19.x before 5.19.16 could be used by local attackers (able to inject WLAN frames) to corrupt a linked list and, in turn, potentially execute code.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/wireless/wireless.git/commit/?h=bcca852027e5878aec911a347407ecc88d6fff7f",
        "commit_title": "If a non-transmitted BSS shares enough information (both",
        "commit_text": "SSID and BSSID!) with another non-transmitted BSS of a different AP, then we can find and update it, and then try to add it to the non-transmitted BSS list. We do a search for it on the transmitted BSS, but if it's not there (but belongs to another transmitted BSS), the list gets corrupted.  Since this is an erroneous situation, simply fail the list insertion in this case and free the non-transmitted BSS.  This fixes CVE-2022-42721.  ",
        "func_before": "static int\ncfg80211_add_nontrans_list(struct cfg80211_bss *trans_bss,\n\t\t\t   struct cfg80211_bss *nontrans_bss)\n{\n\tconst struct element *ssid_elem;\n\tstruct cfg80211_bss *bss = NULL;\n\n\trcu_read_lock();\n\tssid_elem = ieee80211_bss_get_elem(nontrans_bss, WLAN_EID_SSID);\n\tif (!ssid_elem) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\t/* check if nontrans_bss is in the list */\n\tlist_for_each_entry(bss, &trans_bss->nontrans_list, nontrans_list) {\n\t\tif (is_bss(bss, nontrans_bss->bssid, ssid_elem->data,\n\t\t\t   ssid_elem->datalen)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\t/* add to the list */\n\tlist_add_tail(&nontrans_bss->nontrans_list, &trans_bss->nontrans_list);\n\treturn 0;\n}",
        "func": "static int\ncfg80211_add_nontrans_list(struct cfg80211_bss *trans_bss,\n\t\t\t   struct cfg80211_bss *nontrans_bss)\n{\n\tconst struct element *ssid_elem;\n\tstruct cfg80211_bss *bss = NULL;\n\n\trcu_read_lock();\n\tssid_elem = ieee80211_bss_get_elem(nontrans_bss, WLAN_EID_SSID);\n\tif (!ssid_elem) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\t/* check if nontrans_bss is in the list */\n\tlist_for_each_entry(bss, &trans_bss->nontrans_list, nontrans_list) {\n\t\tif (is_bss(bss, nontrans_bss->bssid, ssid_elem->data,\n\t\t\t   ssid_elem->datalen)) {\n\t\t\trcu_read_unlock();\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\t/*\n\t * This is a bit weird - it's not on the list, but already on another\n\t * one! The only way that could happen is if there's some BSSID/SSID\n\t * shared by multiple APs in their multi-BSSID profiles, potentially\n\t * with hidden SSID mixed in ... ignore it.\n\t */\n\tif (!list_empty(&nontrans_bss->nontrans_list))\n\t\treturn -EINVAL;\n\n\t/* add to the list */\n\tlist_add_tail(&nontrans_bss->nontrans_list, &trans_bss->nontrans_list);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,6 +23,15 @@\n \n \trcu_read_unlock();\n \n+\t/*\n+\t * This is a bit weird - it's not on the list, but already on another\n+\t * one! The only way that could happen is if there's some BSSID/SSID\n+\t * shared by multiple APs in their multi-BSSID profiles, potentially\n+\t * with hidden SSID mixed in ... ignore it.\n+\t */\n+\tif (!list_empty(&nontrans_bss->nontrans_list))\n+\t\treturn -EINVAL;\n+\n \t/* add to the list */\n \tlist_add_tail(&nontrans_bss->nontrans_list, &trans_bss->nontrans_list);\n \treturn 0;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t/*",
                "\t * This is a bit weird - it's not on the list, but already on another",
                "\t * one! The only way that could happen is if there's some BSSID/SSID",
                "\t * shared by multiple APs in their multi-BSSID profiles, potentially",
                "\t * with hidden SSID mixed in ... ignore it.",
                "\t */",
                "\tif (!list_empty(&nontrans_bss->nontrans_list))",
                "\t\treturn -EINVAL;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2017-15024",
        "func_name": "binutils-gdb/scan_unit_for_symbols",
        "description": "find_abstract_instance_name in dwarf2.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (infinite recursion and application crash) via a crafted ELF file.",
        "git_url": "https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=52a93b95ec0771c97e26f0bb28630a271a667bd2",
        "commit_title": "",
        "commit_text": "PR22187, infinite loop in find_abstract_instance_name  This patch prevents the simple case of infinite recursion in find_abstract_instance_name by ensuring that the attributes being processed are not the same as the previous call.  The patch also does a little cleanup, and leaves in place some changes to the nested_funcs array that I made when I wrongly thought looping might occur in scan_unit_for_symbols.  \tPR 22187 \t* dwarf2.c (find_abstract_instance_name): Add orig_info_ptr and \tpname param.  Return status.  Make name const.  Don't abort, \treturn an error.  Formatting.  Exit if current info_ptr matches \torig_info_ptr.  Update callers. \t(scan_unit_for_symbols): Start at nesting_level of zero.  Make \tnested_funcs an array of structs for extensibility.  Formatting. ",
        "func_before": "static bfd_boolean\nscan_unit_for_symbols (struct comp_unit *unit)\n{\n  bfd *abfd = unit->abfd;\n  bfd_byte *info_ptr = unit->first_child_die_ptr;\n  bfd_byte *info_ptr_end = unit->stash->info_ptr_end;\n  int nesting_level = 1;\n  struct funcinfo **nested_funcs;\n  int nested_funcs_size;\n\n  /* Maintain a stack of in-scope functions and inlined functions, which we\n     can use to set the caller_func field.  */\n  nested_funcs_size = 32;\n  nested_funcs = (struct funcinfo **)\n    bfd_malloc (nested_funcs_size * sizeof (struct funcinfo *));\n  if (nested_funcs == NULL)\n    return FALSE;\n  nested_funcs[nesting_level] = 0;\n\n  while (nesting_level)\n    {\n      unsigned int abbrev_number, bytes_read, i;\n      struct abbrev_info *abbrev;\n      struct attribute attr;\n      struct funcinfo *func;\n      struct varinfo *var;\n      bfd_vma low_pc = 0;\n      bfd_vma high_pc = 0;\n      bfd_boolean high_pc_relative = FALSE;\n\n      /* PR 17512: file: 9f405d9d.  */\n      if (info_ptr >= info_ptr_end)\n\tgoto fail;\n\n      abbrev_number = _bfd_safe_read_leb128 (abfd, info_ptr, &bytes_read,\n\t\t\t\t\t     FALSE, info_ptr_end);\n      info_ptr += bytes_read;\n\n      if (! abbrev_number)\n\t{\n\t  nesting_level--;\n\t  continue;\n\t}\n\n      abbrev = lookup_abbrev (abbrev_number, unit->abbrevs);\n      if (! abbrev)\n\t{\n\t  static unsigned int previous_failed_abbrev = -1U;\n\n\t  /* Avoid multiple reports of the same missing abbrev.  */\n\t  if (abbrev_number != previous_failed_abbrev)\n\t    {\n\t      _bfd_error_handler\n\t\t(_(\"Dwarf Error: Could not find abbrev number %u.\"),\n\t\t abbrev_number);\n\t      previous_failed_abbrev = abbrev_number;\n\t    }\n\t  bfd_set_error (bfd_error_bad_value);\n\t  goto fail;\n\t}\n\n      var = NULL;\n      if (abbrev->tag == DW_TAG_subprogram\n\t  || abbrev->tag == DW_TAG_entry_point\n\t  || abbrev->tag == DW_TAG_inlined_subroutine)\n\t{\n\t  bfd_size_type amt = sizeof (struct funcinfo);\n\t  func = (struct funcinfo *) bfd_zalloc (abfd, amt);\n\t  if (func == NULL)\n\t    goto fail;\n\t  func->tag = abbrev->tag;\n\t  func->prev_func = unit->function_table;\n\t  unit->function_table = func;\n\t  unit->number_of_functions++;\n\t  BFD_ASSERT (!unit->cached);\n\n\t  if (func->tag == DW_TAG_inlined_subroutine)\n\t    for (i = nesting_level - 1; i >= 1; i--)\n\t      if (nested_funcs[i])\n\t\t{\n\t\t  func->caller_func = nested_funcs[i];\n\t\t  break;\n\t\t}\n\t  nested_funcs[nesting_level] = func;\n\t}\n      else\n\t{\n\t  func = NULL;\n\t  if (abbrev->tag == DW_TAG_variable)\n\t    {\n\t      bfd_size_type amt = sizeof (struct varinfo);\n\t      var = (struct varinfo *) bfd_zalloc (abfd, amt);\n\t      if (var == NULL)\n\t\tgoto fail;\n\t      var->tag = abbrev->tag;\n\t      var->stack = 1;\n\t      var->prev_var = unit->variable_table;\n\t      unit->variable_table = var;\n\t      /* PR 18205: Missing debug information can cause this\n\t\t var to be attached to an already cached unit.  */\n\t    }\n\n\t  /* No inline function in scope at this nesting level.  */\n\t  nested_funcs[nesting_level] = 0;\n\t}\n\n      for (i = 0; i < abbrev->num_attrs; ++i)\n\t{\n\t  info_ptr = read_attribute (&attr, &abbrev->attrs[i], unit, info_ptr, info_ptr_end);\n\t  if (info_ptr == NULL)\n\t    goto fail;\n\n\t  if (func)\n\t    {\n\t      switch (attr.name)\n\t\t{\n\t\tcase DW_AT_call_file:\n\t\t  func->caller_file = concat_filename (unit->line_table,\n\t\t\t\t\t\t       attr.u.val);\n\t\t  break;\n\n\t\tcase DW_AT_call_line:\n\t\t  func->caller_line = attr.u.val;\n\t\t  break;\n\n\t\tcase DW_AT_abstract_origin:\n\t\tcase DW_AT_specification:\n\t\t  func->name = find_abstract_instance_name (unit, &attr,\n\t\t\t\t\t\t\t    &func->is_linkage);\n\t\t  break;\n\n\t\tcase DW_AT_name:\n\t\t  /* Prefer DW_AT_MIPS_linkage_name or DW_AT_linkage_name\n\t\t     over DW_AT_name.  */\n\t\t  if (func->name == NULL && is_str_attr (attr.form))\n\t\t    {\n\t\t      func->name = attr.u.str;\n\t\t      if (non_mangled (unit->lang))\n\t\t\tfunc->is_linkage = TRUE;\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_linkage_name:\n\t\tcase DW_AT_MIPS_linkage_name:\n\t\t  /* PR 16949:  Corrupt debug info can place\n\t\t     non-string forms into these attributes.  */\n\t\t  if (is_str_attr (attr.form))\n\t\t    {\n\t\t      func->name = attr.u.str;\n\t\t      func->is_linkage = TRUE;\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_low_pc:\n\t\t  low_pc = attr.u.val;\n\t\t  break;\n\n\t\tcase DW_AT_high_pc:\n\t\t  high_pc = attr.u.val;\n\t\t  high_pc_relative = attr.form != DW_FORM_addr;\n\t\t  break;\n\n\t\tcase DW_AT_ranges:\n\t\t  if (!read_rangelist (unit, &func->arange, attr.u.val))\n\t\t    goto fail;\n\t\t  break;\n\n\t\tcase DW_AT_decl_file:\n\t\t  func->file = concat_filename (unit->line_table,\n\t\t\t\t\t\tattr.u.val);\n\t\t  break;\n\n\t\tcase DW_AT_decl_line:\n\t\t  func->line = attr.u.val;\n\t\t  break;\n\n\t\tdefault:\n\t\t  break;\n\t\t}\n\t    }\n\t  else if (var)\n\t    {\n\t      switch (attr.name)\n\t\t{\n\t\tcase DW_AT_name:\n\t\t  var->name = attr.u.str;\n\t\t  break;\n\n\t\tcase DW_AT_decl_file:\n\t\t  var->file = concat_filename (unit->line_table,\n\t\t\t\t\t       attr.u.val);\n\t\t  break;\n\n\t\tcase DW_AT_decl_line:\n\t\t  var->line = attr.u.val;\n\t\t  break;\n\n\t\tcase DW_AT_external:\n\t\t  if (attr.u.val != 0)\n\t\t    var->stack = 0;\n\t\t  break;\n\n\t\tcase DW_AT_location:\n\t\t  switch (attr.form)\n\t\t    {\n\t\t    case DW_FORM_block:\n\t\t    case DW_FORM_block1:\n\t\t    case DW_FORM_block2:\n\t\t    case DW_FORM_block4:\n\t\t    case DW_FORM_exprloc:\n\t\t      if (attr.u.blk->data != NULL\n\t\t\t  && *attr.u.blk->data == DW_OP_addr)\n\t\t\t{\n\t\t\t  var->stack = 0;\n\n\t\t\t  /* Verify that DW_OP_addr is the only opcode in the\n\t\t\t     location, in which case the block size will be 1\n\t\t\t     plus the address size.  */\n\t\t\t  /* ??? For TLS variables, gcc can emit\n\t\t\t     DW_OP_addr <addr> DW_OP_GNU_push_tls_address\n\t\t\t     which we don't handle here yet.  */\n\t\t\t  if (attr.u.blk->size == unit->addr_size + 1U)\n\t\t\t    var->addr = bfd_get (unit->addr_size * 8,\n\t\t\t\t\t\t unit->abfd,\n\t\t\t\t\t\t attr.u.blk->data + 1);\n\t\t\t}\n\t\t      break;\n\n\t\t    default:\n\t\t      break;\n\t\t    }\n\t\t  break;\n\n\t\tdefault:\n\t\t  break;\n\t\t}\n\t    }\n\t}\n\n      if (high_pc_relative)\n\thigh_pc += low_pc;\n\n      if (func && high_pc != 0)\n\t{\n\t  if (!arange_add (unit, &func->arange, low_pc, high_pc))\n\t    goto fail;\n\t}\n\n      if (abbrev->has_children)\n\t{\n\t  nesting_level++;\n\n\t  if (nesting_level >= nested_funcs_size)\n\t    {\n\t      struct funcinfo **tmp;\n\n\t      nested_funcs_size *= 2;\n\t      tmp = (struct funcinfo **)\n\t\tbfd_realloc (nested_funcs,\n\t\t\t     nested_funcs_size * sizeof (struct funcinfo *));\n\t      if (tmp == NULL)\n\t\tgoto fail;\n\t      nested_funcs = tmp;\n\t    }\n\t  nested_funcs[nesting_level] = 0;\n\t}\n    }\n\n  free (nested_funcs);\n  return TRUE;\n\n fail:\n  free (nested_funcs);\n  return FALSE;\n}",
        "func": "static bfd_boolean\nscan_unit_for_symbols (struct comp_unit *unit)\n{\n  bfd *abfd = unit->abfd;\n  bfd_byte *info_ptr = unit->first_child_die_ptr;\n  bfd_byte *info_ptr_end = unit->stash->info_ptr_end;\n  int nesting_level = 0;\n  struct nest_funcinfo {\n    struct funcinfo *func;\n  } *nested_funcs;\n  int nested_funcs_size;\n\n  /* Maintain a stack of in-scope functions and inlined functions, which we\n     can use to set the caller_func field.  */\n  nested_funcs_size = 32;\n  nested_funcs = (struct nest_funcinfo *)\n    bfd_malloc (nested_funcs_size * sizeof (*nested_funcs));\n  if (nested_funcs == NULL)\n    return FALSE;\n  nested_funcs[nesting_level].func = 0;\n\n  while (nesting_level >= 0)\n    {\n      unsigned int abbrev_number, bytes_read, i;\n      struct abbrev_info *abbrev;\n      struct attribute attr;\n      struct funcinfo *func;\n      struct varinfo *var;\n      bfd_vma low_pc = 0;\n      bfd_vma high_pc = 0;\n      bfd_boolean high_pc_relative = FALSE;\n\n      /* PR 17512: file: 9f405d9d.  */\n      if (info_ptr >= info_ptr_end)\n\tgoto fail;\n\n      abbrev_number = _bfd_safe_read_leb128 (abfd, info_ptr, &bytes_read,\n\t\t\t\t\t     FALSE, info_ptr_end);\n      info_ptr += bytes_read;\n\n      if (! abbrev_number)\n\t{\n\t  nesting_level--;\n\t  continue;\n\t}\n\n      abbrev = lookup_abbrev (abbrev_number, unit->abbrevs);\n      if (! abbrev)\n\t{\n\t  static unsigned int previous_failed_abbrev = -1U;\n\n\t  /* Avoid multiple reports of the same missing abbrev.  */\n\t  if (abbrev_number != previous_failed_abbrev)\n\t    {\n\t      _bfd_error_handler\n\t\t(_(\"Dwarf Error: Could not find abbrev number %u.\"),\n\t\t abbrev_number);\n\t      previous_failed_abbrev = abbrev_number;\n\t    }\n\t  bfd_set_error (bfd_error_bad_value);\n\t  goto fail;\n\t}\n\n      var = NULL;\n      if (abbrev->tag == DW_TAG_subprogram\n\t  || abbrev->tag == DW_TAG_entry_point\n\t  || abbrev->tag == DW_TAG_inlined_subroutine)\n\t{\n\t  bfd_size_type amt = sizeof (struct funcinfo);\n\t  func = (struct funcinfo *) bfd_zalloc (abfd, amt);\n\t  if (func == NULL)\n\t    goto fail;\n\t  func->tag = abbrev->tag;\n\t  func->prev_func = unit->function_table;\n\t  unit->function_table = func;\n\t  unit->number_of_functions++;\n\t  BFD_ASSERT (!unit->cached);\n\n\t  if (func->tag == DW_TAG_inlined_subroutine)\n\t    for (i = nesting_level; i-- != 0; )\n\t      if (nested_funcs[i].func)\n\t\t{\n\t\t  func->caller_func = nested_funcs[i].func;\n\t\t  break;\n\t\t}\n\t  nested_funcs[nesting_level].func = func;\n\t}\n      else\n\t{\n\t  func = NULL;\n\t  if (abbrev->tag == DW_TAG_variable)\n\t    {\n\t      bfd_size_type amt = sizeof (struct varinfo);\n\t      var = (struct varinfo *) bfd_zalloc (abfd, amt);\n\t      if (var == NULL)\n\t\tgoto fail;\n\t      var->tag = abbrev->tag;\n\t      var->stack = 1;\n\t      var->prev_var = unit->variable_table;\n\t      unit->variable_table = var;\n\t      /* PR 18205: Missing debug information can cause this\n\t\t var to be attached to an already cached unit.  */\n\t    }\n\n\t  /* No inline function in scope at this nesting level.  */\n\t  nested_funcs[nesting_level].func = 0;\n\t}\n\n      for (i = 0; i < abbrev->num_attrs; ++i)\n\t{\n\t  info_ptr = read_attribute (&attr, &abbrev->attrs[i],\n\t\t\t\t     unit, info_ptr, info_ptr_end);\n\t  if (info_ptr == NULL)\n\t    goto fail;\n\n\t  if (func)\n\t    {\n\t      switch (attr.name)\n\t\t{\n\t\tcase DW_AT_call_file:\n\t\t  func->caller_file = concat_filename (unit->line_table,\n\t\t\t\t\t\t       attr.u.val);\n\t\t  break;\n\n\t\tcase DW_AT_call_line:\n\t\t  func->caller_line = attr.u.val;\n\t\t  break;\n\n\t\tcase DW_AT_abstract_origin:\n\t\tcase DW_AT_specification:\n\t\t  if (!find_abstract_instance_name (unit, info_ptr, &attr,\n\t\t\t\t\t\t    &func->name,\n\t\t\t\t\t\t    &func->is_linkage))\n\t\t    goto fail;\n\t\t  break;\n\n\t\tcase DW_AT_name:\n\t\t  /* Prefer DW_AT_MIPS_linkage_name or DW_AT_linkage_name\n\t\t     over DW_AT_name.  */\n\t\t  if (func->name == NULL && is_str_attr (attr.form))\n\t\t    {\n\t\t      func->name = attr.u.str;\n\t\t      if (non_mangled (unit->lang))\n\t\t\tfunc->is_linkage = TRUE;\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_linkage_name:\n\t\tcase DW_AT_MIPS_linkage_name:\n\t\t  /* PR 16949:  Corrupt debug info can place\n\t\t     non-string forms into these attributes.  */\n\t\t  if (is_str_attr (attr.form))\n\t\t    {\n\t\t      func->name = attr.u.str;\n\t\t      func->is_linkage = TRUE;\n\t\t    }\n\t\t  break;\n\n\t\tcase DW_AT_low_pc:\n\t\t  low_pc = attr.u.val;\n\t\t  break;\n\n\t\tcase DW_AT_high_pc:\n\t\t  high_pc = attr.u.val;\n\t\t  high_pc_relative = attr.form != DW_FORM_addr;\n\t\t  break;\n\n\t\tcase DW_AT_ranges:\n\t\t  if (!read_rangelist (unit, &func->arange, attr.u.val))\n\t\t    goto fail;\n\t\t  break;\n\n\t\tcase DW_AT_decl_file:\n\t\t  func->file = concat_filename (unit->line_table,\n\t\t\t\t\t\tattr.u.val);\n\t\t  break;\n\n\t\tcase DW_AT_decl_line:\n\t\t  func->line = attr.u.val;\n\t\t  break;\n\n\t\tdefault:\n\t\t  break;\n\t\t}\n\t    }\n\t  else if (var)\n\t    {\n\t      switch (attr.name)\n\t\t{\n\t\tcase DW_AT_name:\n\t\t  var->name = attr.u.str;\n\t\t  break;\n\n\t\tcase DW_AT_decl_file:\n\t\t  var->file = concat_filename (unit->line_table,\n\t\t\t\t\t       attr.u.val);\n\t\t  break;\n\n\t\tcase DW_AT_decl_line:\n\t\t  var->line = attr.u.val;\n\t\t  break;\n\n\t\tcase DW_AT_external:\n\t\t  if (attr.u.val != 0)\n\t\t    var->stack = 0;\n\t\t  break;\n\n\t\tcase DW_AT_location:\n\t\t  switch (attr.form)\n\t\t    {\n\t\t    case DW_FORM_block:\n\t\t    case DW_FORM_block1:\n\t\t    case DW_FORM_block2:\n\t\t    case DW_FORM_block4:\n\t\t    case DW_FORM_exprloc:\n\t\t      if (attr.u.blk->data != NULL\n\t\t\t  && *attr.u.blk->data == DW_OP_addr)\n\t\t\t{\n\t\t\t  var->stack = 0;\n\n\t\t\t  /* Verify that DW_OP_addr is the only opcode in the\n\t\t\t     location, in which case the block size will be 1\n\t\t\t     plus the address size.  */\n\t\t\t  /* ??? For TLS variables, gcc can emit\n\t\t\t     DW_OP_addr <addr> DW_OP_GNU_push_tls_address\n\t\t\t     which we don't handle here yet.  */\n\t\t\t  if (attr.u.blk->size == unit->addr_size + 1U)\n\t\t\t    var->addr = bfd_get (unit->addr_size * 8,\n\t\t\t\t\t\t unit->abfd,\n\t\t\t\t\t\t attr.u.blk->data + 1);\n\t\t\t}\n\t\t      break;\n\n\t\t    default:\n\t\t      break;\n\t\t    }\n\t\t  break;\n\n\t\tdefault:\n\t\t  break;\n\t\t}\n\t    }\n\t}\n\n      if (high_pc_relative)\n\thigh_pc += low_pc;\n\n      if (func && high_pc != 0)\n\t{\n\t  if (!arange_add (unit, &func->arange, low_pc, high_pc))\n\t    goto fail;\n\t}\n\n      if (abbrev->has_children)\n\t{\n\t  nesting_level++;\n\n\t  if (nesting_level >= nested_funcs_size)\n\t    {\n\t      struct nest_funcinfo *tmp;\n\n\t      nested_funcs_size *= 2;\n\t      tmp = (struct nest_funcinfo *)\n\t\tbfd_realloc (nested_funcs,\n\t\t\t     nested_funcs_size * sizeof (*nested_funcs));\n\t      if (tmp == NULL)\n\t\tgoto fail;\n\t      nested_funcs = tmp;\n\t    }\n\t  nested_funcs[nesting_level].func = 0;\n\t}\n    }\n\n  free (nested_funcs);\n  return TRUE;\n\n fail:\n  free (nested_funcs);\n  return FALSE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,20 +4,22 @@\n   bfd *abfd = unit->abfd;\n   bfd_byte *info_ptr = unit->first_child_die_ptr;\n   bfd_byte *info_ptr_end = unit->stash->info_ptr_end;\n-  int nesting_level = 1;\n-  struct funcinfo **nested_funcs;\n+  int nesting_level = 0;\n+  struct nest_funcinfo {\n+    struct funcinfo *func;\n+  } *nested_funcs;\n   int nested_funcs_size;\n \n   /* Maintain a stack of in-scope functions and inlined functions, which we\n      can use to set the caller_func field.  */\n   nested_funcs_size = 32;\n-  nested_funcs = (struct funcinfo **)\n-    bfd_malloc (nested_funcs_size * sizeof (struct funcinfo *));\n+  nested_funcs = (struct nest_funcinfo *)\n+    bfd_malloc (nested_funcs_size * sizeof (*nested_funcs));\n   if (nested_funcs == NULL)\n     return FALSE;\n-  nested_funcs[nesting_level] = 0;\n-\n-  while (nesting_level)\n+  nested_funcs[nesting_level].func = 0;\n+\n+  while (nesting_level >= 0)\n     {\n       unsigned int abbrev_number, bytes_read, i;\n       struct abbrev_info *abbrev;\n@@ -75,13 +77,13 @@\n \t  BFD_ASSERT (!unit->cached);\n \n \t  if (func->tag == DW_TAG_inlined_subroutine)\n-\t    for (i = nesting_level - 1; i >= 1; i--)\n-\t      if (nested_funcs[i])\n+\t    for (i = nesting_level; i-- != 0; )\n+\t      if (nested_funcs[i].func)\n \t\t{\n-\t\t  func->caller_func = nested_funcs[i];\n+\t\t  func->caller_func = nested_funcs[i].func;\n \t\t  break;\n \t\t}\n-\t  nested_funcs[nesting_level] = func;\n+\t  nested_funcs[nesting_level].func = func;\n \t}\n       else\n \t{\n@@ -101,12 +103,13 @@\n \t    }\n \n \t  /* No inline function in scope at this nesting level.  */\n-\t  nested_funcs[nesting_level] = 0;\n+\t  nested_funcs[nesting_level].func = 0;\n \t}\n \n       for (i = 0; i < abbrev->num_attrs; ++i)\n \t{\n-\t  info_ptr = read_attribute (&attr, &abbrev->attrs[i], unit, info_ptr, info_ptr_end);\n+\t  info_ptr = read_attribute (&attr, &abbrev->attrs[i],\n+\t\t\t\t     unit, info_ptr, info_ptr_end);\n \t  if (info_ptr == NULL)\n \t    goto fail;\n \n@@ -125,8 +128,10 @@\n \n \t\tcase DW_AT_abstract_origin:\n \t\tcase DW_AT_specification:\n-\t\t  func->name = find_abstract_instance_name (unit, &attr,\n-\t\t\t\t\t\t\t    &func->is_linkage);\n+\t\t  if (!find_abstract_instance_name (unit, info_ptr, &attr,\n+\t\t\t\t\t\t    &func->name,\n+\t\t\t\t\t\t    &func->is_linkage))\n+\t\t    goto fail;\n \t\t  break;\n \n \t\tcase DW_AT_name:\n@@ -252,17 +257,17 @@\n \n \t  if (nesting_level >= nested_funcs_size)\n \t    {\n-\t      struct funcinfo **tmp;\n+\t      struct nest_funcinfo *tmp;\n \n \t      nested_funcs_size *= 2;\n-\t      tmp = (struct funcinfo **)\n+\t      tmp = (struct nest_funcinfo *)\n \t\tbfd_realloc (nested_funcs,\n-\t\t\t     nested_funcs_size * sizeof (struct funcinfo *));\n+\t\t\t     nested_funcs_size * sizeof (*nested_funcs));\n \t      if (tmp == NULL)\n \t\tgoto fail;\n \t      nested_funcs = tmp;\n \t    }\n-\t  nested_funcs[nesting_level] = 0;\n+\t  nested_funcs[nesting_level].func = 0;\n \t}\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "  int nesting_level = 1;",
                "  struct funcinfo **nested_funcs;",
                "  nested_funcs = (struct funcinfo **)",
                "    bfd_malloc (nested_funcs_size * sizeof (struct funcinfo *));",
                "  nested_funcs[nesting_level] = 0;",
                "",
                "  while (nesting_level)",
                "\t    for (i = nesting_level - 1; i >= 1; i--)",
                "\t      if (nested_funcs[i])",
                "\t\t  func->caller_func = nested_funcs[i];",
                "\t  nested_funcs[nesting_level] = func;",
                "\t  nested_funcs[nesting_level] = 0;",
                "\t  info_ptr = read_attribute (&attr, &abbrev->attrs[i], unit, info_ptr, info_ptr_end);",
                "\t\t  func->name = find_abstract_instance_name (unit, &attr,",
                "\t\t\t\t\t\t\t    &func->is_linkage);",
                "\t      struct funcinfo **tmp;",
                "\t      tmp = (struct funcinfo **)",
                "\t\t\t     nested_funcs_size * sizeof (struct funcinfo *));",
                "\t  nested_funcs[nesting_level] = 0;"
            ],
            "added_lines": [
                "  int nesting_level = 0;",
                "  struct nest_funcinfo {",
                "    struct funcinfo *func;",
                "  } *nested_funcs;",
                "  nested_funcs = (struct nest_funcinfo *)",
                "    bfd_malloc (nested_funcs_size * sizeof (*nested_funcs));",
                "  nested_funcs[nesting_level].func = 0;",
                "",
                "  while (nesting_level >= 0)",
                "\t    for (i = nesting_level; i-- != 0; )",
                "\t      if (nested_funcs[i].func)",
                "\t\t  func->caller_func = nested_funcs[i].func;",
                "\t  nested_funcs[nesting_level].func = func;",
                "\t  nested_funcs[nesting_level].func = 0;",
                "\t  info_ptr = read_attribute (&attr, &abbrev->attrs[i],",
                "\t\t\t\t     unit, info_ptr, info_ptr_end);",
                "\t\t  if (!find_abstract_instance_name (unit, info_ptr, &attr,",
                "\t\t\t\t\t\t    &func->name,",
                "\t\t\t\t\t\t    &func->is_linkage))",
                "\t\t    goto fail;",
                "\t      struct nest_funcinfo *tmp;",
                "\t      tmp = (struct nest_funcinfo *)",
                "\t\t\t     nested_funcs_size * sizeof (*nested_funcs));",
                "\t  nested_funcs[nesting_level].func = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-15024",
        "func_name": "binutils-gdb/find_abstract_instance_name",
        "description": "find_abstract_instance_name in dwarf2.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (infinite recursion and application crash) via a crafted ELF file.",
        "git_url": "https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=52a93b95ec0771c97e26f0bb28630a271a667bd2",
        "commit_title": "",
        "commit_text": "PR22187, infinite loop in find_abstract_instance_name  This patch prevents the simple case of infinite recursion in find_abstract_instance_name by ensuring that the attributes being processed are not the same as the previous call.  The patch also does a little cleanup, and leaves in place some changes to the nested_funcs array that I made when I wrongly thought looping might occur in scan_unit_for_symbols.  \tPR 22187 \t* dwarf2.c (find_abstract_instance_name): Add orig_info_ptr and \tpname param.  Return status.  Make name const.  Don't abort, \treturn an error.  Formatting.  Exit if current info_ptr matches \torig_info_ptr.  Update callers. \t(scan_unit_for_symbols): Start at nesting_level of zero.  Make \tnested_funcs an array of structs for extensibility.  Formatting. ",
        "func_before": "static char *\nfind_abstract_instance_name (struct comp_unit *unit,\n\t\t\t     struct attribute *attr_ptr,\n\t\t\t     bfd_boolean *is_linkage)\n{\n  bfd *abfd = unit->abfd;\n  bfd_byte *info_ptr;\n  bfd_byte *info_ptr_end;\n  unsigned int abbrev_number, bytes_read, i;\n  struct abbrev_info *abbrev;\n  bfd_uint64_t die_ref = attr_ptr->u.val;\n  struct attribute attr;\n  char *name = NULL;\n\n  /* DW_FORM_ref_addr can reference an entry in a different CU. It\n     is an offset from the .debug_info section, not the current CU.  */\n  if (attr_ptr->form == DW_FORM_ref_addr)\n    {\n      /* We only support DW_FORM_ref_addr within the same file, so\n\t any relocations should be resolved already.  */\n      if (!die_ref)\n\tabort ();\n\n      info_ptr = unit->sec_info_ptr + die_ref;\n      info_ptr_end = unit->end_ptr;\n\n      /* Now find the CU containing this pointer.  */\n      if (info_ptr >= unit->info_ptr_unit && info_ptr < unit->end_ptr)\n\t;\n      else\n\t{\n\t  /* Check other CUs to see if they contain the abbrev.  */\n\t  struct comp_unit * u;\n\n\t  for (u = unit->prev_unit; u != NULL; u = u->prev_unit)\n\t    if (info_ptr >= u->info_ptr_unit && info_ptr < u->end_ptr)\n\t      break;\n\n\t  if (u == NULL)\n\t    for (u = unit->next_unit; u != NULL; u = u->next_unit)\n\t      if (info_ptr >= u->info_ptr_unit && info_ptr < u->end_ptr)\n\t\tbreak;\n\n\t  if (u)\n\t    unit = u;\n\t  /* else FIXME: What do we do now ?  */\n\t}\n    }\n  else if (attr_ptr->form == DW_FORM_GNU_ref_alt)\n    {\n      info_ptr = read_alt_indirect_ref (unit, die_ref);\n      if (info_ptr == NULL)\n\t{\n\t  _bfd_error_handler\n\t    (_(\"Dwarf Error: Unable to read alt ref %llu.\"),\n\t     (long long) die_ref);\n\t  bfd_set_error (bfd_error_bad_value);\n\t  return NULL;\n\t}\n      info_ptr_end = unit->stash->alt_dwarf_info_buffer + unit->stash->alt_dwarf_info_size;\n\n      /* FIXME: Do we need to locate the correct CU, in a similar\n\t fashion to the code in the DW_FORM_ref_addr case above ?  */\n    }\n  else\n    {\n      info_ptr = unit->info_ptr_unit + die_ref;\n      info_ptr_end = unit->end_ptr;\n    }\n\n  abbrev_number = _bfd_safe_read_leb128 (abfd, info_ptr, &bytes_read,\n\t\t\t\t\t FALSE, info_ptr_end);\n  info_ptr += bytes_read;\n\n  if (abbrev_number)\n    {\n      abbrev = lookup_abbrev (abbrev_number, unit->abbrevs);\n      if (! abbrev)\n\t{\n\t  _bfd_error_handler\n\t    (_(\"Dwarf Error: Could not find abbrev number %u.\"), abbrev_number);\n\t  bfd_set_error (bfd_error_bad_value);\n\t}\n      else\n\t{\n\t  for (i = 0; i < abbrev->num_attrs; ++i)\n\t    {\n\t      info_ptr = read_attribute (&attr, &abbrev->attrs[i], unit,\n\t\t\t\t\t info_ptr, info_ptr_end);\n\t      if (info_ptr == NULL)\n\t\tbreak;\n\t      switch (attr.name)\n\t\t{\n\t\tcase DW_AT_name:\n\t\t  /* Prefer DW_AT_MIPS_linkage_name or DW_AT_linkage_name\n\t\t     over DW_AT_name.  */\n\t\t  if (name == NULL && is_str_attr (attr.form))\n\t\t    {\n\t\t      name = attr.u.str;\n\t\t      if (non_mangled (unit->lang))\n\t\t\t*is_linkage = TRUE;\n\t\t    }\n\t\t  break;\n\t\tcase DW_AT_specification:\n\t\t  name = find_abstract_instance_name (unit, &attr, is_linkage);\n\t\t  break;\n\t\tcase DW_AT_linkage_name:\n\t\tcase DW_AT_MIPS_linkage_name:\n\t\t  /* PR 16949:  Corrupt debug info can place\n\t\t     non-string forms into these attributes.  */\n\t\t  if (is_str_attr (attr.form))\n\t\t    {\n\t\t      name = attr.u.str;\n\t\t      *is_linkage = TRUE;\n\t\t    }\n\t\t  break;\n\t\tdefault:\n\t\t  break;\n\t\t}\n\t    }\n\t}\n    }\n  return name;\n}",
        "func": "static bfd_boolean\nfind_abstract_instance_name (struct comp_unit *unit,\n\t\t\t     bfd_byte *orig_info_ptr,\n\t\t\t     struct attribute *attr_ptr,\n\t\t\t     const char **pname,\n\t\t\t     bfd_boolean *is_linkage)\n{\n  bfd *abfd = unit->abfd;\n  bfd_byte *info_ptr;\n  bfd_byte *info_ptr_end;\n  unsigned int abbrev_number, bytes_read, i;\n  struct abbrev_info *abbrev;\n  bfd_uint64_t die_ref = attr_ptr->u.val;\n  struct attribute attr;\n  const char *name = NULL;\n\n  /* DW_FORM_ref_addr can reference an entry in a different CU. It\n     is an offset from the .debug_info section, not the current CU.  */\n  if (attr_ptr->form == DW_FORM_ref_addr)\n    {\n      /* We only support DW_FORM_ref_addr within the same file, so\n\t any relocations should be resolved already.  */\n      if (!die_ref)\n\t{\n\t  _bfd_error_handler\n\t    (_(\"Dwarf Error: Abstract instance DIE ref zero.\"));\n\t  bfd_set_error (bfd_error_bad_value);\n\t  return FALSE;\n\t}\n\n      info_ptr = unit->sec_info_ptr + die_ref;\n      info_ptr_end = unit->end_ptr;\n\n      /* Now find the CU containing this pointer.  */\n      if (info_ptr >= unit->info_ptr_unit && info_ptr < unit->end_ptr)\n\t;\n      else\n\t{\n\t  /* Check other CUs to see if they contain the abbrev.  */\n\t  struct comp_unit * u;\n\n\t  for (u = unit->prev_unit; u != NULL; u = u->prev_unit)\n\t    if (info_ptr >= u->info_ptr_unit && info_ptr < u->end_ptr)\n\t      break;\n\n\t  if (u == NULL)\n\t    for (u = unit->next_unit; u != NULL; u = u->next_unit)\n\t      if (info_ptr >= u->info_ptr_unit && info_ptr < u->end_ptr)\n\t\tbreak;\n\n\t  if (u)\n\t    unit = u;\n\t  /* else FIXME: What do we do now ?  */\n\t}\n    }\n  else if (attr_ptr->form == DW_FORM_GNU_ref_alt)\n    {\n      info_ptr = read_alt_indirect_ref (unit, die_ref);\n      if (info_ptr == NULL)\n\t{\n\t  _bfd_error_handler\n\t    (_(\"Dwarf Error: Unable to read alt ref %llu.\"),\n\t     (long long) die_ref);\n\t  bfd_set_error (bfd_error_bad_value);\n\t  return FALSE;\n\t}\n      info_ptr_end = (unit->stash->alt_dwarf_info_buffer\n\t\t      + unit->stash->alt_dwarf_info_size);\n\n      /* FIXME: Do we need to locate the correct CU, in a similar\n\t fashion to the code in the DW_FORM_ref_addr case above ?  */\n    }\n  else\n    {\n      info_ptr = unit->info_ptr_unit + die_ref;\n      info_ptr_end = unit->end_ptr;\n    }\n\n  abbrev_number = _bfd_safe_read_leb128 (abfd, info_ptr, &bytes_read,\n\t\t\t\t\t FALSE, info_ptr_end);\n  info_ptr += bytes_read;\n\n  if (abbrev_number)\n    {\n      abbrev = lookup_abbrev (abbrev_number, unit->abbrevs);\n      if (! abbrev)\n\t{\n\t  _bfd_error_handler\n\t    (_(\"Dwarf Error: Could not find abbrev number %u.\"), abbrev_number);\n\t  bfd_set_error (bfd_error_bad_value);\n\t  return FALSE;\n\t}\n      else\n\t{\n\t  for (i = 0; i < abbrev->num_attrs; ++i)\n\t    {\n\t      info_ptr = read_attribute (&attr, &abbrev->attrs[i], unit,\n\t\t\t\t\t info_ptr, info_ptr_end);\n\t      if (info_ptr == NULL)\n\t\tbreak;\n\t      /* It doesn't ever make sense for DW_AT_specification to\n\t\t refer to the same DIE.  Stop simple recursion.  */\n\t      if (info_ptr == orig_info_ptr)\n\t\t{\n\t\t  _bfd_error_handler\n\t\t    (_(\"Dwarf Error: Abstract instance recursion detected.\"));\n\t\t  bfd_set_error (bfd_error_bad_value);\n\t\t  return FALSE;\n\t\t}\n\t      switch (attr.name)\n\t\t{\n\t\tcase DW_AT_name:\n\t\t  /* Prefer DW_AT_MIPS_linkage_name or DW_AT_linkage_name\n\t\t     over DW_AT_name.  */\n\t\t  if (name == NULL && is_str_attr (attr.form))\n\t\t    {\n\t\t      name = attr.u.str;\n\t\t      if (non_mangled (unit->lang))\n\t\t\t*is_linkage = TRUE;\n\t\t    }\n\t\t  break;\n\t\tcase DW_AT_specification:\n\t\t  if (!find_abstract_instance_name (unit, info_ptr, &attr,\n\t\t\t\t\t\t    pname, is_linkage))\n\t\t    return FALSE;\n\t\t  break;\n\t\tcase DW_AT_linkage_name:\n\t\tcase DW_AT_MIPS_linkage_name:\n\t\t  /* PR 16949:  Corrupt debug info can place\n\t\t     non-string forms into these attributes.  */\n\t\t  if (is_str_attr (attr.form))\n\t\t    {\n\t\t      name = attr.u.str;\n\t\t      *is_linkage = TRUE;\n\t\t    }\n\t\t  break;\n\t\tdefault:\n\t\t  break;\n\t\t}\n\t    }\n\t}\n    }\n  *pname = name;\n  return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,8 @@\n-static char *\n+static bfd_boolean\n find_abstract_instance_name (struct comp_unit *unit,\n+\t\t\t     bfd_byte *orig_info_ptr,\n \t\t\t     struct attribute *attr_ptr,\n+\t\t\t     const char **pname,\n \t\t\t     bfd_boolean *is_linkage)\n {\n   bfd *abfd = unit->abfd;\n@@ -10,7 +12,7 @@\n   struct abbrev_info *abbrev;\n   bfd_uint64_t die_ref = attr_ptr->u.val;\n   struct attribute attr;\n-  char *name = NULL;\n+  const char *name = NULL;\n \n   /* DW_FORM_ref_addr can reference an entry in a different CU. It\n      is an offset from the .debug_info section, not the current CU.  */\n@@ -19,7 +21,12 @@\n       /* We only support DW_FORM_ref_addr within the same file, so\n \t any relocations should be resolved already.  */\n       if (!die_ref)\n-\tabort ();\n+\t{\n+\t  _bfd_error_handler\n+\t    (_(\"Dwarf Error: Abstract instance DIE ref zero.\"));\n+\t  bfd_set_error (bfd_error_bad_value);\n+\t  return FALSE;\n+\t}\n \n       info_ptr = unit->sec_info_ptr + die_ref;\n       info_ptr_end = unit->end_ptr;\n@@ -55,9 +62,10 @@\n \t    (_(\"Dwarf Error: Unable to read alt ref %llu.\"),\n \t     (long long) die_ref);\n \t  bfd_set_error (bfd_error_bad_value);\n-\t  return NULL;\n+\t  return FALSE;\n \t}\n-      info_ptr_end = unit->stash->alt_dwarf_info_buffer + unit->stash->alt_dwarf_info_size;\n+      info_ptr_end = (unit->stash->alt_dwarf_info_buffer\n+\t\t      + unit->stash->alt_dwarf_info_size);\n \n       /* FIXME: Do we need to locate the correct CU, in a similar\n \t fashion to the code in the DW_FORM_ref_addr case above ?  */\n@@ -80,6 +88,7 @@\n \t  _bfd_error_handler\n \t    (_(\"Dwarf Error: Could not find abbrev number %u.\"), abbrev_number);\n \t  bfd_set_error (bfd_error_bad_value);\n+\t  return FALSE;\n \t}\n       else\n \t{\n@@ -89,6 +98,15 @@\n \t\t\t\t\t info_ptr, info_ptr_end);\n \t      if (info_ptr == NULL)\n \t\tbreak;\n+\t      /* It doesn't ever make sense for DW_AT_specification to\n+\t\t refer to the same DIE.  Stop simple recursion.  */\n+\t      if (info_ptr == orig_info_ptr)\n+\t\t{\n+\t\t  _bfd_error_handler\n+\t\t    (_(\"Dwarf Error: Abstract instance recursion detected.\"));\n+\t\t  bfd_set_error (bfd_error_bad_value);\n+\t\t  return FALSE;\n+\t\t}\n \t      switch (attr.name)\n \t\t{\n \t\tcase DW_AT_name:\n@@ -102,7 +120,9 @@\n \t\t    }\n \t\t  break;\n \t\tcase DW_AT_specification:\n-\t\t  name = find_abstract_instance_name (unit, &attr, is_linkage);\n+\t\t  if (!find_abstract_instance_name (unit, info_ptr, &attr,\n+\t\t\t\t\t\t    pname, is_linkage))\n+\t\t    return FALSE;\n \t\t  break;\n \t\tcase DW_AT_linkage_name:\n \t\tcase DW_AT_MIPS_linkage_name:\n@@ -120,5 +140,6 @@\n \t    }\n \t}\n     }\n-  return name;\n+  *pname = name;\n+  return TRUE;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static char *",
                "  char *name = NULL;",
                "\tabort ();",
                "\t  return NULL;",
                "      info_ptr_end = unit->stash->alt_dwarf_info_buffer + unit->stash->alt_dwarf_info_size;",
                "\t\t  name = find_abstract_instance_name (unit, &attr, is_linkage);",
                "  return name;"
            ],
            "added_lines": [
                "static bfd_boolean",
                "\t\t\t     bfd_byte *orig_info_ptr,",
                "\t\t\t     const char **pname,",
                "  const char *name = NULL;",
                "\t{",
                "\t  _bfd_error_handler",
                "\t    (_(\"Dwarf Error: Abstract instance DIE ref zero.\"));",
                "\t  bfd_set_error (bfd_error_bad_value);",
                "\t  return FALSE;",
                "\t}",
                "\t  return FALSE;",
                "      info_ptr_end = (unit->stash->alt_dwarf_info_buffer",
                "\t\t      + unit->stash->alt_dwarf_info_size);",
                "\t  return FALSE;",
                "\t      /* It doesn't ever make sense for DW_AT_specification to",
                "\t\t refer to the same DIE.  Stop simple recursion.  */",
                "\t      if (info_ptr == orig_info_ptr)",
                "\t\t{",
                "\t\t  _bfd_error_handler",
                "\t\t    (_(\"Dwarf Error: Abstract instance recursion detected.\"));",
                "\t\t  bfd_set_error (bfd_error_bad_value);",
                "\t\t  return FALSE;",
                "\t\t}",
                "\t\t  if (!find_abstract_instance_name (unit, info_ptr, &attr,",
                "\t\t\t\t\t\t    pname, is_linkage))",
                "\t\t    return FALSE;",
                "  *pname = name;",
                "  return TRUE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-15908",
        "func_name": "systemd/dns_packet_read_type_window",
        "description": "In systemd 223 through 235, a remote DNS server can respond with a custom crafted DNS NSEC resource record to trigger an infinite loop in the dns_packet_read_type_window() function of the 'systemd-resolved' service and cause a DoS of the affected service.",
        "git_url": "https://github.com/systemd/systemd/commit/9f939335a07085aa9a9663efd1dca06ef6405d62",
        "commit_title": "resolved: fix loop on packets with pseudo dns types",
        "commit_text": " Reported by Karim Hossen & Thomas Imbert from Sogeti ESEC R&D.  https://bugs.launchpad.net/ubuntu/+source/systemd/+bug/1725351",
        "func_before": "static int dns_packet_read_type_window(DnsPacket *p, Bitmap **types, size_t *start) {\n        uint8_t window;\n        uint8_t length;\n        const uint8_t *bitmap;\n        uint8_t bit = 0;\n        unsigned i;\n        bool found = false;\n        _cleanup_(rewind_dns_packet) DnsPacketRewinder rewinder;\n        int r;\n\n        assert(p);\n        assert(types);\n        INIT_REWINDER(rewinder, p);\n\n        r = bitmap_ensure_allocated(types);\n        if (r < 0)\n                return r;\n\n        r = dns_packet_read_uint8(p, &window, NULL);\n        if (r < 0)\n                return r;\n\n        r = dns_packet_read_uint8(p, &length, NULL);\n        if (r < 0)\n                return r;\n\n        if (length == 0 || length > 32)\n                return -EBADMSG;\n\n        r = dns_packet_read(p, length, (const void **)&bitmap, NULL);\n        if (r < 0)\n                return r;\n\n        for (i = 0; i < length; i++) {\n                uint8_t bitmask = 1 << 7;\n\n                if (!bitmap[i]) {\n                        found = false;\n                        bit += 8;\n                        continue;\n                }\n\n                found = true;\n\n                while (bitmask) {\n                        if (bitmap[i] & bitmask) {\n                                uint16_t n;\n\n                                n = (uint16_t) window << 8 | (uint16_t) bit;\n\n                                /* Ignore pseudo-types. see RFC4034 section 4.1.2 */\n                                if (dns_type_is_pseudo(n))\n                                        continue;\n\n                                r = bitmap_set(*types, n);\n                                if (r < 0)\n                                        return r;\n                        }\n\n                        bit++;\n                        bitmask >>= 1;\n                }\n        }\n\n        if (!found)\n                return -EBADMSG;\n\n        if (start)\n                *start = rewinder.saved_rindex;\n        CANCEL_REWINDER(rewinder);\n\n        return 0;\n}",
        "func": "static int dns_packet_read_type_window(DnsPacket *p, Bitmap **types, size_t *start) {\n        uint8_t window;\n        uint8_t length;\n        const uint8_t *bitmap;\n        uint8_t bit = 0;\n        unsigned i;\n        bool found = false;\n        _cleanup_(rewind_dns_packet) DnsPacketRewinder rewinder;\n        int r;\n\n        assert(p);\n        assert(types);\n        INIT_REWINDER(rewinder, p);\n\n        r = bitmap_ensure_allocated(types);\n        if (r < 0)\n                return r;\n\n        r = dns_packet_read_uint8(p, &window, NULL);\n        if (r < 0)\n                return r;\n\n        r = dns_packet_read_uint8(p, &length, NULL);\n        if (r < 0)\n                return r;\n\n        if (length == 0 || length > 32)\n                return -EBADMSG;\n\n        r = dns_packet_read(p, length, (const void **)&bitmap, NULL);\n        if (r < 0)\n                return r;\n\n        for (i = 0; i < length; i++) {\n                uint8_t bitmask = 1 << 7;\n\n                if (!bitmap[i]) {\n                        found = false;\n                        bit += 8;\n                        continue;\n                }\n\n                found = true;\n\n                for (; bitmask; bit++, bitmask >>= 1)\n                        if (bitmap[i] & bitmask) {\n                                uint16_t n;\n\n                                n = (uint16_t) window << 8 | (uint16_t) bit;\n\n                                /* Ignore pseudo-types. see RFC4034 section 4.1.2 */\n                                if (dns_type_is_pseudo(n))\n                                        continue;\n\n                                r = bitmap_set(*types, n);\n                                if (r < 0)\n                                        return r;\n                        }\n        }\n\n        if (!found)\n                return -EBADMSG;\n\n        if (start)\n                *start = rewinder.saved_rindex;\n        CANCEL_REWINDER(rewinder);\n\n        return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -42,7 +42,7 @@\n \n                 found = true;\n \n-                while (bitmask) {\n+                for (; bitmask; bit++, bitmask >>= 1)\n                         if (bitmap[i] & bitmask) {\n                                 uint16_t n;\n \n@@ -56,10 +56,6 @@\n                                 if (r < 0)\n                                         return r;\n                         }\n-\n-                        bit++;\n-                        bitmask >>= 1;\n-                }\n         }\n \n         if (!found)",
        "diff_line_info": {
            "deleted_lines": [
                "                while (bitmask) {",
                "",
                "                        bit++;",
                "                        bitmask >>= 1;",
                "                }"
            ],
            "added_lines": [
                "                for (; bitmask; bit++, bitmask >>= 1)"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14173",
        "func_name": "ImageMagick/ReadTXTImage",
        "description": "In the function ReadTXTImage() in coders/txt.c in ImageMagick 7.0.6-10, an integer overflow might occur for the addition operation \"GetQuantumRange(depth)+1\" when \"depth\" is large, producing a smaller value than expected. As a result, an infinite loop would occur for a crafted TXT file that claims a very large \"max_value\" value.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/50f54462076648ac2e36c3f58f4dadd4babbf1c9",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/713",
        "commit_text": "",
        "func_before": "static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    colorspace[MagickPathExtent],\n    text[MagickPathExtent];\n\n  Image\n    *image;\n\n  long\n    x_offset,\n    y_offset;\n\n  PixelInfo\n    pixel;\n\n  MagickBooleanType\n    status;\n\n  QuantumAny\n    range;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    count,\n    type,\n    y;\n\n  unsigned long\n    depth,\n    height,\n    max_value,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) ResetMagickMemory(text,0,sizeof(text));\n  (void) ReadBlobString(image,text);\n  if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    width=0;\n    height=0;\n    max_value=0;\n    *colorspace='\\0';\n    count=(ssize_t) sscanf(text+32,\"%lu,%lu,%lu,%s\",&width,&height,&max_value,\n      colorspace);\n    if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->columns=width;\n    image->rows=height;\n    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;\n    image->depth=depth;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    LocaleLower(colorspace);\n    i=(ssize_t) strlen(colorspace)-1;\n    image->alpha_trait=UndefinedPixelTrait;\n    if ((i > 0) && (colorspace[i] == 'a'))\n      {\n        colorspace[i]='\\0';\n        image->alpha_trait=BlendPixelTrait;\n      }\n    type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);\n    if (type < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    (void) SetImageBackgroundColor(image,exception);\n    (void) SetImageColorspace(image,(ColorspaceType) type,exception);\n    GetPixelInfo(image,&pixel);\n    range=GetQuantumRange(image->depth);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      double\n        alpha,\n        black,\n        blue,\n        green,\n        red;\n\n      red=0.0;\n      green=0.0;\n      blue=0.0;\n      black=0.0;\n      alpha=0.0;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        if (ReadBlobString(image,text) == (char *) NULL)\n          break;\n        switch (image->colorspace)\n        {\n          case GRAYColorspace:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\"%ld,%ld: (%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&alpha);\n                green=red;\n                blue=red;\n                break;\n              }\n            count=(ssize_t) sscanf(text,\"%ld,%ld: (%lf%*[%,]\",&x_offset,\n              &y_offset,&red);\n            green=red;\n            blue=red;\n            break;       \n          }\n          case CMYKColorspace:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&black,&alpha);\n                break;\n              }\n            count=(ssize_t) sscanf(text,\n              \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue,&black);\n            break;\n          }\n          default:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&alpha);\n                break;\n              }\n            count=(ssize_t) sscanf(text,\n              \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue);\n            break;       \n          }\n        }\n        if (strchr(text,'%') != (char *) NULL)\n          {\n            red*=0.01*range;\n            green*=0.01*range;\n            blue*=0.01*range;\n            black*=0.01*range;\n            alpha*=0.01*range;\n          }\n        if (image->colorspace == LabColorspace)\n          {\n            green+=(range+1)/2.0;\n            blue+=(range+1)/2.0;\n          }\n        pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),\n          range);\n        pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),\n          range);\n        pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),\n          range);\n        pixel.black=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (black+0.5),\n          range);\n        pixel.alpha=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (alpha+0.5),\n          range);\n        q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          continue;\n        SetPixelViaPixelInfo(image,&pixel,q);\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n    }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    (void) ReadBlobString(image,text);\n    if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    colorspace[MagickPathExtent],\n    text[MagickPathExtent];\n\n  Image\n    *image;\n\n  long\n    x_offset,\n    y_offset;\n\n  PixelInfo\n    pixel;\n\n  MagickBooleanType\n    status;\n\n  QuantumAny\n    range;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    count,\n    type,\n    y;\n\n  unsigned long\n    depth,\n    height,\n    max_value,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) ResetMagickMemory(text,0,sizeof(text));\n  (void) ReadBlobString(image,text);\n  if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    width=0;\n    height=0;\n    max_value=0;\n    *colorspace='\\0';\n    count=(ssize_t) sscanf(text+32,\"%lu,%lu,%lu,%s\",&width,&height,&max_value,\n      colorspace);\n    if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->columns=width;\n    image->rows=height;\n    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++)\n      if (depth >= 64)\n        break;\n    image->depth=depth;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    LocaleLower(colorspace);\n    i=(ssize_t) strlen(colorspace)-1;\n    image->alpha_trait=UndefinedPixelTrait;\n    if ((i > 0) && (colorspace[i] == 'a'))\n      {\n        colorspace[i]='\\0';\n        image->alpha_trait=BlendPixelTrait;\n      }\n    type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);\n    if (type < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    (void) SetImageBackgroundColor(image,exception);\n    (void) SetImageColorspace(image,(ColorspaceType) type,exception);\n    GetPixelInfo(image,&pixel);\n    range=GetQuantumRange(image->depth);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      double\n        alpha,\n        black,\n        blue,\n        green,\n        red;\n\n      red=0.0;\n      green=0.0;\n      blue=0.0;\n      black=0.0;\n      alpha=0.0;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        if (ReadBlobString(image,text) == (char *) NULL)\n          break;\n        switch (image->colorspace)\n        {\n          case GRAYColorspace:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\"%ld,%ld: (%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&alpha);\n                green=red;\n                blue=red;\n                break;\n              }\n            count=(ssize_t) sscanf(text,\"%ld,%ld: (%lf%*[%,]\",&x_offset,\n              &y_offset,&red);\n            green=red;\n            blue=red;\n            break;       \n          }\n          case CMYKColorspace:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&black,&alpha);\n                break;\n              }\n            count=(ssize_t) sscanf(text,\n              \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue,&black);\n            break;\n          }\n          default:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&alpha);\n                break;\n              }\n            count=(ssize_t) sscanf(text,\n              \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue);\n            break;       \n          }\n        }\n        if (strchr(text,'%') != (char *) NULL)\n          {\n            red*=0.01*range;\n            green*=0.01*range;\n            blue*=0.01*range;\n            black*=0.01*range;\n            alpha*=0.01*range;\n          }\n        if (image->colorspace == LabColorspace)\n          {\n            green+=(range+1)/2.0;\n            blue+=(range+1)/2.0;\n          }\n        pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),\n          range);\n        pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),\n          range);\n        pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),\n          range);\n        pixel.black=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (black+0.5),\n          range);\n        pixel.alpha=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (alpha+0.5),\n          range);\n        q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          continue;\n        SetPixelViaPixelInfo(image,&pixel,q);\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n    }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    (void) ReadBlobString(image,text);\n    if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -71,7 +71,9 @@\n       ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n     image->columns=width;\n     image->rows=height;\n-    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;\n+    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++)\n+      if (depth >= 64)\n+        break;\n     image->depth=depth;\n     status=SetImageExtent(image,image->columns,image->rows,exception);\n     if (status == MagickFalse)",
        "diff_line_info": {
            "deleted_lines": [
                "    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;"
            ],
            "added_lines": [
                "    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++)",
                "      if (depth >= 64)",
                "        break;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12989",
        "func_name": "the-tcpdump-group/tcpdump/resp_get_length",
        "description": "The RESP parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-resp.c:resp_get_length().",
        "git_url": "https://github.com/the-tcpdump-group/tcpdump/commit/db24063b01cba8e9d4d88b7d8ac70c9000c104e4",
        "commit_title": "CVE-2017-12989/RESP: Make sure resp_get_length() advances the pointer for invalid lengths.",
        "commit_text": " Make sure that it always sends *endp before returning and that, for invalid lengths where we don't like a character in the length string, what it sets *endp to is past the character in question, so we don't run the risk of infinitely looping (or doing something else random) if a character in the length is invalid.  This fixes an infinite loop discovered by Forcepoint's security researchers Otto Airamo & Antti Levomki.  Add a test using the capture file supplied by the reporter(s).",
        "func_before": "static int\nresp_get_length(netdissect_options *ndo, register const u_char *bp, int len, const u_char **endp)\n{\n    int result;\n    u_char c;\n    int saw_digit;\n    int neg;\n    int too_large;\n\n    if (len == 0)\n        goto trunc;\n    ND_TCHECK(*bp);\n    too_large = 0;\n    neg = 0;\n    if (*bp == '-') {\n        neg = 1;\n        bp++;\n        len--;\n    }\n    result = 0;\n    saw_digit = 0;\n\n    for (;;) {\n        if (len == 0)\n            goto trunc;\n        ND_TCHECK(*bp);\n        c = *bp;\n        if (!(c >= '0' && c <= '9')) {\n            if (!saw_digit)\n                goto invalid;\n            break;\n        }\n        c -= '0';\n        if (result > (INT_MAX / 10)) {\n            /* This will overflow an int when we multiply it by 10. */\n            too_large = 1;\n        } else {\n            result *= 10;\n            if (result == INT_MAX && c > (INT_MAX % 10)) {\n                /* This will overflow an int when we add c */\n                too_large = 1;\n            } else\n                result += c;\n        }\n        bp++;\n        len--;\n        saw_digit = 1;\n    }\n    if (!saw_digit)\n        goto invalid;\n\n    /*\n     * OK, the next thing should be \\r\\n.\n     */\n    if (len == 0)\n        goto trunc;\n    ND_TCHECK(*bp);\n    if (*bp != '\\r')\n        goto invalid;\n    bp++;\n    len--;\n    if (len == 0)\n        goto trunc;\n    ND_TCHECK(*bp);\n    if (*bp != '\\n')\n        goto invalid;\n    bp++;\n    len--;\n    *endp = bp;\n    if (neg) {\n        /* -1 means \"null\", anything else is invalid */\n        if (too_large || result != 1)\n            return (-4);\n        result = -1;\n    }\n    return (too_large ? -3 : result);\n\ntrunc:\n    return (-2);\n\ninvalid:\n    return (-5);\n}",
        "func": "static int\nresp_get_length(netdissect_options *ndo, register const u_char *bp, int len, const u_char **endp)\n{\n    int result;\n    u_char c;\n    int saw_digit;\n    int neg;\n    int too_large;\n\n    if (len == 0)\n        goto trunc;\n    ND_TCHECK(*bp);\n    too_large = 0;\n    neg = 0;\n    if (*bp == '-') {\n        neg = 1;\n        bp++;\n        len--;\n    }\n    result = 0;\n    saw_digit = 0;\n\n    for (;;) {\n        if (len == 0)\n            goto trunc;\n        ND_TCHECK(*bp);\n        c = *bp;\n        if (!(c >= '0' && c <= '9')) {\n            if (!saw_digit) {\n                bp++;\n                goto invalid;\n            }\n            break;\n        }\n        c -= '0';\n        if (result > (INT_MAX / 10)) {\n            /* This will overflow an int when we multiply it by 10. */\n            too_large = 1;\n        } else {\n            result *= 10;\n            if (result == INT_MAX && c > (INT_MAX % 10)) {\n                /* This will overflow an int when we add c */\n                too_large = 1;\n            } else\n                result += c;\n        }\n        bp++;\n        len--;\n        saw_digit = 1;\n    }\n    if (!saw_digit)\n        goto invalid;\n\n    /*\n     * OK, the next thing should be \\r\\n.\n     */\n    if (len == 0)\n        goto trunc;\n    ND_TCHECK(*bp);\n    if (*bp != '\\r') {\n        bp++;\n        goto invalid;\n    }\n    bp++;\n    len--;\n    if (len == 0)\n        goto trunc;\n    ND_TCHECK(*bp);\n    if (*bp != '\\n') {\n        bp++;\n        goto invalid;\n    }\n    bp++;\n    len--;\n    *endp = bp;\n    if (neg) {\n        /* -1 means \"null\", anything else is invalid */\n        if (too_large || result != 1)\n            return (-4);\n        result = -1;\n    }\n    return (too_large ? -3 : result);\n\ntrunc:\n    *endp = bp;\n    return (-2);\n\ninvalid:\n    *endp = bp;\n    return (-5);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,8 +26,10 @@\n         ND_TCHECK(*bp);\n         c = *bp;\n         if (!(c >= '0' && c <= '9')) {\n-            if (!saw_digit)\n+            if (!saw_digit) {\n+                bp++;\n                 goto invalid;\n+            }\n             break;\n         }\n         c -= '0';\n@@ -55,15 +57,19 @@\n     if (len == 0)\n         goto trunc;\n     ND_TCHECK(*bp);\n-    if (*bp != '\\r')\n+    if (*bp != '\\r') {\n+        bp++;\n         goto invalid;\n+    }\n     bp++;\n     len--;\n     if (len == 0)\n         goto trunc;\n     ND_TCHECK(*bp);\n-    if (*bp != '\\n')\n+    if (*bp != '\\n') {\n+        bp++;\n         goto invalid;\n+    }\n     bp++;\n     len--;\n     *endp = bp;\n@@ -76,8 +82,10 @@\n     return (too_large ? -3 : result);\n \n trunc:\n+    *endp = bp;\n     return (-2);\n \n invalid:\n+    *endp = bp;\n     return (-5);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "            if (!saw_digit)",
                "    if (*bp != '\\r')",
                "    if (*bp != '\\n')"
            ],
            "added_lines": [
                "            if (!saw_digit) {",
                "                bp++;",
                "            }",
                "    if (*bp != '\\r') {",
                "        bp++;",
                "    }",
                "    if (*bp != '\\n') {",
                "        bp++;",
                "    }",
                "    *endp = bp;",
                "    *endp = bp;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12990",
        "func_name": "the-tcpdump-group/tcpdump/ikev2_auth_print",
        "description": "The ISAKMP parser in tcpdump before 4.9.2 could enter an infinite loop due to bugs in print-isakmp.c, several functions.",
        "git_url": "https://github.com/the-tcpdump-group/tcpdump/commit/c2ef693866beae071a24b45c49f9674af1df4028",
        "commit_title": "CVE-2017-12990/Fix printing of ISAKMPv1 Notification payload data.",
        "commit_text": " The closest thing to a specification for the contents of the payload data is draft-ietf-ipsec-notifymsg-04, and nothing in there says that it is ever a complete ISAKMP message, so don't dissect types we don't have specific code for as a complete ISAKMP message.  While we're at it, fix a comment, and clean up printing of V1 Nonce, V2 Authentication payloads, and v2 Notice payloads.  This fixes an infinite loop discovered by Forcepoint's security researchers Otto Airamo & Antti Levomki.  Add a test using the capture file supplied by the reporter(s).",
        "func_before": "static const u_char *\nikev2_auth_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_auth a;\n\tconst char *v2_auth[]={ \"invalid\", \"rsasig\",\n\t\t\t\t\"shared-secret\", \"dsssig\" };\n\tconst u_char *authdata = (const u_char*)ext + sizeof(a);\n\tunsigned int len;\n\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&a, ext, sizeof(a));\n\tikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);\n\tlen = ntohs(a.h.len);\n\n\tND_PRINT((ndo,\" len=%d method=%s\", len-4,\n\t\t  STR_OR_ID(a.auth_method, v2_auth)));\n\n\tif (1 < ndo->ndo_vflag && 4 < len) {\n\t\tND_PRINT((ndo,\" authdata=(\"));\n\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n\t\t\tgoto trunc;\n\t\tND_PRINT((ndo,\") \"));\n\t} else if(ndo->ndo_vflag && 4 < len) {\n\t\tif(!ike_show_somedata(ndo, authdata, ep)) goto trunc;\n\t}\n\n\treturn (const u_char *)ext + len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}",
        "func": "static const u_char *\nikev2_auth_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_auth a;\n\tconst char *v2_auth[]={ \"invalid\", \"rsasig\",\n\t\t\t\t\"shared-secret\", \"dsssig\" };\n\tconst u_char *authdata = (const u_char*)ext + sizeof(a);\n\tunsigned int len;\n\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&a, ext, sizeof(a));\n\tikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);\n\tlen = ntohs(a.h.len);\n\n\t/*\n\t * Our caller has ensured that the length is >= 4.\n\t */\n\tND_PRINT((ndo,\" len=%u method=%s\", len-4,\n\t\t  STR_OR_ID(a.auth_method, v2_auth)));\n\tif (len > 4) {\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tND_PRINT((ndo, \" authdata=(\"));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n\t\t\t\tgoto trunc;\n\t\t\tND_PRINT((ndo, \") \"));\n\t\t} else if (ndo->ndo_vflag) {\n\t\t\tif (!ike_show_somedata(ndo, authdata, ep))\n\t\t\t\tgoto trunc;\n\t\t}\n\t}\n\n\treturn (const u_char *)ext + len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,16 +16,21 @@\n \tikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);\n \tlen = ntohs(a.h.len);\n \n-\tND_PRINT((ndo,\" len=%d method=%s\", len-4,\n+\t/*\n+\t * Our caller has ensured that the length is >= 4.\n+\t */\n+\tND_PRINT((ndo,\" len=%u method=%s\", len-4,\n \t\t  STR_OR_ID(a.auth_method, v2_auth)));\n-\n-\tif (1 < ndo->ndo_vflag && 4 < len) {\n-\t\tND_PRINT((ndo,\" authdata=(\"));\n-\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n-\t\t\tgoto trunc;\n-\t\tND_PRINT((ndo,\") \"));\n-\t} else if(ndo->ndo_vflag && 4 < len) {\n-\t\tif(!ike_show_somedata(ndo, authdata, ep)) goto trunc;\n+\tif (len > 4) {\n+\t\tif (ndo->ndo_vflag > 1) {\n+\t\t\tND_PRINT((ndo, \" authdata=(\"));\n+\t\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n+\t\t\t\tgoto trunc;\n+\t\t\tND_PRINT((ndo, \") \"));\n+\t\t} else if (ndo->ndo_vflag) {\n+\t\t\tif (!ike_show_somedata(ndo, authdata, ep))\n+\t\t\t\tgoto trunc;\n+\t\t}\n \t}\n \n \treturn (const u_char *)ext + len;",
        "diff_line_info": {
            "deleted_lines": [
                "\tND_PRINT((ndo,\" len=%d method=%s\", len-4,",
                "",
                "\tif (1 < ndo->ndo_vflag && 4 < len) {",
                "\t\tND_PRINT((ndo,\" authdata=(\"));",
                "\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))",
                "\t\t\tgoto trunc;",
                "\t\tND_PRINT((ndo,\") \"));",
                "\t} else if(ndo->ndo_vflag && 4 < len) {",
                "\t\tif(!ike_show_somedata(ndo, authdata, ep)) goto trunc;"
            ],
            "added_lines": [
                "\t/*",
                "\t * Our caller has ensured that the length is >= 4.",
                "\t */",
                "\tND_PRINT((ndo,\" len=%u method=%s\", len-4,",
                "\tif (len > 4) {",
                "\t\tif (ndo->ndo_vflag > 1) {",
                "\t\t\tND_PRINT((ndo, \" authdata=(\"));",
                "\t\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))",
                "\t\t\t\tgoto trunc;",
                "\t\t\tND_PRINT((ndo, \") \"));",
                "\t\t} else if (ndo->ndo_vflag) {",
                "\t\t\tif (!ike_show_somedata(ndo, authdata, ep))",
                "\t\t\t\tgoto trunc;",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12990",
        "func_name": "the-tcpdump-group/tcpdump/ikev1_n_print",
        "description": "The ISAKMP parser in tcpdump before 4.9.2 could enter an infinite loop due to bugs in print-isakmp.c, several functions.",
        "git_url": "https://github.com/the-tcpdump-group/tcpdump/commit/c2ef693866beae071a24b45c49f9674af1df4028",
        "commit_title": "CVE-2017-12990/Fix printing of ISAKMPv1 Notification payload data.",
        "commit_text": " The closest thing to a specification for the contents of the payload data is draft-ietf-ipsec-notifymsg-04, and nothing in there says that it is ever a complete ISAKMP message, so don't dissect types we don't have specific code for as a complete ISAKMP message.  While we're at it, fix a comment, and clean up printing of V1 Nonce, V2 Authentication payloads, and v2 Notice payloads.  This fixes an infinite loop discovered by Forcepoint's security researchers Otto Airamo & Antti Levomki.  Add a test using the capture file supplied by the reporter(s).",
        "func_before": "static const u_char *\nikev1_n_print(netdissect_options *ndo, u_char tpay _U_,\n\t      const struct isakmp_gen *ext, u_int item_len,\n\t      const u_char *ep, uint32_t phase, uint32_t doi0 _U_,\n\t      uint32_t proto0 _U_, int depth)\n{\n\tconst struct ikev1_pl_n *p;\n\tstruct ikev1_pl_n n;\n\tconst u_char *cp;\n\tconst u_char *ep2;\n\tuint32_t doi;\n\tuint32_t proto;\n\tstatic const char *notify_error_str[] = {\n\t\tNULL,\t\t\t\t\"INVALID-PAYLOAD-TYPE\",\n\t\t\"DOI-NOT-SUPPORTED\",\t\t\"SITUATION-NOT-SUPPORTED\",\n\t\t\"INVALID-COOKIE\",\t\t\"INVALID-MAJOR-VERSION\",\n\t\t\"INVALID-MINOR-VERSION\",\t\"INVALID-EXCHANGE-TYPE\",\n\t\t\"INVALID-FLAGS\",\t\t\"INVALID-MESSAGE-ID\",\n\t\t\"INVALID-PROTOCOL-ID\",\t\t\"INVALID-SPI\",\n\t\t\"INVALID-TRANSFORM-ID\",\t\t\"ATTRIBUTES-NOT-SUPPORTED\",\n\t\t\"NO-PROPOSAL-CHOSEN\",\t\t\"BAD-PROPOSAL-SYNTAX\",\n\t\t\"PAYLOAD-MALFORMED\",\t\t\"INVALID-KEY-INFORMATION\",\n\t\t\"INVALID-ID-INFORMATION\",\t\"INVALID-CERT-ENCODING\",\n\t\t\"INVALID-CERTIFICATE\",\t\t\"CERT-TYPE-UNSUPPORTED\",\n\t\t\"INVALID-CERT-AUTHORITY\",\t\"INVALID-HASH-INFORMATION\",\n\t\t\"AUTHENTICATION-FAILED\",\t\"INVALID-SIGNATURE\",\n\t\t\"ADDRESS-NOTIFICATION\",\t\t\"NOTIFY-SA-LIFETIME\",\n\t\t\"CERTIFICATE-UNAVAILABLE\",\t\"UNSUPPORTED-EXCHANGE-TYPE\",\n\t\t\"UNEQUAL-PAYLOAD-LENGTHS\",\n\t};\n\tstatic const char *ipsec_notify_error_str[] = {\n\t\t\"RESERVED\",\n\t};\n\tstatic const char *notify_status_str[] = {\n\t\t\"CONNECTED\",\n\t};\n\tstatic const char *ipsec_notify_status_str[] = {\n\t\t\"RESPONDER-LIFETIME\",\t\t\"REPLAY-STATUS\",\n\t\t\"INITIAL-CONTACT\",\n\t};\n/* NOTE: these macro must be called with x in proper range */\n\n/* 0 - 8191 */\n#define NOTIFY_ERROR_STR(x) \\\n\tSTR_OR_ID((x), notify_error_str)\n\n/* 8192 - 16383 */\n#define IPSEC_NOTIFY_ERROR_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 8192), ipsec_notify_error_str)\n\n/* 16384 - 24575 */\n#define NOTIFY_STATUS_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 16384), notify_status_str)\n\n/* 24576 - 32767 */\n#define IPSEC_NOTIFY_STATUS_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 24576), ipsec_notify_status_str)\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_N)));\n\n\tp = (const struct ikev1_pl_n *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&n, ext, sizeof(n));\n\tdoi = ntohl(n.doi);\n\tproto = n.prot_id;\n\tif (doi != 1) {\n\t\tND_PRINT((ndo,\" doi=%d\", doi));\n\t\tND_PRINT((ndo,\" proto=%d\", proto));\n\t\tif (ntohs(n.type) < 8192)\n\t\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_ERROR_STR(ntohs(n.type))));\n\t\telse if (ntohs(n.type) < 16384)\n\t\t\tND_PRINT((ndo,\" type=%s\", numstr(ntohs(n.type))));\n\t\telse if (ntohs(n.type) < 24576)\n\t\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_STATUS_STR(ntohs(n.type))));\n\t\telse\n\t\t\tND_PRINT((ndo,\" type=%s\", numstr(ntohs(n.type))));\n\t\tif (n.spi_size) {\n\t\t\tND_PRINT((ndo,\" spi=\"));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))\n\t\t\t\tgoto trunc;\n\t\t}\n\t\treturn (const u_char *)(p + 1) + n.spi_size;\n\t}\n\n\tND_PRINT((ndo,\" doi=ipsec\"));\n\tND_PRINT((ndo,\" proto=%s\", PROTOIDSTR(proto)));\n\tif (ntohs(n.type) < 8192)\n\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_ERROR_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 16384)\n\t\tND_PRINT((ndo,\" type=%s\", IPSEC_NOTIFY_ERROR_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 24576)\n\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_STATUS_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 32768)\n\t\tND_PRINT((ndo,\" type=%s\", IPSEC_NOTIFY_STATUS_STR(ntohs(n.type))));\n\telse\n\t\tND_PRINT((ndo,\" type=%s\", numstr(ntohs(n.type))));\n\tif (n.spi_size) {\n\t\tND_PRINT((ndo,\" spi=\"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))\n\t\t\tgoto trunc;\n\t}\n\n\tcp = (const u_char *)(p + 1) + n.spi_size;\n\tep2 = (const u_char *)p + item_len;\n\n\tif (cp < ep) {\n\t\tND_PRINT((ndo,\" orig=(\"));\n\t\tswitch (ntohs(n.type)) {\n\t\tcase IPSECDOI_NTYPE_RESPONDER_LIFETIME:\n\t\t    {\n\t\t\tconst struct attrmap *map = oakley_t_map;\n\t\t\tsize_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);\n\t\t\twhile (cp < ep && cp < ep2) {\n\t\t\t\tcp = ikev1_attrmap_print(ndo, cp,\n\t\t\t\t\t(ep < ep2) ? ep : ep2, map, nmap);\n\t\t\t}\n\t\t\tbreak;\n\t\t    }\n\t\tcase IPSECDOI_NTYPE_REPLAY_STATUS:\n\t\t\tND_PRINT((ndo,\"replay detection %sabled\",\n\t\t\t\t  EXTRACT_32BITS(cp) ? \"en\" : \"dis\"));\n\t\t\tbreak;\n\t\tcase ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN:\n\t\t\tif (ikev1_sub_print(ndo, ISAKMP_NPTYPE_SA,\n\t\t\t\t\t    (const struct isakmp_gen *)cp, ep, phase, doi, proto,\n\t\t\t\t\t    depth) == NULL)\n\t\t\t\treturn NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* NULL is dummy */\n\t\t\tisakmp_print(ndo, cp,\n\t\t\t\t     item_len - sizeof(*p) - n.spi_size,\n\t\t\t\t     NULL);\n\t\t}\n\t\tND_PRINT((ndo,\")\"));\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_N)));\n\treturn NULL;\n}",
        "func": "static const u_char *\nikev1_n_print(netdissect_options *ndo, u_char tpay _U_,\n\t      const struct isakmp_gen *ext, u_int item_len,\n\t      const u_char *ep, uint32_t phase _U_, uint32_t doi0 _U_,\n\t      uint32_t proto0 _U_, int depth _U_)\n{\n\tconst struct ikev1_pl_n *p;\n\tstruct ikev1_pl_n n;\n\tconst u_char *cp;\n\tconst u_char *ep2;\n\tuint32_t doi;\n\tuint32_t proto;\n\tstatic const char *notify_error_str[] = {\n\t\tNULL,\t\t\t\t\"INVALID-PAYLOAD-TYPE\",\n\t\t\"DOI-NOT-SUPPORTED\",\t\t\"SITUATION-NOT-SUPPORTED\",\n\t\t\"INVALID-COOKIE\",\t\t\"INVALID-MAJOR-VERSION\",\n\t\t\"INVALID-MINOR-VERSION\",\t\"INVALID-EXCHANGE-TYPE\",\n\t\t\"INVALID-FLAGS\",\t\t\"INVALID-MESSAGE-ID\",\n\t\t\"INVALID-PROTOCOL-ID\",\t\t\"INVALID-SPI\",\n\t\t\"INVALID-TRANSFORM-ID\",\t\t\"ATTRIBUTES-NOT-SUPPORTED\",\n\t\t\"NO-PROPOSAL-CHOSEN\",\t\t\"BAD-PROPOSAL-SYNTAX\",\n\t\t\"PAYLOAD-MALFORMED\",\t\t\"INVALID-KEY-INFORMATION\",\n\t\t\"INVALID-ID-INFORMATION\",\t\"INVALID-CERT-ENCODING\",\n\t\t\"INVALID-CERTIFICATE\",\t\t\"CERT-TYPE-UNSUPPORTED\",\n\t\t\"INVALID-CERT-AUTHORITY\",\t\"INVALID-HASH-INFORMATION\",\n\t\t\"AUTHENTICATION-FAILED\",\t\"INVALID-SIGNATURE\",\n\t\t\"ADDRESS-NOTIFICATION\",\t\t\"NOTIFY-SA-LIFETIME\",\n\t\t\"CERTIFICATE-UNAVAILABLE\",\t\"UNSUPPORTED-EXCHANGE-TYPE\",\n\t\t\"UNEQUAL-PAYLOAD-LENGTHS\",\n\t};\n\tstatic const char *ipsec_notify_error_str[] = {\n\t\t\"RESERVED\",\n\t};\n\tstatic const char *notify_status_str[] = {\n\t\t\"CONNECTED\",\n\t};\n\tstatic const char *ipsec_notify_status_str[] = {\n\t\t\"RESPONDER-LIFETIME\",\t\t\"REPLAY-STATUS\",\n\t\t\"INITIAL-CONTACT\",\n\t};\n/* NOTE: these macro must be called with x in proper range */\n\n/* 0 - 8191 */\n#define NOTIFY_ERROR_STR(x) \\\n\tSTR_OR_ID((x), notify_error_str)\n\n/* 8192 - 16383 */\n#define IPSEC_NOTIFY_ERROR_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 8192), ipsec_notify_error_str)\n\n/* 16384 - 24575 */\n#define NOTIFY_STATUS_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 16384), notify_status_str)\n\n/* 24576 - 32767 */\n#define IPSEC_NOTIFY_STATUS_STR(x) \\\n\tSTR_OR_ID((u_int)((x) - 24576), ipsec_notify_status_str)\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_N)));\n\n\tp = (const struct ikev1_pl_n *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&n, ext, sizeof(n));\n\tdoi = ntohl(n.doi);\n\tproto = n.prot_id;\n\tif (doi != 1) {\n\t\tND_PRINT((ndo,\" doi=%d\", doi));\n\t\tND_PRINT((ndo,\" proto=%d\", proto));\n\t\tif (ntohs(n.type) < 8192)\n\t\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_ERROR_STR(ntohs(n.type))));\n\t\telse if (ntohs(n.type) < 16384)\n\t\t\tND_PRINT((ndo,\" type=%s\", numstr(ntohs(n.type))));\n\t\telse if (ntohs(n.type) < 24576)\n\t\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_STATUS_STR(ntohs(n.type))));\n\t\telse\n\t\t\tND_PRINT((ndo,\" type=%s\", numstr(ntohs(n.type))));\n\t\tif (n.spi_size) {\n\t\t\tND_PRINT((ndo,\" spi=\"));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))\n\t\t\t\tgoto trunc;\n\t\t}\n\t\treturn (const u_char *)(p + 1) + n.spi_size;\n\t}\n\n\tND_PRINT((ndo,\" doi=ipsec\"));\n\tND_PRINT((ndo,\" proto=%s\", PROTOIDSTR(proto)));\n\tif (ntohs(n.type) < 8192)\n\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_ERROR_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 16384)\n\t\tND_PRINT((ndo,\" type=%s\", IPSEC_NOTIFY_ERROR_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 24576)\n\t\tND_PRINT((ndo,\" type=%s\", NOTIFY_STATUS_STR(ntohs(n.type))));\n\telse if (ntohs(n.type) < 32768)\n\t\tND_PRINT((ndo,\" type=%s\", IPSEC_NOTIFY_STATUS_STR(ntohs(n.type))));\n\telse\n\t\tND_PRINT((ndo,\" type=%s\", numstr(ntohs(n.type))));\n\tif (n.spi_size) {\n\t\tND_PRINT((ndo,\" spi=\"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))\n\t\t\tgoto trunc;\n\t}\n\n\tcp = (const u_char *)(p + 1) + n.spi_size;\n\tep2 = (const u_char *)p + item_len;\n\n\tif (cp < ep) {\n\t\tswitch (ntohs(n.type)) {\n\t\tcase IPSECDOI_NTYPE_RESPONDER_LIFETIME:\n\t\t    {\n\t\t\tconst struct attrmap *map = oakley_t_map;\n\t\t\tsize_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);\n\t\t\tND_PRINT((ndo,\" attrs=(\"));\n\t\t\twhile (cp < ep && cp < ep2) {\n\t\t\t\tcp = ikev1_attrmap_print(ndo, cp,\n\t\t\t\t\t(ep < ep2) ? ep : ep2, map, nmap);\n\t\t\t}\n\t\t\tND_PRINT((ndo,\")\"));\n\t\t\tbreak;\n\t\t    }\n\t\tcase IPSECDOI_NTYPE_REPLAY_STATUS:\n\t\t\tND_PRINT((ndo,\" status=(\"));\n\t\t\tND_PRINT((ndo,\"replay detection %sabled\",\n\t\t\t\t  EXTRACT_32BITS(cp) ? \"en\" : \"dis\"));\n\t\t\tND_PRINT((ndo,\")\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * XXX - fill in more types here; see, for example,\n\t\t\t * draft-ietf-ipsec-notifymsg-04.\n\t\t\t */\n\t\t\tif (ndo->ndo_vflag > 3) {\n\t\t\t\tND_PRINT((ndo,\" data=(\"));\n\t\t\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n\t\t\t\t\tgoto trunc;\n\t\t\t\tND_PRINT((ndo,\")\"));\n\t\t\t} else {\n\t\t\t\tif (!ike_show_somedata(ndo, cp, ep))\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_N)));\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,8 @@\n static const u_char *\n ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,\n \t      const struct isakmp_gen *ext, u_int item_len,\n-\t      const u_char *ep, uint32_t phase, uint32_t doi0 _U_,\n-\t      uint32_t proto0 _U_, int depth)\n+\t      const u_char *ep, uint32_t phase _U_, uint32_t doi0 _U_,\n+\t      uint32_t proto0 _U_, int depth _U_)\n {\n \tconst struct ikev1_pl_n *p;\n \tstruct ikev1_pl_n n;\n@@ -104,35 +104,41 @@\n \tep2 = (const u_char *)p + item_len;\n \n \tif (cp < ep) {\n-\t\tND_PRINT((ndo,\" orig=(\"));\n \t\tswitch (ntohs(n.type)) {\n \t\tcase IPSECDOI_NTYPE_RESPONDER_LIFETIME:\n \t\t    {\n \t\t\tconst struct attrmap *map = oakley_t_map;\n \t\t\tsize_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);\n+\t\t\tND_PRINT((ndo,\" attrs=(\"));\n \t\t\twhile (cp < ep && cp < ep2) {\n \t\t\t\tcp = ikev1_attrmap_print(ndo, cp,\n \t\t\t\t\t(ep < ep2) ? ep : ep2, map, nmap);\n \t\t\t}\n+\t\t\tND_PRINT((ndo,\")\"));\n \t\t\tbreak;\n \t\t    }\n \t\tcase IPSECDOI_NTYPE_REPLAY_STATUS:\n+\t\t\tND_PRINT((ndo,\" status=(\"));\n \t\t\tND_PRINT((ndo,\"replay detection %sabled\",\n \t\t\t\t  EXTRACT_32BITS(cp) ? \"en\" : \"dis\"));\n-\t\t\tbreak;\n-\t\tcase ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN:\n-\t\t\tif (ikev1_sub_print(ndo, ISAKMP_NPTYPE_SA,\n-\t\t\t\t\t    (const struct isakmp_gen *)cp, ep, phase, doi, proto,\n-\t\t\t\t\t    depth) == NULL)\n-\t\t\t\treturn NULL;\n+\t\t\tND_PRINT((ndo,\")\"));\n \t\t\tbreak;\n \t\tdefault:\n-\t\t\t/* NULL is dummy */\n-\t\t\tisakmp_print(ndo, cp,\n-\t\t\t\t     item_len - sizeof(*p) - n.spi_size,\n-\t\t\t\t     NULL);\n+\t\t\t/*\n+\t\t\t * XXX - fill in more types here; see, for example,\n+\t\t\t * draft-ietf-ipsec-notifymsg-04.\n+\t\t\t */\n+\t\t\tif (ndo->ndo_vflag > 3) {\n+\t\t\t\tND_PRINT((ndo,\" data=(\"));\n+\t\t\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n+\t\t\t\t\tgoto trunc;\n+\t\t\t\tND_PRINT((ndo,\")\"));\n+\t\t\t} else {\n+\t\t\t\tif (!ike_show_somedata(ndo, cp, ep))\n+\t\t\t\t\tgoto trunc;\n+\t\t\t}\n+\t\t\tbreak;\n \t\t}\n-\t\tND_PRINT((ndo,\")\"));\n \t}\n \treturn (const u_char *)ext + item_len;\n trunc:",
        "diff_line_info": {
            "deleted_lines": [
                "\t      const u_char *ep, uint32_t phase, uint32_t doi0 _U_,",
                "\t      uint32_t proto0 _U_, int depth)",
                "\t\tND_PRINT((ndo,\" orig=(\"));",
                "\t\t\tbreak;",
                "\t\tcase ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN:",
                "\t\t\tif (ikev1_sub_print(ndo, ISAKMP_NPTYPE_SA,",
                "\t\t\t\t\t    (const struct isakmp_gen *)cp, ep, phase, doi, proto,",
                "\t\t\t\t\t    depth) == NULL)",
                "\t\t\t\treturn NULL;",
                "\t\t\t/* NULL is dummy */",
                "\t\t\tisakmp_print(ndo, cp,",
                "\t\t\t\t     item_len - sizeof(*p) - n.spi_size,",
                "\t\t\t\t     NULL);",
                "\t\tND_PRINT((ndo,\")\"));"
            ],
            "added_lines": [
                "\t      const u_char *ep, uint32_t phase _U_, uint32_t doi0 _U_,",
                "\t      uint32_t proto0 _U_, int depth _U_)",
                "\t\t\tND_PRINT((ndo,\" attrs=(\"));",
                "\t\t\tND_PRINT((ndo,\")\"));",
                "\t\t\tND_PRINT((ndo,\" status=(\"));",
                "\t\t\tND_PRINT((ndo,\")\"));",
                "\t\t\t/*",
                "\t\t\t * XXX - fill in more types here; see, for example,",
                "\t\t\t * draft-ietf-ipsec-notifymsg-04.",
                "\t\t\t */",
                "\t\t\tif (ndo->ndo_vflag > 3) {",
                "\t\t\t\tND_PRINT((ndo,\" data=(\"));",
                "\t\t\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))",
                "\t\t\t\t\tgoto trunc;",
                "\t\t\t\tND_PRINT((ndo,\")\"));",
                "\t\t\t} else {",
                "\t\t\t\tif (!ike_show_somedata(ndo, cp, ep))",
                "\t\t\t\t\tgoto trunc;",
                "\t\t\t}",
                "\t\t\tbreak;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12990",
        "func_name": "the-tcpdump-group/tcpdump/ikev1_nonce_print",
        "description": "The ISAKMP parser in tcpdump before 4.9.2 could enter an infinite loop due to bugs in print-isakmp.c, several functions.",
        "git_url": "https://github.com/the-tcpdump-group/tcpdump/commit/c2ef693866beae071a24b45c49f9674af1df4028",
        "commit_title": "CVE-2017-12990/Fix printing of ISAKMPv1 Notification payload data.",
        "commit_text": " The closest thing to a specification for the contents of the payload data is draft-ietf-ipsec-notifymsg-04, and nothing in there says that it is ever a complete ISAKMP message, so don't dissect types we don't have specific code for as a complete ISAKMP message.  While we're at it, fix a comment, and clean up printing of V1 Nonce, V2 Authentication payloads, and v2 Notice payloads.  This fixes an infinite loop discovered by Forcepoint's security researchers Otto Airamo & Antti Levomki.  Add a test using the capture file supplied by the reporter(s).",
        "func_before": "static const u_char *\nikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t  const struct isakmp_gen *ext,\n\t\t  u_int item_len _U_,\n\t\t  const u_char *ep,\n\t\t  uint32_t phase _U_, uint32_t doi _U_,\n\t\t  uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" n len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t} else if (1 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!ike_show_somedata(ndo, (const u_char *)(const uint8_t *)(ext + 1), ep))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\treturn NULL;\n}",
        "func": "static const u_char *\nikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t  const struct isakmp_gen *ext,\n\t\t  u_int item_len _U_,\n\t\t  const u_char *ep,\n\t\t  uint32_t phase _U_, uint32_t doi _U_,\n\t\t  uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\t/*\n\t * Our caller has ensured that the length is >= 4.\n\t */\n\tND_PRINT((ndo,\" n len=%u\", ntohs(e.len) - 4));\n\tif (ntohs(e.len) > 4) {\n\t\tif (ndo->ndo_vflag > 2) {\n\t\t\tND_PRINT((ndo, \" \"));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\t\tgoto trunc;\n\t\t} else if (ndo->ndo_vflag > 1) {\n\t\t\tND_PRINT((ndo, \" \"));\n\t\t\tif (!ike_show_somedata(ndo, (const u_char *)(ext + 1), ep))\n\t\t\t\tgoto trunc;\n\t\t}\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,15 +12,20 @@\n \n \tND_TCHECK(*ext);\n \tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n-\tND_PRINT((ndo,\" n len=%d\", ntohs(e.len) - 4));\n-\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n-\t\tND_PRINT((ndo,\" \"));\n-\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n-\t\t\tgoto trunc;\n-\t} else if (1 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n-\t\tND_PRINT((ndo,\" \"));\n-\t\tif (!ike_show_somedata(ndo, (const u_char *)(const uint8_t *)(ext + 1), ep))\n-\t\t\tgoto trunc;\n+\t/*\n+\t * Our caller has ensured that the length is >= 4.\n+\t */\n+\tND_PRINT((ndo,\" n len=%u\", ntohs(e.len) - 4));\n+\tif (ntohs(e.len) > 4) {\n+\t\tif (ndo->ndo_vflag > 2) {\n+\t\t\tND_PRINT((ndo, \" \"));\n+\t\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n+\t\t\t\tgoto trunc;\n+\t\t} else if (ndo->ndo_vflag > 1) {\n+\t\t\tND_PRINT((ndo, \" \"));\n+\t\t\tif (!ike_show_somedata(ndo, (const u_char *)(ext + 1), ep))\n+\t\t\t\tgoto trunc;\n+\t\t}\n \t}\n \treturn (const u_char *)ext + ntohs(e.len);\n trunc:",
        "diff_line_info": {
            "deleted_lines": [
                "\tND_PRINT((ndo,\" n len=%d\", ntohs(e.len) - 4));",
                "\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {",
                "\t\tND_PRINT((ndo,\" \"));",
                "\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))",
                "\t\t\tgoto trunc;",
                "\t} else if (1 < ndo->ndo_vflag && 4 < ntohs(e.len)) {",
                "\t\tND_PRINT((ndo,\" \"));",
                "\t\tif (!ike_show_somedata(ndo, (const u_char *)(const uint8_t *)(ext + 1), ep))",
                "\t\t\tgoto trunc;"
            ],
            "added_lines": [
                "\t/*",
                "\t * Our caller has ensured that the length is >= 4.",
                "\t */",
                "\tND_PRINT((ndo,\" n len=%u\", ntohs(e.len) - 4));",
                "\tif (ntohs(e.len) > 4) {",
                "\t\tif (ndo->ndo_vflag > 2) {",
                "\t\t\tND_PRINT((ndo, \" \"));",
                "\t\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))",
                "\t\t\t\tgoto trunc;",
                "\t\t} else if (ndo->ndo_vflag > 1) {",
                "\t\t\tND_PRINT((ndo, \" \"));",
                "\t\t\tif (!ike_show_somedata(ndo, (const u_char *)(ext + 1), ep))",
                "\t\t\t\tgoto trunc;",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12990",
        "func_name": "the-tcpdump-group/tcpdump/ikev2_n_print",
        "description": "The ISAKMP parser in tcpdump before 4.9.2 could enter an infinite loop due to bugs in print-isakmp.c, several functions.",
        "git_url": "https://github.com/the-tcpdump-group/tcpdump/commit/c2ef693866beae071a24b45c49f9674af1df4028",
        "commit_title": "CVE-2017-12990/Fix printing of ISAKMPv1 Notification payload data.",
        "commit_text": " The closest thing to a specification for the contents of the payload data is draft-ietf-ipsec-notifymsg-04, and nothing in there says that it is ever a complete ISAKMP message, so don't dissect types we don't have specific code for as a complete ISAKMP message.  While we're at it, fix a comment, and clean up printing of V1 Nonce, V2 Authentication payloads, and v2 Notice payloads.  This fixes an infinite loop discovered by Forcepoint's security researchers Otto Airamo & Antti Levomki.  Add a test using the capture file supplied by the reporter(s).",
        "func_before": "static const u_char *\nikev2_n_print(netdissect_options *ndo, u_char tpay _U_,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tconst struct ikev2_n *p;\n\tstruct ikev2_n n;\n\tconst u_char *cp;\n\tu_char showspi, showdata, showsomedata;\n\tconst char *notify_name;\n\tuint32_t type;\n\n\tp = (const struct ikev2_n *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&n, ext, sizeof(n));\n\tikev2_pay_print(ndo, NPSTR(ISAKMP_NPTYPE_N), n.h.critical);\n\n\tshowspi = 1;\n\tshowdata = 0;\n\tshowsomedata=0;\n\tnotify_name=NULL;\n\n\tND_PRINT((ndo,\" prot_id=%s\", PROTOIDSTR(n.prot_id)));\n\n\ttype = ntohs(n.type);\n\n\t/* notify space is annoying sparse */\n\tswitch(type) {\n\tcase IV2_NOTIFY_UNSUPPORTED_CRITICAL_PAYLOAD:\n\t\tnotify_name = \"unsupported_critical_payload\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_IKE_SPI:\n\t\tnotify_name = \"invalid_ike_spi\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_MAJOR_VERSION:\n\t\tnotify_name = \"invalid_major_version\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_SYNTAX:\n\t\tnotify_name = \"invalid_syntax\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_MESSAGE_ID:\n\t\tnotify_name = \"invalid_message_id\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_SPI:\n\t\tnotify_name = \"invalid_spi\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_NO_PROPOSAL_CHOSEN:\n\t\tnotify_name = \"no_protocol_chosen\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_KE_PAYLOAD:\n\t\tnotify_name = \"invalid_ke_payload\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_AUTHENTICATION_FAILED:\n\t\tnotify_name = \"authentication_failed\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_SINGLE_PAIR_REQUIRED:\n\t\tnotify_name = \"single_pair_required\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_NO_ADDITIONAL_SAS:\n\t\tnotify_name = \"no_additional_sas\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INTERNAL_ADDRESS_FAILURE:\n\t\tnotify_name = \"internal_address_failure\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_FAILED_CP_REQUIRED:\n\t\tnotify_name = \"failed:cp_required\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_SELECTORS:\n\t\tnotify_name = \"invalid_selectors\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INITIAL_CONTACT:\n\t\tnotify_name = \"initial_contact\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_SET_WINDOW_SIZE:\n\t\tnotify_name = \"set_window_size\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_ADDITIONAL_TS_POSSIBLE:\n\t\tnotify_name = \"additional_ts_possible\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_IPCOMP_SUPPORTED:\n\t\tnotify_name = \"ipcomp_supported\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_NAT_DETECTION_SOURCE_IP:\n\t\tnotify_name = \"nat_detection_source_ip\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_NAT_DETECTION_DESTINATION_IP:\n\t\tnotify_name = \"nat_detection_destination_ip\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_COOKIE:\n\t\tnotify_name = \"cookie\";\n\t\tshowspi = 1;\n\t\tshowsomedata= 1;\n\t\tshowdata= 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_USE_TRANSPORT_MODE:\n\t\tnotify_name = \"use_transport_mode\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_HTTP_CERT_LOOKUP_SUPPORTED:\n\t\tnotify_name = \"http_cert_lookup_supported\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_REKEY_SA:\n\t\tnotify_name = \"rekey_sa\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_ESP_TFC_PADDING_NOT_SUPPORTED:\n\t\tnotify_name = \"tfc_padding_not_supported\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_NON_FIRST_FRAGMENTS_ALSO:\n\t\tnotify_name = \"non_first_fragment_also\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tif (type < 8192) {\n\t\t\tnotify_name=\"error\";\n\t\t} else if(type < 16384) {\n\t\t\tnotify_name=\"private-error\";\n\t\t} else if(type < 40960) {\n\t\t\tnotify_name=\"status\";\n\t\t} else {\n\t\t\tnotify_name=\"private-status\";\n\t\t}\n\t}\n\n\tif(notify_name) {\n\t\tND_PRINT((ndo,\" type=%u(%s)\", type, notify_name));\n\t}\n\n\n\tif (showspi && n.spi_size) {\n\t\tND_PRINT((ndo,\" spi=\"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))\n\t\t\tgoto trunc;\n\t}\n\n\tcp = (const u_char *)(p + 1) + n.spi_size;\n\n\tif(3 < ndo->ndo_vflag) {\n\t\tshowdata = 1;\n\t}\n\n\tif ((showdata || (showsomedata && ep-cp < 30)) && cp < ep) {\n\t\tND_PRINT((ndo,\" data=(\"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n\t\t\tgoto trunc;\n\n\t\tND_PRINT((ndo,\")\"));\n\n\t} else if(showsomedata && cp < ep) {\n\t\tif(!ike_show_somedata(ndo, cp, ep)) goto trunc;\n\t}\n\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_N)));\n\treturn NULL;\n}",
        "func": "static const u_char *\nikev2_n_print(netdissect_options *ndo, u_char tpay _U_,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tconst struct ikev2_n *p;\n\tstruct ikev2_n n;\n\tconst u_char *cp;\n\tu_char showspi, showsomedata;\n\tconst char *notify_name;\n\tuint32_t type;\n\n\tp = (const struct ikev2_n *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&n, ext, sizeof(n));\n\tikev2_pay_print(ndo, NPSTR(ISAKMP_NPTYPE_N), n.h.critical);\n\n\tshowspi = 1;\n\tshowsomedata=0;\n\tnotify_name=NULL;\n\n\tND_PRINT((ndo,\" prot_id=%s\", PROTOIDSTR(n.prot_id)));\n\n\ttype = ntohs(n.type);\n\n\t/* notify space is annoying sparse */\n\tswitch(type) {\n\tcase IV2_NOTIFY_UNSUPPORTED_CRITICAL_PAYLOAD:\n\t\tnotify_name = \"unsupported_critical_payload\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_IKE_SPI:\n\t\tnotify_name = \"invalid_ike_spi\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_MAJOR_VERSION:\n\t\tnotify_name = \"invalid_major_version\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_SYNTAX:\n\t\tnotify_name = \"invalid_syntax\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_MESSAGE_ID:\n\t\tnotify_name = \"invalid_message_id\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_SPI:\n\t\tnotify_name = \"invalid_spi\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_NO_PROPOSAL_CHOSEN:\n\t\tnotify_name = \"no_protocol_chosen\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_KE_PAYLOAD:\n\t\tnotify_name = \"invalid_ke_payload\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_AUTHENTICATION_FAILED:\n\t\tnotify_name = \"authentication_failed\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_SINGLE_PAIR_REQUIRED:\n\t\tnotify_name = \"single_pair_required\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_NO_ADDITIONAL_SAS:\n\t\tnotify_name = \"no_additional_sas\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INTERNAL_ADDRESS_FAILURE:\n\t\tnotify_name = \"internal_address_failure\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_FAILED_CP_REQUIRED:\n\t\tnotify_name = \"failed:cp_required\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INVALID_SELECTORS:\n\t\tnotify_name = \"invalid_selectors\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_INITIAL_CONTACT:\n\t\tnotify_name = \"initial_contact\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_SET_WINDOW_SIZE:\n\t\tnotify_name = \"set_window_size\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_ADDITIONAL_TS_POSSIBLE:\n\t\tnotify_name = \"additional_ts_possible\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_IPCOMP_SUPPORTED:\n\t\tnotify_name = \"ipcomp_supported\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_NAT_DETECTION_SOURCE_IP:\n\t\tnotify_name = \"nat_detection_source_ip\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_NAT_DETECTION_DESTINATION_IP:\n\t\tnotify_name = \"nat_detection_destination_ip\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_COOKIE:\n\t\tnotify_name = \"cookie\";\n\t\tshowspi = 1;\n\t\tshowsomedata= 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_USE_TRANSPORT_MODE:\n\t\tnotify_name = \"use_transport_mode\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_HTTP_CERT_LOOKUP_SUPPORTED:\n\t\tnotify_name = \"http_cert_lookup_supported\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_REKEY_SA:\n\t\tnotify_name = \"rekey_sa\";\n\t\tshowspi = 1;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_ESP_TFC_PADDING_NOT_SUPPORTED:\n\t\tnotify_name = \"tfc_padding_not_supported\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tcase IV2_NOTIFY_NON_FIRST_FRAGMENTS_ALSO:\n\t\tnotify_name = \"non_first_fragment_also\";\n\t\tshowspi = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tif (type < 8192) {\n\t\t\tnotify_name=\"error\";\n\t\t} else if(type < 16384) {\n\t\t\tnotify_name=\"private-error\";\n\t\t} else if(type < 40960) {\n\t\t\tnotify_name=\"status\";\n\t\t} else {\n\t\t\tnotify_name=\"private-status\";\n\t\t}\n\t}\n\n\tif(notify_name) {\n\t\tND_PRINT((ndo,\" type=%u(%s)\", type, notify_name));\n\t}\n\n\n\tif (showspi && n.spi_size) {\n\t\tND_PRINT((ndo,\" spi=\"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))\n\t\t\tgoto trunc;\n\t}\n\n\tcp = (const u_char *)(p + 1) + n.spi_size;\n\n\tif (cp < ep) {\n\t\tif (ndo->ndo_vflag > 3 || (showsomedata && ep-cp < 30)) {\n\t\t\tND_PRINT((ndo,\" data=(\"));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n\t\t\t\tgoto trunc;\n\n\t\t\tND_PRINT((ndo,\")\"));\n\t\t} else if (showsomedata) {\n\t\t\tif (!ike_show_somedata(ndo, cp, ep))\n\t\t\t\tgoto trunc;\n\t\t}\n\t}\n\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_N)));\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,7 @@\n \tconst struct ikev2_n *p;\n \tstruct ikev2_n n;\n \tconst u_char *cp;\n-\tu_char showspi, showdata, showsomedata;\n+\tu_char showspi, showsomedata;\n \tconst char *notify_name;\n \tuint32_t type;\n \n@@ -18,7 +18,6 @@\n \tikev2_pay_print(ndo, NPSTR(ISAKMP_NPTYPE_N), n.h.critical);\n \n \tshowspi = 1;\n-\tshowdata = 0;\n \tshowsomedata=0;\n \tnotify_name=NULL;\n \n@@ -132,7 +131,6 @@\n \t\tnotify_name = \"cookie\";\n \t\tshowspi = 1;\n \t\tshowsomedata= 1;\n-\t\tshowdata= 0;\n \t\tbreak;\n \n \tcase IV2_NOTIFY_USE_TRANSPORT_MODE:\n@@ -185,19 +183,17 @@\n \n \tcp = (const u_char *)(p + 1) + n.spi_size;\n \n-\tif(3 < ndo->ndo_vflag) {\n-\t\tshowdata = 1;\n-\t}\n-\n-\tif ((showdata || (showsomedata && ep-cp < 30)) && cp < ep) {\n-\t\tND_PRINT((ndo,\" data=(\"));\n-\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n-\t\t\tgoto trunc;\n-\n-\t\tND_PRINT((ndo,\")\"));\n-\n-\t} else if(showsomedata && cp < ep) {\n-\t\tif(!ike_show_somedata(ndo, cp, ep)) goto trunc;\n+\tif (cp < ep) {\n+\t\tif (ndo->ndo_vflag > 3 || (showsomedata && ep-cp < 30)) {\n+\t\t\tND_PRINT((ndo,\" data=(\"));\n+\t\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n+\t\t\t\tgoto trunc;\n+\n+\t\t\tND_PRINT((ndo,\")\"));\n+\t\t} else if (showsomedata) {\n+\t\t\tif (!ike_show_somedata(ndo, cp, ep))\n+\t\t\t\tgoto trunc;\n+\t\t}\n \t}\n \n \treturn (const u_char *)ext + item_len;",
        "diff_line_info": {
            "deleted_lines": [
                "\tu_char showspi, showdata, showsomedata;",
                "\tshowdata = 0;",
                "\t\tshowdata= 0;",
                "\tif(3 < ndo->ndo_vflag) {",
                "\t\tshowdata = 1;",
                "\t}",
                "",
                "\tif ((showdata || (showsomedata && ep-cp < 30)) && cp < ep) {",
                "\t\tND_PRINT((ndo,\" data=(\"));",
                "\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))",
                "\t\t\tgoto trunc;",
                "",
                "\t\tND_PRINT((ndo,\")\"));",
                "",
                "\t} else if(showsomedata && cp < ep) {",
                "\t\tif(!ike_show_somedata(ndo, cp, ep)) goto trunc;"
            ],
            "added_lines": [
                "\tu_char showspi, showsomedata;",
                "\tif (cp < ep) {",
                "\t\tif (ndo->ndo_vflag > 3 || (showsomedata && ep-cp < 30)) {",
                "\t\t\tND_PRINT((ndo,\" data=(\"));",
                "\t\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))",
                "\t\t\t\tgoto trunc;",
                "",
                "\t\t\tND_PRINT((ndo,\")\"));",
                "\t\t} else if (showsomedata) {",
                "\t\t\tif (!ike_show_somedata(ndo, cp, ep))",
                "\t\t\t\tgoto trunc;",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12995",
        "func_name": "the-tcpdump-group/tcpdump/ns_nprint",
        "description": "The DNS parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-domain.c:ns_print().",
        "git_url": "https://github.com/the-tcpdump-group/tcpdump/commit/3a76fd7c95fced2c2f8c8148a9055c3a542eff29",
        "commit_title": "CVE-2017-12995/Check for DNS compression pointers that don't point backwards.",
        "commit_text": " This is what BIND 9.11.0-P2 does; it not only detects pointers that loop, as \"point backwards\" means \"point before anything we've processed so far, including what we're processing right now\", so the pointer can't point to itself (as that's what we're processing right now).  This fixes an infinite loop discovered by Forcepoint's security researchers Otto Airamo & Antti Levomki.  Add a test using the capture file supplied by the reporter(s).  Also, add some infinite-pointer-loop captures.  More checks should be done.  We might, for example, want to make sure the upper 2 bits of the label length/pointer byte are 00 or 11, and that if we encounter a pointer and jump backwards to what we think is a label the label ends before the beginning of the last label we processed, to make sure the pointer doesn't point backwards into the *middle* of a label, and also make sure the entire name is <= 255 bytes long.",
        "func_before": "const u_char *\nns_nprint(netdissect_options *ndo,\n          register const u_char *cp, register const u_char *bp)\n{\n\tregister u_int i, l;\n\tregister const u_char *rp = NULL;\n\tregister int compress = 0;\n\tint chars_processed;\n\tint elt;\n\tint data_size = ndo->ndo_snapend - bp;\n\n\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n\t\treturn(NULL);\n\tif (!ND_TTEST2(*cp, 1))\n\t\treturn(NULL);\n\tchars_processed = 1;\n\tif (((i = *cp++) & INDIR_MASK) != INDIR_MASK) {\n\t\tcompress = 0;\n\t\trp = cp + l;\n\t}\n\n\tif (i != 0)\n\t\twhile (i && cp < ndo->ndo_snapend) {\n\t\t\tif ((i & INDIR_MASK) == INDIR_MASK) {\n\t\t\t\tif (!compress) {\n\t\t\t\t\trp = cp + 1;\n\t\t\t\t\tcompress = 1;\n\t\t\t\t}\n\t\t\t\tif (!ND_TTEST2(*cp, 1))\n\t\t\t\t\treturn(NULL);\n\t\t\t\tcp = bp + (((i << 8) | *cp) & 0x3fff);\n\t\t\t\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n\t\t\t\t\treturn(NULL);\n\t\t\t\tif (!ND_TTEST2(*cp, 1))\n\t\t\t\t\treturn(NULL);\n\t\t\t\ti = *cp++;\n\t\t\t\tchars_processed++;\n\n\t\t\t\t/*\n\t\t\t\t * If we've looked at every character in\n\t\t\t\t * the message, this pointer will make\n\t\t\t\t * us look at some character again,\n\t\t\t\t * which means we're looping.\n\t\t\t\t */\n\t\t\t\tif (chars_processed >= data_size) {\n\t\t\t\t\tND_PRINT((ndo, \"<LOOP>\"));\n\t\t\t\t\treturn (NULL);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((i & INDIR_MASK) == EDNS0_MASK) {\n\t\t\t\telt = (i & ~INDIR_MASK);\n\t\t\t\tswitch(elt) {\n\t\t\t\tcase EDNS0_ELT_BITLABEL:\n\t\t\t\t\tif (blabel_print(ndo, cp) == NULL)\n\t\t\t\t\t\treturn (NULL);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* unknown ELT */\n\t\t\t\t\tND_PRINT((ndo, \"<ELT %d>\", elt));\n\t\t\t\t\treturn(NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (fn_printn(ndo, cp, l, ndo->ndo_snapend))\n\t\t\t\t\treturn(NULL);\n\t\t\t}\n\n\t\t\tcp += l;\n\t\t\tchars_processed += l;\n\t\t\tND_PRINT((ndo, \".\"));\n\t\t\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n\t\t\t\treturn(NULL);\n\t\t\tif (!ND_TTEST2(*cp, 1))\n\t\t\t\treturn(NULL);\n\t\t\ti = *cp++;\n\t\t\tchars_processed++;\n\t\t\tif (!compress)\n\t\t\t\trp += l + 1;\n\t\t}\n\telse\n\t\tND_PRINT((ndo, \".\"));\n\treturn (rp);\n}",
        "func": "const u_char *\nns_nprint(netdissect_options *ndo,\n          register const u_char *cp, register const u_char *bp)\n{\n\tregister u_int i, l;\n\tregister const u_char *rp = NULL;\n\tregister int compress = 0;\n\tint elt;\n\tu_int offset, max_offset;\n\n\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n\t\treturn(NULL);\n\tif (!ND_TTEST2(*cp, 1))\n\t\treturn(NULL);\n\tmax_offset = (u_int)(cp - bp);\n\tif (((i = *cp++) & INDIR_MASK) != INDIR_MASK) {\n\t\tcompress = 0;\n\t\trp = cp + l;\n\t}\n\n\tif (i != 0)\n\t\twhile (i && cp < ndo->ndo_snapend) {\n\t\t\tif ((i & INDIR_MASK) == INDIR_MASK) {\n\t\t\t\tif (!compress) {\n\t\t\t\t\trp = cp + 1;\n\t\t\t\t\tcompress = 1;\n\t\t\t\t}\n\t\t\t\tif (!ND_TTEST2(*cp, 1))\n\t\t\t\t\treturn(NULL);\n\t\t\t\toffset = (((i << 8) | *cp) & 0x3fff);\n\t\t\t\t/*\n\t\t\t\t * This must move backwards in the packet.\n\t\t\t\t * No RFC explicitly says that, but BIND's\n\t\t\t\t * name decompression code requires it,\n\t\t\t\t * as a way of preventing infinite loops\n\t\t\t\t * and other bad behavior, and it's probably\n\t\t\t\t * what was intended (compress by pointing\n\t\t\t\t * to domain name suffixes already seen in\n\t\t\t\t * the packet).\n\t\t\t\t */\n\t\t\t\tif (offset >= max_offset) {\n\t\t\t\t\tND_PRINT((ndo, \"<BAD PTR>\"));\n\t\t\t\t\treturn(NULL);\n\t\t\t\t}\n\t\t\t\tmax_offset = offset;\n\t\t\t\tcp = bp + offset;\n\t\t\t\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n\t\t\t\t\treturn(NULL);\n\t\t\t\tif (!ND_TTEST2(*cp, 1))\n\t\t\t\t\treturn(NULL);\n\t\t\t\ti = *cp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((i & INDIR_MASK) == EDNS0_MASK) {\n\t\t\t\telt = (i & ~INDIR_MASK);\n\t\t\t\tswitch(elt) {\n\t\t\t\tcase EDNS0_ELT_BITLABEL:\n\t\t\t\t\tif (blabel_print(ndo, cp) == NULL)\n\t\t\t\t\t\treturn (NULL);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* unknown ELT */\n\t\t\t\t\tND_PRINT((ndo, \"<ELT %d>\", elt));\n\t\t\t\t\treturn(NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (fn_printn(ndo, cp, l, ndo->ndo_snapend))\n\t\t\t\t\treturn(NULL);\n\t\t\t}\n\n\t\t\tcp += l;\n\t\t\tND_PRINT((ndo, \".\"));\n\t\t\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n\t\t\t\treturn(NULL);\n\t\t\tif (!ND_TTEST2(*cp, 1))\n\t\t\t\treturn(NULL);\n\t\t\ti = *cp++;\n\t\t\tif (!compress)\n\t\t\t\trp += l + 1;\n\t\t}\n\telse\n\t\tND_PRINT((ndo, \".\"));\n\treturn (rp);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,15 +5,14 @@\n \tregister u_int i, l;\n \tregister const u_char *rp = NULL;\n \tregister int compress = 0;\n-\tint chars_processed;\n \tint elt;\n-\tint data_size = ndo->ndo_snapend - bp;\n+\tu_int offset, max_offset;\n \n \tif ((l = labellen(ndo, cp)) == (u_int)-1)\n \t\treturn(NULL);\n \tif (!ND_TTEST2(*cp, 1))\n \t\treturn(NULL);\n-\tchars_processed = 1;\n+\tmax_offset = (u_int)(cp - bp);\n \tif (((i = *cp++) & INDIR_MASK) != INDIR_MASK) {\n \t\tcompress = 0;\n \t\trp = cp + l;\n@@ -28,24 +27,28 @@\n \t\t\t\t}\n \t\t\t\tif (!ND_TTEST2(*cp, 1))\n \t\t\t\t\treturn(NULL);\n-\t\t\t\tcp = bp + (((i << 8) | *cp) & 0x3fff);\n+\t\t\t\toffset = (((i << 8) | *cp) & 0x3fff);\n+\t\t\t\t/*\n+\t\t\t\t * This must move backwards in the packet.\n+\t\t\t\t * No RFC explicitly says that, but BIND's\n+\t\t\t\t * name decompression code requires it,\n+\t\t\t\t * as a way of preventing infinite loops\n+\t\t\t\t * and other bad behavior, and it's probably\n+\t\t\t\t * what was intended (compress by pointing\n+\t\t\t\t * to domain name suffixes already seen in\n+\t\t\t\t * the packet).\n+\t\t\t\t */\n+\t\t\t\tif (offset >= max_offset) {\n+\t\t\t\t\tND_PRINT((ndo, \"<BAD PTR>\"));\n+\t\t\t\t\treturn(NULL);\n+\t\t\t\t}\n+\t\t\t\tmax_offset = offset;\n+\t\t\t\tcp = bp + offset;\n \t\t\t\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n \t\t\t\t\treturn(NULL);\n \t\t\t\tif (!ND_TTEST2(*cp, 1))\n \t\t\t\t\treturn(NULL);\n \t\t\t\ti = *cp++;\n-\t\t\t\tchars_processed++;\n-\n-\t\t\t\t/*\n-\t\t\t\t * If we've looked at every character in\n-\t\t\t\t * the message, this pointer will make\n-\t\t\t\t * us look at some character again,\n-\t\t\t\t * which means we're looping.\n-\t\t\t\t */\n-\t\t\t\tif (chars_processed >= data_size) {\n-\t\t\t\t\tND_PRINT((ndo, \"<LOOP>\"));\n-\t\t\t\t\treturn (NULL);\n-\t\t\t\t}\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tif ((i & INDIR_MASK) == EDNS0_MASK) {\n@@ -66,14 +69,12 @@\n \t\t\t}\n \n \t\t\tcp += l;\n-\t\t\tchars_processed += l;\n \t\t\tND_PRINT((ndo, \".\"));\n \t\t\tif ((l = labellen(ndo, cp)) == (u_int)-1)\n \t\t\t\treturn(NULL);\n \t\t\tif (!ND_TTEST2(*cp, 1))\n \t\t\t\treturn(NULL);\n \t\t\ti = *cp++;\n-\t\t\tchars_processed++;\n \t\t\tif (!compress)\n \t\t\t\trp += l + 1;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "\tint chars_processed;",
                "\tint data_size = ndo->ndo_snapend - bp;",
                "\tchars_processed = 1;",
                "\t\t\t\tcp = bp + (((i << 8) | *cp) & 0x3fff);",
                "\t\t\t\tchars_processed++;",
                "",
                "\t\t\t\t/*",
                "\t\t\t\t * If we've looked at every character in",
                "\t\t\t\t * the message, this pointer will make",
                "\t\t\t\t * us look at some character again,",
                "\t\t\t\t * which means we're looping.",
                "\t\t\t\t */",
                "\t\t\t\tif (chars_processed >= data_size) {",
                "\t\t\t\t\tND_PRINT((ndo, \"<LOOP>\"));",
                "\t\t\t\t\treturn (NULL);",
                "\t\t\t\t}",
                "\t\t\tchars_processed += l;",
                "\t\t\tchars_processed++;"
            ],
            "added_lines": [
                "\tu_int offset, max_offset;",
                "\tmax_offset = (u_int)(cp - bp);",
                "\t\t\t\toffset = (((i << 8) | *cp) & 0x3fff);",
                "\t\t\t\t/*",
                "\t\t\t\t * This must move backwards in the packet.",
                "\t\t\t\t * No RFC explicitly says that, but BIND's",
                "\t\t\t\t * name decompression code requires it,",
                "\t\t\t\t * as a way of preventing infinite loops",
                "\t\t\t\t * and other bad behavior, and it's probably",
                "\t\t\t\t * what was intended (compress by pointing",
                "\t\t\t\t * to domain name suffixes already seen in",
                "\t\t\t\t * the packet).",
                "\t\t\t\t */",
                "\t\t\t\tif (offset >= max_offset) {",
                "\t\t\t\t\tND_PRINT((ndo, \"<BAD PTR>\"));",
                "\t\t\t\t\treturn(NULL);",
                "\t\t\t\t}",
                "\t\t\t\tmax_offset = offset;",
                "\t\t\t\tcp = bp + offset;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12997",
        "func_name": "the-tcpdump-group/tcpdump/lldp_private_8021_print",
        "description": "The LLDP parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-lldp.c:lldp_private_8021_print().",
        "git_url": "https://github.com/the-tcpdump-group/tcpdump/commit/34cec721d39c76be1e0a600829a7b17bdfb832b6",
        "commit_title": "CVE-2017-12997/LLDP: Don't use an 8-bit loop counter.",
        "commit_text": " If you have a  \tfor (i = 0; i < N; i++)  loop, you'd better make sure that i is big enough to hold N - not N-1, N.  The TLV length here is 9 bits long, not 8 bits long, so an 8-bit loop counter will overflow and you can loop infinitely.  This fixes an infinite loop discovered by Forcepoint's security researchers Otto Airamo & Antti Levomki.  Add tests using the capture files supplied by the reporter(s).  Clean up the output a bit while we're at it.",
        "func_before": "static int\nlldp_private_8021_print(netdissect_options *ndo,\n                        const u_char *tptr, u_int tlv_len)\n{\n    int subtype, hexdump = FALSE;\n    u_int sublen;\n    u_int tval;\n    uint8_t i;\n\n    if (tlv_len < 4) {\n        return hexdump;\n    }\n    subtype = *(tptr+3);\n\n    ND_PRINT((ndo, \"\\n\\t  %s Subtype (%u)\",\n           tok2str(lldp_8021_subtype_values, \"unknown\", subtype),\n           subtype));\n\n    switch (subtype) {\n    case LLDP_PRIVATE_8021_SUBTYPE_PORT_VLAN_ID:\n        if (tlv_len < 6) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    port vlan id (PVID): %u\",\n               EXTRACT_16BITS(tptr + 4)));\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_VLAN_ID:\n        if (tlv_len < 7) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    port and protocol vlan id (PPVID): %u, flags [%s] (0x%02x)\",\n               EXTRACT_16BITS(tptr+5),\n\t       bittok2str(lldp_8021_port_protocol_id_values, \"none\", *(tptr+4)),\n\t       *(tptr + 4)));\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_VLAN_NAME:\n        if (tlv_len < 6) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    vlan id (VID): %u\", EXTRACT_16BITS(tptr + 4)));\n        if (tlv_len < 7) {\n            return hexdump;\n        }\n        sublen = *(tptr+6);\n        if (tlv_len < 7+sublen) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    vlan name: \"));\n        safeputs(ndo, tptr + 7, sublen);\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_IDENTITY:\n        if (tlv_len < 5) {\n            return hexdump;\n        }\n        sublen = *(tptr+4);\n        if (tlv_len < 5+sublen) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    protocol identity: \"));\n        safeputs(ndo, tptr + 5, sublen);\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION_LENGTH){\n        \treturn hexdump;\n        }\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \"\\n\\t    Pre-Priority CNPV Indicator\"));\n        ND_PRINT((ndo, \"\\n\\t     Priority : 0  1  2  3  4  5  6  7\"));\n        ND_PRINT((ndo, \"\\n\\t     Value    : \"));\n        for(i=0;i<NO_OF_BITS;i++)\n            ND_PRINT((ndo, \"%-2d \", (tval >> i) & 0x01));\n        tval=*(tptr+5);\n        ND_PRINT((ndo, \"\\n\\t    Pre-Priority Ready Indicator\"));\n        ND_PRINT((ndo, \"\\n\\t     Priority : 0  1  2  3  4  5  6  7\"));\n        ND_PRINT((ndo, \"\\n\\t     Value    : \"));\n        for(i=0;i<NO_OF_BITS;i++)\n            ND_PRINT((ndo, \"%-2d \", (tval >> i) & 0x01));\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION_LENGTH) {\n            return hexdump;\n        }\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \"\\n\\t    Willing:%d, CBS:%d, RES:%d, Max TCs:%d\",\n        \ttval >> 7, (tval >> 6) & 0x02, (tval >> 3) & 0x07, tval & 0x07));\n\n        /*Print Priority Assignment Table*/\n        print_ets_priority_assignment_table(ndo, tptr + 5);\n\n        /*Print TC Bandwidth Table*/\n        print_tc_bandwidth_table(ndo, tptr + 9);\n\n        /* Print TSA Assignment Table */\n        print_tsa_assignment_table(ndo, tptr + 17);\n\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION_LENGTH) {\n        \treturn hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    RES: %d\", *(tptr + 4)));\n        /*Print Priority Assignment Table */\n        print_ets_priority_assignment_table(ndo, tptr + 5);\n        /*Print TC Bandwidth Table */\n        print_tc_bandwidth_table(ndo, tptr + 9);\n        /* Print TSA Assignment Table */\n        print_tsa_assignment_table(ndo, tptr + 17);\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION_LENGTH) {\n            return hexdump;\n        }\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \"\\n\\t    Willing: %d, MBC: %d, RES: %d, PFC cap:%d \",\n        \ttval >> 7, (tval >> 6) & 0x01, (tval >> 4) & 0x03, (tval & 0x0f)));\n        ND_PRINT((ndo, \"\\n\\t    PFC Enable\"));\n        tval=*(tptr+5);\n        ND_PRINT((ndo, \"\\n\\t     Priority : 0  1  2  3  4  5  6  7\"));\n        ND_PRINT((ndo, \"\\n\\t     Value    : \"));\n        for(i=0;i<NO_OF_BITS;i++)\n            ND_PRINT((ndo, \"%-2d \", (tval >> i) & 0x01));\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    RES: %d\", *(tptr + 4)));\n        if(tlv_len<=LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH){\n        \treturn hexdump;\n        }\n        /*  Length of Application Priority Table */\n        sublen=tlv_len-5;\n        if(sublen%3!=0){\n        \treturn hexdump;\n        }\n        i=0;\n        ND_PRINT((ndo, \"\\n\\t    Application Priority Table\"));\n        while(i<sublen) {\n        \ttval=*(tptr+i+5);\n        \tND_PRINT((ndo, \"\\n\\t      Priority: %d, RES: %d, Sel: %d\",\n        \t\t tval >> 5, (tval >> 3) & 0x03, (tval & 0x07)));\n        \tND_PRINT((ndo, \"Protocol ID: %d\", EXTRACT_16BITS(tptr + i + 5)));\n        \ti=i+3;\n        }\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_EVB:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_EVB_LENGTH){\n        \treturn hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    EVB Bridge Status\"));\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \"\\n\\t      RES: %d, BGID: %d, RRCAP: %d, RRCTR: %d\",\n        \ttval >> 3, (tval >> 2) & 0x01, (tval >> 1) & 0x01, tval & 0x01));\n        ND_PRINT((ndo, \"\\n\\t    EVB Station Status\"));\n        tval=*(tptr+5);\n        ND_PRINT((ndo, \"\\n\\t      RES: %d, SGID: %d, RRREQ: %d,RRSTAT: %d\",\n        \ttval >> 4, (tval >> 3) & 0x01, (tval >> 2) & 0x01, tval & 0x03));\n        tval=*(tptr+6);\n        ND_PRINT((ndo, \"\\n\\t    R: %d, RTE: %d, \",tval >> 5, tval & 0x1f));\n        tval=*(tptr+7);\n        ND_PRINT((ndo, \"EVB Mode: %s [%d]\",\n        \ttok2str(lldp_evb_mode_values, \"unknown\", tval >> 6), tval >> 6));\n        ND_PRINT((ndo, \"\\n\\t    ROL: %d, RWD: %d, \", (tval >> 5) & 0x01, tval & 0x1f));\n        tval=*(tptr+8);\n        ND_PRINT((ndo, \"RES: %d, ROL: %d, RKA: %d\", tval >> 6, (tval >> 5) & 0x01, tval & 0x1f));\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_CDCP:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_CDCP_MIN_LENGTH){\n        \treturn hexdump;\n        }\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \"\\n\\t    Role: %d, RES: %d, Scomp: %d \",\n        \ttval >> 7, (tval >> 4) & 0x07, (tval >> 3) & 0x01));\n        ND_PRINT((ndo, \"ChnCap: %d\", EXTRACT_16BITS(tptr + 6) & 0x0fff));\n        sublen=tlv_len-8;\n        if(sublen%3!=0) {\n        \treturn hexdump;\n        }\n        i=0;\n        while(i<sublen) {\n        \ttval=EXTRACT_24BITS(tptr+i+8);\n        \tND_PRINT((ndo, \"\\n\\t    SCID: %d, SVID: %d\",\n        \t\ttval >> 12, tval & 0x000fff));\n        \ti=i+3;\n        }\n        break;\n\n    default:\n        hexdump = TRUE;\n        break;\n    }\n\n    return hexdump;\n}",
        "func": "static int\nlldp_private_8021_print(netdissect_options *ndo,\n                        const u_char *tptr, u_int tlv_len)\n{\n    int subtype, hexdump = FALSE;\n    u_int sublen;\n    u_int tval;\n    u_int i;\n\n    if (tlv_len < 4) {\n        return hexdump;\n    }\n    subtype = *(tptr+3);\n\n    ND_PRINT((ndo, \"\\n\\t  %s Subtype (%u)\",\n           tok2str(lldp_8021_subtype_values, \"unknown\", subtype),\n           subtype));\n\n    switch (subtype) {\n    case LLDP_PRIVATE_8021_SUBTYPE_PORT_VLAN_ID:\n        if (tlv_len < 6) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    port vlan id (PVID): %u\",\n               EXTRACT_16BITS(tptr + 4)));\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_VLAN_ID:\n        if (tlv_len < 7) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    port and protocol vlan id (PPVID): %u, flags [%s] (0x%02x)\",\n               EXTRACT_16BITS(tptr+5),\n\t       bittok2str(lldp_8021_port_protocol_id_values, \"none\", *(tptr+4)),\n\t       *(tptr + 4)));\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_VLAN_NAME:\n        if (tlv_len < 6) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    vlan id (VID): %u\", EXTRACT_16BITS(tptr + 4)));\n        if (tlv_len < 7) {\n            return hexdump;\n        }\n        sublen = *(tptr+6);\n        if (tlv_len < 7+sublen) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    vlan name: \"));\n        safeputs(ndo, tptr + 7, sublen);\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_IDENTITY:\n        if (tlv_len < 5) {\n            return hexdump;\n        }\n        sublen = *(tptr+4);\n        if (tlv_len < 5+sublen) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    protocol identity: \"));\n        safeputs(ndo, tptr + 5, sublen);\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION_LENGTH){\n        \treturn hexdump;\n        }\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \"\\n\\t    Pre-Priority CNPV Indicator\"));\n        ND_PRINT((ndo, \"\\n\\t     Priority : 0  1  2  3  4  5  6  7\"));\n        ND_PRINT((ndo, \"\\n\\t     Value    : \"));\n        for(i=0;i<NO_OF_BITS;i++)\n            ND_PRINT((ndo, \"%-2d \", (tval >> i) & 0x01));\n        tval=*(tptr+5);\n        ND_PRINT((ndo, \"\\n\\t    Pre-Priority Ready Indicator\"));\n        ND_PRINT((ndo, \"\\n\\t     Priority : 0  1  2  3  4  5  6  7\"));\n        ND_PRINT((ndo, \"\\n\\t     Value    : \"));\n        for(i=0;i<NO_OF_BITS;i++)\n            ND_PRINT((ndo, \"%-2d \", (tval >> i) & 0x01));\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION_LENGTH) {\n            return hexdump;\n        }\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \"\\n\\t    Willing:%d, CBS:%d, RES:%d, Max TCs:%d\",\n        \ttval >> 7, (tval >> 6) & 0x02, (tval >> 3) & 0x07, tval & 0x07));\n\n        /*Print Priority Assignment Table*/\n        print_ets_priority_assignment_table(ndo, tptr + 5);\n\n        /*Print TC Bandwidth Table*/\n        print_tc_bandwidth_table(ndo, tptr + 9);\n\n        /* Print TSA Assignment Table */\n        print_tsa_assignment_table(ndo, tptr + 17);\n\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION_LENGTH) {\n        \treturn hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    RES: %d\", *(tptr + 4)));\n        /*Print Priority Assignment Table */\n        print_ets_priority_assignment_table(ndo, tptr + 5);\n        /*Print TC Bandwidth Table */\n        print_tc_bandwidth_table(ndo, tptr + 9);\n        /* Print TSA Assignment Table */\n        print_tsa_assignment_table(ndo, tptr + 17);\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION_LENGTH) {\n            return hexdump;\n        }\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \"\\n\\t    Willing: %d, MBC: %d, RES: %d, PFC cap:%d \",\n        \ttval >> 7, (tval >> 6) & 0x01, (tval >> 4) & 0x03, (tval & 0x0f)));\n        ND_PRINT((ndo, \"\\n\\t    PFC Enable\"));\n        tval=*(tptr+5);\n        ND_PRINT((ndo, \"\\n\\t     Priority : 0  1  2  3  4  5  6  7\"));\n        ND_PRINT((ndo, \"\\n\\t     Value    : \"));\n        for(i=0;i<NO_OF_BITS;i++)\n            ND_PRINT((ndo, \"%-2d \", (tval >> i) & 0x01));\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH) {\n            return hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    RES: %d\", *(tptr + 4)));\n        if(tlv_len<=LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH){\n        \treturn hexdump;\n        }\n        /*  Length of Application Priority Table */\n        sublen=tlv_len-5;\n        if(sublen%3!=0){\n        \treturn hexdump;\n        }\n        i=0;\n        ND_PRINT((ndo, \"\\n\\t    Application Priority Table\"));\n        while(i<sublen) {\n        \ttval=*(tptr+i+5);\n        \tND_PRINT((ndo, \"\\n\\t      Priority: %u, RES: %u, Sel: %u, Protocol ID: %u\",\n        \t\t tval >> 5, (tval >> 3) & 0x03, (tval & 0x07),\n        \t\t EXTRACT_16BITS(tptr + i + 5)));\n        \ti=i+3;\n        }\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_EVB:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_EVB_LENGTH){\n        \treturn hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    EVB Bridge Status\"));\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \"\\n\\t      RES: %d, BGID: %d, RRCAP: %d, RRCTR: %d\",\n        \ttval >> 3, (tval >> 2) & 0x01, (tval >> 1) & 0x01, tval & 0x01));\n        ND_PRINT((ndo, \"\\n\\t    EVB Station Status\"));\n        tval=*(tptr+5);\n        ND_PRINT((ndo, \"\\n\\t      RES: %d, SGID: %d, RRREQ: %d,RRSTAT: %d\",\n        \ttval >> 4, (tval >> 3) & 0x01, (tval >> 2) & 0x01, tval & 0x03));\n        tval=*(tptr+6);\n        ND_PRINT((ndo, \"\\n\\t    R: %d, RTE: %d, \",tval >> 5, tval & 0x1f));\n        tval=*(tptr+7);\n        ND_PRINT((ndo, \"EVB Mode: %s [%d]\",\n        \ttok2str(lldp_evb_mode_values, \"unknown\", tval >> 6), tval >> 6));\n        ND_PRINT((ndo, \"\\n\\t    ROL: %d, RWD: %d, \", (tval >> 5) & 0x01, tval & 0x1f));\n        tval=*(tptr+8);\n        ND_PRINT((ndo, \"RES: %d, ROL: %d, RKA: %d\", tval >> 6, (tval >> 5) & 0x01, tval & 0x1f));\n        break;\n\n    case LLDP_PRIVATE_8021_SUBTYPE_CDCP:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_CDCP_MIN_LENGTH){\n        \treturn hexdump;\n        }\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \"\\n\\t    Role: %d, RES: %d, Scomp: %d \",\n        \ttval >> 7, (tval >> 4) & 0x07, (tval >> 3) & 0x01));\n        ND_PRINT((ndo, \"ChnCap: %d\", EXTRACT_16BITS(tptr + 6) & 0x0fff));\n        sublen=tlv_len-8;\n        if(sublen%3!=0) {\n        \treturn hexdump;\n        }\n        i=0;\n        while(i<sublen) {\n        \ttval=EXTRACT_24BITS(tptr+i+8);\n        \tND_PRINT((ndo, \"\\n\\t    SCID: %d, SVID: %d\",\n        \t\ttval >> 12, tval & 0x000fff));\n        \ti=i+3;\n        }\n        break;\n\n    default:\n        hexdump = TRUE;\n        break;\n    }\n\n    return hexdump;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n     int subtype, hexdump = FALSE;\n     u_int sublen;\n     u_int tval;\n-    uint8_t i;\n+    u_int i;\n \n     if (tlv_len < 4) {\n         return hexdump;\n@@ -141,9 +141,9 @@\n         ND_PRINT((ndo, \"\\n\\t    Application Priority Table\"));\n         while(i<sublen) {\n         \ttval=*(tptr+i+5);\n-        \tND_PRINT((ndo, \"\\n\\t      Priority: %d, RES: %d, Sel: %d\",\n-        \t\t tval >> 5, (tval >> 3) & 0x03, (tval & 0x07)));\n-        \tND_PRINT((ndo, \"Protocol ID: %d\", EXTRACT_16BITS(tptr + i + 5)));\n+        \tND_PRINT((ndo, \"\\n\\t      Priority: %u, RES: %u, Sel: %u, Protocol ID: %u\",\n+        \t\t tval >> 5, (tval >> 3) & 0x03, (tval & 0x07),\n+        \t\t EXTRACT_16BITS(tptr + i + 5)));\n         \ti=i+3;\n         }\n         break;",
        "diff_line_info": {
            "deleted_lines": [
                "    uint8_t i;",
                "        \tND_PRINT((ndo, \"\\n\\t      Priority: %d, RES: %d, Sel: %d\",",
                "        \t\t tval >> 5, (tval >> 3) & 0x03, (tval & 0x07)));",
                "        \tND_PRINT((ndo, \"Protocol ID: %d\", EXTRACT_16BITS(tptr + i + 5)));"
            ],
            "added_lines": [
                "    u_int i;",
                "        \tND_PRINT((ndo, \"\\n\\t      Priority: %u, RES: %u, Sel: %u, Protocol ID: %u\",",
                "        \t\t tval >> 5, (tval >> 3) & 0x03, (tval & 0x07),",
                "        \t\t EXTRACT_16BITS(tptr + i + 5)));"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14741",
        "func_name": "ImageMagick/ReadCAPTIONImage",
        "description": "The ReadCAPTIONImage function in coders/caption.c in ImageMagick 7.0.7-3 allows remote attackers to cause a denial of service (infinite loop) via a crafted font file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/bb11d07139efe0f5e4ce0e4afda32abdbe82fa9d",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/771",
        "commit_text": "",
        "func_before": "static Image *ReadCAPTIONImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    *caption,\n    geometry[MaxTextExtent],\n    *property,\n    *text;\n\n  const char\n    *gravity,\n    *option;\n\n  DrawInfo\n    *draw_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    split,\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    height,\n    width;\n\n  TypeMetric\n    metrics;\n\n  /*\n    Initialize Image structure.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  (void) ResetImagePage(image,\"0x0+0+0\");\n  /*\n    Format caption.\n  */\n  option=GetImageOption(image_info,\"filename\");\n  if (option == (const char *) NULL)\n    property=InterpretImageProperties(image_info,image,image_info->filename);\n  else\n    if (LocaleNCompare(option,\"caption:\",8) == 0)\n      property=InterpretImageProperties(image_info,image,option+8);\n    else\n      property=InterpretImageProperties(image_info,image,option);\n  (void) SetImageProperty(image,\"caption\",property);\n  property=DestroyString(property);\n  caption=ConstantString(GetImageProperty(image,\"caption\"));\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  (void) CloneString(&draw_info->text,caption);\n  gravity=GetImageOption(image_info,\"gravity\");\n  if (gravity != (char *) NULL)\n    draw_info->gravity=(GravityType) ParseCommandOption(MagickGravityOptions,\n      MagickFalse,gravity);\n  split=MagickFalse;\n  status=MagickTrue;\n  if (image->columns == 0)\n    {\n      text=AcquireString(caption);\n      i=FormatMagickCaption(image,draw_info,split,&metrics,&text);\n      (void) CloneString(&draw_info->text,text);\n      text=DestroyString(text);\n      (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",\n        -metrics.bounds.x1,metrics.ascent);\n      if (draw_info->gravity == UndefinedGravity)\n        (void) CloneString(&draw_info->geometry,geometry);\n      status=GetMultilineTypeMetrics(image,draw_info,&metrics);\n      width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);\n      image->columns=width;\n    }\n  if (image->rows == 0)\n    {\n      split=MagickTrue;\n      text=AcquireString(caption);\n      i=FormatMagickCaption(image,draw_info,split,&metrics,&text);\n      (void) CloneString(&draw_info->text,text);\n      text=DestroyString(text);\n      (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",\n        -metrics.bounds.x1,metrics.ascent);\n      if (draw_info->gravity == UndefinedGravity)\n        (void) CloneString(&draw_info->geometry,geometry);\n      status=GetMultilineTypeMetrics(image,draw_info,&metrics);\n      image->rows=(size_t) ((i+1)*(metrics.ascent-metrics.descent+\n        draw_info->interline_spacing+draw_info->stroke_width)+0.5);\n    }\n  if (status != MagickFalse)\n    status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    { \n      draw_info=DestroyDrawInfo(draw_info);\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if (SetImageBackgroundColor(image) == MagickFalse)\n    {\n      draw_info=DestroyDrawInfo(draw_info);\n      InheritException(exception,&image->exception);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if ((fabs(image_info->pointsize) < MagickEpsilon) && (strlen(caption) > 0))\n    {\n      double\n        high,\n        low;\n\n      /*\n        Auto fit text into bounding box.\n      */\n      for ( ; ; draw_info->pointsize*=2.0)\n      {\n        text=AcquireString(caption);\n        i=FormatMagickCaption(image,draw_info,split,&metrics,&text);\n        (void) CloneString(&draw_info->text,text);\n        text=DestroyString(text);\n        (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",\n          -metrics.bounds.x1,metrics.ascent);\n        if (draw_info->gravity == UndefinedGravity)\n          (void) CloneString(&draw_info->geometry,geometry);\n        status=GetMultilineTypeMetrics(image,draw_info,&metrics);\n        (void) status;\n        width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);\n        height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);\n        if ((image->columns != 0) && (image->rows != 0))\n          {\n            if ((width >= image->columns) && (height >= image->rows))\n              break;\n          }\n        else\n          if (((image->columns != 0) && (width >= image->columns)) ||\n              ((image->rows != 0) && (height >= image->rows)))\n            break;\n      }\n      high=draw_info->pointsize;\n      for (low=1.0; (high-low) > 0.5; )\n      {\n        draw_info->pointsize=(low+high)/2.0;\n        text=AcquireString(caption);\n        i=FormatMagickCaption(image,draw_info,split,&metrics,&text);\n        (void) CloneString(&draw_info->text,text);\n        text=DestroyString(text);\n        (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",\n          -metrics.bounds.x1,metrics.ascent);\n        if (draw_info->gravity == UndefinedGravity)\n          (void) CloneString(&draw_info->geometry,geometry);\n        (void) GetMultilineTypeMetrics(image,draw_info,&metrics);\n        width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);\n        height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);\n        if ((image->columns != 0) && (image->rows != 0))\n          {\n            if ((width < image->columns) && (height < image->rows))\n              low=draw_info->pointsize+0.5;\n            else\n              high=draw_info->pointsize-0.5;\n          }\n        else\n          if (((image->columns != 0) && (width < image->columns)) ||\n              ((image->rows != 0) && (height < image->rows)))\n            low=draw_info->pointsize+0.5;\n          else\n            high=draw_info->pointsize-0.5;\n      }\n      draw_info->pointsize=floor((low+high)/2.0-0.5);\n    }\n  /*\n    Draw caption.\n  */\n  i=FormatMagickCaption(image,draw_info,split,&metrics,&caption);\n  (void) CloneString(&draw_info->text,caption);\n  (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",MagickMax(\n    draw_info->direction == RightToLeftDirection ? image->columns-\n    metrics.bounds.x2 : -metrics.bounds.x1,0.0),draw_info->gravity ==\n    UndefinedGravity ? metrics.ascent : 0.0);\n  (void) CloneString(&draw_info->geometry,geometry);\n  status=AnnotateImage(image,draw_info);\n  if (image_info->pointsize == 0.0)\n    { \n      char\n        pointsize[MaxTextExtent];\n      \n      (void) FormatLocaleString(pointsize,MaxTextExtent,\"%.20g\",\n        draw_info->pointsize);\n      (void) SetImageProperty(image,\"caption:pointsize\",pointsize);\n    }\n  draw_info=DestroyDrawInfo(draw_info);\n  caption=DestroyString(caption);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadCAPTIONImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    *caption,\n    geometry[MaxTextExtent],\n    *property,\n    *text;\n\n  const char\n    *gravity,\n    *option;\n\n  DrawInfo\n    *draw_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    split,\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    height,\n    width;\n\n  TypeMetric\n    metrics;\n\n  /*\n    Initialize Image structure.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  (void) ResetImagePage(image,\"0x0+0+0\");\n  /*\n    Format caption.\n  */\n  option=GetImageOption(image_info,\"filename\");\n  if (option == (const char *) NULL)\n    property=InterpretImageProperties(image_info,image,image_info->filename);\n  else\n    if (LocaleNCompare(option,\"caption:\",8) == 0)\n      property=InterpretImageProperties(image_info,image,option+8);\n    else\n      property=InterpretImageProperties(image_info,image,option);\n  (void) SetImageProperty(image,\"caption\",property);\n  property=DestroyString(property);\n  caption=ConstantString(GetImageProperty(image,\"caption\"));\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  (void) CloneString(&draw_info->text,caption);\n  gravity=GetImageOption(image_info,\"gravity\");\n  if (gravity != (char *) NULL)\n    draw_info->gravity=(GravityType) ParseCommandOption(MagickGravityOptions,\n      MagickFalse,gravity);\n  split=MagickFalse;\n  status=MagickTrue;\n  if (image->columns == 0)\n    {\n      text=AcquireString(caption);\n      i=FormatMagickCaption(image,draw_info,split,&metrics,&text);\n      (void) CloneString(&draw_info->text,text);\n      text=DestroyString(text);\n      (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",\n        -metrics.bounds.x1,metrics.ascent);\n      if (draw_info->gravity == UndefinedGravity)\n        (void) CloneString(&draw_info->geometry,geometry);\n      status=GetMultilineTypeMetrics(image,draw_info,&metrics);\n      width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);\n      image->columns=width;\n    }\n  if (image->rows == 0)\n    {\n      split=MagickTrue;\n      text=AcquireString(caption);\n      i=FormatMagickCaption(image,draw_info,split,&metrics,&text);\n      (void) CloneString(&draw_info->text,text);\n      text=DestroyString(text);\n      (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",\n        -metrics.bounds.x1,metrics.ascent);\n      if (draw_info->gravity == UndefinedGravity)\n        (void) CloneString(&draw_info->geometry,geometry);\n      status=GetMultilineTypeMetrics(image,draw_info,&metrics);\n      image->rows=(size_t) ((i+1)*(metrics.ascent-metrics.descent+\n        draw_info->interline_spacing+draw_info->stroke_width)+0.5);\n    }\n  if (status != MagickFalse)\n    status=SetImageExtent(image,image->columns,image->rows);\n  if (status == MagickFalse)\n    { \n      draw_info=DestroyDrawInfo(draw_info);\n      InheritException(exception,&image->exception);\n      return(DestroyImageList(image));\n    }\n  if (SetImageBackgroundColor(image) == MagickFalse)\n    {\n      draw_info=DestroyDrawInfo(draw_info);\n      InheritException(exception,&image->exception);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if ((fabs(image_info->pointsize) < MagickEpsilon) && (strlen(caption) > 0))\n    {\n      double\n        high,\n        low;\n\n      ssize_t\n        n;\n\n      /*\n        Auto fit text into bounding box.\n      */\n      for (n=0; n < 32; n++, draw_info->pointsize*=2.0)\n      {\n        text=AcquireString(caption);\n        i=FormatMagickCaption(image,draw_info,split,&metrics,&text);\n        (void) CloneString(&draw_info->text,text);\n        text=DestroyString(text);\n        (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",\n          -metrics.bounds.x1,metrics.ascent);\n        if (draw_info->gravity == UndefinedGravity)\n          (void) CloneString(&draw_info->geometry,geometry);\n        status=GetMultilineTypeMetrics(image,draw_info,&metrics);\n        (void) status;\n        width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);\n        height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);\n        if ((image->columns != 0) && (image->rows != 0))\n          {\n            if ((width >= image->columns) && (height >= image->rows))\n              break;\n          }\n        else\n          if (((image->columns != 0) && (width >= image->columns)) ||\n              ((image->rows != 0) && (height >= image->rows)))\n            break;\n      }\n      high=draw_info->pointsize;\n      for (low=1.0; (high-low) > 0.5; )\n      {\n        draw_info->pointsize=(low+high)/2.0;\n        text=AcquireString(caption);\n        i=FormatMagickCaption(image,draw_info,split,&metrics,&text);\n        (void) CloneString(&draw_info->text,text);\n        text=DestroyString(text);\n        (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",\n          -metrics.bounds.x1,metrics.ascent);\n        if (draw_info->gravity == UndefinedGravity)\n          (void) CloneString(&draw_info->geometry,geometry);\n        (void) GetMultilineTypeMetrics(image,draw_info,&metrics);\n        width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5);\n        height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5);\n        if ((image->columns != 0) && (image->rows != 0))\n          {\n            if ((width < image->columns) && (height < image->rows))\n              low=draw_info->pointsize+0.5;\n            else\n              high=draw_info->pointsize-0.5;\n          }\n        else\n          if (((image->columns != 0) && (width < image->columns)) ||\n              ((image->rows != 0) && (height < image->rows)))\n            low=draw_info->pointsize+0.5;\n          else\n            high=draw_info->pointsize-0.5;\n      }\n      draw_info->pointsize=floor((low+high)/2.0-0.5);\n    }\n  /*\n    Draw caption.\n  */\n  i=FormatMagickCaption(image,draw_info,split,&metrics,&caption);\n  (void) CloneString(&draw_info->text,caption);\n  (void) FormatLocaleString(geometry,MaxTextExtent,\"%+g%+g\",MagickMax(\n    draw_info->direction == RightToLeftDirection ? image->columns-\n    metrics.bounds.x2 : -metrics.bounds.x1,0.0),draw_info->gravity ==\n    UndefinedGravity ? metrics.ascent : 0.0);\n  (void) CloneString(&draw_info->geometry,geometry);\n  status=AnnotateImage(image,draw_info);\n  if (image_info->pointsize == 0.0)\n    { \n      char\n        pointsize[MaxTextExtent];\n      \n      (void) FormatLocaleString(pointsize,MaxTextExtent,\"%.20g\",\n        draw_info->pointsize);\n      (void) SetImageProperty(image,\"caption:pointsize\",pointsize);\n    }\n  draw_info=DestroyDrawInfo(draw_info);\n  caption=DestroyString(caption);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -115,10 +115,13 @@\n         high,\n         low;\n \n+      ssize_t\n+        n;\n+\n       /*\n         Auto fit text into bounding box.\n       */\n-      for ( ; ; draw_info->pointsize*=2.0)\n+      for (n=0; n < 32; n++, draw_info->pointsize*=2.0)\n       {\n         text=AcquireString(caption);\n         i=FormatMagickCaption(image,draw_info,split,&metrics,&text);",
        "diff_line_info": {
            "deleted_lines": [
                "      for ( ; ; draw_info->pointsize*=2.0)"
            ],
            "added_lines": [
                "      ssize_t",
                "        n;",
                "",
                "      for (n=0; n < 32; n++, draw_info->pointsize*=2.0)"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14932",
        "func_name": "binutils-gdb/decode_line_info",
        "description": "decode_line_info in dwarf2.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (infinite loop) via a crafted ELF file.",
        "git_url": "https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=e338894dc2e603683bed2172e8e9f25b29051005",
        "commit_title": "",
        "commit_text": "PR22204, Lack of DW_LNE_end_sequence causes \"infinite\" loop  \tPR 22204 \t* dwarf2.c (decode_line_info): Ensure line_ptr stays within \tbounds in inner loop. ",
        "func_before": "static struct line_info_table*\ndecode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)\n{\n  bfd *abfd = unit->abfd;\n  struct line_info_table* table;\n  bfd_byte *line_ptr;\n  bfd_byte *line_end;\n  struct line_head lh;\n  unsigned int i, bytes_read, offset_size;\n  char *cur_file, *cur_dir;\n  unsigned char op_code, extended_op, adj_opcode;\n  unsigned int exop_len;\n  bfd_size_type amt;\n\n  if (! read_section (abfd, &stash->debug_sections[debug_line],\n\t\t      stash->syms, unit->line_offset,\n\t\t      &stash->dwarf_line_buffer, &stash->dwarf_line_size))\n    return NULL;\n\n  amt = sizeof (struct line_info_table);\n  table = (struct line_info_table *) bfd_alloc (abfd, amt);\n  if (table == NULL)\n    return NULL;\n  table->abfd = abfd;\n  table->comp_dir = unit->comp_dir;\n\n  table->num_files = 0;\n  table->files = NULL;\n\n  table->num_dirs = 0;\n  table->dirs = NULL;\n\n  table->num_sequences = 0;\n  table->sequences = NULL;\n\n  table->lcl_head = NULL;\n\n  if (stash->dwarf_line_size < 16)\n    {\n      _bfd_error_handler\n\t(_(\"Dwarf Error: Line info section is too small (%Ld)\"),\n\t stash->dwarf_line_size);\n      bfd_set_error (bfd_error_bad_value);\n      return NULL;\n    }\n  line_ptr = stash->dwarf_line_buffer + unit->line_offset;\n  line_end = stash->dwarf_line_buffer + stash->dwarf_line_size;\n\n  /* Read in the prologue.  */\n  lh.total_length = read_4_bytes (abfd, line_ptr, line_end);\n  line_ptr += 4;\n  offset_size = 4;\n  if (lh.total_length == 0xffffffff)\n    {\n      lh.total_length = read_8_bytes (abfd, line_ptr, line_end);\n      line_ptr += 8;\n      offset_size = 8;\n    }\n  else if (lh.total_length == 0 && unit->addr_size == 8)\n    {\n      /* Handle (non-standard) 64-bit DWARF2 formats.  */\n      lh.total_length = read_4_bytes (abfd, line_ptr, line_end);\n      line_ptr += 4;\n      offset_size = 8;\n    }\n\n  if (lh.total_length > (size_t) (line_end - line_ptr))\n    {\n      _bfd_error_handler\n\t/* xgettext: c-format */\n\t(_(\"Dwarf Error: Line info data is bigger (%#Lx)\"\n\t   \" than the space remaining in the section (%#lx)\"),\n\t lh.total_length, (unsigned long) (line_end - line_ptr));\n      bfd_set_error (bfd_error_bad_value);\n      return NULL;\n    }\n\n  line_end = line_ptr + lh.total_length;\n\n  lh.version = read_2_bytes (abfd, line_ptr, line_end);\n  if (lh.version < 2 || lh.version > 5)\n    {\n      _bfd_error_handler\n\t(_(\"Dwarf Error: Unhandled .debug_line version %d.\"), lh.version);\n      bfd_set_error (bfd_error_bad_value);\n      return NULL;\n    }\n  line_ptr += 2;\n\n  if (line_ptr + offset_size + (lh.version >= 5 ? 8 : (lh.version >= 4 ? 6 : 5))\n      >= line_end)\n    {\n      _bfd_error_handler\n\t(_(\"Dwarf Error: Ran out of room reading prologue\"));\n      bfd_set_error (bfd_error_bad_value);\n      return NULL;\n    }\n\n  if (lh.version >= 5)\n    {\n      unsigned int segment_selector_size;\n\n      /* Skip address size.  */\n      read_1_byte (abfd, line_ptr, line_end);\n      line_ptr += 1;\n\n      segment_selector_size = read_1_byte (abfd, line_ptr, line_end);\n      line_ptr += 1;\n      if (segment_selector_size != 0)\n\t{\n\t  _bfd_error_handler\n\t    (_(\"Dwarf Error: Line info unsupported segment selector size %u.\"),\n\t     segment_selector_size);\n\t  bfd_set_error (bfd_error_bad_value);\n\t  return NULL;\n\t}\n    }\n\n  if (offset_size == 4)\n    lh.prologue_length = read_4_bytes (abfd, line_ptr, line_end);\n  else\n    lh.prologue_length = read_8_bytes (abfd, line_ptr, line_end);\n  line_ptr += offset_size;\n\n  lh.minimum_instruction_length = read_1_byte (abfd, line_ptr, line_end);\n  line_ptr += 1;\n\n  if (lh.version >= 4)\n    {\n      lh.maximum_ops_per_insn = read_1_byte (abfd, line_ptr, line_end);\n      line_ptr += 1;\n    }\n  else\n    lh.maximum_ops_per_insn = 1;\n\n  if (lh.maximum_ops_per_insn == 0)\n    {\n      _bfd_error_handler\n\t(_(\"Dwarf Error: Invalid maximum operations per instruction.\"));\n      bfd_set_error (bfd_error_bad_value);\n      return NULL;\n    }\n\n  lh.default_is_stmt = read_1_byte (abfd, line_ptr, line_end);\n  line_ptr += 1;\n\n  lh.line_base = read_1_signed_byte (abfd, line_ptr, line_end);\n  line_ptr += 1;\n\n  lh.line_range = read_1_byte (abfd, line_ptr, line_end);\n  line_ptr += 1;\n\n  lh.opcode_base = read_1_byte (abfd, line_ptr, line_end);\n  line_ptr += 1;\n\n  if (line_ptr + (lh.opcode_base - 1) >= line_end)\n    {\n      _bfd_error_handler (_(\"Dwarf Error: Ran out of room reading opcodes\"));\n      bfd_set_error (bfd_error_bad_value);\n      return NULL;\n    }\n\n  amt = lh.opcode_base * sizeof (unsigned char);\n  lh.standard_opcode_lengths = (unsigned char *) bfd_alloc (abfd, amt);\n\n  lh.standard_opcode_lengths[0] = 1;\n\n  for (i = 1; i < lh.opcode_base; ++i)\n    {\n      lh.standard_opcode_lengths[i] = read_1_byte (abfd, line_ptr, line_end);\n      line_ptr += 1;\n    }\n\n  if (lh.version >= 5)\n    {\n      /* Read directory table.  */\n      if (!read_formatted_entries (unit, &line_ptr, line_end, table,\n\t\t\t\t   line_info_add_include_dir_stub))\n\tgoto fail;\n\n      /* Read file name table.  */\n      if (!read_formatted_entries (unit, &line_ptr, line_end, table,\n\t\t\t\t   line_info_add_file_name))\n\tgoto fail;\n    }\n  else\n    {\n      /* Read directory table.  */\n      while ((cur_dir = read_string (abfd, line_ptr, line_end, &bytes_read)) != NULL)\n\t{\n\t  line_ptr += bytes_read;\n\n\t  if (!line_info_add_include_dir (table, cur_dir))\n\t    goto fail;\n\t}\n\n      line_ptr += bytes_read;\n\n      /* Read file name table.  */\n      while ((cur_file = read_string (abfd, line_ptr, line_end, &bytes_read)) != NULL)\n\t{\n\t  unsigned int dir, xtime, size;\n\n\t  line_ptr += bytes_read;\n\n\t  dir = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);\n\t  line_ptr += bytes_read;\n\t  xtime = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);\n\t  line_ptr += bytes_read;\n\t  size = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);\n\t  line_ptr += bytes_read;\n\n\t  if (!line_info_add_file_name (table, cur_file, dir, xtime, size))\n\t    goto fail;\n\t}\n\n      line_ptr += bytes_read;\n    }\n\n  /* Read the statement sequences until there's nothing left.  */\n  while (line_ptr < line_end)\n    {\n      /* State machine registers.  */\n      bfd_vma address = 0;\n      unsigned char op_index = 0;\n      char * filename = table->num_files ? concat_filename (table, 1) : NULL;\n      unsigned int line = 1;\n      unsigned int column = 0;\n      unsigned int discriminator = 0;\n      int is_stmt = lh.default_is_stmt;\n      int end_sequence = 0;\n      /* eraxxon@alumni.rice.edu: Against the DWARF2 specs, some\n\t compilers generate address sequences that are wildly out of\n\t order using DW_LNE_set_address (e.g. Intel C++ 6.0 compiler\n\t for ia64-Linux).  Thus, to determine the low and high\n\t address, we must compare on every DW_LNS_copy, etc.  */\n      bfd_vma low_pc  = (bfd_vma) -1;\n      bfd_vma high_pc = 0;\n\n      /* Decode the table.  */\n      while (! end_sequence)\n\t{\n\t  op_code = read_1_byte (abfd, line_ptr, line_end);\n\t  line_ptr += 1;\n\n\t  if (op_code >= lh.opcode_base)\n\t    {\n\t      /* Special operand.  */\n\t      adj_opcode = op_code - lh.opcode_base;\n\t      if (lh.line_range == 0)\n\t\tgoto line_fail;\n\t      if (lh.maximum_ops_per_insn == 1)\n\t\taddress += (adj_opcode / lh.line_range\n\t\t\t    * lh.minimum_instruction_length);\n\t      else\n\t\t{\n\t\t  address += ((op_index + adj_opcode / lh.line_range)\n\t\t\t      / lh.maximum_ops_per_insn\n\t\t\t      * lh.minimum_instruction_length);\n\t\t  op_index = ((op_index + adj_opcode / lh.line_range)\n\t\t\t      % lh.maximum_ops_per_insn);\n\t\t}\n\t      line += lh.line_base + (adj_opcode % lh.line_range);\n\t      /* Append row to matrix using current values.  */\n\t      if (!add_line_info (table, address, op_index, filename,\n\t\t\t\t  line, column, discriminator, 0))\n\t\tgoto line_fail;\n\t      discriminator = 0;\n\t      if (address < low_pc)\n\t\tlow_pc = address;\n\t      if (address > high_pc)\n\t\thigh_pc = address;\n\t    }\n\t  else switch (op_code)\n\t    {\n\t    case DW_LNS_extended_op:\n\t      exop_len = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,\n\t\t\t\t\t\tFALSE, line_end);\n\t      line_ptr += bytes_read;\n\t      extended_op = read_1_byte (abfd, line_ptr, line_end);\n\t      line_ptr += 1;\n\n\t      switch (extended_op)\n\t\t{\n\t\tcase DW_LNE_end_sequence:\n\t\t  end_sequence = 1;\n\t\t  if (!add_line_info (table, address, op_index, filename, line,\n\t\t\t\t      column, discriminator, end_sequence))\n\t\t    goto line_fail;\n\t\t  discriminator = 0;\n\t\t  if (address < low_pc)\n\t\t    low_pc = address;\n\t\t  if (address > high_pc)\n\t\t    high_pc = address;\n\t\t  if (!arange_add (unit, &unit->arange, low_pc, high_pc))\n\t\t    goto line_fail;\n\t\t  break;\n\t\tcase DW_LNE_set_address:\n\t\t  address = read_address (unit, line_ptr, line_end);\n\t\t  op_index = 0;\n\t\t  line_ptr += unit->addr_size;\n\t\t  break;\n\t\tcase DW_LNE_define_file:\n\t\t  cur_file = read_string (abfd, line_ptr, line_end, &bytes_read);\n\t\t  line_ptr += bytes_read;\n\t\t  if ((table->num_files % FILE_ALLOC_CHUNK) == 0)\n\t\t    {\n\t\t      struct fileinfo *tmp;\n\n\t\t      amt = table->num_files + FILE_ALLOC_CHUNK;\n\t\t      amt *= sizeof (struct fileinfo);\n\t\t      tmp = (struct fileinfo *) bfd_realloc (table->files, amt);\n\t\t      if (tmp == NULL)\n\t\t\tgoto line_fail;\n\t\t      table->files = tmp;\n\t\t    }\n\t\t  table->files[table->num_files].name = cur_file;\n\t\t  table->files[table->num_files].dir =\n\t\t    _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,\n\t\t\t\t\t   FALSE, line_end);\n\t\t  line_ptr += bytes_read;\n\t\t  table->files[table->num_files].time =\n\t\t    _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,\n\t\t\t\t\t   FALSE, line_end);\n\t\t  line_ptr += bytes_read;\n\t\t  table->files[table->num_files].size =\n\t\t    _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,\n\t\t\t\t\t   FALSE, line_end);\n\t\t  line_ptr += bytes_read;\n\t\t  table->num_files++;\n\t\t  break;\n\t\tcase DW_LNE_set_discriminator:\n\t\t  discriminator =\n\t\t    _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,\n\t\t\t\t\t   FALSE, line_end);\n\t\t  line_ptr += bytes_read;\n\t\t  break;\n\t\tcase DW_LNE_HP_source_file_correlation:\n\t\t  line_ptr += exop_len - 1;\n\t\t  break;\n\t\tdefault:\n\t\t  _bfd_error_handler\n\t\t    (_(\"Dwarf Error: mangled line number section.\"));\n\t\t  bfd_set_error (bfd_error_bad_value);\n\t\tline_fail:\n\t\t  if (filename != NULL)\n\t\t    free (filename);\n\t\t  goto fail;\n\t\t}\n\t      break;\n\t    case DW_LNS_copy:\n\t      if (!add_line_info (table, address, op_index,\n\t\t\t\t  filename, line, column, discriminator, 0))\n\t\tgoto line_fail;\n\t      discriminator = 0;\n\t      if (address < low_pc)\n\t\tlow_pc = address;\n\t      if (address > high_pc)\n\t\thigh_pc = address;\n\t      break;\n\t    case DW_LNS_advance_pc:\n\t      if (lh.maximum_ops_per_insn == 1)\n\t\taddress += (lh.minimum_instruction_length\n\t\t\t    * _bfd_safe_read_leb128 (abfd, line_ptr,\n\t\t\t\t\t\t     &bytes_read,\n\t\t\t\t\t\t     FALSE, line_end));\n\t      else\n\t\t{\n\t\t  bfd_vma adjust = _bfd_safe_read_leb128 (abfd, line_ptr,\n\t\t\t\t\t\t\t  &bytes_read,\n\t\t\t\t\t\t\t  FALSE, line_end);\n\t\t  address = ((op_index + adjust) / lh.maximum_ops_per_insn\n\t\t\t     * lh.minimum_instruction_length);\n\t\t  op_index = (op_index + adjust) % lh.maximum_ops_per_insn;\n\t\t}\n\t      line_ptr += bytes_read;\n\t      break;\n\t    case DW_LNS_advance_line:\n\t      line += _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,\n\t\t\t\t\t     TRUE, line_end);\n\t      line_ptr += bytes_read;\n\t      break;\n\t    case DW_LNS_set_file:\n\t      {\n\t\tunsigned int file;\n\n\t\t/* The file and directory tables are 0\n\t\t   based, the references are 1 based.  */\n\t\tfile = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,\n\t\t\t\t\t      FALSE, line_end);\n\t\tline_ptr += bytes_read;\n\t\tif (filename)\n\t\t  free (filename);\n\t\tfilename = concat_filename (table, file);\n\t\tbreak;\n\t      }\n\t    case DW_LNS_set_column:\n\t      column = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,\n\t\t\t\t\t      FALSE, line_end);\n\t      line_ptr += bytes_read;\n\t      break;\n\t    case DW_LNS_negate_stmt:\n\t      is_stmt = (!is_stmt);\n\t      break;\n\t    case DW_LNS_set_basic_block:\n\t      break;\n\t    case DW_LNS_const_add_pc:\n\t      if (lh.line_range == 0)\n\t\tgoto line_fail;\n\t      if (lh.maximum_ops_per_insn == 1)\n\t\taddress += (lh.minimum_instruction_length\n\t\t\t    * ((255 - lh.opcode_base) / lh.line_range));\n\t      else\n\t\t{\n\t\t  bfd_vma adjust = ((255 - lh.opcode_base) / lh.line_range);\n\t\t  address += (lh.minimum_instruction_length\n\t\t\t      * ((op_index + adjust)\n\t\t\t\t / lh.maximum_ops_per_insn));\n\t\t  op_index = (op_index + adjust) % lh.maximum_ops_per_insn;\n\t\t}\n\t      break;\n\t    case DW_LNS_fixed_advance_pc:\n\t      address += read_2_bytes (abfd, line_ptr, line_end);\n\t      op_index = 0;\n\t      line_ptr += 2;\n\t      break;\n\t    default:\n\t      /* Unknown standard opcode, ignore it.  */\n\t      for (i = 0; i < lh.standard_opcode_lengths[op_code]; i++)\n\t\t{\n\t\t  (void) _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,\n\t\t\t\t\t\tFALSE, line_end);\n\t\t  line_ptr += bytes_read;\n\t\t}\n\t      break;\n\t    }\n\t}\n\n      if (filename)\n\tfree (filename);\n    }\n\n  if (sort_line_sequences (table))\n    return table;\n\n fail:\n  while (table->sequences != NULL)\n    {\n      struct line_sequence* seq = table->sequences;\n      table->sequences = table->sequences->prev_sequence;\n      free (seq);\n    }\n  if (table->files != NULL)\n    free (table->files);\n  if (table->dirs != NULL)\n    free (table->dirs);\n  return NULL;\n}",
        "func": "static struct line_info_table*\ndecode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)\n{\n  bfd *abfd = unit->abfd;\n  struct line_info_table* table;\n  bfd_byte *line_ptr;\n  bfd_byte *line_end;\n  struct line_head lh;\n  unsigned int i, bytes_read, offset_size;\n  char *cur_file, *cur_dir;\n  unsigned char op_code, extended_op, adj_opcode;\n  unsigned int exop_len;\n  bfd_size_type amt;\n\n  if (! read_section (abfd, &stash->debug_sections[debug_line],\n\t\t      stash->syms, unit->line_offset,\n\t\t      &stash->dwarf_line_buffer, &stash->dwarf_line_size))\n    return NULL;\n\n  amt = sizeof (struct line_info_table);\n  table = (struct line_info_table *) bfd_alloc (abfd, amt);\n  if (table == NULL)\n    return NULL;\n  table->abfd = abfd;\n  table->comp_dir = unit->comp_dir;\n\n  table->num_files = 0;\n  table->files = NULL;\n\n  table->num_dirs = 0;\n  table->dirs = NULL;\n\n  table->num_sequences = 0;\n  table->sequences = NULL;\n\n  table->lcl_head = NULL;\n\n  if (stash->dwarf_line_size < 16)\n    {\n      _bfd_error_handler\n\t(_(\"Dwarf Error: Line info section is too small (%Ld)\"),\n\t stash->dwarf_line_size);\n      bfd_set_error (bfd_error_bad_value);\n      return NULL;\n    }\n  line_ptr = stash->dwarf_line_buffer + unit->line_offset;\n  line_end = stash->dwarf_line_buffer + stash->dwarf_line_size;\n\n  /* Read in the prologue.  */\n  lh.total_length = read_4_bytes (abfd, line_ptr, line_end);\n  line_ptr += 4;\n  offset_size = 4;\n  if (lh.total_length == 0xffffffff)\n    {\n      lh.total_length = read_8_bytes (abfd, line_ptr, line_end);\n      line_ptr += 8;\n      offset_size = 8;\n    }\n  else if (lh.total_length == 0 && unit->addr_size == 8)\n    {\n      /* Handle (non-standard) 64-bit DWARF2 formats.  */\n      lh.total_length = read_4_bytes (abfd, line_ptr, line_end);\n      line_ptr += 4;\n      offset_size = 8;\n    }\n\n  if (lh.total_length > (size_t) (line_end - line_ptr))\n    {\n      _bfd_error_handler\n\t/* xgettext: c-format */\n\t(_(\"Dwarf Error: Line info data is bigger (%#Lx)\"\n\t   \" than the space remaining in the section (%#lx)\"),\n\t lh.total_length, (unsigned long) (line_end - line_ptr));\n      bfd_set_error (bfd_error_bad_value);\n      return NULL;\n    }\n\n  line_end = line_ptr + lh.total_length;\n\n  lh.version = read_2_bytes (abfd, line_ptr, line_end);\n  if (lh.version < 2 || lh.version > 5)\n    {\n      _bfd_error_handler\n\t(_(\"Dwarf Error: Unhandled .debug_line version %d.\"), lh.version);\n      bfd_set_error (bfd_error_bad_value);\n      return NULL;\n    }\n  line_ptr += 2;\n\n  if (line_ptr + offset_size + (lh.version >= 5 ? 8 : (lh.version >= 4 ? 6 : 5))\n      >= line_end)\n    {\n      _bfd_error_handler\n\t(_(\"Dwarf Error: Ran out of room reading prologue\"));\n      bfd_set_error (bfd_error_bad_value);\n      return NULL;\n    }\n\n  if (lh.version >= 5)\n    {\n      unsigned int segment_selector_size;\n\n      /* Skip address size.  */\n      read_1_byte (abfd, line_ptr, line_end);\n      line_ptr += 1;\n\n      segment_selector_size = read_1_byte (abfd, line_ptr, line_end);\n      line_ptr += 1;\n      if (segment_selector_size != 0)\n\t{\n\t  _bfd_error_handler\n\t    (_(\"Dwarf Error: Line info unsupported segment selector size %u.\"),\n\t     segment_selector_size);\n\t  bfd_set_error (bfd_error_bad_value);\n\t  return NULL;\n\t}\n    }\n\n  if (offset_size == 4)\n    lh.prologue_length = read_4_bytes (abfd, line_ptr, line_end);\n  else\n    lh.prologue_length = read_8_bytes (abfd, line_ptr, line_end);\n  line_ptr += offset_size;\n\n  lh.minimum_instruction_length = read_1_byte (abfd, line_ptr, line_end);\n  line_ptr += 1;\n\n  if (lh.version >= 4)\n    {\n      lh.maximum_ops_per_insn = read_1_byte (abfd, line_ptr, line_end);\n      line_ptr += 1;\n    }\n  else\n    lh.maximum_ops_per_insn = 1;\n\n  if (lh.maximum_ops_per_insn == 0)\n    {\n      _bfd_error_handler\n\t(_(\"Dwarf Error: Invalid maximum operations per instruction.\"));\n      bfd_set_error (bfd_error_bad_value);\n      return NULL;\n    }\n\n  lh.default_is_stmt = read_1_byte (abfd, line_ptr, line_end);\n  line_ptr += 1;\n\n  lh.line_base = read_1_signed_byte (abfd, line_ptr, line_end);\n  line_ptr += 1;\n\n  lh.line_range = read_1_byte (abfd, line_ptr, line_end);\n  line_ptr += 1;\n\n  lh.opcode_base = read_1_byte (abfd, line_ptr, line_end);\n  line_ptr += 1;\n\n  if (line_ptr + (lh.opcode_base - 1) >= line_end)\n    {\n      _bfd_error_handler (_(\"Dwarf Error: Ran out of room reading opcodes\"));\n      bfd_set_error (bfd_error_bad_value);\n      return NULL;\n    }\n\n  amt = lh.opcode_base * sizeof (unsigned char);\n  lh.standard_opcode_lengths = (unsigned char *) bfd_alloc (abfd, amt);\n\n  lh.standard_opcode_lengths[0] = 1;\n\n  for (i = 1; i < lh.opcode_base; ++i)\n    {\n      lh.standard_opcode_lengths[i] = read_1_byte (abfd, line_ptr, line_end);\n      line_ptr += 1;\n    }\n\n  if (lh.version >= 5)\n    {\n      /* Read directory table.  */\n      if (!read_formatted_entries (unit, &line_ptr, line_end, table,\n\t\t\t\t   line_info_add_include_dir_stub))\n\tgoto fail;\n\n      /* Read file name table.  */\n      if (!read_formatted_entries (unit, &line_ptr, line_end, table,\n\t\t\t\t   line_info_add_file_name))\n\tgoto fail;\n    }\n  else\n    {\n      /* Read directory table.  */\n      while ((cur_dir = read_string (abfd, line_ptr, line_end, &bytes_read)) != NULL)\n\t{\n\t  line_ptr += bytes_read;\n\n\t  if (!line_info_add_include_dir (table, cur_dir))\n\t    goto fail;\n\t}\n\n      line_ptr += bytes_read;\n\n      /* Read file name table.  */\n      while ((cur_file = read_string (abfd, line_ptr, line_end, &bytes_read)) != NULL)\n\t{\n\t  unsigned int dir, xtime, size;\n\n\t  line_ptr += bytes_read;\n\n\t  dir = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);\n\t  line_ptr += bytes_read;\n\t  xtime = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);\n\t  line_ptr += bytes_read;\n\t  size = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read, FALSE, line_end);\n\t  line_ptr += bytes_read;\n\n\t  if (!line_info_add_file_name (table, cur_file, dir, xtime, size))\n\t    goto fail;\n\t}\n\n      line_ptr += bytes_read;\n    }\n\n  /* Read the statement sequences until there's nothing left.  */\n  while (line_ptr < line_end)\n    {\n      /* State machine registers.  */\n      bfd_vma address = 0;\n      unsigned char op_index = 0;\n      char * filename = table->num_files ? concat_filename (table, 1) : NULL;\n      unsigned int line = 1;\n      unsigned int column = 0;\n      unsigned int discriminator = 0;\n      int is_stmt = lh.default_is_stmt;\n      int end_sequence = 0;\n      /* eraxxon@alumni.rice.edu: Against the DWARF2 specs, some\n\t compilers generate address sequences that are wildly out of\n\t order using DW_LNE_set_address (e.g. Intel C++ 6.0 compiler\n\t for ia64-Linux).  Thus, to determine the low and high\n\t address, we must compare on every DW_LNS_copy, etc.  */\n      bfd_vma low_pc  = (bfd_vma) -1;\n      bfd_vma high_pc = 0;\n\n      /* Decode the table.  */\n      while (!end_sequence && line_ptr < line_end)\n\t{\n\t  op_code = read_1_byte (abfd, line_ptr, line_end);\n\t  line_ptr += 1;\n\n\t  if (op_code >= lh.opcode_base)\n\t    {\n\t      /* Special operand.  */\n\t      adj_opcode = op_code - lh.opcode_base;\n\t      if (lh.line_range == 0)\n\t\tgoto line_fail;\n\t      if (lh.maximum_ops_per_insn == 1)\n\t\taddress += (adj_opcode / lh.line_range\n\t\t\t    * lh.minimum_instruction_length);\n\t      else\n\t\t{\n\t\t  address += ((op_index + adj_opcode / lh.line_range)\n\t\t\t      / lh.maximum_ops_per_insn\n\t\t\t      * lh.minimum_instruction_length);\n\t\t  op_index = ((op_index + adj_opcode / lh.line_range)\n\t\t\t      % lh.maximum_ops_per_insn);\n\t\t}\n\t      line += lh.line_base + (adj_opcode % lh.line_range);\n\t      /* Append row to matrix using current values.  */\n\t      if (!add_line_info (table, address, op_index, filename,\n\t\t\t\t  line, column, discriminator, 0))\n\t\tgoto line_fail;\n\t      discriminator = 0;\n\t      if (address < low_pc)\n\t\tlow_pc = address;\n\t      if (address > high_pc)\n\t\thigh_pc = address;\n\t    }\n\t  else switch (op_code)\n\t    {\n\t    case DW_LNS_extended_op:\n\t      exop_len = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,\n\t\t\t\t\t\tFALSE, line_end);\n\t      line_ptr += bytes_read;\n\t      extended_op = read_1_byte (abfd, line_ptr, line_end);\n\t      line_ptr += 1;\n\n\t      switch (extended_op)\n\t\t{\n\t\tcase DW_LNE_end_sequence:\n\t\t  end_sequence = 1;\n\t\t  if (!add_line_info (table, address, op_index, filename, line,\n\t\t\t\t      column, discriminator, end_sequence))\n\t\t    goto line_fail;\n\t\t  discriminator = 0;\n\t\t  if (address < low_pc)\n\t\t    low_pc = address;\n\t\t  if (address > high_pc)\n\t\t    high_pc = address;\n\t\t  if (!arange_add (unit, &unit->arange, low_pc, high_pc))\n\t\t    goto line_fail;\n\t\t  break;\n\t\tcase DW_LNE_set_address:\n\t\t  address = read_address (unit, line_ptr, line_end);\n\t\t  op_index = 0;\n\t\t  line_ptr += unit->addr_size;\n\t\t  break;\n\t\tcase DW_LNE_define_file:\n\t\t  cur_file = read_string (abfd, line_ptr, line_end, &bytes_read);\n\t\t  line_ptr += bytes_read;\n\t\t  if ((table->num_files % FILE_ALLOC_CHUNK) == 0)\n\t\t    {\n\t\t      struct fileinfo *tmp;\n\n\t\t      amt = table->num_files + FILE_ALLOC_CHUNK;\n\t\t      amt *= sizeof (struct fileinfo);\n\t\t      tmp = (struct fileinfo *) bfd_realloc (table->files, amt);\n\t\t      if (tmp == NULL)\n\t\t\tgoto line_fail;\n\t\t      table->files = tmp;\n\t\t    }\n\t\t  table->files[table->num_files].name = cur_file;\n\t\t  table->files[table->num_files].dir =\n\t\t    _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,\n\t\t\t\t\t   FALSE, line_end);\n\t\t  line_ptr += bytes_read;\n\t\t  table->files[table->num_files].time =\n\t\t    _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,\n\t\t\t\t\t   FALSE, line_end);\n\t\t  line_ptr += bytes_read;\n\t\t  table->files[table->num_files].size =\n\t\t    _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,\n\t\t\t\t\t   FALSE, line_end);\n\t\t  line_ptr += bytes_read;\n\t\t  table->num_files++;\n\t\t  break;\n\t\tcase DW_LNE_set_discriminator:\n\t\t  discriminator =\n\t\t    _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,\n\t\t\t\t\t   FALSE, line_end);\n\t\t  line_ptr += bytes_read;\n\t\t  break;\n\t\tcase DW_LNE_HP_source_file_correlation:\n\t\t  line_ptr += exop_len - 1;\n\t\t  break;\n\t\tdefault:\n\t\t  _bfd_error_handler\n\t\t    (_(\"Dwarf Error: mangled line number section.\"));\n\t\t  bfd_set_error (bfd_error_bad_value);\n\t\tline_fail:\n\t\t  if (filename != NULL)\n\t\t    free (filename);\n\t\t  goto fail;\n\t\t}\n\t      break;\n\t    case DW_LNS_copy:\n\t      if (!add_line_info (table, address, op_index,\n\t\t\t\t  filename, line, column, discriminator, 0))\n\t\tgoto line_fail;\n\t      discriminator = 0;\n\t      if (address < low_pc)\n\t\tlow_pc = address;\n\t      if (address > high_pc)\n\t\thigh_pc = address;\n\t      break;\n\t    case DW_LNS_advance_pc:\n\t      if (lh.maximum_ops_per_insn == 1)\n\t\taddress += (lh.minimum_instruction_length\n\t\t\t    * _bfd_safe_read_leb128 (abfd, line_ptr,\n\t\t\t\t\t\t     &bytes_read,\n\t\t\t\t\t\t     FALSE, line_end));\n\t      else\n\t\t{\n\t\t  bfd_vma adjust = _bfd_safe_read_leb128 (abfd, line_ptr,\n\t\t\t\t\t\t\t  &bytes_read,\n\t\t\t\t\t\t\t  FALSE, line_end);\n\t\t  address = ((op_index + adjust) / lh.maximum_ops_per_insn\n\t\t\t     * lh.minimum_instruction_length);\n\t\t  op_index = (op_index + adjust) % lh.maximum_ops_per_insn;\n\t\t}\n\t      line_ptr += bytes_read;\n\t      break;\n\t    case DW_LNS_advance_line:\n\t      line += _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,\n\t\t\t\t\t     TRUE, line_end);\n\t      line_ptr += bytes_read;\n\t      break;\n\t    case DW_LNS_set_file:\n\t      {\n\t\tunsigned int file;\n\n\t\t/* The file and directory tables are 0\n\t\t   based, the references are 1 based.  */\n\t\tfile = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,\n\t\t\t\t\t      FALSE, line_end);\n\t\tline_ptr += bytes_read;\n\t\tif (filename)\n\t\t  free (filename);\n\t\tfilename = concat_filename (table, file);\n\t\tbreak;\n\t      }\n\t    case DW_LNS_set_column:\n\t      column = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,\n\t\t\t\t\t      FALSE, line_end);\n\t      line_ptr += bytes_read;\n\t      break;\n\t    case DW_LNS_negate_stmt:\n\t      is_stmt = (!is_stmt);\n\t      break;\n\t    case DW_LNS_set_basic_block:\n\t      break;\n\t    case DW_LNS_const_add_pc:\n\t      if (lh.line_range == 0)\n\t\tgoto line_fail;\n\t      if (lh.maximum_ops_per_insn == 1)\n\t\taddress += (lh.minimum_instruction_length\n\t\t\t    * ((255 - lh.opcode_base) / lh.line_range));\n\t      else\n\t\t{\n\t\t  bfd_vma adjust = ((255 - lh.opcode_base) / lh.line_range);\n\t\t  address += (lh.minimum_instruction_length\n\t\t\t      * ((op_index + adjust)\n\t\t\t\t / lh.maximum_ops_per_insn));\n\t\t  op_index = (op_index + adjust) % lh.maximum_ops_per_insn;\n\t\t}\n\t      break;\n\t    case DW_LNS_fixed_advance_pc:\n\t      address += read_2_bytes (abfd, line_ptr, line_end);\n\t      op_index = 0;\n\t      line_ptr += 2;\n\t      break;\n\t    default:\n\t      /* Unknown standard opcode, ignore it.  */\n\t      for (i = 0; i < lh.standard_opcode_lengths[op_code]; i++)\n\t\t{\n\t\t  (void) _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,\n\t\t\t\t\t\tFALSE, line_end);\n\t\t  line_ptr += bytes_read;\n\t\t}\n\t      break;\n\t    }\n\t}\n\n      if (filename)\n\tfree (filename);\n    }\n\n  if (sort_line_sequences (table))\n    return table;\n\n fail:\n  while (table->sequences != NULL)\n    {\n      struct line_sequence* seq = table->sequences;\n      table->sequences = table->sequences->prev_sequence;\n      free (seq);\n    }\n  if (table->files != NULL)\n    free (table->files);\n  if (table->dirs != NULL)\n    free (table->dirs);\n  return NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -238,7 +238,7 @@\n       bfd_vma high_pc = 0;\n \n       /* Decode the table.  */\n-      while (! end_sequence)\n+      while (!end_sequence && line_ptr < line_end)\n \t{\n \t  op_code = read_1_byte (abfd, line_ptr, line_end);\n \t  line_ptr += 1;",
        "diff_line_info": {
            "deleted_lines": [
                "      while (! end_sequence)"
            ],
            "added_lines": [
                "      while (!end_sequence && line_ptr < line_end)"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14933",
        "func_name": "binutils-gdb/read_formatted_entries",
        "description": "read_formatted_entries in dwarf2.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (infinite loop) via a crafted ELF file.",
        "git_url": "https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=30d0157a2ad64e64e5ff9fcc0dbe78a3e682f573",
        "commit_title": "",
        "commit_text": "Avoid needless resource usage when processing a corrupt DWARF directory or file name table.  \tPR 22210 \t* dwarf2.c (read_formatted_entries): Fail early if we know that \tthe loop parsing data entries will overflow the end of the \tsection. ",
        "func_before": "static bfd_boolean\nread_formatted_entries (struct comp_unit *unit, bfd_byte **bufp,\n\t\t\tbfd_byte *buf_end, struct line_info_table *table,\n\t\t\tbfd_boolean (*callback) (struct line_info_table *table,\n\t\t\t\t\t\t char *cur_file,\n\t\t\t\t\t\t unsigned int dir,\n\t\t\t\t\t\t unsigned int time,\n\t\t\t\t\t\t unsigned int size))\n{\n  bfd *abfd = unit->abfd;\n  bfd_byte format_count, formati;\n  bfd_vma data_count, datai;\n  bfd_byte *buf = *bufp;\n  bfd_byte *format_header_data;\n  unsigned int bytes_read;\n\n  format_count = read_1_byte (abfd, buf, buf_end);\n  buf += 1;\n  format_header_data = buf;\n  for (formati = 0; formati < format_count; formati++)\n    {\n      _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE, buf_end);\n      buf += bytes_read;\n      _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE, buf_end);\n      buf += bytes_read;\n    }\n\n  data_count = _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE, buf_end);\n  buf += bytes_read;\n  if (format_count == 0 && data_count != 0)\n    {\n      _bfd_error_handler (_(\"Dwarf Error: Zero format count.\"));\n      bfd_set_error (bfd_error_bad_value);\n      return FALSE;\n    }\n\n  for (datai = 0; datai < data_count; datai++)\n    {\n      bfd_byte *format = format_header_data;\n      struct fileinfo fe;\n\n      memset (&fe, 0, sizeof fe);\n      for (formati = 0; formati < format_count; formati++)\n\t{\n\t  bfd_vma content_type, form;\n\t  char *string_trash;\n\t  char **stringp = &string_trash;\n\t  unsigned int uint_trash, *uintp = &uint_trash;\n\n\t  content_type = _bfd_safe_read_leb128 (abfd, format, &bytes_read,\n\t\t\t\t\t\tFALSE, buf_end);\n\t  format += bytes_read;\n\t  switch (content_type)\n\t    {\n\t    case DW_LNCT_path:\n\t      stringp = &fe.name;\n\t      break;\n\t    case DW_LNCT_directory_index:\n\t      uintp = &fe.dir;\n\t      break;\n\t    case DW_LNCT_timestamp:\n\t      uintp = &fe.time;\n\t      break;\n\t    case DW_LNCT_size:\n\t      uintp = &fe.size;\n\t      break;\n\t    case DW_LNCT_MD5:\n\t      break;\n\t    default:\n\t      _bfd_error_handler\n\t\t(_(\"Dwarf Error: Unknown format content type %Lu.\"),\n\t\t content_type);\n\t      bfd_set_error (bfd_error_bad_value);\n\t      return FALSE;\n\t    }\n\n\t  form = _bfd_safe_read_leb128 (abfd, format, &bytes_read, FALSE,\n\t\t\t\t\tbuf_end);\n\t  format += bytes_read;\n\t  switch (form)\n\t    {\n\t    case DW_FORM_string:\n\t      *stringp = read_string (abfd, buf, buf_end, &bytes_read);\n\t      buf += bytes_read;\n\t      break;\n\n\t    case DW_FORM_line_strp:\n\t      *stringp = read_indirect_line_string (unit, buf, buf_end, &bytes_read);\n\t      buf += bytes_read;\n\t      break;\n\n\t    case DW_FORM_data1:\n\t      *uintp = read_1_byte (abfd, buf, buf_end);\n\t      buf += 1;\n\t      break;\n\n\t    case DW_FORM_data2:\n\t      *uintp = read_2_bytes (abfd, buf, buf_end);\n\t      buf += 2;\n\t      break;\n\n\t    case DW_FORM_data4:\n\t      *uintp = read_4_bytes (abfd, buf, buf_end);\n\t      buf += 4;\n\t      break;\n\n\t    case DW_FORM_data8:\n\t      *uintp = read_8_bytes (abfd, buf, buf_end);\n\t      buf += 8;\n\t      break;\n\n\t    case DW_FORM_udata:\n\t      *uintp = _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE,\n\t\t\t\t\t      buf_end);\n\t      buf += bytes_read;\n\t      break;\n\n\t    case DW_FORM_block:\n\t      /* It is valid only for DW_LNCT_timestamp which is ignored by\n\t\t current GDB.  */\n\t      break;\n\t    }\n\t}\n\n      if (!callback (table, fe.name, fe.dir, fe.time, fe.size))\n\treturn FALSE;\n    }\n\n  *bufp = buf;\n  return TRUE;\n}",
        "func": "static bfd_boolean\nread_formatted_entries (struct comp_unit *unit, bfd_byte **bufp,\n\t\t\tbfd_byte *buf_end, struct line_info_table *table,\n\t\t\tbfd_boolean (*callback) (struct line_info_table *table,\n\t\t\t\t\t\t char *cur_file,\n\t\t\t\t\t\t unsigned int dir,\n\t\t\t\t\t\t unsigned int time,\n\t\t\t\t\t\t unsigned int size))\n{\n  bfd *abfd = unit->abfd;\n  bfd_byte format_count, formati;\n  bfd_vma data_count, datai;\n  bfd_byte *buf = *bufp;\n  bfd_byte *format_header_data;\n  unsigned int bytes_read;\n\n  format_count = read_1_byte (abfd, buf, buf_end);\n  buf += 1;\n  format_header_data = buf;\n  for (formati = 0; formati < format_count; formati++)\n    {\n      _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE, buf_end);\n      buf += bytes_read;\n      _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE, buf_end);\n      buf += bytes_read;\n    }\n\n  data_count = _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE, buf_end);\n  buf += bytes_read;\n  if (format_count == 0 && data_count != 0)\n    {\n      _bfd_error_handler (_(\"Dwarf Error: Zero format count.\"));\n      bfd_set_error (bfd_error_bad_value);\n      return FALSE;\n    }\n\n  /* PR 22210.  Paranoia check.  Don't bother running the loop\n     if we know that we are going to run out of buffer.  */\n  if (data_count > (bfd_vma) (buf_end - buf))\n    {\n      _bfd_error_handler (_(\"Dwarf Error: data count (%Lx) larger than buffer size.\"),\n\t\t\t  data_count);\n      bfd_set_error (bfd_error_bad_value);\n      return FALSE;\n    }\n\n  for (datai = 0; datai < data_count; datai++)\n    {\n      bfd_byte *format = format_header_data;\n      struct fileinfo fe;\n\n      memset (&fe, 0, sizeof fe);\n      for (formati = 0; formati < format_count; formati++)\n\t{\n\t  bfd_vma content_type, form;\n\t  char *string_trash;\n\t  char **stringp = &string_trash;\n\t  unsigned int uint_trash, *uintp = &uint_trash;\n\n\t  content_type = _bfd_safe_read_leb128 (abfd, format, &bytes_read,\n\t\t\t\t\t\tFALSE, buf_end);\n\t  format += bytes_read;\n\t  switch (content_type)\n\t    {\n\t    case DW_LNCT_path:\n\t      stringp = &fe.name;\n\t      break;\n\t    case DW_LNCT_directory_index:\n\t      uintp = &fe.dir;\n\t      break;\n\t    case DW_LNCT_timestamp:\n\t      uintp = &fe.time;\n\t      break;\n\t    case DW_LNCT_size:\n\t      uintp = &fe.size;\n\t      break;\n\t    case DW_LNCT_MD5:\n\t      break;\n\t    default:\n\t      _bfd_error_handler\n\t\t(_(\"Dwarf Error: Unknown format content type %Lu.\"),\n\t\t content_type);\n\t      bfd_set_error (bfd_error_bad_value);\n\t      return FALSE;\n\t    }\n\n\t  form = _bfd_safe_read_leb128 (abfd, format, &bytes_read, FALSE,\n\t\t\t\t\tbuf_end);\n\t  format += bytes_read;\n\t  switch (form)\n\t    {\n\t    case DW_FORM_string:\n\t      *stringp = read_string (abfd, buf, buf_end, &bytes_read);\n\t      buf += bytes_read;\n\t      break;\n\n\t    case DW_FORM_line_strp:\n\t      *stringp = read_indirect_line_string (unit, buf, buf_end, &bytes_read);\n\t      buf += bytes_read;\n\t      break;\n\n\t    case DW_FORM_data1:\n\t      *uintp = read_1_byte (abfd, buf, buf_end);\n\t      buf += 1;\n\t      break;\n\n\t    case DW_FORM_data2:\n\t      *uintp = read_2_bytes (abfd, buf, buf_end);\n\t      buf += 2;\n\t      break;\n\n\t    case DW_FORM_data4:\n\t      *uintp = read_4_bytes (abfd, buf, buf_end);\n\t      buf += 4;\n\t      break;\n\n\t    case DW_FORM_data8:\n\t      *uintp = read_8_bytes (abfd, buf, buf_end);\n\t      buf += 8;\n\t      break;\n\n\t    case DW_FORM_udata:\n\t      *uintp = _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE,\n\t\t\t\t\t      buf_end);\n\t      buf += bytes_read;\n\t      break;\n\n\t    case DW_FORM_block:\n\t      /* It is valid only for DW_LNCT_timestamp which is ignored by\n\t\t current GDB.  */\n\t      break;\n\t    }\n\t}\n\n      if (!callback (table, fe.name, fe.dir, fe.time, fe.size))\n\treturn FALSE;\n    }\n\n  *bufp = buf;\n  return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,6 +30,16 @@\n   if (format_count == 0 && data_count != 0)\n     {\n       _bfd_error_handler (_(\"Dwarf Error: Zero format count.\"));\n+      bfd_set_error (bfd_error_bad_value);\n+      return FALSE;\n+    }\n+\n+  /* PR 22210.  Paranoia check.  Don't bother running the loop\n+     if we know that we are going to run out of buffer.  */\n+  if (data_count > (bfd_vma) (buf_end - buf))\n+    {\n+      _bfd_error_handler (_(\"Dwarf Error: data count (%Lx) larger than buffer size.\"),\n+\t\t\t  data_count);\n       bfd_set_error (bfd_error_bad_value);\n       return FALSE;\n     }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      bfd_set_error (bfd_error_bad_value);",
                "      return FALSE;",
                "    }",
                "",
                "  /* PR 22210.  Paranoia check.  Don't bother running the loop",
                "     if we know that we are going to run out of buffer.  */",
                "  if (data_count > (bfd_vma) (buf_end - buf))",
                "    {",
                "      _bfd_error_handler (_(\"Dwarf Error: data count (%Lx) larger than buffer size.\"),",
                "\t\t\t  data_count);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14933",
        "func_name": "binutils-gdb/read_formatted_entries",
        "description": "read_formatted_entries in dwarf2.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (infinite loop) via a crafted ELF file.",
        "git_url": "https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=33e0a9a056bd23e923b929a4f2ab049ade0b1c32",
        "commit_title": "",
        "commit_text": "Tidy reading data in read_formatted_entries  Using read_attribute_value accomplishes two things: It checks for unexpected formats, and ensures the buffer pointer always increments.  \tPR 22210 \t* dwarf2.c (read_formatted_entries): Use read_attribute_value to \tread data. ",
        "func_before": "static bfd_boolean\nread_formatted_entries (struct comp_unit *unit, bfd_byte **bufp,\n\t\t\tbfd_byte *buf_end, struct line_info_table *table,\n\t\t\tbfd_boolean (*callback) (struct line_info_table *table,\n\t\t\t\t\t\t char *cur_file,\n\t\t\t\t\t\t unsigned int dir,\n\t\t\t\t\t\t unsigned int time,\n\t\t\t\t\t\t unsigned int size))\n{\n  bfd *abfd = unit->abfd;\n  bfd_byte format_count, formati;\n  bfd_vma data_count, datai;\n  bfd_byte *buf = *bufp;\n  bfd_byte *format_header_data;\n  unsigned int bytes_read;\n\n  format_count = read_1_byte (abfd, buf, buf_end);\n  buf += 1;\n  format_header_data = buf;\n  for (formati = 0; formati < format_count; formati++)\n    {\n      _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE, buf_end);\n      buf += bytes_read;\n      _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE, buf_end);\n      buf += bytes_read;\n    }\n\n  data_count = _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE, buf_end);\n  buf += bytes_read;\n  if (format_count == 0 && data_count != 0)\n    {\n      _bfd_error_handler (_(\"Dwarf Error: Zero format count.\"));\n      bfd_set_error (bfd_error_bad_value);\n      return FALSE;\n    }\n\n  /* PR 22210.  Paranoia check.  Don't bother running the loop\n     if we know that we are going to run out of buffer.  */\n  if (data_count > (bfd_vma) (buf_end - buf))\n    {\n      _bfd_error_handler (_(\"Dwarf Error: data count (%Lx) larger than buffer size.\"),\n\t\t\t  data_count);\n      bfd_set_error (bfd_error_bad_value);\n      return FALSE;\n    }\n\n  for (datai = 0; datai < data_count; datai++)\n    {\n      bfd_byte *format = format_header_data;\n      struct fileinfo fe;\n\n      memset (&fe, 0, sizeof fe);\n      for (formati = 0; formati < format_count; formati++)\n\t{\n\t  bfd_vma content_type, form;\n\t  char *string_trash;\n\t  char **stringp = &string_trash;\n\t  unsigned int uint_trash, *uintp = &uint_trash;\n\n\t  content_type = _bfd_safe_read_leb128 (abfd, format, &bytes_read,\n\t\t\t\t\t\tFALSE, buf_end);\n\t  format += bytes_read;\n\t  switch (content_type)\n\t    {\n\t    case DW_LNCT_path:\n\t      stringp = &fe.name;\n\t      break;\n\t    case DW_LNCT_directory_index:\n\t      uintp = &fe.dir;\n\t      break;\n\t    case DW_LNCT_timestamp:\n\t      uintp = &fe.time;\n\t      break;\n\t    case DW_LNCT_size:\n\t      uintp = &fe.size;\n\t      break;\n\t    case DW_LNCT_MD5:\n\t      break;\n\t    default:\n\t      _bfd_error_handler\n\t\t(_(\"Dwarf Error: Unknown format content type %Lu.\"),\n\t\t content_type);\n\t      bfd_set_error (bfd_error_bad_value);\n\t      return FALSE;\n\t    }\n\n\t  form = _bfd_safe_read_leb128 (abfd, format, &bytes_read, FALSE,\n\t\t\t\t\tbuf_end);\n\t  format += bytes_read;\n\t  switch (form)\n\t    {\n\t    case DW_FORM_string:\n\t      *stringp = read_string (abfd, buf, buf_end, &bytes_read);\n\t      buf += bytes_read;\n\t      break;\n\n\t    case DW_FORM_line_strp:\n\t      *stringp = read_indirect_line_string (unit, buf, buf_end, &bytes_read);\n\t      buf += bytes_read;\n\t      break;\n\n\t    case DW_FORM_data1:\n\t      *uintp = read_1_byte (abfd, buf, buf_end);\n\t      buf += 1;\n\t      break;\n\n\t    case DW_FORM_data2:\n\t      *uintp = read_2_bytes (abfd, buf, buf_end);\n\t      buf += 2;\n\t      break;\n\n\t    case DW_FORM_data4:\n\t      *uintp = read_4_bytes (abfd, buf, buf_end);\n\t      buf += 4;\n\t      break;\n\n\t    case DW_FORM_data8:\n\t      *uintp = read_8_bytes (abfd, buf, buf_end);\n\t      buf += 8;\n\t      break;\n\n\t    case DW_FORM_udata:\n\t      *uintp = _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE,\n\t\t\t\t\t      buf_end);\n\t      buf += bytes_read;\n\t      break;\n\n\t    case DW_FORM_block:\n\t      /* It is valid only for DW_LNCT_timestamp which is ignored by\n\t\t current GDB.  */\n\t      break;\n\t    }\n\t}\n\n      if (!callback (table, fe.name, fe.dir, fe.time, fe.size))\n\treturn FALSE;\n    }\n\n  *bufp = buf;\n  return TRUE;\n}",
        "func": "static bfd_boolean\nread_formatted_entries (struct comp_unit *unit, bfd_byte **bufp,\n\t\t\tbfd_byte *buf_end, struct line_info_table *table,\n\t\t\tbfd_boolean (*callback) (struct line_info_table *table,\n\t\t\t\t\t\t char *cur_file,\n\t\t\t\t\t\t unsigned int dir,\n\t\t\t\t\t\t unsigned int time,\n\t\t\t\t\t\t unsigned int size))\n{\n  bfd *abfd = unit->abfd;\n  bfd_byte format_count, formati;\n  bfd_vma data_count, datai;\n  bfd_byte *buf = *bufp;\n  bfd_byte *format_header_data;\n  unsigned int bytes_read;\n\n  format_count = read_1_byte (abfd, buf, buf_end);\n  buf += 1;\n  format_header_data = buf;\n  for (formati = 0; formati < format_count; formati++)\n    {\n      _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE, buf_end);\n      buf += bytes_read;\n      _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE, buf_end);\n      buf += bytes_read;\n    }\n\n  data_count = _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE, buf_end);\n  buf += bytes_read;\n  if (format_count == 0 && data_count != 0)\n    {\n      _bfd_error_handler (_(\"Dwarf Error: Zero format count.\"));\n      bfd_set_error (bfd_error_bad_value);\n      return FALSE;\n    }\n\n  /* PR 22210.  Paranoia check.  Don't bother running the loop\n     if we know that we are going to run out of buffer.  */\n  if (data_count > (bfd_vma) (buf_end - buf))\n    {\n      _bfd_error_handler (_(\"Dwarf Error: data count (%Lx) larger than buffer size.\"),\n\t\t\t  data_count);\n      bfd_set_error (bfd_error_bad_value);\n      return FALSE;\n    }\n\n  for (datai = 0; datai < data_count; datai++)\n    {\n      bfd_byte *format = format_header_data;\n      struct fileinfo fe;\n\n      memset (&fe, 0, sizeof fe);\n      for (formati = 0; formati < format_count; formati++)\n\t{\n\t  bfd_vma content_type, form;\n\t  char *string_trash;\n\t  char **stringp = &string_trash;\n\t  unsigned int uint_trash, *uintp = &uint_trash;\n\t  struct attribute attr;\n\n\t  content_type = _bfd_safe_read_leb128 (abfd, format, &bytes_read,\n\t\t\t\t\t\tFALSE, buf_end);\n\t  format += bytes_read;\n\t  switch (content_type)\n\t    {\n\t    case DW_LNCT_path:\n\t      stringp = &fe.name;\n\t      break;\n\t    case DW_LNCT_directory_index:\n\t      uintp = &fe.dir;\n\t      break;\n\t    case DW_LNCT_timestamp:\n\t      uintp = &fe.time;\n\t      break;\n\t    case DW_LNCT_size:\n\t      uintp = &fe.size;\n\t      break;\n\t    case DW_LNCT_MD5:\n\t      break;\n\t    default:\n\t      _bfd_error_handler\n\t\t(_(\"Dwarf Error: Unknown format content type %Lu.\"),\n\t\t content_type);\n\t      bfd_set_error (bfd_error_bad_value);\n\t      return FALSE;\n\t    }\n\n\t  form = _bfd_safe_read_leb128 (abfd, format, &bytes_read, FALSE,\n\t\t\t\t\tbuf_end);\n\t  format += bytes_read;\n\n\t  buf = read_attribute_value (&attr, form, 0, unit, buf, buf_end);\n\t  if (buf == NULL)\n\t    return FALSE;\n\t  switch (form)\n\t    {\n\t    case DW_FORM_string:\n\t    case DW_FORM_line_strp:\n\t      *stringp = attr.u.str;\n\t      break;\n\n\t    case DW_FORM_data1:\n\t    case DW_FORM_data2:\n\t    case DW_FORM_data4:\n\t    case DW_FORM_data8:\n\t    case DW_FORM_udata:\n\t      *uintp = attr.u.val;\n\t      break;\n\t    }\n\t}\n\n      if (!callback (table, fe.name, fe.dir, fe.time, fe.size))\n\treturn FALSE;\n    }\n\n  *bufp = buf;\n  return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -56,6 +56,7 @@\n \t  char *string_trash;\n \t  char **stringp = &string_trash;\n \t  unsigned int uint_trash, *uintp = &uint_trash;\n+\t  struct attribute attr;\n \n \t  content_type = _bfd_safe_read_leb128 (abfd, format, &bytes_read,\n \t\t\t\t\t\tFALSE, buf_end);\n@@ -87,47 +88,23 @@\n \t  form = _bfd_safe_read_leb128 (abfd, format, &bytes_read, FALSE,\n \t\t\t\t\tbuf_end);\n \t  format += bytes_read;\n+\n+\t  buf = read_attribute_value (&attr, form, 0, unit, buf, buf_end);\n+\t  if (buf == NULL)\n+\t    return FALSE;\n \t  switch (form)\n \t    {\n \t    case DW_FORM_string:\n-\t      *stringp = read_string (abfd, buf, buf_end, &bytes_read);\n-\t      buf += bytes_read;\n-\t      break;\n-\n \t    case DW_FORM_line_strp:\n-\t      *stringp = read_indirect_line_string (unit, buf, buf_end, &bytes_read);\n-\t      buf += bytes_read;\n+\t      *stringp = attr.u.str;\n \t      break;\n \n \t    case DW_FORM_data1:\n-\t      *uintp = read_1_byte (abfd, buf, buf_end);\n-\t      buf += 1;\n-\t      break;\n-\n \t    case DW_FORM_data2:\n-\t      *uintp = read_2_bytes (abfd, buf, buf_end);\n-\t      buf += 2;\n-\t      break;\n-\n \t    case DW_FORM_data4:\n-\t      *uintp = read_4_bytes (abfd, buf, buf_end);\n-\t      buf += 4;\n-\t      break;\n-\n \t    case DW_FORM_data8:\n-\t      *uintp = read_8_bytes (abfd, buf, buf_end);\n-\t      buf += 8;\n-\t      break;\n-\n \t    case DW_FORM_udata:\n-\t      *uintp = _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE,\n-\t\t\t\t\t      buf_end);\n-\t      buf += bytes_read;\n-\t      break;\n-\n-\t    case DW_FORM_block:\n-\t      /* It is valid only for DW_LNCT_timestamp which is ignored by\n-\t\t current GDB.  */\n+\t      *uintp = attr.u.val;\n \t      break;\n \t    }\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t      *stringp = read_string (abfd, buf, buf_end, &bytes_read);",
                "\t      buf += bytes_read;",
                "\t      break;",
                "",
                "\t      *stringp = read_indirect_line_string (unit, buf, buf_end, &bytes_read);",
                "\t      buf += bytes_read;",
                "\t      *uintp = read_1_byte (abfd, buf, buf_end);",
                "\t      buf += 1;",
                "\t      break;",
                "",
                "\t      *uintp = read_2_bytes (abfd, buf, buf_end);",
                "\t      buf += 2;",
                "\t      break;",
                "",
                "\t      *uintp = read_4_bytes (abfd, buf, buf_end);",
                "\t      buf += 4;",
                "\t      break;",
                "",
                "\t      *uintp = read_8_bytes (abfd, buf, buf_end);",
                "\t      buf += 8;",
                "\t      break;",
                "",
                "\t      *uintp = _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE,",
                "\t\t\t\t\t      buf_end);",
                "\t      buf += bytes_read;",
                "\t      break;",
                "",
                "\t    case DW_FORM_block:",
                "\t      /* It is valid only for DW_LNCT_timestamp which is ignored by",
                "\t\t current GDB.  */"
            ],
            "added_lines": [
                "\t  struct attribute attr;",
                "",
                "\t  buf = read_attribute_value (&attr, form, 0, unit, buf, buf_end);",
                "\t  if (buf == NULL)",
                "\t    return FALSE;",
                "\t      *stringp = attr.u.str;",
                "\t      *uintp = attr.u.val;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14934",
        "func_name": "binutils-gdb/process_debug_info",
        "description": "process_debug_info in dwarf.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (infinite loop) via a crafted ELF file that contains a negative size value in a CU structure.",
        "git_url": "https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=19485196044b2521af979f1e5c4a89bfb90fba0b",
        "commit_title": "",
        "commit_text": "Prevent an infinite loop in the DWARF parsing code when encountering a CU structure with a small negative size.  \tPR 22219 \t* dwarf.c (process_debug_info): Add a check for a negative \tcu_length field. ",
        "func_before": "static int\nprocess_debug_info (struct dwarf_section *section,\n\t\t    void *file,\n\t\t    enum dwarf_section_display_enum abbrev_sec,\n\t\t    int do_loc,\n\t\t    int do_types)\n{\n  unsigned char *start = section->start;\n  unsigned char *end = start + section->size;\n  unsigned char *section_begin;\n  unsigned int unit;\n  unsigned int num_units = 0;\n\n  if ((do_loc || do_debug_loc || do_debug_ranges)\n      && num_debug_info_entries == 0\n      && ! do_types)\n    {\n      dwarf_vma length;\n\n      /* First scan the section to get the number of comp units.  */\n      for (section_begin = start, num_units = 0; section_begin < end;\n\t   num_units ++)\n\t{\n\t  /* Read the first 4 bytes.  For a 32-bit DWARF section, this\n\t     will be the length.  For a 64-bit DWARF section, it'll be\n\t     the escape code 0xffffffff followed by an 8 byte length.  */\n\t  SAFE_BYTE_GET (length, section_begin, 4, end);\n\n\t  if (length == 0xffffffff)\n\t    {\n\t      SAFE_BYTE_GET (length, section_begin + 4, 8, end);\n\t      section_begin += length + 12;\n\t    }\n\t  else if (length >= 0xfffffff0 && length < 0xffffffff)\n\t    {\n\t      warn (_(\"Reserved length value (0x%s) found in section %s\\n\"),\n\t\t    dwarf_vmatoa (\"x\", length), section->name);\n\t      return 0;\n\t    }\n\t  else\n\t    section_begin += length + 4;\n\n\t  /* Negative values are illegal, they may even cause infinite\n\t     looping.  This can happen if we can't accurately apply\n\t     relocations to an object file, or if the file is corrupt.  */\n\t  if ((signed long) length <= 0 || section_begin < start)\n\t    {\n\t      warn (_(\"Corrupt unit length (0x%s) found in section %s\\n\"),\n\t\t    dwarf_vmatoa (\"x\", length), section->name);\n\t      return 0;\n\t    }\n\t}\n\n      if (num_units == 0)\n\t{\n\t  error (_(\"No comp units in %s section ?\\n\"), section->name);\n\t  return 0;\n\t}\n\n      /* Then allocate an array to hold the information.  */\n      debug_information = (debug_info *) cmalloc (num_units,\n\t\t\t\t\t\t  sizeof (* debug_information));\n      if (debug_information == NULL)\n\t{\n\t  error (_(\"Not enough memory for a debug info array of %u entries\\n\"),\n\t\t num_units);\n\t  alloc_num_debug_info_entries = num_debug_info_entries = 0;\n\t  return 0;\n\t}\n      /* PR 17531: file: 92ca3797.\n\t We cannot rely upon the debug_information array being initialised\n\t before it is used.  A corrupt file could easily contain references\n\t to a unit for which information has not been made available.  So\n\t we ensure that the array is zeroed here.  */\n      memset (debug_information, 0, num_units * sizeof (*debug_information));\n\n      alloc_num_debug_info_entries = num_units;\n    }\n\n  if (!do_loc)\n    {\n      if (dwarf_start_die == 0)\n\tprintf (_(\"Contents of the %s section:\\n\\n\"), section->name);\n\n      load_debug_section (str, file);\n      load_debug_section (line_str, file);\n      load_debug_section (str_dwo, file);\n      load_debug_section (str_index, file);\n      load_debug_section (str_index_dwo, file);\n      load_debug_section (debug_addr, file);\n    }\n\n  load_debug_section (abbrev_sec, file);\n  if (debug_displays [abbrev_sec].section.start == NULL)\n    {\n      warn (_(\"Unable to locate %s section!\\n\"),\n\t    debug_displays [abbrev_sec].section.name);\n      return 0;\n    }\n\n  for (section_begin = start, unit = 0; start < end; unit++)\n    {\n      DWARF2_Internal_CompUnit compunit;\n      unsigned char *hdrptr;\n      unsigned char *tags;\n      int level, last_level, saved_level;\n      dwarf_vma cu_offset;\n      unsigned int offset_size;\n      int initial_length_size;\n      dwarf_vma signature_high = 0;\n      dwarf_vma signature_low = 0;\n      dwarf_vma type_offset = 0;\n      struct cu_tu_set *this_set;\n      dwarf_vma abbrev_base;\n      size_t abbrev_size;\n\n      hdrptr = start;\n\n      SAFE_BYTE_GET_AND_INC (compunit.cu_length, hdrptr, 4, end);\n\n      if (compunit.cu_length == 0xffffffff)\n\t{\n\t  SAFE_BYTE_GET_AND_INC (compunit.cu_length, hdrptr, 8, end);\n\t  offset_size = 8;\n\t  initial_length_size = 12;\n\t}\n      else\n\t{\n\t  offset_size = 4;\n\t  initial_length_size = 4;\n\t}\n\n      SAFE_BYTE_GET_AND_INC (compunit.cu_version, hdrptr, 2, end);\n\n      cu_offset = start - section_begin;\n\n      this_set = find_cu_tu_set_v2 (cu_offset, do_types);\n\n      if (compunit.cu_version < 5)\n\t{\n\t  compunit.cu_unit_type = DW_UT_compile;\n\t  /* Initialize it due to a false compiler warning.  */\n\t  compunit.cu_pointer_size = -1;\n\t}\n      else\n\t{\n\t  SAFE_BYTE_GET_AND_INC (compunit.cu_unit_type, hdrptr, 1, end);\n\t  do_types = (compunit.cu_unit_type == DW_UT_type);\n\n\t  SAFE_BYTE_GET_AND_INC (compunit.cu_pointer_size, hdrptr, 1, end);\n\t}\n\n      SAFE_BYTE_GET_AND_INC (compunit.cu_abbrev_offset, hdrptr, offset_size, end);\n\n      if (this_set == NULL)\n\t{\n\t  abbrev_base = 0;\n\t  abbrev_size = debug_displays [abbrev_sec].section.size;\n\t}\n      else\n\t{\n\t  abbrev_base = this_set->section_offsets [DW_SECT_ABBREV];\n\t  abbrev_size = this_set->section_sizes [DW_SECT_ABBREV];\n\t}\n\n      if (compunit.cu_version < 5)\n\tSAFE_BYTE_GET_AND_INC (compunit.cu_pointer_size, hdrptr, 1, end);\n\n      /* PR 17512: file: 001-108546-0.001:0.1.  */\n      if (compunit.cu_pointer_size < 2 || compunit.cu_pointer_size > 8)\n\t{\n\t  warn (_(\"Invalid pointer size (%d) in compunit header, using %d instead\\n\"),\n\t\tcompunit.cu_pointer_size, offset_size);\n\t  compunit.cu_pointer_size = offset_size;\n\t}\n\n      if (do_types)\n\t{\n\t  SAFE_BYTE_GET64 (hdrptr, &signature_high, &signature_low, end);\n\t  hdrptr += 8;\n\t  SAFE_BYTE_GET_AND_INC (type_offset, hdrptr, offset_size, end);\n\t}\n\n      if ((do_loc || do_debug_loc || do_debug_ranges)\n\t  && num_debug_info_entries == 0\n\t  && ! do_types)\n\t{\n\t  debug_information [unit].cu_offset = cu_offset;\n\t  debug_information [unit].pointer_size\n\t    = compunit.cu_pointer_size;\n\t  debug_information [unit].offset_size = offset_size;\n\t  debug_information [unit].dwarf_version = compunit.cu_version;\n\t  debug_information [unit].base_address = 0;\n\t  debug_information [unit].addr_base = DEBUG_INFO_UNAVAILABLE;\n\t  debug_information [unit].ranges_base = DEBUG_INFO_UNAVAILABLE;\n\t  debug_information [unit].loc_offsets = NULL;\n\t  debug_information [unit].have_frame_base = NULL;\n\t  debug_information [unit].max_loc_offsets = 0;\n\t  debug_information [unit].num_loc_offsets = 0;\n\t  debug_information [unit].range_lists = NULL;\n\t  debug_information [unit].max_range_lists= 0;\n\t  debug_information [unit].num_range_lists = 0;\n\t}\n\n      if (!do_loc && dwarf_start_die == 0)\n\t{\n\t  printf (_(\"  Compilation Unit @ offset 0x%s:\\n\"),\n\t\t  dwarf_vmatoa (\"x\", cu_offset));\n\t  printf (_(\"   Length:        0x%s (%s)\\n\"),\n\t\t  dwarf_vmatoa (\"x\", compunit.cu_length),\n\t\t  offset_size == 8 ? \"64-bit\" : \"32-bit\");\n\t  printf (_(\"   Version:       %d\\n\"), compunit.cu_version);\n\t  printf (_(\"   Abbrev Offset: 0x%s\\n\"),\n\t\t  dwarf_vmatoa (\"x\", compunit.cu_abbrev_offset));\n\t  printf (_(\"   Pointer Size:  %d\\n\"), compunit.cu_pointer_size);\n\t  if (do_types)\n\t    {\n\t      char buf[64];\n\n\t      printf (_(\"   Signature:     0x%s\\n\"),\n\t\t      dwarf_vmatoa64 (signature_high, signature_low,\n\t\t\t\t      buf, sizeof (buf)));\n\t      printf (_(\"   Type Offset:   0x%s\\n\"),\n\t\t      dwarf_vmatoa (\"x\", type_offset));\n\t    }\n\t  if (this_set != NULL)\n\t    {\n\t      dwarf_vma *offsets = this_set->section_offsets;\n\t      size_t *sizes = this_set->section_sizes;\n\n\t      printf (_(\"   Section contributions:\\n\"));\n\t      printf (_(\"    .debug_abbrev.dwo:       0x%s  0x%s\\n\"),\n\t\t      dwarf_vmatoa (\"x\", offsets [DW_SECT_ABBREV]),\n\t\t      dwarf_vmatoa (\"x\", sizes [DW_SECT_ABBREV]));\n\t      printf (_(\"    .debug_line.dwo:         0x%s  0x%s\\n\"),\n\t\t      dwarf_vmatoa (\"x\", offsets [DW_SECT_LINE]),\n\t\t      dwarf_vmatoa (\"x\", sizes [DW_SECT_LINE]));\n\t      printf (_(\"    .debug_loc.dwo:          0x%s  0x%s\\n\"),\n\t\t      dwarf_vmatoa (\"x\", offsets [DW_SECT_LOC]),\n\t\t      dwarf_vmatoa (\"x\", sizes [DW_SECT_LOC]));\n\t      printf (_(\"    .debug_str_offsets.dwo:  0x%s  0x%s\\n\"),\n\t\t      dwarf_vmatoa (\"x\", offsets [DW_SECT_STR_OFFSETS]),\n\t\t      dwarf_vmatoa (\"x\", sizes [DW_SECT_STR_OFFSETS]));\n\t    }\n\t}\n\n      if (cu_offset + compunit.cu_length + initial_length_size\n\t  > section->size)\n\t{\n\t  warn (_(\"Debug info is corrupted, length of CU at %s\"\n\t\t  \" extends beyond end of section (length = %s)\\n\"),\n\t\tdwarf_vmatoa (\"x\", cu_offset),\n\t\tdwarf_vmatoa (\"x\", compunit.cu_length));\n\t  num_units = unit;\n\t  break;\n\t}\n      tags = hdrptr;\n      start += compunit.cu_length + initial_length_size;\n\n      if (start > end)\n\t{\n\t  warn (_(\"Debug info is corrupt.  CU at %s extends beyond end of section\"),\n\t\tdwarf_vmatoa (\"x\", cu_offset));\n\t  start = end;\n\t}\n\n      if (compunit.cu_version < 2 || compunit.cu_version > 5)\n\t{\n\t  warn (_(\"CU at offset %s contains corrupt or \"\n\t\t  \"unsupported version number: %d.\\n\"),\n\t\tdwarf_vmatoa (\"x\", cu_offset), compunit.cu_version);\n\t  continue;\n\t}\n\n      if (compunit.cu_unit_type != DW_UT_compile\n\t  && compunit.cu_unit_type != DW_UT_type)\n\t{\n\t  warn (_(\"CU at offset %s contains corrupt or \"\n\t\t  \"unsupported unit type: %d.\\n\"),\n\t\tdwarf_vmatoa (\"x\", cu_offset), compunit.cu_unit_type);\n\t  continue;\n\t}\n\n      free_abbrevs ();\n\n      /* Process the abbrevs used by this compilation unit.  */\n      if (compunit.cu_abbrev_offset >= abbrev_size)\n\twarn (_(\"Debug info is corrupted, abbrev offset (%lx) is larger than abbrev section size (%lx)\\n\"),\n\t      (unsigned long) compunit.cu_abbrev_offset,\n\t      (unsigned long) abbrev_size);\n      /* PR 17531: file:4bcd9ce9.  */\n      else if ((abbrev_base + abbrev_size)\n\t       > debug_displays [abbrev_sec].section.size)\n\twarn (_(\"Debug info is corrupted, abbrev size (%lx) is larger than abbrev section size (%lx)\\n\"),\n\t      (unsigned long) abbrev_base + abbrev_size,\n\t      (unsigned long) debug_displays [abbrev_sec].section.size);\n      else\n\tprocess_abbrev_section\n\t  (((unsigned char *) debug_displays [abbrev_sec].section.start\n\t    + abbrev_base + compunit.cu_abbrev_offset),\n\t   ((unsigned char *) debug_displays [abbrev_sec].section.start\n\t    + abbrev_base + abbrev_size));\n\n      level = 0;\n      last_level = level;\n      saved_level = -1;\n      while (tags < start)\n\t{\n\t  unsigned int bytes_read;\n\t  unsigned long abbrev_number;\n\t  unsigned long die_offset;\n\t  abbrev_entry *entry;\n\t  abbrev_attr *attr;\n\t  int do_printing = 1;\n\n\t  die_offset = tags - section_begin;\n\n\t  abbrev_number = read_uleb128 (tags, & bytes_read, start);\n\t  tags += bytes_read;\n\n\t  /* A null DIE marks the end of a list of siblings or it may also be\n\t     a section padding.  */\n\t  if (abbrev_number == 0)\n\t    {\n\t      /* Check if it can be a section padding for the last CU.  */\n\t      if (level == 0 && start == end)\n\t\t{\n\t\t  unsigned char *chk;\n\n\t\t  for (chk = tags; chk < start; chk++)\n\t\t    if (*chk != 0)\n\t\t      break;\n\t\t  if (chk == start)\n\t\t    break;\n\t\t}\n\n\t      if (!do_loc && die_offset >= dwarf_start_die\n\t\t  && (dwarf_cutoff_level == -1\n\t\t      || level < dwarf_cutoff_level))\n\t\tprintf (_(\" <%d><%lx>: Abbrev Number: 0\\n\"),\n\t\t\tlevel, die_offset);\n\n\t      --level;\n\t      if (level < 0)\n\t\t{\n\t\t  static unsigned num_bogus_warns = 0;\n\n\t\t  if (num_bogus_warns < 3)\n\t\t    {\n\t\t      warn (_(\"Bogus end-of-siblings marker detected at offset %lx in %s section\\n\"),\n\t\t\t    die_offset, section->name);\n\t\t      num_bogus_warns ++;\n\t\t      if (num_bogus_warns == 3)\n\t\t\twarn (_(\"Further warnings about bogus end-of-sibling markers suppressed\\n\"));\n\t\t    }\n\t\t}\n\t      if (dwarf_start_die != 0 && level < saved_level)\n\t\treturn 1;\n\t      continue;\n\t    }\n\n\t  if (!do_loc)\n\t    {\n\t      if (dwarf_start_die != 0 && die_offset < dwarf_start_die)\n\t\tdo_printing = 0;\n\t      else\n\t\t{\n\t\t  if (dwarf_start_die != 0 && die_offset == dwarf_start_die)\n\t\t    saved_level = level;\n\t\t  do_printing = (dwarf_cutoff_level == -1\n\t\t\t\t || level < dwarf_cutoff_level);\n\t\t  if (do_printing)\n\t\t    printf (_(\" <%d><%lx>: Abbrev Number: %lu\"),\n\t\t\t    level, die_offset, abbrev_number);\n\t\t  else if (dwarf_cutoff_level == -1\n\t\t\t   || last_level < dwarf_cutoff_level)\n\t\t    printf (_(\" <%d><%lx>: ...\\n\"), level, die_offset);\n\t\t  last_level = level;\n\t\t}\n\t    }\n\n\t  /* Scan through the abbreviation list until we reach the\n\t     correct entry.  */\n\t  for (entry = first_abbrev;\n\t       entry && entry->entry != abbrev_number;\n\t       entry = entry->next)\n\t    continue;\n\n\t  if (entry == NULL)\n\t    {\n\t      if (!do_loc && do_printing)\n\t\t{\n\t\t  printf (\"\\n\");\n\t\t  fflush (stdout);\n\t\t}\n\t      warn (_(\"DIE at offset 0x%lx refers to abbreviation number %lu which does not exist\\n\"),\n\t\t    die_offset, abbrev_number);\n\t      return 0;\n\t    }\n\n\t  if (!do_loc && do_printing)\n\t    printf (\" (%s)\\n\", get_TAG_name (entry->tag));\n\n\t  switch (entry->tag)\n\t    {\n\t    default:\n\t      need_base_address = 0;\n\t      break;\n\t    case DW_TAG_compile_unit:\n\t      need_base_address = 1;\n\t      break;\n\t    case DW_TAG_entry_point:\n\t    case DW_TAG_subprogram:\n\t      need_base_address = 0;\n\t      /* Assuming that there is no DW_AT_frame_base.  */\n\t      have_frame_base = 0;\n\t      break;\n\t    }\n\n\t  debug_info *debug_info_p =\n\t    (debug_information && unit < alloc_num_debug_info_entries)\n\t    ? debug_information + unit : NULL;\n\n\t  assert (!debug_info_p\n\t\t  || (debug_info_p->num_loc_offsets\n\t\t      == debug_info_p->num_loc_views));\n\n\t  for (attr = entry->first_attr;\n\t       attr && attr->attribute;\n\t       attr = attr->next)\n\t    {\n\t      if (! do_loc && do_printing)\n\t\t/* Show the offset from where the tag was extracted.  */\n\t\tprintf (\"    <%lx>\", (unsigned long)(tags - section_begin));\n\n\t      tags = read_and_display_attr (attr->attribute,\n\t\t\t\t\t    attr->form,\n\t\t\t\t\t    attr->implicit_const,\n\t\t\t\t\t    tags,\n\t\t\t\t\t    end,\n\t\t\t\t\t    cu_offset,\n\t\t\t\t\t    compunit.cu_pointer_size,\n\t\t\t\t\t    offset_size,\n\t\t\t\t\t    compunit.cu_version,\n\t\t\t\t\t    debug_info_p,\n\t\t\t\t\t    do_loc || ! do_printing,\n\t\t\t\t\t    section,\n\t\t\t\t\t    this_set);\n\t    }\n\n\t  /* If a locview attribute appears before a location one,\n\t     make sure we don't associate it with an earlier\n\t     loclist. */\n\t  if (debug_info_p)\n\t    switch (debug_info_p->num_loc_offsets - debug_info_p->num_loc_views)\n\t      {\n\t      case 1:\n\t\tdebug_info_p->loc_views [debug_info_p->num_loc_views] = vm1;\n\t\tdebug_info_p->num_loc_views++;\n\t\tassert (debug_info_p->num_loc_views\n\t\t\t== debug_info_p->num_loc_offsets);\n\t\tbreak;\n\n\t      case 0:\n\t\tbreak;\n\n\t      case -1:\n\t\twarn(_(\"DIE has locviews without loclist\\n\"));\n\t\tdebug_info_p->num_loc_views--;\n\t\tbreak;\n\n\t      default:\n\t\tassert (0);\n\t    }\n\n\t  if (entry->children)\n\t    ++level;\n\t}\n    }\n\n  /* Set num_debug_info_entries here so that it can be used to check if\n     we need to process .debug_loc and .debug_ranges sections.  */\n  if ((do_loc || do_debug_loc || do_debug_ranges)\n      && num_debug_info_entries == 0\n      && ! do_types)\n    {\n      if (num_units > alloc_num_debug_info_entries)\n\tnum_debug_info_entries = alloc_num_debug_info_entries;\n      else\n\tnum_debug_info_entries = num_units;\n    }\n\n  if (!do_loc)\n    printf (\"\\n\");\n\n  return 1;\n}",
        "func": "static int\nprocess_debug_info (struct dwarf_section *section,\n\t\t    void *file,\n\t\t    enum dwarf_section_display_enum abbrev_sec,\n\t\t    int do_loc,\n\t\t    int do_types)\n{\n  unsigned char *start = section->start;\n  unsigned char *end = start + section->size;\n  unsigned char *section_begin;\n  unsigned int unit;\n  unsigned int num_units = 0;\n\n  if ((do_loc || do_debug_loc || do_debug_ranges)\n      && num_debug_info_entries == 0\n      && ! do_types)\n    {\n      dwarf_vma length;\n\n      /* First scan the section to get the number of comp units.  */\n      for (section_begin = start, num_units = 0; section_begin < end;\n\t   num_units ++)\n\t{\n\t  /* Read the first 4 bytes.  For a 32-bit DWARF section, this\n\t     will be the length.  For a 64-bit DWARF section, it'll be\n\t     the escape code 0xffffffff followed by an 8 byte length.  */\n\t  SAFE_BYTE_GET (length, section_begin, 4, end);\n\n\t  if (length == 0xffffffff)\n\t    {\n\t      SAFE_BYTE_GET (length, section_begin + 4, 8, end);\n\t      section_begin += length + 12;\n\t    }\n\t  else if (length >= 0xfffffff0 && length < 0xffffffff)\n\t    {\n\t      warn (_(\"Reserved length value (0x%s) found in section %s\\n\"),\n\t\t    dwarf_vmatoa (\"x\", length), section->name);\n\t      return 0;\n\t    }\n\t  else\n\t    section_begin += length + 4;\n\n\t  /* Negative values are illegal, they may even cause infinite\n\t     looping.  This can happen if we can't accurately apply\n\t     relocations to an object file, or if the file is corrupt.  */\n\t  if ((signed long) length <= 0 || section_begin < start)\n\t    {\n\t      warn (_(\"Corrupt unit length (0x%s) found in section %s\\n\"),\n\t\t    dwarf_vmatoa (\"x\", length), section->name);\n\t      return 0;\n\t    }\n\t}\n\n      if (num_units == 0)\n\t{\n\t  error (_(\"No comp units in %s section ?\\n\"), section->name);\n\t  return 0;\n\t}\n\n      /* Then allocate an array to hold the information.  */\n      debug_information = (debug_info *) cmalloc (num_units,\n\t\t\t\t\t\t  sizeof (* debug_information));\n      if (debug_information == NULL)\n\t{\n\t  error (_(\"Not enough memory for a debug info array of %u entries\\n\"),\n\t\t num_units);\n\t  alloc_num_debug_info_entries = num_debug_info_entries = 0;\n\t  return 0;\n\t}\n      /* PR 17531: file: 92ca3797.\n\t We cannot rely upon the debug_information array being initialised\n\t before it is used.  A corrupt file could easily contain references\n\t to a unit for which information has not been made available.  So\n\t we ensure that the array is zeroed here.  */\n      memset (debug_information, 0, num_units * sizeof (*debug_information));\n\n      alloc_num_debug_info_entries = num_units;\n    }\n\n  if (!do_loc)\n    {\n      if (dwarf_start_die == 0)\n\tprintf (_(\"Contents of the %s section:\\n\\n\"), section->name);\n\n      load_debug_section (str, file);\n      load_debug_section (line_str, file);\n      load_debug_section (str_dwo, file);\n      load_debug_section (str_index, file);\n      load_debug_section (str_index_dwo, file);\n      load_debug_section (debug_addr, file);\n    }\n\n  load_debug_section (abbrev_sec, file);\n  if (debug_displays [abbrev_sec].section.start == NULL)\n    {\n      warn (_(\"Unable to locate %s section!\\n\"),\n\t    debug_displays [abbrev_sec].section.name);\n      return 0;\n    }\n\n  for (section_begin = start, unit = 0; start < end; unit++)\n    {\n      DWARF2_Internal_CompUnit compunit;\n      unsigned char *hdrptr;\n      unsigned char *tags;\n      int level, last_level, saved_level;\n      dwarf_vma cu_offset;\n      unsigned int offset_size;\n      unsigned int initial_length_size;\n      dwarf_vma signature_high = 0;\n      dwarf_vma signature_low = 0;\n      dwarf_vma type_offset = 0;\n      struct cu_tu_set *this_set;\n      dwarf_vma abbrev_base;\n      size_t abbrev_size;\n\n      hdrptr = start;\n\n      SAFE_BYTE_GET_AND_INC (compunit.cu_length, hdrptr, 4, end);\n\n      if (compunit.cu_length == 0xffffffff)\n\t{\n\t  SAFE_BYTE_GET_AND_INC (compunit.cu_length, hdrptr, 8, end);\n\t  offset_size = 8;\n\t  initial_length_size = 12;\n\t}\n      else\n\t{\n\t  offset_size = 4;\n\t  initial_length_size = 4;\n\t}\n\n      SAFE_BYTE_GET_AND_INC (compunit.cu_version, hdrptr, 2, end);\n\n      cu_offset = start - section_begin;\n\n      this_set = find_cu_tu_set_v2 (cu_offset, do_types);\n\n      if (compunit.cu_version < 5)\n\t{\n\t  compunit.cu_unit_type = DW_UT_compile;\n\t  /* Initialize it due to a false compiler warning.  */\n\t  compunit.cu_pointer_size = -1;\n\t}\n      else\n\t{\n\t  SAFE_BYTE_GET_AND_INC (compunit.cu_unit_type, hdrptr, 1, end);\n\t  do_types = (compunit.cu_unit_type == DW_UT_type);\n\n\t  SAFE_BYTE_GET_AND_INC (compunit.cu_pointer_size, hdrptr, 1, end);\n\t}\n\n      SAFE_BYTE_GET_AND_INC (compunit.cu_abbrev_offset, hdrptr, offset_size, end);\n\n      if (this_set == NULL)\n\t{\n\t  abbrev_base = 0;\n\t  abbrev_size = debug_displays [abbrev_sec].section.size;\n\t}\n      else\n\t{\n\t  abbrev_base = this_set->section_offsets [DW_SECT_ABBREV];\n\t  abbrev_size = this_set->section_sizes [DW_SECT_ABBREV];\n\t}\n\n      if (compunit.cu_version < 5)\n\tSAFE_BYTE_GET_AND_INC (compunit.cu_pointer_size, hdrptr, 1, end);\n\n      /* PR 17512: file: 001-108546-0.001:0.1.  */\n      if (compunit.cu_pointer_size < 2 || compunit.cu_pointer_size > 8)\n\t{\n\t  warn (_(\"Invalid pointer size (%d) in compunit header, using %d instead\\n\"),\n\t\tcompunit.cu_pointer_size, offset_size);\n\t  compunit.cu_pointer_size = offset_size;\n\t}\n\n      if (do_types)\n\t{\n\t  SAFE_BYTE_GET64 (hdrptr, &signature_high, &signature_low, end);\n\t  hdrptr += 8;\n\t  SAFE_BYTE_GET_AND_INC (type_offset, hdrptr, offset_size, end);\n\t}\n\n      if ((do_loc || do_debug_loc || do_debug_ranges)\n\t  && num_debug_info_entries == 0\n\t  && ! do_types)\n\t{\n\t  debug_information [unit].cu_offset = cu_offset;\n\t  debug_information [unit].pointer_size\n\t    = compunit.cu_pointer_size;\n\t  debug_information [unit].offset_size = offset_size;\n\t  debug_information [unit].dwarf_version = compunit.cu_version;\n\t  debug_information [unit].base_address = 0;\n\t  debug_information [unit].addr_base = DEBUG_INFO_UNAVAILABLE;\n\t  debug_information [unit].ranges_base = DEBUG_INFO_UNAVAILABLE;\n\t  debug_information [unit].loc_offsets = NULL;\n\t  debug_information [unit].have_frame_base = NULL;\n\t  debug_information [unit].max_loc_offsets = 0;\n\t  debug_information [unit].num_loc_offsets = 0;\n\t  debug_information [unit].range_lists = NULL;\n\t  debug_information [unit].max_range_lists= 0;\n\t  debug_information [unit].num_range_lists = 0;\n\t}\n\n      if (!do_loc && dwarf_start_die == 0)\n\t{\n\t  printf (_(\"  Compilation Unit @ offset 0x%s:\\n\"),\n\t\t  dwarf_vmatoa (\"x\", cu_offset));\n\t  printf (_(\"   Length:        0x%s (%s)\\n\"),\n\t\t  dwarf_vmatoa (\"x\", compunit.cu_length),\n\t\t  offset_size == 8 ? \"64-bit\" : \"32-bit\");\n\t  printf (_(\"   Version:       %d\\n\"), compunit.cu_version);\n\t  printf (_(\"   Abbrev Offset: 0x%s\\n\"),\n\t\t  dwarf_vmatoa (\"x\", compunit.cu_abbrev_offset));\n\t  printf (_(\"   Pointer Size:  %d\\n\"), compunit.cu_pointer_size);\n\t  if (do_types)\n\t    {\n\t      char buf[64];\n\n\t      printf (_(\"   Signature:     0x%s\\n\"),\n\t\t      dwarf_vmatoa64 (signature_high, signature_low,\n\t\t\t\t      buf, sizeof (buf)));\n\t      printf (_(\"   Type Offset:   0x%s\\n\"),\n\t\t      dwarf_vmatoa (\"x\", type_offset));\n\t    }\n\t  if (this_set != NULL)\n\t    {\n\t      dwarf_vma *offsets = this_set->section_offsets;\n\t      size_t *sizes = this_set->section_sizes;\n\n\t      printf (_(\"   Section contributions:\\n\"));\n\t      printf (_(\"    .debug_abbrev.dwo:       0x%s  0x%s\\n\"),\n\t\t      dwarf_vmatoa (\"x\", offsets [DW_SECT_ABBREV]),\n\t\t      dwarf_vmatoa (\"x\", sizes [DW_SECT_ABBREV]));\n\t      printf (_(\"    .debug_line.dwo:         0x%s  0x%s\\n\"),\n\t\t      dwarf_vmatoa (\"x\", offsets [DW_SECT_LINE]),\n\t\t      dwarf_vmatoa (\"x\", sizes [DW_SECT_LINE]));\n\t      printf (_(\"    .debug_loc.dwo:          0x%s  0x%s\\n\"),\n\t\t      dwarf_vmatoa (\"x\", offsets [DW_SECT_LOC]),\n\t\t      dwarf_vmatoa (\"x\", sizes [DW_SECT_LOC]));\n\t      printf (_(\"    .debug_str_offsets.dwo:  0x%s  0x%s\\n\"),\n\t\t      dwarf_vmatoa (\"x\", offsets [DW_SECT_STR_OFFSETS]),\n\t\t      dwarf_vmatoa (\"x\", sizes [DW_SECT_STR_OFFSETS]));\n\t    }\n\t}\n\n      if (cu_offset + compunit.cu_length + initial_length_size\n\t  > section->size)\n\t{\n\t  warn (_(\"Debug info is corrupted, length of CU at %s\"\n\t\t  \" extends beyond end of section (length = %s)\\n\"),\n\t\tdwarf_vmatoa (\"x\", cu_offset),\n\t\tdwarf_vmatoa (\"x\", compunit.cu_length));\n\t  num_units = unit;\n\t  break;\n\t}\n      else if (compunit.cu_length + initial_length_size < initial_length_size)\n\t{\n\t  warn (_(\"Debug info is corrupted, length of CU at %s is negative (%s)\\n\"),\n\t\tdwarf_vmatoa (\"x\", cu_offset),\n\t\tdwarf_vmatoa (\"x\", compunit.cu_length));\n\t  num_units = unit;\n\t  break;\n\t}\n\n      tags = hdrptr;\n      start += compunit.cu_length + initial_length_size;\n\n      if (start > end)\n\t{\n\t  warn (_(\"Debug info is corrupt.  CU at %s extends beyond end of section\"),\n\t\tdwarf_vmatoa (\"x\", cu_offset));\n\t  start = end;\n\t}\n\n      if (compunit.cu_version < 2 || compunit.cu_version > 5)\n\t{\n\t  warn (_(\"CU at offset %s contains corrupt or \"\n\t\t  \"unsupported version number: %d.\\n\"),\n\t\tdwarf_vmatoa (\"x\", cu_offset), compunit.cu_version);\n\t  continue;\n\t}\n\n      if (compunit.cu_unit_type != DW_UT_compile\n\t  && compunit.cu_unit_type != DW_UT_type)\n\t{\n\t  warn (_(\"CU at offset %s contains corrupt or \"\n\t\t  \"unsupported unit type: %d.\\n\"),\n\t\tdwarf_vmatoa (\"x\", cu_offset), compunit.cu_unit_type);\n\t  continue;\n\t}\n\n      free_abbrevs ();\n\n      /* Process the abbrevs used by this compilation unit.  */\n      if (compunit.cu_abbrev_offset >= abbrev_size)\n\twarn (_(\"Debug info is corrupted, abbrev offset (%lx) is larger than abbrev section size (%lx)\\n\"),\n\t      (unsigned long) compunit.cu_abbrev_offset,\n\t      (unsigned long) abbrev_size);\n      /* PR 17531: file:4bcd9ce9.  */\n      else if ((abbrev_base + abbrev_size)\n\t       > debug_displays [abbrev_sec].section.size)\n\twarn (_(\"Debug info is corrupted, abbrev size (%lx) is larger than abbrev section size (%lx)\\n\"),\n\t      (unsigned long) abbrev_base + abbrev_size,\n\t      (unsigned long) debug_displays [abbrev_sec].section.size);\n      else\n\tprocess_abbrev_section\n\t  (((unsigned char *) debug_displays [abbrev_sec].section.start\n\t    + abbrev_base + compunit.cu_abbrev_offset),\n\t   ((unsigned char *) debug_displays [abbrev_sec].section.start\n\t    + abbrev_base + abbrev_size));\n\n      level = 0;\n      last_level = level;\n      saved_level = -1;\n      while (tags < start)\n\t{\n\t  unsigned int bytes_read;\n\t  unsigned long abbrev_number;\n\t  unsigned long die_offset;\n\t  abbrev_entry *entry;\n\t  abbrev_attr *attr;\n\t  int do_printing = 1;\n\n\t  die_offset = tags - section_begin;\n\n\t  abbrev_number = read_uleb128 (tags, & bytes_read, start);\n\t  tags += bytes_read;\n\n\t  /* A null DIE marks the end of a list of siblings or it may also be\n\t     a section padding.  */\n\t  if (abbrev_number == 0)\n\t    {\n\t      /* Check if it can be a section padding for the last CU.  */\n\t      if (level == 0 && start == end)\n\t\t{\n\t\t  unsigned char *chk;\n\n\t\t  for (chk = tags; chk < start; chk++)\n\t\t    if (*chk != 0)\n\t\t      break;\n\t\t  if (chk == start)\n\t\t    break;\n\t\t}\n\n\t      if (!do_loc && die_offset >= dwarf_start_die\n\t\t  && (dwarf_cutoff_level == -1\n\t\t      || level < dwarf_cutoff_level))\n\t\tprintf (_(\" <%d><%lx>: Abbrev Number: 0\\n\"),\n\t\t\tlevel, die_offset);\n\n\t      --level;\n\t      if (level < 0)\n\t\t{\n\t\t  static unsigned num_bogus_warns = 0;\n\n\t\t  if (num_bogus_warns < 3)\n\t\t    {\n\t\t      warn (_(\"Bogus end-of-siblings marker detected at offset %lx in %s section\\n\"),\n\t\t\t    die_offset, section->name);\n\t\t      num_bogus_warns ++;\n\t\t      if (num_bogus_warns == 3)\n\t\t\twarn (_(\"Further warnings about bogus end-of-sibling markers suppressed\\n\"));\n\t\t    }\n\t\t}\n\t      if (dwarf_start_die != 0 && level < saved_level)\n\t\treturn 1;\n\t      continue;\n\t    }\n\n\t  if (!do_loc)\n\t    {\n\t      if (dwarf_start_die != 0 && die_offset < dwarf_start_die)\n\t\tdo_printing = 0;\n\t      else\n\t\t{\n\t\t  if (dwarf_start_die != 0 && die_offset == dwarf_start_die)\n\t\t    saved_level = level;\n\t\t  do_printing = (dwarf_cutoff_level == -1\n\t\t\t\t || level < dwarf_cutoff_level);\n\t\t  if (do_printing)\n\t\t    printf (_(\" <%d><%lx>: Abbrev Number: %lu\"),\n\t\t\t    level, die_offset, abbrev_number);\n\t\t  else if (dwarf_cutoff_level == -1\n\t\t\t   || last_level < dwarf_cutoff_level)\n\t\t    printf (_(\" <%d><%lx>: ...\\n\"), level, die_offset);\n\t\t  last_level = level;\n\t\t}\n\t    }\n\n\t  /* Scan through the abbreviation list until we reach the\n\t     correct entry.  */\n\t  for (entry = first_abbrev;\n\t       entry && entry->entry != abbrev_number;\n\t       entry = entry->next)\n\t    continue;\n\n\t  if (entry == NULL)\n\t    {\n\t      if (!do_loc && do_printing)\n\t\t{\n\t\t  printf (\"\\n\");\n\t\t  fflush (stdout);\n\t\t}\n\t      warn (_(\"DIE at offset 0x%lx refers to abbreviation number %lu which does not exist\\n\"),\n\t\t    die_offset, abbrev_number);\n\t      return 0;\n\t    }\n\n\t  if (!do_loc && do_printing)\n\t    printf (\" (%s)\\n\", get_TAG_name (entry->tag));\n\n\t  switch (entry->tag)\n\t    {\n\t    default:\n\t      need_base_address = 0;\n\t      break;\n\t    case DW_TAG_compile_unit:\n\t      need_base_address = 1;\n\t      break;\n\t    case DW_TAG_entry_point:\n\t    case DW_TAG_subprogram:\n\t      need_base_address = 0;\n\t      /* Assuming that there is no DW_AT_frame_base.  */\n\t      have_frame_base = 0;\n\t      break;\n\t    }\n\n\t  debug_info *debug_info_p =\n\t    (debug_information && unit < alloc_num_debug_info_entries)\n\t    ? debug_information + unit : NULL;\n\n\t  assert (!debug_info_p\n\t\t  || (debug_info_p->num_loc_offsets\n\t\t      == debug_info_p->num_loc_views));\n\n\t  for (attr = entry->first_attr;\n\t       attr && attr->attribute;\n\t       attr = attr->next)\n\t    {\n\t      if (! do_loc && do_printing)\n\t\t/* Show the offset from where the tag was extracted.  */\n\t\tprintf (\"    <%lx>\", (unsigned long)(tags - section_begin));\n\n\t      tags = read_and_display_attr (attr->attribute,\n\t\t\t\t\t    attr->form,\n\t\t\t\t\t    attr->implicit_const,\n\t\t\t\t\t    tags,\n\t\t\t\t\t    end,\n\t\t\t\t\t    cu_offset,\n\t\t\t\t\t    compunit.cu_pointer_size,\n\t\t\t\t\t    offset_size,\n\t\t\t\t\t    compunit.cu_version,\n\t\t\t\t\t    debug_info_p,\n\t\t\t\t\t    do_loc || ! do_printing,\n\t\t\t\t\t    section,\n\t\t\t\t\t    this_set);\n\t    }\n\n\t  /* If a locview attribute appears before a location one,\n\t     make sure we don't associate it with an earlier\n\t     loclist. */\n\t  if (debug_info_p)\n\t    switch (debug_info_p->num_loc_offsets - debug_info_p->num_loc_views)\n\t      {\n\t      case 1:\n\t\tdebug_info_p->loc_views [debug_info_p->num_loc_views] = vm1;\n\t\tdebug_info_p->num_loc_views++;\n\t\tassert (debug_info_p->num_loc_views\n\t\t\t== debug_info_p->num_loc_offsets);\n\t\tbreak;\n\n\t      case 0:\n\t\tbreak;\n\n\t      case -1:\n\t\twarn(_(\"DIE has locviews without loclist\\n\"));\n\t\tdebug_info_p->num_loc_views--;\n\t\tbreak;\n\n\t      default:\n\t\tassert (0);\n\t    }\n\n\t  if (entry->children)\n\t    ++level;\n\t}\n    }\n\n  /* Set num_debug_info_entries here so that it can be used to check if\n     we need to process .debug_loc and .debug_ranges sections.  */\n  if ((do_loc || do_debug_loc || do_debug_ranges)\n      && num_debug_info_entries == 0\n      && ! do_types)\n    {\n      if (num_units > alloc_num_debug_info_entries)\n\tnum_debug_info_entries = alloc_num_debug_info_entries;\n      else\n\tnum_debug_info_entries = num_units;\n    }\n\n  if (!do_loc)\n    printf (\"\\n\");\n\n  return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -106,7 +106,7 @@\n       int level, last_level, saved_level;\n       dwarf_vma cu_offset;\n       unsigned int offset_size;\n-      int initial_length_size;\n+      unsigned int initial_length_size;\n       dwarf_vma signature_high = 0;\n       dwarf_vma signature_low = 0;\n       dwarf_vma type_offset = 0;\n@@ -254,6 +254,15 @@\n \t  num_units = unit;\n \t  break;\n \t}\n+      else if (compunit.cu_length + initial_length_size < initial_length_size)\n+\t{\n+\t  warn (_(\"Debug info is corrupted, length of CU at %s is negative (%s)\\n\"),\n+\t\tdwarf_vmatoa (\"x\", cu_offset),\n+\t\tdwarf_vmatoa (\"x\", compunit.cu_length));\n+\t  num_units = unit;\n+\t  break;\n+\t}\n+\n       tags = hdrptr;\n       start += compunit.cu_length + initial_length_size;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "      int initial_length_size;"
            ],
            "added_lines": [
                "      unsigned int initial_length_size;",
                "      else if (compunit.cu_length + initial_length_size < initial_length_size)",
                "\t{",
                "\t  warn (_(\"Debug info is corrupted, length of CU at %s is negative (%s)\\n\"),",
                "\t\tdwarf_vmatoa (\"x\", cu_offset),",
                "\t\tdwarf_vmatoa (\"x\", compunit.cu_length));",
                "\t  num_units = unit;",
                "\t  break;",
                "\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2017-5596",
        "func_name": "wireshark/asterix_fspec_len",
        "description": "In Wireshark 2.2.0 to 2.2.3 and 2.0.0 to 2.0.9, the ASTERIX dissector could go into an infinite loop, triggered by packet injection or a malformed capture file. This was addressed in epan/dissectors/packet-asterix.c by changing a data type to avoid an integer overflow.",
        "git_url": "https://github.com/wireshark/wireshark/commit/781f03580c81339513bb1238b202b72469a1240b",
        "commit_title": "ASTERIX: Avoid an integer overflow.",
        "commit_text": " Count using a guint instead of a guint8.  Bug: 13344",
        "func_before": "static guint8 asterix_fspec_len (tvbuff_t *tvb, guint offset)\n{\n    guint8 i;\n    for (i = 0; (tvb_get_guint8 (tvb, offset + i) & 1) && i < tvb_reported_length (tvb) - offset; i++);\n    return i + 1;\n}",
        "func": "static guint asterix_fspec_len (tvbuff_t *tvb, guint offset)\n{\n    guint i;\n    guint max_length = tvb_reported_length (tvb) - offset;\n    for (i = 0; (tvb_get_guint8 (tvb, offset + i) & 1) && i < max_length; i++);\n    return i + 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,7 @@\n-static guint8 asterix_fspec_len (tvbuff_t *tvb, guint offset)\n+static guint asterix_fspec_len (tvbuff_t *tvb, guint offset)\n {\n-    guint8 i;\n-    for (i = 0; (tvb_get_guint8 (tvb, offset + i) & 1) && i < tvb_reported_length (tvb) - offset; i++);\n+    guint i;\n+    guint max_length = tvb_reported_length (tvb) - offset;\n+    for (i = 0; (tvb_get_guint8 (tvb, offset + i) & 1) && i < max_length; i++);\n     return i + 1;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static guint8 asterix_fspec_len (tvbuff_t *tvb, guint offset)",
                "    guint8 i;",
                "    for (i = 0; (tvb_get_guint8 (tvb, offset + i) & 1) && i < tvb_reported_length (tvb) - offset; i++);"
            ],
            "added_lines": [
                "static guint asterix_fspec_len (tvbuff_t *tvb, guint offset)",
                "    guint i;",
                "    guint max_length = tvb_reported_length (tvb) - offset;",
                "    for (i = 0; (tvb_get_guint8 (tvb, offset + i) & 1) && i < max_length; i++);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-20482",
        "func_name": "tar/check_data_region",
        "description": "GNU Tar through 1.30, when --sparse is used, mishandles file shrinkage during read access, which allows local users to cause a denial of service (infinite read loop in sparse_dump_region in sparse.c) by modifying a file that is supposed to be archived by a different user's process (e.g., a system backup running as root).",
        "git_url": "http://git.savannah.gnu.org/cgit/tar.git/commit/?id=c15c42ccd1e2377945fd0414eca1a49294bff454",
        "commit_title": "* NEWS: Update.",
        "commit_text": "* src/sparse.c (sparse_dump_region): Handle short read condition. (sparse_extract_region,check_data_region): Fix dumped_size calculation. Handle short read condition. (pax_decode_header): Fix dumped_size calculation. * tests/Makefile.am: Add new testcases. * tests/testsuite.at: Likewise.  * tests/sptrcreat.at: New file. * tests/sptrdiff00.at: New file. * tests/sptrdiff01.at: New file. ",
        "func_before": "static bool\ncheck_data_region (struct tar_sparse_file *file, size_t i)\n{\n  off_t size_left;\n\n  if (!lseek_or_error (file, file->stat_info->sparse_map[i].offset))\n    return false;\n  size_left = file->stat_info->sparse_map[i].numbytes;\n  mv_size_left (file->stat_info->archive_file_size - file->dumped_size);\n\n  while (size_left > 0)\n    {\n      size_t bytes_read;\n      size_t rdsize = (size_left > BLOCKSIZE) ? BLOCKSIZE : size_left;\n      char diff_buffer[BLOCKSIZE];\n\n      union block *blk = find_next_block ();\n      if (!blk)\n\t{\n\t  ERROR ((0, 0, _(\"Unexpected EOF in archive\")));\n\t  return false;\n\t}\n      set_next_block_after (blk);\n      bytes_read = safe_read (file->fd, diff_buffer, rdsize);\n      if (bytes_read == SAFE_READ_ERROR)\n\t{\n          read_diag_details (file->stat_info->orig_file_name,\n\t\t\t     (file->stat_info->sparse_map[i].offset\n\t\t\t      + file->stat_info->sparse_map[i].numbytes\n\t\t\t      - size_left),\n\t\t\t     rdsize);\n\t  return false;\n\t}\n      file->dumped_size += bytes_read;\n      size_left -= bytes_read;\n      mv_size_left (file->stat_info->archive_file_size - file->dumped_size);\n      if (memcmp (blk->buffer, diff_buffer, rdsize))\n\t{\n\t  report_difference (file->stat_info, _(\"Contents differ\"));\n\t  return false;\n\t}\n    }\n  return true;\n}",
        "func": "static bool\ncheck_data_region (struct tar_sparse_file *file, size_t i)\n{\n  off_t size_left;\n\n  if (!lseek_or_error (file, file->stat_info->sparse_map[i].offset))\n    return false;\n  size_left = file->stat_info->sparse_map[i].numbytes;\n  mv_size_left (file->stat_info->archive_file_size - file->dumped_size);\n\n  while (size_left > 0)\n    {\n      size_t bytes_read;\n      size_t rdsize = (size_left > BLOCKSIZE) ? BLOCKSIZE : size_left;\n      char diff_buffer[BLOCKSIZE];\n\n      union block *blk = find_next_block ();\n      if (!blk)\n\t{\n\t  ERROR ((0, 0, _(\"Unexpected EOF in archive\")));\n\t  return false;\n\t}\n      set_next_block_after (blk);\n      file->dumped_size += BLOCKSIZE;      \n      bytes_read = safe_read (file->fd, diff_buffer, rdsize);\n      if (bytes_read == SAFE_READ_ERROR)\n\t{\n          read_diag_details (file->stat_info->orig_file_name,\n\t\t\t     (file->stat_info->sparse_map[i].offset\n\t\t\t      + file->stat_info->sparse_map[i].numbytes\n\t\t\t      - size_left),\n\t\t\t     rdsize);\n\t  return false;\n\t}\n      else if (bytes_read == 0)\n\t{\n\t  report_difference (&current_stat_info, _(\"Size differs\"));\n\t  return false;\n\t}\n      size_left -= bytes_read;\n      mv_size_left (file->stat_info->archive_file_size - file->dumped_size);\n      if (memcmp (blk->buffer, diff_buffer, rdsize))\n\t{\n\t  report_difference (file->stat_info, _(\"Contents differ\"));\n\t  return false;\n\t}\n    }\n  return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,6 +21,7 @@\n \t  return false;\n \t}\n       set_next_block_after (blk);\n+      file->dumped_size += BLOCKSIZE;      \n       bytes_read = safe_read (file->fd, diff_buffer, rdsize);\n       if (bytes_read == SAFE_READ_ERROR)\n \t{\n@@ -31,7 +32,11 @@\n \t\t\t     rdsize);\n \t  return false;\n \t}\n-      file->dumped_size += bytes_read;\n+      else if (bytes_read == 0)\n+\t{\n+\t  report_difference (&current_stat_info, _(\"Size differs\"));\n+\t  return false;\n+\t}\n       size_left -= bytes_read;\n       mv_size_left (file->stat_info->archive_file_size - file->dumped_size);\n       if (memcmp (blk->buffer, diff_buffer, rdsize))",
        "diff_line_info": {
            "deleted_lines": [
                "      file->dumped_size += bytes_read;"
            ],
            "added_lines": [
                "      file->dumped_size += BLOCKSIZE;      ",
                "      else if (bytes_read == 0)",
                "\t{",
                "\t  report_difference (&current_stat_info, _(\"Size differs\"));",
                "\t  return false;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-20482",
        "func_name": "tar/sparse_dump_region",
        "description": "GNU Tar through 1.30, when --sparse is used, mishandles file shrinkage during read access, which allows local users to cause a denial of service (infinite read loop in sparse_dump_region in sparse.c) by modifying a file that is supposed to be archived by a different user's process (e.g., a system backup running as root).",
        "git_url": "http://git.savannah.gnu.org/cgit/tar.git/commit/?id=c15c42ccd1e2377945fd0414eca1a49294bff454",
        "commit_title": "* NEWS: Update.",
        "commit_text": "* src/sparse.c (sparse_dump_region): Handle short read condition. (sparse_extract_region,check_data_region): Fix dumped_size calculation. Handle short read condition. (pax_decode_header): Fix dumped_size calculation. * tests/Makefile.am: Add new testcases. * tests/testsuite.at: Likewise.  * tests/sptrcreat.at: New file. * tests/sptrdiff00.at: New file. * tests/sptrdiff01.at: New file. ",
        "func_before": "static bool\nsparse_dump_region (struct tar_sparse_file *file, size_t i)\n{\n  union block *blk;\n  off_t bytes_left = file->stat_info->sparse_map[i].numbytes;\n\n  if (!lseek_or_error (file, file->stat_info->sparse_map[i].offset))\n    return false;\n\n  while (bytes_left > 0)\n    {\n      size_t bufsize = (bytes_left > BLOCKSIZE) ? BLOCKSIZE : bytes_left;\n      size_t bytes_read;\n\n      blk = find_next_block ();\n      bytes_read = safe_read (file->fd, blk->buffer, bufsize);\n      if (bytes_read == SAFE_READ_ERROR)\n\t{\n          read_diag_details (file->stat_info->orig_file_name,\n\t                     (file->stat_info->sparse_map[i].offset\n\t\t\t      + file->stat_info->sparse_map[i].numbytes\n\t\t\t      - bytes_left),\n\t\t\t     bufsize);\n\t  return false;\n\t}\n\n      memset (blk->buffer + bytes_read, 0, BLOCKSIZE - bytes_read);\n      bytes_left -= bytes_read;\n      file->dumped_size += bytes_read;\n      set_next_block_after (blk);\n    }\n\n  return true;\n}",
        "func": "static bool\nsparse_dump_region (struct tar_sparse_file *file, size_t i)\n{\n  union block *blk;\n  off_t bytes_left = file->stat_info->sparse_map[i].numbytes;\n\n  if (!lseek_or_error (file, file->stat_info->sparse_map[i].offset))\n    return false;\n\n  while (bytes_left > 0)\n    {\n      size_t bufsize = (bytes_left > BLOCKSIZE) ? BLOCKSIZE : bytes_left;\n      size_t bytes_read;\n\n      blk = find_next_block ();\n      bytes_read = safe_read (file->fd, blk->buffer, bufsize);\n      if (bytes_read == SAFE_READ_ERROR)\n\t{\n          read_diag_details (file->stat_info->orig_file_name,\n\t                     (file->stat_info->sparse_map[i].offset\n\t\t\t      + file->stat_info->sparse_map[i].numbytes\n\t\t\t      - bytes_left),\n\t\t\t     bufsize);\n\t  return false;\n\t}\n      else if (bytes_read == 0)\n\t{\n\t  char buf[UINTMAX_STRSIZE_BOUND];\n\t  struct stat st;\n\t  size_t n;\n\t  if (fstat (file->fd, &st) == 0)\n\t    n = file->stat_info->stat.st_size - st.st_size;\n\t  else\n\t    n = file->stat_info->stat.st_size\n\t      - (file->stat_info->sparse_map[i].offset\n\t\t + file->stat_info->sparse_map[i].numbytes\n\t\t - bytes_left);\n\t  \n\t  WARNOPT (WARN_FILE_SHRANK,\n\t\t   (0, 0,\n\t\t    ngettext (\"%s: File shrank by %s byte; padding with zeros\",\n\t\t\t      \"%s: File shrank by %s bytes; padding with zeros\",\n\t\t\t      n),\n\t\t    quotearg_colon (file->stat_info->orig_file_name),\n\t\t    STRINGIFY_BIGINT (n, buf)));\n\t  if (! ignore_failed_read_option)\n\t    set_exit_status (TAREXIT_DIFFERS);\n\t  return false;\n\t}\n\n      memset (blk->buffer + bytes_read, 0, BLOCKSIZE - bytes_read);\n      bytes_left -= bytes_read;\n      file->dumped_size += bytes_read;\n      set_next_block_after (blk);\n    }\n\n  return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,6 +23,30 @@\n \t\t\t     bufsize);\n \t  return false;\n \t}\n+      else if (bytes_read == 0)\n+\t{\n+\t  char buf[UINTMAX_STRSIZE_BOUND];\n+\t  struct stat st;\n+\t  size_t n;\n+\t  if (fstat (file->fd, &st) == 0)\n+\t    n = file->stat_info->stat.st_size - st.st_size;\n+\t  else\n+\t    n = file->stat_info->stat.st_size\n+\t      - (file->stat_info->sparse_map[i].offset\n+\t\t + file->stat_info->sparse_map[i].numbytes\n+\t\t - bytes_left);\n+\t  \n+\t  WARNOPT (WARN_FILE_SHRANK,\n+\t\t   (0, 0,\n+\t\t    ngettext (\"%s: File shrank by %s byte; padding with zeros\",\n+\t\t\t      \"%s: File shrank by %s bytes; padding with zeros\",\n+\t\t\t      n),\n+\t\t    quotearg_colon (file->stat_info->orig_file_name),\n+\t\t    STRINGIFY_BIGINT (n, buf)));\n+\t  if (! ignore_failed_read_option)\n+\t    set_exit_status (TAREXIT_DIFFERS);\n+\t  return false;\n+\t}\n \n       memset (blk->buffer + bytes_read, 0, BLOCKSIZE - bytes_read);\n       bytes_left -= bytes_read;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      else if (bytes_read == 0)",
                "\t{",
                "\t  char buf[UINTMAX_STRSIZE_BOUND];",
                "\t  struct stat st;",
                "\t  size_t n;",
                "\t  if (fstat (file->fd, &st) == 0)",
                "\t    n = file->stat_info->stat.st_size - st.st_size;",
                "\t  else",
                "\t    n = file->stat_info->stat.st_size",
                "\t      - (file->stat_info->sparse_map[i].offset",
                "\t\t + file->stat_info->sparse_map[i].numbytes",
                "\t\t - bytes_left);",
                "\t  ",
                "\t  WARNOPT (WARN_FILE_SHRANK,",
                "\t\t   (0, 0,",
                "\t\t    ngettext (\"%s: File shrank by %s byte; padding with zeros\",",
                "\t\t\t      \"%s: File shrank by %s bytes; padding with zeros\",",
                "\t\t\t      n),",
                "\t\t    quotearg_colon (file->stat_info->orig_file_name),",
                "\t\t    STRINGIFY_BIGINT (n, buf)));",
                "\t  if (! ignore_failed_read_option)",
                "\t    set_exit_status (TAREXIT_DIFFERS);",
                "\t  return false;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-20482",
        "func_name": "tar/sparse_extract_region",
        "description": "GNU Tar through 1.30, when --sparse is used, mishandles file shrinkage during read access, which allows local users to cause a denial of service (infinite read loop in sparse_dump_region in sparse.c) by modifying a file that is supposed to be archived by a different user's process (e.g., a system backup running as root).",
        "git_url": "http://git.savannah.gnu.org/cgit/tar.git/commit/?id=c15c42ccd1e2377945fd0414eca1a49294bff454",
        "commit_title": "* NEWS: Update.",
        "commit_text": "* src/sparse.c (sparse_dump_region): Handle short read condition. (sparse_extract_region,check_data_region): Fix dumped_size calculation. Handle short read condition. (pax_decode_header): Fix dumped_size calculation. * tests/Makefile.am: Add new testcases. * tests/testsuite.at: Likewise.  * tests/sptrcreat.at: New file. * tests/sptrdiff00.at: New file. * tests/sptrdiff01.at: New file. ",
        "func_before": "static bool\nsparse_extract_region (struct tar_sparse_file *file, size_t i)\n{\n  off_t write_size;\n\n  if (!lseek_or_error (file, file->stat_info->sparse_map[i].offset))\n    return false;\n\n  write_size = file->stat_info->sparse_map[i].numbytes;\n\n  if (write_size == 0)\n    {\n      /* Last block of the file is a hole */\n      if (file->seekable && sys_truncate (file->fd))\n\ttruncate_warn (file->stat_info->orig_file_name);\n    }\n  else while (write_size > 0)\n    {\n      size_t count;\n      size_t wrbytes = (write_size > BLOCKSIZE) ? BLOCKSIZE : write_size;\n      union block *blk = find_next_block ();\n      if (!blk)\n\t{\n\t  ERROR ((0, 0, _(\"Unexpected EOF in archive\")));\n\t  return false;\n\t}\n      set_next_block_after (blk);\n      count = blocking_write (file->fd, blk->buffer, wrbytes);\n      write_size -= count;\n      file->dumped_size += count;\n      mv_size_left (file->stat_info->archive_file_size - file->dumped_size);\n      file->offset += count;\n      if (count != wrbytes)\n\t{\n\t  write_error_details (file->stat_info->orig_file_name,\n\t\t\t       count, wrbytes);\n\t  return false;\n\t}\n    }\n  return true;\n}",
        "func": "static bool\nsparse_extract_region (struct tar_sparse_file *file, size_t i)\n{\n  off_t write_size;\n\n  if (!lseek_or_error (file, file->stat_info->sparse_map[i].offset))\n    return false;\n\n  write_size = file->stat_info->sparse_map[i].numbytes;\n\n  if (write_size == 0)\n    {\n      /* Last block of the file is a hole */\n      if (file->seekable && sys_truncate (file->fd))\n\ttruncate_warn (file->stat_info->orig_file_name);\n    }\n  else while (write_size > 0)\n    {\n      size_t count;\n      size_t wrbytes = (write_size > BLOCKSIZE) ? BLOCKSIZE : write_size;\n      union block *blk = find_next_block ();\n      if (!blk)\n\t{\n\t  ERROR ((0, 0, _(\"Unexpected EOF in archive\")));\n\t  return false;\n\t}\n      set_next_block_after (blk);\n      file->dumped_size += BLOCKSIZE;\n      count = blocking_write (file->fd, blk->buffer, wrbytes);\n      write_size -= count;\n      mv_size_left (file->stat_info->archive_file_size - file->dumped_size);\n      file->offset += count;\n      if (count != wrbytes)\n\t{\n\t  write_error_details (file->stat_info->orig_file_name,\n\t\t\t       count, wrbytes);\n\t  return false;\n\t}\n    }\n  return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,9 +25,9 @@\n \t  return false;\n \t}\n       set_next_block_after (blk);\n+      file->dumped_size += BLOCKSIZE;\n       count = blocking_write (file->fd, blk->buffer, wrbytes);\n       write_size -= count;\n-      file->dumped_size += count;\n       mv_size_left (file->stat_info->archive_file_size - file->dumped_size);\n       file->offset += count;\n       if (count != wrbytes)",
        "diff_line_info": {
            "deleted_lines": [
                "      file->dumped_size += count;"
            ],
            "added_lines": [
                "      file->dumped_size += BLOCKSIZE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-20482",
        "func_name": "tar/pax_decode_header",
        "description": "GNU Tar through 1.30, when --sparse is used, mishandles file shrinkage during read access, which allows local users to cause a denial of service (infinite read loop in sparse_dump_region in sparse.c) by modifying a file that is supposed to be archived by a different user's process (e.g., a system backup running as root).",
        "git_url": "http://git.savannah.gnu.org/cgit/tar.git/commit/?id=c15c42ccd1e2377945fd0414eca1a49294bff454",
        "commit_title": "* NEWS: Update.",
        "commit_text": "* src/sparse.c (sparse_dump_region): Handle short read condition. (sparse_extract_region,check_data_region): Fix dumped_size calculation. Handle short read condition. (pax_decode_header): Fix dumped_size calculation. * tests/Makefile.am: Add new testcases. * tests/testsuite.at: Likewise.  * tests/sptrcreat.at: New file. * tests/sptrdiff00.at: New file. * tests/sptrdiff01.at: New file. ",
        "func_before": "static bool\npax_decode_header (struct tar_sparse_file *file)\n{\n  if (file->stat_info->sparse_major > 0)\n    {\n      uintmax_t u;\n      char nbuf[UINTMAX_STRSIZE_BOUND];\n      union block *blk;\n      char *p;\n      size_t i;\n\n#define COPY_BUF(b,buf,src) do                                     \\\n {                                                                 \\\n   char *endp = b->buffer + BLOCKSIZE;                             \\\n   char *dst = buf;                                                \\\n   do                                                              \\\n     {                                                             \\\n       if (dst == buf + UINTMAX_STRSIZE_BOUND -1)                  \\\n         {                                                         \\\n           ERROR ((0, 0, _(\"%s: numeric overflow in sparse archive member\"), \\\n\t          file->stat_info->orig_file_name));               \\\n           return false;                                           \\\n         }                                                         \\\n       if (src == endp)                                            \\\n\t {                                                         \\\n\t   set_next_block_after (b);                               \\\n           file->dumped_size += BLOCKSIZE;                         \\\n           b = find_next_block ();                                 \\\n           src = b->buffer;                                        \\\n\t   endp = b->buffer + BLOCKSIZE;                           \\\n\t }                                                         \\\n       *dst = *src++;                                              \\\n     }                                                             \\\n   while (*dst++ != '\\n');                                         \\\n   dst[-1] = 0;                                                    \\\n } while (0)\n\n      set_next_block_after (current_header);\n      file->dumped_size += BLOCKSIZE;\n      blk = find_next_block ();\n      p = blk->buffer;\n      COPY_BUF (blk,nbuf,p);\n      if (!decode_num (&u, nbuf, TYPE_MAXIMUM (size_t)))\n\t{\n\t  ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t  file->stat_info->orig_file_name));\n\t  return false;\n\t}\n      file->stat_info->sparse_map_size = u;\n      file->stat_info->sparse_map = xcalloc (file->stat_info->sparse_map_size,\n\t\t\t\t\t     sizeof (*file->stat_info->sparse_map));\n      file->stat_info->sparse_map_avail = 0;\n      for (i = 0; i < file->stat_info->sparse_map_size; i++)\n\t{\n\t  struct sp_array sp;\n\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.offset = u;\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.numbytes = u;\n\t  sparse_add_map (file->stat_info, &sp);\n\t}\n      set_next_block_after (blk);\n    }\n\n  return true;\n}",
        "func": "static bool\npax_decode_header (struct tar_sparse_file *file)\n{\n  if (file->stat_info->sparse_major > 0)\n    {\n      uintmax_t u;\n      char nbuf[UINTMAX_STRSIZE_BOUND];\n      union block *blk;\n      char *p;\n      size_t i;\n      off_t start;\n      \n#define COPY_BUF(b,buf,src) do                                     \\\n {                                                                 \\\n   char *endp = b->buffer + BLOCKSIZE;                             \\\n   char *dst = buf;                                                \\\n   do                                                              \\\n     {                                                             \\\n       if (dst == buf + UINTMAX_STRSIZE_BOUND -1)                  \\\n         {                                                         \\\n           ERROR ((0, 0, _(\"%s: numeric overflow in sparse archive member\"), \\\n\t          file->stat_info->orig_file_name));               \\\n           return false;                                           \\\n         }                                                         \\\n       if (src == endp)                                            \\\n\t {                                                         \\\n\t   set_next_block_after (b);                               \\\n           b = find_next_block ();                                 \\\n           src = b->buffer;                                        \\\n\t   endp = b->buffer + BLOCKSIZE;                           \\\n\t }                                                         \\\n       *dst = *src++;                                              \\\n     }                                                             \\\n   while (*dst++ != '\\n');                                         \\\n   dst[-1] = 0;                                                    \\\n } while (0)\n\n      start = current_block_ordinal ();\n      set_next_block_after (current_header);\n      blk = find_next_block ();\n      p = blk->buffer;\n      COPY_BUF (blk,nbuf,p);\n      if (!decode_num (&u, nbuf, TYPE_MAXIMUM (size_t)))\n\t{\n\t  ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t  file->stat_info->orig_file_name));\n\t  return false;\n\t}\n      file->stat_info->sparse_map_size = u;\n      file->stat_info->sparse_map = xcalloc (file->stat_info->sparse_map_size,\n\t\t\t\t\t     sizeof (*file->stat_info->sparse_map));\n      file->stat_info->sparse_map_avail = 0;\n      for (i = 0; i < file->stat_info->sparse_map_size; i++)\n\t{\n\t  struct sp_array sp;\n\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.offset = u;\n\t  COPY_BUF (blk,nbuf,p);\n\t  if (!decode_num (&u, nbuf, TYPE_MAXIMUM (off_t)))\n\t    {\n\t      ERROR ((0, 0, _(\"%s: malformed sparse archive member\"),\n\t\t      file->stat_info->orig_file_name));\n\t      return false;\n\t    }\n\t  sp.numbytes = u;\n\t  sparse_add_map (file->stat_info, &sp);\n\t}\n      set_next_block_after (blk);\n\n      file->dumped_size += BLOCKSIZE * (current_block_ordinal () - start);\n    }\n\n  return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,8 @@\n       union block *blk;\n       char *p;\n       size_t i;\n-\n+      off_t start;\n+      \n #define COPY_BUF(b,buf,src) do                                     \\\n  {                                                                 \\\n    char *endp = b->buffer + BLOCKSIZE;                             \\\n@@ -24,7 +25,6 @@\n        if (src == endp)                                            \\\n \t {                                                         \\\n \t   set_next_block_after (b);                               \\\n-           file->dumped_size += BLOCKSIZE;                         \\\n            b = find_next_block ();                                 \\\n            src = b->buffer;                                        \\\n \t   endp = b->buffer + BLOCKSIZE;                           \\\n@@ -35,8 +35,8 @@\n    dst[-1] = 0;                                                    \\\n  } while (0)\n \n+      start = current_block_ordinal ();\n       set_next_block_after (current_header);\n-      file->dumped_size += BLOCKSIZE;\n       blk = find_next_block ();\n       p = blk->buffer;\n       COPY_BUF (blk,nbuf,p);\n@@ -73,6 +73,8 @@\n \t  sparse_add_map (file->stat_info, &sp);\n \t}\n       set_next_block_after (blk);\n+\n+      file->dumped_size += BLOCKSIZE * (current_block_ordinal () - start);\n     }\n \n   return true;",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "           file->dumped_size += BLOCKSIZE;                         \\",
                "      file->dumped_size += BLOCKSIZE;"
            ],
            "added_lines": [
                "      off_t start;",
                "      ",
                "      start = current_block_ordinal ();",
                "",
                "      file->dumped_size += BLOCKSIZE * (current_block_ordinal () - start);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-20482",
        "func_name": "tar/check_sparse_region",
        "description": "GNU Tar through 1.30, when --sparse is used, mishandles file shrinkage during read access, which allows local users to cause a denial of service (infinite read loop in sparse_dump_region in sparse.c) by modifying a file that is supposed to be archived by a different user's process (e.g., a system backup running as root).",
        "git_url": "http://git.savannah.gnu.org/cgit/tar.git/commit/?id=c15c42ccd1e2377945fd0414eca1a49294bff454",
        "commit_title": "* NEWS: Update.",
        "commit_text": "* src/sparse.c (sparse_dump_region): Handle short read condition. (sparse_extract_region,check_data_region): Fix dumped_size calculation. Handle short read condition. (pax_decode_header): Fix dumped_size calculation. * tests/Makefile.am: Add new testcases. * tests/testsuite.at: Likewise.  * tests/sptrcreat.at: New file. * tests/sptrdiff00.at: New file. * tests/sptrdiff01.at: New file. ",
        "func_before": "static bool\ncheck_sparse_region (struct tar_sparse_file *file, off_t beg, off_t end)\n{\n  if (!lseek_or_error (file, beg))\n    return false;\n\n  while (beg < end)\n    {\n      size_t bytes_read;\n      size_t rdsize = BLOCKSIZE < end - beg ? BLOCKSIZE : end - beg;\n      char diff_buffer[BLOCKSIZE];\n\n      bytes_read = safe_read (file->fd, diff_buffer, rdsize);\n      if (bytes_read == SAFE_READ_ERROR)\n\t{\n          read_diag_details (file->stat_info->orig_file_name,\n\t                     beg,\n\t\t\t     rdsize);\n\t  return false;\n\t}\n      if (!zero_block_p (diff_buffer, bytes_read))\n\t{\n\t  char begbuf[INT_BUFSIZE_BOUND (off_t)];\n \t  report_difference (file->stat_info,\n\t\t\t     _(\"File fragment at %s is not a hole\"),\n\t\t\t     offtostr (beg, begbuf));\n\t  return false;\n\t}\n\n      beg += bytes_read;\n    }\n  return true;\n}",
        "func": "static bool\ncheck_sparse_region (struct tar_sparse_file *file, off_t beg, off_t end)\n{\n  if (!lseek_or_error (file, beg))\n    return false;\n\n  while (beg < end)\n    {\n      size_t bytes_read;\n      size_t rdsize = BLOCKSIZE < end - beg ? BLOCKSIZE : end - beg;\n      char diff_buffer[BLOCKSIZE];\n\n      bytes_read = safe_read (file->fd, diff_buffer, rdsize);\n      if (bytes_read == SAFE_READ_ERROR)\n\t{\n          read_diag_details (file->stat_info->orig_file_name,\n\t                     beg,\n\t\t\t     rdsize);\n\t  return false;\n\t}\n      else if (bytes_read == 0)\n\t{\n\t  report_difference (file->stat_info, _(\"Size differs\"));\n\t  return false;\n\t}\n      \n      if (!zero_block_p (diff_buffer, bytes_read))\n\t{\n\t  char begbuf[INT_BUFSIZE_BOUND (off_t)];\n \t  report_difference (file->stat_info,\n\t\t\t     _(\"File fragment at %s is not a hole\"),\n\t\t\t     offtostr (beg, begbuf));\n\t  return false;\n\t}\n\n      beg += bytes_read;\n    }\n\n  return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,6 +18,12 @@\n \t\t\t     rdsize);\n \t  return false;\n \t}\n+      else if (bytes_read == 0)\n+\t{\n+\t  report_difference (file->stat_info, _(\"Size differs\"));\n+\t  return false;\n+\t}\n+      \n       if (!zero_block_p (diff_buffer, bytes_read))\n \t{\n \t  char begbuf[INT_BUFSIZE_BOUND (off_t)];\n@@ -29,5 +35,6 @@\n \n       beg += bytes_read;\n     }\n+\n   return true;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      else if (bytes_read == 0)",
                "\t{",
                "\t  report_difference (file->stat_info, _(\"Size differs\"));",
                "\t  return false;",
                "\t}",
                "      ",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-37748",
        "func_name": "miniupnp/ngiflib/DecodeGifImg",
        "description": "ngiflib commit 5e7292 was discovered to contain an infinite loop via the function DecodeGifImg at ngiflib.c.",
        "git_url": "https://github.com/miniupnp/ngiflib/commit/fb2713a548a530c13f14b586a479818cb0182a5e",
        "commit_title": "fix npix counting",
        "commit_text": " bug introduced in cf429e0a2fe26b5f01ce0c8e9b79432e94509b6e fixes #25",
        "func_before": "static int DecodeGifImg(struct ngiflib_img * i) {\n\tstruct ngiflib_decode_context context;\n\tlong npix;\n\tu8 * stackp;\n\tu8 * stack_top;\n\tu16 clr;\n\tu16 eof;\n\tu16 free;\n\tu16 act_code = 0;\n\tu16 old_code = 0;\n\tu16 read_byt;\n\tu16 ab_prfx[4096];\n\tu8 ab_suffx[4096];\n\tu8 ab_stack[4096];\n\tu8 flags;\n\tu8 casspecial = 0;\n\n\tif(!i) return -1;\n\n\ti->posX = GetWord(i->parent);\t/* offsetX */\n\ti->posY = GetWord(i->parent);\t/* offsetY */\n\ti->width = GetWord(i->parent);\t/* SizeX   */\n\ti->height = GetWord(i->parent);\t/* SizeY   */\n\n\tif((i->width > i->parent->width) || (i->height > i->parent->height)) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\tif(i->parent->log) fprintf(i->parent->log, \"*** ERROR *** Image bigger than global GIF canvas !\\n\");\n#endif\n\t\treturn -1;\n\t}\n\tif((i->posX + i->width) > i->parent->width) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\tif(i->parent->log) fprintf(i->parent->log, \"*** WARNING *** Adjusting X position\\n\");\n#endif\n\t\ti->posX = i->parent->width - i->width;\n\t}\n\tif((i->posY + i->height) > i->parent->height) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\tif(i->parent->log) fprintf(i->parent->log, \"*** WARNING *** Adjusting Y position\\n\");\n#endif\n\t\ti->posY = i->parent->height - i->height;\n\t}\n\tcontext.Xtogo = i->width;\n\tcontext.curY = i->posY;\n#ifdef NGIFLIB_INDEXED_ONLY\n\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\tcontext.line_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width;\n\tcontext.frbuff_p.p8 = context.line_p.p8 + i->posX;\n\t#else\n\tcontext.frbuff_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width + i->posX;\n\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n#else\n\tif(i->parent->mode & NGIFLIB_MODE_INDEXED) {\n\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\tcontext.line_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width;\n\t\tcontext.frbuff_p.p8 = context.line_p.p8 + i->posX;\n\t\t#else\n\t\tcontext.frbuff_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width + i->posX;\n\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t} else {\n\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\tcontext.line_p.p32 = i->parent->frbuff.p32 + (u32)i->posY*i->parent->width;\n\t\tcontext.frbuff_p.p32 = context.line_p.p32 + i->posX;\n\t\t#else\n\t\tcontext.frbuff_p.p32 = i->parent->frbuff.p32 + (u32)i->posY*i->parent->width + i->posX;\n\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\n\tnpix = (long)i->width * i->height;\n\tflags = GetByte(i->parent);\n\ti->interlaced = (flags & 64) >> 6;\n\tcontext.pass = i->interlaced ? 1 : 0;\n\ti->sort_flag = (flags & 32) >> 5;\t/* is local palette sorted by color frequency ? */\n\ti->localpalbits = (flags & 7) + 1;\n\tif(flags&128) { /* palette locale */\n\t\tint k;\n\t\tint localpalsize = 1 << i->localpalbits;\n#if !defined(NGIFLIB_NO_FILE)\n\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"Local palette\\n\");\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\t\ti->palette = (struct ngiflib_rgb *)ngiflib_malloc(sizeof(struct ngiflib_rgb)*localpalsize);\n#ifdef EXTRA_MALLOC_CHECK\n\t\tif(i->palette == NULL) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\tif(i->parent->log) fprintf(i->parent->log, \"*** ERROR *** The value returned by 'ngiflib_malloc()' call at %s:%d location is NULL\\n\", __FILE__, __LINE__);\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\t\t\treturn -2;    /* memory error */\n\t\t}\n#endif /* EXTRA_MALLOC_CHECK */\n\t\tfor(k=0; k<localpalsize; k++) {\n\t\t\ti->palette[k].r = GetByte(i->parent);\n\t\t\ti->palette[k].g = GetByte(i->parent);\n\t\t\ti->palette[k].b = GetByte(i->parent);\n\t\t}\n#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\tif(i->parent->palette_cb) i->parent->palette_cb(i->parent, i->palette, localpalsize);\n#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t} else {\n\t\t/* use global palette */\n\t\ti->palette = i->parent->palette;\n\t\ti->localpalbits = i->parent->imgbits;\n\t}\n\ti->ncolors = 1 << i->localpalbits;\n\n#ifndef NGIFLIB_INDEXED_ONLY\n\tif (!(i->parent->mode & NGIFLIB_MODE_INDEXED)) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\tif(i->parent->log) fprintf(i->parent->log, \"*** ERROR *** Cannot decode without palette\\n\");\n#endif\n\t\treturn -1;\n\t}\n#endif\n\n\ti->imgbits = GetByte(i->parent);\t/* LZW Minimum Code Size */\n\tif (i->imgbits > 11) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\tif(i->parent->log) fprintf(i->parent->log, \"*** ERROR *** Invalid LZW Minimum Code Size : %d\\n\", (int)i->imgbits);\n#endif\n\t\treturn -1;\n\t}\n\n#if !defined(NGIFLIB_NO_FILE)\n\tif(i->parent && i->parent->log) {\n\t\tif(i->interlaced) fprintf(i->parent->log, \"interlaced \");\n\t\tfprintf(i->parent->log, \"img pos(%hu,%hu) size %hux%hu palbits=%hhu imgbits=%hhu ncolors=%hu\\n\",\n\t       i->posX, i->posY, i->width, i->height, i->localpalbits, i->imgbits, i->ncolors);\n\t}\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\n\tif(i->imgbits==1) {\t/* fix for 1bit images ? */\n\t\ti->imgbits = 2;\n\t}\n\tclr = 1 << i->imgbits;\n\teof = clr + 1;\n\tfree = clr + 2;\n\tcontext.nbbit = i->imgbits + 1;\n\tcontext.max = clr + clr - 1; /* (1 << context.nbbit) - 1 */\n\tstackp = stack_top = ab_stack + 4096;\n\t\n\tcontext.restbits = 0;\t/* initialise le \"buffer\" de lecture */\n\tcontext.restbyte = 0;\t/* des codes LZW */\n\tcontext.lbyte = 0;\n\tfor(;;) {\n\t\tact_code = GetGifWord(i, &context);\n\t\tif(act_code==eof) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"End of image code 0x%x (nbbit=%u)\\n\", eof, context.nbbit);\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\t\t\treturn 0;\n\t\t}\n\t\tif(npix==0) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"assez de pixels, On se casse !\\n\");\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\t\t\treturn 1;\n\t\t}\t\n\t\tif(act_code==clr) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"Code clear (%hu) (free=%hu) npix=%ld\\n\", clr, free, npix);\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\t\t\t/* clear */\n\t\t\tfree = clr + 2;\n\t\t\tcontext.nbbit = i->imgbits + 1;\n\t\t\tcontext.max = clr + clr - 1; /* (1 << context.nbbit) - 1 */\n\t\t\tact_code = GetGifWord(i, &context);\t/* the first code after the clear code is concrete */\n\t\t\tif (act_code >= clr)\n\t\t\t{\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"Invalid code %hu just after clear(%hu) !\\n\", act_code, clr);\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcasspecial = (u8)act_code;\n\t\t\told_code = act_code;\n\t\t\tif(npix > 0) WritePixel(i, &context, casspecial);\n\t\t\tnpix--;\n\t\t} else if(act_code > free) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"Invalid code %hu (free=%hu) !\\n\", act_code, free);\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tread_byt = act_code;\n\t\t\tif(act_code == free) {\t/* code pas encore dans alphabet */\n/*\t\t\t\tprintf(\"Code pas dans alphabet : %d>=%d push %d\\n\", act_code, free, casspecial); */\n\t\t\t\t*(--stackp) = casspecial; /* dernier debut de chaine ! */\n\t\t\t\tact_code = old_code;\n\t\t\t}\n/*\t\t\tprintf(\"actcode=%d\\n\", act_code); */\n\t\t\twhile(act_code > clr) { /* code non concret */\n\t\t\t\t/* fillstackloop empile les suffixes ! */\n\t\t\t\t*(--stackp) = ab_suffx[act_code];\n\t\t\t\tact_code = ab_prfx[act_code];\t/* prefixe */\n\t\t\t}\n\t\t\t/* act_code est concret */\n\t\t\tcasspecial = (u8)act_code;\t/* dernier debut de chaine ! */\n\t\t\t*(--stackp) = casspecial;\t/* push on stack */\n\t\t\tif(npix >= (stack_top - stackp)) {\n\t\t\t\tWritePixels(i, &context, stackp, stack_top - stackp);\t/* unstack all pixels at once */\n\t\t\t} else if(npix > 0) {\t/* \"pixel overflow\" */\n\t\t\t\tWritePixels(i, &context, stackp, npix);\n\t\t\t}\n\t\t\tnpix -= (stack_top - stackp);\n\t\t\tstackp = stack_top;\n/*\t\t\tputchar('\\n'); */\n\t\t\tif(free < 4096) { /* la taille du dico est 4096 max ! */\n\t\t\t\tab_prfx[free] = old_code;\n\t\t\t\tab_suffx[free] = (u8)act_code;\n\t\t\t\tfree++;\n\t\t\t\tif((free > context.max) && (context.nbbit < 12)) {\n\t\t\t\t\tcontext.nbbit++;\t/* 1 bit de plus pour les codes LZW */\n\t\t\t\t\tcontext.max += context.max + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\told_code = read_byt;\n\t\t}\n\t\t\t\n\t}\n\treturn 0;\n}",
        "func": "static int DecodeGifImg(struct ngiflib_img * i) {\n\tstruct ngiflib_decode_context context;\n\tlong npix;\n\tu8 * stackp;\n\tu8 * stack_top;\n\tu16 clr;\n\tu16 eof;\n\tu16 free;\n\tu16 act_code = 0;\n\tu16 old_code = 0;\n\tu16 read_byt;\n\tu16 ab_prfx[4096];\n\tu8 ab_suffx[4096];\n\tu8 ab_stack[4096];\n\tu8 flags;\n\tu8 casspecial = 0;\n\n\tif(!i) return -1;\n\n\ti->posX = GetWord(i->parent);\t/* offsetX */\n\ti->posY = GetWord(i->parent);\t/* offsetY */\n\ti->width = GetWord(i->parent);\t/* SizeX   */\n\ti->height = GetWord(i->parent);\t/* SizeY   */\n\n\tif((i->width > i->parent->width) || (i->height > i->parent->height)) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\tif(i->parent->log) fprintf(i->parent->log, \"*** ERROR *** Image bigger than global GIF canvas !\\n\");\n#endif\n\t\treturn -1;\n\t}\n\tif((i->posX + i->width) > i->parent->width) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\tif(i->parent->log) fprintf(i->parent->log, \"*** WARNING *** Adjusting X position\\n\");\n#endif\n\t\ti->posX = i->parent->width - i->width;\n\t}\n\tif((i->posY + i->height) > i->parent->height) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\tif(i->parent->log) fprintf(i->parent->log, \"*** WARNING *** Adjusting Y position\\n\");\n#endif\n\t\ti->posY = i->parent->height - i->height;\n\t}\n\tcontext.Xtogo = i->width;\n\tcontext.curY = i->posY;\n#ifdef NGIFLIB_INDEXED_ONLY\n\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\tcontext.line_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width;\n\tcontext.frbuff_p.p8 = context.line_p.p8 + i->posX;\n\t#else\n\tcontext.frbuff_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width + i->posX;\n\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n#else\n\tif(i->parent->mode & NGIFLIB_MODE_INDEXED) {\n\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\tcontext.line_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width;\n\t\tcontext.frbuff_p.p8 = context.line_p.p8 + i->posX;\n\t\t#else\n\t\tcontext.frbuff_p.p8 = i->parent->frbuff.p8 + (u32)i->posY*i->parent->width + i->posX;\n\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t} else {\n\t\t#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\tcontext.line_p.p32 = i->parent->frbuff.p32 + (u32)i->posY*i->parent->width;\n\t\tcontext.frbuff_p.p32 = context.line_p.p32 + i->posX;\n\t\t#else\n\t\tcontext.frbuff_p.p32 = i->parent->frbuff.p32 + (u32)i->posY*i->parent->width + i->posX;\n\t\t#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t}\n#endif /* NGIFLIB_INDEXED_ONLY */\n\n\tnpix = (long)i->width * i->height;\n\tflags = GetByte(i->parent);\n\ti->interlaced = (flags & 64) >> 6;\n\tcontext.pass = i->interlaced ? 1 : 0;\n\ti->sort_flag = (flags & 32) >> 5;\t/* is local palette sorted by color frequency ? */\n\ti->localpalbits = (flags & 7) + 1;\n\tif(flags&128) { /* palette locale */\n\t\tint k;\n\t\tint localpalsize = 1 << i->localpalbits;\n#if !defined(NGIFLIB_NO_FILE)\n\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"Local palette\\n\");\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\t\ti->palette = (struct ngiflib_rgb *)ngiflib_malloc(sizeof(struct ngiflib_rgb)*localpalsize);\n#ifdef EXTRA_MALLOC_CHECK\n\t\tif(i->palette == NULL) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\tif(i->parent->log) fprintf(i->parent->log, \"*** ERROR *** The value returned by 'ngiflib_malloc()' call at %s:%d location is NULL\\n\", __FILE__, __LINE__);\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\t\t\treturn -2;    /* memory error */\n\t\t}\n#endif /* EXTRA_MALLOC_CHECK */\n\t\tfor(k=0; k<localpalsize; k++) {\n\t\t\ti->palette[k].r = GetByte(i->parent);\n\t\t\ti->palette[k].g = GetByte(i->parent);\n\t\t\ti->palette[k].b = GetByte(i->parent);\n\t\t}\n#ifdef NGIFLIB_ENABLE_CALLBACKS\n\t\tif(i->parent->palette_cb) i->parent->palette_cb(i->parent, i->palette, localpalsize);\n#endif /* NGIFLIB_ENABLE_CALLBACKS */\n\t} else {\n\t\t/* use global palette */\n\t\ti->palette = i->parent->palette;\n\t\ti->localpalbits = i->parent->imgbits;\n\t}\n\ti->ncolors = 1 << i->localpalbits;\n\n#ifndef NGIFLIB_INDEXED_ONLY\n\tif (!(i->parent->mode & NGIFLIB_MODE_INDEXED)) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\tif(i->parent->log) fprintf(i->parent->log, \"*** ERROR *** Cannot decode without palette\\n\");\n#endif\n\t\treturn -1;\n\t}\n#endif\n\n\ti->imgbits = GetByte(i->parent);\t/* LZW Minimum Code Size */\n\tif (i->imgbits > 11) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\tif(i->parent->log) fprintf(i->parent->log, \"*** ERROR *** Invalid LZW Minimum Code Size : %d\\n\", (int)i->imgbits);\n#endif\n\t\treturn -1;\n\t}\n\n#if !defined(NGIFLIB_NO_FILE)\n\tif(i->parent && i->parent->log) {\n\t\tif(i->interlaced) fprintf(i->parent->log, \"interlaced \");\n\t\tfprintf(i->parent->log, \"img pos(%hu,%hu) size %hux%hu palbits=%hhu imgbits=%hhu ncolors=%hu\\n\",\n\t       i->posX, i->posY, i->width, i->height, i->localpalbits, i->imgbits, i->ncolors);\n\t}\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\n\tif(i->imgbits==1) {\t/* fix for 1bit images ? */\n\t\ti->imgbits = 2;\n\t}\n\tclr = 1 << i->imgbits;\n\teof = clr + 1;\n\tfree = clr + 2;\n\tcontext.nbbit = i->imgbits + 1;\n\tcontext.max = clr + clr - 1; /* (1 << context.nbbit) - 1 */\n\tstackp = stack_top = ab_stack + 4096;\n\t\n\tcontext.restbits = 0;\t/* initialise le \"buffer\" de lecture */\n\tcontext.restbyte = 0;\t/* des codes LZW */\n\tcontext.lbyte = 0;\n\tfor(;;) {\n\t\tact_code = GetGifWord(i, &context);\n\t\tif(act_code==eof) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"End of image code 0x%x (nbbit=%u)\\n\", eof, context.nbbit);\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\t\t\treturn 0;\n\t\t}\n\t\tif(npix==0) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"assez de pixels, On se casse !\\n\");\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\t\t\treturn 1;\n\t\t}\t\n\t\tif(act_code==clr) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"Code clear (%hu) (free=%hu) npix=%ld\\n\", clr, free, npix);\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\t\t\t/* clear */\n\t\t\tfree = clr + 2;\n\t\t\tcontext.nbbit = i->imgbits + 1;\n\t\t\tcontext.max = clr + clr - 1; /* (1 << context.nbbit) - 1 */\n\t\t\tact_code = GetGifWord(i, &context);\t/* the first code after the clear code is concrete */\n\t\t\tif (act_code >= clr)\n\t\t\t{\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"Invalid code %hu just after clear(%hu) !\\n\", act_code, clr);\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcasspecial = (u8)act_code;\n\t\t\told_code = act_code;\n\t\t\tif(npix > 0) {\n\t\t\t\tWritePixel(i, &context, casspecial);\n\t\t\t\tnpix--;\n\t\t\t}\n\t\t} else if(act_code > free) {\n#if !defined(NGIFLIB_NO_FILE)\n\t\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"Invalid code %hu (free=%hu) !\\n\", act_code, free);\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tread_byt = act_code;\n\t\t\tif(act_code == free) {\t/* code pas encore dans alphabet */\n/*\t\t\t\tprintf(\"Code pas dans alphabet : %d>=%d push %d\\n\", act_code, free, casspecial); */\n\t\t\t\t*(--stackp) = casspecial; /* dernier debut de chaine ! */\n\t\t\t\tact_code = old_code;\n\t\t\t}\n/*\t\t\tprintf(\"actcode=%d\\n\", act_code); */\n\t\t\twhile(act_code > clr) { /* code non concret */\n\t\t\t\t/* fillstackloop empile les suffixes ! */\n\t\t\t\t*(--stackp) = ab_suffx[act_code];\n\t\t\t\tact_code = ab_prfx[act_code];\t/* prefixe */\n\t\t\t}\n\t\t\t/* act_code est concret */\n\t\t\tcasspecial = (u8)act_code;\t/* dernier debut de chaine ! */\n\t\t\t*(--stackp) = casspecial;\t/* push on stack */\n\t\t\tif(npix >= (stack_top - stackp)) {\n\t\t\t\tWritePixels(i, &context, stackp, stack_top - stackp);\t/* unstack all pixels at once */\n\t\t\t\tnpix -= (stack_top - stackp);\n\t\t\t} else if(npix > 0) {\t/* \"pixel overflow\" */\n\t\t\t\tWritePixels(i, &context, stackp, npix);\n\t\t\t\tnpix = 0;\n\t\t\t}\n\t\t\tstackp = stack_top;\n/*\t\t\tputchar('\\n'); */\n\t\t\tif(free < 4096) { /* la taille du dico est 4096 max ! */\n\t\t\t\tab_prfx[free] = old_code;\n\t\t\t\tab_suffx[free] = (u8)act_code;\n\t\t\t\tfree++;\n\t\t\t\tif((free > context.max) && (context.nbbit < 12)) {\n\t\t\t\t\tcontext.nbbit++;\t/* 1 bit de plus pour les codes LZW */\n\t\t\t\t\tcontext.max += context.max + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\told_code = read_byt;\n\t\t}\n\t\t\t\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -173,8 +173,10 @@\n \t\t\t}\n \t\t\tcasspecial = (u8)act_code;\n \t\t\told_code = act_code;\n-\t\t\tif(npix > 0) WritePixel(i, &context, casspecial);\n-\t\t\tnpix--;\n+\t\t\tif(npix > 0) {\n+\t\t\t\tWritePixel(i, &context, casspecial);\n+\t\t\t\tnpix--;\n+\t\t\t}\n \t\t} else if(act_code > free) {\n #if !defined(NGIFLIB_NO_FILE)\n \t\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"Invalid code %hu (free=%hu) !\\n\", act_code, free);\n@@ -198,10 +200,11 @@\n \t\t\t*(--stackp) = casspecial;\t/* push on stack */\n \t\t\tif(npix >= (stack_top - stackp)) {\n \t\t\t\tWritePixels(i, &context, stackp, stack_top - stackp);\t/* unstack all pixels at once */\n+\t\t\t\tnpix -= (stack_top - stackp);\n \t\t\t} else if(npix > 0) {\t/* \"pixel overflow\" */\n \t\t\t\tWritePixels(i, &context, stackp, npix);\n-\t\t\t}\n-\t\t\tnpix -= (stack_top - stackp);\n+\t\t\t\tnpix = 0;\n+\t\t\t}\n \t\t\tstackp = stack_top;\n /*\t\t\tputchar('\\n'); */\n \t\t\tif(free < 4096) { /* la taille du dico est 4096 max ! */",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tif(npix > 0) WritePixel(i, &context, casspecial);",
                "\t\t\tnpix--;",
                "\t\t\t}",
                "\t\t\tnpix -= (stack_top - stackp);"
            ],
            "added_lines": [
                "\t\t\tif(npix > 0) {",
                "\t\t\t\tWritePixel(i, &context, casspecial);",
                "\t\t\t\tnpix--;",
                "\t\t\t}",
                "\t\t\t\tnpix -= (stack_top - stackp);",
                "\t\t\t\tnpix = 0;",
                "\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-8558",
        "func_name": "qemu/ehci_process_itd",
        "description": "The ehci_process_itd function in hw/usb/hcd-ehci.c in QEMU allows local guest OS administrators to cause a denial of service (infinite loop and CPU consumption) via a circular isochronous transfer descriptor (iTD) list.",
        "git_url": "https://github.com/qemu/qemu/commit/156a2e4dbffa85997636a7a39ef12da6f1b40254",
        "commit_title": "ehci: make idt processing more robust",
        "commit_text": " Make ehci_process_itd return an error in case we didn't do any actual iso transfer because we've found no active transaction.  That'll avoid ehci happily run in circles forever if the guest builds a loop out of idts.  This is CVE-2015-8558.  Cc: qemu-stable@nongnu.org",
        "func_before": "static int ehci_process_itd(EHCIState *ehci,\n                            EHCIitd *itd,\n                            uint32_t addr)\n{\n    USBDevice *dev;\n    USBEndpoint *ep;\n    uint32_t i, len, pid, dir, devaddr, endp;\n    uint32_t pg, off, ptr1, ptr2, max, mult;\n\n    ehci->periodic_sched_active = PERIODIC_ACTIVE;\n\n    dir =(itd->bufptr[1] & ITD_BUFPTR_DIRECTION);\n    devaddr = get_field(itd->bufptr[0], ITD_BUFPTR_DEVADDR);\n    endp = get_field(itd->bufptr[0], ITD_BUFPTR_EP);\n    max = get_field(itd->bufptr[1], ITD_BUFPTR_MAXPKT);\n    mult = get_field(itd->bufptr[2], ITD_BUFPTR_MULT);\n\n    for(i = 0; i < 8; i++) {\n        if (itd->transact[i] & ITD_XACT_ACTIVE) {\n            pg   = get_field(itd->transact[i], ITD_XACT_PGSEL);\n            off  = itd->transact[i] & ITD_XACT_OFFSET_MASK;\n            ptr1 = (itd->bufptr[pg] & ITD_BUFPTR_MASK);\n            ptr2 = (itd->bufptr[pg+1] & ITD_BUFPTR_MASK);\n            len  = get_field(itd->transact[i], ITD_XACT_LENGTH);\n\n            if (len > max * mult) {\n                len = max * mult;\n            }\n\n            if (len > BUFF_SIZE) {\n                return -1;\n            }\n\n            qemu_sglist_init(&ehci->isgl, ehci->device, 2, ehci->as);\n            if (off + len > 4096) {\n                /* transfer crosses page border */\n                uint32_t len2 = off + len - 4096;\n                uint32_t len1 = len - len2;\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len1);\n                qemu_sglist_add(&ehci->isgl, ptr2, len2);\n            } else {\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len);\n            }\n\n            pid = dir ? USB_TOKEN_IN : USB_TOKEN_OUT;\n\n            dev = ehci_find_device(ehci, devaddr);\n            ep = usb_ep_get(dev, pid, endp);\n            if (ep && ep->type == USB_ENDPOINT_XFER_ISOC) {\n                usb_packet_setup(&ehci->ipacket, pid, ep, 0, addr, false,\n                                 (itd->transact[i] & ITD_XACT_IOC) != 0);\n                usb_packet_map(&ehci->ipacket, &ehci->isgl);\n                usb_handle_packet(dev, &ehci->ipacket);\n                usb_packet_unmap(&ehci->ipacket, &ehci->isgl);\n            } else {\n                DPRINTF(\"ISOCH: attempt to addess non-iso endpoint\\n\");\n                ehci->ipacket.status = USB_RET_NAK;\n                ehci->ipacket.actual_length = 0;\n            }\n            qemu_sglist_destroy(&ehci->isgl);\n\n            switch (ehci->ipacket.status) {\n            case USB_RET_SUCCESS:\n                break;\n            default:\n                fprintf(stderr, \"Unexpected iso usb result: %d\\n\",\n                        ehci->ipacket.status);\n                /* Fall through */\n            case USB_RET_IOERROR:\n            case USB_RET_NODEV:\n                /* 3.3.2: XACTERR is only allowed on IN transactions */\n                if (dir) {\n                    itd->transact[i] |= ITD_XACT_XACTERR;\n                    ehci_raise_irq(ehci, USBSTS_ERRINT);\n                }\n                break;\n            case USB_RET_BABBLE:\n                itd->transact[i] |= ITD_XACT_BABBLE;\n                ehci_raise_irq(ehci, USBSTS_ERRINT);\n                break;\n            case USB_RET_NAK:\n                /* no data for us, so do a zero-length transfer */\n                ehci->ipacket.actual_length = 0;\n                break;\n            }\n            if (!dir) {\n                set_field(&itd->transact[i], len - ehci->ipacket.actual_length,\n                          ITD_XACT_LENGTH); /* OUT */\n            } else {\n                set_field(&itd->transact[i], ehci->ipacket.actual_length,\n                          ITD_XACT_LENGTH); /* IN */\n            }\n            if (itd->transact[i] & ITD_XACT_IOC) {\n                ehci_raise_irq(ehci, USBSTS_INT);\n            }\n            itd->transact[i] &= ~ITD_XACT_ACTIVE;\n        }\n    }\n    return 0;\n}",
        "func": "static int ehci_process_itd(EHCIState *ehci,\n                            EHCIitd *itd,\n                            uint32_t addr)\n{\n    USBDevice *dev;\n    USBEndpoint *ep;\n    uint32_t i, len, pid, dir, devaddr, endp, xfers = 0;\n    uint32_t pg, off, ptr1, ptr2, max, mult;\n\n    ehci->periodic_sched_active = PERIODIC_ACTIVE;\n\n    dir =(itd->bufptr[1] & ITD_BUFPTR_DIRECTION);\n    devaddr = get_field(itd->bufptr[0], ITD_BUFPTR_DEVADDR);\n    endp = get_field(itd->bufptr[0], ITD_BUFPTR_EP);\n    max = get_field(itd->bufptr[1], ITD_BUFPTR_MAXPKT);\n    mult = get_field(itd->bufptr[2], ITD_BUFPTR_MULT);\n\n    for(i = 0; i < 8; i++) {\n        if (itd->transact[i] & ITD_XACT_ACTIVE) {\n            pg   = get_field(itd->transact[i], ITD_XACT_PGSEL);\n            off  = itd->transact[i] & ITD_XACT_OFFSET_MASK;\n            ptr1 = (itd->bufptr[pg] & ITD_BUFPTR_MASK);\n            ptr2 = (itd->bufptr[pg+1] & ITD_BUFPTR_MASK);\n            len  = get_field(itd->transact[i], ITD_XACT_LENGTH);\n\n            if (len > max * mult) {\n                len = max * mult;\n            }\n\n            if (len > BUFF_SIZE) {\n                return -1;\n            }\n\n            qemu_sglist_init(&ehci->isgl, ehci->device, 2, ehci->as);\n            if (off + len > 4096) {\n                /* transfer crosses page border */\n                uint32_t len2 = off + len - 4096;\n                uint32_t len1 = len - len2;\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len1);\n                qemu_sglist_add(&ehci->isgl, ptr2, len2);\n            } else {\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len);\n            }\n\n            pid = dir ? USB_TOKEN_IN : USB_TOKEN_OUT;\n\n            dev = ehci_find_device(ehci, devaddr);\n            ep = usb_ep_get(dev, pid, endp);\n            if (ep && ep->type == USB_ENDPOINT_XFER_ISOC) {\n                usb_packet_setup(&ehci->ipacket, pid, ep, 0, addr, false,\n                                 (itd->transact[i] & ITD_XACT_IOC) != 0);\n                usb_packet_map(&ehci->ipacket, &ehci->isgl);\n                usb_handle_packet(dev, &ehci->ipacket);\n                usb_packet_unmap(&ehci->ipacket, &ehci->isgl);\n            } else {\n                DPRINTF(\"ISOCH: attempt to addess non-iso endpoint\\n\");\n                ehci->ipacket.status = USB_RET_NAK;\n                ehci->ipacket.actual_length = 0;\n            }\n            qemu_sglist_destroy(&ehci->isgl);\n\n            switch (ehci->ipacket.status) {\n            case USB_RET_SUCCESS:\n                break;\n            default:\n                fprintf(stderr, \"Unexpected iso usb result: %d\\n\",\n                        ehci->ipacket.status);\n                /* Fall through */\n            case USB_RET_IOERROR:\n            case USB_RET_NODEV:\n                /* 3.3.2: XACTERR is only allowed on IN transactions */\n                if (dir) {\n                    itd->transact[i] |= ITD_XACT_XACTERR;\n                    ehci_raise_irq(ehci, USBSTS_ERRINT);\n                }\n                break;\n            case USB_RET_BABBLE:\n                itd->transact[i] |= ITD_XACT_BABBLE;\n                ehci_raise_irq(ehci, USBSTS_ERRINT);\n                break;\n            case USB_RET_NAK:\n                /* no data for us, so do a zero-length transfer */\n                ehci->ipacket.actual_length = 0;\n                break;\n            }\n            if (!dir) {\n                set_field(&itd->transact[i], len - ehci->ipacket.actual_length,\n                          ITD_XACT_LENGTH); /* OUT */\n            } else {\n                set_field(&itd->transact[i], ehci->ipacket.actual_length,\n                          ITD_XACT_LENGTH); /* IN */\n            }\n            if (itd->transact[i] & ITD_XACT_IOC) {\n                ehci_raise_irq(ehci, USBSTS_INT);\n            }\n            itd->transact[i] &= ~ITD_XACT_ACTIVE;\n            xfers++;\n        }\n    }\n    return xfers ? 0 : -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n {\n     USBDevice *dev;\n     USBEndpoint *ep;\n-    uint32_t i, len, pid, dir, devaddr, endp;\n+    uint32_t i, len, pid, dir, devaddr, endp, xfers = 0;\n     uint32_t pg, off, ptr1, ptr2, max, mult;\n \n     ehci->periodic_sched_active = PERIODIC_ACTIVE;\n@@ -94,7 +94,8 @@\n                 ehci_raise_irq(ehci, USBSTS_INT);\n             }\n             itd->transact[i] &= ~ITD_XACT_ACTIVE;\n+            xfers++;\n         }\n     }\n-    return 0;\n+    return xfers ? 0 : -1;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    uint32_t i, len, pid, dir, devaddr, endp;",
                "    return 0;"
            ],
            "added_lines": [
                "    uint32_t i, len, pid, dir, devaddr, endp, xfers = 0;",
                "            xfers++;",
                "    return xfers ? 0 : -1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-3573",
        "func_name": "saitoha/libsixel/load_jpeg",
        "description": "In libsixel v1.8.2, there is an infinite loop in the function sixel_decode_raw_impl() in the file fromsixel.c, as demonstrated by sixel2png.",
        "git_url": "https://github.com/saitoha/libsixel/commit/68ecbc1fec8772ddaace1cb2ddd0ab04eb1d1ac1",
        "commit_title": "check jpeg decoder error",
        "commit_text": "",
        "func_before": "static SIXELSTATUS\nload_jpeg(unsigned char **result,\n          unsigned char *data,\n          size_t datasize,\n          int *pwidth,\n          int *pheight,\n          int *ppixelformat,\n          sixel_allocator_t *allocator)\n{\n    SIXELSTATUS status = SIXEL_JPEG_ERROR;\n    JDIMENSION row_stride;\n    size_t size;\n    JSAMPARRAY buffer;\n    struct jpeg_decompress_struct cinfo;\n    struct jpeg_error_mgr pub;\n\n    cinfo.err = jpeg_std_error(&pub);\n\n    jpeg_create_decompress(&cinfo);\n    jpeg_mem_src(&cinfo, data, datasize);\n    jpeg_read_header(&cinfo, TRUE);\n\n    /* disable colormap (indexed color), grayscale -> rgb */\n    cinfo.quantize_colors = FALSE;\n    cinfo.out_color_space = JCS_RGB;\n    jpeg_start_decompress(&cinfo);\n\n    if (cinfo.output_components != 3) {\n        sixel_helper_set_additional_message(\n            \"load_jpeg: unknown pixel format.\");\n        status = SIXEL_BAD_INPUT;\n        goto end;\n    }\n\n    *ppixelformat = SIXEL_PIXELFORMAT_RGB888;\n    *pwidth = (int)cinfo.output_width;\n    *pheight = (int)cinfo.output_height;\n\n    size = (size_t)(*pwidth * *pheight * cinfo.output_components);\n    *result = (unsigned char *)sixel_allocator_malloc(allocator, size);\n    if (*result == NULL) {\n        sixel_helper_set_additional_message(\n            \"load_jpeg: sixel_allocator_malloc() failed.\");\n        status = SIXEL_BAD_ALLOCATION;\n        goto end;\n    }\n    row_stride = cinfo.output_width * (unsigned int)cinfo.output_components;\n    buffer = (*cinfo.mem->alloc_sarray)((j_common_ptr)&cinfo, JPOOL_IMAGE, row_stride, 1);\n\n    while (cinfo.output_scanline < cinfo.output_height) {\n        jpeg_read_scanlines(&cinfo, buffer, 1);\n        memcpy(*result + (cinfo.output_scanline - 1) * row_stride, buffer[0], row_stride);\n    }\n\n    status = SIXEL_OK;\n\nend:\n    jpeg_finish_decompress(&cinfo);\n    jpeg_destroy_decompress(&cinfo);\n\n    return status;\n}",
        "func": "static SIXELSTATUS\nload_jpeg(unsigned char **result,\n          unsigned char *data,\n          size_t datasize,\n          int *pwidth,\n          int *pheight,\n          int *ppixelformat,\n          sixel_allocator_t *allocator)\n{\n    SIXELSTATUS status = SIXEL_JPEG_ERROR;\n    JDIMENSION row_stride;\n    size_t size;\n    JSAMPARRAY buffer;\n    struct jpeg_decompress_struct cinfo;\n    struct jpeg_error_mgr pub;\n\n    cinfo.err = jpeg_std_error(&pub);\n\n    jpeg_create_decompress(&cinfo);\n    jpeg_mem_src(&cinfo, data, datasize);\n    jpeg_read_header(&cinfo, TRUE);\n\n    /* disable colormap (indexed color), grayscale -> rgb */\n    cinfo.quantize_colors = FALSE;\n    cinfo.out_color_space = JCS_RGB;\n    jpeg_start_decompress(&cinfo);\n\n    if (cinfo.output_components != 3) {\n        sixel_helper_set_additional_message(\n            \"load_jpeg: unknown pixel format.\");\n        status = SIXEL_BAD_INPUT;\n        goto end;\n    }\n\n    *ppixelformat = SIXEL_PIXELFORMAT_RGB888;\n    *pwidth = (int)cinfo.output_width;\n    *pheight = (int)cinfo.output_height;\n\n    size = (size_t)(*pwidth * *pheight * cinfo.output_components);\n    *result = (unsigned char *)sixel_allocator_malloc(allocator, size);\n    if (*result == NULL) {\n        sixel_helper_set_additional_message(\n            \"load_jpeg: sixel_allocator_malloc() failed.\");\n        status = SIXEL_BAD_ALLOCATION;\n        goto end;\n    }\n    row_stride = cinfo.output_width * (unsigned int)cinfo.output_components;\n    buffer = (*cinfo.mem->alloc_sarray)((j_common_ptr)&cinfo, JPOOL_IMAGE, row_stride, 1);\n\n    while (cinfo.output_scanline < cinfo.output_height) {\n        jpeg_read_scanlines(&cinfo, buffer, 1);\n        if (cinfo.err->num_warnings > 0) {\n            sixel_helper_set_additional_message(\n                \"jpeg_read_scanlines: error/warining occuered.\");\n            status = SIXEL_BAD_INPUT;\n            goto end;\n        }\n        memcpy(*result + (cinfo.output_scanline - 1) * row_stride, buffer[0], row_stride);\n    }\n\n    status = SIXEL_OK;\n\nend:\n    jpeg_finish_decompress(&cinfo);\n    jpeg_destroy_decompress(&cinfo);\n\n    return status;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -49,6 +49,12 @@\n \n     while (cinfo.output_scanline < cinfo.output_height) {\n         jpeg_read_scanlines(&cinfo, buffer, 1);\n+        if (cinfo.err->num_warnings > 0) {\n+            sixel_helper_set_additional_message(\n+                \"jpeg_read_scanlines: error/warining occuered.\");\n+            status = SIXEL_BAD_INPUT;\n+            goto end;\n+        }\n         memcpy(*result + (cinfo.output_scanline - 1) * row_stride, buffer[0], row_stride);\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (cinfo.err->num_warnings > 0) {",
                "            sixel_helper_set_additional_message(",
                "                \"jpeg_read_scanlines: error/warining occuered.\");",
                "            status = SIXEL_BAD_INPUT;",
                "            goto end;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-3573",
        "func_name": "saitoha/libsixel/sixel_decode_raw_impl",
        "description": "In libsixel v1.8.2, there is an infinite loop in the function sixel_decode_raw_impl() in the file fromsixel.c, as demonstrated by sixel2png.",
        "git_url": "https://github.com/saitoha/libsixel/commit/9c013f23661370a5ece2f0c9c1acfd342e2efebb",
        "commit_title": "check size, fix issue #83",
        "commit_text": "",
        "func_before": "SIXELAPI SIXELSTATUS\nsixel_decode_raw_impl(\n    unsigned char     *p,         /* sixel bytes */\n    int                len,       /* size of sixel bytes */\n    image_buffer_t    *image,\n    parser_context_t  *context,\n    sixel_allocator_t *allocator) /* allocator object */\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    int n;\n    int i;\n    int y;\n    int bits;\n    int sixel_vertical_mask;\n    int sx;\n    int sy;\n    int c;\n    int pos;\n    unsigned char *p0 = p;\n\n    while (p < p0 + len) {\n        switch (context->state) {\n        case PS_GROUND:\n            switch (*p) {\n            case 0x1b:\n                context->state = PS_ESC;\n                p++;\n                break;\n            case 0x90:\n                context->state = PS_DCS;\n                p++;\n                break;\n            case 0x9c:\n                p++;\n                goto finalize;\n            default:\n                p++;\n                break;\n            }\n            break;\n\n        case PS_ESC:\n            switch (*p) {\n            case '\\\\':\n            case 0x9c:\n                p++;\n                goto finalize;\n            case 'P':\n                context->param = -1;\n                context->state = PS_DCS;\n                p++;\n                break;\n            default:\n                p++;\n                break;\n            }\n            break;\n\n        case PS_DCS:\n            switch (*p) {\n            case 0x1b:\n                context->state = PS_ESC;\n                p++;\n                break;\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                if (context->param < 0) {\n                    context->param = 0;\n                }\n                context->param = context->param * 10 + *p - '0';\n                p++;\n                break;\n            case ';':\n                if (context->param < 0) {\n                    context->param = 0;\n                }\n                if (context->nparams < DECSIXEL_PARAMS_MAX) {\n                    context->params[context->nparams++] = context->param;\n                }\n                context->param = 0;\n                p++;\n                break;\n            case 'q':\n                if (context->param >= 0 && context->nparams < DECSIXEL_PARAMS_MAX) {\n                    context->params[context->nparams++] = context->param;\n                }\n                if (context->nparams > 0) {\n                    /* Pn1 */\n                    switch (context->params[0]) {\n                    case 0:\n                    case 1:\n                        context->attributed_pad = 2;\n                        break;\n                    case 2:\n                        context->attributed_pad = 5;\n                        break;\n                    case 3:\n                    case 4:\n                        context->attributed_pad = 4;\n                        break;\n                    case 5:\n                    case 6:\n                        context->attributed_pad = 3;\n                        break;\n                    case 7:\n                    case 8:\n                        context->attributed_pad = 2;\n                        break;\n                    case 9:\n                        context->attributed_pad = 1;\n                        break;\n                    default:\n                        context->attributed_pad = 2;\n                        break;\n                    }\n                }\n\n                if (context->nparams > 2) {\n                    /* Pn3 */\n                    if (context->params[2] == 0) {\n                        context->params[2] = 10;\n                    }\n                    context->attributed_pan = context->attributed_pan * context->params[2] / 10;\n                    context->attributed_pad = context->attributed_pad * context->params[2] / 10;\n                    if (context->attributed_pan <= 0) {\n                        context->attributed_pan = 1;\n                    }\n                    if (context->attributed_pad <= 0) {\n                        context->attributed_pad = 1;\n                    }\n                }\n                context->nparams = 0;\n                context->state = PS_DECSIXEL;\n                p++;\n                break;\n            default:\n                p++;\n                break;\n            }\n            break;\n\n        case PS_DECSIXEL:\n            switch (*p) {\n            case '\\x1b':\n                context->state = PS_ESC;\n                p++;\n                break;\n            case '\"':\n                context->param = 0;\n                context->nparams = 0;\n                context->state = PS_DECGRA;\n                p++;\n                break;\n            case '!':\n                context->param = 0;\n                context->nparams = 0;\n                context->state = PS_DECGRI;\n                p++;\n                break;\n            case '#':\n                context->param = 0;\n                context->nparams = 0;\n                context->state = PS_DECGCI;\n                p++;\n                break;\n            case '$':\n                /* DECGCR Graphics Carriage Return */\n                context->pos_x = 0;\n                p++;\n                break;\n            case '-':\n                /* DECGNL Graphics Next Line */\n                context->pos_x = 0;\n                context->pos_y += 6;\n                p++;\n                break;\n            default:\n                if (*p >= '?' && *p <= '~') {  /* sixel characters */\n                    if (image->width < (context->pos_x + context->repeat_count) || image->height < (context->pos_y + 6)) {\n                        sx = image->width * 2;\n                        sy = image->height * 2;\n                        while (sx < (context->pos_x + context->repeat_count) || sy < (context->pos_y + 6)) {\n                            sx *= 2;\n                            sy *= 2;\n                        }\n                        status = image_buffer_resize(image, sx, sy, context->bgindex, allocator);\n                        if (SIXEL_FAILED(status)) {\n                            goto end;\n                        }\n                    }\n\n                    if (context->color_index > image->ncolors) {\n                        image->ncolors = context->color_index;\n                    }\n\n                    bits = *p - '?';\n\n                    if (bits == 0) {\n                        context->pos_x += context->repeat_count;\n                    } else {\n                        sixel_vertical_mask = 0x01;\n                        if (context->repeat_count <= 1) {\n                            for (i = 0; i < 6; i++) {\n                                if ((bits & sixel_vertical_mask) != 0) {\n                                    pos = image->width * (context->pos_y + i) + context->pos_x;\n                                    image->data[pos] = context->color_index;\n                                    if (context->max_x < context->pos_x) {\n                                        context->max_x = context->pos_x;\n                                    }\n                                    if (context->max_y < (context->pos_y + i)) {\n                                        context->max_y = context->pos_y + i;\n                                    }\n                                }\n                                sixel_vertical_mask <<= 1;\n                            }\n                            context->pos_x += 1;\n                        } else {\n                            /* context->repeat_count > 1 */\n                            for (i = 0; i < 6; i++) {\n                                if ((bits & sixel_vertical_mask) != 0) {\n                                    c = sixel_vertical_mask << 1;\n                                    for (n = 1; (i + n) < 6; n++) {\n                                        if ((bits & c) == 0) {\n                                            break;\n                                        }\n                                        c <<= 1;\n                                    }\n                                    for (y = context->pos_y + i; y < context->pos_y + i + n; ++y) {\n                                        memset(image->data + image->width * y + context->pos_x,\n                                               context->color_index,\n                                               (size_t)context->repeat_count);\n                                    }\n                                    if (context->max_x < (context->pos_x + context->repeat_count - 1)) {\n                                        context->max_x = context->pos_x + context->repeat_count - 1;\n                                    }\n                                    if (context->max_y < (context->pos_y + i + n - 1)) {\n                                        context->max_y = context->pos_y + i + n - 1;\n                                    }\n                                    i += (n - 1);\n                                    sixel_vertical_mask <<= (n - 1);\n                                }\n                                sixel_vertical_mask <<= 1;\n                            }\n                            context->pos_x += context->repeat_count;\n                        }\n                    }\n                    context->repeat_count = 1;\n                }\n                p++;\n                break;\n            }\n            break;\n\n        case PS_DECGRA:\n            /* DECGRA Set Raster Attributes \" Pan; Pad; Ph; Pv */\n            switch (*p) {\n            case '\\x1b':\n                context->state = PS_ESC;\n                p++;\n                break;\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                context->param = context->param * 10 + *p - '0';\n                p++;\n                break;\n            case ';':\n                if (context->nparams < DECSIXEL_PARAMS_MAX) {\n                    context->params[context->nparams++] = context->param;\n                }\n                context->param = 0;\n                p++;\n                break;\n            default:\n                if (context->nparams < DECSIXEL_PARAMS_MAX) {\n                    context->params[context->nparams++] = context->param;\n                }\n                if (context->nparams > 0) {\n                    context->attributed_pad = context->params[0];\n                }\n                if (context->nparams > 1) {\n                    context->attributed_pan = context->params[1];\n                }\n                if (context->nparams > 2 && context->params[2] > 0) {\n                    context->attributed_ph = context->params[2];\n                }\n                if (context->nparams > 3 && context->params[3] > 0) {\n                    context->attributed_pv = context->params[3];\n                }\n\n                if (context->attributed_pan <= 0) {\n                    context->attributed_pan = 1;\n                }\n                if (context->attributed_pad <= 0) {\n                    context->attributed_pad = 1;\n                }\n\n                if (image->width < context->attributed_ph ||\n                        image->height < context->attributed_pv) {\n                    sx = context->attributed_ph;\n                    if (image->width > context->attributed_ph) {\n                        sx = image->width;\n                    }\n\n                    sy = context->attributed_pv;\n                    if (image->height > context->attributed_pv) {\n                        sy = image->height;\n                    }\n\n                    status = image_buffer_resize(image, sx, sy, context->bgindex, allocator);\n                    if (SIXEL_FAILED(status)) {\n                        goto end;\n                    }\n                }\n                context->state = PS_DECSIXEL;\n                context->param = 0;\n                context->nparams = 0;\n            }\n            break;\n\n        case PS_DECGRI:\n            /* DECGRI Graphics Repeat Introducer ! Pn Ch */\n            switch (*p) {\n            case '\\x1b':\n                context->state = PS_ESC;\n                p++;\n                break;\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                context->param = context->param * 10 + *p - '0';\n                p++;\n                break;\n            default:\n                context->repeat_count = context->param;\n                if (context->repeat_count == 0) {\n                    context->repeat_count = 1;\n                }\n                context->state = PS_DECSIXEL;\n                context->param = 0;\n                context->nparams = 0;\n                break;\n            }\n            break;\n\n        case PS_DECGCI:\n            /* DECGCI Graphics Color Introducer # Pc; Pu; Px; Py; Pz */\n            switch (*p) {\n            case '\\x1b':\n                context->state = PS_ESC;\n                p++;\n                break;\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                context->param = context->param * 10 + *p - '0';\n                p++;\n                break;\n            case ';':\n                if (context->nparams < DECSIXEL_PARAMS_MAX) {\n                    context->params[context->nparams++] = context->param;\n                }\n                context->param = 0;\n                p++;\n                break;\n            default:\n                context->state = PS_DECSIXEL;\n                if (context->nparams < DECSIXEL_PARAMS_MAX) {\n                    context->params[context->nparams++] = context->param;\n                }\n                context->param = 0;\n\n                if (context->nparams > 0) {\n                    context->color_index = context->params[0];\n                    if (context->color_index < 0) {\n                        context->color_index = 0;\n                    } else if (context->color_index >= SIXEL_PALETTE_MAX) {\n                        context->color_index = SIXEL_PALETTE_MAX - 1;\n                    }\n                }\n\n                if (context->nparams > 4) {\n                    if (context->params[1] == 1) {\n                        /* HLS */\n                        if (context->params[2] > 360) {\n                            context->params[2] = 360;\n                        }\n                        if (context->params[3] > 100) {\n                            context->params[3] = 100;\n                        }\n                        if (context->params[4] > 100) {\n                            context->params[4] = 100;\n                        }\n                        image->palette[context->color_index]\n                            = hls_to_rgb(context->params[2], context->params[3], context->params[4]);\n                    } else if (context->params[1] == 2) {\n                        /* RGB */\n                        if (context->params[2] > 100) {\n                            context->params[2] = 100;\n                        }\n                        if (context->params[3] > 100) {\n                            context->params[3] = 100;\n                        }\n                        if (context->params[4] > 100) {\n                            context->params[4] = 100;\n                        }\n                        image->palette[context->color_index]\n                            = SIXEL_XRGB(context->params[2], context->params[3], context->params[4]);\n                    }\n                }\n                break;\n            }\n            break;\n        default:\n            break;\n        }\n    }\n\nfinalize:\n    if (++context->max_x < context->attributed_ph) {\n        context->max_x = context->attributed_ph;\n    }\n\n    if (++context->max_y < context->attributed_pv) {\n        context->max_y = context->attributed_pv;\n    }\n\n    if (image->width > context->max_x || image->height > context->max_y) {\n        status = image_buffer_resize(image, context->max_x, context->max_y, context->bgindex, allocator);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n    }\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}",
        "func": "SIXELAPI SIXELSTATUS\nsixel_decode_raw_impl(\n    unsigned char     *p,         /* sixel bytes */\n    int                len,       /* size of sixel bytes */\n    image_buffer_t    *image,\n    parser_context_t  *context,\n    sixel_allocator_t *allocator) /* allocator object */\n{\n    SIXELSTATUS status = SIXEL_FALSE;\n    int n;\n    int i;\n    int y;\n    int bits;\n    int sixel_vertical_mask;\n    int sx;\n    int sy;\n    int c;\n    int pos;\n    unsigned char *p0 = p;\n\n    while (p < p0 + len) {\n        switch (context->state) {\n        case PS_GROUND:\n            switch (*p) {\n            case 0x1b:\n                context->state = PS_ESC;\n                p++;\n                break;\n            case 0x90:\n                context->state = PS_DCS;\n                p++;\n                break;\n            case 0x9c:\n                p++;\n                goto finalize;\n            default:\n                p++;\n                break;\n            }\n            break;\n\n        case PS_ESC:\n            switch (*p) {\n            case '\\\\':\n            case 0x9c:\n                p++;\n                goto finalize;\n            case 'P':\n                context->param = -1;\n                context->state = PS_DCS;\n                p++;\n                break;\n            default:\n                p++;\n                break;\n            }\n            break;\n\n        case PS_DCS:\n            switch (*p) {\n            case 0x1b:\n                context->state = PS_ESC;\n                p++;\n                break;\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                if (context->param < 0) {\n                    context->param = 0;\n                }\n                context->param = context->param * 10 + *p - '0';\n                p++;\n                break;\n            case ';':\n                if (context->param < 0) {\n                    context->param = 0;\n                }\n                if (context->nparams < DECSIXEL_PARAMS_MAX) {\n                    context->params[context->nparams++] = context->param;\n                }\n                context->param = 0;\n                p++;\n                break;\n            case 'q':\n                if (context->param >= 0 && context->nparams < DECSIXEL_PARAMS_MAX) {\n                    context->params[context->nparams++] = context->param;\n                }\n                if (context->nparams > 0) {\n                    /* Pn1 */\n                    switch (context->params[0]) {\n                    case 0:\n                    case 1:\n                        context->attributed_pad = 2;\n                        break;\n                    case 2:\n                        context->attributed_pad = 5;\n                        break;\n                    case 3:\n                    case 4:\n                        context->attributed_pad = 4;\n                        break;\n                    case 5:\n                    case 6:\n                        context->attributed_pad = 3;\n                        break;\n                    case 7:\n                    case 8:\n                        context->attributed_pad = 2;\n                        break;\n                    case 9:\n                        context->attributed_pad = 1;\n                        break;\n                    default:\n                        context->attributed_pad = 2;\n                        break;\n                    }\n                }\n\n                if (context->nparams > 2) {\n                    /* Pn3 */\n                    if (context->params[2] == 0) {\n                        context->params[2] = 10;\n                    }\n                    context->attributed_pan = context->attributed_pan * context->params[2] / 10;\n                    context->attributed_pad = context->attributed_pad * context->params[2] / 10;\n                    if (context->attributed_pan <= 0) {\n                        context->attributed_pan = 1;\n                    }\n                    if (context->attributed_pad <= 0) {\n                        context->attributed_pad = 1;\n                    }\n                }\n                context->nparams = 0;\n                context->state = PS_DECSIXEL;\n                p++;\n                break;\n            default:\n                p++;\n                break;\n            }\n            break;\n\n        case PS_DECSIXEL:\n            switch (*p) {\n            case '\\x1b':\n                context->state = PS_ESC;\n                p++;\n                break;\n            case '\"':\n                context->param = 0;\n                context->nparams = 0;\n                context->state = PS_DECGRA;\n                p++;\n                break;\n            case '!':\n                context->param = 0;\n                context->nparams = 0;\n                context->state = PS_DECGRI;\n                p++;\n                break;\n            case '#':\n                context->param = 0;\n                context->nparams = 0;\n                context->state = PS_DECGCI;\n                p++;\n                break;\n            case '$':\n                /* DECGCR Graphics Carriage Return */\n                context->pos_x = 0;\n                p++;\n                break;\n            case '-':\n                /* DECGNL Graphics Next Line */\n                context->pos_x = 0;\n                context->pos_y += 6;\n                p++;\n                break;\n            default:\n                if (*p >= '?' && *p <= '~') {  /* sixel characters */\n                    if (image->width < (context->pos_x + context->repeat_count) || image->height < (context->pos_y + 6)) {\n                        sx = image->width * 2;\n                        sy = image->height * 2;\n                        while (sx < (context->pos_x + context->repeat_count) || sy < (context->pos_y + 6)) {\n                            sx *= 2;\n                            sy *= 2;\n                        }\n                        status = image_buffer_resize(image, sx, sy, context->bgindex, allocator);\n                        if (SIXEL_FAILED(status)) {\n                            goto end;\n                        }\n                    }\n\n                    if (context->color_index > image->ncolors) {\n                        image->ncolors = context->color_index;\n                    }\n\n                    bits = *p - '?';\n\n                    if (bits == 0) {\n                        context->pos_x += context->repeat_count;\n                    } else {\n                        sixel_vertical_mask = 0x01;\n                        if (context->repeat_count <= 1) {\n                            for (i = 0; i < 6; i++) {\n                                if ((bits & sixel_vertical_mask) != 0) {\n                                    pos = image->width * (context->pos_y + i) + context->pos_x;\n                                    image->data[pos] = context->color_index;\n                                    if (context->max_x < context->pos_x) {\n                                        context->max_x = context->pos_x;\n                                    }\n                                    if (context->max_y < (context->pos_y + i)) {\n                                        context->max_y = context->pos_y + i;\n                                    }\n                                }\n                                sixel_vertical_mask <<= 1;\n                            }\n                            context->pos_x += 1;\n                        } else {\n                            /* context->repeat_count > 1 */\n                            for (i = 0; i < 6; i++) {\n                                if ((bits & sixel_vertical_mask) != 0) {\n                                    c = sixel_vertical_mask << 1;\n                                    for (n = 1; (i + n) < 6; n++) {\n                                        if ((bits & c) == 0) {\n                                            break;\n                                        }\n                                        c <<= 1;\n                                    }\n                                    for (y = context->pos_y + i; y < context->pos_y + i + n; ++y) {\n                                        memset(image->data + image->width * y + context->pos_x,\n                                               context->color_index,\n                                               (size_t)context->repeat_count);\n                                    }\n                                    if (context->max_x < (context->pos_x + context->repeat_count - 1)) {\n                                        context->max_x = context->pos_x + context->repeat_count - 1;\n                                    }\n                                    if (context->max_y < (context->pos_y + i + n - 1)) {\n                                        context->max_y = context->pos_y + i + n - 1;\n                                    }\n                                    i += (n - 1);\n                                    sixel_vertical_mask <<= (n - 1);\n                                }\n                                sixel_vertical_mask <<= 1;\n                            }\n                            context->pos_x += context->repeat_count;\n                        }\n                    }\n                    context->repeat_count = 1;\n                }\n                p++;\n                break;\n            }\n            break;\n\n        case PS_DECGRA:\n            /* DECGRA Set Raster Attributes \" Pan; Pad; Ph; Pv */\n            switch (*p) {\n            case '\\x1b':\n                context->state = PS_ESC;\n                p++;\n                break;\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                context->param = context->param * 10 + *p - '0';\n                p++;\n                break;\n            case ';':\n                if (context->nparams < DECSIXEL_PARAMS_MAX) {\n                    context->params[context->nparams++] = context->param;\n                }\n                context->param = 0;\n                p++;\n                break;\n            default:\n                if (context->nparams < DECSIXEL_PARAMS_MAX) {\n                    context->params[context->nparams++] = context->param;\n                }\n                if (context->nparams > 0) {\n                    context->attributed_pad = context->params[0];\n                }\n                if (context->nparams > 1) {\n                    context->attributed_pan = context->params[1];\n                }\n                if (context->nparams > 2 && context->params[2] > 0) {\n                    context->attributed_ph = context->params[2];\n                }\n                if (context->nparams > 3 && context->params[3] > 0) {\n                    context->attributed_pv = context->params[3];\n                }\n\n                if (context->attributed_pan <= 0) {\n                    context->attributed_pan = 1;\n                }\n                if (context->attributed_pad <= 0) {\n                    context->attributed_pad = 1;\n                }\n\n                if (image->width < context->attributed_ph ||\n                        image->height < context->attributed_pv) {\n                    sx = context->attributed_ph;\n                    if (image->width > context->attributed_ph) {\n                        sx = image->width;\n                    }\n\n                    sy = context->attributed_pv;\n                    if (image->height > context->attributed_pv) {\n                        sy = image->height;\n                    }\n\n                    status = image_buffer_resize(image, sx, sy, context->bgindex, allocator);\n                    if (SIXEL_FAILED(status)) {\n                        goto end;\n                    }\n                }\n                context->state = PS_DECSIXEL;\n                context->param = 0;\n                context->nparams = 0;\n            }\n            break;\n\n        case PS_DECGRI:\n            /* DECGRI Graphics Repeat Introducer ! Pn Ch */\n            switch (*p) {\n            case '\\x1b':\n                context->state = PS_ESC;\n                p++;\n                break;\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                context->param = context->param * 10 + *p - '0';\n                p++;\n                break;\n            default:\n                context->repeat_count = context->param;\n                if (context->repeat_count == 0) {\n                    context->repeat_count = 1;\n                }\n                if (context->repeat_count > 0xffff) { /* check too huge number */\n                    status = SIXEL_BAD_INPUT;\n                    goto end;\n                }\n                context->state = PS_DECSIXEL;\n                context->param = 0;\n                context->nparams = 0;\n                break;\n            }\n            break;\n\n        case PS_DECGCI:\n            /* DECGCI Graphics Color Introducer # Pc; Pu; Px; Py; Pz */\n            switch (*p) {\n            case '\\x1b':\n                context->state = PS_ESC;\n                p++;\n                break;\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                context->param = context->param * 10 + *p - '0';\n                p++;\n                break;\n            case ';':\n                if (context->nparams < DECSIXEL_PARAMS_MAX) {\n                    context->params[context->nparams++] = context->param;\n                }\n                context->param = 0;\n                p++;\n                break;\n            default:\n                context->state = PS_DECSIXEL;\n                if (context->nparams < DECSIXEL_PARAMS_MAX) {\n                    context->params[context->nparams++] = context->param;\n                }\n                context->param = 0;\n\n                if (context->nparams > 0) {\n                    context->color_index = context->params[0];\n                    if (context->color_index < 0) {\n                        context->color_index = 0;\n                    } else if (context->color_index >= SIXEL_PALETTE_MAX) {\n                        context->color_index = SIXEL_PALETTE_MAX - 1;\n                    }\n                }\n\n                if (context->nparams > 4) {\n                    if (context->params[1] == 1) {\n                        /* HLS */\n                        if (context->params[2] > 360) {\n                            context->params[2] = 360;\n                        }\n                        if (context->params[3] > 100) {\n                            context->params[3] = 100;\n                        }\n                        if (context->params[4] > 100) {\n                            context->params[4] = 100;\n                        }\n                        image->palette[context->color_index]\n                            = hls_to_rgb(context->params[2], context->params[3], context->params[4]);\n                    } else if (context->params[1] == 2) {\n                        /* RGB */\n                        if (context->params[2] > 100) {\n                            context->params[2] = 100;\n                        }\n                        if (context->params[3] > 100) {\n                            context->params[3] = 100;\n                        }\n                        if (context->params[4] > 100) {\n                            context->params[4] = 100;\n                        }\n                        image->palette[context->color_index]\n                            = SIXEL_XRGB(context->params[2], context->params[3], context->params[4]);\n                    }\n                }\n                break;\n            }\n            break;\n        default:\n            break;\n        }\n    }\n\nfinalize:\n    if (++context->max_x < context->attributed_ph) {\n        context->max_x = context->attributed_ph;\n    }\n\n    if (++context->max_y < context->attributed_pv) {\n        context->max_y = context->attributed_pv;\n    }\n\n    if (image->width > context->max_x || image->height > context->max_y) {\n        status = image_buffer_resize(image, context->max_x, context->max_y, context->bgindex, allocator);\n        if (SIXEL_FAILED(status)) {\n            goto end;\n        }\n    }\n\n    status = SIXEL_OK;\n\nend:\n    return status;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -358,6 +358,10 @@\n                 if (context->repeat_count == 0) {\n                     context->repeat_count = 1;\n                 }\n+                if (context->repeat_count > 0xffff) { /* check too huge number */\n+                    status = SIXEL_BAD_INPUT;\n+                    goto end;\n+                }\n                 context->state = PS_DECSIXEL;\n                 context->param = 0;\n                 context->nparams = 0;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "                if (context->repeat_count > 0xffff) { /* check too huge number */",
                "                    status = SIXEL_BAD_INPUT;",
                "                    goto end;",
                "                }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-1000020",
        "func_name": "libarchive/parse_rockridge",
        "description": "libarchive version commit 5a98dcf8a86364b3c2c469c85b93647dfb139961 onwards (version v2.8.0 onwards) contains a CWE-835: Loop with Unreachable Exit Condition ('Infinite Loop') vulnerability in ISO9660 parser, archive_read_support_format_iso9660.c, read_CE()/parse_rockridge() that can result in DoS by infinite loop. This attack appears to be exploitable via the victim opening a specially crafted ISO9660 file.",
        "git_url": "https://github.com/libarchive/libarchive/commit/8312eaa576014cd9b965012af51bc1f967b12423",
        "commit_title": "iso9660: Fail when expected Rockridge extensions is missing",
        "commit_text": " A corrupted or malicious ISO9660 image can cause read_CE() to loop forever.  read_CE() calls parse_rockridge(), expecting a Rockridge extension to be read. However, parse_rockridge() is structured as a while loop starting with a sanity check, and if the sanity check fails before the loop has run, the function returns ARCHIVE_OK without advancing the position in the file. This causes read_CE() to retry indefinitely.  Make parse_rockridge() return ARCHIVE_WARN if it didn't read an extension. As someone with no real knowledge of the format, this seems more apt than ARCHIVE_FATAL, but both the call-sites escalate it to a fatal error immediately anyway.  Found with a combination of AFL, afl-rb (FairFuzz) and qsym.",
        "func_before": "static int\nparse_rockridge(struct archive_read *a, struct file_info *file,\n    const unsigned char *p, const unsigned char *end)\n{\n\tstruct iso9660 *iso9660;\n\n\tiso9660 = (struct iso9660 *)(a->format->data);\n\n\twhile (p + 4 <= end  /* Enough space for another entry. */\n\t    && p[0] >= 'A' && p[0] <= 'Z' /* Sanity-check 1st char of name. */\n\t    && p[1] >= 'A' && p[1] <= 'Z' /* Sanity-check 2nd char of name. */\n\t    && p[2] >= 4 /* Sanity-check length. */\n\t    && p + p[2] <= end) { /* Sanity-check length. */\n\t\tconst unsigned char *data = p + 4;\n\t\tint data_length = p[2] - 4;\n\t\tint version = p[3];\n\n\t\tswitch(p[0]) {\n\t\tcase 'C':\n\t\t\tif (p[1] == 'E') {\n\t\t\t\tif (version == 1 && data_length == 24) {\n\t\t\t\t\t/*\n\t\t\t\t\t * CE extension comprises:\n\t\t\t\t\t *   8 byte sector containing extension\n\t\t\t\t\t *   8 byte offset w/in above sector\n\t\t\t\t\t *   8 byte length of continuation\n\t\t\t\t\t */\n\t\t\t\t\tint32_t location =\n\t\t\t\t\t    archive_le32dec(data);\n\t\t\t\t\tfile->ce_offset =\n\t\t\t\t\t    archive_le32dec(data+8);\n\t\t\t\t\tfile->ce_size =\n\t\t\t\t\t    archive_le32dec(data+16);\n\t\t\t\t\tif (register_CE(a, location, file)\n\t\t\t\t\t    != ARCHIVE_OK)\n\t\t\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (p[1] == 'L') {\n\t\t\t\tif (version == 1 && data_length == 8) {\n\t\t\t\t\tfile->cl_offset = (uint64_t)\n\t\t\t\t\t    iso9660->logical_block_size *\n\t\t\t\t\t    (uint64_t)archive_le32dec(data);\n\t\t\t\t\tiso9660->seenRockridge = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tif (p[1] == 'M') {\n\t\t\t\tif (version == 1) {\n\t\t\t\t\tparse_rockridge_NM1(file,\n\t\t\t\t\t    data, data_length);\n\t\t\t\t\tiso9660->seenRockridge = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\t/*\n\t\t\t * PD extension is padding;\n\t\t\t * contents are always ignored.\n\t\t\t *\n\t\t\t * PL extension won't appear;\n\t\t\t * contents are always ignored.\n\t\t\t */\n\t\t\tif (p[1] == 'N') {\n\t\t\t\tif (version == 1 && data_length == 16) {\n\t\t\t\t\tfile->rdev = toi(data,4);\n\t\t\t\t\tfile->rdev <<= 32;\n\t\t\t\t\tfile->rdev |= toi(data + 8, 4);\n\t\t\t\t\tiso9660->seenRockridge = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (p[1] == 'X') {\n\t\t\t\t/*\n\t\t\t\t * PX extension comprises:\n\t\t\t\t *   8 bytes for mode,\n\t\t\t\t *   8 bytes for nlinks,\n\t\t\t\t *   8 bytes for uid,\n\t\t\t\t *   8 bytes for gid,\n\t\t\t\t *   8 bytes for inode.\n\t\t\t\t */\n\t\t\t\tif (version == 1) {\n\t\t\t\t\tif (data_length >= 8)\n\t\t\t\t\t\tfile->mode\n\t\t\t\t\t\t    = toi(data, 4);\n\t\t\t\t\tif (data_length >= 16)\n\t\t\t\t\t\tfile->nlinks\n\t\t\t\t\t\t    = toi(data + 8, 4);\n\t\t\t\t\tif (data_length >= 24)\n\t\t\t\t\t\tfile->uid\n\t\t\t\t\t\t    = toi(data + 16, 4);\n\t\t\t\t\tif (data_length >= 32)\n\t\t\t\t\t\tfile->gid\n\t\t\t\t\t\t    = toi(data + 24, 4);\n\t\t\t\t\tif (data_length >= 40)\n\t\t\t\t\t\tfile->number\n\t\t\t\t\t\t    = toi(data + 32, 4);\n\t\t\t\t\tiso9660->seenRockridge = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tif (p[1] == 'E' && version == 1) {\n\t\t\t\tfile->re = 1;\n\t\t\t\tiso9660->seenRockridge = 1;\n\t\t\t}\n\t\t\telse if (p[1] == 'R' && version == 1) {\n\t\t\t\t/*\n\t\t\t\t * RR extension comprises:\n\t\t\t\t *    one byte flag value\n\t\t\t\t * This extension is obsolete,\n\t\t\t\t * so contents are always ignored.\n\t\t\t\t */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tif (p[1] == 'L') {\n\t\t\t\tif (version == 1) {\n\t\t\t\t\tparse_rockridge_SL1(file,\n\t\t\t\t\t    data, data_length);\n\t\t\t\t\tiso9660->seenRockridge = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (p[1] == 'T'\n\t\t\t    && data_length == 0 && version == 1) {\n\t\t\t\t/*\n\t\t\t\t * ST extension marks end of this\n\t\t\t\t * block of SUSP entries.\n\t\t\t\t *\n\t\t\t\t * It allows SUSP to coexist with\n\t\t\t\t * non-SUSP uses of the System\n\t\t\t\t * Use Area by placing non-SUSP data\n\t\t\t\t * after SUSP data.\n\t\t\t\t */\n\t\t\t\tiso9660->seenSUSP = 0;\n\t\t\t\tiso9660->seenRockridge = 0;\n\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tif (p[1] == 'F') {\n\t\t\t\tif (version == 1) {\n\t\t\t\t\tparse_rockridge_TF1(file,\n\t\t\t\t\t    data, data_length);\n\t\t\t\t\tiso9660->seenRockridge = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'Z':\n\t\t\tif (p[1] == 'F') {\n\t\t\t\tif (version == 1)\n\t\t\t\t\tparse_rockridge_ZF1(file,\n\t\t\t\t\t    data, data_length);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tp += p[2];\n\t}\n\treturn (ARCHIVE_OK);\n}",
        "func": "static int\nparse_rockridge(struct archive_read *a, struct file_info *file,\n    const unsigned char *p, const unsigned char *end)\n{\n\tstruct iso9660 *iso9660;\n\tint entry_seen = 0;\n\n\tiso9660 = (struct iso9660 *)(a->format->data);\n\n\twhile (p + 4 <= end  /* Enough space for another entry. */\n\t    && p[0] >= 'A' && p[0] <= 'Z' /* Sanity-check 1st char of name. */\n\t    && p[1] >= 'A' && p[1] <= 'Z' /* Sanity-check 2nd char of name. */\n\t    && p[2] >= 4 /* Sanity-check length. */\n\t    && p + p[2] <= end) { /* Sanity-check length. */\n\t\tconst unsigned char *data = p + 4;\n\t\tint data_length = p[2] - 4;\n\t\tint version = p[3];\n\n\t\tswitch(p[0]) {\n\t\tcase 'C':\n\t\t\tif (p[1] == 'E') {\n\t\t\t\tif (version == 1 && data_length == 24) {\n\t\t\t\t\t/*\n\t\t\t\t\t * CE extension comprises:\n\t\t\t\t\t *   8 byte sector containing extension\n\t\t\t\t\t *   8 byte offset w/in above sector\n\t\t\t\t\t *   8 byte length of continuation\n\t\t\t\t\t */\n\t\t\t\t\tint32_t location =\n\t\t\t\t\t    archive_le32dec(data);\n\t\t\t\t\tfile->ce_offset =\n\t\t\t\t\t    archive_le32dec(data+8);\n\t\t\t\t\tfile->ce_size =\n\t\t\t\t\t    archive_le32dec(data+16);\n\t\t\t\t\tif (register_CE(a, location, file)\n\t\t\t\t\t    != ARCHIVE_OK)\n\t\t\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (p[1] == 'L') {\n\t\t\t\tif (version == 1 && data_length == 8) {\n\t\t\t\t\tfile->cl_offset = (uint64_t)\n\t\t\t\t\t    iso9660->logical_block_size *\n\t\t\t\t\t    (uint64_t)archive_le32dec(data);\n\t\t\t\t\tiso9660->seenRockridge = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'N':\n\t\t\tif (p[1] == 'M') {\n\t\t\t\tif (version == 1) {\n\t\t\t\t\tparse_rockridge_NM1(file,\n\t\t\t\t\t    data, data_length);\n\t\t\t\t\tiso9660->seenRockridge = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\t/*\n\t\t\t * PD extension is padding;\n\t\t\t * contents are always ignored.\n\t\t\t *\n\t\t\t * PL extension won't appear;\n\t\t\t * contents are always ignored.\n\t\t\t */\n\t\t\tif (p[1] == 'N') {\n\t\t\t\tif (version == 1 && data_length == 16) {\n\t\t\t\t\tfile->rdev = toi(data,4);\n\t\t\t\t\tfile->rdev <<= 32;\n\t\t\t\t\tfile->rdev |= toi(data + 8, 4);\n\t\t\t\t\tiso9660->seenRockridge = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (p[1] == 'X') {\n\t\t\t\t/*\n\t\t\t\t * PX extension comprises:\n\t\t\t\t *   8 bytes for mode,\n\t\t\t\t *   8 bytes for nlinks,\n\t\t\t\t *   8 bytes for uid,\n\t\t\t\t *   8 bytes for gid,\n\t\t\t\t *   8 bytes for inode.\n\t\t\t\t */\n\t\t\t\tif (version == 1) {\n\t\t\t\t\tif (data_length >= 8)\n\t\t\t\t\t\tfile->mode\n\t\t\t\t\t\t    = toi(data, 4);\n\t\t\t\t\tif (data_length >= 16)\n\t\t\t\t\t\tfile->nlinks\n\t\t\t\t\t\t    = toi(data + 8, 4);\n\t\t\t\t\tif (data_length >= 24)\n\t\t\t\t\t\tfile->uid\n\t\t\t\t\t\t    = toi(data + 16, 4);\n\t\t\t\t\tif (data_length >= 32)\n\t\t\t\t\t\tfile->gid\n\t\t\t\t\t\t    = toi(data + 24, 4);\n\t\t\t\t\tif (data_length >= 40)\n\t\t\t\t\t\tfile->number\n\t\t\t\t\t\t    = toi(data + 32, 4);\n\t\t\t\t\tiso9660->seenRockridge = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tif (p[1] == 'E' && version == 1) {\n\t\t\t\tfile->re = 1;\n\t\t\t\tiso9660->seenRockridge = 1;\n\t\t\t}\n\t\t\telse if (p[1] == 'R' && version == 1) {\n\t\t\t\t/*\n\t\t\t\t * RR extension comprises:\n\t\t\t\t *    one byte flag value\n\t\t\t\t * This extension is obsolete,\n\t\t\t\t * so contents are always ignored.\n\t\t\t\t */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tif (p[1] == 'L') {\n\t\t\t\tif (version == 1) {\n\t\t\t\t\tparse_rockridge_SL1(file,\n\t\t\t\t\t    data, data_length);\n\t\t\t\t\tiso9660->seenRockridge = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (p[1] == 'T'\n\t\t\t    && data_length == 0 && version == 1) {\n\t\t\t\t/*\n\t\t\t\t * ST extension marks end of this\n\t\t\t\t * block of SUSP entries.\n\t\t\t\t *\n\t\t\t\t * It allows SUSP to coexist with\n\t\t\t\t * non-SUSP uses of the System\n\t\t\t\t * Use Area by placing non-SUSP data\n\t\t\t\t * after SUSP data.\n\t\t\t\t */\n\t\t\t\tiso9660->seenSUSP = 0;\n\t\t\t\tiso9660->seenRockridge = 0;\n\t\t\t\treturn (ARCHIVE_OK);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tif (p[1] == 'F') {\n\t\t\t\tif (version == 1) {\n\t\t\t\t\tparse_rockridge_TF1(file,\n\t\t\t\t\t    data, data_length);\n\t\t\t\t\tiso9660->seenRockridge = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'Z':\n\t\t\tif (p[1] == 'F') {\n\t\t\t\tif (version == 1)\n\t\t\t\t\tparse_rockridge_ZF1(file,\n\t\t\t\t\t    data, data_length);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tp += p[2];\n\t\tentry_seen = 1;\n\t}\n\n\tif (entry_seen)\n\t\treturn (ARCHIVE_OK);\n\telse {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t  \"Tried to parse Rockridge extensions, but none found\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,7 @@\n     const unsigned char *p, const unsigned char *end)\n {\n \tstruct iso9660 *iso9660;\n+\tint entry_seen = 0;\n \n \tiso9660 = (struct iso9660 *)(a->format->data);\n \n@@ -158,6 +159,14 @@\n \t\t}\n \n \t\tp += p[2];\n+\t\tentry_seen = 1;\n \t}\n-\treturn (ARCHIVE_OK);\n+\n+\tif (entry_seen)\n+\t\treturn (ARCHIVE_OK);\n+\telse {\n+\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n+\t\t\t\t  \"Tried to parse Rockridge extensions, but none found\");\n+\t\treturn (ARCHIVE_WARN);\n+\t}\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn (ARCHIVE_OK);"
            ],
            "added_lines": [
                "\tint entry_seen = 0;",
                "\t\tentry_seen = 1;",
                "",
                "\tif (entry_seen)",
                "\t\treturn (ARCHIVE_OK);",
                "\telse {",
                "\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,",
                "\t\t\t\t  \"Tried to parse Rockridge extensions, but none found\");",
                "\t\treturn (ARCHIVE_WARN);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-20784",
        "func_name": "torvalds/linux/print_cfs_stats",
        "description": "In the Linux kernel before 4.20.2, kernel/sched/fair.c mishandles leaf cfs_rq's, which allows attackers to cause a denial of service (infinite loop in update_blocked_averages) or possibly have unspecified other impact by inducing a high load.",
        "git_url": "https://github.com/torvalds/linux/commit/c40f7d74c741a907cfaeb73a7697081881c497d0",
        "commit_title": "sched/fair: Fix infinite loop in update_blocked_averages() by reverting a9e7f6544b9c",
        "commit_text": " Zhipeng Xie, Xie XiuQi and Sargun Dhillon reported lockups in the scheduler under high loads, starting at around the v4.18 time frame, and Zhipeng Xie tracked it down to bugs in the rq->leaf_cfs_rq_list manipulation.  Do a (manual) revert of:    a9e7f6544b9c (\"sched/fair: Fix O(nr_cgroups) in load balance path\")  It turns out that the list_del_leaf_cfs_rq() introduced by this commit is a surprising property that was not considered in followup commits such as:    9c2791f936ef (\"sched/fair: Fix hierarchical order in rq->leaf_cfs_rq_list\")  As Vincent Guittot explains:   \"I think that there is a bigger problem with commit a9e7f6544b9c and   cfs_rq throttling:    Let take the example of the following topology TG2 --> TG1 --> root:     1) The 1st time a task is enqueued, we will add TG2 cfs_rq then TG1       cfs_rq to leaf_cfs_rq_list and we are sure to do the whole branch in       one path because it has never been used and can't be throttled so       tmp_alone_branch will point to leaf_cfs_rq_list at the end.     2) Then TG1 is throttled     3) and we add TG3 as a new child of TG1.     4) The 1st enqueue of a task on TG3 will add TG3 cfs_rq just before TG1       cfs_rq and tmp_alone_branch will stay  on rq->leaf_cfs_rq_list.    With commit a9e7f6544b9c, we can del a cfs_rq from rq->leaf_cfs_rq_list.   So if the load of TG1 cfs_rq becomes NULL before step 2) above, TG1   cfs_rq is removed from the list.   Then at step 4), TG3 cfs_rq is added at the beginning of rq->leaf_cfs_rq_list   but tmp_alone_branch still points to TG3 cfs_rq because its throttled   parent can't be enqueued when the lock is released.   tmp_alone_branch doesn't point to rq->leaf_cfs_rq_list whereas it should.    So if TG3 cfs_rq is removed or destroyed before tmp_alone_branch   points on another TG cfs_rq, the next TG cfs_rq that will be added,   will be linked outside rq->leaf_cfs_rq_list - which is bad.    In addition, we can break the ordering of the cfs_rq in   rq->leaf_cfs_rq_list but this ordering is used to update and   propagate the update from leaf down to root.\"  Instead of trying to work through all these cases and trying to reproduce the very high loads that produced the lockup to begin with, simplify the code temporarily by reverting a9e7f6544b9c - which change was clearly not thought through completely.  This (hopefully) gives us a kernel that doesn't lock up so people can continue to enjoy their holidays without worrying about regressions. ;-)  [ mingo: Wrote changelog, fixed weird spelling in code comment while at it. ]  Analyzed-by: Xie XiuQi <xiexiuqi@huawei.com> Analyzed-by: Vincent Guittot <vincent.guittot@linaro.org> Cc: <stable@vger.kernel.org> # v4.13+ Cc: Bin Li <huawei.libin@huawei.com> Cc: Mike Galbraith <efault@gmx.de> Cc: Peter Zijlstra <peterz@infradead.org> Cc: Tejun Heo <tj@kernel.org> Cc: Thomas Gleixner <tglx@linutronix.de> Link: http://lkml.kernel.org/r/1545879866-27809-1-git-send-email-xiexiuqi@huawei.com",
        "func_before": "void print_cfs_stats(struct seq_file *m, int cpu)\n{\n\tstruct cfs_rq *cfs_rq, *pos;\n\n\trcu_read_lock();\n\tfor_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)\n\t\tprint_cfs_rq(m, cpu, cfs_rq);\n\trcu_read_unlock();\n}",
        "func": "void print_cfs_stats(struct seq_file *m, int cpu)\n{\n\tstruct cfs_rq *cfs_rq;\n\n\trcu_read_lock();\n\tfor_each_leaf_cfs_rq(cpu_rq(cpu), cfs_rq)\n\t\tprint_cfs_rq(m, cpu, cfs_rq);\n\trcu_read_unlock();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,9 +1,9 @@\n void print_cfs_stats(struct seq_file *m, int cpu)\n {\n-\tstruct cfs_rq *cfs_rq, *pos;\n+\tstruct cfs_rq *cfs_rq;\n \n \trcu_read_lock();\n-\tfor_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)\n+\tfor_each_leaf_cfs_rq(cpu_rq(cpu), cfs_rq)\n \t\tprint_cfs_rq(m, cpu, cfs_rq);\n \trcu_read_unlock();\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tstruct cfs_rq *cfs_rq, *pos;",
                "\tfor_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)"
            ],
            "added_lines": [
                "\tstruct cfs_rq *cfs_rq;",
                "\tfor_each_leaf_cfs_rq(cpu_rq(cpu), cfs_rq)"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-20784",
        "func_name": "torvalds/linux/update_blocked_averages",
        "description": "In the Linux kernel before 4.20.2, kernel/sched/fair.c mishandles leaf cfs_rq's, which allows attackers to cause a denial of service (infinite loop in update_blocked_averages) or possibly have unspecified other impact by inducing a high load.",
        "git_url": "https://github.com/torvalds/linux/commit/c40f7d74c741a907cfaeb73a7697081881c497d0",
        "commit_title": "sched/fair: Fix infinite loop in update_blocked_averages() by reverting a9e7f6544b9c",
        "commit_text": " Zhipeng Xie, Xie XiuQi and Sargun Dhillon reported lockups in the scheduler under high loads, starting at around the v4.18 time frame, and Zhipeng Xie tracked it down to bugs in the rq->leaf_cfs_rq_list manipulation.  Do a (manual) revert of:    a9e7f6544b9c (\"sched/fair: Fix O(nr_cgroups) in load balance path\")  It turns out that the list_del_leaf_cfs_rq() introduced by this commit is a surprising property that was not considered in followup commits such as:    9c2791f936ef (\"sched/fair: Fix hierarchical order in rq->leaf_cfs_rq_list\")  As Vincent Guittot explains:   \"I think that there is a bigger problem with commit a9e7f6544b9c and   cfs_rq throttling:    Let take the example of the following topology TG2 --> TG1 --> root:     1) The 1st time a task is enqueued, we will add TG2 cfs_rq then TG1       cfs_rq to leaf_cfs_rq_list and we are sure to do the whole branch in       one path because it has never been used and can't be throttled so       tmp_alone_branch will point to leaf_cfs_rq_list at the end.     2) Then TG1 is throttled     3) and we add TG3 as a new child of TG1.     4) The 1st enqueue of a task on TG3 will add TG3 cfs_rq just before TG1       cfs_rq and tmp_alone_branch will stay  on rq->leaf_cfs_rq_list.    With commit a9e7f6544b9c, we can del a cfs_rq from rq->leaf_cfs_rq_list.   So if the load of TG1 cfs_rq becomes NULL before step 2) above, TG1   cfs_rq is removed from the list.   Then at step 4), TG3 cfs_rq is added at the beginning of rq->leaf_cfs_rq_list   but tmp_alone_branch still points to TG3 cfs_rq because its throttled   parent can't be enqueued when the lock is released.   tmp_alone_branch doesn't point to rq->leaf_cfs_rq_list whereas it should.    So if TG3 cfs_rq is removed or destroyed before tmp_alone_branch   points on another TG cfs_rq, the next TG cfs_rq that will be added,   will be linked outside rq->leaf_cfs_rq_list - which is bad.    In addition, we can break the ordering of the cfs_rq in   rq->leaf_cfs_rq_list but this ordering is used to update and   propagate the update from leaf down to root.\"  Instead of trying to work through all these cases and trying to reproduce the very high loads that produced the lockup to begin with, simplify the code temporarily by reverting a9e7f6544b9c - which change was clearly not thought through completely.  This (hopefully) gives us a kernel that doesn't lock up so people can continue to enjoy their holidays without worrying about regressions. ;-)  [ mingo: Wrote changelog, fixed weird spelling in code comment while at it. ]  Analyzed-by: Xie XiuQi <xiexiuqi@huawei.com> Analyzed-by: Vincent Guittot <vincent.guittot@linaro.org> Cc: <stable@vger.kernel.org> # v4.13+ Cc: Bin Li <huawei.libin@huawei.com> Cc: Mike Galbraith <efault@gmx.de> Cc: Peter Zijlstra <peterz@infradead.org> Cc: Tejun Heo <tj@kernel.org> Cc: Thomas Gleixner <tglx@linutronix.de> Link: http://lkml.kernel.org/r/1545879866-27809-1-git-send-email-xiexiuqi@huawei.com",
        "func_before": "static void update_blocked_averages(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct cfs_rq *cfs_rq, *pos;\n\tconst struct sched_class *curr_class;\n\tstruct rq_flags rf;\n\tbool done = true;\n\n\trq_lock_irqsave(rq, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * Iterates the task_group tree in a bottom up fashion, see\n\t * list_add_leaf_cfs_rq() for details.\n\t */\n\tfor_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {\n\t\tstruct sched_entity *se;\n\n\t\t/* throttled entities do not contribute to load */\n\t\tif (throttled_hierarchy(cfs_rq))\n\t\t\tcontinue;\n\n\t\tif (update_cfs_rq_load_avg(cfs_rq_clock_task(cfs_rq), cfs_rq))\n\t\t\tupdate_tg_load_avg(cfs_rq, 0);\n\n\t\t/* Propagate pending load changes to the parent, if any: */\n\t\tse = cfs_rq->tg->se[cpu];\n\t\tif (se && !skip_blocked_update(se))\n\t\t\tupdate_load_avg(cfs_rq_of(se), se, 0);\n\n\t\t/*\n\t\t * There can be a lot of idle CPU cgroups.  Don't let fully\n\t\t * decayed cfs_rqs linger on the list.\n\t\t */\n\t\tif (cfs_rq_is_decayed(cfs_rq))\n\t\t\tlist_del_leaf_cfs_rq(cfs_rq);\n\n\t\t/* Don't need periodic decay once load/util_avg are null */\n\t\tif (cfs_rq_has_blocked(cfs_rq))\n\t\t\tdone = false;\n\t}\n\n\tcurr_class = rq->curr->sched_class;\n\tupdate_rt_rq_load_avg(rq_clock_task(rq), rq, curr_class == &rt_sched_class);\n\tupdate_dl_rq_load_avg(rq_clock_task(rq), rq, curr_class == &dl_sched_class);\n\tupdate_irq_load_avg(rq, 0);\n\t/* Don't need periodic decay once load/util_avg are null */\n\tif (others_have_blocked(rq))\n\t\tdone = false;\n\n#ifdef CONFIG_NO_HZ_COMMON\n\trq->last_blocked_load_update_tick = jiffies;\n\tif (done)\n\t\trq->has_blocked_load = 0;\n#endif\n\trq_unlock_irqrestore(rq, &rf);\n}",
        "func": "static void update_blocked_averages(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct cfs_rq *cfs_rq;\n\tconst struct sched_class *curr_class;\n\tstruct rq_flags rf;\n\tbool done = true;\n\n\trq_lock_irqsave(rq, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * Iterates the task_group tree in a bottom up fashion, see\n\t * list_add_leaf_cfs_rq() for details.\n\t */\n\tfor_each_leaf_cfs_rq(rq, cfs_rq) {\n\t\tstruct sched_entity *se;\n\n\t\t/* throttled entities do not contribute to load */\n\t\tif (throttled_hierarchy(cfs_rq))\n\t\t\tcontinue;\n\n\t\tif (update_cfs_rq_load_avg(cfs_rq_clock_task(cfs_rq), cfs_rq))\n\t\t\tupdate_tg_load_avg(cfs_rq, 0);\n\n\t\t/* Propagate pending load changes to the parent, if any: */\n\t\tse = cfs_rq->tg->se[cpu];\n\t\tif (se && !skip_blocked_update(se))\n\t\t\tupdate_load_avg(cfs_rq_of(se), se, 0);\n\n\t\t/* Don't need periodic decay once load/util_avg are null */\n\t\tif (cfs_rq_has_blocked(cfs_rq))\n\t\t\tdone = false;\n\t}\n\n\tcurr_class = rq->curr->sched_class;\n\tupdate_rt_rq_load_avg(rq_clock_task(rq), rq, curr_class == &rt_sched_class);\n\tupdate_dl_rq_load_avg(rq_clock_task(rq), rq, curr_class == &dl_sched_class);\n\tupdate_irq_load_avg(rq, 0);\n\t/* Don't need periodic decay once load/util_avg are null */\n\tif (others_have_blocked(rq))\n\t\tdone = false;\n\n#ifdef CONFIG_NO_HZ_COMMON\n\trq->last_blocked_load_update_tick = jiffies;\n\tif (done)\n\t\trq->has_blocked_load = 0;\n#endif\n\trq_unlock_irqrestore(rq, &rf);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n static void update_blocked_averages(int cpu)\n {\n \tstruct rq *rq = cpu_rq(cpu);\n-\tstruct cfs_rq *cfs_rq, *pos;\n+\tstruct cfs_rq *cfs_rq;\n \tconst struct sched_class *curr_class;\n \tstruct rq_flags rf;\n \tbool done = true;\n@@ -13,7 +13,7 @@\n \t * Iterates the task_group tree in a bottom up fashion, see\n \t * list_add_leaf_cfs_rq() for details.\n \t */\n-\tfor_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {\n+\tfor_each_leaf_cfs_rq(rq, cfs_rq) {\n \t\tstruct sched_entity *se;\n \n \t\t/* throttled entities do not contribute to load */\n@@ -27,13 +27,6 @@\n \t\tse = cfs_rq->tg->se[cpu];\n \t\tif (se && !skip_blocked_update(se))\n \t\t\tupdate_load_avg(cfs_rq_of(se), se, 0);\n-\n-\t\t/*\n-\t\t * There can be a lot of idle CPU cgroups.  Don't let fully\n-\t\t * decayed cfs_rqs linger on the list.\n-\t\t */\n-\t\tif (cfs_rq_is_decayed(cfs_rq))\n-\t\t\tlist_del_leaf_cfs_rq(cfs_rq);\n \n \t\t/* Don't need periodic decay once load/util_avg are null */\n \t\tif (cfs_rq_has_blocked(cfs_rq))",
        "diff_line_info": {
            "deleted_lines": [
                "\tstruct cfs_rq *cfs_rq, *pos;",
                "\tfor_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {",
                "",
                "\t\t/*",
                "\t\t * There can be a lot of idle CPU cgroups.  Don't let fully",
                "\t\t * decayed cfs_rqs linger on the list.",
                "\t\t */",
                "\t\tif (cfs_rq_is_decayed(cfs_rq))",
                "\t\t\tlist_del_leaf_cfs_rq(cfs_rq);"
            ],
            "added_lines": [
                "\tstruct cfs_rq *cfs_rq;",
                "\tfor_each_leaf_cfs_rq(rq, cfs_rq) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-16789",
        "func_name": "shellinabox/urlParsePostBody",
        "description": "libhttp/url.c in shellinabox through 2.20 has an implementation flaw in the HTTP request parsing logic. By sending a crafted multipart/form-data HTTP request, an attacker could exploit this to force shellinaboxd into an infinite loop, exhausting available CPU resources and taking the service down.",
        "git_url": "https://github.com/shellinabox/shellinabox/commit/4f0ecc31ac6f985e0dd3f5a52cbfc0e9251f6361",
        "commit_title": "Rolling code for version 2.21",
        "commit_text": "",
        "func_before": "static void urlParsePostBody(struct URL *url,\n                             const struct HttpConnection *http,\n                             const char *buf, int len) {\n  struct HashMap contentType;\n  initHashMap(&contentType, urlDestroyHashMapEntry, NULL);\n  const char *ctHeader     = getFromHashMap(&http->header, \"content-type\");\n  urlParseHeaderLine(&contentType, ctHeader, ctHeader ? strlen(ctHeader) : 0);\n  if (getRefFromHashMap(&contentType, \"application/x-www-form-urlencoded\")) {\n    urlParseQueryString(&url->args, buf, len);\n  } else if (getRefFromHashMap(&contentType, \"multipart/form-data\")) {\n    const char *boundary   = getFromHashMap(&contentType, \"boundary\");\n    if (boundary && *boundary) {\n      const char *lastPart = NULL;\n      for (const char *part = buf; len > 0; ) {\n        const char *ptr;\n        if ((part == buf && (ptr = urlMemstr(part, len, \"--\")) != NULL) ||\n            (ptr = urlMemstr(part, len, \"\\r\\n--\")) != NULL) {\n          len             -= ptr - part + (part == buf ? 2 : 4);\n          part             = ptr + (part == buf ? 2 : 4);\n          if (!urlMemcmp(part, len, boundary)) {\n            int i          = strlen(boundary);\n            len           -= i;\n            part          += i;\n            if (!urlMemcmp(part, len, \"\\r\\n\")) {\n              len         -= 2;\n              part        += 2;\n              if (lastPart) {\n                urlParsePart(url, lastPart, ptr - lastPart);\n              } else {\n                if (ptr != buf) {\n                  info(\"[http] Ignoring prologue before \\\"multipart/form-data\\\"!\");\n                }\n              }\n              lastPart     = part;\n            } else if (!urlMemcmp(part, len, \"--\\r\\n\")) {\n              len         -= 4;\n              part        += 4;\n              urlParsePart(url, lastPart, ptr - lastPart);\n              lastPart     = NULL;\n              if (len > 0) {\n                info(\"[http] Ignoring epilogue past end of \\\"multipart/\"\n\t\t\t\t     \"form-data\\\"!\");\n              }\n            }\n          }\n        }\n      }\n      if (lastPart) {\n        warn(\"[http] Missing final \\\"boundary\\\" for \\\"multipart/form-data\\\"!\");\n      }\n    } else {\n      warn(\"[http] Missing \\\"boundary\\\" information for \\\"multipart/form-data\\\"!\");\n    }\n  }\n  destroyHashMap(&contentType);\n}",
        "func": "static void urlParsePostBody(struct URL *url,\n                             const struct HttpConnection *http,\n                             const char *buf, int len) {\n  struct HashMap contentType;\n  initHashMap(&contentType, urlDestroyHashMapEntry, NULL);\n  const char *ctHeader     = getFromHashMap(&http->header, \"content-type\");\n  urlParseHeaderLine(&contentType, ctHeader, ctHeader ? strlen(ctHeader) : 0);\n  if (getRefFromHashMap(&contentType, \"application/x-www-form-urlencoded\")) {\n    urlParseQueryString(&url->args, buf, len);\n  } else if (getRefFromHashMap(&contentType, \"multipart/form-data\")) {\n    const char *boundary   = getFromHashMap(&contentType, \"boundary\");\n    if (boundary && *boundary) {\n      const char *lastPart = NULL;\n      for (const char *part = buf; len > 0; ) {\n        const char *ptr;\n        if ((part == buf && (ptr = urlMemstr(part, len, \"--\")) != NULL) ||\n            (ptr = urlMemstr(part, len, \"\\r\\n--\")) != NULL) {\n          len             -= ptr - part + (part == buf ? 2 : 4);\n          part             = ptr + (part == buf ? 2 : 4);\n          if (!urlMemcmp(part, len, boundary)) {\n            int i          = strlen(boundary);\n            len           -= i;\n            part          += i;\n            if (!urlMemcmp(part, len, \"\\r\\n\")) {\n              len         -= 2;\n              part        += 2;\n              if (lastPart) {\n                urlParsePart(url, lastPart, ptr - lastPart);\n              } else {\n                if (ptr != buf) {\n                  info(\"[http] Ignoring prologue before \\\"multipart/form-data\\\"!\");\n                }\n              }\n              lastPart     = part;\n            } else if (!urlMemcmp(part, len, \"--\\r\\n\")) {\n              len         -= 4;\n              part        += 4;\n              urlParsePart(url, lastPart, ptr - lastPart);\n              lastPart     = NULL;\n              if (len > 0) {\n                info(\"[http] Ignoring epilogue past end of \\\"multipart/\"\n\t\t\t\t     \"form-data\\\"!\");\n              }\n            }\n          }\n        }\n        /* elf-2018.09.09: Detection of broken multipart/form-data\n           fixes DoS vulnerability.\n\n           On 9/9/18 10:43 AM, Imre Rad wrote:\n           Hi Markus, Marc!\n\n           I identified a vulnerability today in Shellinabox, it is\n           remote a denial of service, shellinaboxd eating up 100% cpu\n           and not processing subsequent requests after the attack was\n           mounted.\n        */\n        else {\n          warn (\"[http] Ignorning broken multipart/form-data\");\n          break;\n        }\n      }\n      if (lastPart) {\n        warn(\"[http] Missing final \\\"boundary\\\" for \\\"multipart/form-data\\\"!\");\n      }\n    } else {\n      warn(\"[http] Missing \\\"boundary\\\" information for \\\"multipart/form-data\\\"!\");\n    }\n  }\n  destroyHashMap(&contentType);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -44,6 +44,21 @@\n             }\n           }\n         }\n+        /* elf-2018.09.09: Detection of broken multipart/form-data\n+           fixes DoS vulnerability.\n+\n+           On 9/9/18 10:43 AM, Imre Rad wrote:\n+           Hi Markus, Marc!\n+\n+           I identified a vulnerability today in Shellinabox, it is\n+           remote a denial of service, shellinaboxd eating up 100% cpu\n+           and not processing subsequent requests after the attack was\n+           mounted.\n+        */\n+        else {\n+          warn (\"[http] Ignorning broken multipart/form-data\");\n+          break;\n+        }\n       }\n       if (lastPart) {\n         warn(\"[http] Missing final \\\"boundary\\\" for \\\"multipart/form-data\\\"!\");",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        /* elf-2018.09.09: Detection of broken multipart/form-data",
                "           fixes DoS vulnerability.",
                "",
                "           On 9/9/18 10:43 AM, Imre Rad wrote:",
                "           Hi Markus, Marc!",
                "",
                "           I identified a vulnerability today in Shellinabox, it is",
                "           remote a denial of service, shellinaboxd eating up 100% cpu",
                "           and not processing subsequent requests after the attack was",
                "           mounted.",
                "        */",
                "        else {",
                "          warn (\"[http] Ignorning broken multipart/form-data\");",
                "          break;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-10897",
        "func_name": "wireshark/dissect_compressed_beamforming_and_cqi",
        "description": "In Wireshark 3.0.0, the IEEE 802.11 dissector could go into an infinite loop. This was addressed in epan/dissectors/packet-ieee80211.c by detecting cases in which the bit offset does not advance.",
        "git_url": "https://github.com/wireshark/wireshark/commit/00d5e9e9fb377f52ab7696f25c1dbc011ef0244d",
        "commit_title": "IEEE 802.11: Fix an infinite loop.",
        "commit_text": " In dissect_compressed_beamforming_and_cqi, break out of a loop if our bit offset doesn't advance.  Bug: 15553",
        "func_before": "static guint\ndissect_compressed_beamforming_and_cqi(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)\n{\n  int byte_count = 0;\n  guint64 mimo_cntl = tvb_get_letoh40(tvb, offset);\n  int nc = 0, nr = 0, i;\n  int bw, grouping, codebook, feedback, bit_offset, scidx;\n  int phi_bits = 0, psi_bits = 0;\n  proto_tree *snr_tree = NULL, *feedback_tree = NULL;\n  int start_offset;\n  int ru_start_index, ru_end_index;\n\n  nc = (int)((mimo_cntl & 0x07) + 1);\n  nr = (int)(((mimo_cntl >> 3) & 0x07) + 1);\n  bw = (int)((mimo_cntl >> 6) & 0x03);\n  grouping = (int)((mimo_cntl >> 8) & 0x01);\n  codebook = (int)((mimo_cntl >> 9) & 0x01);\n  feedback = (int)((mimo_cntl >> 10) & 0x03);\n  ru_start_index = (int)((mimo_cntl >> 16) & 0x7F);\n  ru_end_index = (int)((mimo_cntl >> 23) & 0x7F);\n\n  proto_tree_add_bitmask_with_flags(tree, tvb, offset,\n    hf_ieee80211_he_mimo_control_field, ett_ff_he_mimo_control,\n    he_mimo_control_headers, ENC_LITTLE_ENDIAN,\n    BMT_NO_APPEND);\n  offset += 5;\n\n  snr_tree = proto_tree_add_subtree(tree, tvb, offset, nc,\n                ett_ff_he_mimo_beamforming_report_snr, NULL,\n                \"Average Signal to Noise Ratio\");\n\n  for (i = 0; i < nc; i++) {\n    gint8 snr = tvb_get_guint8(tvb, offset);\n\n    proto_tree_add_uint_format(snr_tree,\n        hf_ieee80211_he_compressed_beamforming_report_snr, tvb, offset, 1,\n        snr, \"Stream %d: %s%0.2fdB (0x%02x)\", i, (snr == 127 ? \">=\" :\n                                                  (snr == -128 ? \"<=\" : \"\")),\n                                             (float)((float)88 + snr)/4,\n                                             (guint8)snr);\n    offset++;\n  }\n\n  /*\n   * The rest of the data consists of the compressed beamforming matrices, one\n   * for each SCIDX per group. Each matrix consists of phi and psi angles\n   * encoded using the number of bits specified using the codebook field.\n   *\n   * The matrices contain a number entries related to Nr -1 & Nc except when\n   * Nr == Nc, and then it is Nr -1 x Nc -1, with Nr - 1 phi angles, Nc - 1\n   * psi angles, Nr - 2 phi angles, Nc - 2 psi angles ...\n   */\n  if (feedback == 0) {  /* SU */\n    if (codebook == 0) {\n      phi_bits = 2; psi_bits = 4;\n    } else {\n      phi_bits = 4; psi_bits = 6;\n    }\n  } else if (feedback == 1) { /* MU */\n    if (grouping == 1) {\n      phi_bits = 9; psi_bits = 7;\n    } else {\n      if (codebook == 0) {\n        phi_bits = 5; psi_bits = 7;\n      } else {\n        phi_bits = 7; psi_bits = 9;\n      }\n    }\n  }  /* DO something about CQI etc. */\n\n  feedback_tree = proto_tree_add_subtree(tree, tvb, offset, -1,\n                        ett_ff_he_mimo_feedback_matrices, NULL,\n                        \"Feedback Matrices\");\n\n  start_offset = offset;\n  bit_offset = offset * 8;\n  scidx = SCIDX_END_SENTINAL;\n  while ((scidx = next_he_scidx(scidx, bw, grouping, feedback,\n          ru_start_index, ru_end_index)) != (int)SCIDX_END_SENTINAL) {\n    bit_offset = dissect_he_feedback_matrix(feedback_tree, tvb, offset,\n                        bit_offset, scidx, nr, nc, phi_bits, psi_bits);\n    offset = bit_offset / 8;\n  }\n\n  offset = (bit_offset + 7) / 8;\n  proto_item_set_len(feedback_tree, offset - start_offset);\n\n  /* Sometimes the FCS is in the buffer as well ... */\n  byte_count = tvb_reported_length_remaining(tvb, offset);\n  if (byte_count > 0)\n    offset += byte_count; /* Should fix the real problem */\n\n  return offset;\n}",
        "func": "static guint\ndissect_compressed_beamforming_and_cqi(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)\n{\n  int byte_count = 0;\n  guint64 mimo_cntl = tvb_get_letoh40(tvb, offset);\n  int nc = 0, nr = 0, i;\n  int bw, grouping, codebook, feedback, bit_offset, scidx;\n  int phi_bits = 0, psi_bits = 0;\n  proto_tree *snr_tree = NULL, *feedback_tree = NULL;\n  int start_offset;\n  int ru_start_index, ru_end_index;\n\n  nc = (int)((mimo_cntl & 0x07) + 1);\n  nr = (int)(((mimo_cntl >> 3) & 0x07) + 1);\n  bw = (int)((mimo_cntl >> 6) & 0x03);\n  grouping = (int)((mimo_cntl >> 8) & 0x01);\n  codebook = (int)((mimo_cntl >> 9) & 0x01);\n  feedback = (int)((mimo_cntl >> 10) & 0x03);\n  ru_start_index = (int)((mimo_cntl >> 16) & 0x7F);\n  ru_end_index = (int)((mimo_cntl >> 23) & 0x7F);\n\n  proto_tree_add_bitmask_with_flags(tree, tvb, offset,\n    hf_ieee80211_he_mimo_control_field, ett_ff_he_mimo_control,\n    he_mimo_control_headers, ENC_LITTLE_ENDIAN,\n    BMT_NO_APPEND);\n  offset += 5;\n\n  snr_tree = proto_tree_add_subtree(tree, tvb, offset, nc,\n                ett_ff_he_mimo_beamforming_report_snr, NULL,\n                \"Average Signal to Noise Ratio\");\n\n  for (i = 0; i < nc; i++) {\n    gint8 snr = tvb_get_guint8(tvb, offset);\n\n    proto_tree_add_uint_format(snr_tree,\n        hf_ieee80211_he_compressed_beamforming_report_snr, tvb, offset, 1,\n        snr, \"Stream %d: %s%0.2fdB (0x%02x)\", i, (snr == 127 ? \">=\" :\n                                                  (snr == -128 ? \"<=\" : \"\")),\n                                             (float)((float)88 + snr)/4,\n                                             (guint8)snr);\n    offset++;\n  }\n\n  /*\n   * The rest of the data consists of the compressed beamforming matrices, one\n   * for each SCIDX per group. Each matrix consists of phi and psi angles\n   * encoded using the number of bits specified using the codebook field.\n   *\n   * The matrices contain a number entries related to Nr -1 & Nc except when\n   * Nr == Nc, and then it is Nr -1 x Nc -1, with Nr - 1 phi angles, Nc - 1\n   * psi angles, Nr - 2 phi angles, Nc - 2 psi angles ...\n   */\n  if (feedback == 0) {  /* SU */\n    if (codebook == 0) {\n      phi_bits = 2; psi_bits = 4;\n    } else {\n      phi_bits = 4; psi_bits = 6;\n    }\n  } else if (feedback == 1) { /* MU */\n    if (grouping == 1) {\n      phi_bits = 9; psi_bits = 7;\n    } else {\n      if (codebook == 0) {\n        phi_bits = 5; psi_bits = 7;\n      } else {\n        phi_bits = 7; psi_bits = 9;\n      }\n    }\n  }  /* DO something about CQI etc. */\n\n  feedback_tree = proto_tree_add_subtree(tree, tvb, offset, -1,\n                        ett_ff_he_mimo_feedback_matrices, NULL,\n                        \"Feedback Matrices\");\n\n  start_offset = offset;\n  bit_offset = offset * 8;\n  scidx = SCIDX_END_SENTINAL;\n  while ((scidx = next_he_scidx(scidx, bw, grouping, feedback,\n          ru_start_index, ru_end_index)) != (int)SCIDX_END_SENTINAL) {\n    int prev_bit_offset = bit_offset;\n    bit_offset = dissect_he_feedback_matrix(feedback_tree, tvb, offset,\n                        bit_offset, scidx, nr, nc, phi_bits, psi_bits);\n    if (bit_offset <= prev_bit_offset) {\n      expert_add_info(pinfo, tree, &ei_ieee80211_bad_length);\n      break;\n    }\n\n    offset = bit_offset / 8;\n  }\n\n  offset = (bit_offset + 7) / 8;\n  proto_item_set_len(feedback_tree, offset - start_offset);\n\n  /* Sometimes the FCS is in the buffer as well ... */\n  byte_count = tvb_reported_length_remaining(tvb, offset);\n  if (byte_count > 0)\n    offset += byte_count; /* Should fix the real problem */\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n static guint\n-dissect_compressed_beamforming_and_cqi(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)\n+dissect_compressed_beamforming_and_cqi(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)\n {\n   int byte_count = 0;\n   guint64 mimo_cntl = tvb_get_letoh40(tvb, offset);\n@@ -77,8 +77,14 @@\n   scidx = SCIDX_END_SENTINAL;\n   while ((scidx = next_he_scidx(scidx, bw, grouping, feedback,\n           ru_start_index, ru_end_index)) != (int)SCIDX_END_SENTINAL) {\n+    int prev_bit_offset = bit_offset;\n     bit_offset = dissect_he_feedback_matrix(feedback_tree, tvb, offset,\n                         bit_offset, scidx, nr, nc, phi_bits, psi_bits);\n+    if (bit_offset <= prev_bit_offset) {\n+      expert_add_info(pinfo, tree, &ei_ieee80211_bad_length);\n+      break;\n+    }\n+\n     offset = bit_offset / 8;\n   }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "dissect_compressed_beamforming_and_cqi(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo _U_, int offset)"
            ],
            "added_lines": [
                "dissect_compressed_beamforming_and_cqi(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset)",
                "    int prev_bit_offset = bit_offset;",
                "    if (bit_offset <= prev_bit_offset) {",
                "      expert_add_info(pinfo, tree, &ei_ieee80211_bad_length);",
                "      break;",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-10897",
        "func_name": "wireshark/dissect_owe_transition_mode",
        "description": "In Wireshark 3.0.0, the IEEE 802.11 dissector could go into an infinite loop. This was addressed in epan/dissectors/packet-ieee80211.c by detecting cases in which the bit offset does not advance.",
        "git_url": "https://github.com/wireshark/wireshark/commit/00d5e9e9fb377f52ab7696f25c1dbc011ef0244d",
        "commit_title": "IEEE 802.11: Fix an infinite loop.",
        "commit_text": " In dissect_compressed_beamforming_and_cqi, break out of a loop if our bit offset doesn't advance.  Bug: 15553",
        "func_before": "static int\ndissect_owe_transition_mode(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\n{\n  guint8 ssid_len;\n\n  int len = tvb_captured_length(tvb);\n  int offset = 0;\n\n  proto_tree_add_item(tree, hf_ieee80211_wfa_ie_owe_bssid, tvb, offset, 6, ENC_NA);\n  offset  += 6;\n  len -= 6;\n\n  ssid_len = tvb_get_guint8(tvb, offset);\n\n  proto_tree_add_uint(tree, hf_ieee80211_wfa_ie_owe_ssid_length, tvb, offset, 1, ssid_len);\n  offset  += 1;\n  len -= 1;\n\n  if (len < ssid_len) {\n    expert_add_info(pinfo, tree, &ei_ieee80211_bad_length);\n    return offset;\n  }\n\n  proto_tree_add_item(tree, hf_ieee80211_wfa_ie_owe_ssid, tvb, offset, ssid_len, ENC_ASCII|ENC_NA);\n  offset  += len;\n  len -= len;\n\n  if (len >= 2) {\n    proto_tree_add_item(tree, hf_ieee80211_wfa_ie_owe_band_info, tvb, offset, 1, ENC_NA);\n    offset  += 1;\n\n    proto_tree_add_item(tree, hf_ieee80211_wfa_ie_owe_channel_info, tvb, offset, 1, ENC_NA);\n    offset  += 1;\n  }\n\n  return offset;\n}",
        "func": "static int\ndissect_owe_transition_mode(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n{\n  guint8 ssid_len;\n\n  int len = tvb_captured_length(tvb);\n  int offset = 0;\n\n  proto_tree_add_item(tree, hf_ieee80211_wfa_ie_owe_bssid, tvb, offset, 6, ENC_NA);\n  offset  += 6;\n  len -= 6;\n\n  ssid_len = tvb_get_guint8(tvb, offset);\n\n  proto_tree_add_uint(tree, hf_ieee80211_wfa_ie_owe_ssid_length, tvb, offset, 1, ssid_len);\n  offset  += 1;\n  len -= 1;\n\n  if (len < ssid_len) {\n    expert_add_info(pinfo, tree, &ei_ieee80211_bad_length);\n    return offset;\n  }\n\n  proto_tree_add_item(tree, hf_ieee80211_wfa_ie_owe_ssid, tvb, offset, ssid_len, ENC_ASCII|ENC_NA);\n  offset  += len;\n  len -= len;\n\n  if (len >= 2) {\n    proto_tree_add_item(tree, hf_ieee80211_wfa_ie_owe_band_info, tvb, offset, 1, ENC_NA);\n    offset  += 1;\n\n    proto_tree_add_item(tree, hf_ieee80211_wfa_ie_owe_channel_info, tvb, offset, 1, ENC_NA);\n    offset  += 1;\n  }\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n static int\n-dissect_owe_transition_mode(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)\n+dissect_owe_transition_mode(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n {\n   guint8 ssid_len;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "dissect_owe_transition_mode(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void* data _U_)"
            ],
            "added_lines": [
                "dissect_owe_transition_mode(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-10898",
        "func_name": "wireshark/dissect_gsup_tlvs",
        "description": "In Wireshark 3.0.0, the GSUP dissector could go into an infinite loop. This was addressed in epan/dissectors/packet-gsm_gsup.c by rejecting an invalid Information Element length.",
        "git_url": "https://github.com/wireshark/wireshark/commit/f80b7d1b279fb6c13f640019a1bbc42b18bf7469",
        "commit_title": "gsm_gsup: check the current len against the caller length.",
        "commit_text": " When the former is greater than the latter, we have a malformed packet. Add an expert info and stop the dissection.  Bug: 15585 (cherry picked from commit 5d9d7893d6723b4545d4c2c765002e4830493dc6)",
        "func_before": "static gint\ndissect_gsup_tlvs(tvbuff_t *tvb, int base_offs, int length, packet_info *pinfo, proto_tree *tree,\n\t\t  proto_item *gsup_ti, guint8 msg_type)\n{\n\tint offset = base_offs;\n\n\twhile (offset - base_offs < length) {\n\t\tguint8 tag;\n\t\tunsigned int len;\n\t\tproto_item *ti;\n\t\tproto_tree *att_tree;\n\t\tconst guchar *apn;\n\t\tconst gchar *str;\n\t\tguint apn_len;\n\n\t\ttag = tvb_get_guint8(tvb, offset);\n\t\toffset++;\n\n\t\tlen = tvb_get_guint8(tvb, offset);\n\t\toffset++;\n\n\t\tatt_tree = proto_tree_add_subtree_format(tree, tvb, offset-2, len+2, ett_gsup_ie, &ti,\n\t\t\t\t\t\t\"IE: %s\",\n\t\t\t\t\t\tval_to_str(tag, gsup_iei_types, \"Unknown 0x%02x\"));\n\t\tproto_tree_add_item(att_tree, hf_gsup_iei, tvb, offset-2, 1, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_uint(att_tree, hf_gsup_ie_len, tvb, offset-1, 1, len);\n\n\t\tswitch (tag) {\n\t\t/* Nested TLVs */\n\t\tcase OSMO_GSUP_AUTH_TUPLE_IE:\n\t\tcase OSMO_GSUP_PDP_INFO_IE:\n\t\t\tdissect_gsup_tlvs(tvb, offset, len, pinfo, att_tree, gsup_ti, msg_type);\n\t\t\tbreak;\n\t\t/* Normal IEs */\n\t\tcase OSMO_GSUP_RAND_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_rand, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_SRES_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_sres, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_KC_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_kc, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_IK_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_ik, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_CK_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_ck, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_AUTN_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_autn, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_AUTS_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_auts, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_RES_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_res, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_CN_DOMAIN_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_cn_domain, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_CANCEL_TYPE_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_cancel_type, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_IMSI_IE:\n\t\t\tstr = dissect_e212_imsi(tvb, pinfo, att_tree, offset, len, FALSE);\n\t\t\tproto_item_append_text(ti, \", %s\", str);\n\t\t\tproto_item_append_text(gsup_ti, \", IMSI: %s\", str);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_MSISDN_IE:\n\t\t\tstr = dissect_e164_msisdn(tvb, att_tree, offset+1, len-1, E164_ENC_BCD);\n\t\t\tproto_item_append_text(ti, \", %s\", str);\n\t\t\tproto_item_append_text(gsup_ti, \", MSISDN: %s\", str);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_ACCESS_POINT_NAME_IE:\n\t\t\tif (len == 1) {\n\t\t\t\tguint8 ch = tvb_get_guint8(tvb, offset);\n\t\t\t\tproto_tree_add_item(att_tree, hf_gsup_ie_payload, tvb, offset, len, ENC_NA);\n\t\t\t\tif (ch == '*')\n\t\t\t\t\tproto_item_append_text(ti, \", '*' (Wildcard)\");\n\t\t\t} else {\n\t\t\t\tget_dns_name(tvb, offset, len, 0, &apn, &apn_len);\n\t\t\t\tproto_tree_add_string(att_tree, hf_gsup_apn, tvb, offset, len, apn);\n\t\t\t\tproto_item_append_text(ti, \", %s\", apn);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_PDP_CONTEXT_ID_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_pdp_context_id, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_CHARG_CHAR_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_charg_char, tvb, offset, len, ENC_ASCII|ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_CAUSE_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_cause, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\t/* boolean flags: either they're present or not */\n\t\tcase OSMO_GSUP_PDP_INFO_COMPL_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_pdp_info_compl, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_FREEZE_PTMSI_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_freeze_ptmsi, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_SESSION_ID_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_session_id, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_SESSION_STATE_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_session_state, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_SS_INFO_IE:\n\t\t\tdissect_ss_info_ie(tvb, pinfo, offset, len, att_tree);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_SM_RP_MR_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_sm_rp_mr, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_SM_RP_DA_IE:\n\t\t\tdissect_sm_rp_da_ie(tvb, pinfo, offset, len, att_tree);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_SM_RP_OA_IE:\n\t\t\tdissect_sm_rp_oa_ie(tvb, pinfo, offset, len, att_tree);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_SM_RP_UI_IE:\n\t\t\tdissect_sm_rp_ui_ie(tvb, pinfo, offset, len, att_tree, msg_type);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_SM_RP_CAUSE_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_sm_rp_cause, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_SM_RP_MMS_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_sm_rp_mms, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_SM_ALERT_RSN_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_sm_alert_rsn, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_IMEI_IE:\n\t\t\tdissect_imei_ie(tvb, pinfo, offset, len, att_tree);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_IMEI_RESULT_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_imei_result, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_HLR_NUMBER_IE:\n\t\tcase OSMO_GSUP_PDP_TYPE_IE:\n\t\tcase OSMO_GSUP_PDP_QOS_IE:\n\t\tdefault:\n\t\t\t/* Unknown/unsupported IE: Print raw payload in addition to IEI + Length printed above */\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_ie_payload, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\t}\n\n\t\toffset += len;\n\t}\n\n\treturn offset;\n}",
        "func": "static gint\ndissect_gsup_tlvs(tvbuff_t *tvb, int base_offs, int length, packet_info *pinfo, proto_tree *tree,\n\t\t  proto_item *gsup_ti, guint8 msg_type)\n{\n\tint offset = base_offs;\n\n\twhile (offset - base_offs < length) {\n\t\tguint8 tag;\n\t\tguint8 len;\n\t\tproto_item *ti;\n\t\tproto_tree *att_tree;\n\t\tconst guchar *apn;\n\t\tconst gchar *str;\n\t\tguint apn_len;\n\n\t\ttag = tvb_get_guint8(tvb, offset);\n\t\toffset++;\n\n\t\tlen = tvb_get_guint8(tvb, offset);\n\t\toffset++;\n\n\t\tif (offset - base_offs + len > length) {\n\t\t\texpert_add_info(pinfo, gsup_ti, &ei_gsup_ie_len_invalid);\n\t\t\treturn offset - 2;\n\t\t}\n\n\t\tatt_tree = proto_tree_add_subtree_format(tree, tvb, offset-2, len+2, ett_gsup_ie, &ti,\n\t\t\t\t\t\t\"IE: %s\",\n\t\t\t\t\t\tval_to_str(tag, gsup_iei_types, \"Unknown 0x%02x\"));\n\t\tproto_tree_add_item(att_tree, hf_gsup_iei, tvb, offset-2, 1, ENC_BIG_ENDIAN);\n\t\tproto_tree_add_uint(att_tree, hf_gsup_ie_len, tvb, offset-1, 1, len);\n\n\t\tswitch (tag) {\n\t\t/* Nested TLVs */\n\t\tcase OSMO_GSUP_AUTH_TUPLE_IE:\n\t\tcase OSMO_GSUP_PDP_INFO_IE:\n\t\t\tdissect_gsup_tlvs(tvb, offset, len, pinfo, att_tree, gsup_ti, msg_type);\n\t\t\tbreak;\n\t\t/* Normal IEs */\n\t\tcase OSMO_GSUP_RAND_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_rand, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_SRES_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_sres, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_KC_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_kc, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_IK_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_ik, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_CK_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_ck, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_AUTN_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_autn, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_AUTS_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_auts, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_RES_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_res, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_CN_DOMAIN_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_cn_domain, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_CANCEL_TYPE_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_cancel_type, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_IMSI_IE:\n\t\t\tstr = dissect_e212_imsi(tvb, pinfo, att_tree, offset, len, FALSE);\n\t\t\tproto_item_append_text(ti, \", %s\", str);\n\t\t\tproto_item_append_text(gsup_ti, \", IMSI: %s\", str);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_MSISDN_IE:\n\t\t\tstr = dissect_e164_msisdn(tvb, att_tree, offset+1, len-1, E164_ENC_BCD);\n\t\t\tproto_item_append_text(ti, \", %s\", str);\n\t\t\tproto_item_append_text(gsup_ti, \", MSISDN: %s\", str);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_ACCESS_POINT_NAME_IE:\n\t\t\tif (len == 1) {\n\t\t\t\tguint8 ch = tvb_get_guint8(tvb, offset);\n\t\t\t\tproto_tree_add_item(att_tree, hf_gsup_ie_payload, tvb, offset, len, ENC_NA);\n\t\t\t\tif (ch == '*')\n\t\t\t\t\tproto_item_append_text(ti, \", '*' (Wildcard)\");\n\t\t\t} else {\n\t\t\t\tget_dns_name(tvb, offset, len, 0, &apn, &apn_len);\n\t\t\t\tproto_tree_add_string(att_tree, hf_gsup_apn, tvb, offset, len, apn);\n\t\t\t\tproto_item_append_text(ti, \", %s\", apn);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_PDP_CONTEXT_ID_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_pdp_context_id, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_CHARG_CHAR_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_charg_char, tvb, offset, len, ENC_ASCII|ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_CAUSE_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_cause, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\t/* boolean flags: either they're present or not */\n\t\tcase OSMO_GSUP_PDP_INFO_COMPL_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_pdp_info_compl, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_FREEZE_PTMSI_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_freeze_ptmsi, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_SESSION_ID_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_session_id, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_SESSION_STATE_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_session_state, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_SS_INFO_IE:\n\t\t\tdissect_ss_info_ie(tvb, pinfo, offset, len, att_tree);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_SM_RP_MR_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_sm_rp_mr, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_SM_RP_DA_IE:\n\t\t\tdissect_sm_rp_da_ie(tvb, pinfo, offset, len, att_tree);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_SM_RP_OA_IE:\n\t\t\tdissect_sm_rp_oa_ie(tvb, pinfo, offset, len, att_tree);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_SM_RP_UI_IE:\n\t\t\tdissect_sm_rp_ui_ie(tvb, pinfo, offset, len, att_tree, msg_type);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_SM_RP_CAUSE_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_sm_rp_cause, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_SM_RP_MMS_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_sm_rp_mms, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_SM_ALERT_RSN_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_sm_alert_rsn, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_IMEI_IE:\n\t\t\tdissect_imei_ie(tvb, pinfo, offset, len, att_tree);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_IMEI_RESULT_IE:\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_imei_result, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\tcase OSMO_GSUP_HLR_NUMBER_IE:\n\t\tcase OSMO_GSUP_PDP_TYPE_IE:\n\t\tcase OSMO_GSUP_PDP_QOS_IE:\n\t\tdefault:\n\t\t\t/* Unknown/unsupported IE: Print raw payload in addition to IEI + Length printed above */\n\t\t\tproto_tree_add_item(att_tree, hf_gsup_ie_payload, tvb, offset, len, ENC_NA);\n\t\t\tbreak;\n\t\t}\n\n\t\toffset += len;\n\t}\n\n\treturn offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n \n \twhile (offset - base_offs < length) {\n \t\tguint8 tag;\n-\t\tunsigned int len;\n+\t\tguint8 len;\n \t\tproto_item *ti;\n \t\tproto_tree *att_tree;\n \t\tconst guchar *apn;\n@@ -18,6 +18,11 @@\n \n \t\tlen = tvb_get_guint8(tvb, offset);\n \t\toffset++;\n+\n+\t\tif (offset - base_offs + len > length) {\n+\t\t\texpert_add_info(pinfo, gsup_ti, &ei_gsup_ie_len_invalid);\n+\t\t\treturn offset - 2;\n+\t\t}\n \n \t\tatt_tree = proto_tree_add_subtree_format(tree, tvb, offset-2, len+2, ett_gsup_ie, &ti,\n \t\t\t\t\t\t\"IE: %s\",",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tunsigned int len;"
            ],
            "added_lines": [
                "\t\tguint8 len;",
                "",
                "\t\tif (offset - base_offs + len > length) {",
                "\t\t\texpert_add_info(pinfo, gsup_ti, &ei_gsup_ie_len_invalid);",
                "\t\t\treturn offset - 2;",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-10898",
        "func_name": "wireshark/proto_register_gsup",
        "description": "In Wireshark 3.0.0, the GSUP dissector could go into an infinite loop. This was addressed in epan/dissectors/packet-gsm_gsup.c by rejecting an invalid Information Element length.",
        "git_url": "https://github.com/wireshark/wireshark/commit/f80b7d1b279fb6c13f640019a1bbc42b18bf7469",
        "commit_title": "gsm_gsup: check the current len against the caller length.",
        "commit_text": " When the former is greater than the latter, we have a malformed packet. Add an expert info and stop the dissection.  Bug: 15585 (cherry picked from commit 5d9d7893d6723b4545d4c2c765002e4830493dc6)",
        "func_before": "void\nproto_register_gsup(void)\n{\n\tstatic hf_register_info hf[] = {\n\t\t{ &hf_gsup_msg_type, { \"Message Type\", \"gsup.msg_type\",\n\t\t  FT_UINT8, BASE_DEC, VALS(gsup_msg_types), 0, NULL, HFILL } },\n\t\t{ &hf_gsup_iei, { \"Information Element Identifier\", \"gsup.ie.iei\",\n\t\t  FT_UINT8, BASE_DEC, VALS(gsup_iei_types), 0, NULL, HFILL } },\n\t\t{ &hf_gsup_ie_len, { \"Information Element Length\", \"gsup.ie.len\",\n\t\t  FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL } },\n\t\t{ &hf_gsup_ie_payload, { \"Information Element Payload\", \"gsup.ie.payload\",\n\t\t  FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } },\n\n\t\t{ &hf_gsup_rand, { \"RAND\", \"gsup.rand\",\n\t\t  FT_BYTES, BASE_NONE, NULL, 0, \"Random Challenge\", HFILL } },\n\t\t{ &hf_gsup_sres, { \"SRES\", \"gsup.sres\",\n\t\t  FT_BYTES, BASE_NONE, NULL, 0, \"GSM/GPRS Authentication Result SRES Value\", HFILL } },\n\t\t{ &hf_gsup_kc, { \"Kc\", \"gsup.kc\",\n\t\t  FT_BYTES, BASE_NONE, NULL, 0, \"GSM/GPRS Ciphering Key\", HFILL } },\n\t\t{ &hf_gsup_ik, { \"IK\", \"gsup.ik\",\n\t\t  FT_BYTES, BASE_NONE, NULL, 0, \"UMTS Integrity Protection Key\", HFILL } },\n\t\t{ &hf_gsup_ck, { \"CK\", \"gsup.ck\",\n\t\t  FT_BYTES, BASE_NONE, NULL, 0, \"UMTS Ciphering Key\", HFILL } },\n\t\t{ &hf_gsup_autn, { \"AUTN\", \"gsup.autn\",\n\t\t  FT_BYTES, BASE_NONE, NULL, 0, \"UMTS Authentication Nonce\", HFILL } },\n\t\t{ &hf_gsup_auts, { \"AUTN\", \"gsup.auts\",\n\t\t  FT_BYTES, BASE_NONE, NULL, 0, \"UMTS Authentication Sync\", HFILL } },\n\t\t{ &hf_gsup_res, { \"RES\", \"gsup.res\",\n\t\t  FT_BYTES, BASE_NONE, NULL, 0, \"UMTS Authentication Result\", HFILL } },\n\n\t\t{ &hf_gsup_cn_domain, { \"CN Domain Indicator\", \"gsup.cn_domain\",\n\t\t  FT_UINT8, BASE_DEC, VALS(gsup_cndomain_types), 0, NULL, HFILL } },\n\t\t{ &hf_gsup_cancel_type, { \"Cancel Type\", \"gsup.cancel_type\",\n\t\t  FT_UINT8, BASE_DEC, VALS(gsup_cancel_types), 0, NULL, HFILL } },\n\t\t{ &hf_gsup_pdp_info_compl, { \"PDP Information Complete\", \"gsup.pdp_info_compl\",\n\t\t  FT_BOOLEAN, BASE_NONE, NULL, 0, NULL, HFILL } },\n\t\t{ &hf_gsup_freeze_ptmsi, { \"Freeze P-TMSI\", \"gsup.freeze_ptmsi\",\n\t\t  FT_BOOLEAN, BASE_NONE, NULL, 0, NULL, HFILL } },\n\t\t{ &hf_gsup_apn, { \"APN\", \"gsup.apn\",\n\t\t  FT_STRING, BASE_NONE, NULL, 0, \"Access Point Name\", HFILL } },\n\t\t{ &hf_gsup_pdp_context_id, { \"PDP Context ID\", \"gsup.pdp_context_id\",\n\t\t  FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL } },\n\t\t{ &hf_gsup_charg_char, { \"Charging Character\", \"gsup.charg_char\",\n\t\t  FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } },\n\t\t{ &hf_gsup_cause, { \"Cause\", \"gsup.cause\",\n\t\t  FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL } },\n\t\t{ &hf_gsup_session_id, { \"Session ID\", \"gsup.session_id\",\n\t\t  FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL } },\n\t\t{ &hf_gsup_session_state, { \"Session State\", \"gsup.session_state\",\n\t\t  FT_UINT8, BASE_DEC, VALS(gsup_session_states), 0, NULL, HFILL } },\n\t\t{ &hf_gsup_sm_rp_mr, { \"SM-RP-MR (Message Reference)\", \"gsup.sm_rp_mr\",\n\t\t  FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL } },\n\t\t{ &hf_gsup_sm_rp_da_id_type, { \"Address Type\", \"gsup.sm_rp_da.addr_type\",\n\t\t  FT_UINT8, BASE_DEC, VALS(osmo_gsup_sms_sm_rp_oda_types), 0, NULL, HFILL } },\n\t\t{ &hf_gsup_sm_rp_oa_id_type, { \"Address Type\", \"gsup.sm_rp_oa.addr_type\",\n\t\t  FT_UINT8, BASE_DEC, VALS(osmo_gsup_sms_sm_rp_oda_types), 0, NULL, HFILL } },\n\t\t{ &hf_gsup_sm_rp_cause, { \"SM-RP Cause\", \"gsup.sm_rp.cause\",\n\t\t  FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL } },\n\t\t{ &hf_gsup_sm_rp_mms, { \"More Messages to Send\", \"gsup.sm_rp.mms\",\n\t\t  FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL } },\n\t\t{ &hf_gsup_sm_alert_rsn, { \"SM Alert Reason\", \"gsup.sm_alert_rsn\",\n\t\t  FT_UINT8, BASE_DEC, VALS(osmo_gsup_sms_sm_alert_rsn_types), 0, NULL, HFILL } },\n\t\t{ &hf_gsup_imei_result, { \"IMEI Check Result\", \"gsup.imei_check_res\",\n\t\t  FT_UINT8, BASE_DEC, VALS(gsup_imei_result_types), 0, NULL, HFILL } },\n\t};\n\tstatic gint *ett[] = {\n\t\t&ett_gsup,\n\t\t&ett_gsup_ie,\n\t};\n\n\texpert_module_t *expert_gsup;\n\n\tstatic ei_register_info ei[] = {\n\t\t{ &ei_sm_rp_da_invalid,\n\t\t  { \"gsup.sm_rp_da.invalid\", PI_PROTOCOL, PI_ERROR,\n\t\t    \"Malformed SM-RP-DA IE\", EXPFILL } },\n\t\t{ &ei_sm_rp_oa_invalid,\n\t\t  { \"gsup.sm_rp_oa.invalid\", PI_PROTOCOL, PI_ERROR,\n\t\t    \"Malformed SM-RP-OA IE\", EXPFILL } },\n\t};\n\n\tproto_gsup = proto_register_protocol(\"Osmocom General Subscriber Update Protocol\", \"gsup\", \"gsup\");\n\tproto_register_field_array(proto_gsup, hf, array_length(hf));\n\tproto_register_subtree_array(ett, array_length(ett));\n\n\texpert_gsup = expert_register_protocol(proto_gsup);\n\texpert_register_field_array(expert_gsup, ei, array_length(ei));\n}",
        "func": "void\nproto_register_gsup(void)\n{\n\tstatic hf_register_info hf[] = {\n\t\t{ &hf_gsup_msg_type, { \"Message Type\", \"gsup.msg_type\",\n\t\t  FT_UINT8, BASE_DEC, VALS(gsup_msg_types), 0, NULL, HFILL } },\n\t\t{ &hf_gsup_iei, { \"Information Element Identifier\", \"gsup.ie.iei\",\n\t\t  FT_UINT8, BASE_DEC, VALS(gsup_iei_types), 0, NULL, HFILL } },\n\t\t{ &hf_gsup_ie_len, { \"Information Element Length\", \"gsup.ie.len\",\n\t\t  FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL } },\n\t\t{ &hf_gsup_ie_payload, { \"Information Element Payload\", \"gsup.ie.payload\",\n\t\t  FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } },\n\n\t\t{ &hf_gsup_rand, { \"RAND\", \"gsup.rand\",\n\t\t  FT_BYTES, BASE_NONE, NULL, 0, \"Random Challenge\", HFILL } },\n\t\t{ &hf_gsup_sres, { \"SRES\", \"gsup.sres\",\n\t\t  FT_BYTES, BASE_NONE, NULL, 0, \"GSM/GPRS Authentication Result SRES Value\", HFILL } },\n\t\t{ &hf_gsup_kc, { \"Kc\", \"gsup.kc\",\n\t\t  FT_BYTES, BASE_NONE, NULL, 0, \"GSM/GPRS Ciphering Key\", HFILL } },\n\t\t{ &hf_gsup_ik, { \"IK\", \"gsup.ik\",\n\t\t  FT_BYTES, BASE_NONE, NULL, 0, \"UMTS Integrity Protection Key\", HFILL } },\n\t\t{ &hf_gsup_ck, { \"CK\", \"gsup.ck\",\n\t\t  FT_BYTES, BASE_NONE, NULL, 0, \"UMTS Ciphering Key\", HFILL } },\n\t\t{ &hf_gsup_autn, { \"AUTN\", \"gsup.autn\",\n\t\t  FT_BYTES, BASE_NONE, NULL, 0, \"UMTS Authentication Nonce\", HFILL } },\n\t\t{ &hf_gsup_auts, { \"AUTN\", \"gsup.auts\",\n\t\t  FT_BYTES, BASE_NONE, NULL, 0, \"UMTS Authentication Sync\", HFILL } },\n\t\t{ &hf_gsup_res, { \"RES\", \"gsup.res\",\n\t\t  FT_BYTES, BASE_NONE, NULL, 0, \"UMTS Authentication Result\", HFILL } },\n\n\t\t{ &hf_gsup_cn_domain, { \"CN Domain Indicator\", \"gsup.cn_domain\",\n\t\t  FT_UINT8, BASE_DEC, VALS(gsup_cndomain_types), 0, NULL, HFILL } },\n\t\t{ &hf_gsup_cancel_type, { \"Cancel Type\", \"gsup.cancel_type\",\n\t\t  FT_UINT8, BASE_DEC, VALS(gsup_cancel_types), 0, NULL, HFILL } },\n\t\t{ &hf_gsup_pdp_info_compl, { \"PDP Information Complete\", \"gsup.pdp_info_compl\",\n\t\t  FT_BOOLEAN, BASE_NONE, NULL, 0, NULL, HFILL } },\n\t\t{ &hf_gsup_freeze_ptmsi, { \"Freeze P-TMSI\", \"gsup.freeze_ptmsi\",\n\t\t  FT_BOOLEAN, BASE_NONE, NULL, 0, NULL, HFILL } },\n\t\t{ &hf_gsup_apn, { \"APN\", \"gsup.apn\",\n\t\t  FT_STRING, BASE_NONE, NULL, 0, \"Access Point Name\", HFILL } },\n\t\t{ &hf_gsup_pdp_context_id, { \"PDP Context ID\", \"gsup.pdp_context_id\",\n\t\t  FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL } },\n\t\t{ &hf_gsup_charg_char, { \"Charging Character\", \"gsup.charg_char\",\n\t\t  FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } },\n\t\t{ &hf_gsup_cause, { \"Cause\", \"gsup.cause\",\n\t\t  FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL } },\n\t\t{ &hf_gsup_session_id, { \"Session ID\", \"gsup.session_id\",\n\t\t  FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL } },\n\t\t{ &hf_gsup_session_state, { \"Session State\", \"gsup.session_state\",\n\t\t  FT_UINT8, BASE_DEC, VALS(gsup_session_states), 0, NULL, HFILL } },\n\t\t{ &hf_gsup_sm_rp_mr, { \"SM-RP-MR (Message Reference)\", \"gsup.sm_rp_mr\",\n\t\t  FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL } },\n\t\t{ &hf_gsup_sm_rp_da_id_type, { \"Address Type\", \"gsup.sm_rp_da.addr_type\",\n\t\t  FT_UINT8, BASE_DEC, VALS(osmo_gsup_sms_sm_rp_oda_types), 0, NULL, HFILL } },\n\t\t{ &hf_gsup_sm_rp_oa_id_type, { \"Address Type\", \"gsup.sm_rp_oa.addr_type\",\n\t\t  FT_UINT8, BASE_DEC, VALS(osmo_gsup_sms_sm_rp_oda_types), 0, NULL, HFILL } },\n\t\t{ &hf_gsup_sm_rp_cause, { \"SM-RP Cause\", \"gsup.sm_rp.cause\",\n\t\t  FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL } },\n\t\t{ &hf_gsup_sm_rp_mms, { \"More Messages to Send\", \"gsup.sm_rp.mms\",\n\t\t  FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL } },\n\t\t{ &hf_gsup_sm_alert_rsn, { \"SM Alert Reason\", \"gsup.sm_alert_rsn\",\n\t\t  FT_UINT8, BASE_DEC, VALS(osmo_gsup_sms_sm_alert_rsn_types), 0, NULL, HFILL } },\n\t\t{ &hf_gsup_imei_result, { \"IMEI Check Result\", \"gsup.imei_check_res\",\n\t\t  FT_UINT8, BASE_DEC, VALS(gsup_imei_result_types), 0, NULL, HFILL } },\n\t};\n\tstatic gint *ett[] = {\n\t\t&ett_gsup,\n\t\t&ett_gsup_ie,\n\t};\n\n\texpert_module_t *expert_gsup;\n\n\tstatic ei_register_info ei[] = {\n\t\t{ &ei_sm_rp_da_invalid,\n\t\t  { \"gsup.sm_rp_da.invalid\", PI_PROTOCOL, PI_ERROR,\n\t\t    \"Malformed SM-RP-DA IE\", EXPFILL } },\n\t\t{ &ei_sm_rp_oa_invalid,\n\t\t  { \"gsup.sm_rp_oa.invalid\", PI_PROTOCOL, PI_ERROR,\n\t\t    \"Malformed SM-RP-OA IE\", EXPFILL } },\n\t\t{ &ei_gsup_ie_len_invalid,\n\t\t  { \"gsup.ie.len.invalid\", PI_PROTOCOL, PI_MALFORMED,\n\t\t    \"Invalid Information Element Length\", EXPFILL } },\n\t};\n\n\tproto_gsup = proto_register_protocol(\"Osmocom General Subscriber Update Protocol\", \"gsup\", \"gsup\");\n\tproto_register_field_array(proto_gsup, hf, array_length(hf));\n\tproto_register_subtree_array(ett, array_length(ett));\n\n\texpert_gsup = expert_register_protocol(proto_gsup);\n\texpert_register_field_array(expert_gsup, ei, array_length(ei));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -77,6 +77,9 @@\n \t\t{ &ei_sm_rp_oa_invalid,\n \t\t  { \"gsup.sm_rp_oa.invalid\", PI_PROTOCOL, PI_ERROR,\n \t\t    \"Malformed SM-RP-OA IE\", EXPFILL } },\n+\t\t{ &ei_gsup_ie_len_invalid,\n+\t\t  { \"gsup.ie.len.invalid\", PI_PROTOCOL, PI_MALFORMED,\n+\t\t    \"Invalid Information Element Length\", EXPFILL } },\n \t};\n \n \tproto_gsup = proto_register_protocol(\"Osmocom General Subscriber Update Protocol\", \"gsup\", \"gsup\");",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t{ &ei_gsup_ie_len_invalid,",
                "\t\t  { \"gsup.ie.len.invalid\", PI_PROTOCOL, PI_MALFORMED,",
                "\t\t    \"Invalid Information Element Length\", EXPFILL } },"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-10900",
        "func_name": "wireshark/dissect_rbm_object",
        "description": "In Wireshark 3.0.0, the Rbm dissector could go into an infinite loop. This was addressed in epan/dissectors/file-rbm.c by handling unknown object types safely.",
        "git_url": "https://github.com/wireshark/wireshark/commit/26eee01f57f0a86fb375892c7937eac24ede4610",
        "commit_title": "Rbm: Be more strict about unknown object types.",
        "commit_text": " Stop dissection if we encounter an unknown object type.  Update .editorconfig while we're here.  Bug: 15612 (cherry picked from commit f273ecd5d94f0c39d1683ed147656daee3ef799b)",
        "func_before": "static void dissect_rbm_object(tvbuff_t* tvb, packet_info* pinfo, proto_tree* ptree, gint* offset, gchar** type, gchar** value)\n{\n\tguint8 subtype = tvb_get_guint8(tvb, *offset);\n\tproto_tree* tree;\n\tgchar* type_local = NULL;\n\tgchar* value_local = NULL;\n\tgint offset_start = *offset;\n\n\ttree = proto_tree_add_subtree(ptree, tvb, *offset, 0, ett_variable, NULL, \"\");\n\n\tproto_tree_add_item(tree, hf_rbm_type, tvb, *offset, 1, ENC_NA);\n\t*offset += 1;\n\n\tswitch (subtype) {\n\t\tcase '0':\n\t\tcase 'T':\n\t\tcase 'F':\n\t\t\tdissect_rbm_basic(tvb, pinfo, tree, offset, subtype, &type_local, &value_local);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\ttype_local = \"Integer\";\n\t\t\tdissect_rbm_integer(tvb, pinfo, tree, offset, &value_local);\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\ttype_local = \"Symbol\";\n\t\t\tdissect_rbm_symbol(tvb, pinfo, tree, offset, &value_local);\n\t\t\tbreak;\n\t\tcase '\"':\n\t\t\ttype_local = \"String\";\n\t\t\tdissect_rbm_string(tvb, pinfo, tree, offset, &value_local);\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\ttype_local = \"Instance Variable\";\n\t\t\tdissect_rbm_variable(tvb, pinfo, tree, offset, &value_local);\n\t\t\tbreak;\n\t\tcase '[':\n\t\t\ttype_local = \"Array\";\n\t\t\tdissect_rbm_array(tvb, pinfo, tree, offset, &value_local);\n\t\t\tbreak;\n\t\tcase '{':\n\t\t\ttype_local = \"Hash\";\n\t\t\tdissect_rbm_hash(tvb, pinfo, tree, offset, &value_local);\n\t\t\tbreak;\n\t\tcase ';':\n\t\tcase '@':\n\t\t\tdissect_rbm_link(tvb, pinfo, tree, offset, subtype, &type_local, &value_local);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\ttype_local = \"Double\";\n\t\t\tdissect_rbm_double(tvb, pinfo, tree, offset, &value_local);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\ttype_local = \"Class\";\n\t\t\tdissect_rbm_class(tvb, pinfo, tree, offset, &value_local);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\ttype_local = \"Module\";\n\t\t\tdissect_rbm_module(tvb, pinfo, tree, offset, &value_local);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\ttype_local = \"Struct\";\n\t\t\tdissect_rbm_struct(tvb, pinfo, tree, offset, &value_local);\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\ttype_local = \"Regex\";\n\t\t\tdissect_rbm_regex(tvb, pinfo, tree, offset, &value_local);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\ttype_local = \"DRb::DRbObject\";\n\t\t\tdissect_rbm_drb(tvb, pinfo, tree, offset);\n\t\t\tbreak;\n\t\tcase ',':\n\t\t\tdissect_rbm_inline(tvb, pinfo, tree, offset, &type_local, &value_local);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tdissect_rbm_rubyobject(tvb, pinfo, tree, offset);\n\t\t\ttype_local = \"Ruby Object\";\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\ttype_local = \"UserClass\";\n\t\t\tdissect_rbm_userclass(tvb, pinfo, tree, offset, &value_local);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\ttype_local = \"Extended Object\";\n\t\t\tdissect_rbm_extended(tvb, pinfo, tree, offset);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texpert_add_info_format(pinfo, tree, &ei_rbm_invalid,\n\t\t\t\t\"Object type 0x%x is invalid\", subtype);\n\t}\n\n\tproto_item_set_len(tree, *offset - offset_start);\n\n\tproto_item_append_text(tree, \"Type: %s\", type_local);\n\tif (value_local && strlen(value_local))\n\t\tproto_item_append_text(tree, \", Value: %s\", value_local);\n\n\tif (type)\n\t\t*type = type_local;\n\tif (value)\n\t\t*value = value_local;\n}",
        "func": "static void dissect_rbm_object(tvbuff_t* tvb, packet_info* pinfo, proto_tree* ptree, gint* offset, gchar** type, gchar** value)\n{\n\tguint8 subtype = tvb_get_guint8(tvb, *offset);\n\tproto_tree* tree;\n\tgchar* type_local = \"Unknown\";\n\tgchar* value_local = \"Unknown\";\n\tgint offset_start = *offset;\n\n\ttree = proto_tree_add_subtree(ptree, tvb, *offset, 0, ett_variable, NULL, \"\");\n\n\tproto_tree_add_item(tree, hf_rbm_type, tvb, *offset, 1, ENC_NA);\n\t*offset += 1;\n\n\tswitch (subtype) {\n\t\tcase '0':\n\t\tcase 'T':\n\t\tcase 'F':\n\t\t\tdissect_rbm_basic(tvb, pinfo, tree, offset, subtype, &type_local, &value_local);\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\ttype_local = \"Integer\";\n\t\t\tdissect_rbm_integer(tvb, pinfo, tree, offset, &value_local);\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\ttype_local = \"Symbol\";\n\t\t\tdissect_rbm_symbol(tvb, pinfo, tree, offset, &value_local);\n\t\t\tbreak;\n\t\tcase '\"':\n\t\t\ttype_local = \"String\";\n\t\t\tdissect_rbm_string(tvb, pinfo, tree, offset, &value_local);\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\ttype_local = \"Instance Variable\";\n\t\t\tdissect_rbm_variable(tvb, pinfo, tree, offset, &value_local);\n\t\t\tbreak;\n\t\tcase '[':\n\t\t\ttype_local = \"Array\";\n\t\t\tdissect_rbm_array(tvb, pinfo, tree, offset, &value_local);\n\t\t\tbreak;\n\t\tcase '{':\n\t\t\ttype_local = \"Hash\";\n\t\t\tdissect_rbm_hash(tvb, pinfo, tree, offset, &value_local);\n\t\t\tbreak;\n\t\tcase ';':\n\t\tcase '@':\n\t\t\tdissect_rbm_link(tvb, pinfo, tree, offset, subtype, &type_local, &value_local);\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\ttype_local = \"Double\";\n\t\t\tdissect_rbm_double(tvb, pinfo, tree, offset, &value_local);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\ttype_local = \"Class\";\n\t\t\tdissect_rbm_class(tvb, pinfo, tree, offset, &value_local);\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\ttype_local = \"Module\";\n\t\t\tdissect_rbm_module(tvb, pinfo, tree, offset, &value_local);\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\ttype_local = \"Struct\";\n\t\t\tdissect_rbm_struct(tvb, pinfo, tree, offset, &value_local);\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\ttype_local = \"Regex\";\n\t\t\tdissect_rbm_regex(tvb, pinfo, tree, offset, &value_local);\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\ttype_local = \"DRb::DRbObject\";\n\t\t\tdissect_rbm_drb(tvb, pinfo, tree, offset);\n\t\t\tbreak;\n\t\tcase ',':\n\t\t\tdissect_rbm_inline(tvb, pinfo, tree, offset, &type_local, &value_local);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tdissect_rbm_rubyobject(tvb, pinfo, tree, offset);\n\t\t\ttype_local = \"Ruby Object\";\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\ttype_local = \"UserClass\";\n\t\t\tdissect_rbm_userclass(tvb, pinfo, tree, offset, &value_local);\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\ttype_local = \"Extended Object\";\n\t\t\tdissect_rbm_extended(tvb, pinfo, tree, offset);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texpert_add_info_format(pinfo, tree, &ei_rbm_invalid,\n\t\t\t\t\"Object type 0x%x is invalid\", subtype);\n\t\t\t*offset += tvb_reported_length_remaining(tvb, *offset);\n\t}\n\n\tproto_item_set_len(tree, *offset - offset_start);\n\n\tproto_item_append_text(tree, \"Type: %s\", type_local);\n\tif (value_local && strlen(value_local))\n\t\tproto_item_append_text(tree, \", Value: %s\", value_local);\n\n\tif (type)\n\t\t*type = type_local;\n\tif (value)\n\t\t*value = value_local;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,8 +2,8 @@\n {\n \tguint8 subtype = tvb_get_guint8(tvb, *offset);\n \tproto_tree* tree;\n-\tgchar* type_local = NULL;\n-\tgchar* value_local = NULL;\n+\tgchar* type_local = \"Unknown\";\n+\tgchar* value_local = \"Unknown\";\n \tgint offset_start = *offset;\n \n \ttree = proto_tree_add_subtree(ptree, tvb, *offset, 0, ett_variable, NULL, \"\");\n@@ -87,6 +87,7 @@\n \t\tdefault:\n \t\t\texpert_add_info_format(pinfo, tree, &ei_rbm_invalid,\n \t\t\t\t\"Object type 0x%x is invalid\", subtype);\n+\t\t\t*offset += tvb_reported_length_remaining(tvb, *offset);\n \t}\n \n \tproto_item_set_len(tree, *offset - offset_start);",
        "diff_line_info": {
            "deleted_lines": [
                "\tgchar* type_local = NULL;",
                "\tgchar* value_local = NULL;"
            ],
            "added_lines": [
                "\tgchar* type_local = \"Unknown\";",
                "\tgchar* value_local = \"Unknown\";",
                "\t\t\t*offset += tvb_reported_length_remaining(tvb, *offset);"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-2213",
        "func_name": "torvalds/linux/inet_diag_bc_audit",
        "description": "The inet_diag_bc_audit function in net/ipv4/inet_diag.c in the Linux kernel before 2.6.39.3 does not properly audit INET_DIAG bytecode, which allows local users to cause a denial of service (kernel infinite loop) via crafted INET_DIAG_REQ_BYTECODE instructions in a netlink message, as demonstrated by an INET_DIAG_BC_JMP instruction with a zero yes value, a different vulnerability than CVE-2010-3880.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=eeb1497277d6b1a0a34ed36b97e18f2bd7d6de0d",
        "commit_title": "A malicious user or buggy application can inject code and trigger an",
        "commit_text": "infinite loop in inet_diag_bc_audit()  Also make sure each instruction is aligned on 4 bytes boundary, to avoid unaligned accesses.  ",
        "func_before": "static int inet_diag_bc_audit(const void *bytecode, int bytecode_len)\n{\n\tconst unsigned char *bc = bytecode;\n\tint  len = bytecode_len;\n\n\twhile (len > 0) {\n\t\tstruct inet_diag_bc_op *op = (struct inet_diag_bc_op *)bc;\n\n//printk(\"BC: %d %d %d {%d} / %d\\n\", op->code, op->yes, op->no, op[1].no, len);\n\t\tswitch (op->code) {\n\t\tcase INET_DIAG_BC_AUTO:\n\t\tcase INET_DIAG_BC_S_COND:\n\t\tcase INET_DIAG_BC_D_COND:\n\t\tcase INET_DIAG_BC_S_GE:\n\t\tcase INET_DIAG_BC_S_LE:\n\t\tcase INET_DIAG_BC_D_GE:\n\t\tcase INET_DIAG_BC_D_LE:\n\t\t\tif (op->yes < 4 || op->yes > len + 4)\n\t\t\t\treturn -EINVAL;\n\t\tcase INET_DIAG_BC_JMP:\n\t\t\tif (op->no < 4 || op->no > len + 4)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (op->no < len &&\n\t\t\t    !valid_cc(bytecode, bytecode_len, len - op->no))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase INET_DIAG_BC_NOP:\n\t\t\tif (op->yes < 4 || op->yes > len + 4)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbc  += op->yes;\n\t\tlen -= op->yes;\n\t}\n\treturn len == 0 ? 0 : -EINVAL;\n}",
        "func": "static int inet_diag_bc_audit(const void *bytecode, int bytecode_len)\n{\n\tconst void *bc = bytecode;\n\tint  len = bytecode_len;\n\n\twhile (len > 0) {\n\t\tconst struct inet_diag_bc_op *op = bc;\n\n//printk(\"BC: %d %d %d {%d} / %d\\n\", op->code, op->yes, op->no, op[1].no, len);\n\t\tswitch (op->code) {\n\t\tcase INET_DIAG_BC_AUTO:\n\t\tcase INET_DIAG_BC_S_COND:\n\t\tcase INET_DIAG_BC_D_COND:\n\t\tcase INET_DIAG_BC_S_GE:\n\t\tcase INET_DIAG_BC_S_LE:\n\t\tcase INET_DIAG_BC_D_GE:\n\t\tcase INET_DIAG_BC_D_LE:\n\t\tcase INET_DIAG_BC_JMP:\n\t\t\tif (op->no < 4 || op->no > len + 4 || op->no & 3)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (op->no < len &&\n\t\t\t    !valid_cc(bytecode, bytecode_len, len - op->no))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase INET_DIAG_BC_NOP:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (op->yes < 4 || op->yes > len + 4 || op->yes & 3)\n\t\t\treturn -EINVAL;\n\t\tbc  += op->yes;\n\t\tlen -= op->yes;\n\t}\n\treturn len == 0 ? 0 : -EINVAL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,10 @@\n static int inet_diag_bc_audit(const void *bytecode, int bytecode_len)\n {\n-\tconst unsigned char *bc = bytecode;\n+\tconst void *bc = bytecode;\n \tint  len = bytecode_len;\n \n \twhile (len > 0) {\n-\t\tstruct inet_diag_bc_op *op = (struct inet_diag_bc_op *)bc;\n+\t\tconst struct inet_diag_bc_op *op = bc;\n \n //printk(\"BC: %d %d %d {%d} / %d\\n\", op->code, op->yes, op->no, op[1].no, len);\n \t\tswitch (op->code) {\n@@ -15,22 +15,20 @@\n \t\tcase INET_DIAG_BC_S_LE:\n \t\tcase INET_DIAG_BC_D_GE:\n \t\tcase INET_DIAG_BC_D_LE:\n-\t\t\tif (op->yes < 4 || op->yes > len + 4)\n-\t\t\t\treturn -EINVAL;\n \t\tcase INET_DIAG_BC_JMP:\n-\t\t\tif (op->no < 4 || op->no > len + 4)\n+\t\t\tif (op->no < 4 || op->no > len + 4 || op->no & 3)\n \t\t\t\treturn -EINVAL;\n \t\t\tif (op->no < len &&\n \t\t\t    !valid_cc(bytecode, bytecode_len, len - op->no))\n \t\t\t\treturn -EINVAL;\n \t\t\tbreak;\n \t\tcase INET_DIAG_BC_NOP:\n-\t\t\tif (op->yes < 4 || op->yes > len + 4)\n-\t\t\t\treturn -EINVAL;\n \t\t\tbreak;\n \t\tdefault:\n \t\t\treturn -EINVAL;\n \t\t}\n+\t\tif (op->yes < 4 || op->yes > len + 4 || op->yes & 3)\n+\t\t\treturn -EINVAL;\n \t\tbc  += op->yes;\n \t\tlen -= op->yes;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\tconst unsigned char *bc = bytecode;",
                "\t\tstruct inet_diag_bc_op *op = (struct inet_diag_bc_op *)bc;",
                "\t\t\tif (op->yes < 4 || op->yes > len + 4)",
                "\t\t\t\treturn -EINVAL;",
                "\t\t\tif (op->no < 4 || op->no > len + 4)",
                "\t\t\tif (op->yes < 4 || op->yes > len + 4)",
                "\t\t\t\treturn -EINVAL;"
            ],
            "added_lines": [
                "\tconst void *bc = bytecode;",
                "\t\tconst struct inet_diag_bc_op *op = bc;",
                "\t\t\tif (op->no < 4 || op->no > len + 4 || op->no & 3)",
                "\t\tif (op->yes < 4 || op->yes > len + 4 || op->yes & 3)",
                "\t\t\treturn -EINVAL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-2213",
        "func_name": "torvalds/linux/valid_cc",
        "description": "The inet_diag_bc_audit function in net/ipv4/inet_diag.c in the Linux kernel before 2.6.39.3 does not properly audit INET_DIAG bytecode, which allows local users to cause a denial of service (kernel infinite loop) via crafted INET_DIAG_REQ_BYTECODE instructions in a netlink message, as demonstrated by an INET_DIAG_BC_JMP instruction with a zero yes value, a different vulnerability than CVE-2010-3880.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=eeb1497277d6b1a0a34ed36b97e18f2bd7d6de0d",
        "commit_title": "A malicious user or buggy application can inject code and trigger an",
        "commit_text": "infinite loop in inet_diag_bc_audit()  Also make sure each instruction is aligned on 4 bytes boundary, to avoid unaligned accesses.  ",
        "func_before": "static int valid_cc(const void *bc, int len, int cc)\n{\n\twhile (len >= 0) {\n\t\tconst struct inet_diag_bc_op *op = bc;\n\n\t\tif (cc > len)\n\t\t\treturn 0;\n\t\tif (cc == len)\n\t\t\treturn 1;\n\t\tif (op->yes < 4)\n\t\t\treturn 0;\n\t\tlen -= op->yes;\n\t\tbc  += op->yes;\n\t}\n\treturn 0;\n}",
        "func": "static int valid_cc(const void *bc, int len, int cc)\n{\n\twhile (len >= 0) {\n\t\tconst struct inet_diag_bc_op *op = bc;\n\n\t\tif (cc > len)\n\t\t\treturn 0;\n\t\tif (cc == len)\n\t\t\treturn 1;\n\t\tif (op->yes < 4 || op->yes & 3)\n\t\t\treturn 0;\n\t\tlen -= op->yes;\n\t\tbc  += op->yes;\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,7 @@\n \t\t\treturn 0;\n \t\tif (cc == len)\n \t\t\treturn 1;\n-\t\tif (op->yes < 4)\n+\t\tif (op->yes < 4 || op->yes & 3)\n \t\t\treturn 0;\n \t\tlen -= op->yes;\n \t\tbc  += op->yes;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (op->yes < 4)"
            ],
            "added_lines": [
                "\t\tif (op->yes < 4 || op->yes & 3)"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22235",
        "func_name": "wireshark/dissect_dnp3_message",
        "description": "Crash in DNP dissector in Wireshark 3.4.0 to 3.4.6 and 3.2.0 to 3.2.14 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/029a7fcec5c6fc9407bd7f50ad6c3ce79f4d393b",
        "commit_title": "DNP: use the proper free function",
        "commit_text": " g618661b22e introduced a free for a so called memory leak (which wasn't a real leak due to the pinfo->pool garbage collector) but used the wrong free function. Let's keep the explicit free but use the right function.  Closes #17462 ",
        "func_before": "static int\ndissect_dnp3_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n{\n  proto_item  *ti, *tdl, *tc, *hidden_item;\n  proto_tree  *dnp3_tree, *dl_tree, *field_tree;\n  int          offset = 0, temp_offset = 0;\n  gboolean     dl_prm;\n  guint8       dl_len, dl_ctl, dl_func;\n  const gchar *func_code_str;\n  guint16      dl_dst, dl_src, calc_dl_crc;\n\n  /* Make entries in Protocol column and Info column on summary display */\n  col_set_str(pinfo->cinfo, COL_PROTOCOL, \"DNP 3.0\");\n  col_clear(pinfo->cinfo, COL_INFO);\n\n  /* Skip \"0x0564\" header bytes */\n  temp_offset += 2;\n\n  dl_len = tvb_get_guint8(tvb, temp_offset);\n  temp_offset += 1;\n\n  dl_ctl = tvb_get_guint8(tvb, temp_offset);\n  temp_offset += 1;\n\n  dl_dst = tvb_get_letohs(tvb, temp_offset);\n  temp_offset += 2;\n\n  dl_src = tvb_get_letohs(tvb, temp_offset);\n\n  dl_func = dl_ctl & DNP3_CTL_FUNC;\n  dl_prm = dl_ctl & DNP3_CTL_PRM;\n  func_code_str = val_to_str(dl_func, dl_prm ? dnp3_ctl_func_pri_vals : dnp3_ctl_func_sec_vals,\n           \"Unknown function (0x%02x)\");\n\n  /* Make sure source and dest are always in the info column */\n  col_append_fstr(pinfo->cinfo, COL_INFO, \"from %u to %u\", dl_src, dl_dst);\n  col_append_sep_fstr(pinfo->cinfo, COL_INFO, NULL, \"len=%u, %s\", dl_len, func_code_str);\n\n  /* create display subtree for the protocol */\n  ti = proto_tree_add_item(tree, proto_dnp3, tvb, offset, -1, ENC_NA);\n  dnp3_tree = proto_item_add_subtree(ti, ett_dnp3);\n\n  /* Create Subtree for Data Link Layer */\n  dl_tree = proto_tree_add_subtree_format(dnp3_tree, tvb, offset, DNP_HDR_LEN, ett_dnp3_dl, &tdl,\n        \"Data Link Layer, Len: %u, From: %u, To: %u, \", dl_len, dl_src, dl_dst);\n  if (dl_prm) {\n    if (dl_ctl & DNP3_CTL_DIR) proto_item_append_text(tdl, \"DIR, \");\n    if (dl_ctl & DNP3_CTL_PRM) proto_item_append_text(tdl, \"PRM, \");\n    if (dl_ctl & DNP3_CTL_FCB) proto_item_append_text(tdl, \"FCB, \");\n    if (dl_ctl & DNP3_CTL_FCV) proto_item_append_text(tdl, \"FCV, \");\n  }\n  else {\n    if (dl_ctl & DNP3_CTL_DIR) proto_item_append_text(tdl, \"DIR, \");\n    if (dl_ctl & DNP3_CTL_PRM) proto_item_append_text(tdl, \"PRM, \");\n    if (dl_ctl & DNP3_CTL_RES) proto_item_append_text(tdl, \"RES, \");\n    if (dl_ctl & DNP3_CTL_DFC) proto_item_append_text(tdl, \"DFC, \");\n  }\n  proto_item_append_text(tdl, \"%s\", func_code_str);\n\n  /* start bytes */\n  proto_tree_add_item(dl_tree, hf_dnp3_start, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  /* add length field */\n  proto_tree_add_item(dl_tree, hf_dnp3_len, tvb, offset, 1, ENC_BIG_ENDIAN);\n  offset += 1;\n\n  /* Add Control Byte Subtree */\n  tc = proto_tree_add_uint_format_value(dl_tree, hf_dnp3_ctl, tvb, offset, 1, dl_ctl,\n          \"0x%02x (\", dl_ctl);\n  /* Add Text to Control Byte Subtree Header */\n  if (dl_prm) {\n    if (dl_ctl & DNP3_CTL_DIR) proto_item_append_text(tc, \"DIR, \");\n    if (dl_ctl & DNP3_CTL_PRM) proto_item_append_text(tc, \"PRM, \");\n    if (dl_ctl & DNP3_CTL_FCB) proto_item_append_text(tc, \"FCB, \");\n    if (dl_ctl & DNP3_CTL_FCV) proto_item_append_text(tc, \"FCV, \");\n  }\n  else {\n    if (dl_ctl & DNP3_CTL_DIR) proto_item_append_text(tc, \"DIR, \");\n    if (dl_ctl & DNP3_CTL_PRM) proto_item_append_text(tc, \"PRM, \");\n    if (dl_ctl & DNP3_CTL_RES) proto_item_append_text(tc, \"RES, \");\n    if (dl_ctl & DNP3_CTL_DFC) proto_item_append_text(tc, \"DFC, \");\n  }\n  proto_item_append_text(tc, \"%s)\", func_code_str );\n  field_tree = proto_item_add_subtree(tc, ett_dnp3_dl_ctl);\n\n  /* Add Control Byte Subtree Items */\n  if (dl_prm) {\n    proto_tree_add_item(field_tree, hf_dnp3_ctl_dir, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(field_tree, hf_dnp3_ctl_prm, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(field_tree, hf_dnp3_ctl_fcb, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(field_tree, hf_dnp3_ctl_fcv, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(field_tree, hf_dnp3_ctl_prifunc, tvb, offset, 1, ENC_BIG_ENDIAN);\n  }\n  else {\n    proto_tree_add_item(field_tree, hf_dnp3_ctl_dir, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(field_tree, hf_dnp3_ctl_prm, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(field_tree, hf_dnp3_ctl_dfc, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(field_tree, hf_dnp3_ctl_secfunc, tvb, offset, 1, ENC_BIG_ENDIAN);\n  }\n    offset += 1;\n\n  /* add destination and source addresses */\n  proto_tree_add_item(dl_tree, hf_dnp3_dst, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n  hidden_item = proto_tree_add_item(dl_tree, hf_dnp3_addr, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n  proto_item_set_hidden(hidden_item);\n  offset += 2;\n  proto_tree_add_item(dl_tree, hf_dnp3_src, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n  hidden_item = proto_tree_add_item(dl_tree, hf_dnp3_addr, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n  proto_item_set_hidden(hidden_item);\n  offset += 2;\n\n  /* and header CRC */\n  calc_dl_crc = calculateCRCtvb(tvb, 0, DNP_HDR_LEN - 2);\n  proto_tree_add_checksum(dl_tree, tvb, offset, hf_dnp3_data_hdr_crc,\n                          hf_dnp3_data_hdr_crc_status, &ei_dnp3_data_hdr_crc_incorrect,\n                          pinfo, calc_dl_crc, ENC_LITTLE_ENDIAN, PROTO_CHECKSUM_VERIFY);\n  offset += 2;\n\n  /* If the DataLink function is 'Request Link Status' or 'Status of Link',\n     or 'Reset Link' we don't expect any Transport or Application Layer Data\n     NOTE: This code should probably check what DOES have TR or AL data */\n  if ((dl_func != DL_FUNC_LINK_STAT) && (dl_func != DL_FUNC_STAT_LINK) &&\n      (dl_func != DL_FUNC_RESET_LINK) && (dl_func != DL_FUNC_ACK))\n  {\n    proto_tree *data_tree;\n    proto_item *data_ti;\n    guint8      tr_ctl, tr_seq;\n    gboolean    tr_fir, tr_fin;\n    guint8     *al_buffer, *al_buffer_ptr;\n    guint8      data_len;\n    int         data_start = offset;\n    int         tl_offset;\n    gboolean    crc_OK = FALSE;\n    tvbuff_t   *next_tvb;\n    guint       i;\n    static int * const transport_flags[] = {\n      &hf_dnp3_tr_fin,\n      &hf_dnp3_tr_fir,\n      &hf_dnp3_tr_seq,\n      NULL\n    };\n\n    /* get the transport layer byte */\n    tr_ctl = tvb_get_guint8(tvb, offset);\n    tr_seq = tr_ctl & DNP3_TR_SEQ;\n    tr_fir = tr_ctl & DNP3_TR_FIR;\n    tr_fin = tr_ctl & DNP3_TR_FIN;\n\n    /* Add Transport Layer Tree */\n    tc = proto_tree_add_bitmask(dnp3_tree, tvb, offset, hf_dnp3_tr_ctl, ett_dnp3_tr_ctl, transport_flags, ENC_BIG_ENDIAN);\n    proto_item_append_text(tc, \"(\");\n    if (tr_fir) proto_item_append_text(tc, \"FIR, \");\n    if (tr_fin) proto_item_append_text(tc, \"FIN, \");\n    proto_item_append_text(tc, \"Sequence %u)\", tr_seq);\n\n    /* Add data chunk tree */\n    data_tree = proto_tree_add_subtree(dnp3_tree, tvb, offset, -1, ett_dnp3_dl_data, &data_ti, \"Data Chunks\");\n\n    /* extract the application layer data, validating the CRCs */\n\n    /* XXX - check for dl_len <= 5 */\n    data_len = dl_len - 5;\n    al_buffer = (guint8 *)wmem_alloc(pinfo->pool, data_len);\n    al_buffer_ptr = al_buffer;\n    i = 0;\n    tl_offset = 1;  /* skip the initial transport layer byte when assembling chunks for the application layer tvb */\n    while (data_len > 0)\n    {\n      guint8        chk_size;\n      const guint8 *chk_ptr;\n      proto_tree   *chk_tree;\n      proto_item   *chk_len_ti;\n      guint16       calc_crc, act_crc;\n\n      chk_size = MIN(data_len, AL_MAX_CHUNK_SIZE);\n      chk_ptr  = tvb_get_ptr(tvb, offset, chk_size);\n      memcpy(al_buffer_ptr, chk_ptr + tl_offset, chk_size - tl_offset);\n      al_buffer_ptr += chk_size - tl_offset;\n\n      chk_tree = proto_tree_add_subtree_format(data_tree, tvb, offset, chk_size + 2, ett_dnp3_dl_chunk, NULL, \"Data Chunk: %u\", i);\n      proto_tree_add_item(chk_tree, hf_dnp3_data_chunk, tvb, offset, chk_size, ENC_NA);\n      chk_len_ti = proto_tree_add_uint(chk_tree, hf_dnp3_data_chunk_len, tvb, offset, 0, chk_size);\n      proto_item_set_generated(chk_len_ti);\n\n      offset  += chk_size;\n\n      calc_crc = calculateCRC(chk_ptr, chk_size);\n      proto_tree_add_checksum(chk_tree, tvb, offset, hf_dnp3_data_chunk_crc,\n                              hf_dnp3_data_chunk_crc_status, &ei_dnp3_data_chunk_crc_incorrect,\n                              pinfo, calc_crc, ENC_LITTLE_ENDIAN, PROTO_CHECKSUM_VERIFY);\n      act_crc  = tvb_get_letohs(tvb, offset);\n      offset  += 2;\n      crc_OK   = calc_crc == act_crc;\n      if (!crc_OK)\n      {\n        /* Don't trust the rest of the data, get out of here */\n        break;\n      }\n      data_len -= chk_size;\n      i++;\n      tl_offset = 0;  /* copy all the data in the rest of the chunks */\n    }\n    proto_item_set_len(data_ti, offset - data_start);\n\n    /* if crc OK, set up new tvb */\n    if (crc_OK)\n    {\n      tvbuff_t *al_tvb;\n      gboolean  save_fragmented;\n\n      al_tvb = tvb_new_child_real_data(tvb, al_buffer, (guint) (al_buffer_ptr-al_buffer), (gint) (al_buffer_ptr-al_buffer));\n\n      /* Check for fragmented packet */\n      save_fragmented = pinfo->fragmented;\n\n      /* Reassemble AL fragments */\n      static guint al_max_fragments = 60;\n      static guint al_fragment_aging = 64; /* sequence numbers only 6 bit */\n      fragment_head *frag_al = NULL;\n      pinfo->fragmented = TRUE;\n      if (!pinfo->fd->visited)\n      {\n        frag_al = fragment_add_seq_single_aging(&al_reassembly_table,\n            al_tvb, 0, pinfo, tr_seq, NULL,\n            tvb_reported_length(al_tvb), /* As this is a constructed tvb, all of it is ok */\n            tr_fir, tr_fin,\n            al_max_fragments, al_fragment_aging);\n      }\n      else\n      {\n        frag_al = fragment_get_reassembled_id(&al_reassembly_table, pinfo, tr_seq);\n      }\n      next_tvb = process_reassembled_data(al_tvb, 0, pinfo,\n          \"Reassembled DNP 3.0 Application Layer message\", frag_al, &dnp3_frag_items,\n          NULL, dnp3_tree);\n\n      if (frag_al)\n      {\n        if (pinfo->num == frag_al->reassembled_in && pinfo->curr_layer_num == frag_al->reas_in_layer_num)\n        {\n          /* As a complete AL message will have cleared the info column,\n             make sure source and dest are always in the info column */\n          //col_append_fstr(pinfo->cinfo, COL_INFO, \"from %u to %u\", dl_src, dl_dst);\n          //col_set_fence(pinfo->cinfo, COL_INFO);\n          dissect_dnp3_al(next_tvb, pinfo, dnp3_tree);\n        }\n        else\n        {\n          /* Lock any column info set by the DL and TL */\n          col_set_fence(pinfo->cinfo, COL_INFO);\n          col_append_fstr(pinfo->cinfo, COL_INFO,\n              \" (Application Layer fragment %u, reassembled in packet %u)\",\n              tr_seq, frag_al->reassembled_in);\n          proto_tree_add_item(dnp3_tree, hf_al_frag_data, al_tvb, 0, -1, ENC_NA);\n        }\n      }\n      else\n      {\n        col_append_fstr(pinfo->cinfo, COL_INFO,\n            \" (Application Layer Unreassembled fragment %u)\",\n            tr_seq);\n        proto_tree_add_item(dnp3_tree, hf_al_frag_data, al_tvb, 0, -1, ENC_NA);\n      }\n\n      pinfo->fragmented = save_fragmented;\n    }\n    else\n    {\n      /* CRC error - throw away the data. */\n      g_free(al_buffer);\n      next_tvb = NULL;\n    }\n  }\n\n  /* Set the length of the message */\n  proto_item_set_len(ti, offset);\n  return offset;\n}",
        "func": "static int\ndissect_dnp3_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n{\n  proto_item  *ti, *tdl, *tc, *hidden_item;\n  proto_tree  *dnp3_tree, *dl_tree, *field_tree;\n  int          offset = 0, temp_offset = 0;\n  gboolean     dl_prm;\n  guint8       dl_len, dl_ctl, dl_func;\n  const gchar *func_code_str;\n  guint16      dl_dst, dl_src, calc_dl_crc;\n\n  /* Make entries in Protocol column and Info column on summary display */\n  col_set_str(pinfo->cinfo, COL_PROTOCOL, \"DNP 3.0\");\n  col_clear(pinfo->cinfo, COL_INFO);\n\n  /* Skip \"0x0564\" header bytes */\n  temp_offset += 2;\n\n  dl_len = tvb_get_guint8(tvb, temp_offset);\n  temp_offset += 1;\n\n  dl_ctl = tvb_get_guint8(tvb, temp_offset);\n  temp_offset += 1;\n\n  dl_dst = tvb_get_letohs(tvb, temp_offset);\n  temp_offset += 2;\n\n  dl_src = tvb_get_letohs(tvb, temp_offset);\n\n  dl_func = dl_ctl & DNP3_CTL_FUNC;\n  dl_prm = dl_ctl & DNP3_CTL_PRM;\n  func_code_str = val_to_str(dl_func, dl_prm ? dnp3_ctl_func_pri_vals : dnp3_ctl_func_sec_vals,\n           \"Unknown function (0x%02x)\");\n\n  /* Make sure source and dest are always in the info column */\n  col_append_fstr(pinfo->cinfo, COL_INFO, \"from %u to %u\", dl_src, dl_dst);\n  col_append_sep_fstr(pinfo->cinfo, COL_INFO, NULL, \"len=%u, %s\", dl_len, func_code_str);\n\n  /* create display subtree for the protocol */\n  ti = proto_tree_add_item(tree, proto_dnp3, tvb, offset, -1, ENC_NA);\n  dnp3_tree = proto_item_add_subtree(ti, ett_dnp3);\n\n  /* Create Subtree for Data Link Layer */\n  dl_tree = proto_tree_add_subtree_format(dnp3_tree, tvb, offset, DNP_HDR_LEN, ett_dnp3_dl, &tdl,\n        \"Data Link Layer, Len: %u, From: %u, To: %u, \", dl_len, dl_src, dl_dst);\n  if (dl_prm) {\n    if (dl_ctl & DNP3_CTL_DIR) proto_item_append_text(tdl, \"DIR, \");\n    if (dl_ctl & DNP3_CTL_PRM) proto_item_append_text(tdl, \"PRM, \");\n    if (dl_ctl & DNP3_CTL_FCB) proto_item_append_text(tdl, \"FCB, \");\n    if (dl_ctl & DNP3_CTL_FCV) proto_item_append_text(tdl, \"FCV, \");\n  }\n  else {\n    if (dl_ctl & DNP3_CTL_DIR) proto_item_append_text(tdl, \"DIR, \");\n    if (dl_ctl & DNP3_CTL_PRM) proto_item_append_text(tdl, \"PRM, \");\n    if (dl_ctl & DNP3_CTL_RES) proto_item_append_text(tdl, \"RES, \");\n    if (dl_ctl & DNP3_CTL_DFC) proto_item_append_text(tdl, \"DFC, \");\n  }\n  proto_item_append_text(tdl, \"%s\", func_code_str);\n\n  /* start bytes */\n  proto_tree_add_item(dl_tree, hf_dnp3_start, tvb, offset, 2, ENC_BIG_ENDIAN);\n  offset += 2;\n\n  /* add length field */\n  proto_tree_add_item(dl_tree, hf_dnp3_len, tvb, offset, 1, ENC_BIG_ENDIAN);\n  offset += 1;\n\n  /* Add Control Byte Subtree */\n  tc = proto_tree_add_uint_format_value(dl_tree, hf_dnp3_ctl, tvb, offset, 1, dl_ctl,\n          \"0x%02x (\", dl_ctl);\n  /* Add Text to Control Byte Subtree Header */\n  if (dl_prm) {\n    if (dl_ctl & DNP3_CTL_DIR) proto_item_append_text(tc, \"DIR, \");\n    if (dl_ctl & DNP3_CTL_PRM) proto_item_append_text(tc, \"PRM, \");\n    if (dl_ctl & DNP3_CTL_FCB) proto_item_append_text(tc, \"FCB, \");\n    if (dl_ctl & DNP3_CTL_FCV) proto_item_append_text(tc, \"FCV, \");\n  }\n  else {\n    if (dl_ctl & DNP3_CTL_DIR) proto_item_append_text(tc, \"DIR, \");\n    if (dl_ctl & DNP3_CTL_PRM) proto_item_append_text(tc, \"PRM, \");\n    if (dl_ctl & DNP3_CTL_RES) proto_item_append_text(tc, \"RES, \");\n    if (dl_ctl & DNP3_CTL_DFC) proto_item_append_text(tc, \"DFC, \");\n  }\n  proto_item_append_text(tc, \"%s)\", func_code_str );\n  field_tree = proto_item_add_subtree(tc, ett_dnp3_dl_ctl);\n\n  /* Add Control Byte Subtree Items */\n  if (dl_prm) {\n    proto_tree_add_item(field_tree, hf_dnp3_ctl_dir, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(field_tree, hf_dnp3_ctl_prm, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(field_tree, hf_dnp3_ctl_fcb, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(field_tree, hf_dnp3_ctl_fcv, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(field_tree, hf_dnp3_ctl_prifunc, tvb, offset, 1, ENC_BIG_ENDIAN);\n  }\n  else {\n    proto_tree_add_item(field_tree, hf_dnp3_ctl_dir, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(field_tree, hf_dnp3_ctl_prm, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(field_tree, hf_dnp3_ctl_dfc, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(field_tree, hf_dnp3_ctl_secfunc, tvb, offset, 1, ENC_BIG_ENDIAN);\n  }\n    offset += 1;\n\n  /* add destination and source addresses */\n  proto_tree_add_item(dl_tree, hf_dnp3_dst, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n  hidden_item = proto_tree_add_item(dl_tree, hf_dnp3_addr, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n  proto_item_set_hidden(hidden_item);\n  offset += 2;\n  proto_tree_add_item(dl_tree, hf_dnp3_src, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n  hidden_item = proto_tree_add_item(dl_tree, hf_dnp3_addr, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n  proto_item_set_hidden(hidden_item);\n  offset += 2;\n\n  /* and header CRC */\n  calc_dl_crc = calculateCRCtvb(tvb, 0, DNP_HDR_LEN - 2);\n  proto_tree_add_checksum(dl_tree, tvb, offset, hf_dnp3_data_hdr_crc,\n                          hf_dnp3_data_hdr_crc_status, &ei_dnp3_data_hdr_crc_incorrect,\n                          pinfo, calc_dl_crc, ENC_LITTLE_ENDIAN, PROTO_CHECKSUM_VERIFY);\n  offset += 2;\n\n  /* If the DataLink function is 'Request Link Status' or 'Status of Link',\n     or 'Reset Link' we don't expect any Transport or Application Layer Data\n     NOTE: This code should probably check what DOES have TR or AL data */\n  if ((dl_func != DL_FUNC_LINK_STAT) && (dl_func != DL_FUNC_STAT_LINK) &&\n      (dl_func != DL_FUNC_RESET_LINK) && (dl_func != DL_FUNC_ACK))\n  {\n    proto_tree *data_tree;\n    proto_item *data_ti;\n    guint8      tr_ctl, tr_seq;\n    gboolean    tr_fir, tr_fin;\n    guint8     *al_buffer, *al_buffer_ptr;\n    guint8      data_len;\n    int         data_start = offset;\n    int         tl_offset;\n    gboolean    crc_OK = FALSE;\n    tvbuff_t   *next_tvb;\n    guint       i;\n    static int * const transport_flags[] = {\n      &hf_dnp3_tr_fin,\n      &hf_dnp3_tr_fir,\n      &hf_dnp3_tr_seq,\n      NULL\n    };\n\n    /* get the transport layer byte */\n    tr_ctl = tvb_get_guint8(tvb, offset);\n    tr_seq = tr_ctl & DNP3_TR_SEQ;\n    tr_fir = tr_ctl & DNP3_TR_FIR;\n    tr_fin = tr_ctl & DNP3_TR_FIN;\n\n    /* Add Transport Layer Tree */\n    tc = proto_tree_add_bitmask(dnp3_tree, tvb, offset, hf_dnp3_tr_ctl, ett_dnp3_tr_ctl, transport_flags, ENC_BIG_ENDIAN);\n    proto_item_append_text(tc, \"(\");\n    if (tr_fir) proto_item_append_text(tc, \"FIR, \");\n    if (tr_fin) proto_item_append_text(tc, \"FIN, \");\n    proto_item_append_text(tc, \"Sequence %u)\", tr_seq);\n\n    /* Add data chunk tree */\n    data_tree = proto_tree_add_subtree(dnp3_tree, tvb, offset, -1, ett_dnp3_dl_data, &data_ti, \"Data Chunks\");\n\n    /* extract the application layer data, validating the CRCs */\n\n    /* XXX - check for dl_len <= 5 */\n    data_len = dl_len - 5;\n    al_buffer = (guint8 *)wmem_alloc(pinfo->pool, data_len);\n    al_buffer_ptr = al_buffer;\n    i = 0;\n    tl_offset = 1;  /* skip the initial transport layer byte when assembling chunks for the application layer tvb */\n    while (data_len > 0)\n    {\n      guint8        chk_size;\n      const guint8 *chk_ptr;\n      proto_tree   *chk_tree;\n      proto_item   *chk_len_ti;\n      guint16       calc_crc, act_crc;\n\n      chk_size = MIN(data_len, AL_MAX_CHUNK_SIZE);\n      chk_ptr  = tvb_get_ptr(tvb, offset, chk_size);\n      memcpy(al_buffer_ptr, chk_ptr + tl_offset, chk_size - tl_offset);\n      al_buffer_ptr += chk_size - tl_offset;\n\n      chk_tree = proto_tree_add_subtree_format(data_tree, tvb, offset, chk_size + 2, ett_dnp3_dl_chunk, NULL, \"Data Chunk: %u\", i);\n      proto_tree_add_item(chk_tree, hf_dnp3_data_chunk, tvb, offset, chk_size, ENC_NA);\n      chk_len_ti = proto_tree_add_uint(chk_tree, hf_dnp3_data_chunk_len, tvb, offset, 0, chk_size);\n      proto_item_set_generated(chk_len_ti);\n\n      offset  += chk_size;\n\n      calc_crc = calculateCRC(chk_ptr, chk_size);\n      proto_tree_add_checksum(chk_tree, tvb, offset, hf_dnp3_data_chunk_crc,\n                              hf_dnp3_data_chunk_crc_status, &ei_dnp3_data_chunk_crc_incorrect,\n                              pinfo, calc_crc, ENC_LITTLE_ENDIAN, PROTO_CHECKSUM_VERIFY);\n      act_crc  = tvb_get_letohs(tvb, offset);\n      offset  += 2;\n      crc_OK   = calc_crc == act_crc;\n      if (!crc_OK)\n      {\n        /* Don't trust the rest of the data, get out of here */\n        break;\n      }\n      data_len -= chk_size;\n      i++;\n      tl_offset = 0;  /* copy all the data in the rest of the chunks */\n    }\n    proto_item_set_len(data_ti, offset - data_start);\n\n    /* if crc OK, set up new tvb */\n    if (crc_OK)\n    {\n      tvbuff_t *al_tvb;\n      gboolean  save_fragmented;\n\n      al_tvb = tvb_new_child_real_data(tvb, al_buffer, (guint) (al_buffer_ptr-al_buffer), (gint) (al_buffer_ptr-al_buffer));\n\n      /* Check for fragmented packet */\n      save_fragmented = pinfo->fragmented;\n\n      /* Reassemble AL fragments */\n      static guint al_max_fragments = 60;\n      static guint al_fragment_aging = 64; /* sequence numbers only 6 bit */\n      fragment_head *frag_al = NULL;\n      pinfo->fragmented = TRUE;\n      if (!pinfo->fd->visited)\n      {\n        frag_al = fragment_add_seq_single_aging(&al_reassembly_table,\n            al_tvb, 0, pinfo, tr_seq, NULL,\n            tvb_reported_length(al_tvb), /* As this is a constructed tvb, all of it is ok */\n            tr_fir, tr_fin,\n            al_max_fragments, al_fragment_aging);\n      }\n      else\n      {\n        frag_al = fragment_get_reassembled_id(&al_reassembly_table, pinfo, tr_seq);\n      }\n      next_tvb = process_reassembled_data(al_tvb, 0, pinfo,\n          \"Reassembled DNP 3.0 Application Layer message\", frag_al, &dnp3_frag_items,\n          NULL, dnp3_tree);\n\n      if (frag_al)\n      {\n        if (pinfo->num == frag_al->reassembled_in && pinfo->curr_layer_num == frag_al->reas_in_layer_num)\n        {\n          /* As a complete AL message will have cleared the info column,\n             make sure source and dest are always in the info column */\n          //col_append_fstr(pinfo->cinfo, COL_INFO, \"from %u to %u\", dl_src, dl_dst);\n          //col_set_fence(pinfo->cinfo, COL_INFO);\n          dissect_dnp3_al(next_tvb, pinfo, dnp3_tree);\n        }\n        else\n        {\n          /* Lock any column info set by the DL and TL */\n          col_set_fence(pinfo->cinfo, COL_INFO);\n          col_append_fstr(pinfo->cinfo, COL_INFO,\n              \" (Application Layer fragment %u, reassembled in packet %u)\",\n              tr_seq, frag_al->reassembled_in);\n          proto_tree_add_item(dnp3_tree, hf_al_frag_data, al_tvb, 0, -1, ENC_NA);\n        }\n      }\n      else\n      {\n        col_append_fstr(pinfo->cinfo, COL_INFO,\n            \" (Application Layer Unreassembled fragment %u)\",\n            tr_seq);\n        proto_tree_add_item(dnp3_tree, hf_al_frag_data, al_tvb, 0, -1, ENC_NA);\n      }\n\n      pinfo->fragmented = save_fragmented;\n    }\n    else\n    {\n      /* CRC error - throw away the data. */\n      wmem_free(pinfo->pool, al_buffer);\n      next_tvb = NULL;\n    }\n  }\n\n  /* Set the length of the message */\n  proto_item_set_len(ti, offset);\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -268,7 +268,7 @@\n     else\n     {\n       /* CRC error - throw away the data. */\n-      g_free(al_buffer);\n+      wmem_free(pinfo->pool, al_buffer);\n       next_tvb = NULL;\n     }\n   }",
        "diff_line_info": {
            "deleted_lines": [
                "      g_free(al_buffer);"
            ],
            "added_lines": [
                "      wmem_free(pinfo->pool, al_buffer);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3679",
        "func_name": "torvalds/linux/rb_per_cpu_empty",
        "description": "A lack of CPU resource in the Linux kernel tracing module functionality in versions prior to 5.14-rc3 was found in the way user uses trace ring buffer in a specific way. Only privileged local users (with CAP_SYS_ADMIN capability) could use this flaw to starve the resources causing denial of service.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=67f0d6d9883c13174669f88adac4f0ee656cc16a",
        "commit_title": "The \"rb_per_cpu_empty()\" misinterpret the condition (as not-empty) when",
        "commit_text": "\"head_page\" and \"commit_page\" of \"struct ring_buffer_per_cpu\" points to the same buffer page, whose \"buffer_data_page\" is empty and \"read\" field is non-zero.  An error scenario could be constructed as followed (kernel perspective):  1. All pages in the buffer has been accessed by reader(s) so that all of them will have non-zero \"read\" field.  2. Read and clear all buffer pages so that \"rb_num_of_entries()\" will return 0 rendering there's no more data to read. It is also required that the \"read_page\", \"commit_page\" and \"tail_page\" points to the same page, while \"head_page\" is the next page of them.  3. Invoke \"ring_buffer_lock_reserve()\" with large enough \"length\" so that it shot pass the end of current tail buffer page. Now the \"head_page\", \"commit_page\" and \"tail_page\" points to the same page.  4. Discard current event with \"ring_buffer_discard_commit()\", so that \"head_page\", \"commit_page\" and \"tail_page\" points to a page whose buffer data page is now empty.  When the error scenario has been constructed, \"tracing_read_pipe\" will be trapped inside a deadloop: \"trace_empty()\" returns 0 since \"rb_per_cpu_empty()\" returns 0 when it hits the CPU containing such constructed ring buffer. Then \"trace_find_next_entry_inc()\" always return NULL since \"rb_num_of_entries()\" reports there's no more entry to read. Finally \"trace_seq_to_user()\" returns \"-EBUSY\" spanking \"tracing_read_pipe\" back to the start of the \"waitagain\" loop.  I've also written a proof-of-concept script to construct the scenario and trigger the bug automatically, you can use it to trace and validate my reasoning above:    https://github.com/aegistudio/RingBufferDetonator.git  Tests has been carried out on linux kernel 5.14-rc2 (2734d6c1b1a089fb593ef6a23d4b70903526fe0c), my fixed version of kernel (for testing whether my update fixes the bug) and some older kernels (for range of affected kernels). Test result is also attached to the proof-of-concept repository.  Link: https://lore.kernel.org/linux-trace-devel/YPaNxsIlb2yjSi5Y@aegistudio/ Link: https://lore.kernel.org/linux-trace-devel/YPgrN85WL9VyrZ55@aegistudio  Cc: stable@vger.kernel.org Suggested-by: Linus Torvalds <torvalds@linuxfoundation.org> ",
        "func_before": "static bool rb_per_cpu_empty(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tstruct buffer_page *reader = cpu_buffer->reader_page;\n\tstruct buffer_page *head = rb_set_head_page(cpu_buffer);\n\tstruct buffer_page *commit = cpu_buffer->commit_page;\n\n\t/* In case of error, head will be NULL */\n\tif (unlikely(!head))\n\t\treturn true;\n\n\treturn reader->read == rb_page_commit(reader) &&\n\t\t(commit == reader ||\n\t\t (commit == head &&\n\t\t  head->read == rb_page_commit(commit)));\n}",
        "func": "static bool rb_per_cpu_empty(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tstruct buffer_page *reader = cpu_buffer->reader_page;\n\tstruct buffer_page *head = rb_set_head_page(cpu_buffer);\n\tstruct buffer_page *commit = cpu_buffer->commit_page;\n\n\t/* In case of error, head will be NULL */\n\tif (unlikely(!head))\n\t\treturn true;\n\n\t/* Reader should exhaust content in reader page */\n\tif (reader->read != rb_page_commit(reader))\n\t\treturn false;\n\n\t/*\n\t * If writers are committing on the reader page, knowing all\n\t * committed content has been read, the ring buffer is empty.\n\t */\n\tif (commit == reader)\n\t\treturn true;\n\n\t/*\n\t * If writers are committing on a page other than reader page\n\t * and head page, there should always be content to read.\n\t */\n\tif (commit != head)\n\t\treturn false;\n\n\t/*\n\t * Writers are committing on the head page, we just need\n\t * to care about there're committed data, and the reader will\n\t * swap reader page with head page when it is to read data.\n\t */\n\treturn rb_page_commit(commit) == 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,8 +8,28 @@\n \tif (unlikely(!head))\n \t\treturn true;\n \n-\treturn reader->read == rb_page_commit(reader) &&\n-\t\t(commit == reader ||\n-\t\t (commit == head &&\n-\t\t  head->read == rb_page_commit(commit)));\n+\t/* Reader should exhaust content in reader page */\n+\tif (reader->read != rb_page_commit(reader))\n+\t\treturn false;\n+\n+\t/*\n+\t * If writers are committing on the reader page, knowing all\n+\t * committed content has been read, the ring buffer is empty.\n+\t */\n+\tif (commit == reader)\n+\t\treturn true;\n+\n+\t/*\n+\t * If writers are committing on a page other than reader page\n+\t * and head page, there should always be content to read.\n+\t */\n+\tif (commit != head)\n+\t\treturn false;\n+\n+\t/*\n+\t * Writers are committing on the head page, we just need\n+\t * to care about there're committed data, and the reader will\n+\t * swap reader page with head page when it is to read data.\n+\t */\n+\treturn rb_page_commit(commit) == 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn reader->read == rb_page_commit(reader) &&",
                "\t\t(commit == reader ||",
                "\t\t (commit == head &&",
                "\t\t  head->read == rb_page_commit(commit)));"
            ],
            "added_lines": [
                "\t/* Reader should exhaust content in reader page */",
                "\tif (reader->read != rb_page_commit(reader))",
                "\t\treturn false;",
                "",
                "\t/*",
                "\t * If writers are committing on the reader page, knowing all",
                "\t * committed content has been read, the ring buffer is empty.",
                "\t */",
                "\tif (commit == reader)",
                "\t\treturn true;",
                "",
                "\t/*",
                "\t * If writers are committing on a page other than reader page",
                "\t * and head page, there should always be content to read.",
                "\t */",
                "\tif (commit != head)",
                "\t\treturn false;",
                "",
                "\t/*",
                "\t * Writers are committing on the head page, we just need",
                "\t * to care about there're committed data, and the reader will",
                "\t * swap reader page with head page when it is to read data.",
                "\t */",
                "\treturn rb_page_commit(commit) == 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-37621",
        "func_name": "Exiv2/exiv2/Image::printIFDStructure",
        "description": "Exiv2 is a command-line utility and C++ library for reading, writing, deleting, and modifying the metadata of image files. An infinite loop was found in Exiv2 versions v0.27.4 and earlier. The infinite loop is triggered when Exiv2 is used to print the metadata of a crafted image file. An attacker could potentially exploit the vulnerability to cause a denial of service, if they can trick the victim into running Exiv2 on a crafted image file. Note that this bug is only triggered when printing the image ICC profile, which is a less frequently used Exiv2 operation that requires an extra command line option (`-p C`). The bug is fixed in version v0.27.5.",
        "git_url": "https://github.com/Exiv2/exiv2/commit/191cd2690608f19335d82ed2be36c7ce8bdc60b9",
        "commit_title": "dirLength == 0 can cause an infinite loop.",
        "commit_text": "",
        "func_before": "void Image::printIFDStructure(BasicIo& io, std::ostream& out, Exiv2::PrintStructureOption option,uint32_t start,bool bSwap,char c,int depth)\n    {\n        depth++;\n        if ( depth == 1 ) visits.clear();\n        bool bFirst  = true  ;\n\n        // buffer\n        const size_t dirSize = 32;\n        DataBuf  dir(dirSize);\n        bool bPrint = option == kpsBasic || option == kpsRecursive;\n\n        do {\n            // Read top of directory\n            const int seekSuccess = !io.seek(start,BasicIo::beg);\n            const long bytesRead = io.read(dir.pData_, 2);\n            if (!seekSuccess || bytesRead == 0) {\n                throw Error(kerCorruptedMetadata);\n            }\n            uint16_t   dirLength = byteSwap2(dir,0,bSwap);\n\n            bool tooBig = dirLength > 500;\n            if ( tooBig ) throw Error(kerTiffDirectoryTooLarge);\n\n            if ( bFirst && bPrint ) {\n                out << Internal::indent(depth) << Internal::stringFormat(\"STRUCTURE OF TIFF FILE (%c%c): \",c,c) << io.path() << std::endl;\n                if ( tooBig ) out << Internal::indent(depth) << \"dirLength = \" << dirLength << std::endl;\n            }\n\n            // Read the dictionary\n            for ( int i = 0 ; i < dirLength ; i ++ ) {\n                if ( visits.find(io.tell()) != visits.end()  ) { // #547\n                    throw Error(kerCorruptedMetadata);\n                }\n                visits.insert(io.tell());\n                \n                if ( bFirst && bPrint ) {\n                    out << Internal::indent(depth)\n                        << \" address |    tag                              |     \"\n                        << \" type |    count |    offset | value\\n\";\n                }\n                bFirst = false;\n\n                io.read(dir.pData_, 12);\n                uint16_t tag    = byteSwap2(dir,0,bSwap);\n                uint16_t type   = byteSwap2(dir,2,bSwap);\n                uint32_t count  = byteSwap4(dir,4,bSwap);\n                uint32_t offset = byteSwap4(dir,8,bSwap);\n\n                // Break for unknown tag types else we may segfault.\n                if ( !typeValid(type) ) {\n                    std::cerr << \"invalid type in tiff structure\" << type << std::endl;\n                    start = 0; // break from do loop\n                    throw Error(kerInvalidTypeValue);\n                }\n\n                std::string sp  = \"\" ; // output spacer\n\n                //prepare to print the value\n                uint32_t kount  = isPrintXMP(tag,option) ? count // haul in all the data\n                                : isPrintICC(tag,option) ? count // ditto\n                                : isStringType(type)     ? (count > 32 ? 32 : count) // restrict long arrays\n                                : count > 5              ? 5\n                                : count\n                                ;\n                uint32_t pad    = isStringType(type) ? 1 : 0;\n                uint32_t size   = isStringType(type) ? 1\n                                : is2ByteType(type)  ? 2\n                                : is4ByteType(type)  ? 4\n                                : is8ByteType(type)  ? 8\n                                : 1\n                                ;\n\n                // if ( offset > io.size() ) offset = 0; // Denial of service?\n\n                // #55 and #56 memory allocation crash test/data/POC8\n                long long allocate = (long long) size*count + pad+20;\n                if ( allocate > (long long) io.size() ) {\n                    throw Error(kerInvalidMalloc);\n                }\n                DataBuf  buf((long)allocate);  // allocate a buffer\n                std::memset(buf.pData_, 0, buf.size_);\n                std::memcpy(buf.pData_,dir.pData_+8,4);  // copy dir[8:11] into buffer (short strings)\n                const bool bOffsetIsPointer = count*size > 4;\n\n                if ( bOffsetIsPointer ) {         // read into buffer\n                    size_t   restore = io.tell();  // save\n                    io.seek(offset,BasicIo::beg);  // position\n                    io.read(buf.pData_,count*size);// read\n                    io.seek(restore,BasicIo::beg); // restore\n                }\n\n                if ( bPrint ) {\n                    const uint32_t address = start + 2 + i*12 ;\n                    const std::string offsetString = bOffsetIsPointer?\n                        Internal::stringFormat(\"%10u\", offset):\n                        \"\";\n\n                    out << Internal::indent(depth)\n                    << Internal::stringFormat(\"%8u | %#06x %-28s |%10s |%9u |%10s | \"\n                                              ,address,tag,tagName(tag).c_str(),typeName(type),count,offsetString.c_str());\n                    if ( isShortType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            out << sp << byteSwap2(buf,k*size,bSwap);\n                            sp = \" \";\n                        }\n                    } else if ( isLongType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            out << sp << byteSwap4(buf,k*size,bSwap);\n                            sp = \" \";\n                        }\n\n                    } else if ( isRationalType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            uint32_t a = byteSwap4(buf,k*size+0,bSwap);\n                            uint32_t b = byteSwap4(buf,k*size+4,bSwap);\n                            out << sp << a << \"/\" << b;\n                            sp = \" \";\n                        }\n                    } else if ( isStringType(type) ) {\n                        out << sp << Internal::binaryToString(makeSlice(buf, 0, kount));\n                    }\n\n                    sp = kount == count ? \"\" : \" ...\";\n                    out << sp << std::endl;\n\n                    if ( option == kpsRecursive && (tag == 0x8769 /* ExifTag */ || tag == 0x014a/*SubIFDs*/  || type == tiffIfd) ) {\n                        for ( size_t k = 0 ; k < count ; k++ ) {\n                            size_t   restore = io.tell();\n                            uint32_t offset = byteSwap4(buf,k*size,bSwap);\n                            printIFDStructure(io,out,option,offset,bSwap,c,depth);\n                            io.seek(restore,BasicIo::beg);\n                        }\n                    } else if ( option == kpsRecursive && tag == 0x83bb /* IPTCNAA */ ) {\n\n                        if (static_cast<size_t>(Safe::add(count, offset)) > io.size()) {\n                            throw Error(kerCorruptedMetadata);\n                        }\n\n                        const size_t restore = io.tell();\n                        io.seek(offset, BasicIo::beg);  // position\n                        std::vector<byte> bytes(count) ;  // allocate memory\n                        // TODO: once we have C++11 use bytes.data()\n                        const long read_bytes = io.read(&bytes[0], count);\n                        io.seek(restore, BasicIo::beg);\n                        // TODO: once we have C++11 use bytes.data()\n                        IptcData::printStructure(out, makeSliceUntil(&bytes[0], read_bytes), depth);\n\n                    }  else if ( option == kpsRecursive && tag == 0x927c /* MakerNote */ && count > 10) {\n                        size_t   restore = io.tell();  // save\n\n                        uint32_t jump= 10           ;\n                        byte     bytes[20]          ;\n                        const char* chars = (const char*) &bytes[0] ;\n                        io.seek(offset,BasicIo::beg);  // position\n                        io.read(bytes,jump    )     ;  // read\n                        bytes[jump]=0               ;\n                        if ( ::strcmp(\"Nikon\",chars) == 0 ) {\n                            // tag is an embedded tiff\n                            byte* bytes=new byte[count-jump] ;  // allocate memory\n                            io.read(bytes,count-jump)        ;  // read\n                            MemIo memIo(bytes,count-jump)    ;  // create a file\n                            printTiffStructure(memIo,out,option,depth);\n                            delete[] bytes                   ;  // free\n                        } else {\n                            // tag is an IFD\n                            io.seek(0,BasicIo::beg);  // position\n                            printIFDStructure(io,out,option,offset,bSwap,c,depth);\n                        }\n\n                        io.seek(restore,BasicIo::beg); // restore\n                    }\n                }\n\n                if ( isPrintXMP(tag,option) ) {\n                    buf.pData_[count]=0;\n                    out << (char*) buf.pData_;\n                }\n                if ( isPrintICC(tag,option) ) {\n                    out.write((const char*)buf.pData_,count);\n                }\n            }\n            if ( start ) {\n                io.read(dir.pData_, 4);\n                start = tooBig ? 0 : byteSwap4(dir,0,bSwap);\n            }\n        } while (start) ;\n\n        if ( bPrint ) {\n            out << Internal::indent(depth) << \"END \" << io.path() << std::endl;\n        }\n        out.flush();\n        depth--;\n    }",
        "func": "void Image::printIFDStructure(BasicIo& io, std::ostream& out, Exiv2::PrintStructureOption option,uint32_t start,bool bSwap,char c,int depth)\n    {\n        depth++;\n        if ( depth == 1 ) visits.clear();\n        bool bFirst  = true  ;\n\n        // buffer\n        const size_t dirSize = 32;\n        DataBuf  dir(dirSize);\n        bool bPrint = option == kpsBasic || option == kpsRecursive;\n\n        do {\n            // Read top of directory\n            const int seekSuccess = !io.seek(start,BasicIo::beg);\n            const long bytesRead = io.read(dir.pData_, 2);\n            if (!seekSuccess || bytesRead == 0) {\n                throw Error(kerCorruptedMetadata);\n            }\n            uint16_t   dirLength = byteSwap2(dir,0,bSwap);\n            // Prevent infinite loops. (GHSA-m479-7frc-gqqg)\n            enforce(dirLength > 0, kerCorruptedMetadata);\n\n            bool tooBig = dirLength > 500;\n            if ( tooBig ) throw Error(kerTiffDirectoryTooLarge);\n\n            if ( bFirst && bPrint ) {\n                out << Internal::indent(depth) << Internal::stringFormat(\"STRUCTURE OF TIFF FILE (%c%c): \",c,c) << io.path() << std::endl;\n                if ( tooBig ) out << Internal::indent(depth) << \"dirLength = \" << dirLength << std::endl;\n            }\n\n            // Read the dictionary\n            for ( int i = 0 ; i < dirLength ; i ++ ) {\n                if ( visits.find(io.tell()) != visits.end()  ) { // #547\n                    throw Error(kerCorruptedMetadata);\n                }\n                visits.insert(io.tell());\n                \n                if ( bFirst && bPrint ) {\n                    out << Internal::indent(depth)\n                        << \" address |    tag                              |     \"\n                        << \" type |    count |    offset | value\\n\";\n                }\n                bFirst = false;\n\n                io.read(dir.pData_, 12);\n                uint16_t tag    = byteSwap2(dir,0,bSwap);\n                uint16_t type   = byteSwap2(dir,2,bSwap);\n                uint32_t count  = byteSwap4(dir,4,bSwap);\n                uint32_t offset = byteSwap4(dir,8,bSwap);\n\n                // Break for unknown tag types else we may segfault.\n                if ( !typeValid(type) ) {\n                    std::cerr << \"invalid type in tiff structure\" << type << std::endl;\n                    start = 0; // break from do loop\n                    throw Error(kerInvalidTypeValue);\n                }\n\n                std::string sp  = \"\" ; // output spacer\n\n                //prepare to print the value\n                uint32_t kount  = isPrintXMP(tag,option) ? count // haul in all the data\n                                : isPrintICC(tag,option) ? count // ditto\n                                : isStringType(type)     ? (count > 32 ? 32 : count) // restrict long arrays\n                                : count > 5              ? 5\n                                : count\n                                ;\n                uint32_t pad    = isStringType(type) ? 1 : 0;\n                uint32_t size   = isStringType(type) ? 1\n                                : is2ByteType(type)  ? 2\n                                : is4ByteType(type)  ? 4\n                                : is8ByteType(type)  ? 8\n                                : 1\n                                ;\n\n                // if ( offset > io.size() ) offset = 0; // Denial of service?\n\n                // #55 and #56 memory allocation crash test/data/POC8\n                long long allocate = (long long) size*count + pad+20;\n                if ( allocate > (long long) io.size() ) {\n                    throw Error(kerInvalidMalloc);\n                }\n                DataBuf  buf((long)allocate);  // allocate a buffer\n                std::memset(buf.pData_, 0, buf.size_);\n                std::memcpy(buf.pData_,dir.pData_+8,4);  // copy dir[8:11] into buffer (short strings)\n                const bool bOffsetIsPointer = count*size > 4;\n\n                if ( bOffsetIsPointer ) {         // read into buffer\n                    size_t   restore = io.tell();  // save\n                    io.seek(offset,BasicIo::beg);  // position\n                    io.read(buf.pData_,count*size);// read\n                    io.seek(restore,BasicIo::beg); // restore\n                }\n\n                if ( bPrint ) {\n                    const uint32_t address = start + 2 + i*12 ;\n                    const std::string offsetString = bOffsetIsPointer?\n                        Internal::stringFormat(\"%10u\", offset):\n                        \"\";\n\n                    out << Internal::indent(depth)\n                    << Internal::stringFormat(\"%8u | %#06x %-28s |%10s |%9u |%10s | \"\n                                              ,address,tag,tagName(tag).c_str(),typeName(type),count,offsetString.c_str());\n                    if ( isShortType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            out << sp << byteSwap2(buf,k*size,bSwap);\n                            sp = \" \";\n                        }\n                    } else if ( isLongType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            out << sp << byteSwap4(buf,k*size,bSwap);\n                            sp = \" \";\n                        }\n\n                    } else if ( isRationalType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            uint32_t a = byteSwap4(buf,k*size+0,bSwap);\n                            uint32_t b = byteSwap4(buf,k*size+4,bSwap);\n                            out << sp << a << \"/\" << b;\n                            sp = \" \";\n                        }\n                    } else if ( isStringType(type) ) {\n                        out << sp << Internal::binaryToString(makeSlice(buf, 0, kount));\n                    }\n\n                    sp = kount == count ? \"\" : \" ...\";\n                    out << sp << std::endl;\n\n                    if ( option == kpsRecursive && (tag == 0x8769 /* ExifTag */ || tag == 0x014a/*SubIFDs*/  || type == tiffIfd) ) {\n                        for ( size_t k = 0 ; k < count ; k++ ) {\n                            size_t   restore = io.tell();\n                            uint32_t offset = byteSwap4(buf,k*size,bSwap);\n                            printIFDStructure(io,out,option,offset,bSwap,c,depth);\n                            io.seek(restore,BasicIo::beg);\n                        }\n                    } else if ( option == kpsRecursive && tag == 0x83bb /* IPTCNAA */ ) {\n\n                        if (static_cast<size_t>(Safe::add(count, offset)) > io.size()) {\n                            throw Error(kerCorruptedMetadata);\n                        }\n\n                        const size_t restore = io.tell();\n                        io.seek(offset, BasicIo::beg);  // position\n                        std::vector<byte> bytes(count) ;  // allocate memory\n                        // TODO: once we have C++11 use bytes.data()\n                        const long read_bytes = io.read(&bytes[0], count);\n                        io.seek(restore, BasicIo::beg);\n                        // TODO: once we have C++11 use bytes.data()\n                        IptcData::printStructure(out, makeSliceUntil(&bytes[0], read_bytes), depth);\n\n                    }  else if ( option == kpsRecursive && tag == 0x927c /* MakerNote */ && count > 10) {\n                        size_t   restore = io.tell();  // save\n\n                        uint32_t jump= 10           ;\n                        byte     bytes[20]          ;\n                        const char* chars = (const char*) &bytes[0] ;\n                        io.seek(offset,BasicIo::beg);  // position\n                        io.read(bytes,jump    )     ;  // read\n                        bytes[jump]=0               ;\n                        if ( ::strcmp(\"Nikon\",chars) == 0 ) {\n                            // tag is an embedded tiff\n                            byte* bytes=new byte[count-jump] ;  // allocate memory\n                            io.read(bytes,count-jump)        ;  // read\n                            MemIo memIo(bytes,count-jump)    ;  // create a file\n                            printTiffStructure(memIo,out,option,depth);\n                            delete[] bytes                   ;  // free\n                        } else {\n                            // tag is an IFD\n                            io.seek(0,BasicIo::beg);  // position\n                            printIFDStructure(io,out,option,offset,bSwap,c,depth);\n                        }\n\n                        io.seek(restore,BasicIo::beg); // restore\n                    }\n                }\n\n                if ( isPrintXMP(tag,option) ) {\n                    buf.pData_[count]=0;\n                    out << (char*) buf.pData_;\n                }\n                if ( isPrintICC(tag,option) ) {\n                    out.write((const char*)buf.pData_,count);\n                }\n            }\n            if ( start ) {\n                io.read(dir.pData_, 4);\n                start = tooBig ? 0 : byteSwap4(dir,0,bSwap);\n            }\n        } while (start) ;\n\n        if ( bPrint ) {\n            out << Internal::indent(depth) << \"END \" << io.path() << std::endl;\n        }\n        out.flush();\n        depth--;\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,8 @@\n                 throw Error(kerCorruptedMetadata);\n             }\n             uint16_t   dirLength = byteSwap2(dir,0,bSwap);\n+            // Prevent infinite loops. (GHSA-m479-7frc-gqqg)\n+            enforce(dirLength > 0, kerCorruptedMetadata);\n \n             bool tooBig = dirLength > 500;\n             if ( tooBig ) throw Error(kerTiffDirectoryTooLarge);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            // Prevent infinite loops. (GHSA-m479-7frc-gqqg)",
                "            enforce(dirLength > 0, kerCorruptedMetadata);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-37621",
        "func_name": "Exiv2/exiv2/Image::printIFDStructure",
        "description": "Exiv2 is a command-line utility and C++ library for reading, writing, deleting, and modifying the metadata of image files. An infinite loop was found in Exiv2 versions v0.27.4 and earlier. The infinite loop is triggered when Exiv2 is used to print the metadata of a crafted image file. An attacker could potentially exploit the vulnerability to cause a denial of service, if they can trick the victim into running Exiv2 on a crafted image file. Note that this bug is only triggered when printing the image ICC profile, which is a less frequently used Exiv2 operation that requires an extra command line option (`-p C`). The bug is fixed in version v0.27.5.",
        "git_url": "https://github.com/Exiv2/exiv2/commit/d9fd4c4272df172ae89c0a9c41341adc75ebba86",
        "commit_title": "Defensive programming in Image::printIFDStructure",
        "commit_text": "",
        "func_before": "void Image::printIFDStructure(BasicIo& io, std::ostream& out, Exiv2::PrintStructureOption option,uint32_t start,bool bSwap,char c,int depth)\n    {\n        depth++;\n        if ( depth == 1 ) visits.clear();\n        bool bFirst  = true  ;\n\n        // buffer\n        const size_t dirSize = 32;\n        DataBuf  dir(dirSize);\n        bool bPrint = option == kpsBasic || option == kpsRecursive;\n\n        do {\n            // Read top of directory\n            const int seekSuccess = !io.seek(start,BasicIo::beg);\n            const long bytesRead = io.read(dir.pData_, 2);\n            if (!seekSuccess || bytesRead == 0) {\n                throw Error(kerCorruptedMetadata);\n            }\n            uint16_t   dirLength = byteSwap2(dir,0,bSwap);\n            // Prevent infinite loops. (GHSA-m479-7frc-gqqg)\n            enforce(dirLength > 0, kerCorruptedMetadata);\n\n            bool tooBig = dirLength > 500;\n            if ( tooBig ) throw Error(kerTiffDirectoryTooLarge);\n\n            if ( bFirst && bPrint ) {\n                out << Internal::indent(depth) << Internal::stringFormat(\"STRUCTURE OF TIFF FILE (%c%c): \",c,c) << io.path() << std::endl;\n                if ( tooBig ) out << Internal::indent(depth) << \"dirLength = \" << dirLength << std::endl;\n            }\n\n            // Read the dictionary\n            for ( int i = 0 ; i < dirLength ; i ++ ) {\n                if ( visits.find(io.tell()) != visits.end()  ) { // #547\n                    throw Error(kerCorruptedMetadata);\n                }\n                visits.insert(io.tell());\n                \n                if ( bFirst && bPrint ) {\n                    out << Internal::indent(depth)\n                        << \" address |    tag                              |     \"\n                        << \" type |    count |    offset | value\\n\";\n                }\n                bFirst = false;\n\n                io.read(dir.pData_, 12);\n                uint16_t tag    = byteSwap2(dir,0,bSwap);\n                uint16_t type   = byteSwap2(dir,2,bSwap);\n                uint32_t count  = byteSwap4(dir,4,bSwap);\n                uint32_t offset = byteSwap4(dir,8,bSwap);\n\n                // Break for unknown tag types else we may segfault.\n                if ( !typeValid(type) ) {\n                    std::cerr << \"invalid type in tiff structure\" << type << std::endl;\n                    start = 0; // break from do loop\n                    throw Error(kerInvalidTypeValue);\n                }\n\n                std::string sp  = \"\" ; // output spacer\n\n                //prepare to print the value\n                uint32_t kount  = isPrintXMP(tag,option) ? count // haul in all the data\n                                : isPrintICC(tag,option) ? count // ditto\n                                : isStringType(type)     ? (count > 32 ? 32 : count) // restrict long arrays\n                                : count > 5              ? 5\n                                : count\n                                ;\n                uint32_t pad    = isStringType(type) ? 1 : 0;\n                uint32_t size   = isStringType(type) ? 1\n                                : is2ByteType(type)  ? 2\n                                : is4ByteType(type)  ? 4\n                                : is8ByteType(type)  ? 8\n                                : 1\n                                ;\n\n                // if ( offset > io.size() ) offset = 0; // Denial of service?\n\n                // #55 and #56 memory allocation crash test/data/POC8\n                long long allocate = (long long) size*count + pad+20;\n                if ( allocate > (long long) io.size() ) {\n                    throw Error(kerInvalidMalloc);\n                }\n                DataBuf  buf((long)allocate);  // allocate a buffer\n                std::memset(buf.pData_, 0, buf.size_);\n                std::memcpy(buf.pData_,dir.pData_+8,4);  // copy dir[8:11] into buffer (short strings)\n                const bool bOffsetIsPointer = count*size > 4;\n\n                if ( bOffsetIsPointer ) {         // read into buffer\n                    size_t   restore = io.tell();  // save\n                    io.seek(offset,BasicIo::beg);  // position\n                    io.read(buf.pData_,count*size);// read\n                    io.seek(restore,BasicIo::beg); // restore\n                }\n\n                if ( bPrint ) {\n                    const uint32_t address = start + 2 + i*12 ;\n                    const std::string offsetString = bOffsetIsPointer?\n                        Internal::stringFormat(\"%10u\", offset):\n                        \"\";\n\n                    out << Internal::indent(depth)\n                    << Internal::stringFormat(\"%8u | %#06x %-28s |%10s |%9u |%10s | \"\n                                              ,address,tag,tagName(tag).c_str(),typeName(type),count,offsetString.c_str());\n                    if ( isShortType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            out << sp << byteSwap2(buf,k*size,bSwap);\n                            sp = \" \";\n                        }\n                    } else if ( isLongType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            out << sp << byteSwap4(buf,k*size,bSwap);\n                            sp = \" \";\n                        }\n\n                    } else if ( isRationalType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            uint32_t a = byteSwap4(buf,k*size+0,bSwap);\n                            uint32_t b = byteSwap4(buf,k*size+4,bSwap);\n                            out << sp << a << \"/\" << b;\n                            sp = \" \";\n                        }\n                    } else if ( isStringType(type) ) {\n                        out << sp << Internal::binaryToString(makeSlice(buf, 0, kount));\n                    }\n\n                    sp = kount == count ? \"\" : \" ...\";\n                    out << sp << std::endl;\n\n                    if ( option == kpsRecursive && (tag == 0x8769 /* ExifTag */ || tag == 0x014a/*SubIFDs*/  || type == tiffIfd) ) {\n                        for ( size_t k = 0 ; k < count ; k++ ) {\n                            size_t   restore = io.tell();\n                            uint32_t offset = byteSwap4(buf,k*size,bSwap);\n                            printIFDStructure(io,out,option,offset,bSwap,c,depth);\n                            io.seek(restore,BasicIo::beg);\n                        }\n                    } else if ( option == kpsRecursive && tag == 0x83bb /* IPTCNAA */ ) {\n\n                        if (static_cast<size_t>(Safe::add(count, offset)) > io.size()) {\n                            throw Error(kerCorruptedMetadata);\n                        }\n\n                        const size_t restore = io.tell();\n                        io.seek(offset, BasicIo::beg);  // position\n                        std::vector<byte> bytes(count) ;  // allocate memory\n                        // TODO: once we have C++11 use bytes.data()\n                        const long read_bytes = io.read(&bytes[0], count);\n                        io.seek(restore, BasicIo::beg);\n                        // TODO: once we have C++11 use bytes.data()\n                        IptcData::printStructure(out, makeSliceUntil(&bytes[0], read_bytes), depth);\n\n                    }  else if ( option == kpsRecursive && tag == 0x927c /* MakerNote */ && count > 10) {\n                        size_t   restore = io.tell();  // save\n\n                        uint32_t jump= 10           ;\n                        byte     bytes[20]          ;\n                        const char* chars = (const char*) &bytes[0] ;\n                        io.seek(offset,BasicIo::beg);  // position\n                        io.read(bytes,jump    )     ;  // read\n                        bytes[jump]=0               ;\n                        if ( ::strcmp(\"Nikon\",chars) == 0 ) {\n                            // tag is an embedded tiff\n                            byte* bytes=new byte[count-jump] ;  // allocate memory\n                            io.read(bytes,count-jump)        ;  // read\n                            MemIo memIo(bytes,count-jump)    ;  // create a file\n                            printTiffStructure(memIo,out,option,depth);\n                            delete[] bytes                   ;  // free\n                        } else {\n                            // tag is an IFD\n                            io.seek(0,BasicIo::beg);  // position\n                            printIFDStructure(io,out,option,offset,bSwap,c,depth);\n                        }\n\n                        io.seek(restore,BasicIo::beg); // restore\n                    }\n                }\n\n                if ( isPrintXMP(tag,option) ) {\n                    buf.pData_[count]=0;\n                    out << (char*) buf.pData_;\n                }\n                if ( isPrintICC(tag,option) ) {\n                    out.write((const char*)buf.pData_,count);\n                }\n            }\n            if ( start ) {\n                io.read(dir.pData_, 4);\n                start = tooBig ? 0 : byteSwap4(dir,0,bSwap);\n            }\n        } while (start) ;\n\n        if ( bPrint ) {\n            out << Internal::indent(depth) << \"END \" << io.path() << std::endl;\n        }\n        out.flush();\n        depth--;\n    }",
        "func": "void Image::printIFDStructure(BasicIo& io, std::ostream& out, Exiv2::PrintStructureOption option,uint32_t start,bool bSwap,char c,int depth)\n    {\n        depth++;\n        if ( depth == 1 ) visits.clear();\n        bool bFirst  = true  ;\n\n        // buffer\n        const size_t dirSize = 32;\n        DataBuf  dir(dirSize);\n        bool bPrint = option == kpsBasic || option == kpsRecursive;\n\n        do {\n            // Read top of directory\n            seekOrThrow(io, start, BasicIo::beg, kerCorruptedMetadata);\n            readOrThrow(io, dir.pData_, 2, kerCorruptedMetadata);\n            uint16_t   dirLength = byteSwap2(dir,0,bSwap);\n            // Prevent infinite loops. (GHSA-m479-7frc-gqqg)\n            enforce(dirLength > 0, kerCorruptedMetadata);\n\n            bool tooBig = dirLength > 500;\n            if ( tooBig ) throw Error(kerTiffDirectoryTooLarge);\n\n            if ( bFirst && bPrint ) {\n                out << Internal::indent(depth) << Internal::stringFormat(\"STRUCTURE OF TIFF FILE (%c%c): \",c,c) << io.path() << std::endl;\n                if ( tooBig ) out << Internal::indent(depth) << \"dirLength = \" << dirLength << std::endl;\n            }\n\n            // Read the dictionary\n            for ( int i = 0 ; i < dirLength ; i ++ ) {\n                if ( visits.find(io.tell()) != visits.end()  ) { // #547\n                    throw Error(kerCorruptedMetadata);\n                }\n                visits.insert(io.tell());\n                \n                if ( bFirst && bPrint ) {\n                    out << Internal::indent(depth)\n                        << \" address |    tag                              |     \"\n                        << \" type |    count |    offset | value\\n\";\n                }\n                bFirst = false;\n\n                readOrThrow(io, dir.pData_, 12, kerCorruptedMetadata);\n                uint16_t tag    = byteSwap2(dir,0,bSwap);\n                uint16_t type   = byteSwap2(dir,2,bSwap);\n                uint32_t count  = byteSwap4(dir,4,bSwap);\n                uint32_t offset = byteSwap4(dir,8,bSwap);\n\n                // Break for unknown tag types else we may segfault.\n                if ( !typeValid(type) ) {\n                    std::cerr << \"invalid type in tiff structure\" << type << std::endl;\n                    start = 0; // break from do loop\n                    throw Error(kerInvalidTypeValue);\n                }\n\n                std::string sp  = \"\" ; // output spacer\n\n                //prepare to print the value\n                uint32_t kount  = isPrintXMP(tag,option) ? count // haul in all the data\n                                : isPrintICC(tag,option) ? count // ditto\n                                : isStringType(type)     ? (count > 32 ? 32 : count) // restrict long arrays\n                                : count > 5              ? 5\n                                : count\n                                ;\n                uint32_t pad    = isStringType(type) ? 1 : 0;\n                uint32_t size   = isStringType(type) ? 1\n                                : is2ByteType(type)  ? 2\n                                : is4ByteType(type)  ? 4\n                                : is8ByteType(type)  ? 8\n                                : 1\n                                ;\n\n                // if ( offset > io.size() ) offset = 0; // Denial of service?\n\n                // #55 and #56 memory allocation crash test/data/POC8\n                const uint64_t allocate64 = static_cast<uint64_t>(size) * count + pad + 20;\n                if ( allocate64 > io.size() ) {\n                    throw Error(kerInvalidMalloc);\n                }\n                // Overflow check\n                enforce(allocate64 <= static_cast<uint64_t>(std::numeric_limits<uint32_t>::max()), kerCorruptedMetadata);\n                enforce(allocate64 <= static_cast<uint64_t>(std::numeric_limits<long>::max()), kerCorruptedMetadata);\n                const long allocate = static_cast<long>(allocate64);\n                DataBuf  buf(allocate);  // allocate a buffer\n                std::memset(buf.pData_, 0, buf.size_);\n                std::memcpy(buf.pData_,dir.pData_+8,4);  // copy dir[8:11] into buffer (short strings)\n\n                // We have already checked that this multiplication cannot overflow.\n                const uint32_t count_x_size = count*size;\n                const bool bOffsetIsPointer = count_x_size > 4;\n\n                if ( bOffsetIsPointer ) {         // read into buffer\n                    const long restore = io.tell(); // save\n                    seekOrThrow(io, offset, BasicIo::beg, kerCorruptedMetadata); // position\n                    readOrThrow(io, buf.pData_, static_cast<long>(count_x_size), kerCorruptedMetadata); // read\n                    seekOrThrow(io, restore, BasicIo::beg, kerCorruptedMetadata); // restore\n                }\n\n                if ( bPrint ) {\n                    const uint32_t address = start + 2 + i*12 ;\n                    const std::string offsetString = bOffsetIsPointer?\n                        Internal::stringFormat(\"%10u\", offset):\n                        \"\";\n\n                    out << Internal::indent(depth)\n                    << Internal::stringFormat(\"%8u | %#06x %-28s |%10s |%9u |%10s | \"\n                                              ,address,tag,tagName(tag).c_str(),typeName(type),count,offsetString.c_str());\n                    if ( isShortType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            out << sp << byteSwap2(buf,k*size,bSwap);\n                            sp = \" \";\n                        }\n                    } else if ( isLongType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            out << sp << byteSwap4(buf,k*size,bSwap);\n                            sp = \" \";\n                        }\n\n                    } else if ( isRationalType(type) ){\n                        for ( size_t k = 0 ; k < kount ; k++ ) {\n                            uint32_t a = byteSwap4(buf,k*size+0,bSwap);\n                            uint32_t b = byteSwap4(buf,k*size+4,bSwap);\n                            out << sp << a << \"/\" << b;\n                            sp = \" \";\n                        }\n                    } else if ( isStringType(type) ) {\n                        out << sp << Internal::binaryToString(makeSlice(buf, 0, kount));\n                    }\n\n                    sp = kount == count ? \"\" : \" ...\";\n                    out << sp << std::endl;\n\n                    if ( option == kpsRecursive && (tag == 0x8769 /* ExifTag */ || tag == 0x014a/*SubIFDs*/  || type == tiffIfd) ) {\n                        for ( size_t k = 0 ; k < count ; k++ ) {\n                            const long restore = io.tell();\n                            uint32_t offset = byteSwap4(buf,k*size,bSwap);\n                            printIFDStructure(io,out,option,offset,bSwap,c,depth);\n                            seekOrThrow(io, restore, BasicIo::beg, kerCorruptedMetadata);\n                        }\n                    } else if ( option == kpsRecursive && tag == 0x83bb /* IPTCNAA */ ) {\n\n                        if (static_cast<size_t>(Safe::add(count, offset)) > io.size()) {\n                            throw Error(kerCorruptedMetadata);\n                        }\n\n                        const long restore = io.tell();\n                        seekOrThrow(io, offset, BasicIo::beg, kerCorruptedMetadata);  // position\n                        std::vector<byte> bytes(count) ;  // allocate memory\n                        // TODO: once we have C++11 use bytes.data()\n                        readOrThrow(io, &bytes[0], count, kerCorruptedMetadata);\n                        seekOrThrow(io, restore, BasicIo::beg, kerCorruptedMetadata);\n                        // TODO: once we have C++11 use bytes.data()\n                        IptcData::printStructure(out, makeSliceUntil(&bytes[0], count), depth);\n\n                    }  else if ( option == kpsRecursive && tag == 0x927c /* MakerNote */ && count > 10) {\n                        const long restore = io.tell();  // save\n\n                        uint32_t jump= 10           ;\n                        byte     bytes[20]          ;\n                        const char* chars = (const char*) &bytes[0] ;\n                        seekOrThrow(io, offset, BasicIo::beg, kerCorruptedMetadata);  // position\n                        readOrThrow(io, bytes, jump, kerCorruptedMetadata)     ;  // read\n                        bytes[jump]=0               ;\n                        if ( ::strcmp(\"Nikon\",chars) == 0 ) {\n                            // tag is an embedded tiff\n                            const long byteslen = count-jump;\n                            DataBuf bytes(byteslen);  // allocate a buffer\n                            readOrThrow(io, bytes.pData_, byteslen, kerCorruptedMetadata);  // read\n                            MemIo memIo(bytes.pData_, byteslen)    ;  // create a file\n                            printTiffStructure(memIo,out,option,depth);\n                        } else {\n                            // tag is an IFD\n                            seekOrThrow(io, 0, BasicIo::beg, kerCorruptedMetadata);  // position\n                            printIFDStructure(io,out,option,offset,bSwap,c,depth);\n                        }\n\n                        seekOrThrow(io, restore, BasicIo::beg, kerCorruptedMetadata); // restore\n                    }\n                }\n\n                if ( isPrintXMP(tag,option) ) {\n                    buf.pData_[count]=0;\n                    out << (char*) buf.pData_;\n                }\n                if ( isPrintICC(tag,option) ) {\n                    out.write((const char*)buf.pData_,count);\n                }\n            }\n            if ( start ) {\n                readOrThrow(io, dir.pData_, 4, kerCorruptedMetadata);\n                start = tooBig ? 0 : byteSwap4(dir,0,bSwap);\n            }\n        } while (start) ;\n\n        if ( bPrint ) {\n            out << Internal::indent(depth) << \"END \" << io.path() << std::endl;\n        }\n        out.flush();\n        depth--;\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,11 +11,8 @@\n \n         do {\n             // Read top of directory\n-            const int seekSuccess = !io.seek(start,BasicIo::beg);\n-            const long bytesRead = io.read(dir.pData_, 2);\n-            if (!seekSuccess || bytesRead == 0) {\n-                throw Error(kerCorruptedMetadata);\n-            }\n+            seekOrThrow(io, start, BasicIo::beg, kerCorruptedMetadata);\n+            readOrThrow(io, dir.pData_, 2, kerCorruptedMetadata);\n             uint16_t   dirLength = byteSwap2(dir,0,bSwap);\n             // Prevent infinite loops. (GHSA-m479-7frc-gqqg)\n             enforce(dirLength > 0, kerCorruptedMetadata);\n@@ -42,7 +39,7 @@\n                 }\n                 bFirst = false;\n \n-                io.read(dir.pData_, 12);\n+                readOrThrow(io, dir.pData_, 12, kerCorruptedMetadata);\n                 uint16_t tag    = byteSwap2(dir,0,bSwap);\n                 uint16_t type   = byteSwap2(dir,2,bSwap);\n                 uint32_t count  = byteSwap4(dir,4,bSwap);\n@@ -75,20 +72,27 @@\n                 // if ( offset > io.size() ) offset = 0; // Denial of service?\n \n                 // #55 and #56 memory allocation crash test/data/POC8\n-                long long allocate = (long long) size*count + pad+20;\n-                if ( allocate > (long long) io.size() ) {\n+                const uint64_t allocate64 = static_cast<uint64_t>(size) * count + pad + 20;\n+                if ( allocate64 > io.size() ) {\n                     throw Error(kerInvalidMalloc);\n                 }\n-                DataBuf  buf((long)allocate);  // allocate a buffer\n+                // Overflow check\n+                enforce(allocate64 <= static_cast<uint64_t>(std::numeric_limits<uint32_t>::max()), kerCorruptedMetadata);\n+                enforce(allocate64 <= static_cast<uint64_t>(std::numeric_limits<long>::max()), kerCorruptedMetadata);\n+                const long allocate = static_cast<long>(allocate64);\n+                DataBuf  buf(allocate);  // allocate a buffer\n                 std::memset(buf.pData_, 0, buf.size_);\n                 std::memcpy(buf.pData_,dir.pData_+8,4);  // copy dir[8:11] into buffer (short strings)\n-                const bool bOffsetIsPointer = count*size > 4;\n+\n+                // We have already checked that this multiplication cannot overflow.\n+                const uint32_t count_x_size = count*size;\n+                const bool bOffsetIsPointer = count_x_size > 4;\n \n                 if ( bOffsetIsPointer ) {         // read into buffer\n-                    size_t   restore = io.tell();  // save\n-                    io.seek(offset,BasicIo::beg);  // position\n-                    io.read(buf.pData_,count*size);// read\n-                    io.seek(restore,BasicIo::beg); // restore\n+                    const long restore = io.tell(); // save\n+                    seekOrThrow(io, offset, BasicIo::beg, kerCorruptedMetadata); // position\n+                    readOrThrow(io, buf.pData_, static_cast<long>(count_x_size), kerCorruptedMetadata); // read\n+                    seekOrThrow(io, restore, BasicIo::beg, kerCorruptedMetadata); // restore\n                 }\n \n                 if ( bPrint ) {\n@@ -127,10 +131,10 @@\n \n                     if ( option == kpsRecursive && (tag == 0x8769 /* ExifTag */ || tag == 0x014a/*SubIFDs*/  || type == tiffIfd) ) {\n                         for ( size_t k = 0 ; k < count ; k++ ) {\n-                            size_t   restore = io.tell();\n+                            const long restore = io.tell();\n                             uint32_t offset = byteSwap4(buf,k*size,bSwap);\n                             printIFDStructure(io,out,option,offset,bSwap,c,depth);\n-                            io.seek(restore,BasicIo::beg);\n+                            seekOrThrow(io, restore, BasicIo::beg, kerCorruptedMetadata);\n                         }\n                     } else if ( option == kpsRecursive && tag == 0x83bb /* IPTCNAA */ ) {\n \n@@ -138,38 +142,38 @@\n                             throw Error(kerCorruptedMetadata);\n                         }\n \n-                        const size_t restore = io.tell();\n-                        io.seek(offset, BasicIo::beg);  // position\n+                        const long restore = io.tell();\n+                        seekOrThrow(io, offset, BasicIo::beg, kerCorruptedMetadata);  // position\n                         std::vector<byte> bytes(count) ;  // allocate memory\n                         // TODO: once we have C++11 use bytes.data()\n-                        const long read_bytes = io.read(&bytes[0], count);\n-                        io.seek(restore, BasicIo::beg);\n+                        readOrThrow(io, &bytes[0], count, kerCorruptedMetadata);\n+                        seekOrThrow(io, restore, BasicIo::beg, kerCorruptedMetadata);\n                         // TODO: once we have C++11 use bytes.data()\n-                        IptcData::printStructure(out, makeSliceUntil(&bytes[0], read_bytes), depth);\n+                        IptcData::printStructure(out, makeSliceUntil(&bytes[0], count), depth);\n \n                     }  else if ( option == kpsRecursive && tag == 0x927c /* MakerNote */ && count > 10) {\n-                        size_t   restore = io.tell();  // save\n+                        const long restore = io.tell();  // save\n \n                         uint32_t jump= 10           ;\n                         byte     bytes[20]          ;\n                         const char* chars = (const char*) &bytes[0] ;\n-                        io.seek(offset,BasicIo::beg);  // position\n-                        io.read(bytes,jump    )     ;  // read\n+                        seekOrThrow(io, offset, BasicIo::beg, kerCorruptedMetadata);  // position\n+                        readOrThrow(io, bytes, jump, kerCorruptedMetadata)     ;  // read\n                         bytes[jump]=0               ;\n                         if ( ::strcmp(\"Nikon\",chars) == 0 ) {\n                             // tag is an embedded tiff\n-                            byte* bytes=new byte[count-jump] ;  // allocate memory\n-                            io.read(bytes,count-jump)        ;  // read\n-                            MemIo memIo(bytes,count-jump)    ;  // create a file\n+                            const long byteslen = count-jump;\n+                            DataBuf bytes(byteslen);  // allocate a buffer\n+                            readOrThrow(io, bytes.pData_, byteslen, kerCorruptedMetadata);  // read\n+                            MemIo memIo(bytes.pData_, byteslen)    ;  // create a file\n                             printTiffStructure(memIo,out,option,depth);\n-                            delete[] bytes                   ;  // free\n                         } else {\n                             // tag is an IFD\n-                            io.seek(0,BasicIo::beg);  // position\n+                            seekOrThrow(io, 0, BasicIo::beg, kerCorruptedMetadata);  // position\n                             printIFDStructure(io,out,option,offset,bSwap,c,depth);\n                         }\n \n-                        io.seek(restore,BasicIo::beg); // restore\n+                        seekOrThrow(io, restore, BasicIo::beg, kerCorruptedMetadata); // restore\n                     }\n                 }\n \n@@ -182,7 +186,7 @@\n                 }\n             }\n             if ( start ) {\n-                io.read(dir.pData_, 4);\n+                readOrThrow(io, dir.pData_, 4, kerCorruptedMetadata);\n                 start = tooBig ? 0 : byteSwap4(dir,0,bSwap);\n             }\n         } while (start) ;",
        "diff_line_info": {
            "deleted_lines": [
                "            const int seekSuccess = !io.seek(start,BasicIo::beg);",
                "            const long bytesRead = io.read(dir.pData_, 2);",
                "            if (!seekSuccess || bytesRead == 0) {",
                "                throw Error(kerCorruptedMetadata);",
                "            }",
                "                io.read(dir.pData_, 12);",
                "                long long allocate = (long long) size*count + pad+20;",
                "                if ( allocate > (long long) io.size() ) {",
                "                DataBuf  buf((long)allocate);  // allocate a buffer",
                "                const bool bOffsetIsPointer = count*size > 4;",
                "                    size_t   restore = io.tell();  // save",
                "                    io.seek(offset,BasicIo::beg);  // position",
                "                    io.read(buf.pData_,count*size);// read",
                "                    io.seek(restore,BasicIo::beg); // restore",
                "                            size_t   restore = io.tell();",
                "                            io.seek(restore,BasicIo::beg);",
                "                        const size_t restore = io.tell();",
                "                        io.seek(offset, BasicIo::beg);  // position",
                "                        const long read_bytes = io.read(&bytes[0], count);",
                "                        io.seek(restore, BasicIo::beg);",
                "                        IptcData::printStructure(out, makeSliceUntil(&bytes[0], read_bytes), depth);",
                "                        size_t   restore = io.tell();  // save",
                "                        io.seek(offset,BasicIo::beg);  // position",
                "                        io.read(bytes,jump    )     ;  // read",
                "                            byte* bytes=new byte[count-jump] ;  // allocate memory",
                "                            io.read(bytes,count-jump)        ;  // read",
                "                            MemIo memIo(bytes,count-jump)    ;  // create a file",
                "                            delete[] bytes                   ;  // free",
                "                            io.seek(0,BasicIo::beg);  // position",
                "                        io.seek(restore,BasicIo::beg); // restore",
                "                io.read(dir.pData_, 4);"
            ],
            "added_lines": [
                "            seekOrThrow(io, start, BasicIo::beg, kerCorruptedMetadata);",
                "            readOrThrow(io, dir.pData_, 2, kerCorruptedMetadata);",
                "                readOrThrow(io, dir.pData_, 12, kerCorruptedMetadata);",
                "                const uint64_t allocate64 = static_cast<uint64_t>(size) * count + pad + 20;",
                "                if ( allocate64 > io.size() ) {",
                "                // Overflow check",
                "                enforce(allocate64 <= static_cast<uint64_t>(std::numeric_limits<uint32_t>::max()), kerCorruptedMetadata);",
                "                enforce(allocate64 <= static_cast<uint64_t>(std::numeric_limits<long>::max()), kerCorruptedMetadata);",
                "                const long allocate = static_cast<long>(allocate64);",
                "                DataBuf  buf(allocate);  // allocate a buffer",
                "",
                "                // We have already checked that this multiplication cannot overflow.",
                "                const uint32_t count_x_size = count*size;",
                "                const bool bOffsetIsPointer = count_x_size > 4;",
                "                    const long restore = io.tell(); // save",
                "                    seekOrThrow(io, offset, BasicIo::beg, kerCorruptedMetadata); // position",
                "                    readOrThrow(io, buf.pData_, static_cast<long>(count_x_size), kerCorruptedMetadata); // read",
                "                    seekOrThrow(io, restore, BasicIo::beg, kerCorruptedMetadata); // restore",
                "                            const long restore = io.tell();",
                "                            seekOrThrow(io, restore, BasicIo::beg, kerCorruptedMetadata);",
                "                        const long restore = io.tell();",
                "                        seekOrThrow(io, offset, BasicIo::beg, kerCorruptedMetadata);  // position",
                "                        readOrThrow(io, &bytes[0], count, kerCorruptedMetadata);",
                "                        seekOrThrow(io, restore, BasicIo::beg, kerCorruptedMetadata);",
                "                        IptcData::printStructure(out, makeSliceUntil(&bytes[0], count), depth);",
                "                        const long restore = io.tell();  // save",
                "                        seekOrThrow(io, offset, BasicIo::beg, kerCorruptedMetadata);  // position",
                "                        readOrThrow(io, bytes, jump, kerCorruptedMetadata)     ;  // read",
                "                            const long byteslen = count-jump;",
                "                            DataBuf bytes(byteslen);  // allocate a buffer",
                "                            readOrThrow(io, bytes.pData_, byteslen, kerCorruptedMetadata);  // read",
                "                            MemIo memIo(bytes.pData_, byteslen)    ;  // create a file",
                "                            seekOrThrow(io, 0, BasicIo::beg, kerCorruptedMetadata);  // position",
                "                        seekOrThrow(io, restore, BasicIo::beg, kerCorruptedMetadata); // restore",
                "                readOrThrow(io, dir.pData_, 4, kerCorruptedMetadata);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-37621",
        "func_name": "Exiv2/exiv2/Image::printTiffStructure",
        "description": "Exiv2 is a command-line utility and C++ library for reading, writing, deleting, and modifying the metadata of image files. An infinite loop was found in Exiv2 versions v0.27.4 and earlier. The infinite loop is triggered when Exiv2 is used to print the metadata of a crafted image file. An attacker could potentially exploit the vulnerability to cause a denial of service, if they can trick the victim into running Exiv2 on a crafted image file. Note that this bug is only triggered when printing the image ICC profile, which is a less frequently used Exiv2 operation that requires an extra command line option (`-p C`). The bug is fixed in version v0.27.5.",
        "git_url": "https://github.com/Exiv2/exiv2/commit/d9fd4c4272df172ae89c0a9c41341adc75ebba86",
        "commit_title": "Defensive programming in Image::printIFDStructure",
        "commit_text": "",
        "func_before": "void Image::printTiffStructure(BasicIo& io, std::ostream& out, Exiv2::PrintStructureOption option,int depth,size_t offset /*=0*/)\n    {\n        if ( option == kpsBasic || option == kpsXMP || option == kpsRecursive || option == kpsIccProfile ) {\n            // buffer\n            const size_t dirSize = 32;\n            DataBuf  dir(dirSize);\n\n            // read header (we already know for certain that we have a Tiff file)\n            io.read(dir.pData_,  8);\n            char c = (char) dir.pData_[0] ;\n            bool bSwap   = ( c == 'M' && isLittleEndianPlatform() )\n                        || ( c == 'I' && isBigEndianPlatform()    )\n                        ;\n            uint32_t start = byteSwap4(dir,4,bSwap);\n            printIFDStructure(io,out,option,start+(uint32_t)offset,bSwap,c,depth);\n        }\n    }",
        "func": "void Image::printTiffStructure(BasicIo& io, std::ostream& out, Exiv2::PrintStructureOption option,int depth,size_t offset /*=0*/)\n    {\n        if ( option == kpsBasic || option == kpsXMP || option == kpsRecursive || option == kpsIccProfile ) {\n            // buffer\n            const size_t dirSize = 32;\n            DataBuf  dir(dirSize);\n\n            // read header (we already know for certain that we have a Tiff file)\n            readOrThrow(io, dir.pData_,  8, kerCorruptedMetadata);\n            char c = (char) dir.pData_[0] ;\n            bool bSwap   = ( c == 'M' && isLittleEndianPlatform() )\n                        || ( c == 'I' && isBigEndianPlatform()    )\n                        ;\n            uint32_t start = byteSwap4(dir,4,bSwap);\n            printIFDStructure(io,out,option,start+(uint32_t)offset,bSwap,c,depth);\n        }\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n             DataBuf  dir(dirSize);\n \n             // read header (we already know for certain that we have a Tiff file)\n-            io.read(dir.pData_,  8);\n+            readOrThrow(io, dir.pData_,  8, kerCorruptedMetadata);\n             char c = (char) dir.pData_[0] ;\n             bool bSwap   = ( c == 'M' && isLittleEndianPlatform() )\n                         || ( c == 'I' && isBigEndianPlatform()    )",
        "diff_line_info": {
            "deleted_lines": [
                "            io.read(dir.pData_,  8);"
            ],
            "added_lines": [
                "            readOrThrow(io, dir.pData_,  8, kerCorruptedMetadata);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-37622",
        "func_name": "Exiv2/exiv2/JpegBase::printStructure",
        "description": "Exiv2 is a command-line utility and C++ library for reading, writing, deleting, and modifying the metadata of image files. An infinite loop was found in Exiv2 versions v0.27.4 and earlier. The infinite loop is triggered when Exiv2 is used to modify the metadata of a crafted image file. An attacker could potentially exploit the vulnerability to cause a denial of service, if they can trick the victim into running Exiv2 on a crafted image file. Note that this bug is only triggered when deleting the IPTC data, which is a less frequently used Exiv2 operation that requires an extra command line option (`-d I rm`). The bug is fixed in version v0.27.5.",
        "git_url": "https://github.com/Exiv2/exiv2/commit/19026fab2bc2b6dee2150f38153feb65a41cea17",
        "commit_title": "Remove redundant check.",
        "commit_text": "",
        "func_before": "void JpegBase::printStructure(std::ostream& out, PrintStructureOption option, int depth)\n    {\n        if (io_->open() != 0)\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        // Ensure that this is the correct image type\n        if (!isThisType(*io_, false)) {\n            if (io_->error() || io_->eof())\n                throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAJpeg);\n        }\n\n        bool bPrint = option == kpsBasic || option == kpsRecursive;\n        Exiv2::Uint32Vector iptcDataSegs;\n\n        if (bPrint || option == kpsXMP || option == kpsIccProfile || option == kpsIptcErase) {\n            // nmonic for markers\n            std::string nm[256];\n            nm[0xd8] = \"SOI\";\n            nm[0xd9] = \"EOI\";\n            nm[0xda] = \"SOS\";\n            nm[0xdb] = \"DQT\";\n            nm[0xdd] = \"DRI\";\n            nm[0xfe] = \"COM\";\n\n            // 0xe0 .. 0xef are APPn\n            // 0xc0 .. 0xcf are SOFn (except 4)\n            nm[0xc4] = \"DHT\";\n            for (int i = 0; i <= 15; i++) {\n                char MN[16];\n                /// \\todo to be replaced by std::snprintf on master (only available in c++11)\n                sprintf(MN, \"APP%d\", i);\n                nm[0xe0 + i] = MN;\n                if (i != 4) {\n                    sprintf(MN, \"SOF%d\", i);\n                    nm[0xc0 + i] = MN;\n                }\n            }\n\n            // which markers have a length field?\n            bool mHasLength[256];\n            for (int i = 0; i < 256; i++)\n                mHasLength[i] = (i >= sof0_ && i <= sof15_) || (i >= app0_ && i <= (app0_ | 0x0F)) ||\n                                (i == dht_ || i == dqt_ || i == dri_ || i == com_ || i == sos_);\n\n            // Container for the signature\n            bool bExtXMP = false;\n            long bufRead = 0;\n            const long bufMinSize = 36;\n            DataBuf buf(bufMinSize);\n\n            // Read section marker\n            int marker = advanceToMarker();\n            if (marker < 0)\n                throw Error(kerNotAJpeg);\n\n            bool done = false;\n            bool first = true;\n            while (!done) {\n                // print marker bytes\n                if (first && bPrint) {\n                    out << \"STRUCTURE OF JPEG FILE: \" << io_->path() << std::endl;\n                    out << \" address | marker       |  length | data\" << std::endl;\n                    REPORT_MARKER;\n                }\n                first = false;\n                bool bLF = bPrint;\n\n                // Read size and signature\n                std::memset(buf.pData_, 0x0, buf.size_);\n                bufRead = io_->read(buf.pData_, bufMinSize);\n                if (io_->error() || bufRead != bufMinSize)\n                    throw Error(kerFailedToReadImageData);\n                if (bufRead < 2)\n                    throw Error(kerNotAJpeg);\n                const uint16_t size = mHasLength[marker] ? getUShort(buf.pData_, bigEndian) : 0;\n                if (bPrint && mHasLength[marker])\n                    out << Internal::stringFormat(\" | %7d \", size);\n\n                // print signature for APPn\n                if (marker >= app0_ && marker <= (app0_ | 0x0F)) {\n                    // http://www.adobe.com/content/dam/Adobe/en/devnet/xmp/pdfs/XMPSpecificationPart3.pdf p75\n                    const std::string signature =\n                        string_from_unterminated(reinterpret_cast<const char*>(buf.pData_ + 2), buf.size_ - 2);\n\n                    // 728 rmills@rmillsmbp:~/gnu/exiv2/ttt $ exiv2 -pS test/data/exiv2-bug922.jpg\n                    // STRUCTURE OF JPEG FILE: test/data/exiv2-bug922.jpg\n                    // address | marker     | length  | data\n                    //       0 | 0xd8 SOI   |       0\n                    //       2 | 0xe1 APP1  |     911 | Exif..MM.*.......%.........#....\n                    //     915 | 0xe1 APP1  |     870 | http://ns.adobe.com/xap/1.0/.<x:\n                    //    1787 | 0xe1 APP1  |   65460 | http://ns.adobe.com/xmp/extensio\n                    if (option == kpsXMP && signature.rfind(\"http://ns.adobe.com/x\", 0) == 0) {\n                        // extract XMP\n                        if (size > 0) {\n                            io_->seek(-bufRead, BasicIo::cur);\n                            std::vector<byte> xmp(size + 1);\n                            io_->read(&xmp[0], size);\n                            int start = 0;\n\n                            // http://wwwimages.adobe.com/content/dam/Adobe/en/devnet/xmp/pdfs/XMPSpecificationPart3.pdf\n                            // if we find HasExtendedXMP, set the flag and ignore this block\n                            // the first extended block is a copy of the Standard block.\n                            // a robust implementation allows extended blocks to be out of sequence\n                            // we could implement out of sequence with a dictionary of sequence/offset\n                            // and dumping the XMP in a post read operation similar to kpsIptcErase\n                            // for the moment, dumping 'on the fly' is working fine\n                            if (!bExtXMP) {\n                                while (xmp.at(start)) {\n                                    start++;\n                                }\n                                start++;\n                                const std::string xmp_from_start = string_from_unterminated(\n                                    reinterpret_cast<const char*>(&xmp.at(start)), size - start);\n                                if (xmp_from_start.find(\"HasExtendedXMP\", start) != xmp_from_start.npos) {\n                                    start = size;  // ignore this packet, we'll get on the next time around\n                                    bExtXMP = true;\n                                }\n                            } else {\n                                start = 2 + 35 + 32 + 4 + 4;  // Adobe Spec, p19\n                            }\n\n                            out.write(reinterpret_cast<const char*>(&xmp.at(start)), size - start);\n                            bufRead = size;\n                            done = !bExtXMP;\n                        }\n                    } else if (option == kpsIccProfile && signature.compare(iccId_) == 0) {\n                        // extract ICCProfile\n                        if (size > 0) {\n                            io_->seek(-bufRead, BasicIo::cur);  // back to buffer (after marker)\n                            io_->seek(14 + 2, BasicIo::cur);    // step over header\n                            DataBuf icc(size - (14 + 2));\n                            io_->read(icc.pData_, icc.size_);\n                            out.write(reinterpret_cast<const char*>(icc.pData_), icc.size_);\n#ifdef EXIV2_DEBUG_MESSAGES\n                            std::cout << \"iccProfile size = \" << icc.size_ << std::endl;\n#endif\n                            bufRead = size;\n                        }\n                    } else if (option == kpsIptcErase && signature.compare(\"Photoshop 3.0\") == 0) {\n                        // delete IPTC data segment from JPEG\n                        if (size > 0) {\n                            io_->seek(-bufRead, BasicIo::cur);\n                            iptcDataSegs.push_back(io_->tell());\n                            iptcDataSegs.push_back(size);\n                        }\n                    } else if (bPrint) {\n                        const size_t start = size > 0 ? 2 : 0;\n                        const size_t end = start + (size > 32 ? 32 : size);\n                        out << \"| \" << Internal::binaryToString(makeSlice(buf, start, end));\n                        if (signature.compare(iccId_) == 0) {\n                            // extract the chunk information from the buffer\n                            //\n                            // the buffer looks like this in this branch\n                            // ICC_PROFILE\\0AB\n                            // where A & B are bytes (the variables chunk & chunks)\n                            //\n                            // We cannot extract the variables A and B from the signature string, as they are beyond the\n                            // null termination (and signature ends there).\n                            // => Read the chunk info from the DataBuf directly\n                            enforce<std::out_of_range>(buf.size_ - 2 > 14, \"Buffer too small to extract chunk information.\");\n                            const int chunk = buf.pData_[2 + 12];\n                            const int chunks = buf.pData_[2 + 13];\n                            out << Internal::stringFormat(\" chunk %d/%d\", chunk, chunks);\n                        }\n                    }\n\n                    // for MPF: http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/MPF.html\n                    // for FLIR: http://owl.phy.queensu.ca/~phil/exiftool/TagNames/FLIR.html\n                    bool bFlir = option == kpsRecursive && marker == (app0_ + 1) && signature.compare(\"FLIR\") == 0;\n                    bool bExif = option == kpsRecursive && marker == (app0_ + 1) && signature.compare(\"Exif\") == 0;\n                    bool bMPF = option == kpsRecursive && marker == (app0_ + 2) && signature.compare(\"MPF\") == 0;\n                    bool bPS = option == kpsRecursive && signature.compare(\"Photoshop 3.0\") == 0;\n                    if (bFlir || bExif || bMPF || bPS) {\n                        // extract Exif data block which is tiff formatted\n                        if (size > 0) {\n                            out << std::endl;\n\n                            // allocate storage and current file position\n                            byte* exif = new byte[size];\n                            uint32_t restore = io_->tell();\n\n                            // copy the data to memory\n                            io_->seek(-bufRead, BasicIo::cur);\n                            io_->read(exif, size);\n                            uint32_t start = signature.compare(\"Exif\") == 0 ? 8 : 6;\n                            uint32_t max = (uint32_t)size - 1;\n\n                            // is this an fff block?\n                            if (bFlir) {\n                                start = 0;\n                                bFlir = false;\n                                while (start < max) {\n                                    if (std::strcmp((const char*)(exif + start), \"FFF\") == 0) {\n                                        bFlir = true;\n                                        break;\n                                    }\n                                    start++;\n                                }\n                            }\n\n                            // there is a header in FLIR, followed by a tiff block\n                            // Hunt down the tiff using brute force\n                            if (bFlir) {\n                                // FLIRFILEHEAD* pFFF = (FLIRFILEHEAD*) (exif+start) ;\n                                while (start < max) {\n                                    if (exif[start] == 'I' && exif[start + 1] == 'I')\n                                        break;\n                                    if (exif[start] == 'M' && exif[start + 1] == 'M')\n                                        break;\n                                    start++;\n                                }\n                                if (start < max)\n                                    std::cout << \"  FFF start = \" << start << std::endl;\n                                // << \" index = \" << pFFF->dwIndexOff << std::endl;\n                            }\n\n                            if (bPS) {\n                                IptcData::printStructure(out, makeSlice(exif, 0, size), depth);\n                            } else {\n                                // create a copy on write memio object with the data, then print the structure\n                                BasicIo::AutoPtr p = BasicIo::AutoPtr(new MemIo(exif + start, size - start));\n                                if (start < max)\n                                    printTiffStructure(*p, out, option, depth);\n                            }\n\n                            // restore and clean up\n                            io_->seek(restore, Exiv2::BasicIo::beg);\n                            delete[] exif;\n                            bLF = false;\n                        }\n                    }\n                }\n\n                // print COM marker\n                if (bPrint && marker == com_) {\n                    // size includes 2 for the two bytes for size!\n                    const int n = (size - 2) > 32 ? 32 : size - 2;\n                    // start after the two bytes\n                    out << \"| \"\n                        << Internal::binaryToString(\n                               makeSlice(buf, 2, n + 2 /* cannot overflow as n is at most size - 2 */));\n                }\n\n                // Skip the segment if the size is known\n                if (io_->seek(size - bufRead, BasicIo::cur))\n                    throw Error(kerFailedToReadImageData);\n\n                if (bLF)\n                    out << std::endl;\n\n                if (marker != sos_) {\n                    // Read the beginning of the next segment\n                    marker = advanceToMarker();\n                    enforce(marker>=0, kerNoImageInInputData);\n                    REPORT_MARKER;\n                }\n                done |= marker == eoi_ || marker == sos_;\n                if (done && bPrint)\n                    out << std::endl;\n            }\n        }\n        if (option == kpsIptcErase && iptcDataSegs.size()) {\n#ifdef EXIV2_DEBUG_MESSAGES\n            std::cout << \"iptc data blocks: \" << iptcDataSegs.size() << std::endl;\n            uint32_t toggle = 0;\n            for (Uint32Vector_i i = iptcDataSegs.begin(); i != iptcDataSegs.end(); i++) {\n                std::cout << *i;\n                if (toggle++ % 2)\n                    std::cout << std::endl;\n                else\n                    std::cout << ' ';\n            }\n#endif\n            uint32_t count = (uint32_t)iptcDataSegs.size();\n\n            // figure out which blocks to copy\n            uint64_t* pos = new uint64_t[count + 2];\n            pos[0] = 0;\n            // copy the data that is not iptc\n            Uint32Vector_i it = iptcDataSegs.begin();\n            for (uint64_t i = 0; i < count; i++) {\n                bool bOdd = (i % 2) != 0;\n                bool bEven = !bOdd;\n                pos[i + 1] = bEven ? *it : pos[i] + *it;\n                ++it;\n            }\n            pos[count + 1] = io_->size() - pos[count];\n#ifdef EXIV2_DEBUG_MESSAGES\n            for (uint64_t i = 0; i < count + 2; i++)\n                std::cout << pos[i] << \" \";\n            std::cout << std::endl;\n#endif\n            // $ dd bs=1 skip=$((0)) count=$((13164)) if=ETH0138028.jpg of=E1.jpg\n            // $ dd bs=1 skip=$((49304)) count=2000000  if=ETH0138028.jpg of=E2.jpg\n            // cat E1.jpg E2.jpg > E.jpg\n            // exiv2 -pS E.jpg\n\n            // binary copy io_ to a temporary file\n            BasicIo::AutoPtr tempIo(new MemIo);\n\n            assert(tempIo.get() != 0);\n            for (uint64_t i = 0; i < (count / 2) + 1; i++) {\n                uint64_t start = pos[2 * i] + 2;  // step JPG 2 byte marker\n                if (start == 2)\n                    start = 0;  // read the file 2 byte SOI\n                long length = (long)(pos[2 * i + 1] - start);\n                if (length) {\n#ifdef EXIV2_DEBUG_MESSAGES\n                    std::cout << start << \":\" << length << std::endl;\n#endif\n                    io_->seek(start, BasicIo::beg);\n                    DataBuf buf(length);\n                    io_->read(buf.pData_, buf.size_);\n                    tempIo->write(buf.pData_, buf.size_);\n                }\n            }\n            delete[] pos;\n\n            io_->seek(0, BasicIo::beg);\n            io_->transfer(*tempIo);  // may throw\n            io_->seek(0, BasicIo::beg);\n            readMetadata();\n        }\n    }",
        "func": "void JpegBase::printStructure(std::ostream& out, PrintStructureOption option, int depth)\n    {\n        if (io_->open() != 0)\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        // Ensure that this is the correct image type\n        if (!isThisType(*io_, false)) {\n            if (io_->error() || io_->eof())\n                throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAJpeg);\n        }\n\n        bool bPrint = option == kpsBasic || option == kpsRecursive;\n        Exiv2::Uint32Vector iptcDataSegs;\n\n        if (bPrint || option == kpsXMP || option == kpsIccProfile || option == kpsIptcErase) {\n            // nmonic for markers\n            std::string nm[256];\n            nm[0xd8] = \"SOI\";\n            nm[0xd9] = \"EOI\";\n            nm[0xda] = \"SOS\";\n            nm[0xdb] = \"DQT\";\n            nm[0xdd] = \"DRI\";\n            nm[0xfe] = \"COM\";\n\n            // 0xe0 .. 0xef are APPn\n            // 0xc0 .. 0xcf are SOFn (except 4)\n            nm[0xc4] = \"DHT\";\n            for (int i = 0; i <= 15; i++) {\n                char MN[16];\n                /// \\todo to be replaced by std::snprintf on master (only available in c++11)\n                sprintf(MN, \"APP%d\", i);\n                nm[0xe0 + i] = MN;\n                if (i != 4) {\n                    sprintf(MN, \"SOF%d\", i);\n                    nm[0xc0 + i] = MN;\n                }\n            }\n\n            // which markers have a length field?\n            bool mHasLength[256];\n            for (int i = 0; i < 256; i++)\n                mHasLength[i] = (i >= sof0_ && i <= sof15_) || (i >= app0_ && i <= (app0_ | 0x0F)) ||\n                                (i == dht_ || i == dqt_ || i == dri_ || i == com_ || i == sos_);\n\n            // Container for the signature\n            bool bExtXMP = false;\n            long bufRead = 0;\n            const long bufMinSize = 36;\n            DataBuf buf(bufMinSize);\n\n            // Read section marker\n            int marker = advanceToMarker();\n            if (marker < 0)\n                throw Error(kerNotAJpeg);\n\n            bool done = false;\n            bool first = true;\n            while (!done) {\n                // print marker bytes\n                if (first && bPrint) {\n                    out << \"STRUCTURE OF JPEG FILE: \" << io_->path() << std::endl;\n                    out << \" address | marker       |  length | data\" << std::endl;\n                    REPORT_MARKER;\n                }\n                first = false;\n                bool bLF = bPrint;\n\n                // Read size and signature\n                std::memset(buf.pData_, 0x0, buf.size_);\n                bufRead = io_->read(buf.pData_, bufMinSize);\n                if (io_->error() || bufRead != bufMinSize)\n                    throw Error(kerFailedToReadImageData);\n                const uint16_t size = mHasLength[marker] ? getUShort(buf.pData_, bigEndian) : 0;\n                if (bPrint && mHasLength[marker])\n                    out << Internal::stringFormat(\" | %7d \", size);\n\n                // print signature for APPn\n                if (marker >= app0_ && marker <= (app0_ | 0x0F)) {\n                    // http://www.adobe.com/content/dam/Adobe/en/devnet/xmp/pdfs/XMPSpecificationPart3.pdf p75\n                    const std::string signature =\n                        string_from_unterminated(reinterpret_cast<const char*>(buf.pData_ + 2), buf.size_ - 2);\n\n                    // 728 rmills@rmillsmbp:~/gnu/exiv2/ttt $ exiv2 -pS test/data/exiv2-bug922.jpg\n                    // STRUCTURE OF JPEG FILE: test/data/exiv2-bug922.jpg\n                    // address | marker     | length  | data\n                    //       0 | 0xd8 SOI   |       0\n                    //       2 | 0xe1 APP1  |     911 | Exif..MM.*.......%.........#....\n                    //     915 | 0xe1 APP1  |     870 | http://ns.adobe.com/xap/1.0/.<x:\n                    //    1787 | 0xe1 APP1  |   65460 | http://ns.adobe.com/xmp/extensio\n                    if (option == kpsXMP && signature.rfind(\"http://ns.adobe.com/x\", 0) == 0) {\n                        // extract XMP\n                        if (size > 0) {\n                            io_->seek(-bufRead, BasicIo::cur);\n                            std::vector<byte> xmp(size + 1);\n                            io_->read(&xmp[0], size);\n                            int start = 0;\n\n                            // http://wwwimages.adobe.com/content/dam/Adobe/en/devnet/xmp/pdfs/XMPSpecificationPart3.pdf\n                            // if we find HasExtendedXMP, set the flag and ignore this block\n                            // the first extended block is a copy of the Standard block.\n                            // a robust implementation allows extended blocks to be out of sequence\n                            // we could implement out of sequence with a dictionary of sequence/offset\n                            // and dumping the XMP in a post read operation similar to kpsIptcErase\n                            // for the moment, dumping 'on the fly' is working fine\n                            if (!bExtXMP) {\n                                while (xmp.at(start)) {\n                                    start++;\n                                }\n                                start++;\n                                const std::string xmp_from_start = string_from_unterminated(\n                                    reinterpret_cast<const char*>(&xmp.at(start)), size - start);\n                                if (xmp_from_start.find(\"HasExtendedXMP\", start) != xmp_from_start.npos) {\n                                    start = size;  // ignore this packet, we'll get on the next time around\n                                    bExtXMP = true;\n                                }\n                            } else {\n                                start = 2 + 35 + 32 + 4 + 4;  // Adobe Spec, p19\n                            }\n\n                            out.write(reinterpret_cast<const char*>(&xmp.at(start)), size - start);\n                            bufRead = size;\n                            done = !bExtXMP;\n                        }\n                    } else if (option == kpsIccProfile && signature.compare(iccId_) == 0) {\n                        // extract ICCProfile\n                        if (size > 0) {\n                            io_->seek(-bufRead, BasicIo::cur);  // back to buffer (after marker)\n                            io_->seek(14 + 2, BasicIo::cur);    // step over header\n                            DataBuf icc(size - (14 + 2));\n                            io_->read(icc.pData_, icc.size_);\n                            out.write(reinterpret_cast<const char*>(icc.pData_), icc.size_);\n#ifdef EXIV2_DEBUG_MESSAGES\n                            std::cout << \"iccProfile size = \" << icc.size_ << std::endl;\n#endif\n                            bufRead = size;\n                        }\n                    } else if (option == kpsIptcErase && signature.compare(\"Photoshop 3.0\") == 0) {\n                        // delete IPTC data segment from JPEG\n                        if (size > 0) {\n                            io_->seek(-bufRead, BasicIo::cur);\n                            iptcDataSegs.push_back(io_->tell());\n                            iptcDataSegs.push_back(size);\n                        }\n                    } else if (bPrint) {\n                        const size_t start = size > 0 ? 2 : 0;\n                        const size_t end = start + (size > 32 ? 32 : size);\n                        out << \"| \" << Internal::binaryToString(makeSlice(buf, start, end));\n                        if (signature.compare(iccId_) == 0) {\n                            // extract the chunk information from the buffer\n                            //\n                            // the buffer looks like this in this branch\n                            // ICC_PROFILE\\0AB\n                            // where A & B are bytes (the variables chunk & chunks)\n                            //\n                            // We cannot extract the variables A and B from the signature string, as they are beyond the\n                            // null termination (and signature ends there).\n                            // => Read the chunk info from the DataBuf directly\n                            enforce<std::out_of_range>(buf.size_ - 2 > 14, \"Buffer too small to extract chunk information.\");\n                            const int chunk = buf.pData_[2 + 12];\n                            const int chunks = buf.pData_[2 + 13];\n                            out << Internal::stringFormat(\" chunk %d/%d\", chunk, chunks);\n                        }\n                    }\n\n                    // for MPF: http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/MPF.html\n                    // for FLIR: http://owl.phy.queensu.ca/~phil/exiftool/TagNames/FLIR.html\n                    bool bFlir = option == kpsRecursive && marker == (app0_ + 1) && signature.compare(\"FLIR\") == 0;\n                    bool bExif = option == kpsRecursive && marker == (app0_ + 1) && signature.compare(\"Exif\") == 0;\n                    bool bMPF = option == kpsRecursive && marker == (app0_ + 2) && signature.compare(\"MPF\") == 0;\n                    bool bPS = option == kpsRecursive && signature.compare(\"Photoshop 3.0\") == 0;\n                    if (bFlir || bExif || bMPF || bPS) {\n                        // extract Exif data block which is tiff formatted\n                        if (size > 0) {\n                            out << std::endl;\n\n                            // allocate storage and current file position\n                            byte* exif = new byte[size];\n                            uint32_t restore = io_->tell();\n\n                            // copy the data to memory\n                            io_->seek(-bufRead, BasicIo::cur);\n                            io_->read(exif, size);\n                            uint32_t start = signature.compare(\"Exif\") == 0 ? 8 : 6;\n                            uint32_t max = (uint32_t)size - 1;\n\n                            // is this an fff block?\n                            if (bFlir) {\n                                start = 0;\n                                bFlir = false;\n                                while (start < max) {\n                                    if (std::strcmp((const char*)(exif + start), \"FFF\") == 0) {\n                                        bFlir = true;\n                                        break;\n                                    }\n                                    start++;\n                                }\n                            }\n\n                            // there is a header in FLIR, followed by a tiff block\n                            // Hunt down the tiff using brute force\n                            if (bFlir) {\n                                // FLIRFILEHEAD* pFFF = (FLIRFILEHEAD*) (exif+start) ;\n                                while (start < max) {\n                                    if (exif[start] == 'I' && exif[start + 1] == 'I')\n                                        break;\n                                    if (exif[start] == 'M' && exif[start + 1] == 'M')\n                                        break;\n                                    start++;\n                                }\n                                if (start < max)\n                                    std::cout << \"  FFF start = \" << start << std::endl;\n                                // << \" index = \" << pFFF->dwIndexOff << std::endl;\n                            }\n\n                            if (bPS) {\n                                IptcData::printStructure(out, makeSlice(exif, 0, size), depth);\n                            } else {\n                                // create a copy on write memio object with the data, then print the structure\n                                BasicIo::AutoPtr p = BasicIo::AutoPtr(new MemIo(exif + start, size - start));\n                                if (start < max)\n                                    printTiffStructure(*p, out, option, depth);\n                            }\n\n                            // restore and clean up\n                            io_->seek(restore, Exiv2::BasicIo::beg);\n                            delete[] exif;\n                            bLF = false;\n                        }\n                    }\n                }\n\n                // print COM marker\n                if (bPrint && marker == com_) {\n                    // size includes 2 for the two bytes for size!\n                    const int n = (size - 2) > 32 ? 32 : size - 2;\n                    // start after the two bytes\n                    out << \"| \"\n                        << Internal::binaryToString(\n                               makeSlice(buf, 2, n + 2 /* cannot overflow as n is at most size - 2 */));\n                }\n\n                // Skip the segment if the size is known\n                if (io_->seek(size - bufRead, BasicIo::cur))\n                    throw Error(kerFailedToReadImageData);\n\n                if (bLF)\n                    out << std::endl;\n\n                if (marker != sos_) {\n                    // Read the beginning of the next segment\n                    marker = advanceToMarker();\n                    enforce(marker>=0, kerNoImageInInputData);\n                    REPORT_MARKER;\n                }\n                done |= marker == eoi_ || marker == sos_;\n                if (done && bPrint)\n                    out << std::endl;\n            }\n        }\n        if (option == kpsIptcErase && iptcDataSegs.size()) {\n#ifdef EXIV2_DEBUG_MESSAGES\n            std::cout << \"iptc data blocks: \" << iptcDataSegs.size() << std::endl;\n            uint32_t toggle = 0;\n            for (Uint32Vector_i i = iptcDataSegs.begin(); i != iptcDataSegs.end(); i++) {\n                std::cout << *i;\n                if (toggle++ % 2)\n                    std::cout << std::endl;\n                else\n                    std::cout << ' ';\n            }\n#endif\n            uint32_t count = (uint32_t)iptcDataSegs.size();\n\n            // figure out which blocks to copy\n            uint64_t* pos = new uint64_t[count + 2];\n            pos[0] = 0;\n            // copy the data that is not iptc\n            Uint32Vector_i it = iptcDataSegs.begin();\n            for (uint64_t i = 0; i < count; i++) {\n                bool bOdd = (i % 2) != 0;\n                bool bEven = !bOdd;\n                pos[i + 1] = bEven ? *it : pos[i] + *it;\n                ++it;\n            }\n            pos[count + 1] = io_->size() - pos[count];\n#ifdef EXIV2_DEBUG_MESSAGES\n            for (uint64_t i = 0; i < count + 2; i++)\n                std::cout << pos[i] << \" \";\n            std::cout << std::endl;\n#endif\n            // $ dd bs=1 skip=$((0)) count=$((13164)) if=ETH0138028.jpg of=E1.jpg\n            // $ dd bs=1 skip=$((49304)) count=2000000  if=ETH0138028.jpg of=E2.jpg\n            // cat E1.jpg E2.jpg > E.jpg\n            // exiv2 -pS E.jpg\n\n            // binary copy io_ to a temporary file\n            BasicIo::AutoPtr tempIo(new MemIo);\n\n            assert(tempIo.get() != 0);\n            for (uint64_t i = 0; i < (count / 2) + 1; i++) {\n                uint64_t start = pos[2 * i] + 2;  // step JPG 2 byte marker\n                if (start == 2)\n                    start = 0;  // read the file 2 byte SOI\n                long length = (long)(pos[2 * i + 1] - start);\n                if (length) {\n#ifdef EXIV2_DEBUG_MESSAGES\n                    std::cout << start << \":\" << length << std::endl;\n#endif\n                    io_->seek(start, BasicIo::beg);\n                    DataBuf buf(length);\n                    io_->read(buf.pData_, buf.size_);\n                    tempIo->write(buf.pData_, buf.size_);\n                }\n            }\n            delete[] pos;\n\n            io_->seek(0, BasicIo::beg);\n            io_->transfer(*tempIo);  // may throw\n            io_->seek(0, BasicIo::beg);\n            readMetadata();\n        }\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -70,8 +70,6 @@\n                 bufRead = io_->read(buf.pData_, bufMinSize);\n                 if (io_->error() || bufRead != bufMinSize)\n                     throw Error(kerFailedToReadImageData);\n-                if (bufRead < 2)\n-                    throw Error(kerNotAJpeg);\n                 const uint16_t size = mHasLength[marker] ? getUShort(buf.pData_, bigEndian) : 0;\n                 if (bPrint && mHasLength[marker])\n                     out << Internal::stringFormat(\" | %7d \", size);",
        "diff_line_info": {
            "deleted_lines": [
                "                if (bufRead < 2)",
                "                    throw Error(kerNotAJpeg);"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2021-37622",
        "func_name": "Exiv2/exiv2/JpegBase::printStructure",
        "description": "Exiv2 is a command-line utility and C++ library for reading, writing, deleting, and modifying the metadata of image files. An infinite loop was found in Exiv2 versions v0.27.4 and earlier. The infinite loop is triggered when Exiv2 is used to modify the metadata of a crafted image file. An attacker could potentially exploit the vulnerability to cause a denial of service, if they can trick the victim into running Exiv2 on a crafted image file. Note that this bug is only triggered when deleting the IPTC data, which is a less frequently used Exiv2 operation that requires an extra command line option (`-d I rm`). The bug is fixed in version v0.27.5.",
        "git_url": "https://github.com/Exiv2/exiv2/commit/ffe5eb517dad93845e62144d8e53f52b17420ecd",
        "commit_title": "Make sure that read is complete to prevent infinite loop.",
        "commit_text": "",
        "func_before": "void JpegBase::printStructure(std::ostream& out, PrintStructureOption option, int depth)\n    {\n        if (io_->open() != 0)\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        // Ensure that this is the correct image type\n        if (!isThisType(*io_, false)) {\n            if (io_->error() || io_->eof())\n                throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAJpeg);\n        }\n\n        bool bPrint = option == kpsBasic || option == kpsRecursive;\n        Exiv2::Uint32Vector iptcDataSegs;\n\n        if (bPrint || option == kpsXMP || option == kpsIccProfile || option == kpsIptcErase) {\n            // nmonic for markers\n            std::string nm[256];\n            nm[0xd8] = \"SOI\";\n            nm[0xd9] = \"EOI\";\n            nm[0xda] = \"SOS\";\n            nm[0xdb] = \"DQT\";\n            nm[0xdd] = \"DRI\";\n            nm[0xfe] = \"COM\";\n\n            // 0xe0 .. 0xef are APPn\n            // 0xc0 .. 0xcf are SOFn (except 4)\n            nm[0xc4] = \"DHT\";\n            for (int i = 0; i <= 15; i++) {\n                char MN[16];\n                /// \\todo to be replaced by std::snprintf on master (only available in c++11)\n                sprintf(MN, \"APP%d\", i);\n                nm[0xe0 + i] = MN;\n                if (i != 4) {\n                    sprintf(MN, \"SOF%d\", i);\n                    nm[0xc0 + i] = MN;\n                }\n            }\n\n            // which markers have a length field?\n            bool mHasLength[256];\n            for (int i = 0; i < 256; i++)\n                mHasLength[i] = (i >= sof0_ && i <= sof15_) || (i >= app0_ && i <= (app0_ | 0x0F)) ||\n                                (i == dht_ || i == dqt_ || i == dri_ || i == com_ || i == sos_);\n\n            // Container for the signature\n            bool bExtXMP = false;\n            long bufRead = 0;\n            const long bufMinSize = 36;\n            DataBuf buf(bufMinSize);\n\n            // Read section marker\n            int marker = advanceToMarker();\n            if (marker < 0)\n                throw Error(kerNotAJpeg);\n\n            bool done = false;\n            bool first = true;\n            while (!done) {\n                // print marker bytes\n                if (first && bPrint) {\n                    out << \"STRUCTURE OF JPEG FILE: \" << io_->path() << std::endl;\n                    out << \" address | marker       |  length | data\" << std::endl;\n                    REPORT_MARKER;\n                }\n                first = false;\n                bool bLF = bPrint;\n\n                // Read size and signature\n                std::memset(buf.pData_, 0x0, buf.size_);\n                bufRead = io_->read(buf.pData_, bufMinSize);\n                if (io_->error())\n                    throw Error(kerFailedToReadImageData);\n                if (bufRead < 2)\n                    throw Error(kerNotAJpeg);\n                const uint16_t size = mHasLength[marker] ? getUShort(buf.pData_, bigEndian) : 0;\n                if (bPrint && mHasLength[marker])\n                    out << Internal::stringFormat(\" | %7d \", size);\n\n                // print signature for APPn\n                if (marker >= app0_ && marker <= (app0_ | 0x0F)) {\n                    // http://www.adobe.com/content/dam/Adobe/en/devnet/xmp/pdfs/XMPSpecificationPart3.pdf p75\n                    const std::string signature =\n                        string_from_unterminated(reinterpret_cast<const char*>(buf.pData_ + 2), buf.size_ - 2);\n\n                    // 728 rmills@rmillsmbp:~/gnu/exiv2/ttt $ exiv2 -pS test/data/exiv2-bug922.jpg\n                    // STRUCTURE OF JPEG FILE: test/data/exiv2-bug922.jpg\n                    // address | marker     | length  | data\n                    //       0 | 0xd8 SOI   |       0\n                    //       2 | 0xe1 APP1  |     911 | Exif..MM.*.......%.........#....\n                    //     915 | 0xe1 APP1  |     870 | http://ns.adobe.com/xap/1.0/.<x:\n                    //    1787 | 0xe1 APP1  |   65460 | http://ns.adobe.com/xmp/extensio\n                    if (option == kpsXMP && signature.rfind(\"http://ns.adobe.com/x\", 0) == 0) {\n                        // extract XMP\n                        if (size > 0) {\n                            io_->seek(-bufRead, BasicIo::cur);\n                            std::vector<byte> xmp(size + 1);\n                            io_->read(&xmp[0], size);\n                            int start = 0;\n\n                            // http://wwwimages.adobe.com/content/dam/Adobe/en/devnet/xmp/pdfs/XMPSpecificationPart3.pdf\n                            // if we find HasExtendedXMP, set the flag and ignore this block\n                            // the first extended block is a copy of the Standard block.\n                            // a robust implementation allows extended blocks to be out of sequence\n                            // we could implement out of sequence with a dictionary of sequence/offset\n                            // and dumping the XMP in a post read operation similar to kpsIptcErase\n                            // for the moment, dumping 'on the fly' is working fine\n                            if (!bExtXMP) {\n                                while (xmp.at(start)) {\n                                    start++;\n                                }\n                                start++;\n                                const std::string xmp_from_start = string_from_unterminated(\n                                    reinterpret_cast<const char*>(&xmp.at(start)), size - start);\n                                if (xmp_from_start.find(\"HasExtendedXMP\", start) != xmp_from_start.npos) {\n                                    start = size;  // ignore this packet, we'll get on the next time around\n                                    bExtXMP = true;\n                                }\n                            } else {\n                                start = 2 + 35 + 32 + 4 + 4;  // Adobe Spec, p19\n                            }\n\n                            out.write(reinterpret_cast<const char*>(&xmp.at(start)), size - start);\n                            bufRead = size;\n                            done = !bExtXMP;\n                        }\n                    } else if (option == kpsIccProfile && signature.compare(iccId_) == 0) {\n                        // extract ICCProfile\n                        if (size > 0) {\n                            io_->seek(-bufRead, BasicIo::cur);  // back to buffer (after marker)\n                            io_->seek(14 + 2, BasicIo::cur);    // step over header\n                            DataBuf icc(size - (14 + 2));\n                            io_->read(icc.pData_, icc.size_);\n                            out.write(reinterpret_cast<const char*>(icc.pData_), icc.size_);\n#ifdef EXIV2_DEBUG_MESSAGES\n                            std::cout << \"iccProfile size = \" << icc.size_ << std::endl;\n#endif\n                            bufRead = size;\n                        }\n                    } else if (option == kpsIptcErase && signature.compare(\"Photoshop 3.0\") == 0) {\n                        // delete IPTC data segment from JPEG\n                        if (size > 0) {\n                            io_->seek(-bufRead, BasicIo::cur);\n                            iptcDataSegs.push_back(io_->tell());\n                            iptcDataSegs.push_back(size);\n                        }\n                    } else if (bPrint) {\n                        const size_t start = size > 0 ? 2 : 0;\n                        const size_t end = start + (size > 32 ? 32 : size);\n                        out << \"| \" << Internal::binaryToString(makeSlice(buf, start, end));\n                        if (signature.compare(iccId_) == 0) {\n                            // extract the chunk information from the buffer\n                            //\n                            // the buffer looks like this in this branch\n                            // ICC_PROFILE\\0AB\n                            // where A & B are bytes (the variables chunk & chunks)\n                            //\n                            // We cannot extract the variables A and B from the signature string, as they are beyond the\n                            // null termination (and signature ends there).\n                            // => Read the chunk info from the DataBuf directly\n                            enforce<std::out_of_range>(buf.size_ - 2 > 14, \"Buffer too small to extract chunk information.\");\n                            const int chunk = buf.pData_[2 + 12];\n                            const int chunks = buf.pData_[2 + 13];\n                            out << Internal::stringFormat(\" chunk %d/%d\", chunk, chunks);\n                        }\n                    }\n\n                    // for MPF: http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/MPF.html\n                    // for FLIR: http://owl.phy.queensu.ca/~phil/exiftool/TagNames/FLIR.html\n                    bool bFlir = option == kpsRecursive && marker == (app0_ + 1) && signature.compare(\"FLIR\") == 0;\n                    bool bExif = option == kpsRecursive && marker == (app0_ + 1) && signature.compare(\"Exif\") == 0;\n                    bool bMPF = option == kpsRecursive && marker == (app0_ + 2) && signature.compare(\"MPF\") == 0;\n                    bool bPS = option == kpsRecursive && signature.compare(\"Photoshop 3.0\") == 0;\n                    if (bFlir || bExif || bMPF || bPS) {\n                        // extract Exif data block which is tiff formatted\n                        if (size > 0) {\n                            out << std::endl;\n\n                            // allocate storage and current file position\n                            byte* exif = new byte[size];\n                            uint32_t restore = io_->tell();\n\n                            // copy the data to memory\n                            io_->seek(-bufRead, BasicIo::cur);\n                            io_->read(exif, size);\n                            uint32_t start = signature.compare(\"Exif\") == 0 ? 8 : 6;\n                            uint32_t max = (uint32_t)size - 1;\n\n                            // is this an fff block?\n                            if (bFlir) {\n                                start = 0;\n                                bFlir = false;\n                                while (start < max) {\n                                    if (std::strcmp((const char*)(exif + start), \"FFF\") == 0) {\n                                        bFlir = true;\n                                        break;\n                                    }\n                                    start++;\n                                }\n                            }\n\n                            // there is a header in FLIR, followed by a tiff block\n                            // Hunt down the tiff using brute force\n                            if (bFlir) {\n                                // FLIRFILEHEAD* pFFF = (FLIRFILEHEAD*) (exif+start) ;\n                                while (start < max) {\n                                    if (exif[start] == 'I' && exif[start + 1] == 'I')\n                                        break;\n                                    if (exif[start] == 'M' && exif[start + 1] == 'M')\n                                        break;\n                                    start++;\n                                }\n                                if (start < max)\n                                    std::cout << \"  FFF start = \" << start << std::endl;\n                                // << \" index = \" << pFFF->dwIndexOff << std::endl;\n                            }\n\n                            if (bPS) {\n                                IptcData::printStructure(out, makeSlice(exif, 0, size), depth);\n                            } else {\n                                // create a copy on write memio object with the data, then print the structure\n                                BasicIo::AutoPtr p = BasicIo::AutoPtr(new MemIo(exif + start, size - start));\n                                if (start < max)\n                                    printTiffStructure(*p, out, option, depth);\n                            }\n\n                            // restore and clean up\n                            io_->seek(restore, Exiv2::BasicIo::beg);\n                            delete[] exif;\n                            bLF = false;\n                        }\n                    }\n                }\n\n                // print COM marker\n                if (bPrint && marker == com_) {\n                    // size includes 2 for the two bytes for size!\n                    const int n = (size - 2) > 32 ? 32 : size - 2;\n                    // start after the two bytes\n                    out << \"| \"\n                        << Internal::binaryToString(\n                               makeSlice(buf, 2, n + 2 /* cannot overflow as n is at most size - 2 */));\n                }\n\n                // Skip the segment if the size is known\n                if (io_->seek(size - bufRead, BasicIo::cur))\n                    throw Error(kerFailedToReadImageData);\n\n                if (bLF)\n                    out << std::endl;\n\n                if (marker != sos_) {\n                    // Read the beginning of the next segment\n                    marker = advanceToMarker();\n                    enforce(marker>=0, kerNoImageInInputData);\n                    REPORT_MARKER;\n                }\n                done |= marker == eoi_ || marker == sos_;\n                if (done && bPrint)\n                    out << std::endl;\n            }\n        }\n        if (option == kpsIptcErase && iptcDataSegs.size()) {\n#ifdef EXIV2_DEBUG_MESSAGES\n            std::cout << \"iptc data blocks: \" << iptcDataSegs.size() << std::endl;\n            uint32_t toggle = 0;\n            for (Uint32Vector_i i = iptcDataSegs.begin(); i != iptcDataSegs.end(); i++) {\n                std::cout << *i;\n                if (toggle++ % 2)\n                    std::cout << std::endl;\n                else\n                    std::cout << ' ';\n            }\n#endif\n            uint32_t count = (uint32_t)iptcDataSegs.size();\n\n            // figure out which blocks to copy\n            uint64_t* pos = new uint64_t[count + 2];\n            pos[0] = 0;\n            // copy the data that is not iptc\n            Uint32Vector_i it = iptcDataSegs.begin();\n            for (uint64_t i = 0; i < count; i++) {\n                bool bOdd = (i % 2) != 0;\n                bool bEven = !bOdd;\n                pos[i + 1] = bEven ? *it : pos[i] + *it;\n                ++it;\n            }\n            pos[count + 1] = io_->size() - pos[count];\n#ifdef EXIV2_DEBUG_MESSAGES\n            for (uint64_t i = 0; i < count + 2; i++)\n                std::cout << pos[i] << \" \";\n            std::cout << std::endl;\n#endif\n            // $ dd bs=1 skip=$((0)) count=$((13164)) if=ETH0138028.jpg of=E1.jpg\n            // $ dd bs=1 skip=$((49304)) count=2000000  if=ETH0138028.jpg of=E2.jpg\n            // cat E1.jpg E2.jpg > E.jpg\n            // exiv2 -pS E.jpg\n\n            // binary copy io_ to a temporary file\n            BasicIo::AutoPtr tempIo(new MemIo);\n\n            assert(tempIo.get() != 0);\n            for (uint64_t i = 0; i < (count / 2) + 1; i++) {\n                uint64_t start = pos[2 * i] + 2;  // step JPG 2 byte marker\n                if (start == 2)\n                    start = 0;  // read the file 2 byte SOI\n                long length = (long)(pos[2 * i + 1] - start);\n                if (length) {\n#ifdef EXIV2_DEBUG_MESSAGES\n                    std::cout << start << \":\" << length << std::endl;\n#endif\n                    io_->seek(start, BasicIo::beg);\n                    DataBuf buf(length);\n                    io_->read(buf.pData_, buf.size_);\n                    tempIo->write(buf.pData_, buf.size_);\n                }\n            }\n            delete[] pos;\n\n            io_->seek(0, BasicIo::beg);\n            io_->transfer(*tempIo);  // may throw\n            io_->seek(0, BasicIo::beg);\n            readMetadata();\n        }\n    }",
        "func": "void JpegBase::printStructure(std::ostream& out, PrintStructureOption option, int depth)\n    {\n        if (io_->open() != 0)\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        // Ensure that this is the correct image type\n        if (!isThisType(*io_, false)) {\n            if (io_->error() || io_->eof())\n                throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAJpeg);\n        }\n\n        bool bPrint = option == kpsBasic || option == kpsRecursive;\n        Exiv2::Uint32Vector iptcDataSegs;\n\n        if (bPrint || option == kpsXMP || option == kpsIccProfile || option == kpsIptcErase) {\n            // nmonic for markers\n            std::string nm[256];\n            nm[0xd8] = \"SOI\";\n            nm[0xd9] = \"EOI\";\n            nm[0xda] = \"SOS\";\n            nm[0xdb] = \"DQT\";\n            nm[0xdd] = \"DRI\";\n            nm[0xfe] = \"COM\";\n\n            // 0xe0 .. 0xef are APPn\n            // 0xc0 .. 0xcf are SOFn (except 4)\n            nm[0xc4] = \"DHT\";\n            for (int i = 0; i <= 15; i++) {\n                char MN[16];\n                /// \\todo to be replaced by std::snprintf on master (only available in c++11)\n                sprintf(MN, \"APP%d\", i);\n                nm[0xe0 + i] = MN;\n                if (i != 4) {\n                    sprintf(MN, \"SOF%d\", i);\n                    nm[0xc0 + i] = MN;\n                }\n            }\n\n            // which markers have a length field?\n            bool mHasLength[256];\n            for (int i = 0; i < 256; i++)\n                mHasLength[i] = (i >= sof0_ && i <= sof15_) || (i >= app0_ && i <= (app0_ | 0x0F)) ||\n                                (i == dht_ || i == dqt_ || i == dri_ || i == com_ || i == sos_);\n\n            // Container for the signature\n            bool bExtXMP = false;\n            long bufRead = 0;\n            const long bufMinSize = 36;\n            DataBuf buf(bufMinSize);\n\n            // Read section marker\n            int marker = advanceToMarker();\n            if (marker < 0)\n                throw Error(kerNotAJpeg);\n\n            bool done = false;\n            bool first = true;\n            while (!done) {\n                // print marker bytes\n                if (first && bPrint) {\n                    out << \"STRUCTURE OF JPEG FILE: \" << io_->path() << std::endl;\n                    out << \" address | marker       |  length | data\" << std::endl;\n                    REPORT_MARKER;\n                }\n                first = false;\n                bool bLF = bPrint;\n\n                // Read size and signature\n                std::memset(buf.pData_, 0x0, buf.size_);\n                bufRead = io_->read(buf.pData_, bufMinSize);\n                if (io_->error() || bufRead != bufMinSize)\n                    throw Error(kerFailedToReadImageData);\n                if (bufRead < 2)\n                    throw Error(kerNotAJpeg);\n                const uint16_t size = mHasLength[marker] ? getUShort(buf.pData_, bigEndian) : 0;\n                if (bPrint && mHasLength[marker])\n                    out << Internal::stringFormat(\" | %7d \", size);\n\n                // print signature for APPn\n                if (marker >= app0_ && marker <= (app0_ | 0x0F)) {\n                    // http://www.adobe.com/content/dam/Adobe/en/devnet/xmp/pdfs/XMPSpecificationPart3.pdf p75\n                    const std::string signature =\n                        string_from_unterminated(reinterpret_cast<const char*>(buf.pData_ + 2), buf.size_ - 2);\n\n                    // 728 rmills@rmillsmbp:~/gnu/exiv2/ttt $ exiv2 -pS test/data/exiv2-bug922.jpg\n                    // STRUCTURE OF JPEG FILE: test/data/exiv2-bug922.jpg\n                    // address | marker     | length  | data\n                    //       0 | 0xd8 SOI   |       0\n                    //       2 | 0xe1 APP1  |     911 | Exif..MM.*.......%.........#....\n                    //     915 | 0xe1 APP1  |     870 | http://ns.adobe.com/xap/1.0/.<x:\n                    //    1787 | 0xe1 APP1  |   65460 | http://ns.adobe.com/xmp/extensio\n                    if (option == kpsXMP && signature.rfind(\"http://ns.adobe.com/x\", 0) == 0) {\n                        // extract XMP\n                        if (size > 0) {\n                            io_->seek(-bufRead, BasicIo::cur);\n                            std::vector<byte> xmp(size + 1);\n                            io_->read(&xmp[0], size);\n                            int start = 0;\n\n                            // http://wwwimages.adobe.com/content/dam/Adobe/en/devnet/xmp/pdfs/XMPSpecificationPart3.pdf\n                            // if we find HasExtendedXMP, set the flag and ignore this block\n                            // the first extended block is a copy of the Standard block.\n                            // a robust implementation allows extended blocks to be out of sequence\n                            // we could implement out of sequence with a dictionary of sequence/offset\n                            // and dumping the XMP in a post read operation similar to kpsIptcErase\n                            // for the moment, dumping 'on the fly' is working fine\n                            if (!bExtXMP) {\n                                while (xmp.at(start)) {\n                                    start++;\n                                }\n                                start++;\n                                const std::string xmp_from_start = string_from_unterminated(\n                                    reinterpret_cast<const char*>(&xmp.at(start)), size - start);\n                                if (xmp_from_start.find(\"HasExtendedXMP\", start) != xmp_from_start.npos) {\n                                    start = size;  // ignore this packet, we'll get on the next time around\n                                    bExtXMP = true;\n                                }\n                            } else {\n                                start = 2 + 35 + 32 + 4 + 4;  // Adobe Spec, p19\n                            }\n\n                            out.write(reinterpret_cast<const char*>(&xmp.at(start)), size - start);\n                            bufRead = size;\n                            done = !bExtXMP;\n                        }\n                    } else if (option == kpsIccProfile && signature.compare(iccId_) == 0) {\n                        // extract ICCProfile\n                        if (size > 0) {\n                            io_->seek(-bufRead, BasicIo::cur);  // back to buffer (after marker)\n                            io_->seek(14 + 2, BasicIo::cur);    // step over header\n                            DataBuf icc(size - (14 + 2));\n                            io_->read(icc.pData_, icc.size_);\n                            out.write(reinterpret_cast<const char*>(icc.pData_), icc.size_);\n#ifdef EXIV2_DEBUG_MESSAGES\n                            std::cout << \"iccProfile size = \" << icc.size_ << std::endl;\n#endif\n                            bufRead = size;\n                        }\n                    } else if (option == kpsIptcErase && signature.compare(\"Photoshop 3.0\") == 0) {\n                        // delete IPTC data segment from JPEG\n                        if (size > 0) {\n                            io_->seek(-bufRead, BasicIo::cur);\n                            iptcDataSegs.push_back(io_->tell());\n                            iptcDataSegs.push_back(size);\n                        }\n                    } else if (bPrint) {\n                        const size_t start = size > 0 ? 2 : 0;\n                        const size_t end = start + (size > 32 ? 32 : size);\n                        out << \"| \" << Internal::binaryToString(makeSlice(buf, start, end));\n                        if (signature.compare(iccId_) == 0) {\n                            // extract the chunk information from the buffer\n                            //\n                            // the buffer looks like this in this branch\n                            // ICC_PROFILE\\0AB\n                            // where A & B are bytes (the variables chunk & chunks)\n                            //\n                            // We cannot extract the variables A and B from the signature string, as they are beyond the\n                            // null termination (and signature ends there).\n                            // => Read the chunk info from the DataBuf directly\n                            enforce<std::out_of_range>(buf.size_ - 2 > 14, \"Buffer too small to extract chunk information.\");\n                            const int chunk = buf.pData_[2 + 12];\n                            const int chunks = buf.pData_[2 + 13];\n                            out << Internal::stringFormat(\" chunk %d/%d\", chunk, chunks);\n                        }\n                    }\n\n                    // for MPF: http://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/MPF.html\n                    // for FLIR: http://owl.phy.queensu.ca/~phil/exiftool/TagNames/FLIR.html\n                    bool bFlir = option == kpsRecursive && marker == (app0_ + 1) && signature.compare(\"FLIR\") == 0;\n                    bool bExif = option == kpsRecursive && marker == (app0_ + 1) && signature.compare(\"Exif\") == 0;\n                    bool bMPF = option == kpsRecursive && marker == (app0_ + 2) && signature.compare(\"MPF\") == 0;\n                    bool bPS = option == kpsRecursive && signature.compare(\"Photoshop 3.0\") == 0;\n                    if (bFlir || bExif || bMPF || bPS) {\n                        // extract Exif data block which is tiff formatted\n                        if (size > 0) {\n                            out << std::endl;\n\n                            // allocate storage and current file position\n                            byte* exif = new byte[size];\n                            uint32_t restore = io_->tell();\n\n                            // copy the data to memory\n                            io_->seek(-bufRead, BasicIo::cur);\n                            io_->read(exif, size);\n                            uint32_t start = signature.compare(\"Exif\") == 0 ? 8 : 6;\n                            uint32_t max = (uint32_t)size - 1;\n\n                            // is this an fff block?\n                            if (bFlir) {\n                                start = 0;\n                                bFlir = false;\n                                while (start < max) {\n                                    if (std::strcmp((const char*)(exif + start), \"FFF\") == 0) {\n                                        bFlir = true;\n                                        break;\n                                    }\n                                    start++;\n                                }\n                            }\n\n                            // there is a header in FLIR, followed by a tiff block\n                            // Hunt down the tiff using brute force\n                            if (bFlir) {\n                                // FLIRFILEHEAD* pFFF = (FLIRFILEHEAD*) (exif+start) ;\n                                while (start < max) {\n                                    if (exif[start] == 'I' && exif[start + 1] == 'I')\n                                        break;\n                                    if (exif[start] == 'M' && exif[start + 1] == 'M')\n                                        break;\n                                    start++;\n                                }\n                                if (start < max)\n                                    std::cout << \"  FFF start = \" << start << std::endl;\n                                // << \" index = \" << pFFF->dwIndexOff << std::endl;\n                            }\n\n                            if (bPS) {\n                                IptcData::printStructure(out, makeSlice(exif, 0, size), depth);\n                            } else {\n                                // create a copy on write memio object with the data, then print the structure\n                                BasicIo::AutoPtr p = BasicIo::AutoPtr(new MemIo(exif + start, size - start));\n                                if (start < max)\n                                    printTiffStructure(*p, out, option, depth);\n                            }\n\n                            // restore and clean up\n                            io_->seek(restore, Exiv2::BasicIo::beg);\n                            delete[] exif;\n                            bLF = false;\n                        }\n                    }\n                }\n\n                // print COM marker\n                if (bPrint && marker == com_) {\n                    // size includes 2 for the two bytes for size!\n                    const int n = (size - 2) > 32 ? 32 : size - 2;\n                    // start after the two bytes\n                    out << \"| \"\n                        << Internal::binaryToString(\n                               makeSlice(buf, 2, n + 2 /* cannot overflow as n is at most size - 2 */));\n                }\n\n                // Skip the segment if the size is known\n                if (io_->seek(size - bufRead, BasicIo::cur))\n                    throw Error(kerFailedToReadImageData);\n\n                if (bLF)\n                    out << std::endl;\n\n                if (marker != sos_) {\n                    // Read the beginning of the next segment\n                    marker = advanceToMarker();\n                    enforce(marker>=0, kerNoImageInInputData);\n                    REPORT_MARKER;\n                }\n                done |= marker == eoi_ || marker == sos_;\n                if (done && bPrint)\n                    out << std::endl;\n            }\n        }\n        if (option == kpsIptcErase && iptcDataSegs.size()) {\n#ifdef EXIV2_DEBUG_MESSAGES\n            std::cout << \"iptc data blocks: \" << iptcDataSegs.size() << std::endl;\n            uint32_t toggle = 0;\n            for (Uint32Vector_i i = iptcDataSegs.begin(); i != iptcDataSegs.end(); i++) {\n                std::cout << *i;\n                if (toggle++ % 2)\n                    std::cout << std::endl;\n                else\n                    std::cout << ' ';\n            }\n#endif\n            uint32_t count = (uint32_t)iptcDataSegs.size();\n\n            // figure out which blocks to copy\n            uint64_t* pos = new uint64_t[count + 2];\n            pos[0] = 0;\n            // copy the data that is not iptc\n            Uint32Vector_i it = iptcDataSegs.begin();\n            for (uint64_t i = 0; i < count; i++) {\n                bool bOdd = (i % 2) != 0;\n                bool bEven = !bOdd;\n                pos[i + 1] = bEven ? *it : pos[i] + *it;\n                ++it;\n            }\n            pos[count + 1] = io_->size() - pos[count];\n#ifdef EXIV2_DEBUG_MESSAGES\n            for (uint64_t i = 0; i < count + 2; i++)\n                std::cout << pos[i] << \" \";\n            std::cout << std::endl;\n#endif\n            // $ dd bs=1 skip=$((0)) count=$((13164)) if=ETH0138028.jpg of=E1.jpg\n            // $ dd bs=1 skip=$((49304)) count=2000000  if=ETH0138028.jpg of=E2.jpg\n            // cat E1.jpg E2.jpg > E.jpg\n            // exiv2 -pS E.jpg\n\n            // binary copy io_ to a temporary file\n            BasicIo::AutoPtr tempIo(new MemIo);\n\n            assert(tempIo.get() != 0);\n            for (uint64_t i = 0; i < (count / 2) + 1; i++) {\n                uint64_t start = pos[2 * i] + 2;  // step JPG 2 byte marker\n                if (start == 2)\n                    start = 0;  // read the file 2 byte SOI\n                long length = (long)(pos[2 * i + 1] - start);\n                if (length) {\n#ifdef EXIV2_DEBUG_MESSAGES\n                    std::cout << start << \":\" << length << std::endl;\n#endif\n                    io_->seek(start, BasicIo::beg);\n                    DataBuf buf(length);\n                    io_->read(buf.pData_, buf.size_);\n                    tempIo->write(buf.pData_, buf.size_);\n                }\n            }\n            delete[] pos;\n\n            io_->seek(0, BasicIo::beg);\n            io_->transfer(*tempIo);  // may throw\n            io_->seek(0, BasicIo::beg);\n            readMetadata();\n        }\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -68,7 +68,7 @@\n                 // Read size and signature\n                 std::memset(buf.pData_, 0x0, buf.size_);\n                 bufRead = io_->read(buf.pData_, bufMinSize);\n-                if (io_->error())\n+                if (io_->error() || bufRead != bufMinSize)\n                     throw Error(kerFailedToReadImageData);\n                 if (bufRead < 2)\n                     throw Error(kerNotAJpeg);",
        "diff_line_info": {
            "deleted_lines": [
                "                if (io_->error())"
            ],
            "added_lines": [
                "                if (io_->error() || bufRead != bufMinSize)"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-16932",
        "func_name": "GNOME/libxml2/xmlParsePEReference",
        "description": "parser.c in libxml2 before 2.9.5 does not prevent infinite recursion in parameter entities.",
        "git_url": "https://github.com/GNOME/libxml2/commit/899a5d9f0ed13b8e32449a08a361e0de127dd961",
        "commit_title": "Detect infinite recursion in parameter entities",
        "commit_text": " When expanding a parameter entity in a DTD, infinite recursion could lead to an infinite loop or memory exhaustion.  Thanks to Wei Lei for the first of many reports.  Fixes bug 759579.",
        "func_before": "void\nxmlParsePEReference(xmlParserCtxtPtr ctxt)\n{\n    const xmlChar *name;\n    xmlEntityPtr entity = NULL;\n    xmlParserInputPtr input;\n\n    if (RAW != '%')\n        return;\n    NEXT;\n    name = xmlParseName(ctxt);\n    if (name == NULL) {\n\txmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME, \"PEReference: no name\\n\");\n\treturn;\n    }\n    if (xmlParserDebugEntities)\n\txmlGenericError(xmlGenericErrorContext,\n\t\t\"PEReference: %s\\n\", name);\n    if (RAW != ';') {\n\txmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL);\n        return;\n    }\n\n    NEXT;\n\n    /*\n     * Increate the number of entity references parsed\n     */\n    ctxt->nbentities++;\n\n    /*\n     * Request the entity from SAX\n     */\n    if ((ctxt->sax != NULL) &&\n\t(ctxt->sax->getParameterEntity != NULL))\n\tentity = ctxt->sax->getParameterEntity(ctxt->userData, name);\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn;\n    if (entity == NULL) {\n\t/*\n\t * [ WFC: Entity Declared ]\n\t * In a document without any DTD, a document with only an\n\t * internal DTD subset which contains no parameter entity\n\t * references, or a document with \"standalone='yes'\", ...\n\t * ... The declaration of a parameter entity must precede\n\t * any reference to it...\n\t */\n\tif ((ctxt->standalone == 1) ||\n\t    ((ctxt->hasExternalSubset == 0) &&\n\t     (ctxt->hasPErefs == 0))) {\n\t    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n\t\t\t      \"PEReference: %%%s; not found\\n\",\n\t\t\t      name);\n\t} else {\n\t    /*\n\t     * [ VC: Entity Declared ]\n\t     * In a document with an external subset or external\n\t     * parameter entities with \"standalone='no'\", ...\n\t     * ... The declaration of a parameter entity must\n\t     * precede any reference to it...\n\t     */\n            if ((ctxt->validate) && (ctxt->vctxt.error != NULL)) {\n                xmlValidityError(ctxt, XML_WAR_UNDECLARED_ENTITY,\n                                 \"PEReference: %%%s; not found\\n\",\n                                 name, NULL);\n            } else\n                xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n                              \"PEReference: %%%s; not found\\n\",\n                              name, NULL);\n            ctxt->valid = 0;\n\t}\n\txmlParserEntityCheck(ctxt, 0, NULL, 0);\n    } else {\n\t/*\n\t * Internal checking in case the entity quest barfed\n\t */\n\tif ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&\n\t    (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {\n\t    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n\t\t  \"Internal: %%%s; is not a parameter entity\\n\",\n\t\t\t  name, NULL);\n\t} else {\n            xmlChar start[4];\n            xmlCharEncoding enc;\n\n\t    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n\t        ((ctxt->options & XML_PARSE_NOENT) == 0) &&\n\t\t((ctxt->options & XML_PARSE_DTDVALID) == 0) &&\n\t\t((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&\n\t\t((ctxt->options & XML_PARSE_DTDATTR) == 0) &&\n\t\t(ctxt->replaceEntities == 0) &&\n\t\t(ctxt->validate == 0))\n\t\treturn;\n\n\t    input = xmlNewEntityInputStream(ctxt, entity);\n\t    if (xmlPushInput(ctxt, input) < 0)\n\t\treturn;\n\n\t    if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) {\n                /*\n                 * Get the 4 first bytes and decode the charset\n                 * if enc != XML_CHAR_ENCODING_NONE\n                 * plug some encoding conversion routines.\n                 * Note that, since we may have some non-UTF8\n                 * encoding (like UTF16, bug 135229), the 'length'\n                 * is not known, but we can calculate based upon\n                 * the amount of data in the buffer.\n                 */\n                GROW\n                if (ctxt->instate == XML_PARSER_EOF)\n                    return;\n                if ((ctxt->input->end - ctxt->input->cur)>=4) {\n                    start[0] = RAW;\n                    start[1] = NXT(1);\n                    start[2] = NXT(2);\n                    start[3] = NXT(3);\n                    enc = xmlDetectCharEncoding(start, 4);\n                    if (enc != XML_CHAR_ENCODING_NONE) {\n                        xmlSwitchEncoding(ctxt, enc);\n                    }\n                }\n\n                if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&\n                    (IS_BLANK_CH(NXT(5)))) {\n                    xmlParseTextDecl(ctxt);\n                }\n            }\n\t}\n    }\n    ctxt->hasPErefs = 1;\n}",
        "func": "void\nxmlParsePEReference(xmlParserCtxtPtr ctxt)\n{\n    const xmlChar *name;\n    xmlEntityPtr entity = NULL;\n    xmlParserInputPtr input;\n\n    if (RAW != '%')\n        return;\n    NEXT;\n    name = xmlParseName(ctxt);\n    if (name == NULL) {\n\txmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME, \"PEReference: no name\\n\");\n\treturn;\n    }\n    if (xmlParserDebugEntities)\n\txmlGenericError(xmlGenericErrorContext,\n\t\t\"PEReference: %s\\n\", name);\n    if (RAW != ';') {\n\txmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL);\n        return;\n    }\n\n    NEXT;\n\n    /*\n     * Increate the number of entity references parsed\n     */\n    ctxt->nbentities++;\n\n    /*\n     * Request the entity from SAX\n     */\n    if ((ctxt->sax != NULL) &&\n\t(ctxt->sax->getParameterEntity != NULL))\n\tentity = ctxt->sax->getParameterEntity(ctxt->userData, name);\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn;\n    if (entity == NULL) {\n\t/*\n\t * [ WFC: Entity Declared ]\n\t * In a document without any DTD, a document with only an\n\t * internal DTD subset which contains no parameter entity\n\t * references, or a document with \"standalone='yes'\", ...\n\t * ... The declaration of a parameter entity must precede\n\t * any reference to it...\n\t */\n\tif ((ctxt->standalone == 1) ||\n\t    ((ctxt->hasExternalSubset == 0) &&\n\t     (ctxt->hasPErefs == 0))) {\n\t    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n\t\t\t      \"PEReference: %%%s; not found\\n\",\n\t\t\t      name);\n\t} else {\n\t    /*\n\t     * [ VC: Entity Declared ]\n\t     * In a document with an external subset or external\n\t     * parameter entities with \"standalone='no'\", ...\n\t     * ... The declaration of a parameter entity must\n\t     * precede any reference to it...\n\t     */\n            if ((ctxt->validate) && (ctxt->vctxt.error != NULL)) {\n                xmlValidityError(ctxt, XML_WAR_UNDECLARED_ENTITY,\n                                 \"PEReference: %%%s; not found\\n\",\n                                 name, NULL);\n            } else\n                xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n                              \"PEReference: %%%s; not found\\n\",\n                              name, NULL);\n            ctxt->valid = 0;\n\t}\n\txmlParserEntityCheck(ctxt, 0, NULL, 0);\n    } else {\n\t/*\n\t * Internal checking in case the entity quest barfed\n\t */\n\tif ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&\n\t    (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {\n\t    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n\t\t  \"Internal: %%%s; is not a parameter entity\\n\",\n\t\t\t  name, NULL);\n\t} else {\n            xmlChar start[4];\n            xmlCharEncoding enc;\n\n\t    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n\t        ((ctxt->options & XML_PARSE_NOENT) == 0) &&\n\t\t((ctxt->options & XML_PARSE_DTDVALID) == 0) &&\n\t\t((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&\n\t\t((ctxt->options & XML_PARSE_DTDATTR) == 0) &&\n\t\t(ctxt->replaceEntities == 0) &&\n\t\t(ctxt->validate == 0))\n\t\treturn;\n\n\t    input = xmlNewEntityInputStream(ctxt, entity);\n\t    if (xmlPushInput(ctxt, input) < 0) {\n                xmlFreeInputStream(input);\n\t\treturn;\n            }\n\n\t    if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) {\n                /*\n                 * Get the 4 first bytes and decode the charset\n                 * if enc != XML_CHAR_ENCODING_NONE\n                 * plug some encoding conversion routines.\n                 * Note that, since we may have some non-UTF8\n                 * encoding (like UTF16, bug 135229), the 'length'\n                 * is not known, but we can calculate based upon\n                 * the amount of data in the buffer.\n                 */\n                GROW\n                if (ctxt->instate == XML_PARSER_EOF)\n                    return;\n                if ((ctxt->input->end - ctxt->input->cur)>=4) {\n                    start[0] = RAW;\n                    start[1] = NXT(1);\n                    start[2] = NXT(2);\n                    start[3] = NXT(3);\n                    enc = xmlDetectCharEncoding(start, 4);\n                    if (enc != XML_CHAR_ENCODING_NONE) {\n                        xmlSwitchEncoding(ctxt, enc);\n                    }\n                }\n\n                if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&\n                    (IS_BLANK_CH(NXT(5)))) {\n                    xmlParseTextDecl(ctxt);\n                }\n            }\n\t}\n    }\n    ctxt->hasPErefs = 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -93,8 +93,10 @@\n \t\treturn;\n \n \t    input = xmlNewEntityInputStream(ctxt, entity);\n-\t    if (xmlPushInput(ctxt, input) < 0)\n+\t    if (xmlPushInput(ctxt, input) < 0) {\n+                xmlFreeInputStream(input);\n \t\treturn;\n+            }\n \n \t    if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) {\n                 /*",
        "diff_line_info": {
            "deleted_lines": [
                "\t    if (xmlPushInput(ctxt, input) < 0)"
            ],
            "added_lines": [
                "\t    if (xmlPushInput(ctxt, input) < 0) {",
                "                xmlFreeInputStream(input);",
                "            }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-16932",
        "func_name": "GNOME/libxml2/xmlPushInput",
        "description": "parser.c in libxml2 before 2.9.5 does not prevent infinite recursion in parameter entities.",
        "git_url": "https://github.com/GNOME/libxml2/commit/899a5d9f0ed13b8e32449a08a361e0de127dd961",
        "commit_title": "Detect infinite recursion in parameter entities",
        "commit_text": " When expanding a parameter entity in a DTD, infinite recursion could lead to an infinite loop or memory exhaustion.  Thanks to Wei Lei for the first of many reports.  Fixes bug 759579.",
        "func_before": "int\nxmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {\n    int ret;\n    if (input == NULL) return(-1);\n\n    if (xmlParserDebugEntities) {\n\tif ((ctxt->input != NULL) && (ctxt->input->filename))\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"%s(%d): \", ctxt->input->filename,\n\t\t    ctxt->input->line);\n\txmlGenericError(xmlGenericErrorContext,\n\t\t\"Pushing input %d : %.30s\\n\", ctxt->inputNr+1, input->cur);\n    }\n    ret = inputPush(ctxt, input);\n    if (ctxt->instate == XML_PARSER_EOF)\n        return(-1);\n    GROW;\n    return(ret);\n}",
        "func": "int\nxmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {\n    int ret;\n    if (input == NULL) return(-1);\n\n    if (xmlParserDebugEntities) {\n\tif ((ctxt->input != NULL) && (ctxt->input->filename))\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"%s(%d): \", ctxt->input->filename,\n\t\t    ctxt->input->line);\n\txmlGenericError(xmlGenericErrorContext,\n\t\t\"Pushing input %d : %.30s\\n\", ctxt->inputNr+1, input->cur);\n    }\n    if (((ctxt->inputNr > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||\n        (ctxt->inputNr > 1024)) {\n        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n        while (ctxt->inputNr > 1)\n            xmlFreeInputStream(inputPop(ctxt));\n\treturn(-1);\n    }\n    ret = inputPush(ctxt, input);\n    if (ctxt->instate == XML_PARSER_EOF)\n        return(-1);\n    GROW;\n    return(ret);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,6 +11,13 @@\n \txmlGenericError(xmlGenericErrorContext,\n \t\t\"Pushing input %d : %.30s\\n\", ctxt->inputNr+1, input->cur);\n     }\n+    if (((ctxt->inputNr > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||\n+        (ctxt->inputNr > 1024)) {\n+        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n+        while (ctxt->inputNr > 1)\n+            xmlFreeInputStream(inputPop(ctxt));\n+\treturn(-1);\n+    }\n     ret = inputPush(ctxt, input);\n     if (ctxt->instate == XML_PARSER_EOF)\n         return(-1);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (((ctxt->inputNr > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||",
                "        (ctxt->inputNr > 1024)) {",
                "        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);",
                "        while (ctxt->inputNr > 1)",
                "            xmlFreeInputStream(inputPop(ctxt));",
                "\treturn(-1);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-17044",
        "func_name": "xen-project/xen/p2m_pod_demand_populate",
        "description": "An issue was discovered in Xen through 4.9.x allowing HVM guest OS users to cause a denial of service (infinite loop and host OS hang) by leveraging the mishandling of Populate on Demand (PoD) errors.",
        "git_url": "https://github.com/xen-project/xen/commit/a1c6c6768971ea387d7eba0803908ef0928b43ac",
        "commit_title": "x86/pod: prevent infinite loop when shattering large pages",
        "commit_text": " When populating pages, the PoD may need to split large ones using p2m_set_entry and request the caller to retry (see ept_get_entry for instance).  p2m_set_entry may fail to shatter if it is not possible to allocate memory for the new page table. However, the error is not propagated resulting to the callers to retry infinitely the PoD.  Prevent the infinite loop by return false when it is not possible to shatter the large mapping.  This is XSA-246. ",
        "func_before": "bool\np2m_pod_demand_populate(struct p2m_domain *p2m, gfn_t gfn,\n                        unsigned int order)\n{\n    struct domain *d = p2m->domain;\n    struct page_info *p = NULL; /* Compiler warnings */\n    gfn_t gfn_aligned = _gfn((gfn_x(gfn) >> order) << order);\n    mfn_t mfn;\n    unsigned long i;\n\n    ASSERT(gfn_locked_by_me(p2m, gfn));\n    pod_lock(p2m);\n\n    /*\n     * This check is done with the pod lock held.  This will make sure that\n     * even if d->is_dying changes under our feet, p2m_pod_empty_cache()\n     * won't start until we're done.\n     */\n    if ( unlikely(d->is_dying) )\n        goto out_fail;\n\n\n    /*\n     * Because PoD does not have cache list for 1GB pages, it has to remap\n     * 1GB region to 2MB chunks for a retry.\n     */\n    if ( order == PAGE_ORDER_1G )\n    {\n        pod_unlock(p2m);\n        /*\n         * Note that we are supposed to call p2m_set_entry() 512 times to\n         * split 1GB into 512 2MB pages here. But We only do once here because\n         * p2m_set_entry() should automatically shatter the 1GB page into\n         * 512 2MB pages. The rest of 511 calls are unnecessary.\n         *\n         * NOTE: In a fine-grained p2m locking scenario this operation\n         * may need to promote its locking from gfn->1g superpage\n         */\n        p2m_set_entry(p2m, gfn_aligned, INVALID_MFN, PAGE_ORDER_2M,\n                      p2m_populate_on_demand, p2m->default_access);\n        return true;\n    }\n\n    /* Only reclaim if we're in actual need of more cache. */\n    if ( p2m->pod.entry_count > p2m->pod.count )\n        pod_eager_reclaim(p2m);\n\n    /*\n     * Only sweep if we're actually out of memory.  Doing anything else\n     * causes unnecessary time and fragmentation of superpages in the p2m.\n     */\n    if ( p2m->pod.count == 0 )\n        p2m_pod_emergency_sweep(p2m);\n\n    /* If the sweep failed, give up. */\n    if ( p2m->pod.count == 0 )\n        goto out_of_memory;\n\n    /* Keep track of the highest gfn demand-populated by a guest fault */\n    p2m->pod.max_guest = gfn_max(gfn, p2m->pod.max_guest);\n\n    /*\n     * Get a page f/ the cache.  A NULL return value indicates that the\n     * 2-meg range should be marked singleton PoD, and retried.\n     */\n    if ( (p = p2m_pod_cache_get(p2m, order)) == NULL )\n        goto remap_and_retry;\n\n    mfn = page_to_mfn(p);\n\n    BUG_ON((mfn_x(mfn) & ((1UL << order) - 1)) != 0);\n\n    p2m_set_entry(p2m, gfn_aligned, mfn, order, p2m_ram_rw,\n                  p2m->default_access);\n\n    for( i = 0; i < (1UL << order); i++ )\n    {\n        set_gpfn_from_mfn(mfn_x(mfn) + i, gfn_x(gfn_aligned) + i);\n        paging_mark_dirty(d, mfn_add(mfn, i));\n    }\n\n    p2m->pod.entry_count -= (1UL << order);\n    BUG_ON(p2m->pod.entry_count < 0);\n\n    pod_eager_record(p2m, gfn_aligned, order);\n\n    if ( tb_init_done )\n    {\n        struct {\n            u64 gfn, mfn;\n            int d:16,order:16;\n        } t;\n\n        t.gfn = gfn_x(gfn);\n        t.mfn = mfn_x(mfn);\n        t.d = d->domain_id;\n        t.order = order;\n\n        __trace_var(TRC_MEM_POD_POPULATE, 0, sizeof(t), &t);\n    }\n\n    pod_unlock(p2m);\n    return true;\nout_of_memory:\n    pod_unlock(p2m);\n\n    printk(\"%s: Dom%d out of PoD memory! (tot=%\"PRIu32\" ents=%ld dom%d)\\n\",\n           __func__, d->domain_id, d->tot_pages, p2m->pod.entry_count,\n           current->domain->domain_id);\n    domain_crash(d);\n    return false;\nout_fail:\n    pod_unlock(p2m);\n    return false;\nremap_and_retry:\n    BUG_ON(order != PAGE_ORDER_2M);\n    pod_unlock(p2m);\n\n    /* Remap this 2-meg region in singleton chunks */\n    /*\n     * NOTE: In a p2m fine-grained lock scenario this might\n     * need promoting the gfn lock from gfn->2M superpage.\n     */\n    for ( i = 0; i < (1UL << order); i++ )\n        p2m_set_entry(p2m, gfn_add(gfn_aligned, i), INVALID_MFN, PAGE_ORDER_4K,\n                      p2m_populate_on_demand, p2m->default_access);\n    if ( tb_init_done )\n    {\n        struct {\n            u64 gfn;\n            int d:16;\n        } t;\n\n        t.gfn = gfn_x(gfn);\n        t.d = d->domain_id;\n\n        __trace_var(TRC_MEM_POD_SUPERPAGE_SPLINTER, 0, sizeof(t), &t);\n    }\n\n    return true;\n}",
        "func": "bool\np2m_pod_demand_populate(struct p2m_domain *p2m, gfn_t gfn,\n                        unsigned int order)\n{\n    struct domain *d = p2m->domain;\n    struct page_info *p = NULL; /* Compiler warnings */\n    gfn_t gfn_aligned = _gfn((gfn_x(gfn) >> order) << order);\n    mfn_t mfn;\n    unsigned long i;\n\n    ASSERT(gfn_locked_by_me(p2m, gfn));\n    pod_lock(p2m);\n\n    /*\n     * This check is done with the pod lock held.  This will make sure that\n     * even if d->is_dying changes under our feet, p2m_pod_empty_cache()\n     * won't start until we're done.\n     */\n    if ( unlikely(d->is_dying) )\n        goto out_fail;\n\n\n    /*\n     * Because PoD does not have cache list for 1GB pages, it has to remap\n     * 1GB region to 2MB chunks for a retry.\n     */\n    if ( order == PAGE_ORDER_1G )\n    {\n        pod_unlock(p2m);\n        /*\n         * Note that we are supposed to call p2m_set_entry() 512 times to\n         * split 1GB into 512 2MB pages here. But We only do once here because\n         * p2m_set_entry() should automatically shatter the 1GB page into\n         * 512 2MB pages. The rest of 511 calls are unnecessary.\n         *\n         * NOTE: In a fine-grained p2m locking scenario this operation\n         * may need to promote its locking from gfn->1g superpage\n         */\n        return !p2m_set_entry(p2m, gfn_aligned, INVALID_MFN, PAGE_ORDER_2M,\n                              p2m_populate_on_demand, p2m->default_access);\n    }\n\n    /* Only reclaim if we're in actual need of more cache. */\n    if ( p2m->pod.entry_count > p2m->pod.count )\n        pod_eager_reclaim(p2m);\n\n    /*\n     * Only sweep if we're actually out of memory.  Doing anything else\n     * causes unnecessary time and fragmentation of superpages in the p2m.\n     */\n    if ( p2m->pod.count == 0 )\n        p2m_pod_emergency_sweep(p2m);\n\n    /* If the sweep failed, give up. */\n    if ( p2m->pod.count == 0 )\n        goto out_of_memory;\n\n    /* Keep track of the highest gfn demand-populated by a guest fault */\n    p2m->pod.max_guest = gfn_max(gfn, p2m->pod.max_guest);\n\n    /*\n     * Get a page f/ the cache.  A NULL return value indicates that the\n     * 2-meg range should be marked singleton PoD, and retried.\n     */\n    if ( (p = p2m_pod_cache_get(p2m, order)) == NULL )\n        goto remap_and_retry;\n\n    mfn = page_to_mfn(p);\n\n    BUG_ON((mfn_x(mfn) & ((1UL << order) - 1)) != 0);\n\n    if ( p2m_set_entry(p2m, gfn_aligned, mfn, order, p2m_ram_rw,\n                       p2m->default_access) )\n    {\n        p2m_pod_cache_add(p2m, p, order);\n        goto out_fail;\n    }\n\n    for( i = 0; i < (1UL << order); i++ )\n    {\n        set_gpfn_from_mfn(mfn_x(mfn) + i, gfn_x(gfn_aligned) + i);\n        paging_mark_dirty(d, mfn_add(mfn, i));\n    }\n\n    p2m->pod.entry_count -= (1UL << order);\n    BUG_ON(p2m->pod.entry_count < 0);\n\n    pod_eager_record(p2m, gfn_aligned, order);\n\n    if ( tb_init_done )\n    {\n        struct {\n            u64 gfn, mfn;\n            int d:16,order:16;\n        } t;\n\n        t.gfn = gfn_x(gfn);\n        t.mfn = mfn_x(mfn);\n        t.d = d->domain_id;\n        t.order = order;\n\n        __trace_var(TRC_MEM_POD_POPULATE, 0, sizeof(t), &t);\n    }\n\n    pod_unlock(p2m);\n    return true;\nout_of_memory:\n    pod_unlock(p2m);\n\n    printk(\"%s: Dom%d out of PoD memory! (tot=%\"PRIu32\" ents=%ld dom%d)\\n\",\n           __func__, d->domain_id, d->tot_pages, p2m->pod.entry_count,\n           current->domain->domain_id);\n    domain_crash(d);\n    return false;\nout_fail:\n    pod_unlock(p2m);\n    return false;\nremap_and_retry:\n    BUG_ON(order != PAGE_ORDER_2M);\n    pod_unlock(p2m);\n\n    /*\n     * Remap this 2-meg region in singleton chunks. See the comment on the\n     * 1G page splitting path above for why a single call suffices.\n     *\n     * NOTE: In a p2m fine-grained lock scenario this might\n     * need promoting the gfn lock from gfn->2M superpage.\n     */\n    if ( p2m_set_entry(p2m, gfn_aligned, INVALID_MFN, PAGE_ORDER_4K,\n                       p2m_populate_on_demand, p2m->default_access) )\n        return false;\n\n    if ( tb_init_done )\n    {\n        struct {\n            u64 gfn;\n            int d:16;\n        } t;\n\n        t.gfn = gfn_x(gfn);\n        t.d = d->domain_id;\n\n        __trace_var(TRC_MEM_POD_SUPERPAGE_SPLINTER, 0, sizeof(t), &t);\n    }\n\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -36,9 +36,8 @@\n          * NOTE: In a fine-grained p2m locking scenario this operation\n          * may need to promote its locking from gfn->1g superpage\n          */\n-        p2m_set_entry(p2m, gfn_aligned, INVALID_MFN, PAGE_ORDER_2M,\n-                      p2m_populate_on_demand, p2m->default_access);\n-        return true;\n+        return !p2m_set_entry(p2m, gfn_aligned, INVALID_MFN, PAGE_ORDER_2M,\n+                              p2m_populate_on_demand, p2m->default_access);\n     }\n \n     /* Only reclaim if we're in actual need of more cache. */\n@@ -70,8 +69,12 @@\n \n     BUG_ON((mfn_x(mfn) & ((1UL << order) - 1)) != 0);\n \n-    p2m_set_entry(p2m, gfn_aligned, mfn, order, p2m_ram_rw,\n-                  p2m->default_access);\n+    if ( p2m_set_entry(p2m, gfn_aligned, mfn, order, p2m_ram_rw,\n+                       p2m->default_access) )\n+    {\n+        p2m_pod_cache_add(p2m, p, order);\n+        goto out_fail;\n+    }\n \n     for( i = 0; i < (1UL << order); i++ )\n     {\n@@ -116,14 +119,17 @@\n     BUG_ON(order != PAGE_ORDER_2M);\n     pod_unlock(p2m);\n \n-    /* Remap this 2-meg region in singleton chunks */\n     /*\n+     * Remap this 2-meg region in singleton chunks. See the comment on the\n+     * 1G page splitting path above for why a single call suffices.\n+     *\n      * NOTE: In a p2m fine-grained lock scenario this might\n      * need promoting the gfn lock from gfn->2M superpage.\n      */\n-    for ( i = 0; i < (1UL << order); i++ )\n-        p2m_set_entry(p2m, gfn_add(gfn_aligned, i), INVALID_MFN, PAGE_ORDER_4K,\n-                      p2m_populate_on_demand, p2m->default_access);\n+    if ( p2m_set_entry(p2m, gfn_aligned, INVALID_MFN, PAGE_ORDER_4K,\n+                       p2m_populate_on_demand, p2m->default_access) )\n+        return false;\n+\n     if ( tb_init_done )\n     {\n         struct {",
        "diff_line_info": {
            "deleted_lines": [
                "        p2m_set_entry(p2m, gfn_aligned, INVALID_MFN, PAGE_ORDER_2M,",
                "                      p2m_populate_on_demand, p2m->default_access);",
                "        return true;",
                "    p2m_set_entry(p2m, gfn_aligned, mfn, order, p2m_ram_rw,",
                "                  p2m->default_access);",
                "    /* Remap this 2-meg region in singleton chunks */",
                "    for ( i = 0; i < (1UL << order); i++ )",
                "        p2m_set_entry(p2m, gfn_add(gfn_aligned, i), INVALID_MFN, PAGE_ORDER_4K,",
                "                      p2m_populate_on_demand, p2m->default_access);"
            ],
            "added_lines": [
                "        return !p2m_set_entry(p2m, gfn_aligned, INVALID_MFN, PAGE_ORDER_2M,",
                "                              p2m_populate_on_demand, p2m->default_access);",
                "    if ( p2m_set_entry(p2m, gfn_aligned, mfn, order, p2m_ram_rw,",
                "                       p2m->default_access) )",
                "    {",
                "        p2m_pod_cache_add(p2m, p, order);",
                "        goto out_fail;",
                "    }",
                "     * Remap this 2-meg region in singleton chunks. See the comment on the",
                "     * 1G page splitting path above for why a single call suffices.",
                "     *",
                "    if ( p2m_set_entry(p2m, gfn_aligned, INVALID_MFN, PAGE_ORDER_4K,",
                "                       p2m_populate_on_demand, p2m->default_access) )",
                "        return false;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2018-5253",
        "func_name": "axiomatic-systems/Bento4/AP4_FtypAtom::AP4_FtypAtom",
        "description": "The AP4_FtypAtom class in Core/Ap4FtypAtom.cpp in Bento4 1.5.1.0 has an Infinite loop via a crafted MP4 file that triggers size mishandling.",
        "git_url": "https://github.com/axiomatic-systems/Bento4/commit/e13b22fe41f87db766a061d5003d4019a3ed5c18",
        "commit_title": "fix for #233",
        "commit_text": "",
        "func_before": "AP4_FtypAtom::AP4_FtypAtom(AP4_UI32 size, AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_FTYP, size)\n{\n    stream.ReadUI32(m_MajorBrand);\n    stream.ReadUI32(m_MinorVersion);\n    size -= 16;\n    while (size) {\n        AP4_UI32 compatible_brand;\n        stream.ReadUI32(compatible_brand);\n        m_CompatibleBrands.Append(compatible_brand);\n        size -= 4;\n    }\n}",
        "func": "AP4_FtypAtom::AP4_FtypAtom(AP4_UI32 size, AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_FTYP, size),\n    m_MajorBrand(0),\n    m_MinorVersion(0)\n{\n    if (size < 16) return;\n    stream.ReadUI32(m_MajorBrand);\n    stream.ReadUI32(m_MinorVersion);\n    size -= 16;\n    while (size >= 4) {\n        AP4_UI32 compatible_brand;\n        AP4_Result result = stream.ReadUI32(compatible_brand);\n        if (AP4_FAILED(result)) return;\n        m_CompatibleBrands.Append(compatible_brand);\n        size -= 4;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,12 +1,16 @@\n AP4_FtypAtom::AP4_FtypAtom(AP4_UI32 size, AP4_ByteStream& stream) :\n-    AP4_Atom(AP4_ATOM_TYPE_FTYP, size)\n+    AP4_Atom(AP4_ATOM_TYPE_FTYP, size),\n+    m_MajorBrand(0),\n+    m_MinorVersion(0)\n {\n+    if (size < 16) return;\n     stream.ReadUI32(m_MajorBrand);\n     stream.ReadUI32(m_MinorVersion);\n     size -= 16;\n-    while (size) {\n+    while (size >= 4) {\n         AP4_UI32 compatible_brand;\n-        stream.ReadUI32(compatible_brand);\n+        AP4_Result result = stream.ReadUI32(compatible_brand);\n+        if (AP4_FAILED(result)) return;\n         m_CompatibleBrands.Append(compatible_brand);\n         size -= 4;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    AP4_Atom(AP4_ATOM_TYPE_FTYP, size)",
                "    while (size) {",
                "        stream.ReadUI32(compatible_brand);"
            ],
            "added_lines": [
                "    AP4_Atom(AP4_ATOM_TYPE_FTYP, size),",
                "    m_MajorBrand(0),",
                "    m_MinorVersion(0)",
                "    if (size < 16) return;",
                "    while (size >= 4) {",
                "        AP4_Result result = stream.ReadUI32(compatible_brand);",
                "        if (AP4_FAILED(result)) return;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-6196",
        "func_name": "tats/w3m/feed_table_block_tag",
        "description": "w3m through 0.5.3 is prone to an infinite recursion flaw in HTMLlineproc0 because the feed_table_block_tag function in table.c does not prevent a negative indent value.",
        "git_url": "https://github.com/tats/w3m/commit/8354763b90490d4105695df52674d0fcef823e92",
        "commit_title": "Prevent negative indent value in feed_table_block_tag()",
        "commit_text": " Bug-Debian: https://github.com/tats/w3m/issues/88",
        "func_before": "static void\nfeed_table_block_tag(struct table *tbl,\n\t\t     char *line, struct table_mode *mode, int indent, int cmd)\n{\n    int offset;\n    if (mode->indent_level <= 0 && indent == -1)\n\treturn;\n    if (mode->indent_level >= CHAR_MAX && indent == 1)\n\treturn;\n    setwidth(tbl, mode);\n    feed_table_inline_tag(tbl, line, mode, -1);\n    clearcontentssize(tbl, mode);\n    if (indent == 1) {\n\tmode->indent_level++;\n\tif (mode->indent_level <= MAX_INDENT_LEVEL)\n\t    tbl->indent += INDENT_INCR;\n    }\n    else if (indent == -1) {\n\tmode->indent_level--;\n\tif (mode->indent_level < MAX_INDENT_LEVEL)\n\t    tbl->indent -= INDENT_INCR;\n    }\n    offset = tbl->indent;\n    if (cmd == HTML_DT) {\n\tif (mode->indent_level > 0 && mode->indent_level <= MAX_INDENT_LEVEL)\n\t    offset -= INDENT_INCR;\n    }\n    if (tbl->indent > 0) {\n\tcheck_minimum0(tbl, 0);\n\taddcontentssize(tbl, offset);\n    }\n}",
        "func": "static void\nfeed_table_block_tag(struct table *tbl,\n\t\t     char *line, struct table_mode *mode, int indent, int cmd)\n{\n    int offset;\n    if (mode->indent_level <= 0 && indent == -1)\n\treturn;\n    if (mode->indent_level >= CHAR_MAX && indent == 1)\n\treturn;\n    setwidth(tbl, mode);\n    feed_table_inline_tag(tbl, line, mode, -1);\n    clearcontentssize(tbl, mode);\n    if (indent == 1) {\n\tmode->indent_level++;\n\tif (mode->indent_level <= MAX_INDENT_LEVEL)\n\t    tbl->indent += INDENT_INCR;\n    }\n    else if (indent == -1) {\n\tmode->indent_level--;\n\tif (mode->indent_level < MAX_INDENT_LEVEL)\n\t    tbl->indent -= INDENT_INCR;\n    }\n    if (tbl->indent < 0)\n\ttbl->indent = 0;\n    offset = tbl->indent;\n    if (cmd == HTML_DT) {\n\tif (mode->indent_level > 0 && mode->indent_level <= MAX_INDENT_LEVEL)\n\t    offset -= INDENT_INCR;\n\tif (offset < 0)\n\t    offset = 0;\n    }\n    if (tbl->indent > 0) {\n\tcheck_minimum0(tbl, 0);\n\taddcontentssize(tbl, offset);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,10 +20,14 @@\n \tif (mode->indent_level < MAX_INDENT_LEVEL)\n \t    tbl->indent -= INDENT_INCR;\n     }\n+    if (tbl->indent < 0)\n+\ttbl->indent = 0;\n     offset = tbl->indent;\n     if (cmd == HTML_DT) {\n \tif (mode->indent_level > 0 && mode->indent_level <= MAX_INDENT_LEVEL)\n \t    offset -= INDENT_INCR;\n+\tif (offset < 0)\n+\t    offset = 0;\n     }\n     if (tbl->indent > 0) {\n \tcheck_minimum0(tbl, 0);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (tbl->indent < 0)",
                "\ttbl->indent = 0;",
                "\tif (offset < 0)",
                "\t    offset = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-18183",
        "func_name": "qpdf/QPDFWriter::enqueueObject",
        "description": "An issue was discovered in QPDF before 7.0.0. There is an infinite loop in the QPDFWriter::enqueueObject() function in libqpdf/QPDFWriter.cc.",
        "git_url": "https://github.com/qpdf/qpdf/commit/8249a26d69f72b9cda584c14cc3f12769985e481",
        "commit_title": "Fix infinite loop in QPDFWriter (fixes #143)",
        "commit_text": "",
        "func_before": "void\nQPDFWriter::enqueueObject(QPDFObjectHandle object)\n{\n    if (object.isIndirect())\n    {\n        if (object.getOwningQPDF() != &(this->pdf))\n        {\n            QTC::TC(\"qpdf\", \"QPDFWriter foreign object\");\n            throw std::logic_error(\n                \"QPDFObjectHandle from different QPDF found while writing.\"\n                \"  Use QPDF::copyForeignObject to add objects from\"\n                \" another file.\");\n        }\n\n\tQPDFObjGen og = object.getObjGen();\n\n\tif (obj_renumber.count(og) == 0)\n\t{\n\t    if (this->object_to_object_stream.count(og))\n\t    {\n\t\t// This is in an object stream.  Don't process it\n\t\t// here.  Instead, enqueue the object stream.  Object\n\t\t// streams always have generation 0.\n\t\tint stream_id = this->object_to_object_stream[og];\n\t\tenqueueObject(this->pdf.getObjectByID(stream_id, 0));\n\t    }\n\t    else\n\t    {\n\t\tobject_queue.push_back(object);\n\t\tobj_renumber[og] = next_objid++;\n\n\t\tif ((og.getGen() == 0) &&\n                    this->object_stream_to_objects.count(og.getObj()))\n\t\t{\n\t\t    // For linearized files, uncompressed objects go\n\t\t    // at end, and we take care of assigning numbers\n\t\t    // to them elsewhere.\n\t\t    if (! this->linearized)\n\t\t    {\n\t\t\tassignCompressedObjectNumbers(og);\n\t\t    }\n\t\t}\n\t\telse if ((! this->direct_stream_lengths) && object.isStream())\n\t\t{\n\t\t    // reserve next object ID for length\n\t\t    ++next_objid;\n\t\t}\n\t    }\n\t}\n    }\n    else if (object.isArray())\n    {\n\tint n = object.getArrayNItems();\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t    if (! this->linearized)\n\t    {\n\t\tenqueueObject(object.getArrayItem(i));\n\t    }\n\t}\n    }\n    else if (object.isDictionary())\n    {\n\tstd::set<std::string> keys = object.getKeys();\n\tfor (std::set<std::string>::iterator iter = keys.begin();\n\t     iter != keys.end(); ++iter)\n\t{\n\t    if (! this->linearized)\n\t    {\n\t\tenqueueObject(object.getKey(*iter));\n\t    }\n\t}\n    }\n    else\n    {\n\t// ignore\n    }\n}",
        "func": "void\nQPDFWriter::enqueueObject(QPDFObjectHandle object)\n{\n    if (object.isIndirect())\n    {\n        if (object.getOwningQPDF() != &(this->pdf))\n        {\n            QTC::TC(\"qpdf\", \"QPDFWriter foreign object\");\n            throw std::logic_error(\n                \"QPDFObjectHandle from different QPDF found while writing.\"\n                \"  Use QPDF::copyForeignObject to add objects from\"\n                \" another file.\");\n        }\n\n\tQPDFObjGen og = object.getObjGen();\n\n\tif (obj_renumber.count(og) == 0)\n\t{\n\t    if (this->object_to_object_stream.count(og))\n\t    {\n\t\t// This is in an object stream.  Don't process it\n\t\t// here.  Instead, enqueue the object stream.  Object\n\t\t// streams always have generation 0.\n\t\tint stream_id = this->object_to_object_stream[og];\n                // Detect loops by storing invalid object ID 0, which\n                // will get overwritten later.\n                obj_renumber[og] = 0;\n\t\tenqueueObject(this->pdf.getObjectByID(stream_id, 0));\n\t    }\n\t    else\n\t    {\n\t\tobject_queue.push_back(object);\n\t\tobj_renumber[og] = next_objid++;\n\n\t\tif ((og.getGen() == 0) &&\n                    this->object_stream_to_objects.count(og.getObj()))\n\t\t{\n\t\t    // For linearized files, uncompressed objects go\n\t\t    // at end, and we take care of assigning numbers\n\t\t    // to them elsewhere.\n\t\t    if (! this->linearized)\n\t\t    {\n\t\t\tassignCompressedObjectNumbers(og);\n\t\t    }\n\t\t}\n\t\telse if ((! this->direct_stream_lengths) && object.isStream())\n\t\t{\n\t\t    // reserve next object ID for length\n\t\t    ++next_objid;\n\t\t}\n\t    }\n\t}\n        else if (obj_renumber[og] == 0)\n        {\n            // This can happen if a specially constructed file\n            // indicates that an object stream is inside itself.\n            QTC::TC(\"qpdf\", \"QPDFWriter ignore self-referential object stream\");\n        }\n    }\n    else if (object.isArray())\n    {\n\tint n = object.getArrayNItems();\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t    if (! this->linearized)\n\t    {\n\t\tenqueueObject(object.getArrayItem(i));\n\t    }\n\t}\n    }\n    else if (object.isDictionary())\n    {\n\tstd::set<std::string> keys = object.getKeys();\n\tfor (std::set<std::string>::iterator iter = keys.begin();\n\t     iter != keys.end(); ++iter)\n\t{\n\t    if (! this->linearized)\n\t    {\n\t\tenqueueObject(object.getKey(*iter));\n\t    }\n\t}\n    }\n    else\n    {\n\t// ignore\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,6 +22,9 @@\n \t\t// here.  Instead, enqueue the object stream.  Object\n \t\t// streams always have generation 0.\n \t\tint stream_id = this->object_to_object_stream[og];\n+                // Detect loops by storing invalid object ID 0, which\n+                // will get overwritten later.\n+                obj_renumber[og] = 0;\n \t\tenqueueObject(this->pdf.getObjectByID(stream_id, 0));\n \t    }\n \t    else\n@@ -47,6 +50,12 @@\n \t\t}\n \t    }\n \t}\n+        else if (obj_renumber[og] == 0)\n+        {\n+            // This can happen if a specially constructed file\n+            // indicates that an object stream is inside itself.\n+            QTC::TC(\"qpdf\", \"QPDFWriter ignore self-referential object stream\");\n+        }\n     }\n     else if (object.isArray())\n     {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "                // Detect loops by storing invalid object ID 0, which",
                "                // will get overwritten later.",
                "                obj_renumber[og] = 0;",
                "        else if (obj_renumber[og] == 0)",
                "        {",
                "            // This can happen if a specially constructed file",
                "            // indicates that an object stream is inside itself.",
                "            QTC::TC(\"qpdf\", \"QPDFWriter ignore self-referential object stream\");",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-18186",
        "func_name": "qpdf/QPDF::read_xref",
        "description": "An issue was discovered in QPDF before 7.0.0. There is an infinite loop due to looping xref tables in QPDF.cc.",
        "git_url": "https://github.com/qpdf/qpdf/commit/85f05cc57ffa0a863d9d9b23e73acea9410b2937",
        "commit_title": "Detect xref pointer infinite loop (fixes #149)",
        "commit_text": "",
        "func_before": "void\nQPDF::read_xref(qpdf_offset_t xref_offset)\n{\n    std::map<int, int> free_table;\n    while (xref_offset)\n    {\n        char buf[7];\n        memset(buf, 0, sizeof(buf));\n\tthis->m->file->seek(xref_offset, SEEK_SET);\n\tthis->m->file->read(buf, sizeof(buf) - 1);\n        // The PDF spec says xref must be followed by a line\n        // terminator, but files exist in the wild where it is\n        // terminated by arbitrary whitespace.\n        if ((strncmp(buf, \"xref\", 4) == 0) &&\n            QUtil::is_space(buf[4]))\n\t{\n            QTC::TC(\"qpdf\", \"QPDF xref space\",\n                    ((buf[4] == '\\n') ? 0 :\n                     (buf[4] == '\\r') ? 1 :\n                     (buf[4] == ' ') ? 2 : 9999));\n            int skip = 4;\n            // buf is null-terminated, and QUtil::is_space('\\0') is\n            // false, so this won't overrun.\n            while (QUtil::is_space(buf[skip]))\n            {\n                ++skip;\n            }\n            xref_offset = read_xrefTable(xref_offset + skip);\n\t}\n\telse\n\t{\n\t    xref_offset = read_xrefStream(xref_offset);\n\t}\n    }\n\n    if (! this->m->trailer.isInitialized())\n    {\n        throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), \"\", 0,\n                      \"unable to find trailer while reading xref\");\n    }\n    int size = this->m->trailer.getKey(\"/Size\").getIntValue();\n    int max_obj = 0;\n    if (! this->m->xref_table.empty())\n    {\n\tmax_obj = (*(this->m->xref_table.rbegin())).first.getObj();\n    }\n    if (! this->m->deleted_objects.empty())\n    {\n\tmax_obj = std::max(max_obj, *(this->m->deleted_objects.rbegin()));\n    }\n    if (size != max_obj + 1)\n    {\n\tQTC::TC(\"qpdf\", \"QPDF xref size mismatch\");\n\twarn(QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), \"\", 0,\n\t\t     std::string(\"reported number of objects (\") +\n\t\t     QUtil::int_to_string(size) +\n\t\t     \") inconsistent with actual number of objects (\" +\n\t\t     QUtil::int_to_string(max_obj + 1) + \")\"));\n    }\n\n    // We no longer need the deleted_objects table, so go ahead and\n    // clear it out to make sure we never depend on its being set.\n    this->m->deleted_objects.clear();\n}",
        "func": "void\nQPDF::read_xref(qpdf_offset_t xref_offset)\n{\n    std::map<int, int> free_table;\n    std::set<qpdf_offset_t> visited;\n    while (xref_offset)\n    {\n        visited.insert(xref_offset);\n        char buf[7];\n        memset(buf, 0, sizeof(buf));\n\tthis->m->file->seek(xref_offset, SEEK_SET);\n\tthis->m->file->read(buf, sizeof(buf) - 1);\n        // The PDF spec says xref must be followed by a line\n        // terminator, but files exist in the wild where it is\n        // terminated by arbitrary whitespace.\n        if ((strncmp(buf, \"xref\", 4) == 0) &&\n            QUtil::is_space(buf[4]))\n\t{\n            QTC::TC(\"qpdf\", \"QPDF xref space\",\n                    ((buf[4] == '\\n') ? 0 :\n                     (buf[4] == '\\r') ? 1 :\n                     (buf[4] == ' ') ? 2 : 9999));\n            int skip = 4;\n            // buf is null-terminated, and QUtil::is_space('\\0') is\n            // false, so this won't overrun.\n            while (QUtil::is_space(buf[skip]))\n            {\n                ++skip;\n            }\n            xref_offset = read_xrefTable(xref_offset + skip);\n\t}\n\telse\n\t{\n\t    xref_offset = read_xrefStream(xref_offset);\n\t}\n        if (visited.count(xref_offset) != 0)\n        {\n            xref_offset = 0;\n        }\n    }\n\n    if (! this->m->trailer.isInitialized())\n    {\n        throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), \"\", 0,\n                      \"unable to find trailer while reading xref\");\n    }\n    int size = this->m->trailer.getKey(\"/Size\").getIntValue();\n    int max_obj = 0;\n    if (! this->m->xref_table.empty())\n    {\n\tmax_obj = (*(this->m->xref_table.rbegin())).first.getObj();\n    }\n    if (! this->m->deleted_objects.empty())\n    {\n\tmax_obj = std::max(max_obj, *(this->m->deleted_objects.rbegin()));\n    }\n    if (size != max_obj + 1)\n    {\n\tQTC::TC(\"qpdf\", \"QPDF xref size mismatch\");\n\twarn(QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), \"\", 0,\n\t\t     std::string(\"reported number of objects (\") +\n\t\t     QUtil::int_to_string(size) +\n\t\t     \") inconsistent with actual number of objects (\" +\n\t\t     QUtil::int_to_string(max_obj + 1) + \")\"));\n    }\n\n    // We no longer need the deleted_objects table, so go ahead and\n    // clear it out to make sure we never depend on its being set.\n    this->m->deleted_objects.clear();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,8 +2,10 @@\n QPDF::read_xref(qpdf_offset_t xref_offset)\n {\n     std::map<int, int> free_table;\n+    std::set<qpdf_offset_t> visited;\n     while (xref_offset)\n     {\n+        visited.insert(xref_offset);\n         char buf[7];\n         memset(buf, 0, sizeof(buf));\n \tthis->m->file->seek(xref_offset, SEEK_SET);\n@@ -31,6 +33,10 @@\n \t{\n \t    xref_offset = read_xrefStream(xref_offset);\n \t}\n+        if (visited.count(xref_offset) != 0)\n+        {\n+            xref_offset = 0;\n+        }\n     }\n \n     if (! this->m->trailer.isInitialized())",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    std::set<qpdf_offset_t> visited;",
                "        visited.insert(xref_offset);",
                "        if (visited.count(xref_offset) != 0)",
                "        {",
                "            xref_offset = 0;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-24808",
        "func_name": "michaelrsweet/pdfio/_pdfioDictSetValue",
        "description": " PDFio is a C library for reading and writing PDF files. In versions prior to 1.1.0 a denial of service (DOS) vulnerability exists in the pdfio parser. Crafted pdf files can cause the program to run at 100% utilization and never terminate. The pdf which causes this crash found in testing is about 28kb in size and was discovered via fuzzing. Anyone who uses this library either as a standalone binary or as a library can be DOSed when attempting to parse this type of file. Web servers or other automated processes which rely on this code to turn pdf submissions into plaintext can be DOSed when an attacker uploads the pdf. Please see the linked GHSA for an example pdf. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
        "git_url": "https://github.com/michaelrsweet/pdfio/commit/4f10021e7ee527c1aa24853e2947e38e154d9ccb",
        "commit_title": "Fix denial-of-service attack when reading corrupt PDF files.",
        "commit_text": "",
        "func_before": "bool\t\t\t\t\t// O - `true` on success, `false` on failure\n_pdfioDictSetValue(\n    pdfio_dict_t   *dict,\t\t// I - Dictionary\n    const char     *key,\t\t// I - Key\n    _pdfio_value_t *value)\t\t// I - Value\n{\n  _pdfio_pair_t\t*pair;\t\t\t// Current pair\n\n\n  PDFIO_DEBUG(\"_pdfioDictSetValue(dict=%p, key=\\\"%s\\\", value=%p)\\n\", dict, key, (void *)value);\n\n  // See if the key is already set...\n  if (dict->num_pairs > 0)\n  {\n    _pdfio_pair_t\tpkey;\t\t// Search key\n\n    pkey.key = key;\n\n    if ((pair = (_pdfio_pair_t *)bsearch(&pkey, dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs)) != NULL)\n    {\n      // Yes, replace the value...\n      PDFIO_DEBUG(\"_pdfioDictSetValue: Replacing existing value.\\n\");\n      if (pair->value.type == PDFIO_VALTYPE_BINARY)\n        free(pair->value.value.binary.data);\n      pair->value = *value;\n      return (true);\n    }\n  }\n\n  // Nope, add a pair...\n  if (dict->num_pairs >= dict->alloc_pairs)\n  {\n    // Expand the dictionary...\n    _pdfio_pair_t *temp = (_pdfio_pair_t *)realloc(dict->pairs, (dict->alloc_pairs + 8) * sizeof(_pdfio_pair_t));\n\n    if (!temp)\n    {\n      PDFIO_DEBUG(\"_pdfioDictSetValue: Out of memory.\\n\");\n      return (false);\n    }\n\n    dict->pairs       = temp;\n    dict->alloc_pairs += 8;\n  }\n\n  pair = dict->pairs + dict->num_pairs;\n  dict->num_pairs ++;\n\n  pair->key   = key;\n  pair->value = *value;\n\n  // Re-sort the dictionary and return...\n  if (dict->num_pairs > 1 && compare_pairs(pair - 1, pair) > 0)\n    qsort(dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs);\n\n#ifdef DEBUG\n  PDFIO_DEBUG(\"_pdfioDictSetValue(%p): %lu pairs\\n\", (void *)dict, (unsigned long)dict->num_pairs);\n  PDFIO_DEBUG(\"_pdfioDictSetValue(%p): \", (void *)dict);\n  PDFIO_DEBUG_DICT(dict);\n  PDFIO_DEBUG(\"\\n\");\n#endif // DEBUG\n\n  return (true);\n}",
        "func": "bool\t\t\t\t\t// O - `true` on success, `false` on failure\n_pdfioDictSetValue(\n    pdfio_dict_t   *dict,\t\t// I - Dictionary\n    const char     *key,\t\t// I - Key\n    _pdfio_value_t *value)\t\t// I - Value\n{\n  _pdfio_pair_t\t*pair;\t\t\t// Current pair\n\n\n  PDFIO_DEBUG(\"_pdfioDictSetValue(dict=%p, key=\\\"%s\\\", value=%p)\\n\", dict, key, (void *)value);\n\n  // See if the key is already set...\n  if (dict->num_pairs > 0)\n  {\n    _pdfio_pair_t\tpkey;\t\t// Search key\n\n    pkey.key = key;\n\n    if ((pair = (_pdfio_pair_t *)bsearch(&pkey, dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs)) != NULL)\n    {\n      // Yes, replace the value...\n      PDFIO_DEBUG(\"_pdfioDictSetValue: Replacing existing value.\\n\");\n      if (pair->value.type == PDFIO_VALTYPE_BINARY)\n        free(pair->value.value.binary.data);\n      pair->value = *value;\n      return (true);\n    }\n  }\n\n  // Nope, add a pair...\n  if (dict->num_pairs >= dict->alloc_pairs)\n  {\n    // Expand the dictionary...\n    _pdfio_pair_t *temp = (_pdfio_pair_t *)realloc(dict->pairs, (dict->alloc_pairs + 8) * sizeof(_pdfio_pair_t));\n\n    if (!temp)\n    {\n      PDFIO_DEBUG(\"_pdfioDictSetValue: Out of memory.\\n\");\n      return (false);\n    }\n\n    dict->pairs       = temp;\n    dict->alloc_pairs += 8;\n  }\n\n  pair = dict->pairs + dict->num_pairs;\n  dict->num_pairs ++;\n\n  pair->key   = key;\n  pair->value = *value;\n\n  // Re-sort the dictionary and return...\n  if (dict->num_pairs > 1 && compare_pairs(pair - 1, pair) > 0)\n    qsort(dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs);\n\n#ifdef DEBUG\n  PDFIO_DEBUG(\"_pdfioDictSetValue(%p): %lu pairs\\n\", (void *)dict, (unsigned long)dict->num_pairs);\n//  PDFIO_DEBUG(\"_pdfioDictSetValue(%p): \", (void *)dict);\n//  PDFIO_DEBUG_DICT(dict);\n//  PDFIO_DEBUG(\"\\n\");\n#endif // DEBUG\n\n  return (true);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -55,9 +55,9 @@\n \n #ifdef DEBUG\n   PDFIO_DEBUG(\"_pdfioDictSetValue(%p): %lu pairs\\n\", (void *)dict, (unsigned long)dict->num_pairs);\n-  PDFIO_DEBUG(\"_pdfioDictSetValue(%p): \", (void *)dict);\n-  PDFIO_DEBUG_DICT(dict);\n-  PDFIO_DEBUG(\"\\n\");\n+//  PDFIO_DEBUG(\"_pdfioDictSetValue(%p): \", (void *)dict);\n+//  PDFIO_DEBUG_DICT(dict);\n+//  PDFIO_DEBUG(\"\\n\");\n #endif // DEBUG\n \n   return (true);",
        "diff_line_info": {
            "deleted_lines": [
                "  PDFIO_DEBUG(\"_pdfioDictSetValue(%p): \", (void *)dict);",
                "  PDFIO_DEBUG_DICT(dict);",
                "  PDFIO_DEBUG(\"\\n\");"
            ],
            "added_lines": [
                "//  PDFIO_DEBUG(\"_pdfioDictSetValue(%p): \", (void *)dict);",
                "//  PDFIO_DEBUG_DICT(dict);",
                "//  PDFIO_DEBUG(\"\\n\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-24808",
        "func_name": "michaelrsweet/pdfio/_pdfioDictRead",
        "description": " PDFio is a C library for reading and writing PDF files. In versions prior to 1.1.0 a denial of service (DOS) vulnerability exists in the pdfio parser. Crafted pdf files can cause the program to run at 100% utilization and never terminate. The pdf which causes this crash found in testing is about 28kb in size and was discovered via fuzzing. Anyone who uses this library either as a standalone binary or as a library can be DOSed when attempting to parse this type of file. Web servers or other automated processes which rely on this code to turn pdf submissions into plaintext can be DOSed when an attacker uploads the pdf. Please see the linked GHSA for an example pdf. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
        "git_url": "https://github.com/michaelrsweet/pdfio/commit/4f10021e7ee527c1aa24853e2947e38e154d9ccb",
        "commit_title": "Fix denial-of-service attack when reading corrupt PDF files.",
        "commit_text": "",
        "func_before": "pdfio_dict_t *\t\t\t\t// O - New dictionary\n_pdfioDictRead(pdfio_file_t   *pdf,\t// I - PDF file\n               pdfio_obj_t    *obj,\t// I - Object, if any\n               _pdfio_token_t *tb,\t// I - Token buffer/stack\n               size_t         depth)\t// I - Depth of dictionary\n{\n  pdfio_dict_t\t\t*dict;\t\t// New dictionary\n  char\t\t\tkey[256];\t// Dictionary key\n  _pdfio_value_t\tvalue;\t\t// Dictionary value\n\n\n  PDFIO_DEBUG(\"_pdfioDictRead(pdf=%p)\\n\", pdf);\n\n  // Create a dictionary and start reading...\n  if ((dict = pdfioDictCreate(pdf)) == NULL)\n    return (NULL);\n\n  while (_pdfioTokenGet(tb, key, sizeof(key)))\n  {\n    // Get the next key or end-of-dictionary...\n    if (!strcmp(key, \">>\"))\n    {\n      // End of dictionary...\n      return (dict);\n    }\n    else if (key[0] != '/')\n    {\n      _pdfioFileError(pdf, \"Invalid dictionary contents.\");\n      break;\n    }\n\n    // Then get the next value...\n    if (!_pdfioValueRead(pdf, obj, tb, &value, depth))\n    {\n      _pdfioFileError(pdf, \"Missing value for dictionary key.\");\n      break;\n    }\n\n    if (!_pdfioDictSetValue(dict, pdfioStringCreate(pdf, key + 1), &value))\n      break;\n\n//    PDFIO_DEBUG(\"_pdfioDictRead: Set %s.\\n\", key);\n  }\n\n  // Dictionary is invalid - pdfioFileClose will free the memory, return NULL\n  // to indicate an error...\n  return (NULL);\n}",
        "func": "pdfio_dict_t *\t\t\t\t// O - New dictionary\n_pdfioDictRead(pdfio_file_t   *pdf,\t// I - PDF file\n               pdfio_obj_t    *obj,\t// I - Object, if any\n               _pdfio_token_t *tb,\t// I - Token buffer/stack\n               size_t         depth)\t// I - Depth of dictionary\n{\n  pdfio_dict_t\t\t*dict;\t\t// New dictionary\n  char\t\t\tkey[256];\t// Dictionary key\n  _pdfio_value_t\tvalue;\t\t// Dictionary value\n\n\n  PDFIO_DEBUG(\"_pdfioDictRead(pdf=%p)\\n\", pdf);\n\n  // Create a dictionary and start reading...\n  if ((dict = pdfioDictCreate(pdf)) == NULL)\n    return (NULL);\n\n  while (_pdfioTokenGet(tb, key, sizeof(key)))\n  {\n    // Get the next key or end-of-dictionary...\n    if (!strcmp(key, \">>\"))\n    {\n      // End of dictionary...\n      return (dict);\n    }\n    else if (key[0] != '/')\n    {\n      _pdfioFileError(pdf, \"Invalid dictionary contents.\");\n      break;\n    }\n    else if (_pdfioDictGetValue(dict, key + 1))\n    {\n      _pdfioFileError(pdf, \"Duplicate dictionary key '%s'.\", key + 1);\n      return (NULL);\n    }\n\n    // Then get the next value...\n    PDFIO_DEBUG(\"_pdfioDictRead: Reading value for '%s'.\\n\", key + 1);\n\n    if (!_pdfioValueRead(pdf, obj, tb, &value, depth))\n    {\n      _pdfioFileError(pdf, \"Missing value for dictionary key.\");\n      break;\n    }\n\n    if (!_pdfioDictSetValue(dict, pdfioStringCreate(pdf, key + 1), &value))\n      break;\n\n//    PDFIO_DEBUG(\"_pdfioDictRead: Set %s.\\n\", key);\n  }\n\n  // Dictionary is invalid - pdfioFileClose will free the memory, return NULL\n  // to indicate an error...\n  return (NULL);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,8 +28,15 @@\n       _pdfioFileError(pdf, \"Invalid dictionary contents.\");\n       break;\n     }\n+    else if (_pdfioDictGetValue(dict, key + 1))\n+    {\n+      _pdfioFileError(pdf, \"Duplicate dictionary key '%s'.\", key + 1);\n+      return (NULL);\n+    }\n \n     // Then get the next value...\n+    PDFIO_DEBUG(\"_pdfioDictRead: Reading value for '%s'.\\n\", key + 1);\n+\n     if (!_pdfioValueRead(pdf, obj, tb, &value, depth))\n     {\n       _pdfioFileError(pdf, \"Missing value for dictionary key.\");",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    else if (_pdfioDictGetValue(dict, key + 1))",
                "    {",
                "      _pdfioFileError(pdf, \"Duplicate dictionary key '%s'.\", key + 1);",
                "      return (NULL);",
                "    }",
                "    PDFIO_DEBUG(\"_pdfioDictRead: Reading value for '%s'.\\n\", key + 1);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-24808",
        "func_name": "michaelrsweet/pdfio/_pdfioFileConsume",
        "description": " PDFio is a C library for reading and writing PDF files. In versions prior to 1.1.0 a denial of service (DOS) vulnerability exists in the pdfio parser. Crafted pdf files can cause the program to run at 100% utilization and never terminate. The pdf which causes this crash found in testing is about 28kb in size and was discovered via fuzzing. Anyone who uses this library either as a standalone binary or as a library can be DOSed when attempting to parse this type of file. Web servers or other automated processes which rely on this code to turn pdf submissions into plaintext can be DOSed when an attacker uploads the pdf. Please see the linked GHSA for an example pdf. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
        "git_url": "https://github.com/michaelrsweet/pdfio/commit/4f10021e7ee527c1aa24853e2947e38e154d9ccb",
        "commit_title": "Fix denial-of-service attack when reading corrupt PDF files.",
        "commit_text": "",
        "func_before": "bool\t\t\t\t\t// O - `true` on sucess, `false` on EOF\n_pdfioFileConsume(pdfio_file_t *pdf,\t// I - PDF file\n                  size_t       bytes)\t// I - Bytes to consume\n{\n  PDFIO_DEBUG(\"_pdfioFileConsume(pdf=%p, bytes=%u)\\n\", pdf, (unsigned)bytes);\n\n  if ((size_t)(pdf->bufend - pdf->bufptr) > bytes)\n    pdf->bufptr += bytes;\n  else if (_pdfioFileSeek(pdf, (off_t)bytes, SEEK_CUR) < 0)\n    return (false);\n\n  return (true);\n}",
        "func": "bool\t\t\t\t\t// O - `true` on sucess, `false` on EOF\n_pdfioFileConsume(pdfio_file_t *pdf,\t// I - PDF file\n                  size_t       bytes)\t// I - Bytes to consume\n{\n  PDFIO_DEBUG(\"_pdfioFileConsume(pdf=%p, bytes=%u)\\n\", pdf, (unsigned)bytes);\n\n  if ((size_t)(pdf->bufend - pdf->bufptr) > bytes)\n    pdf->bufptr += bytes;\n  else if (_pdfioFileSeek(pdf, (off_t)bytes, SEEK_CUR) < 0)\n    return (false);\n\n  PDFIO_DEBUG(\"_pdfioFileConsume: pos=%ld\\n\", (long)(pdf->bufpos + pdf->bufptr - pdf->buffer));\n\n  return (true);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,5 +9,7 @@\n   else if (_pdfioFileSeek(pdf, (off_t)bytes, SEEK_CUR) < 0)\n     return (false);\n \n+  PDFIO_DEBUG(\"_pdfioFileConsume: pos=%ld\\n\", (long)(pdf->bufpos + pdf->bufptr - pdf->buffer));\n+\n   return (true);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  PDFIO_DEBUG(\"_pdfioFileConsume: pos=%ld\\n\", (long)(pdf->bufpos + pdf->bufptr - pdf->buffer));",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-24808",
        "func_name": "michaelrsweet/pdfio/load_xref",
        "description": " PDFio is a C library for reading and writing PDF files. In versions prior to 1.1.0 a denial of service (DOS) vulnerability exists in the pdfio parser. Crafted pdf files can cause the program to run at 100% utilization and never terminate. The pdf which causes this crash found in testing is about 28kb in size and was discovered via fuzzing. Anyone who uses this library either as a standalone binary or as a library can be DOSed when attempting to parse this type of file. Web servers or other automated processes which rely on this code to turn pdf submissions into plaintext can be DOSed when an attacker uploads the pdf. Please see the linked GHSA for an example pdf. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
        "git_url": "https://github.com/michaelrsweet/pdfio/commit/4f10021e7ee527c1aa24853e2947e38e154d9ccb",
        "commit_title": "Fix denial-of-service attack when reading corrupt PDF files.",
        "commit_text": "",
        "func_before": "static bool\t\t\t\t// O - `true` on success, `false` on failure\nload_xref(\n    pdfio_file_t        *pdf,\t\t// I - PDF file\n    off_t               xref_offset,\t// I - Offset to xref\n    pdfio_password_cb_t password_cb,\t// I - Password callback or `NULL` for none\n    void                *password_data)\t// I - Password callback data, if any\n{\n  bool\t\tdone = false;\t\t// Are we done?\n  char\t\tline[1024],\t\t// Line from file\n\t\t*ptr;\t\t\t// Pointer into line\n  _pdfio_value_t trailer;\t\t// Trailer dictionary\n  intmax_t\tnumber,\t\t\t// Object number\n\t\tnum_objects,\t\t// Number of objects\n\t\toffset;\t\t\t// Offset in file\n  int\t\tgeneration;\t\t// Generation number\n  _pdfio_token_t tb;\t\t\t// Token buffer/stack\n  off_t\t\tline_offset;\t\t// Offset to start of line\n\n\n  while (!done)\n  {\n    if (_pdfioFileSeek(pdf, xref_offset, SEEK_SET) != xref_offset)\n    {\n      _pdfioFileError(pdf, \"Unable to seek to start of xref table.\");\n      return (false);\n    }\n\n    do\n    {\n      line_offset = _pdfioFileTell(pdf);\n\n      if (!_pdfioFileGets(pdf, line, sizeof(line)))\n      {\n\t_pdfioFileError(pdf, \"Unable to read start of xref table.\");\n\treturn (false);\n      }\n    }\n    while (!line[0]);\n\n    PDFIO_DEBUG(\"load_xref: line_offset=%lu, line='%s'\\n\", (unsigned long)line_offset, line);\n\n    if (isdigit(line[0] & 255) && strlen(line) > 4 && (!strcmp(line + strlen(line) - 4, \" obj\") || ((ptr = strstr(line, \" obj\")) != NULL && ptr[4] == '<')))\n    {\n      // Cross-reference stream\n      pdfio_obj_t\t*obj;\t\t// Object\n      size_t\t\ti;\t\t// Looping var\n      pdfio_array_t\t*index_array;\t// Index array\n      size_t\t\tindex_n,\t// Current element in array\n\t\t\tindex_count,\t// Number of values in index array\n\t\t\tcount;\t\t// Number of objects in current pairing\n      pdfio_array_t\t*w_array;\t// W array\n      size_t\t\tw[3];\t\t// Size of each cross-reference field\n      size_t\t\tw_2,\t\t// Offset to second field\n\t\t\tw_3;\t\t// Offset to third field\n      size_t\t\tw_total;\t// Total length\n      pdfio_stream_t\t*st;\t\t// Stream\n      unsigned char\tbuffer[32];\t// Read buffer\n      size_t\t\tnum_sobjs = 0,\t// Number of object streams\n\t\t\tsobjs[4096];\t// Object streams to load\n      pdfio_obj_t\t*current;\t// Current object\n\n      if ((number = strtoimax(line, &ptr, 10)) < 1)\n      {\n\t_pdfioFileError(pdf, \"Bad xref table header '%s'.\", line);\n\treturn (false);\n      }\n\n      if ((generation = (int)strtol(ptr, &ptr, 10)) < 0 || generation > 65535)\n      {\n\t_pdfioFileError(pdf, \"Bad xref table header '%s'.\", line);\n\treturn (false);\n      }\n\n      while (isspace(*ptr & 255))\n\tptr ++;\n\n      if (strncmp(ptr, \"obj\", 3))\n      {\n\t_pdfioFileError(pdf, \"Bad xref table header '%s'.\", line);\n\treturn (false);\n      }\n\n      if (_pdfioFileSeek(pdf, line_offset + ptr + 3 - line, SEEK_SET) < 0)\n      {\n        _pdfioFileError(pdf, \"Unable to seek to xref object %lu %u.\", (unsigned long)number, (unsigned)generation);\n        return (false);\n      }\n\n      PDFIO_DEBUG(\"load_xref: Loading object %lu %u.\\n\", (unsigned long)number, (unsigned)generation);\n\n      if ((obj = add_obj(pdf, (size_t)number, (unsigned short)generation, xref_offset)) == NULL)\n      {\n        _pdfioFileError(pdf, \"Unable to allocate memory for object.\");\n        return (false);\n      }\n\n      _pdfioTokenInit(&tb, pdf, (_pdfio_tconsume_cb_t)_pdfioFileConsume, (_pdfio_tpeek_cb_t)_pdfioFilePeek, pdf);\n\n      if (!_pdfioValueRead(pdf, obj, &tb, &trailer, 0))\n      {\n        _pdfioFileError(pdf, \"Unable to read cross-reference stream dictionary.\");\n        return (false);\n      }\n      else if (trailer.type != PDFIO_VALTYPE_DICT)\n      {\n\t_pdfioFileError(pdf, \"Cross-reference stream does not have a dictionary.\");\n\treturn (false);\n      }\n\n      obj->value = trailer;\n\n      if (!_pdfioTokenGet(&tb, line, sizeof(line)) || strcmp(line, \"stream\"))\n      {\n        _pdfioFileError(pdf, \"Unable to get stream after xref dictionary.\");\n        return (false);\n      }\n\n      _pdfioTokenFlush(&tb);\n\n      obj->stream_offset = _pdfioFileTell(pdf);\n\n      if ((index_array = pdfioDictGetArray(trailer.value.dict, \"Index\")) != NULL)\n        index_count = index_array->num_values;\n      else\n        index_count = 1;\n\n      if ((w_array = pdfioDictGetArray(trailer.value.dict, \"W\")) == NULL)\n      {\n\t_pdfioFileError(pdf, \"Cross-reference stream does not have required W key.\");\n\treturn (false);\n      }\n\n      w[0]    = (size_t)pdfioArrayGetNumber(w_array, 0);\n      w[1]    = (size_t)pdfioArrayGetNumber(w_array, 1);\n      w[2]    = (size_t)pdfioArrayGetNumber(w_array, 2);\n      w_total = w[0] + w[1] + w[2];\n      w_2     = w[0];\n      w_3     = w[0] + w[1];\n\n      if (w[1] == 0 || w[2] > 2 || w[0] > sizeof(buffer) || w[1] > sizeof(buffer) || w[2] > sizeof(buffer) || w_total > sizeof(buffer))\n      {\n\t_pdfioFileError(pdf, \"Cross-reference stream has invalid W key.\");\n\treturn (false);\n      }\n\n      if ((st = pdfioObjOpenStream(obj, true)) == NULL)\n      {\n\t_pdfioFileError(pdf, \"Unable to open cross-reference stream.\");\n\treturn (false);\n      }\n\n      for (index_n = 0; index_n < index_count; index_n += 2)\n      {\n        if (index_count == 1)\n        {\n          number = 0;\n          count  = 999999999;\n\t}\n\telse\n\t{\n          number = (intmax_t)pdfioArrayGetNumber(index_array, index_n);\n          count  = (size_t)pdfioArrayGetNumber(index_array, index_n + 1);\n\t}\n\n\twhile (count > 0 && pdfioStreamRead(st, buffer, w_total) > 0)\n\t{\n\t  count --;\n\n\t  PDFIO_DEBUG(\"load_xref: number=%u %02X%02X%02X%02X%02X\\n\", (unsigned)number, buffer[0], buffer[1], buffer[2], buffer[3], buffer[4]);\n\n\t  // Check whether this is an object definition...\n\t  if (w[0] > 0)\n\t  {\n\t    if (buffer[0] == 0)\n\t    {\n\t      // Ignore free objects...\n\t      number ++;\n\t      continue;\n\t    }\n\t  }\n\n\t  for (i = 1, offset = buffer[w_2]; i < w[1]; i ++)\n\t    offset = (offset << 8) | buffer[w_2 + i];\n\n\t  switch (w[2])\n\t  {\n\t    default :\n\t\tgeneration = 0;\n\t\tbreak;\n\t    case 1 :\n\t\tgeneration = buffer[w_3];\n\t\tbreak;\n\t    case 2 :\n\t\tgeneration = (buffer[w_3] << 8) | buffer[w_3 + 1];\n\t\tbreak;\n\t  }\n\n\t  // Create a placeholder for the object in memory...\n\t  if ((current = pdfioFileFindObj(pdf, (size_t)number)) != NULL)\n\t  {\n\t    PDFIO_DEBUG(\"load_xref: existing object, prev offset=%u\\n\", (unsigned)current->offset);\n\n            if (w[0] == 0 || buffer[0] == 1)\n            {\n              // Location of object...\n\t      current->offset = offset;\n\t    }\n\t    else if (number != offset)\n\t    {\n\t      // Object is part of a stream, offset is the object number...\n\t      current->offset = 0;\n\t    }\n\n\t    PDFIO_DEBUG(\"load_xref: new offset=%u\\n\", (unsigned)current->offset);\n\t  }\n\n\t  if (w[0] > 0 && buffer[0] == 2)\n\t  {\n\t    // Object streams need to be loaded into memory, so add them\n\t    // to the list of objects to load later as needed...\n\t    for (i = 0; i < num_sobjs; i ++)\n\t    {\n\t      if (sobjs[i] == (size_t)offset)\n\t\tbreak;\n\t    }\n\n\t    if (i >= num_sobjs && num_sobjs < (sizeof(sobjs) / sizeof(sobjs[0])))\n\t      sobjs[num_sobjs ++] = (size_t)offset;\n\t  }\n\t  else if (!current)\n\t  {\n\t    // Add this object...\n\t    if (!add_obj(pdf, (size_t)number, (unsigned short)generation, offset))\n\t      return (false);\n\t  }\n\n\t  number ++;\n\t}\n      }\n\n      pdfioStreamClose(st);\n\n      if (!pdf->trailer_dict)\n      {\n\t// Save the trailer dictionary and grab the root (catalog) and info\n\t// objects...\n\tpdf->trailer_dict = trailer.value.dict;\n\tpdf->info_obj     = pdfioDictGetObj(pdf->trailer_dict, \"Info\");\n\tpdf->encrypt_obj  = pdfioDictGetObj(pdf->trailer_dict, \"Encrypt\");\n\tpdf->id_array     = pdfioDictGetArray(pdf->trailer_dict, \"ID\");\n\n\t// If the trailer contains an Encrypt key, try unlocking the file...\n\tif (pdf->encrypt_obj && !_pdfioCryptoUnlock(pdf, password_cb, password_data))\n\t  return (false);\n      }\n\n      // Load any object streams that are left...\n      PDFIO_DEBUG(\"load_xref: %lu compressed object streams to load.\\n\", (unsigned long)num_sobjs);\n\n      for (i = 0; i < num_sobjs; i ++)\n      {\n        if ((obj = pdfioFileFindObj(pdf, sobjs[i])) != NULL)\n        {\n\t  PDFIO_DEBUG(\"load_xref: Loading compressed object stream %lu (pdf=%p, obj->pdf=%p).\\n\", (unsigned long)sobjs[i], pdf, obj->pdf);\n\n          if (!load_obj_stream(obj))\n            return (false);\n\t}\n\telse\n\t{\n\t  _pdfioFileError(pdf, \"Unable to find compressed object stream %lu.\", (unsigned long)sobjs[i]);\n\t  return (false);\n\t}\n      }\n    }\n    else if (!strcmp(line, \"xref\"))\n    {\n      // Read the xref tables\n      while (_pdfioFileGets(pdf, line, sizeof(line)))\n      {\n\tif (!strcmp(line, \"trailer\"))\n\t  break;\n\telse if (!line[0])\n\t  continue;\n\n\tif (sscanf(line, \"%jd%jd\", &number, &num_objects) != 2)\n\t{\n\t  _pdfioFileError(pdf, \"Malformed xref table section '%s'.\", line);\n\t  return (false);\n\t}\n\n\t// Read this group of objects...\n\tfor (; num_objects > 0; num_objects --, number ++)\n\t{\n\t  // Read a line from the file and validate it...\n\t  if (_pdfioFileRead(pdf, line, 20) != 20)\n\t    return (false);\n\n\t  line[20] = '\\0';\n\n\t  if (strcmp(line + 18, \"\\r\\n\") && strcmp(line + 18, \" \\n\") && strcmp(line + 18, \" \\r\"))\n\t  {\n\t    _pdfioFileError(pdf, \"Malformed xref table entry '%s'.\", line);\n\t    return (false);\n\t  }\n\t  line[18] = '\\0';\n\n\t  // Parse the line\n\t  if ((offset = strtoimax(line, &ptr, 10)) < 0)\n\t  {\n\t    _pdfioFileError(pdf, \"Malformed xref table entry '%s'.\", line);\n\t    return (false);\n\t  }\n\n\t  if ((generation = (int)strtol(ptr, &ptr, 10)) < 0 || generation > 65535)\n\t  {\n\t    _pdfioFileError(pdf, \"Malformed xref table entry '%s'.\", line);\n\t    return (false);\n\t  }\n\n\t  if (*ptr != ' ')\n\t  {\n\t    _pdfioFileError(pdf, \"Malformed xref table entry '%s'.\", line);\n\t    return (false);\n\t  }\n\n\t  ptr ++;\n\t  if (*ptr != 'f' && *ptr != 'n')\n\t  {\n\t    _pdfioFileError(pdf, \"Malformed xref table entry '%s'.\", line);\n\t    return (false);\n\t  }\n\n\t  if (*ptr == 'f')\n\t    continue;\t\t\t// Don't care about free objects...\n\n\t  // Create a placeholder for the object in memory...\n\t  if (pdfioFileFindObj(pdf, (size_t)number))\n\t    continue;\t\t\t// Don't replace newer object...\n\n\t  if (!add_obj(pdf, (size_t)number, (unsigned short)generation, offset))\n\t    return (false);\n\t}\n      }\n\n      if (strcmp(line, \"trailer\"))\n      {\n\t_pdfioFileError(pdf, \"Missing trailer.\");\n\treturn (false);\n      }\n\n      _pdfioTokenInit(&tb, pdf, (_pdfio_tconsume_cb_t)_pdfioFileConsume, (_pdfio_tpeek_cb_t)_pdfioFilePeek, pdf);\n\n      if (!_pdfioValueRead(pdf, NULL, &tb, &trailer, 0))\n      {\n\t_pdfioFileError(pdf, \"Unable to read trailer dictionary.\");\n\treturn (false);\n      }\n      else if (trailer.type != PDFIO_VALTYPE_DICT)\n      {\n\t_pdfioFileError(pdf, \"Trailer is not a dictionary.\");\n\treturn (false);\n      }\n\n      _pdfioTokenFlush(&tb);\n\n      if (!pdf->trailer_dict)\n      {\n\t// Save the trailer dictionary and grab the root (catalog) and info\n\t// objects...\n\tpdf->trailer_dict = trailer.value.dict;\n\tpdf->info_obj     = pdfioDictGetObj(pdf->trailer_dict, \"Info\");\n\tpdf->encrypt_obj  = pdfioDictGetObj(pdf->trailer_dict, \"Encrypt\");\n\tpdf->id_array     = pdfioDictGetArray(pdf->trailer_dict, \"ID\");\n\n\t// If the trailer contains an Encrypt key, try unlocking the file...\n\tif (pdf->encrypt_obj && !_pdfioCryptoUnlock(pdf, password_cb, password_data))\n\t  return (false);\n      }\n    }\n    else\n    {\n      _pdfioFileError(pdf, \"Bad xref table header '%s'.\", line);\n      return (false);\n    }\n\n    PDFIO_DEBUG(\"load_xref: Contents of trailer dictionary:\\n\");\n    PDFIO_DEBUG(\"load_xref: \");\n    PDFIO_DEBUG_VALUE(&trailer);\n    PDFIO_DEBUG(\"\\n\");\n\n    if ((xref_offset = (off_t)pdfioDictGetNumber(trailer.value.dict, \"Prev\")) <= 0)\n      done = true;\n  }\n\n  // Once we have all of the xref tables loaded, get the important objects and\n  // build the pages array...\n  if ((pdf->root_obj = pdfioDictGetObj(pdf->trailer_dict, \"Root\")) == NULL)\n  {\n    _pdfioFileError(pdf, \"Missing Root object.\");\n    return (false);\n  }\n\n  PDFIO_DEBUG(\"load_xref: Root=%p(%lu)\\n\", pdf->root_obj, (unsigned long)pdf->root_obj->number);\n\n  return (load_pages(pdf, pdfioDictGetObj(pdfioObjGetDict(pdf->root_obj), \"Pages\"), 0));\n}",
        "func": "static bool\t\t\t\t// O - `true` on success, `false` on failure\nload_xref(\n    pdfio_file_t        *pdf,\t\t// I - PDF file\n    off_t               xref_offset,\t// I - Offset to xref\n    pdfio_password_cb_t password_cb,\t// I - Password callback or `NULL` for none\n    void                *password_data)\t// I - Password callback data, if any\n{\n  bool\t\tdone = false;\t\t// Are we done?\n  char\t\tline[1024],\t\t// Line from file\n\t\t*ptr;\t\t\t// Pointer into line\n  _pdfio_value_t trailer;\t\t// Trailer dictionary\n  intmax_t\tnumber,\t\t\t// Object number\n\t\tnum_objects,\t\t// Number of objects\n\t\toffset;\t\t\t// Offset in file\n  int\t\tgeneration;\t\t// Generation number\n  _pdfio_token_t tb;\t\t\t// Token buffer/stack\n  off_t\t\tline_offset;\t\t// Offset to start of line\n\n\n  while (!done)\n  {\n    if (_pdfioFileSeek(pdf, xref_offset, SEEK_SET) != xref_offset)\n    {\n      _pdfioFileError(pdf, \"Unable to seek to start of xref table.\");\n      return (false);\n    }\n\n    do\n    {\n      line_offset = _pdfioFileTell(pdf);\n\n      if (!_pdfioFileGets(pdf, line, sizeof(line)))\n      {\n\t_pdfioFileError(pdf, \"Unable to read start of xref table.\");\n\treturn (false);\n      }\n    }\n    while (!line[0]);\n\n    PDFIO_DEBUG(\"load_xref: line_offset=%lu, line='%s'\\n\", (unsigned long)line_offset, line);\n\n    if (isdigit(line[0] & 255) && strlen(line) > 4 && (!strcmp(line + strlen(line) - 4, \" obj\") || ((ptr = strstr(line, \" obj\")) != NULL && ptr[4] == '<')))\n    {\n      // Cross-reference stream\n      pdfio_obj_t\t*obj;\t\t// Object\n      size_t\t\ti;\t\t// Looping var\n      pdfio_array_t\t*index_array;\t// Index array\n      size_t\t\tindex_n,\t// Current element in array\n\t\t\tindex_count,\t// Number of values in index array\n\t\t\tcount;\t\t// Number of objects in current pairing\n      pdfio_array_t\t*w_array;\t// W array\n      size_t\t\tw[3];\t\t// Size of each cross-reference field\n      size_t\t\tw_2,\t\t// Offset to second field\n\t\t\tw_3;\t\t// Offset to third field\n      size_t\t\tw_total;\t// Total length\n      pdfio_stream_t\t*st;\t\t// Stream\n      unsigned char\tbuffer[32];\t// Read buffer\n      size_t\t\tnum_sobjs = 0,\t// Number of object streams\n\t\t\tsobjs[4096];\t// Object streams to load\n      pdfio_obj_t\t*current;\t// Current object\n\n      if ((number = strtoimax(line, &ptr, 10)) < 1)\n      {\n\t_pdfioFileError(pdf, \"Bad xref table header '%s'.\", line);\n\treturn (false);\n      }\n\n      if ((generation = (int)strtol(ptr, &ptr, 10)) < 0 || generation > 65535)\n      {\n\t_pdfioFileError(pdf, \"Bad xref table header '%s'.\", line);\n\treturn (false);\n      }\n\n      while (isspace(*ptr & 255))\n\tptr ++;\n\n      if (strncmp(ptr, \"obj\", 3))\n      {\n\t_pdfioFileError(pdf, \"Bad xref table header '%s'.\", line);\n\treturn (false);\n      }\n\n      if (_pdfioFileSeek(pdf, line_offset + ptr + 3 - line, SEEK_SET) < 0)\n      {\n        _pdfioFileError(pdf, \"Unable to seek to xref object %lu %u.\", (unsigned long)number, (unsigned)generation);\n        return (false);\n      }\n\n      PDFIO_DEBUG(\"load_xref: Loading object %lu %u.\\n\", (unsigned long)number, (unsigned)generation);\n\n      if ((obj = add_obj(pdf, (size_t)number, (unsigned short)generation, xref_offset)) == NULL)\n      {\n        _pdfioFileError(pdf, \"Unable to allocate memory for object.\");\n        return (false);\n      }\n\n      _pdfioTokenInit(&tb, pdf, (_pdfio_tconsume_cb_t)_pdfioFileConsume, (_pdfio_tpeek_cb_t)_pdfioFilePeek, pdf);\n\n      if (!_pdfioValueRead(pdf, obj, &tb, &trailer, 0))\n      {\n        _pdfioFileError(pdf, \"Unable to read cross-reference stream dictionary.\");\n        return (false);\n      }\n      else if (trailer.type != PDFIO_VALTYPE_DICT)\n      {\n\t_pdfioFileError(pdf, \"Cross-reference stream does not have a dictionary.\");\n\treturn (false);\n      }\n\n      obj->value = trailer;\n\n      if (!_pdfioTokenGet(&tb, line, sizeof(line)) || strcmp(line, \"stream\"))\n      {\n        _pdfioFileError(pdf, \"Unable to get stream after xref dictionary.\");\n        return (false);\n      }\n\n      _pdfioTokenFlush(&tb);\n\n      obj->stream_offset = _pdfioFileTell(pdf);\n\n      if ((index_array = pdfioDictGetArray(trailer.value.dict, \"Index\")) != NULL)\n        index_count = index_array->num_values;\n      else\n        index_count = 1;\n\n      if ((w_array = pdfioDictGetArray(trailer.value.dict, \"W\")) == NULL)\n      {\n\t_pdfioFileError(pdf, \"Cross-reference stream does not have required W key.\");\n\treturn (false);\n      }\n\n      w[0]    = (size_t)pdfioArrayGetNumber(w_array, 0);\n      w[1]    = (size_t)pdfioArrayGetNumber(w_array, 1);\n      w[2]    = (size_t)pdfioArrayGetNumber(w_array, 2);\n      w_total = w[0] + w[1] + w[2];\n      w_2     = w[0];\n      w_3     = w[0] + w[1];\n\n      if (w[1] == 0 || w[2] > 2 || w[0] > sizeof(buffer) || w[1] > sizeof(buffer) || w[2] > sizeof(buffer) || w_total > sizeof(buffer))\n      {\n\t_pdfioFileError(pdf, \"Cross-reference stream has invalid W key.\");\n\treturn (false);\n      }\n\n      if ((st = pdfioObjOpenStream(obj, true)) == NULL)\n      {\n\t_pdfioFileError(pdf, \"Unable to open cross-reference stream.\");\n\treturn (false);\n      }\n\n      for (index_n = 0; index_n < index_count; index_n += 2)\n      {\n        if (index_count == 1)\n        {\n          number = 0;\n          count  = 999999999;\n\t}\n\telse\n\t{\n          number = (intmax_t)pdfioArrayGetNumber(index_array, index_n);\n          count  = (size_t)pdfioArrayGetNumber(index_array, index_n + 1);\n\t}\n\n\twhile (count > 0 && pdfioStreamRead(st, buffer, w_total) > 0)\n\t{\n\t  count --;\n\n\t  PDFIO_DEBUG(\"load_xref: number=%u %02X%02X%02X%02X%02X\\n\", (unsigned)number, buffer[0], buffer[1], buffer[2], buffer[3], buffer[4]);\n\n\t  // Check whether this is an object definition...\n\t  if (w[0] > 0)\n\t  {\n\t    if (buffer[0] == 0)\n\t    {\n\t      // Ignore free objects...\n\t      number ++;\n\t      continue;\n\t    }\n\t  }\n\n\t  for (i = 1, offset = buffer[w_2]; i < w[1]; i ++)\n\t    offset = (offset << 8) | buffer[w_2 + i];\n\n\t  switch (w[2])\n\t  {\n\t    default :\n\t\tgeneration = 0;\n\t\tbreak;\n\t    case 1 :\n\t\tgeneration = buffer[w_3];\n\t\tbreak;\n\t    case 2 :\n\t\tgeneration = (buffer[w_3] << 8) | buffer[w_3 + 1];\n\t\tbreak;\n\t  }\n\n\t  // Create a placeholder for the object in memory...\n\t  if ((current = pdfioFileFindObj(pdf, (size_t)number)) != NULL)\n\t  {\n\t    PDFIO_DEBUG(\"load_xref: existing object, prev offset=%u\\n\", (unsigned)current->offset);\n\n            if (w[0] == 0 || buffer[0] == 1)\n            {\n              // Location of object...\n\t      current->offset = offset;\n\t    }\n\t    else if (number != offset)\n\t    {\n\t      // Object is part of a stream, offset is the object number...\n\t      current->offset = 0;\n\t    }\n\n\t    PDFIO_DEBUG(\"load_xref: new offset=%u\\n\", (unsigned)current->offset);\n\t  }\n\n\t  if (w[0] > 0 && buffer[0] == 2)\n\t  {\n\t    // Object streams need to be loaded into memory, so add them\n\t    // to the list of objects to load later as needed...\n\t    for (i = 0; i < num_sobjs; i ++)\n\t    {\n\t      if (sobjs[i] == (size_t)offset)\n\t\tbreak;\n\t    }\n\n\t    if (i >= num_sobjs && num_sobjs < (sizeof(sobjs) / sizeof(sobjs[0])))\n\t      sobjs[num_sobjs ++] = (size_t)offset;\n\t  }\n\t  else if (!current)\n\t  {\n\t    // Add this object...\n\t    if (!add_obj(pdf, (size_t)number, (unsigned short)generation, offset))\n\t      return (false);\n\t  }\n\n\t  number ++;\n\t}\n      }\n\n      pdfioStreamClose(st);\n\n      if (!pdf->trailer_dict)\n      {\n\t// Save the trailer dictionary and grab the root (catalog) and info\n\t// objects...\n\tpdf->trailer_dict = trailer.value.dict;\n\tpdf->info_obj     = pdfioDictGetObj(pdf->trailer_dict, \"Info\");\n\tpdf->encrypt_obj  = pdfioDictGetObj(pdf->trailer_dict, \"Encrypt\");\n\tpdf->id_array     = pdfioDictGetArray(pdf->trailer_dict, \"ID\");\n\n\t// If the trailer contains an Encrypt key, try unlocking the file...\n\tif (pdf->encrypt_obj && !_pdfioCryptoUnlock(pdf, password_cb, password_data))\n\t  return (false);\n      }\n\n      // Load any object streams that are left...\n      PDFIO_DEBUG(\"load_xref: %lu compressed object streams to load.\\n\", (unsigned long)num_sobjs);\n\n      for (i = 0; i < num_sobjs; i ++)\n      {\n        if ((obj = pdfioFileFindObj(pdf, sobjs[i])) != NULL)\n        {\n\t  PDFIO_DEBUG(\"load_xref: Loading compressed object stream %lu (pdf=%p, obj->pdf=%p).\\n\", (unsigned long)sobjs[i], pdf, obj->pdf);\n\n          if (!load_obj_stream(obj))\n            return (false);\n\t}\n\telse\n\t{\n\t  _pdfioFileError(pdf, \"Unable to find compressed object stream %lu.\", (unsigned long)sobjs[i]);\n\t  return (false);\n\t}\n      }\n    }\n    else if (!strcmp(line, \"xref\"))\n    {\n      // Read the xref tables\n      while (_pdfioFileGets(pdf, line, sizeof(line)))\n      {\n\tif (!strcmp(line, \"trailer\"))\n\t  break;\n\telse if (!line[0])\n\t  continue;\n\n\tif (sscanf(line, \"%jd%jd\", &number, &num_objects) != 2)\n\t{\n\t  _pdfioFileError(pdf, \"Malformed xref table section '%s'.\", line);\n\t  return (false);\n\t}\n\n\t// Read this group of objects...\n\tfor (; num_objects > 0; num_objects --, number ++)\n\t{\n\t  // Read a line from the file and validate it...\n\t  if (_pdfioFileRead(pdf, line, 20) != 20)\n\t    return (false);\n\n\t  line[20] = '\\0';\n\n\t  if (strcmp(line + 18, \"\\r\\n\") && strcmp(line + 18, \" \\n\") && strcmp(line + 18, \" \\r\"))\n\t  {\n\t    _pdfioFileError(pdf, \"Malformed xref table entry '%s'.\", line);\n\t    return (false);\n\t  }\n\t  line[18] = '\\0';\n\n\t  // Parse the line\n\t  if ((offset = strtoimax(line, &ptr, 10)) < 0)\n\t  {\n\t    _pdfioFileError(pdf, \"Malformed xref table entry '%s'.\", line);\n\t    return (false);\n\t  }\n\n\t  if ((generation = (int)strtol(ptr, &ptr, 10)) < 0 || generation > 65535)\n\t  {\n\t    _pdfioFileError(pdf, \"Malformed xref table entry '%s'.\", line);\n\t    return (false);\n\t  }\n\n\t  if (*ptr != ' ')\n\t  {\n\t    _pdfioFileError(pdf, \"Malformed xref table entry '%s'.\", line);\n\t    return (false);\n\t  }\n\n\t  ptr ++;\n\t  if (*ptr != 'f' && *ptr != 'n')\n\t  {\n\t    _pdfioFileError(pdf, \"Malformed xref table entry '%s'.\", line);\n\t    return (false);\n\t  }\n\n\t  if (*ptr == 'f')\n\t    continue;\t\t\t// Don't care about free objects...\n\n\t  // Create a placeholder for the object in memory...\n\t  if (pdfioFileFindObj(pdf, (size_t)number))\n\t    continue;\t\t\t// Don't replace newer object...\n\n\t  if (!add_obj(pdf, (size_t)number, (unsigned short)generation, offset))\n\t    return (false);\n\t}\n      }\n\n      if (strcmp(line, \"trailer\"))\n      {\n\t_pdfioFileError(pdf, \"Missing trailer.\");\n\treturn (false);\n      }\n\n      _pdfioTokenInit(&tb, pdf, (_pdfio_tconsume_cb_t)_pdfioFileConsume, (_pdfio_tpeek_cb_t)_pdfioFilePeek, pdf);\n\n      if (!_pdfioValueRead(pdf, NULL, &tb, &trailer, 0))\n      {\n\t_pdfioFileError(pdf, \"Unable to read trailer dictionary.\");\n\treturn (false);\n      }\n      else if (trailer.type != PDFIO_VALTYPE_DICT)\n      {\n\t_pdfioFileError(pdf, \"Trailer is not a dictionary.\");\n\treturn (false);\n      }\n\n      PDFIO_DEBUG(\"load_xref: Got trailer dict.\\n\");\n\n      _pdfioTokenFlush(&tb);\n\n      if (!pdf->trailer_dict)\n      {\n\t// Save the trailer dictionary and grab the root (catalog) and info\n\t// objects...\n\tpdf->trailer_dict = trailer.value.dict;\n\tpdf->info_obj     = pdfioDictGetObj(pdf->trailer_dict, \"Info\");\n\tpdf->encrypt_obj  = pdfioDictGetObj(pdf->trailer_dict, \"Encrypt\");\n\tpdf->id_array     = pdfioDictGetArray(pdf->trailer_dict, \"ID\");\n\n\t// If the trailer contains an Encrypt key, try unlocking the file...\n\tif (pdf->encrypt_obj && !_pdfioCryptoUnlock(pdf, password_cb, password_data))\n\t  return (false);\n      }\n    }\n    else\n    {\n      _pdfioFileError(pdf, \"Bad xref table header '%s'.\", line);\n      return (false);\n    }\n\n    PDFIO_DEBUG(\"load_xref: Contents of trailer dictionary:\\n\");\n    PDFIO_DEBUG(\"load_xref: \");\n    PDFIO_DEBUG_VALUE(&trailer);\n    PDFIO_DEBUG(\"\\n\");\n\n    if ((xref_offset = (off_t)pdfioDictGetNumber(trailer.value.dict, \"Prev\")) <= 0)\n      done = true;\n  }\n\n  // Once we have all of the xref tables loaded, get the important objects and\n  // build the pages array...\n  if ((pdf->root_obj = pdfioDictGetObj(pdf->trailer_dict, \"Root\")) == NULL)\n  {\n    _pdfioFileError(pdf, \"Missing Root object.\");\n    return (false);\n  }\n\n  PDFIO_DEBUG(\"load_xref: Root=%p(%lu)\\n\", pdf->root_obj, (unsigned long)pdf->root_obj->number);\n\n  return (load_pages(pdf, pdfioDictGetObj(pdfioObjGetDict(pdf->root_obj), \"Pages\"), 0));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -362,6 +362,8 @@\n \treturn (false);\n       }\n \n+      PDFIO_DEBUG(\"load_xref: Got trailer dict.\\n\");\n+\n       _pdfioTokenFlush(&tb);\n \n       if (!pdf->trailer_dict)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      PDFIO_DEBUG(\"load_xref: Got trailer dict.\\n\");",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-24808",
        "func_name": "michaelrsweet/pdfio/get_char",
        "description": " PDFio is a C library for reading and writing PDF files. In versions prior to 1.1.0 a denial of service (DOS) vulnerability exists in the pdfio parser. Crafted pdf files can cause the program to run at 100% utilization and never terminate. The pdf which causes this crash found in testing is about 28kb in size and was discovered via fuzzing. Anyone who uses this library either as a standalone binary or as a library can be DOSed when attempting to parse this type of file. Web servers or other automated processes which rely on this code to turn pdf submissions into plaintext can be DOSed when an attacker uploads the pdf. Please see the linked GHSA for an example pdf. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
        "git_url": "https://github.com/michaelrsweet/pdfio/commit/4f10021e7ee527c1aa24853e2947e38e154d9ccb",
        "commit_title": "Fix denial-of-service attack when reading corrupt PDF files.",
        "commit_text": "",
        "func_before": "static int\t\t\t\t// O - Character or `EOF` on end-of-file\nget_char(_pdfio_token_t *tb)\t\t// I - Token buffer\n{\n  ssize_t\tbytes;\t\t\t// Bytes peeked\n\n\n  // Refill the buffer as needed...\n  if (tb->bufptr >= tb->bufend)\n  {\n    // Consume previous bytes...\n    if (tb->bufend > tb->buffer)\n    {\n      PDFIO_DEBUG(\"get_char: Consuming %d bytes.\\n\", (int)(tb->bufend - tb->buffer));\n      (tb->consume_cb)(tb->cb_data, (size_t)(tb->bufend - tb->buffer));\n    }\n\n    // Peek new bytes...\n    if ((bytes = (tb->peek_cb)(tb->cb_data, tb->buffer, sizeof(tb->buffer))) <= 0)\n    {\n      tb->bufptr = tb->bufend = tb->buffer;\n      return (EOF);\n    }\n\n    // Update pointers...\n    tb->bufptr = tb->buffer;\n    tb->bufend = tb->buffer + bytes;\n\n#ifdef DEBUG\n    unsigned char *ptr;\t\t\t// Pointer into buffer\n\n    PDFIO_DEBUG(\"get_char: Read '\");\n    for (ptr = tb->buffer; ptr < tb->bufend; ptr ++)\n    {\n      if (*ptr < ' ' || *ptr == 0x7f)\n        PDFIO_DEBUG(\"\\\\%03o\", *ptr);\n      else\n        PDFIO_DEBUG(\"%c\", *ptr);\n    }\n    PDFIO_DEBUG(\"'\\n\");\n#endif // DEBUG\n  }\n\n  // Return the next character...\n  return (*(tb->bufptr)++);\n}",
        "func": "static int\t\t\t\t// O - Character or `EOF` on end-of-file\nget_char(_pdfio_token_t *tb)\t\t// I - Token buffer\n{\n  ssize_t\tbytes;\t\t\t// Bytes peeked\n\n\n  // Refill the buffer as needed...\n  if (tb->bufptr >= tb->bufend)\n  {\n    // Consume previous bytes...\n    if (tb->bufend > tb->buffer)\n    {\n      PDFIO_DEBUG(\"get_char: Consuming %d bytes.\\n\", (int)(tb->bufend - tb->buffer));\n      (tb->consume_cb)(tb->cb_data, (size_t)(tb->bufend - tb->buffer));\n    }\n\n    // Peek new bytes...\n    if ((bytes = (tb->peek_cb)(tb->cb_data, tb->buffer, sizeof(tb->buffer))) <= 0)\n    {\n      tb->bufptr = tb->bufend = tb->buffer;\n      return (EOF);\n    }\n\n    // Update pointers...\n    tb->bufptr = tb->buffer;\n    tb->bufend = tb->buffer + bytes;\n\n#if 0\n#ifdef DEBUG\n    unsigned char *ptr;\t\t\t// Pointer into buffer\n\n    PDFIO_DEBUG(\"get_char: Read '\");\n    for (ptr = tb->buffer; ptr < tb->bufend; ptr ++)\n    {\n      if (*ptr < ' ' || *ptr == 0x7f)\n        PDFIO_DEBUG(\"\\\\%03o\", *ptr);\n      else\n        PDFIO_DEBUG(\"%c\", *ptr);\n    }\n    PDFIO_DEBUG(\"'\\n\");\n#endif // DEBUG\n#endif // 0\n  }\n\n  // Return the next character...\n  return (*(tb->bufptr)++);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,6 +25,7 @@\n     tb->bufptr = tb->buffer;\n     tb->bufend = tb->buffer + bytes;\n \n+#if 0\n #ifdef DEBUG\n     unsigned char *ptr;\t\t\t// Pointer into buffer\n \n@@ -38,6 +39,7 @@\n     }\n     PDFIO_DEBUG(\"'\\n\");\n #endif // DEBUG\n+#endif // 0\n   }\n \n   // Return the next character...",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#if 0",
                "#endif // 0"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-24808",
        "func_name": "michaelrsweet/pdfio/_pdfioTokenRead",
        "description": " PDFio is a C library for reading and writing PDF files. In versions prior to 1.1.0 a denial of service (DOS) vulnerability exists in the pdfio parser. Crafted pdf files can cause the program to run at 100% utilization and never terminate. The pdf which causes this crash found in testing is about 28kb in size and was discovered via fuzzing. Anyone who uses this library either as a standalone binary or as a library can be DOSed when attempting to parse this type of file. Web servers or other automated processes which rely on this code to turn pdf submissions into plaintext can be DOSed when an attacker uploads the pdf. Please see the linked GHSA for an example pdf. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
        "git_url": "https://github.com/michaelrsweet/pdfio/commit/4f10021e7ee527c1aa24853e2947e38e154d9ccb",
        "commit_title": "Fix denial-of-service attack when reading corrupt PDF files.",
        "commit_text": "",
        "func_before": "bool\t\t\t\t\t// O - `true` on success, `false` on failure\n_pdfioTokenRead(_pdfio_token_t *tb,\t// I - Token buffer/stack\n\t\tchar           *buffer,\t// I - String buffer\n\t\tsize_t         bufsize)\t// I - Size of string buffer\n{\n  int\tch,\t\t\t\t// Character\n\tparens = 0;\t\t\t// Parenthesis level\n  char\t*bufptr,\t\t\t// Pointer into buffer\n\t*bufend,\t\t\t// End of buffer\n\tstate = '\\0';\t\t\t// Current state\n  bool\tsaw_nul = false;\t\t// Did we see a nul character?\n\n\n  //\n  // \"state\" is:\n  //\n  // - '\\0' for idle\n  // - '(' for literal string\n  // - '/' for name\n  // - '<' for possible hex string or dict\n  // - '>' for possible dict\n  // - '%' for comment\n  // - 'K' for keyword\n  // - 'N' for number\n\n  // Read the next token, skipping any leading whitespace...\n  bufptr = buffer;\n  bufend = buffer + bufsize - 1;\n\n  // Skip leading whitespace...\n  while ((ch = get_char(tb)) != EOF)\n  {\n    if (ch == '%')\n    {\n      // Skip comment\n      while ((ch = get_char(tb)) != EOF)\n      {\n\tif (ch == '\\n' || ch == '\\r')\n\t  break;\n      }\n    }\n    else if (!isspace(ch))\n      break;\n  }\n\n  if (ch == EOF)\n    return (false);\n\n  // Check for delimiters...\n  if (strchr(PDFIO_DELIM_CHARS, ch) != NULL)\n  {\n    *bufptr++ = state = (char)ch;\n  }\n  else if (strchr(PDFIO_NUMBER_CHARS, ch) != NULL)\n  {\n    // Number\n    state     = 'N';\n    *bufptr++ = (char)ch;\n  }\n  else\n  {\n    // Keyword\n    state     = 'K';\n    *bufptr++ = (char)ch;\n  }\n\n  switch (state)\n  {\n    case '(' : // Literal string\n\twhile ((ch = get_char(tb)) != EOF)\n\t{\n\t  if (ch == 0)\n\t    saw_nul = true;\n\n\t  if (ch == '\\\\')\n\t  {\n\t    // Quoted character...\n\t    int\ti;\t\t\t// Looping var\n\n\t    switch (ch = get_char(tb))\n\t    {\n\t      case '0' : // Octal character escape\n\t      case '1' :\n\t      case '2' :\n\t      case '3' :\n\t      case '4' :\n\t      case '5' :\n\t      case '6' :\n\t      case '7' :\n\t\t  for (ch -= '0', i = 0; i < 2; i ++)\n\t\t  {\n\t\t    int tch = get_char(tb);\t// Next char\n\n\t\t    if (tch >= '0' && tch <= '7')\n\t\t    {\n\t\t      ch = (char)((ch << 3) | (tch - '0'));\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t      tb->bufptr --;\n\t\t      break;\n\t\t    }\n\t\t  }\n\t\t  break;\n\n\t      case '\\\\' :\n\t      case '(' :\n\t      case ')' :\n\t\t  break;\n\n\t      case 'n' :\n\t\t  ch = '\\n';\n\t\t  break;\n\n\t      case 'r' :\n\t\t  ch = '\\r';\n\t\t  break;\n\n\t      case 't' :\n\t\t  ch = '\\t';\n\t\t  break;\n\n\t      case 'b' :\n\t\t  ch = '\\b';\n\t\t  break;\n\n\t      case 'f' :\n\t\t  ch = '\\f';\n\t\t  break;\n\n\t      default :\n\t          // Ignore blackslash per PDF spec...\n\t          break;\n\t    }\n\t  }\n\t  else if (ch == '(')\n\t  {\n\t    // Keep track of parenthesis\n\t    parens ++;\n\t  }\n\t  else if (ch == ')')\n\t  {\n\t    if (parens == 0)\n\t      break;\n\n\t    parens --;\n\t  }\n\n\t  if (bufptr < bufend)\n\t  {\n\t    // Normal character...\n\t    *bufptr++ = (char)ch;\n\t  }\n\t  else\n\t  {\n\t    // Out of space\n\t    _pdfioFileError(tb->pdf, \"Token too large.\");\n\t    return (false);\n\t  }\n\t}\n\n\tif (ch != ')')\n\t{\n\t  _pdfioFileError(tb->pdf, \"Unterminated string literal.\");\n\t  return (false);\n\t}\n\n\tif (saw_nul)\n\t{\n\t  // Convert to a hex (binary) string...\n\t  char\t*litptr,\t\t// Pointer to literal character\n\t\t*hexptr;\t\t// Pointer to hex character\n\t  size_t bytes = (size_t)(bufptr - buffer - 1);\n\t\t\t\t\t// Bytes of data...\n          static const char *hexchars = \"0123456789ABCDEF\";\n\t\t\t\t\t// Hex digits\n\n          PDFIO_DEBUG(\"_pdfioTokenRead: Converting nul-containing string to binary.\\n\");\n\n          if ((2 * (bytes + 1)) > bufsize)\n          {\n\t    // Out of space...\n\t    _pdfioFileError(tb->pdf, \"Token too large.\");\n\t    return (false);\n          }\n\n\t  *buffer = '<';\n\t  for (litptr = bufptr - 1, hexptr = buffer + 2 * bytes - 1; litptr > buffer; litptr --, hexptr -= 2)\n\t  {\n\t    int litch = *litptr;\t// Grab the character\n\n\t    hexptr[0] = hexchars[(litch >> 4) & 15];\n\t    hexptr[1] = hexchars[litch & 15];\n\t  }\n\t  bufptr = buffer + 2 * bytes + 1;\n\t}\n\tbreak;\n\n    case 'K' : // keyword\n\twhile ((ch = get_char(tb)) != EOF && !isspace(ch))\n\t{\n\t  if (strchr(PDFIO_DELIM_CHARS, ch) != NULL)\n\t  {\n\t    // End of keyword...\n\t    tb->bufptr --;\n\t    break;\n\t  }\n\t  else if (bufptr < bufend)\n\t  {\n\t    // Normal character...\n\t    *bufptr++ = (char)ch;\n\t  }\n\t  else\n\t  {\n\t    // Out of space...\n\t    _pdfioFileError(tb->pdf, \"Token too large.\");\n\t    return (false);\n\t  }\n\t}\n\tbreak;\n\n    case 'N' : // number\n\twhile ((ch = get_char(tb)) != EOF && !isspace(ch))\n\t{\n\t  if (!isdigit(ch) && ch != '.')\n\t  {\n\t    // End of number...\n\t    tb->bufptr --;\n\t    break;\n\t  }\n\t  else if (bufptr < bufend)\n\t  {\n\t    // Normal character...\n\t    *bufptr++ = (char)ch;\n\t  }\n\t  else\n\t  {\n\t    // Out of space...\n\t    _pdfioFileError(tb->pdf, \"Token too large.\");\n\t    return (false);\n\t  }\n\t}\n\tbreak;\n\n    case '/' : // \"/name\"\n\twhile ((ch = get_char(tb)) != EOF && !isspace(ch))\n\t{\n\t  if (strchr(PDFIO_DELIM_CHARS, ch) != NULL)\n\t  {\n\t    // End of keyword...\n\t    tb->bufptr --;\n\t    break;\n\t  }\n\t  else if (ch == '#')\n\t  {\n\t    // Quoted character (#xx) in name...\n\t    int\ti;\t\t\t// Looping var\n\n\t    for (i = 0, ch = 0; i < 2; i ++)\n\t    {\n\t      int tch = get_char(tb);\n\n\t      if (!isxdigit(tch & 255))\n\t      {\n\t\t_pdfioFileError(tb->pdf, \"Bad # escape in name.\");\n\t\treturn (false);\n\t      }\n\t      else if (isdigit(tch))\n\t\tch = ((ch & 255) << 4) | (tch - '0');\n\t      else\n\t\tch = ((ch & 255) << 4) | (tolower(tch) - 'a' + 10);\n\t    }\n\t  }\n\n\t  if (bufptr < bufend)\n\t  {\n\t    *bufptr++ = (char)ch;\n\t  }\n\t  else\n\t  {\n\t    // Out of space\n\t    _pdfioFileError(tb->pdf, \"Token too large.\");\n\t    return (false);\n\t  }\n\t}\n\tbreak;\n\n    case '<' : // Potential hex string\n\tif ((ch = get_char(tb)) == '<')\n\t{\n\t  // Dictionary delimiter\n\t  *bufptr++ = (char)ch;\n\t  break;\n\t}\n\telse if (!isspace(ch & 255) && !isxdigit(ch & 255))\n\t{\n\t  _pdfioFileError(tb->pdf, \"Syntax error: '<%c'\", ch);\n\t  return (false);\n\t}\n\n        do\n\t{\n\t  if (isxdigit(ch))\n\t  {\n\t    if (bufptr < bufend)\n\t    {\n\t      // Hex digit\n\t      *bufptr++ = (char)ch;\n\t    }\n\t    else\n\t    {\n\t      // Too large\n\t      _pdfioFileError(tb->pdf, \"Token too large.\");\n\t      return (false);\n\t    }\n\t  }\n\t  else if (!isspace(ch))\n\t  {\n\t    _pdfioFileError(tb->pdf, \"Invalid hex string character '%c'.\", ch);\n\t    return (false);\n\t  }\n\t}\n\twhile ((ch = get_char(tb)) != EOF && ch != '>');\n\n\tif (ch == EOF)\n\t{\n\t  _pdfioFileError(tb->pdf, \"Unterminated hex string.\");\n\t  return (false);\n\t}\n\tbreak;\n\n    case '>' : // Dictionary\n\tif ((ch = get_char(tb)) == '>')\n\t{\n\t  *bufptr++ = '>';\n\t}\n\telse\n\t{\n\t  _pdfioFileError(tb->pdf, \"Syntax error: '>%c'.\", ch);\n\t  return (false);\n\t}\n\tbreak;\n  }\n\n  *bufptr = '\\0';\n\n  PDFIO_DEBUG(\"_pdfioTokenRead: Read '%s'.\\n\", buffer);\n\n  return (bufptr > buffer);\n}",
        "func": "bool\t\t\t\t\t// O - `true` on success, `false` on failure\n_pdfioTokenRead(_pdfio_token_t *tb,\t// I - Token buffer/stack\n\t\tchar           *buffer,\t// I - String buffer\n\t\tsize_t         bufsize)\t// I - Size of string buffer\n{\n  int\tch,\t\t\t\t// Character\n\tparens = 0;\t\t\t// Parenthesis level\n  char\t*bufptr,\t\t\t// Pointer into buffer\n\t*bufend,\t\t\t// End of buffer\n\tstate = '\\0';\t\t\t// Current state\n  bool\tsaw_nul = false;\t\t// Did we see a nul character?\n\n\n  //\n  // \"state\" is:\n  //\n  // - '\\0' for idle\n  // - '(' for literal string\n  // - '/' for name\n  // - '<' for possible hex string or dict\n  // - '>' for possible dict\n  // - '%' for comment\n  // - 'K' for keyword\n  // - 'N' for number\n\n  // Read the next token, skipping any leading whitespace...\n  bufptr = buffer;\n  bufend = buffer + bufsize - 1;\n\n  // Skip leading whitespace...\n  while ((ch = get_char(tb)) != EOF)\n  {\n    if (ch == '%')\n    {\n      // Skip comment\n      while ((ch = get_char(tb)) != EOF)\n      {\n\tif (ch == '\\n' || ch == '\\r')\n\t  break;\n      }\n    }\n    else if (!isspace(ch))\n      break;\n  }\n\n  if (ch == EOF)\n    return (false);\n\n  // Check for delimiters...\n  if (strchr(PDFIO_DELIM_CHARS, ch) != NULL)\n  {\n    *bufptr++ = state = (char)ch;\n  }\n  else if (strchr(PDFIO_NUMBER_CHARS, ch) != NULL)\n  {\n    // Number\n    state     = 'N';\n    *bufptr++ = (char)ch;\n  }\n  else\n  {\n    // Keyword\n    state     = 'K';\n    *bufptr++ = (char)ch;\n  }\n\n  switch (state)\n  {\n    case '(' : // Literal string\n\twhile ((ch = get_char(tb)) != EOF)\n\t{\n\t  if (ch == 0)\n\t    saw_nul = true;\n\n\t  if (ch == '\\\\')\n\t  {\n\t    // Quoted character...\n\t    int\ti;\t\t\t// Looping var\n\n\t    switch (ch = get_char(tb))\n\t    {\n\t      case '0' : // Octal character escape\n\t      case '1' :\n\t      case '2' :\n\t      case '3' :\n\t      case '4' :\n\t      case '5' :\n\t      case '6' :\n\t      case '7' :\n\t\t  for (ch -= '0', i = 0; i < 2; i ++)\n\t\t  {\n\t\t    int tch = get_char(tb);\t// Next char\n\n\t\t    if (tch >= '0' && tch <= '7')\n\t\t    {\n\t\t      ch = (char)((ch << 3) | (tch - '0'));\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t      tb->bufptr --;\n\t\t      break;\n\t\t    }\n\t\t  }\n\t\t  break;\n\n\t      case '\\\\' :\n\t      case '(' :\n\t      case ')' :\n\t\t  break;\n\n\t      case 'n' :\n\t\t  ch = '\\n';\n\t\t  break;\n\n\t      case 'r' :\n\t\t  ch = '\\r';\n\t\t  break;\n\n\t      case 't' :\n\t\t  ch = '\\t';\n\t\t  break;\n\n\t      case 'b' :\n\t\t  ch = '\\b';\n\t\t  break;\n\n\t      case 'f' :\n\t\t  ch = '\\f';\n\t\t  break;\n\n\t      default :\n\t          // Ignore blackslash per PDF spec...\n\t          break;\n\t    }\n\t  }\n\t  else if (ch == '(')\n\t  {\n\t    // Keep track of parenthesis\n\t    parens ++;\n\t  }\n\t  else if (ch == ')')\n\t  {\n\t    if (parens == 0)\n\t      break;\n\n\t    parens --;\n\t  }\n\n\t  if (bufptr < bufend)\n\t  {\n\t    // Normal character...\n\t    *bufptr++ = (char)ch;\n\t  }\n\t  else\n\t  {\n\t    // Out of space\n\t    _pdfioFileError(tb->pdf, \"Token too large.\");\n\t    return (false);\n\t  }\n\t}\n\n\tif (ch != ')')\n\t{\n\t  _pdfioFileError(tb->pdf, \"Unterminated string literal.\");\n\t  return (false);\n\t}\n\n\tif (saw_nul)\n\t{\n\t  // Convert to a hex (binary) string...\n\t  char\t*litptr,\t\t// Pointer to literal character\n\t\t*hexptr;\t\t// Pointer to hex character\n\t  size_t bytes = (size_t)(bufptr - buffer - 1);\n\t\t\t\t\t// Bytes of data...\n          static const char *hexchars = \"0123456789ABCDEF\";\n\t\t\t\t\t// Hex digits\n\n          PDFIO_DEBUG(\"_pdfioTokenRead: Converting nul-containing string to binary.\\n\");\n\n          if ((2 * (bytes + 1)) > bufsize)\n          {\n\t    // Out of space...\n\t    _pdfioFileError(tb->pdf, \"Token too large.\");\n\t    return (false);\n          }\n\n\t  *buffer = '<';\n\t  for (litptr = bufptr - 1, hexptr = buffer + 2 * bytes - 1; litptr > buffer; litptr --, hexptr -= 2)\n\t  {\n\t    int litch = *litptr;\t// Grab the character\n\n\t    hexptr[0] = hexchars[(litch >> 4) & 15];\n\t    hexptr[1] = hexchars[litch & 15];\n\t  }\n\t  bufptr = buffer + 2 * bytes + 1;\n\t}\n\tbreak;\n\n    case 'K' : // keyword\n\twhile ((ch = get_char(tb)) != EOF && !isspace(ch))\n\t{\n\t  if (strchr(PDFIO_DELIM_CHARS, ch) != NULL)\n\t  {\n\t    // End of keyword...\n\t    tb->bufptr --;\n\t    break;\n\t  }\n\t  else if (bufptr < bufend)\n\t  {\n\t    // Normal character...\n\t    *bufptr++ = (char)ch;\n\t  }\n\t  else\n\t  {\n\t    // Out of space...\n\t    _pdfioFileError(tb->pdf, \"Token too large.\");\n\t    return (false);\n\t  }\n\t}\n\tbreak;\n\n    case 'N' : // number\n\twhile ((ch = get_char(tb)) != EOF && !isspace(ch))\n\t{\n\t  if (!isdigit(ch) && ch != '.')\n\t  {\n\t    // End of number...\n\t    tb->bufptr --;\n\t    break;\n\t  }\n\t  else if (bufptr < bufend)\n\t  {\n\t    // Normal character...\n\t    *bufptr++ = (char)ch;\n\t  }\n\t  else\n\t  {\n\t    // Out of space...\n\t    _pdfioFileError(tb->pdf, \"Token too large.\");\n\t    return (false);\n\t  }\n\t}\n\tbreak;\n\n    case '/' : // \"/name\"\n\twhile ((ch = get_char(tb)) != EOF && !isspace(ch))\n\t{\n\t  if (strchr(PDFIO_DELIM_CHARS, ch) != NULL)\n\t  {\n\t    // End of keyword...\n\t    tb->bufptr --;\n\t    break;\n\t  }\n\t  else if (ch == '#')\n\t  {\n\t    // Quoted character (#xx) in name...\n\t    int\ti;\t\t\t// Looping var\n\n\t    for (i = 0, ch = 0; i < 2; i ++)\n\t    {\n\t      int tch = get_char(tb);\n\n\t      if (!isxdigit(tch & 255))\n\t      {\n\t\t_pdfioFileError(tb->pdf, \"Bad # escape in name.\");\n\t\treturn (false);\n\t      }\n\t      else if (isdigit(tch))\n\t\tch = ((ch & 255) << 4) | (tch - '0');\n\t      else\n\t\tch = ((ch & 255) << 4) | (tolower(tch) - 'a' + 10);\n\t    }\n\t  }\n\n\t  if (bufptr < bufend)\n\t  {\n\t    *bufptr++ = (char)ch;\n\t  }\n\t  else\n\t  {\n\t    // Out of space\n\t    _pdfioFileError(tb->pdf, \"Token too large.\");\n\t    return (false);\n\t  }\n\t}\n\tbreak;\n\n    case '<' : // Potential hex string\n\tif ((ch = get_char(tb)) == '<')\n\t{\n\t  // Dictionary delimiter\n\t  *bufptr++ = (char)ch;\n\t  break;\n\t}\n\telse if (!isspace(ch & 255) && !isxdigit(ch & 255))\n\t{\n\t  _pdfioFileError(tb->pdf, \"Syntax error: '<%c'\", ch);\n\t  return (false);\n\t}\n\n        do\n\t{\n\t  if (isxdigit(ch))\n\t  {\n\t    if (bufptr < bufend)\n\t    {\n\t      // Hex digit\n\t      *bufptr++ = (char)ch;\n\t    }\n\t    else\n\t    {\n\t      // Too large\n\t      _pdfioFileError(tb->pdf, \"Token too large.\");\n\t      return (false);\n\t    }\n\t  }\n\t  else if (!isspace(ch))\n\t  {\n\t    _pdfioFileError(tb->pdf, \"Invalid hex string character '%c'.\", ch);\n\t    return (false);\n\t  }\n\t}\n\twhile ((ch = get_char(tb)) != EOF && ch != '>');\n\n\tif (ch == EOF)\n\t{\n\t  _pdfioFileError(tb->pdf, \"Unterminated hex string.\");\n\t  return (false);\n\t}\n\tbreak;\n\n    case '>' : // Dictionary\n\tif ((ch = get_char(tb)) == '>')\n\t{\n\t  *bufptr++ = '>';\n\t}\n\telse\n\t{\n\t  _pdfioFileError(tb->pdf, \"Syntax error: '>%c'.\", ch);\n\t  return (false);\n\t}\n\tbreak;\n  }\n\n  *bufptr = '\\0';\n\n//  PDFIO_DEBUG(\"_pdfioTokenRead: Read '%s'.\\n\", buffer);\n\n  return (bufptr > buffer);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -344,7 +344,7 @@\n \n   *bufptr = '\\0';\n \n-  PDFIO_DEBUG(\"_pdfioTokenRead: Read '%s'.\\n\", buffer);\n+//  PDFIO_DEBUG(\"_pdfioTokenRead: Read '%s'.\\n\", buffer);\n \n   return (bufptr > buffer);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  PDFIO_DEBUG(\"_pdfioTokenRead: Read '%s'.\\n\", buffer);"
            ],
            "added_lines": [
                "//  PDFIO_DEBUG(\"_pdfioTokenRead: Read '%s'.\\n\", buffer);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-24808",
        "func_name": "michaelrsweet/pdfio/_pdfioTokenGet",
        "description": " PDFio is a C library for reading and writing PDF files. In versions prior to 1.1.0 a denial of service (DOS) vulnerability exists in the pdfio parser. Crafted pdf files can cause the program to run at 100% utilization and never terminate. The pdf which causes this crash found in testing is about 28kb in size and was discovered via fuzzing. Anyone who uses this library either as a standalone binary or as a library can be DOSed when attempting to parse this type of file. Web servers or other automated processes which rely on this code to turn pdf submissions into plaintext can be DOSed when an attacker uploads the pdf. Please see the linked GHSA for an example pdf. Users are advised to upgrade. There are no known workarounds for this vulnerability.",
        "git_url": "https://github.com/michaelrsweet/pdfio/commit/4f10021e7ee527c1aa24853e2947e38e154d9ccb",
        "commit_title": "Fix denial-of-service attack when reading corrupt PDF files.",
        "commit_text": "",
        "func_before": "bool\t\t\t\t\t// O - `true` on success, `false` on failure\n_pdfioTokenGet(_pdfio_token_t *tb,\t// I - Token buffer/stack\n\t       char           *buffer,\t// I - String buffer\n\t       size_t         bufsize)\t// I - Size of string buffer\n{\n  // See if we have a token waiting on the stack...\n  if (tb->num_tokens > 0)\n  {\n    // Yes, return it...\n    tb->num_tokens --;\n    strncpy(buffer, tb->tokens[tb->num_tokens], bufsize - 1);\n    buffer[bufsize - 1] = '\\0';\n\n    PDFIO_DEBUG(\"_pdfioTokenGet(tb=%p, buffer=%p, bufsize=%u): Popping '%s' from stack.\\n\", tb, buffer, (unsigned)bufsize, buffer);\n\n    free(tb->tokens[tb->num_tokens]);\n    tb->tokens[tb->num_tokens] = NULL;\n\n    return (true);\n  }\n\n  // No, read a new one...\n  return (_pdfioTokenRead(tb, buffer, bufsize));\n}",
        "func": "bool\t\t\t\t\t// O - `true` on success, `false` on failure\n_pdfioTokenGet(_pdfio_token_t *tb,\t// I - Token buffer/stack\n\t       char           *buffer,\t// I - String buffer\n\t       size_t         bufsize)\t// I - Size of string buffer\n{\n  // See if we have a token waiting on the stack...\n  if (tb->num_tokens > 0)\n  {\n    // Yes, return it...\n    size_t len;\t\t\t\t// Length of token\n\n    tb->num_tokens --;\n\n    if ((len = strlen(tb->tokens[tb->num_tokens])) > (bufsize - 1))\n    {\n      // Value too large...\n      PDFIO_DEBUG(\"_pdfioTokenGet(tb=%p, buffer=%p, bufsize=%u): Token '%s' from stack too large.\\n\", tb, buffer, (unsigned)bufsize, tb->tokens[tb->num_tokens]);\n      *buffer = '\\0';\n      return (false);\n    }\n\n    memcpy(buffer, tb->tokens[tb->num_tokens], len);\n    buffer[len] = '\\0';\n\n    PDFIO_DEBUG(\"_pdfioTokenGet(tb=%p, buffer=%p, bufsize=%u): Popping '%s' from stack.\\n\", tb, buffer, (unsigned)bufsize, buffer);\n\n    free(tb->tokens[tb->num_tokens]);\n    tb->tokens[tb->num_tokens] = NULL;\n\n    return (true);\n  }\n\n  // No, read a new one...\n  return (_pdfioTokenRead(tb, buffer, bufsize));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,9 +7,20 @@\n   if (tb->num_tokens > 0)\n   {\n     // Yes, return it...\n+    size_t len;\t\t\t\t// Length of token\n+\n     tb->num_tokens --;\n-    strncpy(buffer, tb->tokens[tb->num_tokens], bufsize - 1);\n-    buffer[bufsize - 1] = '\\0';\n+\n+    if ((len = strlen(tb->tokens[tb->num_tokens])) > (bufsize - 1))\n+    {\n+      // Value too large...\n+      PDFIO_DEBUG(\"_pdfioTokenGet(tb=%p, buffer=%p, bufsize=%u): Token '%s' from stack too large.\\n\", tb, buffer, (unsigned)bufsize, tb->tokens[tb->num_tokens]);\n+      *buffer = '\\0';\n+      return (false);\n+    }\n+\n+    memcpy(buffer, tb->tokens[tb->num_tokens], len);\n+    buffer[len] = '\\0';\n \n     PDFIO_DEBUG(\"_pdfioTokenGet(tb=%p, buffer=%p, bufsize=%u): Popping '%s' from stack.\\n\", tb, buffer, (unsigned)bufsize, buffer);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    strncpy(buffer, tb->tokens[tb->num_tokens], bufsize - 1);",
                "    buffer[bufsize - 1] = '\\0';"
            ],
            "added_lines": [
                "    size_t len;\t\t\t\t// Length of token",
                "",
                "",
                "    if ((len = strlen(tb->tokens[tb->num_tokens])) > (bufsize - 1))",
                "    {",
                "      // Value too large...",
                "      PDFIO_DEBUG(\"_pdfioTokenGet(tb=%p, buffer=%p, bufsize=%u): Token '%s' from stack too large.\\n\", tb, buffer, (unsigned)bufsize, tb->tokens[tb->num_tokens]);",
                "      *buffer = '\\0';",
                "      return (false);",
                "    }",
                "",
                "    memcpy(buffer, tb->tokens[tb->num_tokens], len);",
                "    buffer[len] = '\\0';"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-25824",
        "func_name": "airtower-luna/mod_gnutls/mgs_transport_read",
        "description": "Mod_gnutls is a TLS module for Apache HTTPD based on GnuTLS. Versions from 0.9.0 to 0.12.0 (including) did not properly fail blocking read operations on TLS connections when the transport hit timeouts. Instead it entered an endless loop retrying the read operation, consuming CPU resources. This could be exploited for denial of service attacks. If trace level logging was enabled, it would also produce an excessive amount of log output during the loop, consuming disk space. The problem has been fixed in commit d7eec4e598158ab6a98bf505354e84352f9715ec, please update to version 0.12.1. There are no workarounds, users who cannot update should apply the errno fix detailed in the security advisory. \n",
        "git_url": "https://github.com/airtower-luna/mod_gnutls/commit/d7eec4e598158ab6a98bf505354e84352f9715ec",
        "commit_title": "Fix loop in blocking read on transport timeout",
        "commit_text": " The loop was cased by an incorrect errno if the transport read in mgs_transport_read() fails with an APR TIMEUP status, as happens when mod_reqtimeout limits are exceeded. Setting the transport errno to EGAIN meant that a blocking read would be retried endlessly, setting ETIMEDOUT instead makes the read fail as it should.  The bug was introduced in commit 92cb0cca41af946055307e373b6ab6d76d34f356, first release to include it was 0.9.0.  Many thanks to Flix Arreola Rodrguez for the detailed analysis [1] on the Debian bug tracker!  [1] https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=942737#25",
        "func_before": "ssize_t mgs_transport_read(gnutls_transport_ptr_t ptr,\n                           void *buffer, size_t len)\n{\n    mgs_handle_t *ctxt = ptr;\n    apr_size_t in = len;\n    apr_read_type_e block = ctxt->input_block;\n\n    ctxt->input_rc = APR_SUCCESS;\n\n    /* If Len = 0, we don't do anything. */\n    if (!len || buffer == NULL)\n    {\n        return 0;\n    }\n    /* Input bucket brigade is missing, EOF */\n    if (!ctxt->input_bb)\n    {\n        ctxt->input_rc = APR_EOF;\n        gnutls_transport_set_errno(ctxt->session, ECONNABORTED);\n        return -1;\n    }\n\n    if (APR_BRIGADE_EMPTY(ctxt->input_bb))\n    {\n        apr_status_t rc = ap_get_brigade(ctxt->input_filter->next,\n                                         ctxt->input_bb, AP_MODE_READBYTES,\n                                         ctxt->input_block, in);\n\n        /* Not a problem, there was simply no data ready yet.\n         */\n        if (APR_STATUS_IS_EAGAIN(rc) || APR_STATUS_IS_EINTR(rc)\n            || (rc == APR_SUCCESS\n                && APR_BRIGADE_EMPTY(ctxt->input_bb)))\n        {\n            /* Turning APR_SUCCESS into APR_EINTR isn't ideal, but\n             * it's the best matching error code for \"didn't get data,\n             * but read didn't permanently fail either.\" */\n            ctxt->input_rc = (rc != APR_SUCCESS ? rc : APR_EINTR);\n            gnutls_transport_set_errno(ctxt->session,\n                                       EAI_APR_TO_RAW(ctxt->input_rc));\n            return -1;\n        }\n\n        /* Blocking ap_get_brigade() can return a timeout status,\n         * sometimes after a very short time. \"Don't give up, just\n         * return the timeout\" is what mod_ssl does. */\n        if (ctxt->input_block == APR_BLOCK_READ\n            && APR_STATUS_IS_TIMEUP(rc)\n            && APR_BRIGADE_EMPTY(ctxt->input_bb))\n        {\n            ctxt->input_rc = rc;\n            gnutls_transport_set_errno(ctxt->session, EAGAIN);\n            return -1;\n        }\n\n        if (rc != APR_SUCCESS)\n        {\n            /* Unexpected errors discard the brigade */\n            ap_log_cerror(APLOG_MARK, APLOG_INFO, rc, ctxt->c,\n                          \"%s: Unexpected error!\", __func__);\n            apr_brigade_cleanup(ctxt->input_bb);\n            ctxt->input_bb = NULL;\n            gnutls_transport_set_errno(ctxt->session, EIO);\n            return -1;\n        }\n    }\n\n    ctxt->input_rc = brigade_consume(ctxt->input_bb, block, buffer, &len);\n\n    if (ctxt->input_rc == APR_SUCCESS)\n    {\n        return (ssize_t) len;\n    }\n\n    if (APR_STATUS_IS_EAGAIN(ctxt->input_rc)\n        || APR_STATUS_IS_EINTR(ctxt->input_rc))\n    {\n        if (len == 0)\n        {\n            gnutls_transport_set_errno(ctxt->session,\n                                       EAI_APR_TO_RAW(ctxt->input_rc));\n            return -1;\n        }\n\n        return (ssize_t) len;\n    }\n\n    /* Unexpected errors and APR_EOF clean out the brigade.\n     * Subsequent calls will return APR_EOF. */\n    apr_brigade_cleanup(ctxt->input_bb);\n    ctxt->input_bb = NULL;\n\n    if (APR_STATUS_IS_EOF(ctxt->input_rc) && len)\n    {\n        /* Some data has been received before EOF, return it. */\n        return (ssize_t) len;\n    }\n\n    gnutls_transport_set_errno(ctxt->session, EIO);\n    return -1;\n}",
        "func": "ssize_t mgs_transport_read(gnutls_transport_ptr_t ptr,\n                           void *buffer, size_t len)\n{\n    mgs_handle_t *ctxt = ptr;\n    apr_size_t in = len;\n    apr_read_type_e block = ctxt->input_block;\n\n    ctxt->input_rc = APR_SUCCESS;\n\n    /* If Len = 0, we don't do anything. */\n    if (!len || buffer == NULL)\n    {\n        return 0;\n    }\n    /* Input bucket brigade is missing, EOF */\n    if (!ctxt->input_bb)\n    {\n        ctxt->input_rc = APR_EOF;\n        gnutls_transport_set_errno(ctxt->session, ECONNABORTED);\n        return -1;\n    }\n\n    if (APR_BRIGADE_EMPTY(ctxt->input_bb))\n    {\n        apr_status_t rc = ap_get_brigade(ctxt->input_filter->next,\n                                         ctxt->input_bb, AP_MODE_READBYTES,\n                                         ctxt->input_block, in);\n\n        /* Not a problem, there was simply no data ready yet.\n         */\n        if (APR_STATUS_IS_EAGAIN(rc) || APR_STATUS_IS_EINTR(rc)\n            || (rc == APR_SUCCESS\n                && APR_BRIGADE_EMPTY(ctxt->input_bb)))\n        {\n            /* Turning APR_SUCCESS into APR_EINTR isn't ideal, but\n             * it's the best matching error code for \"didn't get data,\n             * but read didn't permanently fail either.\" */\n            ctxt->input_rc = (rc != APR_SUCCESS ? rc : APR_EINTR);\n            gnutls_transport_set_errno(ctxt->session,\n                                       EAI_APR_TO_RAW(ctxt->input_rc));\n            return -1;\n        }\n\n        /* Blocking ap_get_brigade() can return a timeout status,\n         * sometimes after a very short time. \"Don't give up, just\n         * return the timeout\" is what mod_ssl does. */\n        if (ctxt->input_block == APR_BLOCK_READ\n            && APR_STATUS_IS_TIMEUP(rc)\n            && APR_BRIGADE_EMPTY(ctxt->input_bb))\n        {\n            ctxt->input_rc = rc;\n            gnutls_transport_set_errno(ctxt->session, ETIMEDOUT);\n            return -1;\n        }\n\n        if (rc != APR_SUCCESS)\n        {\n            /* Unexpected errors discard the brigade */\n            ap_log_cerror(APLOG_MARK, APLOG_INFO, rc, ctxt->c,\n                          \"%s: Unexpected error!\", __func__);\n            apr_brigade_cleanup(ctxt->input_bb);\n            ctxt->input_bb = NULL;\n            gnutls_transport_set_errno(ctxt->session, EIO);\n            return -1;\n        }\n    }\n\n    ctxt->input_rc = brigade_consume(ctxt->input_bb, block, buffer, &len);\n\n    if (ctxt->input_rc == APR_SUCCESS)\n    {\n        return (ssize_t) len;\n    }\n\n    if (APR_STATUS_IS_EAGAIN(ctxt->input_rc)\n        || APR_STATUS_IS_EINTR(ctxt->input_rc))\n    {\n        if (len == 0)\n        {\n            gnutls_transport_set_errno(ctxt->session,\n                                       EAI_APR_TO_RAW(ctxt->input_rc));\n            return -1;\n        }\n\n        return (ssize_t) len;\n    }\n\n    /* Unexpected errors and APR_EOF clean out the brigade.\n     * Subsequent calls will return APR_EOF. */\n    apr_brigade_cleanup(ctxt->input_bb);\n    ctxt->input_bb = NULL;\n\n    if (APR_STATUS_IS_EOF(ctxt->input_rc) && len)\n    {\n        /* Some data has been received before EOF, return it. */\n        return (ssize_t) len;\n    }\n\n    gnutls_transport_set_errno(ctxt->session, EIO);\n    return -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -49,7 +49,7 @@\n             && APR_BRIGADE_EMPTY(ctxt->input_bb))\n         {\n             ctxt->input_rc = rc;\n-            gnutls_transport_set_errno(ctxt->session, EAGAIN);\n+            gnutls_transport_set_errno(ctxt->session, ETIMEDOUT);\n             return -1;\n         }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "            gnutls_transport_set_errno(ctxt->session, EAGAIN);"
            ],
            "added_lines": [
                "            gnutls_transport_set_errno(ctxt->session, ETIMEDOUT);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-25824",
        "func_name": "airtower-luna/mod_gnutls/gnutls_io_input_read",
        "description": "Mod_gnutls is a TLS module for Apache HTTPD based on GnuTLS. Versions from 0.9.0 to 0.12.0 (including) did not properly fail blocking read operations on TLS connections when the transport hit timeouts. Instead it entered an endless loop retrying the read operation, consuming CPU resources. This could be exploited for denial of service attacks. If trace level logging was enabled, it would also produce an excessive amount of log output during the loop, consuming disk space. The problem has been fixed in commit d7eec4e598158ab6a98bf505354e84352f9715ec, please update to version 0.12.1. There are no workarounds, users who cannot update should apply the errno fix detailed in the security advisory. \n",
        "git_url": "https://github.com/airtower-luna/mod_gnutls/commit/d7eec4e598158ab6a98bf505354e84352f9715ec",
        "commit_title": "Fix loop in blocking read on transport timeout",
        "commit_text": " The loop was cased by an incorrect errno if the transport read in mgs_transport_read() fails with an APR TIMEUP status, as happens when mod_reqtimeout limits are exceeded. Setting the transport errno to EGAIN meant that a blocking read would be retried endlessly, setting ETIMEDOUT instead makes the read fail as it should.  The bug was introduced in commit 92cb0cca41af946055307e373b6ab6d76d34f356, first release to include it was 0.9.0.  Many thanks to Flix Arreola Rodrguez for the detailed analysis [1] on the Debian bug tracker!  [1] https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=942737#25",
        "func_before": "static apr_status_t gnutls_io_input_read(mgs_handle_t * ctxt,\n        char *buf, apr_size_t * len)\n{\n    apr_size_t wanted = *len;\n    apr_size_t bytes = 0;\n\n    *len = 0;\n\n    /* If we have something leftover from last time, try that first. */\n    if ((bytes = char_buffer_read(&ctxt->input_cbuf, buf, wanted))) {\n        *len = bytes;\n        if (ctxt->input_mode == AP_MODE_SPECULATIVE) {\n            /* We want to rollback this read. */\n            if (ctxt->input_cbuf.length > 0) {\n                ctxt->input_cbuf.value -= bytes;\n                ctxt->input_cbuf.length += bytes;\n            } else {\n                char_buffer_write(&ctxt->input_cbuf, buf,\n                        (int) bytes);\n            }\n            return APR_SUCCESS;\n        }\n        /* This could probably be *len == wanted, but be safe from stray\n         * photons.\n         */\n        if (*len >= wanted) {\n            return APR_SUCCESS;\n        }\n        if (ctxt->input_mode == AP_MODE_GETLINE) {\n            if (memchr(buf, APR_ASCII_LF, *len)) {\n                return APR_SUCCESS;\n            }\n        } else {\n            /* Down to a nonblock pattern as we have some data already\n             */\n            ctxt->input_block = APR_NONBLOCK_READ;\n        }\n    }\n\n    if (ctxt->session == NULL) {\n        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, ctxt->c,\n                      \"%s: GnuTLS session is NULL!\", __func__);\n        return APR_EGENERAL;\n    }\n\n    while (1)\n    {\n        /* Note: The pull function sets ctxt->input_rc */\n        int rc = gnutls_record_recv(ctxt->session,\n                                    buf + bytes, wanted - bytes);\n\n        if (rc > 0) {\n            *len += rc;\n            if (ctxt->input_mode == AP_MODE_SPECULATIVE) {\n                /* We want to rollback this read. */\n                char_buffer_write(&ctxt->input_cbuf, buf,\n                                  *len);\n            }\n            return ctxt->input_rc;\n        } else if (rc == 0) {\n            /* EOF, return code depends on whether we still have data\n             * to return. */\n            if (*len > 0) {\n                ctxt->input_rc = APR_SUCCESS;\n            } else {\n                ctxt->input_rc = APR_EOF;\n            }\n            break;\n        } else { /* (rc < 0) */\n\n            if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN)\n            {\n                ap_log_cerror(APLOG_MARK, APLOG_TRACE2, ctxt->input_rc, ctxt->c,\n                              \"%s: looping recv after '%s' (%d)\",\n                              __func__, gnutls_strerror(rc), rc);\n                /* For a blocking read, loop and try again\n                 * immediately. Otherwise just notify the caller. */\n                if (ctxt->input_block != APR_NONBLOCK_READ)\n                    continue;\n                else\n                    ctxt->input_rc =\n                        (rc == GNUTLS_E_AGAIN ? APR_EAGAIN : APR_EINTR);\n            } else if (rc == GNUTLS_E_REHANDSHAKE) {\n                /* A client has asked for a new Hankshake. Currently, we don't do it */\n                ap_log_cerror(APLOG_MARK, APLOG_DEBUG,\n                        ctxt->input_rc,\n                        ctxt->c,\n                        \"GnuTLS: Error reading data. Client Requested a New Handshake.\"\n                        \" (%d) '%s'\", rc,\n                        gnutls_strerror(rc));\n            } else if (rc == GNUTLS_E_WARNING_ALERT_RECEIVED) {\n                rc = gnutls_alert_get(ctxt->session);\n                ap_log_cerror(APLOG_MARK, APLOG_DEBUG,\n                        ctxt->input_rc,\n                        ctxt->c,\n                        \"GnuTLS: Warning Alert From Client: \"\n                        \" (%d) '%s'\", rc,\n                        gnutls_alert_get_name(rc));\n            } else if (rc == GNUTLS_E_FATAL_ALERT_RECEIVED) {\n                rc = gnutls_alert_get(ctxt->session);\n                ap_log_cerror(APLOG_MARK, APLOG_DEBUG,\n                        ctxt->input_rc,\n                        ctxt->c,\n                        \"GnuTLS: Fatal Alert From Client: \"\n                        \"(%d) '%s'\", rc,\n                        gnutls_alert_get_name(rc));\n                ctxt->input_rc = APR_EGENERAL;\n                break;\n            } else {\n                /* Some Other Error. Report it. Die. */\n                if (gnutls_error_is_fatal(rc)) {\n                    ap_log_cerror(\n                        APLOG_MARK, APLOG_DEBUG,\n                        ctxt->input_rc,\n                        ctxt->c,\n                        \"GnuTLS: Error reading data. (%d) '%s'\",\n                        rc, gnutls_strerror(rc));\n                } else if (*len > 0) {\n                    ctxt->input_rc = APR_SUCCESS;\n                    break;\n                }\n            }\n\n            if (ctxt->input_rc == APR_SUCCESS) {\n                ap_log_cerror(APLOG_MARK, APLOG_INFO, ctxt->input_rc, ctxt->c,\n                              \"%s: GnuTLS error: %s (%d)\",\n                              __func__, gnutls_strerror(rc), rc);\n                ctxt->input_rc = APR_EGENERAL;\n            }\n            break;\n        }\n    }\n    return ctxt->input_rc;\n}",
        "func": "static apr_status_t gnutls_io_input_read(mgs_handle_t * ctxt,\n        char *buf, apr_size_t * len)\n{\n    apr_size_t wanted = *len;\n    apr_size_t bytes = 0;\n\n    *len = 0;\n\n    /* If we have something leftover from last time, try that first. */\n    if ((bytes = char_buffer_read(&ctxt->input_cbuf, buf, wanted))) {\n        *len = bytes;\n        if (ctxt->input_mode == AP_MODE_SPECULATIVE) {\n            /* We want to rollback this read. */\n            if (ctxt->input_cbuf.length > 0) {\n                ctxt->input_cbuf.value -= bytes;\n                ctxt->input_cbuf.length += bytes;\n            } else {\n                char_buffer_write(&ctxt->input_cbuf, buf,\n                        (int) bytes);\n            }\n            return APR_SUCCESS;\n        }\n        /* This could probably be *len == wanted, but be safe from stray\n         * photons.\n         */\n        if (*len >= wanted) {\n            return APR_SUCCESS;\n        }\n        if (ctxt->input_mode == AP_MODE_GETLINE) {\n            if (memchr(buf, APR_ASCII_LF, *len)) {\n                return APR_SUCCESS;\n            }\n        } else {\n            /* Down to a nonblock pattern as we have some data already\n             */\n            ctxt->input_block = APR_NONBLOCK_READ;\n        }\n    }\n\n    if (ctxt->session == NULL) {\n        ap_log_cerror(APLOG_MARK, APLOG_INFO, 0, ctxt->c,\n                      \"%s: GnuTLS session is NULL!\", __func__);\n        return APR_EGENERAL;\n    }\n\n    while (1)\n    {\n        /* Note: The pull function sets ctxt->input_rc */\n        int rc = gnutls_record_recv(ctxt->session,\n                                    buf + bytes, wanted - bytes);\n\n        if (rc > 0) {\n            *len += rc;\n            if (ctxt->input_mode == AP_MODE_SPECULATIVE) {\n                /* We want to rollback this read. */\n                char_buffer_write(&ctxt->input_cbuf, buf,\n                                  *len);\n            }\n            return ctxt->input_rc;\n        } else if (rc == 0) {\n            /* EOF, return code depends on whether we still have data\n             * to return. */\n            if (*len > 0) {\n                ctxt->input_rc = APR_SUCCESS;\n            } else {\n                ctxt->input_rc = APR_EOF;\n            }\n            break;\n        } else { /* (rc < 0) */\n\n            if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN)\n            {\n                ap_log_cerror(APLOG_MARK, APLOG_TRACE2, ctxt->input_rc, ctxt->c,\n                              \"%s: looping recv after '%s' (%d)\",\n                              __func__, gnutls_strerror(rc), rc);\n                /* For a blocking read, loop and try again\n                 * immediately. Otherwise just notify the caller. */\n                if (ctxt->input_block != APR_NONBLOCK_READ)\n                    continue;\n                else\n                    ctxt->input_rc =\n                        (rc == GNUTLS_E_AGAIN ? APR_EAGAIN : APR_EINTR);\n            } else if (rc == GNUTLS_E_REHANDSHAKE) {\n                /* A client has asked for a new Hankshake. Currently, we don't do it */\n                ap_log_cerror(APLOG_MARK, APLOG_DEBUG,\n                        ctxt->input_rc,\n                        ctxt->c,\n                        \"GnuTLS: Error reading data. Client Requested a New Handshake.\"\n                        \" (%d) '%s'\", rc,\n                        gnutls_strerror(rc));\n            } else if (rc == GNUTLS_E_WARNING_ALERT_RECEIVED) {\n                rc = gnutls_alert_get(ctxt->session);\n                ap_log_cerror(APLOG_MARK, APLOG_DEBUG,\n                        ctxt->input_rc,\n                        ctxt->c,\n                        \"GnuTLS: Warning Alert From Client: \"\n                        \" (%d) '%s'\", rc,\n                        gnutls_alert_get_name(rc));\n            } else if (rc == GNUTLS_E_FATAL_ALERT_RECEIVED) {\n                rc = gnutls_alert_get(ctxt->session);\n                ap_log_cerror(APLOG_MARK, APLOG_DEBUG,\n                        ctxt->input_rc,\n                        ctxt->c,\n                        \"GnuTLS: Fatal Alert From Client: \"\n                        \"(%d) '%s'\", rc,\n                        gnutls_alert_get_name(rc));\n                ctxt->input_rc = APR_EGENERAL;\n                break;\n            } else if (rc == GNUTLS_E_PULL_ERROR\n                       && APR_STATUS_IS_TIMEUP(ctxt->input_rc)) {\n                ap_log_cerror(\n                    APLOG_MARK, APLOG_TRACE2, ctxt->input_rc, ctxt->c,\n                    \"%s: transport read timed out\", __func__);\n            } else {\n                /* Some Other Error. Report it. Die. */\n                if (gnutls_error_is_fatal(rc)) {\n                    ap_log_cerror(\n                        APLOG_MARK, APLOG_DEBUG,\n                        ctxt->input_rc,\n                        ctxt->c,\n                        \"GnuTLS: Error reading data. (%d) '%s'\",\n                        rc, gnutls_strerror(rc));\n                } else if (*len > 0) {\n                    ctxt->input_rc = APR_SUCCESS;\n                    break;\n                }\n            }\n\n            if (ctxt->input_rc == APR_SUCCESS) {\n                ap_log_cerror(APLOG_MARK, APLOG_INFO, ctxt->input_rc, ctxt->c,\n                              \"%s: GnuTLS error: %s (%d)\",\n                              __func__, gnutls_strerror(rc), rc);\n                ctxt->input_rc = APR_EGENERAL;\n            }\n            break;\n        }\n    }\n    return ctxt->input_rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -106,6 +106,11 @@\n                         gnutls_alert_get_name(rc));\n                 ctxt->input_rc = APR_EGENERAL;\n                 break;\n+            } else if (rc == GNUTLS_E_PULL_ERROR\n+                       && APR_STATUS_IS_TIMEUP(ctxt->input_rc)) {\n+                ap_log_cerror(\n+                    APLOG_MARK, APLOG_TRACE2, ctxt->input_rc, ctxt->c,\n+                    \"%s: transport read timed out\", __func__);\n             } else {\n                 /* Some Other Error. Report it. Die. */\n                 if (gnutls_error_is_fatal(rc)) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            } else if (rc == GNUTLS_E_PULL_ERROR",
                "                       && APR_STATUS_IS_TIMEUP(ctxt->input_rc)) {",
                "                ap_log_cerror(",
                "                    APLOG_MARK, APLOG_TRACE2, ctxt->input_rc, ctxt->c,",
                "                    \"%s: transport read timed out\", __func__);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0711",
        "func_name": "haproxy/http_manage_server_side_cookies",
        "description": "A flaw was found in the way HAProxy processed HTTP responses containing the \"Set-Cookie2\" header. This flaw could allow an attacker to send crafted HTTP response packets which lead to an infinite loop, eventually resulting in a denial of service condition. The highest threat from this vulnerability is availability.",
        "git_url": "https://github.com/haproxy/haproxy/commit/bfb15ab34ead85f64cd6da0e9fb418c9cd14cee8",
        "commit_title": "BUG/MAJOR: http/htx: prevent unbounded loop in http_manage_server_side_cookies",
        "commit_text": " Ensure calls to http_find_header() terminate. If a \"Set-Cookie2\" header is found then the while(1) loop in http_manage_server_side_cookies() will never terminate, resulting in the watchdog firing and the process terminating via SIGABRT.  The while(1) loop becomes unbounded because an unmatched call to http_find_header(\"Set-Cookie\") will leave ctx->blk=NULL. Subsequent calls to check for \"Set-Cookie2\" will now enumerate from the beginning of all the blocks and will once again match on subsequent passes (assuming a match first time around), hence the loop becoming unbounded.  This issue was introduced with HTX and this fix should be backported to all versions supporting HTX.  Many thanks to Grant Spence (gspence@redhat.com) for working through this issue with me.",
        "func_before": "static void http_manage_server_side_cookies(struct stream *s, struct channel *res)\n{\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct htx *htx;\n\tstruct http_hdr_ctx ctx;\n\tstruct server *srv;\n\tchar *hdr_beg, *hdr_end;\n\tchar *prev, *att_beg, *att_end, *equal, *val_beg, *val_end, *next;\n\tint is_cookie2 = 0;\n\n\thtx = htxbuf(&res->buf);\n\n\tctx.blk = NULL;\n\twhile (1) {\n\t\tint is_first = 1;\n\n\t\tif (!http_find_header(htx, ist(\"Set-Cookie\"), &ctx, 1)) {\n\t\t\tif (!http_find_header(htx, ist(\"Set-Cookie2\"), &ctx, 1))\n\t\t\t\tbreak;\n\t\t\tis_cookie2 = 1;\n\t\t}\n\n\t\t/* OK, right now we know we have a Set-Cookie* at hdr_beg, and\n\t\t * <prev> points to the colon.\n\t\t */\n\t\ttxn->flags |= TX_SCK_PRESENT;\n\n\t\t/* Maybe we only wanted to see if there was a Set-Cookie (eg:\n\t\t * check-cache is enabled) and we are not interested in checking\n\t\t * them. Warning, the cookie capture is declared in the frontend.\n\t\t */\n\t\tif (s->be->cookie_name == NULL && sess->fe->capture_name == NULL)\n\t\t\tbreak;\n\n\t\t/* OK so now we know we have to process this response cookie.\n\t\t * The format of the Set-Cookie header is slightly different\n\t\t * from the format of the Cookie header in that it does not\n\t\t * support the comma as a cookie delimiter (thus the header\n\t\t * cannot be folded) because the Expires attribute described in\n\t\t * the original Netscape's spec may contain an unquoted date\n\t\t * with a comma inside. We have to live with this because\n\t\t * many browsers don't support Max-Age and some browsers don't\n\t\t * support quoted strings. However the Set-Cookie2 header is\n\t\t * clean.\n\t\t *\n\t\t * We have to keep multiple pointers in order to support cookie\n\t\t * removal at the beginning, middle or end of header without\n\t\t * corrupting the header (in case of set-cookie2). A special\n\t\t * pointer, <scav> points to the beginning of the set-cookie-av\n\t\t * fields after the first semi-colon. The <next> pointer points\n\t\t * either to the end of line (set-cookie) or next unquoted comma\n\t\t * (set-cookie2). All of these headers are valid :\n\t\t *\n\t\t * hdr_beg                                                  hdr_end\n\t\t * |                                                           |\n\t\t * v                                                           |\n\t\t * NAME1  =  VALUE 1  ; Secure; Path=\"/\"                       |\n\t\t * NAME=VALUE; Secure; Expires=Thu, 01-Jan-1970 00:00:01 GMT   v\n\t\t * NAME = VALUE ; Secure; Expires=Thu, 01-Jan-1970 00:00:01 GMT\n\t\t * NAME1 = VALUE 1 ; Max-Age=0, NAME2=VALUE2; Discard\n\t\t * | |   | | |     | |          |\n\t\t * | |   | | |     | |          +-> next\n\t\t * | |   | | |     | +------------> scav\n\t\t * | |   | | |     +--------------> val_end\n\t\t * | |   | | +--------------------> val_beg\n\t\t * | |   | +----------------------> equal\n\t\t * | |   +------------------------> att_end\n\t\t * | +----------------------------> att_beg\n\t\t * +------------------------------> prev\n\t\t * -------------------------------> hdr_beg\n\t\t */\n\t\thdr_beg = ctx.value.ptr;\n\t\thdr_end = hdr_beg + ctx.value.len;\n\t\tfor (prev = hdr_beg; prev < hdr_end; prev = next) {\n\n\t\t\t/* Iterate through all cookies on this line */\n\n\t\t\t/* find att_beg */\n\t\t\tatt_beg = prev;\n\t\t\tif (!is_first)\n\t\t\t\tatt_beg++;\n\t\t\tis_first = 0;\n\n\t\t\twhile (att_beg < hdr_end && HTTP_IS_SPHT(*att_beg))\n\t\t\t\tatt_beg++;\n\n\t\t\t/* find att_end : this is the first character after the last non\n\t\t\t * space before the equal. It may be equal to hdr_end.\n\t\t\t */\n\t\t\tequal = att_end = att_beg;\n\n\t\t\twhile (equal < hdr_end) {\n\t\t\t\tif (*equal == '=' || *equal == ';' || (is_cookie2 && *equal == ','))\n\t\t\t\t\tbreak;\n\t\t\t\tif (HTTP_IS_SPHT(*equal++))\n\t\t\t\t\tcontinue;\n\t\t\t\tatt_end = equal;\n\t\t\t}\n\n\t\t\t/* here, <equal> points to '=', a delimiter or the end. <att_end>\n\t\t\t * is between <att_beg> and <equal>, both may be identical.\n\t\t\t */\n\n\t\t\t/* look for end of cookie if there is an equal sign */\n\t\t\tif (equal < hdr_end && *equal == '=') {\n\t\t\t\t/* look for the beginning of the value */\n\t\t\t\tval_beg = equal + 1;\n\t\t\t\twhile (val_beg < hdr_end && HTTP_IS_SPHT(*val_beg))\n\t\t\t\t\tval_beg++;\n\n\t\t\t\t/* find the end of the value, respecting quotes */\n\t\t\t\tnext = http_find_cookie_value_end(val_beg, hdr_end);\n\n\t\t\t\t/* make val_end point to the first white space or delimiter after the value */\n\t\t\t\tval_end = next;\n\t\t\t\twhile (val_end > val_beg && HTTP_IS_SPHT(*(val_end - 1)))\n\t\t\t\t\tval_end--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* <equal> points to next comma, semi-colon or EOL */\n\t\t\t\tval_beg = val_end = next = equal;\n\t\t\t}\n\n\t\t\tif (next < hdr_end) {\n\t\t\t\t/* Set-Cookie2 supports multiple cookies, and <next> points to\n\t\t\t\t * a colon or semi-colon before the end. So skip all attr-value\n\t\t\t\t * pairs and look for the next comma. For Set-Cookie, since\n\t\t\t\t * commas are permitted in values, skip to the end.\n\t\t\t\t */\n\t\t\t\tif (is_cookie2)\n\t\t\t\t\tnext = http_find_hdr_value_end(next, hdr_end);\n\t\t\t\telse\n\t\t\t\t\tnext = hdr_end;\n\t\t\t}\n\n\t\t\t/* Now everything is as on the diagram above */\n\n\t\t\t/* Ignore cookies with no equal sign */\n\t\t\tif (equal == val_end)\n\t\t\t\tcontinue;\n\n\t\t\t/* If there are spaces around the equal sign, we need to\n\t\t\t * strip them otherwise we'll get trouble for cookie captures,\n\t\t\t * or even for rewrites. Since this happens extremely rarely,\n\t\t\t * it does not hurt performance.\n\t\t\t */\n\t\t\tif (unlikely(att_end != equal || val_beg > equal + 1)) {\n\t\t\t\tint stripped_before = 0;\n\t\t\t\tint stripped_after = 0;\n\n\t\t\t\tif (att_end != equal) {\n\t\t\t\t\tmemmove(att_end, equal, hdr_end - equal);\n\t\t\t\t\tstripped_before = (att_end - equal);\n\t\t\t\t\tequal   += stripped_before;\n\t\t\t\t\tval_beg += stripped_before;\n\t\t\t\t}\n\n\t\t\t\tif (val_beg > equal + 1) {\n\t\t\t\t\tmemmove(equal + 1, val_beg, hdr_end + stripped_before - val_beg);\n\t\t\t\t\tstripped_after = (equal + 1) - val_beg;\n\t\t\t\t\tval_beg += stripped_after;\n\t\t\t\t\tstripped_before += stripped_after;\n\t\t\t\t}\n\n\t\t\t\tval_end      += stripped_before;\n\t\t\t\tnext         += stripped_before;\n\t\t\t\thdr_end      += stripped_before;\n\n\t\t\t\thtx_change_blk_value_len(htx, ctx.blk, hdr_end - hdr_beg);\n\t\t\t\tctx.value.len = hdr_end - hdr_beg;\n\t\t\t}\n\n\t\t\t/* First, let's see if we want to capture this cookie. We check\n\t\t\t * that we don't already have a server side cookie, because we\n\t\t\t * can only capture one. Also as an optimisation, we ignore\n\t\t\t * cookies shorter than the declared name.\n\t\t\t */\n\t\t\tif (sess->fe->capture_name != NULL &&\n\t\t\t    txn->srv_cookie == NULL &&\n\t\t\t    (val_end - att_beg >= sess->fe->capture_namelen) &&\n\t\t\t    memcmp(att_beg, sess->fe->capture_name, sess->fe->capture_namelen) == 0) {\n\t\t\t\tint log_len = val_end - att_beg;\n\t\t\t\tif ((txn->srv_cookie = pool_alloc(pool_head_capture)) == NULL) {\n\t\t\t\t\tha_alert(\"HTTP logging : out of memory.\\n\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (log_len > sess->fe->capture_len)\n\t\t\t\t\t\tlog_len = sess->fe->capture_len;\n\t\t\t\t\tmemcpy(txn->srv_cookie, att_beg, log_len);\n\t\t\t\t\ttxn->srv_cookie[log_len] = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsrv = objt_server(s->target);\n\t\t\t/* now check if we need to process it for persistence */\n\t\t\tif (!(s->flags & SF_IGNORE_PRST) &&\n\t\t\t    (att_end - att_beg == s->be->cookie_len) && (s->be->cookie_name != NULL) &&\n\t\t\t    (memcmp(att_beg, s->be->cookie_name, att_end - att_beg) == 0)) {\n\t\t\t\t/* assume passive cookie by default */\n\t\t\t\ttxn->flags &= ~TX_SCK_MASK;\n\t\t\t\ttxn->flags |= TX_SCK_FOUND;\n\n\t\t\t\t/* If the cookie is in insert mode on a known server, we'll delete\n\t\t\t\t * this occurrence because we'll insert another one later.\n\t\t\t\t * We'll delete it too if the \"indirect\" option is set and we're in\n\t\t\t\t * a direct access.\n\t\t\t\t */\n\t\t\t\tif (s->be->ck_opts & PR_CK_PSV) {\n\t\t\t\t\t/* The \"preserve\" flag was set, we don't want to touch the\n\t\t\t\t\t * server's cookie.\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t\telse if ((srv && (s->be->ck_opts & PR_CK_INS)) ||\n\t\t\t\t    ((s->flags & SF_DIRECT) && (s->be->ck_opts & PR_CK_IND))) {\n\t\t\t\t\t/* this cookie must be deleted */\n\t\t\t\t\tif (prev == hdr_beg && next == hdr_end) {\n\t\t\t\t\t\t/* whole header */\n\t\t\t\t\t\thttp_remove_header(htx, &ctx);\n\t\t\t\t\t\t/* note: while both invalid now, <next> and <hdr_end>\n\t\t\t\t\t\t * are still equal, so the for() will stop as expected.\n\t\t\t\t\t\t */\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* just remove the value */\n\t\t\t\t\t\tint delta = http_del_hdr_value(hdr_beg, hdr_end, &prev, next);\n\t\t\t\t\t\tnext      = prev;\n\t\t\t\t\t\thdr_end  += delta;\n\t\t\t\t\t}\n\t\t\t\t\ttxn->flags &= ~TX_SCK_MASK;\n\t\t\t\t\ttxn->flags |= TX_SCK_DELETED;\n\t\t\t\t\t/* and go on with next cookie */\n\t\t\t\t}\n\t\t\t\telse if (srv && srv->cookie && (s->be->ck_opts & PR_CK_RW)) {\n\t\t\t\t\t/* replace bytes val_beg->val_end with the cookie name associated\n\t\t\t\t\t * with this server since we know it.\n\t\t\t\t\t */\n\t\t\t\t\tint sliding, delta;\n\n\t\t\t\t\tctx.value = ist2(val_beg, val_end - val_beg);\n\t\t\t\t        ctx.lws_before = ctx.lws_after = 0;\n\t\t\t\t\thttp_replace_header_value(htx, &ctx, ist2(srv->cookie, srv->cklen));\n\t\t\t\t\tdelta     = srv->cklen - (val_end - val_beg);\n\t\t\t\t\tsliding   = (ctx.value.ptr - val_beg);\n\t\t\t\t\thdr_beg  += sliding;\n\t\t\t\t\tval_beg  += sliding;\n\t\t\t\t\tnext     += sliding + delta;\n\t\t\t\t\thdr_end  += sliding + delta;\n\n\t\t\t\t\ttxn->flags &= ~TX_SCK_MASK;\n\t\t\t\t\ttxn->flags |= TX_SCK_REPLACED;\n\t\t\t\t}\n\t\t\t\telse if (srv && srv->cookie && (s->be->ck_opts & PR_CK_PFX)) {\n\t\t\t\t\t/* insert the cookie name associated with this server\n\t\t\t\t\t * before existing cookie, and insert a delimiter between them..\n\t\t\t\t\t */\n\t\t\t\t\tint sliding, delta;\n\t\t\t\t\tctx.value = ist2(val_beg, 0);\n\t\t\t\t        ctx.lws_before = ctx.lws_after = 0;\n\t\t\t\t\thttp_replace_header_value(htx, &ctx, ist2(srv->cookie, srv->cklen + 1));\n\t\t\t\t\tdelta     = srv->cklen + 1;\n\t\t\t\t\tsliding   = (ctx.value.ptr - val_beg);\n\t\t\t\t\thdr_beg  += sliding;\n\t\t\t\t\tval_beg  += sliding;\n\t\t\t\t\tnext     += sliding + delta;\n\t\t\t\t\thdr_end  += sliding + delta;\n\n\t\t\t\t\tval_beg[srv->cklen] = COOKIE_DELIM;\n\t\t\t\t\ttxn->flags &= ~TX_SCK_MASK;\n\t\t\t\t\ttxn->flags |= TX_SCK_REPLACED;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* that's done for this cookie, check the next one on the same\n\t\t\t * line when next != hdr_end (only if is_cookie2).\n\t\t\t */\n\t\t}\n\t}\n}",
        "func": "static void http_manage_server_side_cookies(struct stream *s, struct channel *res)\n{\n\tstruct session *sess = s->sess;\n\tstruct http_txn *txn = s->txn;\n\tstruct htx *htx;\n\tstruct http_hdr_ctx ctx;\n\tstruct server *srv;\n\tchar *hdr_beg, *hdr_end;\n\tchar *prev, *att_beg, *att_end, *equal, *val_beg, *val_end, *next;\n\tint is_cookie2 = 0;\n\n\thtx = htxbuf(&res->buf);\n\n\tctx.blk = NULL;\n\twhile (1) {\n\t\tint is_first = 1;\n\n\t\tif (is_cookie2 || !http_find_header(htx, ist(\"Set-Cookie\"), &ctx, 1)) {\n\t\t\tif (!http_find_header(htx, ist(\"Set-Cookie2\"), &ctx, 1))\n\t\t\t\tbreak;\n\t\t\tis_cookie2 = 1;\n\t\t}\n\n\t\t/* OK, right now we know we have a Set-Cookie* at hdr_beg, and\n\t\t * <prev> points to the colon.\n\t\t */\n\t\ttxn->flags |= TX_SCK_PRESENT;\n\n\t\t/* Maybe we only wanted to see if there was a Set-Cookie (eg:\n\t\t * check-cache is enabled) and we are not interested in checking\n\t\t * them. Warning, the cookie capture is declared in the frontend.\n\t\t */\n\t\tif (s->be->cookie_name == NULL && sess->fe->capture_name == NULL)\n\t\t\tbreak;\n\n\t\t/* OK so now we know we have to process this response cookie.\n\t\t * The format of the Set-Cookie header is slightly different\n\t\t * from the format of the Cookie header in that it does not\n\t\t * support the comma as a cookie delimiter (thus the header\n\t\t * cannot be folded) because the Expires attribute described in\n\t\t * the original Netscape's spec may contain an unquoted date\n\t\t * with a comma inside. We have to live with this because\n\t\t * many browsers don't support Max-Age and some browsers don't\n\t\t * support quoted strings. However the Set-Cookie2 header is\n\t\t * clean.\n\t\t *\n\t\t * We have to keep multiple pointers in order to support cookie\n\t\t * removal at the beginning, middle or end of header without\n\t\t * corrupting the header (in case of set-cookie2). A special\n\t\t * pointer, <scav> points to the beginning of the set-cookie-av\n\t\t * fields after the first semi-colon. The <next> pointer points\n\t\t * either to the end of line (set-cookie) or next unquoted comma\n\t\t * (set-cookie2). All of these headers are valid :\n\t\t *\n\t\t * hdr_beg                                                  hdr_end\n\t\t * |                                                           |\n\t\t * v                                                           |\n\t\t * NAME1  =  VALUE 1  ; Secure; Path=\"/\"                       |\n\t\t * NAME=VALUE; Secure; Expires=Thu, 01-Jan-1970 00:00:01 GMT   v\n\t\t * NAME = VALUE ; Secure; Expires=Thu, 01-Jan-1970 00:00:01 GMT\n\t\t * NAME1 = VALUE 1 ; Max-Age=0, NAME2=VALUE2; Discard\n\t\t * | |   | | |     | |          |\n\t\t * | |   | | |     | |          +-> next\n\t\t * | |   | | |     | +------------> scav\n\t\t * | |   | | |     +--------------> val_end\n\t\t * | |   | | +--------------------> val_beg\n\t\t * | |   | +----------------------> equal\n\t\t * | |   +------------------------> att_end\n\t\t * | +----------------------------> att_beg\n\t\t * +------------------------------> prev\n\t\t * -------------------------------> hdr_beg\n\t\t */\n\t\thdr_beg = ctx.value.ptr;\n\t\thdr_end = hdr_beg + ctx.value.len;\n\t\tfor (prev = hdr_beg; prev < hdr_end; prev = next) {\n\n\t\t\t/* Iterate through all cookies on this line */\n\n\t\t\t/* find att_beg */\n\t\t\tatt_beg = prev;\n\t\t\tif (!is_first)\n\t\t\t\tatt_beg++;\n\t\t\tis_first = 0;\n\n\t\t\twhile (att_beg < hdr_end && HTTP_IS_SPHT(*att_beg))\n\t\t\t\tatt_beg++;\n\n\t\t\t/* find att_end : this is the first character after the last non\n\t\t\t * space before the equal. It may be equal to hdr_end.\n\t\t\t */\n\t\t\tequal = att_end = att_beg;\n\n\t\t\twhile (equal < hdr_end) {\n\t\t\t\tif (*equal == '=' || *equal == ';' || (is_cookie2 && *equal == ','))\n\t\t\t\t\tbreak;\n\t\t\t\tif (HTTP_IS_SPHT(*equal++))\n\t\t\t\t\tcontinue;\n\t\t\t\tatt_end = equal;\n\t\t\t}\n\n\t\t\t/* here, <equal> points to '=', a delimiter or the end. <att_end>\n\t\t\t * is between <att_beg> and <equal>, both may be identical.\n\t\t\t */\n\n\t\t\t/* look for end of cookie if there is an equal sign */\n\t\t\tif (equal < hdr_end && *equal == '=') {\n\t\t\t\t/* look for the beginning of the value */\n\t\t\t\tval_beg = equal + 1;\n\t\t\t\twhile (val_beg < hdr_end && HTTP_IS_SPHT(*val_beg))\n\t\t\t\t\tval_beg++;\n\n\t\t\t\t/* find the end of the value, respecting quotes */\n\t\t\t\tnext = http_find_cookie_value_end(val_beg, hdr_end);\n\n\t\t\t\t/* make val_end point to the first white space or delimiter after the value */\n\t\t\t\tval_end = next;\n\t\t\t\twhile (val_end > val_beg && HTTP_IS_SPHT(*(val_end - 1)))\n\t\t\t\t\tval_end--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* <equal> points to next comma, semi-colon or EOL */\n\t\t\t\tval_beg = val_end = next = equal;\n\t\t\t}\n\n\t\t\tif (next < hdr_end) {\n\t\t\t\t/* Set-Cookie2 supports multiple cookies, and <next> points to\n\t\t\t\t * a colon or semi-colon before the end. So skip all attr-value\n\t\t\t\t * pairs and look for the next comma. For Set-Cookie, since\n\t\t\t\t * commas are permitted in values, skip to the end.\n\t\t\t\t */\n\t\t\t\tif (is_cookie2)\n\t\t\t\t\tnext = http_find_hdr_value_end(next, hdr_end);\n\t\t\t\telse\n\t\t\t\t\tnext = hdr_end;\n\t\t\t}\n\n\t\t\t/* Now everything is as on the diagram above */\n\n\t\t\t/* Ignore cookies with no equal sign */\n\t\t\tif (equal == val_end)\n\t\t\t\tcontinue;\n\n\t\t\t/* If there are spaces around the equal sign, we need to\n\t\t\t * strip them otherwise we'll get trouble for cookie captures,\n\t\t\t * or even for rewrites. Since this happens extremely rarely,\n\t\t\t * it does not hurt performance.\n\t\t\t */\n\t\t\tif (unlikely(att_end != equal || val_beg > equal + 1)) {\n\t\t\t\tint stripped_before = 0;\n\t\t\t\tint stripped_after = 0;\n\n\t\t\t\tif (att_end != equal) {\n\t\t\t\t\tmemmove(att_end, equal, hdr_end - equal);\n\t\t\t\t\tstripped_before = (att_end - equal);\n\t\t\t\t\tequal   += stripped_before;\n\t\t\t\t\tval_beg += stripped_before;\n\t\t\t\t}\n\n\t\t\t\tif (val_beg > equal + 1) {\n\t\t\t\t\tmemmove(equal + 1, val_beg, hdr_end + stripped_before - val_beg);\n\t\t\t\t\tstripped_after = (equal + 1) - val_beg;\n\t\t\t\t\tval_beg += stripped_after;\n\t\t\t\t\tstripped_before += stripped_after;\n\t\t\t\t}\n\n\t\t\t\tval_end      += stripped_before;\n\t\t\t\tnext         += stripped_before;\n\t\t\t\thdr_end      += stripped_before;\n\n\t\t\t\thtx_change_blk_value_len(htx, ctx.blk, hdr_end - hdr_beg);\n\t\t\t\tctx.value.len = hdr_end - hdr_beg;\n\t\t\t}\n\n\t\t\t/* First, let's see if we want to capture this cookie. We check\n\t\t\t * that we don't already have a server side cookie, because we\n\t\t\t * can only capture one. Also as an optimisation, we ignore\n\t\t\t * cookies shorter than the declared name.\n\t\t\t */\n\t\t\tif (sess->fe->capture_name != NULL &&\n\t\t\t    txn->srv_cookie == NULL &&\n\t\t\t    (val_end - att_beg >= sess->fe->capture_namelen) &&\n\t\t\t    memcmp(att_beg, sess->fe->capture_name, sess->fe->capture_namelen) == 0) {\n\t\t\t\tint log_len = val_end - att_beg;\n\t\t\t\tif ((txn->srv_cookie = pool_alloc(pool_head_capture)) == NULL) {\n\t\t\t\t\tha_alert(\"HTTP logging : out of memory.\\n\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (log_len > sess->fe->capture_len)\n\t\t\t\t\t\tlog_len = sess->fe->capture_len;\n\t\t\t\t\tmemcpy(txn->srv_cookie, att_beg, log_len);\n\t\t\t\t\ttxn->srv_cookie[log_len] = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsrv = objt_server(s->target);\n\t\t\t/* now check if we need to process it for persistence */\n\t\t\tif (!(s->flags & SF_IGNORE_PRST) &&\n\t\t\t    (att_end - att_beg == s->be->cookie_len) && (s->be->cookie_name != NULL) &&\n\t\t\t    (memcmp(att_beg, s->be->cookie_name, att_end - att_beg) == 0)) {\n\t\t\t\t/* assume passive cookie by default */\n\t\t\t\ttxn->flags &= ~TX_SCK_MASK;\n\t\t\t\ttxn->flags |= TX_SCK_FOUND;\n\n\t\t\t\t/* If the cookie is in insert mode on a known server, we'll delete\n\t\t\t\t * this occurrence because we'll insert another one later.\n\t\t\t\t * We'll delete it too if the \"indirect\" option is set and we're in\n\t\t\t\t * a direct access.\n\t\t\t\t */\n\t\t\t\tif (s->be->ck_opts & PR_CK_PSV) {\n\t\t\t\t\t/* The \"preserve\" flag was set, we don't want to touch the\n\t\t\t\t\t * server's cookie.\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t\telse if ((srv && (s->be->ck_opts & PR_CK_INS)) ||\n\t\t\t\t    ((s->flags & SF_DIRECT) && (s->be->ck_opts & PR_CK_IND))) {\n\t\t\t\t\t/* this cookie must be deleted */\n\t\t\t\t\tif (prev == hdr_beg && next == hdr_end) {\n\t\t\t\t\t\t/* whole header */\n\t\t\t\t\t\thttp_remove_header(htx, &ctx);\n\t\t\t\t\t\t/* note: while both invalid now, <next> and <hdr_end>\n\t\t\t\t\t\t * are still equal, so the for() will stop as expected.\n\t\t\t\t\t\t */\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* just remove the value */\n\t\t\t\t\t\tint delta = http_del_hdr_value(hdr_beg, hdr_end, &prev, next);\n\t\t\t\t\t\tnext      = prev;\n\t\t\t\t\t\thdr_end  += delta;\n\t\t\t\t\t}\n\t\t\t\t\ttxn->flags &= ~TX_SCK_MASK;\n\t\t\t\t\ttxn->flags |= TX_SCK_DELETED;\n\t\t\t\t\t/* and go on with next cookie */\n\t\t\t\t}\n\t\t\t\telse if (srv && srv->cookie && (s->be->ck_opts & PR_CK_RW)) {\n\t\t\t\t\t/* replace bytes val_beg->val_end with the cookie name associated\n\t\t\t\t\t * with this server since we know it.\n\t\t\t\t\t */\n\t\t\t\t\tint sliding, delta;\n\n\t\t\t\t\tctx.value = ist2(val_beg, val_end - val_beg);\n\t\t\t\t        ctx.lws_before = ctx.lws_after = 0;\n\t\t\t\t\thttp_replace_header_value(htx, &ctx, ist2(srv->cookie, srv->cklen));\n\t\t\t\t\tdelta     = srv->cklen - (val_end - val_beg);\n\t\t\t\t\tsliding   = (ctx.value.ptr - val_beg);\n\t\t\t\t\thdr_beg  += sliding;\n\t\t\t\t\tval_beg  += sliding;\n\t\t\t\t\tnext     += sliding + delta;\n\t\t\t\t\thdr_end  += sliding + delta;\n\n\t\t\t\t\ttxn->flags &= ~TX_SCK_MASK;\n\t\t\t\t\ttxn->flags |= TX_SCK_REPLACED;\n\t\t\t\t}\n\t\t\t\telse if (srv && srv->cookie && (s->be->ck_opts & PR_CK_PFX)) {\n\t\t\t\t\t/* insert the cookie name associated with this server\n\t\t\t\t\t * before existing cookie, and insert a delimiter between them..\n\t\t\t\t\t */\n\t\t\t\t\tint sliding, delta;\n\t\t\t\t\tctx.value = ist2(val_beg, 0);\n\t\t\t\t        ctx.lws_before = ctx.lws_after = 0;\n\t\t\t\t\thttp_replace_header_value(htx, &ctx, ist2(srv->cookie, srv->cklen + 1));\n\t\t\t\t\tdelta     = srv->cklen + 1;\n\t\t\t\t\tsliding   = (ctx.value.ptr - val_beg);\n\t\t\t\t\thdr_beg  += sliding;\n\t\t\t\t\tval_beg  += sliding;\n\t\t\t\t\tnext     += sliding + delta;\n\t\t\t\t\thdr_end  += sliding + delta;\n\n\t\t\t\t\tval_beg[srv->cklen] = COOKIE_DELIM;\n\t\t\t\t\ttxn->flags &= ~TX_SCK_MASK;\n\t\t\t\t\ttxn->flags |= TX_SCK_REPLACED;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* that's done for this cookie, check the next one on the same\n\t\t\t * line when next != hdr_end (only if is_cookie2).\n\t\t\t */\n\t\t}\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,7 @@\n \twhile (1) {\n \t\tint is_first = 1;\n \n-\t\tif (!http_find_header(htx, ist(\"Set-Cookie\"), &ctx, 1)) {\n+\t\tif (is_cookie2 || !http_find_header(htx, ist(\"Set-Cookie\"), &ctx, 1)) {\n \t\t\tif (!http_find_header(htx, ist(\"Set-Cookie2\"), &ctx, 1))\n \t\t\t\tbreak;\n \t\t\tis_cookie2 = 1;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (!http_find_header(htx, ist(\"Set-Cookie\"), &ctx, 1)) {"
            ],
            "added_lines": [
                "\t\tif (is_cookie2 || !http_find_header(htx, ist(\"Set-Cookie\"), &ctx, 1)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0778",
        "func_name": "openssl/BN_mod_sqrt",
        "description": "The BN_mod_sqrt() function, which computes a modular square root, contains a bug that can cause it to loop forever for non-prime moduli. Internally this function is used when parsing certificates that contain elliptic curve public keys in compressed form or explicit elliptic curve parameters with a base point encoded in compressed form. It is possible to trigger the infinite loop by crafting a certificate that has invalid explicit curve parameters. Since certificate parsing happens prior to verification of the certificate signature, any process that parses an externally supplied certificate may thus be subject to a denial of service attack. The infinite loop can also be reached when parsing crafted private keys as they can contain explicit elliptic curve parameters. Thus vulnerable situations include: - TLS clients consuming server certificates - TLS servers consuming client certificates - Hosting providers taking certificates or private keys from customers - Certificate authorities parsing certification requests from subscribers - Anything else which parses ASN.1 elliptic curve parameters Also any other applications that use the BN_mod_sqrt() where the attacker can control the parameter values are vulnerable to this DoS issue. In the OpenSSL 1.0.2 version the public key is not parsed during initial parsing of the certificate which makes it slightly harder to trigger the infinite loop. However any operation which requires the public key from the certificate will trigger the infinite loop. In particular the attacker can use a self-signed certificate to trigger the loop during verification of the certificate signature. This issue affects OpenSSL versions 1.0.2, 1.1.1 and 3.0. It was addressed in the releases of 1.1.1n and 3.0.2 on the 15th March 2022. Fixed in OpenSSL 3.0.2 (Affected 3.0.0,3.0.1). Fixed in OpenSSL 1.1.1n (Affected 1.1.1-1.1.1m). Fixed in OpenSSL 1.0.2zd (Affected 1.0.2-1.0.2zc).",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=3118eb64934499d93db3230748a452351d1d9a65",
        "commit_title": "",
        "commit_text": "Fix possible infinite loop in BN_mod_sqrt()  The calculation in some cases does not finish for non-prime p.  This fixes CVE-2022-0778.  Based on patch by David Benjamin <davidben@google.com>.  ",
        "func_before": "BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)\n/*\n * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks\n * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number\n * Theory\", algorithm 1.5.1). 'p' must be prime!\n */\n{\n    BIGNUM *ret = in;\n    int err = 1;\n    int r;\n    BIGNUM *A, *b, *q, *t, *x, *y;\n    int e, i, j;\n\n    if (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\n        if (BN_abs_is_word(p, 2)) {\n            if (ret == NULL)\n                ret = BN_new();\n            if (ret == NULL)\n                goto end;\n            if (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\n                if (ret != in)\n                    BN_free(ret);\n                return NULL;\n            }\n            bn_check_top(ret);\n            return ret;\n        }\n\n        BNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);\n        return NULL;\n    }\n\n    if (BN_is_zero(a) || BN_is_one(a)) {\n        if (ret == NULL)\n            ret = BN_new();\n        if (ret == NULL)\n            goto end;\n        if (!BN_set_word(ret, BN_is_one(a))) {\n            if (ret != in)\n                BN_free(ret);\n            return NULL;\n        }\n        bn_check_top(ret);\n        return ret;\n    }\n\n    BN_CTX_start(ctx);\n    A = BN_CTX_get(ctx);\n    b = BN_CTX_get(ctx);\n    q = BN_CTX_get(ctx);\n    t = BN_CTX_get(ctx);\n    x = BN_CTX_get(ctx);\n    y = BN_CTX_get(ctx);\n    if (y == NULL)\n        goto end;\n\n    if (ret == NULL)\n        ret = BN_new();\n    if (ret == NULL)\n        goto end;\n\n    /* A = a mod p */\n    if (!BN_nnmod(A, a, p, ctx))\n        goto end;\n\n    /* now write  |p| - 1  as  2^e*q  where  q  is odd */\n    e = 1;\n    while (!BN_is_bit_set(p, e))\n        e++;\n    /* we'll set  q  later (if needed) */\n\n    if (e == 1) {\n        /*-\n         * The easy case:  (|p|-1)/2  is odd, so 2 has an inverse\n         * modulo  (|p|-1)/2,  and square roots can be computed\n         * directly by modular exponentiation.\n         * We have\n         *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),\n         * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.\n         */\n        if (!BN_rshift(q, p, 2))\n            goto end;\n        q->neg = 0;\n        if (!BN_add_word(q, 1))\n            goto end;\n        if (!BN_mod_exp(ret, A, q, p, ctx))\n            goto end;\n        err = 0;\n        goto vrfy;\n    }\n\n    if (e == 2) {\n        /*-\n         * |p| == 5  (mod 8)\n         *\n         * In this case  2  is always a non-square since\n         * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.\n         * So if  a  really is a square, then  2*a  is a non-square.\n         * Thus for\n         *      b := (2*a)^((|p|-5)/8),\n         *      i := (2*a)*b^2\n         * we have\n         *     i^2 = (2*a)^((1 + (|p|-5)/4)*2)\n         *         = (2*a)^((p-1)/2)\n         *         = -1;\n         * so if we set\n         *      x := a*b*(i-1),\n         * then\n         *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)\n         *         = a^2 * b^2 * (-2*i)\n         *         = a*(-i)*(2*a*b^2)\n         *         = a*(-i)*i\n         *         = a.\n         *\n         * (This is due to A.O.L. Atkin,\n         * Subject: Square Roots and Cognate Matters modulo p=8n+5.\n         * URL: https://listserv.nodak.edu/cgi-bin/wa.exe?A2=ind9211&L=NMBRTHRY&P=4026\n         * November 1992.)\n         */\n\n        /* t := 2*a */\n        if (!BN_mod_lshift1_quick(t, A, p))\n            goto end;\n\n        /* b := (2*a)^((|p|-5)/8) */\n        if (!BN_rshift(q, p, 3))\n            goto end;\n        q->neg = 0;\n        if (!BN_mod_exp(b, t, q, p, ctx))\n            goto end;\n\n        /* y := b^2 */\n        if (!BN_mod_sqr(y, b, p, ctx))\n            goto end;\n\n        /* t := (2*a)*b^2 - 1 */\n        if (!BN_mod_mul(t, t, y, p, ctx))\n            goto end;\n        if (!BN_sub_word(t, 1))\n            goto end;\n\n        /* x = a*b*t */\n        if (!BN_mod_mul(x, A, b, p, ctx))\n            goto end;\n        if (!BN_mod_mul(x, x, t, p, ctx))\n            goto end;\n\n        if (!BN_copy(ret, x))\n            goto end;\n        err = 0;\n        goto vrfy;\n    }\n\n    /*\n     * e > 2, so we really have to use the Tonelli/Shanks algorithm. First,\n     * find some y that is not a square.\n     */\n    if (!BN_copy(q, p))\n        goto end;               /* use 'q' as temp */\n    q->neg = 0;\n    i = 2;\n    do {\n        /*\n         * For efficiency, try small numbers first; if this fails, try random\n         * numbers.\n         */\n        if (i < 22) {\n            if (!BN_set_word(y, i))\n                goto end;\n        } else {\n            if (!BN_priv_rand(y, BN_num_bits(p), 0, 0))\n                goto end;\n            if (BN_ucmp(y, p) >= 0) {\n                if (!(p->neg ? BN_add : BN_sub) (y, y, p))\n                    goto end;\n            }\n            /* now 0 <= y < |p| */\n            if (BN_is_zero(y))\n                if (!BN_set_word(y, i))\n                    goto end;\n        }\n\n        r = BN_kronecker(y, q, ctx); /* here 'q' is |p| */\n        if (r < -1)\n            goto end;\n        if (r == 0) {\n            /* m divides p */\n            BNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);\n            goto end;\n        }\n    }\n    while (r == 1 && ++i < 82);\n\n    if (r != -1) {\n        /*\n         * Many rounds and still no non-square -- this is more likely a bug\n         * than just bad luck. Even if p is not prime, we should have found\n         * some y such that r == -1.\n         */\n        BNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS);\n        goto end;\n    }\n\n    /* Here's our actual 'q': */\n    if (!BN_rshift(q, q, e))\n        goto end;\n\n    /*\n     * Now that we have some non-square, we can find an element of order 2^e\n     * by computing its q'th power.\n     */\n    if (!BN_mod_exp(y, y, q, p, ctx))\n        goto end;\n    if (BN_is_one(y)) {\n        BNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);\n        goto end;\n    }\n\n    /*-\n     * Now we know that (if  p  is indeed prime) there is an integer\n     * k,  0 <= k < 2^e,  such that\n     *\n     *      a^q * y^k == 1   (mod p).\n     *\n     * As  a^q  is a square and  y  is not,  k  must be even.\n     * q+1  is even, too, so there is an element\n     *\n     *     X := a^((q+1)/2) * y^(k/2),\n     *\n     * and it satisfies\n     *\n     *     X^2 = a^q * a     * y^k\n     *         = a,\n     *\n     * so it is the square root that we are looking for.\n     */\n\n    /* t := (q-1)/2  (note that  q  is odd) */\n    if (!BN_rshift1(t, q))\n        goto end;\n\n    /* x := a^((q-1)/2) */\n    if (BN_is_zero(t)) {        /* special case: p = 2^e + 1 */\n        if (!BN_nnmod(t, A, p, ctx))\n            goto end;\n        if (BN_is_zero(t)) {\n            /* special case: a == 0  (mod p) */\n            BN_zero(ret);\n            err = 0;\n            goto end;\n        } else if (!BN_one(x))\n            goto end;\n    } else {\n        if (!BN_mod_exp(x, A, t, p, ctx))\n            goto end;\n        if (BN_is_zero(x)) {\n            /* special case: a == 0  (mod p) */\n            BN_zero(ret);\n            err = 0;\n            goto end;\n        }\n    }\n\n    /* b := a*x^2  (= a^q) */\n    if (!BN_mod_sqr(b, x, p, ctx))\n        goto end;\n    if (!BN_mod_mul(b, b, A, p, ctx))\n        goto end;\n\n    /* x := a*x    (= a^((q+1)/2)) */\n    if (!BN_mod_mul(x, x, A, p, ctx))\n        goto end;\n\n    while (1) {\n        /*-\n         * Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E\n         * where  E  refers to the original value of  e,  which we\n         * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2).\n         *\n         * We have  a*b = x^2,\n         *    y^2^(e-1) = -1,\n         *    b^2^(e-1) = 1.\n         */\n\n        if (BN_is_one(b)) {\n            if (!BN_copy(ret, x))\n                goto end;\n            err = 0;\n            goto vrfy;\n        }\n\n        /* find smallest  i  such that  b^(2^i) = 1 */\n        i = 1;\n        if (!BN_mod_sqr(t, b, p, ctx))\n            goto end;\n        while (!BN_is_one(t)) {\n            i++;\n            if (i == e) {\n                BNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);\n                goto end;\n            }\n            if (!BN_mod_mul(t, t, t, p, ctx))\n                goto end;\n        }\n\n        /* t := y^2^(e - i - 1) */\n        if (!BN_copy(t, y))\n            goto end;\n        for (j = e - i - 1; j > 0; j--) {\n            if (!BN_mod_sqr(t, t, p, ctx))\n                goto end;\n        }\n        if (!BN_mod_mul(y, t, t, p, ctx))\n            goto end;\n        if (!BN_mod_mul(x, x, t, p, ctx))\n            goto end;\n        if (!BN_mod_mul(b, b, y, p, ctx))\n            goto end;\n        e = i;\n    }\n\n vrfy:\n    if (!err) {\n        /*\n         * verify the result -- the input might have been not a square (test\n         * added in 0.9.8)\n         */\n\n        if (!BN_mod_sqr(x, ret, p, ctx))\n            err = 1;\n\n        if (!err && 0 != BN_cmp(x, A)) {\n            BNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);\n            err = 1;\n        }\n    }\n\n end:\n    if (err) {\n        if (ret != in)\n            BN_clear_free(ret);\n        ret = NULL;\n    }\n    BN_CTX_end(ctx);\n    bn_check_top(ret);\n    return ret;\n}",
        "func": "BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)\n/*\n * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks\n * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number\n * Theory\", algorithm 1.5.1). 'p' must be prime, otherwise an error or\n * an incorrect \"result\" will be returned.\n */\n{\n    BIGNUM *ret = in;\n    int err = 1;\n    int r;\n    BIGNUM *A, *b, *q, *t, *x, *y;\n    int e, i, j;\n\n    if (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\n        if (BN_abs_is_word(p, 2)) {\n            if (ret == NULL)\n                ret = BN_new();\n            if (ret == NULL)\n                goto end;\n            if (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\n                if (ret != in)\n                    BN_free(ret);\n                return NULL;\n            }\n            bn_check_top(ret);\n            return ret;\n        }\n\n        BNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);\n        return NULL;\n    }\n\n    if (BN_is_zero(a) || BN_is_one(a)) {\n        if (ret == NULL)\n            ret = BN_new();\n        if (ret == NULL)\n            goto end;\n        if (!BN_set_word(ret, BN_is_one(a))) {\n            if (ret != in)\n                BN_free(ret);\n            return NULL;\n        }\n        bn_check_top(ret);\n        return ret;\n    }\n\n    BN_CTX_start(ctx);\n    A = BN_CTX_get(ctx);\n    b = BN_CTX_get(ctx);\n    q = BN_CTX_get(ctx);\n    t = BN_CTX_get(ctx);\n    x = BN_CTX_get(ctx);\n    y = BN_CTX_get(ctx);\n    if (y == NULL)\n        goto end;\n\n    if (ret == NULL)\n        ret = BN_new();\n    if (ret == NULL)\n        goto end;\n\n    /* A = a mod p */\n    if (!BN_nnmod(A, a, p, ctx))\n        goto end;\n\n    /* now write  |p| - 1  as  2^e*q  where  q  is odd */\n    e = 1;\n    while (!BN_is_bit_set(p, e))\n        e++;\n    /* we'll set  q  later (if needed) */\n\n    if (e == 1) {\n        /*-\n         * The easy case:  (|p|-1)/2  is odd, so 2 has an inverse\n         * modulo  (|p|-1)/2,  and square roots can be computed\n         * directly by modular exponentiation.\n         * We have\n         *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),\n         * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.\n         */\n        if (!BN_rshift(q, p, 2))\n            goto end;\n        q->neg = 0;\n        if (!BN_add_word(q, 1))\n            goto end;\n        if (!BN_mod_exp(ret, A, q, p, ctx))\n            goto end;\n        err = 0;\n        goto vrfy;\n    }\n\n    if (e == 2) {\n        /*-\n         * |p| == 5  (mod 8)\n         *\n         * In this case  2  is always a non-square since\n         * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.\n         * So if  a  really is a square, then  2*a  is a non-square.\n         * Thus for\n         *      b := (2*a)^((|p|-5)/8),\n         *      i := (2*a)*b^2\n         * we have\n         *     i^2 = (2*a)^((1 + (|p|-5)/4)*2)\n         *         = (2*a)^((p-1)/2)\n         *         = -1;\n         * so if we set\n         *      x := a*b*(i-1),\n         * then\n         *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)\n         *         = a^2 * b^2 * (-2*i)\n         *         = a*(-i)*(2*a*b^2)\n         *         = a*(-i)*i\n         *         = a.\n         *\n         * (This is due to A.O.L. Atkin,\n         * Subject: Square Roots and Cognate Matters modulo p=8n+5.\n         * URL: https://listserv.nodak.edu/cgi-bin/wa.exe?A2=ind9211&L=NMBRTHRY&P=4026\n         * November 1992.)\n         */\n\n        /* t := 2*a */\n        if (!BN_mod_lshift1_quick(t, A, p))\n            goto end;\n\n        /* b := (2*a)^((|p|-5)/8) */\n        if (!BN_rshift(q, p, 3))\n            goto end;\n        q->neg = 0;\n        if (!BN_mod_exp(b, t, q, p, ctx))\n            goto end;\n\n        /* y := b^2 */\n        if (!BN_mod_sqr(y, b, p, ctx))\n            goto end;\n\n        /* t := (2*a)*b^2 - 1 */\n        if (!BN_mod_mul(t, t, y, p, ctx))\n            goto end;\n        if (!BN_sub_word(t, 1))\n            goto end;\n\n        /* x = a*b*t */\n        if (!BN_mod_mul(x, A, b, p, ctx))\n            goto end;\n        if (!BN_mod_mul(x, x, t, p, ctx))\n            goto end;\n\n        if (!BN_copy(ret, x))\n            goto end;\n        err = 0;\n        goto vrfy;\n    }\n\n    /*\n     * e > 2, so we really have to use the Tonelli/Shanks algorithm. First,\n     * find some y that is not a square.\n     */\n    if (!BN_copy(q, p))\n        goto end;               /* use 'q' as temp */\n    q->neg = 0;\n    i = 2;\n    do {\n        /*\n         * For efficiency, try small numbers first; if this fails, try random\n         * numbers.\n         */\n        if (i < 22) {\n            if (!BN_set_word(y, i))\n                goto end;\n        } else {\n            if (!BN_priv_rand(y, BN_num_bits(p), 0, 0))\n                goto end;\n            if (BN_ucmp(y, p) >= 0) {\n                if (!(p->neg ? BN_add : BN_sub) (y, y, p))\n                    goto end;\n            }\n            /* now 0 <= y < |p| */\n            if (BN_is_zero(y))\n                if (!BN_set_word(y, i))\n                    goto end;\n        }\n\n        r = BN_kronecker(y, q, ctx); /* here 'q' is |p| */\n        if (r < -1)\n            goto end;\n        if (r == 0) {\n            /* m divides p */\n            BNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);\n            goto end;\n        }\n    }\n    while (r == 1 && ++i < 82);\n\n    if (r != -1) {\n        /*\n         * Many rounds and still no non-square -- this is more likely a bug\n         * than just bad luck. Even if p is not prime, we should have found\n         * some y such that r == -1.\n         */\n        BNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS);\n        goto end;\n    }\n\n    /* Here's our actual 'q': */\n    if (!BN_rshift(q, q, e))\n        goto end;\n\n    /*\n     * Now that we have some non-square, we can find an element of order 2^e\n     * by computing its q'th power.\n     */\n    if (!BN_mod_exp(y, y, q, p, ctx))\n        goto end;\n    if (BN_is_one(y)) {\n        BNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);\n        goto end;\n    }\n\n    /*-\n     * Now we know that (if  p  is indeed prime) there is an integer\n     * k,  0 <= k < 2^e,  such that\n     *\n     *      a^q * y^k == 1   (mod p).\n     *\n     * As  a^q  is a square and  y  is not,  k  must be even.\n     * q+1  is even, too, so there is an element\n     *\n     *     X := a^((q+1)/2) * y^(k/2),\n     *\n     * and it satisfies\n     *\n     *     X^2 = a^q * a     * y^k\n     *         = a,\n     *\n     * so it is the square root that we are looking for.\n     */\n\n    /* t := (q-1)/2  (note that  q  is odd) */\n    if (!BN_rshift1(t, q))\n        goto end;\n\n    /* x := a^((q-1)/2) */\n    if (BN_is_zero(t)) {        /* special case: p = 2^e + 1 */\n        if (!BN_nnmod(t, A, p, ctx))\n            goto end;\n        if (BN_is_zero(t)) {\n            /* special case: a == 0  (mod p) */\n            BN_zero(ret);\n            err = 0;\n            goto end;\n        } else if (!BN_one(x))\n            goto end;\n    } else {\n        if (!BN_mod_exp(x, A, t, p, ctx))\n            goto end;\n        if (BN_is_zero(x)) {\n            /* special case: a == 0  (mod p) */\n            BN_zero(ret);\n            err = 0;\n            goto end;\n        }\n    }\n\n    /* b := a*x^2  (= a^q) */\n    if (!BN_mod_sqr(b, x, p, ctx))\n        goto end;\n    if (!BN_mod_mul(b, b, A, p, ctx))\n        goto end;\n\n    /* x := a*x    (= a^((q+1)/2)) */\n    if (!BN_mod_mul(x, x, A, p, ctx))\n        goto end;\n\n    while (1) {\n        /*-\n         * Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E\n         * where  E  refers to the original value of  e,  which we\n         * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2).\n         *\n         * We have  a*b = x^2,\n         *    y^2^(e-1) = -1,\n         *    b^2^(e-1) = 1.\n         */\n\n        if (BN_is_one(b)) {\n            if (!BN_copy(ret, x))\n                goto end;\n            err = 0;\n            goto vrfy;\n        }\n\n        /* Find the smallest i, 0 < i < e, such that b^(2^i) = 1. */\n        for (i = 1; i < e; i++) {\n            if (i == 1) {\n                if (!BN_mod_sqr(t, b, p, ctx))\n                    goto end;\n\n            } else {\n                if (!BN_mod_mul(t, t, t, p, ctx))\n                    goto end;\n            }\n            if (BN_is_one(t))\n                break;\n        }\n        /* If not found, a is not a square or p is not prime. */\n        if (i >= e) {\n            BNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);\n            goto end;\n        }\n\n        /* t := y^2^(e - i - 1) */\n        if (!BN_copy(t, y))\n            goto end;\n        for (j = e - i - 1; j > 0; j--) {\n            if (!BN_mod_sqr(t, t, p, ctx))\n                goto end;\n        }\n        if (!BN_mod_mul(y, t, t, p, ctx))\n            goto end;\n        if (!BN_mod_mul(x, x, t, p, ctx))\n            goto end;\n        if (!BN_mod_mul(b, b, y, p, ctx))\n            goto end;\n        e = i;\n    }\n\n vrfy:\n    if (!err) {\n        /*\n         * verify the result -- the input might have been not a square (test\n         * added in 0.9.8)\n         */\n\n        if (!BN_mod_sqr(x, ret, p, ctx))\n            err = 1;\n\n        if (!err && 0 != BN_cmp(x, A)) {\n            BNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);\n            err = 1;\n        }\n    }\n\n end:\n    if (err) {\n        if (ret != in)\n            BN_clear_free(ret);\n        ret = NULL;\n    }\n    BN_CTX_end(ctx);\n    bn_check_top(ret);\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,8 @@\n /*\n  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks\n  * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number\n- * Theory\", algorithm 1.5.1). 'p' must be prime!\n+ * Theory\", algorithm 1.5.1). 'p' must be prime, otherwise an error or\n+ * an incorrect \"result\" will be returned.\n  */\n {\n     BIGNUM *ret = in;\n@@ -289,18 +290,23 @@\n             goto vrfy;\n         }\n \n-        /* find smallest  i  such that  b^(2^i) = 1 */\n-        i = 1;\n-        if (!BN_mod_sqr(t, b, p, ctx))\n-            goto end;\n-        while (!BN_is_one(t)) {\n-            i++;\n-            if (i == e) {\n-                BNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);\n-                goto end;\n+        /* Find the smallest i, 0 < i < e, such that b^(2^i) = 1. */\n+        for (i = 1; i < e; i++) {\n+            if (i == 1) {\n+                if (!BN_mod_sqr(t, b, p, ctx))\n+                    goto end;\n+\n+            } else {\n+                if (!BN_mod_mul(t, t, t, p, ctx))\n+                    goto end;\n             }\n-            if (!BN_mod_mul(t, t, t, p, ctx))\n-                goto end;\n+            if (BN_is_one(t))\n+                break;\n+        }\n+        /* If not found, a is not a square or p is not prime. */\n+        if (i >= e) {\n+            BNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);\n+            goto end;\n         }\n \n         /* t := y^2^(e - i - 1) */",
        "diff_line_info": {
            "deleted_lines": [
                " * Theory\", algorithm 1.5.1). 'p' must be prime!",
                "        /* find smallest  i  such that  b^(2^i) = 1 */",
                "        i = 1;",
                "        if (!BN_mod_sqr(t, b, p, ctx))",
                "            goto end;",
                "        while (!BN_is_one(t)) {",
                "            i++;",
                "            if (i == e) {",
                "                BNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);",
                "                goto end;",
                "            if (!BN_mod_mul(t, t, t, p, ctx))",
                "                goto end;"
            ],
            "added_lines": [
                " * Theory\", algorithm 1.5.1). 'p' must be prime, otherwise an error or",
                " * an incorrect \"result\" will be returned.",
                "        /* Find the smallest i, 0 < i < e, such that b^(2^i) = 1. */",
                "        for (i = 1; i < e; i++) {",
                "            if (i == 1) {",
                "                if (!BN_mod_sqr(t, b, p, ctx))",
                "                    goto end;",
                "",
                "            } else {",
                "                if (!BN_mod_mul(t, t, t, p, ctx))",
                "                    goto end;",
                "            if (BN_is_one(t))",
                "                break;",
                "        }",
                "        /* If not found, a is not a square or p is not prime. */",
                "        if (i >= e) {",
                "            BNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);",
                "            goto end;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0778",
        "func_name": "openssl/BN_mod_sqrt",
        "description": "The BN_mod_sqrt() function, which computes a modular square root, contains a bug that can cause it to loop forever for non-prime moduli. Internally this function is used when parsing certificates that contain elliptic curve public keys in compressed form or explicit elliptic curve parameters with a base point encoded in compressed form. It is possible to trigger the infinite loop by crafting a certificate that has invalid explicit curve parameters. Since certificate parsing happens prior to verification of the certificate signature, any process that parses an externally supplied certificate may thus be subject to a denial of service attack. The infinite loop can also be reached when parsing crafted private keys as they can contain explicit elliptic curve parameters. Thus vulnerable situations include: - TLS clients consuming server certificates - TLS servers consuming client certificates - Hosting providers taking certificates or private keys from customers - Certificate authorities parsing certification requests from subscribers - Anything else which parses ASN.1 elliptic curve parameters Also any other applications that use the BN_mod_sqrt() where the attacker can control the parameter values are vulnerable to this DoS issue. In the OpenSSL 1.0.2 version the public key is not parsed during initial parsing of the certificate which makes it slightly harder to trigger the infinite loop. However any operation which requires the public key from the certificate will trigger the infinite loop. In particular the attacker can use a self-signed certificate to trigger the loop during verification of the certificate signature. This issue affects OpenSSL versions 1.0.2, 1.1.1 and 3.0. It was addressed in the releases of 1.1.1n and 3.0.2 on the 15th March 2022. Fixed in OpenSSL 3.0.2 (Affected 3.0.0,3.0.1). Fixed in OpenSSL 1.1.1n (Affected 1.1.1-1.1.1m). Fixed in OpenSSL 1.0.2zd (Affected 1.0.2-1.0.2zc).",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=a466912611aa6cbdf550cd10601390e587451246",
        "commit_title": "",
        "commit_text": "Fix possible infinite loop in BN_mod_sqrt()  The calculation in some cases does not finish for non-prime p.  This fixes CVE-2022-0778.  Based on patch by David Benjamin <davidben@google.com>.  (cherry picked from commit 9eafb53614bf65797db25f467946e735e1b43dc9) ",
        "func_before": "BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)\n/*\n * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks\n * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number\n * Theory\", algorithm 1.5.1). 'p' must be prime!\n */\n{\n    BIGNUM *ret = in;\n    int err = 1;\n    int r;\n    BIGNUM *A, *b, *q, *t, *x, *y;\n    int e, i, j;\n    int used_ctx = 0;\n\n    if (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\n        if (BN_abs_is_word(p, 2)) {\n            if (ret == NULL)\n                ret = BN_new();\n            if (ret == NULL)\n                goto end;\n            if (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\n                if (ret != in)\n                    BN_free(ret);\n                return NULL;\n            }\n            bn_check_top(ret);\n            return ret;\n        }\n\n        ERR_raise(ERR_LIB_BN, BN_R_P_IS_NOT_PRIME);\n        return NULL;\n    }\n\n    if (BN_is_zero(a) || BN_is_one(a)) {\n        if (ret == NULL)\n            ret = BN_new();\n        if (ret == NULL)\n            goto end;\n        if (!BN_set_word(ret, BN_is_one(a))) {\n            if (ret != in)\n                BN_free(ret);\n            return NULL;\n        }\n        bn_check_top(ret);\n        return ret;\n    }\n\n    BN_CTX_start(ctx);\n    used_ctx = 1;\n    A = BN_CTX_get(ctx);\n    b = BN_CTX_get(ctx);\n    q = BN_CTX_get(ctx);\n    t = BN_CTX_get(ctx);\n    x = BN_CTX_get(ctx);\n    y = BN_CTX_get(ctx);\n    if (y == NULL)\n        goto end;\n\n    if (ret == NULL)\n        ret = BN_new();\n    if (ret == NULL)\n        goto end;\n\n    /* A = a mod p */\n    if (!BN_nnmod(A, a, p, ctx))\n        goto end;\n\n    /* now write  |p| - 1  as  2^e*q  where  q  is odd */\n    e = 1;\n    while (!BN_is_bit_set(p, e))\n        e++;\n    /* we'll set  q  later (if needed) */\n\n    if (e == 1) {\n        /*-\n         * The easy case:  (|p|-1)/2  is odd, so 2 has an inverse\n         * modulo  (|p|-1)/2,  and square roots can be computed\n         * directly by modular exponentiation.\n         * We have\n         *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),\n         * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.\n         */\n        if (!BN_rshift(q, p, 2))\n            goto end;\n        q->neg = 0;\n        if (!BN_add_word(q, 1))\n            goto end;\n        if (!BN_mod_exp(ret, A, q, p, ctx))\n            goto end;\n        err = 0;\n        goto vrfy;\n    }\n\n    if (e == 2) {\n        /*-\n         * |p| == 5  (mod 8)\n         *\n         * In this case  2  is always a non-square since\n         * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.\n         * So if  a  really is a square, then  2*a  is a non-square.\n         * Thus for\n         *      b := (2*a)^((|p|-5)/8),\n         *      i := (2*a)*b^2\n         * we have\n         *     i^2 = (2*a)^((1 + (|p|-5)/4)*2)\n         *         = (2*a)^((p-1)/2)\n         *         = -1;\n         * so if we set\n         *      x := a*b*(i-1),\n         * then\n         *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)\n         *         = a^2 * b^2 * (-2*i)\n         *         = a*(-i)*(2*a*b^2)\n         *         = a*(-i)*i\n         *         = a.\n         *\n         * (This is due to A.O.L. Atkin,\n         * Subject: Square Roots and Cognate Matters modulo p=8n+5.\n         * URL: https://listserv.nodak.edu/cgi-bin/wa.exe?A2=ind9211&L=NMBRTHRY&P=4026\n         * November 1992.)\n         */\n\n        /* t := 2*a */\n        if (!BN_mod_lshift1_quick(t, A, p))\n            goto end;\n\n        /* b := (2*a)^((|p|-5)/8) */\n        if (!BN_rshift(q, p, 3))\n            goto end;\n        q->neg = 0;\n        if (!BN_mod_exp(b, t, q, p, ctx))\n            goto end;\n\n        /* y := b^2 */\n        if (!BN_mod_sqr(y, b, p, ctx))\n            goto end;\n\n        /* t := (2*a)*b^2 - 1 */\n        if (!BN_mod_mul(t, t, y, p, ctx))\n            goto end;\n        if (!BN_sub_word(t, 1))\n            goto end;\n\n        /* x = a*b*t */\n        if (!BN_mod_mul(x, A, b, p, ctx))\n            goto end;\n        if (!BN_mod_mul(x, x, t, p, ctx))\n            goto end;\n\n        if (!BN_copy(ret, x))\n            goto end;\n        err = 0;\n        goto vrfy;\n    }\n\n    /*\n     * e > 2, so we really have to use the Tonelli/Shanks algorithm. First,\n     * find some y that is not a square.\n     */\n    if (!BN_copy(q, p))\n        goto end;               /* use 'q' as temp */\n    q->neg = 0;\n    i = 2;\n    do {\n        /*\n         * For efficiency, try small numbers first; if this fails, try random\n         * numbers.\n         */\n        if (i < 22) {\n            if (!BN_set_word(y, i))\n                goto end;\n        } else {\n            if (!BN_priv_rand_ex(y, BN_num_bits(p), 0, 0, 0, ctx))\n                goto end;\n            if (BN_ucmp(y, p) >= 0) {\n                if (!(p->neg ? BN_add : BN_sub) (y, y, p))\n                    goto end;\n            }\n            /* now 0 <= y < |p| */\n            if (BN_is_zero(y))\n                if (!BN_set_word(y, i))\n                    goto end;\n        }\n\n        r = BN_kronecker(y, q, ctx); /* here 'q' is |p| */\n        if (r < -1)\n            goto end;\n        if (r == 0) {\n            /* m divides p */\n            ERR_raise(ERR_LIB_BN, BN_R_P_IS_NOT_PRIME);\n            goto end;\n        }\n    }\n    while (r == 1 && ++i < 82);\n\n    if (r != -1) {\n        /*\n         * Many rounds and still no non-square -- this is more likely a bug\n         * than just bad luck. Even if p is not prime, we should have found\n         * some y such that r == -1.\n         */\n        ERR_raise(ERR_LIB_BN, BN_R_TOO_MANY_ITERATIONS);\n        goto end;\n    }\n\n    /* Here's our actual 'q': */\n    if (!BN_rshift(q, q, e))\n        goto end;\n\n    /*\n     * Now that we have some non-square, we can find an element of order 2^e\n     * by computing its q'th power.\n     */\n    if (!BN_mod_exp(y, y, q, p, ctx))\n        goto end;\n    if (BN_is_one(y)) {\n        ERR_raise(ERR_LIB_BN, BN_R_P_IS_NOT_PRIME);\n        goto end;\n    }\n\n    /*-\n     * Now we know that (if  p  is indeed prime) there is an integer\n     * k,  0 <= k < 2^e,  such that\n     *\n     *      a^q * y^k == 1   (mod p).\n     *\n     * As  a^q  is a square and  y  is not,  k  must be even.\n     * q+1  is even, too, so there is an element\n     *\n     *     X := a^((q+1)/2) * y^(k/2),\n     *\n     * and it satisfies\n     *\n     *     X^2 = a^q * a     * y^k\n     *         = a,\n     *\n     * so it is the square root that we are looking for.\n     */\n\n    /* t := (q-1)/2  (note that  q  is odd) */\n    if (!BN_rshift1(t, q))\n        goto end;\n\n    /* x := a^((q-1)/2) */\n    if (BN_is_zero(t)) {        /* special case: p = 2^e + 1 */\n        if (!BN_nnmod(t, A, p, ctx))\n            goto end;\n        if (BN_is_zero(t)) {\n            /* special case: a == 0  (mod p) */\n            BN_zero(ret);\n            err = 0;\n            goto end;\n        } else if (!BN_one(x))\n            goto end;\n    } else {\n        if (!BN_mod_exp(x, A, t, p, ctx))\n            goto end;\n        if (BN_is_zero(x)) {\n            /* special case: a == 0  (mod p) */\n            BN_zero(ret);\n            err = 0;\n            goto end;\n        }\n    }\n\n    /* b := a*x^2  (= a^q) */\n    if (!BN_mod_sqr(b, x, p, ctx))\n        goto end;\n    if (!BN_mod_mul(b, b, A, p, ctx))\n        goto end;\n\n    /* x := a*x    (= a^((q+1)/2)) */\n    if (!BN_mod_mul(x, x, A, p, ctx))\n        goto end;\n\n    while (1) {\n        /*-\n         * Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E\n         * where  E  refers to the original value of  e,  which we\n         * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2).\n         *\n         * We have  a*b = x^2,\n         *    y^2^(e-1) = -1,\n         *    b^2^(e-1) = 1.\n         */\n\n        if (BN_is_one(b)) {\n            if (!BN_copy(ret, x))\n                goto end;\n            err = 0;\n            goto vrfy;\n        }\n\n        /* find smallest  i  such that  b^(2^i) = 1 */\n        i = 1;\n        if (!BN_mod_sqr(t, b, p, ctx))\n            goto end;\n        while (!BN_is_one(t)) {\n            i++;\n            if (i == e) {\n                ERR_raise(ERR_LIB_BN, BN_R_NOT_A_SQUARE);\n                goto end;\n            }\n            if (!BN_mod_mul(t, t, t, p, ctx))\n                goto end;\n        }\n\n        /* t := y^2^(e - i - 1) */\n        if (!BN_copy(t, y))\n            goto end;\n        for (j = e - i - 1; j > 0; j--) {\n            if (!BN_mod_sqr(t, t, p, ctx))\n                goto end;\n        }\n        if (!BN_mod_mul(y, t, t, p, ctx))\n            goto end;\n        if (!BN_mod_mul(x, x, t, p, ctx))\n            goto end;\n        if (!BN_mod_mul(b, b, y, p, ctx))\n            goto end;\n        e = i;\n    }\n\n vrfy:\n    if (!err) {\n        /*\n         * verify the result -- the input might have been not a square (test\n         * added in 0.9.8)\n         */\n\n        if (!BN_mod_sqr(x, ret, p, ctx))\n            err = 1;\n\n        if (!err && 0 != BN_cmp(x, A)) {\n            ERR_raise(ERR_LIB_BN, BN_R_NOT_A_SQUARE);\n            err = 1;\n        }\n    }\n\n end:\n    if (err) {\n        if (ret != in)\n            BN_clear_free(ret);\n        ret = NULL;\n    }\n    if (used_ctx)\n        BN_CTX_end(ctx);\n    bn_check_top(ret);\n    return ret;\n}",
        "func": "BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)\n/*\n * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks\n * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number\n * Theory\", algorithm 1.5.1). 'p' must be prime, otherwise an error or\n * an incorrect \"result\" will be returned.\n */\n{\n    BIGNUM *ret = in;\n    int err = 1;\n    int r;\n    BIGNUM *A, *b, *q, *t, *x, *y;\n    int e, i, j;\n    int used_ctx = 0;\n\n    if (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\n        if (BN_abs_is_word(p, 2)) {\n            if (ret == NULL)\n                ret = BN_new();\n            if (ret == NULL)\n                goto end;\n            if (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\n                if (ret != in)\n                    BN_free(ret);\n                return NULL;\n            }\n            bn_check_top(ret);\n            return ret;\n        }\n\n        ERR_raise(ERR_LIB_BN, BN_R_P_IS_NOT_PRIME);\n        return NULL;\n    }\n\n    if (BN_is_zero(a) || BN_is_one(a)) {\n        if (ret == NULL)\n            ret = BN_new();\n        if (ret == NULL)\n            goto end;\n        if (!BN_set_word(ret, BN_is_one(a))) {\n            if (ret != in)\n                BN_free(ret);\n            return NULL;\n        }\n        bn_check_top(ret);\n        return ret;\n    }\n\n    BN_CTX_start(ctx);\n    used_ctx = 1;\n    A = BN_CTX_get(ctx);\n    b = BN_CTX_get(ctx);\n    q = BN_CTX_get(ctx);\n    t = BN_CTX_get(ctx);\n    x = BN_CTX_get(ctx);\n    y = BN_CTX_get(ctx);\n    if (y == NULL)\n        goto end;\n\n    if (ret == NULL)\n        ret = BN_new();\n    if (ret == NULL)\n        goto end;\n\n    /* A = a mod p */\n    if (!BN_nnmod(A, a, p, ctx))\n        goto end;\n\n    /* now write  |p| - 1  as  2^e*q  where  q  is odd */\n    e = 1;\n    while (!BN_is_bit_set(p, e))\n        e++;\n    /* we'll set  q  later (if needed) */\n\n    if (e == 1) {\n        /*-\n         * The easy case:  (|p|-1)/2  is odd, so 2 has an inverse\n         * modulo  (|p|-1)/2,  and square roots can be computed\n         * directly by modular exponentiation.\n         * We have\n         *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),\n         * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.\n         */\n        if (!BN_rshift(q, p, 2))\n            goto end;\n        q->neg = 0;\n        if (!BN_add_word(q, 1))\n            goto end;\n        if (!BN_mod_exp(ret, A, q, p, ctx))\n            goto end;\n        err = 0;\n        goto vrfy;\n    }\n\n    if (e == 2) {\n        /*-\n         * |p| == 5  (mod 8)\n         *\n         * In this case  2  is always a non-square since\n         * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.\n         * So if  a  really is a square, then  2*a  is a non-square.\n         * Thus for\n         *      b := (2*a)^((|p|-5)/8),\n         *      i := (2*a)*b^2\n         * we have\n         *     i^2 = (2*a)^((1 + (|p|-5)/4)*2)\n         *         = (2*a)^((p-1)/2)\n         *         = -1;\n         * so if we set\n         *      x := a*b*(i-1),\n         * then\n         *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)\n         *         = a^2 * b^2 * (-2*i)\n         *         = a*(-i)*(2*a*b^2)\n         *         = a*(-i)*i\n         *         = a.\n         *\n         * (This is due to A.O.L. Atkin,\n         * Subject: Square Roots and Cognate Matters modulo p=8n+5.\n         * URL: https://listserv.nodak.edu/cgi-bin/wa.exe?A2=ind9211&L=NMBRTHRY&P=4026\n         * November 1992.)\n         */\n\n        /* t := 2*a */\n        if (!BN_mod_lshift1_quick(t, A, p))\n            goto end;\n\n        /* b := (2*a)^((|p|-5)/8) */\n        if (!BN_rshift(q, p, 3))\n            goto end;\n        q->neg = 0;\n        if (!BN_mod_exp(b, t, q, p, ctx))\n            goto end;\n\n        /* y := b^2 */\n        if (!BN_mod_sqr(y, b, p, ctx))\n            goto end;\n\n        /* t := (2*a)*b^2 - 1 */\n        if (!BN_mod_mul(t, t, y, p, ctx))\n            goto end;\n        if (!BN_sub_word(t, 1))\n            goto end;\n\n        /* x = a*b*t */\n        if (!BN_mod_mul(x, A, b, p, ctx))\n            goto end;\n        if (!BN_mod_mul(x, x, t, p, ctx))\n            goto end;\n\n        if (!BN_copy(ret, x))\n            goto end;\n        err = 0;\n        goto vrfy;\n    }\n\n    /*\n     * e > 2, so we really have to use the Tonelli/Shanks algorithm. First,\n     * find some y that is not a square.\n     */\n    if (!BN_copy(q, p))\n        goto end;               /* use 'q' as temp */\n    q->neg = 0;\n    i = 2;\n    do {\n        /*\n         * For efficiency, try small numbers first; if this fails, try random\n         * numbers.\n         */\n        if (i < 22) {\n            if (!BN_set_word(y, i))\n                goto end;\n        } else {\n            if (!BN_priv_rand_ex(y, BN_num_bits(p), 0, 0, 0, ctx))\n                goto end;\n            if (BN_ucmp(y, p) >= 0) {\n                if (!(p->neg ? BN_add : BN_sub) (y, y, p))\n                    goto end;\n            }\n            /* now 0 <= y < |p| */\n            if (BN_is_zero(y))\n                if (!BN_set_word(y, i))\n                    goto end;\n        }\n\n        r = BN_kronecker(y, q, ctx); /* here 'q' is |p| */\n        if (r < -1)\n            goto end;\n        if (r == 0) {\n            /* m divides p */\n            ERR_raise(ERR_LIB_BN, BN_R_P_IS_NOT_PRIME);\n            goto end;\n        }\n    }\n    while (r == 1 && ++i < 82);\n\n    if (r != -1) {\n        /*\n         * Many rounds and still no non-square -- this is more likely a bug\n         * than just bad luck. Even if p is not prime, we should have found\n         * some y such that r == -1.\n         */\n        ERR_raise(ERR_LIB_BN, BN_R_TOO_MANY_ITERATIONS);\n        goto end;\n    }\n\n    /* Here's our actual 'q': */\n    if (!BN_rshift(q, q, e))\n        goto end;\n\n    /*\n     * Now that we have some non-square, we can find an element of order 2^e\n     * by computing its q'th power.\n     */\n    if (!BN_mod_exp(y, y, q, p, ctx))\n        goto end;\n    if (BN_is_one(y)) {\n        ERR_raise(ERR_LIB_BN, BN_R_P_IS_NOT_PRIME);\n        goto end;\n    }\n\n    /*-\n     * Now we know that (if  p  is indeed prime) there is an integer\n     * k,  0 <= k < 2^e,  such that\n     *\n     *      a^q * y^k == 1   (mod p).\n     *\n     * As  a^q  is a square and  y  is not,  k  must be even.\n     * q+1  is even, too, so there is an element\n     *\n     *     X := a^((q+1)/2) * y^(k/2),\n     *\n     * and it satisfies\n     *\n     *     X^2 = a^q * a     * y^k\n     *         = a,\n     *\n     * so it is the square root that we are looking for.\n     */\n\n    /* t := (q-1)/2  (note that  q  is odd) */\n    if (!BN_rshift1(t, q))\n        goto end;\n\n    /* x := a^((q-1)/2) */\n    if (BN_is_zero(t)) {        /* special case: p = 2^e + 1 */\n        if (!BN_nnmod(t, A, p, ctx))\n            goto end;\n        if (BN_is_zero(t)) {\n            /* special case: a == 0  (mod p) */\n            BN_zero(ret);\n            err = 0;\n            goto end;\n        } else if (!BN_one(x))\n            goto end;\n    } else {\n        if (!BN_mod_exp(x, A, t, p, ctx))\n            goto end;\n        if (BN_is_zero(x)) {\n            /* special case: a == 0  (mod p) */\n            BN_zero(ret);\n            err = 0;\n            goto end;\n        }\n    }\n\n    /* b := a*x^2  (= a^q) */\n    if (!BN_mod_sqr(b, x, p, ctx))\n        goto end;\n    if (!BN_mod_mul(b, b, A, p, ctx))\n        goto end;\n\n    /* x := a*x    (= a^((q+1)/2)) */\n    if (!BN_mod_mul(x, x, A, p, ctx))\n        goto end;\n\n    while (1) {\n        /*-\n         * Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E\n         * where  E  refers to the original value of  e,  which we\n         * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2).\n         *\n         * We have  a*b = x^2,\n         *    y^2^(e-1) = -1,\n         *    b^2^(e-1) = 1.\n         */\n\n        if (BN_is_one(b)) {\n            if (!BN_copy(ret, x))\n                goto end;\n            err = 0;\n            goto vrfy;\n        }\n\n        /* Find the smallest i, 0 < i < e, such that b^(2^i) = 1. */\n        for (i = 1; i < e; i++) {\n            if (i == 1) {\n                if (!BN_mod_sqr(t, b, p, ctx))\n                    goto end;\n\n            } else {\n                if (!BN_mod_mul(t, t, t, p, ctx))\n                    goto end;\n            }\n            if (BN_is_one(t))\n                break;\n        }\n        /* If not found, a is not a square or p is not prime. */\n        if (i >= e) {\n            ERR_raise(ERR_LIB_BN, BN_R_NOT_A_SQUARE);\n            goto end;\n        }\n\n        /* t := y^2^(e - i - 1) */\n        if (!BN_copy(t, y))\n            goto end;\n        for (j = e - i - 1; j > 0; j--) {\n            if (!BN_mod_sqr(t, t, p, ctx))\n                goto end;\n        }\n        if (!BN_mod_mul(y, t, t, p, ctx))\n            goto end;\n        if (!BN_mod_mul(x, x, t, p, ctx))\n            goto end;\n        if (!BN_mod_mul(b, b, y, p, ctx))\n            goto end;\n        e = i;\n    }\n\n vrfy:\n    if (!err) {\n        /*\n         * verify the result -- the input might have been not a square (test\n         * added in 0.9.8)\n         */\n\n        if (!BN_mod_sqr(x, ret, p, ctx))\n            err = 1;\n\n        if (!err && 0 != BN_cmp(x, A)) {\n            ERR_raise(ERR_LIB_BN, BN_R_NOT_A_SQUARE);\n            err = 1;\n        }\n    }\n\n end:\n    if (err) {\n        if (ret != in)\n            BN_clear_free(ret);\n        ret = NULL;\n    }\n    if (used_ctx)\n        BN_CTX_end(ctx);\n    bn_check_top(ret);\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,8 @@\n /*\n  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks\n  * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number\n- * Theory\", algorithm 1.5.1). 'p' must be prime!\n+ * Theory\", algorithm 1.5.1). 'p' must be prime, otherwise an error or\n+ * an incorrect \"result\" will be returned.\n  */\n {\n     BIGNUM *ret = in;\n@@ -291,18 +292,23 @@\n             goto vrfy;\n         }\n \n-        /* find smallest  i  such that  b^(2^i) = 1 */\n-        i = 1;\n-        if (!BN_mod_sqr(t, b, p, ctx))\n-            goto end;\n-        while (!BN_is_one(t)) {\n-            i++;\n-            if (i == e) {\n-                ERR_raise(ERR_LIB_BN, BN_R_NOT_A_SQUARE);\n-                goto end;\n+        /* Find the smallest i, 0 < i < e, such that b^(2^i) = 1. */\n+        for (i = 1; i < e; i++) {\n+            if (i == 1) {\n+                if (!BN_mod_sqr(t, b, p, ctx))\n+                    goto end;\n+\n+            } else {\n+                if (!BN_mod_mul(t, t, t, p, ctx))\n+                    goto end;\n             }\n-            if (!BN_mod_mul(t, t, t, p, ctx))\n-                goto end;\n+            if (BN_is_one(t))\n+                break;\n+        }\n+        /* If not found, a is not a square or p is not prime. */\n+        if (i >= e) {\n+            ERR_raise(ERR_LIB_BN, BN_R_NOT_A_SQUARE);\n+            goto end;\n         }\n \n         /* t := y^2^(e - i - 1) */",
        "diff_line_info": {
            "deleted_lines": [
                " * Theory\", algorithm 1.5.1). 'p' must be prime!",
                "        /* find smallest  i  such that  b^(2^i) = 1 */",
                "        i = 1;",
                "        if (!BN_mod_sqr(t, b, p, ctx))",
                "            goto end;",
                "        while (!BN_is_one(t)) {",
                "            i++;",
                "            if (i == e) {",
                "                ERR_raise(ERR_LIB_BN, BN_R_NOT_A_SQUARE);",
                "                goto end;",
                "            if (!BN_mod_mul(t, t, t, p, ctx))",
                "                goto end;"
            ],
            "added_lines": [
                " * Theory\", algorithm 1.5.1). 'p' must be prime, otherwise an error or",
                " * an incorrect \"result\" will be returned.",
                "        /* Find the smallest i, 0 < i < e, such that b^(2^i) = 1. */",
                "        for (i = 1; i < e; i++) {",
                "            if (i == 1) {",
                "                if (!BN_mod_sqr(t, b, p, ctx))",
                "                    goto end;",
                "",
                "            } else {",
                "                if (!BN_mod_mul(t, t, t, p, ctx))",
                "                    goto end;",
                "            if (BN_is_one(t))",
                "                break;",
                "        }",
                "        /* If not found, a is not a square or p is not prime. */",
                "        if (i >= e) {",
                "            ERR_raise(ERR_LIB_BN, BN_R_NOT_A_SQUARE);",
                "            goto end;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-20257",
        "func_name": "qemu/process_tx_desc",
        "description": "An infinite loop flaw was found in the e1000 NIC emulator of the QEMU. This issue occurs while processing transmits (tx) descriptors in process_tx_desc if various descriptor fields are initialized with invalid values. This flaw allows a guest to consume CPU cycles on the host, resulting in a denial of service. The highest threat from this vulnerability is to system availability.",
        "git_url": "https://github.com/qemu/qemu/commit/3de46e6fc489c52c9431a8a832ad8170a7569bd8",
        "commit_title": "e1000: fail early for evil descriptor",
        "commit_text": " During procss_tx_desc(), driver can try to chain data descriptor with legacy descriptor, when will lead underflow for the following calculation in process_tx_desc() for bytes:              if (tp->size + bytes > msh)                 bytes = msh - tp->size;  This will lead a infinite loop. So check and fail early if tp->size if greater or equal to msh.  Cc: Prasad J Pandit <ppandit@redhat.com> Cc: qemu-stable@nongnu.org",
        "func_before": "static void\nprocess_tx_desc(E1000State *s, struct e1000_tx_desc *dp)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n    uint32_t txd_lower = le32_to_cpu(dp->lower.data);\n    uint32_t dtype = txd_lower & (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D);\n    unsigned int split_size = txd_lower & 0xffff, bytes, sz;\n    unsigned int msh = 0xfffff;\n    uint64_t addr;\n    struct e1000_context_desc *xp = (struct e1000_context_desc *)dp;\n    struct e1000_tx *tp = &s->tx;\n\n    s->mit_ide |= (txd_lower & E1000_TXD_CMD_IDE);\n    if (dtype == E1000_TXD_CMD_DEXT) {    /* context descriptor */\n        if (le32_to_cpu(xp->cmd_and_length) & E1000_TXD_CMD_TSE) {\n            e1000x_read_tx_ctx_descr(xp, &tp->tso_props);\n            s->use_tso_for_migration = 1;\n            tp->tso_frames = 0;\n        } else {\n            e1000x_read_tx_ctx_descr(xp, &tp->props);\n            s->use_tso_for_migration = 0;\n        }\n        return;\n    } else if (dtype == (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D)) {\n        // data descriptor\n        if (tp->size == 0) {\n            tp->sum_needed = le32_to_cpu(dp->upper.data) >> 8;\n        }\n        tp->cptse = (txd_lower & E1000_TXD_CMD_TSE) ? 1 : 0;\n    } else {\n        // legacy descriptor\n        tp->cptse = 0;\n    }\n\n    if (e1000x_vlan_enabled(s->mac_reg) &&\n        e1000x_is_vlan_txd(txd_lower) &&\n        (tp->cptse || txd_lower & E1000_TXD_CMD_EOP)) {\n        tp->vlan_needed = 1;\n        stw_be_p(tp->vlan_header,\n                      le16_to_cpu(s->mac_reg[VET]));\n        stw_be_p(tp->vlan_header + 2,\n                      le16_to_cpu(dp->upper.fields.special));\n    }\n\n    addr = le64_to_cpu(dp->buffer_addr);\n    if (tp->cptse) {\n        msh = tp->tso_props.hdr_len + tp->tso_props.mss;\n        do {\n            bytes = split_size;\n            if (tp->size + bytes > msh)\n                bytes = msh - tp->size;\n\n            bytes = MIN(sizeof(tp->data) - tp->size, bytes);\n            pci_dma_read(d, addr, tp->data + tp->size, bytes);\n            sz = tp->size + bytes;\n            if (sz >= tp->tso_props.hdr_len\n                && tp->size < tp->tso_props.hdr_len) {\n                memmove(tp->header, tp->data, tp->tso_props.hdr_len);\n            }\n            tp->size = sz;\n            addr += bytes;\n            if (sz == msh) {\n                xmit_seg(s);\n                memmove(tp->data, tp->header, tp->tso_props.hdr_len);\n                tp->size = tp->tso_props.hdr_len;\n            }\n            split_size -= bytes;\n        } while (bytes && split_size);\n    } else {\n        split_size = MIN(sizeof(tp->data) - tp->size, split_size);\n        pci_dma_read(d, addr, tp->data + tp->size, split_size);\n        tp->size += split_size;\n    }\n\n    if (!(txd_lower & E1000_TXD_CMD_EOP))\n        return;\n    if (!(tp->cptse && tp->size < tp->tso_props.hdr_len)) {\n        xmit_seg(s);\n    }\n    tp->tso_frames = 0;\n    tp->sum_needed = 0;\n    tp->vlan_needed = 0;\n    tp->size = 0;\n    tp->cptse = 0;\n}",
        "func": "static void\nprocess_tx_desc(E1000State *s, struct e1000_tx_desc *dp)\n{\n    PCIDevice *d = PCI_DEVICE(s);\n    uint32_t txd_lower = le32_to_cpu(dp->lower.data);\n    uint32_t dtype = txd_lower & (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D);\n    unsigned int split_size = txd_lower & 0xffff, bytes, sz;\n    unsigned int msh = 0xfffff;\n    uint64_t addr;\n    struct e1000_context_desc *xp = (struct e1000_context_desc *)dp;\n    struct e1000_tx *tp = &s->tx;\n\n    s->mit_ide |= (txd_lower & E1000_TXD_CMD_IDE);\n    if (dtype == E1000_TXD_CMD_DEXT) {    /* context descriptor */\n        if (le32_to_cpu(xp->cmd_and_length) & E1000_TXD_CMD_TSE) {\n            e1000x_read_tx_ctx_descr(xp, &tp->tso_props);\n            s->use_tso_for_migration = 1;\n            tp->tso_frames = 0;\n        } else {\n            e1000x_read_tx_ctx_descr(xp, &tp->props);\n            s->use_tso_for_migration = 0;\n        }\n        return;\n    } else if (dtype == (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D)) {\n        // data descriptor\n        if (tp->size == 0) {\n            tp->sum_needed = le32_to_cpu(dp->upper.data) >> 8;\n        }\n        tp->cptse = (txd_lower & E1000_TXD_CMD_TSE) ? 1 : 0;\n    } else {\n        // legacy descriptor\n        tp->cptse = 0;\n    }\n\n    if (e1000x_vlan_enabled(s->mac_reg) &&\n        e1000x_is_vlan_txd(txd_lower) &&\n        (tp->cptse || txd_lower & E1000_TXD_CMD_EOP)) {\n        tp->vlan_needed = 1;\n        stw_be_p(tp->vlan_header,\n                      le16_to_cpu(s->mac_reg[VET]));\n        stw_be_p(tp->vlan_header + 2,\n                      le16_to_cpu(dp->upper.fields.special));\n    }\n\n    addr = le64_to_cpu(dp->buffer_addr);\n    if (tp->cptse) {\n        msh = tp->tso_props.hdr_len + tp->tso_props.mss;\n        do {\n            bytes = split_size;\n            if (tp->size >= msh) {\n                goto eop;\n            }\n            if (tp->size + bytes > msh)\n                bytes = msh - tp->size;\n\n            bytes = MIN(sizeof(tp->data) - tp->size, bytes);\n            pci_dma_read(d, addr, tp->data + tp->size, bytes);\n            sz = tp->size + bytes;\n            if (sz >= tp->tso_props.hdr_len\n                && tp->size < tp->tso_props.hdr_len) {\n                memmove(tp->header, tp->data, tp->tso_props.hdr_len);\n            }\n            tp->size = sz;\n            addr += bytes;\n            if (sz == msh) {\n                xmit_seg(s);\n                memmove(tp->data, tp->header, tp->tso_props.hdr_len);\n                tp->size = tp->tso_props.hdr_len;\n            }\n            split_size -= bytes;\n        } while (bytes && split_size);\n    } else {\n        split_size = MIN(sizeof(tp->data) - tp->size, split_size);\n        pci_dma_read(d, addr, tp->data + tp->size, split_size);\n        tp->size += split_size;\n    }\n\neop:\n    if (!(txd_lower & E1000_TXD_CMD_EOP))\n        return;\n    if (!(tp->cptse && tp->size < tp->tso_props.hdr_len)) {\n        xmit_seg(s);\n    }\n    tp->tso_frames = 0;\n    tp->sum_needed = 0;\n    tp->vlan_needed = 0;\n    tp->size = 0;\n    tp->cptse = 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -47,6 +47,9 @@\n         msh = tp->tso_props.hdr_len + tp->tso_props.mss;\n         do {\n             bytes = split_size;\n+            if (tp->size >= msh) {\n+                goto eop;\n+            }\n             if (tp->size + bytes > msh)\n                 bytes = msh - tp->size;\n \n@@ -72,6 +75,7 @@\n         tp->size += split_size;\n     }\n \n+eop:\n     if (!(txd_lower & E1000_TXD_CMD_EOP))\n         return;\n     if (!(tp->cptse && tp->size < tp->tso_props.hdr_len)) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            if (tp->size >= msh) {",
                "                goto eop;",
                "            }",
                "eop:"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-24763",
        "func_name": "pjsip/pjproject/xml_parse_node",
        "description": "PJSIP is a free and open source multimedia communication library written in the C language. Versions 2.12 and prior contain a denial-of-service vulnerability that affects PJSIP users that consume PJSIP's XML parsing in their apps. Users are advised to update. There are no known workarounds.",
        "git_url": "https://github.com/pjsip/pjproject/commit/856f87c2e97a27b256482dbe0d748b1194355a21",
        "commit_title": "Merge pull request from GHSA-5x45-qp78-g4p4",
        "commit_text": " * Prevent infinite loop in scanning xml content  * Simplify scanning method  * Optimization",
        "func_before": "static pj_xml_node *xml_parse_node( pj_pool_t *pool, pj_scanner *scanner)\n{\n    pj_xml_node *node;\n    pj_str_t end_name;\n\n    PJ_CHECK_STACK();\n\n    if (*scanner->curptr != '<')\n\ton_syntax_error(scanner);\n\n    /* Handle Processing Instructino (PI) construct (i.e. \"<?\") */\n    if (*scanner->curptr == '<' && *(scanner->curptr+1) == '?') {\n\tpj_scan_advance_n(scanner, 2, PJ_FALSE);\n\tfor (;;) {\n\t    pj_str_t dummy;\n\t    pj_scan_get_until_ch(scanner, '?', &dummy);\n\t    if (*scanner->curptr=='?' && *(scanner->curptr+1)=='>') {\n\t\tpj_scan_advance_n(scanner, 2, PJ_TRUE);\n\t\tbreak;\n\t    } else {\n\t\tpj_scan_advance_n(scanner, 1, PJ_FALSE);\n\t    }\n\t}\n\treturn xml_parse_node(pool, scanner);\n    }\n\n    /* Handle comments construct (i.e. \"<!\") */\n    if (pj_scan_strcmp(scanner, \"<!\", 2) == 0) {\n\tpj_scan_advance_n(scanner, 2, PJ_FALSE);\n\tfor (;;) {\n\t    pj_str_t dummy;\n\t    pj_scan_get_until_ch(scanner, '>', &dummy);\n\t    if (pj_scan_strcmp(scanner, \">\", 1) == 0) {\n\t\tpj_scan_advance_n(scanner, 1, PJ_TRUE);\n\t\tbreak;\n\t    } else {\n\t\tpj_scan_advance_n(scanner, 1, PJ_FALSE);\n\t    }\n\t}\n\treturn xml_parse_node(pool, scanner);\n    }\n\n    /* Alloc node. */\n    node = alloc_node(pool);\n\n    /* Get '<' */\n    pj_scan_get_char(scanner);\n\n    /* Get node name. */\n    pj_scan_get_until_chr( scanner, \" />\\t\\r\\n\", &node->name);\n\n    /* Get attributes. */\n    while (*scanner->curptr != '>' && *scanner->curptr != '/') {\n\tpj_xml_attr *attr = alloc_attr(pool);\n\t\n\tpj_scan_get_until_chr( scanner, \"=> \\t\\r\\n\", &attr->name);\n\tif (*scanner->curptr == '=') {\n\t    pj_scan_get_char( scanner );\n            pj_scan_get_quotes(scanner, \"\\\"'\", \"\\\"'\", 2, &attr->value);\n\t    /* remove quote characters */\n\t    ++attr->value.ptr;\n\t    attr->value.slen -= 2;\n\t}\n\t\n\tpj_list_push_back( &node->attr_head, attr );\n    }\n\n    if (*scanner->curptr == '/') {\n\tpj_scan_get_char(scanner);\n\tif (pj_scan_get_char(scanner) != '>')\n\t    on_syntax_error(scanner);\n\treturn node;\n    }\n\n    /* Enclosing bracket. */\n    if (pj_scan_get_char(scanner) != '>')\n\ton_syntax_error(scanner);\n\n    /* Sub nodes. */\n    while (*scanner->curptr == '<' && *(scanner->curptr+1) != '/'\n\t\t\t\t   && *(scanner->curptr+1) != '!')\n    {\n\tpj_xml_node *sub_node = xml_parse_node(pool, scanner);\n\tpj_list_push_back( &node->node_head, sub_node );\n    }\n\n    /* Content. */\n    if (!pj_scan_is_eof(scanner) && *scanner->curptr != '<') {\n\tpj_scan_get_until_ch(scanner, '<', &node->content);\n    }\n\n    /* CDATA content. */\n    if (*scanner->curptr == '<' && *(scanner->curptr+1) == '!' &&\n\tpj_scan_strcmp(scanner, \"<![CDATA[\", 9) == 0)\n    {\n\tpj_scan_advance_n(scanner, 9, PJ_FALSE);\n\tpj_scan_get_until_ch(scanner, ']', &node->content);\n\twhile (pj_scan_strcmp(scanner, \"]]>\", 3)) {\n\t    pj_str_t dummy;\n\t    pj_scan_get_until_ch(scanner, ']', &dummy);\n\t}\n\tnode->content.slen = scanner->curptr - node->content.ptr;\n\tpj_scan_advance_n(scanner, 3, PJ_TRUE);\n    }\n\n    /* Enclosing node. */\n    if (pj_scan_get_char(scanner) != '<' || pj_scan_get_char(scanner) != '/')\n\ton_syntax_error(scanner);\n\n    pj_scan_get_until_chr(scanner, \" \\t>\", &end_name);\n\n    /* Compare name. */\n    if (pj_stricmp(&node->name, &end_name) != 0)\n\ton_syntax_error(scanner);\n\n    /* Enclosing '>' */\n    if (pj_scan_get_char(scanner) != '>')\n\ton_syntax_error(scanner);\n\n    return node;\n}",
        "func": "static pj_xml_node *xml_parse_node( pj_pool_t *pool, pj_scanner *scanner)\n{\n    pj_xml_node *node;\n    pj_str_t end_name;\n\n    PJ_CHECK_STACK();\n\n    if (*scanner->curptr != '<')\n\ton_syntax_error(scanner);\n\n    /* Handle Processing Instructino (PI) construct (i.e. \"<?\") */\n    if (*scanner->curptr == '<' && *(scanner->curptr+1) == '?') {\n\tpj_scan_advance_n(scanner, 2, PJ_FALSE);\n\tfor (;;) {\n\t    pj_str_t dummy;\n\t    pj_scan_get_until_ch(scanner, '?', &dummy);\n\t    if (*scanner->curptr=='?' && *(scanner->curptr+1)=='>') {\n\t\tpj_scan_advance_n(scanner, 2, PJ_TRUE);\n\t\tbreak;\n\t    } else {\n\t\tpj_scan_advance_n(scanner, 1, PJ_FALSE);\n\t    }\n\t}\n\treturn xml_parse_node(pool, scanner);\n    }\n\n    /* Handle comments construct (i.e. \"<!\") */\n    if (pj_scan_strcmp(scanner, \"<!\", 2) == 0) {\n\tpj_scan_advance_n(scanner, 2, PJ_FALSE);\n\tfor (;;) {\n\t    pj_str_t dummy;\n\t    pj_scan_get_until_ch(scanner, '>', &dummy);\n\t    if (pj_scan_strcmp(scanner, \">\", 1) == 0) {\n\t\tpj_scan_advance_n(scanner, 1, PJ_TRUE);\n\t\tbreak;\n\t    } else {\n\t\tpj_scan_advance_n(scanner, 1, PJ_FALSE);\n\t    }\n\t}\n\treturn xml_parse_node(pool, scanner);\n    }\n\n    /* Alloc node. */\n    node = alloc_node(pool);\n\n    /* Get '<' */\n    pj_scan_get_char(scanner);\n\n    /* Get node name. */\n    pj_scan_get_until_chr( scanner, \" />\\t\\r\\n\", &node->name);\n\n    /* Get attributes. */\n    while (*scanner->curptr != '>' && *scanner->curptr != '/') {\n\tpj_xml_attr *attr = alloc_attr(pool);\n\t\n\tpj_scan_get_until_chr( scanner, \"=> \\t\\r\\n\", &attr->name);\n\tif (*scanner->curptr == '=') {\n\t    pj_scan_get_char( scanner );\n            pj_scan_get_quotes(scanner, \"\\\"'\", \"\\\"'\", 2, &attr->value);\n\t    /* remove quote characters */\n\t    ++attr->value.ptr;\n\t    attr->value.slen -= 2;\n\t}\n\t\n\tpj_list_push_back( &node->attr_head, attr );\n    }\n\n    if (*scanner->curptr == '/') {\n\tpj_scan_get_char(scanner);\n\tif (pj_scan_get_char(scanner) != '>')\n\t    on_syntax_error(scanner);\n\treturn node;\n    }\n\n    /* Enclosing bracket. */\n    if (pj_scan_get_char(scanner) != '>')\n\ton_syntax_error(scanner);\n\n    /* Sub nodes. */\n    while (*scanner->curptr == '<' && *(scanner->curptr+1) != '/'\n\t\t\t\t   && *(scanner->curptr+1) != '!')\n    {\n\tpj_xml_node *sub_node = xml_parse_node(pool, scanner);\n\tpj_list_push_back( &node->node_head, sub_node );\n    }\n\n    /* Content. */\n    if (!pj_scan_is_eof(scanner) && *scanner->curptr != '<') {\n\tpj_scan_get_until_ch(scanner, '<', &node->content);\n    }\n\n    /* CDATA content. */\n    if (*scanner->curptr == '<' && *(scanner->curptr+1) == '!' &&\n\tpj_scan_strcmp(scanner, \"<![CDATA[\", 9) == 0)\n    {\n\tpj_scan_advance_n(scanner, 9, PJ_FALSE);\n\tpj_scan_get_until_ch(scanner, ']', &node->content);\n\twhile (pj_scan_strcmp(scanner, \"]]>\", 3)) {\n\t    pj_str_t dummy;\n\n\t    pj_scan_advance_n(scanner, 1, PJ_FALSE);\n\t    pj_scan_get_until_ch(scanner, ']', &dummy);\n\t}\n\tnode->content.slen = scanner->curptr - node->content.ptr;\n\tpj_scan_advance_n(scanner, 3, PJ_TRUE);\n    }\n\n    /* Enclosing node. */\n    if (pj_scan_get_char(scanner) != '<' || pj_scan_get_char(scanner) != '/')\n\ton_syntax_error(scanner);\n\n    pj_scan_get_until_chr(scanner, \" \\t>\", &end_name);\n\n    /* Compare name. */\n    if (pj_stricmp(&node->name, &end_name) != 0)\n\ton_syntax_error(scanner);\n\n    /* Enclosing '>' */\n    if (pj_scan_get_char(scanner) != '>')\n\ton_syntax_error(scanner);\n\n    return node;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -97,6 +97,8 @@\n \tpj_scan_get_until_ch(scanner, ']', &node->content);\n \twhile (pj_scan_strcmp(scanner, \"]]>\", 3)) {\n \t    pj_str_t dummy;\n+\n+\t    pj_scan_advance_n(scanner, 1, PJ_FALSE);\n \t    pj_scan_get_until_ch(scanner, ']', &dummy);\n \t}\n \tnode->content.slen = scanner->curptr - node->content.ptr;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\t    pj_scan_advance_n(scanner, 1, PJ_FALSE);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-24191",
        "func_name": "michaelrsweet/htmldoc/gif_read_lzw",
        "description": "In HTMLDOC 1.9.14, an infinite loop in the gif_read_lzw function can lead to a pointer arbitrarily pointing to heap memory and resulting in a buffer overflow.",
        "git_url": "https://github.com/michaelrsweet/htmldoc/commit/fb0334a51300988e9b83b9870d4063e86002b077",
        "commit_title": "Fix a potential stack overflow bug with GIF images (Issue #470)",
        "commit_text": "",
        "func_before": "static int\t\t\t\t/* I - Byte from stream */\ngif_read_lzw(FILE *fp,\t\t\t/* I - File to read from */\n\t     int  first_time,\t\t/* I - 1 = first time, 0 = not first time */\n \t     int  input_code_size)\t/* I - Code size in bits */\n{\n  int\t\ti,\t\t\t/* Looping var */\n\t\tcode,\t\t\t/* Current code */\n\t\tincode;\t\t\t/* Input code */\n  static short\tfresh = 0,\t\t/* 1 = empty buffers */\n\t\tcode_size = 0,\t\t/* Current code size */\n\t\tset_code_size = 0,\t/* Initial code size set */\n\t\tmax_code = 0,\t\t/* Maximum code used */\n\t\tmax_code_size = 0,\t/* Maximum code size */\n\t\tfirstcode = 0,\t\t/* First code read */\n\t\toldcode = 0,\t\t/* Last code read */\n\t\tclear_code = 0,\t\t/* Clear code for LZW input */\n\t\tend_code = 0,\t\t/* End code for LZW input */\n\t\ttable[2][4096],\t\t/* String table */\n\t\tstack[8192],\t\t/* Output stack */\n\t\t*sp = stack;\t\t/* Current stack pointer */\n\n\n  if (first_time)\n  {\n   /*\n    * Setup LZW state...\n    */\n\n    set_code_size = (short)input_code_size;\n    code_size     = set_code_size + 1;\n    clear_code    = (short)(1 << set_code_size);\n    end_code      = clear_code + 1;\n    max_code_size = 2 * clear_code;\n    max_code      = clear_code + 2;\n\n   /*\n    * Initialize input buffers...\n    */\n\n    gif_get_code(fp, 0, 1);\n\n   /*\n    * Wipe the decompressor table...\n    */\n\n    fresh = 1;\n\n    for (i = 0; i < clear_code; i ++)\n    {\n      table[0][i] = 0;\n      table[1][i] = (short)i;\n    }\n\n    for (; i < 4096; i ++)\n      table[0][i] = table[1][0] = 0;\n\n    sp = stack;\n\n    return (0);\n  }\n  else if (fresh)\n  {\n    fresh = 0;\n\n    do\n      firstcode = oldcode = (short)gif_get_code(fp, code_size, 0);\n    while (firstcode == clear_code);\n\n    return (firstcode);\n  }\n\n  if (sp > stack)\n    return (*--sp);\n\n  while ((code = gif_get_code(fp, code_size, 0)) >= 0)\n  {\n    if (code == clear_code)\n    {\n      for (i = 0; i < clear_code; i ++)\n      {\n\ttable[0][i] = 0;\n\ttable[1][i] = (short)i;\n      }\n\n      for (; i < 4096; i ++)\n\ttable[0][i] = table[1][i] = 0;\n\n      code_size     = set_code_size + 1;\n      max_code_size = 2 * clear_code;\n      max_code      = clear_code + 2;\n\n      sp = stack;\n\n      firstcode = oldcode = (short)gif_get_code(fp, code_size, 0);\n\n      return (firstcode);\n    }\n    else if (code == end_code)\n    {\n      uchar\tbuf[260];\n\n\n      if (!gif_eof)\n        while (gif_get_block(fp, buf) > 0);\n\n      return (-2);\n    }\n\n    incode = code;\n\n    if (code >= max_code)\n    {\n      *sp++ = firstcode;\n      code  = oldcode;\n    }\n\n    while (code >= clear_code)\n    {\n      *sp++ = table[1][code];\n      if (code == table[0][code])\n\treturn (255);\n\n      code = table[0][code];\n    }\n\n    *sp++ = firstcode = table[1][code];\n    code  = max_code;\n\n    if (code < 4096)\n    {\n      table[0][code] = oldcode;\n      table[1][code] = firstcode;\n      max_code ++;\n\n      if (max_code >= max_code_size && max_code_size < 4096)\n      {\n\tmax_code_size *= 2;\n\tcode_size ++;\n      }\n    }\n\n    oldcode = (short)incode;\n\n    if (sp > stack)\n      return (*--sp);\n  }\n\n  return (code);\n}",
        "func": "static int\t\t\t\t/* I - Byte from stream */\ngif_read_lzw(FILE *fp,\t\t\t/* I - File to read from */\n\t     int  first_time,\t\t/* I - 1 = first time, 0 = not first time */\n \t     int  input_code_size)\t/* I - Code size in bits */\n{\n  int\t\ti,\t\t\t/* Looping var */\n\t\tcode,\t\t\t/* Current code */\n\t\tincode;\t\t\t/* Input code */\n  static short\tfresh = 0,\t\t/* 1 = empty buffers */\n\t\tcode_size = 0,\t\t/* Current code size */\n\t\tset_code_size = 0,\t/* Initial code size set */\n\t\tmax_code = 0,\t\t/* Maximum code used */\n\t\tmax_code_size = 0,\t/* Maximum code size */\n\t\tfirstcode = 0,\t\t/* First code read */\n\t\toldcode = 0,\t\t/* Last code read */\n\t\tclear_code = 0,\t\t/* Clear code for LZW input */\n\t\tend_code = 0,\t\t/* End code for LZW input */\n\t\ttable[2][4096],\t\t/* String table */\n\t\tstack[8192],\t\t/* Output stack */\n\t\t*sp = stack;\t\t/* Current stack pointer */\n\n\n  if (first_time)\n  {\n   /*\n    * Setup LZW state...\n    */\n\n    set_code_size = (short)input_code_size;\n    code_size     = set_code_size + 1;\n    clear_code    = (short)(1 << set_code_size);\n    end_code      = clear_code + 1;\n    max_code_size = 2 * clear_code;\n    max_code      = clear_code + 2;\n\n   /*\n    * Initialize input buffers...\n    */\n\n    gif_get_code(fp, 0, 1);\n\n   /*\n    * Wipe the decompressor table...\n    */\n\n    fresh = 1;\n\n    for (i = 0; i < clear_code; i ++)\n    {\n      table[0][i] = 0;\n      table[1][i] = (short)i;\n    }\n\n    for (; i < 4096; i ++)\n      table[0][i] = table[1][0] = 0;\n\n    sp = stack;\n\n    return (0);\n  }\n  else if (fresh)\n  {\n    fresh = 0;\n\n    do\n      firstcode = oldcode = (short)gif_get_code(fp, code_size, 0);\n    while (firstcode == clear_code);\n\n    return (firstcode);\n  }\n\n  if (sp > stack)\n    return (*--sp);\n\n  while ((code = gif_get_code(fp, code_size, 0)) >= 0)\n  {\n    if (code == clear_code)\n    {\n      for (i = 0; i < clear_code; i ++)\n      {\n\ttable[0][i] = 0;\n\ttable[1][i] = (short)i;\n      }\n\n      for (; i < 4096; i ++)\n\ttable[0][i] = table[1][i] = 0;\n\n      code_size     = set_code_size + 1;\n      max_code_size = 2 * clear_code;\n      max_code      = clear_code + 2;\n\n      sp = stack;\n\n      firstcode = oldcode = (short)gif_get_code(fp, code_size, 0);\n\n      return (firstcode);\n    }\n    else if (code == end_code)\n    {\n      uchar\tbuf[260];\n\n      if (!gif_eof)\n        while (gif_get_block(fp, buf) > 0);\n\n      return (-2);\n    }\n\n    incode = code;\n\n    if (code >= max_code)\n    {\n      *sp++ = firstcode;\n      code  = oldcode;\n    }\n\n    while (code >= clear_code)\n    {\n      if (sp >= (stack + sizeof(stack)))\n        return (255);\n\n      *sp++ = table[1][code];\n\n      if (code == table[0][code])\n\treturn (255);\n\n      code = table[0][code];\n    }\n\n    if (sp >= (stack + sizeof(stack)))\n      return (255);\n\n    *sp++ = firstcode = table[1][code];\n\n    if ((code = max_code) < 4096)\n    {\n      table[0][code] = oldcode;\n      table[1][code] = firstcode;\n      max_code ++;\n\n      if (max_code >= max_code_size && max_code_size < 4096)\n      {\n\tmax_code_size *= 2;\n\tcode_size ++;\n      }\n    }\n\n    oldcode = (short)incode;\n\n    if (sp > stack)\n      return (*--sp);\n  }\n\n  return (code);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -99,7 +99,6 @@\n     {\n       uchar\tbuf[260];\n \n-\n       if (!gif_eof)\n         while (gif_get_block(fp, buf) > 0);\n \n@@ -116,17 +115,23 @@\n \n     while (code >= clear_code)\n     {\n+      if (sp >= (stack + sizeof(stack)))\n+        return (255);\n+\n       *sp++ = table[1][code];\n+\n       if (code == table[0][code])\n \treturn (255);\n \n       code = table[0][code];\n     }\n \n+    if (sp >= (stack + sizeof(stack)))\n+      return (255);\n+\n     *sp++ = firstcode = table[1][code];\n-    code  = max_code;\n \n-    if (code < 4096)\n+    if ((code = max_code) < 4096)\n     {\n       table[0][code] = oldcode;\n       table[1][code] = firstcode;",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "    code  = max_code;",
                "    if (code < 4096)"
            ],
            "added_lines": [
                "      if (sp >= (stack + sizeof(stack)))",
                "        return (255);",
                "",
                "",
                "    if (sp >= (stack + sizeof(stack)))",
                "      return (255);",
                "",
                "    if ((code = max_code) < 4096)"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-21159",
        "func_name": "mz-automation/libiec61850/parseNormalModeParameters",
        "description": "A denial of service vulnerability exists in the parseNormalModeParameters functionality of MZ Automation GmbH libiec61850 1.5.0. A specially-crafted series of network requests can lead to denial of service. An attacker can send a sequence of malformed iec61850 messages to trigger this vulnerability.",
        "git_url": "https://github.com/mz-automation/libiec61850/commit/cfa94cbf10302bedc779703f874ee2e8387a0721",
        "commit_title": "- fixed - Bug in presentation layer parser can cause infinite loop (LIB61850-302)",
        "commit_text": "",
        "func_before": "static int\nparseNormalModeParameters(IsoPresentation* self, uint8_t* buffer, int totalLength, int bufPos)\n{\n    int endPos = bufPos + totalLength;\n\n    self->calledPresentationSelector.size = 0;\n    self->callingPresentationSelector.size = 0;\n\n    bool hasUserData = false;\n\n    while (bufPos < endPos) {\n        uint8_t tag = buffer[bufPos++];\n        int len;\n\n        if (bufPos == endPos) {\n            if (DEBUG_PRES)\n                printf(\"PRES: invalid message\\n\");\n            return -1;\n        }\n\n        bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, endPos);\n\n        if (bufPos < 0) {\n            if (DEBUG_PRES)\n                printf(\"PRES: wrong parameter length\\n\");\n            return -1;\n        }\n\n        switch (tag) {\n        case 0x81: /* calling-presentation-selector */\n\n            if (len > 16) {\n                if (DEBUG_PRES)\n                    printf(\"PRES: calling-presentation-sel too large\\n\");\n            }\n            else {\n                self->callingPresentationSelector.size = len;\n                int i;\n                for (i = 0; i < len; i++)\n                    self->callingPresentationSelector.value[i] = buffer[bufPos + i];\n            }\n\n            bufPos += len;\n            break;\n\n        case 0x82: /* called-presentation-selector */\n\n            if (len > 16) {\n                if (DEBUG_PRES)\n                    printf(\"PRES: called-presentation-sel too large\\n\");\n            }\n            else {\n                self->calledPresentationSelector.size = len;\n                int i;\n                for (i = 0; i < len; i++)\n                    self->calledPresentationSelector.value[i] = buffer[bufPos + i];\n            }\n\n            bufPos += len;\n            break;\n\n        case 0x83: /* responding-presentation-selector */\n\n            if (len > 16) {\n                if (DEBUG_PRES)\n                    printf(\"PRES: responding-presentation-sel too large\\n\");\n            }\n\n            bufPos += len;\n            break;\n\n        case 0xa4: /* presentation-context-definition list */\n            if (DEBUG_PRES)\n                printf(\"PRES: pcd list\\n\");\n            bufPos = parsePresentationContextDefinitionList(self, buffer, len, bufPos);\n            break;\n\n        case 0xa5: /* context-definition-result-list */\n\n            bufPos += len;\n            break;\n\n        case 0x61: /* user data */\n            if (DEBUG_PRES)\n                printf(\"PRES: user-data\\n\");\n\n            bufPos = parseFullyEncodedData(self, buffer, len, bufPos);\n\n            if (bufPos < 0)\n                return -1;\n\n            if (self->nextPayload.size > 0)\n                hasUserData = true;\n\n            break;\n\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n\n        default:\n            if (DEBUG_PRES)\n                printf(\"PRES: unknown tag in normal-mode\\n\");\n            bufPos += len;\n            break;\n        }\n    }\n\n    if (hasUserData == false) {\n        if (DEBUG_PRES)\n            printf(\"PRES: user-data is missing\\n\");\n\n        return -1;\n    }\n\n    return bufPos;\n}",
        "func": "static int\nparseNormalModeParameters(IsoPresentation* self, uint8_t* buffer, int totalLength, int bufPos)\n{\n    int endPos = bufPos + totalLength;\n\n    self->calledPresentationSelector.size = 0;\n    self->callingPresentationSelector.size = 0;\n\n    bool hasUserData = false;\n\n    while (bufPos < endPos) {\n        uint8_t tag = buffer[bufPos++];\n        int len;\n\n        if (bufPos == endPos) {\n            if (DEBUG_PRES)\n                printf(\"PRES: invalid message\\n\");\n            return -1;\n        }\n\n        bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, endPos);\n\n        if (bufPos < 0) {\n            if (DEBUG_PRES)\n                printf(\"PRES: wrong parameter length\\n\");\n            return -1;\n        }\n\n        switch (tag) {\n        case 0x81: /* calling-presentation-selector */\n\n            if (len > 16) {\n                if (DEBUG_PRES)\n                    printf(\"PRES: calling-presentation-sel too large\\n\");\n            }\n            else {\n                self->callingPresentationSelector.size = len;\n                int i;\n                for (i = 0; i < len; i++)\n                    self->callingPresentationSelector.value[i] = buffer[bufPos + i];\n            }\n\n            bufPos += len;\n            break;\n\n        case 0x82: /* called-presentation-selector */\n\n            if (len > 16) {\n                if (DEBUG_PRES)\n                    printf(\"PRES: called-presentation-sel too large\\n\");\n            }\n            else {\n                self->calledPresentationSelector.size = len;\n                int i;\n                for (i = 0; i < len; i++)\n                    self->calledPresentationSelector.value[i] = buffer[bufPos + i];\n            }\n\n            bufPos += len;\n            break;\n\n        case 0x83: /* responding-presentation-selector */\n\n            if (len > 16) {\n                if (DEBUG_PRES)\n                    printf(\"PRES: responding-presentation-sel too large\\n\");\n            }\n\n            bufPos += len;\n            break;\n\n        case 0xa4: /* presentation-context-definition list */\n            if (DEBUG_PRES)\n                printf(\"PRES: pcd list\\n\");\n            bufPos = parsePresentationContextDefinitionList(self, buffer, len, bufPos);\n\n            if (bufPos < 0)\n                return -1;\n\n            break;\n\n        case 0xa5: /* context-definition-result-list */\n\n            bufPos += len;\n            break;\n\n        case 0x61: /* user data */\n            if (DEBUG_PRES)\n                printf(\"PRES: user-data\\n\");\n\n            bufPos = parseFullyEncodedData(self, buffer, len, bufPos);\n\n            if (bufPos < 0)\n                return -1;\n\n            if (self->nextPayload.size > 0)\n                hasUserData = true;\n\n            break;\n\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n\n        default:\n            if (DEBUG_PRES)\n                printf(\"PRES: unknown tag in normal-mode\\n\");\n            bufPos += len;\n            break;\n        }\n    }\n\n    if (hasUserData == false) {\n        if (DEBUG_PRES)\n            printf(\"PRES: user-data is missing\\n\");\n\n        return -1;\n    }\n\n    return bufPos;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -73,6 +73,10 @@\n             if (DEBUG_PRES)\n                 printf(\"PRES: pcd list\\n\");\n             bufPos = parsePresentationContextDefinitionList(self, buffer, len, bufPos);\n+\n+            if (bufPos < 0)\n+                return -1;\n+\n             break;\n \n         case 0xa5: /* context-definition-result-list */",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "            if (bufPos < 0)",
                "                return -1;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-24792",
        "func_name": "pjsip/pjproject/pjmedia_avi_player_create_streams",
        "description": "PJSIP is a free and open source multimedia communication library written in C. A denial-of-service vulnerability affects applications on a 32-bit systems that use PJSIP versions 2.12 and prior to play/read invalid WAV files. The vulnerability occurs when reading WAV file data chunks with length greater than 31-bit integers. The vulnerability does not affect 64-bit apps and should not affect apps that only plays trusted WAV files. A patch is available on the `master` branch of the `pjsip/project` GitHub repository. As a workaround, apps can reject a WAV file received from an unknown source or validate the file first.",
        "git_url": "https://github.com/pjsip/pjproject/commit/947bc1ee6d05be10204b918df75a503415fd3213",
        "commit_title": "Merge pull request from GHSA-rwgw-vwxg-q799",
        "commit_text": " * Prevent potential infinite loop when parsing WAV format file  * Check if subchunk is negative.  * Fix and add checks  * Change data type from pj_ssize_t to long.  * Modify check  * Fix leak file descriptor and modify check on wav_playlist  * Move overflow/underflow check to pj_file_setpos()  * Use macro to simplify check  * modification based on comments  * Remove unnecessary casting  * Modification based on comments",
        "func_before": "PJ_DEF(pj_status_t)\npjmedia_avi_player_create_streams(pj_pool_t *pool,\n                                  const char *filename,\n\t\t\t\t  unsigned options,\n\t\t\t\t  pjmedia_avi_streams **p_streams)\n{\n    pjmedia_avi_hdr avi_hdr;\n    struct avi_reader_port *fport[PJMEDIA_AVI_MAX_NUM_STREAMS];\n    pj_off_t pos;\n    unsigned i, nstr = 0;\n    pj_status_t status = PJ_SUCCESS;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(pool && filename && p_streams, PJ_EINVAL);\n\n    /* Check the file really exists. */\n    if (!pj_file_exists(filename)) {\n\treturn PJ_ENOTFOUND;\n    }\n\n    /* Create fport instance. */\n    fport[0] = create_avi_port(pool);\n    if (!fport[0]) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Get the file size. */\n    fport[0]->fsize = pj_file_size(filename);\n\n    /* Size must be more than AVI header size */\n    if (fport[0]->fsize <= sizeof(riff_hdr_t) + sizeof(avih_hdr_t) + \n                           sizeof(strl_hdr_t))\n    {\n\treturn PJMEDIA_EINVALIMEDIATYPE;\n    }\n\n    /* Open file. */\n    status = pj_file_open(pool, filename, PJ_O_RDONLY, &fport[0]->fd);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Read the RIFF + AVIH header. */\n    status = file_read(fport[0]->fd, &avi_hdr,\n                       sizeof(riff_hdr_t) + sizeof(avih_hdr_t));\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    /* Validate AVI file. */\n    if (!COMPARE_TAG(avi_hdr.riff_hdr.riff, PJMEDIA_AVI_RIFF_TAG) ||\n\t!COMPARE_TAG(avi_hdr.riff_hdr.avi, PJMEDIA_AVI_AVI_TAG) ||\n        !COMPARE_TAG(avi_hdr.avih_hdr.list_tag, PJMEDIA_AVI_LIST_TAG) ||\n        !COMPARE_TAG(avi_hdr.avih_hdr.hdrl_tag, PJMEDIA_AVI_HDRL_TAG) ||\n        !COMPARE_TAG(avi_hdr.avih_hdr.avih, PJMEDIA_AVI_AVIH_TAG))\n    {\n\tstatus = PJMEDIA_EINVALIMEDIATYPE;\n        goto on_error;\n    }\n\n    PJ_LOG(5, (THIS_FILE, \"The AVI file has %d streams.\",\n               avi_hdr.avih_hdr.num_streams));\n\n    /* Unsupported AVI format. */\n    if (avi_hdr.avih_hdr.num_streams > PJMEDIA_AVI_MAX_NUM_STREAMS) {\n        status = PJMEDIA_EAVIUNSUPP;\n        goto on_error;\n    }\n\n    /** \n     * TODO: Possibly unsupported AVI format.\n     * If you encounter this warning, verify whether the avi player\n     * is working properly.\n     */\n    if (avi_hdr.avih_hdr.flags & AVIF_MUSTUSEINDEX ||\n        avi_hdr.avih_hdr.pad > 1)\n    {\n        PJ_LOG(3, (THIS_FILE, \"Warning!!! Possibly unsupported AVI format: \"\n                   \"flags:%d, pad:%d\", avi_hdr.avih_hdr.flags, \n                   avi_hdr.avih_hdr.pad));\n    }\n\n    /* Read the headers of each stream. */\n    for (i = 0; i < avi_hdr.avih_hdr.num_streams; i++) {\n        pj_size_t elem = 0;\n        pj_ssize_t size_to_read;\n\n        /* Read strl header */\n        status = file_read(fport[0]->fd, &avi_hdr.strl_hdr[i],\n                           sizeof(strl_hdr_t));\n        if (status != PJ_SUCCESS)\n            goto on_error;\n        \n        elem = COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                           PJMEDIA_AVI_VIDS_TAG) ? \n               sizeof(strf_video_hdr_t) :\n               COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                           PJMEDIA_AVI_AUDS_TAG) ?\n               sizeof(strf_audio_hdr_t) : 0;\n\n        /* Read strf header */\n        status = file_read2(fport[0]->fd, &avi_hdr.strf_hdr[i],\n                            elem, 0);\n        if (status != PJ_SUCCESS)\n            goto on_error;\n\n        /* Normalize the endian */\n        if (elem == sizeof(strf_video_hdr_t))\n            data_to_host2(&avi_hdr.strf_hdr[i],\n                          sizeof(strf_video_hdr_sizes)/\n                          sizeof(strf_video_hdr_sizes[0]),\n                          strf_video_hdr_sizes);\n        else if (elem == sizeof(strf_audio_hdr_t))\n            data_to_host2(&avi_hdr.strf_hdr[i],\n                          sizeof(strf_audio_hdr_sizes)/\n                          sizeof(strf_audio_hdr_sizes[0]),\n                          strf_audio_hdr_sizes);\n\n        /* Skip the remainder of the header */\n        size_to_read = avi_hdr.strl_hdr[i].list_sz - (sizeof(strl_hdr_t) -\n                       8) - elem;\n\tstatus = pj_file_setpos(fport[0]->fd, size_to_read, PJ_SEEK_CUR);\n\tif (status != PJ_SUCCESS) {\n            goto on_error;\n\t}\n    }\n\n    /* Finish reading the AVIH header */\n    status = pj_file_setpos(fport[0]->fd, avi_hdr.avih_hdr.list_sz +\n                            sizeof(riff_hdr_t) + 8, PJ_SEEK_SET);\n    if (status != PJ_SUCCESS) {\n        goto on_error;\n    }\n\n    /* Skip any JUNK or LIST INFO until we get MOVI tag */\n    do {\n        pjmedia_avi_subchunk ch;\n        int read = 0;\n\n        status = file_read(fport[0]->fd, &ch, sizeof(pjmedia_avi_subchunk));\n        if (status != PJ_SUCCESS) {\n            goto on_error;\n        }\n\n        if (COMPARE_TAG(ch.id, PJMEDIA_AVI_LIST_TAG))\n        {\n            read = 4;\n            status = file_read(fport[0]->fd, &ch, read);\n            if (COMPARE_TAG(ch.id, PJMEDIA_AVI_MOVI_TAG))\n                break;\n        }\n\n        status = pj_file_setpos(fport[0]->fd, ch.len-read, PJ_SEEK_CUR);\n        if (status != PJ_SUCCESS) {\n            goto on_error;\n        }\n    } while(1);\n\n    status = pj_file_getpos(fport[0]->fd, &pos);\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    for (i = 0, nstr = 0; i < avi_hdr.avih_hdr.num_streams; i++) {\n\tpjmedia_format_id fmt_id;\n\n        /* Skip non-audio, non-video, or disabled streams) */\n        if ((!COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                          PJMEDIA_AVI_VIDS_TAG) &&\n             !COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                          PJMEDIA_AVI_AUDS_TAG)) ||\n            avi_hdr.strl_hdr[i].flags & AVISF_DISABLED)\n        {\n            continue;\n        }\n\n        if (COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                        PJMEDIA_AVI_VIDS_TAG))\n        {\n            int j;\n\n            if (avi_hdr.strl_hdr[i].flags & AVISF_VIDEO_PALCHANGES) {\n                PJ_LOG(4, (THIS_FILE, \"Unsupported video stream\"));\n                continue;\n            }\n\n            fmt_id = avi_hdr.strl_hdr[i].codec;\n            for (j = sizeof(avi_fmts)/sizeof(avi_fmts[0])-1; j >= 0; j--) {\n                /* Check supported video formats here */\n                if (fmt_id == avi_fmts[j].fmt_id) {\n                    if (avi_fmts[j].eff_fmt_id)\n                        fmt_id = avi_fmts[j].eff_fmt_id;\n                    break;\n                }\n            }\n            \n            if (j < 0) {\n                PJ_LOG(4, (THIS_FILE, \"Unsupported video stream\"));\n                continue;\n            }\n        } else {\n            /* Check supported audio formats here */\n\t    strf_audio_hdr_t *hdr = (strf_audio_hdr_t*)\n\t\t\t\t    &avi_hdr.strf_hdr[i].strf_audio_hdr;\n            if (hdr->fmt_tag == PJMEDIA_WAVE_FMT_TAG_PCM &&\n\t\thdr->bits_per_sample == 16)\n\t    {\n\t\tfmt_id = PJMEDIA_FORMAT_PCM;\n\t    }\n\t    else if (hdr->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ALAW)\n\t    {\n\t\tfmt_id = PJMEDIA_FORMAT_PCMA;\n\t    }\n\t    else if (hdr->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ULAW)\n\t    {\n\t\tfmt_id = PJMEDIA_FORMAT_PCMU;\n\t    }\n\t    else\n            {\n                PJ_LOG(4, (THIS_FILE, \"Unsupported audio stream\"));\n                continue;\n            }\n        }\n\n        if (nstr > 0) {\n            /* Create fport instance. */\n            fport[nstr] = create_avi_port(pool);\n            if (!fport[nstr]) {\n\t        status = PJ_ENOMEM;\n                goto on_error;\n            }\n\n            /* Open file. */\n            status = pj_file_open(pool, filename, PJ_O_RDONLY,\n                                  &fport[nstr]->fd);\n            if (status != PJ_SUCCESS)\n                goto on_error;\n\n            /* Set the file position */\n            status = pj_file_setpos(fport[nstr]->fd, pos, PJ_SEEK_SET);\n            if (status != PJ_SUCCESS) {\n                goto on_error;\n            }\n        }\n\n        fport[nstr]->stream_id = i;\n        fport[nstr]->fmt_id = fmt_id;\n\n        nstr++;\n    }\n\n    if (nstr == 0) {\n        status = PJMEDIA_EAVIUNSUPP;\n        goto on_error;\n    }\n\n    for (i = 0; i < nstr; i++) {\n        strl_hdr_t *strl_hdr = &avi_hdr.strl_hdr[fport[i]->stream_id];\n\n        /* Initialize */\n        fport[i]->options = options;\n        fport[i]->fsize = fport[0]->fsize;\n        /* Current file position now points to start of data */\n        fport[i]->start_data = pos;\n        \n        if (COMPARE_TAG(strl_hdr->data_type, PJMEDIA_AVI_VIDS_TAG)) {\n            strf_video_hdr_t *strf_hdr =\n                &avi_hdr.strf_hdr[fport[i]->stream_id].strf_video_hdr;\n            const pjmedia_video_format_info *vfi;\n\n            vfi = pjmedia_get_video_format_info(\n                pjmedia_video_format_mgr_instance(),\n                strl_hdr->codec);\n\n            fport[i]->bits_per_sample = (vfi ? vfi->bpp : 0);\n            fport[i]->usec_per_frame = avi_hdr.avih_hdr.usec_per_frame;\n            pjmedia_format_init_video(&fport[i]->base.info.fmt,\n                                      fport[i]->fmt_id,\n                                      strf_hdr->biWidth,\n                                      strf_hdr->biHeight,\n                                      strl_hdr->rate,\n                                      strl_hdr->scale);\n#if 0\n            /* The calculation below is wrong. strf_hdr->biSizeImage shows\n             * uncompressed size. Looks like we need to go the ugly way to\n             * get the bitrage:\n             *    http://www.virtualdub.org/blog/pivot/entry.php?id=159\n             */\n            bps = strf_hdr->biSizeImage * 8 * strl_hdr->rate / strl_hdr->scale;\n            if (bps==0) {\n        \t/* strf_hdr->biSizeImage may be zero for uncompressed RGB */\n        \tbps = strf_hdr->biWidth * strf_hdr->biHeight *\n        \t\tstrf_hdr->biBitCount *\n        \t\tstrl_hdr->rate / strl_hdr->scale;\n            }\n            fport[i]->base.info.fmt.det.vid.avg_bps = bps;\n            fport[i]->base.info.fmt.det.vid.max_bps = bps;\n#endif\n        } else {\n            strf_audio_hdr_t *strf_hdr =\n                &avi_hdr.strf_hdr[fport[i]->stream_id].strf_audio_hdr;\n\n            fport[i]->bits_per_sample = strf_hdr->bits_per_sample;\n            fport[i]->usec_per_frame = avi_hdr.avih_hdr.usec_per_frame;\n            pjmedia_format_init_audio(&fport[i]->base.info.fmt,\n                                      fport[i]->fmt_id,\n                                      strf_hdr->sample_rate,\n                                      strf_hdr->nchannels,\n                                      strf_hdr->bits_per_sample,\n                                      20000 /* fport[i]->usec_per_frame */,\n                                      strf_hdr->bytes_per_sec * 8,\n                                      strf_hdr->bytes_per_sec * 8);\n\n\t    /* Set format to PCM (we will decode PCMA/U) */\n\t    if (fport[i]->fmt_id == PJMEDIA_FORMAT_PCMA ||\n\t\tfport[i]->fmt_id == PJMEDIA_FORMAT_PCMU)\n\t    {\n\t\tfport[i]->base.info.fmt.id = PJMEDIA_FORMAT_PCM;\n\t\tfport[i]->base.info.fmt.det.aud.bits_per_sample = 16;\n\t    }\n\t}\n\n        pj_strdup2(pool, &fport[i]->base.info.name, filename);\n    }\n\n    /* Done. */\n    *p_streams = pj_pool_alloc(pool, sizeof(pjmedia_avi_streams));\n    (*p_streams)->num_streams = nstr;\n    (*p_streams)->streams = pj_pool_calloc(pool, (*p_streams)->num_streams,\n                                           sizeof(pjmedia_port *));\n    for (i = 0; i < nstr; i++)\n        (*p_streams)->streams[i] = &fport[i]->base;\n\n    PJ_LOG(4,(THIS_FILE, \n\t      \"AVI file player '%.*s' created with \"\n\t      \"%d media ports\",\n\t      (int)fport[0]->base.info.name.slen,\n\t      fport[0]->base.info.name.ptr,\n              (*p_streams)->num_streams));\n\n    return PJ_SUCCESS;\n\non_error:\n    fport[0]->base.on_destroy(&fport[0]->base);\n    for (i = 1; i < nstr; i++)\n        fport[i]->base.on_destroy(&fport[i]->base);\n    if (status == AVI_EOF)\n        return PJMEDIA_EINVALIMEDIATYPE;\n    return status;\n}",
        "func": "PJ_DEF(pj_status_t)\npjmedia_avi_player_create_streams(pj_pool_t *pool,\n                                  const char *filename,\n\t\t\t\t  unsigned options,\n\t\t\t\t  pjmedia_avi_streams **p_streams)\n{\n    pjmedia_avi_hdr avi_hdr;\n    struct avi_reader_port *fport[PJMEDIA_AVI_MAX_NUM_STREAMS];\n    pj_off_t pos;\n    unsigned i, nstr = 0;\n    pj_status_t status = PJ_SUCCESS;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(pool && filename && p_streams, PJ_EINVAL);\n\n    /* Check the file really exists. */\n    if (!pj_file_exists(filename)) {\n\treturn PJ_ENOTFOUND;\n    }\n\n    /* Create fport instance. */\n    fport[0] = create_avi_port(pool);\n    if (!fport[0]) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Get the file size. */\n    fport[0]->fsize = pj_file_size(filename);\n\n    /* Size must be more than AVI header size */\n    if (fport[0]->fsize <= sizeof(riff_hdr_t) + sizeof(avih_hdr_t) + \n                           sizeof(strl_hdr_t))\n    {\n\treturn PJMEDIA_EINVALIMEDIATYPE;\n    }\n\n    /* Open file. */\n    status = pj_file_open(pool, filename, PJ_O_RDONLY, &fport[0]->fd);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Read the RIFF + AVIH header. */\n    status = file_read(fport[0]->fd, &avi_hdr,\n                       sizeof(riff_hdr_t) + sizeof(avih_hdr_t));\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    /* Validate AVI file. */\n    if (!COMPARE_TAG(avi_hdr.riff_hdr.riff, PJMEDIA_AVI_RIFF_TAG) ||\n\t!COMPARE_TAG(avi_hdr.riff_hdr.avi, PJMEDIA_AVI_AVI_TAG) ||\n        !COMPARE_TAG(avi_hdr.avih_hdr.list_tag, PJMEDIA_AVI_LIST_TAG) ||\n        !COMPARE_TAG(avi_hdr.avih_hdr.hdrl_tag, PJMEDIA_AVI_HDRL_TAG) ||\n        !COMPARE_TAG(avi_hdr.avih_hdr.avih, PJMEDIA_AVI_AVIH_TAG))\n    {\n\tstatus = PJMEDIA_EINVALIMEDIATYPE;\n        goto on_error;\n    }\n\n    PJ_LOG(5, (THIS_FILE, \"The AVI file has %d streams.\",\n               avi_hdr.avih_hdr.num_streams));\n\n    /* Unsupported AVI format. */\n    if (avi_hdr.avih_hdr.num_streams > PJMEDIA_AVI_MAX_NUM_STREAMS) {\n        status = PJMEDIA_EAVIUNSUPP;\n        goto on_error;\n    }\n\n    /** \n     * TODO: Possibly unsupported AVI format.\n     * If you encounter this warning, verify whether the avi player\n     * is working properly.\n     */\n    if (avi_hdr.avih_hdr.flags & AVIF_MUSTUSEINDEX ||\n        avi_hdr.avih_hdr.pad > 1)\n    {\n        PJ_LOG(3, (THIS_FILE, \"Warning!!! Possibly unsupported AVI format: \"\n                   \"flags:%d, pad:%d\", avi_hdr.avih_hdr.flags, \n                   avi_hdr.avih_hdr.pad));\n    }\n\n    /* Read the headers of each stream. */\n    for (i = 0; i < avi_hdr.avih_hdr.num_streams; i++) {\n        pj_size_t elem = 0;\n        pj_off_t size_to_read;\n\n        /* Read strl header */\n        status = file_read(fport[0]->fd, &avi_hdr.strl_hdr[i],\n                           sizeof(strl_hdr_t));\n        if (status != PJ_SUCCESS)\n            goto on_error;\n        \n        elem = COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                           PJMEDIA_AVI_VIDS_TAG) ? \n               sizeof(strf_video_hdr_t) :\n               COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                           PJMEDIA_AVI_AUDS_TAG) ?\n               sizeof(strf_audio_hdr_t) : 0;\n\n        /* Read strf header */\n        status = file_read2(fport[0]->fd, &avi_hdr.strf_hdr[i],\n                            elem, 0);\n        if (status != PJ_SUCCESS)\n            goto on_error;\n\n        /* Normalize the endian */\n        if (elem == sizeof(strf_video_hdr_t))\n            data_to_host2(&avi_hdr.strf_hdr[i],\n                          sizeof(strf_video_hdr_sizes)/\n                          sizeof(strf_video_hdr_sizes[0]),\n                          strf_video_hdr_sizes);\n        else if (elem == sizeof(strf_audio_hdr_t))\n            data_to_host2(&avi_hdr.strf_hdr[i],\n                          sizeof(strf_audio_hdr_sizes)/\n                          sizeof(strf_audio_hdr_sizes[0]),\n                          strf_audio_hdr_sizes);\n\n        /* Skip the remainder of the header */\n        size_to_read = avi_hdr.strl_hdr[i].list_sz - (sizeof(strl_hdr_t) -\n                       8) - elem;\n\tstatus = pj_file_setpos(fport[0]->fd, size_to_read, PJ_SEEK_CUR);\n\tif (status != PJ_SUCCESS) {\n            goto on_error;\n\t}\n    }\n\n    /* Finish reading the AVIH header */\n    status = pj_file_setpos(fport[0]->fd, avi_hdr.avih_hdr.list_sz +\n                            sizeof(riff_hdr_t) + 8, PJ_SEEK_SET);\n    if (status != PJ_SUCCESS) {\n        goto on_error;\n    }\n\n    /* Skip any JUNK or LIST INFO until we get MOVI tag */\n    do {\n        pjmedia_avi_subchunk ch;\n        int read = 0;\n        pj_off_t size_to_read;\n\n        status = file_read(fport[0]->fd, &ch, sizeof(pjmedia_avi_subchunk));\n        if (status != PJ_SUCCESS) {\n            goto on_error;\n        }\n\n        if (COMPARE_TAG(ch.id, PJMEDIA_AVI_LIST_TAG))\n        {\n            read = 4;\n            status = file_read(fport[0]->fd, &ch, read);\n            if (COMPARE_TAG(ch.id, PJMEDIA_AVI_MOVI_TAG))\n                break;\n        }\n\n        if (ch.len < read) {\n            status = PJ_EINVAL;\n            goto on_error;\n        }\n        PJ_CHECK_OVERFLOW_UINT32_TO_LONG(ch.len - read, \n                                         status = PJ_EINVAL; goto on_error;);\n        size_to_read = (pj_off_t)ch.len - read;\n\n        status = pj_file_setpos(fport[0]->fd, size_to_read, PJ_SEEK_CUR);\n        if (status != PJ_SUCCESS) {\n            goto on_error;\n        }\n    } while(1);\n\n    status = pj_file_getpos(fport[0]->fd, &pos);\n    if (status != PJ_SUCCESS)\n        goto on_error;\n\n    for (i = 0, nstr = 0; i < avi_hdr.avih_hdr.num_streams; i++) {\n\tpjmedia_format_id fmt_id;\n\n        /* Skip non-audio, non-video, or disabled streams) */\n        if ((!COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                          PJMEDIA_AVI_VIDS_TAG) &&\n             !COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                          PJMEDIA_AVI_AUDS_TAG)) ||\n            avi_hdr.strl_hdr[i].flags & AVISF_DISABLED)\n        {\n            continue;\n        }\n\n        if (COMPARE_TAG(avi_hdr.strl_hdr[i].data_type, \n                        PJMEDIA_AVI_VIDS_TAG))\n        {\n            int j;\n\n            if (avi_hdr.strl_hdr[i].flags & AVISF_VIDEO_PALCHANGES) {\n                PJ_LOG(4, (THIS_FILE, \"Unsupported video stream\"));\n                continue;\n            }\n\n            fmt_id = avi_hdr.strl_hdr[i].codec;\n            for (j = sizeof(avi_fmts)/sizeof(avi_fmts[0])-1; j >= 0; j--) {\n                /* Check supported video formats here */\n                if (fmt_id == avi_fmts[j].fmt_id) {\n                    if (avi_fmts[j].eff_fmt_id)\n                        fmt_id = avi_fmts[j].eff_fmt_id;\n                    break;\n                }\n            }\n            \n            if (j < 0) {\n                PJ_LOG(4, (THIS_FILE, \"Unsupported video stream\"));\n                continue;\n            }\n        } else {\n            /* Check supported audio formats here */\n\t    strf_audio_hdr_t *hdr = (strf_audio_hdr_t*)\n\t\t\t\t    &avi_hdr.strf_hdr[i].strf_audio_hdr;\n            if (hdr->fmt_tag == PJMEDIA_WAVE_FMT_TAG_PCM &&\n\t\thdr->bits_per_sample == 16)\n\t    {\n\t\tfmt_id = PJMEDIA_FORMAT_PCM;\n\t    }\n\t    else if (hdr->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ALAW)\n\t    {\n\t\tfmt_id = PJMEDIA_FORMAT_PCMA;\n\t    }\n\t    else if (hdr->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ULAW)\n\t    {\n\t\tfmt_id = PJMEDIA_FORMAT_PCMU;\n\t    }\n\t    else\n            {\n                PJ_LOG(4, (THIS_FILE, \"Unsupported audio stream\"));\n                continue;\n            }\n        }\n\n        if (nstr > 0) {\n            /* Create fport instance. */\n            fport[nstr] = create_avi_port(pool);\n            if (!fport[nstr]) {\n\t        status = PJ_ENOMEM;\n                goto on_error;\n            }\n\n            /* Open file. */\n            status = pj_file_open(pool, filename, PJ_O_RDONLY,\n                                  &fport[nstr]->fd);\n            if (status != PJ_SUCCESS)\n                goto on_error;\n\n            /* Set the file position */\n            status = pj_file_setpos(fport[nstr]->fd, pos, PJ_SEEK_SET);\n            if (status != PJ_SUCCESS) {\n                goto on_error;\n            }\n        }\n\n        fport[nstr]->stream_id = i;\n        fport[nstr]->fmt_id = fmt_id;\n\n        nstr++;\n    }\n\n    if (nstr == 0) {\n        status = PJMEDIA_EAVIUNSUPP;\n        goto on_error;\n    }\n\n    for (i = 0; i < nstr; i++) {\n        strl_hdr_t *strl_hdr = &avi_hdr.strl_hdr[fport[i]->stream_id];\n\n        /* Initialize */\n        fport[i]->options = options;\n        fport[i]->fsize = fport[0]->fsize;\n        /* Current file position now points to start of data */\n        fport[i]->start_data = pos;\n        \n        if (COMPARE_TAG(strl_hdr->data_type, PJMEDIA_AVI_VIDS_TAG)) {\n            strf_video_hdr_t *strf_hdr =\n                &avi_hdr.strf_hdr[fport[i]->stream_id].strf_video_hdr;\n            const pjmedia_video_format_info *vfi;\n\n            vfi = pjmedia_get_video_format_info(\n                pjmedia_video_format_mgr_instance(),\n                strl_hdr->codec);\n\n            fport[i]->bits_per_sample = (vfi ? vfi->bpp : 0);\n            fport[i]->usec_per_frame = avi_hdr.avih_hdr.usec_per_frame;\n            pjmedia_format_init_video(&fport[i]->base.info.fmt,\n                                      fport[i]->fmt_id,\n                                      strf_hdr->biWidth,\n                                      strf_hdr->biHeight,\n                                      strl_hdr->rate,\n                                      strl_hdr->scale);\n#if 0\n            /* The calculation below is wrong. strf_hdr->biSizeImage shows\n             * uncompressed size. Looks like we need to go the ugly way to\n             * get the bitrage:\n             *    http://www.virtualdub.org/blog/pivot/entry.php?id=159\n             */\n            bps = strf_hdr->biSizeImage * 8 * strl_hdr->rate / strl_hdr->scale;\n            if (bps==0) {\n        \t/* strf_hdr->biSizeImage may be zero for uncompressed RGB */\n        \tbps = strf_hdr->biWidth * strf_hdr->biHeight *\n        \t\tstrf_hdr->biBitCount *\n        \t\tstrl_hdr->rate / strl_hdr->scale;\n            }\n            fport[i]->base.info.fmt.det.vid.avg_bps = bps;\n            fport[i]->base.info.fmt.det.vid.max_bps = bps;\n#endif\n        } else {\n            strf_audio_hdr_t *strf_hdr =\n                &avi_hdr.strf_hdr[fport[i]->stream_id].strf_audio_hdr;\n\n            fport[i]->bits_per_sample = strf_hdr->bits_per_sample;\n            fport[i]->usec_per_frame = avi_hdr.avih_hdr.usec_per_frame;\n            pjmedia_format_init_audio(&fport[i]->base.info.fmt,\n                                      fport[i]->fmt_id,\n                                      strf_hdr->sample_rate,\n                                      strf_hdr->nchannels,\n                                      strf_hdr->bits_per_sample,\n                                      20000 /* fport[i]->usec_per_frame */,\n                                      strf_hdr->bytes_per_sec * 8,\n                                      strf_hdr->bytes_per_sec * 8);\n\n\t    /* Set format to PCM (we will decode PCMA/U) */\n\t    if (fport[i]->fmt_id == PJMEDIA_FORMAT_PCMA ||\n\t\tfport[i]->fmt_id == PJMEDIA_FORMAT_PCMU)\n\t    {\n\t\tfport[i]->base.info.fmt.id = PJMEDIA_FORMAT_PCM;\n\t\tfport[i]->base.info.fmt.det.aud.bits_per_sample = 16;\n\t    }\n\t}\n\n        pj_strdup2(pool, &fport[i]->base.info.name, filename);\n    }\n\n    /* Done. */\n    *p_streams = pj_pool_alloc(pool, sizeof(pjmedia_avi_streams));\n    (*p_streams)->num_streams = nstr;\n    (*p_streams)->streams = pj_pool_calloc(pool, (*p_streams)->num_streams,\n                                           sizeof(pjmedia_port *));\n    for (i = 0; i < nstr; i++)\n        (*p_streams)->streams[i] = &fport[i]->base;\n\n    PJ_LOG(4,(THIS_FILE, \n\t      \"AVI file player '%.*s' created with \"\n\t      \"%d media ports\",\n\t      (int)fport[0]->base.info.name.slen,\n\t      fport[0]->base.info.name.ptr,\n              (*p_streams)->num_streams));\n\n    return PJ_SUCCESS;\n\non_error:\n    fport[0]->base.on_destroy(&fport[0]->base);\n    for (i = 1; i < nstr; i++)\n        fport[i]->base.on_destroy(&fport[i]->base);\n    if (status == AVI_EOF)\n        return PJMEDIA_EINVALIMEDIATYPE;\n    return status;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -81,7 +81,7 @@\n     /* Read the headers of each stream. */\n     for (i = 0; i < avi_hdr.avih_hdr.num_streams; i++) {\n         pj_size_t elem = 0;\n-        pj_ssize_t size_to_read;\n+        pj_off_t size_to_read;\n \n         /* Read strl header */\n         status = file_read(fport[0]->fd, &avi_hdr.strl_hdr[i],\n@@ -134,6 +134,7 @@\n     do {\n         pjmedia_avi_subchunk ch;\n         int read = 0;\n+        pj_off_t size_to_read;\n \n         status = file_read(fport[0]->fd, &ch, sizeof(pjmedia_avi_subchunk));\n         if (status != PJ_SUCCESS) {\n@@ -148,7 +149,15 @@\n                 break;\n         }\n \n-        status = pj_file_setpos(fport[0]->fd, ch.len-read, PJ_SEEK_CUR);\n+        if (ch.len < read) {\n+            status = PJ_EINVAL;\n+            goto on_error;\n+        }\n+        PJ_CHECK_OVERFLOW_UINT32_TO_LONG(ch.len - read, \n+                                         status = PJ_EINVAL; goto on_error;);\n+        size_to_read = (pj_off_t)ch.len - read;\n+\n+        status = pj_file_setpos(fport[0]->fd, size_to_read, PJ_SEEK_CUR);\n         if (status != PJ_SUCCESS) {\n             goto on_error;\n         }",
        "diff_line_info": {
            "deleted_lines": [
                "        pj_ssize_t size_to_read;",
                "        status = pj_file_setpos(fport[0]->fd, ch.len-read, PJ_SEEK_CUR);"
            ],
            "added_lines": [
                "        pj_off_t size_to_read;",
                "        pj_off_t size_to_read;",
                "        if (ch.len < read) {",
                "            status = PJ_EINVAL;",
                "            goto on_error;",
                "        }",
                "        PJ_CHECK_OVERFLOW_UINT32_TO_LONG(ch.len - read, ",
                "                                         status = PJ_EINVAL; goto on_error;);",
                "        size_to_read = (pj_off_t)ch.len - read;",
                "",
                "        status = pj_file_setpos(fport[0]->fd, size_to_read, PJ_SEEK_CUR);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-24792",
        "func_name": "pjsip/pjproject/avi_get_frame",
        "description": "PJSIP is a free and open source multimedia communication library written in C. A denial-of-service vulnerability affects applications on a 32-bit systems that use PJSIP versions 2.12 and prior to play/read invalid WAV files. The vulnerability occurs when reading WAV file data chunks with length greater than 31-bit integers. The vulnerability does not affect 64-bit apps and should not affect apps that only plays trusted WAV files. A patch is available on the `master` branch of the `pjsip/project` GitHub repository. As a workaround, apps can reject a WAV file received from an unknown source or validate the file first.",
        "git_url": "https://github.com/pjsip/pjproject/commit/947bc1ee6d05be10204b918df75a503415fd3213",
        "commit_title": "Merge pull request from GHSA-rwgw-vwxg-q799",
        "commit_text": " * Prevent potential infinite loop when parsing WAV format file  * Check if subchunk is negative.  * Fix and add checks  * Change data type from pj_ssize_t to long.  * Modify check  * Fix leak file descriptor and modify check on wav_playlist  * Move overflow/underflow check to pj_file_setpos()  * Use macro to simplify check  * modification based on comments  * Remove unnecessary casting  * Modification based on comments",
        "func_before": "static pj_status_t avi_get_frame(pjmedia_port *this_port, \n\t\t\t         pjmedia_frame *frame)\n{\n    struct avi_reader_port *fport = (struct avi_reader_port*)this_port;\n    pj_status_t status = PJ_SUCCESS;\n    pj_ssize_t size_read = 0, size_to_read = 0;\n\n    pj_assert(fport->base.info.signature == SIGNATURE);\n\n    /* We encountered end of file */\n    if (fport->eof) {\n\tPJ_LOG(5,(THIS_FILE, \"File port %.*s EOF\",\n\t\t  (int)fport->base.info.name.slen,\n\t\t  fport->base.info.name.ptr));\n\n\t/* Call callback, if any */\n\tif (fport->cb2) {\n\t    pj_bool_t no_loop = (fport->options & PJMEDIA_AVI_FILE_NO_LOOP);\n\n\t    if (!fport->subscribed) {\n\t    \tstatus = pjmedia_event_subscribe(NULL, &file_on_event,\n\t    \t\t\t\t         fport, fport);\n\t    \tfport->subscribed = (status == PJ_SUCCESS)? PJ_TRUE:\n\t    \t\t\t    PJ_FALSE;\n\t    }\n\n\t    if (fport->subscribed && fport->eof != 2) {\n\t    \tpjmedia_event event;\n\n\t    \tif (no_loop) {\n\t    \t    /* To prevent the callback from being called repeatedly */\n\t    \t    fport->eof = 2;\n\t    \t} else {\n\t    \t    fport->eof = PJ_FALSE;\n        \t    pj_file_setpos(fport->fd, fport->start_data, PJ_SEEK_SET);\n\t    \t}\n\n\t    \tpjmedia_event_init(&event, PJMEDIA_EVENT_CALLBACK,\n\t                      \t   NULL, fport);\n\t    \tpjmedia_event_publish(NULL, fport, &event,\n\t                              PJMEDIA_EVENT_PUBLISH_POST_EVENT);\n\t    }\n\t    \n\t    /* Should not access player port after this since\n\t     * it might have been destroyed by the callback.\n\t     */\n\t    frame->type = PJMEDIA_FRAME_TYPE_NONE;\n\t    frame->size = 0;\n\t    \n\t    return (no_loop? PJ_EEOF: PJ_SUCCESS);\n\n\t} else if (fport->cb) {\n\t    status = (*fport->cb)(this_port, fport->base.port_data.pdata);\n\t}\n\n\t/* If callback returns non PJ_SUCCESS or 'no loop' is specified,\n\t * return immediately (and don't try to access player port since\n\t * it might have been destroyed by the callback).\n\t */\n\tif ((status != PJ_SUCCESS) ||\n            (fport->options & PJMEDIA_AVI_FILE_NO_LOOP)) \n        {\n\t    frame->type = PJMEDIA_FRAME_TYPE_NONE;\n\t    frame->size = 0;\n\t    return PJ_EEOF;\n\t}\n\n        /* Rewind file */\n\tPJ_LOG(5,(THIS_FILE, \"File port %.*s rewinding..\",\n\t\t  (int)fport->base.info.name.slen,\n\t\t  fport->base.info.name.ptr));\n\tfport->eof = PJ_FALSE;\n        pj_file_setpos(fport->fd, fport->start_data, PJ_SEEK_SET);\n    }\n\n    /* For PCMU/A audio stream, reduce frame size to half (temporarily). */\n    if (fport->base.info.fmt.type == PJMEDIA_TYPE_AUDIO &&\n\t(fport->fmt_id == PJMEDIA_FORMAT_PCMA ||\n\t fport->fmt_id == PJMEDIA_FORMAT_PCMU))\n    {\n\tframe->size >>= 1;\n    }\n\n    /* Fill frame buffer. */\n    size_to_read = frame->size;\n    do {\n        pjmedia_avi_subchunk ch = {0, 0};\n        char *cid;\n        unsigned stream_id;\n\n        /* We need to read data from the file past the chunk boundary */\n        if (fport->size_left > 0 && fport->size_left < size_to_read) {\n            status = file_read3(fport->fd, frame->buf, fport->size_left,\n                                fport->bits_per_sample, &size_read);\n            if (status != PJ_SUCCESS)\n                goto on_error2;\n            size_to_read -= fport->size_left;\n            fport->size_left = 0;\n        }\n\n        /* Read new chunk data */\n        if (fport->size_left == 0) {\n            pj_off_t pos;\n            pj_file_getpos(fport->fd, &pos);\n\n            /* Data is padded to the nearest WORD boundary */\n            if (fport->pad) {\n                status = pj_file_setpos(fport->fd, fport->pad, PJ_SEEK_CUR);\n                fport->pad = 0;\n            }\n\n            status = file_read(fport->fd, &ch, sizeof(pjmedia_avi_subchunk));\n            if (status != PJ_SUCCESS) {\n                size_read = 0;\n                goto on_error2;\n            }\n\n            cid = (char *)&ch.id;\n            if (cid[0] >= '0' && cid[0] <= '9' &&\n                cid[1] >= '0' && cid[1] <= '9') \n            {\n                stream_id = (cid[0] - '0') * 10 + (cid[1] - '0');\n            } else\n                stream_id = 100;\n            fport->pad = (pj_uint8_t)ch.len & 1;\n\n            TRACE_((THIS_FILE, \"Reading movi data at pos %u (%x), id: %.*s, \"\n                               \"length: %u\", (unsigned long)pos,\n                               (unsigned long)pos, 4, cid, ch.len));\n\n            /* We are only interested in data with our stream id */\n            if (stream_id != fport->stream_id) {\n                if (COMPARE_TAG(ch.id, PJMEDIA_AVI_LIST_TAG))\n                    PJ_LOG(5, (THIS_FILE, \"Unsupported LIST tag found in \"\n                                          \"the movi data.\"));\n                else if (COMPARE_TAG(ch.id, PJMEDIA_AVI_RIFF_TAG)) {\n                    PJ_LOG(3, (THIS_FILE, \"Unsupported format: multiple \"\n                           \"AVIs in a single file.\"));\n                    status = AVI_EOF;\n                    goto on_error2;\n                }\n\n                status = pj_file_setpos(fport->fd, ch.len,\n                                        PJ_SEEK_CUR);\n                continue;\n            }\n            fport->size_left = ch.len;\n        }\n\n        frame->type = (fport->base.info.fmt.type == PJMEDIA_TYPE_VIDEO ?\n                       PJMEDIA_FRAME_TYPE_VIDEO : PJMEDIA_FRAME_TYPE_AUDIO);\n\n        if (frame->type == PJMEDIA_FRAME_TYPE_AUDIO) {\n            if (size_to_read > fport->size_left)\n                size_to_read = fport->size_left;\n            status = file_read3(fport->fd, (char *)frame->buf + frame->size -\n                                size_to_read, size_to_read,\n                                fport->bits_per_sample, &size_read);\n            if (status != PJ_SUCCESS)\n                goto on_error2;\n            fport->size_left -= size_to_read;\n        } else {\n            pj_assert(frame->size >= ch.len);\n            status = file_read3(fport->fd, frame->buf, ch.len,\n                                0, &size_read);\n            if (status != PJ_SUCCESS)\n                goto on_error2;\n            frame->size = ch.len;\n            fport->size_left = 0;\n        }\n\n        break;\n\n    } while(1);\n    frame->timestamp.u64 = fport->next_ts.u64;\n    if (frame->type == PJMEDIA_FRAME_TYPE_AUDIO) {\n\n\t/* Decode PCMU/A frame */\n\tif (fport->fmt_id == PJMEDIA_FORMAT_PCMA ||\n\t    fport->fmt_id == PJMEDIA_FORMAT_PCMU)\n\t{\n\t    unsigned i;\n\t    pj_uint16_t *dst;\n\t    pj_uint8_t *src;\n\n\t    dst = (pj_uint16_t*)frame->buf + frame->size - 1;\n\t    src = (pj_uint8_t*)frame->buf + frame->size - 1;\n\n\t    if (fport->fmt_id == PJMEDIA_FORMAT_PCMU) {\n\t\tfor (i = 0; i < frame->size; ++i) {\n\t\t    *dst-- = (pj_uint16_t) pjmedia_ulaw2linear(*src--);\n\t\t}\n\t    } else {\n\t\tfor (i = 0; i < frame->size; ++i) {\n\t\t    *dst-- = (pj_uint16_t) pjmedia_alaw2linear(*src--);\n\t\t}\n\t    }\n\n\t    /* Return back the frame size */\n\t    frame->size <<= 1;\n\t}\n\n\tif (fport->usec_per_frame) {\n\t    fport->next_ts.u64 += (fport->usec_per_frame *\n\t\t\t\t   fport->base.info.fmt.det.aud.clock_rate /\n\t\t\t\t   1000000);\n\t} else {\n\t    fport->next_ts.u64 += (frame->size *\n\t\t\t\t   fport->base.info.fmt.det.aud.clock_rate /\n\t\t\t\t   (fport->base.info.fmt.det.aud.avg_bps / 8));\n\t}\n    } else {\n\tif (fport->usec_per_frame) {\n\t    fport->next_ts.u64 += (fport->usec_per_frame * VIDEO_CLOCK_RATE /\n\t\t\t\t   1000000);\n\t} else {\n\t    fport->next_ts.u64 += (frame->size * VIDEO_CLOCK_RATE /\n\t\t\t\t   (fport->base.info.fmt.det.vid.avg_bps / 8));\n\t}\n    }\n\n    return PJ_SUCCESS;\n\non_error2:\n    if (status == AVI_EOF) {\n        fport->eof = PJ_TRUE;\n\n        size_to_read -= size_read;\n        if (size_to_read == (pj_ssize_t)frame->size) {\n            /* Frame is empty */\n \t    frame->type = PJMEDIA_FRAME_TYPE_NONE;\n\t    frame->size = 0;\n\t    return PJ_EEOF;           \n        }\n        pj_bzero((char *)frame->buf + frame->size - size_to_read,\n                 size_to_read);\n\n        return PJ_SUCCESS;\n    }\n\n    return status;\n}",
        "func": "static pj_status_t avi_get_frame(pjmedia_port *this_port, \n\t\t\t         pjmedia_frame *frame)\n{\n    struct avi_reader_port *fport = (struct avi_reader_port*)this_port;\n    pj_status_t status = PJ_SUCCESS;\n    pj_ssize_t size_read = 0, size_to_read = 0;\n\n    pj_assert(fport->base.info.signature == SIGNATURE);\n\n    /* We encountered end of file */\n    if (fport->eof) {\n\tPJ_LOG(5,(THIS_FILE, \"File port %.*s EOF\",\n\t\t  (int)fport->base.info.name.slen,\n\t\t  fport->base.info.name.ptr));\n\n\t/* Call callback, if any */\n\tif (fport->cb2) {\n\t    pj_bool_t no_loop = (fport->options & PJMEDIA_AVI_FILE_NO_LOOP);\n\n\t    if (!fport->subscribed) {\n\t    \tstatus = pjmedia_event_subscribe(NULL, &file_on_event,\n\t    \t\t\t\t         fport, fport);\n\t    \tfport->subscribed = (status == PJ_SUCCESS)? PJ_TRUE:\n\t    \t\t\t    PJ_FALSE;\n\t    }\n\n\t    if (fport->subscribed && fport->eof != 2) {\n\t    \tpjmedia_event event;\n\n\t    \tif (no_loop) {\n\t    \t    /* To prevent the callback from being called repeatedly */\n\t    \t    fport->eof = 2;\n\t    \t} else {\n\t    \t    fport->eof = PJ_FALSE;\n        \t    pj_file_setpos(fport->fd, fport->start_data, PJ_SEEK_SET);\n\t    \t}\n\n\t    \tpjmedia_event_init(&event, PJMEDIA_EVENT_CALLBACK,\n\t                      \t   NULL, fport);\n\t    \tpjmedia_event_publish(NULL, fport, &event,\n\t                              PJMEDIA_EVENT_PUBLISH_POST_EVENT);\n\t    }\n\t    \n\t    /* Should not access player port after this since\n\t     * it might have been destroyed by the callback.\n\t     */\n\t    frame->type = PJMEDIA_FRAME_TYPE_NONE;\n\t    frame->size = 0;\n\t    \n\t    return (no_loop? PJ_EEOF: PJ_SUCCESS);\n\n\t} else if (fport->cb) {\n\t    status = (*fport->cb)(this_port, fport->base.port_data.pdata);\n\t}\n\n\t/* If callback returns non PJ_SUCCESS or 'no loop' is specified,\n\t * return immediately (and don't try to access player port since\n\t * it might have been destroyed by the callback).\n\t */\n\tif ((status != PJ_SUCCESS) ||\n            (fport->options & PJMEDIA_AVI_FILE_NO_LOOP)) \n        {\n\t    frame->type = PJMEDIA_FRAME_TYPE_NONE;\n\t    frame->size = 0;\n\t    return PJ_EEOF;\n\t}\n\n        /* Rewind file */\n\tPJ_LOG(5,(THIS_FILE, \"File port %.*s rewinding..\",\n\t\t  (int)fport->base.info.name.slen,\n\t\t  fport->base.info.name.ptr));\n\tfport->eof = PJ_FALSE;\n        pj_file_setpos(fport->fd, fport->start_data, PJ_SEEK_SET);\n    }\n\n    /* For PCMU/A audio stream, reduce frame size to half (temporarily). */\n    if (fport->base.info.fmt.type == PJMEDIA_TYPE_AUDIO &&\n\t(fport->fmt_id == PJMEDIA_FORMAT_PCMA ||\n\t fport->fmt_id == PJMEDIA_FORMAT_PCMU))\n    {\n\tframe->size >>= 1;\n    }\n\n    /* Fill frame buffer. */\n    size_to_read = frame->size;\n    do {\n        pjmedia_avi_subchunk ch = {0, 0};\n        char *cid;\n        unsigned stream_id;\n\n        /* We need to read data from the file past the chunk boundary */\n        if (fport->size_left > 0 && fport->size_left < size_to_read) {\n            status = file_read3(fport->fd, frame->buf, fport->size_left,\n                                fport->bits_per_sample, &size_read);\n            if (status != PJ_SUCCESS)\n                goto on_error2;\n            size_to_read -= fport->size_left;\n            fport->size_left = 0;\n        }\n\n        /* Read new chunk data */\n        if (fport->size_left == 0) {\n            pj_off_t pos;\n            pj_off_t ch_len;\n\n            pj_file_getpos(fport->fd, &pos);\n\n            /* Data is padded to the nearest WORD boundary */\n            if (fport->pad) {\n                status = pj_file_setpos(fport->fd, fport->pad, PJ_SEEK_CUR);\n                fport->pad = 0;\n            }\n\n            status = file_read(fport->fd, &ch, sizeof(pjmedia_avi_subchunk));\n            if (status != PJ_SUCCESS) {\n                size_read = 0;\n                goto on_error2;\n            }\n            \n            PJ_CHECK_OVERFLOW_UINT32_TO_LONG(ch.len, \n                                         status = PJ_EINVAL;  goto on_error2;);\n            ch_len = ch.len;\n\n            cid = (char *)&ch.id;\n            if (cid[0] >= '0' && cid[0] <= '9' &&\n                cid[1] >= '0' && cid[1] <= '9') \n            {\n                stream_id = (cid[0] - '0') * 10 + (cid[1] - '0');\n            } else\n                stream_id = 100;\n            fport->pad = (pj_uint8_t)ch.len & 1;\n\n            TRACE_((THIS_FILE, \"Reading movi data at pos %u (%x), id: %.*s, \"\n                               \"length: %u\", (unsigned long)pos,\n                               (unsigned long)pos, 4, cid, ch.len));\n\n            /* We are only interested in data with our stream id */\n            if (stream_id != fport->stream_id) {\n                if (COMPARE_TAG(ch.id, PJMEDIA_AVI_LIST_TAG))\n                    PJ_LOG(5, (THIS_FILE, \"Unsupported LIST tag found in \"\n                                          \"the movi data.\"));\n                else if (COMPARE_TAG(ch.id, PJMEDIA_AVI_RIFF_TAG)) {\n                    PJ_LOG(3, (THIS_FILE, \"Unsupported format: multiple \"\n                           \"AVIs in a single file.\"));\n                    status = AVI_EOF;\n                    goto on_error2;\n                }\n\n                status = pj_file_setpos(fport->fd, ch_len, PJ_SEEK_CUR);\n                continue;\n            }\n            fport->size_left = ch.len;\n        }\n\n        frame->type = (fport->base.info.fmt.type == PJMEDIA_TYPE_VIDEO ?\n                       PJMEDIA_FRAME_TYPE_VIDEO : PJMEDIA_FRAME_TYPE_AUDIO);\n\n        if (frame->type == PJMEDIA_FRAME_TYPE_AUDIO) {\n            if (size_to_read > fport->size_left)\n                size_to_read = fport->size_left;\n            status = file_read3(fport->fd, (char *)frame->buf + frame->size -\n                                size_to_read, size_to_read,\n                                fport->bits_per_sample, &size_read);\n            if (status != PJ_SUCCESS)\n                goto on_error2;\n            fport->size_left -= size_to_read;\n        } else {\n            pj_assert(frame->size >= ch.len);\n            status = file_read3(fport->fd, frame->buf, ch.len,\n                                0, &size_read);\n            if (status != PJ_SUCCESS)\n                goto on_error2;\n            frame->size = ch.len;\n            fport->size_left = 0;\n        }\n\n        break;\n\n    } while(1);\n    frame->timestamp.u64 = fport->next_ts.u64;\n    if (frame->type == PJMEDIA_FRAME_TYPE_AUDIO) {\n\n\t/* Decode PCMU/A frame */\n\tif (fport->fmt_id == PJMEDIA_FORMAT_PCMA ||\n\t    fport->fmt_id == PJMEDIA_FORMAT_PCMU)\n\t{\n\t    unsigned i;\n\t    pj_uint16_t *dst;\n\t    pj_uint8_t *src;\n\n\t    dst = (pj_uint16_t*)frame->buf + frame->size - 1;\n\t    src = (pj_uint8_t*)frame->buf + frame->size - 1;\n\n\t    if (fport->fmt_id == PJMEDIA_FORMAT_PCMU) {\n\t\tfor (i = 0; i < frame->size; ++i) {\n\t\t    *dst-- = (pj_uint16_t) pjmedia_ulaw2linear(*src--);\n\t\t}\n\t    } else {\n\t\tfor (i = 0; i < frame->size; ++i) {\n\t\t    *dst-- = (pj_uint16_t) pjmedia_alaw2linear(*src--);\n\t\t}\n\t    }\n\n\t    /* Return back the frame size */\n\t    frame->size <<= 1;\n\t}\n\n\tif (fport->usec_per_frame) {\n\t    fport->next_ts.u64 += (fport->usec_per_frame *\n\t\t\t\t   fport->base.info.fmt.det.aud.clock_rate /\n\t\t\t\t   1000000);\n\t} else {\n\t    fport->next_ts.u64 += (frame->size *\n\t\t\t\t   fport->base.info.fmt.det.aud.clock_rate /\n\t\t\t\t   (fport->base.info.fmt.det.aud.avg_bps / 8));\n\t}\n    } else {\n\tif (fport->usec_per_frame) {\n\t    fport->next_ts.u64 += (fport->usec_per_frame * VIDEO_CLOCK_RATE /\n\t\t\t\t   1000000);\n\t} else {\n\t    fport->next_ts.u64 += (frame->size * VIDEO_CLOCK_RATE /\n\t\t\t\t   (fport->base.info.fmt.det.vid.avg_bps / 8));\n\t}\n    }\n\n    return PJ_SUCCESS;\n\non_error2:\n    if (status == AVI_EOF) {\n        fport->eof = PJ_TRUE;\n\n        size_to_read -= size_read;\n        if (size_to_read == (pj_ssize_t)frame->size) {\n            /* Frame is empty */\n \t    frame->type = PJMEDIA_FRAME_TYPE_NONE;\n\t    frame->size = 0;\n\t    return PJ_EEOF;           \n        }\n        pj_bzero((char *)frame->buf + frame->size - size_to_read,\n                 size_to_read);\n\n        return PJ_SUCCESS;\n    }\n\n    return status;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -101,6 +101,8 @@\n         /* Read new chunk data */\n         if (fport->size_left == 0) {\n             pj_off_t pos;\n+            pj_off_t ch_len;\n+\n             pj_file_getpos(fport->fd, &pos);\n \n             /* Data is padded to the nearest WORD boundary */\n@@ -114,6 +116,10 @@\n                 size_read = 0;\n                 goto on_error2;\n             }\n+            \n+            PJ_CHECK_OVERFLOW_UINT32_TO_LONG(ch.len, \n+                                         status = PJ_EINVAL;  goto on_error2;);\n+            ch_len = ch.len;\n \n             cid = (char *)&ch.id;\n             if (cid[0] >= '0' && cid[0] <= '9' &&\n@@ -140,8 +146,7 @@\n                     goto on_error2;\n                 }\n \n-                status = pj_file_setpos(fport->fd, ch.len,\n-                                        PJ_SEEK_CUR);\n+                status = pj_file_setpos(fport->fd, ch_len, PJ_SEEK_CUR);\n                 continue;\n             }\n             fport->size_left = ch.len;",
        "diff_line_info": {
            "deleted_lines": [
                "                status = pj_file_setpos(fport->fd, ch.len,",
                "                                        PJ_SEEK_CUR);"
            ],
            "added_lines": [
                "            pj_off_t ch_len;",
                "",
                "            ",
                "            PJ_CHECK_OVERFLOW_UINT32_TO_LONG(ch.len, ",
                "                                         status = PJ_EINVAL;  goto on_error2;);",
                "            ch_len = ch.len;",
                "                status = pj_file_setpos(fport->fd, ch_len, PJ_SEEK_CUR);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-24792",
        "func_name": "pjsip/pjproject/pjmedia_wav_playlist_create",
        "description": "PJSIP is a free and open source multimedia communication library written in C. A denial-of-service vulnerability affects applications on a 32-bit systems that use PJSIP versions 2.12 and prior to play/read invalid WAV files. The vulnerability occurs when reading WAV file data chunks with length greater than 31-bit integers. The vulnerability does not affect 64-bit apps and should not affect apps that only plays trusted WAV files. A patch is available on the `master` branch of the `pjsip/project` GitHub repository. As a workaround, apps can reject a WAV file received from an unknown source or validate the file first.",
        "git_url": "https://github.com/pjsip/pjproject/commit/947bc1ee6d05be10204b918df75a503415fd3213",
        "commit_title": "Merge pull request from GHSA-rwgw-vwxg-q799",
        "commit_text": " * Prevent potential infinite loop when parsing WAV format file  * Check if subchunk is negative.  * Fix and add checks  * Change data type from pj_ssize_t to long.  * Modify check  * Fix leak file descriptor and modify check on wav_playlist  * Move overflow/underflow check to pj_file_setpos()  * Use macro to simplify check  * modification based on comments  * Remove unnecessary casting  * Modification based on comments",
        "func_before": "PJ_DEF(pj_status_t) pjmedia_wav_playlist_create(pj_pool_t *pool,\n\t\t\t\t\t\tconst pj_str_t *port_label,\n\t\t\t\t\t\tconst pj_str_t file_list[],\n\t\t\t\t\t\tint file_count,\n\t\t\t\t\t\tunsigned ptime,\n\t\t\t\t\t\tunsigned options,\n\t\t\t\t\t\tpj_ssize_t buff_size,\n\t\t\t\t\t\tpjmedia_port **p_port)\n{\n    struct playlist_port *fport;\n    pjmedia_audio_format_detail *afd;\n    pj_off_t pos;\n    pj_status_t status;\n    int index;\n    pj_bool_t has_wave_info = PJ_FALSE;\n    pj_str_t tmp_port_label;\n    char filename[PJ_MAXPATH];\t/* filename for open operations.    */\n\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(pool && file_list && file_count && p_port, PJ_EINVAL);\n\n    /* Normalize port_label */\n    if (port_label == NULL || port_label->slen == 0) {\n\ttmp_port_label = pj_str(\"WAV playlist\");\n\tport_label = &tmp_port_label;\n    }\n\n    /* Be sure all files exist\t*/\n    for (index=0; index<file_count; index++) {\n\n\tPJ_ASSERT_RETURN(file_list[index].slen >= 0, PJ_ETOOSMALL);\n\tif (file_list[index].slen >= PJ_MAXPATH)\n\t    return PJ_ENAMETOOLONG;\n\n\tpj_memcpy(filename, file_list[index].ptr, file_list[index].slen);\n\tfilename[file_list[index].slen] = '\\0';\n\n    \t/* Check the file really exists. */\n    \tif (!pj_file_exists(filename)) {\n\t    PJ_LOG(4,(THIS_FILE,\n\t\t      \"WAV playlist error: file '%s' not found\",\n\t      \t      filename));\n\t    return PJ_ENOTFOUND;\n    \t}\n    }\n\n    /* Normalize ptime */\n    if (ptime == 0)\n\tptime = 20;\n\n    /* Create fport instance. */\n    fport = create_file_list_port(pool, port_label);\n    if (!fport) {\n\treturn PJ_ENOMEM;\n    }\n\n    afd = pjmedia_format_get_audio_format_detail(&fport->base.info.fmt, 1);\n\n    /* start with the first file. */\n    fport->current_file = 0;\n    fport->max_file = file_count;\n\n    /* Create file descriptor list */\n    fport->fd_list = (pj_oshandle_t*)\n\t\t     pj_pool_zalloc(pool, sizeof(pj_oshandle_t)*file_count);\n    if (!fport->fd_list) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Create file size list */\n    fport->fsize_list = (pj_off_t*)\n\t\t\tpj_pool_alloc(pool, sizeof(pj_off_t)*file_count);\n    if (!fport->fsize_list) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Create start of WAVE data list */\n    fport->start_data_list = (unsigned*)\n\t\t\t     pj_pool_alloc(pool, sizeof(unsigned)*file_count);\n    if (!fport->start_data_list) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Create data len list */\n    fport->data_len_list = (unsigned*)\n\t\t\t     pj_pool_alloc(pool, sizeof(unsigned)*file_count);\n    if (!fport->data_len_list) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Create data left list */\n    fport->data_left_list = (unsigned*)\n\t\t\t     pj_pool_alloc(pool, sizeof(unsigned)*file_count);\n    if (!fport->data_left_list) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Create file position list */\n    fport->fpos_list = (pj_off_t*)\n\t\t       pj_pool_alloc(pool, sizeof(pj_off_t)*file_count);\n    if (!fport->fpos_list) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Create file buffer once for this operation.\n     */\n    if (buff_size < 1) buff_size = PJMEDIA_FILE_PORT_BUFSIZE;\n    fport->bufsize = (pj_uint32_t)buff_size;\n\n\n    /* Create buffer. */\n    fport->buf = (char*) pj_pool_alloc(pool, fport->bufsize);\n    if (!fport->buf) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Initialize port */\n    fport->options = options;\n    fport->readpos = fport->buf;\n\n\n    /* ok run this for all files to be sure all are good for playback. */\n    for (index=file_count-1; index>=0; index--) {\n\n\tpjmedia_wave_hdr wavehdr;\n\tpj_ssize_t size_to_read, size_read;\n\n\t/* we end with the last one so we are good to go if still in function*/\n\tpj_memcpy(filename, file_list[index].ptr, file_list[index].slen);\n\tfilename[file_list[index].slen] = '\\0';\n\n\t/* Get the file size. */\n\tfport->current_file = index;\n\tfport->fsize_list[index] = pj_file_size(filename);\n\t\n\t/* Size must be more than WAVE header size */\n\tif (fport->fsize_list[index] <= sizeof(pjmedia_wave_hdr)) {\n\t    status = PJMEDIA_ENOTVALIDWAVE;\n\t    goto on_error;\n\t}\n\t\n\t/* Open file. */\n\tstatus = pj_file_open( pool, filename, PJ_O_RDONLY, \n\t\t\t       &fport->fd_list[index]);\n\tif (status != PJ_SUCCESS)\n\t    goto on_error;\n\t\n\t/* Read the file header plus fmt header only. */\n\tsize_read = size_to_read = sizeof(wavehdr) - 8;\n\tstatus = pj_file_read( fport->fd_list[index], &wavehdr, &size_read);\n\tif (status != PJ_SUCCESS) {\n\t    goto on_error;\n\t}\n\n\tif (size_read != size_to_read) {\n\t    status = PJMEDIA_ENOTVALIDWAVE;\n\t    goto on_error;\n\t}\n\t\n\t/* Normalize WAVE header fields values from little-endian to host\n\t * byte order.\n\t */\n\tpjmedia_wave_hdr_file_to_host(&wavehdr);\n\t\n\t/* Validate WAVE file. */\n\tif (wavehdr.riff_hdr.riff != PJMEDIA_RIFF_TAG ||\n\t    wavehdr.riff_hdr.wave != PJMEDIA_WAVE_TAG ||\n\t    wavehdr.fmt_hdr.fmt != PJMEDIA_FMT_TAG)\n\t{\n\t    TRACE_((THIS_FILE,\n\t\t\"actual value|expected riff=%x|%x, wave=%x|%x fmt=%x|%x\",\n\t\twavehdr.riff_hdr.riff, PJMEDIA_RIFF_TAG,\n\t\twavehdr.riff_hdr.wave, PJMEDIA_WAVE_TAG,\n\t\twavehdr.fmt_hdr.fmt, PJMEDIA_FMT_TAG));\n\t    status = PJMEDIA_ENOTVALIDWAVE;\n\t    goto on_error;\n\t}\n\t\n\t/* Must be PCM with 16bits per sample */\n\tif (wavehdr.fmt_hdr.fmt_tag != 1 ||\n\t    wavehdr.fmt_hdr.bits_per_sample != 16)\n\t{\n\t    status = PJMEDIA_EWAVEUNSUPP;\n\t    goto on_error;\n\t}\n\t\n\t/* Block align must be 2*nchannels */\n\tif (wavehdr.fmt_hdr.block_align != \n\t\twavehdr.fmt_hdr.nchan * BYTES_PER_SAMPLE)\n\t{\n\t    status = PJMEDIA_EWAVEUNSUPP;\n\t    goto on_error;\n\t}\n\t\n\t/* If length of fmt_header is greater than 16, skip the remaining\n\t * fmt header data.\n\t */\n\tif (wavehdr.fmt_hdr.len > 16) {\n\t    size_to_read = wavehdr.fmt_hdr.len - 16;\n\t    status = pj_file_setpos(fport->fd_list[index], size_to_read, \n\t\t\t\t    PJ_SEEK_CUR);\n\t    if (status != PJ_SUCCESS) {\n\t\tgoto on_error;\n\t    }\n\t}\n\t\n\t/* Repeat reading the WAVE file until we have 'data' chunk */\n\tfor (;;) {\n\t    pjmedia_wave_subchunk subchunk;\n\t    size_read = 8;\n\t    status = pj_file_read(fport->fd_list[index], &subchunk, \n\t\t\t\t  &size_read);\n\t    if (status != PJ_SUCCESS || size_read != 8) {\n\t\tstatus = PJMEDIA_EWAVETOOSHORT;\n\t\tgoto on_error;\n\t    }\n\t    \n\t    /* Normalize endianness */\n\t    PJMEDIA_WAVE_NORMALIZE_SUBCHUNK(&subchunk);\n\t    \n\t    /* Break if this is \"data\" chunk */\n\t    if (subchunk.id == PJMEDIA_DATA_TAG) {\n\t\twavehdr.data_hdr.data = PJMEDIA_DATA_TAG;\n\t\twavehdr.data_hdr.len = subchunk.len;\n\t\tbreak;\n\t    }\n\t    \n\t    /* Otherwise skip the chunk contents */\n\t    size_to_read = subchunk.len;\n\t    status = pj_file_setpos(fport->fd_list[index], size_to_read, \n\t\t\t\t    PJ_SEEK_CUR);\n\t    if (status != PJ_SUCCESS) {\n\t\tgoto on_error;\n\t    }\n\t}\n\t\n\t/* Current file position now points to start of data */\n\tstatus = pj_file_getpos(fport->fd_list[index], &pos);\n\tfport->start_data_list[index] = (unsigned)pos;\n\tfport->data_len_list[index] = wavehdr.data_hdr.len;\n\tfport->data_left_list[index] = wavehdr.data_hdr.len;\n\t\n\t/* Validate length. */\n\tif (wavehdr.data_hdr.len > fport->fsize_list[index] - \n\t\t\t\t       fport->start_data_list[index]) \n\t{\n\t    status = PJMEDIA_EWAVEUNSUPP;\n\t    goto on_error;\n\t}\n\tif (wavehdr.data_hdr.len < ptime * wavehdr.fmt_hdr.sample_rate *\n\t\t\t\t    wavehdr.fmt_hdr.nchan / 1000)\n\t{\n\t    status = PJMEDIA_EWAVETOOSHORT;\n\t    goto on_error;\n\t}\n\t\n\t/* It seems like we have a valid WAVE file. */\n\t\n\t/* Update port info if we don't have one, otherwise check\n\t * that the WAV file has the same attributes as previous files. \n\t */\n\tif (!has_wave_info) {\n\t    afd->channel_count = wavehdr.fmt_hdr.nchan;\n\t    afd->clock_rate = wavehdr.fmt_hdr.sample_rate;\n\t    afd->bits_per_sample = wavehdr.fmt_hdr.bits_per_sample;\n\t    afd->frame_time_usec = ptime * 1000;\n\t    afd->avg_bps = afd->max_bps = afd->clock_rate *\n\t\t\t\t\t  afd->channel_count *\n\t\t\t\t\t  afd->bits_per_sample;\n\n\t    has_wave_info = PJ_TRUE;\n\n\t} else {\n\n\t    /* Check that this file has the same characteristics as the other\n\t     * files.\n\t     */\n\t    if (wavehdr.fmt_hdr.nchan != afd->channel_count ||\n\t\twavehdr.fmt_hdr.sample_rate != afd->clock_rate ||\n\t\twavehdr.fmt_hdr.bits_per_sample != afd->bits_per_sample)\n\t    {\n\t\t/* This file has different characteristics than the other \n\t\t * files. \n\t\t */\n\t\tPJ_LOG(4,(THIS_FILE,\n\t\t          \"WAV playlist error: file '%s' has differrent number\"\n\t\t\t  \" of channels, sample rate, or bits per sample\",\n\t      \t\t  filename));\n\t\tstatus = PJMEDIA_EWAVEUNSUPP;\n\t\tgoto on_error;\n\t    }\n\n\t}\n\n\t/* If file is shorter than buffer size, adjust buffer size to file\n\t * size. Otherwise EOF callback will be called multiple times when\n\t * file_fill_buffer() is called.\n\t */\n\tif (wavehdr.data_hdr.len < (unsigned)buff_size)\n\t    buff_size = wavehdr.data_hdr.len;\n\n\t/* Create file buffer.\n\t */\n\tfport->bufsize = (pj_uint32_t)buff_size;\t\n\t\n\t/* Set initial position of the file. */\n\tfport->fpos_list[index] = fport->start_data_list[index];\n    }\n\n    /* Fill up the buffer. */\n    status = file_fill_buffer(fport);\n    if (status != PJ_SUCCESS) {\n\tgoto on_error;\n    }\n    \n    /* Done. */\n    \n    *p_port = &fport->base;\n    \n    PJ_LOG(4,(THIS_FILE,\n\t     \"WAV playlist '%.*s' created: samp.rate=%d, ch=%d, bufsize=%uKB\",\n\t     (int)port_label->slen,\n\t     port_label->ptr,\n\t     afd->clock_rate,\n\t     afd->channel_count,\n\t     fport->bufsize / 1000));\n    \n    return PJ_SUCCESS;\n\non_error:\n    for (index=0; index<file_count; ++index) {\n\tif (fport->fd_list[index] != 0)\n\t    pj_file_close(fport->fd_list[index]);\n    }\n\n    return status;\n}",
        "func": "PJ_DEF(pj_status_t) pjmedia_wav_playlist_create(pj_pool_t *pool,\n\t\t\t\t\t\tconst pj_str_t *port_label,\n\t\t\t\t\t\tconst pj_str_t file_list[],\n\t\t\t\t\t\tint file_count,\n\t\t\t\t\t\tunsigned ptime,\n\t\t\t\t\t\tunsigned options,\n\t\t\t\t\t\tpj_ssize_t buff_size,\n\t\t\t\t\t\tpjmedia_port **p_port)\n{\n    struct playlist_port *fport;\n    pjmedia_audio_format_detail *afd;\n    pj_off_t pos;\n    pj_status_t status;\n    int index;\n    pj_bool_t has_wave_info = PJ_FALSE;\n    pj_str_t tmp_port_label;\n    char filename[PJ_MAXPATH];\t/* filename for open operations.    */\n\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(pool && file_list && file_count && p_port, PJ_EINVAL);\n\n    /* Normalize port_label */\n    if (port_label == NULL || port_label->slen == 0) {\n\ttmp_port_label = pj_str(\"WAV playlist\");\n\tport_label = &tmp_port_label;\n    }\n\n    /* Be sure all files exist\t*/\n    for (index=0; index<file_count; index++) {\n\n\tPJ_ASSERT_RETURN(file_list[index].slen >= 0, PJ_ETOOSMALL);\n\tif (file_list[index].slen >= PJ_MAXPATH)\n\t    return PJ_ENAMETOOLONG;\n\n\tpj_memcpy(filename, file_list[index].ptr, file_list[index].slen);\n\tfilename[file_list[index].slen] = '\\0';\n\n    \t/* Check the file really exists. */\n    \tif (!pj_file_exists(filename)) {\n\t    PJ_LOG(4,(THIS_FILE,\n\t\t      \"WAV playlist error: file '%s' not found\",\n\t      \t      filename));\n\t    return PJ_ENOTFOUND;\n    \t}\n    }\n\n    /* Normalize ptime */\n    if (ptime == 0)\n\tptime = 20;\n\n    /* Create fport instance. */\n    fport = create_file_list_port(pool, port_label);\n    if (!fport) {\n\treturn PJ_ENOMEM;\n    }\n\n    afd = pjmedia_format_get_audio_format_detail(&fport->base.info.fmt, 1);\n\n    /* start with the first file. */\n    fport->current_file = 0;\n    fport->max_file = file_count;\n\n    /* Create file descriptor list */\n    fport->fd_list = (pj_oshandle_t*)\n\t\t     pj_pool_zalloc(pool, sizeof(pj_oshandle_t)*file_count);\n    if (!fport->fd_list) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Create file size list */\n    fport->fsize_list = (pj_off_t*)\n\t\t\tpj_pool_alloc(pool, sizeof(pj_off_t)*file_count);\n    if (!fport->fsize_list) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Create start of WAVE data list */\n    fport->start_data_list = (unsigned*)\n\t\t\t     pj_pool_alloc(pool, sizeof(unsigned)*file_count);\n    if (!fport->start_data_list) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Create data len list */\n    fport->data_len_list = (unsigned*)\n\t\t\t     pj_pool_alloc(pool, sizeof(unsigned)*file_count);\n    if (!fport->data_len_list) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Create data left list */\n    fport->data_left_list = (unsigned*)\n\t\t\t     pj_pool_alloc(pool, sizeof(unsigned)*file_count);\n    if (!fport->data_left_list) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Create file position list */\n    fport->fpos_list = (pj_off_t*)\n\t\t       pj_pool_alloc(pool, sizeof(pj_off_t)*file_count);\n    if (!fport->fpos_list) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Create file buffer once for this operation.\n     */\n    if (buff_size < 1) buff_size = PJMEDIA_FILE_PORT_BUFSIZE;\n    fport->bufsize = (pj_uint32_t)buff_size;\n\n\n    /* Create buffer. */\n    fport->buf = (char*) pj_pool_alloc(pool, fport->bufsize);\n    if (!fport->buf) {\n\treturn PJ_ENOMEM;\n    }\n\n    /* Initialize port */\n    fport->options = options;\n    fport->readpos = fport->buf;\n\n\n    /* ok run this for all files to be sure all are good for playback. */\n    for (index=file_count-1; index>=0; index--) {\n\n\tpjmedia_wave_hdr wavehdr;\n\tpj_ssize_t size_read;\n\tpj_off_t size_to_read;\n\n\t/* we end with the last one so we are good to go if still in function*/\n\tpj_memcpy(filename, file_list[index].ptr, file_list[index].slen);\n\tfilename[file_list[index].slen] = '\\0';\n\n\t/* Get the file size. */\n\tfport->current_file = index;\n\tfport->fsize_list[index] = pj_file_size(filename);\n\t\n\t/* Size must be more than WAVE header size */\n\tif (fport->fsize_list[index] <= sizeof(pjmedia_wave_hdr)) {\n\t    status = PJMEDIA_ENOTVALIDWAVE;\n\t    goto on_error;\n\t}\n\t\n\t/* Open file. */\n\tstatus = pj_file_open( pool, filename, PJ_O_RDONLY, \n\t\t\t       &fport->fd_list[index]);\n\tif (status != PJ_SUCCESS)\n\t    goto on_error;\n\t\n\t/* Read the file header plus fmt header only. */\n\tsize_to_read = size_read = sizeof(wavehdr) - 8;\t\n\tstatus = pj_file_read( fport->fd_list[index], &wavehdr, &size_read);\n\tif (status != PJ_SUCCESS) {\n\t    goto on_error;\n\t}\n\n\tif (size_read != size_to_read) {\n\t    status = PJMEDIA_ENOTVALIDWAVE;\n\t    goto on_error;\n\t}\n\t\n\t/* Normalize WAVE header fields values from little-endian to host\n\t * byte order.\n\t */\n\tpjmedia_wave_hdr_file_to_host(&wavehdr);\n\t\n\t/* Validate WAVE file. */\n\tif (wavehdr.riff_hdr.riff != PJMEDIA_RIFF_TAG ||\n\t    wavehdr.riff_hdr.wave != PJMEDIA_WAVE_TAG ||\n\t    wavehdr.fmt_hdr.fmt != PJMEDIA_FMT_TAG)\n\t{\n\t    TRACE_((THIS_FILE,\n\t\t\"actual value|expected riff=%x|%x, wave=%x|%x fmt=%x|%x\",\n\t\twavehdr.riff_hdr.riff, PJMEDIA_RIFF_TAG,\n\t\twavehdr.riff_hdr.wave, PJMEDIA_WAVE_TAG,\n\t\twavehdr.fmt_hdr.fmt, PJMEDIA_FMT_TAG));\n\t    status = PJMEDIA_ENOTVALIDWAVE;\n\t    goto on_error;\n\t}\n\t\n\t/* Must be PCM with 16bits per sample */\n\tif (wavehdr.fmt_hdr.fmt_tag != 1 ||\n\t    wavehdr.fmt_hdr.bits_per_sample != 16)\n\t{\n\t    status = PJMEDIA_EWAVEUNSUPP;\n\t    goto on_error;\n\t}\n\t\n\t/* Block align must be 2*nchannels */\n\tif (wavehdr.fmt_hdr.block_align != \n\t\twavehdr.fmt_hdr.nchan * BYTES_PER_SAMPLE)\n\t{\n\t    status = PJMEDIA_EWAVEUNSUPP;\n\t    goto on_error;\n\t}\n\t\n\t/* If length of fmt_header is greater than 16, skip the remaining\n\t * fmt header data.\n\t */\n\tif (wavehdr.fmt_hdr.len > 16) {\n\t    PJ_CHECK_OVERFLOW_UINT32_TO_LONG(wavehdr.fmt_hdr.len-16,\n\t\t\t       status = PJMEDIA_ENOTVALIDWAVE; goto on_error;);\n\t    size_to_read = (pj_off_t)wavehdr.fmt_hdr.len - 16;\n\t    status = pj_file_setpos(fport->fd_list[index], size_to_read, \n\t\t\t\t    PJ_SEEK_CUR);\n\t    if (status != PJ_SUCCESS) {\n\t\tgoto on_error;\n\t    }\n\t}\n\t\n\t/* Repeat reading the WAVE file until we have 'data' chunk */\n\tfor (;;) {\n\t    pjmedia_wave_subchunk subchunk;\n\t    size_read = 8;\n\t    status = pj_file_read(fport->fd_list[index], &subchunk, \n\t\t\t\t  &size_read);\n\t    if (status != PJ_SUCCESS || size_read != 8) {\n\t\tstatus = PJMEDIA_EWAVETOOSHORT;\n\t\tgoto on_error;\n\t    }\n\t    \n\t    /* Normalize endianness */\n\t    PJMEDIA_WAVE_NORMALIZE_SUBCHUNK(&subchunk);\n\t    \n\t    /* Break if this is \"data\" chunk */\n\t    if (subchunk.id == PJMEDIA_DATA_TAG) {\n\t\twavehdr.data_hdr.data = PJMEDIA_DATA_TAG;\n\t\twavehdr.data_hdr.len = subchunk.len;\n\t\tbreak;\n\t    }\n\t    \n\t    /* Otherwise skip the chunk contents */\n\t    PJ_CHECK_OVERFLOW_UINT32_TO_LONG(subchunk.len, \n\t\t\t       status = PJMEDIA_ENOTVALIDWAVE; goto on_error;);\n\t    size_to_read = subchunk.len;\n\n\t    status = pj_file_setpos(fport->fd_list[index], size_to_read, \n\t\t\t\t    PJ_SEEK_CUR);\n\t    if (status != PJ_SUCCESS) {\n\t\tgoto on_error;\n\t    }\n\t}\n\t\n\t/* Current file position now points to start of data */\n\tstatus = pj_file_getpos(fport->fd_list[index], &pos);\n\tfport->start_data_list[index] = (unsigned)pos;\n\tfport->data_len_list[index] = wavehdr.data_hdr.len;\n\tfport->data_left_list[index] = wavehdr.data_hdr.len;\n\t\n\t/* Validate length. */\n\tif (wavehdr.data_hdr.len > fport->fsize_list[index] - \n\t\t\t\t       fport->start_data_list[index]) \n\t{\n\t    status = PJMEDIA_EWAVEUNSUPP;\n\t    goto on_error;\n\t}\n\tif (wavehdr.data_hdr.len < ptime * wavehdr.fmt_hdr.sample_rate *\n\t\t\t\t    wavehdr.fmt_hdr.nchan / 1000)\n\t{\n\t    status = PJMEDIA_EWAVETOOSHORT;\n\t    goto on_error;\n\t}\n\t\n\t/* It seems like we have a valid WAVE file. */\n\t\n\t/* Update port info if we don't have one, otherwise check\n\t * that the WAV file has the same attributes as previous files. \n\t */\n\tif (!has_wave_info) {\n\t    afd->channel_count = wavehdr.fmt_hdr.nchan;\n\t    afd->clock_rate = wavehdr.fmt_hdr.sample_rate;\n\t    afd->bits_per_sample = wavehdr.fmt_hdr.bits_per_sample;\n\t    afd->frame_time_usec = ptime * 1000;\n\t    afd->avg_bps = afd->max_bps = afd->clock_rate *\n\t\t\t\t\t  afd->channel_count *\n\t\t\t\t\t  afd->bits_per_sample;\n\n\t    has_wave_info = PJ_TRUE;\n\n\t} else {\n\n\t    /* Check that this file has the same characteristics as the other\n\t     * files.\n\t     */\n\t    if (wavehdr.fmt_hdr.nchan != afd->channel_count ||\n\t\twavehdr.fmt_hdr.sample_rate != afd->clock_rate ||\n\t\twavehdr.fmt_hdr.bits_per_sample != afd->bits_per_sample)\n\t    {\n\t\t/* This file has different characteristics than the other \n\t\t * files. \n\t\t */\n\t\tPJ_LOG(4,(THIS_FILE,\n\t\t          \"WAV playlist error: file '%s' has differrent number\"\n\t\t\t  \" of channels, sample rate, or bits per sample\",\n\t      \t\t  filename));\n\t\tstatus = PJMEDIA_EWAVEUNSUPP;\n\t\tgoto on_error;\n\t    }\n\n\t}\n\n\t/* If file is shorter than buffer size, adjust buffer size to file\n\t * size. Otherwise EOF callback will be called multiple times when\n\t * file_fill_buffer() is called.\n\t */\n\tif (wavehdr.data_hdr.len < (unsigned)buff_size)\n\t    buff_size = wavehdr.data_hdr.len;\n\n\t/* Create file buffer.\n\t */\n\tfport->bufsize = (pj_uint32_t)buff_size;\t\n\t\n\t/* Set initial position of the file. */\n\tfport->fpos_list[index] = fport->start_data_list[index];\n    }\n\n    /* Fill up the buffer. */\n    status = file_fill_buffer(fport);\n    if (status != PJ_SUCCESS) {\n\tgoto on_error;\n    }\n    \n    /* Done. */\n    \n    *p_port = &fport->base;\n    \n    PJ_LOG(4,(THIS_FILE,\n\t     \"WAV playlist '%.*s' created: samp.rate=%d, ch=%d, bufsize=%uKB\",\n\t     (int)port_label->slen,\n\t     port_label->ptr,\n\t     afd->clock_rate,\n\t     afd->channel_count,\n\t     fport->bufsize / 1000));\n    \n    return PJ_SUCCESS;\n\non_error:\n    for (index=0; index<file_count; ++index) {\n\tif (fport->fd_list[index] != 0)\n\t    pj_file_close(fport->fd_list[index]);\n    }\n\n    return status;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -124,7 +124,8 @@\n     for (index=file_count-1; index>=0; index--) {\n \n \tpjmedia_wave_hdr wavehdr;\n-\tpj_ssize_t size_to_read, size_read;\n+\tpj_ssize_t size_read;\n+\tpj_off_t size_to_read;\n \n \t/* we end with the last one so we are good to go if still in function*/\n \tpj_memcpy(filename, file_list[index].ptr, file_list[index].slen);\n@@ -147,7 +148,7 @@\n \t    goto on_error;\n \t\n \t/* Read the file header plus fmt header only. */\n-\tsize_read = size_to_read = sizeof(wavehdr) - 8;\n+\tsize_to_read = size_read = sizeof(wavehdr) - 8;\t\n \tstatus = pj_file_read( fport->fd_list[index], &wavehdr, &size_read);\n \tif (status != PJ_SUCCESS) {\n \t    goto on_error;\n@@ -197,7 +198,9 @@\n \t * fmt header data.\n \t */\n \tif (wavehdr.fmt_hdr.len > 16) {\n-\t    size_to_read = wavehdr.fmt_hdr.len - 16;\n+\t    PJ_CHECK_OVERFLOW_UINT32_TO_LONG(wavehdr.fmt_hdr.len-16,\n+\t\t\t       status = PJMEDIA_ENOTVALIDWAVE; goto on_error;);\n+\t    size_to_read = (pj_off_t)wavehdr.fmt_hdr.len - 16;\n \t    status = pj_file_setpos(fport->fd_list[index], size_to_read, \n \t\t\t\t    PJ_SEEK_CUR);\n \t    if (status != PJ_SUCCESS) {\n@@ -227,7 +230,10 @@\n \t    }\n \t    \n \t    /* Otherwise skip the chunk contents */\n+\t    PJ_CHECK_OVERFLOW_UINT32_TO_LONG(subchunk.len, \n+\t\t\t       status = PJMEDIA_ENOTVALIDWAVE; goto on_error;);\n \t    size_to_read = subchunk.len;\n+\n \t    status = pj_file_setpos(fport->fd_list[index], size_to_read, \n \t\t\t\t    PJ_SEEK_CUR);\n \t    if (status != PJ_SUCCESS) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tpj_ssize_t size_to_read, size_read;",
                "\tsize_read = size_to_read = sizeof(wavehdr) - 8;",
                "\t    size_to_read = wavehdr.fmt_hdr.len - 16;"
            ],
            "added_lines": [
                "\tpj_ssize_t size_read;",
                "\tpj_off_t size_to_read;",
                "\tsize_to_read = size_read = sizeof(wavehdr) - 8;\t",
                "\t    PJ_CHECK_OVERFLOW_UINT32_TO_LONG(wavehdr.fmt_hdr.len-16,",
                "\t\t\t       status = PJMEDIA_ENOTVALIDWAVE; goto on_error;);",
                "\t    size_to_read = (pj_off_t)wavehdr.fmt_hdr.len - 16;",
                "\t    PJ_CHECK_OVERFLOW_UINT32_TO_LONG(subchunk.len, ",
                "\t\t\t       status = PJMEDIA_ENOTVALIDWAVE; goto on_error;);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-24792",
        "func_name": "pjsip/pjproject/pjmedia_wav_player_port_create",
        "description": "PJSIP is a free and open source multimedia communication library written in C. A denial-of-service vulnerability affects applications on a 32-bit systems that use PJSIP versions 2.12 and prior to play/read invalid WAV files. The vulnerability occurs when reading WAV file data chunks with length greater than 31-bit integers. The vulnerability does not affect 64-bit apps and should not affect apps that only plays trusted WAV files. A patch is available on the `master` branch of the `pjsip/project` GitHub repository. As a workaround, apps can reject a WAV file received from an unknown source or validate the file first.",
        "git_url": "https://github.com/pjsip/pjproject/commit/947bc1ee6d05be10204b918df75a503415fd3213",
        "commit_title": "Merge pull request from GHSA-rwgw-vwxg-q799",
        "commit_text": " * Prevent potential infinite loop when parsing WAV format file  * Check if subchunk is negative.  * Fix and add checks  * Change data type from pj_ssize_t to long.  * Modify check  * Fix leak file descriptor and modify check on wav_playlist  * Move overflow/underflow check to pj_file_setpos()  * Use macro to simplify check  * modification based on comments  * Remove unnecessary casting  * Modification based on comments",
        "func_before": "PJ_DEF(pj_status_t) pjmedia_wav_player_port_create( pj_pool_t *pool,\n\t\t\t\t\t\t     const char *filename,\n\t\t\t\t\t\t     unsigned ptime,\n\t\t\t\t\t\t     unsigned options,\n\t\t\t\t\t\t     pj_ssize_t buff_size,\n\t\t\t\t\t\t     pjmedia_port **p_port )\n{\n    pjmedia_wave_hdr wave_hdr;\n    pj_ssize_t size_to_read, size_read;\n    struct file_reader_port *fport;\n    pjmedia_audio_format_detail *ad;\n    pj_off_t pos;\n    pj_str_t name;\n    unsigned samples_per_frame;\n    pj_status_t status = PJ_SUCCESS;\n\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(pool && filename && p_port, PJ_EINVAL);\n\n    /* Check the file really exists. */\n    if (!pj_file_exists(filename)) {\n\treturn PJ_ENOTFOUND;\n    }\n\n    /* Normalize ptime */\n    if (ptime == 0)\n\tptime = 20;\n\n    /* Normalize buff_size */\n    if (buff_size < 1) buff_size = PJMEDIA_FILE_PORT_BUFSIZE;\n\n\n    /* Create fport instance. */\n    fport = create_file_port(pool);\n    if (!fport) {\n\treturn PJ_ENOMEM;\n    }\n\n\n    /* Get the file size. */\n    fport->fsize = pj_file_size(filename);\n\n    /* Size must be more than WAVE header size */\n    if (fport->fsize <= sizeof(pjmedia_wave_hdr)) {\n\treturn PJMEDIA_ENOTVALIDWAVE;\n    }\n\n    /* Open file. */\n    status = pj_file_open( pool, filename, PJ_O_RDONLY, &fport->fd);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Read the file header plus fmt header only. */\n    size_read = size_to_read = sizeof(wave_hdr) - 8;\n    status = pj_file_read( fport->fd, &wave_hdr, &size_read);\n    if (status != PJ_SUCCESS) {\n\tpj_file_close(fport->fd);\n\treturn status;\n    }\n    if (size_read != size_to_read) {\n\tpj_file_close(fport->fd);\n\treturn PJMEDIA_ENOTVALIDWAVE;\n    }\n\n    /* Normalize WAVE header fields values from little-endian to host\n     * byte order.\n     */\n    pjmedia_wave_hdr_file_to_host(&wave_hdr);\n    \n    /* Validate WAVE file. */\n    if (wave_hdr.riff_hdr.riff != PJMEDIA_RIFF_TAG ||\n\twave_hdr.riff_hdr.wave != PJMEDIA_WAVE_TAG ||\n\twave_hdr.fmt_hdr.fmt != PJMEDIA_FMT_TAG)\n    {\n\tpj_file_close(fport->fd);\n\tTRACE_((THIS_FILE, \n\t\t\"actual value|expected riff=%x|%x, wave=%x|%x fmt=%x|%x\",\n\t\twave_hdr.riff_hdr.riff, PJMEDIA_RIFF_TAG,\n\t\twave_hdr.riff_hdr.wave, PJMEDIA_WAVE_TAG,\n\t\twave_hdr.fmt_hdr.fmt, PJMEDIA_FMT_TAG));\n\treturn PJMEDIA_ENOTVALIDWAVE;\n    }\n\n    /* Validate format and its attributes (i.e: bits per sample, block align) */\n    switch (wave_hdr.fmt_hdr.fmt_tag) {\n    case PJMEDIA_WAVE_FMT_TAG_PCM:\n\tif (wave_hdr.fmt_hdr.bits_per_sample != 16 || \n\t    wave_hdr.fmt_hdr.block_align != 2 * wave_hdr.fmt_hdr.nchan)\n\t    status = PJMEDIA_EWAVEUNSUPP;\n\tbreak;\n\n    case PJMEDIA_WAVE_FMT_TAG_ALAW:\n    case PJMEDIA_WAVE_FMT_TAG_ULAW:\n\tif (wave_hdr.fmt_hdr.bits_per_sample != 8 ||\n\t    wave_hdr.fmt_hdr.block_align != wave_hdr.fmt_hdr.nchan)\n\t    status = PJMEDIA_ENOTVALIDWAVE;\n\tbreak;\n\n    default:\n\tstatus = PJMEDIA_EWAVEUNSUPP;\n\tbreak;\n    }\n\n    if (status != PJ_SUCCESS) {\n\tpj_file_close(fport->fd);\n\treturn status;\n    }\n\n    fport->fmt_tag = (pjmedia_wave_fmt_tag)wave_hdr.fmt_hdr.fmt_tag;\n    fport->bytes_per_sample = (pj_uint16_t) \n\t\t\t      (wave_hdr.fmt_hdr.bits_per_sample / 8);\n\n    /* If length of fmt_header is greater than 16, skip the remaining\n     * fmt header data.\n     */\n    if (wave_hdr.fmt_hdr.len > 16) {\n\tsize_to_read = wave_hdr.fmt_hdr.len - 16;\n\tstatus = pj_file_setpos(fport->fd, size_to_read, PJ_SEEK_CUR);\n\tif (status != PJ_SUCCESS) {\n\t    pj_file_close(fport->fd);\n\t    return status;\n\t}\n    }\n\n    /* Repeat reading the WAVE file until we have 'data' chunk */\n    for (;;) {\n\tpjmedia_wave_subchunk subchunk;\n\tsize_read = 8;\n\tstatus = pj_file_read(fport->fd, &subchunk, &size_read);\n\tif (status != PJ_SUCCESS || size_read != 8) {\n\t    pj_file_close(fport->fd);\n\t    return PJMEDIA_EWAVETOOSHORT;\n\t}\n\n\t/* Normalize endianness */\n\tPJMEDIA_WAVE_NORMALIZE_SUBCHUNK(&subchunk);\n\n\t/* Break if this is \"data\" chunk */\n\tif (subchunk.id == PJMEDIA_DATA_TAG) {\n\t    wave_hdr.data_hdr.data = PJMEDIA_DATA_TAG;\n\t    wave_hdr.data_hdr.len = subchunk.len;\n\t    break;\n\t}\n\n\t/* Otherwise skip the chunk contents */\n\tsize_to_read = subchunk.len;\n\tstatus = pj_file_setpos(fport->fd, size_to_read, PJ_SEEK_CUR);\n\tif (status != PJ_SUCCESS) {\n\t    pj_file_close(fport->fd);\n\t    return status;\n\t}\n    }\n\n    /* Current file position now points to start of data */\n    status = pj_file_getpos(fport->fd, &pos);\n    fport->start_data = (unsigned)pos;\n    fport->data_len = wave_hdr.data_hdr.len;\n    fport->data_left = wave_hdr.data_hdr.len;\n\n    /* Validate length. */\n    if (wave_hdr.data_hdr.len > fport->fsize - fport->start_data) {\n    \t/* Actual data length may be shorter than declared. We should still\n    \t * try to play whatever data is there instead of immediately returning\n    \t * error.\n    \t */\n    \twave_hdr.data_hdr.len = (pj_uint32_t)fport->fsize - fport->start_data;\n\t// pj_file_close(fport->fd);\n\t// return PJMEDIA_EWAVEUNSUPP;\n    }\n    if (wave_hdr.data_hdr.len < ptime * wave_hdr.fmt_hdr.sample_rate *\n\t\t\t\twave_hdr.fmt_hdr.nchan / 1000)\n    {\n\tpj_file_close(fport->fd);\n\treturn PJMEDIA_EWAVETOOSHORT;\n    }\n\n    /* It seems like we have a valid WAVE file. */\n\n    /* Initialize */\n    fport->options = options;\n\n    /* Update port info. */\n    ad = pjmedia_format_get_audio_format_detail(&fport->base.info.fmt, 1);\n    pj_strdup2(pool, &name, filename);\n    samples_per_frame = ptime * wave_hdr.fmt_hdr.sample_rate *\n\t\t        wave_hdr.fmt_hdr.nchan / 1000;\n    pjmedia_port_info_init(&fport->base.info, &name, SIGNATURE,\n\t\t\t   wave_hdr.fmt_hdr.sample_rate,\n\t\t\t   wave_hdr.fmt_hdr.nchan,\n\t\t\t   BITS_PER_SAMPLE,\n\t\t\t   samples_per_frame);\n\n    /* If file is shorter than buffer size, adjust buffer size to file\n     * size. Otherwise EOF callback will be called multiple times when\n     * fill_buffer() is called.\n     */\n    if (wave_hdr.data_hdr.len < (unsigned)buff_size)\n\tbuff_size = wave_hdr.data_hdr.len;\n\n    /* Create file buffer.\n     */\n    fport->bufsize = (pj_uint32_t)buff_size;\n\n\n    /* samples_per_frame must be smaller than bufsize (because get_frame()\n     * doesn't handle this case).\n     */\n    if (samples_per_frame * fport->bytes_per_sample >= fport->bufsize) {\n\tpj_file_close(fport->fd);\n\treturn PJ_EINVAL;\n    }\n\n    /* Create buffer. */\n    fport->buf = (char*) pj_pool_alloc(pool, fport->bufsize);\n    if (!fport->buf) {\n\tpj_file_close(fport->fd);\n\treturn PJ_ENOMEM;\n    }\n \n    fport->readpos = fport->buf;\n\n    /* Set initial position of the file. */\n    fport->fpos = fport->start_data;\n\n    /* Fill up the buffer. */\n    status = fill_buffer(fport);\n    if (status != PJ_SUCCESS) {\n\tpj_file_close(fport->fd);\n\treturn status;\n    }\n\n    /* Done. */\n\n    *p_port = &fport->base;\n\n\n    PJ_LOG(4,(THIS_FILE, \n\t      \"File player '%.*s' created: samp.rate=%d, ch=%d, bufsize=%uKB, \"\n\t      \"filesize=%luKB\",\n\t      (int)fport->base.info.name.slen,\n\t      fport->base.info.name.ptr,\n\t      ad->clock_rate,\n\t      ad->channel_count,\n\t      fport->bufsize / 1000,\n\t      (unsigned long)(fport->fsize / 1000)));\n\n    return PJ_SUCCESS;\n}",
        "func": "PJ_DEF(pj_status_t) pjmedia_wav_player_port_create( pj_pool_t *pool,\n\t\t\t\t\t\t     const char *filename,\n\t\t\t\t\t\t     unsigned ptime,\n\t\t\t\t\t\t     unsigned options,\n\t\t\t\t\t\t     pj_ssize_t buff_size,\n\t\t\t\t\t\t     pjmedia_port **p_port )\n{\n    pjmedia_wave_hdr wave_hdr;\n    pj_ssize_t size_read;\n    pj_off_t size_to_read;\n    struct file_reader_port *fport;\n    pjmedia_audio_format_detail *ad;\n    pj_off_t pos;\n    pj_str_t name;\n    unsigned samples_per_frame;\n    pj_status_t status = PJ_SUCCESS;\n\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(pool && filename && p_port, PJ_EINVAL);\n\n    /* Check the file really exists. */\n    if (!pj_file_exists(filename)) {\n\treturn PJ_ENOTFOUND;\n    }\n\n    /* Normalize ptime */\n    if (ptime == 0)\n\tptime = 20;\n\n    /* Normalize buff_size */\n    if (buff_size < 1) buff_size = PJMEDIA_FILE_PORT_BUFSIZE;\n\n\n    /* Create fport instance. */\n    fport = create_file_port(pool);\n    if (!fport) {\n\treturn PJ_ENOMEM;\n    }\n\n\n    /* Get the file size. */\n    fport->fsize = pj_file_size(filename);\n\n    /* Size must be more than WAVE header size */\n    if (fport->fsize <= sizeof(pjmedia_wave_hdr)) {\n\treturn PJMEDIA_ENOTVALIDWAVE;\n    }\n\n    /* Open file. */\n    status = pj_file_open( pool, filename, PJ_O_RDONLY, &fport->fd);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Read the file header plus fmt header only. */\n    size_to_read = size_read = sizeof(wave_hdr) - 8;\n    status = pj_file_read( fport->fd, &wave_hdr, &size_read);\n    if (status != PJ_SUCCESS) {\n\tpj_file_close(fport->fd);\n\treturn status;\n    }\n    if (size_read != size_to_read) {\n\tpj_file_close(fport->fd);\n\treturn PJMEDIA_ENOTVALIDWAVE;\n    }\n\n    /* Normalize WAVE header fields values from little-endian to host\n     * byte order.\n     */\n    pjmedia_wave_hdr_file_to_host(&wave_hdr);\n    \n    /* Validate WAVE file. */\n    if (wave_hdr.riff_hdr.riff != PJMEDIA_RIFF_TAG ||\n\twave_hdr.riff_hdr.wave != PJMEDIA_WAVE_TAG ||\n\twave_hdr.fmt_hdr.fmt != PJMEDIA_FMT_TAG)\n    {\n\tpj_file_close(fport->fd);\n\tTRACE_((THIS_FILE, \n\t\t\"actual value|expected riff=%x|%x, wave=%x|%x fmt=%x|%x\",\n\t\twave_hdr.riff_hdr.riff, PJMEDIA_RIFF_TAG,\n\t\twave_hdr.riff_hdr.wave, PJMEDIA_WAVE_TAG,\n\t\twave_hdr.fmt_hdr.fmt, PJMEDIA_FMT_TAG));\n\treturn PJMEDIA_ENOTVALIDWAVE;\n    }\n\n    /* Validate format and its attributes (i.e: bits per sample, block align) */\n    switch (wave_hdr.fmt_hdr.fmt_tag) {\n    case PJMEDIA_WAVE_FMT_TAG_PCM:\n\tif (wave_hdr.fmt_hdr.bits_per_sample != 16 || \n\t    wave_hdr.fmt_hdr.block_align != 2 * wave_hdr.fmt_hdr.nchan)\n\t    status = PJMEDIA_EWAVEUNSUPP;\n\tbreak;\n\n    case PJMEDIA_WAVE_FMT_TAG_ALAW:\n    case PJMEDIA_WAVE_FMT_TAG_ULAW:\n\tif (wave_hdr.fmt_hdr.bits_per_sample != 8 ||\n\t    wave_hdr.fmt_hdr.block_align != wave_hdr.fmt_hdr.nchan)\n\t    status = PJMEDIA_ENOTVALIDWAVE;\n\tbreak;\n\n    default:\n\tstatus = PJMEDIA_EWAVEUNSUPP;\n\tbreak;\n    }\n\n    if (status != PJ_SUCCESS) {\n\tpj_file_close(fport->fd);\n\treturn status;\n    }\n\n    fport->fmt_tag = (pjmedia_wave_fmt_tag)wave_hdr.fmt_hdr.fmt_tag;\n    fport->bytes_per_sample = (pj_uint16_t) \n\t\t\t      (wave_hdr.fmt_hdr.bits_per_sample / 8);\n\n    /* If length of fmt_header is greater than 16, skip the remaining\n     * fmt header data.\n     */\n    if (wave_hdr.fmt_hdr.len > 16) {\n\tPJ_CHECK_OVERFLOW_UINT32_TO_LONG(wave_hdr.fmt_hdr.len - 16,\n\t\t      pj_file_close(fport->fd); return PJMEDIA_ENOTVALIDWAVE;);\n\tsize_to_read = (pj_off_t)wave_hdr.fmt_hdr.len - 16;\n\tstatus = pj_file_setpos(fport->fd, size_to_read, PJ_SEEK_CUR);\n\tif (status != PJ_SUCCESS) {\n\t    pj_file_close(fport->fd);\n\t    return status;\n\t}\n    }\n\n    /* Repeat reading the WAVE file until we have 'data' chunk */\n    for (;;) {\n\tpjmedia_wave_subchunk subchunk;\n\tsize_read = 8;\n\tstatus = pj_file_read(fport->fd, &subchunk, &size_read);\n\tif (status != PJ_SUCCESS || size_read != 8) {\n\t    pj_file_close(fport->fd);\n\t    return PJMEDIA_EWAVETOOSHORT;\n\t}\n\n\t/* Normalize endianness */\n\tPJMEDIA_WAVE_NORMALIZE_SUBCHUNK(&subchunk);\n\n\t/* Break if this is \"data\" chunk */\n\tif (subchunk.id == PJMEDIA_DATA_TAG) {\n\t    wave_hdr.data_hdr.data = PJMEDIA_DATA_TAG;\n\t    wave_hdr.data_hdr.len = subchunk.len;\n\t    break;\n\t}\n\n\t/* Otherwise skip the chunk contents */\n\tPJ_CHECK_OVERFLOW_UINT32_TO_LONG(subchunk.len, \n\t\t      pj_file_close(fport->fd); return PJMEDIA_ENOTVALIDWAVE;);\n\tsize_to_read = subchunk.len;\n\n\tstatus = pj_file_setpos(fport->fd, size_to_read, PJ_SEEK_CUR);\n\tif (status != PJ_SUCCESS) {\n\t    pj_file_close(fport->fd);\n\t    return status;\n\t}\n    }\n\n    /* Current file position now points to start of data */\n    status = pj_file_getpos(fport->fd, &pos);\n    fport->start_data = (unsigned)pos;\n    fport->data_len = wave_hdr.data_hdr.len;\n    fport->data_left = wave_hdr.data_hdr.len;\n\n    /* Validate length. */\n    if (wave_hdr.data_hdr.len > fport->fsize - fport->start_data) {\n    \t/* Actual data length may be shorter than declared. We should still\n    \t * try to play whatever data is there instead of immediately returning\n    \t * error.\n    \t */\n    \twave_hdr.data_hdr.len = (pj_uint32_t)fport->fsize - fport->start_data;\n\t// pj_file_close(fport->fd);\n\t// return PJMEDIA_EWAVEUNSUPP;\n    }\n    if (wave_hdr.data_hdr.len < ptime * wave_hdr.fmt_hdr.sample_rate *\n\t\t\t\twave_hdr.fmt_hdr.nchan / 1000)\n    {\n\tpj_file_close(fport->fd);\n\treturn PJMEDIA_EWAVETOOSHORT;\n    }\n\n    /* It seems like we have a valid WAVE file. */\n\n    /* Initialize */\n    fport->options = options;\n\n    /* Update port info. */\n    ad = pjmedia_format_get_audio_format_detail(&fport->base.info.fmt, 1);\n    pj_strdup2(pool, &name, filename);\n    samples_per_frame = ptime * wave_hdr.fmt_hdr.sample_rate *\n\t\t        wave_hdr.fmt_hdr.nchan / 1000;\n    pjmedia_port_info_init(&fport->base.info, &name, SIGNATURE,\n\t\t\t   wave_hdr.fmt_hdr.sample_rate,\n\t\t\t   wave_hdr.fmt_hdr.nchan,\n\t\t\t   BITS_PER_SAMPLE,\n\t\t\t   samples_per_frame);\n\n    /* If file is shorter than buffer size, adjust buffer size to file\n     * size. Otherwise EOF callback will be called multiple times when\n     * fill_buffer() is called.\n     */\n    if (wave_hdr.data_hdr.len < (unsigned)buff_size)\n\tbuff_size = wave_hdr.data_hdr.len;\n\n    /* Create file buffer.\n     */\n    fport->bufsize = (pj_uint32_t)buff_size;\n\n\n    /* samples_per_frame must be smaller than bufsize (because get_frame()\n     * doesn't handle this case).\n     */\n    if (samples_per_frame * fport->bytes_per_sample >= fport->bufsize) {\n\tpj_file_close(fport->fd);\n\treturn PJ_EINVAL;\n    }\n\n    /* Create buffer. */\n    fport->buf = (char*) pj_pool_alloc(pool, fport->bufsize);\n    if (!fport->buf) {\n\tpj_file_close(fport->fd);\n\treturn PJ_ENOMEM;\n    }\n \n    fport->readpos = fport->buf;\n\n    /* Set initial position of the file. */\n    fport->fpos = fport->start_data;\n\n    /* Fill up the buffer. */\n    status = fill_buffer(fport);\n    if (status != PJ_SUCCESS) {\n\tpj_file_close(fport->fd);\n\treturn status;\n    }\n\n    /* Done. */\n\n    *p_port = &fport->base;\n\n\n    PJ_LOG(4,(THIS_FILE, \n\t      \"File player '%.*s' created: samp.rate=%d, ch=%d, bufsize=%uKB, \"\n\t      \"filesize=%luKB\",\n\t      (int)fport->base.info.name.slen,\n\t      fport->base.info.name.ptr,\n\t      ad->clock_rate,\n\t      ad->channel_count,\n\t      fport->bufsize / 1000,\n\t      (unsigned long)(fport->fsize / 1000)));\n\n    return PJ_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,8 @@\n \t\t\t\t\t\t     pjmedia_port **p_port )\n {\n     pjmedia_wave_hdr wave_hdr;\n-    pj_ssize_t size_to_read, size_read;\n+    pj_ssize_t size_read;\n+    pj_off_t size_to_read;\n     struct file_reader_port *fport;\n     pjmedia_audio_format_detail *ad;\n     pj_off_t pos;\n@@ -52,7 +53,7 @@\n \treturn status;\n \n     /* Read the file header plus fmt header only. */\n-    size_read = size_to_read = sizeof(wave_hdr) - 8;\n+    size_to_read = size_read = sizeof(wave_hdr) - 8;\n     status = pj_file_read( fport->fd, &wave_hdr, &size_read);\n     if (status != PJ_SUCCESS) {\n \tpj_file_close(fport->fd);\n@@ -115,7 +116,9 @@\n      * fmt header data.\n      */\n     if (wave_hdr.fmt_hdr.len > 16) {\n-\tsize_to_read = wave_hdr.fmt_hdr.len - 16;\n+\tPJ_CHECK_OVERFLOW_UINT32_TO_LONG(wave_hdr.fmt_hdr.len - 16,\n+\t\t      pj_file_close(fport->fd); return PJMEDIA_ENOTVALIDWAVE;);\n+\tsize_to_read = (pj_off_t)wave_hdr.fmt_hdr.len - 16;\n \tstatus = pj_file_setpos(fport->fd, size_to_read, PJ_SEEK_CUR);\n \tif (status != PJ_SUCCESS) {\n \t    pj_file_close(fport->fd);\n@@ -144,7 +147,10 @@\n \t}\n \n \t/* Otherwise skip the chunk contents */\n+\tPJ_CHECK_OVERFLOW_UINT32_TO_LONG(subchunk.len, \n+\t\t      pj_file_close(fport->fd); return PJMEDIA_ENOTVALIDWAVE;);\n \tsize_to_read = subchunk.len;\n+\n \tstatus = pj_file_setpos(fport->fd, size_to_read, PJ_SEEK_CUR);\n \tif (status != PJ_SUCCESS) {\n \t    pj_file_close(fport->fd);",
        "diff_line_info": {
            "deleted_lines": [
                "    pj_ssize_t size_to_read, size_read;",
                "    size_read = size_to_read = sizeof(wave_hdr) - 8;",
                "\tsize_to_read = wave_hdr.fmt_hdr.len - 16;"
            ],
            "added_lines": [
                "    pj_ssize_t size_read;",
                "    pj_off_t size_to_read;",
                "    size_to_read = size_read = sizeof(wave_hdr) - 8;",
                "\tPJ_CHECK_OVERFLOW_UINT32_TO_LONG(wave_hdr.fmt_hdr.len - 16,",
                "\t\t      pj_file_close(fport->fd); return PJMEDIA_ENOTVALIDWAVE;);",
                "\tsize_to_read = (pj_off_t)wave_hdr.fmt_hdr.len - 16;",
                "\tPJ_CHECK_OVERFLOW_UINT32_TO_LONG(subchunk.len, ",
                "\t\t      pj_file_close(fport->fd); return PJMEDIA_ENOTVALIDWAVE;);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-24792",
        "func_name": "pjsip/pjproject/pj_file_setpos",
        "description": "PJSIP is a free and open source multimedia communication library written in C. A denial-of-service vulnerability affects applications on a 32-bit systems that use PJSIP versions 2.12 and prior to play/read invalid WAV files. The vulnerability occurs when reading WAV file data chunks with length greater than 31-bit integers. The vulnerability does not affect 64-bit apps and should not affect apps that only plays trusted WAV files. A patch is available on the `master` branch of the `pjsip/project` GitHub repository. As a workaround, apps can reject a WAV file received from an unknown source or validate the file first.",
        "git_url": "https://github.com/pjsip/pjproject/commit/947bc1ee6d05be10204b918df75a503415fd3213",
        "commit_title": "Merge pull request from GHSA-rwgw-vwxg-q799",
        "commit_text": " * Prevent potential infinite loop when parsing WAV format file  * Check if subchunk is negative.  * Fix and add checks  * Change data type from pj_ssize_t to long.  * Modify check  * Fix leak file descriptor and modify check on wav_playlist  * Move overflow/underflow check to pj_file_setpos()  * Use macro to simplify check  * modification based on comments  * Remove unnecessary casting  * Modification based on comments",
        "func_before": "PJ_DEF(pj_status_t) pj_file_setpos( pj_oshandle_t fd,\n                                    pj_off_t offset,\n                                    enum pj_file_seek_type whence)\n{\n    int mode;\n\n    switch (whence) {\n    case PJ_SEEK_SET:\n        mode = SEEK_SET; break;\n    case PJ_SEEK_CUR:\n        mode = SEEK_CUR; break;\n    case PJ_SEEK_END:\n        mode = SEEK_END; break;\n    default:\n        pj_assert(!\"Invalid whence in file_setpos\");\n        return PJ_EINVAL;\n    }\n\n    if (fseek((FILE*)fd, (long)offset, mode) != 0)\n        return PJ_RETURN_OS_ERROR(errno);\n\n    return PJ_SUCCESS;\n}",
        "func": "PJ_DEF(pj_status_t) pj_file_setpos( pj_oshandle_t fd,\n                                    pj_off_t offset,\n                                    enum pj_file_seek_type whence)\n{\n    int mode;\n\n    if ((sizeof(pj_off_t) > sizeof(long)) &&\n        (offset > PJ_MAXLONG || offset < PJ_MINLONG)) \n    {\n        return PJ_ENOTSUP;\n    }\n\n    switch (whence) {\n    case PJ_SEEK_SET:\n        mode = SEEK_SET; break;\n    case PJ_SEEK_CUR:\n        mode = SEEK_CUR; break;\n    case PJ_SEEK_END:\n        mode = SEEK_END; break;\n    default:\n        pj_assert(!\"Invalid whence in file_setpos\");\n        return PJ_EINVAL;\n    }\n\n    if (fseek((FILE*)fd, (long)offset, mode) != 0)\n        return PJ_RETURN_OS_ERROR(errno);\n\n    return PJ_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,12 @@\n                                     enum pj_file_seek_type whence)\n {\n     int mode;\n+\n+    if ((sizeof(pj_off_t) > sizeof(long)) &&\n+        (offset > PJ_MAXLONG || offset < PJ_MINLONG)) \n+    {\n+        return PJ_ENOTSUP;\n+    }\n \n     switch (whence) {\n     case PJ_SEEK_SET:",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    if ((sizeof(pj_off_t) > sizeof(long)) &&",
                "        (offset > PJ_MAXLONG || offset < PJ_MINLONG)) ",
                "    {",
                "        return PJ_ENOTSUP;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-40592",
        "func_name": "gpac/isoffin_process",
        "description": "GPAC version before commit 71460d72ec07df766dab0a4d52687529f3efcf0a (version v1.0.1 onwards) contains loop with unreachable exit condition ('infinite loop') vulnerability in ISOBMFF reader filter, isoffin_read.c. Function isoffin_process() can result in DoS by infinite loop. To exploit, the victim must open a specially crafted mp4 file.",
        "git_url": "https://github.com/gpac/gpac/commit/71460d72ec07df766dab0a4d52687529f3efcf0a",
        "commit_title": "fixed #1876",
        "commit_text": "",
        "func_before": "static GF_Err isoffin_process(GF_Filter *filter)\n{\n\tISOMReader *read = gf_filter_get_udta(filter);\n\tu32 i, count = gf_list_count(read->channels);\n\tBool is_active = GF_FALSE;\n\tBool in_is_eos = GF_FALSE;\n\tBool check_forced_end = GF_FALSE;\n\tBool has_new_data = GF_FALSE;\n\tu64 min_offset_plus_one = 0;\n\tu32 nb_forced_end=0;\n\tif (read->in_error)\n\t\treturn read->in_error;\n\n\tif (read->pid) {\n\t\tBool fetch_input = GF_TRUE;\n\n\t\t//we failed at loading the init segment during a dash switch, retry\n\t\tif (!read->is_partial_download && !read->mem_load_mode && (read->moov_not_loaded==2) ) {\n\t\t\tisoffin_configure_pid(filter, read->pid, GF_FALSE);\n\t\t\tif (read->moov_not_loaded) return GF_OK;\n\t\t}\n\t\tif (read->mem_load_mode==2) {\n\t\t\tif (!read->force_fetch && read->mem_blob.size > read->mstore_size) {\n\t\t\t\tfetch_input = GF_FALSE;\n\t\t\t}\n\t\t\tread->force_fetch = GF_FALSE;\n\t\t}\n\t\twhile (fetch_input) {\n\t\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(read->pid);\n\t\t\tif (!pck) {\n\t\t\t\t//we issued a seek, wait for the first packet to be received before fetching channels\n\t\t\t\t//otherwise we could end up reading from the wrong cache\n\t\t\t\tif (read->wait_for_source) {\n\t\t\t\t\t//something went wrong during the seek request\n\t\t\t\t\tif (gf_filter_pid_is_eos(read->pid))\n\t\t\t\t\t\treturn GF_EOS;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tread->wait_for_source = GF_FALSE;\n\n\t\t\tif (read->mem_load_mode) {\n\t\t\t\tu32 data_size;\n\t\t\t\tconst u8 *pck_data = gf_filter_pck_get_data(pck, &data_size);\n\t\t\t\tisoffin_push_buffer(filter, read, pck_data, data_size);\n\t\t\t}\n\t\t\t//we just had a switch but init seg is not completely done: input packet is only a part of the init, drop it\n\t\t\telse if (read->moov_not_loaded==2) {\n\t\t\t\tgf_filter_pid_drop_packet(read->pid);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tgf_filter_pid_drop_packet(read->pid);\n\t\t\thas_new_data = GF_TRUE;\n\t\t\tif (read->in_error)\n\t\t\t\treturn read->in_error;\n\t\t}\n\t\tif (gf_filter_pid_is_eos(read->pid)) {\n\t\t\tread->input_loaded = GF_TRUE;\n\t\t\tin_is_eos = GF_TRUE;\n\t\t}\n\t\tif (read->input_is_stop) {\n\t\t\tread->input_loaded = GF_TRUE;\n\t\t\tin_is_eos = GF_TRUE;\n\t\t\tread->input_is_stop = GF_FALSE;\n\t\t}\n\t\tif (!read->frag_type && read->input_loaded) {\n\t\t\tin_is_eos = GF_TRUE;\n\t\t}\n        //segment is invalid, wait for eos on input an send eos on all channels\n        if (read->invalid_segment) {\n            if (!in_is_eos) return GF_OK;\n            read->invalid_segment = GF_FALSE;\n\n            for (i=0; i<count; i++) {\n                ISOMChannel *ch = gf_list_get(read->channels, i);\n                if (!ch->playing) {\n                    continue;\n                }\n                if (!ch->eos_sent) {\n                    ch->eos_sent = GF_TRUE;\n                    gf_filter_pid_set_eos(ch->pid);\n                }\n            }\n            read->eos_signaled = GF_TRUE;\n            return GF_EOS;\n        }\n\t} else if (read->extern_mov) {\n\t\tin_is_eos = GF_TRUE;\n\t\tread->input_loaded = GF_TRUE;\n\t}\n\tif (read->moov_not_loaded==1) {\n\t\tif (read->mem_load_mode)\n\t\t\treturn GF_OK;\n\t\tread->moov_not_loaded = GF_FALSE;\n\t\treturn isoffin_setup(filter, read);\n\t}\n\n\tif (read->refresh_fragmented) {\n\t\tconst GF_PropertyValue *prop;\n\n\t\tif (in_is_eos) {\n\t\t\tread->refresh_fragmented = GF_FALSE;\n\t\t} else {\n\t\t\tprop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_FILE_CACHED);\n\t\t\tif (prop && prop->value.boolean)\n\t\t\t\tread->refresh_fragmented = GF_FALSE;\n\t\t}\n\n\t\tif (has_new_data) {\n\t\t\tu64 bytesMissing=0;\n\t\t\tGF_Err e;\n\t\t\tconst char *new_url = NULL;\n\t\t\tprop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_FILEPATH);\n\t\t\tif (prop) new_url = prop->value.string;\n\n\t\t\te = gf_isom_refresh_fragmented(read->mov, &bytesMissing, new_url);\n\n\t\t\tif (e && (e!= GF_ISOM_INCOMPLETE_FILE)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[IsoMedia] Failed to refresh current segment: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\tread->refresh_fragmented = GF_FALSE;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] Refreshing current segment at UTC \"LLU\" - \"LLU\" bytes still missing - input is EOS %d\\n\", gf_net_get_utc(), bytesMissing, in_is_eos));\n\t\t\t}\n\n\t\t\tif (!read->refresh_fragmented && (e==GF_ISOM_INCOMPLETE_FILE)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[IsoMedia] Incomplete Segment received - \"LLU\" bytes missing but EOF found\\n\", bytesMissing ));\n\t\t\t}\n\n#ifndef GPAC_DISABLE_LOG\n\t\t\tif (gf_log_tool_level_on(GF_LOG_DASH, GF_LOG_DEBUG)) {\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tISOMChannel *ch = gf_list_get(read->channels, i);\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] refresh track %d fragment - cur sample %d - new sample count %d\\n\", ch->track, ch->sample_num, gf_isom_get_sample_count(ch->owner->mov, ch->track) ));\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tisor_check_producer_ref_time(read);\n\t\t\tif (!read->frag_type)\n\t\t\t\tread->refresh_fragmented = GF_FALSE;\n\t\t}\n\t}\n\n\tfor (i=0; i<count; i++) {\n\t\tu8 *data;\n\t\tu32 nb_pck=50;\n\t\tISOMChannel *ch;\n\t\tch = gf_list_get(read->channels, i);\n\t\tif (!ch->playing) {\n\t\t\tnb_forced_end++;\n\t\t\tcontinue;\n\t\t}\n\t\t//eos not sent on this channel, we are active\n\t\tif (!ch->eos_sent)\n\t\t\tis_active = GF_TRUE;\n\n\t\twhile (nb_pck) {\n\t\t\tch->sample_data_offset = 0;\n\t\t\tif (!read->full_segment_flush && gf_filter_pid_would_block(ch->pid) )\n\t\t\t\tbreak;\n\n\t\t\tif (ch->item_id) {\n\t\t\t\tisor_reader_get_sample_from_item(ch);\n\t\t\t} else {\n\t\t\t\tisor_reader_get_sample(ch);\n\t\t\t}\n\n\t\t\tif (read->stsd && (ch->last_sample_desc_index != read->stsd) && ch->sample) {\n\t\t\t\tisor_reader_release_sample(ch);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ch->sample) {\n\t\t\t\tu32 sample_dur;\n\t\t\t\tu8 dep_flags;\n\t\t\t\tu8 *subs_buf;\n\t\t\t\tu32 subs_buf_size;\n\t\t\t\tGF_FilterPacket *pck;\n\t\t\t\tif (ch->needs_pid_reconfig) {\n\t\t\t\t\tisor_update_channel_config(ch);\n\t\t\t\t\tch->needs_pid_reconfig = GF_FALSE;\n\t\t\t\t}\n\n\t\t\t\t//we have at least two samples, update GF_PROP_PID_HAS_SYNC if needed\n\t\t\t\tif (ch->check_has_rap && (gf_isom_get_sample_count(ch->owner->mov, ch->track)>1) && (gf_isom_has_sync_points(ch->owner->mov, ch->track)==1)) {\n\t\t\t\t\tch->check_has_rap = GF_FALSE;\n\t\t\t\t\tch->has_rap = GF_TRUE;\n\t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_HAS_SYNC, &PROP_BOOL(ch->has_rap) );\n\t\t\t\t}\n\n\t\t\t\t//strip param sets from payload, trigger reconfig if needed\n\t\t\t\tisor_reader_check_config(ch);\n\n\t\t\t\tif (read->nodata) {\n\t\t\t\t\tpck = gf_filter_pck_new_shared(ch->pid, NULL, ch->sample->dataLength, NULL);\n\t\t\t\t\tif (!pck) return GF_OUT_OF_MEM;\n\t\t\t\t} else {\n\t\t\t\t\tpck = gf_filter_pck_new_alloc(ch->pid, ch->sample->dataLength, &data);\n\t\t\t\t\tif (!pck) return GF_OUT_OF_MEM;\n\n\t\t\t\t\tmemcpy(data, ch->sample->data, ch->sample->dataLength);\n\t\t\t\t}\n\t\t\t\tgf_filter_pck_set_dts(pck, ch->dts);\n\t\t\t\tgf_filter_pck_set_cts(pck, ch->cts);\n\t\t\t\tif (ch->sample->IsRAP==-1) {\n\t\t\t\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_1);\n\t\t\t\t\tch->redundant = 1;\n\t\t\t\t} else {\n\t\t\t\t\tgf_filter_pck_set_sap(pck, (GF_FilterSAPType) ch->sample->IsRAP);\n\t\t\t\t}\n\n\t\t\t\tif (ch->sap_3)\n\t\t\t\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_3);\n\t\t\t\telse if (ch->sap_4_type) {\n\t\t\t\t\tgf_filter_pck_set_sap(pck, (ch->sap_4_type==GF_ISOM_SAMPLE_PREROLL) ? GF_FILTER_SAP_4_PROL : GF_FILTER_SAP_4);\n\t\t\t\t\tgf_filter_pck_set_roll_info(pck, ch->roll);\n\t\t\t\t}\n\n\t\t\t\tsample_dur = ch->au_duration;\n\t\t\t\tif (ch->sample->nb_pack)\n\t\t\t\t\tsample_dur *= ch->sample->nb_pack;\n\t\t\t\tgf_filter_pck_set_duration(pck, sample_dur);\n\t\t\t\tgf_filter_pck_set_seek_flag(pck, ch->seek_flag);\n\n\t\t\t\t//for now we only signal xPS mask for non-sap\n\t\t\t\tif (ch->xps_mask && !gf_filter_pck_get_sap(pck) ) {\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_XPS_MASK, &PROP_UINT(ch->xps_mask) );\n\t\t\t\t}\n\n\t\t\t\tdep_flags = ch->isLeading;\n\t\t\t\tdep_flags <<= 2;\n\t\t\t\tdep_flags |= ch->dependsOn;\n\t\t\t\tdep_flags <<= 2;\n\t\t\t\tdep_flags |= ch->dependedOn;\n\t\t\t\tdep_flags <<= 2;\n\t\t\t\tdep_flags |= ch->redundant;\n\n\t\t\t\tif (dep_flags)\n\t\t\t\t\tgf_filter_pck_set_dependency_flags(pck, dep_flags);\n\n\t\t\t\tgf_filter_pck_set_crypt_flags(pck, ch->pck_encrypted ? GF_FILTER_PCK_CRYPT : 0);\n\t\t\t\tgf_filter_pck_set_seq_num(pck, ch->sample_num);\n\n\n\t\t\t\tsubs_buf = gf_isom_sample_get_subsamples_buffer(read->mov, ch->track, ch->sample_num, &subs_buf_size);\n\t\t\t\tif (subs_buf) {\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SUBS, &PROP_DATA_NO_COPY(subs_buf, subs_buf_size) );\n\t\t\t\t}\n\n\t\t\t\tif (ch->sai_buffer && ch->pck_encrypted) {\n\t\t\t\t\tassert(ch->sai_buffer_size);\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_CENC_SAI, &PROP_DATA(ch->sai_buffer, ch->sai_buffer_size) );\n\t\t\t\t}\n\n\t\t\t\tif (read->sigfrag) {\n\t\t\t\t\tGF_ISOFragmentBoundaryInfo finfo;\n\t\t\t\t\tif (gf_isom_sample_is_fragment_start(read->mov, ch->track, ch->sample_num, &finfo) ) {\n\t\t\t\t\t\tu64 start=0;\n\t\t\t\t\t\tu32 traf_start = finfo.seg_start_plus_one ? 2 : 1;\n\n\t\t\t\t\t\tif (finfo.seg_start_plus_one)\n\t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_CUE_START, &PROP_BOOL(GF_TRUE));\n\n\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FRAG_START, &PROP_UINT(traf_start));\n\n\t\t\t\t\t\tstart = finfo.frag_start;\n\t\t\t\t\t\tif (finfo.seg_start_plus_one) start = finfo.seg_start_plus_one-1;\n\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FRAG_RANGE, &PROP_FRAC64_INT(start, finfo.mdat_end));\n\t\t\t\t\t\tif (finfo.moof_template) {\n\t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_MOOF_TEMPLATE, &PROP_DATA((u8 *)finfo.moof_template, finfo.moof_template_size));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (finfo.sidx_end) {\n\t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SIDX_RANGE, &PROP_FRAC64_INT(finfo.sidx_start , finfo.sidx_end));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (read->seg_name_changed) {\n\t\t\t\t\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(read->pid, GF_PROP_PID_URL);\n\t\t\t\t\t\t\tread->seg_name_changed = GF_FALSE;\n\t\t\t\t\t\t\tif (p && p->value.string) {\n\t\t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PID_URL, &PROP_STRING(p->value.string));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ch->sender_ntp) {\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SENDER_NTP, &PROP_LONGUINT(ch->sender_ntp));\n\t\t\t\t\tif (ch->ntp_at_server_ntp) {\n\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_RECEIVER_NTP, &PROP_LONGUINT(ch->ntp_at_server_ntp));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tch->eos_sent = GF_FALSE;\n\n\t\t\t\t//this might not be the true end of stream\n\t\t\t\tif ((ch->streamType==GF_STREAM_AUDIO) && (ch->sample_num == gf_isom_get_sample_count(read->mov, ch->track))) {\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_END_RANGE, &PROP_BOOL(GF_TRUE));\n\t\t\t\t}\n\n\t\t\t\tgf_filter_pck_send(pck);\n\t\t\t\tisor_reader_release_sample(ch);\n\n\t\t\t\tch->last_valid_sample_data_offset = ch->sample_data_offset;\n\t\t\t\tnb_pck--;\n\t\t\t} else if (ch->last_state==GF_EOS) {\n\t\t\t\tif (ch->playing == 2) {\n\t\t\t\t\tif (in_is_eos) {\n\t\t\t\t\t\tch->playing = GF_FALSE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnb_forced_end++;\n\t\t\t\t\t\tcheck_forced_end = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (in_is_eos && !ch->eos_sent) {\n\t\t\t\t\tvoid *tfrf;\n\t\t\t\t\tconst void *gf_isom_get_tfrf(GF_ISOFile *movie, u32 trackNumber);\n\n\t\t\t\t\tch->eos_sent = GF_TRUE;\n\t\t\t\t\tread->eos_signaled = GF_TRUE;\n\n\t\t\t\t\ttfrf = (void *) gf_isom_get_tfrf(read->mov, ch->track);\n\t\t\t\t\tif (tfrf) {\n\t\t\t\t\t\tgf_filter_pid_set_info_str(ch->pid, \"smooth_tfrf\", &PROP_POINTER(tfrf) );\n\t\t\t\t\t\tch->last_has_tfrf = GF_TRUE;\n\t\t\t\t\t} else if (ch->last_has_tfrf) {\n\t\t\t\t\t\tgf_filter_pid_set_info_str(ch->pid, \"smooth_tfrf\", NULL);\n\t\t\t\t\t\tch->last_has_tfrf = GF_FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\tgf_filter_pid_set_eos(ch->pid);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tread->force_fetch = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!min_offset_plus_one || (min_offset_plus_one - 1 > ch->last_valid_sample_data_offset))\n\t\t\tmin_offset_plus_one = 1 + ch->last_valid_sample_data_offset;\n\t}\n\tif (read->mem_load_mode && min_offset_plus_one) {\n\t\tisoffin_purge_mem(read, min_offset_plus_one-1);\n\t}\n\n\t//we reached end of playback due to play range request, we must send eos - however for safety reason with DASH, we first need to cancel the input\n\tif (read->pid && check_forced_end && (nb_forced_end==count)) {\n\t\t//abort input\n\t\tGF_FilterEvent evt;\n\t\tGF_FEVT_INIT(evt, GF_FEVT_STOP, read->pid);\n\t\tgf_filter_pid_send_event(read->pid, &evt);\n\t}\n\n\n\tif (!is_active) {\n\t\treturn GF_EOS;\n\t}\n\t//if (in_is_eos)\n//\tgf_filter_ask_rt_reschedule(filter, 1);\n\treturn GF_OK;\n\n}",
        "func": "static GF_Err isoffin_process(GF_Filter *filter)\n{\n\tISOMReader *read = gf_filter_get_udta(filter);\n\tu32 i, count = gf_list_count(read->channels);\n\tBool is_active = GF_FALSE;\n\tBool in_is_eos = GF_FALSE;\n\tBool check_forced_end = GF_FALSE;\n\tBool has_new_data = GF_FALSE;\n\tu64 min_offset_plus_one = 0;\n\tu32 nb_forced_end=0;\n\tif (read->in_error)\n\t\treturn read->in_error;\n\n\tif (read->pid) {\n\t\tBool fetch_input = GF_TRUE;\n\n\t\t//we failed at loading the init segment during a dash switch, retry\n\t\tif (!read->is_partial_download && !read->mem_load_mode && (read->moov_not_loaded==2) ) {\n\t\t\tisoffin_configure_pid(filter, read->pid, GF_FALSE);\n\t\t\tif (read->moov_not_loaded) return GF_OK;\n\t\t}\n\t\tif (read->mem_load_mode==2) {\n\t\t\tif (!read->force_fetch && read->mem_blob.size > read->mstore_size) {\n\t\t\t\tfetch_input = GF_FALSE;\n\t\t\t}\n\t\t\tread->force_fetch = GF_FALSE;\n\t\t}\n\t\twhile (fetch_input) {\n\t\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(read->pid);\n\t\t\tif (!pck) {\n\t\t\t\t//we issued a seek, wait for the first packet to be received before fetching channels\n\t\t\t\t//otherwise we could end up reading from the wrong cache\n\t\t\t\tif (read->wait_for_source) {\n\t\t\t\t\t//something went wrong during the seek request\n\t\t\t\t\tif (gf_filter_pid_is_eos(read->pid))\n\t\t\t\t\t\treturn GF_EOS;\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tread->wait_for_source = GF_FALSE;\n\n\t\t\tif (read->mem_load_mode) {\n\t\t\t\tu32 data_size;\n\t\t\t\tconst u8 *pck_data = gf_filter_pck_get_data(pck, &data_size);\n\t\t\t\tisoffin_push_buffer(filter, read, pck_data, data_size);\n\t\t\t}\n\t\t\t//we just had a switch but init seg is not completely done: input packet is only a part of the init, drop it\n\t\t\telse if (read->moov_not_loaded==2) {\n\t\t\t\tgf_filter_pid_drop_packet(read->pid);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\tgf_filter_pid_drop_packet(read->pid);\n\t\t\thas_new_data = GF_TRUE;\n\t\t\tif (read->in_error)\n\t\t\t\treturn read->in_error;\n\t\t}\n\t\tif (gf_filter_pid_is_eos(read->pid)) {\n\t\t\tread->input_loaded = GF_TRUE;\n\t\t\tin_is_eos = GF_TRUE;\n\t\t}\n\t\tif (read->input_is_stop) {\n\t\t\tread->input_loaded = GF_TRUE;\n\t\t\tin_is_eos = GF_TRUE;\n\t\t\tread->input_is_stop = GF_FALSE;\n\t\t}\n\t\tif (!read->frag_type && read->input_loaded) {\n\t\t\tin_is_eos = GF_TRUE;\n\t\t}\n        //segment is invalid, wait for eos on input an send eos on all channels\n        if (read->invalid_segment) {\n            if (!in_is_eos) return GF_OK;\n            read->invalid_segment = GF_FALSE;\n\n            for (i=0; i<count; i++) {\n                ISOMChannel *ch = gf_list_get(read->channels, i);\n                if (!ch->playing) {\n                    continue;\n                }\n                if (!ch->eos_sent) {\n                    ch->eos_sent = GF_TRUE;\n                    gf_filter_pid_set_eos(ch->pid);\n                }\n            }\n            read->eos_signaled = GF_TRUE;\n            return GF_EOS;\n        }\n\t} else if (read->extern_mov) {\n\t\tin_is_eos = GF_TRUE;\n\t\tread->input_loaded = GF_TRUE;\n\t}\n\tif (read->moov_not_loaded==1) {\n\t\tif (read->mem_load_mode)\n\t\t\treturn GF_OK;\n\t\tread->moov_not_loaded = GF_FALSE;\n\t\treturn isoffin_setup(filter, read);\n\t}\n\n\tif (read->refresh_fragmented) {\n\t\tconst GF_PropertyValue *prop;\n\n\t\tif (in_is_eos) {\n\t\t\tread->refresh_fragmented = GF_FALSE;\n\t\t} else {\n\t\t\tprop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_FILE_CACHED);\n\t\t\tif (prop && prop->value.boolean)\n\t\t\t\tread->refresh_fragmented = GF_FALSE;\n\t\t}\n\n\t\tif (has_new_data) {\n\t\t\tu64 bytesMissing=0;\n\t\t\tGF_Err e;\n\t\t\tconst char *new_url = NULL;\n\t\t\tprop = gf_filter_pid_get_property(read->pid, GF_PROP_PID_FILEPATH);\n\t\t\tif (prop) new_url = prop->value.string;\n\n\t\t\te = gf_isom_refresh_fragmented(read->mov, &bytesMissing, new_url);\n\n\t\t\tif (e && (e!= GF_ISOM_INCOMPLETE_FILE)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[IsoMedia] Failed to refresh current segment: %s\\n\", gf_error_to_string(e) ));\n\t\t\t\tread->refresh_fragmented = GF_FALSE;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] Refreshing current segment at UTC \"LLU\" - \"LLU\" bytes still missing - input is EOS %d\\n\", gf_net_get_utc(), bytesMissing, in_is_eos));\n\t\t\t}\n\n\t\t\tif (!read->refresh_fragmented && (e==GF_ISOM_INCOMPLETE_FILE)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[IsoMedia] Incomplete Segment received - \"LLU\" bytes missing but EOF found\\n\", bytesMissing ));\n\t\t\t}\n\n#ifndef GPAC_DISABLE_LOG\n\t\t\tif (gf_log_tool_level_on(GF_LOG_DASH, GF_LOG_DEBUG)) {\n\t\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\t\tISOMChannel *ch = gf_list_get(read->channels, i);\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] refresh track %d fragment - cur sample %d - new sample count %d\\n\", ch->track, ch->sample_num, gf_isom_get_sample_count(ch->owner->mov, ch->track) ));\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tisor_check_producer_ref_time(read);\n\t\t\tif (!read->frag_type)\n\t\t\t\tread->refresh_fragmented = GF_FALSE;\n\t\t}\n\t}\n\n\tfor (i=0; i<count; i++) {\n\t\tu8 *data;\n\t\tu32 nb_pck=50;\n\t\tISOMChannel *ch;\n\t\tch = gf_list_get(read->channels, i);\n\t\tif (!ch->playing) {\n\t\t\tnb_forced_end++;\n\t\t\tcontinue;\n\t\t}\n\t\t//eos not sent on this channel, we are active\n\t\tif (!ch->eos_sent)\n\t\t\tis_active = GF_TRUE;\n\n\t\twhile (nb_pck) {\n\t\t\tch->sample_data_offset = 0;\n\t\t\tif (!read->full_segment_flush && gf_filter_pid_would_block(ch->pid) )\n\t\t\t\tbreak;\n\n\t\t\tif (ch->item_id) {\n\t\t\t\tisor_reader_get_sample_from_item(ch);\n\t\t\t} else {\n\t\t\t\tisor_reader_get_sample(ch);\n\t\t\t}\n\n\t\t\tif (read->stsd && (ch->last_sample_desc_index != read->stsd) && ch->sample) {\n\t\t\t\tisor_reader_release_sample(ch);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ch->sample) {\n\t\t\t\tu32 sample_dur;\n\t\t\t\tu8 dep_flags;\n\t\t\t\tu8 *subs_buf;\n\t\t\t\tu32 subs_buf_size;\n\t\t\t\tGF_FilterPacket *pck;\n\t\t\t\tif (ch->needs_pid_reconfig) {\n\t\t\t\t\tisor_update_channel_config(ch);\n\t\t\t\t\tch->needs_pid_reconfig = GF_FALSE;\n\t\t\t\t}\n\n\t\t\t\t//we have at least two samples, update GF_PROP_PID_HAS_SYNC if needed\n\t\t\t\tif (ch->check_has_rap && (gf_isom_get_sample_count(ch->owner->mov, ch->track)>1) && (gf_isom_has_sync_points(ch->owner->mov, ch->track)==1)) {\n\t\t\t\t\tch->check_has_rap = GF_FALSE;\n\t\t\t\t\tch->has_rap = GF_TRUE;\n\t\t\t\t\tgf_filter_pid_set_property(ch->pid, GF_PROP_PID_HAS_SYNC, &PROP_BOOL(ch->has_rap) );\n\t\t\t\t}\n\n\t\t\t\t//strip param sets from payload, trigger reconfig if needed\n\t\t\t\tisor_reader_check_config(ch);\n\n\t\t\t\tif (read->nodata) {\n\t\t\t\t\tpck = gf_filter_pck_new_shared(ch->pid, NULL, ch->sample->dataLength, NULL);\n\t\t\t\t\tif (!pck) return GF_OUT_OF_MEM;\n\t\t\t\t} else {\n\t\t\t\t\tpck = gf_filter_pck_new_alloc(ch->pid, ch->sample->dataLength, &data);\n\t\t\t\t\tif (!pck) return GF_OUT_OF_MEM;\n\n\t\t\t\t\tmemcpy(data, ch->sample->data, ch->sample->dataLength);\n\t\t\t\t}\n\t\t\t\tgf_filter_pck_set_dts(pck, ch->dts);\n\t\t\t\tgf_filter_pck_set_cts(pck, ch->cts);\n\t\t\t\tif (ch->sample->IsRAP==-1) {\n\t\t\t\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_1);\n\t\t\t\t\tch->redundant = 1;\n\t\t\t\t} else {\n\t\t\t\t\tgf_filter_pck_set_sap(pck, (GF_FilterSAPType) ch->sample->IsRAP);\n\t\t\t\t}\n\n\t\t\t\tif (ch->sap_3)\n\t\t\t\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_3);\n\t\t\t\telse if (ch->sap_4_type) {\n\t\t\t\t\tgf_filter_pck_set_sap(pck, (ch->sap_4_type==GF_ISOM_SAMPLE_PREROLL) ? GF_FILTER_SAP_4_PROL : GF_FILTER_SAP_4);\n\t\t\t\t\tgf_filter_pck_set_roll_info(pck, ch->roll);\n\t\t\t\t}\n\n\t\t\t\tsample_dur = ch->au_duration;\n\t\t\t\tif (ch->sample->nb_pack)\n\t\t\t\t\tsample_dur *= ch->sample->nb_pack;\n\t\t\t\tgf_filter_pck_set_duration(pck, sample_dur);\n\t\t\t\tgf_filter_pck_set_seek_flag(pck, ch->seek_flag);\n\n\t\t\t\t//for now we only signal xPS mask for non-sap\n\t\t\t\tif (ch->xps_mask && !gf_filter_pck_get_sap(pck) ) {\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_XPS_MASK, &PROP_UINT(ch->xps_mask) );\n\t\t\t\t}\n\n\t\t\t\tdep_flags = ch->isLeading;\n\t\t\t\tdep_flags <<= 2;\n\t\t\t\tdep_flags |= ch->dependsOn;\n\t\t\t\tdep_flags <<= 2;\n\t\t\t\tdep_flags |= ch->dependedOn;\n\t\t\t\tdep_flags <<= 2;\n\t\t\t\tdep_flags |= ch->redundant;\n\n\t\t\t\tif (dep_flags)\n\t\t\t\t\tgf_filter_pck_set_dependency_flags(pck, dep_flags);\n\n\t\t\t\tgf_filter_pck_set_crypt_flags(pck, ch->pck_encrypted ? GF_FILTER_PCK_CRYPT : 0);\n\t\t\t\tgf_filter_pck_set_seq_num(pck, ch->sample_num);\n\n\n\t\t\t\tsubs_buf = gf_isom_sample_get_subsamples_buffer(read->mov, ch->track, ch->sample_num, &subs_buf_size);\n\t\t\t\tif (subs_buf) {\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SUBS, &PROP_DATA_NO_COPY(subs_buf, subs_buf_size) );\n\t\t\t\t}\n\n\t\t\t\tif (ch->sai_buffer && ch->pck_encrypted) {\n\t\t\t\t\tassert(ch->sai_buffer_size);\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_CENC_SAI, &PROP_DATA(ch->sai_buffer, ch->sai_buffer_size) );\n\t\t\t\t}\n\n\t\t\t\tif (read->sigfrag) {\n\t\t\t\t\tGF_ISOFragmentBoundaryInfo finfo;\n\t\t\t\t\tif (gf_isom_sample_is_fragment_start(read->mov, ch->track, ch->sample_num, &finfo) ) {\n\t\t\t\t\t\tu64 start=0;\n\t\t\t\t\t\tu32 traf_start = finfo.seg_start_plus_one ? 2 : 1;\n\n\t\t\t\t\t\tif (finfo.seg_start_plus_one)\n\t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_CUE_START, &PROP_BOOL(GF_TRUE));\n\n\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FRAG_START, &PROP_UINT(traf_start));\n\n\t\t\t\t\t\tstart = finfo.frag_start;\n\t\t\t\t\t\tif (finfo.seg_start_plus_one) start = finfo.seg_start_plus_one-1;\n\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FRAG_RANGE, &PROP_FRAC64_INT(start, finfo.mdat_end));\n\t\t\t\t\t\tif (finfo.moof_template) {\n\t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_MOOF_TEMPLATE, &PROP_DATA((u8 *)finfo.moof_template, finfo.moof_template_size));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (finfo.sidx_end) {\n\t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SIDX_RANGE, &PROP_FRAC64_INT(finfo.sidx_start , finfo.sidx_end));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (read->seg_name_changed) {\n\t\t\t\t\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(read->pid, GF_PROP_PID_URL);\n\t\t\t\t\t\t\tread->seg_name_changed = GF_FALSE;\n\t\t\t\t\t\t\tif (p && p->value.string) {\n\t\t\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PID_URL, &PROP_STRING(p->value.string));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ch->sender_ntp) {\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SENDER_NTP, &PROP_LONGUINT(ch->sender_ntp));\n\t\t\t\t\tif (ch->ntp_at_server_ntp) {\n\t\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_RECEIVER_NTP, &PROP_LONGUINT(ch->ntp_at_server_ntp));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tch->eos_sent = GF_FALSE;\n\n\t\t\t\t//this might not be the true end of stream\n\t\t\t\tif ((ch->streamType==GF_STREAM_AUDIO) && (ch->sample_num == gf_isom_get_sample_count(read->mov, ch->track))) {\n\t\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_END_RANGE, &PROP_BOOL(GF_TRUE));\n\t\t\t\t}\n\n\t\t\t\tgf_filter_pck_send(pck);\n\t\t\t\tisor_reader_release_sample(ch);\n\n\t\t\t\tch->last_valid_sample_data_offset = ch->sample_data_offset;\n\t\t\t\tnb_pck--;\n\t\t\t} else if (ch->last_state==GF_EOS) {\n\t\t\t\tif (ch->playing == 2) {\n\t\t\t\t\tif (in_is_eos) {\n\t\t\t\t\t\tch->playing = GF_FALSE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnb_forced_end++;\n\t\t\t\t\t\tcheck_forced_end = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (in_is_eos && !ch->eos_sent) {\n\t\t\t\t\tvoid *tfrf;\n\t\t\t\t\tconst void *gf_isom_get_tfrf(GF_ISOFile *movie, u32 trackNumber);\n\n\t\t\t\t\tch->eos_sent = GF_TRUE;\n\t\t\t\t\tread->eos_signaled = GF_TRUE;\n\n\t\t\t\t\ttfrf = (void *) gf_isom_get_tfrf(read->mov, ch->track);\n\t\t\t\t\tif (tfrf) {\n\t\t\t\t\t\tgf_filter_pid_set_info_str(ch->pid, \"smooth_tfrf\", &PROP_POINTER(tfrf) );\n\t\t\t\t\t\tch->last_has_tfrf = GF_TRUE;\n\t\t\t\t\t} else if (ch->last_has_tfrf) {\n\t\t\t\t\t\tgf_filter_pid_set_info_str(ch->pid, \"smooth_tfrf\", NULL);\n\t\t\t\t\t\tch->last_has_tfrf = GF_FALSE;\n\t\t\t\t\t}\n\n\t\t\t\t\tgf_filter_pid_set_eos(ch->pid);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else if (ch->last_state==GF_ISOM_INVALID_FILE) {\n\t\t\t\tif (!ch->eos_sent) {\n\t\t\t\t\tch->eos_sent = GF_TRUE;\n\t\t\t\t\tread->eos_signaled = GF_TRUE;\n\t\t\t\t\tgf_filter_pid_set_eos(ch->pid);\n\t\t\t\t}\n\t\t\t\treturn ch->last_state;\n\t\t\t} else {\n\t\t\t\tread->force_fetch = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!min_offset_plus_one || (min_offset_plus_one - 1 > ch->last_valid_sample_data_offset))\n\t\t\tmin_offset_plus_one = 1 + ch->last_valid_sample_data_offset;\n\t}\n\tif (read->mem_load_mode && min_offset_plus_one) {\n\t\tisoffin_purge_mem(read, min_offset_plus_one-1);\n\t}\n\n\t//we reached end of playback due to play range request, we must send eos - however for safety reason with DASH, we first need to cancel the input\n\tif (read->pid && check_forced_end && (nb_forced_end==count)) {\n\t\t//abort input\n\t\tGF_FilterEvent evt;\n\t\tGF_FEVT_INIT(evt, GF_FEVT_STOP, read->pid);\n\t\tgf_filter_pid_send_event(read->pid, &evt);\n\t}\n\n\n\tif (!is_active) {\n\t\treturn GF_EOS;\n\t}\n\t//if (in_is_eos)\n//\tgf_filter_ask_rt_reschedule(filter, 1);\n\treturn GF_OK;\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -327,6 +327,13 @@\n \t\t\t\t\tgf_filter_pid_set_eos(ch->pid);\n \t\t\t\t}\n \t\t\t\tbreak;\n+\t\t\t} else if (ch->last_state==GF_ISOM_INVALID_FILE) {\n+\t\t\t\tif (!ch->eos_sent) {\n+\t\t\t\t\tch->eos_sent = GF_TRUE;\n+\t\t\t\t\tread->eos_signaled = GF_TRUE;\n+\t\t\t\t\tgf_filter_pid_set_eos(ch->pid);\n+\t\t\t\t}\n+\t\t\t\treturn ch->last_state;\n \t\t\t} else {\n \t\t\t\tread->force_fetch = GF_TRUE;\n \t\t\t\tbreak;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\t} else if (ch->last_state==GF_ISOM_INVALID_FILE) {",
                "\t\t\t\tif (!ch->eos_sent) {",
                "\t\t\t\t\tch->eos_sent = GF_TRUE;",
                "\t\t\t\t\tread->eos_signaled = GF_TRUE;",
                "\t\t\t\t\tgf_filter_pid_set_eos(ch->pid);",
                "\t\t\t\t}",
                "\t\t\t\treturn ch->last_state;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-40592",
        "func_name": "gpac/isor_reader_get_sample",
        "description": "GPAC version before commit 71460d72ec07df766dab0a4d52687529f3efcf0a (version v1.0.1 onwards) contains loop with unreachable exit condition ('infinite loop') vulnerability in ISOBMFF reader filter, isoffin_read.c. Function isoffin_process() can result in DoS by infinite loop. To exploit, the victim must open a specially crafted mp4 file.",
        "git_url": "https://github.com/gpac/gpac/commit/71460d72ec07df766dab0a4d52687529f3efcf0a",
        "commit_title": "fixed #1876",
        "commit_text": "",
        "func_before": "void isor_reader_get_sample(ISOMChannel *ch)\n{\n\tGF_Err e;\n\tu32 sample_desc_index;\n\tif (ch->sample) return;\n\n\tif (ch->next_track) {\n\t\tch->track = ch->next_track;\n\t\tch->next_track = 0;\n\t}\n\n\tif (ch->to_init) {\n\t\tinit_reader(ch);\n\t\tsample_desc_index = ch->last_sample_desc_index;\n\t} else if (ch->speed < 0) {\n\t\tif (ch->last_state == GF_EOS) {\n\t\t\tch->sample = NULL;\n\t\t\treturn;\n\t\t}\n\n\t\tif (ch->static_sample->IsRAP) {\n\t\t\tch->last_rap_sample_time = ch->sample_time;\n\t\t}\n\n\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, NULL);\n\n\t\tif ((e==GF_EOS) || (ch->static_sample->IsRAP)) {\n\t\t\tif (!ch->last_rap_sample_time) {\n\t\t\t\te = GF_EOS;\n\t\t\t} else {\n\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->last_rap_sample_time - 1, &sample_desc_index, GF_ISOM_SEARCH_SYNC_BACKWARD, &ch->static_sample, &ch->sample_num, NULL);\n\t\t\t}\n\t\t}\n\n\t\tif (e) {\n\t\t\tif ((e==GF_EOS) && !ch->owner->frag_type) {\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t}\n\t\t\tch->sample = NULL;\n\t\t\treturn;\n\t\t}\n\t\tch->sample = ch->static_sample;\n\n\t\tif (ch->sample->DTS == ch->sample_time) {\n\t\t\tif (!ch->owner->frag_type) {\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t}\n\t\t}\n\t\tif (ch->sample) {\n\t\t\tch->sample_time = ch->sample->DTS;\n\t\t}\n\n\t} else if (ch->has_edit_list) {\n\t\tu32 prev_sample = ch->sample_num;\n\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\n\t\tif (e == GF_OK) {\n\t\t\tch->sample = ch->static_sample;\n\n\t\t\t/*we are in forced seek mode: fetch all samples before the one matching the sample time*/\n\t\t\tif (ch->edit_sync_frame) {\n\t\t\t\tch->edit_sync_frame++;\n\t\t\t\tif (ch->edit_sync_frame < ch->sample_num) {\n\t\t\t\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->edit_sync_frame, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\t\t\t\tch->sample->DTS = ch->sample_time;\n\t\t\t\t\tch->sample->CTS_Offset = 0;\n\t\t\t\t} else {\n\t\t\t\t\tch->edit_sync_frame = 0;\n\t\t\t\t\tif (ch->sample) ch->sample_time = ch->sample->DTS;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*if we get the same sample, figure out next interesting time (current sample + DTS gap to next sample should be a good bet)*/\n\t\t\t\tif (prev_sample == ch->sample_num) {\n\t\t\t\t\tif (ch->owner->frag_type && (ch->sample_num==gf_isom_get_sample_count(ch->owner->mov, ch->track))) {\n\t\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu32 sample_num = ch->sample_num ? ch->sample_num : 1;\n\n\t\t\t\t\t\tif (sample_num >= gf_isom_get_sample_count(ch->owner->mov, ch->track) ) {\n\t\t\t\t\t\t\t//e = GF_EOS;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tu32 time_diff = gf_isom_get_sample_duration(ch->owner->mov, ch->track, sample_num);\n\t\t\t\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + time_diff, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\t\t\t\t\t\t\tif (e==GF_OK) {\n\t\t\t\t\t\t\t\tif (ch->sample_num == prev_sample) {\n\t\t\t\t\t\t\t\t\tch->sample_time += time_diff;\n\t\t\t\t\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tch->sample = ch->static_sample;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*we jumped to another segment - if RAP is needed look for closest rap in decoding order and\n\t\t\t\tforce seek mode*/\n\t\t\t\tif (ch->sample && !ch->sample->IsRAP && ch->has_rap && (ch->sample_num != prev_sample+1)) {\n\t\t\t\t\tGF_ISOSample *found = ch->static_sample;\n\t\t\t\t\tu32 samp_num = ch->sample_num;\n\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_SYNC_BACKWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\n\t\t\t\t\tif (e == GF_OK) ch->sample = ch->static_sample;\n\n\t\t\t\t\t/*if no sync point in the past, use the first non-sync for the given time*/\n\t\t\t\t\tif (!ch->sample || !ch->sample->data) {\n\t\t\t\t\t\tch->sample = ch->static_sample = found;\n\t\t\t\t\t\tch->sample_time = ch->sample->DTS;\n\t\t\t\t\t\tch->sample_num = samp_num;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tch->sample = ch->static_sample;\n\t\t\t\t\t\tch->edit_sync_frame = ch->sample_num;\n\t\t\t\t\t\tch->sample->DTS = ch->sample_time;\n\t\t\t\t\t\tch->sample->CTS_Offset = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (ch->sample) ch->sample_time = ch->sample->DTS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBool do_fetch = GF_TRUE;\n\t\tch->sample_num++;\n\n\t\tif (ch->sap_only) {\n\t\t\tBool is_rap = gf_isom_get_sample_sync(ch->owner->mov, ch->track, ch->sample_num);\n\t\t\tif (!is_rap) {\n\t\t\t\tGF_ISOSampleRollType roll_type;\n\t\t\t\tgf_isom_get_sample_rap_roll_info(ch->owner->mov, ch->track, ch->sample_num, &is_rap, &roll_type, NULL);\n\t\t\t\tif (roll_type) is_rap = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (!is_rap) {\n\t\t\t\tdo_fetch = GF_FALSE;\n\t\t\t} else if (ch->sap_only==2) {\n\t\t\t\tch->sap_only = 0;\n\t\t\t}\n\t\t}\n\t\tif (do_fetch) {\n\t\t\tif (ch->owner->nodata) {\n\t\t\t\tch->sample = gf_isom_get_sample_info_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, &ch->sample_data_offset, ch->static_sample);\n\t\t\t} else {\n\t\t\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\t\t}\n\t\t\t/*if sync shadow / carousel RAP skip*/\n\t\t\tif (ch->sample && (ch->sample->IsRAP==RAP_REDUNDANT)) {\n\t\t\t\tch->sample = NULL;\n\t\t\t\tch->sample_num++;\n\t\t\t\tisor_reader_get_sample(ch);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t//check scalable track change\n\tif (ch->sample && ch->sample->IsRAP && ch->next_track) {\n\t\tch->track = ch->next_track;\n\t\tch->next_track = 0;\n\t\tch->sample = NULL;\n\t\tisor_reader_get_sample(ch);\n\t\treturn;\n\t}\n\n\tif (!ch->sample) {\n\t\tu32 sample_count = gf_isom_get_sample_count(ch->owner->mov, ch->track);\n\t\tch->sample_data_offset = 0;\n\t\t/*incomplete file - check if we're still downloading or not*/\n\t\tif (gf_isom_get_missing_bytes(ch->owner->mov, ch->track)) {\n\t\t\tch->last_state = GF_ISOM_INCOMPLETE_FILE;\n\t\t\tif (ch->owner->mem_load_mode==2)\n\t\t\t\tch->owner->force_fetch = GF_TRUE;\n\n\t\t\tif (!ch->owner->input_loaded) {\n\t\t\t\tch->last_state = GF_OK;\n\t\t\t\tif (!ch->has_edit_list && ch->sample_num)\n\t\t\t\t\tch->sample_num--;\n\t\t\t} else {\n\t\t\t\tif (ch->sample_num >= gf_isom_get_sample_count(ch->owner->mov, ch->track)) {\n\t\t\t\t\tch->last_state = GF_EOS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!ch->sample_num\n\t\t         || ((ch->speed >= 0) && (ch->sample_num >= sample_count))\n\t\t         || ((ch->speed < 0) && (ch->sample_time == gf_isom_get_current_tfdt(ch->owner->mov, ch->track) ))\n\t\t        ) {\n\n\t\t\tif (ch->owner->frag_type==1) {\n\t\t\t\t/*if sample cannot be found and file is fragmented, rewind sample*/\n\t\t\t\tif (ch->sample_num) ch->sample_num--;\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t} else if (ch->last_state != GF_EOS) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[IsoMedia] Track #%d end of stream reached\\n\", ch->track));\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t\tif (ch->sample_num>sample_count) ch->sample_num = sample_count;\n\t\t\t} else {\n\t\t\t\tif (ch->sample_num>sample_count) ch->sample_num = sample_count;\n\t\t\t}\n\t\t} else {\n\t\t\te = gf_isom_last_error(ch->owner->mov);\n\t\t\tGF_LOG((e==GF_ISOM_INCOMPLETE_FILE) ? GF_LOG_DEBUG : GF_LOG_WARNING, GF_LOG_DASH, (\"[IsoMedia] Track #%d fail to fetch sample %d / %d: %s\\n\", ch->track, ch->sample_num, gf_isom_get_sample_count(ch->owner->mov, ch->track), gf_error_to_string(e) ));\n\t\t}\n\t\treturn;\n\t}\n\n\tif (sample_desc_index != ch->last_sample_desc_index) {\n\t\tif (!ch->owner->stsd) {\n\t\t\t//we used sample entry 1 by default to setup, if no active prev sample (edit list might trigger this)\n\t\t\t//and new sample desc is 1, do not reconfigure\n\t\t\tif (!ch->last_sample_desc_index && (sample_desc_index==1)) {\n\n\t\t\t} else {\n\t\t\t\tch->needs_pid_reconfig = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\tch->last_sample_desc_index = sample_desc_index;\n\t}\n\n\tch->last_state = GF_OK;\n\tch->au_duration = gf_isom_get_sample_duration(ch->owner->mov, ch->track, ch->sample_num);\n\n\tch->sap_3 = GF_FALSE;\n\tch->sap_4_type = 0;\n\tch->roll = 0;\n\tch->set_disc = ch->owner->clock_discontinuity ? 2 : 0;\n\tch->owner->clock_discontinuity = 0;\n\n\tif (ch->sample) {\n\t\tgf_isom_get_sample_rap_roll_info(ch->owner->mov, ch->track, ch->sample_num, &ch->sap_3, &ch->sap_4_type, &ch->roll);\n\n\t\t/*still seeking or not ?\n\t\t 1- when speed is negative, the RAP found is \"after\" the seek point in playback order since we used backward RAP search: nothing to do\n\t\t 2- otherwise set DTS+CTS to start value\n\t\t */\n\t\tif ((ch->speed < 0) || (ch->start <= ch->sample->DTS + ch->sample->CTS_Offset)) {\n\t\t\tch->dts = ch->sample->DTS;\n\t\t\tch->cts = ch->sample->DTS + ch->sample->CTS_Offset;\n\t\t\tch->seek_flag = 0;\n\t\t} else {\n\t\t\tch->cts = ch->start;\n\t\t\tch->seek_flag = 1;\n\t\t\tch->dts = ch->start;\n\t\t}\n\n\t\tif (ch->end && (ch->end < ch->sample->DTS + ch->sample->CTS_Offset + ch->au_duration)) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] End of Channel \"LLD\" (CTS \"LLD\")\\n\", ch->end, ch->sample->DTS + ch->sample->CTS_Offset));\n\t\t\tch->sample = NULL;\n\t\t\tch->last_state = GF_EOS;\n\t\t\tch->playing = 2;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (ch->owner->last_sender_ntp && ch->cts==ch->owner->cts_for_last_sender_ntp) {\n\t\tch->sender_ntp = ch->owner->last_sender_ntp;\n\t\tch->ntp_at_server_ntp = ch->owner->ntp_at_last_sender_ntp;\n\t} else if (ch->owner->last_sender_ntp && ch->dts==ch->owner->cts_for_last_sender_ntp) {\n\t\tch->sender_ntp = ch->owner->last_sender_ntp;\n\t\tch->ntp_at_server_ntp = ch->owner->ntp_at_last_sender_ntp;\n\t} else {\n\t\tch->sender_ntp = ch->ntp_at_server_ntp = 0;\n\t}\n\n\tif (!ch->sample_num) return;\n\n\tgf_isom_get_sample_flags(ch->owner->mov, ch->track, ch->sample_num, &ch->isLeading, &ch->dependsOn, &ch->dependedOn, &ch->redundant);\n\n\tif (ch->is_encrypted) {\n\t\t/*in case of CENC: we write sample auxiliary information to slh->sai; its size is in saiz*/\n\t\tif (gf_isom_is_cenc_media(ch->owner->mov, ch->track, ch->last_sample_desc_index)) {\n\t\t\tisor_update_cenc_info(ch, GF_FALSE);\n\n\t\t} else if (gf_isom_is_media_encrypted(ch->owner->mov, ch->track, ch->last_sample_desc_index)) {\n\t\t\tch->pck_encrypted = GF_TRUE;\n\t\t} else {\n\t\t\tch->pck_encrypted = GF_FALSE;\n\t\t}\n\t}\n\tif (ch->sample && ch->sample->nb_pack)\n\t\tch->sample_num += ch->sample->nb_pack-1;\n}",
        "func": "void isor_reader_get_sample(ISOMChannel *ch)\n{\n\tGF_Err e;\n\tu32 sample_desc_index;\n\tif (ch->sample) return;\n\n\tif (ch->next_track) {\n\t\tch->track = ch->next_track;\n\t\tch->next_track = 0;\n\t}\n\n\tif (ch->to_init) {\n\t\tinit_reader(ch);\n\t\tsample_desc_index = ch->last_sample_desc_index;\n\t} else if (ch->speed < 0) {\n\t\tif (ch->last_state == GF_EOS) {\n\t\t\tch->sample = NULL;\n\t\t\treturn;\n\t\t}\n\n\t\tif (ch->static_sample->IsRAP) {\n\t\t\tch->last_rap_sample_time = ch->sample_time;\n\t\t}\n\n\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, NULL);\n\n\t\tif ((e==GF_EOS) || (ch->static_sample->IsRAP)) {\n\t\t\tif (!ch->last_rap_sample_time) {\n\t\t\t\te = GF_EOS;\n\t\t\t} else {\n\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->last_rap_sample_time - 1, &sample_desc_index, GF_ISOM_SEARCH_SYNC_BACKWARD, &ch->static_sample, &ch->sample_num, NULL);\n\t\t\t}\n\t\t}\n\n\t\tif (e) {\n\t\t\tif ((e==GF_EOS) && !ch->owner->frag_type) {\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t}\n\t\t\tch->sample = NULL;\n\t\t\treturn;\n\t\t}\n\t\tch->sample = ch->static_sample;\n\n\t\tif (ch->sample->DTS == ch->sample_time) {\n\t\t\tif (!ch->owner->frag_type) {\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t}\n\t\t}\n\t\tif (ch->sample) {\n\t\t\tch->sample_time = ch->sample->DTS;\n\t\t}\n\n\t} else if (ch->has_edit_list) {\n\t\tu32 prev_sample = ch->sample_num;\n\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\n\t\tif (e == GF_OK) {\n\t\t\tch->sample = ch->static_sample;\n\n\t\t\t/*we are in forced seek mode: fetch all samples before the one matching the sample time*/\n\t\t\tif (ch->edit_sync_frame) {\n\t\t\t\tch->edit_sync_frame++;\n\t\t\t\tif (ch->edit_sync_frame < ch->sample_num) {\n\t\t\t\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->edit_sync_frame, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\t\t\t\tch->sample->DTS = ch->sample_time;\n\t\t\t\t\tch->sample->CTS_Offset = 0;\n\t\t\t\t} else {\n\t\t\t\t\tch->edit_sync_frame = 0;\n\t\t\t\t\tif (ch->sample) ch->sample_time = ch->sample->DTS;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*if we get the same sample, figure out next interesting time (current sample + DTS gap to next sample should be a good bet)*/\n\t\t\t\tif (prev_sample == ch->sample_num) {\n\t\t\t\t\tif (ch->owner->frag_type && (ch->sample_num==gf_isom_get_sample_count(ch->owner->mov, ch->track))) {\n\t\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu32 sample_num = ch->sample_num ? ch->sample_num : 1;\n\n\t\t\t\t\t\tif (sample_num >= gf_isom_get_sample_count(ch->owner->mov, ch->track) ) {\n\t\t\t\t\t\t\t//e = GF_EOS;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tu32 time_diff = gf_isom_get_sample_duration(ch->owner->mov, ch->track, sample_num);\n\t\t\t\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + time_diff, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\t\t\t\t\t\t\tif (e==GF_OK) {\n\t\t\t\t\t\t\t\tif (ch->sample_num == prev_sample) {\n\t\t\t\t\t\t\t\t\tch->sample_time += time_diff;\n\t\t\t\t\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tch->sample = ch->static_sample;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*we jumped to another segment - if RAP is needed look for closest rap in decoding order and\n\t\t\t\tforce seek mode*/\n\t\t\t\tif (ch->sample && !ch->sample->IsRAP && ch->has_rap && (ch->sample_num != prev_sample+1)) {\n\t\t\t\t\tGF_ISOSample *found = ch->static_sample;\n\t\t\t\t\tu32 samp_num = ch->sample_num;\n\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_SYNC_BACKWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\n\t\t\t\t\tif (e == GF_OK) ch->sample = ch->static_sample;\n\n\t\t\t\t\t/*if no sync point in the past, use the first non-sync for the given time*/\n\t\t\t\t\tif (!ch->sample || !ch->sample->data) {\n\t\t\t\t\t\tch->sample = ch->static_sample = found;\n\t\t\t\t\t\tch->sample_time = ch->sample->DTS;\n\t\t\t\t\t\tch->sample_num = samp_num;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tch->sample = ch->static_sample;\n\t\t\t\t\t\tch->edit_sync_frame = ch->sample_num;\n\t\t\t\t\t\tch->sample->DTS = ch->sample_time;\n\t\t\t\t\t\tch->sample->CTS_Offset = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (ch->sample) ch->sample_time = ch->sample->DTS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBool do_fetch = GF_TRUE;\n\t\tch->sample_num++;\n\n\t\tif (ch->sap_only) {\n\t\t\tBool is_rap = gf_isom_get_sample_sync(ch->owner->mov, ch->track, ch->sample_num);\n\t\t\tif (!is_rap) {\n\t\t\t\tGF_ISOSampleRollType roll_type;\n\t\t\t\tgf_isom_get_sample_rap_roll_info(ch->owner->mov, ch->track, ch->sample_num, &is_rap, &roll_type, NULL);\n\t\t\t\tif (roll_type) is_rap = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (!is_rap) {\n\t\t\t\tdo_fetch = GF_FALSE;\n\t\t\t} else if (ch->sap_only==2) {\n\t\t\t\tch->sap_only = 0;\n\t\t\t}\n\t\t}\n\t\tif (do_fetch) {\n\t\t\tif (ch->owner->nodata) {\n\t\t\t\tch->sample = gf_isom_get_sample_info_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, &ch->sample_data_offset, ch->static_sample);\n\t\t\t} else {\n\t\t\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\t\t}\n\t\t\t/*if sync shadow / carousel RAP skip*/\n\t\t\tif (ch->sample && (ch->sample->IsRAP==RAP_REDUNDANT)) {\n\t\t\t\tch->sample = NULL;\n\t\t\t\tch->sample_num++;\n\t\t\t\tisor_reader_get_sample(ch);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t//check scalable track change\n\tif (ch->sample && ch->sample->IsRAP && ch->next_track) {\n\t\tch->track = ch->next_track;\n\t\tch->next_track = 0;\n\t\tch->sample = NULL;\n\t\tisor_reader_get_sample(ch);\n\t\treturn;\n\t}\n\n\tif (!ch->sample) {\n\t\tu32 sample_count = gf_isom_get_sample_count(ch->owner->mov, ch->track);\n\t\tch->sample_data_offset = 0;\n\t\t/*incomplete file - check if we're still downloading or not*/\n\t\tif (gf_isom_get_missing_bytes(ch->owner->mov, ch->track)) {\n\t\t\tch->last_state = GF_ISOM_INCOMPLETE_FILE;\n\t\t\tif (ch->owner->mem_load_mode==2)\n\t\t\t\tch->owner->force_fetch = GF_TRUE;\n\n\t\t\tif (!ch->owner->input_loaded) {\n\t\t\t\tch->last_state = GF_OK;\n\t\t\t\tif (!ch->has_edit_list && ch->sample_num)\n\t\t\t\t\tch->sample_num--;\n\t\t\t} else {\n\t\t\t\tif (ch->to_init && ch->sample_num) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] Failed to fetch initial sample %d for track %d\\n\"));\n\t\t\t\t\tch->last_state = GF_ISOM_INVALID_FILE;\n\t\t\t\t}\n\t\t\t\tif (ch->sample_num >= gf_isom_get_sample_count(ch->owner->mov, ch->track)) {\n\t\t\t\t\tch->last_state = GF_EOS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!ch->sample_num\n\t\t         || ((ch->speed >= 0) && (ch->sample_num >= sample_count))\n\t\t         || ((ch->speed < 0) && (ch->sample_time == gf_isom_get_current_tfdt(ch->owner->mov, ch->track) ))\n\t\t        ) {\n\n\t\t\tif (ch->owner->frag_type==1) {\n\t\t\t\t/*if sample cannot be found and file is fragmented, rewind sample*/\n\t\t\t\tif (ch->sample_num) ch->sample_num--;\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t} else if (ch->last_state != GF_EOS) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[IsoMedia] Track #%d end of stream reached\\n\", ch->track));\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t\tif (ch->sample_num>sample_count) ch->sample_num = sample_count;\n\t\t\t} else {\n\t\t\t\tif (ch->sample_num>sample_count) ch->sample_num = sample_count;\n\t\t\t}\n\t\t} else {\n\t\t\te = gf_isom_last_error(ch->owner->mov);\n\t\t\tGF_LOG((e==GF_ISOM_INCOMPLETE_FILE) ? GF_LOG_DEBUG : GF_LOG_WARNING, GF_LOG_DASH, (\"[IsoMedia] Track #%d fail to fetch sample %d / %d: %s\\n\", ch->track, ch->sample_num, gf_isom_get_sample_count(ch->owner->mov, ch->track), gf_error_to_string(e) ));\n\t\t}\n\t\treturn;\n\t}\n\n\tif (sample_desc_index != ch->last_sample_desc_index) {\n\t\tif (!ch->owner->stsd) {\n\t\t\t//we used sample entry 1 by default to setup, if no active prev sample (edit list might trigger this)\n\t\t\t//and new sample desc is 1, do not reconfigure\n\t\t\tif (!ch->last_sample_desc_index && (sample_desc_index==1)) {\n\n\t\t\t} else {\n\t\t\t\tch->needs_pid_reconfig = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\tch->last_sample_desc_index = sample_desc_index;\n\t}\n\n\tch->last_state = GF_OK;\n\tch->au_duration = gf_isom_get_sample_duration(ch->owner->mov, ch->track, ch->sample_num);\n\n\tch->sap_3 = GF_FALSE;\n\tch->sap_4_type = 0;\n\tch->roll = 0;\n\tch->set_disc = ch->owner->clock_discontinuity ? 2 : 0;\n\tch->owner->clock_discontinuity = 0;\n\n\tif (ch->sample) {\n\t\tgf_isom_get_sample_rap_roll_info(ch->owner->mov, ch->track, ch->sample_num, &ch->sap_3, &ch->sap_4_type, &ch->roll);\n\n\t\t/*still seeking or not ?\n\t\t 1- when speed is negative, the RAP found is \"after\" the seek point in playback order since we used backward RAP search: nothing to do\n\t\t 2- otherwise set DTS+CTS to start value\n\t\t */\n\t\tif ((ch->speed < 0) || (ch->start <= ch->sample->DTS + ch->sample->CTS_Offset)) {\n\t\t\tch->dts = ch->sample->DTS;\n\t\t\tch->cts = ch->sample->DTS + ch->sample->CTS_Offset;\n\t\t\tch->seek_flag = 0;\n\t\t} else {\n\t\t\tch->cts = ch->start;\n\t\t\tch->seek_flag = 1;\n\t\t\tch->dts = ch->start;\n\t\t}\n\n\t\tif (ch->end && (ch->end < ch->sample->DTS + ch->sample->CTS_Offset + ch->au_duration)) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[IsoMedia] End of Channel \"LLD\" (CTS \"LLD\")\\n\", ch->end, ch->sample->DTS + ch->sample->CTS_Offset));\n\t\t\tch->sample = NULL;\n\t\t\tch->last_state = GF_EOS;\n\t\t\tch->playing = 2;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (ch->owner->last_sender_ntp && ch->cts==ch->owner->cts_for_last_sender_ntp) {\n\t\tch->sender_ntp = ch->owner->last_sender_ntp;\n\t\tch->ntp_at_server_ntp = ch->owner->ntp_at_last_sender_ntp;\n\t} else if (ch->owner->last_sender_ntp && ch->dts==ch->owner->cts_for_last_sender_ntp) {\n\t\tch->sender_ntp = ch->owner->last_sender_ntp;\n\t\tch->ntp_at_server_ntp = ch->owner->ntp_at_last_sender_ntp;\n\t} else {\n\t\tch->sender_ntp = ch->ntp_at_server_ntp = 0;\n\t}\n\n\tif (!ch->sample_num) return;\n\n\tgf_isom_get_sample_flags(ch->owner->mov, ch->track, ch->sample_num, &ch->isLeading, &ch->dependsOn, &ch->dependedOn, &ch->redundant);\n\n\tif (ch->is_encrypted) {\n\t\t/*in case of CENC: we write sample auxiliary information to slh->sai; its size is in saiz*/\n\t\tif (gf_isom_is_cenc_media(ch->owner->mov, ch->track, ch->last_sample_desc_index)) {\n\t\t\tisor_update_cenc_info(ch, GF_FALSE);\n\n\t\t} else if (gf_isom_is_media_encrypted(ch->owner->mov, ch->track, ch->last_sample_desc_index)) {\n\t\t\tch->pck_encrypted = GF_TRUE;\n\t\t} else {\n\t\t\tch->pck_encrypted = GF_FALSE;\n\t\t}\n\t}\n\tif (ch->sample && ch->sample->nb_pack)\n\t\tch->sample_num += ch->sample->nb_pack-1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -177,6 +177,10 @@\n \t\t\t\tif (!ch->has_edit_list && ch->sample_num)\n \t\t\t\t\tch->sample_num--;\n \t\t\t} else {\n+\t\t\t\tif (ch->to_init && ch->sample_num) {\n+\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] Failed to fetch initial sample %d for track %d\\n\"));\n+\t\t\t\t\tch->last_state = GF_ISOM_INVALID_FILE;\n+\t\t\t\t}\n \t\t\t\tif (ch->sample_num >= gf_isom_get_sample_count(ch->owner->mov, ch->track)) {\n \t\t\t\t\tch->last_state = GF_EOS;\n \t\t\t\t}",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\t\tif (ch->to_init && ch->sample_num) {",
                "\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] Failed to fetch initial sample %d for track %d\\n\"));",
                "\t\t\t\t\tch->last_state = GF_ISOM_INVALID_FILE;",
                "\t\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7322",
        "func_name": "wireshark/dissect_dcm_tag",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-dcm.c had an infinite loop that was addressed by checking for integer wraparound.",
        "git_url": "https://github.com/wireshark/wireshark/commit/afc780e2c796e971bb7d164103f4f0d10d3c25b5",
        "commit_title": "DICOM: Prevent infinite loop (dissect_dcm_tag)",
        "commit_text": " uint32 value could wrap around, resulting in infinite loop.  Bug: 14411 (cherry picked from commit b6328eba6a3d33930489709ee1e47140dcc30dfb)",
        "func_before": "static guint32\ndissect_dcm_tag(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                dcm_state_pdv_t *pdv, guint32 offset, guint32 endpos,\n                gboolean is_first_tag, const gchar **tag_description,\n                gboolean *end_of_seq_or_item)\n{\n    /* Decode one tag. If it is a sequence or item start create a subtree.\n       Returns new offset.\n    */\n\n    proto_tree  *tag_ptree = NULL;      /* Tree for decoded tag details */\n    proto_tree  *seq_ptree = NULL;      /* Possible subtree for sequences and items */\n\n    proto_item  *tag_pitem = NULL;\n    dcm_tag_t   *tag_def   = NULL;\n\n    gint ett;\n\n    const gchar *vr = NULL;\n    gchar       *tag_value = NULL;      /* Tag Value converted to a string      */\n    gchar       *tag_summary;\n\n    guint32 vl = 0;\n    guint16 vl_1 = 0;\n    guint16 vl_2 = 0;\n\n    guint32 offset_tag   = 0;           /* Remember offsets for tree, since the tree    */\n    guint32 offset_vr    = 0;           /* header is created pretty late                */\n    guint32 offset_vl    = 0;\n\n    guint32 vl_max = 0;                 /* Max Value Length to Parse */\n\n    guint16 grp = 0;\n    guint16 elm = 0;\n\n    guint32 len_decoded_remaing = 0;\n\n    gboolean is_little_endian = FALSE;\n    gboolean is_implicit = FALSE;\n    gboolean is_vl_long = FALSE;            /* True for 4 Bytes length fields */\n\n    gboolean is_sequence = FALSE;           /* True for Sequence Tags */\n    gboolean is_item = FALSE;               /* True for Sequence Item Tags */\n\n    *tag_description = NULL;                /* Reset description. It's wmem packet scope memory, so not really bad*/\n\n    tag_value = (gchar *)wmem_alloc0(wmem_packet_scope(), MAX_BUF_LEN);\n\n    /* Decode the syntax a little more */\n    if (pdv->syntax == DCM_EBE) is_little_endian = FALSE;\n    else                        is_little_endian = TRUE;\n\n    if (pdv->syntax == DCM_ILE) is_implicit = TRUE;\n    else                        is_implicit = FALSE;\n\n    offset_tag = offset;\n\n\n    if (pdv->prev && is_first_tag) {\n        len_decoded_remaing = pdv->prev->open_tag.len_decoded;\n    }\n\n\n    /* Since we may have a fragmented header, check for every attribute,\n       whether we have already decoded left-overs from the previous PDV.\n       Since we have implicit & explicit syntax, copying the open tag to\n       a buffer without decoding, would have caused tvb_get_xxtohs()\n       implementations on the copy.\n\n       An alternative approach would have been to resemble the PDVs first.\n\n       The attempts to reassemble without named sources (to be implemented)\n       were very sensitive to missing packets. In such a case, no packet\n       of a PDV chain was decoded, not even the start.\n\n       So for the time being, use this rather cumbersome approach.\n\n       For every two bytes (PDV length are always a factor of 2)\n       check whether we have enough data in the buffer and store the value\n       accordingly. In the next frame check, whether we have decoded this yet.\n    */\n\n    /* Group */\n    if (len_decoded_remaing >= 2) {\n        grp = pdv->prev->open_tag.grp;\n        len_decoded_remaing -= 2;\n    }\n    else {\n\n        if (dcm_tag_is_open(pdv, offset_tag, offset, endpos, 2)) return endpos; /* Exit if needed */\n\n        if (is_little_endian)   grp = tvb_get_letohs(tvb, offset);\n        else                    grp = tvb_get_ntohs (tvb, offset);\n        offset += 2;\n        pdv->open_tag.grp = grp;\n    }\n\n    /* Element */\n    if (len_decoded_remaing >= 2) {\n        elm = pdv->prev->open_tag.elm;\n        len_decoded_remaing -= 2;\n    }\n    else {\n\n        if (dcm_tag_is_open(pdv, offset_tag, offset, endpos, 2)) return endpos;    /* Exit if needed */\n\n        if (is_little_endian)   elm = tvb_get_letohs(tvb, offset);\n        else                    elm = tvb_get_ntohs (tvb, offset);\n        offset += 2;\n        pdv->open_tag.elm = elm;\n    }\n\n    /* Find the best matching tag */\n    tag_def = dcm_tag_lookup(grp, elm);\n\n    /* Value Representation */\n    offset_vr = offset;\n    if ((grp == 0xFFFE) && (elm == 0xE000 || elm == 0xE00D || elm == 0xE0DD))  {\n        /* Item start, Item Delimitation or Sequence Delimitation */\n        vr = \"UL\";\n        is_vl_long = TRUE;                          /* These tags always have a 4 byte length field */\n    }\n    else if (is_implicit) {\n        /* Get VR from tag definition */\n        vr = wmem_strdup(wmem_packet_scope(), tag_def->vr);\n        is_vl_long = TRUE;                          /* Implicit always has 4 byte length field */\n    }\n    else {\n\n        if (len_decoded_remaing >= 2) {\n            vr = wmem_strdup(wmem_packet_scope(), pdv->prev->open_tag.vr);\n            len_decoded_remaing -= 2;\n        }\n        else {\n\n            /* Controlled exit, if VR does not fit. */\n            if (dcm_tag_is_open(pdv, offset_tag, offset_vr, endpos, 2)) return endpos;\n\n            vr = (gchar *)tvb_get_string_enc(wmem_packet_scope(), tvb, offset, 2, ENC_ASCII);\n            offset += 2;\n\n            g_free(pdv->open_tag.vr);\n            pdv->open_tag.vr = g_strdup(vr);        /* needs to survive withing a session */\n        }\n\n\n        if ((strcmp(vr, \"OB\") == 0) || (strcmp(vr, \"OW\") == 0) || (strcmp(vr, \"OF\") == 0) ||\n            (strcmp(vr, \"SQ\") == 0) || (strcmp(vr, \"UT\") == 0) || (strcmp(vr, \"UN\") == 0)) {\n            /* 4 bytes specials: OB, OW, OF, SQ, UT or UN */\n            is_vl_long = TRUE;\n\n            /* Skip 2 Bytes */\n            if (len_decoded_remaing >= 2) {\n                len_decoded_remaing -= 2;\n            }\n            else {\n                if (dcm_tag_is_open(pdv, offset_tag, offset_vr, endpos, 2)) return endpos;\n                offset += 2;\n            }\n        }\n        else {\n            is_vl_long = FALSE;\n        }\n    }\n\n\n    /* Value Length. This is rather cumbersome code to get a 4 byte length, but in the\n       fragmented case, we have 2*2 bytes. So always use that pattern\n    */\n\n    offset_vl = offset;\n    if (len_decoded_remaing >= 2) {\n        vl_1 = pdv->prev->open_tag.vl_1;\n        len_decoded_remaing -= 2;\n    }\n    else {\n\n        if (dcm_tag_is_open(pdv, offset_tag, offset_vl, endpos, 2)) return endpos;\n        if (is_little_endian)   vl_1 = tvb_get_letohs(tvb, offset);\n        else                    vl_1 = tvb_get_ntohs(tvb, offset);\n        offset += 2;\n        pdv->open_tag.vl_1 = vl_1;\n    }\n\n    if (is_vl_long) {\n\n        if (len_decoded_remaing >= 2) {\n            vl_2 = pdv->prev->open_tag.vl_2;\n        }\n        else {\n\n            if (dcm_tag_is_open(pdv, offset_tag, offset_vl+2, endpos, 2)) return endpos;\n            if (is_little_endian)       vl_2 = tvb_get_letohs(tvb, offset);\n            else                        vl_2 = tvb_get_ntohs(tvb, offset);\n            offset += 2;\n            pdv->open_tag.vl_2 = vl_2;\n        }\n\n        if (is_little_endian)   vl = (vl_2 << 16) + vl_1;\n        else                    vl = (vl_1 << 16) + vl_2;\n    }\n    else {\n        vl = vl_1;\n    }\n\n    /* Now we have most of the information, except for sequences and items with undefined\n       length :-/. But, whether we know the length or not, we now need to create the tree\n       item and subtree, before we can loop into sequences and items\n\n       Display the information we collected so far. Don't wait until the value is parsed,\n       because that parsing might cause an exception. If that happens within a sequence,\n       the sequence tag would not show up with the value\n\n       Use different ett_ for Sequences & Items, so that fold/unfold state makes sense\n    */\n\n    tag_summary = dcm_tag_summary(grp, elm, vl, tag_def->description, vr, tag_def->is_retired, is_implicit);\n    is_sequence = (strcmp(vr, \"SQ\") == 0) || (vl == 0xFFFFFFFF);\n    is_item = ((grp == 0xFFFE) && (elm == 0xE000));\n\n    if ((is_sequence | is_item) &&  global_dcm_seq_subtree) {\n        ett = is_sequence ? ett_dcm_data_seq : ett_dcm_data_item;\n    } else {\n        ett = ett_dcm_data_tag;\n    }\n\n        if (vl == 0xFFFFFFFF) {\n                /* 'Just' mark header as the length of the item */\n                tag_ptree = proto_tree_add_subtree(tree, tvb, offset_tag, offset - offset_tag,\n                                ett, &tag_pitem, tag_summary);\n                vl_max = 0;         /* We don't know who long this sequence/item is */\n        }\n        else if (offset + vl <= endpos) {\n                /* Show real length of item */\n                tag_ptree = proto_tree_add_subtree(tree, tvb, offset_tag, offset + vl - offset_tag,\n                                ett, &tag_pitem, tag_summary);\n                vl_max = vl;\n        }\n        else {\n                /* Value is longer than what we have in the PDV, -> we do have a OPEN tag */\n                tag_ptree = proto_tree_add_subtree(tree, tvb, offset_tag, endpos - offset_tag,\n                                ett, &tag_pitem, tag_summary);\n                vl_max = endpos - offset;\n        }\n\n    /* If you are going to touch the following 25 lines, make sure you reserve a few hours to go\n       through both display options and check for proper tree display :-)\n    */\n        if (is_sequence | is_item) {\n\n                if (global_dcm_seq_subtree) {\n                        /* Use different ett_ for Sequences & Items, so that fold/unfold state makes sense */\n                        seq_ptree = tag_ptree;\n                        if (!global_dcm_tag_subtree)\n                                tag_ptree = NULL;\n                }\n                else {\n                        seq_ptree = tree;\n                        if (!global_dcm_tag_subtree) {\n                                tag_ptree = NULL;\n                        }\n                }\n        }\n        else {\n                /* For tags */\n                if (!global_dcm_tag_subtree) {\n                        tag_ptree = NULL;\n                }\n        }\n\n        /*  ---------------------------------------------------------------\n        Tag details as separate items\n        ---------------------------------------------------------------\n        */\n\n    proto_tree_add_uint_format_value(tag_ptree, hf_dcm_tag, tvb, offset_tag, 4,\n        (grp << 16) | elm, \"%04x,%04x (%s)\", grp, elm, tag_def->description);\n\n    /* Add VR to tag detail, except for dicom items */\n    if (!is_item)  {\n        if (is_implicit) {\n            /* Select header, since no VR is present in implicit syntax */\n            proto_tree_add_string_format(tag_ptree, hf_dcm_tag_vr, tvb, offset_tag, 4, vr, \"%-8.8s%s\", \"VR:\", vr);\n        }\n        else {\n            proto_tree_add_string_format(tag_ptree, hf_dcm_tag_vr, tvb, offset_vr,  2, vr, \"%-8.8s%s\", \"VR:\", vr);\n        }\n    }\n\n    /* Add length to tag detail */\n    proto_tree_add_uint_format(tag_ptree, hf_dcm_tag_vl, tvb, offset_vl, (is_vl_long ? 4 : 2), vl, \"%-8.8s%u\", \"Length:\", vl);\n\n\n    /*  ---------------------------------------------------------------\n        Finally the Tag Value\n        ---------------------------------------------------------------\n    */\n    if ((is_sequence || is_item) && (vl > 0)) {\n        /* Sequence or Item Start */\n\n        guint32 endpos_item = 0;\n        gboolean local_end_of_seq_or_item = FALSE;\n        gboolean is_first_desc = TRUE;\n\n        const gchar *item_description = NULL;       /* Will be allocated as wmem packet scope memory in dissect_dcm_tag() */\n\n        if (vl == 0xFFFFFFFF) {\n            /* Undefined length */\n\n            while ((!local_end_of_seq_or_item) && (!pdv->open_tag.is_header_fragmented) && (offset < endpos)) {\n\n                offset = dissect_dcm_tag(tvb, pinfo, seq_ptree, pdv, offset, endpos, FALSE,\n                    &item_description, &local_end_of_seq_or_item);\n\n                if (item_description && global_dcm_seq_subtree) {\n                    proto_item_append_text(tag_pitem, (is_first_desc ? \" %s\" : \", %s\"), item_description);\n                    is_first_desc = FALSE;\n                }\n            }\n        }\n        else {\n            /* Defined length */\n            endpos_item = offset + vl_max;\n\n            while (offset < endpos_item) {\n\n                offset = dissect_dcm_tag(tvb, pinfo, seq_ptree, pdv, offset, endpos_item, FALSE,\n                    &item_description, &local_end_of_seq_or_item);\n\n                if (item_description && global_dcm_seq_subtree) {\n                    proto_item_append_text(tag_pitem, (is_first_desc ? \" %s\" : \", %s\"), item_description);\n                    is_first_desc = FALSE;\n                }\n            }\n        }\n    } /*  if ((is_sequence || is_item) && (vl > 0)) */\n    else if ((grp == 0xFFFE) && (elm == 0xE00D)) {\n        /* Item delimitation for items with undefined length */\n        *end_of_seq_or_item = TRUE;\n    }\n    else if ((grp == 0xFFFE) && (elm == 0xE0DD)) {\n        /* Sequence delimitation for sequences with undefined length */\n        *end_of_seq_or_item = TRUE;\n    }\n    else if (vl == 0) {\n        /* No value */\n        g_strlcpy(tag_value, \"<Empty>\", MAX_BUF_LEN);\n    }\n    else if (vl > vl_max) {\n        /* Tag is longer than the PDV/PDU. Don't perform any decoding */\n\n        gchar *tag_desc;\n\n        proto_tree_add_bytes_format(tag_ptree, hf_dcm_tag_value_byte, tvb, offset, vl_max,\n            NULL, \"%-8.8sBytes %d - %d [start]\", \"Value:\", 1, vl_max);\n\n        g_snprintf(tag_value, MAX_BUF_LEN, \"<Bytes %d - %d, start>\", 1, vl_max);\n        offset += vl_max;\n\n        /*  Save the needed data for reuse, and subsequent packets\n            This will leak a little within the session.\n\n            But since we may have tags being closed and reopen in the same PDV\n            we will always need to store this\n        */\n\n        tag_desc = dcm_tag_summary(grp, elm, vl, tag_def->description, vr, tag_def->is_retired, is_implicit);\n\n        if (pdv->open_tag.desc == NULL) {\n            pdv->open_tag.is_value_fragmented = TRUE;\n            pdv->open_tag.desc = wmem_strdup(wmem_file_scope(), tag_desc);\n            pdv->open_tag.len_total = vl;\n            pdv->open_tag.len_remaining = vl - vl_max;\n        }\n    }\n    else {\n        /* Regular value. Identify the type, decode and display */\n\n        offset = dissect_dcm_tag_value(tvb, pinfo, tag_ptree, pdv, offset, grp, elm, vl, vl_max, vr, &tag_value);\n\n        /* -------------------------------------------------------------\n           We have decoded the value. Now store those tags of interest\n           -------------------------------------------------------------\n        */\n\n        /* Store SOP Class and Instance UID in first PDV of this object */\n        if (grp == 0x0008 && elm == 0x0016) {\n            dcm_state_pdv_get_obj_start(pdv)->sop_class_uid = wmem_strdup(wmem_file_scope(), tag_value);\n        }\n        else if (grp == 0x0008 && elm == 0x0018) {\n            dcm_state_pdv_get_obj_start(pdv)->sop_instance_uid = wmem_strdup(wmem_file_scope(), tag_value);\n        }\n        else if (grp == 0x0000 && elm == 0x0100) {\n            /* This is the command tag -> overwrite existing PDV description */\n            pdv->desc = wmem_strdup(wmem_file_scope(), tag_value);\n        }\n    }\n\n\n    /* -------------------------------------------------------------------\n       Add the value to the already constructed item\n       -------------------------------------------------------------------\n    */\n\n    proto_item_append_text(tag_pitem, \" %s\", tag_value);\n\n    if (tag_def->add_to_summary) {\n        *tag_description = wmem_strdup(wmem_packet_scope(), g_strstrip(tag_value));\n    }\n\n    return offset;\n}",
        "func": "static guint32\ndissect_dcm_tag(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                dcm_state_pdv_t *pdv, guint32 offset, guint32 endpos,\n                gboolean is_first_tag, const gchar **tag_description,\n                gboolean *end_of_seq_or_item)\n{\n    /* Decode one tag. If it is a sequence or item start create a subtree.\n       Returns new offset.\n    */\n\n    proto_tree  *tag_ptree = NULL;      /* Tree for decoded tag details */\n    proto_tree  *seq_ptree = NULL;      /* Possible subtree for sequences and items */\n\n    proto_item  *tag_pitem = NULL;\n    dcm_tag_t   *tag_def   = NULL;\n\n    gint ett;\n\n    const gchar *vr = NULL;\n    gchar       *tag_value = NULL;      /* Tag Value converted to a string      */\n    gchar       *tag_summary;\n\n    guint32 vl = 0;\n    guint16 vl_1 = 0;\n    guint16 vl_2 = 0;\n\n    guint32 offset_tag   = 0;           /* Remember offsets for tree, since the tree    */\n    guint32 offset_vr    = 0;           /* header is created pretty late                */\n    guint32 offset_vl    = 0;\n\n    guint32 vl_max = 0;                 /* Max Value Length to Parse */\n\n    guint16 grp = 0;\n    guint16 elm = 0;\n\n    guint32 len_decoded_remaing = 0;\n\n    gboolean is_little_endian = FALSE;\n    gboolean is_implicit = FALSE;\n    gboolean is_vl_long = FALSE;            /* True for 4 Bytes length fields */\n\n    gboolean is_sequence = FALSE;           /* True for Sequence Tags */\n    gboolean is_item = FALSE;               /* True for Sequence Item Tags */\n\n    *tag_description = NULL;                /* Reset description. It's wmem packet scope memory, so not really bad*/\n\n    tag_value = (gchar *)wmem_alloc0(wmem_packet_scope(), MAX_BUF_LEN);\n\n    /* Decode the syntax a little more */\n    if (pdv->syntax == DCM_EBE) is_little_endian = FALSE;\n    else                        is_little_endian = TRUE;\n\n    if (pdv->syntax == DCM_ILE) is_implicit = TRUE;\n    else                        is_implicit = FALSE;\n\n    offset_tag = offset;\n\n\n    if (pdv->prev && is_first_tag) {\n        len_decoded_remaing = pdv->prev->open_tag.len_decoded;\n    }\n\n\n    /* Since we may have a fragmented header, check for every attribute,\n       whether we have already decoded left-overs from the previous PDV.\n       Since we have implicit & explicit syntax, copying the open tag to\n       a buffer without decoding, would have caused tvb_get_xxtohs()\n       implementations on the copy.\n\n       An alternative approach would have been to resemble the PDVs first.\n\n       The attempts to reassemble without named sources (to be implemented)\n       were very sensitive to missing packets. In such a case, no packet\n       of a PDV chain was decoded, not even the start.\n\n       So for the time being, use this rather cumbersome approach.\n\n       For every two bytes (PDV length are always a factor of 2)\n       check whether we have enough data in the buffer and store the value\n       accordingly. In the next frame check, whether we have decoded this yet.\n    */\n\n    /* Group */\n    if (len_decoded_remaing >= 2) {\n        grp = pdv->prev->open_tag.grp;\n        len_decoded_remaing -= 2;\n    }\n    else {\n\n        if (dcm_tag_is_open(pdv, offset_tag, offset, endpos, 2)) return endpos; /* Exit if needed */\n\n        if (is_little_endian)   grp = tvb_get_letohs(tvb, offset);\n        else                    grp = tvb_get_ntohs (tvb, offset);\n        offset += 2;\n        pdv->open_tag.grp = grp;\n    }\n\n    /* Element */\n    if (len_decoded_remaing >= 2) {\n        elm = pdv->prev->open_tag.elm;\n        len_decoded_remaing -= 2;\n    }\n    else {\n\n        if (dcm_tag_is_open(pdv, offset_tag, offset, endpos, 2)) return endpos;    /* Exit if needed */\n\n        if (is_little_endian)   elm = tvb_get_letohs(tvb, offset);\n        else                    elm = tvb_get_ntohs (tvb, offset);\n        offset += 2;\n        pdv->open_tag.elm = elm;\n    }\n\n    /* Find the best matching tag */\n    tag_def = dcm_tag_lookup(grp, elm);\n\n    /* Value Representation */\n    offset_vr = offset;\n    if ((grp == 0xFFFE) && (elm == 0xE000 || elm == 0xE00D || elm == 0xE0DD))  {\n        /* Item start, Item Delimitation or Sequence Delimitation */\n        vr = \"UL\";\n        is_vl_long = TRUE;                          /* These tags always have a 4 byte length field */\n    }\n    else if (is_implicit) {\n        /* Get VR from tag definition */\n        vr = wmem_strdup(wmem_packet_scope(), tag_def->vr);\n        is_vl_long = TRUE;                          /* Implicit always has 4 byte length field */\n    }\n    else {\n\n        if (len_decoded_remaing >= 2) {\n            vr = wmem_strdup(wmem_packet_scope(), pdv->prev->open_tag.vr);\n            len_decoded_remaing -= 2;\n        }\n        else {\n\n            /* Controlled exit, if VR does not fit. */\n            if (dcm_tag_is_open(pdv, offset_tag, offset_vr, endpos, 2)) return endpos;\n\n            vr = (gchar *)tvb_get_string_enc(wmem_packet_scope(), tvb, offset, 2, ENC_ASCII);\n            offset += 2;\n\n            g_free(pdv->open_tag.vr);\n            pdv->open_tag.vr = g_strdup(vr);        /* needs to survive withing a session */\n        }\n\n\n        if ((strcmp(vr, \"OB\") == 0) || (strcmp(vr, \"OW\") == 0) || (strcmp(vr, \"OF\") == 0) ||\n            (strcmp(vr, \"SQ\") == 0) || (strcmp(vr, \"UT\") == 0) || (strcmp(vr, \"UN\") == 0)) {\n            /* 4 bytes specials: OB, OW, OF, SQ, UT or UN */\n            is_vl_long = TRUE;\n\n            /* Skip 2 Bytes */\n            if (len_decoded_remaing >= 2) {\n                len_decoded_remaing -= 2;\n            }\n            else {\n                if (dcm_tag_is_open(pdv, offset_tag, offset_vr, endpos, 2)) return endpos;\n                offset += 2;\n            }\n        }\n        else {\n            is_vl_long = FALSE;\n        }\n    }\n\n\n    /* Value Length. This is rather cumbersome code to get a 4 byte length, but in the\n       fragmented case, we have 2*2 bytes. So always use that pattern\n    */\n\n    offset_vl = offset;\n    if (len_decoded_remaing >= 2) {\n        vl_1 = pdv->prev->open_tag.vl_1;\n        len_decoded_remaing -= 2;\n    }\n    else {\n\n        if (dcm_tag_is_open(pdv, offset_tag, offset_vl, endpos, 2)) return endpos;\n        if (is_little_endian)   vl_1 = tvb_get_letohs(tvb, offset);\n        else                    vl_1 = tvb_get_ntohs(tvb, offset);\n        offset += 2;\n        pdv->open_tag.vl_1 = vl_1;\n    }\n\n    if (is_vl_long) {\n\n        if (len_decoded_remaing >= 2) {\n            vl_2 = pdv->prev->open_tag.vl_2;\n        }\n        else {\n\n            if (dcm_tag_is_open(pdv, offset_tag, offset_vl+2, endpos, 2)) return endpos;\n            if (is_little_endian)       vl_2 = tvb_get_letohs(tvb, offset);\n            else                        vl_2 = tvb_get_ntohs(tvb, offset);\n            offset += 2;\n            pdv->open_tag.vl_2 = vl_2;\n        }\n\n        if (is_little_endian)   vl = (vl_2 << 16) + vl_1;\n        else                    vl = (vl_1 << 16) + vl_2;\n    }\n    else {\n        vl = vl_1;\n    }\n\n    /* Now we have most of the information, except for sequences and items with undefined\n       length :-/. But, whether we know the length or not, we now need to create the tree\n       item and subtree, before we can loop into sequences and items\n\n       Display the information we collected so far. Don't wait until the value is parsed,\n       because that parsing might cause an exception. If that happens within a sequence,\n       the sequence tag would not show up with the value\n\n       Use different ett_ for Sequences & Items, so that fold/unfold state makes sense\n    */\n\n    tag_summary = dcm_tag_summary(grp, elm, vl, tag_def->description, vr, tag_def->is_retired, is_implicit);\n    is_sequence = (strcmp(vr, \"SQ\") == 0) || (vl == 0xFFFFFFFF);\n    is_item = ((grp == 0xFFFE) && (elm == 0xE000));\n\n    if ((is_sequence | is_item) &&  global_dcm_seq_subtree) {\n        ett = is_sequence ? ett_dcm_data_seq : ett_dcm_data_item;\n    } else {\n        ett = ett_dcm_data_tag;\n    }\n\n        if (vl == 0xFFFFFFFF) {\n                /* 'Just' mark header as the length of the item */\n                tag_ptree = proto_tree_add_subtree(tree, tvb, offset_tag, offset - offset_tag,\n                                ett, &tag_pitem, tag_summary);\n                vl_max = 0;         /* We don't know who long this sequence/item is */\n        }\n        else if ((offset + vl <= endpos) &&\n                 (offset + vl > offset)) { /* Ensure no wraparound */\n                /* Show real length of item */\n                tag_ptree = proto_tree_add_subtree(tree, tvb, offset_tag, offset + vl - offset_tag,\n                                ett, &tag_pitem, tag_summary);\n                vl_max = vl;\n        }\n        else {\n                /* Value is longer than what we have in the PDV, -> we do have a OPEN tag */\n                tag_ptree = proto_tree_add_subtree(tree, tvb, offset_tag, endpos - offset_tag,\n                                ett, &tag_pitem, tag_summary);\n                vl_max = endpos - offset;\n        }\n\n    /* If you are going to touch the following 25 lines, make sure you reserve a few hours to go\n       through both display options and check for proper tree display :-)\n    */\n        if (is_sequence | is_item) {\n\n                if (global_dcm_seq_subtree) {\n                        /* Use different ett_ for Sequences & Items, so that fold/unfold state makes sense */\n                        seq_ptree = tag_ptree;\n                        if (!global_dcm_tag_subtree)\n                                tag_ptree = NULL;\n                }\n                else {\n                        seq_ptree = tree;\n                        if (!global_dcm_tag_subtree) {\n                                tag_ptree = NULL;\n                        }\n                }\n        }\n        else {\n                /* For tags */\n                if (!global_dcm_tag_subtree) {\n                        tag_ptree = NULL;\n                }\n        }\n\n        /*  ---------------------------------------------------------------\n        Tag details as separate items\n        ---------------------------------------------------------------\n        */\n\n    proto_tree_add_uint_format_value(tag_ptree, hf_dcm_tag, tvb, offset_tag, 4,\n        (grp << 16) | elm, \"%04x,%04x (%s)\", grp, elm, tag_def->description);\n\n    /* Add VR to tag detail, except for dicom items */\n    if (!is_item)  {\n        if (is_implicit) {\n            /* Select header, since no VR is present in implicit syntax */\n            proto_tree_add_string_format(tag_ptree, hf_dcm_tag_vr, tvb, offset_tag, 4, vr, \"%-8.8s%s\", \"VR:\", vr);\n        }\n        else {\n            proto_tree_add_string_format(tag_ptree, hf_dcm_tag_vr, tvb, offset_vr,  2, vr, \"%-8.8s%s\", \"VR:\", vr);\n        }\n    }\n\n    /* Add length to tag detail */\n    proto_tree_add_uint_format(tag_ptree, hf_dcm_tag_vl, tvb, offset_vl, (is_vl_long ? 4 : 2), vl, \"%-8.8s%u\", \"Length:\", vl);\n\n\n    /*  ---------------------------------------------------------------\n        Finally the Tag Value\n        ---------------------------------------------------------------\n    */\n    if ((is_sequence || is_item) && (vl > 0)) {\n        /* Sequence or Item Start */\n\n        guint32 endpos_item = 0;\n        gboolean local_end_of_seq_or_item = FALSE;\n        gboolean is_first_desc = TRUE;\n\n        const gchar *item_description = NULL;       /* Will be allocated as wmem packet scope memory in dissect_dcm_tag() */\n\n        if (vl == 0xFFFFFFFF) {\n            /* Undefined length */\n\n            while ((!local_end_of_seq_or_item) && (!pdv->open_tag.is_header_fragmented) && (offset < endpos)) {\n\n                offset = dissect_dcm_tag(tvb, pinfo, seq_ptree, pdv, offset, endpos, FALSE,\n                    &item_description, &local_end_of_seq_or_item);\n\n                if (item_description && global_dcm_seq_subtree) {\n                    proto_item_append_text(tag_pitem, (is_first_desc ? \" %s\" : \", %s\"), item_description);\n                    is_first_desc = FALSE;\n                }\n            }\n        }\n        else {\n            /* Defined length */\n            endpos_item = offset + vl_max;\n\n            while (offset < endpos_item) {\n\n                offset = dissect_dcm_tag(tvb, pinfo, seq_ptree, pdv, offset, endpos_item, FALSE,\n                    &item_description, &local_end_of_seq_or_item);\n\n                if (item_description && global_dcm_seq_subtree) {\n                    proto_item_append_text(tag_pitem, (is_first_desc ? \" %s\" : \", %s\"), item_description);\n                    is_first_desc = FALSE;\n                }\n            }\n        }\n    } /*  if ((is_sequence || is_item) && (vl > 0)) */\n    else if ((grp == 0xFFFE) && (elm == 0xE00D)) {\n        /* Item delimitation for items with undefined length */\n        *end_of_seq_or_item = TRUE;\n    }\n    else if ((grp == 0xFFFE) && (elm == 0xE0DD)) {\n        /* Sequence delimitation for sequences with undefined length */\n        *end_of_seq_or_item = TRUE;\n    }\n    else if (vl == 0) {\n        /* No value */\n        g_strlcpy(tag_value, \"<Empty>\", MAX_BUF_LEN);\n    }\n    else if (vl > vl_max) {\n        /* Tag is longer than the PDV/PDU. Don't perform any decoding */\n\n        gchar *tag_desc;\n\n        proto_tree_add_bytes_format(tag_ptree, hf_dcm_tag_value_byte, tvb, offset, vl_max,\n            NULL, \"%-8.8sBytes %d - %d [start]\", \"Value:\", 1, vl_max);\n\n        g_snprintf(tag_value, MAX_BUF_LEN, \"<Bytes %d - %d, start>\", 1, vl_max);\n        offset += vl_max;\n\n        /*  Save the needed data for reuse, and subsequent packets\n            This will leak a little within the session.\n\n            But since we may have tags being closed and reopen in the same PDV\n            we will always need to store this\n        */\n\n        tag_desc = dcm_tag_summary(grp, elm, vl, tag_def->description, vr, tag_def->is_retired, is_implicit);\n\n        if (pdv->open_tag.desc == NULL) {\n            pdv->open_tag.is_value_fragmented = TRUE;\n            pdv->open_tag.desc = wmem_strdup(wmem_file_scope(), tag_desc);\n            pdv->open_tag.len_total = vl;\n            pdv->open_tag.len_remaining = vl - vl_max;\n        }\n    }\n    else {\n        /* Regular value. Identify the type, decode and display */\n\n        offset = dissect_dcm_tag_value(tvb, pinfo, tag_ptree, pdv, offset, grp, elm, vl, vl_max, vr, &tag_value);\n\n        /* -------------------------------------------------------------\n           We have decoded the value. Now store those tags of interest\n           -------------------------------------------------------------\n        */\n\n        /* Store SOP Class and Instance UID in first PDV of this object */\n        if (grp == 0x0008 && elm == 0x0016) {\n            dcm_state_pdv_get_obj_start(pdv)->sop_class_uid = wmem_strdup(wmem_file_scope(), tag_value);\n        }\n        else if (grp == 0x0008 && elm == 0x0018) {\n            dcm_state_pdv_get_obj_start(pdv)->sop_instance_uid = wmem_strdup(wmem_file_scope(), tag_value);\n        }\n        else if (grp == 0x0000 && elm == 0x0100) {\n            /* This is the command tag -> overwrite existing PDV description */\n            pdv->desc = wmem_strdup(wmem_file_scope(), tag_value);\n        }\n    }\n\n\n    /* -------------------------------------------------------------------\n       Add the value to the already constructed item\n       -------------------------------------------------------------------\n    */\n\n    proto_item_append_text(tag_pitem, \" %s\", tag_value);\n\n    if (tag_def->add_to_summary) {\n        *tag_description = wmem_strdup(wmem_packet_scope(), g_strstrip(tag_value));\n    }\n\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -230,7 +230,8 @@\n                                 ett, &tag_pitem, tag_summary);\n                 vl_max = 0;         /* We don't know who long this sequence/item is */\n         }\n-        else if (offset + vl <= endpos) {\n+        else if ((offset + vl <= endpos) &&\n+                 (offset + vl > offset)) { /* Ensure no wraparound */\n                 /* Show real length of item */\n                 tag_ptree = proto_tree_add_subtree(tree, tvb, offset_tag, offset + vl - offset_tag,\n                                 ett, &tag_pitem, tag_summary);",
        "diff_line_info": {
            "deleted_lines": [
                "        else if (offset + vl <= endpos) {"
            ],
            "added_lines": [
                "        else if ((offset + vl <= endpos) &&",
                "                 (offset + vl > offset)) { /* Ensure no wraparound */"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7324",
        "func_name": "wireshark/dissect_sccp_optional_parameters",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-sccp.c had an infinite loop that was addressed by using a correct integer data type.",
        "git_url": "https://github.com/wireshark/wireshark/commit/9e7695bbee18525eaa6d12b32230313ae8a36a81",
        "commit_title": "SCCP: Use int datatype for offset to prevent infinite loops",
        "commit_text": " Fields are 16-bit values and large 16-bit values can be incorrectly treated as negative, causing infinite loops in offset calculations.  Bug: 14413 (cherry picked from commit 620647a3e01d65fef985093cefb9352e21603261)",
        "func_before": "static void\ndissect_sccp_optional_parameters(tvbuff_t *tvb, packet_info *pinfo,\n                                 proto_tree *sccp_tree, proto_tree *tree,\n                                 guint16 offset, sccp_decode_context_t* sccp_info)\n{\n  guint8 parameter_type;\n\n  while ((parameter_type = tvb_get_guint8(tvb, offset)) !=\n         PARAMETER_END_OF_OPTIONAL_PARAMETERS) {\n\n    offset += PARAMETER_TYPE_LENGTH;\n    offset += dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                              parameter_type, offset, sccp_info);\n  }\n\n  /* Process end of optional parameters */\n  dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree, parameter_type, offset,\n                         END_OF_OPTIONAL_PARAMETERS_LENGTH, sccp_info);\n\n}",
        "func": "static void\ndissect_sccp_optional_parameters(tvbuff_t *tvb, packet_info *pinfo,\n                                 proto_tree *sccp_tree, proto_tree *tree,\n                                 int offset, sccp_decode_context_t* sccp_info)\n{\n  guint8 parameter_type;\n\n  while ((parameter_type = tvb_get_guint8(tvb, offset)) !=\n         PARAMETER_END_OF_OPTIONAL_PARAMETERS) {\n\n    offset += PARAMETER_TYPE_LENGTH;\n    offset += dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                              parameter_type, offset, sccp_info);\n  }\n\n  /* Process end of optional parameters */\n  dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree, parameter_type, offset,\n                         END_OF_OPTIONAL_PARAMETERS_LENGTH, sccp_info);\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n static void\n dissect_sccp_optional_parameters(tvbuff_t *tvb, packet_info *pinfo,\n                                  proto_tree *sccp_tree, proto_tree *tree,\n-                                 guint16 offset, sccp_decode_context_t* sccp_info)\n+                                 int offset, sccp_decode_context_t* sccp_info)\n {\n   guint8 parameter_type;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "                                 guint16 offset, sccp_decode_context_t* sccp_info)"
            ],
            "added_lines": [
                "                                 int offset, sccp_decode_context_t* sccp_info)"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7324",
        "func_name": "wireshark/dissect_sccp_message",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-sccp.c had an infinite loop that was addressed by using a correct integer data type.",
        "git_url": "https://github.com/wireshark/wireshark/commit/9e7695bbee18525eaa6d12b32230313ae8a36a81",
        "commit_title": "SCCP: Use int datatype for offset to prevent infinite loops",
        "commit_text": " Fields are 16-bit values and large 16-bit values can be incorrectly treated as negative, causing infinite loops in offset calculations.  Bug: 14413 (cherry picked from commit 620647a3e01d65fef985093cefb9352e21603261)",
        "func_before": "static int\ndissect_sccp_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *sccp_tree,\n                     proto_tree *tree)\n{\n  guint16   variable_pointer1 = 0, variable_pointer2 = 0, variable_pointer3 = 0;\n  guint16   optional_pointer  = 0, orig_opt_ptr = 0;\n  guint16   offset = 0;\n  gboolean  save_fragmented;\n  tvbuff_t *new_tvb = NULL;\n  fragment_head *frag_msg = NULL;\n  guint32   source_local_ref = 0;\n  guint8    more;\n  guint     msg_offset = tvb_offset_from_real_beginning(tvb);\n  sccp_decode_context_t sccp_info = {0, INVALID_LR, INVALID_LR, NULL, NULL};\n\n/* Macro for getting pointer to mandatory variable parameters */\n#define VARIABLE_POINTER(var, hf_var, ptr_size) \\\n  do {                                          \\\n    if (ptr_size == POINTER_LENGTH)             \\\n      var = tvb_get_guint8(tvb, offset);        \\\n    else                                        \\\n      var = tvb_get_letohs(tvb, offset);        \\\n    proto_tree_add_uint(sccp_tree, hf_var, tvb, \\\n                        offset, ptr_size, var); \\\n    var += offset;                              \\\n    if (ptr_size == POINTER_LENGTH_LONG)        \\\n      var += 1;                                 \\\n    offset += ptr_size;                         \\\n  } while (0)\n\n/* Macro for getting pointer to optional parameters */\n#define OPTIONAL_POINTER(ptr_size)                                      \\\n  do {                                                                  \\\n    if (ptr_size == POINTER_LENGTH)                                     \\\n      orig_opt_ptr = optional_pointer = tvb_get_guint8(tvb, offset);    \\\n    else                                                                \\\n      orig_opt_ptr = optional_pointer = tvb_get_letohs(tvb, offset);    \\\n    proto_tree_add_uint(sccp_tree, hf_sccp_optional_pointer, tvb,       \\\n                        offset, ptr_size, optional_pointer);            \\\n    optional_pointer += offset;                                         \\\n    if (ptr_size == POINTER_LENGTH_LONG)                                \\\n      optional_pointer += 1;                                            \\\n    offset += ptr_size;                                                 \\\n  } while (0)\n\n\n  /* Extract the message type;  all other processing is based on this */\n  sccp_info.message_type   = tvb_get_guint8(tvb, SCCP_MSG_TYPE_OFFSET);\n  offset = SCCP_MSG_TYPE_LENGTH;\n\n  /*  Do not change col_add_fstr() to col_append_fstr() here: we _want_\n   *  this call to overwrite whatever's currently in the INFO column (e.g.,\n   *  \"DATA\" from the SCTP dissector).\n   *\n   *  If there's something there that should not be overwritten, whoever\n   *  put that info there should call col_set_fence() to protect it.\n   */\n  col_add_fstr(pinfo->cinfo, COL_INFO, \"%s \",\n               val_to_str(sccp_info.message_type, sccp_message_type_acro_values, \"Unknown: %d\"));\n\n  if (sccp_tree) {\n    /* add the message type to the protocol tree */\n    proto_tree_add_uint(sccp_tree, hf_sccp_message_type, tvb,\n                        SCCP_MSG_TYPE_OFFSET, SCCP_MSG_TYPE_LENGTH, sccp_info.message_type);\n\n  };\n\n  no_assoc.calling_dpc   = 0;\n  no_assoc.called_dpc    = 0;\n  no_assoc.calling_ssn   = INVALID_SSN;\n  no_assoc.called_ssn    = INVALID_SSN;\n  no_assoc.has_fw_key    = FALSE;\n  no_assoc.has_bw_key    = FALSE;\n  no_assoc.payload       = SCCP_PLOAD_NONE;\n  no_assoc.called_party  = NULL;\n  no_assoc.calling_party = NULL;\n  no_assoc.extra_info    = NULL;\n\n  switch (sccp_info.message_type) {\n  case SCCP_MSG_TYPE_CR:\n    /*  TTC and NTT (Japan) say that the connection-oriented messages are\n     *  deleted (not standardized), but they appear to be used anyway, so\n     *  we'll dissect it...\n     */\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_SOURCE_LOCAL_REFERENCE,\n                                     offset, SOURCE_LOCAL_REFERENCE_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_CLASS, offset,\n                                     PROTOCOL_CLASS_LENGTH, &sccp_info);\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n\n    VARIABLE_POINTER(variable_pointer1, hf_sccp_variable_pointer1, POINTER_LENGTH);\n    OPTIONAL_POINTER(POINTER_LENGTH);\n\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_CALLED_PARTY_ADDRESS,\n                                    variable_pointer1, &sccp_info);\n    break;\n\n  case SCCP_MSG_TYPE_CC:\n    /*  TODO: connection has been established;  theoretically we could keep\n     *  keep track of the SLR/DLR with the called/calling from the CR and\n     *  track the connection (e.g., on subsequent messages regarding this\n     *  SLR we could set the global vars \"call*_ssn\" so data could get\n     *  sub-dissected).\n     */\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,\n                                     offset,\n                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_SOURCE_LOCAL_REFERENCE,\n                                     offset, SOURCE_LOCAL_REFERENCE_LENGTH, &sccp_info);\n\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_CLASS, offset,\n                                     PROTOCOL_CLASS_LENGTH, &sccp_info);\n    OPTIONAL_POINTER(POINTER_LENGTH);\n    break;\n\n  case SCCP_MSG_TYPE_CREF:\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,\n                                     offset,\n                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);\n\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_REFUSAL_CAUSE, offset,\n                                     REFUSAL_CAUSE_LENGTH, &sccp_info);\n    OPTIONAL_POINTER(POINTER_LENGTH);\n    break;\n\n  case SCCP_MSG_TYPE_RLSD:\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,\n                                     offset,\n                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_SOURCE_LOCAL_REFERENCE,\n                                     offset, SOURCE_LOCAL_REFERENCE_LENGTH, &sccp_info);\n\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_RELEASE_CAUSE, offset,\n                                     RELEASE_CAUSE_LENGTH, &sccp_info);\n\n    OPTIONAL_POINTER(POINTER_LENGTH);\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n    break;\n\n  case SCCP_MSG_TYPE_RLC:\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,\n                                     offset,\n                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_SOURCE_LOCAL_REFERENCE,\n                                     offset, SOURCE_LOCAL_REFERENCE_LENGTH, &sccp_info);\n\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n    break;\n\n  case SCCP_MSG_TYPE_DT1:\n    source_local_ref = tvb_get_letoh24(tvb, offset);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,\n                                     offset,\n                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);\n\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n\n    more = tvb_get_guint8(tvb, offset) & SEGMENTING_REASSEMBLING_MASK;\n\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_SEGMENTING_REASSEMBLING,\n                                     offset, SEGMENTING_REASSEMBLING_LENGTH, &sccp_info);\n    VARIABLE_POINTER(variable_pointer1, hf_sccp_variable_pointer1, POINTER_LENGTH);\n\n    /* Reassemble */\n    if (!sccp_reassemble) {\n      proto_tree_add_item(sccp_tree, hf_sccp_segmented_data, tvb, variable_pointer1,\n                          tvb_get_guint8(tvb, variable_pointer1)+1, ENC_NA);\n      dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                      PARAMETER_DATA, variable_pointer1, &sccp_info);\n\n    } else {\n      save_fragmented = pinfo->fragmented;\n      pinfo->fragmented = TRUE;\n      frag_msg = fragment_add_seq_next(&sccp_xudt_msg_reassembly_table,\n                                       tvb, variable_pointer1 + 1,\n                                       pinfo,\n                                       source_local_ref,                       /* ID for fragments belonging together */\n                                       NULL,\n                                       tvb_get_guint8(tvb, variable_pointer1), /* fragment length - to the end */\n                                       more);                                  /* More fragments? */\n\n      new_tvb = process_reassembled_data(tvb, variable_pointer1 + 1, pinfo,\n                                         \"Reassembled SCCP\", frag_msg,\n                                         &sccp_xudt_msg_frag_items, NULL,\n                                         tree);\n\n      if (frag_msg && frag_msg->next) { /* Reassembled */\n        col_append_str(pinfo->cinfo, COL_INFO, \"(Message reassembled) \");\n      } else if (more) { /* Not last packet of reassembled message */\n        col_append_str(pinfo->cinfo, COL_INFO, \"(Message fragment) \");\n      }\n\n      pinfo->fragmented = save_fragmented;\n\n      if (new_tvb)\n        dissect_sccp_data_param(new_tvb, pinfo, tree, sccp_info.assoc);\n    }\n\n    /* End reassemble */\n    break;\n\n  case SCCP_MSG_TYPE_DT2:\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,\n                                     offset,\n                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);\n\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_SEQUENCING_SEGMENTING, offset,\n                                     SEQUENCING_SEGMENTING_LENGTH, &sccp_info);\n    break;\n\n  case SCCP_MSG_TYPE_AK:\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,\n                                     offset,\n                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);\n\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_RECEIVE_SEQUENCE_NUMBER,\n                                     offset, RECEIVE_SEQUENCE_NUMBER_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_CREDIT, offset, CREDIT_LENGTH, &sccp_info);\n    break;\n\n  case SCCP_MSG_TYPE_UDT:\n    sccp_info.sccp_msg = new_ud_msg(pinfo, sccp_info.message_type);\n\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_CLASS, offset,\n                                     PROTOCOL_CLASS_LENGTH, &sccp_info);\n    VARIABLE_POINTER(variable_pointer1, hf_sccp_variable_pointer1, POINTER_LENGTH);\n    VARIABLE_POINTER(variable_pointer2, hf_sccp_variable_pointer2, POINTER_LENGTH);\n    VARIABLE_POINTER(variable_pointer3, hf_sccp_variable_pointer3, POINTER_LENGTH);\n\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_CALLED_PARTY_ADDRESS,\n                                    variable_pointer1, &sccp_info);\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_CALLING_PARTY_ADDRESS,\n                                    variable_pointer2, &sccp_info);\n\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree, PARAMETER_DATA,\n                                    variable_pointer3, &sccp_info);\n    break;\n\n  case SCCP_MSG_TYPE_UDTS:\n  {\n    gboolean save_in_error_pkt = pinfo->flags.in_error_pkt;\n    pinfo->flags.in_error_pkt = TRUE;\n\n    sccp_info.sccp_msg = new_ud_msg(pinfo, sccp_info.message_type);\n\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_RETURN_CAUSE, offset,\n                                     RETURN_CAUSE_LENGTH, &sccp_info);\n\n    VARIABLE_POINTER(variable_pointer1, hf_sccp_variable_pointer1, POINTER_LENGTH);\n    VARIABLE_POINTER(variable_pointer2, hf_sccp_variable_pointer2, POINTER_LENGTH);\n    VARIABLE_POINTER(variable_pointer3, hf_sccp_variable_pointer3, POINTER_LENGTH);\n\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_CALLED_PARTY_ADDRESS,\n                                    variable_pointer1, &sccp_info);\n\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_CALLING_PARTY_ADDRESS,\n                                    variable_pointer2, &sccp_info);\n\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree, PARAMETER_DATA,\n                                    variable_pointer3, &sccp_info);\n    pinfo->flags.in_error_pkt = save_in_error_pkt;\n    break;\n  }\n\n  case SCCP_MSG_TYPE_ED:\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,\n                                     offset,\n                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);\n\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n\n    VARIABLE_POINTER(variable_pointer1, hf_sccp_variable_pointer1, POINTER_LENGTH);\n\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree, PARAMETER_DATA,\n                                    variable_pointer1, &sccp_info);\n    break;\n\n  case SCCP_MSG_TYPE_EA:\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,\n                                     offset,\n                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n    break;\n\n  case SCCP_MSG_TYPE_RSR:\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,\n                                     offset,\n                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_SOURCE_LOCAL_REFERENCE,\n                                     offset, SOURCE_LOCAL_REFERENCE_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_RESET_CAUSE, offset,\n                                     RESET_CAUSE_LENGTH, &sccp_info);\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n    break;\n\n  case SCCP_MSG_TYPE_RSC:\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,\n                                     offset,\n                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_SOURCE_LOCAL_REFERENCE,\n                                     offset, SOURCE_LOCAL_REFERENCE_LENGTH, &sccp_info);\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n    break;\n\n  case SCCP_MSG_TYPE_ERR:\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,\n                                     offset,\n                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_ERROR_CAUSE, offset,\n                                     ERROR_CAUSE_LENGTH, &sccp_info);\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n    break;\n\n  case SCCP_MSG_TYPE_IT:\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,\n                                     offset,\n                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_SOURCE_LOCAL_REFERENCE,\n                                     offset, SOURCE_LOCAL_REFERENCE_LENGTH, &sccp_info);\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_CLASS, offset,\n                                     PROTOCOL_CLASS_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_SEQUENCING_SEGMENTING,\n                                     offset, SEQUENCING_SEGMENTING_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_CREDIT, offset, CREDIT_LENGTH, &sccp_info);\n    break;\n\n  case SCCP_MSG_TYPE_XUDT:\n    sccp_info.sccp_msg = new_ud_msg(pinfo, sccp_info.message_type);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_CLASS, offset,\n                                     PROTOCOL_CLASS_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_HOP_COUNTER, offset,\n                                     HOP_COUNTER_LENGTH, &sccp_info);\n\n    VARIABLE_POINTER(variable_pointer1, hf_sccp_variable_pointer1, POINTER_LENGTH);\n    VARIABLE_POINTER(variable_pointer2, hf_sccp_variable_pointer2, POINTER_LENGTH);\n    VARIABLE_POINTER(variable_pointer3, hf_sccp_variable_pointer3, POINTER_LENGTH);\n    OPTIONAL_POINTER(POINTER_LENGTH);\n\n      /*  Optional parameters are Segmentation and Importance\n       *  NOTE 2 - Segmentation Should not be present in case of a single XUDT\n       *  message.\n       */\n\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_CALLED_PARTY_ADDRESS,\n                                    variable_pointer1, &sccp_info);\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_CALLING_PARTY_ADDRESS,\n                                    variable_pointer2, &sccp_info);\n\n    if (tvb_get_guint8(tvb, optional_pointer) == PARAMETER_SEGMENTATION) {\n      if (!sccp_reassemble) {\n        proto_tree_add_item(sccp_tree, hf_sccp_segmented_data, tvb, variable_pointer3, tvb_get_guint8(tvb, variable_pointer3)+1, ENC_NA);\n      } else {\n        guint8 octet;\n        gboolean more_frag = TRUE;\n\n        /* Get the first octet of parameter Segmentation, Ch 3.17 in Q.713\n         * Bit 8 of octet 1 is used for First segment indication\n         * Bit 7 of octet 1 is used to keep in the message in sequence\n         *         delivery option required by the SCCP user\n         * Bits 6 and 5 in octet 1 are spare bits.\n         * Bits 4-1 of octet 1 are used to indicate the number of\n         *            remaining segments.\n         * The values 0000 to 1111 are possible; the value 0000 indicates\n         * the last segment.\n         */\n        octet = tvb_get_guint8(tvb, optional_pointer+2);\n        source_local_ref = tvb_get_letoh24(tvb, optional_pointer+3);\n\n        if ((octet & 0x0f) == 0)\n          more_frag = FALSE;\n\n        save_fragmented = pinfo->fragmented;\n        pinfo->fragmented = TRUE;\n        frag_msg = fragment_add_seq_next(&sccp_xudt_msg_reassembly_table,\n                                         tvb, variable_pointer3 + 1,\n                                         pinfo,\n                                         source_local_ref,                            /* ID for fragments belonging together */\n                                         NULL,\n                                         tvb_get_guint8(tvb, variable_pointer3),       /* fragment length - to the end */\n                                         more_frag);                          /* More fragments? */\n\n        if ((octet & 0x80) == 0x80) /*First segment, set number of segments*/\n          fragment_set_tot_len(&sccp_xudt_msg_reassembly_table,\n                               pinfo, source_local_ref, NULL, (octet & 0xf));\n\n        new_tvb = process_reassembled_data(tvb, variable_pointer3 + 1,\n                                           pinfo, \"Reassembled SCCP\",\n                                           frag_msg,\n                                           &sccp_xudt_msg_frag_items,\n                                           NULL, tree);\n\n        if (frag_msg) { /* Reassembled */\n          col_append_str(pinfo->cinfo, COL_INFO,\"(Message reassembled) \");\n        } else { /* Not last packet of reassembled message */\n          col_append_str(pinfo->cinfo, COL_INFO,\"(Message fragment) \");\n        }\n\n        pinfo->fragmented = save_fragmented;\n\n        if (new_tvb)\n          dissect_sccp_data_param(new_tvb, pinfo, tree, sccp_info.assoc);\n      }\n    } else {\n      dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                      PARAMETER_DATA, variable_pointer3, &sccp_info);\n    }\n    break;\n\n  case SCCP_MSG_TYPE_XUDTS:\n  {\n    gboolean save_in_error_pkt = pinfo->flags.in_error_pkt;\n    pinfo->flags.in_error_pkt = TRUE;\n\n    sccp_info.sccp_msg = new_ud_msg(pinfo, sccp_info.message_type);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_RETURN_CAUSE, offset,\n                                     RETURN_CAUSE_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_HOP_COUNTER, offset,\n                                     HOP_COUNTER_LENGTH, &sccp_info);\n\n    VARIABLE_POINTER(variable_pointer1, hf_sccp_variable_pointer1, POINTER_LENGTH);\n    VARIABLE_POINTER(variable_pointer2, hf_sccp_variable_pointer2, POINTER_LENGTH);\n    VARIABLE_POINTER(variable_pointer3, hf_sccp_variable_pointer3, POINTER_LENGTH);\n    OPTIONAL_POINTER(POINTER_LENGTH);\n\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_CALLED_PARTY_ADDRESS,\n                                    variable_pointer1, &sccp_info);\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_CALLING_PARTY_ADDRESS,\n                                    variable_pointer2, &sccp_info);\n\n    if (tvb_get_guint8(tvb, optional_pointer) == PARAMETER_SEGMENTATION) {\n      if (!sccp_reassemble) {\n        proto_tree_add_item(sccp_tree, hf_sccp_segmented_data, tvb, variable_pointer3, tvb_get_guint8(tvb, variable_pointer3)+1, ENC_NA);\n\n      } else {\n        guint8 octet;\n        gboolean more_frag = TRUE;\n\n\n        /* Get the first octet of parameter Segmentation, Ch 3.17 in Q.713\n         * Bit 8 of octet 1 is used for First segment indication\n         * Bit 7 of octet 1 is used to keep in the message in sequence\n         *         delivery option required by the SCCP user\n         * Bits 6 and 5 in octet 1 are spare bits.\n         * Bits 4-1 of octet 1 are used to indicate the number of\n         *            remaining segments.\n         * The values 0000 to 1111 are possible; the value 0000 indicates\n         * the last segment.\n         */\n        octet = tvb_get_guint8(tvb, optional_pointer+2);\n        source_local_ref = tvb_get_letoh24(tvb, optional_pointer+3);\n\n        if ((octet & 0x0f) == 0)\n          more_frag = FALSE;\n\n        save_fragmented = pinfo->fragmented;\n        pinfo->fragmented = TRUE;\n        frag_msg = fragment_add_seq_next(&sccp_xudt_msg_reassembly_table,\n                                         tvb, variable_pointer3 + 1,\n                                         pinfo,\n                                         source_local_ref,                            /* ID for fragments belonging together */\n                                         NULL,\n                                         tvb_get_guint8(tvb, variable_pointer3),      /* fragment length - to the end */\n                                         more_frag);                                  /* More fragments? */\n\n        if ((octet & 0x80) == 0x80) /*First segment, set number of segments*/\n          fragment_set_tot_len(&sccp_xudt_msg_reassembly_table,\n                               pinfo, source_local_ref, NULL, (octet & 0xf));\n\n        new_tvb = process_reassembled_data(tvb, variable_pointer3 + 1,\n                                           pinfo, \"Reassembled SCCP\",\n                                           frag_msg,\n                                           &sccp_xudt_msg_frag_items,\n                                           NULL, tree);\n\n        if (frag_msg) { /* Reassembled */\n          col_append_str(pinfo->cinfo, COL_INFO, \"(Message reassembled) \");\n        } else { /* Not last packet of reassembled message */\n          col_append_str(pinfo->cinfo, COL_INFO, \"(Message fragment) \");\n        }\n\n        pinfo->fragmented = save_fragmented;\n\n        if (new_tvb)\n          dissect_sccp_data_param(new_tvb, pinfo, tree, sccp_info.assoc);\n      }\n    } else {\n      dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                      PARAMETER_DATA, variable_pointer3, &sccp_info);\n    }\n    pinfo->flags.in_error_pkt = save_in_error_pkt;\n    break;\n  }\n  case SCCP_MSG_TYPE_LUDT:\n    sccp_info.sccp_msg = new_ud_msg(pinfo, sccp_info.message_type);\n\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_CLASS, offset,\n                                     PROTOCOL_CLASS_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_HOP_COUNTER, offset,\n                                     HOP_COUNTER_LENGTH, &sccp_info);\n\n    VARIABLE_POINTER(variable_pointer1, hf_sccp_variable_pointer1, POINTER_LENGTH_LONG);\n    VARIABLE_POINTER(variable_pointer2, hf_sccp_variable_pointer2, POINTER_LENGTH_LONG);\n    VARIABLE_POINTER(variable_pointer3, hf_sccp_variable_pointer3, POINTER_LENGTH_LONG);\n    OPTIONAL_POINTER(POINTER_LENGTH_LONG);\n\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_CALLED_PARTY_ADDRESS,\n                                    variable_pointer1, &sccp_info);\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_CALLING_PARTY_ADDRESS,\n                                    variable_pointer2, &sccp_info);\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_LONG_DATA, variable_pointer3, &sccp_info);\n    break;\n\n  case SCCP_MSG_TYPE_LUDTS:\n    sccp_info.sccp_msg = new_ud_msg(pinfo, sccp_info.message_type);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_RETURN_CAUSE, offset,\n                                     RETURN_CAUSE_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_HOP_COUNTER, offset,\n                                     HOP_COUNTER_LENGTH, &sccp_info);\n\n    VARIABLE_POINTER(variable_pointer1, hf_sccp_variable_pointer1, POINTER_LENGTH_LONG);\n    VARIABLE_POINTER(variable_pointer2, hf_sccp_variable_pointer2, POINTER_LENGTH_LONG);\n    VARIABLE_POINTER(variable_pointer3, hf_sccp_variable_pointer3, POINTER_LENGTH_LONG);\n    OPTIONAL_POINTER(POINTER_LENGTH_LONG);\n\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_CALLED_PARTY_ADDRESS,\n                                    variable_pointer1, &sccp_info);\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_CALLING_PARTY_ADDRESS,\n                                    variable_pointer2, &sccp_info);\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_LONG_DATA, variable_pointer3, &sccp_info);\n    break;\n\n  default:\n    dissect_sccp_unknown_message(tvb, sccp_tree);\n  }\n\n  if (orig_opt_ptr)\n    dissect_sccp_optional_parameters(tvb, pinfo, sccp_tree, tree,\n                                     optional_pointer, &sccp_info);\n\n  if (trace_sccp && sccp_info.assoc && (sccp_info.assoc != &no_assoc)) {\n    proto_item *pi = proto_tree_add_uint(sccp_tree, hf_sccp_assoc_id, tvb, 0, 0, sccp_info.assoc->id);\n    proto_tree *pt = proto_item_add_subtree(pi, ett_sccp_assoc);\n    PROTO_ITEM_SET_GENERATED(pi);\n    if (sccp_info.assoc->msgs) {\n      sccp_msg_info_t *m;\n      for(m = sccp_info.assoc->msgs; m ; m = m->data.co.next) {\n        pi = proto_tree_add_uint(pt, hf_sccp_assoc_msg, tvb, 0, 0, m->framenum);\n\n        if (sccp_info.assoc->payload != SCCP_PLOAD_NONE)\n          proto_item_append_text(pi,\" %s\", val_to_str(sccp_info.assoc->payload, assoc_protos, \"Unknown: %d\"));\n\n        if (m->data.co.label)\n          proto_item_append_text(pi,\" %s\", m->data.co.label);\n\n        if ((m->framenum == pinfo->num) && (m->offset == msg_offset) ) {\n          tap_queue_packet(sccp_tap, pinfo, m);\n          proto_item_append_text(pi,\" (current)\");\n        }\n        PROTO_ITEM_SET_GENERATED(pi);\n      }\n    }\n  }\n\n  return offset;\n}",
        "func": "static int\ndissect_sccp_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *sccp_tree,\n                     proto_tree *tree)\n{\n  guint16   variable_pointer1 = 0, variable_pointer2 = 0, variable_pointer3 = 0;\n  guint16   optional_pointer  = 0, orig_opt_ptr = 0;\n  int   offset = 0;\n  gboolean  save_fragmented;\n  tvbuff_t *new_tvb = NULL;\n  fragment_head *frag_msg = NULL;\n  guint32   source_local_ref = 0;\n  guint8    more;\n  guint     msg_offset = tvb_offset_from_real_beginning(tvb);\n  sccp_decode_context_t sccp_info = {0, INVALID_LR, INVALID_LR, NULL, NULL};\n\n/* Macro for getting pointer to mandatory variable parameters */\n#define VARIABLE_POINTER(var, hf_var, ptr_size) \\\n  do {                                          \\\n    if (ptr_size == POINTER_LENGTH)             \\\n      var = tvb_get_guint8(tvb, offset);        \\\n    else                                        \\\n      var = tvb_get_letohs(tvb, offset);        \\\n    proto_tree_add_uint(sccp_tree, hf_var, tvb, \\\n                        offset, ptr_size, var); \\\n    var += offset;                              \\\n    if (ptr_size == POINTER_LENGTH_LONG)        \\\n      var += 1;                                 \\\n    offset += ptr_size;                         \\\n  } while (0)\n\n/* Macro for getting pointer to optional parameters */\n#define OPTIONAL_POINTER(ptr_size)                                      \\\n  do {                                                                  \\\n    if (ptr_size == POINTER_LENGTH)                                     \\\n      orig_opt_ptr = optional_pointer = tvb_get_guint8(tvb, offset);    \\\n    else                                                                \\\n      orig_opt_ptr = optional_pointer = tvb_get_letohs(tvb, offset);    \\\n    proto_tree_add_uint(sccp_tree, hf_sccp_optional_pointer, tvb,       \\\n                        offset, ptr_size, optional_pointer);            \\\n    optional_pointer += offset;                                         \\\n    if (ptr_size == POINTER_LENGTH_LONG)                                \\\n      optional_pointer += 1;                                            \\\n    offset += ptr_size;                                                 \\\n  } while (0)\n\n\n  /* Extract the message type;  all other processing is based on this */\n  sccp_info.message_type   = tvb_get_guint8(tvb, SCCP_MSG_TYPE_OFFSET);\n  offset = SCCP_MSG_TYPE_LENGTH;\n\n  /*  Do not change col_add_fstr() to col_append_fstr() here: we _want_\n   *  this call to overwrite whatever's currently in the INFO column (e.g.,\n   *  \"DATA\" from the SCTP dissector).\n   *\n   *  If there's something there that should not be overwritten, whoever\n   *  put that info there should call col_set_fence() to protect it.\n   */\n  col_add_fstr(pinfo->cinfo, COL_INFO, \"%s \",\n               val_to_str(sccp_info.message_type, sccp_message_type_acro_values, \"Unknown: %d\"));\n\n  if (sccp_tree) {\n    /* add the message type to the protocol tree */\n    proto_tree_add_uint(sccp_tree, hf_sccp_message_type, tvb,\n                        SCCP_MSG_TYPE_OFFSET, SCCP_MSG_TYPE_LENGTH, sccp_info.message_type);\n\n  };\n\n  no_assoc.calling_dpc   = 0;\n  no_assoc.called_dpc    = 0;\n  no_assoc.calling_ssn   = INVALID_SSN;\n  no_assoc.called_ssn    = INVALID_SSN;\n  no_assoc.has_fw_key    = FALSE;\n  no_assoc.has_bw_key    = FALSE;\n  no_assoc.payload       = SCCP_PLOAD_NONE;\n  no_assoc.called_party  = NULL;\n  no_assoc.calling_party = NULL;\n  no_assoc.extra_info    = NULL;\n\n  switch (sccp_info.message_type) {\n  case SCCP_MSG_TYPE_CR:\n    /*  TTC and NTT (Japan) say that the connection-oriented messages are\n     *  deleted (not standardized), but they appear to be used anyway, so\n     *  we'll dissect it...\n     */\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_SOURCE_LOCAL_REFERENCE,\n                                     offset, SOURCE_LOCAL_REFERENCE_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_CLASS, offset,\n                                     PROTOCOL_CLASS_LENGTH, &sccp_info);\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n\n    VARIABLE_POINTER(variable_pointer1, hf_sccp_variable_pointer1, POINTER_LENGTH);\n    OPTIONAL_POINTER(POINTER_LENGTH);\n\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_CALLED_PARTY_ADDRESS,\n                                    variable_pointer1, &sccp_info);\n    break;\n\n  case SCCP_MSG_TYPE_CC:\n    /*  TODO: connection has been established;  theoretically we could keep\n     *  keep track of the SLR/DLR with the called/calling from the CR and\n     *  track the connection (e.g., on subsequent messages regarding this\n     *  SLR we could set the global vars \"call*_ssn\" so data could get\n     *  sub-dissected).\n     */\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,\n                                     offset,\n                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_SOURCE_LOCAL_REFERENCE,\n                                     offset, SOURCE_LOCAL_REFERENCE_LENGTH, &sccp_info);\n\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_CLASS, offset,\n                                     PROTOCOL_CLASS_LENGTH, &sccp_info);\n    OPTIONAL_POINTER(POINTER_LENGTH);\n    break;\n\n  case SCCP_MSG_TYPE_CREF:\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,\n                                     offset,\n                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);\n\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_REFUSAL_CAUSE, offset,\n                                     REFUSAL_CAUSE_LENGTH, &sccp_info);\n    OPTIONAL_POINTER(POINTER_LENGTH);\n    break;\n\n  case SCCP_MSG_TYPE_RLSD:\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,\n                                     offset,\n                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_SOURCE_LOCAL_REFERENCE,\n                                     offset, SOURCE_LOCAL_REFERENCE_LENGTH, &sccp_info);\n\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_RELEASE_CAUSE, offset,\n                                     RELEASE_CAUSE_LENGTH, &sccp_info);\n\n    OPTIONAL_POINTER(POINTER_LENGTH);\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n    break;\n\n  case SCCP_MSG_TYPE_RLC:\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,\n                                     offset,\n                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_SOURCE_LOCAL_REFERENCE,\n                                     offset, SOURCE_LOCAL_REFERENCE_LENGTH, &sccp_info);\n\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n    break;\n\n  case SCCP_MSG_TYPE_DT1:\n    source_local_ref = tvb_get_letoh24(tvb, offset);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,\n                                     offset,\n                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);\n\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n\n    more = tvb_get_guint8(tvb, offset) & SEGMENTING_REASSEMBLING_MASK;\n\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_SEGMENTING_REASSEMBLING,\n                                     offset, SEGMENTING_REASSEMBLING_LENGTH, &sccp_info);\n    VARIABLE_POINTER(variable_pointer1, hf_sccp_variable_pointer1, POINTER_LENGTH);\n\n    /* Reassemble */\n    if (!sccp_reassemble) {\n      proto_tree_add_item(sccp_tree, hf_sccp_segmented_data, tvb, variable_pointer1,\n                          tvb_get_guint8(tvb, variable_pointer1)+1, ENC_NA);\n      dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                      PARAMETER_DATA, variable_pointer1, &sccp_info);\n\n    } else {\n      save_fragmented = pinfo->fragmented;\n      pinfo->fragmented = TRUE;\n      frag_msg = fragment_add_seq_next(&sccp_xudt_msg_reassembly_table,\n                                       tvb, variable_pointer1 + 1,\n                                       pinfo,\n                                       source_local_ref,                       /* ID for fragments belonging together */\n                                       NULL,\n                                       tvb_get_guint8(tvb, variable_pointer1), /* fragment length - to the end */\n                                       more);                                  /* More fragments? */\n\n      new_tvb = process_reassembled_data(tvb, variable_pointer1 + 1, pinfo,\n                                         \"Reassembled SCCP\", frag_msg,\n                                         &sccp_xudt_msg_frag_items, NULL,\n                                         tree);\n\n      if (frag_msg && frag_msg->next) { /* Reassembled */\n        col_append_str(pinfo->cinfo, COL_INFO, \"(Message reassembled) \");\n      } else if (more) { /* Not last packet of reassembled message */\n        col_append_str(pinfo->cinfo, COL_INFO, \"(Message fragment) \");\n      }\n\n      pinfo->fragmented = save_fragmented;\n\n      if (new_tvb)\n        dissect_sccp_data_param(new_tvb, pinfo, tree, sccp_info.assoc);\n    }\n\n    /* End reassemble */\n    break;\n\n  case SCCP_MSG_TYPE_DT2:\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,\n                                     offset,\n                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);\n\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_SEQUENCING_SEGMENTING, offset,\n                                     SEQUENCING_SEGMENTING_LENGTH, &sccp_info);\n    break;\n\n  case SCCP_MSG_TYPE_AK:\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,\n                                     offset,\n                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);\n\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_RECEIVE_SEQUENCE_NUMBER,\n                                     offset, RECEIVE_SEQUENCE_NUMBER_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_CREDIT, offset, CREDIT_LENGTH, &sccp_info);\n    break;\n\n  case SCCP_MSG_TYPE_UDT:\n    sccp_info.sccp_msg = new_ud_msg(pinfo, sccp_info.message_type);\n\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_CLASS, offset,\n                                     PROTOCOL_CLASS_LENGTH, &sccp_info);\n    VARIABLE_POINTER(variable_pointer1, hf_sccp_variable_pointer1, POINTER_LENGTH);\n    VARIABLE_POINTER(variable_pointer2, hf_sccp_variable_pointer2, POINTER_LENGTH);\n    VARIABLE_POINTER(variable_pointer3, hf_sccp_variable_pointer3, POINTER_LENGTH);\n\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_CALLED_PARTY_ADDRESS,\n                                    variable_pointer1, &sccp_info);\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_CALLING_PARTY_ADDRESS,\n                                    variable_pointer2, &sccp_info);\n\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree, PARAMETER_DATA,\n                                    variable_pointer3, &sccp_info);\n    break;\n\n  case SCCP_MSG_TYPE_UDTS:\n  {\n    gboolean save_in_error_pkt = pinfo->flags.in_error_pkt;\n    pinfo->flags.in_error_pkt = TRUE;\n\n    sccp_info.sccp_msg = new_ud_msg(pinfo, sccp_info.message_type);\n\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_RETURN_CAUSE, offset,\n                                     RETURN_CAUSE_LENGTH, &sccp_info);\n\n    VARIABLE_POINTER(variable_pointer1, hf_sccp_variable_pointer1, POINTER_LENGTH);\n    VARIABLE_POINTER(variable_pointer2, hf_sccp_variable_pointer2, POINTER_LENGTH);\n    VARIABLE_POINTER(variable_pointer3, hf_sccp_variable_pointer3, POINTER_LENGTH);\n\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_CALLED_PARTY_ADDRESS,\n                                    variable_pointer1, &sccp_info);\n\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_CALLING_PARTY_ADDRESS,\n                                    variable_pointer2, &sccp_info);\n\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree, PARAMETER_DATA,\n                                    variable_pointer3, &sccp_info);\n    pinfo->flags.in_error_pkt = save_in_error_pkt;\n    break;\n  }\n\n  case SCCP_MSG_TYPE_ED:\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,\n                                     offset,\n                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);\n\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n\n    VARIABLE_POINTER(variable_pointer1, hf_sccp_variable_pointer1, POINTER_LENGTH);\n\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree, PARAMETER_DATA,\n                                    variable_pointer1, &sccp_info);\n    break;\n\n  case SCCP_MSG_TYPE_EA:\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,\n                                     offset,\n                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n    break;\n\n  case SCCP_MSG_TYPE_RSR:\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,\n                                     offset,\n                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_SOURCE_LOCAL_REFERENCE,\n                                     offset, SOURCE_LOCAL_REFERENCE_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_RESET_CAUSE, offset,\n                                     RESET_CAUSE_LENGTH, &sccp_info);\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n    break;\n\n  case SCCP_MSG_TYPE_RSC:\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,\n                                     offset,\n                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_SOURCE_LOCAL_REFERENCE,\n                                     offset, SOURCE_LOCAL_REFERENCE_LENGTH, &sccp_info);\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n    break;\n\n  case SCCP_MSG_TYPE_ERR:\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,\n                                     offset,\n                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_ERROR_CAUSE, offset,\n                                     ERROR_CAUSE_LENGTH, &sccp_info);\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n    break;\n\n  case SCCP_MSG_TYPE_IT:\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_DESTINATION_LOCAL_REFERENCE,\n                                     offset,\n                                     DESTINATION_LOCAL_REFERENCE_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_SOURCE_LOCAL_REFERENCE,\n                                     offset, SOURCE_LOCAL_REFERENCE_LENGTH, &sccp_info);\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_CLASS, offset,\n                                     PROTOCOL_CLASS_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_SEQUENCING_SEGMENTING,\n                                     offset, SEQUENCING_SEGMENTING_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_CREDIT, offset, CREDIT_LENGTH, &sccp_info);\n    break;\n\n  case SCCP_MSG_TYPE_XUDT:\n    sccp_info.sccp_msg = new_ud_msg(pinfo, sccp_info.message_type);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_CLASS, offset,\n                                     PROTOCOL_CLASS_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_HOP_COUNTER, offset,\n                                     HOP_COUNTER_LENGTH, &sccp_info);\n\n    VARIABLE_POINTER(variable_pointer1, hf_sccp_variable_pointer1, POINTER_LENGTH);\n    VARIABLE_POINTER(variable_pointer2, hf_sccp_variable_pointer2, POINTER_LENGTH);\n    VARIABLE_POINTER(variable_pointer3, hf_sccp_variable_pointer3, POINTER_LENGTH);\n    OPTIONAL_POINTER(POINTER_LENGTH);\n\n      /*  Optional parameters are Segmentation and Importance\n       *  NOTE 2 - Segmentation Should not be present in case of a single XUDT\n       *  message.\n       */\n\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_CALLED_PARTY_ADDRESS,\n                                    variable_pointer1, &sccp_info);\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_CALLING_PARTY_ADDRESS,\n                                    variable_pointer2, &sccp_info);\n\n    if (tvb_get_guint8(tvb, optional_pointer) == PARAMETER_SEGMENTATION) {\n      if (!sccp_reassemble) {\n        proto_tree_add_item(sccp_tree, hf_sccp_segmented_data, tvb, variable_pointer3, tvb_get_guint8(tvb, variable_pointer3)+1, ENC_NA);\n      } else {\n        guint8 octet;\n        gboolean more_frag = TRUE;\n\n        /* Get the first octet of parameter Segmentation, Ch 3.17 in Q.713\n         * Bit 8 of octet 1 is used for First segment indication\n         * Bit 7 of octet 1 is used to keep in the message in sequence\n         *         delivery option required by the SCCP user\n         * Bits 6 and 5 in octet 1 are spare bits.\n         * Bits 4-1 of octet 1 are used to indicate the number of\n         *            remaining segments.\n         * The values 0000 to 1111 are possible; the value 0000 indicates\n         * the last segment.\n         */\n        octet = tvb_get_guint8(tvb, optional_pointer+2);\n        source_local_ref = tvb_get_letoh24(tvb, optional_pointer+3);\n\n        if ((octet & 0x0f) == 0)\n          more_frag = FALSE;\n\n        save_fragmented = pinfo->fragmented;\n        pinfo->fragmented = TRUE;\n        frag_msg = fragment_add_seq_next(&sccp_xudt_msg_reassembly_table,\n                                         tvb, variable_pointer3 + 1,\n                                         pinfo,\n                                         source_local_ref,                            /* ID for fragments belonging together */\n                                         NULL,\n                                         tvb_get_guint8(tvb, variable_pointer3),       /* fragment length - to the end */\n                                         more_frag);                          /* More fragments? */\n\n        if ((octet & 0x80) == 0x80) /*First segment, set number of segments*/\n          fragment_set_tot_len(&sccp_xudt_msg_reassembly_table,\n                               pinfo, source_local_ref, NULL, (octet & 0xf));\n\n        new_tvb = process_reassembled_data(tvb, variable_pointer3 + 1,\n                                           pinfo, \"Reassembled SCCP\",\n                                           frag_msg,\n                                           &sccp_xudt_msg_frag_items,\n                                           NULL, tree);\n\n        if (frag_msg) { /* Reassembled */\n          col_append_str(pinfo->cinfo, COL_INFO,\"(Message reassembled) \");\n        } else { /* Not last packet of reassembled message */\n          col_append_str(pinfo->cinfo, COL_INFO,\"(Message fragment) \");\n        }\n\n        pinfo->fragmented = save_fragmented;\n\n        if (new_tvb)\n          dissect_sccp_data_param(new_tvb, pinfo, tree, sccp_info.assoc);\n      }\n    } else {\n      dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                      PARAMETER_DATA, variable_pointer3, &sccp_info);\n    }\n    break;\n\n  case SCCP_MSG_TYPE_XUDTS:\n  {\n    gboolean save_in_error_pkt = pinfo->flags.in_error_pkt;\n    pinfo->flags.in_error_pkt = TRUE;\n\n    sccp_info.sccp_msg = new_ud_msg(pinfo, sccp_info.message_type);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_RETURN_CAUSE, offset,\n                                     RETURN_CAUSE_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_HOP_COUNTER, offset,\n                                     HOP_COUNTER_LENGTH, &sccp_info);\n\n    VARIABLE_POINTER(variable_pointer1, hf_sccp_variable_pointer1, POINTER_LENGTH);\n    VARIABLE_POINTER(variable_pointer2, hf_sccp_variable_pointer2, POINTER_LENGTH);\n    VARIABLE_POINTER(variable_pointer3, hf_sccp_variable_pointer3, POINTER_LENGTH);\n    OPTIONAL_POINTER(POINTER_LENGTH);\n\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_CALLED_PARTY_ADDRESS,\n                                    variable_pointer1, &sccp_info);\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_CALLING_PARTY_ADDRESS,\n                                    variable_pointer2, &sccp_info);\n\n    if (tvb_get_guint8(tvb, optional_pointer) == PARAMETER_SEGMENTATION) {\n      if (!sccp_reassemble) {\n        proto_tree_add_item(sccp_tree, hf_sccp_segmented_data, tvb, variable_pointer3, tvb_get_guint8(tvb, variable_pointer3)+1, ENC_NA);\n\n      } else {\n        guint8 octet;\n        gboolean more_frag = TRUE;\n\n\n        /* Get the first octet of parameter Segmentation, Ch 3.17 in Q.713\n         * Bit 8 of octet 1 is used for First segment indication\n         * Bit 7 of octet 1 is used to keep in the message in sequence\n         *         delivery option required by the SCCP user\n         * Bits 6 and 5 in octet 1 are spare bits.\n         * Bits 4-1 of octet 1 are used to indicate the number of\n         *            remaining segments.\n         * The values 0000 to 1111 are possible; the value 0000 indicates\n         * the last segment.\n         */\n        octet = tvb_get_guint8(tvb, optional_pointer+2);\n        source_local_ref = tvb_get_letoh24(tvb, optional_pointer+3);\n\n        if ((octet & 0x0f) == 0)\n          more_frag = FALSE;\n\n        save_fragmented = pinfo->fragmented;\n        pinfo->fragmented = TRUE;\n        frag_msg = fragment_add_seq_next(&sccp_xudt_msg_reassembly_table,\n                                         tvb, variable_pointer3 + 1,\n                                         pinfo,\n                                         source_local_ref,                            /* ID for fragments belonging together */\n                                         NULL,\n                                         tvb_get_guint8(tvb, variable_pointer3),      /* fragment length - to the end */\n                                         more_frag);                                  /* More fragments? */\n\n        if ((octet & 0x80) == 0x80) /*First segment, set number of segments*/\n          fragment_set_tot_len(&sccp_xudt_msg_reassembly_table,\n                               pinfo, source_local_ref, NULL, (octet & 0xf));\n\n        new_tvb = process_reassembled_data(tvb, variable_pointer3 + 1,\n                                           pinfo, \"Reassembled SCCP\",\n                                           frag_msg,\n                                           &sccp_xudt_msg_frag_items,\n                                           NULL, tree);\n\n        if (frag_msg) { /* Reassembled */\n          col_append_str(pinfo->cinfo, COL_INFO, \"(Message reassembled) \");\n        } else { /* Not last packet of reassembled message */\n          col_append_str(pinfo->cinfo, COL_INFO, \"(Message fragment) \");\n        }\n\n        pinfo->fragmented = save_fragmented;\n\n        if (new_tvb)\n          dissect_sccp_data_param(new_tvb, pinfo, tree, sccp_info.assoc);\n      }\n    } else {\n      dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                      PARAMETER_DATA, variable_pointer3, &sccp_info);\n    }\n    pinfo->flags.in_error_pkt = save_in_error_pkt;\n    break;\n  }\n  case SCCP_MSG_TYPE_LUDT:\n    sccp_info.sccp_msg = new_ud_msg(pinfo, sccp_info.message_type);\n\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_CLASS, offset,\n                                     PROTOCOL_CLASS_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_HOP_COUNTER, offset,\n                                     HOP_COUNTER_LENGTH, &sccp_info);\n\n    VARIABLE_POINTER(variable_pointer1, hf_sccp_variable_pointer1, POINTER_LENGTH_LONG);\n    VARIABLE_POINTER(variable_pointer2, hf_sccp_variable_pointer2, POINTER_LENGTH_LONG);\n    VARIABLE_POINTER(variable_pointer3, hf_sccp_variable_pointer3, POINTER_LENGTH_LONG);\n    OPTIONAL_POINTER(POINTER_LENGTH_LONG);\n\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_CALLED_PARTY_ADDRESS,\n                                    variable_pointer1, &sccp_info);\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_CALLING_PARTY_ADDRESS,\n                                    variable_pointer2, &sccp_info);\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_LONG_DATA, variable_pointer3, &sccp_info);\n    break;\n\n  case SCCP_MSG_TYPE_LUDTS:\n    sccp_info.sccp_msg = new_ud_msg(pinfo, sccp_info.message_type);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_RETURN_CAUSE, offset,\n                                     RETURN_CAUSE_LENGTH, &sccp_info);\n    offset += dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree,\n                                     PARAMETER_HOP_COUNTER, offset,\n                                     HOP_COUNTER_LENGTH, &sccp_info);\n\n    VARIABLE_POINTER(variable_pointer1, hf_sccp_variable_pointer1, POINTER_LENGTH_LONG);\n    VARIABLE_POINTER(variable_pointer2, hf_sccp_variable_pointer2, POINTER_LENGTH_LONG);\n    VARIABLE_POINTER(variable_pointer3, hf_sccp_variable_pointer3, POINTER_LENGTH_LONG);\n    OPTIONAL_POINTER(POINTER_LENGTH_LONG);\n\n    sccp_info.assoc = get_sccp_assoc(pinfo, msg_offset, &sccp_info);\n\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_CALLED_PARTY_ADDRESS,\n                                    variable_pointer1, &sccp_info);\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_CALLING_PARTY_ADDRESS,\n                                    variable_pointer2, &sccp_info);\n    dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree,\n                                    PARAMETER_LONG_DATA, variable_pointer3, &sccp_info);\n    break;\n\n  default:\n    dissect_sccp_unknown_message(tvb, sccp_tree);\n  }\n\n  if (orig_opt_ptr)\n    dissect_sccp_optional_parameters(tvb, pinfo, sccp_tree, tree,\n                                     optional_pointer, &sccp_info);\n\n  if (trace_sccp && sccp_info.assoc && (sccp_info.assoc != &no_assoc)) {\n    proto_item *pi = proto_tree_add_uint(sccp_tree, hf_sccp_assoc_id, tvb, 0, 0, sccp_info.assoc->id);\n    proto_tree *pt = proto_item_add_subtree(pi, ett_sccp_assoc);\n    PROTO_ITEM_SET_GENERATED(pi);\n    if (sccp_info.assoc->msgs) {\n      sccp_msg_info_t *m;\n      for(m = sccp_info.assoc->msgs; m ; m = m->data.co.next) {\n        pi = proto_tree_add_uint(pt, hf_sccp_assoc_msg, tvb, 0, 0, m->framenum);\n\n        if (sccp_info.assoc->payload != SCCP_PLOAD_NONE)\n          proto_item_append_text(pi,\" %s\", val_to_str(sccp_info.assoc->payload, assoc_protos, \"Unknown: %d\"));\n\n        if (m->data.co.label)\n          proto_item_append_text(pi,\" %s\", m->data.co.label);\n\n        if ((m->framenum == pinfo->num) && (m->offset == msg_offset) ) {\n          tap_queue_packet(sccp_tap, pinfo, m);\n          proto_item_append_text(pi,\" (current)\");\n        }\n        PROTO_ITEM_SET_GENERATED(pi);\n      }\n    }\n  }\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n {\n   guint16   variable_pointer1 = 0, variable_pointer2 = 0, variable_pointer3 = 0;\n   guint16   optional_pointer  = 0, orig_opt_ptr = 0;\n-  guint16   offset = 0;\n+  int   offset = 0;\n   gboolean  save_fragmented;\n   tvbuff_t *new_tvb = NULL;\n   fragment_head *frag_msg = NULL;",
        "diff_line_info": {
            "deleted_lines": [
                "  guint16   offset = 0;"
            ],
            "added_lines": [
                "  int   offset = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7324",
        "func_name": "wireshark/dissect_sccp_variable_parameter",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-sccp.c had an infinite loop that was addressed by using a correct integer data type.",
        "git_url": "https://github.com/wireshark/wireshark/commit/9e7695bbee18525eaa6d12b32230313ae8a36a81",
        "commit_title": "SCCP: Use int datatype for offset to prevent infinite loops",
        "commit_text": " Fields are 16-bit values and large 16-bit values can be incorrectly treated as negative, causing infinite loops in offset calculations.  Bug: 14413 (cherry picked from commit 620647a3e01d65fef985093cefb9352e21603261)",
        "func_before": "static guint16\ndissect_sccp_variable_parameter(tvbuff_t *tvb, packet_info *pinfo,\n                                proto_tree *sccp_tree, proto_tree *tree,\n                                guint8 parameter_type, guint16 offset, sccp_decode_context_t* sccp_info)\n{\n  guint16     parameter_length;\n  guint8      length_length;\n  proto_item *pi;\n\n  if (parameter_type != PARAMETER_LONG_DATA) {\n    parameter_length = tvb_get_guint8(tvb, offset);\n    length_length = PARAMETER_LENGTH_LENGTH;\n  } else {\n    /* Long data parameter has 16 bit length */\n    parameter_length = tvb_get_letohs(tvb, offset);\n    length_length = PARAMETER_LONG_DATA_LENGTH_LENGTH;\n  }\n\n  pi = proto_tree_add_uint_format(sccp_tree, hf_sccp_param_length, tvb, offset,\n                                  length_length, parameter_length, \"%s length: %d\",\n                                  val_to_str(parameter_type, sccp_parameter_values,\n                                             \"Unknown: %d\"),\n                                  parameter_length);\n  if (!sccp_show_length) {\n    /* The user doesn't want to see it... */\n    PROTO_ITEM_SET_HIDDEN(pi);\n  }\n\n  offset += length_length;\n\n  dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree, parameter_type, offset,\n                         parameter_length, sccp_info);\n\n  return(parameter_length + length_length);\n}",
        "func": "static guint16\ndissect_sccp_variable_parameter(tvbuff_t *tvb, packet_info *pinfo,\n                                proto_tree *sccp_tree, proto_tree *tree,\n                                guint8 parameter_type, int offset, sccp_decode_context_t* sccp_info)\n{\n  guint16     parameter_length;\n  guint8      length_length;\n  proto_item *pi;\n\n  if (parameter_type != PARAMETER_LONG_DATA) {\n    parameter_length = tvb_get_guint8(tvb, offset);\n    length_length = PARAMETER_LENGTH_LENGTH;\n  } else {\n    /* Long data parameter has 16 bit length */\n    parameter_length = tvb_get_letohs(tvb, offset);\n    length_length = PARAMETER_LONG_DATA_LENGTH_LENGTH;\n  }\n\n  pi = proto_tree_add_uint_format(sccp_tree, hf_sccp_param_length, tvb, offset,\n                                  length_length, parameter_length, \"%s length: %d\",\n                                  val_to_str(parameter_type, sccp_parameter_values,\n                                             \"Unknown: %d\"),\n                                  parameter_length);\n  if (!sccp_show_length) {\n    /* The user doesn't want to see it... */\n    PROTO_ITEM_SET_HIDDEN(pi);\n  }\n\n  offset += length_length;\n\n  dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree, parameter_type, offset,\n                         parameter_length, sccp_info);\n\n  return(parameter_length + length_length);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n static guint16\n dissect_sccp_variable_parameter(tvbuff_t *tvb, packet_info *pinfo,\n                                 proto_tree *sccp_tree, proto_tree *tree,\n-                                guint8 parameter_type, guint16 offset, sccp_decode_context_t* sccp_info)\n+                                guint8 parameter_type, int offset, sccp_decode_context_t* sccp_info)\n {\n   guint16     parameter_length;\n   guint8      length_length;",
        "diff_line_info": {
            "deleted_lines": [
                "                                guint8 parameter_type, guint16 offset, sccp_decode_context_t* sccp_info)"
            ],
            "added_lines": [
                "                                guint8 parameter_type, int offset, sccp_decode_context_t* sccp_info)"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7324",
        "func_name": "wireshark/dissect_sccp_parameter",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-sccp.c had an infinite loop that was addressed by using a correct integer data type.",
        "git_url": "https://github.com/wireshark/wireshark/commit/9e7695bbee18525eaa6d12b32230313ae8a36a81",
        "commit_title": "SCCP: Use int datatype for offset to prevent infinite loops",
        "commit_text": " Fields are 16-bit values and large 16-bit values can be incorrectly treated as negative, causing infinite loops in offset calculations.  Bug: 14413 (cherry picked from commit 620647a3e01d65fef985093cefb9352e21603261)",
        "func_before": "static guint16\ndissect_sccp_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *sccp_tree,\n                       proto_tree *tree, guint8 parameter_type, guint16 offset,\n                       guint16 parameter_length, sccp_decode_context_t *sccp_info)\n{\n  tvbuff_t *parameter_tvb;\n\n  switch (parameter_type) {\n  case PARAMETER_CALLED_PARTY_ADDRESS:\n  case PARAMETER_CALLING_PARTY_ADDRESS:\n  case PARAMETER_DATA:\n  case PARAMETER_LONG_DATA:\n  case PARAMETER_SOURCE_LOCAL_REFERENCE:\n  case PARAMETER_DESTINATION_LOCAL_REFERENCE:\n  case PARAMETER_RELEASE_CAUSE:\n  case PARAMETER_RETURN_CAUSE:\n  case PARAMETER_RESET_CAUSE:\n  case PARAMETER_ERROR_CAUSE:\n  case PARAMETER_REFUSAL_CAUSE:\n\n    /*  These parameters must be dissected even if !sccp_tree (so that\n     *  assoc information can be created).\n     */\n    break;\n\n  default:\n    if (!sccp_tree) return(parameter_length);\n\n  }\n\n  parameter_tvb = tvb_new_subset_length(tvb, offset, parameter_length);\n\n  switch (parameter_type) {\n\n  case PARAMETER_END_OF_OPTIONAL_PARAMETERS:\n    proto_tree_add_item(sccp_tree, hf_sccp_end_optional_param, tvb, offset, parameter_length, ENC_NA);\n    break;\n\n  case PARAMETER_DESTINATION_LOCAL_REFERENCE:\n    dissect_sccp_dlr_param(parameter_tvb, pinfo, sccp_tree, parameter_length, sccp_info);\n    break;\n\n  case PARAMETER_SOURCE_LOCAL_REFERENCE:\n    dissect_sccp_slr_param(parameter_tvb, pinfo, sccp_tree, parameter_length, sccp_info);\n    break;\n\n  case PARAMETER_CALLED_PARTY_ADDRESS:\n    dissect_sccp_called_param(parameter_tvb, pinfo, sccp_tree, parameter_length, sccp_info);\n    break;\n\n  case PARAMETER_CALLING_PARTY_ADDRESS:\n    dissect_sccp_calling_param(parameter_tvb, pinfo, sccp_tree, parameter_length, sccp_info);\n    break;\n\n  case PARAMETER_CLASS:\n    dissect_sccp_class_param(parameter_tvb, pinfo, sccp_tree, parameter_length, sccp_info);\n    break;\n\n  case PARAMETER_SEGMENTING_REASSEMBLING:\n    dissect_sccp_segmenting_reassembling_param(parameter_tvb, pinfo, sccp_tree,\n                                               parameter_length);\n    break;\n\n  case PARAMETER_RECEIVE_SEQUENCE_NUMBER:\n    dissect_sccp_receive_sequence_number_param(parameter_tvb, pinfo, sccp_tree,\n                                               parameter_length);\n    break;\n\n  case PARAMETER_SEQUENCING_SEGMENTING:\n    dissect_sccp_sequencing_segmenting_param(parameter_tvb, sccp_tree,\n                                             parameter_length);\n    break;\n\n  case PARAMETER_CREDIT:\n    dissect_sccp_credit_param(parameter_tvb, pinfo, sccp_tree, parameter_length);\n    break;\n\n  case PARAMETER_RELEASE_CAUSE:\n    dissect_sccp_release_cause_param(parameter_tvb, pinfo, sccp_tree, parameter_length);\n    break;\n\n  case PARAMETER_RETURN_CAUSE:\n    dissect_sccp_return_cause_param(parameter_tvb, pinfo, sccp_tree, parameter_length);\n    break;\n\n  case PARAMETER_RESET_CAUSE:\n    dissect_sccp_reset_cause_param(parameter_tvb, pinfo, sccp_tree, parameter_length);\n    break;\n\n  case PARAMETER_ERROR_CAUSE:\n    dissect_sccp_error_cause_param(parameter_tvb, pinfo, sccp_tree, parameter_length);\n    break;\n\n  case PARAMETER_REFUSAL_CAUSE:\n    dissect_sccp_refusal_cause_param(parameter_tvb, pinfo, sccp_tree, parameter_length);\n    break;\n\n  case PARAMETER_DATA:\n    dissect_sccp_data_param(parameter_tvb, pinfo, tree, sccp_info->assoc);\n\n    /* TODO? Re-adjust length of SCCP item since it may be sub-dissected */\n    /* sccp_length = proto_item_get_len(sccp_item);\n     * sccp_length -= parameter_length;\n     * proto_item_set_len(sccp_item, sccp_length);\n     *\n     * except that proto_item_get_len() is *NOT* guaranteed to return\n     * a correct value - if the item has been \"faked\", it will be wrong\n     */\n    break;\n\n  case PARAMETER_SEGMENTATION:\n    dissect_sccp_segmentation_param(parameter_tvb, pinfo, sccp_tree, parameter_length);\n    break;\n\n  case PARAMETER_HOP_COUNTER:\n    dissect_sccp_hop_counter_param(parameter_tvb, sccp_tree, parameter_length);\n    break;\n\n  case PARAMETER_IMPORTANCE:\n    if (decode_mtp3_standard != ANSI_STANDARD)\n      dissect_sccp_importance_param(parameter_tvb, pinfo, sccp_tree, parameter_length);\n    else\n      dissect_sccp_unknown_param(parameter_tvb, sccp_tree, parameter_type,\n                                 parameter_length);\n    break;\n\n  case PARAMETER_LONG_DATA:\n    dissect_sccp_data_param(parameter_tvb, pinfo, tree, sccp_info->assoc);\n    break;\n\n  case PARAMETER_ISNI:\n    if (decode_mtp3_standard != ANSI_STANDARD)\n      dissect_sccp_unknown_param(parameter_tvb, sccp_tree, parameter_type,\n                                 parameter_length);\n    else\n      dissect_sccp_isni_param(parameter_tvb, sccp_tree, parameter_length);\n    break;\n\n  default:\n    dissect_sccp_unknown_param(parameter_tvb, sccp_tree, parameter_type,\n                               parameter_length);\n    break;\n  }\n\n  return(parameter_length);\n}",
        "func": "static guint16\ndissect_sccp_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *sccp_tree,\n                       proto_tree *tree, guint8 parameter_type, int offset,\n                       guint16 parameter_length, sccp_decode_context_t *sccp_info)\n{\n  tvbuff_t *parameter_tvb;\n\n  switch (parameter_type) {\n  case PARAMETER_CALLED_PARTY_ADDRESS:\n  case PARAMETER_CALLING_PARTY_ADDRESS:\n  case PARAMETER_DATA:\n  case PARAMETER_LONG_DATA:\n  case PARAMETER_SOURCE_LOCAL_REFERENCE:\n  case PARAMETER_DESTINATION_LOCAL_REFERENCE:\n  case PARAMETER_RELEASE_CAUSE:\n  case PARAMETER_RETURN_CAUSE:\n  case PARAMETER_RESET_CAUSE:\n  case PARAMETER_ERROR_CAUSE:\n  case PARAMETER_REFUSAL_CAUSE:\n\n    /*  These parameters must be dissected even if !sccp_tree (so that\n     *  assoc information can be created).\n     */\n    break;\n\n  default:\n    if (!sccp_tree) return(parameter_length);\n\n  }\n\n  parameter_tvb = tvb_new_subset_length(tvb, offset, parameter_length);\n\n  switch (parameter_type) {\n\n  case PARAMETER_END_OF_OPTIONAL_PARAMETERS:\n    proto_tree_add_item(sccp_tree, hf_sccp_end_optional_param, tvb, offset, parameter_length, ENC_NA);\n    break;\n\n  case PARAMETER_DESTINATION_LOCAL_REFERENCE:\n    dissect_sccp_dlr_param(parameter_tvb, pinfo, sccp_tree, parameter_length, sccp_info);\n    break;\n\n  case PARAMETER_SOURCE_LOCAL_REFERENCE:\n    dissect_sccp_slr_param(parameter_tvb, pinfo, sccp_tree, parameter_length, sccp_info);\n    break;\n\n  case PARAMETER_CALLED_PARTY_ADDRESS:\n    dissect_sccp_called_param(parameter_tvb, pinfo, sccp_tree, parameter_length, sccp_info);\n    break;\n\n  case PARAMETER_CALLING_PARTY_ADDRESS:\n    dissect_sccp_calling_param(parameter_tvb, pinfo, sccp_tree, parameter_length, sccp_info);\n    break;\n\n  case PARAMETER_CLASS:\n    dissect_sccp_class_param(parameter_tvb, pinfo, sccp_tree, parameter_length, sccp_info);\n    break;\n\n  case PARAMETER_SEGMENTING_REASSEMBLING:\n    dissect_sccp_segmenting_reassembling_param(parameter_tvb, pinfo, sccp_tree,\n                                               parameter_length);\n    break;\n\n  case PARAMETER_RECEIVE_SEQUENCE_NUMBER:\n    dissect_sccp_receive_sequence_number_param(parameter_tvb, pinfo, sccp_tree,\n                                               parameter_length);\n    break;\n\n  case PARAMETER_SEQUENCING_SEGMENTING:\n    dissect_sccp_sequencing_segmenting_param(parameter_tvb, sccp_tree,\n                                             parameter_length);\n    break;\n\n  case PARAMETER_CREDIT:\n    dissect_sccp_credit_param(parameter_tvb, pinfo, sccp_tree, parameter_length);\n    break;\n\n  case PARAMETER_RELEASE_CAUSE:\n    dissect_sccp_release_cause_param(parameter_tvb, pinfo, sccp_tree, parameter_length);\n    break;\n\n  case PARAMETER_RETURN_CAUSE:\n    dissect_sccp_return_cause_param(parameter_tvb, pinfo, sccp_tree, parameter_length);\n    break;\n\n  case PARAMETER_RESET_CAUSE:\n    dissect_sccp_reset_cause_param(parameter_tvb, pinfo, sccp_tree, parameter_length);\n    break;\n\n  case PARAMETER_ERROR_CAUSE:\n    dissect_sccp_error_cause_param(parameter_tvb, pinfo, sccp_tree, parameter_length);\n    break;\n\n  case PARAMETER_REFUSAL_CAUSE:\n    dissect_sccp_refusal_cause_param(parameter_tvb, pinfo, sccp_tree, parameter_length);\n    break;\n\n  case PARAMETER_DATA:\n    dissect_sccp_data_param(parameter_tvb, pinfo, tree, sccp_info->assoc);\n\n    /* TODO? Re-adjust length of SCCP item since it may be sub-dissected */\n    /* sccp_length = proto_item_get_len(sccp_item);\n     * sccp_length -= parameter_length;\n     * proto_item_set_len(sccp_item, sccp_length);\n     *\n     * except that proto_item_get_len() is *NOT* guaranteed to return\n     * a correct value - if the item has been \"faked\", it will be wrong\n     */\n    break;\n\n  case PARAMETER_SEGMENTATION:\n    dissect_sccp_segmentation_param(parameter_tvb, pinfo, sccp_tree, parameter_length);\n    break;\n\n  case PARAMETER_HOP_COUNTER:\n    dissect_sccp_hop_counter_param(parameter_tvb, sccp_tree, parameter_length);\n    break;\n\n  case PARAMETER_IMPORTANCE:\n    if (decode_mtp3_standard != ANSI_STANDARD)\n      dissect_sccp_importance_param(parameter_tvb, pinfo, sccp_tree, parameter_length);\n    else\n      dissect_sccp_unknown_param(parameter_tvb, sccp_tree, parameter_type,\n                                 parameter_length);\n    break;\n\n  case PARAMETER_LONG_DATA:\n    dissect_sccp_data_param(parameter_tvb, pinfo, tree, sccp_info->assoc);\n    break;\n\n  case PARAMETER_ISNI:\n    if (decode_mtp3_standard != ANSI_STANDARD)\n      dissect_sccp_unknown_param(parameter_tvb, sccp_tree, parameter_type,\n                                 parameter_length);\n    else\n      dissect_sccp_isni_param(parameter_tvb, sccp_tree, parameter_length);\n    break;\n\n  default:\n    dissect_sccp_unknown_param(parameter_tvb, sccp_tree, parameter_type,\n                               parameter_length);\n    break;\n  }\n\n  return(parameter_length);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n static guint16\n dissect_sccp_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *sccp_tree,\n-                       proto_tree *tree, guint8 parameter_type, guint16 offset,\n+                       proto_tree *tree, guint8 parameter_type, int offset,\n                        guint16 parameter_length, sccp_decode_context_t *sccp_info)\n {\n   tvbuff_t *parameter_tvb;",
        "diff_line_info": {
            "deleted_lines": [
                "                       proto_tree *tree, guint8 parameter_type, guint16 offset,"
            ],
            "added_lines": [
                "                       proto_tree *tree, guint8 parameter_type, int offset,"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7325",
        "func_name": "wireshark/dissect_rpkirtr_pdu",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-rpki-rtr.c had an infinite loop that was addressed by validating a length field.",
        "git_url": "https://github.com/wireshark/wireshark/commit/7be234d06ea39ab6a88115ae41d71060f1f15e3c",
        "commit_title": "RPKI-Router: Sanity check length field to prevent infinite loop",
        "commit_text": " Bug: 14414 (cherry picked from commit 5e8391ff900db18ccf8663918919b16085406874)",
        "func_before": "static int dissect_rpkirtr_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n{\n\n    proto_item *ti = NULL, *ti_flags, *ti_type;\n    proto_tree *rpkirtr_tree = NULL, *flags_tree = NULL;\n    int offset = 0;\n    guint8 pdu_type, version;\n    guint length;\n\n    while (tvb_reported_length_remaining(tvb, offset) != 0) {\n\n        ti = proto_tree_add_item(tree, proto_rpkirtr, tvb, 0, -1, ENC_NA);\n\n        rpkirtr_tree = proto_item_add_subtree(ti, ett_rpkirtr);\n\n        proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_version, tvb, offset, 1, ENC_BIG_ENDIAN);\n        version = tvb_get_guint8(tvb, offset);\n        offset += 1;\n\n        ti_type = proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_pdu_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n        pdu_type = tvb_get_guint8(tvb, offset);\n        col_append_sep_str(pinfo->cinfo, COL_INFO, NULL, val_to_str(pdu_type, rtr_pdu_type_vals, \"Unknown (%d)\"));\n        proto_item_append_text(ti, \" (%s)\", val_to_str(pdu_type, rtr_pdu_type_vals, \"Unknown %d\"));\n        offset += 1;\n\n        length = tvb_get_ntohl(tvb, offset);\n\n        switch (pdu_type) {\n            case RPKI_RTR_SERIAL_NOTIFY_PDU: /* Serial Notify (0) */\n            case RPKI_RTR_SERIAL_QUERY_PDU:  /* Serial Query (1)  */\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_session_id,       tvb, offset, 2, ENC_BIG_ENDIAN);\n                offset += 2;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);\n                /* TODO: Add check length ? */\n                offset += 4;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_serial_number,    tvb, offset, 4, ENC_BIG_ENDIAN);\n                offset += 4;\n                break;\n            case RPKI_RTR_RESET_QUERY_PDU:  /* Reset Query (2) */\n            case RPKI_RTR_CACHE_RESET_PDU:  /* Cache Reset (8) */\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 2, ENC_NA);\n                offset += 2;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);\n                /* TODO: Add check length ? */\n                offset += 4;\n                break;\n            case RPKI_RTR_CACHE_RESPONSE_PDU:  /* Cache Response (3) */\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_session_id,       tvb, offset, 2, ENC_BIG_ENDIAN);\n                offset += 2;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);\n                /* TODO: Add check length ? */\n                offset += 4;\n                break;\n            case RPKI_RTR_IPV4_PREFIX_PDU: /* IPv4 Prefix (4) */\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 2, ENC_NA);\n                offset += 2;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);\n                /* TODO: Add check length ? */\n                offset += 4;\n                ti_flags = proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_flags, tvb, offset, 1, ENC_BIG_ENDIAN);\n                flags_tree = proto_item_add_subtree(ti_flags, ett_flags);\n                proto_tree_add_item(flags_tree, hf_rpkirtr_flags_aw,           tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_prefix_length,    tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_max_length,       tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 1, ENC_NA);\n                offset += 1;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_ipv4_prefix,      tvb, offset, 4, ENC_BIG_ENDIAN);\n                offset += 4;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_as_number,        tvb, offset, 4, ENC_BIG_ENDIAN);\n                offset += 4;\n                break;\n            case RPKI_RTR_IPV6_PREFIX_PDU: /* IPv6 Prefix (6) */\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 2, ENC_NA);\n                offset += 2;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);\n                /* TODO: Add check length ? */\n                offset += 4;\n                ti_flags = proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_flags, tvb, offset, 1, ENC_BIG_ENDIAN);\n                flags_tree = proto_item_add_subtree(ti_flags, ett_flags);\n                proto_tree_add_item(flags_tree, hf_rpkirtr_flags_aw,           tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_prefix_length,    tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_max_length,       tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 1, ENC_NA);\n                offset += 1;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_ipv6_prefix,      tvb, offset, 16, ENC_NA);\n                offset += 16;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_as_number,        tvb, offset, 4, ENC_BIG_ENDIAN);\n                offset += 4;\n                break;\n            case RPKI_RTR_END_OF_DATA_PDU: /* End Of Data (7) */\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_session_id,       tvb, offset, 2, ENC_BIG_ENDIAN);\n                offset += 2;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);\n                /* TODO: Add check length ? */\n                offset += 4;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_serial_number,    tvb, offset, 4, ENC_BIG_ENDIAN);\n                offset += 4;\n\n                if (version >= 1){\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_refresh_interval, tvb, offset, 4, ENC_BIG_ENDIAN);\n                offset += 4;\n\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_retry_interval,   tvb, offset, 4, ENC_BIG_ENDIAN);\n                offset += 4;\n\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_expire_interval,  tvb, offset, 4, ENC_BIG_ENDIAN);\n                offset += 4;\n                }\n                break;\n\n            case RPKI_RTR_ROUTER_KEY: /* Router Key (9) */\n                if(version < 1){\n                    /* Error about wrong version... */\n                    expert_add_info(pinfo, ti_type, &ei_rpkirtr_wrong_version_router_key);\n                } else {\n                    asn1_ctx_t asn1_ctx;\n\n                    ti_flags = proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_flags, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    flags_tree = proto_item_add_subtree(ti_flags, ett_flags_nd);\n                    proto_tree_add_item(flags_tree, hf_rpkirtr_flags_rk,           tvb, offset, 1, ENC_BIG_ENDIAN);\n                    offset += 1;\n                    proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 2, ENC_NA);\n                    offset += 1;\n                    proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);\n                    /* TODO: Add check length ? */\n                    offset += 4;\n                    proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_subject_key_identifier, tvb, offset, 20, ENC_NA);\n                    offset += 20;\n\n                    proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_as_number, tvb, offset, 4, ENC_BIG_ENDIAN);\n                    offset += 4;\n                    asn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo);\n                    offset = dissect_x509af_SubjectPublicKeyInfo(FALSE, tvb, offset, &asn1_ctx, rpkirtr_tree, hf_rpkirtr_subject_public_key_info);\n\n                }\n                break;\n            case RPKI_RTR_ERROR_REPORT_PDU: /* Error Report (10) */\n            {\n                guint32 len_pdu, len_text;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_error_code,       tvb, offset, 2, ENC_BIG_ENDIAN);\n                offset += 2;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);\n                /* TODO: Add check length ? */\n                offset += 4;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length_pdu,       tvb, offset, 4, ENC_BIG_ENDIAN);\n                len_pdu =                                                      tvb_get_ntohl(tvb, offset);\n                offset += 4;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_error_pdu,        tvb, offset, len_pdu, ENC_NA);\n                offset +=  len_pdu;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length_text,      tvb, offset, 4, ENC_BIG_ENDIAN);\n                len_text =                                                     tvb_get_ntohl(tvb, offset);\n                offset += 4,\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_error_text,   tvb, offset, len_text, ENC_ASCII|ENC_NA);\n                offset += len_text;\n            }\n            break;\n            default:\n                /* No default ? */\n                offset += length;\n                break;\n        }\n    }\n\n    return tvb_reported_length(tvb);\n}",
        "func": "static int dissect_rpkirtr_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n{\n\n    proto_item *ti = NULL, *ti_flags, *ti_type;\n    proto_tree *rpkirtr_tree = NULL, *flags_tree = NULL;\n    int offset = 0;\n    guint8 pdu_type, version;\n    guint length;\n\n    while (tvb_reported_length_remaining(tvb, offset) > 0) {\n\n        ti = proto_tree_add_item(tree, proto_rpkirtr, tvb, 0, -1, ENC_NA);\n\n        rpkirtr_tree = proto_item_add_subtree(ti, ett_rpkirtr);\n\n        proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_version, tvb, offset, 1, ENC_BIG_ENDIAN);\n        version = tvb_get_guint8(tvb, offset);\n        offset += 1;\n\n        ti_type = proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_pdu_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n        pdu_type = tvb_get_guint8(tvb, offset);\n        col_append_sep_str(pinfo->cinfo, COL_INFO, NULL, val_to_str(pdu_type, rtr_pdu_type_vals, \"Unknown (%d)\"));\n        proto_item_append_text(ti, \" (%s)\", val_to_str(pdu_type, rtr_pdu_type_vals, \"Unknown %d\"));\n        offset += 1;\n\n        length = tvb_get_ntohl(tvb, offset);\n\n        switch (pdu_type) {\n            case RPKI_RTR_SERIAL_NOTIFY_PDU: /* Serial Notify (0) */\n            case RPKI_RTR_SERIAL_QUERY_PDU:  /* Serial Query (1)  */\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_session_id,       tvb, offset, 2, ENC_BIG_ENDIAN);\n                offset += 2;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);\n                /* TODO: Add check length ? */\n                offset += 4;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_serial_number,    tvb, offset, 4, ENC_BIG_ENDIAN);\n                offset += 4;\n                break;\n            case RPKI_RTR_RESET_QUERY_PDU:  /* Reset Query (2) */\n            case RPKI_RTR_CACHE_RESET_PDU:  /* Cache Reset (8) */\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 2, ENC_NA);\n                offset += 2;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);\n                /* TODO: Add check length ? */\n                offset += 4;\n                break;\n            case RPKI_RTR_CACHE_RESPONSE_PDU:  /* Cache Response (3) */\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_session_id,       tvb, offset, 2, ENC_BIG_ENDIAN);\n                offset += 2;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);\n                /* TODO: Add check length ? */\n                offset += 4;\n                break;\n            case RPKI_RTR_IPV4_PREFIX_PDU: /* IPv4 Prefix (4) */\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 2, ENC_NA);\n                offset += 2;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);\n                /* TODO: Add check length ? */\n                offset += 4;\n                ti_flags = proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_flags, tvb, offset, 1, ENC_BIG_ENDIAN);\n                flags_tree = proto_item_add_subtree(ti_flags, ett_flags);\n                proto_tree_add_item(flags_tree, hf_rpkirtr_flags_aw,           tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_prefix_length,    tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_max_length,       tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 1, ENC_NA);\n                offset += 1;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_ipv4_prefix,      tvb, offset, 4, ENC_BIG_ENDIAN);\n                offset += 4;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_as_number,        tvb, offset, 4, ENC_BIG_ENDIAN);\n                offset += 4;\n                break;\n            case RPKI_RTR_IPV6_PREFIX_PDU: /* IPv6 Prefix (6) */\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 2, ENC_NA);\n                offset += 2;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);\n                /* TODO: Add check length ? */\n                offset += 4;\n                ti_flags = proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_flags, tvb, offset, 1, ENC_BIG_ENDIAN);\n                flags_tree = proto_item_add_subtree(ti_flags, ett_flags);\n                proto_tree_add_item(flags_tree, hf_rpkirtr_flags_aw,           tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_prefix_length,    tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_max_length,       tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 1, ENC_NA);\n                offset += 1;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_ipv6_prefix,      tvb, offset, 16, ENC_NA);\n                offset += 16;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_as_number,        tvb, offset, 4, ENC_BIG_ENDIAN);\n                offset += 4;\n                break;\n            case RPKI_RTR_END_OF_DATA_PDU: /* End Of Data (7) */\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_session_id,       tvb, offset, 2, ENC_BIG_ENDIAN);\n                offset += 2;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);\n                /* TODO: Add check length ? */\n                offset += 4;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_serial_number,    tvb, offset, 4, ENC_BIG_ENDIAN);\n                offset += 4;\n\n                if (version >= 1){\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_refresh_interval, tvb, offset, 4, ENC_BIG_ENDIAN);\n                offset += 4;\n\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_retry_interval,   tvb, offset, 4, ENC_BIG_ENDIAN);\n                offset += 4;\n\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_expire_interval,  tvb, offset, 4, ENC_BIG_ENDIAN);\n                offset += 4;\n                }\n                break;\n\n            case RPKI_RTR_ROUTER_KEY: /* Router Key (9) */\n                if(version < 1){\n                    /* Error about wrong version... */\n                    expert_add_info(pinfo, ti_type, &ei_rpkirtr_wrong_version_router_key);\n                } else {\n                    asn1_ctx_t asn1_ctx;\n\n                    ti_flags = proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_flags, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    flags_tree = proto_item_add_subtree(ti_flags, ett_flags_nd);\n                    proto_tree_add_item(flags_tree, hf_rpkirtr_flags_rk,           tvb, offset, 1, ENC_BIG_ENDIAN);\n                    offset += 1;\n                    proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 2, ENC_NA);\n                    offset += 1;\n                    proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);\n                    /* TODO: Add check length ? */\n                    offset += 4;\n                    proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_subject_key_identifier, tvb, offset, 20, ENC_NA);\n                    offset += 20;\n\n                    proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_as_number, tvb, offset, 4, ENC_BIG_ENDIAN);\n                    offset += 4;\n                    asn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo);\n                    offset = dissect_x509af_SubjectPublicKeyInfo(FALSE, tvb, offset, &asn1_ctx, rpkirtr_tree, hf_rpkirtr_subject_public_key_info);\n\n                }\n                break;\n            case RPKI_RTR_ERROR_REPORT_PDU: /* Error Report (10) */\n            {\n                guint32 len_pdu, len_text;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_error_code,       tvb, offset, 2, ENC_BIG_ENDIAN);\n                offset += 2;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN);\n                /* TODO: Add check length ? */\n                offset += 4;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length_pdu,       tvb, offset, 4, ENC_BIG_ENDIAN);\n                len_pdu =                                                      tvb_get_ntohl(tvb, offset);\n                offset += 4;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_error_pdu,        tvb, offset, len_pdu, ENC_NA);\n                offset +=  len_pdu;\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length_text,      tvb, offset, 4, ENC_BIG_ENDIAN);\n                len_text =                                                     tvb_get_ntohl(tvb, offset);\n                offset += 4,\n                proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_error_text,   tvb, offset, len_text, ENC_ASCII|ENC_NA);\n                offset += len_text;\n            }\n            break;\n            default:\n                /* No default ? At least sanity check the length*/\n                if (length > tvb_reported_length(tvb)) {\n                    expert_add_info(pinfo, ti_type, &ei_rpkirtr_bad_length);\n                    return tvb_reported_length(tvb);\n                }\n\n                offset += length;\n                break;\n        }\n    }\n\n    return tvb_reported_length(tvb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,7 @@\n     guint8 pdu_type, version;\n     guint length;\n \n-    while (tvb_reported_length_remaining(tvb, offset) != 0) {\n+    while (tvb_reported_length_remaining(tvb, offset) > 0) {\n \n         ti = proto_tree_add_item(tree, proto_rpkirtr, tvb, 0, -1, ENC_NA);\n \n@@ -161,7 +161,12 @@\n             }\n             break;\n             default:\n-                /* No default ? */\n+                /* No default ? At least sanity check the length*/\n+                if (length > tvb_reported_length(tvb)) {\n+                    expert_add_info(pinfo, ti_type, &ei_rpkirtr_bad_length);\n+                    return tvb_reported_length(tvb);\n+                }\n+\n                 offset += length;\n                 break;\n         }",
        "diff_line_info": {
            "deleted_lines": [
                "    while (tvb_reported_length_remaining(tvb, offset) != 0) {",
                "                /* No default ? */"
            ],
            "added_lines": [
                "    while (tvb_reported_length_remaining(tvb, offset) > 0) {",
                "                /* No default ? At least sanity check the length*/",
                "                if (length > tvb_reported_length(tvb)) {",
                "                    expert_add_info(pinfo, ti_type, &ei_rpkirtr_bad_length);",
                "                    return tvb_reported_length(tvb);",
                "                }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7325",
        "func_name": "wireshark/proto_register_rpkirtr",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-rpki-rtr.c had an infinite loop that was addressed by validating a length field.",
        "git_url": "https://github.com/wireshark/wireshark/commit/7be234d06ea39ab6a88115ae41d71060f1f15e3c",
        "commit_title": "RPKI-Router: Sanity check length field to prevent infinite loop",
        "commit_text": " Bug: 14414 (cherry picked from commit 5e8391ff900db18ccf8663918919b16085406874)",
        "func_before": "void\nproto_register_rpkirtr(void)\n{\n    module_t *rpkirtr_module;\n\n    static hf_register_info hf[] = {\n        { &hf_rpkirtr_version,\n            { \"Version\", \"rpki-rtr.version\",\n            FT_UINT8, BASE_DEC, NULL, 0x0,\n            \"Denoting the version of this protocol (currently 0)\", HFILL }\n        },\n        { &hf_rpkirtr_pdu_type,\n            { \"PDU Type\", \"rpki-rtr.pdu_type\",\n            FT_UINT8, BASE_DEC, VALS(rtr_pdu_type_vals), 0x0,\n            \"Denoting the type of the PDU\", HFILL }\n        },\n        { &hf_rpkirtr_reserved,\n            { \"Reserved\", \"rpki-rtr.reserved\",\n            FT_BYTES, BASE_NONE, NULL, 0x0,\n            \"Must be zero\", HFILL }\n        },\n        { &hf_rpkirtr_session_id,\n            { \"Session ID\", \"rpki-rtr.session_id\",\n            FT_UINT16, BASE_DEC, NULL, 0x0,\n            NULL, HFILL }\n        },\n        { &hf_rpkirtr_length,\n            { \"Length\", \"rpki-rtr.length\",\n            FT_UINT32, BASE_DEC, NULL, 0x0,\n            \"Value the count of the bytes in the entire PDU, including the eight bytes of header that end with the length field\", HFILL }\n        },\n        { &hf_rpkirtr_serial_number,\n            { \"Serial Number\", \"rpki-rtr.serial_number\",\n            FT_UINT32, BASE_DEC, NULL, 0x0,\n            NULL, HFILL }\n        },\n        { &hf_rpkirtr_flags,\n            { \"Flags\", \"rpki-rtr.flags\",\n            FT_UINT8, BASE_HEX, NULL, 0x0,\n            NULL, HFILL }\n        },\n        { &hf_rpkirtr_flags_aw,\n            { \"Flag AW\", \"rpki-rtr.flags.aw\",\n            FT_BOOLEAN, 8, TFS(&tfs_flag_type_aw), 0x01,\n            NULL, HFILL }\n        },\n        { &hf_rpkirtr_flags_rk,\n            { \"Flag Router Key\", \"rpki-rtr.flags.rk\",\n            FT_BOOLEAN, 8, TFS(&tfs_flag_type_rk), 0x01,\n            NULL, HFILL }\n        },\n        { &hf_rpkirtr_prefix_length,\n            { \"Prefix Length\", \"rpki-rtr.prefix_length\",\n            FT_UINT8, BASE_DEC, NULL, 0x0,\n            \"Denoting the shortest prefix allowed for the prefix\", HFILL }\n        },\n        { &hf_rpkirtr_max_length,\n            { \"Max length\", \"rpki-rtr.max_length\",\n            FT_UINT8, BASE_DEC, NULL, 0x0,\n            \"Denoting the longest prefix allowed by the prefix.  This MUST NOT be less than the Prefix Length element\", HFILL }\n        },\n        { &hf_rpkirtr_ipv4_prefix,\n            { \"IPv4 Prefix\", \"rpki-rtr.ipv4_prefix\",\n            FT_IPv4, BASE_NONE, NULL, 0x0,\n            \"The IPv4 prefix of the ROA\", HFILL }\n        },\n        { &hf_rpkirtr_ipv6_prefix,\n            { \"IPv6 Prefix\", \"rpki-rtr.ipv6_prefix\",\n            FT_IPv6, BASE_NONE, NULL, 0x0,\n            \"The IPv6 prefix of the ROA\", HFILL }\n        },\n        { &hf_rpkirtr_as_number,\n            { \"AS Number\", \"rpki-rtr.as_number\",\n            FT_UINT32, BASE_DEC, NULL, 0x0,\n            \"Autonomous System Number allowed to announce this prefix\", HFILL }\n        },\n        { &hf_rpkirtr_error_code,\n            { \"Error Code\", \"rpki-rtr.error_code\",\n            FT_UINT16, BASE_DEC, VALS(rtr_error_code_vals), 0x0,\n            NULL, HFILL }\n        },\n        { &hf_rpkirtr_length_pdu,\n            { \"Length of Encapsulated PDU\", \"rpki-rtr.length_pdu\",\n            FT_UINT32, BASE_DEC, NULL, 0x0,\n            NULL, HFILL }\n        },\n        { &hf_rpkirtr_error_pdu,\n            { \"Erroneous PDU\", \"rpki-rtr.error_pdu\",\n            FT_BYTES, BASE_NONE, NULL, 0x0,\n            NULL, HFILL }\n        },\n        { &hf_rpkirtr_length_text,\n            { \"Length of text\", \"rpki-rtr.length_text\",\n            FT_UINT32, BASE_DEC, NULL, 0x0,\n            NULL, HFILL }\n        },\n        { &hf_rpkirtr_error_text,\n            { \"Erroneous Text\", \"rpki-rtr.error_text\",\n            FT_STRING, BASE_NONE, NULL, 0x0,\n            NULL, HFILL }\n        },\n        { &hf_rpkirtr_refresh_interval,\n            { \"Refresh Interval\", \"rpki-rtr.refresh_interval\",\n            FT_UINT32, BASE_DEC, NULL, 0x0,\n            NULL, HFILL }\n        },\n        { &hf_rpkirtr_retry_interval,\n            { \"Retry Interval\", \"rpki-rtr.retry_interval\",\n            FT_UINT32, BASE_DEC, NULL, 0x0,\n            NULL, HFILL }\n        },\n        { &hf_rpkirtr_expire_interval,\n            { \"Expire Interval\", \"rpki-rtr.expire_interval\",\n            FT_UINT32, BASE_DEC, NULL, 0x0,\n            NULL, HFILL }\n        },\n        { &hf_rpkirtr_subject_key_identifier,\n            { \"Subject Key Identifier\", \"rpki-rtr.subject_key_identifier\",\n            FT_BYTES, BASE_NONE, NULL, 0x0,\n            NULL, HFILL }\n        },\n        { &hf_rpkirtr_subject_public_key_info,\n            { \"Subject Public Key Info\", \"rpki-rtr.subject_public_key_info\",\n            FT_NONE, BASE_NONE, NULL, 0x0,\n            NULL, HFILL }\n        }\n    };\n\n    static gint *ett[] = {\n        &ett_rpkirtr,\n        &ett_flags,\n        &ett_flags_nd\n    };\n\n    static ei_register_info ei[] = {\n        { &ei_rpkirtr_wrong_version_router_key, { \"rpkirtr.router_key.wrong_version\", PI_MALFORMED, PI_WARN, \"Wrong version for Router Key type\", EXPFILL }},\n    };\n\n    expert_module_t *expert_rpkirtr;\n\n    proto_rpkirtr = proto_register_protocol(\"RPKI-Router Protocol\",\n        \"RPKI-Router Protocol\", \"rpkirtr\");\n\n    proto_register_field_array(proto_rpkirtr, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n\n    rpkirtr_module = prefs_register_protocol(proto_rpkirtr,\n        proto_reg_handoff_rpkirtr);\n\n    prefs_register_uint_preference(rpkirtr_module, \"tcp.rpkirtr_tls.port\", \"RPKI-RTR TCP TLS Port\",\n         \"RPKI-Router Protocol TCP TLS port if other than the default\",\n         10, &g_port_rpkirtr_tls);\n\n    expert_rpkirtr = expert_register_protocol(proto_rpkirtr);\n    expert_register_field_array(expert_rpkirtr, ei, array_length(ei));\n    rpkirtr_handle = register_dissector(\"rpkirtr\", dissect_rpkirtr, proto_rpkirtr);\n}",
        "func": "void\nproto_register_rpkirtr(void)\n{\n    module_t *rpkirtr_module;\n\n    static hf_register_info hf[] = {\n        { &hf_rpkirtr_version,\n            { \"Version\", \"rpki-rtr.version\",\n            FT_UINT8, BASE_DEC, NULL, 0x0,\n            \"Denoting the version of this protocol (currently 0)\", HFILL }\n        },\n        { &hf_rpkirtr_pdu_type,\n            { \"PDU Type\", \"rpki-rtr.pdu_type\",\n            FT_UINT8, BASE_DEC, VALS(rtr_pdu_type_vals), 0x0,\n            \"Denoting the type of the PDU\", HFILL }\n        },\n        { &hf_rpkirtr_reserved,\n            { \"Reserved\", \"rpki-rtr.reserved\",\n            FT_BYTES, BASE_NONE, NULL, 0x0,\n            \"Must be zero\", HFILL }\n        },\n        { &hf_rpkirtr_session_id,\n            { \"Session ID\", \"rpki-rtr.session_id\",\n            FT_UINT16, BASE_DEC, NULL, 0x0,\n            NULL, HFILL }\n        },\n        { &hf_rpkirtr_length,\n            { \"Length\", \"rpki-rtr.length\",\n            FT_UINT32, BASE_DEC, NULL, 0x0,\n            \"Value the count of the bytes in the entire PDU, including the eight bytes of header that end with the length field\", HFILL }\n        },\n        { &hf_rpkirtr_serial_number,\n            { \"Serial Number\", \"rpki-rtr.serial_number\",\n            FT_UINT32, BASE_DEC, NULL, 0x0,\n            NULL, HFILL }\n        },\n        { &hf_rpkirtr_flags,\n            { \"Flags\", \"rpki-rtr.flags\",\n            FT_UINT8, BASE_HEX, NULL, 0x0,\n            NULL, HFILL }\n        },\n        { &hf_rpkirtr_flags_aw,\n            { \"Flag AW\", \"rpki-rtr.flags.aw\",\n            FT_BOOLEAN, 8, TFS(&tfs_flag_type_aw), 0x01,\n            NULL, HFILL }\n        },\n        { &hf_rpkirtr_flags_rk,\n            { \"Flag Router Key\", \"rpki-rtr.flags.rk\",\n            FT_BOOLEAN, 8, TFS(&tfs_flag_type_rk), 0x01,\n            NULL, HFILL }\n        },\n        { &hf_rpkirtr_prefix_length,\n            { \"Prefix Length\", \"rpki-rtr.prefix_length\",\n            FT_UINT8, BASE_DEC, NULL, 0x0,\n            \"Denoting the shortest prefix allowed for the prefix\", HFILL }\n        },\n        { &hf_rpkirtr_max_length,\n            { \"Max length\", \"rpki-rtr.max_length\",\n            FT_UINT8, BASE_DEC, NULL, 0x0,\n            \"Denoting the longest prefix allowed by the prefix.  This MUST NOT be less than the Prefix Length element\", HFILL }\n        },\n        { &hf_rpkirtr_ipv4_prefix,\n            { \"IPv4 Prefix\", \"rpki-rtr.ipv4_prefix\",\n            FT_IPv4, BASE_NONE, NULL, 0x0,\n            \"The IPv4 prefix of the ROA\", HFILL }\n        },\n        { &hf_rpkirtr_ipv6_prefix,\n            { \"IPv6 Prefix\", \"rpki-rtr.ipv6_prefix\",\n            FT_IPv6, BASE_NONE, NULL, 0x0,\n            \"The IPv6 prefix of the ROA\", HFILL }\n        },\n        { &hf_rpkirtr_as_number,\n            { \"AS Number\", \"rpki-rtr.as_number\",\n            FT_UINT32, BASE_DEC, NULL, 0x0,\n            \"Autonomous System Number allowed to announce this prefix\", HFILL }\n        },\n        { &hf_rpkirtr_error_code,\n            { \"Error Code\", \"rpki-rtr.error_code\",\n            FT_UINT16, BASE_DEC, VALS(rtr_error_code_vals), 0x0,\n            NULL, HFILL }\n        },\n        { &hf_rpkirtr_length_pdu,\n            { \"Length of Encapsulated PDU\", \"rpki-rtr.length_pdu\",\n            FT_UINT32, BASE_DEC, NULL, 0x0,\n            NULL, HFILL }\n        },\n        { &hf_rpkirtr_error_pdu,\n            { \"Erroneous PDU\", \"rpki-rtr.error_pdu\",\n            FT_BYTES, BASE_NONE, NULL, 0x0,\n            NULL, HFILL }\n        },\n        { &hf_rpkirtr_length_text,\n            { \"Length of text\", \"rpki-rtr.length_text\",\n            FT_UINT32, BASE_DEC, NULL, 0x0,\n            NULL, HFILL }\n        },\n        { &hf_rpkirtr_error_text,\n            { \"Erroneous Text\", \"rpki-rtr.error_text\",\n            FT_STRING, BASE_NONE, NULL, 0x0,\n            NULL, HFILL }\n        },\n        { &hf_rpkirtr_refresh_interval,\n            { \"Refresh Interval\", \"rpki-rtr.refresh_interval\",\n            FT_UINT32, BASE_DEC, NULL, 0x0,\n            NULL, HFILL }\n        },\n        { &hf_rpkirtr_retry_interval,\n            { \"Retry Interval\", \"rpki-rtr.retry_interval\",\n            FT_UINT32, BASE_DEC, NULL, 0x0,\n            NULL, HFILL }\n        },\n        { &hf_rpkirtr_expire_interval,\n            { \"Expire Interval\", \"rpki-rtr.expire_interval\",\n            FT_UINT32, BASE_DEC, NULL, 0x0,\n            NULL, HFILL }\n        },\n        { &hf_rpkirtr_subject_key_identifier,\n            { \"Subject Key Identifier\", \"rpki-rtr.subject_key_identifier\",\n            FT_BYTES, BASE_NONE, NULL, 0x0,\n            NULL, HFILL }\n        },\n        { &hf_rpkirtr_subject_public_key_info,\n            { \"Subject Public Key Info\", \"rpki-rtr.subject_public_key_info\",\n            FT_NONE, BASE_NONE, NULL, 0x0,\n            NULL, HFILL }\n        }\n    };\n\n    static gint *ett[] = {\n        &ett_rpkirtr,\n        &ett_flags,\n        &ett_flags_nd\n    };\n\n    static ei_register_info ei[] = {\n        { &ei_rpkirtr_wrong_version_router_key, { \"rpkirtr.router_key.wrong_version\", PI_MALFORMED, PI_WARN, \"Wrong version for Router Key type\", EXPFILL }},\n        { &ei_rpkirtr_bad_length, { \"rpkirtr.bad_length\", PI_MALFORMED, PI_ERROR, \"Invalid length field\", EXPFILL }},\n    };\n\n    expert_module_t *expert_rpkirtr;\n\n    proto_rpkirtr = proto_register_protocol(\"RPKI-Router Protocol\",\n        \"RPKI-Router Protocol\", \"rpkirtr\");\n\n    proto_register_field_array(proto_rpkirtr, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n\n    rpkirtr_module = prefs_register_protocol(proto_rpkirtr,\n        proto_reg_handoff_rpkirtr);\n\n    prefs_register_uint_preference(rpkirtr_module, \"tcp.rpkirtr_tls.port\", \"RPKI-RTR TCP TLS Port\",\n         \"RPKI-Router Protocol TCP TLS port if other than the default\",\n         10, &g_port_rpkirtr_tls);\n\n    expert_rpkirtr = expert_register_protocol(proto_rpkirtr);\n    expert_register_field_array(expert_rpkirtr, ei, array_length(ei));\n    rpkirtr_handle = register_dissector(\"rpkirtr\", dissect_rpkirtr, proto_rpkirtr);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -134,6 +134,7 @@\n \n     static ei_register_info ei[] = {\n         { &ei_rpkirtr_wrong_version_router_key, { \"rpkirtr.router_key.wrong_version\", PI_MALFORMED, PI_WARN, \"Wrong version for Router Key type\", EXPFILL }},\n+        { &ei_rpkirtr_bad_length, { \"rpkirtr.bad_length\", PI_MALFORMED, PI_ERROR, \"Invalid length field\", EXPFILL }},\n     };\n \n     expert_module_t *expert_rpkirtr;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        { &ei_rpkirtr_bad_length, { \"rpkirtr.bad_length\", PI_MALFORMED, PI_ERROR, \"Invalid length field\", EXPFILL }},"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7326",
        "func_name": "wireshark/dissect_lltd_tlv",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-lltd.c had an infinite loop that was addressed by using a correct integer data type.",
        "git_url": "https://github.com/wireshark/wireshark/commit/293b999425e998d6cde0d9149648e421ea7687d0",
        "commit_title": "LLTD: use wider variables to prevent overflow and infinite loops",
        "commit_text": " Bug: 14419 (cherry picked from commit 8760999f646fb398fa0c824f3539cee4a4911d13)",
        "func_before": "static int\ndissect_lltd_tlv(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint32 offset, gboolean* end)\n{\n    guint8     i, type, length = 0;\n    proto_item *tlv_item, *type_item;\n    proto_tree *tlv_tree, *type_tree;\n    guint32 temp32;\n\n    type = tvb_get_guint8(tvb, offset);\n    if (type == 0)\n    {\n        /* End of Property type doesn't have length */\n        tlv_tree = proto_tree_add_subtree(tree, tvb, offset, 1, ett_tlv_item, &tlv_item, \"TLV Item (End of Property List)\");\n        *end = TRUE;\n    }\n    else\n    {\n        length = tvb_get_guint8(tvb, offset+1);\n        tlv_tree = proto_tree_add_subtree_format(tree, tvb, offset, length+2, ett_tlv_item, &tlv_item,\n                    \"TLV Item (%s)\", val_to_str(type, lltd_tlv_type_vals, \"Unknown (0x%02x)\"));\n        *end = FALSE;\n    }\n\n    proto_tree_add_item(tlv_tree, hf_lltd_tlv_type, tvb, offset, 1, ENC_NA);\n    if (type != 0)\n        proto_tree_add_item(tlv_tree, hf_lltd_tlv_length, tvb, offset+1, 1, ENC_NA);\n\n\n    if ((type != 0) && (length > tvb_reported_length_remaining(tvb, offset+2)))\n    {\n        expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"TLV Length field too big\");\n        *end = TRUE;\n        return 2;\n    }\n\n    switch(type)\n    {\n    case 0x00: /* End of Property List */\n        /* No data, no length field */\n        return 1;\n    case 0x01: /* Host ID */\n        if (length != 6)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid Host ID length\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_host_id, tvb, offset+2, 6, ENC_NA);\n        break;\n    case 0x02: /* Characteristics */\n        if (length != 4)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Characteristics length\");\n        }\n        else\n        {\n            type_tree = proto_tree_add_subtree(tree, tvb, offset+2, 4, ett_characteristics, &type_item, \"Characteristics\");\n            proto_tree_add_item(type_tree, hf_lltd_char_p, tvb, offset+2, 4, ENC_BIG_ENDIAN);\n            proto_tree_add_item(type_tree, hf_lltd_char_x, tvb, offset+2, 4, ENC_BIG_ENDIAN);\n            proto_tree_add_item(type_tree, hf_lltd_char_f, tvb, offset+2, 4, ENC_BIG_ENDIAN);\n            proto_tree_add_item(type_tree, hf_lltd_char_m, tvb, offset+2, 4, ENC_BIG_ENDIAN);\n            proto_tree_add_item(type_tree, hf_lltd_char_l, tvb, offset+2, 4, ENC_BIG_ENDIAN);\n            proto_tree_add_item(type_tree, hf_lltd_char_reserved, tvb, offset+2, 4, ENC_BIG_ENDIAN);\n            if (tvb_get_ntohl(tvb, offset+2) & LLTD_CHARACTERISTIC_RESERVE_MASK)\n                expert_add_info(pinfo, type_item, &ei_lltd_char_reserved);\n        }\n        break;\n    case 0x03: /* Physical Medium */\n        if (length != 4)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid Physical Medium length\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_physical_medium, tvb, offset+2, 4, ENC_BIG_ENDIAN);\n        break;\n    case 0x04: /* Wireless Mode */\n        if (length != 1)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid Wireless Mode length\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_wireless_mode, tvb, offset+2, 1, ENC_BIG_ENDIAN);\n        break;\n    case 0x05: /* 802.11 BSSID */\n        if (length != 6)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid BSSID length\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_bssid, tvb, offset+2, 6, ENC_NA);\n        break;\n    case 0x06: /* 802.11 SSID */\n        if (length > 32)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"SSID length too large\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_ssid, tvb, offset+2, length, ENC_NA|ENC_ASCII);\n        break;\n    case 0x07: /* IPv4 Address */\n        if (length != 4)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid IPv4 Address length\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_ipv4_address, tvb, offset+2, 4, ENC_BIG_ENDIAN);\n        break;\n    case 0x08: /* IPv6 Address */\n        if (length != 16)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid IPv6 Address length\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_ipv6_address, tvb, offset+2, 16, ENC_NA);\n        break;\n    case 0x09: /* 802.11 Maximum Operation Rate */\n        if (length != 2)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid Maximum Operation Rate length\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_max_operation_rate, tvb, offset+2, 2, ENC_BIG_ENDIAN);\n        break;\n    case 0x0A: /* Performance Counter Frequency */\n        if (length != 8)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid Performance Counter Frequency length\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_performance_count_freq, tvb, offset+2, 8, ENC_BIG_ENDIAN);\n        break;\n    case 0x0C: /* Link Speed */\n        if (length != 4)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid Link Speed length\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_link_speed, tvb, offset+2, 4, ENC_BIG_ENDIAN);\n        break;\n    case 0x0D: /* 802.11 RSSI */\n        if (length != 4)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid RSSI length\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_rssi, tvb, offset+2, 4, ENC_BIG_ENDIAN);\n        break;\n    case 0x0F: /* Machine Name */\n        if (length > 32)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Machine Name length too large\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_machine_name, tvb, offset+2, length, ENC_LITTLE_ENDIAN|ENC_UCS_2);\n        break;\n    case 0x10: /* Support Information */\n        if (length > 64)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Support Information length too large\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_support_info, tvb, offset+2, length, ENC_LITTLE_ENDIAN|ENC_UCS_2);\n        break;\n    case 0x11: /* Friendly Name */\n        if (length != 0)\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid Friendly Name length\");\n        break;\n    case 0x12: /* Device UUID */\n        if (length != 22)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid Device UUID length\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_device_uuid, tvb, offset+2, 22, ENC_NA);\n        break;\n    case 0x13: /* Hardware ID */\n        if (length != 0)\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid Hardware ID length\");\n        break;\n    case 0x14: /* QoS Characteristics */\n        if (length != 4)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"QoS Characteristics length\");\n        }\n        else\n        {\n            type_tree = proto_tree_add_subtree(tlv_tree, tvb, offset+2, 4, ett_qos_characteristics, &type_item, \"QoS Characteristics\");\n            proto_tree_add_item(type_tree, hf_lltd_qos_char_e, tvb, offset+2, 4, ENC_BIG_ENDIAN);\n            proto_tree_add_item(type_tree, hf_lltd_qos_char_q, tvb, offset+2, 4, ENC_BIG_ENDIAN);\n            proto_tree_add_item(type_tree, hf_lltd_qos_char_p, tvb, offset+2, 4, ENC_BIG_ENDIAN);\n            proto_tree_add_item(type_tree, hf_lltd_qos_char_reserved, tvb, offset+2, 4, ENC_BIG_ENDIAN);\n            temp32 = tvb_get_ntohl(tvb, offset+2);\n            if (temp32 & LLTD_QOS_CHARACTERISTIC_RESERVE_MASK)\n                expert_add_info(pinfo, type_item, &ei_lltd_char_reserved);\n        }\n        break;\n    case 0x15: /* 802.11 Physical Medium */\n        if (length != 1)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid 802.11 Phyiscal Medium length\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_80211_physical_medium, tvb, offset+2, 1, ENC_BIG_ENDIAN);\n        break;\n    case 0x19: /* Sees-List Working Set */\n        if (length != 2)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid Sees-List Working Set length\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_sees_list_working_set, tvb, offset+2, 2, ENC_BIG_ENDIAN);\n        break;\n    case 0x1B: /* Repeater AP Lineage */\n        type_tree = proto_tree_add_subtree(tree, tvb, offset+2, length, ett_repeater_ap_lineage, NULL, \"Repeater AP Lineage\");\n        for (i = 0; i < length; i += 6)\n            proto_tree_add_item(type_tree, hf_lltd_repeater_ap_lineage, tvb, offset+2+i, 6, ENC_NA);\n\n        if (length > 36)\n            expert_add_info(pinfo, tlv_item, &ei_lltd_too_many_paths);\n        break;\n    case 0x0E: /* Icon Image */\n    case 0x16: /* AP Association Table */\n    case 0x18: /* Detailed Icon Image */\n    case 0x1A: /* Component Table */\n    case 0x1C: /* Repeater AP Table */\n        if (length != 0)\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid length\");\n        break;\n    default:\n        expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_type, \"Invalid TLV Type 0x%02x\", type);\n        break;\n    }\n\n    return length+2;\n}",
        "func": "static int\ndissect_lltd_tlv(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint32 offset, gboolean* end)\n{\n    guint8     type, length = 0;\n    proto_item *tlv_item, *type_item;\n    proto_tree *tlv_tree, *type_tree;\n    guint32 i, temp32;\n\n    type = tvb_get_guint8(tvb, offset);\n    if (type == 0)\n    {\n        /* End of Property type doesn't have length */\n        tlv_tree = proto_tree_add_subtree(tree, tvb, offset, 1, ett_tlv_item, &tlv_item, \"TLV Item (End of Property List)\");\n        *end = TRUE;\n    }\n    else\n    {\n        length = tvb_get_guint8(tvb, offset+1);\n        tlv_tree = proto_tree_add_subtree_format(tree, tvb, offset, length+2, ett_tlv_item, &tlv_item,\n                    \"TLV Item (%s)\", val_to_str(type, lltd_tlv_type_vals, \"Unknown (0x%02x)\"));\n        *end = FALSE;\n    }\n\n    proto_tree_add_item(tlv_tree, hf_lltd_tlv_type, tvb, offset, 1, ENC_NA);\n    if (type != 0)\n        proto_tree_add_item(tlv_tree, hf_lltd_tlv_length, tvb, offset+1, 1, ENC_NA);\n\n\n    if ((type != 0) && (length > tvb_reported_length_remaining(tvb, offset+2)))\n    {\n        expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"TLV Length field too big\");\n        *end = TRUE;\n        return 2;\n    }\n\n    switch(type)\n    {\n    case 0x00: /* End of Property List */\n        /* No data, no length field */\n        return 1;\n    case 0x01: /* Host ID */\n        if (length != 6)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid Host ID length\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_host_id, tvb, offset+2, 6, ENC_NA);\n        break;\n    case 0x02: /* Characteristics */\n        if (length != 4)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Characteristics length\");\n        }\n        else\n        {\n            type_tree = proto_tree_add_subtree(tree, tvb, offset+2, 4, ett_characteristics, &type_item, \"Characteristics\");\n            proto_tree_add_item(type_tree, hf_lltd_char_p, tvb, offset+2, 4, ENC_BIG_ENDIAN);\n            proto_tree_add_item(type_tree, hf_lltd_char_x, tvb, offset+2, 4, ENC_BIG_ENDIAN);\n            proto_tree_add_item(type_tree, hf_lltd_char_f, tvb, offset+2, 4, ENC_BIG_ENDIAN);\n            proto_tree_add_item(type_tree, hf_lltd_char_m, tvb, offset+2, 4, ENC_BIG_ENDIAN);\n            proto_tree_add_item(type_tree, hf_lltd_char_l, tvb, offset+2, 4, ENC_BIG_ENDIAN);\n            proto_tree_add_item(type_tree, hf_lltd_char_reserved, tvb, offset+2, 4, ENC_BIG_ENDIAN);\n            if (tvb_get_ntohl(tvb, offset+2) & LLTD_CHARACTERISTIC_RESERVE_MASK)\n                expert_add_info(pinfo, type_item, &ei_lltd_char_reserved);\n        }\n        break;\n    case 0x03: /* Physical Medium */\n        if (length != 4)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid Physical Medium length\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_physical_medium, tvb, offset+2, 4, ENC_BIG_ENDIAN);\n        break;\n    case 0x04: /* Wireless Mode */\n        if (length != 1)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid Wireless Mode length\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_wireless_mode, tvb, offset+2, 1, ENC_BIG_ENDIAN);\n        break;\n    case 0x05: /* 802.11 BSSID */\n        if (length != 6)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid BSSID length\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_bssid, tvb, offset+2, 6, ENC_NA);\n        break;\n    case 0x06: /* 802.11 SSID */\n        if (length > 32)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"SSID length too large\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_ssid, tvb, offset+2, length, ENC_NA|ENC_ASCII);\n        break;\n    case 0x07: /* IPv4 Address */\n        if (length != 4)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid IPv4 Address length\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_ipv4_address, tvb, offset+2, 4, ENC_BIG_ENDIAN);\n        break;\n    case 0x08: /* IPv6 Address */\n        if (length != 16)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid IPv6 Address length\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_ipv6_address, tvb, offset+2, 16, ENC_NA);\n        break;\n    case 0x09: /* 802.11 Maximum Operation Rate */\n        if (length != 2)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid Maximum Operation Rate length\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_max_operation_rate, tvb, offset+2, 2, ENC_BIG_ENDIAN);\n        break;\n    case 0x0A: /* Performance Counter Frequency */\n        if (length != 8)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid Performance Counter Frequency length\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_performance_count_freq, tvb, offset+2, 8, ENC_BIG_ENDIAN);\n        break;\n    case 0x0C: /* Link Speed */\n        if (length != 4)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid Link Speed length\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_link_speed, tvb, offset+2, 4, ENC_BIG_ENDIAN);\n        break;\n    case 0x0D: /* 802.11 RSSI */\n        if (length != 4)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid RSSI length\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_rssi, tvb, offset+2, 4, ENC_BIG_ENDIAN);\n        break;\n    case 0x0F: /* Machine Name */\n        if (length > 32)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Machine Name length too large\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_machine_name, tvb, offset+2, length, ENC_LITTLE_ENDIAN|ENC_UCS_2);\n        break;\n    case 0x10: /* Support Information */\n        if (length > 64)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Support Information length too large\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_support_info, tvb, offset+2, length, ENC_LITTLE_ENDIAN|ENC_UCS_2);\n        break;\n    case 0x11: /* Friendly Name */\n        if (length != 0)\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid Friendly Name length\");\n        break;\n    case 0x12: /* Device UUID */\n        if (length != 22)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid Device UUID length\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_device_uuid, tvb, offset+2, 22, ENC_NA);\n        break;\n    case 0x13: /* Hardware ID */\n        if (length != 0)\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid Hardware ID length\");\n        break;\n    case 0x14: /* QoS Characteristics */\n        if (length != 4)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"QoS Characteristics length\");\n        }\n        else\n        {\n            type_tree = proto_tree_add_subtree(tlv_tree, tvb, offset+2, 4, ett_qos_characteristics, &type_item, \"QoS Characteristics\");\n            proto_tree_add_item(type_tree, hf_lltd_qos_char_e, tvb, offset+2, 4, ENC_BIG_ENDIAN);\n            proto_tree_add_item(type_tree, hf_lltd_qos_char_q, tvb, offset+2, 4, ENC_BIG_ENDIAN);\n            proto_tree_add_item(type_tree, hf_lltd_qos_char_p, tvb, offset+2, 4, ENC_BIG_ENDIAN);\n            proto_tree_add_item(type_tree, hf_lltd_qos_char_reserved, tvb, offset+2, 4, ENC_BIG_ENDIAN);\n            temp32 = tvb_get_ntohl(tvb, offset+2);\n            if (temp32 & LLTD_QOS_CHARACTERISTIC_RESERVE_MASK)\n                expert_add_info(pinfo, type_item, &ei_lltd_char_reserved);\n        }\n        break;\n    case 0x15: /* 802.11 Physical Medium */\n        if (length != 1)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid 802.11 Phyiscal Medium length\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_80211_physical_medium, tvb, offset+2, 1, ENC_BIG_ENDIAN);\n        break;\n    case 0x19: /* Sees-List Working Set */\n        if (length != 2)\n        {\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid Sees-List Working Set length\");\n        }\n\n        proto_tree_add_item(tlv_tree, hf_lltd_sees_list_working_set, tvb, offset+2, 2, ENC_BIG_ENDIAN);\n        break;\n    case 0x1B: /* Repeater AP Lineage */\n        type_tree = proto_tree_add_subtree(tree, tvb, offset+2, length, ett_repeater_ap_lineage, NULL, \"Repeater AP Lineage\");\n        for (i = 0; i < length; i += 6)\n            proto_tree_add_item(type_tree, hf_lltd_repeater_ap_lineage, tvb, offset+2+i, 6, ENC_NA);\n\n        if (length > 36)\n            expert_add_info(pinfo, tlv_item, &ei_lltd_too_many_paths);\n        break;\n    case 0x0E: /* Icon Image */\n    case 0x16: /* AP Association Table */\n    case 0x18: /* Detailed Icon Image */\n    case 0x1A: /* Component Table */\n    case 0x1C: /* Repeater AP Table */\n        if (length != 0)\n            expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_length_invalid, \"Invalid length\");\n        break;\n    default:\n        expert_add_info_format(pinfo, tlv_item, &ei_lltd_tlv_type, \"Invalid TLV Type 0x%02x\", type);\n        break;\n    }\n\n    return length+2;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,10 @@\n static int\n dissect_lltd_tlv(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint32 offset, gboolean* end)\n {\n-    guint8     i, type, length = 0;\n+    guint8     type, length = 0;\n     proto_item *tlv_item, *type_item;\n     proto_tree *tlv_tree, *type_tree;\n-    guint32 temp32;\n+    guint32 i, temp32;\n \n     type = tvb_get_guint8(tvb, offset);\n     if (type == 0)",
        "diff_line_info": {
            "deleted_lines": [
                "    guint8     i, type, length = 0;",
                "    guint32 temp32;"
            ],
            "added_lines": [
                "    guint8     type, length = 0;",
                "    guint32 i, temp32;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7327",
        "func_name": "wireshark/dissect_openflow_port_desc_prop_v6",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-openflow_v6.c had an infinite loop that was addressed by validating property lengths.",
        "git_url": "https://github.com/wireshark/wireshark/commit/563989f888e51258edb9a27db56124bdc33c9afe",
        "commit_title": "OpenFlow 1.5: add extra property length checks",
        "commit_text": " Bug: 14420 (cherry picked from commit 944e661514feca102e49e2d776f0a484e24fc597) Conflicts: \tepan/dissectors/packet-openflow_v6.c",
        "func_before": "static int\ndissect_openflow_port_desc_prop_v6(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, guint16 length _U_)\n{\n    proto_tree *prop_tree;\n    guint16 prop_type;\n    guint16 prop_length;\n\n    prop_type = tvb_get_ntohs(tvb, offset);\n    prop_length = tvb_get_ntohs(tvb, offset);\n\n    prop_tree = proto_tree_add_subtree(tree, tvb, offset, prop_length, ett_openflow_v6_port_desc_prop, NULL, \"Port desc. property\");\n\n    /* uint16_t type; */\n    proto_tree_add_item(prop_tree, hf_openflow_v6_port_desc_prop_type, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset+=2;\n\n    /* uint16_t len; */\n    proto_tree_add_item(prop_tree, hf_openflow_v6_port_desc_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset+=2;\n\n    switch (prop_type) {\n    case OFPPDPT_ETHERNET:\n        offset = dissect_openflow_port_desc_prop_ethernet_v6(tvb, pinfo, prop_tree, offset, length);\n        break;\n\n    case OFPPDPT_OPTICAL:\n        offset = dissect_openflow_port_desc_prop_optical_v6(tvb, pinfo, prop_tree, offset, length);\n        break;\n\n    case OFPPDPT_EXPERIMENTER:\n        /* uint32_t experimenter; */\n        proto_tree_add_item(tree, hf_openflow_v6_port_desc_prop_experimenter_experimenter, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n\n        /* uint32_t exp_type; */\n        proto_tree_add_item(tree, hf_openflow_v6_port_desc_prop_experimenter_exp_type, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n\n        proto_tree_add_expert_format(tree, pinfo, &ei_openflow_v6_port_desc_prop_undecoded,\n                                     tvb, offset, prop_length - 12, \"Experimenter port desc. property.\");\n        offset += prop_length - 12;\n        break;\n\n    default:\n        proto_tree_add_expert_format(tree, pinfo, &ei_openflow_v6_port_desc_prop_undecoded,\n                                     tvb, offset, prop_length - 4, \"Unknown port desc. property.\");\n        offset += prop_length - 4;\n        break;\n    }\n\n    return offset;\n}",
        "func": "static int\ndissect_openflow_port_desc_prop_v6(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, guint16 length _U_)\n{\n    proto_tree *prop_tree;\n    proto_item *prop_item;\n    guint16 prop_type;\n    guint16 prop_length;\n\n    prop_type = tvb_get_ntohs(tvb, offset);\n    prop_length = tvb_get_ntohs(tvb, offset);\n\n    prop_tree = proto_tree_add_subtree(tree, tvb, offset, prop_length, ett_openflow_v6_port_desc_prop, NULL, \"Port desc. property\");\n\n    /* uint16_t type; */\n    proto_tree_add_item(prop_tree, hf_openflow_v6_port_desc_prop_type, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset+=2;\n\n    /* uint16_t len; */\n    prop_item = proto_tree_add_item(prop_tree, hf_openflow_v6_port_desc_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset+=2;\n\n    switch (prop_type) {\n    case OFPPDPT_ETHERNET:\n        offset = dissect_openflow_port_desc_prop_ethernet_v6(tvb, pinfo, prop_tree, offset, length);\n        break;\n\n    case OFPPDPT_OPTICAL:\n        offset = dissect_openflow_port_desc_prop_optical_v6(tvb, pinfo, prop_tree, offset, length);\n        break;\n\n    case OFPPDPT_EXPERIMENTER:\n        if (prop_length <= 12) {\n            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);\n            offset = length;\n            break;\n        }\n        /* uint32_t experimenter; */\n        proto_tree_add_item(tree, hf_openflow_v6_port_desc_prop_experimenter_experimenter, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n\n        /* uint32_t exp_type; */\n        proto_tree_add_item(tree, hf_openflow_v6_port_desc_prop_experimenter_exp_type, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n\n        proto_tree_add_expert_format(tree, pinfo, &ei_openflow_v6_port_desc_prop_undecoded,\n                                     tvb, offset, prop_length - 12, \"Experimenter port desc. property.\");\n        offset += prop_length - 12;\n        break;\n\n    default:\n        if (prop_length <= 4) {\n            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);\n            offset = length;\n            break;\n        }\n        proto_tree_add_expert_format(tree, pinfo, &ei_openflow_v6_port_desc_prop_undecoded,\n                                     tvb, offset, prop_length - 4, \"Unknown port desc. property.\");\n        offset += prop_length - 4;\n        break;\n    }\n\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,7 @@\n dissect_openflow_port_desc_prop_v6(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, guint16 length _U_)\n {\n     proto_tree *prop_tree;\n+    proto_item *prop_item;\n     guint16 prop_type;\n     guint16 prop_length;\n \n@@ -15,7 +16,7 @@\n     offset+=2;\n \n     /* uint16_t len; */\n-    proto_tree_add_item(prop_tree, hf_openflow_v6_port_desc_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n+    prop_item = proto_tree_add_item(prop_tree, hf_openflow_v6_port_desc_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n     offset+=2;\n \n     switch (prop_type) {\n@@ -28,6 +29,11 @@\n         break;\n \n     case OFPPDPT_EXPERIMENTER:\n+        if (prop_length <= 12) {\n+            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);\n+            offset = length;\n+            break;\n+        }\n         /* uint32_t experimenter; */\n         proto_tree_add_item(tree, hf_openflow_v6_port_desc_prop_experimenter_experimenter, tvb, offset, 4, ENC_BIG_ENDIAN);\n         offset+=4;\n@@ -42,6 +48,11 @@\n         break;\n \n     default:\n+        if (prop_length <= 4) {\n+            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);\n+            offset = length;\n+            break;\n+        }\n         proto_tree_add_expert_format(tree, pinfo, &ei_openflow_v6_port_desc_prop_undecoded,\n                                      tvb, offset, prop_length - 4, \"Unknown port desc. property.\");\n         offset += prop_length - 4;",
        "diff_line_info": {
            "deleted_lines": [
                "    proto_tree_add_item(prop_tree, hf_openflow_v6_port_desc_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);"
            ],
            "added_lines": [
                "    proto_item *prop_item;",
                "    prop_item = proto_tree_add_item(prop_tree, hf_openflow_v6_port_desc_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);",
                "        if (prop_length <= 12) {",
                "            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);",
                "            offset = length;",
                "            break;",
                "        }",
                "        if (prop_length <= 4) {",
                "            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);",
                "            offset = length;",
                "            break;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7327",
        "func_name": "wireshark/dissect_openflow_portmod_prop_v6",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-openflow_v6.c had an infinite loop that was addressed by validating property lengths.",
        "git_url": "https://github.com/wireshark/wireshark/commit/563989f888e51258edb9a27db56124bdc33c9afe",
        "commit_title": "OpenFlow 1.5: add extra property length checks",
        "commit_text": " Bug: 14420 (cherry picked from commit 944e661514feca102e49e2d776f0a484e24fc597) Conflicts: \tepan/dissectors/packet-openflow_v6.c",
        "func_before": "static int\ndissect_openflow_portmod_prop_v6(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, guint16 length _U_)\n{\n    proto_tree *prop_tree;\n    guint16 prop_type;\n    guint16 prop_length;\n\n    prop_type = tvb_get_ntohs(tvb, offset);\n    prop_length = tvb_get_ntohs(tvb, offset + 2);\n\n    prop_tree = proto_tree_add_subtree(tree, tvb, offset, prop_length, ett_openflow_v6_portmod_prop, NULL, \"Portmod property\");\n\n    /* uint16_t type; */\n    proto_tree_add_item(prop_tree, hf_openflow_v6_portmod_prop_type, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset+=2;\n\n    /* uint16_t len; */\n    proto_tree_add_item(prop_tree, hf_openflow_v6_portmod_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset+=2;\n\n    switch (prop_type) {\n    case OFPPMPT_ETHERNET:\n        offset = dissect_openflow_portmod_prop_ethernet_v6(tvb, pinfo, prop_tree, offset, length);\n        break;\n\n    case OFPPMPT_OPTICAL:\n        offset = dissect_openflow_portmod_prop_optical_v6(tvb, pinfo, prop_tree, offset, length);\n        break;\n\n    case OFPPMPT_EXPERIMENTER:\n        /* uint32_t experimenter; */\n        proto_tree_add_item(tree, hf_openflow_v6_portmod_prop_experimenter_experimenter, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n\n        /* uint32_t exp_type; */\n        proto_tree_add_item(tree, hf_openflow_v6_portmod_prop_experimenter_exp_type, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n\n        proto_tree_add_expert_format(tree, pinfo, &ei_openflow_v6_portmod_prop_undecoded,\n                                     tvb, offset, prop_length - 12, \"Experimenter port desc. property.\");\n        offset += prop_length - 12;\n        break;\n\n    default:\n        proto_tree_add_expert_format(tree, pinfo, &ei_openflow_v6_portmod_prop_undecoded,\n                                     tvb, offset, prop_length - 4, \"Unknown port desc. property.\");\n        offset += prop_length - 4;\n        break;\n    }\n\n    return offset;\n}",
        "func": "static int\ndissect_openflow_portmod_prop_v6(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, guint16 length _U_)\n{\n    proto_tree *prop_tree;\n    proto_item *prop_item;\n    guint16 prop_type;\n    guint16 prop_length;\n\n    prop_type = tvb_get_ntohs(tvb, offset);\n    prop_length = tvb_get_ntohs(tvb, offset + 2);\n\n    prop_tree = proto_tree_add_subtree(tree, tvb, offset, prop_length, ett_openflow_v6_portmod_prop, NULL, \"Portmod property\");\n\n    /* uint16_t type; */\n    proto_tree_add_item(prop_tree, hf_openflow_v6_portmod_prop_type, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset+=2;\n\n    /* uint16_t len; */\n    prop_item = proto_tree_add_item(prop_tree, hf_openflow_v6_portmod_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset+=2;\n\n    switch (prop_type) {\n    case OFPPMPT_ETHERNET:\n        offset = dissect_openflow_portmod_prop_ethernet_v6(tvb, pinfo, prop_tree, offset, length);\n        break;\n\n    case OFPPMPT_OPTICAL:\n        offset = dissect_openflow_portmod_prop_optical_v6(tvb, pinfo, prop_tree, offset, length);\n        break;\n\n    case OFPPMPT_EXPERIMENTER:\n        if (prop_length <= 12) {\n            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);\n            offset = length;\n            break;\n        }\n        /* uint32_t experimenter; */\n        proto_tree_add_item(tree, hf_openflow_v6_portmod_prop_experimenter_experimenter, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n\n        /* uint32_t exp_type; */\n        proto_tree_add_item(tree, hf_openflow_v6_portmod_prop_experimenter_exp_type, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n\n        proto_tree_add_expert_format(tree, pinfo, &ei_openflow_v6_portmod_prop_undecoded,\n                                     tvb, offset, prop_length - 12, \"Experimenter port desc. property.\");\n        offset += prop_length - 12;\n        break;\n\n    default:\n        if (prop_length <= 4) {\n            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);\n            offset = length;\n            break;\n        }\n        proto_tree_add_expert_format(tree, pinfo, &ei_openflow_v6_portmod_prop_undecoded,\n                                     tvb, offset, prop_length - 4, \"Unknown port desc. property.\");\n        offset += prop_length - 4;\n        break;\n    }\n\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,7 @@\n dissect_openflow_portmod_prop_v6(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, guint16 length _U_)\n {\n     proto_tree *prop_tree;\n+    proto_item *prop_item;\n     guint16 prop_type;\n     guint16 prop_length;\n \n@@ -15,7 +16,7 @@\n     offset+=2;\n \n     /* uint16_t len; */\n-    proto_tree_add_item(prop_tree, hf_openflow_v6_portmod_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n+    prop_item = proto_tree_add_item(prop_tree, hf_openflow_v6_portmod_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n     offset+=2;\n \n     switch (prop_type) {\n@@ -28,6 +29,11 @@\n         break;\n \n     case OFPPMPT_EXPERIMENTER:\n+        if (prop_length <= 12) {\n+            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);\n+            offset = length;\n+            break;\n+        }\n         /* uint32_t experimenter; */\n         proto_tree_add_item(tree, hf_openflow_v6_portmod_prop_experimenter_experimenter, tvb, offset, 4, ENC_BIG_ENDIAN);\n         offset+=4;\n@@ -42,6 +48,11 @@\n         break;\n \n     default:\n+        if (prop_length <= 4) {\n+            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);\n+            offset = length;\n+            break;\n+        }\n         proto_tree_add_expert_format(tree, pinfo, &ei_openflow_v6_portmod_prop_undecoded,\n                                      tvb, offset, prop_length - 4, \"Unknown port desc. property.\");\n         offset += prop_length - 4;",
        "diff_line_info": {
            "deleted_lines": [
                "    proto_tree_add_item(prop_tree, hf_openflow_v6_portmod_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);"
            ],
            "added_lines": [
                "    proto_item *prop_item;",
                "    prop_item = proto_tree_add_item(prop_tree, hf_openflow_v6_portmod_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);",
                "        if (prop_length <= 12) {",
                "            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);",
                "            offset = length;",
                "            break;",
                "        }",
                "        if (prop_length <= 4) {",
                "            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);",
                "            offset = length;",
                "            break;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7327",
        "func_name": "wireshark/dissect_openflow_bundle_prop_v6",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-openflow_v6.c had an infinite loop that was addressed by validating property lengths.",
        "git_url": "https://github.com/wireshark/wireshark/commit/563989f888e51258edb9a27db56124bdc33c9afe",
        "commit_title": "OpenFlow 1.5: add extra property length checks",
        "commit_text": " Bug: 14420 (cherry picked from commit 944e661514feca102e49e2d776f0a484e24fc597) Conflicts: \tepan/dissectors/packet-openflow_v6.c",
        "func_before": "static int\ndissect_openflow_bundle_prop_v6(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, guint16 length _U_)\n{\n    proto_tree *prop_tree;\n    guint16 prop_type;\n    guint16 prop_len;\n\n    prop_type = tvb_get_ntohs(tvb, offset);\n    prop_len = tvb_get_ntohs(tvb, offset + 2);\n\n    prop_tree = proto_tree_add_subtree(tree, tvb, offset, prop_len, ett_openflow_v6_bundle_prop, NULL, \"Bundle prop\");\n\n    /* uint16_t type; */\n    proto_tree_add_item(prop_tree, hf_openflow_v6_bundle_prop_type, tvb, offset, 2, ENC_BIG_ENDIAN);\n\n    /* uint16_t length; */\n    proto_tree_add_item(prop_tree, hf_openflow_v6_bundle_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n\n    switch (prop_type) {\n    case OFPBPT_EXPERIMENTER:\n        /* uint32_t experimenter; */\n        proto_tree_add_item(tree, hf_openflow_v6_bundle_prop_experimenter_experimenter, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n\n        /* uint32_t exp_type; */\n        proto_tree_add_item(tree, hf_openflow_v6_bundle_prop_experimenter_exp_type, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n\n        /* uint32_t experimenter_data[0]; */\n        proto_tree_add_expert_format(tree, pinfo, &ei_openflow_v6_bundle_prop_undecoded,\n                                     tvb, offset, prop_len - 12, \"Experimenter bundle prop body.\");\n        offset += prop_len - 12;\n        break;\n\n    default:\n        proto_tree_add_expert_format(tree, pinfo, &ei_openflow_v6_bundle_prop_undecoded,\n                                     tvb, offset, prop_len - 4, \"Unknown bundle prop body.\");\n        offset += prop_len - 4;\n        break;\n    }\n\n    return offset;\n}",
        "func": "static int\ndissect_openflow_bundle_prop_v6(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, guint16 length)\n{\n    proto_tree *prop_tree;\n    proto_item *prop_item;\n    guint16 prop_type;\n    guint16 prop_len;\n\n    prop_type = tvb_get_ntohs(tvb, offset);\n    prop_len = tvb_get_ntohs(tvb, offset + 2);\n\n    prop_tree = proto_tree_add_subtree(tree, tvb, offset, prop_len, ett_openflow_v6_bundle_prop, NULL, \"Bundle prop\");\n\n    /* uint16_t type; */\n    proto_tree_add_item(prop_tree, hf_openflow_v6_bundle_prop_type, tvb, offset, 2, ENC_BIG_ENDIAN);\n\n    /* uint16_t length; */\n    prop_item = proto_tree_add_item(prop_tree, hf_openflow_v6_bundle_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n\n    switch (prop_type) {\n    case OFPBPT_EXPERIMENTER:\n        if (prop_len <= 12) {\n            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);\n            offset = length;\n            break;\n        }\n        /* uint32_t experimenter; */\n        proto_tree_add_item(tree, hf_openflow_v6_bundle_prop_experimenter_experimenter, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n\n        /* uint32_t exp_type; */\n        proto_tree_add_item(tree, hf_openflow_v6_bundle_prop_experimenter_exp_type, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n\n        /* uint32_t experimenter_data[0]; */\n        proto_tree_add_expert_format(tree, pinfo, &ei_openflow_v6_bundle_prop_undecoded,\n                                     tvb, offset, prop_len - 12, \"Experimenter bundle prop body.\");\n        offset += prop_len - 12;\n        break;\n\n    default:\n        if (prop_len <= 4) {\n            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);\n            offset = length;\n            break;\n        }\n        proto_tree_add_expert_format(tree, pinfo, &ei_openflow_v6_bundle_prop_undecoded,\n                                     tvb, offset, prop_len - 4, \"Unknown bundle prop body.\");\n        offset += prop_len - 4;\n        break;\n    }\n\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,8 @@\n static int\n-dissect_openflow_bundle_prop_v6(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, guint16 length _U_)\n+dissect_openflow_bundle_prop_v6(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, guint16 length)\n {\n     proto_tree *prop_tree;\n+    proto_item *prop_item;\n     guint16 prop_type;\n     guint16 prop_len;\n \n@@ -14,10 +15,15 @@\n     proto_tree_add_item(prop_tree, hf_openflow_v6_bundle_prop_type, tvb, offset, 2, ENC_BIG_ENDIAN);\n \n     /* uint16_t length; */\n-    proto_tree_add_item(prop_tree, hf_openflow_v6_bundle_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n+    prop_item = proto_tree_add_item(prop_tree, hf_openflow_v6_bundle_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n \n     switch (prop_type) {\n     case OFPBPT_EXPERIMENTER:\n+        if (prop_len <= 12) {\n+            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);\n+            offset = length;\n+            break;\n+        }\n         /* uint32_t experimenter; */\n         proto_tree_add_item(tree, hf_openflow_v6_bundle_prop_experimenter_experimenter, tvb, offset, 4, ENC_BIG_ENDIAN);\n         offset+=4;\n@@ -33,6 +39,11 @@\n         break;\n \n     default:\n+        if (prop_len <= 4) {\n+            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);\n+            offset = length;\n+            break;\n+        }\n         proto_tree_add_expert_format(tree, pinfo, &ei_openflow_v6_bundle_prop_undecoded,\n                                      tvb, offset, prop_len - 4, \"Unknown bundle prop body.\");\n         offset += prop_len - 4;",
        "diff_line_info": {
            "deleted_lines": [
                "dissect_openflow_bundle_prop_v6(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, guint16 length _U_)",
                "    proto_tree_add_item(prop_tree, hf_openflow_v6_bundle_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);"
            ],
            "added_lines": [
                "dissect_openflow_bundle_prop_v6(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, guint16 length)",
                "    proto_item *prop_item;",
                "    prop_item = proto_tree_add_item(prop_tree, hf_openflow_v6_bundle_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);",
                "        if (prop_len <= 12) {",
                "            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);",
                "            offset = length;",
                "            break;",
                "        }",
                "        if (prop_len <= 4) {",
                "            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);",
                "            offset = length;",
                "            break;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7327",
        "func_name": "wireshark/dissect_openflow_tablemod_prop_v6",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-openflow_v6.c had an infinite loop that was addressed by validating property lengths.",
        "git_url": "https://github.com/wireshark/wireshark/commit/563989f888e51258edb9a27db56124bdc33c9afe",
        "commit_title": "OpenFlow 1.5: add extra property length checks",
        "commit_text": " Bug: 14420 (cherry picked from commit 944e661514feca102e49e2d776f0a484e24fc597) Conflicts: \tepan/dissectors/packet-openflow_v6.c",
        "func_before": "static int\ndissect_openflow_tablemod_prop_v6(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, guint16 length _U_)\n{\n    proto_item *ti;\n    proto_tree *prop_tree, *flags_tree;\n\n    guint16 prop_type;\n    guint16 prop_length;\n\n    prop_type = tvb_get_ntohs(tvb, offset);\n    prop_length = tvb_get_ntohs(tvb, offset + 2);\n\n    prop_tree = proto_tree_add_subtree(tree, tvb, offset, prop_length, ett_openflow_v6_tablemod_prop, NULL, \"Tablemod property\");\n\n    /* uint16_t type; */\n    proto_tree_add_item(prop_tree, hf_openflow_v6_tablemod_prop_type, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset+=2;\n\n    /* uint16_t len; */\n    proto_tree_add_item(prop_tree, hf_openflow_v6_tablemod_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset+=2;\n\n    switch (prop_type) {\n    case OFPTMPT_EVICTION:\n        /* uint32_t flags; */\n        ti = proto_tree_add_item(prop_tree, hf_openflow_v6_tablemod_prop_eviction_flags, tvb, offset, 4, ENC_BIG_ENDIAN);\n        flags_tree = proto_item_add_subtree(ti, ett_openflow_v6_tablemod_prop_eviction_flags);\n\n        proto_tree_add_item(flags_tree, hf_openflow_v6_tablemod_prop_eviction_flags_other, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(flags_tree, hf_openflow_v6_tablemod_prop_eviction_flags_importance, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(flags_tree, hf_openflow_v6_tablemod_prop_eviction_flags_lifetime, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n        break;\n\n    case OFPTMPT_VACANCY:\n        /* uint8_t vacancy_down; */\n        proto_tree_add_item(tree, hf_openflow_v6_tablemod_prop_vacancy_vacancy_down, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset+=1;\n\n        /* uint8_t vacancy_up; */\n        proto_tree_add_item(tree, hf_openflow_v6_tablemod_prop_vacancy_vacancy_up, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset+=1;\n\n        /* uint8_t vacancy; */\n        proto_tree_add_item(tree, hf_openflow_v6_tablemod_prop_vacancy_vacancy, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset+=1;\n\n        /* uint8_t pad[1]; */\n        proto_tree_add_item(tree, hf_openflow_v6_tablemod_prop_vacancy_pad, tvb, offset, 1, ENC_NA);\n        offset+=1;\n        break;\n\n    case OFPTMPT_EXPERIMENTER:\n        /* uint32_t experimenter; */\n        proto_tree_add_item(tree, hf_openflow_v6_tablemod_prop_experimenter_experimenter, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n\n        /* uint32_t exp_type; */\n        proto_tree_add_item(tree, hf_openflow_v6_tablemod_prop_experimenter_exp_type, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n\n        proto_tree_add_expert_format(tree, pinfo, &ei_openflow_v6_tablemod_prop_undecoded,\n                                     tvb, offset, prop_length - 12, \"Experimenter table mod. property.\");\n        offset += prop_length - 12;\n        break;\n\n    default:\n        proto_tree_add_expert_format(tree, pinfo, &ei_openflow_v6_tablemod_prop_undecoded,\n                                     tvb, offset, prop_length - 4, \"Unknown table mod. property.\");\n        offset += prop_length - 4;\n        break;\n    }\n\n    return offset;\n}",
        "func": "static int\ndissect_openflow_tablemod_prop_v6(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, guint16 length _U_)\n{\n    proto_item *ti, *prop_item;\n    proto_tree *prop_tree, *flags_tree;\n\n    guint16 prop_type;\n    guint16 prop_length;\n\n    prop_type = tvb_get_ntohs(tvb, offset);\n    prop_length = tvb_get_ntohs(tvb, offset + 2);\n\n    prop_tree = proto_tree_add_subtree(tree, tvb, offset, prop_length, ett_openflow_v6_tablemod_prop, NULL, \"Tablemod property\");\n\n    /* uint16_t type; */\n    proto_tree_add_item(prop_tree, hf_openflow_v6_tablemod_prop_type, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset+=2;\n\n    /* uint16_t len; */\n    prop_item = proto_tree_add_item(prop_tree, hf_openflow_v6_tablemod_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset+=2;\n\n    switch (prop_type) {\n    case OFPTMPT_EVICTION:\n        /* uint32_t flags; */\n        ti = proto_tree_add_item(prop_tree, hf_openflow_v6_tablemod_prop_eviction_flags, tvb, offset, 4, ENC_BIG_ENDIAN);\n        flags_tree = proto_item_add_subtree(ti, ett_openflow_v6_tablemod_prop_eviction_flags);\n\n        proto_tree_add_item(flags_tree, hf_openflow_v6_tablemod_prop_eviction_flags_other, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(flags_tree, hf_openflow_v6_tablemod_prop_eviction_flags_importance, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(flags_tree, hf_openflow_v6_tablemod_prop_eviction_flags_lifetime, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n        break;\n\n    case OFPTMPT_VACANCY:\n        /* uint8_t vacancy_down; */\n        proto_tree_add_item(tree, hf_openflow_v6_tablemod_prop_vacancy_vacancy_down, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset+=1;\n\n        /* uint8_t vacancy_up; */\n        proto_tree_add_item(tree, hf_openflow_v6_tablemod_prop_vacancy_vacancy_up, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset+=1;\n\n        /* uint8_t vacancy; */\n        proto_tree_add_item(tree, hf_openflow_v6_tablemod_prop_vacancy_vacancy, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset+=1;\n\n        /* uint8_t pad[1]; */\n        proto_tree_add_item(tree, hf_openflow_v6_tablemod_prop_vacancy_pad, tvb, offset, 1, ENC_NA);\n        offset+=1;\n        break;\n\n    case OFPTMPT_EXPERIMENTER:\n        if (prop_length <= 12) {\n            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);\n            offset = length;\n            break;\n        }\n        /* uint32_t experimenter; */\n        proto_tree_add_item(tree, hf_openflow_v6_tablemod_prop_experimenter_experimenter, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n\n        /* uint32_t exp_type; */\n        proto_tree_add_item(tree, hf_openflow_v6_tablemod_prop_experimenter_exp_type, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n\n        proto_tree_add_expert_format(tree, pinfo, &ei_openflow_v6_tablemod_prop_undecoded,\n                                     tvb, offset, prop_length - 12, \"Experimenter table mod. property.\");\n        offset += prop_length - 12;\n        break;\n\n    default:\n        if (prop_length <= 4) {\n            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);\n            offset = length;\n            break;\n        }\n        proto_tree_add_expert_format(tree, pinfo, &ei_openflow_v6_tablemod_prop_undecoded,\n                                     tvb, offset, prop_length - 4, \"Unknown table mod. property.\");\n        offset += prop_length - 4;\n        break;\n    }\n\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n static int\n dissect_openflow_tablemod_prop_v6(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, guint16 length _U_)\n {\n-    proto_item *ti;\n+    proto_item *ti, *prop_item;\n     proto_tree *prop_tree, *flags_tree;\n \n     guint16 prop_type;\n@@ -17,7 +17,7 @@\n     offset+=2;\n \n     /* uint16_t len; */\n-    proto_tree_add_item(prop_tree, hf_openflow_v6_tablemod_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n+    prop_item = proto_tree_add_item(prop_tree, hf_openflow_v6_tablemod_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n     offset+=2;\n \n     switch (prop_type) {\n@@ -51,6 +51,11 @@\n         break;\n \n     case OFPTMPT_EXPERIMENTER:\n+        if (prop_length <= 12) {\n+            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);\n+            offset = length;\n+            break;\n+        }\n         /* uint32_t experimenter; */\n         proto_tree_add_item(tree, hf_openflow_v6_tablemod_prop_experimenter_experimenter, tvb, offset, 4, ENC_BIG_ENDIAN);\n         offset+=4;\n@@ -65,6 +70,11 @@\n         break;\n \n     default:\n+        if (prop_length <= 4) {\n+            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);\n+            offset = length;\n+            break;\n+        }\n         proto_tree_add_expert_format(tree, pinfo, &ei_openflow_v6_tablemod_prop_undecoded,\n                                      tvb, offset, prop_length - 4, \"Unknown table mod. property.\");\n         offset += prop_length - 4;",
        "diff_line_info": {
            "deleted_lines": [
                "    proto_item *ti;",
                "    proto_tree_add_item(prop_tree, hf_openflow_v6_tablemod_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);"
            ],
            "added_lines": [
                "    proto_item *ti, *prop_item;",
                "    prop_item = proto_tree_add_item(prop_tree, hf_openflow_v6_tablemod_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);",
                "        if (prop_length <= 12) {",
                "            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);",
                "            offset = length;",
                "            break;",
                "        }",
                "        if (prop_length <= 4) {",
                "            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);",
                "            offset = length;",
                "            break;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7327",
        "func_name": "wireshark/dissect_openflow_queue_stats_prop_v6",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-openflow_v6.c had an infinite loop that was addressed by validating property lengths.",
        "git_url": "https://github.com/wireshark/wireshark/commit/563989f888e51258edb9a27db56124bdc33c9afe",
        "commit_title": "OpenFlow 1.5: add extra property length checks",
        "commit_text": " Bug: 14420 (cherry picked from commit 944e661514feca102e49e2d776f0a484e24fc597) Conflicts: \tepan/dissectors/packet-openflow_v6.c",
        "func_before": "static int\ndissect_openflow_queue_stats_prop_v6(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, guint16 length _U_)\n{\n    proto_tree *prop_tree;\n    guint16 prop_type;\n    guint16 prop_length;\n\n    prop_type = tvb_get_ntohs(tvb, offset);\n    prop_length = tvb_get_ntohs(tvb, offset + 2);\n\n    prop_tree = proto_tree_add_subtree(tree, tvb, offset, prop_length, ett_openflow_v6_queue_stats_prop, NULL, \"Queue stats property\");\n\n    /* uint16_t type; */\n    proto_tree_add_item(prop_tree, hf_openflow_v6_queue_stats_prop_type, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset+=2;\n\n    /* uint16_t len; */\n    proto_tree_add_item(prop_tree, hf_openflow_v6_queue_stats_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset+=2;\n\n    switch (prop_type) {\n    case OFPMP_EXPERIMENTER:\n        /* uint32_t experimenter; */\n        proto_tree_add_item(tree, hf_openflow_v6_queue_stats_prop_experimenter_experimenter, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n\n        /* uint32_t exp_type; */\n        proto_tree_add_item(tree, hf_openflow_v6_queue_stats_prop_experimenter_exp_type, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n\n        /* uint32_t experimenter_data[0]; */\n        proto_tree_add_expert_format(tree, pinfo, &ei_openflow_v6_queue_stats_prop_undecoded,\n                                     tvb, offset, length - 12, \"Experimenter queue stats prop body.\");\n        offset += prop_length - 12;\n        break;\n\n    default:\n        proto_tree_add_expert_format(tree, pinfo, &ei_openflow_v6_queue_stats_prop_undecoded,\n                                     tvb, offset, length - 4, \"Unknown queue stats prop body.\");\n        offset += prop_length - 4;\n        break;\n    }\n\n    return offset;\n}",
        "func": "static int\ndissect_openflow_queue_stats_prop_v6(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, guint16 length _U_)\n{\n    proto_tree *prop_tree;\n    proto_item *prop_item;\n    guint16 prop_type;\n    guint16 prop_length;\n\n    prop_type = tvb_get_ntohs(tvb, offset);\n    prop_length = tvb_get_ntohs(tvb, offset + 2);\n\n    prop_tree = proto_tree_add_subtree(tree, tvb, offset, prop_length, ett_openflow_v6_queue_stats_prop, NULL, \"Queue stats property\");\n\n    /* uint16_t type; */\n    proto_tree_add_item(prop_tree, hf_openflow_v6_queue_stats_prop_type, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset+=2;\n\n    /* uint16_t len; */\n    prop_item = proto_tree_add_item(prop_tree, hf_openflow_v6_queue_stats_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset+=2;\n\n    switch (prop_type) {\n    case OFPMP_EXPERIMENTER:\n        if (prop_length <= 12) {\n            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);\n            offset = length;\n            break;\n        }\n        /* uint32_t experimenter; */\n        proto_tree_add_item(tree, hf_openflow_v6_queue_stats_prop_experimenter_experimenter, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n\n        /* uint32_t exp_type; */\n        proto_tree_add_item(tree, hf_openflow_v6_queue_stats_prop_experimenter_exp_type, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n\n        /* uint32_t experimenter_data[0]; */\n        proto_tree_add_expert_format(tree, pinfo, &ei_openflow_v6_queue_stats_prop_undecoded,\n                                     tvb, offset, length - 12, \"Experimenter queue stats prop body.\");\n        offset += prop_length - 12;\n        break;\n\n    default:\n        if (prop_length <= 4) {\n            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);\n            offset = length;\n            break;\n        }\n        proto_tree_add_expert_format(tree, pinfo, &ei_openflow_v6_queue_stats_prop_undecoded,\n                                     tvb, offset, length - 4, \"Unknown queue stats prop body.\");\n        offset += prop_length - 4;\n        break;\n    }\n\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,7 @@\n dissect_openflow_queue_stats_prop_v6(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, guint16 length _U_)\n {\n     proto_tree *prop_tree;\n+    proto_item *prop_item;\n     guint16 prop_type;\n     guint16 prop_length;\n \n@@ -15,11 +16,16 @@\n     offset+=2;\n \n     /* uint16_t len; */\n-    proto_tree_add_item(prop_tree, hf_openflow_v6_queue_stats_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n+    prop_item = proto_tree_add_item(prop_tree, hf_openflow_v6_queue_stats_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n     offset+=2;\n \n     switch (prop_type) {\n     case OFPMP_EXPERIMENTER:\n+        if (prop_length <= 12) {\n+            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);\n+            offset = length;\n+            break;\n+        }\n         /* uint32_t experimenter; */\n         proto_tree_add_item(tree, hf_openflow_v6_queue_stats_prop_experimenter_experimenter, tvb, offset, 4, ENC_BIG_ENDIAN);\n         offset+=4;\n@@ -35,6 +41,11 @@\n         break;\n \n     default:\n+        if (prop_length <= 4) {\n+            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);\n+            offset = length;\n+            break;\n+        }\n         proto_tree_add_expert_format(tree, pinfo, &ei_openflow_v6_queue_stats_prop_undecoded,\n                                      tvb, offset, length - 4, \"Unknown queue stats prop body.\");\n         offset += prop_length - 4;",
        "diff_line_info": {
            "deleted_lines": [
                "    proto_tree_add_item(prop_tree, hf_openflow_v6_queue_stats_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);"
            ],
            "added_lines": [
                "    proto_item *prop_item;",
                "    prop_item = proto_tree_add_item(prop_tree, hf_openflow_v6_queue_stats_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);",
                "        if (prop_length <= 12) {",
                "            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);",
                "            offset = length;",
                "            break;",
                "        }",
                "        if (prop_length <= 4) {",
                "            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);",
                "            offset = length;",
                "            break;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7327",
        "func_name": "wireshark/dissect_openflow_async_config_prop_v6",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-openflow_v6.c had an infinite loop that was addressed by validating property lengths.",
        "git_url": "https://github.com/wireshark/wireshark/commit/563989f888e51258edb9a27db56124bdc33c9afe",
        "commit_title": "OpenFlow 1.5: add extra property length checks",
        "commit_text": " Bug: 14420 (cherry picked from commit 944e661514feca102e49e2d776f0a484e24fc597) Conflicts: \tepan/dissectors/packet-openflow_v6.c",
        "func_before": "static int\ndissect_openflow_async_config_prop_v6(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, guint16 length _U_)\n{\n    proto_item *ti;\n    proto_tree *prop_tree, *pi_tree, *ps_tree, *fr_tree, *rs_tree, *ts_tree, *rf_tree;\n    guint16 prop_type;\n    guint16 prop_len;\n\n    prop_type = tvb_get_ntohs(tvb, offset);\n    prop_len = tvb_get_ntohs(tvb, offset + 2);\n\n    prop_tree = proto_tree_add_subtree(tree, tvb, offset, prop_len, ett_openflow_v6_async_config_prop, NULL, \"Async config prop\");\n\n    /* uint16_t type; */\n    proto_tree_add_item(prop_tree, hf_openflow_v6_async_config_prop_type, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset += 2;\n\n    /* uint16_t length; */\n    proto_tree_add_item(prop_tree, hf_openflow_v6_async_config_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset += 2;\n\n    switch (prop_type) {\n    case OFPACPT_PACKET_IN_SLAVE:\n    case OFPACPT_PACKET_IN_MASTER:\n        /* uint32_t mask; */\n        ti = proto_tree_add_item(prop_tree, hf_openflow_v6_async_config_prop_reason_packet_in_mask, tvb, offset, 4, ENC_BIG_ENDIAN);\n        pi_tree = proto_item_add_subtree(ti, ett_openflow_v6_async_config_prop_reason_packet_in_mask);\n\n        proto_tree_add_item(pi_tree, hf_openflow_v6_async_config_prop_reason_packet_in_mask_table_miss, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(pi_tree, hf_openflow_v6_async_config_prop_reason_packet_in_mask_apply_action, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(pi_tree, hf_openflow_v6_async_config_prop_reason_packet_in_mask_invalid_ttl, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(pi_tree, hf_openflow_v6_async_config_prop_reason_packet_in_mask_action_set, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(pi_tree, hf_openflow_v6_async_config_prop_reason_packet_in_mask_group, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(pi_tree, hf_openflow_v6_async_config_prop_reason_packet_in_mask_packet_out, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n        break;\n\n    case OFPACPT_PORT_STATUS_SLAVE:\n    case OFPACPT_PORT_STATUS_MASTER:\n        /* uint32_t mask; */\n        ti = proto_tree_add_item(prop_tree, hf_openflow_v6_async_config_prop_reason_port_status_mask, tvb, offset, 4, ENC_BIG_ENDIAN);\n        ps_tree = proto_item_add_subtree(ti, ett_openflow_v6_async_config_prop_reason_port_status_mask);\n\n        proto_tree_add_item(ps_tree, hf_openflow_v6_async_config_prop_reason_port_status_mask_add, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(ps_tree, hf_openflow_v6_async_config_prop_reason_port_status_mask_delete, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(ps_tree, hf_openflow_v6_async_config_prop_reason_port_status_mask_modify, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n        break;\n\n    case OFPACPT_FLOW_REMOVED_SLAVE:\n    case OFPACPT_FLOW_REMOVED_MASTER:\n        /* uint32_t mask; */\n        ti = proto_tree_add_item(prop_tree, hf_openflow_v6_async_config_prop_reason_flow_removed_mask, tvb, offset, 4, ENC_BIG_ENDIAN);\n        fr_tree = proto_item_add_subtree(ti, ett_openflow_v6_async_config_prop_reason_flow_removed_mask);\n\n        proto_tree_add_item(fr_tree, hf_openflow_v6_async_config_prop_reason_flow_removed_mask_idle_timeout, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(fr_tree, hf_openflow_v6_async_config_prop_reason_flow_removed_mask_hard_timeout, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(fr_tree, hf_openflow_v6_async_config_prop_reason_flow_removed_mask_delete, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(fr_tree, hf_openflow_v6_async_config_prop_reason_flow_removed_mask_group_delete, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(fr_tree, hf_openflow_v6_async_config_prop_reason_flow_removed_mask_meter_delete, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(fr_tree, hf_openflow_v6_async_config_prop_reason_flow_removed_mask_eviction, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n        break;\n\n    case OFPACPT_ROLE_STATUS_SLAVE:\n    case OFPACPT_ROLE_STATUS_MASTER:\n        /* uint32_t mask; */\n        ti = proto_tree_add_item(prop_tree, hf_openflow_v6_async_config_prop_reason_role_status_mask, tvb, offset, 4, ENC_BIG_ENDIAN);\n        rs_tree = proto_item_add_subtree(ti, ett_openflow_v6_async_config_prop_reason_role_status_mask);\n\n        proto_tree_add_item(rs_tree, hf_openflow_v6_async_config_prop_reason_role_status_mask_master_request, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(rs_tree, hf_openflow_v6_async_config_prop_reason_role_status_mask_config, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(rs_tree, hf_openflow_v6_async_config_prop_reason_role_status_mask_experimenter, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n        break;\n\n    case OFPACPT_TABLE_STATUS_SLAVE:\n    case OFPACPT_TABLE_STATUS_MASTER:\n        /* uint32_t mask; */\n        ti = proto_tree_add_item(prop_tree, hf_openflow_v6_async_config_prop_reason_table_status_mask, tvb, offset, 4, ENC_BIG_ENDIAN);\n        ts_tree = proto_item_add_subtree(ti, ett_openflow_v6_async_config_prop_reason_table_status_mask);\n\n        proto_tree_add_item(ts_tree, hf_openflow_v6_async_config_prop_reason_table_status_mask_vacancy_down, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(ts_tree, hf_openflow_v6_async_config_prop_reason_table_status_mask_vacancy_up, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n        break;\n\n    case OFPACPT_REQUESTFORWARD_SLAVE:\n    case OFPACPT_REQUESTFORWARD_MASTER:\n        /* uint32_t mask; */\n        ti = proto_tree_add_item(prop_tree, hf_openflow_v6_async_config_prop_reason_requestforward_mask, tvb, offset, 4, ENC_BIG_ENDIAN);\n        rf_tree = proto_item_add_subtree(ti, ett_openflow_v6_async_config_prop_reason_requestforward_mask);\n\n        proto_tree_add_item(rf_tree, hf_openflow_v6_async_config_prop_reason_requestforward_mask_group_mod, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(rf_tree, hf_openflow_v6_async_config_prop_reason_requestforward_mask_meter_mod, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n        break;\n\n    case OFPACPT_EXPERIMENTER_SLAVE:\n    case OFPACPT_EXPERIMENTER_MASTER:\n        /* uint32_t experimenter; */\n        proto_tree_add_item(prop_tree, hf_openflow_v6_async_config_prop_experimenter_experimenter, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n\n        /* uint32_t exp_type; */\n        proto_tree_add_item(prop_tree, hf_openflow_v6_async_config_prop_experimenter_exp_type, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n\n        /* uint32_t experimenter_data[0]; */\n        proto_tree_add_expert_format(prop_tree, pinfo, &ei_openflow_v6_async_config_prop_undecoded,\n                                     tvb, offset, prop_len - 12, \"Experimenter async config prop body.\");\n        offset += prop_len - 12;\n        break;\n\n    default:\n        proto_tree_add_expert_format(prop_tree, pinfo, &ei_openflow_v6_async_config_prop_undecoded,\n                                     tvb, offset, prop_len - 4, \"Unknown async config prop body.\");\n        offset += prop_len - 4;\n        break;\n    }\n\n    return offset;\n}",
        "func": "static int\ndissect_openflow_async_config_prop_v6(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, guint16 length _U_)\n{\n    proto_item *ti, *prop_item;\n    proto_tree *prop_tree, *pi_tree, *ps_tree, *fr_tree, *rs_tree, *ts_tree, *rf_tree;\n    guint16 prop_type;\n    guint16 prop_len;\n\n    prop_type = tvb_get_ntohs(tvb, offset);\n    prop_len = tvb_get_ntohs(tvb, offset + 2);\n\n    prop_tree = proto_tree_add_subtree(tree, tvb, offset, prop_len, ett_openflow_v6_async_config_prop, NULL, \"Async config prop\");\n\n    /* uint16_t type; */\n    proto_tree_add_item(prop_tree, hf_openflow_v6_async_config_prop_type, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset += 2;\n\n    /* uint16_t length; */\n    prop_item = proto_tree_add_item(prop_tree, hf_openflow_v6_async_config_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n    offset += 2;\n\n    switch (prop_type) {\n    case OFPACPT_PACKET_IN_SLAVE:\n    case OFPACPT_PACKET_IN_MASTER:\n        /* uint32_t mask; */\n        ti = proto_tree_add_item(prop_tree, hf_openflow_v6_async_config_prop_reason_packet_in_mask, tvb, offset, 4, ENC_BIG_ENDIAN);\n        pi_tree = proto_item_add_subtree(ti, ett_openflow_v6_async_config_prop_reason_packet_in_mask);\n\n        proto_tree_add_item(pi_tree, hf_openflow_v6_async_config_prop_reason_packet_in_mask_table_miss, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(pi_tree, hf_openflow_v6_async_config_prop_reason_packet_in_mask_apply_action, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(pi_tree, hf_openflow_v6_async_config_prop_reason_packet_in_mask_invalid_ttl, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(pi_tree, hf_openflow_v6_async_config_prop_reason_packet_in_mask_action_set, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(pi_tree, hf_openflow_v6_async_config_prop_reason_packet_in_mask_group, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(pi_tree, hf_openflow_v6_async_config_prop_reason_packet_in_mask_packet_out, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n        break;\n\n    case OFPACPT_PORT_STATUS_SLAVE:\n    case OFPACPT_PORT_STATUS_MASTER:\n        /* uint32_t mask; */\n        ti = proto_tree_add_item(prop_tree, hf_openflow_v6_async_config_prop_reason_port_status_mask, tvb, offset, 4, ENC_BIG_ENDIAN);\n        ps_tree = proto_item_add_subtree(ti, ett_openflow_v6_async_config_prop_reason_port_status_mask);\n\n        proto_tree_add_item(ps_tree, hf_openflow_v6_async_config_prop_reason_port_status_mask_add, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(ps_tree, hf_openflow_v6_async_config_prop_reason_port_status_mask_delete, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(ps_tree, hf_openflow_v6_async_config_prop_reason_port_status_mask_modify, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n        break;\n\n    case OFPACPT_FLOW_REMOVED_SLAVE:\n    case OFPACPT_FLOW_REMOVED_MASTER:\n        /* uint32_t mask; */\n        ti = proto_tree_add_item(prop_tree, hf_openflow_v6_async_config_prop_reason_flow_removed_mask, tvb, offset, 4, ENC_BIG_ENDIAN);\n        fr_tree = proto_item_add_subtree(ti, ett_openflow_v6_async_config_prop_reason_flow_removed_mask);\n\n        proto_tree_add_item(fr_tree, hf_openflow_v6_async_config_prop_reason_flow_removed_mask_idle_timeout, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(fr_tree, hf_openflow_v6_async_config_prop_reason_flow_removed_mask_hard_timeout, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(fr_tree, hf_openflow_v6_async_config_prop_reason_flow_removed_mask_delete, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(fr_tree, hf_openflow_v6_async_config_prop_reason_flow_removed_mask_group_delete, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(fr_tree, hf_openflow_v6_async_config_prop_reason_flow_removed_mask_meter_delete, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(fr_tree, hf_openflow_v6_async_config_prop_reason_flow_removed_mask_eviction, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n        break;\n\n    case OFPACPT_ROLE_STATUS_SLAVE:\n    case OFPACPT_ROLE_STATUS_MASTER:\n        /* uint32_t mask; */\n        ti = proto_tree_add_item(prop_tree, hf_openflow_v6_async_config_prop_reason_role_status_mask, tvb, offset, 4, ENC_BIG_ENDIAN);\n        rs_tree = proto_item_add_subtree(ti, ett_openflow_v6_async_config_prop_reason_role_status_mask);\n\n        proto_tree_add_item(rs_tree, hf_openflow_v6_async_config_prop_reason_role_status_mask_master_request, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(rs_tree, hf_openflow_v6_async_config_prop_reason_role_status_mask_config, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(rs_tree, hf_openflow_v6_async_config_prop_reason_role_status_mask_experimenter, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n        break;\n\n    case OFPACPT_TABLE_STATUS_SLAVE:\n    case OFPACPT_TABLE_STATUS_MASTER:\n        /* uint32_t mask; */\n        ti = proto_tree_add_item(prop_tree, hf_openflow_v6_async_config_prop_reason_table_status_mask, tvb, offset, 4, ENC_BIG_ENDIAN);\n        ts_tree = proto_item_add_subtree(ti, ett_openflow_v6_async_config_prop_reason_table_status_mask);\n\n        proto_tree_add_item(ts_tree, hf_openflow_v6_async_config_prop_reason_table_status_mask_vacancy_down, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(ts_tree, hf_openflow_v6_async_config_prop_reason_table_status_mask_vacancy_up, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n        break;\n\n    case OFPACPT_REQUESTFORWARD_SLAVE:\n    case OFPACPT_REQUESTFORWARD_MASTER:\n        /* uint32_t mask; */\n        ti = proto_tree_add_item(prop_tree, hf_openflow_v6_async_config_prop_reason_requestforward_mask, tvb, offset, 4, ENC_BIG_ENDIAN);\n        rf_tree = proto_item_add_subtree(ti, ett_openflow_v6_async_config_prop_reason_requestforward_mask);\n\n        proto_tree_add_item(rf_tree, hf_openflow_v6_async_config_prop_reason_requestforward_mask_group_mod, tvb, offset, 4, ENC_BIG_ENDIAN);\n        proto_tree_add_item(rf_tree, hf_openflow_v6_async_config_prop_reason_requestforward_mask_meter_mod, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n        break;\n\n    case OFPACPT_EXPERIMENTER_SLAVE:\n    case OFPACPT_EXPERIMENTER_MASTER:\n        if (prop_len <= 12) {\n            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);\n            offset = length;\n            break;\n        }\n        /* uint32_t experimenter; */\n        proto_tree_add_item(prop_tree, hf_openflow_v6_async_config_prop_experimenter_experimenter, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n\n        /* uint32_t exp_type; */\n        proto_tree_add_item(prop_tree, hf_openflow_v6_async_config_prop_experimenter_exp_type, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset+=4;\n\n        /* uint32_t experimenter_data[0]; */\n        proto_tree_add_expert_format(prop_tree, pinfo, &ei_openflow_v6_async_config_prop_undecoded,\n                                     tvb, offset, prop_len - 12, \"Experimenter async config prop body.\");\n        offset += prop_len - 12;\n        break;\n\n    default:\n        if (prop_len <= 4) {\n            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);\n            offset = length;\n            break;\n        }\n        proto_tree_add_expert_format(prop_tree, pinfo, &ei_openflow_v6_async_config_prop_undecoded,\n                                     tvb, offset, prop_len - 4, \"Unknown async config prop body.\");\n        offset += prop_len - 4;\n        break;\n    }\n\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n static int\n dissect_openflow_async_config_prop_v6(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, guint16 length _U_)\n {\n-    proto_item *ti;\n+    proto_item *ti, *prop_item;\n     proto_tree *prop_tree, *pi_tree, *ps_tree, *fr_tree, *rs_tree, *ts_tree, *rf_tree;\n     guint16 prop_type;\n     guint16 prop_len;\n@@ -16,7 +16,7 @@\n     offset += 2;\n \n     /* uint16_t length; */\n-    proto_tree_add_item(prop_tree, hf_openflow_v6_async_config_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n+    prop_item = proto_tree_add_item(prop_tree, hf_openflow_v6_async_config_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);\n     offset += 2;\n \n     switch (prop_type) {\n@@ -98,6 +98,11 @@\n \n     case OFPACPT_EXPERIMENTER_SLAVE:\n     case OFPACPT_EXPERIMENTER_MASTER:\n+        if (prop_len <= 12) {\n+            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);\n+            offset = length;\n+            break;\n+        }\n         /* uint32_t experimenter; */\n         proto_tree_add_item(prop_tree, hf_openflow_v6_async_config_prop_experimenter_experimenter, tvb, offset, 4, ENC_BIG_ENDIAN);\n         offset+=4;\n@@ -113,6 +118,11 @@\n         break;\n \n     default:\n+        if (prop_len <= 4) {\n+            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);\n+            offset = length;\n+            break;\n+        }\n         proto_tree_add_expert_format(prop_tree, pinfo, &ei_openflow_v6_async_config_prop_undecoded,\n                                      tvb, offset, prop_len - 4, \"Unknown async config prop body.\");\n         offset += prop_len - 4;",
        "diff_line_info": {
            "deleted_lines": [
                "    proto_item *ti;",
                "    proto_tree_add_item(prop_tree, hf_openflow_v6_async_config_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);"
            ],
            "added_lines": [
                "    proto_item *ti, *prop_item;",
                "    prop_item = proto_tree_add_item(prop_tree, hf_openflow_v6_async_config_prop_length, tvb, offset, 2, ENC_BIG_ENDIAN);",
                "        if (prop_len <= 12) {",
                "            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);",
                "            offset = length;",
                "            break;",
                "        }",
                "        if (prop_len <= 4) {",
                "            expert_add_info(pinfo, prop_item, &ei_openflow_v6_length_too_short);",
                "            offset = length;",
                "            break;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7328",
        "func_name": "wireshark/dissect_darwin_usb_iso_transfer",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-usb.c had an infinite loop that was addressed by rejecting short frame header lengths.",
        "git_url": "https://github.com/wireshark/wireshark/commit/69d09028c956f6e049145485ce9b3e2858789b2b",
        "commit_title": "USB: Sanity check Darwin USB header to prevent infinite loop.",
        "commit_text": " Bug: 14421 (cherry picked from commit 95affa1ef1484741156a34aface45aa5e16c02c9)",
        "func_before": "static gint\ndissect_darwin_usb_iso_transfer(packet_info *pinfo _U_, proto_tree *tree, usb_header_t header_type _U_,\n                    guint8 urb_type _U_, tvbuff_t *tvb, gint32 offset, usb_conv_info_t *usb_conv_info)\n{\n    guint32     frame_length;\n    guint32     frame_header_length;\n    guint32     status;\n    guint32     iso_tree_start;\n    guint32     i;\n    guint32     iso_numdesc;\n    guint32     len;\n    proto_item *tii;\n\n    len  = (gint32)tvb_captured_length(tvb);\n    len -= offset;\n\n    tii = proto_tree_add_uint(tree, hf_usb_bInterfaceClass, tvb, offset, 0, usb_conv_info->interfaceClass);\n    PROTO_ITEM_SET_GENERATED(tii);\n\n    status      = tvb_get_guint32(tvb, 8, ENC_LITTLE_ENDIAN);\n    iso_numdesc = tvb_get_guint32(tvb, 12, ENC_LITTLE_ENDIAN);\n\n    iso_tree_start = offset;\n    for (i = 0; (i < iso_numdesc) && (len > 8 /* header len + frame len */); i++) {\n        proto_item   *iso_desc_ti;\n        proto_tree   *iso_desc_tree;\n\n        /* Fetch ISO descriptor fields stored in little-endian byte order. */\n        frame_header_length = tvb_get_guint32(tvb, offset, ENC_LITTLE_ENDIAN);\n        frame_length        = tvb_get_guint32(tvb, offset + 4, ENC_LITTLE_ENDIAN);\n\n        if (len < frame_header_length) {\n            break;\n        }\n\n        iso_desc_ti = proto_tree_add_protocol_format(tree, proto_usb, tvb, offset,\n                20, \"Frame %u [%s]\", i, val_to_str_ext(status, &usb_darwin_status_vals_ext, \"Error %d\"));\n\n        iso_desc_tree = proto_item_add_subtree(iso_desc_ti, ett_usb_isodesc);\n\n        proto_tree_add_item(iso_desc_tree, hf_usb_darwin_iso_frame_number, tvb, offset + 12, 8, ENC_LITTLE_ENDIAN);\n\n        proto_tree_add_item(iso_desc_tree, hf_usb_iso_len, tvb, offset + 4, 4, ENC_LITTLE_ENDIAN);\n\n        if (usb_conv_info->is_request == FALSE) {\n            proto_tree_add_item(iso_desc_tree, hf_usb_darwin_iso_timestamp, tvb, offset + 20, 8, ENC_LITTLE_ENDIAN);\n            proto_tree_add_item(iso_desc_tree, hf_usb_darwin_iso_status, tvb, offset + 8, 4, ENC_LITTLE_ENDIAN);\n\n            /* Data */\n            if (frame_length > len) {\n                frame_length = len;\n            }\n\n            proto_tree_add_item(iso_desc_tree, hf_usb_iso_data, tvb, offset + frame_header_length, frame_length, ENC_NA);\n            proto_tree_set_appendix(iso_desc_tree, tvb, (gint)iso_tree_start, (gint)(offset - iso_tree_start));\n\n            len    -= frame_length;\n            offset += frame_length;\n        }\n\n        /* Padding to align the next header */\n        offset        += frame_header_length;\n        offset         = ((offset + 3) & ~3);\n        iso_tree_start = offset;\n\n        len -= frame_header_length;\n    }\n\n    return offset;\n}",
        "func": "static gint\ndissect_darwin_usb_iso_transfer(packet_info *pinfo _U_, proto_tree *tree, usb_header_t header_type _U_,\n                    guint8 urb_type _U_, tvbuff_t *tvb, gint32 offset, usb_conv_info_t *usb_conv_info)\n{\n    guint32     frame_length;\n    guint32     frame_header_length;\n    guint32     status;\n    guint32     iso_tree_start;\n    guint32     i;\n    guint32     iso_numdesc;\n    guint32     len;\n    proto_item *tii;\n\n    len  = (gint32)tvb_captured_length(tvb);\n    len -= offset;\n\n    tii = proto_tree_add_uint(tree, hf_usb_bInterfaceClass, tvb, offset, 0, usb_conv_info->interfaceClass);\n    PROTO_ITEM_SET_GENERATED(tii);\n\n    status      = tvb_get_guint32(tvb, 8, ENC_LITTLE_ENDIAN);\n    iso_numdesc = tvb_get_guint32(tvb, 12, ENC_LITTLE_ENDIAN);\n\n    iso_tree_start = offset;\n    for (i = 0; (i < iso_numdesc) && (len > 8 /* header len + frame len */); i++) {\n        proto_item   *iso_desc_ti;\n        proto_tree   *iso_desc_tree;\n\n        /* Fetch ISO descriptor fields stored in little-endian byte order. */\n        frame_header_length = tvb_get_guint32(tvb, offset, ENC_LITTLE_ENDIAN);\n        frame_length        = tvb_get_guint32(tvb, offset + 4, ENC_LITTLE_ENDIAN);\n\n        if ((len < frame_header_length) || (frame_header_length < 20)) {\n            break;\n        }\n\n        iso_desc_ti = proto_tree_add_protocol_format(tree, proto_usb, tvb, offset,\n                20, \"Frame %u [%s]\", i, val_to_str_ext(status, &usb_darwin_status_vals_ext, \"Error %d\"));\n\n        iso_desc_tree = proto_item_add_subtree(iso_desc_ti, ett_usb_isodesc);\n\n        proto_tree_add_item(iso_desc_tree, hf_usb_darwin_iso_frame_number, tvb, offset + 12, 8, ENC_LITTLE_ENDIAN);\n\n        proto_tree_add_item(iso_desc_tree, hf_usb_iso_len, tvb, offset + 4, 4, ENC_LITTLE_ENDIAN);\n\n        if (usb_conv_info->is_request == FALSE) {\n            proto_tree_add_item(iso_desc_tree, hf_usb_darwin_iso_timestamp, tvb, offset + 20, 8, ENC_LITTLE_ENDIAN);\n            proto_tree_add_item(iso_desc_tree, hf_usb_darwin_iso_status, tvb, offset + 8, 4, ENC_LITTLE_ENDIAN);\n\n            /* Data */\n            if (frame_length > len) {\n                frame_length = len;\n            }\n\n            proto_tree_add_item(iso_desc_tree, hf_usb_iso_data, tvb, offset + frame_header_length, frame_length, ENC_NA);\n            proto_tree_set_appendix(iso_desc_tree, tvb, (gint)iso_tree_start, (gint)(offset - iso_tree_start));\n\n            len    -= frame_length;\n            offset += frame_length;\n        }\n\n        /* Padding to align the next header */\n        offset        += frame_header_length;\n        offset         = ((offset + 3) & ~3);\n        iso_tree_start = offset;\n\n        len -= frame_header_length;\n    }\n\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -29,7 +29,7 @@\n         frame_header_length = tvb_get_guint32(tvb, offset, ENC_LITTLE_ENDIAN);\n         frame_length        = tvb_get_guint32(tvb, offset + 4, ENC_LITTLE_ENDIAN);\n \n-        if (len < frame_header_length) {\n+        if ((len < frame_header_length) || (frame_header_length < 20)) {\n             break;\n         }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "        if (len < frame_header_length) {"
            ],
            "added_lines": [
                "        if ((len < frame_header_length) || (frame_header_length < 20)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7329",
        "func_name": "wireshark/s7comm_decode_response_write_data",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-s7comm.c had an infinite loop that was addressed by correcting off-by-one errors.",
        "git_url": "https://github.com/wireshark/wireshark/commit/d8a0cbc4f2979e0b1cadbe79f0b8b4ecb92477be",
        "commit_title": "S7comm: fix range check to prevent infinite loop when upper bound is 255",
        "commit_text": " While we are at it, fix identification of not last element in a few places  Bug: 14423 (cherry picked from commit 5d99febe66e96b55a1defa58a906be254bad3a51) Conflicts: \tepan/dissectors/packet-s7comm.c (cherry picked from commit d24db8ddcdd4cdd5c1ea859da93681b4cc98b399)",
        "func_before": "static guint32\ns7comm_decode_response_write_data(tvbuff_t *tvb,\n                                  proto_tree *tree,\n                                  guint8 item_count,\n                                  guint32 offset)\n{\n    guint8 ret_val = 0;\n    guint8 i = 0;\n    proto_item *item = NULL;\n    proto_tree *item_tree = NULL;\n\n    for (i = 1; i <= item_count; i++) {\n        ret_val = tvb_get_guint8(tvb, offset);\n        /* Insert a new tree for every item */\n        item = proto_tree_add_item(tree, hf_s7comm_data_item, tvb, offset, 1, ENC_NA);\n        item_tree = proto_item_add_subtree(item, ett_s7comm_data_item);\n        proto_item_append_text(item, \" [%d]: (%s)\", i, val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));\n        proto_tree_add_uint(item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n        offset += 1;\n    }\n    return offset;\n}",
        "func": "static guint32\ns7comm_decode_response_write_data(tvbuff_t *tvb,\n                                  proto_tree *tree,\n                                  guint8 item_count,\n                                  guint32 offset)\n{\n    guint8 ret_val = 0;\n    guint8 i = 0;\n    proto_item *item = NULL;\n    proto_tree *item_tree = NULL;\n\n    for (i = 0; i < item_count; i++) {\n        ret_val = tvb_get_guint8(tvb, offset);\n        /* Insert a new tree for every item */\n        item = proto_tree_add_item(tree, hf_s7comm_data_item, tvb, offset, 1, ENC_NA);\n        item_tree = proto_item_add_subtree(item, ett_s7comm_data_item);\n        proto_item_append_text(item, \" [%d]: (%s)\", i+1, val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));\n        proto_tree_add_uint(item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n        offset += 1;\n    }\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,12 +9,12 @@\n     proto_item *item = NULL;\n     proto_tree *item_tree = NULL;\n \n-    for (i = 1; i <= item_count; i++) {\n+    for (i = 0; i < item_count; i++) {\n         ret_val = tvb_get_guint8(tvb, offset);\n         /* Insert a new tree for every item */\n         item = proto_tree_add_item(tree, hf_s7comm_data_item, tvb, offset, 1, ENC_NA);\n         item_tree = proto_item_add_subtree(item, ett_s7comm_data_item);\n-        proto_item_append_text(item, \" [%d]: (%s)\", i, val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));\n+        proto_item_append_text(item, \" [%d]: (%s)\", i+1, val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));\n         proto_tree_add_uint(item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n         offset += 1;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    for (i = 1; i <= item_count; i++) {",
                "        proto_item_append_text(item, \" [%d]: (%s)\", i, val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));"
            ],
            "added_lines": [
                "    for (i = 0; i < item_count; i++) {",
                "        proto_item_append_text(item, \" [%d]: (%s)\", i+1, val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7329",
        "func_name": "wireshark/s7comm_decode_req_resp",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-s7comm.c had an infinite loop that was addressed by correcting off-by-one errors.",
        "git_url": "https://github.com/wireshark/wireshark/commit/d8a0cbc4f2979e0b1cadbe79f0b8b4ecb92477be",
        "commit_title": "S7comm: fix range check to prevent infinite loop when upper bound is 255",
        "commit_text": " While we are at it, fix identification of not last element in a few places  Bug: 14423 (cherry picked from commit 5d99febe66e96b55a1defa58a906be254bad3a51) Conflicts: \tepan/dissectors/packet-s7comm.c (cherry picked from commit d24db8ddcdd4cdd5c1ea859da93681b4cc98b399)",
        "func_before": "static guint32\ns7comm_decode_req_resp(tvbuff_t *tvb,\n                       packet_info *pinfo,\n                       proto_tree *tree,\n                       guint16 plength,\n                       guint16 dlength,\n                       guint32 offset,\n                       guint8 rosctr)\n{\n    proto_item *item = NULL;\n    proto_tree *param_tree = NULL;\n    proto_tree *data_tree = NULL;\n    guint8 function = 0;\n    guint8 item_count = 0;\n    guint8 i;\n    guint32 offset_old;\n    guint32 len;\n\n    if (plength > 0) {\n        /* Add parameter tree */\n        item = proto_tree_add_item(tree, hf_s7comm_param, tvb, offset, plength, ENC_NA);\n        param_tree = proto_item_add_subtree(item, ett_s7comm_param);\n        /* Analyze function */\n        function = tvb_get_guint8(tvb, offset);\n        /* add param.function to info column */\n        col_append_fstr(pinfo->cinfo, COL_INFO, \" Function:[%s]\", val_to_str(function, param_functionnames, \"Unknown function: 0x%02x\"));\n        proto_tree_add_uint(param_tree, hf_s7comm_param_service, tvb, offset, 1, function);\n        /* show param.function code at the tree */\n        proto_item_append_text(param_tree, \": (%s)\", val_to_str(function, param_functionnames, \"Unknown function: 0x%02x\"));\n        offset += 1;\n\n        if (rosctr == S7COMM_ROSCTR_JOB) {\n            switch (function){\n                case S7COMM_SERV_READVAR:\n                case S7COMM_SERV_WRITEVAR:\n                    item_count = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(param_tree, hf_s7comm_param_itemcount, tvb, offset, 1, item_count);\n                    offset += 1;\n                    /* parse item data */\n                    for (i = 0; i < item_count; i++) {\n                        offset_old = offset;\n                        offset = s7comm_decode_param_item(tvb, offset, param_tree, i);\n                        /* if length is not a multiple of 2 and this is not the last item, then add a fill-byte */\n                        len = offset - offset_old;\n                        if ((len % 2) && (i < item_count)) {\n                            offset += 1;\n                        }\n                    }\n                    /* in write-function there is a data part */\n                    if ((function == S7COMM_SERV_WRITEVAR) && (dlength > 0)) {\n                        item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                        data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                        /* Add returned data to data-tree */\n                        offset = s7comm_decode_response_read_data(tvb, data_tree, item_count, offset);\n                    }\n                    break;\n                case S7COMM_SERV_SETUPCOMM:\n                    offset = s7comm_decode_pdu_setup_communication(tvb, param_tree, offset);\n                    break;\n                /* Special functions */\n                case S7COMM_FUNCREQUESTDOWNLOAD:\n                case S7COMM_FUNCDOWNLOADBLOCK:\n                case S7COMM_FUNCDOWNLOADENDED:\n                case S7COMM_FUNCSTARTUPLOAD:\n                case S7COMM_FUNCUPLOAD:\n                case S7COMM_FUNCENDUPLOAD:\n                    offset = s7comm_decode_plc_controls_updownload(tvb, pinfo, tree, param_tree, plength, dlength, offset -1, rosctr);\n                    break;\n                case S7COMM_FUNCPISERVICE:\n                    offset = s7comm_decode_pi_service(tvb, pinfo, param_tree, plength, offset -1);\n                    break;\n                case S7COMM_FUNC_PLC_STOP:\n                    offset = s7comm_decode_plc_controls_param_hex29(tvb, param_tree, offset -1);\n                    break;\n\n                default:\n                    /* Print unknown part as raw bytes */\n                    if (plength > 1) {\n                        proto_tree_add_item(param_tree, hf_s7comm_param_data, tvb, offset, plength - 1, ENC_NA);\n                    }\n                    offset += plength - 1; /* 1 byte function code */\n                    if (dlength > 0) {\n                        /* Add data tree\n                         * First 2 bytes in data seem to be a length indicator of (dlength -4 ), so next 2 bytes\n                         * seem to indicate something else. But I'm not sure, so leave it as it is.....\n                         */\n                        item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                        data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                        proto_tree_add_item(data_tree, hf_s7comm_readresponse_data, tvb, offset, dlength, ENC_NA);\n                        offset += dlength;\n                    }\n                    break;\n            }\n        } else if (rosctr == S7COMM_ROSCTR_ACK_DATA) {\n            switch (function){\n                case S7COMM_SERV_READVAR:\n                case S7COMM_SERV_WRITEVAR:\n                    /* This is a read-response, so the requested data may follow when address in request was ok */\n                    item_count = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(param_tree, hf_s7comm_param_itemcount, tvb, offset, 1, item_count);\n                    offset += 1;\n                    /* Add data tree */\n                    item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                    data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                    /* Add returned data to data-tree */\n                    if ((function == S7COMM_SERV_READVAR) && (dlength > 0)) {\n                        offset = s7comm_decode_response_read_data(tvb, data_tree, item_count, offset);\n                    } else if ((function == S7COMM_SERV_WRITEVAR) && (dlength > 0)) {\n                        offset = s7comm_decode_response_write_data(tvb, data_tree, item_count, offset);\n                    }\n                    break;\n                case S7COMM_SERV_SETUPCOMM:\n                    offset = s7comm_decode_pdu_setup_communication(tvb, param_tree, offset);\n                    break;\n                case S7COMM_FUNCREQUESTDOWNLOAD:\n                case S7COMM_FUNCDOWNLOADBLOCK:\n                case S7COMM_FUNCDOWNLOADENDED:\n                case S7COMM_FUNCSTARTUPLOAD:\n                case S7COMM_FUNCUPLOAD:\n                case S7COMM_FUNCENDUPLOAD:\n                    offset = s7comm_decode_plc_controls_updownload(tvb, pinfo, tree, param_tree, plength, dlength, offset -1, rosctr);\n                    break;\n                case S7COMM_FUNCPISERVICE:\n                    if (plength >= 2) {\n                        proto_tree_add_bitmask(param_tree, tvb, offset, hf_s7comm_data_blockcontrol_functionstatus,\n                            ett_s7comm_data_blockcontrol_status, s7comm_data_blockcontrol_status_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    break;\n                default:\n                    /* Print unknown part as raw bytes */\n                    if (plength > 1) {\n                        proto_tree_add_item(param_tree, hf_s7comm_param_data, tvb, offset, plength - 1, ENC_NA);\n                    }\n                    offset += plength - 1; /* 1 byte function code */\n                    if (dlength > 0) {\n                        /* Add data tree\n                         * First 2 bytes in data seem to be a length indicator of (dlength -4 ), so next 2 bytes\n                         * seem to indicate something else. But I'm not sure, so leave it as it is.....\n                         */\n                        item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                        data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                        proto_tree_add_item(data_tree, hf_s7comm_readresponse_data, tvb, offset, dlength, ENC_NA);\n                        offset += dlength;\n                    }\n                    break;\n            }\n        }\n    }\n    return offset;\n}",
        "func": "static guint32\ns7comm_decode_req_resp(tvbuff_t *tvb,\n                       packet_info *pinfo,\n                       proto_tree *tree,\n                       guint16 plength,\n                       guint16 dlength,\n                       guint32 offset,\n                       guint8 rosctr)\n{\n    proto_item *item = NULL;\n    proto_tree *param_tree = NULL;\n    proto_tree *data_tree = NULL;\n    guint8 function = 0;\n    guint8 item_count = 0;\n    guint8 i;\n    guint32 offset_old;\n    guint32 len;\n\n    if (plength > 0) {\n        /* Add parameter tree */\n        item = proto_tree_add_item(tree, hf_s7comm_param, tvb, offset, plength, ENC_NA);\n        param_tree = proto_item_add_subtree(item, ett_s7comm_param);\n        /* Analyze function */\n        function = tvb_get_guint8(tvb, offset);\n        /* add param.function to info column */\n        col_append_fstr(pinfo->cinfo, COL_INFO, \" Function:[%s]\", val_to_str(function, param_functionnames, \"Unknown function: 0x%02x\"));\n        proto_tree_add_uint(param_tree, hf_s7comm_param_service, tvb, offset, 1, function);\n        /* show param.function code at the tree */\n        proto_item_append_text(param_tree, \": (%s)\", val_to_str(function, param_functionnames, \"Unknown function: 0x%02x\"));\n        offset += 1;\n\n        if (rosctr == S7COMM_ROSCTR_JOB) {\n            switch (function){\n                case S7COMM_SERV_READVAR:\n                case S7COMM_SERV_WRITEVAR:\n                    item_count = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(param_tree, hf_s7comm_param_itemcount, tvb, offset, 1, item_count);\n                    offset += 1;\n                    /* parse item data */\n                    for (i = 0; i < item_count; i++) {\n                        offset_old = offset;\n                        offset = s7comm_decode_param_item(tvb, offset, param_tree, i);\n                        /* if length is not a multiple of 2 and this is not the last item, then add a fill-byte */\n                        len = offset - offset_old;\n                        if ((len % 2) && (i < (item_count-1))) {\n                            offset += 1;\n                        }\n                    }\n                    /* in write-function there is a data part */\n                    if ((function == S7COMM_SERV_WRITEVAR) && (dlength > 0)) {\n                        item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                        data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                        /* Add returned data to data-tree */\n                        offset = s7comm_decode_response_read_data(tvb, data_tree, item_count, offset);\n                    }\n                    break;\n                case S7COMM_SERV_SETUPCOMM:\n                    offset = s7comm_decode_pdu_setup_communication(tvb, param_tree, offset);\n                    break;\n                /* Special functions */\n                case S7COMM_FUNCREQUESTDOWNLOAD:\n                case S7COMM_FUNCDOWNLOADBLOCK:\n                case S7COMM_FUNCDOWNLOADENDED:\n                case S7COMM_FUNCSTARTUPLOAD:\n                case S7COMM_FUNCUPLOAD:\n                case S7COMM_FUNCENDUPLOAD:\n                    offset = s7comm_decode_plc_controls_updownload(tvb, pinfo, tree, param_tree, plength, dlength, offset -1, rosctr);\n                    break;\n                case S7COMM_FUNCPISERVICE:\n                    offset = s7comm_decode_pi_service(tvb, pinfo, param_tree, plength, offset -1);\n                    break;\n                case S7COMM_FUNC_PLC_STOP:\n                    offset = s7comm_decode_plc_controls_param_hex29(tvb, param_tree, offset -1);\n                    break;\n\n                default:\n                    /* Print unknown part as raw bytes */\n                    if (plength > 1) {\n                        proto_tree_add_item(param_tree, hf_s7comm_param_data, tvb, offset, plength - 1, ENC_NA);\n                    }\n                    offset += plength - 1; /* 1 byte function code */\n                    if (dlength > 0) {\n                        /* Add data tree\n                         * First 2 bytes in data seem to be a length indicator of (dlength -4 ), so next 2 bytes\n                         * seem to indicate something else. But I'm not sure, so leave it as it is.....\n                         */\n                        item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                        data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                        proto_tree_add_item(data_tree, hf_s7comm_readresponse_data, tvb, offset, dlength, ENC_NA);\n                        offset += dlength;\n                    }\n                    break;\n            }\n        } else if (rosctr == S7COMM_ROSCTR_ACK_DATA) {\n            switch (function){\n                case S7COMM_SERV_READVAR:\n                case S7COMM_SERV_WRITEVAR:\n                    /* This is a read-response, so the requested data may follow when address in request was ok */\n                    item_count = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(param_tree, hf_s7comm_param_itemcount, tvb, offset, 1, item_count);\n                    offset += 1;\n                    /* Add data tree */\n                    item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                    data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                    /* Add returned data to data-tree */\n                    if ((function == S7COMM_SERV_READVAR) && (dlength > 0)) {\n                        offset = s7comm_decode_response_read_data(tvb, data_tree, item_count, offset);\n                    } else if ((function == S7COMM_SERV_WRITEVAR) && (dlength > 0)) {\n                        offset = s7comm_decode_response_write_data(tvb, data_tree, item_count, offset);\n                    }\n                    break;\n                case S7COMM_SERV_SETUPCOMM:\n                    offset = s7comm_decode_pdu_setup_communication(tvb, param_tree, offset);\n                    break;\n                case S7COMM_FUNCREQUESTDOWNLOAD:\n                case S7COMM_FUNCDOWNLOADBLOCK:\n                case S7COMM_FUNCDOWNLOADENDED:\n                case S7COMM_FUNCSTARTUPLOAD:\n                case S7COMM_FUNCUPLOAD:\n                case S7COMM_FUNCENDUPLOAD:\n                    offset = s7comm_decode_plc_controls_updownload(tvb, pinfo, tree, param_tree, plength, dlength, offset -1, rosctr);\n                    break;\n                case S7COMM_FUNCPISERVICE:\n                    if (plength >= 2) {\n                        proto_tree_add_bitmask(param_tree, tvb, offset, hf_s7comm_data_blockcontrol_functionstatus,\n                            ett_s7comm_data_blockcontrol_status, s7comm_data_blockcontrol_status_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    break;\n                default:\n                    /* Print unknown part as raw bytes */\n                    if (plength > 1) {\n                        proto_tree_add_item(param_tree, hf_s7comm_param_data, tvb, offset, plength - 1, ENC_NA);\n                    }\n                    offset += plength - 1; /* 1 byte function code */\n                    if (dlength > 0) {\n                        /* Add data tree\n                         * First 2 bytes in data seem to be a length indicator of (dlength -4 ), so next 2 bytes\n                         * seem to indicate something else. But I'm not sure, so leave it as it is.....\n                         */\n                        item = proto_tree_add_item(tree, hf_s7comm_data, tvb, offset, dlength, ENC_NA);\n                        data_tree = proto_item_add_subtree(item, ett_s7comm_data);\n                        proto_tree_add_item(data_tree, hf_s7comm_readresponse_data, tvb, offset, dlength, ENC_NA);\n                        offset += dlength;\n                    }\n                    break;\n            }\n        }\n    }\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -42,7 +42,7 @@\n                         offset = s7comm_decode_param_item(tvb, offset, param_tree, i);\n                         /* if length is not a multiple of 2 and this is not the last item, then add a fill-byte */\n                         len = offset - offset_old;\n-                        if ((len % 2) && (i < item_count)) {\n+                        if ((len % 2) && (i < (item_count-1))) {\n                             offset += 1;\n                         }\n                     }",
        "diff_line_info": {
            "deleted_lines": [
                "                        if ((len % 2) && (i < item_count)) {"
            ],
            "added_lines": [
                "                        if ((len % 2) && (i < (item_count-1))) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7329",
        "func_name": "wireshark/s7comm_decode_ud_cyclic_subfunc",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-s7comm.c had an infinite loop that was addressed by correcting off-by-one errors.",
        "git_url": "https://github.com/wireshark/wireshark/commit/d8a0cbc4f2979e0b1cadbe79f0b8b4ecb92477be",
        "commit_title": "S7comm: fix range check to prevent infinite loop when upper bound is 255",
        "commit_text": " While we are at it, fix identification of not last element in a few places  Bug: 14423 (cherry picked from commit 5d99febe66e96b55a1defa58a906be254bad3a51) Conflicts: \tepan/dissectors/packet-s7comm.c (cherry picked from commit d24db8ddcdd4cdd5c1ea859da93681b4cc98b399)",
        "func_before": "static guint32\ns7comm_decode_ud_cyclic_subfunc(tvbuff_t *tvb,\n                                proto_tree *data_tree,\n                                guint8 type,                /* Type of data (request/response) */\n                                guint8 subfunc,             /* Subfunction */\n                                guint16 dlength,            /* length of data part given in header */\n                                guint32 offset)             /* Offset on data part +4 */\n{\n    gboolean know_data = FALSE;\n    guint32 offset_old;\n    guint32 len_item;\n    guint8 item_count;\n    guint8 i;\n\n    switch (subfunc)\n    {\n        case S7COMM_UD_SUBF_CYCLIC_MEM:\n            item_count = tvb_get_guint8(tvb, offset + 1);     /* first byte reserved??? */\n            proto_tree_add_uint(data_tree, hf_s7comm_param_itemcount, tvb, offset, 2, item_count);\n            offset += 2;\n            if (type == S7COMM_UD_TYPE_REQ) {                   /* Request to PLC to send cyclic data */\n                proto_tree_add_item(data_tree, hf_s7comm_cycl_interval_timebase, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                proto_tree_add_item(data_tree, hf_s7comm_cycl_interval_time, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                /* parse item data */\n                for (i = 0; i < item_count; i++) {\n                    offset_old = offset;\n                    offset = s7comm_decode_param_item(tvb, offset, data_tree, i);\n                    /* if length is not a multiple of 2 and this is not the last item, then add a fill-byte */\n                    len_item = offset - offset_old;\n                    if ((len_item % 2) && (i < item_count)) {\n                        offset += 1;\n                    }\n                }\n\n            } else if (type == S7COMM_UD_TYPE_RES || type == S7COMM_UD_TYPE_PUSH) {   /* Response from PLC with the requested data */\n                /* parse item data */\n                offset = s7comm_decode_response_read_data(tvb, data_tree, item_count, offset);\n            }\n            know_data = TRUE;\n            break;\n    }\n\n    if (know_data == FALSE && dlength > 4) {\n        proto_tree_add_item(data_tree, hf_s7comm_userdata_data, tvb, offset, dlength - 4, ENC_NA);\n        offset += dlength;\n    }\n    return offset;\n}",
        "func": "static guint32\ns7comm_decode_ud_cyclic_subfunc(tvbuff_t *tvb,\n                                proto_tree *data_tree,\n                                guint8 type,                /* Type of data (request/response) */\n                                guint8 subfunc,             /* Subfunction */\n                                guint16 dlength,            /* length of data part given in header */\n                                guint32 offset)             /* Offset on data part +4 */\n{\n    gboolean know_data = FALSE;\n    guint32 offset_old;\n    guint32 len_item;\n    guint8 item_count;\n    guint8 i;\n\n    switch (subfunc)\n    {\n        case S7COMM_UD_SUBF_CYCLIC_MEM:\n            item_count = tvb_get_guint8(tvb, offset + 1);     /* first byte reserved??? */\n            proto_tree_add_uint(data_tree, hf_s7comm_param_itemcount, tvb, offset, 2, item_count);\n            offset += 2;\n            if (type == S7COMM_UD_TYPE_REQ) {                   /* Request to PLC to send cyclic data */\n                proto_tree_add_item(data_tree, hf_s7comm_cycl_interval_timebase, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                proto_tree_add_item(data_tree, hf_s7comm_cycl_interval_time, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n                /* parse item data */\n                for (i = 0; i < item_count; i++) {\n                    offset_old = offset;\n                    offset = s7comm_decode_param_item(tvb, offset, data_tree, i);\n                    /* if length is not a multiple of 2 and this is not the last item, then add a fill-byte */\n                    len_item = offset - offset_old;\n                    if ((len_item % 2) && (i < (item_count-1))) {\n                        offset += 1;\n                    }\n                }\n\n            } else if (type == S7COMM_UD_TYPE_RES || type == S7COMM_UD_TYPE_PUSH) {   /* Response from PLC with the requested data */\n                /* parse item data */\n                offset = s7comm_decode_response_read_data(tvb, data_tree, item_count, offset);\n            }\n            know_data = TRUE;\n            break;\n    }\n\n    if (know_data == FALSE && dlength > 4) {\n        proto_tree_add_item(data_tree, hf_s7comm_userdata_data, tvb, offset, dlength - 4, ENC_NA);\n        offset += dlength;\n    }\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -29,7 +29,7 @@\n                     offset = s7comm_decode_param_item(tvb, offset, data_tree, i);\n                     /* if length is not a multiple of 2 and this is not the last item, then add a fill-byte */\n                     len_item = offset - offset_old;\n-                    if ((len_item % 2) && (i < item_count)) {\n+                    if ((len_item % 2) && (i < (item_count-1))) {\n                         offset += 1;\n                     }\n                 }",
        "diff_line_info": {
            "deleted_lines": [
                "                    if ((len_item % 2) && (i < item_count)) {"
            ],
            "added_lines": [
                "                    if ((len_item % 2) && (i < (item_count-1))) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7329",
        "func_name": "wireshark/s7comm_decode_response_read_data",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-s7comm.c had an infinite loop that was addressed by correcting off-by-one errors.",
        "git_url": "https://github.com/wireshark/wireshark/commit/d8a0cbc4f2979e0b1cadbe79f0b8b4ecb92477be",
        "commit_title": "S7comm: fix range check to prevent infinite loop when upper bound is 255",
        "commit_text": " While we are at it, fix identification of not last element in a few places  Bug: 14423 (cherry picked from commit 5d99febe66e96b55a1defa58a906be254bad3a51) Conflicts: \tepan/dissectors/packet-s7comm.c (cherry picked from commit d24db8ddcdd4cdd5c1ea859da93681b4cc98b399)",
        "func_before": "static guint32\ns7comm_decode_response_read_data(tvbuff_t *tvb,\n                                 proto_tree *tree,\n                                 guint8 item_count,\n                                 guint32 offset)\n{\n    guint8 ret_val = 0;\n    guint8 tsize = 0;\n    guint16 len = 0, len2 = 0;\n    guint16 head_len = 4;           /* 1 byte res-code, 1 byte transp-size, 2 bytes len */\n    guint8 i = 0;\n    proto_item *item = NULL;\n    proto_tree *item_tree = NULL;\n\n    for (i = 1; i <= item_count; i++) {\n        ret_val = tvb_get_guint8(tvb, offset);\n        if (ret_val == S7COMM_ITEM_RETVAL_RESERVED ||\n            ret_val == S7COMM_ITEM_RETVAL_DATA_OK ||\n            ret_val == S7COMM_ITEM_RETVAL_DATA_ERR\n            ) {\n            tsize = tvb_get_guint8(tvb, offset + 1);\n            len = tvb_get_ntohs(tvb, offset + 2);\n            /* calculate length in bytes */\n            if (tsize == S7COMM_DATA_TRANSPORT_SIZE_BBIT ||\n                tsize == S7COMM_DATA_TRANSPORT_SIZE_BBYTE ||\n                tsize == S7COMM_DATA_TRANSPORT_SIZE_BINT\n                ) {     /* given length is in number of bits */\n                if (len % 8) { /* len is not a multiple of 8, then round up to next number */\n                    len /= 8;\n                    len = len + 1;\n                } else {\n                    len /= 8;\n                }\n            }\n\n            /* the PLC places extra bytes at the end of all but last result, if length is not a multiple of 2 */\n            if ((len % 2) && (i < item_count)) {\n                len2 = len + 1;\n            } else {\n                len2 = len;\n            }\n        }\n        /* Insert a new tree for every item */\n        item = proto_tree_add_item(tree, hf_s7comm_data_item, tvb, offset, len + head_len, ENC_NA);\n        item_tree = proto_item_add_subtree(item, ett_s7comm_data_item);\n        proto_item_append_text(item, \" [%d]: (%s)\", i, val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));\n\n        proto_tree_add_uint(item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n        proto_tree_add_uint(item_tree, hf_s7comm_data_transport_size, tvb, offset + 1, 1, tsize);\n        proto_tree_add_uint(item_tree, hf_s7comm_data_length, tvb, offset + 2, 2, len);\n        offset += head_len;\n\n        if (ret_val == S7COMM_ITEM_RETVAL_DATA_OK || ret_val == S7COMM_ITEM_RETVAL_RESERVED) {\n            proto_tree_add_item(item_tree, hf_s7comm_readresponse_data, tvb, offset, len, ENC_NA);\n            offset += len;\n            if (len != len2) {\n                proto_tree_add_item(item_tree, hf_s7comm_data_fillbyte, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n            }\n        }\n    }\n    return offset;\n}",
        "func": "static guint32\ns7comm_decode_response_read_data(tvbuff_t *tvb,\n                                 proto_tree *tree,\n                                 guint8 item_count,\n                                 guint32 offset)\n{\n    guint8 ret_val = 0;\n    guint8 tsize = 0;\n    guint16 len = 0, len2 = 0;\n    guint16 head_len = 4;           /* 1 byte res-code, 1 byte transp-size, 2 bytes len */\n    guint8 i = 0;\n    proto_item *item = NULL;\n    proto_tree *item_tree = NULL;\n\n    for (i = 0; i < item_count; i++) {\n        ret_val = tvb_get_guint8(tvb, offset);\n        if (ret_val == S7COMM_ITEM_RETVAL_RESERVED ||\n            ret_val == S7COMM_ITEM_RETVAL_DATA_OK ||\n            ret_val == S7COMM_ITEM_RETVAL_DATA_ERR\n            ) {\n            tsize = tvb_get_guint8(tvb, offset + 1);\n            len = tvb_get_ntohs(tvb, offset + 2);\n            /* calculate length in bytes */\n            if (tsize == S7COMM_DATA_TRANSPORT_SIZE_BBIT ||\n                tsize == S7COMM_DATA_TRANSPORT_SIZE_BBYTE ||\n                tsize == S7COMM_DATA_TRANSPORT_SIZE_BINT\n                ) {     /* given length is in number of bits */\n                if (len % 8) { /* len is not a multiple of 8, then round up to next number */\n                    len /= 8;\n                    len = len + 1;\n                } else {\n                    len /= 8;\n                }\n            }\n\n            /* the PLC places extra bytes at the end of all but last result, if length is not a multiple of 2 */\n            if ((len % 2) && (i < (item_count-1))) {\n                len2 = len + 1;\n            } else {\n                len2 = len;\n            }\n        }\n        /* Insert a new tree for every item */\n        item = proto_tree_add_item(tree, hf_s7comm_data_item, tvb, offset, len + head_len, ENC_NA);\n        item_tree = proto_item_add_subtree(item, ett_s7comm_data_item);\n        proto_item_append_text(item, \" [%d]: (%s)\", i+1, val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));\n\n        proto_tree_add_uint(item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n        proto_tree_add_uint(item_tree, hf_s7comm_data_transport_size, tvb, offset + 1, 1, tsize);\n        proto_tree_add_uint(item_tree, hf_s7comm_data_length, tvb, offset + 2, 2, len);\n        offset += head_len;\n\n        if (ret_val == S7COMM_ITEM_RETVAL_DATA_OK || ret_val == S7COMM_ITEM_RETVAL_RESERVED) {\n            proto_tree_add_item(item_tree, hf_s7comm_readresponse_data, tvb, offset, len, ENC_NA);\n            offset += len;\n            if (len != len2) {\n                proto_tree_add_item(item_tree, hf_s7comm_data_fillbyte, tvb, offset, 1, ENC_BIG_ENDIAN);\n                offset += 1;\n            }\n        }\n    }\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,7 @@\n     proto_item *item = NULL;\n     proto_tree *item_tree = NULL;\n \n-    for (i = 1; i <= item_count; i++) {\n+    for (i = 0; i < item_count; i++) {\n         ret_val = tvb_get_guint8(tvb, offset);\n         if (ret_val == S7COMM_ITEM_RETVAL_RESERVED ||\n             ret_val == S7COMM_ITEM_RETVAL_DATA_OK ||\n@@ -34,7 +34,7 @@\n             }\n \n             /* the PLC places extra bytes at the end of all but last result, if length is not a multiple of 2 */\n-            if ((len % 2) && (i < item_count)) {\n+            if ((len % 2) && (i < (item_count-1))) {\n                 len2 = len + 1;\n             } else {\n                 len2 = len;\n@@ -43,7 +43,7 @@\n         /* Insert a new tree for every item */\n         item = proto_tree_add_item(tree, hf_s7comm_data_item, tvb, offset, len + head_len, ENC_NA);\n         item_tree = proto_item_add_subtree(item, ett_s7comm_data_item);\n-        proto_item_append_text(item, \" [%d]: (%s)\", i, val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));\n+        proto_item_append_text(item, \" [%d]: (%s)\", i+1, val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));\n \n         proto_tree_add_uint(item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n         proto_tree_add_uint(item_tree, hf_s7comm_data_transport_size, tvb, offset + 1, 1, tsize);",
        "diff_line_info": {
            "deleted_lines": [
                "    for (i = 1; i <= item_count; i++) {",
                "            if ((len % 2) && (i < item_count)) {",
                "        proto_item_append_text(item, \" [%d]: (%s)\", i, val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));"
            ],
            "added_lines": [
                "    for (i = 0; i < item_count; i++) {",
                "            if ((len % 2) && (i < (item_count-1))) {",
                "        proto_item_append_text(item, \" [%d]: (%s)\", i+1, val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7329",
        "func_name": "wireshark/s7comm_decode_ud_cpu_alarm_main",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-s7comm.c had an infinite loop that was addressed by correcting off-by-one errors.",
        "git_url": "https://github.com/wireshark/wireshark/commit/d8a0cbc4f2979e0b1cadbe79f0b8b4ecb92477be",
        "commit_title": "S7comm: fix range check to prevent infinite loop when upper bound is 255",
        "commit_text": " While we are at it, fix identification of not last element in a few places  Bug: 14423 (cherry picked from commit 5d99febe66e96b55a1defa58a906be254bad3a51) Conflicts: \tepan/dissectors/packet-s7comm.c (cherry picked from commit d24db8ddcdd4cdd5c1ea859da93681b4cc98b399)",
        "func_before": "static guint32\ns7comm_decode_ud_cpu_alarm_main(tvbuff_t *tvb,\n                                packet_info *pinfo,\n                                proto_tree *data_tree,\n                                guint8 type,                /* Type of data (request/response) */\n                                guint8 subfunc,             /* Subfunction */\n                                guint32 offset)             /* Offset on data part +4 */\n{\n    guint32 start_offset;\n    guint32 asc_start_offset;\n    guint32 msg_obj_start_offset;\n    guint32 ev_id;\n    proto_item *msg_item = NULL;\n    proto_tree *msg_item_tree = NULL;\n    proto_item *msg_obj_item = NULL;\n    proto_tree *msg_obj_item_tree = NULL;\n    proto_item *msg_work_item = NULL;\n    proto_tree *msg_work_item_tree = NULL;\n    guint8 nr_objects;\n    guint8 i;\n    guint8 syntax_id;\n    guint8 nr_of_additional_values;\n    guint8 signalstate;\n    guint8 sig_nr;\n    guint8 ret_val;\n    guint8 querytype;\n    guint8 varspec_length;\n\n    start_offset = offset;\n\n    msg_item = proto_tree_add_item(data_tree, hf_s7comm_cpu_alarm_message_item, tvb, offset, 0, ENC_NA);\n    msg_item_tree = proto_item_add_subtree(msg_item, ett_s7comm_cpu_alarm_message);\n\n    if (subfunc == S7COMM_UD_SUBF_CPU_ALARM8_IND || subfunc == S7COMM_UD_SUBF_CPU_ALARMACK_IND ||\n        subfunc == S7COMM_UD_SUBF_CPU_ALARMSQ_IND || subfunc == S7COMM_UD_SUBF_CPU_ALARMS_IND ||\n        subfunc == S7COMM_UD_SUBF_CPU_NOTIFY_IND || subfunc == S7COMM_UD_SUBF_CPU_NOTIFY8_IND) {\n        msg_work_item = proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_timestamp_coming, tvb, offset, 8, ENC_NA);\n        msg_work_item_tree = proto_item_add_subtree(msg_work_item, ett_s7comm_cpu_alarm_message_timestamp);\n        offset = s7comm_add_timestamp_to_tree(tvb, msg_work_item_tree, offset, TRUE, FALSE);\n    }\n    proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_function, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n    nr_objects = tvb_get_guint8(tvb, offset);\n    proto_tree_add_uint(msg_item_tree, hf_s7comm_cpu_alarm_message_nr_objects, tvb, offset, 1, nr_objects);\n    offset += 1;\n    for (i = 1; i <= nr_objects; i++) {\n        msg_obj_start_offset = offset;\n        msg_obj_item = proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_obj_item, tvb, offset, 0, ENC_NA);\n        msg_obj_item_tree = proto_item_add_subtree(msg_obj_item, ett_s7comm_cpu_alarm_message_object);\n        proto_item_append_text(msg_obj_item_tree, \" [%d]\", i);\n        if (type == S7COMM_UD_TYPE_REQ || type == S7COMM_UD_TYPE_PUSH) {\n            proto_tree_add_item(msg_obj_item_tree, hf_s7comm_item_varspec, tvb, offset, 1, ENC_BIG_ENDIAN);\n            offset += 1;\n            varspec_length = tvb_get_guint8(tvb, offset);\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_item_varspec_length, tvb, offset, 1, varspec_length);\n            offset += 1;\n            syntax_id = tvb_get_guint8(tvb, offset);\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_item_syntax_id, tvb, offset, 1, syntax_id);\n            offset += 1;\n            switch (syntax_id) {\n                case S7COMM_SYNTAXID_ALARM_LOCKFREESET:\n                case S7COMM_SYNTAXID_ALARM_INDSET:\n                case S7COMM_SYNTAXID_NOTIFY_INDSET:\n                case S7COMM_SYNTAXID_ALARM_ACKSET:\n                    nr_of_additional_values = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_nr_add_values, tvb, offset, 1, nr_of_additional_values);\n                    offset += 1;\n                    ev_id = tvb_get_ntohl(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_eventid, tvb, offset, 4, ev_id);\n                    offset += 4;\n                    proto_item_append_text(msg_obj_item_tree, \": EventID=0x%08x\", ev_id);\n                    col_append_fstr(pinfo->cinfo, COL_INFO, \" EventID=0x%08x\", ev_id);\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        signalstate = tvb_get_guint8(tvb, offset);\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_eventstate,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        /* show SIG with True values for a quick overview in info-column */\n                        if (signalstate > 0) {\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \" On=[\");\n                            for (sig_nr = 0; sig_nr < 8; sig_nr++) {\n                                if (signalstate & 0x01) {\n                                    signalstate >>= 1;\n                                    if (signalstate == 0) {\n                                        col_append_fstr(pinfo->cinfo, COL_INFO, \"SIG_%d\", sig_nr + 1);\n                                    } else {\n                                        col_append_fstr(pinfo->cinfo, COL_INFO, \"SIG_%d,\", sig_nr + 1);\n                                    }\n                                } else {\n                                    signalstate >>= 1;\n                                }\n                            }\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \"]\");\n                        }\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_state,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_ALARM_ACKSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_ackstate_going,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_ackstate_coming,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    if (syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_going,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_coming,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_lastchanged,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_event_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        if (nr_of_additional_values > 0) {\n                            asc_start_offset = offset;\n                            msg_work_item = proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_associated_value, tvb, offset, 0, ENC_NA);\n                            msg_work_item_tree = proto_item_add_subtree(msg_work_item, ett_s7comm_cpu_alarm_message_associated_value);\n                            offset = s7comm_decode_response_read_data(tvb, msg_work_item_tree, nr_of_additional_values, offset);\n                            proto_item_set_len(msg_work_item_tree, offset - asc_start_offset);\n                        }\n                    }\n                    break;\n                case S7COMM_SYNTAXID_ALARM_QUERYREQSET:\n                    proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_unknown1, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    offset += 1;\n                    querytype = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_querytype, tvb, offset, 1, querytype);\n                    offset += 1;\n                    proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_unknown2, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    offset += 1;\n                    ev_id = tvb_get_ntohl(tvb, offset);\n                    /* there is a querytype=8, which only occurs when a previous SZL request 0x131 index 0x10 has a missing flag in funk_1 */\n                    switch (querytype) {\n                        case S7COMM_ALARM_MESSAGE_QUERYTYPE_BYALARMTYPE:\n                            proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_alarmtype, tvb, offset, 4, ENC_BIG_ENDIAN);\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \" ByAlarmtype=%s\",\n                                val_to_str(ev_id, alarm_message_query_alarmtype_names, \"Unknown Alarmtype: %u\"));\n                            break;\n                        case S7COMM_ALARM_MESSAGE_QUERYTYPE_BYEVENTID:\n                            proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_eventid, tvb, offset, 4, ENC_BIG_ENDIAN);\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \" ByEventID=0x%08x\", ev_id);\n                            break;\n                        default:\n                            break;\n                    }\n                    offset += 4;\n                    break;\n                default:\n                    /* for current unknown syntax id, set offset to end of dataset. The varspec_length includes\n                     * the byte for the syntax_id, so minus one.\n                     */\n                    offset += (varspec_length - 1);\n                    break;\n            }\n        } else if (type == S7COMM_UD_TYPE_RES) {\n            ret_val = tvb_get_guint8(tvb, offset);\n            proto_item_append_text(msg_obj_item_tree, \": (%s)\", val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n            offset += 1;\n        }\n        proto_item_set_len(msg_obj_item_tree, offset - msg_obj_start_offset);\n    }\n    proto_item_set_len(msg_item_tree, offset - start_offset);\n    return offset;\n}",
        "func": "static guint32\ns7comm_decode_ud_cpu_alarm_main(tvbuff_t *tvb,\n                                packet_info *pinfo,\n                                proto_tree *data_tree,\n                                guint8 type,                /* Type of data (request/response) */\n                                guint8 subfunc,             /* Subfunction */\n                                guint32 offset)             /* Offset on data part +4 */\n{\n    guint32 start_offset;\n    guint32 asc_start_offset;\n    guint32 msg_obj_start_offset;\n    guint32 ev_id;\n    proto_item *msg_item = NULL;\n    proto_tree *msg_item_tree = NULL;\n    proto_item *msg_obj_item = NULL;\n    proto_tree *msg_obj_item_tree = NULL;\n    proto_item *msg_work_item = NULL;\n    proto_tree *msg_work_item_tree = NULL;\n    guint8 nr_objects;\n    guint8 i;\n    guint8 syntax_id;\n    guint8 nr_of_additional_values;\n    guint8 signalstate;\n    guint8 sig_nr;\n    guint8 ret_val;\n    guint8 querytype;\n    guint8 varspec_length;\n\n    start_offset = offset;\n\n    msg_item = proto_tree_add_item(data_tree, hf_s7comm_cpu_alarm_message_item, tvb, offset, 0, ENC_NA);\n    msg_item_tree = proto_item_add_subtree(msg_item, ett_s7comm_cpu_alarm_message);\n\n    if (subfunc == S7COMM_UD_SUBF_CPU_ALARM8_IND || subfunc == S7COMM_UD_SUBF_CPU_ALARMACK_IND ||\n        subfunc == S7COMM_UD_SUBF_CPU_ALARMSQ_IND || subfunc == S7COMM_UD_SUBF_CPU_ALARMS_IND ||\n        subfunc == S7COMM_UD_SUBF_CPU_NOTIFY_IND || subfunc == S7COMM_UD_SUBF_CPU_NOTIFY8_IND) {\n        msg_work_item = proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_timestamp_coming, tvb, offset, 8, ENC_NA);\n        msg_work_item_tree = proto_item_add_subtree(msg_work_item, ett_s7comm_cpu_alarm_message_timestamp);\n        offset = s7comm_add_timestamp_to_tree(tvb, msg_work_item_tree, offset, TRUE, FALSE);\n    }\n    proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_function, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n    nr_objects = tvb_get_guint8(tvb, offset);\n    proto_tree_add_uint(msg_item_tree, hf_s7comm_cpu_alarm_message_nr_objects, tvb, offset, 1, nr_objects);\n    offset += 1;\n    for (i = 0; i < nr_objects; i++) {\n        msg_obj_start_offset = offset;\n        msg_obj_item = proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_obj_item, tvb, offset, 0, ENC_NA);\n        msg_obj_item_tree = proto_item_add_subtree(msg_obj_item, ett_s7comm_cpu_alarm_message_object);\n        proto_item_append_text(msg_obj_item_tree, \" [%d]\", i+1);\n        if (type == S7COMM_UD_TYPE_REQ || type == S7COMM_UD_TYPE_PUSH) {\n            proto_tree_add_item(msg_obj_item_tree, hf_s7comm_item_varspec, tvb, offset, 1, ENC_BIG_ENDIAN);\n            offset += 1;\n            varspec_length = tvb_get_guint8(tvb, offset);\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_item_varspec_length, tvb, offset, 1, varspec_length);\n            offset += 1;\n            syntax_id = tvb_get_guint8(tvb, offset);\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_item_syntax_id, tvb, offset, 1, syntax_id);\n            offset += 1;\n            switch (syntax_id) {\n                case S7COMM_SYNTAXID_ALARM_LOCKFREESET:\n                case S7COMM_SYNTAXID_ALARM_INDSET:\n                case S7COMM_SYNTAXID_NOTIFY_INDSET:\n                case S7COMM_SYNTAXID_ALARM_ACKSET:\n                    nr_of_additional_values = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_nr_add_values, tvb, offset, 1, nr_of_additional_values);\n                    offset += 1;\n                    ev_id = tvb_get_ntohl(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_eventid, tvb, offset, 4, ev_id);\n                    offset += 4;\n                    proto_item_append_text(msg_obj_item_tree, \": EventID=0x%08x\", ev_id);\n                    col_append_fstr(pinfo->cinfo, COL_INFO, \" EventID=0x%08x\", ev_id);\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        signalstate = tvb_get_guint8(tvb, offset);\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_eventstate,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        /* show SIG with True values for a quick overview in info-column */\n                        if (signalstate > 0) {\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \" On=[\");\n                            for (sig_nr = 0; sig_nr < 8; sig_nr++) {\n                                if (signalstate & 0x01) {\n                                    signalstate >>= 1;\n                                    if (signalstate == 0) {\n                                        col_append_fstr(pinfo->cinfo, COL_INFO, \"SIG_%d\", sig_nr + 1);\n                                    } else {\n                                        col_append_fstr(pinfo->cinfo, COL_INFO, \"SIG_%d,\", sig_nr + 1);\n                                    }\n                                } else {\n                                    signalstate >>= 1;\n                                }\n                            }\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \"]\");\n                        }\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_state,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_ALARM_ACKSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_ackstate_going,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_ackstate_coming,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    if (syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_going,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_coming,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_lastchanged,\n                            ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN);\n                        offset += 1;\n                        proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_event_reserved, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        offset += 1;\n                    }\n                    if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) {\n                        if (nr_of_additional_values > 0) {\n                            asc_start_offset = offset;\n                            msg_work_item = proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_associated_value, tvb, offset, 0, ENC_NA);\n                            msg_work_item_tree = proto_item_add_subtree(msg_work_item, ett_s7comm_cpu_alarm_message_associated_value);\n                            offset = s7comm_decode_response_read_data(tvb, msg_work_item_tree, nr_of_additional_values, offset);\n                            proto_item_set_len(msg_work_item_tree, offset - asc_start_offset);\n                        }\n                    }\n                    break;\n                case S7COMM_SYNTAXID_ALARM_QUERYREQSET:\n                    proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_unknown1, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    offset += 1;\n                    querytype = tvb_get_guint8(tvb, offset);\n                    proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_querytype, tvb, offset, 1, querytype);\n                    offset += 1;\n                    proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_unknown2, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    offset += 1;\n                    ev_id = tvb_get_ntohl(tvb, offset);\n                    /* there is a querytype=8, which only occurs when a previous SZL request 0x131 index 0x10 has a missing flag in funk_1 */\n                    switch (querytype) {\n                        case S7COMM_ALARM_MESSAGE_QUERYTYPE_BYALARMTYPE:\n                            proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_alarmtype, tvb, offset, 4, ENC_BIG_ENDIAN);\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \" ByAlarmtype=%s\",\n                                val_to_str(ev_id, alarm_message_query_alarmtype_names, \"Unknown Alarmtype: %u\"));\n                            break;\n                        case S7COMM_ALARM_MESSAGE_QUERYTYPE_BYEVENTID:\n                            proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_eventid, tvb, offset, 4, ENC_BIG_ENDIAN);\n                            col_append_fstr(pinfo->cinfo, COL_INFO, \" ByEventID=0x%08x\", ev_id);\n                            break;\n                        default:\n                            break;\n                    }\n                    offset += 4;\n                    break;\n                default:\n                    /* for current unknown syntax id, set offset to end of dataset. The varspec_length includes\n                     * the byte for the syntax_id, so minus one.\n                     */\n                    offset += (varspec_length - 1);\n                    break;\n            }\n        } else if (type == S7COMM_UD_TYPE_RES) {\n            ret_val = tvb_get_guint8(tvb, offset);\n            proto_item_append_text(msg_obj_item_tree, \": (%s)\", val_to_str(ret_val, s7comm_item_return_valuenames, \"Unknown code: 0x%02x\"));\n            proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val);\n            offset += 1;\n        }\n        proto_item_set_len(msg_obj_item_tree, offset - msg_obj_start_offset);\n    }\n    proto_item_set_len(msg_item_tree, offset - start_offset);\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -43,11 +43,11 @@\n     nr_objects = tvb_get_guint8(tvb, offset);\n     proto_tree_add_uint(msg_item_tree, hf_s7comm_cpu_alarm_message_nr_objects, tvb, offset, 1, nr_objects);\n     offset += 1;\n-    for (i = 1; i <= nr_objects; i++) {\n+    for (i = 0; i < nr_objects; i++) {\n         msg_obj_start_offset = offset;\n         msg_obj_item = proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_obj_item, tvb, offset, 0, ENC_NA);\n         msg_obj_item_tree = proto_item_add_subtree(msg_obj_item, ett_s7comm_cpu_alarm_message_object);\n-        proto_item_append_text(msg_obj_item_tree, \" [%d]\", i);\n+        proto_item_append_text(msg_obj_item_tree, \" [%d]\", i+1);\n         if (type == S7COMM_UD_TYPE_REQ || type == S7COMM_UD_TYPE_PUSH) {\n             proto_tree_add_item(msg_obj_item_tree, hf_s7comm_item_varspec, tvb, offset, 1, ENC_BIG_ENDIAN);\n             offset += 1;",
        "diff_line_info": {
            "deleted_lines": [
                "    for (i = 1; i <= nr_objects; i++) {",
                "        proto_item_append_text(msg_obj_item_tree, \" [%d]\", i);"
            ],
            "added_lines": [
                "    for (i = 0; i < nr_objects; i++) {",
                "        proto_item_append_text(msg_obj_item_tree, \" [%d]\", i+1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7330",
        "func_name": "wireshark/get_chancount",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-thread.c had an infinite loop that was addressed by using a correct integer data type.",
        "git_url": "https://github.com/wireshark/wireshark/commit/8ad0c5b3683a17d9e2e16bbf25869140fd5c1c66",
        "commit_title": "Thread: use wider variables to prevent overflow and infinite loops",
        "commit_text": " Bug: 14428 (cherry picked from commit 49e331c4cec96a1ca2637eed48f67553bc53a5b9)",
        "func_before": "static guint\nget_chancount(tvbuff_t *tvb)\n{\n    guint         offset;\n    guint8        tlv_type;\n    guint16       tlv_len;\n    tlv_len_len_e tlv_len_len;\n    guint         chancount = THREAD_MC_INVALID_CHAN_COUNT;\n\n    offset = 0;\n\n    /* Thread Network Data TLVs */\n    while (tvb_offset_exists(tvb, offset)) {\n\n        /* Get the type and length ahead of time to pass to next function so we can highlight\n           proper amount of bytes */\n        tlv_type = tvb_get_guint8(tvb, offset);\n        tlv_len = (guint16)tvb_get_guint8(tvb, offset + 1);\n\n        /* TODO: need to make sure this applies to all MeshCoP TLVs */\n        if (THREAD_TLV_LENGTH_ESC == tlv_len) {\n            /* 16-bit length field */\n            tlv_len = tvb_get_ntohs(tvb, offset + 2);\n            tlv_len_len = TLV_LEN_LEN16;\n        } else {\n            tlv_len_len = TLV_LEN_LEN8;\n        }\n\n        /* Skip over Type and Length */\n        offset += 1 + tlv_len_len;\n\n        switch(tlv_type) {\n\n            case THREAD_MC_TLV_CHANNEL_MASK:\n                {\n                    int i, j;\n                    guint8 entries = 0;\n                    gint32 check_len = tlv_len;\n                    guint8 check_offset = offset + 1; /* Channel page first */\n                    guint8 masklen;\n\n                    /* Check consistency of entries */\n                    while (check_len > 0) {\n\n                        masklen = tvb_get_guint8(tvb, check_offset);\n                        if (masklen == 0) {\n                            break; /* Get out or we might spin forever */\n                        }\n                        masklen += 2; /* Add in page and length */\n                        check_offset += masklen;\n                        check_len -= masklen;\n                        entries++;\n                    }\n\n                    if (check_len != 0) {\n                        /* Not an integer number of entries */\n                        /* offset += tlv_len; */\n                        return chancount;\n                    } else {\n                        chancount = 0;\n                        for (i = 0; i < entries; i++) {\n                            /* Skip over channel page */\n                            offset++;\n                            masklen = tvb_get_guint8(tvb, offset);\n                            offset++;\n                            /* Count the number of channels in the channel mask */\n                            for (j = 0; j < masklen; j++) {\n                                chancount += count_bits_in_byte(tvb_get_guint8(tvb, offset));\n                                offset++;\n                            }\n                        }\n                    }\n                }\n                break;\n\n            default:\n                /* Skip over any other TLVs */\n                offset += tlv_len;\n        }\n    }\n    return chancount;\n}",
        "func": "static guint\nget_chancount(tvbuff_t *tvb)\n{\n    guint         offset;\n    guint8        tlv_type;\n    guint16       tlv_len;\n    tlv_len_len_e tlv_len_len;\n    guint         chancount = THREAD_MC_INVALID_CHAN_COUNT;\n\n    offset = 0;\n\n    /* Thread Network Data TLVs */\n    while (tvb_offset_exists(tvb, offset)) {\n\n        /* Get the type and length ahead of time to pass to next function so we can highlight\n           proper amount of bytes */\n        tlv_type = tvb_get_guint8(tvb, offset);\n        tlv_len = (guint16)tvb_get_guint8(tvb, offset + 1);\n\n        /* TODO: need to make sure this applies to all MeshCoP TLVs */\n        if (THREAD_TLV_LENGTH_ESC == tlv_len) {\n            /* 16-bit length field */\n            tlv_len = tvb_get_ntohs(tvb, offset + 2);\n            tlv_len_len = TLV_LEN_LEN16;\n        } else {\n            tlv_len_len = TLV_LEN_LEN8;\n        }\n\n        /* Skip over Type and Length */\n        offset += 1 + tlv_len_len;\n\n        switch(tlv_type) {\n\n            case THREAD_MC_TLV_CHANNEL_MASK:\n                {\n                    int i, j;\n                    guint8 entries = 0;\n                    gint32 check_len = tlv_len;\n                    gint check_offset = offset + 1; /* Channel page first */\n                    guint16 masklen;\n\n                    /* Check consistency of entries */\n                    while (check_len > 0) {\n\n                        masklen = tvb_get_guint8(tvb, check_offset);\n                        if (masklen == 0) {\n                            break; /* Get out or we might spin forever */\n                        }\n                        masklen += 2; /* Add in page and length */\n                        check_offset += masklen;\n                        check_len -= masklen;\n                        entries++;\n                    }\n\n                    if (check_len != 0) {\n                        /* Not an integer number of entries */\n                        /* offset += tlv_len; */\n                        return chancount;\n                    } else {\n                        chancount = 0;\n                        for (i = 0; i < entries; i++) {\n                            /* Skip over channel page */\n                            offset++;\n                            masklen = tvb_get_guint8(tvb, offset);\n                            offset++;\n                            /* Count the number of channels in the channel mask */\n                            for (j = 0; j < masklen; j++) {\n                                chancount += count_bits_in_byte(tvb_get_guint8(tvb, offset));\n                                offset++;\n                            }\n                        }\n                    }\n                }\n                break;\n\n            default:\n                /* Skip over any other TLVs */\n                offset += tlv_len;\n        }\n    }\n    return chancount;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -36,8 +36,8 @@\n                     int i, j;\n                     guint8 entries = 0;\n                     gint32 check_len = tlv_len;\n-                    guint8 check_offset = offset + 1; /* Channel page first */\n-                    guint8 masklen;\n+                    gint check_offset = offset + 1; /* Channel page first */\n+                    guint16 masklen;\n \n                     /* Check consistency of entries */\n                     while (check_len > 0) {",
        "diff_line_info": {
            "deleted_lines": [
                "                    guint8 check_offset = offset + 1; /* Channel page first */",
                "                    guint8 masklen;"
            ],
            "added_lines": [
                "                    gint check_offset = offset + 1; /* Channel page first */",
                "                    guint16 masklen;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7330",
        "func_name": "wireshark/dissect_thread_mc",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-thread.c had an infinite loop that was addressed by using a correct integer data type.",
        "git_url": "https://github.com/wireshark/wireshark/commit/8ad0c5b3683a17d9e2e16bbf25869140fd5c1c66",
        "commit_title": "Thread: use wider variables to prevent overflow and infinite loops",
        "commit_text": " Bug: 14428 (cherry picked from commit 49e331c4cec96a1ca2637eed48f67553bc53a5b9)",
        "func_before": "static int\ndissect_thread_mc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\n{\n    proto_item    *proto_root;\n    proto_tree    *thread_mc_tree;\n    proto_tree    *tlv_tree;\n    guint         offset = 0;\n    proto_item    *ti;\n    proto_item    *pi;\n    guint8        tlv_type;\n    guint16       tlv_len;\n    tlv_len_len_e tlv_len_len;\n    guint         chancount;\n\n\n    /* Create the protocol tree. */\n    proto_root = proto_tree_add_item(tree, proto_thread_mc, tvb, 0, tvb_reported_length(tvb), ENC_NA);\n    thread_mc_tree = proto_item_add_subtree(proto_root, ett_thread_mc);\n\n    /* Get channel count a priori so we can process energy list better */\n    chancount = get_chancount(tvb);\n\n    /* Thread Network Data TLVs */\n    while (tvb_offset_exists(tvb, offset)) {\n\n        /* Get the type and length ahead of time to pass to next function so we can highlight\n           proper amount of bytes */\n        tlv_type = tvb_get_guint8(tvb, offset);\n        tlv_len = (guint16)tvb_get_guint8(tvb, offset + 1);\n\n        /* TODO: need to make sure this applies to all MeshCoP TLVs */\n        if (THREAD_TLV_LENGTH_ESC == tlv_len) {\n            /* 16-bit length field */\n            tlv_len = tvb_get_ntohs(tvb, offset + 2);\n            tlv_len_len = TLV_LEN_LEN16;\n        } else {\n            tlv_len_len = TLV_LEN_LEN8;\n        }\n\n        /* Create the tree */\n        ti = proto_tree_add_item(thread_mc_tree, hf_thread_mc_tlv, tvb, offset, 1 + tlv_len_len + tlv_len, ENC_NA);\n        tlv_tree = proto_item_add_subtree(ti, ett_thread_mc_tlv);\n\n        /* Type */\n        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* Add value name to value root label */\n        proto_item_append_text(ti, \" (%s)\", val_to_str(tlv_type, thread_mc_tlv_vals, \"Unknown (%d)\"));\n\n        /* Length */\n        switch (tlv_len_len) {\n            case TLV_LEN_LEN8:\n                proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_length8, tvb, offset, 1, ENC_BIG_ENDIAN);\n                break;\n            case TLV_LEN_LEN16:\n                proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_length16, tvb, offset + 1, 2, ENC_BIG_ENDIAN);\n                break;\n            default:\n                break;\n        }\n        offset += tlv_len_len;\n\n        switch(tlv_type) {\n            case THREAD_MC_TLV_CHANNEL:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 3) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* Channel page */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_channel_page, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        /* Channel */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_channel, tvb, offset+1, 2, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_PANID:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* PAN ID */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_pan_id, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_XPANID:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 8) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* PAN ID */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_xpan_id, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_NETWORK_NAME:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len > 16) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_net_name, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_PSKC:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 16) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_pskc, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_NETWORK_MASTER_KEY:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 16) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_master_key, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_NETWORK_KEY_SEQ_CTR:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 4) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_net_key_seq_ctr, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_NETWORK_ML_PREFIX:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 8) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        struct e_in6_addr prefix;\n\n                        memset(&prefix, 0, sizeof(prefix));\n                        tvb_memcpy(tvb, (guint8 *)&prefix.bytes, offset, tlv_len);\n                        pi = proto_tree_add_ipv6(tlv_tree, hf_thread_mc_tlv_ml_prefix, tvb, offset, tlv_len, &prefix);\n                        proto_item_append_text(pi, \"/%d\", tlv_len * 8);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_STEERING_DATA:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len > 16) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* Display it simply */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_steering_data, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_BORDER_AGENT_LOCATOR:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_ba_locator, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_COMMISSIONER_ID:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len > 64) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_commissioner_id, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_COMMISSIONER_SESSION_ID:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_commissioner_sess_id, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_SECURITY_POLICY:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 3) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                        offset += tlv_len;\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_rot, tvb, offset, 2, ENC_BIG_ENDIAN);\n                        offset += 2;\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_o, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_n, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_r, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_c, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_b, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        offset++;\n                    }\n                }\n                break;\n\n            case THREAD_MC_TLV_GET:\n                {\n                    int i;\n\n                    for (i = 0; i < tlv_len; i++) {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        offset++;\n                    }\n                }\n                break;\n\n            case THREAD_MC_TLV_ACTIVE_TSTAMP:\n            case THREAD_MC_TLV_PENDING_TSTAMP:\n                {\n                    nstime_t timestamp;\n\n                    if (tlv_len != 8) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* Fill in the nstime_t structure */\n                        timestamp.secs = (time_t)tvb_get_ntoh48(tvb, offset);\n                        timestamp.nsecs = (int)lround((double)(tvb_get_ntohs(tvb, offset + 6) >> 1) * THREAD_MC_32768_TO_NSEC_FACTOR);\n                        if (tlv_type == THREAD_MC_TLV_ACTIVE_TSTAMP) {\n                            proto_tree_add_time(tlv_tree, hf_thread_mc_tlv_active_tstamp, tvb, offset, 8, &timestamp);\n                        } else {\n                            proto_tree_add_time(tlv_tree, hf_thread_mc_tlv_pending_tstamp, tvb, offset, 8, &timestamp);\n                        }\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_STATE:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 1) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_state, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_JOINER_DTLS_ENCAP:\n                {\n                    tvbuff_t *sub_tvb;\n\n                    if (tlv_len > 0) {\n                        sub_tvb = tvb_new_subset_length(tvb, offset, tlv_len);\n                        call_dissector(thread_dtls_handle, sub_tvb, pinfo, tree);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_COMMISSIONER_UDP_PORT:\n            case THREAD_MC_TLV_JOINER_UDP_PORT:\n                {\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* UDP Port */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_udp_port, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_JOINER_IID:\n                {\n                    if (tlv_len != 8) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* IID */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_iid, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_JOINER_ROUTER_LOCATOR:\n                {\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_jr_locator, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_JOINER_KEK:\n                {\n                    if (tlv_len != 16) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_kek, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_PROVISIONING_URL:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len > 64) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_provisioning_url, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_VENDOR_NAME:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len > 32) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_name, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_VENDOR_MODEL:\n                {\n                    /* Check length is consistent: TODO not specified in spec. */\n                    if (tlv_len > 32) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_model, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_VENDOR_SW_VERSION:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len > 16) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_sw_ver, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_VENDOR_DATA:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len > 64) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* Display it simply */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_data, tvb, offset, tlv_len, ENC_ASCII|ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_VENDOR_STACK_VERSION:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 6) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                        offset += tlv_len;\n                    } else {\n                        guint8 build_u8;\n                        guint16 build;\n\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_stack_ver_oui, tvb, offset, 3, ENC_BIG_ENDIAN);\n                        offset += 3;\n                        build_u8 = tvb_get_guint8(tvb, offset);\n                        offset++;\n                        build = (guint16)build_u8 << 4;\n                        build_u8 = tvb_get_guint8(tvb, offset);\n                        build |= (guint16)build_u8 >> 4;\n                        pi = proto_tree_add_uint(tlv_tree, hf_thread_mc_tlv_vendor_stack_ver_build, tvb, 0, 0, build);\n                        PROTO_ITEM_SET_GENERATED(pi);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_stack_ver_rev, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        offset++;\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_stack_ver_min, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_stack_ver_maj, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        offset++;\n                    }\n                }\n                break;\n\n            case THREAD_MC_TLV_UDP_ENCAPSULATION:\n                {\n                    tvbuff_t *sub_tvb;\n                    guint16 src_port;\n                    guint16 dst_port;\n                    udp_hdr_t *udp_hdr;\n                    guint8 *buffer;\n\n                    src_port = tvb_get_ntohs(tvb, offset);\n                    proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_udp_encap_src_port, tvb, offset, 2, ENC_BIG_ENDIAN);\n                    offset += 2;\n                    dst_port = tvb_get_ntohs(tvb, offset);\n                    proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_udp_encap_dst_port, tvb, offset, 2, ENC_BIG_ENDIAN);\n                    offset += 2;\n\n                    if (tlv_len >= 4)\n                    {\n                        /* Allocate a buffer for the fake UDP datagram and create the fake header. */\n                        buffer = (guint8 *)wmem_alloc(pinfo->pool, sizeof(udp_hdr_t) + (tlv_len - 4));\n\n                        /* Create pseudo UDP header */\n                        udp_hdr = (udp_hdr_t *)buffer;\n                        udp_hdr->src_port = g_htons(src_port);\n                        udp_hdr->dst_port = g_htons(dst_port);\n                        udp_hdr->length = g_htons(tlv_len + 4); /* Includes UDP header length */\n                        udp_hdr->checksum = 0;\n                        /* Copy UDP payload in */\n                        tvb_memcpy(tvb, udp_hdr + 1, offset, tlv_len - 4);\n                        /* Create child tvb */\n                        sub_tvb = tvb_new_child_real_data(tvb, buffer, tlv_len + 4, tvb_reported_length(tvb) + 4);\n                        call_dissector(thread_udp_handle, sub_tvb, pinfo, tree);\n                    }\n                    offset += (tlv_len-4);\n                }\n                break;\n\n            case THREAD_MC_TLV_IPV6_ADDRESS:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 16) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_ipv6_addr, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            /* case THREAD_MC_TLV_PENDING_TSTAMP: Handled in THREAD_MC_TLV_ACTIVE_TSTAMP case */\n\n            case THREAD_MC_TLV_DELAY_TIMER:\n                {\n                    if (tlv_len != 4) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_delay_timer, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_CHANNEL_MASK:\n                {\n                    proto_tree *cm_tree;\n                    int i;\n                    guint8 entries = 0;\n                    gint32 check_len = tlv_len;\n                    guint8 check_offset = offset + 1; /* Channel page first */\n                    guint8 masklen;\n\n                    /* Check consistency of entries */\n                    while (check_len > 0) {\n\n                        masklen = tvb_get_guint8(tvb, check_offset);\n                        if (masklen == 0) {\n                            break; /* Get out or we might spin forever */\n                        }\n                        masklen += 2; /* Add in page and length */\n                        check_offset += masklen;\n                        check_len -= masklen;\n                        entries++;\n                    }\n\n                    if (check_len != 0) {\n                        /* Not an integer number of entries */\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_tlv_length_failed);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                        offset += tlv_len;\n                    } else {\n                        for (i = 0; i < entries; i++) {\n                            pi = proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_chan_mask, tvb, offset, 1, ENC_NA);\n                            cm_tree = proto_item_add_subtree(pi, ett_thread_mc_chan_mask);\n                            proto_tree_add_item(cm_tree, hf_thread_mc_tlv_chan_mask_page, tvb, offset, 1, ENC_BIG_ENDIAN);\n                            offset++;\n                            masklen = tvb_get_guint8(tvb, offset);\n                            proto_tree_add_item(cm_tree, hf_thread_mc_tlv_chan_mask_len, tvb, offset, 1, ENC_BIG_ENDIAN);\n                            offset++;\n                            proto_tree_add_item(cm_tree, hf_thread_mc_tlv_chan_mask_mask, tvb, offset, masklen, ENC_NA);\n                            offset += masklen;\n                        }\n                    }\n                }\n                break;\n\n            case THREAD_MC_TLV_COUNT:\n                {\n                    if (tlv_len != 1) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_count, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_PERIOD:\n                {\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_period, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_SCAN_DURATION:\n                {\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_scan_duration, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_ENERGY_LIST:\n                {\n                    proto_tree *it_tree;\n                    int i;\n\n                    if ((chancount != THREAD_MC_INVALID_CHAN_COUNT) && (chancount != 0) && ((tlv_len % chancount) == 0)) {\n                        /* Go through the number of el_counts of scan */\n                        for (i = 0; i < (int)(tlv_len / (guint16)chancount); i++) {\n                            pi = proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_el_count, tvb, offset, 1, ENC_NA);\n                            proto_item_append_text(pi, \" %d\", i + 1);\n                            it_tree = proto_item_add_subtree(pi, ett_thread_mc_el_count);\n                            proto_tree_add_item(it_tree, hf_thread_mc_tlv_energy_list, tvb, offset, chancount, ENC_NA);\n                            offset += chancount;\n                        }\n                    } else {\n                        /* This might not work but try and display as string */\n                        /* Something wrong with channel count so just show it as a simple string */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_energy_list, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_DISCOVERY_REQUEST:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_discovery_req_ver, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_discovery_req_j, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_DISCOVERY_RESPONSE:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_discovery_rsp_ver, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_discovery_rsp_n, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            default:\n                proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                offset += tlv_len;\n        }\n    }\n    return tvb_captured_length(tvb);\n}",
        "func": "static int\ndissect_thread_mc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\n{\n    proto_item    *proto_root;\n    proto_tree    *thread_mc_tree;\n    proto_tree    *tlv_tree;\n    guint         offset = 0;\n    proto_item    *ti;\n    proto_item    *pi;\n    guint8        tlv_type;\n    guint16       tlv_len;\n    tlv_len_len_e tlv_len_len;\n    guint         chancount;\n\n\n    /* Create the protocol tree. */\n    proto_root = proto_tree_add_item(tree, proto_thread_mc, tvb, 0, tvb_reported_length(tvb), ENC_NA);\n    thread_mc_tree = proto_item_add_subtree(proto_root, ett_thread_mc);\n\n    /* Get channel count a priori so we can process energy list better */\n    chancount = get_chancount(tvb);\n\n    /* Thread Network Data TLVs */\n    while (tvb_offset_exists(tvb, offset)) {\n\n        /* Get the type and length ahead of time to pass to next function so we can highlight\n           proper amount of bytes */\n        tlv_type = tvb_get_guint8(tvb, offset);\n        tlv_len = (guint16)tvb_get_guint8(tvb, offset + 1);\n\n        /* TODO: need to make sure this applies to all MeshCoP TLVs */\n        if (THREAD_TLV_LENGTH_ESC == tlv_len) {\n            /* 16-bit length field */\n            tlv_len = tvb_get_ntohs(tvb, offset + 2);\n            tlv_len_len = TLV_LEN_LEN16;\n        } else {\n            tlv_len_len = TLV_LEN_LEN8;\n        }\n\n        /* Create the tree */\n        ti = proto_tree_add_item(thread_mc_tree, hf_thread_mc_tlv, tvb, offset, 1 + tlv_len_len + tlv_len, ENC_NA);\n        tlv_tree = proto_item_add_subtree(ti, ett_thread_mc_tlv);\n\n        /* Type */\n        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n        offset++;\n\n        /* Add value name to value root label */\n        proto_item_append_text(ti, \" (%s)\", val_to_str(tlv_type, thread_mc_tlv_vals, \"Unknown (%d)\"));\n\n        /* Length */\n        switch (tlv_len_len) {\n            case TLV_LEN_LEN8:\n                proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_length8, tvb, offset, 1, ENC_BIG_ENDIAN);\n                break;\n            case TLV_LEN_LEN16:\n                proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_length16, tvb, offset + 1, 2, ENC_BIG_ENDIAN);\n                break;\n            default:\n                break;\n        }\n        offset += tlv_len_len;\n\n        switch(tlv_type) {\n            case THREAD_MC_TLV_CHANNEL:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 3) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* Channel page */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_channel_page, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        /* Channel */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_channel, tvb, offset+1, 2, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_PANID:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* PAN ID */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_pan_id, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_XPANID:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 8) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* PAN ID */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_xpan_id, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_NETWORK_NAME:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len > 16) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_net_name, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_PSKC:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 16) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_pskc, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_NETWORK_MASTER_KEY:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 16) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_master_key, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_NETWORK_KEY_SEQ_CTR:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 4) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_net_key_seq_ctr, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_NETWORK_ML_PREFIX:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 8) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        struct e_in6_addr prefix;\n\n                        memset(&prefix, 0, sizeof(prefix));\n                        tvb_memcpy(tvb, (guint8 *)&prefix.bytes, offset, tlv_len);\n                        pi = proto_tree_add_ipv6(tlv_tree, hf_thread_mc_tlv_ml_prefix, tvb, offset, tlv_len, &prefix);\n                        proto_item_append_text(pi, \"/%d\", tlv_len * 8);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_STEERING_DATA:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len > 16) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* Display it simply */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_steering_data, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_BORDER_AGENT_LOCATOR:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_ba_locator, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_COMMISSIONER_ID:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len > 64) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_commissioner_id, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_COMMISSIONER_SESSION_ID:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_commissioner_sess_id, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_SECURITY_POLICY:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 3) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                        offset += tlv_len;\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_rot, tvb, offset, 2, ENC_BIG_ENDIAN);\n                        offset += 2;\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_o, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_n, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_r, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_c, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_sec_policy_b, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        offset++;\n                    }\n                }\n                break;\n\n            case THREAD_MC_TLV_GET:\n                {\n                    int i;\n\n                    for (i = 0; i < tlv_len; i++) {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        offset++;\n                    }\n                }\n                break;\n\n            case THREAD_MC_TLV_ACTIVE_TSTAMP:\n            case THREAD_MC_TLV_PENDING_TSTAMP:\n                {\n                    nstime_t timestamp;\n\n                    if (tlv_len != 8) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* Fill in the nstime_t structure */\n                        timestamp.secs = (time_t)tvb_get_ntoh48(tvb, offset);\n                        timestamp.nsecs = (int)lround((double)(tvb_get_ntohs(tvb, offset + 6) >> 1) * THREAD_MC_32768_TO_NSEC_FACTOR);\n                        if (tlv_type == THREAD_MC_TLV_ACTIVE_TSTAMP) {\n                            proto_tree_add_time(tlv_tree, hf_thread_mc_tlv_active_tstamp, tvb, offset, 8, &timestamp);\n                        } else {\n                            proto_tree_add_time(tlv_tree, hf_thread_mc_tlv_pending_tstamp, tvb, offset, 8, &timestamp);\n                        }\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_STATE:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 1) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_state, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_JOINER_DTLS_ENCAP:\n                {\n                    tvbuff_t *sub_tvb;\n\n                    if (tlv_len > 0) {\n                        sub_tvb = tvb_new_subset_length(tvb, offset, tlv_len);\n                        call_dissector(thread_dtls_handle, sub_tvb, pinfo, tree);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_COMMISSIONER_UDP_PORT:\n            case THREAD_MC_TLV_JOINER_UDP_PORT:\n                {\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* UDP Port */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_udp_port, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_JOINER_IID:\n                {\n                    if (tlv_len != 8) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* IID */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_iid, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_JOINER_ROUTER_LOCATOR:\n                {\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_jr_locator, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_JOINER_KEK:\n                {\n                    if (tlv_len != 16) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_kek, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_PROVISIONING_URL:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len > 64) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_provisioning_url, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_VENDOR_NAME:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len > 32) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_name, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_VENDOR_MODEL:\n                {\n                    /* Check length is consistent: TODO not specified in spec. */\n                    if (tlv_len > 32) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_model, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_VENDOR_SW_VERSION:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len > 16) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_sw_ver, tvb, offset, tlv_len, ENC_NA|ENC_UTF_8);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_VENDOR_DATA:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len > 64) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_too_long);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        /* Display it simply */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_data, tvb, offset, tlv_len, ENC_ASCII|ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_VENDOR_STACK_VERSION:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 6) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                        offset += tlv_len;\n                    } else {\n                        guint8 build_u8;\n                        guint16 build;\n\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_stack_ver_oui, tvb, offset, 3, ENC_BIG_ENDIAN);\n                        offset += 3;\n                        build_u8 = tvb_get_guint8(tvb, offset);\n                        offset++;\n                        build = (guint16)build_u8 << 4;\n                        build_u8 = tvb_get_guint8(tvb, offset);\n                        build |= (guint16)build_u8 >> 4;\n                        pi = proto_tree_add_uint(tlv_tree, hf_thread_mc_tlv_vendor_stack_ver_build, tvb, 0, 0, build);\n                        PROTO_ITEM_SET_GENERATED(pi);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_stack_ver_rev, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        offset++;\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_stack_ver_min, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_vendor_stack_ver_maj, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        offset++;\n                    }\n                }\n                break;\n\n            case THREAD_MC_TLV_UDP_ENCAPSULATION:\n                {\n                    tvbuff_t *sub_tvb;\n                    guint16 src_port;\n                    guint16 dst_port;\n                    udp_hdr_t *udp_hdr;\n                    guint8 *buffer;\n\n                    src_port = tvb_get_ntohs(tvb, offset);\n                    proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_udp_encap_src_port, tvb, offset, 2, ENC_BIG_ENDIAN);\n                    offset += 2;\n                    dst_port = tvb_get_ntohs(tvb, offset);\n                    proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_udp_encap_dst_port, tvb, offset, 2, ENC_BIG_ENDIAN);\n                    offset += 2;\n\n                    if (tlv_len >= 4)\n                    {\n                        /* Allocate a buffer for the fake UDP datagram and create the fake header. */\n                        buffer = (guint8 *)wmem_alloc(pinfo->pool, sizeof(udp_hdr_t) + (tlv_len - 4));\n\n                        /* Create pseudo UDP header */\n                        udp_hdr = (udp_hdr_t *)buffer;\n                        udp_hdr->src_port = g_htons(src_port);\n                        udp_hdr->dst_port = g_htons(dst_port);\n                        udp_hdr->length = g_htons(tlv_len + 4); /* Includes UDP header length */\n                        udp_hdr->checksum = 0;\n                        /* Copy UDP payload in */\n                        tvb_memcpy(tvb, udp_hdr + 1, offset, tlv_len - 4);\n                        /* Create child tvb */\n                        sub_tvb = tvb_new_child_real_data(tvb, buffer, tlv_len + 4, tvb_reported_length(tvb) + 4);\n                        call_dissector(thread_udp_handle, sub_tvb, pinfo, tree);\n                    }\n                    offset += (tlv_len-4);\n                }\n                break;\n\n            case THREAD_MC_TLV_IPV6_ADDRESS:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 16) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_ipv6_addr, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            /* case THREAD_MC_TLV_PENDING_TSTAMP: Handled in THREAD_MC_TLV_ACTIVE_TSTAMP case */\n\n            case THREAD_MC_TLV_DELAY_TIMER:\n                {\n                    if (tlv_len != 4) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_delay_timer, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_CHANNEL_MASK:\n                {\n                    proto_tree *cm_tree;\n                    int i;\n                    guint8 entries = 0;\n                    gint32 check_len = tlv_len;\n                    gint check_offset = offset + 1; /* Channel page first */\n                    guint16 masklen;\n\n                    /* Check consistency of entries */\n                    while (check_len > 0) {\n\n                        masklen = tvb_get_guint8(tvb, check_offset);\n                        if (masklen == 0) {\n                            break; /* Get out or we might spin forever */\n                        }\n                        masklen += 2; /* Add in page and length */\n                        check_offset += masklen;\n                        check_len -= masklen;\n                        entries++;\n                    }\n\n                    if (check_len != 0) {\n                        /* Not an integer number of entries */\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_tlv_length_failed);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                        offset += tlv_len;\n                    } else {\n                        for (i = 0; i < entries; i++) {\n                            pi = proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_chan_mask, tvb, offset, 1, ENC_NA);\n                            cm_tree = proto_item_add_subtree(pi, ett_thread_mc_chan_mask);\n                            proto_tree_add_item(cm_tree, hf_thread_mc_tlv_chan_mask_page, tvb, offset, 1, ENC_BIG_ENDIAN);\n                            offset++;\n                            masklen = tvb_get_guint8(tvb, offset);\n                            proto_tree_add_item(cm_tree, hf_thread_mc_tlv_chan_mask_len, tvb, offset, 1, ENC_BIG_ENDIAN);\n                            offset++;\n                            proto_tree_add_item(cm_tree, hf_thread_mc_tlv_chan_mask_mask, tvb, offset, masklen, ENC_NA);\n                            offset += masklen;\n                        }\n                    }\n                }\n                break;\n\n            case THREAD_MC_TLV_COUNT:\n                {\n                    if (tlv_len != 1) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_count, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_PERIOD:\n                {\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_period, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_SCAN_DURATION:\n                {\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_scan_duration, tvb, offset, tlv_len, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_ENERGY_LIST:\n                {\n                    proto_tree *it_tree;\n                    int i;\n\n                    if ((chancount != THREAD_MC_INVALID_CHAN_COUNT) && (chancount != 0) && ((tlv_len % chancount) == 0)) {\n                        /* Go through the number of el_counts of scan */\n                        for (i = 0; i < (int)(tlv_len / (guint16)chancount); i++) {\n                            pi = proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_el_count, tvb, offset, 1, ENC_NA);\n                            proto_item_append_text(pi, \" %d\", i + 1);\n                            it_tree = proto_item_add_subtree(pi, ett_thread_mc_el_count);\n                            proto_tree_add_item(it_tree, hf_thread_mc_tlv_energy_list, tvb, offset, chancount, ENC_NA);\n                            offset += chancount;\n                        }\n                    } else {\n                        /* This might not work but try and display as string */\n                        /* Something wrong with channel count so just show it as a simple string */\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_energy_list, tvb, offset, tlv_len, ENC_NA);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_DISCOVERY_REQUEST:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_discovery_req_ver, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_discovery_req_j, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            case THREAD_MC_TLV_DISCOVERY_RESPONSE:\n                {\n                    /* Check length is consistent */\n                    if (tlv_len != 2) {\n                        expert_add_info(pinfo, proto_root, &ei_thread_mc_len_size_mismatch);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                    } else {\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_discovery_rsp_ver, tvb, offset, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_discovery_rsp_n, tvb, offset, 1, ENC_BIG_ENDIAN);\n                    }\n                    offset += tlv_len;\n                }\n                break;\n\n            default:\n                proto_tree_add_item(tlv_tree, hf_thread_mc_tlv_unknown, tvb, offset, tlv_len, ENC_NA);\n                offset += tlv_len;\n        }\n    }\n    return tvb_captured_length(tvb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -522,8 +522,8 @@\n                     int i;\n                     guint8 entries = 0;\n                     gint32 check_len = tlv_len;\n-                    guint8 check_offset = offset + 1; /* Channel page first */\n-                    guint8 masklen;\n+                    gint check_offset = offset + 1; /* Channel page first */\n+                    guint16 masklen;\n \n                     /* Check consistency of entries */\n                     while (check_len > 0) {",
        "diff_line_info": {
            "deleted_lines": [
                "                    guint8 check_offset = offset + 1; /* Channel page first */",
                "                    guint8 masklen;"
            ],
            "added_lines": [
                "                    gint check_offset = offset + 1; /* Channel page first */",
                "                    guint16 masklen;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7331",
        "func_name": "wireshark/try_dissect_unknown_ber",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-ber.c had an infinite loop that was addressed by validating a length.",
        "git_url": "https://github.com/wireshark/wireshark/commit/157712b2f5f89b19ef2497ea89c5938eb29529da",
        "commit_title": "BER: Add a length check.",
        "commit_text": " Add a common large length reporting function. Add a length check to dissect_ber_set.  Bug: 14444.",
        "func_before": "static int\ntry_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, gint nest_level)\n{\n    int                start_offset;\n    gint8              ber_class;\n    gboolean           pc, ind;\n    gint32             tag;\n    guint32            len;\n    int                hdr_len;\n    proto_item        *item      = NULL;\n    proto_tree        *next_tree = NULL;\n    guint8             c;\n    guint32            i;\n    gboolean           is_printable;\n    volatile gboolean  is_decoded_as;\n    proto_item        *pi, *cause;\n    asn1_ctx_t         asn1_ctx;\n\n    if (nest_level > BER_MAX_NESTING) {\n        /* Assume that we have a malformed packet. */\n        THROW(ReportedBoundsError);\n    }\n\n    start_offset = offset;\n    asn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo);\n\n    offset = get_ber_identifier(tvb, offset, &ber_class, &pc, &tag);\n    offset = get_ber_length(tvb, offset, &len, &ind);\n\n    if (len > (guint32)tvb_reported_length_remaining(tvb, offset)) {\n        /* hmm   maybe something bad happened or the frame is short;\n           since these are not vital outputs just return instead of\n           throwing an exception.\n         */\n\n        if (show_internal_ber_fields) {\n            offset = dissect_ber_identifier(pinfo, tree, tvb, start_offset, &ber_class, &pc, &tag);\n            offset = dissect_ber_length(pinfo, tree, tvb, offset, &len, NULL);\n        }\n        cause = proto_tree_add_string_format_value(\n            tree, hf_ber_error, tvb, offset, len, \"illegal_length\",\n            \"length:%u longer than tvb_reported_length_remaining:%d\",\n            len,\n            tvb_reported_length_remaining(tvb, offset));\n        expert_add_info(pinfo, cause, &ei_ber_error_length);\n        return tvb_reported_length(tvb);\n    }\n/* we don't care about the class only on the constructor flag */\n    switch (pc) {\n\n    case FALSE: /* this is not constructed */\n\n        switch (ber_class) { /* we do care about the class */\n        case BER_CLASS_UNI: /* it a Universal tag - we can decode it */\n            switch (tag) {\n            case BER_UNI_TAG_EOC:\n                /* XXX: shouldn't really get here */\n                break;\n            case BER_UNI_TAG_INTEGER:\n                offset = dissect_ber_integer(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_INTEGER, NULL);\n                break;\n            case BER_UNI_TAG_REAL:\n                offset = dissect_ber_real(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_REAL, NULL);\n                break;\n            case BER_UNI_TAG_BITSTRING:\n                offset = dissect_ber_bitstring(FALSE, &asn1_ctx, tree, tvb, start_offset, NULL, hf_ber_unknown_BITSTRING, -1, NULL);\n                break;\n            case BER_UNI_TAG_ENUMERATED:\n                offset = dissect_ber_integer(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_ENUMERATED, NULL);\n                break;\n            case BER_UNI_TAG_GraphicString:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GraphicString, NULL);\n                break;\n            case BER_UNI_TAG_OCTETSTRING:\n                is_decoded_as = FALSE;\n                if (decode_octetstring_as_ber && (len >= 2)) {\n                    volatile int ber_offset = 0;\n                    guint32 ber_len = 0;\n                    TRY {\n                        ber_offset = get_ber_identifier(tvb, offset, NULL, &pc, NULL);\n                        ber_offset = get_ber_length(tvb, ber_offset, &ber_len, NULL);\n                    } CATCH_ALL {\n                    }\n                    ENDTRY;\n                    if (pc && (ber_len > 0) && (ber_len + (ber_offset - offset) == len)) {\n                        /* Decoded a constructed ASN.1 tag with a length indicating this\n                         * could be BER encoded data.  Try dissecting as unknown BER.\n                         */\n                        is_decoded_as = TRUE;\n                        if (show_internal_ber_fields) {\n                            offset = dissect_ber_identifier(pinfo, tree, tvb, start_offset, NULL, NULL, NULL);\n                            offset = dissect_ber_length(pinfo, tree, tvb, offset, NULL, NULL);\n                        }\n                        item = ber_proto_tree_add_item(pinfo, tree, hf_ber_unknown_BER_OCTETSTRING, tvb, offset, len, ENC_NA);\n                        next_tree = proto_item_add_subtree(item, ett_ber_octet_string);\n                        offset = try_dissect_unknown_ber(pinfo, tvb, offset, next_tree, nest_level+1);\n                    }\n                }\n                if (!is_decoded_as) {\n                    offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_OCTETSTRING, NULL);\n                }\n                break;\n            case BER_UNI_TAG_OID:\n                offset = dissect_ber_object_identifier_str(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_OID, NULL);\n                break;\n            case BER_UNI_TAG_RELATIVE_OID:\n                offset = dissect_ber_relative_oid_str(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_relative_OID, NULL);\n                break;\n            case BER_UNI_TAG_NumericString:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_NumericString, NULL);\n                break;\n            case BER_UNI_TAG_PrintableString:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_PrintableString, NULL);\n                break;\n            case BER_UNI_TAG_TeletexString:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_TeletexString, NULL);\n                break;\n            case BER_UNI_TAG_VisibleString:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_VisibleString, NULL);\n                break;\n            case BER_UNI_TAG_GeneralString:\n                offset = dissect_ber_GeneralString(&asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GeneralString, NULL, 0);\n                break;\n            case BER_UNI_TAG_BMPString:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_BMPString, NULL);\n                break;\n            case BER_UNI_TAG_UniversalString:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_UniversalString, NULL);\n                break;\n            case BER_UNI_TAG_IA5String:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_IA5String, NULL);\n                break;\n            case BER_UNI_TAG_UTCTime:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_UTCTime, NULL);\n                break;\n            case BER_UNI_TAG_NULL:\n                proto_tree_add_item(tree, hf_ber_null_tag, tvb, offset, len, ENC_NA);\n                break;\n            case BER_UNI_TAG_UTF8String:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_UTF8String, NULL);\n                break;\n            case BER_UNI_TAG_GeneralizedTime:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GeneralizedTime, NULL);\n                break;\n            case BER_UNI_TAG_BOOLEAN:\n                offset = dissect_ber_boolean(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_BOOLEAN, NULL);\n                break;\n            default:\n                offset = dissect_ber_identifier(pinfo, tree, tvb, start_offset, &ber_class, &pc, &tag);\n                offset = dissect_ber_length(pinfo, tree, tvb, offset, &len, NULL);\n                cause = proto_tree_add_string_format_value(\n                    tree, hf_ber_error, tvb, offset, len, \"unknown_universal_tag\",\n                    \"can not handle universal tag:%d\",\n                    tag);\n                expert_add_info(pinfo, cause, &ei_ber_universal_tag_unknown);\n                offset += len;\n            }\n            break;\n        case BER_CLASS_APP:\n        case BER_CLASS_CON:\n        case BER_CLASS_PRI:\n        default:\n            /* we dissect again if show_internal_ber_fields is set */\n            if (show_internal_ber_fields) {\n                offset = dissect_ber_identifier(pinfo, tree, tvb, start_offset, &ber_class, &pc, &tag);\n                offset = dissect_ber_length(pinfo, tree, tvb, offset, &len, NULL);\n            }\n\n            /* we can't dissect this directly as it is specific */\n            pi = proto_tree_add_none_format(tree, hf_ber_unknown_BER_primitive, tvb, offset, len,\n                                            \"[%s %d] \", val_to_str_const(ber_class, ber_class_codes, \"Unknown\"), tag);\n\n            is_decoded_as = FALSE;\n            if (decode_primitive_as_ber && (len >= 2)) {\n                volatile int ber_offset = 0;\n                guint32 ber_len = 0;\n                TRY {\n                    ber_offset = get_ber_identifier(tvb, offset, NULL, &pc, NULL);\n                    ber_offset = get_ber_length(tvb, ber_offset, &ber_len, NULL);\n                } CATCH_ALL {\n                }\n                ENDTRY;\n                if (pc && (ber_len > 0) && (ber_len + (ber_offset - offset) == len)) {\n                    /* Decoded a constructed ASN.1 tag with a length indicating this\n                     * could be BER encoded data.  Try dissecting as unknown BER.\n                     */\n                    is_decoded_as = TRUE;\n                    proto_item_append_text (pi, \"[BER encoded]\");\n                    next_tree = proto_item_add_subtree(pi, ett_ber_primitive);\n                    offset = try_dissect_unknown_ber(pinfo, tvb, offset, next_tree, nest_level+1);\n                }\n            }\n\n            if (!is_decoded_as && len) {\n                /* we may want to do better and show the bytes */\n                is_printable = TRUE;\n                for (i=0; i<len; i++) {\n                    c = tvb_get_guint8(tvb, offset+i);\n\n                    if (is_printable && !g_ascii_isprint(c))\n                        is_printable = FALSE;\n\n                    proto_item_append_text(pi, \"%02x\", c);\n                }\n\n                if (is_printable) { /* give a nicer representation if it looks like a string */\n                    proto_item_append_text(pi, \" (\");\n                    for (i=0; i<len; i++) {\n                        proto_item_append_text(pi, \"%c\", tvb_get_guint8(tvb, offset+i));\n                    }\n                    proto_item_append_text(pi, \")\");\n                }\n                offset += len;\n            }\n\n            break;\n        }",
        "func": "static int\ntry_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, gint nest_level)\n{\n    int                start_offset;\n    gint8              ber_class;\n    gboolean           pc, ind;\n    gint32             tag;\n    guint32            len;\n    int                hdr_len;\n    proto_item        *item      = NULL;\n    proto_tree        *next_tree = NULL;\n    guint8             c;\n    guint32            i;\n    gboolean           is_printable;\n    volatile gboolean  is_decoded_as;\n    proto_item        *pi, *cause;\n    asn1_ctx_t         asn1_ctx;\n\n    if (nest_level > BER_MAX_NESTING) {\n        /* Assume that we have a malformed packet. */\n        THROW(ReportedBoundsError);\n    }\n\n    start_offset = offset;\n    asn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo);\n\n    offset = get_ber_identifier(tvb, offset, &ber_class, &pc, &tag);\n    offset = get_ber_length(tvb, offset, &len, &ind);\n\n    if (len > (guint32)tvb_reported_length_remaining(tvb, offset)) {\n        /* hmm   maybe something bad happened or the frame is short;\n           since these are not vital outputs just return instead of\n           throwing an exception.\n         */\n\n        if (show_internal_ber_fields) {\n            offset = dissect_ber_identifier(pinfo, tree, tvb, start_offset, &ber_class, &pc, &tag);\n            offset = dissect_ber_length(pinfo, tree, tvb, offset, &len, NULL);\n        }\n        ber_add_large_length_error(pinfo, tree, tvb, offset, len);\n        return tvb_reported_length(tvb);\n    }\n/* we don't care about the class only on the constructor flag */\n    switch (pc) {\n\n    case FALSE: /* this is not constructed */\n\n        switch (ber_class) { /* we do care about the class */\n        case BER_CLASS_UNI: /* it a Universal tag - we can decode it */\n            switch (tag) {\n            case BER_UNI_TAG_EOC:\n                /* XXX: shouldn't really get here */\n                break;\n            case BER_UNI_TAG_INTEGER:\n                offset = dissect_ber_integer(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_INTEGER, NULL);\n                break;\n            case BER_UNI_TAG_REAL:\n                offset = dissect_ber_real(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_REAL, NULL);\n                break;\n            case BER_UNI_TAG_BITSTRING:\n                offset = dissect_ber_bitstring(FALSE, &asn1_ctx, tree, tvb, start_offset, NULL, hf_ber_unknown_BITSTRING, -1, NULL);\n                break;\n            case BER_UNI_TAG_ENUMERATED:\n                offset = dissect_ber_integer(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_ENUMERATED, NULL);\n                break;\n            case BER_UNI_TAG_GraphicString:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GraphicString, NULL);\n                break;\n            case BER_UNI_TAG_OCTETSTRING:\n                is_decoded_as = FALSE;\n                if (decode_octetstring_as_ber && (len >= 2)) {\n                    volatile int ber_offset = 0;\n                    guint32 ber_len = 0;\n                    TRY {\n                        ber_offset = get_ber_identifier(tvb, offset, NULL, &pc, NULL);\n                        ber_offset = get_ber_length(tvb, ber_offset, &ber_len, NULL);\n                    } CATCH_ALL {\n                    }\n                    ENDTRY;\n                    if (pc && (ber_len > 0) && (ber_len + (ber_offset - offset) == len)) {\n                        /* Decoded a constructed ASN.1 tag with a length indicating this\n                         * could be BER encoded data.  Try dissecting as unknown BER.\n                         */\n                        is_decoded_as = TRUE;\n                        if (show_internal_ber_fields) {\n                            offset = dissect_ber_identifier(pinfo, tree, tvb, start_offset, NULL, NULL, NULL);\n                            offset = dissect_ber_length(pinfo, tree, tvb, offset, NULL, NULL);\n                        }\n                        item = ber_proto_tree_add_item(pinfo, tree, hf_ber_unknown_BER_OCTETSTRING, tvb, offset, len, ENC_NA);\n                        next_tree = proto_item_add_subtree(item, ett_ber_octet_string);\n                        offset = try_dissect_unknown_ber(pinfo, tvb, offset, next_tree, nest_level+1);\n                    }\n                }\n                if (!is_decoded_as) {\n                    offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_OCTETSTRING, NULL);\n                }\n                break;\n            case BER_UNI_TAG_OID:\n                offset = dissect_ber_object_identifier_str(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_OID, NULL);\n                break;\n            case BER_UNI_TAG_RELATIVE_OID:\n                offset = dissect_ber_relative_oid_str(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_relative_OID, NULL);\n                break;\n            case BER_UNI_TAG_NumericString:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_NumericString, NULL);\n                break;\n            case BER_UNI_TAG_PrintableString:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_PrintableString, NULL);\n                break;\n            case BER_UNI_TAG_TeletexString:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_TeletexString, NULL);\n                break;\n            case BER_UNI_TAG_VisibleString:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_VisibleString, NULL);\n                break;\n            case BER_UNI_TAG_GeneralString:\n                offset = dissect_ber_GeneralString(&asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GeneralString, NULL, 0);\n                break;\n            case BER_UNI_TAG_BMPString:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_BMPString, NULL);\n                break;\n            case BER_UNI_TAG_UniversalString:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_UniversalString, NULL);\n                break;\n            case BER_UNI_TAG_IA5String:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_IA5String, NULL);\n                break;\n            case BER_UNI_TAG_UTCTime:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_UTCTime, NULL);\n                break;\n            case BER_UNI_TAG_NULL:\n                proto_tree_add_item(tree, hf_ber_null_tag, tvb, offset, len, ENC_NA);\n                break;\n            case BER_UNI_TAG_UTF8String:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_UTF8String, NULL);\n                break;\n            case BER_UNI_TAG_GeneralizedTime:\n                offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GeneralizedTime, NULL);\n                break;\n            case BER_UNI_TAG_BOOLEAN:\n                offset = dissect_ber_boolean(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_BOOLEAN, NULL);\n                break;\n            default:\n                offset = dissect_ber_identifier(pinfo, tree, tvb, start_offset, &ber_class, &pc, &tag);\n                offset = dissect_ber_length(pinfo, tree, tvb, offset, &len, NULL);\n                cause = proto_tree_add_string_format_value(\n                    tree, hf_ber_error, tvb, offset, len, \"unknown_universal_tag\",\n                    \"can not handle universal tag:%d\",\n                    tag);\n                expert_add_info(pinfo, cause, &ei_ber_universal_tag_unknown);\n                offset += len;\n            }\n            break;\n        case BER_CLASS_APP:\n        case BER_CLASS_CON:\n        case BER_CLASS_PRI:\n        default:\n            /* we dissect again if show_internal_ber_fields is set */\n            if (show_internal_ber_fields) {\n                offset = dissect_ber_identifier(pinfo, tree, tvb, start_offset, &ber_class, &pc, &tag);\n                offset = dissect_ber_length(pinfo, tree, tvb, offset, &len, NULL);\n            }\n\n            /* we can't dissect this directly as it is specific */\n            pi = proto_tree_add_none_format(tree, hf_ber_unknown_BER_primitive, tvb, offset, len,\n                                            \"[%s %d] \", val_to_str_const(ber_class, ber_class_codes, \"Unknown\"), tag);\n\n            is_decoded_as = FALSE;\n            if (decode_primitive_as_ber && (len >= 2)) {\n                volatile int ber_offset = 0;\n                guint32 ber_len = 0;\n                TRY {\n                    ber_offset = get_ber_identifier(tvb, offset, NULL, &pc, NULL);\n                    ber_offset = get_ber_length(tvb, ber_offset, &ber_len, NULL);\n                } CATCH_ALL {\n                }\n                ENDTRY;\n                if (pc && (ber_len > 0) && (ber_len + (ber_offset - offset) == len)) {\n                    /* Decoded a constructed ASN.1 tag with a length indicating this\n                     * could be BER encoded data.  Try dissecting as unknown BER.\n                     */\n                    is_decoded_as = TRUE;\n                    proto_item_append_text (pi, \"[BER encoded]\");\n                    next_tree = proto_item_add_subtree(pi, ett_ber_primitive);\n                    offset = try_dissect_unknown_ber(pinfo, tvb, offset, next_tree, nest_level+1);\n                }\n            }\n\n            if (!is_decoded_as && len) {\n                /* we may want to do better and show the bytes */\n                is_printable = TRUE;\n                for (i=0; i<len; i++) {\n                    c = tvb_get_guint8(tvb, offset+i);\n\n                    if (is_printable && !g_ascii_isprint(c))\n                        is_printable = FALSE;\n\n                    proto_item_append_text(pi, \"%02x\", c);\n                }\n\n                if (is_printable) { /* give a nicer representation if it looks like a string */\n                    proto_item_append_text(pi, \" (\");\n                    for (i=0; i<len; i++) {\n                        proto_item_append_text(pi, \"%c\", tvb_get_guint8(tvb, offset+i));\n                    }\n                    proto_item_append_text(pi, \")\");\n                }\n                offset += len;\n            }\n\n            break;\n        }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -37,12 +37,7 @@\n             offset = dissect_ber_identifier(pinfo, tree, tvb, start_offset, &ber_class, &pc, &tag);\n             offset = dissect_ber_length(pinfo, tree, tvb, offset, &len, NULL);\n         }\n-        cause = proto_tree_add_string_format_value(\n-            tree, hf_ber_error, tvb, offset, len, \"illegal_length\",\n-            \"length:%u longer than tvb_reported_length_remaining:%d\",\n-            len,\n-            tvb_reported_length_remaining(tvb, offset));\n-        expert_add_info(pinfo, cause, &ei_ber_error_length);\n+        ber_add_large_length_error(pinfo, tree, tvb, offset, len);\n         return tvb_reported_length(tvb);\n     }\n /* we don't care about the class only on the constructor flag */",
        "diff_line_info": {
            "deleted_lines": [
                "        cause = proto_tree_add_string_format_value(",
                "            tree, hf_ber_error, tvb, offset, len, \"illegal_length\",",
                "            \"length:%u longer than tvb_reported_length_remaining:%d\",",
                "            len,",
                "            tvb_reported_length_remaining(tvb, offset));",
                "        expert_add_info(pinfo, cause, &ei_ber_error_length);"
            ],
            "added_lines": [
                "        ber_add_large_length_error(pinfo, tree, tvb, offset, len);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7332",
        "func_name": "wireshark/dissect_statans",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-reload.c had an infinite loop that was addressed by validating a length.",
        "git_url": "https://github.com/wireshark/wireshark/commit/1ab0585098c7ce20f3afceb6730427cc2a1e98ea",
        "commit_title": "RELOAD: Fix a length check.",
        "commit_text": " Make sure a length value isn't too large.  Bug: 14445 (cherry picked from commit a806389e50abdbbb5dbdd2071c04ad73beaaadf9)",
        "func_before": "static int\ndissect_statans(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint16 offset, guint16 length)\n{\n  proto_item *ti_statans;\n  proto_tree *statans_tree;\n  guint32     kind_responses_length;\n  guint32     kind_responses_offset = 0;\n  int         nResponses            = 0;\n\n  kind_responses_length = tvb_get_ntohl(tvb, offset);\n\n  if (4 + kind_responses_length > length) {\n    ti_statans = proto_tree_add_item(tree, hf_reload_statans, tvb, offset, length, ENC_NA);\n    expert_add_info_format(pinfo, ti_statans, &ei_reload_truncated_field, \"Truncated StatAns\");\n    return length;\n  }\n  ti_statans = proto_tree_add_item(tree, hf_reload_statans, tvb, offset, 4 + kind_responses_length, ENC_NA);\n  proto_item_append_text(ti_statans, \" (StatKindResponse<%d>)\", kind_responses_length);\n  statans_tree = proto_item_add_subtree(ti_statans, ett_reload_statans);\n\n  proto_tree_add_uint(statans_tree, hf_reload_length_uint32, tvb, offset, 4, kind_responses_length);\n\n\n  while (kind_responses_offset < kind_responses_length) {\n    guint32 kind_responses_increment;\n    kind_responses_increment = dissect_kinddata(tvb, pinfo, statans_tree, offset + 4 + kind_responses_offset, kind_responses_length - kind_responses_offset, TRUE);\n    if (kind_responses_increment == 0) {\n      break;\n    }\n    nResponses++;\n    kind_responses_offset += kind_responses_increment;\n  }\n\n  proto_item_append_text(ti_statans, \": %d elements\", nResponses);\n\n  return 4 + kind_responses_length;\n}",
        "func": "static int\ndissect_statans(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint16 offset, guint16 length)\n{\n  proto_item *ti_statans;\n  proto_tree *statans_tree;\n  guint32     kind_responses_length;\n  guint32     kind_responses_offset = 0;\n  int         nResponses            = 0;\n\n  kind_responses_length = tvb_get_ntohl(tvb, offset);\n\n  if (kind_responses_length > G_MAXUINT16 || 4 + kind_responses_length > length) {\n    ti_statans = proto_tree_add_item(tree, hf_reload_statans, tvb, offset, length, ENC_NA);\n    expert_add_info_format(pinfo, ti_statans, &ei_reload_truncated_field, \"Truncated StatAns\");\n    return length;\n  }\n  ti_statans = proto_tree_add_item(tree, hf_reload_statans, tvb, offset, 4 + kind_responses_length, ENC_NA);\n  proto_item_append_text(ti_statans, \" (StatKindResponse<%d>)\", kind_responses_length);\n  statans_tree = proto_item_add_subtree(ti_statans, ett_reload_statans);\n\n  proto_tree_add_uint(statans_tree, hf_reload_length_uint32, tvb, offset, 4, kind_responses_length);\n\n\n  while (kind_responses_offset < kind_responses_length) {\n    guint32 kind_responses_increment;\n    kind_responses_increment = dissect_kinddata(tvb, pinfo, statans_tree, offset + 4 + kind_responses_offset, kind_responses_length - kind_responses_offset, TRUE);\n    if (kind_responses_increment == 0) {\n      break;\n    }\n    nResponses++;\n    kind_responses_offset += kind_responses_increment;\n  }\n\n  proto_item_append_text(ti_statans, \": %d elements\", nResponses);\n\n  return 4 + kind_responses_length;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,7 @@\n \n   kind_responses_length = tvb_get_ntohl(tvb, offset);\n \n-  if (4 + kind_responses_length > length) {\n+  if (kind_responses_length > G_MAXUINT16 || 4 + kind_responses_length > length) {\n     ti_statans = proto_tree_add_item(tree, hf_reload_statans, tvb, offset, length, ENC_NA);\n     expert_add_info_format(pinfo, ti_statans, &ei_reload_truncated_field, \"Truncated StatAns\");\n     return length;",
        "diff_line_info": {
            "deleted_lines": [
                "  if (4 + kind_responses_length > length) {"
            ],
            "added_lines": [
                "  if (kind_responses_length > G_MAXUINT16 || 4 + kind_responses_length > length) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7333",
        "func_name": "wireshark/get_write_list_chunk_count",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-rpcrdma.c had an infinite loop that was addressed by validating a chunk size.",
        "git_url": "https://github.com/wireshark/wireshark/commit/bd6313181317bfe83842b27650b65f3c2b8d5dc9",
        "commit_title": "RPCoRDMA: Set an upper bound for our chunk size.",
        "commit_text": " Make sure our write chunk size doesn't exceed our tvbuff. Adjust a few length checks.  Bug: 14449",
        "func_before": "static guint get_write_list_chunk_count(tvbuff_t *tvb, guint offset)\n{\n    guint32 value_follows;\n    guint num_chunks, chunk_size;\n\n    num_chunks = 0;\n    while (1) {\n        value_follows = tvb_get_ntohl(tvb, offset);\n        offset += 4;\n        if (!value_follows)\n            break;\n\n        num_chunks++;\n        chunk_size = get_write_chunk_size(tvb, offset);\n        if ((offset + chunk_size) < offset)\n            break;\n    }\n\n   return num_chunks;\n}",
        "func": "static guint get_write_list_chunk_count(tvbuff_t *tvb, guint offset)\n{\n    guint32 value_follows;\n    guint num_chunks, chunk_size;\n\n    num_chunks = 0;\n    while (1) {\n        value_follows = tvb_get_ntohl(tvb, offset);\n        offset += 4;\n        if (!value_follows)\n            break;\n\n        num_chunks++;\n        chunk_size = get_write_chunk_size(tvb, offset);\n        if (chunk_size == 0)\n            break;\n    }\n\n   return num_chunks;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,7 @@\n \n         num_chunks++;\n         chunk_size = get_write_chunk_size(tvb, offset);\n-        if ((offset + chunk_size) < offset)\n+        if (chunk_size == 0)\n             break;\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "        if ((offset + chunk_size) < offset)"
            ],
            "added_lines": [
                "        if (chunk_size == 0)"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7333",
        "func_name": "wireshark/get_write_chunk_size",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-rpcrdma.c had an infinite loop that was addressed by validating a chunk size.",
        "git_url": "https://github.com/wireshark/wireshark/commit/bd6313181317bfe83842b27650b65f3c2b8d5dc9",
        "commit_title": "RPCoRDMA: Set an upper bound for our chunk size.",
        "commit_text": " Make sure our write chunk size doesn't exceed our tvbuff. Adjust a few length checks.  Bug: 14449",
        "func_before": "static guint get_write_chunk_size(tvbuff_t *tvb, guint offset)\n{\n    guint segment_count;\n\n    segment_count = tvb_get_ntohl(tvb, offset);\n    return 4 + (segment_count * 16);\n}",
        "func": "static guint get_write_chunk_size(tvbuff_t *tvb, guint offset)\n{\n    guint segment_count;\n    guint max_count = (guint)tvb_reported_length_remaining(tvb, offset + 4) / 16;\n\n    segment_count = tvb_get_ntohl(tvb, offset);\n    if (segment_count > max_count) {\n        /* XXX We should throw an exception here. */\n        segment_count = max_count;\n    }\n    return 4 + (segment_count * 16);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,12 @@\n static guint get_write_chunk_size(tvbuff_t *tvb, guint offset)\n {\n     guint segment_count;\n+    guint max_count = (guint)tvb_reported_length_remaining(tvb, offset + 4) / 16;\n \n     segment_count = tvb_get_ntohl(tvb, offset);\n+    if (segment_count > max_count) {\n+        /* XXX We should throw an exception here. */\n+        segment_count = max_count;\n+    }\n     return 4 + (segment_count * 16);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    guint max_count = (guint)tvb_reported_length_remaining(tvb, offset + 4) / 16;",
                "    if (segment_count > max_count) {",
                "        /* XXX We should throw an exception here. */",
                "        segment_count = max_count;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7333",
        "func_name": "wireshark/get_write_list_size",
        "description": "In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-rpcrdma.c had an infinite loop that was addressed by validating a chunk size.",
        "git_url": "https://github.com/wireshark/wireshark/commit/bd6313181317bfe83842b27650b65f3c2b8d5dc9",
        "commit_title": "RPCoRDMA: Set an upper bound for our chunk size.",
        "commit_text": " Make sure our write chunk size doesn't exceed our tvbuff. Adjust a few length checks.  Bug: 14449",
        "func_before": "static guint get_write_list_size(tvbuff_t *tvb, guint max_offset, guint offset)\n{\n    guint32 value_follows;\n    guint chunk_size, start = offset;\n\n    while (1) {\n        value_follows = tvb_get_ntohl(tvb, offset);\n        offset += 4;\n        if (offset > max_offset)\n            return 0;\n        if (!value_follows)\n            break;\n\n        chunk_size = get_write_chunk_size(tvb, offset);\n        if ((offset + chunk_size) < offset ||\n            (offset + chunk_size) > max_offset)\n            return 0;\n        offset += chunk_size;\n    }\n\n    return offset - start;\n}",
        "func": "static guint get_write_list_size(tvbuff_t *tvb, guint max_offset, guint offset)\n{\n    guint32 value_follows;\n    guint chunk_size, start = offset;\n\n    while (1) {\n        value_follows = tvb_get_ntohl(tvb, offset);\n        offset += 4;\n        if (offset > max_offset)\n            return 0;\n        if (!value_follows)\n            break;\n\n        chunk_size = get_write_chunk_size(tvb, offset);\n        if ((offset > max_offset) ||\n            (max_offset - offset < chunk_size))\n            return 0;\n        offset += chunk_size;\n    }\n\n    return offset - start;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,8 +12,8 @@\n             break;\n \n         chunk_size = get_write_chunk_size(tvb, offset);\n-        if ((offset + chunk_size) < offset ||\n-            (offset + chunk_size) > max_offset)\n+        if ((offset > max_offset) ||\n+            (max_offset - offset < chunk_size))\n             return 0;\n         offset += chunk_size;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "        if ((offset + chunk_size) < offset ||",
                "            (offset + chunk_size) > max_offset)"
            ],
            "added_lines": [
                "        if ((offset > max_offset) ||",
                "            (max_offset - offset < chunk_size))"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7421",
        "func_name": "wireshark/dissect_dmp_content",
        "description": "In Wireshark 2.2.0 to 2.2.12 and 2.4.0 to 2.4.4, the DMP dissector could go into an infinite loop. This was addressed in epan/dissectors/packet-dmp.c by correctly supporting a bounded number of Security Categories for a DMP Security Classification.",
        "git_url": "https://github.com/wireshark/wireshark/commit/e8be5adae469ba563acfad2c2b98673e1afaf901",
        "commit_title": "DMP: Recurse only once.",
        "commit_text": " Make sure we call dissect_dmp_security_category from itself only once.  Bug: 14408",
        "func_before": "static gint dissect_dmp_content (tvbuff_t *tvb, packet_info *pinfo,\n                                 proto_tree *dmp_tree, gint offset)\n{\n  proto_tree *message_tree = NULL;\n  proto_tree *field_tree = NULL;\n  proto_item *en = NULL, *ei = NULL, *tf = NULL;\n  proto_item *hidden_item;\n  const char  *label_string = wmem_strdup (wmem_packet_scope(), \"\");\n  const gchar *class_name = NULL;\n  guint8      message, dmp_sec_pol, dmp_sec_class, dmp_nation = 0, exp_time, dtg;\n  gint32      secs = 0;\n  guint       prev_rec_no = 0;\n  gint        rep_len, rep_no = 1;\n  gint        loffset, boffset = offset;\n\n  if (dmp.msg_type == REPORT) {\n    en = proto_tree_add_item (dmp_tree, hf_report_content, tvb, offset, 7, ENC_NA);\n  } else if (dmp.msg_type == NOTIF) {\n    en = proto_tree_add_item (dmp_tree, hf_notif_content, tvb, offset, 7, ENC_NA);\n  } else {\n    en = proto_tree_add_item (dmp_tree, hf_message_content, tvb, offset, 7, ENC_NA);\n  }\n  message_tree = proto_item_add_subtree (en, ett_content);\n\n  if (dmp.msg_type == STANAG || dmp.msg_type == IPM) {\n    message = tvb_get_guint8 (tvb, offset);\n    dmp.body_format = (message & 0x03);\n\n    if (dmp.msg_type == STANAG) {\n      /* Message Type */\n      dmp.st_type = (message & 0xC0) >> 6;\n      tf = proto_tree_add_uint_format (message_tree, hf_message_st_type,\n                                       tvb, offset, 1, message,\n                                       \"Message Type: %s (%d)\",\n                                       val_to_str_const (dmp.st_type,\n                                                         message_type_vals, \"\"),\n                                       dmp.st_type);\n      field_tree = proto_item_add_subtree (tf, ett_message_st_type);\n      proto_tree_add_item (field_tree, hf_message_st_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n      if ((message & 0x20) >> 5) {\n        /* Reserved */\n        tf = proto_tree_add_uint_format (message_tree, hf_reserved_0x20,\n                                         tvb, offset, 1, message,\n                                         \"Reserved: %d\", (message & 0x20)>>5);\n        field_tree = proto_item_add_subtree (tf, ett_message_reserved);\n        tf = proto_tree_add_item (field_tree, hf_reserved_0x20, tvb, offset, 1, ENC_BIG_ENDIAN);\n        expert_add_info(pinfo, tf, &ei_reserved_value);\n      }\n\n      /* Precedence */\n      dmp.prec = (message & 0x1C) >> 2;\n      tf = proto_tree_add_uint_format (message_tree, hf_message_precedence,\n                                       tvb, offset, 1, message,\n                                       \"Precedence: %s (%d)\",\n                                       val_to_str_const (dmp.prec, precedence, \"\"),\n                                       dmp.prec);\n      field_tree = proto_item_add_subtree (tf, ett_message_precedence);\n      proto_tree_add_item (field_tree, hf_message_precedence, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    } else {\n      if ((message & 0xE0) >> 5) {\n        /* Reserved */\n        tf = proto_tree_add_uint_format (message_tree, hf_reserved_0xE0,\n                                         tvb, offset, 1, message,\n                                         \"Reserved: %d\", (message & 0xE0)>>5);\n        field_tree = proto_item_add_subtree (tf, ett_message_reserved);\n        tf = proto_tree_add_item (field_tree, hf_reserved_0xE0, tvb, offset, 1, ENC_BIG_ENDIAN);\n        expert_add_info(pinfo, tf, &ei_reserved_value);\n      }\n\n      /* Importance */\n      dmp.prec = (message & 0x1C) >> 2;\n      tf = proto_tree_add_uint_format (message_tree, hf_message_importance,\n                                       tvb, offset, 1, message,\n                                       \"Importance: %s (%d)\",\n                                       val_to_str_const (dmp.prec, importance, \"\"),\n                                       dmp.prec);\n      field_tree = proto_item_add_subtree (tf, ett_message_importance);\n      proto_tree_add_item (field_tree, hf_message_importance, tvb, offset, 1, ENC_BIG_ENDIAN);\n    }\n\n    /* Body Format */\n    tf = proto_tree_add_uint_format (message_tree, hf_message_body_format,\n                                     tvb, offset, 1, message,\n                                     \"Body Format: %s (%d)\",\n                                     val_to_str_const (message & 0x03,\n                                                       body_format_vals, \"\"),\n                                     message & 0x03);\n    field_tree = proto_item_add_subtree (tf, ett_message_body_format);\n    proto_tree_add_item (field_tree, hf_message_body_format, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n  }\n\n  message = tvb_get_guint8 (tvb, offset);\n  /* Security Classification */\n  dmp_sec_class = (message & 0xE0) >> 5;\n  dmp_sec_pol = (message & 0x1C) >> 2;\n  if (dmp_sec_pol == EXTENDED_NATIONAL) {\n    dmp_nation = tvb_get_guint8 (tvb, offset + 1);\n  }\n\n  loffset = offset; /* Offset to start of security label */\n  if (dmp_sec_pol == NATIONAL && dmp_local_nation != 0) {\n    class_name = dmp_national_sec_class (dmp_local_nation, dmp_sec_class);\n  } else if (dmp_sec_pol == EXTENDED_NATIONAL) {\n    class_name = dmp_national_sec_class (dmp_nation, dmp_sec_class);\n  }\n  if ((dmp_sec_pol == NATO || dmp_sec_pol == NATIONAL) && !class_name) {\n    class_name = val_to_str_const (dmp_sec_class, sec_class, \"\");\n  }\n  if (class_name && class_name[0]) {\n    tf = proto_tree_add_uint_format (message_tree, hf_message_sec_class_val,\n                                     tvb, offset, 1, message,\n                                     \"Security Classification: %s (%d)\",\n                                     class_name, dmp_sec_class);\n  } else {\n    tf = proto_tree_add_uint_format (message_tree, hf_message_sec_class_val,\n                                     tvb, offset, 1, message,\n                                     \"Security Classification: %d\",\n                                     dmp_sec_class);\n  }\n  field_tree = proto_item_add_subtree (tf, ett_message_sec_class);\n  tf = proto_tree_add_item (field_tree, hf_message_sec_class_val, tvb, offset, 1, ENC_BIG_ENDIAN);\n  if (class_name) {\n    proto_item_append_text (tf, \" (%s)\", class_name);\n    label_string = wmem_strconcat(wmem_packet_scope(), label_string, class_name, NULL);\n  }\n\n  /* Security Policy */\n  tf = proto_tree_add_uint_format (message_tree, hf_message_sec_pol,\n                                   tvb, offset, 1, message,\n                                   \"Security Policy: %s (%d)\",\n                                   val_to_str (dmp_sec_pol, sec_pol, \"%d\"),\n                                   dmp_sec_pol);\n  field_tree = proto_item_add_subtree (tf, ett_message_sec_pol);\n  proto_tree_add_item (field_tree, hf_message_sec_pol, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n  if (dmp.msg_type == STANAG || dmp.msg_type == IPM) {\n    /* Heading Flags */\n    tf = proto_tree_add_item (message_tree, hf_message_heading_flags, tvb, offset, 1, ENC_NA);\n    field_tree = proto_item_add_subtree (tf, ett_message_heading_flags);\n    proto_tree_add_item (field_tree, hf_message_auth_users, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item (field_tree, hf_message_subject_disc, tvb, offset, 1, ENC_BIG_ENDIAN);\n    if (message & 0x03) {\n      proto_item_append_text (tf, \": %s%s%s discarded\",\n                              (message & 0x02) ? \"Authorizing users\" : \"\",\n                              (message & 0x03) == 0x03 ? \" and \" : \"\",\n                              (message & 0x01) ? \"Subject\" : \"\");\n    } else {\n      proto_item_append_text (tf, \" (none)\");\n    }\n  } else if (dmp.msg_type == NOTIF) {\n    /* Notification Type */\n    dmp.notif_type = (message & 0x03);\n    tf = proto_tree_add_uint_format (message_tree, hf_notif_type,\n                                     tvb, offset, 1, message,\n                                     \"Notification Type: %s\",\n                                     val_to_str_const (dmp.notif_type, notif_type,\n                                                       \"Reserved\"));\n    field_tree = proto_item_add_subtree (tf, ett_notif_type);\n    proto_tree_add_item (field_tree, hf_notif_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n  } else if (message & 0x02) {\n    /* Reserved */\n    tf = proto_tree_add_uint_format (message_tree, hf_reserved_0x02,\n                                     tvb, offset, 1, message,\n                                     \"Reserved: %d\", message & 0x02);\n    field_tree = proto_item_add_subtree (tf, ett_message_reserved);\n    tf = proto_tree_add_item (field_tree, hf_reserved_0x02, tvb, offset, 1, ENC_BIG_ENDIAN);\n    expert_add_info(pinfo, tf, &ei_reserved_value);\n  }\n  offset += 1;\n\n  if (dmp_sec_pol == NATIONAL && dmp_local_nation != 0) {\n    /* Show configured national policy */\n    tf = proto_tree_add_uint (message_tree, hf_message_national_policy_id,\n                              tvb, offset, 0, dmp_local_nation);\n    PROTO_ITEM_SET_GENERATED (tf);\n  } else if (dmp_sec_pol == EXTENDED_NATIONAL) {\n    /* National Policy Identifier */\n    proto_tree_add_item (message_tree, hf_message_national_policy_id, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n  } else if (dmp_sec_pol == EXTENDED_MISSION) {\n    /* Mission Policy Identifier */\n    message = tvb_get_guint8 (tvb, offset);\n    if (message == 0xFF) {\n      proto_tree_add_uint_format_value (message_tree, hf_message_mission_policy_id,\n                                        tvb, offset, 1, message,\n                                        \"Reserved (0xFF)\");\n    } else {\n      proto_tree_add_item (message_tree, hf_message_mission_policy_id, tvb, offset, 1, ENC_BIG_ENDIAN);\n    }\n    offset += 1;\n  }\n\n  /* Security Categories */\n  if (dmp_sec_pol == NATO || dmp_sec_pol == NATIONAL || dmp_sec_pol == EXTENDED_NATIONAL) {\n    offset = dissect_dmp_security_category (tvb, pinfo, message_tree, &label_string, offset, 0);\n    proto_item_append_text (en, \", Security Label: %s\", label_string);\n    tf = proto_tree_add_string (message_tree, hf_message_sec_label, tvb, loffset,\n                                offset - loffset + 1, label_string);\n    PROTO_ITEM_SET_GENERATED (tf);\n  } else {\n    tf = proto_tree_add_item (message_tree, hf_message_sec_cat_val, tvb, offset, 1, ENC_BIG_ENDIAN);\n    field_tree = proto_item_add_subtree (tf, ett_message_sec_cat);\n\n    proto_tree_add_item (field_tree, hf_message_sec_cat_bit7, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item (field_tree, hf_message_sec_cat_bit6, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item (field_tree, hf_message_sec_cat_bit5, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item (field_tree, hf_message_sec_cat_bit4, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item (field_tree, hf_message_sec_cat_bit3, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item (field_tree, hf_message_sec_cat_bit2, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item (field_tree, hf_message_sec_cat_bit1, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item (field_tree, hf_message_sec_cat_bit0, tvb, offset, 1, ENC_BIG_ENDIAN);\n  }\n  offset += 1;\n\n  if (dmp.msg_type == STANAG || dmp.msg_type == IPM) {\n    /* Expiry Time */\n    exp_time = tvb_get_guint8 (tvb, offset);\n    tf = proto_tree_add_uint_format (message_tree, hf_message_exp_time,\n                                     tvb, offset, 1, exp_time,\n                                     \"Expiry Time: \");\n    field_tree = proto_item_add_subtree (tf, ett_message_exp_time);\n    ei = proto_tree_add_item (field_tree, hf_message_exp_time_val, tvb, offset, 1, ENC_BIG_ENDIAN);\n    secs = dmp_dec_exp_time (exp_time);\n    if (secs == DMP_TIME_NOT_PRESENT) {\n      proto_item_append_text (tf, \"Not present\");\n      proto_item_append_text (ei, \" (not present)\");\n    } else if (secs == DMP_TIME_RESERVED) {\n      proto_item_append_text (tf, \"Reserved (0x%2.2x)\", exp_time);\n      proto_item_append_text (ei, \" (Reserved)\");\n    } else {\n      proto_item_append_text (tf, \"%s (%s)\", signed_time_secs_to_str(wmem_packet_scope(), secs),\n                              abs_time_secs_to_str (wmem_packet_scope(), dmp.subm_time + secs, ABSOLUTE_TIME_LOCAL, TRUE));\n      proto_item_append_text (ei, \" (%s from submission time)\", signed_time_secs_to_str(wmem_packet_scope(), secs));\n    }\n    offset += 1;\n  }\n\n  if (dmp.msg_type == STANAG) {\n    dtg = tvb_get_guint8 (tvb, offset);\n    tf = proto_tree_add_uint_format (message_tree, hf_message_dtg, tvb, offset, 1, dtg, \"DTG: \");\n    field_tree = proto_item_add_subtree (tf, ett_message_dtg);\n    proto_tree_add_item (field_tree, hf_message_dtg_sign, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item (field_tree, hf_message_dtg_val, tvb, offset, 1, ENC_BIG_ENDIAN);\n    secs = dmp_dec_dtg (dtg & 0x7F);\n    if (secs == DMP_TIME_NOT_PRESENT) {\n      proto_item_append_text (tf, \"Not present\");\n    } else if (secs == DMP_TIME_RESERVED) {\n      proto_item_append_text (tf, \"Reserved (0x%2.2x)\", dtg & 0x7F);\n    } else if (secs == 0) {\n      proto_item_append_text (tf, \"0 minutes in the %s (%s)\",\n                              (dtg & 0x80) ? dtg_sign.true_string :\n                              dtg_sign.false_string,\n                              abs_time_secs_to_str (wmem_packet_scope(), dmp.subm_time, ABSOLUTE_TIME_LOCAL, TRUE));\n    } else {\n      proto_item_append_text (tf, \"%s in the %s (%s)\", signed_time_secs_to_str(wmem_packet_scope(), secs),\n                              (dtg & 0x80) ? dtg_sign.true_string :\n                              dtg_sign.false_string, (dtg & 0x80) ?\n                              abs_time_secs_to_str (wmem_packet_scope(), dmp.subm_time + secs, ABSOLUTE_TIME_LOCAL, TRUE) :\n                              abs_time_secs_to_str (wmem_packet_scope(), dmp.subm_time - secs, ABSOLUTE_TIME_LOCAL, TRUE));\n    }\n    offset += 1;\n  }\n\n  if (dmp.msg_type == STANAG) {\n    /* SIC */\n    offset = dissect_dmp_sic (tvb, pinfo, message_tree, offset);\n  } else if (dmp.msg_type == REPORT || dmp.msg_type == NOTIF) {\n    if (dmp.version == DMP_VERSION_1 || dmp.msg_id_type == ONLY_DMP_ID) {\n      /* Subject Message Identifier */\n      dmp.subj_id = tvb_get_ntohs (tvb, offset);\n      proto_tree_add_item (message_tree, hf_message_subj_id, tvb, offset, 2, ENC_BIG_ENDIAN);\n      hidden_item = proto_tree_add_item (message_tree, hf_dmp_id, tvb, offset, 2, ENC_BIG_ENDIAN);\n      PROTO_ITEM_SET_HIDDEN (hidden_item);\n      offset += 2;\n    } else if (dmp.msg_id_type == X400_MSG_ID || dmp.msg_id_type == NAT_MSG_ID) {\n      if (dmp.msg_type == REPORT) {\n        /* Subject MTS Identifier */\n        offset = dissect_mts_identifier (tvb, pinfo, message_tree, offset, TRUE);\n      } else {\n        /* Subject IPM Identifier */\n        offset = dissect_ipm_identifier (tvb, pinfo, message_tree, offset, TRUE);\n      }\n      if (dmp.subj_id) {\n        tf = proto_tree_add_uint (message_tree, hf_message_subj_id, tvb, offset, 0, dmp.subj_id);\n        PROTO_ITEM_SET_GENERATED (tf);\n        hidden_item = proto_tree_add_uint (message_tree, hf_dmp_id, tvb, offset, 0, dmp.subj_id);\n        PROTO_ITEM_SET_GENERATED (hidden_item);\n        PROTO_ITEM_SET_HIDDEN (hidden_item);\n      }\n    }\n  }\n\n  if (use_seq_ack_analysis) {\n    register_dmp_id (pinfo, 0);\n  }\n\n  proto_item_set_len (en, offset - boffset);\n\n  if  (dmp.msg_type == STANAG || dmp.msg_type == IPM) {\n    /* User Data */\n    offset = dissect_dmp_message (tvb, pinfo, dmp_tree, offset);\n  } else if (dmp.msg_type == REPORT) {\n    /* One or more Delivery Report or Non-Delivery Report Data */\n    rep_len = tvb_reported_length (tvb);\n    if (dmp.checksum) {\n      rep_len -= 2;\n    }\n    while (offset < rep_len) {\n      offset = dissect_dmp_report (tvb, pinfo, dmp_tree, offset, &prev_rec_no, rep_no++);\n    }\n  } else if (dmp.msg_type == NOTIF) {\n    /* Notification Data */\n    offset = dissect_dmp_notification (tvb, pinfo, dmp_tree, offset);\n  }\n\n  return offset;\n}",
        "func": "static gint dissect_dmp_content (tvbuff_t *tvb, packet_info *pinfo,\n                                 proto_tree *dmp_tree, gint offset)\n{\n  proto_tree *message_tree = NULL;\n  proto_tree *field_tree = NULL;\n  proto_item *en = NULL, *ei = NULL, *tf = NULL;\n  proto_item *hidden_item;\n  const char  *label_string = wmem_strdup (wmem_packet_scope(), \"\");\n  const gchar *class_name = NULL;\n  guint8      message, dmp_sec_pol, dmp_sec_class, dmp_nation = 0, exp_time, dtg;\n  gint32      secs = 0;\n  guint       prev_rec_no = 0;\n  gint        rep_len, rep_no = 1;\n  gint        loffset, boffset = offset;\n\n  if (dmp.msg_type == REPORT) {\n    en = proto_tree_add_item (dmp_tree, hf_report_content, tvb, offset, 7, ENC_NA);\n  } else if (dmp.msg_type == NOTIF) {\n    en = proto_tree_add_item (dmp_tree, hf_notif_content, tvb, offset, 7, ENC_NA);\n  } else {\n    en = proto_tree_add_item (dmp_tree, hf_message_content, tvb, offset, 7, ENC_NA);\n  }\n  message_tree = proto_item_add_subtree (en, ett_content);\n\n  if (dmp.msg_type == STANAG || dmp.msg_type == IPM) {\n    message = tvb_get_guint8 (tvb, offset);\n    dmp.body_format = (message & 0x03);\n\n    if (dmp.msg_type == STANAG) {\n      /* Message Type */\n      dmp.st_type = (message & 0xC0) >> 6;\n      tf = proto_tree_add_uint_format (message_tree, hf_message_st_type,\n                                       tvb, offset, 1, message,\n                                       \"Message Type: %s (%d)\",\n                                       val_to_str_const (dmp.st_type,\n                                                         message_type_vals, \"\"),\n                                       dmp.st_type);\n      field_tree = proto_item_add_subtree (tf, ett_message_st_type);\n      proto_tree_add_item (field_tree, hf_message_st_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n      if ((message & 0x20) >> 5) {\n        /* Reserved */\n        tf = proto_tree_add_uint_format (message_tree, hf_reserved_0x20,\n                                         tvb, offset, 1, message,\n                                         \"Reserved: %d\", (message & 0x20)>>5);\n        field_tree = proto_item_add_subtree (tf, ett_message_reserved);\n        tf = proto_tree_add_item (field_tree, hf_reserved_0x20, tvb, offset, 1, ENC_BIG_ENDIAN);\n        expert_add_info(pinfo, tf, &ei_reserved_value);\n      }\n\n      /* Precedence */\n      dmp.prec = (message & 0x1C) >> 2;\n      tf = proto_tree_add_uint_format (message_tree, hf_message_precedence,\n                                       tvb, offset, 1, message,\n                                       \"Precedence: %s (%d)\",\n                                       val_to_str_const (dmp.prec, precedence, \"\"),\n                                       dmp.prec);\n      field_tree = proto_item_add_subtree (tf, ett_message_precedence);\n      proto_tree_add_item (field_tree, hf_message_precedence, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    } else {\n      if ((message & 0xE0) >> 5) {\n        /* Reserved */\n        tf = proto_tree_add_uint_format (message_tree, hf_reserved_0xE0,\n                                         tvb, offset, 1, message,\n                                         \"Reserved: %d\", (message & 0xE0)>>5);\n        field_tree = proto_item_add_subtree (tf, ett_message_reserved);\n        tf = proto_tree_add_item (field_tree, hf_reserved_0xE0, tvb, offset, 1, ENC_BIG_ENDIAN);\n        expert_add_info(pinfo, tf, &ei_reserved_value);\n      }\n\n      /* Importance */\n      dmp.prec = (message & 0x1C) >> 2;\n      tf = proto_tree_add_uint_format (message_tree, hf_message_importance,\n                                       tvb, offset, 1, message,\n                                       \"Importance: %s (%d)\",\n                                       val_to_str_const (dmp.prec, importance, \"\"),\n                                       dmp.prec);\n      field_tree = proto_item_add_subtree (tf, ett_message_importance);\n      proto_tree_add_item (field_tree, hf_message_importance, tvb, offset, 1, ENC_BIG_ENDIAN);\n    }\n\n    /* Body Format */\n    tf = proto_tree_add_uint_format (message_tree, hf_message_body_format,\n                                     tvb, offset, 1, message,\n                                     \"Body Format: %s (%d)\",\n                                     val_to_str_const (message & 0x03,\n                                                       body_format_vals, \"\"),\n                                     message & 0x03);\n    field_tree = proto_item_add_subtree (tf, ett_message_body_format);\n    proto_tree_add_item (field_tree, hf_message_body_format, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n  }\n\n  message = tvb_get_guint8 (tvb, offset);\n  /* Security Classification */\n  dmp_sec_class = (message & 0xE0) >> 5;\n  dmp_sec_pol = (message & 0x1C) >> 2;\n  if (dmp_sec_pol == EXTENDED_NATIONAL) {\n    dmp_nation = tvb_get_guint8 (tvb, offset + 1);\n  }\n\n  loffset = offset; /* Offset to start of security label */\n  if (dmp_sec_pol == NATIONAL && dmp_local_nation != 0) {\n    class_name = dmp_national_sec_class (dmp_local_nation, dmp_sec_class);\n  } else if (dmp_sec_pol == EXTENDED_NATIONAL) {\n    class_name = dmp_national_sec_class (dmp_nation, dmp_sec_class);\n  }\n  if ((dmp_sec_pol == NATO || dmp_sec_pol == NATIONAL) && !class_name) {\n    class_name = val_to_str_const (dmp_sec_class, sec_class, \"\");\n  }\n  if (class_name && class_name[0]) {\n    tf = proto_tree_add_uint_format (message_tree, hf_message_sec_class_val,\n                                     tvb, offset, 1, message,\n                                     \"Security Classification: %s (%d)\",\n                                     class_name, dmp_sec_class);\n  } else {\n    tf = proto_tree_add_uint_format (message_tree, hf_message_sec_class_val,\n                                     tvb, offset, 1, message,\n                                     \"Security Classification: %d\",\n                                     dmp_sec_class);\n  }\n  field_tree = proto_item_add_subtree (tf, ett_message_sec_class);\n  tf = proto_tree_add_item (field_tree, hf_message_sec_class_val, tvb, offset, 1, ENC_BIG_ENDIAN);\n  if (class_name) {\n    proto_item_append_text (tf, \" (%s)\", class_name);\n    label_string = wmem_strconcat(wmem_packet_scope(), label_string, class_name, NULL);\n  }\n\n  /* Security Policy */\n  tf = proto_tree_add_uint_format (message_tree, hf_message_sec_pol,\n                                   tvb, offset, 1, message,\n                                   \"Security Policy: %s (%d)\",\n                                   val_to_str (dmp_sec_pol, sec_pol, \"%d\"),\n                                   dmp_sec_pol);\n  field_tree = proto_item_add_subtree (tf, ett_message_sec_pol);\n  proto_tree_add_item (field_tree, hf_message_sec_pol, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n  if (dmp.msg_type == STANAG || dmp.msg_type == IPM) {\n    /* Heading Flags */\n    tf = proto_tree_add_item (message_tree, hf_message_heading_flags, tvb, offset, 1, ENC_NA);\n    field_tree = proto_item_add_subtree (tf, ett_message_heading_flags);\n    proto_tree_add_item (field_tree, hf_message_auth_users, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item (field_tree, hf_message_subject_disc, tvb, offset, 1, ENC_BIG_ENDIAN);\n    if (message & 0x03) {\n      proto_item_append_text (tf, \": %s%s%s discarded\",\n                              (message & 0x02) ? \"Authorizing users\" : \"\",\n                              (message & 0x03) == 0x03 ? \" and \" : \"\",\n                              (message & 0x01) ? \"Subject\" : \"\");\n    } else {\n      proto_item_append_text (tf, \" (none)\");\n    }\n  } else if (dmp.msg_type == NOTIF) {\n    /* Notification Type */\n    dmp.notif_type = (message & 0x03);\n    tf = proto_tree_add_uint_format (message_tree, hf_notif_type,\n                                     tvb, offset, 1, message,\n                                     \"Notification Type: %s\",\n                                     val_to_str_const (dmp.notif_type, notif_type,\n                                                       \"Reserved\"));\n    field_tree = proto_item_add_subtree (tf, ett_notif_type);\n    proto_tree_add_item (field_tree, hf_notif_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n  } else if (message & 0x02) {\n    /* Reserved */\n    tf = proto_tree_add_uint_format (message_tree, hf_reserved_0x02,\n                                     tvb, offset, 1, message,\n                                     \"Reserved: %d\", message & 0x02);\n    field_tree = proto_item_add_subtree (tf, ett_message_reserved);\n    tf = proto_tree_add_item (field_tree, hf_reserved_0x02, tvb, offset, 1, ENC_BIG_ENDIAN);\n    expert_add_info(pinfo, tf, &ei_reserved_value);\n  }\n  offset += 1;\n\n  if (dmp_sec_pol == NATIONAL && dmp_local_nation != 0) {\n    /* Show configured national policy */\n    tf = proto_tree_add_uint (message_tree, hf_message_national_policy_id,\n                              tvb, offset, 0, dmp_local_nation);\n    PROTO_ITEM_SET_GENERATED (tf);\n  } else if (dmp_sec_pol == EXTENDED_NATIONAL) {\n    /* National Policy Identifier */\n    proto_tree_add_item (message_tree, hf_message_national_policy_id, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n  } else if (dmp_sec_pol == EXTENDED_MISSION) {\n    /* Mission Policy Identifier */\n    message = tvb_get_guint8 (tvb, offset);\n    if (message == 0xFF) {\n      proto_tree_add_uint_format_value (message_tree, hf_message_mission_policy_id,\n                                        tvb, offset, 1, message,\n                                        \"Reserved (0xFF)\");\n    } else {\n      proto_tree_add_item (message_tree, hf_message_mission_policy_id, tvb, offset, 1, ENC_BIG_ENDIAN);\n    }\n    offset += 1;\n  }\n\n  /* Security Categories */\n  if (dmp_sec_pol == NATO || dmp_sec_pol == NATIONAL || dmp_sec_pol == EXTENDED_NATIONAL) {\n    offset = dissect_dmp_security_category (tvb, pinfo, message_tree, &label_string, offset, 0, FALSE);\n    proto_item_append_text (en, \", Security Label: %s\", label_string);\n    tf = proto_tree_add_string (message_tree, hf_message_sec_label, tvb, loffset,\n                                offset - loffset + 1, label_string);\n    PROTO_ITEM_SET_GENERATED (tf);\n  } else {\n    tf = proto_tree_add_item (message_tree, hf_message_sec_cat_val, tvb, offset, 1, ENC_BIG_ENDIAN);\n    field_tree = proto_item_add_subtree (tf, ett_message_sec_cat);\n\n    proto_tree_add_item (field_tree, hf_message_sec_cat_bit7, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item (field_tree, hf_message_sec_cat_bit6, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item (field_tree, hf_message_sec_cat_bit5, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item (field_tree, hf_message_sec_cat_bit4, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item (field_tree, hf_message_sec_cat_bit3, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item (field_tree, hf_message_sec_cat_bit2, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item (field_tree, hf_message_sec_cat_bit1, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item (field_tree, hf_message_sec_cat_bit0, tvb, offset, 1, ENC_BIG_ENDIAN);\n  }\n  offset += 1;\n\n  if (dmp.msg_type == STANAG || dmp.msg_type == IPM) {\n    /* Expiry Time */\n    exp_time = tvb_get_guint8 (tvb, offset);\n    tf = proto_tree_add_uint_format (message_tree, hf_message_exp_time,\n                                     tvb, offset, 1, exp_time,\n                                     \"Expiry Time: \");\n    field_tree = proto_item_add_subtree (tf, ett_message_exp_time);\n    ei = proto_tree_add_item (field_tree, hf_message_exp_time_val, tvb, offset, 1, ENC_BIG_ENDIAN);\n    secs = dmp_dec_exp_time (exp_time);\n    if (secs == DMP_TIME_NOT_PRESENT) {\n      proto_item_append_text (tf, \"Not present\");\n      proto_item_append_text (ei, \" (not present)\");\n    } else if (secs == DMP_TIME_RESERVED) {\n      proto_item_append_text (tf, \"Reserved (0x%2.2x)\", exp_time);\n      proto_item_append_text (ei, \" (Reserved)\");\n    } else {\n      proto_item_append_text (tf, \"%s (%s)\", signed_time_secs_to_str(wmem_packet_scope(), secs),\n                              abs_time_secs_to_str (wmem_packet_scope(), dmp.subm_time + secs, ABSOLUTE_TIME_LOCAL, TRUE));\n      proto_item_append_text (ei, \" (%s from submission time)\", signed_time_secs_to_str(wmem_packet_scope(), secs));\n    }\n    offset += 1;\n  }\n\n  if (dmp.msg_type == STANAG) {\n    dtg = tvb_get_guint8 (tvb, offset);\n    tf = proto_tree_add_uint_format (message_tree, hf_message_dtg, tvb, offset, 1, dtg, \"DTG: \");\n    field_tree = proto_item_add_subtree (tf, ett_message_dtg);\n    proto_tree_add_item (field_tree, hf_message_dtg_sign, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item (field_tree, hf_message_dtg_val, tvb, offset, 1, ENC_BIG_ENDIAN);\n    secs = dmp_dec_dtg (dtg & 0x7F);\n    if (secs == DMP_TIME_NOT_PRESENT) {\n      proto_item_append_text (tf, \"Not present\");\n    } else if (secs == DMP_TIME_RESERVED) {\n      proto_item_append_text (tf, \"Reserved (0x%2.2x)\", dtg & 0x7F);\n    } else if (secs == 0) {\n      proto_item_append_text (tf, \"0 minutes in the %s (%s)\",\n                              (dtg & 0x80) ? dtg_sign.true_string :\n                              dtg_sign.false_string,\n                              abs_time_secs_to_str (wmem_packet_scope(), dmp.subm_time, ABSOLUTE_TIME_LOCAL, TRUE));\n    } else {\n      proto_item_append_text (tf, \"%s in the %s (%s)\", signed_time_secs_to_str(wmem_packet_scope(), secs),\n                              (dtg & 0x80) ? dtg_sign.true_string :\n                              dtg_sign.false_string, (dtg & 0x80) ?\n                              abs_time_secs_to_str (wmem_packet_scope(), dmp.subm_time + secs, ABSOLUTE_TIME_LOCAL, TRUE) :\n                              abs_time_secs_to_str (wmem_packet_scope(), dmp.subm_time - secs, ABSOLUTE_TIME_LOCAL, TRUE));\n    }\n    offset += 1;\n  }\n\n  if (dmp.msg_type == STANAG) {\n    /* SIC */\n    offset = dissect_dmp_sic (tvb, pinfo, message_tree, offset);\n  } else if (dmp.msg_type == REPORT || dmp.msg_type == NOTIF) {\n    if (dmp.version == DMP_VERSION_1 || dmp.msg_id_type == ONLY_DMP_ID) {\n      /* Subject Message Identifier */\n      dmp.subj_id = tvb_get_ntohs (tvb, offset);\n      proto_tree_add_item (message_tree, hf_message_subj_id, tvb, offset, 2, ENC_BIG_ENDIAN);\n      hidden_item = proto_tree_add_item (message_tree, hf_dmp_id, tvb, offset, 2, ENC_BIG_ENDIAN);\n      PROTO_ITEM_SET_HIDDEN (hidden_item);\n      offset += 2;\n    } else if (dmp.msg_id_type == X400_MSG_ID || dmp.msg_id_type == NAT_MSG_ID) {\n      if (dmp.msg_type == REPORT) {\n        /* Subject MTS Identifier */\n        offset = dissect_mts_identifier (tvb, pinfo, message_tree, offset, TRUE);\n      } else {\n        /* Subject IPM Identifier */\n        offset = dissect_ipm_identifier (tvb, pinfo, message_tree, offset, TRUE);\n      }\n      if (dmp.subj_id) {\n        tf = proto_tree_add_uint (message_tree, hf_message_subj_id, tvb, offset, 0, dmp.subj_id);\n        PROTO_ITEM_SET_GENERATED (tf);\n        hidden_item = proto_tree_add_uint (message_tree, hf_dmp_id, tvb, offset, 0, dmp.subj_id);\n        PROTO_ITEM_SET_GENERATED (hidden_item);\n        PROTO_ITEM_SET_HIDDEN (hidden_item);\n      }\n    }\n  }\n\n  if (use_seq_ack_analysis) {\n    register_dmp_id (pinfo, 0);\n  }\n\n  proto_item_set_len (en, offset - boffset);\n\n  if  (dmp.msg_type == STANAG || dmp.msg_type == IPM) {\n    /* User Data */\n    offset = dissect_dmp_message (tvb, pinfo, dmp_tree, offset);\n  } else if (dmp.msg_type == REPORT) {\n    /* One or more Delivery Report or Non-Delivery Report Data */\n    rep_len = tvb_reported_length (tvb);\n    if (dmp.checksum) {\n      rep_len -= 2;\n    }\n    while (offset < rep_len) {\n      offset = dissect_dmp_report (tvb, pinfo, dmp_tree, offset, &prev_rec_no, rep_no++);\n    }\n  } else if (dmp.msg_type == NOTIF) {\n    /* Notification Data */\n    offset = dissect_dmp_notification (tvb, pinfo, dmp_tree, offset);\n  }\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -195,7 +195,7 @@\n \n   /* Security Categories */\n   if (dmp_sec_pol == NATO || dmp_sec_pol == NATIONAL || dmp_sec_pol == EXTENDED_NATIONAL) {\n-    offset = dissect_dmp_security_category (tvb, pinfo, message_tree, &label_string, offset, 0);\n+    offset = dissect_dmp_security_category (tvb, pinfo, message_tree, &label_string, offset, 0, FALSE);\n     proto_item_append_text (en, \", Security Label: %s\", label_string);\n     tf = proto_tree_add_string (message_tree, hf_message_sec_label, tvb, loffset,\n                                 offset - loffset + 1, label_string);",
        "diff_line_info": {
            "deleted_lines": [
                "    offset = dissect_dmp_security_category (tvb, pinfo, message_tree, &label_string, offset, 0);"
            ],
            "added_lines": [
                "    offset = dissect_dmp_security_category (tvb, pinfo, message_tree, &label_string, offset, 0, FALSE);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7421",
        "func_name": "wireshark/dissect_dmp_security_category",
        "description": "In Wireshark 2.2.0 to 2.2.12 and 2.4.0 to 2.4.4, the DMP dissector could go into an infinite loop. This was addressed in epan/dissectors/packet-dmp.c by correctly supporting a bounded number of Security Categories for a DMP Security Classification.",
        "git_url": "https://github.com/wireshark/wireshark/commit/e8be5adae469ba563acfad2c2b98673e1afaf901",
        "commit_title": "DMP: Recurse only once.",
        "commit_text": " Make sure we call dissect_dmp_security_category from itself only once.  Bug: 14408",
        "func_before": "static gint dissect_dmp_security_category (tvbuff_t *tvb, packet_info *pinfo,\n                                           proto_tree *tree,\n                                           const gchar **label_string,\n                                           gint offset, guint8 ext)\n{\n  proto_tree *field_tree = NULL;\n  proto_item *tf = NULL, *tr = NULL;\n  gchar      *sec_cat = NULL;\n  guint8      message;\n  gboolean    country_code = FALSE;\n\n  message = tvb_get_guint8 (tvb, offset);\n  tf = proto_tree_add_uint_format (tree, hf_message_sec_cat_nat, tvb,\n                                   offset, 1, message, \"Security Categories\");\n  field_tree = proto_item_add_subtree (tf, ett_message_sec_cat);\n\n  switch (ext) {\n\n  case SEC_CAT_EXT_NONE:\n    proto_tree_add_item (field_tree, hf_message_sec_cat_cl, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item (field_tree, hf_message_sec_cat_cs, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item (field_tree, hf_message_sec_cat_ex, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item (field_tree, hf_message_sec_cat_ne, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    tr = proto_tree_add_item (field_tree, hf_reserved_0x08, tvb, offset, 1, ENC_BIG_ENDIAN);\n    if (message & 0x08) {\n      expert_add_info(pinfo, tr, &ei_reserved_value);\n    }\n    tr = proto_tree_add_item (field_tree, hf_reserved_0x04, tvb, offset, 1, ENC_BIG_ENDIAN);\n    if (message & 0x04) {\n      expert_add_info(pinfo, tr, &ei_reserved_value);\n    }\n\n    if (message & 0xF0) {\n      sec_cat = wmem_strdup_printf (wmem_packet_scope(), \"%s%s%s%s\",\n                                    (message & 0x80) ? \",cl\" : \"\",\n                                    (message & 0x40) ? \",cs\" : \"\",\n                                    (message & 0x20) ? \",ex\" : \"\",\n                                    (message & 0x10) ? \",ne\" : \"\");\n      proto_item_append_text (tf, \": %s\", &sec_cat[1]);\n      *label_string = wmem_strconcat(wmem_packet_scope(), *label_string, sec_cat, NULL);\n    }\n    break;\n\n  case SEC_CAT_EXT_PERMISSIVE:\n    if ((message >> 2) == 0x3F) {\n      /* Fake entry because nat_pol_id defines 0x3F as reserved */\n      proto_tree_add_uint_format (field_tree, hf_message_sec_cat_permissive, tvb, offset, 1,\n                                  message, \"1111 11.. = Next byte has Country Code (0x3F)\");\n      country_code = TRUE;\n    } else {\n      tr = proto_tree_add_item (field_tree, hf_message_sec_cat_permissive, tvb, offset, 1, ENC_BIG_ENDIAN);\n      proto_item_append_text (tf, \": rel-to-%s\", get_nat_pol_id_short (message >> 2));\n      *label_string = wmem_strdup_printf(wmem_packet_scope(), \"%s,rel-to-%s\", *label_string, get_nat_pol_id_short (message >> 2));\n      if ((message >> 2) == 0) {\n        expert_add_info(pinfo, tr, &ei_reserved_value);\n      }\n    }\n    break;\n\n  case SEC_CAT_EXT_RESTRICTIVE:\n    proto_tree_add_item (field_tree, hf_message_sec_cat_restrictive, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_item_append_text (tf, \" (restrictive: 0x%2.2x)\", message >> 2);\n    break;\n\n  default:\n    break;\n  }\n\n  proto_item_append_text (tf, \" (0x%2.2x)\", message);\n\n  if (dmp.version == 1) {\n    tr = proto_tree_add_item (field_tree, hf_reserved_0x02, tvb, offset, 1, ENC_BIG_ENDIAN);\n    if (message & 0x02) {\n      expert_add_info(pinfo, tr, &ei_reserved_value);\n    }\n    tr = proto_tree_add_item (field_tree, hf_reserved_0x01, tvb, offset, 1, ENC_BIG_ENDIAN);\n    if (message & 0x01) {\n      expert_add_info(pinfo, tr, &ei_reserved_value);\n    }\n  } else {\n    tr = proto_tree_add_item (field_tree, hf_message_sec_cat_extended, tvb, offset, 1, ENC_BIG_ENDIAN);\n    if ((message & 0x01) && (message & 0x02)) {\n      expert_add_info(pinfo, tr, &ei_reserved_value);\n    } else if (message & 0x01 || message & 0x02) {\n      proto_item_append_text (tf, \" (extended)\");\n      offset = dissect_dmp_security_category (tvb, pinfo, tree, label_string, offset+1, message & 0x03);\n    }\n\n    if (country_code) {\n      proto_tree_add_item (field_tree, hf_message_sec_cat_country_code, tvb, offset+1, 1, ENC_BIG_ENDIAN);\n      proto_item_append_text (tf, \" (rel-to country-code: %d)\", tvb_get_guint8 (tvb, offset+1));\n      proto_item_set_len (tf, 2);\n      offset++;\n    }\n  }\n\n  return offset;\n}",
        "func": "static gint dissect_dmp_security_category (tvbuff_t *tvb, packet_info *pinfo,\n                                           proto_tree *tree,\n                                           const gchar **label_string,\n                                           gint offset, guint8 ext, gboolean extended)\n{\n  proto_tree *field_tree = NULL;\n  proto_item *tf = NULL, *tr = NULL;\n  gchar      *sec_cat = NULL;\n  guint8      message;\n  gboolean    country_code = FALSE;\n\n  message = tvb_get_guint8 (tvb, offset);\n  tf = proto_tree_add_uint_format (tree, hf_message_sec_cat_nat, tvb,\n                                   offset, 1, message, \"Security Categories\");\n  field_tree = proto_item_add_subtree (tf, ett_message_sec_cat);\n\n  switch (ext) {\n\n  case SEC_CAT_EXT_NONE:\n    proto_tree_add_item (field_tree, hf_message_sec_cat_cl, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item (field_tree, hf_message_sec_cat_cs, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item (field_tree, hf_message_sec_cat_ex, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item (field_tree, hf_message_sec_cat_ne, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n    tr = proto_tree_add_item (field_tree, hf_reserved_0x08, tvb, offset, 1, ENC_BIG_ENDIAN);\n    if (message & 0x08) {\n      expert_add_info(pinfo, tr, &ei_reserved_value);\n    }\n    tr = proto_tree_add_item (field_tree, hf_reserved_0x04, tvb, offset, 1, ENC_BIG_ENDIAN);\n    if (message & 0x04) {\n      expert_add_info(pinfo, tr, &ei_reserved_value);\n    }\n\n    if (message & 0xF0) {\n      sec_cat = wmem_strdup_printf (wmem_packet_scope(), \"%s%s%s%s\",\n                                    (message & 0x80) ? \",cl\" : \"\",\n                                    (message & 0x40) ? \",cs\" : \"\",\n                                    (message & 0x20) ? \",ex\" : \"\",\n                                    (message & 0x10) ? \",ne\" : \"\");\n      proto_item_append_text (tf, \": %s\", &sec_cat[1]);\n      *label_string = wmem_strconcat(wmem_packet_scope(), *label_string, sec_cat, NULL);\n    }\n    break;\n\n  case SEC_CAT_EXT_PERMISSIVE:\n    if ((message >> 2) == 0x3F) {\n      /* Fake entry because nat_pol_id defines 0x3F as reserved */\n      proto_tree_add_uint_format (field_tree, hf_message_sec_cat_permissive, tvb, offset, 1,\n                                  message, \"1111 11.. = Next byte has Country Code (0x3F)\");\n      country_code = TRUE;\n    } else {\n      tr = proto_tree_add_item (field_tree, hf_message_sec_cat_permissive, tvb, offset, 1, ENC_BIG_ENDIAN);\n      proto_item_append_text (tf, \": rel-to-%s\", get_nat_pol_id_short (message >> 2));\n      *label_string = wmem_strdup_printf(wmem_packet_scope(), \"%s,rel-to-%s\", *label_string, get_nat_pol_id_short (message >> 2));\n      if ((message >> 2) == 0) {\n        expert_add_info(pinfo, tr, &ei_reserved_value);\n      }\n    }\n    break;\n\n  case SEC_CAT_EXT_RESTRICTIVE:\n    proto_tree_add_item (field_tree, hf_message_sec_cat_restrictive, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_item_append_text (tf, \" (restrictive: 0x%2.2x)\", message >> 2);\n    break;\n\n  default:\n    break;\n  }\n\n  proto_item_append_text (tf, \" (0x%2.2x)\", message);\n\n  if (dmp.version == 1) {\n    tr = proto_tree_add_item (field_tree, hf_reserved_0x02, tvb, offset, 1, ENC_BIG_ENDIAN);\n    if (message & 0x02) {\n      expert_add_info(pinfo, tr, &ei_reserved_value);\n    }\n    tr = proto_tree_add_item (field_tree, hf_reserved_0x01, tvb, offset, 1, ENC_BIG_ENDIAN);\n    if (message & 0x01) {\n      expert_add_info(pinfo, tr, &ei_reserved_value);\n    }\n  } else {\n    tr = proto_tree_add_item (field_tree, hf_message_sec_cat_extended, tvb, offset, 1, ENC_BIG_ENDIAN);\n    if ((message & 0x01) && (message & 0x02)) {\n      expert_add_info(pinfo, tr, &ei_reserved_value);\n    } else if ((message & 0x01 || message & 0x02) && !extended) {\n      proto_item_append_text (tf, \" (extended)\");\n      offset = dissect_dmp_security_category (tvb, pinfo, tree, label_string, offset+1, message & 0x03, TRUE);\n    }\n\n    if (country_code) {\n      proto_tree_add_item (field_tree, hf_message_sec_cat_country_code, tvb, offset+1, 1, ENC_BIG_ENDIAN);\n      proto_item_append_text (tf, \" (rel-to country-code: %d)\", tvb_get_guint8 (tvb, offset+1));\n      proto_item_set_len (tf, 2);\n      offset++;\n    }\n  }\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n static gint dissect_dmp_security_category (tvbuff_t *tvb, packet_info *pinfo,\n                                            proto_tree *tree,\n                                            const gchar **label_string,\n-                                           gint offset, guint8 ext)\n+                                           gint offset, guint8 ext, gboolean extended)\n {\n   proto_tree *field_tree = NULL;\n   proto_item *tf = NULL, *tr = NULL;\n@@ -82,9 +82,9 @@\n     tr = proto_tree_add_item (field_tree, hf_message_sec_cat_extended, tvb, offset, 1, ENC_BIG_ENDIAN);\n     if ((message & 0x01) && (message & 0x02)) {\n       expert_add_info(pinfo, tr, &ei_reserved_value);\n-    } else if (message & 0x01 || message & 0x02) {\n+    } else if ((message & 0x01 || message & 0x02) && !extended) {\n       proto_item_append_text (tf, \" (extended)\");\n-      offset = dissect_dmp_security_category (tvb, pinfo, tree, label_string, offset+1, message & 0x03);\n+      offset = dissect_dmp_security_category (tvb, pinfo, tree, label_string, offset+1, message & 0x03, TRUE);\n     }\n \n     if (country_code) {",
        "diff_line_info": {
            "deleted_lines": [
                "                                           gint offset, guint8 ext)",
                "    } else if (message & 0x01 || message & 0x02) {",
                "      offset = dissect_dmp_security_category (tvb, pinfo, tree, label_string, offset+1, message & 0x03);"
            ],
            "added_lines": [
                "                                           gint offset, guint8 ext, gboolean extended)",
                "    } else if ((message & 0x01 || message & 0x02) && !extended) {",
                "      offset = dissect_dmp_security_category (tvb, pinfo, tree, label_string, offset+1, message & 0x03, TRUE);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7908",
        "func_name": "qemu/mcf_fec_do_tx",
        "description": "The mcf_fec_do_tx function in hw/net/mcf_fec.c in QEMU (aka Quick Emulator) does not properly limit the buffer descriptor count when transmitting packets, which allows local guest OS administrators to cause a denial of service (infinite loop and QEMU process crash) via vectors involving a buffer descriptor with a length of 0 and crafted values in bd.flags.",
        "git_url": "https://github.com/qemu/qemu/commit/070c4b92b8cd5390889716677a0b92444d6e087a",
        "commit_title": "net: mcf: limit buffer descriptor count",
        "commit_text": " ColdFire Fast Ethernet Controller uses buffer descriptors to manage data flow to/fro receive & transmit queues. While transmitting packets, it could continue to read buffer descriptors if a buffer descriptor has length of zero and has crafted values in bd.flags. Set upper limit to number of buffer descriptors. ",
        "func_before": "static void mcf_fec_do_tx(mcf_fec_state *s)\n{\n    uint32_t addr;\n    mcf_fec_bd bd;\n    int frame_size;\n    int len;\n    uint8_t frame[FEC_MAX_FRAME_SIZE];\n    uint8_t *ptr;\n\n    DPRINTF(\"do_tx\\n\");\n    ptr = frame;\n    frame_size = 0;\n    addr = s->tx_descriptor;\n    while (1) {\n        mcf_fec_read_bd(&bd, addr);\n        DPRINTF(\"tx_bd %x flags %04x len %d data %08x\\n\",\n                addr, bd.flags, bd.length, bd.data);\n        if ((bd.flags & FEC_BD_R) == 0) {\n            /* Run out of descriptors to transmit.  */\n            break;\n        }\n        len = bd.length;\n        if (frame_size + len > FEC_MAX_FRAME_SIZE) {\n            len = FEC_MAX_FRAME_SIZE - frame_size;\n            s->eir |= FEC_INT_BABT;\n        }\n        cpu_physical_memory_read(bd.data, ptr, len);\n        ptr += len;\n        frame_size += len;\n        if (bd.flags & FEC_BD_L) {\n            /* Last buffer in frame.  */\n            DPRINTF(\"Sending packet\\n\");\n            qemu_send_packet(qemu_get_queue(s->nic), frame, len);\n            ptr = frame;\n            frame_size = 0;\n            s->eir |= FEC_INT_TXF;\n        }\n        s->eir |= FEC_INT_TXB;\n        bd.flags &= ~FEC_BD_R;\n        /* Write back the modified descriptor.  */\n        mcf_fec_write_bd(&bd, addr);\n        /* Advance to the next descriptor.  */\n        if ((bd.flags & FEC_BD_W) != 0) {\n            addr = s->etdsr;\n        } else {\n            addr += 8;\n        }\n    }\n    s->tx_descriptor = addr;\n}",
        "func": "static void mcf_fec_do_tx(mcf_fec_state *s)\n{\n    uint32_t addr;\n    mcf_fec_bd bd;\n    int frame_size;\n    int len, descnt = 0;\n    uint8_t frame[FEC_MAX_FRAME_SIZE];\n    uint8_t *ptr;\n\n    DPRINTF(\"do_tx\\n\");\n    ptr = frame;\n    frame_size = 0;\n    addr = s->tx_descriptor;\n    while (descnt++ < FEC_MAX_DESC) {\n        mcf_fec_read_bd(&bd, addr);\n        DPRINTF(\"tx_bd %x flags %04x len %d data %08x\\n\",\n                addr, bd.flags, bd.length, bd.data);\n        if ((bd.flags & FEC_BD_R) == 0) {\n            /* Run out of descriptors to transmit.  */\n            break;\n        }\n        len = bd.length;\n        if (frame_size + len > FEC_MAX_FRAME_SIZE) {\n            len = FEC_MAX_FRAME_SIZE - frame_size;\n            s->eir |= FEC_INT_BABT;\n        }\n        cpu_physical_memory_read(bd.data, ptr, len);\n        ptr += len;\n        frame_size += len;\n        if (bd.flags & FEC_BD_L) {\n            /* Last buffer in frame.  */\n            DPRINTF(\"Sending packet\\n\");\n            qemu_send_packet(qemu_get_queue(s->nic), frame, len);\n            ptr = frame;\n            frame_size = 0;\n            s->eir |= FEC_INT_TXF;\n        }\n        s->eir |= FEC_INT_TXB;\n        bd.flags &= ~FEC_BD_R;\n        /* Write back the modified descriptor.  */\n        mcf_fec_write_bd(&bd, addr);\n        /* Advance to the next descriptor.  */\n        if ((bd.flags & FEC_BD_W) != 0) {\n            addr = s->etdsr;\n        } else {\n            addr += 8;\n        }\n    }\n    s->tx_descriptor = addr;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n     uint32_t addr;\n     mcf_fec_bd bd;\n     int frame_size;\n-    int len;\n+    int len, descnt = 0;\n     uint8_t frame[FEC_MAX_FRAME_SIZE];\n     uint8_t *ptr;\n \n@@ -11,7 +11,7 @@\n     ptr = frame;\n     frame_size = 0;\n     addr = s->tx_descriptor;\n-    while (1) {\n+    while (descnt++ < FEC_MAX_DESC) {\n         mcf_fec_read_bd(&bd, addr);\n         DPRINTF(\"tx_bd %x flags %04x len %d data %08x\\n\",\n                 addr, bd.flags, bd.length, bd.data);",
        "diff_line_info": {
            "deleted_lines": [
                "    int len;",
                "    while (1) {"
            ],
            "added_lines": [
                "    int len, descnt = 0;",
                "    while (descnt++ < FEC_MAX_DESC) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-8785",
        "func_name": "torvalds/linux/fuse_fill_write_pages",
        "description": "The fuse_fill_write_pages function in fs/fuse/file.c in the Linux kernel before 4.4 allows local users to cause a denial of service (infinite loop) via a writev system call that triggers a zero length for the first segment of an iov.",
        "git_url": "https://github.com/torvalds/linux/commit/3ca8138f014a913f98e6ef40e939868e1e9ea876",
        "commit_title": "fuse: break infinite loop in fuse_fill_write_pages()",
        "commit_text": " I got a report about unkillable task eating CPU. Further investigation shows, that the problem is in the fuse_fill_write_pages() function. If iov's first segment has zero length, we get an infinite loop, because we never reach iov_iter_advance() call.  Fix this by calling iov_iter_advance() before repeating an attempt to copy data from userspace.  A similar problem is described in 124d3b7041f (\"fix writev regression: pan hanging unkillable and un-straceable\"). If zero-length segmend is followed by segment with invalid address, iov_iter_fault_in_readable() checks only first segment (zero-length), iov_iter_copy_from_user_atomic() skips it, fails at second and returns zero -> goto again without skipping zero-length segment.  Patch calls iov_iter_advance() before goto again: we'll skip zero-length segment at second iteraction and iov_iter_fault_in_readable() will detect invalid address.  Special thanks to Konstantin Khlebnikov, who helped a lot with the commit description.  Cc: Andrew Morton <akpm@linux-foundation.org> Cc: Maxim Patlasov <mpatlasov@parallels.com> Cc: Konstantin Khlebnikov <khlebnikov@yandex-team.ru> Cc: <stable@vger.kernel.org>",
        "func_before": "static ssize_t fuse_fill_write_pages(struct fuse_req *req,\n\t\t\t       struct address_space *mapping,\n\t\t\t       struct iov_iter *ii, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(mapping->host);\n\tunsigned offset = pos & (PAGE_CACHE_SIZE - 1);\n\tsize_t count = 0;\n\tint err;\n\n\treq->in.argpages = 1;\n\treq->page_descs[0].offset = offset;\n\n\tdo {\n\t\tsize_t tmp;\n\t\tstruct page *page;\n\t\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\t\tsize_t bytes = min_t(size_t, PAGE_CACHE_SIZE - offset,\n\t\t\t\t     iov_iter_count(ii));\n\n\t\tbytes = min_t(size_t, bytes, fc->max_write - count);\n\n again:\n\t\terr = -EFAULT;\n\t\tif (iov_iter_fault_in_readable(ii, bytes))\n\t\t\tbreak;\n\n\t\terr = -ENOMEM;\n\t\tpage = grab_cache_page_write_begin(mapping, index, 0);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\n\t\ttmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);\n\t\tflush_dcache_page(page);\n\n\t\tif (!tmp) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbytes = min(bytes, iov_iter_single_seg_count(ii));\n\t\t\tgoto again;\n\t\t}\n\n\t\terr = 0;\n\t\treq->pages[req->num_pages] = page;\n\t\treq->page_descs[req->num_pages].length = tmp;\n\t\treq->num_pages++;\n\n\t\tiov_iter_advance(ii, tmp);\n\t\tcount += tmp;\n\t\tpos += tmp;\n\t\toffset += tmp;\n\t\tif (offset == PAGE_CACHE_SIZE)\n\t\t\toffset = 0;\n\n\t\tif (!fc->big_writes)\n\t\t\tbreak;\n\t} while (iov_iter_count(ii) && count < fc->max_write &&\n\t\t req->num_pages < req->max_pages && offset == 0);\n\n\treturn count > 0 ? count : err;\n}",
        "func": "static ssize_t fuse_fill_write_pages(struct fuse_req *req,\n\t\t\t       struct address_space *mapping,\n\t\t\t       struct iov_iter *ii, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(mapping->host);\n\tunsigned offset = pos & (PAGE_CACHE_SIZE - 1);\n\tsize_t count = 0;\n\tint err;\n\n\treq->in.argpages = 1;\n\treq->page_descs[0].offset = offset;\n\n\tdo {\n\t\tsize_t tmp;\n\t\tstruct page *page;\n\t\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\t\tsize_t bytes = min_t(size_t, PAGE_CACHE_SIZE - offset,\n\t\t\t\t     iov_iter_count(ii));\n\n\t\tbytes = min_t(size_t, bytes, fc->max_write - count);\n\n again:\n\t\terr = -EFAULT;\n\t\tif (iov_iter_fault_in_readable(ii, bytes))\n\t\t\tbreak;\n\n\t\terr = -ENOMEM;\n\t\tpage = grab_cache_page_write_begin(mapping, index, 0);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\n\t\ttmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);\n\t\tflush_dcache_page(page);\n\n\t\tiov_iter_advance(ii, tmp);\n\t\tif (!tmp) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbytes = min(bytes, iov_iter_single_seg_count(ii));\n\t\t\tgoto again;\n\t\t}\n\n\t\terr = 0;\n\t\treq->pages[req->num_pages] = page;\n\t\treq->page_descs[req->num_pages].length = tmp;\n\t\treq->num_pages++;\n\n\t\tcount += tmp;\n\t\tpos += tmp;\n\t\toffset += tmp;\n\t\tif (offset == PAGE_CACHE_SIZE)\n\t\t\toffset = 0;\n\n\t\tif (!fc->big_writes)\n\t\t\tbreak;\n\t} while (iov_iter_count(ii) && count < fc->max_write &&\n\t\t req->num_pages < req->max_pages && offset == 0);\n\n\treturn count > 0 ? count : err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -35,6 +35,7 @@\n \t\ttmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);\n \t\tflush_dcache_page(page);\n \n+\t\tiov_iter_advance(ii, tmp);\n \t\tif (!tmp) {\n \t\t\tunlock_page(page);\n \t\t\tpage_cache_release(page);\n@@ -47,7 +48,6 @@\n \t\treq->page_descs[req->num_pages].length = tmp;\n \t\treq->num_pages++;\n \n-\t\tiov_iter_advance(ii, tmp);\n \t\tcount += tmp;\n \t\tpos += tmp;\n \t\toffset += tmp;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tiov_iter_advance(ii, tmp);"
            ],
            "added_lines": [
                "\t\tiov_iter_advance(ii, tmp);"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-3880",
        "func_name": "torvalds/linux/inet_csk_diag_dump",
        "description": "net/ipv4/inet_diag.c in the Linux kernel before 2.6.37-rc2 does not properly audit INET_DIAG bytecode, which allows local users to cause a denial of service (kernel infinite loop) via crafted INET_DIAG_REQ_BYTECODE instructions in a netlink message that contains multiple attribute elements, as demonstrated by INET_DIAG_BC_JMP instructions.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=22e76c849d505d87c5ecf3d3e6742a65f0ff4860",
        "commit_title": "We were using nlmsg_find_attr() to look up the bytecode by attribute when",
        "commit_text": "auditing, but then just using the first attribute when actually running bytecode. So, if we received a message with two attribute elements, where only the second had type INET_DIAG_REQ_BYTECODE, we would validate and run different bytecode strings.  Fix this by consistently using nlmsg_find_attr everywhere.  ",
        "func_before": "static int inet_csk_diag_dump(struct sock *sk,\n\t\t\t      struct sk_buff *skb,\n\t\t\t      struct netlink_callback *cb)\n{\n\tstruct inet_diag_req *r = NLMSG_DATA(cb->nlh);\n\n\tif (cb->nlh->nlmsg_len > 4 + NLMSG_SPACE(sizeof(*r))) {\n\t\tstruct inet_diag_entry entry;\n\t\tstruct rtattr *bc = (struct rtattr *)(r + 1);\n\t\tstruct inet_sock *inet = inet_sk(sk);\n\n\t\tentry.family = sk->sk_family;\n#if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)\n\t\tif (entry.family == AF_INET6) {\n\t\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\n\t\t\tentry.saddr = np->rcv_saddr.s6_addr32;\n\t\t\tentry.daddr = np->daddr.s6_addr32;\n\t\t} else\n#endif\n\t\t{\n\t\t\tentry.saddr = &inet->inet_rcv_saddr;\n\t\t\tentry.daddr = &inet->inet_daddr;\n\t\t}\n\t\tentry.sport = inet->inet_num;\n\t\tentry.dport = ntohs(inet->inet_dport);\n\t\tentry.userlocks = sk->sk_userlocks;\n\n\t\tif (!inet_diag_bc_run(RTA_DATA(bc), RTA_PAYLOAD(bc), &entry))\n\t\t\treturn 0;\n\t}\n\n\treturn inet_csk_diag_fill(sk, skb, r->idiag_ext,\n\t\t\t\t  NETLINK_CB(cb->skb).pid,\n\t\t\t\t  cb->nlh->nlmsg_seq, NLM_F_MULTI, cb->nlh);\n}",
        "func": "static int inet_csk_diag_dump(struct sock *sk,\n\t\t\t      struct sk_buff *skb,\n\t\t\t      struct netlink_callback *cb)\n{\n\tstruct inet_diag_req *r = NLMSG_DATA(cb->nlh);\n\n\tif (nlmsg_attrlen(cb->nlh, sizeof(*r))) {\n\t\tstruct inet_diag_entry entry;\n\t\tconst struct nlattr *bc = nlmsg_find_attr(cb->nlh,\n\t\t\t\t\t\t\t  sizeof(*r),\n\t\t\t\t\t\t\t  INET_DIAG_REQ_BYTECODE);\n\t\tstruct inet_sock *inet = inet_sk(sk);\n\n\t\tentry.family = sk->sk_family;\n#if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)\n\t\tif (entry.family == AF_INET6) {\n\t\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\n\t\t\tentry.saddr = np->rcv_saddr.s6_addr32;\n\t\t\tentry.daddr = np->daddr.s6_addr32;\n\t\t} else\n#endif\n\t\t{\n\t\t\tentry.saddr = &inet->inet_rcv_saddr;\n\t\t\tentry.daddr = &inet->inet_daddr;\n\t\t}\n\t\tentry.sport = inet->inet_num;\n\t\tentry.dport = ntohs(inet->inet_dport);\n\t\tentry.userlocks = sk->sk_userlocks;\n\n\t\tif (!inet_diag_bc_run(nla_data(bc), nla_len(bc), &entry))\n\t\t\treturn 0;\n\t}\n\n\treturn inet_csk_diag_fill(sk, skb, r->idiag_ext,\n\t\t\t\t  NETLINK_CB(cb->skb).pid,\n\t\t\t\t  cb->nlh->nlmsg_seq, NLM_F_MULTI, cb->nlh);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,9 +4,11 @@\n {\n \tstruct inet_diag_req *r = NLMSG_DATA(cb->nlh);\n \n-\tif (cb->nlh->nlmsg_len > 4 + NLMSG_SPACE(sizeof(*r))) {\n+\tif (nlmsg_attrlen(cb->nlh, sizeof(*r))) {\n \t\tstruct inet_diag_entry entry;\n-\t\tstruct rtattr *bc = (struct rtattr *)(r + 1);\n+\t\tconst struct nlattr *bc = nlmsg_find_attr(cb->nlh,\n+\t\t\t\t\t\t\t  sizeof(*r),\n+\t\t\t\t\t\t\t  INET_DIAG_REQ_BYTECODE);\n \t\tstruct inet_sock *inet = inet_sk(sk);\n \n \t\tentry.family = sk->sk_family;\n@@ -26,7 +28,7 @@\n \t\tentry.dport = ntohs(inet->inet_dport);\n \t\tentry.userlocks = sk->sk_userlocks;\n \n-\t\tif (!inet_diag_bc_run(RTA_DATA(bc), RTA_PAYLOAD(bc), &entry))\n+\t\tif (!inet_diag_bc_run(nla_data(bc), nla_len(bc), &entry))\n \t\t\treturn 0;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (cb->nlh->nlmsg_len > 4 + NLMSG_SPACE(sizeof(*r))) {",
                "\t\tstruct rtattr *bc = (struct rtattr *)(r + 1);",
                "\t\tif (!inet_diag_bc_run(RTA_DATA(bc), RTA_PAYLOAD(bc), &entry))"
            ],
            "added_lines": [
                "\tif (nlmsg_attrlen(cb->nlh, sizeof(*r))) {",
                "\t\tconst struct nlattr *bc = nlmsg_find_attr(cb->nlh,",
                "\t\t\t\t\t\t\t  sizeof(*r),",
                "\t\t\t\t\t\t\t  INET_DIAG_REQ_BYTECODE);",
                "\t\tif (!inet_diag_bc_run(nla_data(bc), nla_len(bc), &entry))"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-3880",
        "func_name": "torvalds/linux/inet_diag_dump_reqs",
        "description": "net/ipv4/inet_diag.c in the Linux kernel before 2.6.37-rc2 does not properly audit INET_DIAG bytecode, which allows local users to cause a denial of service (kernel infinite loop) via crafted INET_DIAG_REQ_BYTECODE instructions in a netlink message that contains multiple attribute elements, as demonstrated by INET_DIAG_BC_JMP instructions.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=22e76c849d505d87c5ecf3d3e6742a65f0ff4860",
        "commit_title": "We were using nlmsg_find_attr() to look up the bytecode by attribute when",
        "commit_text": "auditing, but then just using the first attribute when actually running bytecode. So, if we received a message with two attribute elements, where only the second had type INET_DIAG_REQ_BYTECODE, we would validate and run different bytecode strings.  Fix this by consistently using nlmsg_find_attr everywhere.  ",
        "func_before": "static int inet_diag_dump_reqs(struct sk_buff *skb, struct sock *sk,\n\t\t\t       struct netlink_callback *cb)\n{\n\tstruct inet_diag_entry entry;\n\tstruct inet_diag_req *r = NLMSG_DATA(cb->nlh);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct listen_sock *lopt;\n\tstruct rtattr *bc = NULL;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tint j, s_j;\n\tint reqnum, s_reqnum;\n\tint err = 0;\n\n\ts_j = cb->args[3];\n\ts_reqnum = cb->args[4];\n\n\tif (s_j > 0)\n\t\ts_j--;\n\n\tentry.family = sk->sk_family;\n\n\tread_lock_bh(&icsk->icsk_accept_queue.syn_wait_lock);\n\n\tlopt = icsk->icsk_accept_queue.listen_opt;\n\tif (!lopt || !lopt->qlen)\n\t\tgoto out;\n\n\tif (cb->nlh->nlmsg_len > 4 + NLMSG_SPACE(sizeof(*r))) {\n\t\tbc = (struct rtattr *)(r + 1);\n\t\tentry.sport = inet->inet_num;\n\t\tentry.userlocks = sk->sk_userlocks;\n\t}\n\n\tfor (j = s_j; j < lopt->nr_table_entries; j++) {\n\t\tstruct request_sock *req, *head = lopt->syn_table[j];\n\n\t\treqnum = 0;\n\t\tfor (req = head; req; reqnum++, req = req->dl_next) {\n\t\t\tstruct inet_request_sock *ireq = inet_rsk(req);\n\n\t\t\tif (reqnum < s_reqnum)\n\t\t\t\tcontinue;\n\t\t\tif (r->id.idiag_dport != ireq->rmt_port &&\n\t\t\t    r->id.idiag_dport)\n\t\t\t\tcontinue;\n\n\t\t\tif (bc) {\n\t\t\t\tentry.saddr =\n#if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)\n\t\t\t\t\t(entry.family == AF_INET6) ?\n\t\t\t\t\tinet6_rsk(req)->loc_addr.s6_addr32 :\n#endif\n\t\t\t\t\t&ireq->loc_addr;\n\t\t\t\tentry.daddr =\n#if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)\n\t\t\t\t\t(entry.family == AF_INET6) ?\n\t\t\t\t\tinet6_rsk(req)->rmt_addr.s6_addr32 :\n#endif\n\t\t\t\t\t&ireq->rmt_addr;\n\t\t\t\tentry.dport = ntohs(ireq->rmt_port);\n\n\t\t\t\tif (!inet_diag_bc_run(RTA_DATA(bc),\n\t\t\t\t\t\t    RTA_PAYLOAD(bc), &entry))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = inet_diag_fill_req(skb, sk, req,\n\t\t\t\t\t       NETLINK_CB(cb->skb).pid,\n\t\t\t\t\t       cb->nlh->nlmsg_seq, cb->nlh);\n\t\t\tif (err < 0) {\n\t\t\t\tcb->args[3] = j + 1;\n\t\t\t\tcb->args[4] = reqnum;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\ts_reqnum = 0;\n\t}\n\nout:\n\tread_unlock_bh(&icsk->icsk_accept_queue.syn_wait_lock);\n\n\treturn err;\n}",
        "func": "static int inet_diag_dump_reqs(struct sk_buff *skb, struct sock *sk,\n\t\t\t       struct netlink_callback *cb)\n{\n\tstruct inet_diag_entry entry;\n\tstruct inet_diag_req *r = NLMSG_DATA(cb->nlh);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct listen_sock *lopt;\n\tconst struct nlattr *bc = NULL;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tint j, s_j;\n\tint reqnum, s_reqnum;\n\tint err = 0;\n\n\ts_j = cb->args[3];\n\ts_reqnum = cb->args[4];\n\n\tif (s_j > 0)\n\t\ts_j--;\n\n\tentry.family = sk->sk_family;\n\n\tread_lock_bh(&icsk->icsk_accept_queue.syn_wait_lock);\n\n\tlopt = icsk->icsk_accept_queue.listen_opt;\n\tif (!lopt || !lopt->qlen)\n\t\tgoto out;\n\n\tif (nlmsg_attrlen(cb->nlh, sizeof(*r))) {\n\t\tbc = nlmsg_find_attr(cb->nlh, sizeof(*r),\n\t\t\t\t     INET_DIAG_REQ_BYTECODE);\n\t\tentry.sport = inet->inet_num;\n\t\tentry.userlocks = sk->sk_userlocks;\n\t}\n\n\tfor (j = s_j; j < lopt->nr_table_entries; j++) {\n\t\tstruct request_sock *req, *head = lopt->syn_table[j];\n\n\t\treqnum = 0;\n\t\tfor (req = head; req; reqnum++, req = req->dl_next) {\n\t\t\tstruct inet_request_sock *ireq = inet_rsk(req);\n\n\t\t\tif (reqnum < s_reqnum)\n\t\t\t\tcontinue;\n\t\t\tif (r->id.idiag_dport != ireq->rmt_port &&\n\t\t\t    r->id.idiag_dport)\n\t\t\t\tcontinue;\n\n\t\t\tif (bc) {\n\t\t\t\tentry.saddr =\n#if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)\n\t\t\t\t\t(entry.family == AF_INET6) ?\n\t\t\t\t\tinet6_rsk(req)->loc_addr.s6_addr32 :\n#endif\n\t\t\t\t\t&ireq->loc_addr;\n\t\t\t\tentry.daddr =\n#if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)\n\t\t\t\t\t(entry.family == AF_INET6) ?\n\t\t\t\t\tinet6_rsk(req)->rmt_addr.s6_addr32 :\n#endif\n\t\t\t\t\t&ireq->rmt_addr;\n\t\t\t\tentry.dport = ntohs(ireq->rmt_port);\n\n\t\t\t\tif (!inet_diag_bc_run(nla_data(bc),\n\t\t\t\t\t\t      nla_len(bc), &entry))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = inet_diag_fill_req(skb, sk, req,\n\t\t\t\t\t       NETLINK_CB(cb->skb).pid,\n\t\t\t\t\t       cb->nlh->nlmsg_seq, cb->nlh);\n\t\t\tif (err < 0) {\n\t\t\t\tcb->args[3] = j + 1;\n\t\t\t\tcb->args[4] = reqnum;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\ts_reqnum = 0;\n\t}\n\nout:\n\tread_unlock_bh(&icsk->icsk_accept_queue.syn_wait_lock);\n\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n \tstruct inet_diag_req *r = NLMSG_DATA(cb->nlh);\n \tstruct inet_connection_sock *icsk = inet_csk(sk);\n \tstruct listen_sock *lopt;\n-\tstruct rtattr *bc = NULL;\n+\tconst struct nlattr *bc = NULL;\n \tstruct inet_sock *inet = inet_sk(sk);\n \tint j, s_j;\n \tint reqnum, s_reqnum;\n@@ -25,8 +25,9 @@\n \tif (!lopt || !lopt->qlen)\n \t\tgoto out;\n \n-\tif (cb->nlh->nlmsg_len > 4 + NLMSG_SPACE(sizeof(*r))) {\n-\t\tbc = (struct rtattr *)(r + 1);\n+\tif (nlmsg_attrlen(cb->nlh, sizeof(*r))) {\n+\t\tbc = nlmsg_find_attr(cb->nlh, sizeof(*r),\n+\t\t\t\t     INET_DIAG_REQ_BYTECODE);\n \t\tentry.sport = inet->inet_num;\n \t\tentry.userlocks = sk->sk_userlocks;\n \t}\n@@ -59,8 +60,8 @@\n \t\t\t\t\t&ireq->rmt_addr;\n \t\t\t\tentry.dport = ntohs(ireq->rmt_port);\n \n-\t\t\t\tif (!inet_diag_bc_run(RTA_DATA(bc),\n-\t\t\t\t\t\t    RTA_PAYLOAD(bc), &entry))\n+\t\t\t\tif (!inet_diag_bc_run(nla_data(bc),\n+\t\t\t\t\t\t      nla_len(bc), &entry))\n \t\t\t\t\tcontinue;\n \t\t\t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tstruct rtattr *bc = NULL;",
                "\tif (cb->nlh->nlmsg_len > 4 + NLMSG_SPACE(sizeof(*r))) {",
                "\t\tbc = (struct rtattr *)(r + 1);",
                "\t\t\t\tif (!inet_diag_bc_run(RTA_DATA(bc),",
                "\t\t\t\t\t\t    RTA_PAYLOAD(bc), &entry))"
            ],
            "added_lines": [
                "\tconst struct nlattr *bc = NULL;",
                "\tif (nlmsg_attrlen(cb->nlh, sizeof(*r))) {",
                "\t\tbc = nlmsg_find_attr(cb->nlh, sizeof(*r),",
                "\t\t\t\t     INET_DIAG_REQ_BYTECODE);",
                "\t\t\t\tif (!inet_diag_bc_run(nla_data(bc),",
                "\t\t\t\t\t\t      nla_len(bc), &entry))"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-3880",
        "func_name": "torvalds/linux/inet_twsk_diag_dump",
        "description": "net/ipv4/inet_diag.c in the Linux kernel before 2.6.37-rc2 does not properly audit INET_DIAG bytecode, which allows local users to cause a denial of service (kernel infinite loop) via crafted INET_DIAG_REQ_BYTECODE instructions in a netlink message that contains multiple attribute elements, as demonstrated by INET_DIAG_BC_JMP instructions.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=22e76c849d505d87c5ecf3d3e6742a65f0ff4860",
        "commit_title": "We were using nlmsg_find_attr() to look up the bytecode by attribute when",
        "commit_text": "auditing, but then just using the first attribute when actually running bytecode. So, if we received a message with two attribute elements, where only the second had type INET_DIAG_REQ_BYTECODE, we would validate and run different bytecode strings.  Fix this by consistently using nlmsg_find_attr everywhere.  ",
        "func_before": "static int inet_twsk_diag_dump(struct inet_timewait_sock *tw,\n\t\t\t       struct sk_buff *skb,\n\t\t\t       struct netlink_callback *cb)\n{\n\tstruct inet_diag_req *r = NLMSG_DATA(cb->nlh);\n\n\tif (cb->nlh->nlmsg_len > 4 + NLMSG_SPACE(sizeof(*r))) {\n\t\tstruct inet_diag_entry entry;\n\t\tstruct rtattr *bc = (struct rtattr *)(r + 1);\n\n\t\tentry.family = tw->tw_family;\n#if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)\n\t\tif (tw->tw_family == AF_INET6) {\n\t\t\tstruct inet6_timewait_sock *tw6 =\n\t\t\t\t\t\tinet6_twsk((struct sock *)tw);\n\t\t\tentry.saddr = tw6->tw_v6_rcv_saddr.s6_addr32;\n\t\t\tentry.daddr = tw6->tw_v6_daddr.s6_addr32;\n\t\t} else\n#endif\n\t\t{\n\t\t\tentry.saddr = &tw->tw_rcv_saddr;\n\t\t\tentry.daddr = &tw->tw_daddr;\n\t\t}\n\t\tentry.sport = tw->tw_num;\n\t\tentry.dport = ntohs(tw->tw_dport);\n\t\tentry.userlocks = 0;\n\n\t\tif (!inet_diag_bc_run(RTA_DATA(bc), RTA_PAYLOAD(bc), &entry))\n\t\t\treturn 0;\n\t}\n\n\treturn inet_twsk_diag_fill(tw, skb, r->idiag_ext,\n\t\t\t\t   NETLINK_CB(cb->skb).pid,\n\t\t\t\t   cb->nlh->nlmsg_seq, NLM_F_MULTI, cb->nlh);\n}",
        "func": "static int inet_twsk_diag_dump(struct inet_timewait_sock *tw,\n\t\t\t       struct sk_buff *skb,\n\t\t\t       struct netlink_callback *cb)\n{\n\tstruct inet_diag_req *r = NLMSG_DATA(cb->nlh);\n\n\tif (nlmsg_attrlen(cb->nlh, sizeof(*r))) {\n\t\tstruct inet_diag_entry entry;\n\t\tconst struct nlattr *bc = nlmsg_find_attr(cb->nlh,\n\t\t\t\t\t\t\t  sizeof(*r),\n\t\t\t\t\t\t\t  INET_DIAG_REQ_BYTECODE);\n\n\t\tentry.family = tw->tw_family;\n#if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)\n\t\tif (tw->tw_family == AF_INET6) {\n\t\t\tstruct inet6_timewait_sock *tw6 =\n\t\t\t\t\t\tinet6_twsk((struct sock *)tw);\n\t\t\tentry.saddr = tw6->tw_v6_rcv_saddr.s6_addr32;\n\t\t\tentry.daddr = tw6->tw_v6_daddr.s6_addr32;\n\t\t} else\n#endif\n\t\t{\n\t\t\tentry.saddr = &tw->tw_rcv_saddr;\n\t\t\tentry.daddr = &tw->tw_daddr;\n\t\t}\n\t\tentry.sport = tw->tw_num;\n\t\tentry.dport = ntohs(tw->tw_dport);\n\t\tentry.userlocks = 0;\n\n\t\tif (!inet_diag_bc_run(nla_data(bc), nla_len(bc), &entry))\n\t\t\treturn 0;\n\t}\n\n\treturn inet_twsk_diag_fill(tw, skb, r->idiag_ext,\n\t\t\t\t   NETLINK_CB(cb->skb).pid,\n\t\t\t\t   cb->nlh->nlmsg_seq, NLM_F_MULTI, cb->nlh);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,9 +4,11 @@\n {\n \tstruct inet_diag_req *r = NLMSG_DATA(cb->nlh);\n \n-\tif (cb->nlh->nlmsg_len > 4 + NLMSG_SPACE(sizeof(*r))) {\n+\tif (nlmsg_attrlen(cb->nlh, sizeof(*r))) {\n \t\tstruct inet_diag_entry entry;\n-\t\tstruct rtattr *bc = (struct rtattr *)(r + 1);\n+\t\tconst struct nlattr *bc = nlmsg_find_attr(cb->nlh,\n+\t\t\t\t\t\t\t  sizeof(*r),\n+\t\t\t\t\t\t\t  INET_DIAG_REQ_BYTECODE);\n \n \t\tentry.family = tw->tw_family;\n #if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)\n@@ -25,7 +27,7 @@\n \t\tentry.dport = ntohs(tw->tw_dport);\n \t\tentry.userlocks = 0;\n \n-\t\tif (!inet_diag_bc_run(RTA_DATA(bc), RTA_PAYLOAD(bc), &entry))\n+\t\tif (!inet_diag_bc_run(nla_data(bc), nla_len(bc), &entry))\n \t\t\treturn 0;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (cb->nlh->nlmsg_len > 4 + NLMSG_SPACE(sizeof(*r))) {",
                "\t\tstruct rtattr *bc = (struct rtattr *)(r + 1);",
                "\t\tif (!inet_diag_bc_run(RTA_DATA(bc), RTA_PAYLOAD(bc), &entry))"
            ],
            "added_lines": [
                "\tif (nlmsg_attrlen(cb->nlh, sizeof(*r))) {",
                "\t\tconst struct nlattr *bc = nlmsg_find_attr(cb->nlh,",
                "\t\t\t\t\t\t\t  sizeof(*r),",
                "\t\t\t\t\t\t\t  INET_DIAG_REQ_BYTECODE);",
                "\t\tif (!inet_diag_bc_run(nla_data(bc), nla_len(bc), &entry))"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7401",
        "func_name": "collectd/parse_part_sign_sha256",
        "description": "Incorrect interaction of the parse_packet() and parse_part_sign_sha256() functions in network.c in collectd 5.7.1 and earlier allows remote attackers to cause a denial of service (infinite loop) of a collectd instance (configured with \"SecurityLevel None\" and with empty \"AuthFile\" options) via a crafted UDP packet.",
        "git_url": "https://github.com/collectd/collectd/commit/f6be4f9b49b949b379326c3d7002476e6ce4f211",
        "commit_title": "network plugin: Fix endless loop DOS in parse_packet()",
        "commit_text": " When correct 'Signature part' is received by Collectd, configured without AuthFile option, condition for endless loop occurs due to missing increase of pointer to next unprocessed part.  This is a forward-port of #2233.  Closes: #2174",
        "func_before": "static int parse_part_sign_sha256(sockent_t *se, /* {{{ */\n                                  void **ret_buffer, size_t *ret_buffer_len,\n                                  int flags) {\n  static c_complain_t complain_no_users = C_COMPLAIN_INIT_STATIC;\n\n  char *buffer;\n  size_t buffer_len;\n  size_t buffer_offset;\n\n  size_t username_len;\n  char *secret;\n\n  part_signature_sha256_t pss;\n  uint16_t pss_head_length;\n  char hash[sizeof(pss.hash)];\n\n  gcry_md_hd_t hd;\n  gcry_error_t err;\n  unsigned char *hash_ptr;\n\n  buffer = *ret_buffer;\n  buffer_len = *ret_buffer_len;\n  buffer_offset = 0;\n\n  if (se->data.server.userdb == NULL) {\n    c_complain(\n        LOG_NOTICE, &complain_no_users,\n        \"network plugin: Received signed network packet but can't verify it \"\n        \"because no user DB has been configured. Will accept it.\");\n    return (0);\n  }\n\n  /* Check if the buffer has enough data for this structure. */\n  if (buffer_len <= PART_SIGNATURE_SHA256_SIZE)\n    return (-ENOMEM);\n\n  /* Read type and length header */\n  BUFFER_READ(&pss.head.type, sizeof(pss.head.type));\n  BUFFER_READ(&pss.head.length, sizeof(pss.head.length));\n  pss_head_length = ntohs(pss.head.length);\n\n  /* Check if the `pss_head_length' is within bounds. */\n  if ((pss_head_length <= PART_SIGNATURE_SHA256_SIZE) ||\n      (pss_head_length > buffer_len)) {\n    ERROR(\"network plugin: HMAC-SHA-256 with invalid length received.\");\n    return (-1);\n  }\n\n  /* Copy the hash. */\n  BUFFER_READ(pss.hash, sizeof(pss.hash));\n\n  /* Calculate username length (without null byte) and allocate memory */\n  username_len = pss_head_length - PART_SIGNATURE_SHA256_SIZE;\n  pss.username = malloc(username_len + 1);\n  if (pss.username == NULL)\n    return (-ENOMEM);\n\n  /* Read the username */\n  BUFFER_READ(pss.username, username_len);\n  pss.username[username_len] = 0;\n\n  assert(buffer_offset == pss_head_length);\n\n  /* Query the password */\n  secret = fbh_get(se->data.server.userdb, pss.username);\n  if (secret == NULL) {\n    ERROR(\"network plugin: Unknown user: %s\", pss.username);\n    sfree(pss.username);\n    return (-ENOENT);\n  }\n\n  /* Create a hash device and check the HMAC */\n  hd = NULL;\n  err = gcry_md_open(&hd, GCRY_MD_SHA256, GCRY_MD_FLAG_HMAC);\n  if (err != 0) {\n    ERROR(\"network plugin: Creating HMAC-SHA-256 object failed: %s\",\n          gcry_strerror(err));\n    sfree(secret);\n    sfree(pss.username);\n    return (-1);\n  }\n\n  err = gcry_md_setkey(hd, secret, strlen(secret));\n  if (err != 0) {\n    ERROR(\"network plugin: gcry_md_setkey failed: %s\", gcry_strerror(err));\n    gcry_md_close(hd);\n    sfree(secret);\n    sfree(pss.username);\n    return (-1);\n  }\n\n  gcry_md_write(hd, buffer + PART_SIGNATURE_SHA256_SIZE,\n                buffer_len - PART_SIGNATURE_SHA256_SIZE);\n  hash_ptr = gcry_md_read(hd, GCRY_MD_SHA256);\n  if (hash_ptr == NULL) {\n    ERROR(\"network plugin: gcry_md_read failed.\");\n    gcry_md_close(hd);\n    sfree(secret);\n    sfree(pss.username);\n    return (-1);\n  }\n  memcpy(hash, hash_ptr, sizeof(hash));\n\n  /* Clean up */\n  gcry_md_close(hd);\n  hd = NULL;\n\n  if (memcmp(pss.hash, hash, sizeof(pss.hash)) != 0) {\n    WARNING(\"network plugin: Verifying HMAC-SHA-256 signature failed: \"\n            \"Hash mismatch. Username: %s\",\n            pss.username);\n  } else {\n    parse_packet(se, buffer + buffer_offset, buffer_len - buffer_offset,\n                 flags | PP_SIGNED, pss.username);\n  }\n\n  sfree(secret);\n  sfree(pss.username);\n\n  *ret_buffer = buffer + buffer_len;\n  *ret_buffer_len = 0;\n\n  return (0);\n}",
        "func": "static int parse_part_sign_sha256(sockent_t *se, /* {{{ */\n                                  void **ret_buffer, size_t *ret_buffer_len,\n                                  int flags) {\n  static c_complain_t complain_no_users = C_COMPLAIN_INIT_STATIC;\n\n  char *buffer;\n  size_t buffer_len;\n  size_t buffer_offset;\n\n  size_t username_len;\n  char *secret;\n\n  part_signature_sha256_t pss;\n  uint16_t pss_head_length;\n  char hash[sizeof(pss.hash)];\n\n  gcry_md_hd_t hd;\n  gcry_error_t err;\n  unsigned char *hash_ptr;\n\n  buffer = *ret_buffer;\n  buffer_len = *ret_buffer_len;\n  buffer_offset = 0;\n\n  /* Check if the buffer has enough data for this structure. */\n  if (buffer_len <= PART_SIGNATURE_SHA256_SIZE)\n    return (-ENOMEM);\n\n  /* Read type and length header */\n  BUFFER_READ(&pss.head.type, sizeof(pss.head.type));\n  BUFFER_READ(&pss.head.length, sizeof(pss.head.length));\n  pss_head_length = ntohs(pss.head.length);\n\n  /* Check if the `pss_head_length' is within bounds. */\n  if ((pss_head_length <= PART_SIGNATURE_SHA256_SIZE) ||\n      (pss_head_length > buffer_len)) {\n    ERROR(\"network plugin: HMAC-SHA-256 with invalid length received.\");\n    return (-1);\n  }\n\n  if (se->data.server.userdb == NULL) {\n    c_complain(\n        LOG_NOTICE, &complain_no_users,\n        \"network plugin: Received signed network packet but can't verify it \"\n        \"because no user DB has been configured. Will accept it.\");\n\n    *ret_buffer = buffer + pss_head_length;\n    *ret_buffer_len -= pss_head_length;\n\n    return (0);\n  }\n\n  /* Copy the hash. */\n  BUFFER_READ(pss.hash, sizeof(pss.hash));\n\n  /* Calculate username length (without null byte) and allocate memory */\n  username_len = pss_head_length - PART_SIGNATURE_SHA256_SIZE;\n  pss.username = malloc(username_len + 1);\n  if (pss.username == NULL)\n    return (-ENOMEM);\n\n  /* Read the username */\n  BUFFER_READ(pss.username, username_len);\n  pss.username[username_len] = 0;\n\n  assert(buffer_offset == pss_head_length);\n\n  /* Query the password */\n  secret = fbh_get(se->data.server.userdb, pss.username);\n  if (secret == NULL) {\n    ERROR(\"network plugin: Unknown user: %s\", pss.username);\n    sfree(pss.username);\n    return (-ENOENT);\n  }\n\n  /* Create a hash device and check the HMAC */\n  hd = NULL;\n  err = gcry_md_open(&hd, GCRY_MD_SHA256, GCRY_MD_FLAG_HMAC);\n  if (err != 0) {\n    ERROR(\"network plugin: Creating HMAC-SHA-256 object failed: %s\",\n          gcry_strerror(err));\n    sfree(secret);\n    sfree(pss.username);\n    return (-1);\n  }\n\n  err = gcry_md_setkey(hd, secret, strlen(secret));\n  if (err != 0) {\n    ERROR(\"network plugin: gcry_md_setkey failed: %s\", gcry_strerror(err));\n    gcry_md_close(hd);\n    sfree(secret);\n    sfree(pss.username);\n    return (-1);\n  }\n\n  gcry_md_write(hd, buffer + PART_SIGNATURE_SHA256_SIZE,\n                buffer_len - PART_SIGNATURE_SHA256_SIZE);\n  hash_ptr = gcry_md_read(hd, GCRY_MD_SHA256);\n  if (hash_ptr == NULL) {\n    ERROR(\"network plugin: gcry_md_read failed.\");\n    gcry_md_close(hd);\n    sfree(secret);\n    sfree(pss.username);\n    return (-1);\n  }\n  memcpy(hash, hash_ptr, sizeof(hash));\n\n  /* Clean up */\n  gcry_md_close(hd);\n  hd = NULL;\n\n  if (memcmp(pss.hash, hash, sizeof(pss.hash)) != 0) {\n    WARNING(\"network plugin: Verifying HMAC-SHA-256 signature failed: \"\n            \"Hash mismatch. Username: %s\",\n            pss.username);\n  } else {\n    parse_packet(se, buffer + buffer_offset, buffer_len - buffer_offset,\n                 flags | PP_SIGNED, pss.username);\n  }\n\n  sfree(secret);\n  sfree(pss.username);\n\n  *ret_buffer = buffer + buffer_len;\n  *ret_buffer_len = 0;\n\n  return (0);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,14 +22,6 @@\n   buffer_len = *ret_buffer_len;\n   buffer_offset = 0;\n \n-  if (se->data.server.userdb == NULL) {\n-    c_complain(\n-        LOG_NOTICE, &complain_no_users,\n-        \"network plugin: Received signed network packet but can't verify it \"\n-        \"because no user DB has been configured. Will accept it.\");\n-    return (0);\n-  }\n-\n   /* Check if the buffer has enough data for this structure. */\n   if (buffer_len <= PART_SIGNATURE_SHA256_SIZE)\n     return (-ENOMEM);\n@@ -44,6 +36,18 @@\n       (pss_head_length > buffer_len)) {\n     ERROR(\"network plugin: HMAC-SHA-256 with invalid length received.\");\n     return (-1);\n+  }\n+\n+  if (se->data.server.userdb == NULL) {\n+    c_complain(\n+        LOG_NOTICE, &complain_no_users,\n+        \"network plugin: Received signed network packet but can't verify it \"\n+        \"because no user DB has been configured. Will accept it.\");\n+\n+    *ret_buffer = buffer + pss_head_length;\n+    *ret_buffer_len -= pss_head_length;\n+\n+    return (0);\n   }\n \n   /* Copy the hash. */",
        "diff_line_info": {
            "deleted_lines": [
                "  if (se->data.server.userdb == NULL) {",
                "    c_complain(",
                "        LOG_NOTICE, &complain_no_users,",
                "        \"network plugin: Received signed network packet but can't verify it \"",
                "        \"because no user DB has been configured. Will accept it.\");",
                "    return (0);",
                "  }",
                ""
            ],
            "added_lines": [
                "  }",
                "",
                "  if (se->data.server.userdb == NULL) {",
                "    c_complain(",
                "        LOG_NOTICE, &complain_no_users,",
                "        \"network plugin: Received signed network packet but can't verify it \"",
                "        \"because no user DB has been configured. Will accept it.\");",
                "",
                "    *ret_buffer = buffer + pss_head_length;",
                "    *ret_buffer_len -= pss_head_length;",
                "",
                "    return (0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7701",
        "func_name": "wireshark/dissect_bgp_path_attr",
        "description": "In Wireshark 2.2.0 to 2.2.5 and 2.0.0 to 2.0.11, the BGP dissector could go into an infinite loop, triggered by packet injection or a malformed capture file. This was addressed in epan/dissectors/packet-bgp.c by using a different integer data type.",
        "git_url": "https://github.com/wireshark/wireshark/commit/fa31f69b407436d0946f84baa0acdcc50962bf7a",
        "commit_title": "BGP: fix a variable underflow",
        "commit_text": " Bug: 13557 (cherry picked from commit 0bd11903938e7fbcc876888178ed9c1f085fdffc)",
        "func_before": "static void\ndissect_bgp_path_attr(proto_tree *subtree, tvbuff_t *tvb, guint16 path_attr_len, guint tvb_off, packet_info *pinfo)\n{\n    guint8        bgpa_flags;                 /* path attributes          */\n    guint8        bgpa_type;\n    gint          o;                          /* packet offset            */\n    gint          q=0;                        /* tmp                      */\n    gint          end=0;                      /* message end              */\n    int           advance;                    /* tmp                      */\n    proto_item    *ti;                        /* tree item                */\n    proto_item    *ti_communities;            /* tree communities         */\n    proto_item    *ti_community;              /* tree for each community  */\n    proto_item    *attr_len_item;\n    proto_item    *aigp_type_item;\n    proto_tree    *subtree2;                  /* path attribute subtree   */\n    proto_tree    *subtree3;                  /* subtree for attributes   */\n    proto_tree    *subtree4;                  /* subtree for attributes   */\n    proto_tree    *subtree5;                  /* subtree for attributes   */\n    proto_tree    *subtree6;                  /* subtree for attributes   */\n    proto_tree    *attr_set_subtree;          /* subtree for attr_set     */\n    proto_tree    *as_path_segment_tree;      /* subtree for AS_PATH segments */\n    gint          number_as_segment=0;        /* Number As segment        */\n    proto_tree    *communities_tree;          /* subtree for COMMUNITIES  */\n    proto_tree    *community_tree;            /* subtree for a community  */\n    proto_tree    *cluster_list_tree;         /* subtree for CLUSTER_LIST */\n    int           i=0, j, k;                  /* tmp                      */\n    guint8        type=0;                     /* AS_PATH segment type     */\n    guint8        length=0;                   /* AS_PATH segment length   */\n    wmem_strbuf_t *junk_emstr;                /* tmp                      */\n    guint32       aggregator_as;\n    guint16       ssa_type;                   /* SSA T + Type */\n    guint16       ssa_len;                    /* SSA TLV Length */\n    guint8        ssa_v3_len;                 /* SSA L2TPv3 Cookie Length */\n    guint16       encaps_tunnel_type;         /* Encapsulation Tunnel Type */\n    guint16       encaps_tunnel_len;          /* Encapsulation TLV Length */\n    guint8        encaps_tunnel_subtype;      /* Encapsulation Tunnel Sub-TLV Type */\n    guint8        encaps_tunnel_sublen;       /* Encapsulation TLV Sub-TLV Length */\n    guint8        aigp_type;                  /* AIGP TLV type from AIGP attribute */\n\n    o = tvb_off;\n    junk_emstr = wmem_strbuf_new_label(wmem_packet_scope());\n\n    while (i < path_attr_len) {\n        proto_item *ti_pa, *ti_flags;\n        int     off;\n        guint16 alen, aoff, tlen, aoff_save;\n        guint16 af;\n        guint8  saf, snpa;\n        guint8  nexthop_len;\n        guint8  asn_len = 0;\n\n        static const int * path_flags[] = {\n            &hf_bgp_update_path_attribute_flags_optional,\n            &hf_bgp_update_path_attribute_flags_transitive,\n            &hf_bgp_update_path_attribute_flags_partial,\n            &hf_bgp_update_path_attribute_flags_extended_length,\n            NULL\n        };\n\n        bgpa_flags = tvb_get_guint8(tvb, o + i);\n        bgpa_type = tvb_get_guint8(tvb, o + i+1);\n\n        /* check for the Extended Length bit */\n        if (bgpa_flags & BGP_ATTR_FLAG_EXTENDED_LENGTH) {\n            alen = tvb_get_ntohs(tvb, o + i + BGP_SIZE_OF_PATH_ATTRIBUTE);\n            aoff = BGP_SIZE_OF_PATH_ATTRIBUTE+2;\n        } else {\n            alen = tvb_get_guint8(tvb, o + i + BGP_SIZE_OF_PATH_ATTRIBUTE);\n            aoff = BGP_SIZE_OF_PATH_ATTRIBUTE+1;\n        }\n        tlen = alen;\n\n        ti_pa = proto_tree_add_item(subtree, hf_bgp_update_path_attribute, tvb, o + i, tlen + aoff, ENC_NA);\n        proto_item_append_text(ti_pa, \" - %s\", val_to_str(bgpa_type, bgpattr_type, \"Unknown (%u)\"));\n\n        subtree2 = proto_item_add_subtree(ti_pa, ett_bgp_attr);\n\n        ti_flags = proto_tree_add_bitmask(subtree2, tvb, o + i, hf_bgp_update_path_attribute_flags, ett_bgp_attr_flags, path_flags, ENC_NA);\n\n        proto_item_append_text(ti_flags,\"%s%s%s%s\",\n                 ((bgpa_flags & BGP_ATTR_FLAG_OPTIONAL) == 0) ? \": Well-known\" : \": Optional\",\n                 ((bgpa_flags & BGP_ATTR_FLAG_TRANSITIVE) == 0) ? \", Non-transitive\" : \", Transitive\",\n                 ((bgpa_flags & BGP_ATTR_FLAG_PARTIAL) == 0) ? \", Complete\" : \", Partial\",\n                 ((bgpa_flags & BGP_ATTR_FLAG_EXTENDED_LENGTH) == 0) ? \"\" : \", Extended Length\");\n\n        proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_type_code, tvb, o + i + 1, 1, ENC_BIG_ENDIAN);\n\n        attr_len_item = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_length, tvb, o + i + BGP_SIZE_OF_PATH_ATTRIBUTE,\n                                            aoff - BGP_SIZE_OF_PATH_ATTRIBUTE, ENC_BIG_ENDIAN);\n\n        /* Path Attribute Type */\n        switch (bgpa_type) {\n            case BGPTYPE_ORIGIN:\n                if (tlen != 1) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Origin (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                } else {\n                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_origin, tvb,\n                                        o + i + aoff, 1, ENC_BIG_ENDIAN);\n                    proto_item_append_text(ti_pa, \": %s\", val_to_str_const(tvb_get_guint8(tvb, o + i + aoff), bgpattr_origin, \"Unknown\"));\n                }\n                break;\n            case BGPTYPE_AS_PATH:\n            case BGPTYPE_AS4_PATH:\n                /* Apply heuristic to guess if we are facing 2 or 4 bytes ASN\n                   (o + i + aoff) =\n                   (o + current attribute + aoff bytes to first tuple)\n                   heuristic also tell us how many AS segments we have */\n                asn_len = heuristic_as2_or_4_from_as_path(tvb, o+i+aoff, o+i+aoff+tlen,\n                                                          bgpa_type, &number_as_segment);\n                if (asn_len == 255)\n                    {\n                        expert_add_info_format(pinfo, ti_pa, &ei_bgp_attr_as_path_as_len_err,\n                                               \"ASN length uncalculated by heuristic : %u\", asn_len);\n                        break;\n                    }\n                proto_item_append_text(ti_pa,\": \");\n                if(tlen == 0) {\n                    proto_item_append_text(ti_pa,\"empty\");\n                }\n                q = o + i + aoff;\n                for (k=0; k < number_as_segment; k++)\n                {\n                    type = tvb_get_guint8(tvb, q);\n                    length = tvb_get_guint8(tvb, q+1);\n                    ti = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_as_path_segment, tvb,\n                                             q, length * asn_len + 2, ENC_NA);\n                    proto_item_append_text(ti,\": \");\n                    as_path_segment_tree = proto_item_add_subtree(ti, ett_bgp_as_path_segment);\n                    proto_tree_add_item(as_path_segment_tree, hf_bgp_update_path_attribute_as_path_segment_type, tvb,\n                                        q, 1, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(as_path_segment_tree, hf_bgp_update_path_attribute_as_path_segment_length, tvb,\n                                        q+1, 1, ENC_BIG_ENDIAN);\n                    switch(type)\n                    {\n                        case AS_SET:\n                            proto_item_append_text(ti_pa, \"{\");\n                            proto_item_append_text(ti, \"{\");\n                            break;\n                        case AS_CONFED_SET:\n                            proto_item_append_text(ti_pa, \"[\");\n                            proto_item_append_text(ti, \"[\");\n                            break;\n                        case AS_CONFED_SEQUENCE:\n                            proto_item_append_text(ti_pa, \"(\");\n                            proto_item_append_text(ti, \"(\");\n                            break;\n                    }\n\n                    q = q + 2;\n                    for (j = 0; j < length; j++)\n                    {\n                        if(asn_len == 2) {\n                            proto_tree_add_item(as_path_segment_tree,\n                                                hf_bgp_update_path_attribute_as_path_segment_as2,\n                                                tvb, q, 2, ENC_BIG_ENDIAN);\n                            proto_item_append_text(ti_pa, \"%u\",\n                                                   tvb_get_ntohs(tvb, q));\n                            proto_item_append_text(ti, \"%u\",\n                                                   tvb_get_ntohs(tvb, q));\n                        }\n                        else if (asn_len == 4) {\n                            proto_tree_add_item(as_path_segment_tree,\n                                                hf_bgp_update_path_attribute_as_path_segment_as4,\n                                                tvb, q, 4, ENC_BIG_ENDIAN);\n                            proto_item_append_text(ti_pa, \"%u\",\n                                                   tvb_get_ntohl(tvb, q));\n                            proto_item_append_text(ti, \"%u\",\n                                                   tvb_get_ntohl(tvb, q));\n                        }\n                        if (j != length-1)\n                        {\n                            proto_item_append_text(ti_pa, \"%s\",\n                                                   (type == AS_SET || type == AS_CONFED_SET) ?\n                                                   \", \" : \" \");\n                            proto_item_append_text(ti, \"%s\",\n                                                   (type == AS_SET || type == AS_CONFED_SET) ?\n                                                   \", \" : \" \");\n                        }\n                        q += asn_len;\n                    }\n                    switch(type)\n                    {\n                        case AS_SET:\n                            proto_item_append_text(ti_pa, \"} \");\n                            proto_item_append_text(ti, \"}\");\n                            break;\n                        case AS_CONFED_SET:\n                            proto_item_append_text(ti_pa, \"] \");\n                            proto_item_append_text(ti, \"]\");\n                            break;\n                        case AS_CONFED_SEQUENCE:\n                            proto_item_append_text(ti_pa, \") \");\n                            proto_item_append_text(ti, \")\");\n                            break;\n                        default:\n                            proto_item_append_text(ti_pa, \" \");\n                            break;\n                    }\n                }\n\n                break;\n            case BGPTYPE_NEXT_HOP:\n                if (tlen != 4) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Next hop (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                } else {\n                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_next_hop, tvb,\n                                        o + i + aoff, 4, ENC_BIG_ENDIAN);\n                    proto_item_append_text(ti_pa, \": %s \", tvb_ip_to_str(tvb, o + i + aoff));\n                }\n                break;\n            case BGPTYPE_MULTI_EXIT_DISC:\n                if (tlen != 4) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Multiple exit discriminator (invalid): %u byte%s\",\n                                                 tlen, plurality(tlen, \"\", \"s\"));\n                } else {\n                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_multi_exit_disc, tvb,\n                                        o + i + aoff, tlen, ENC_BIG_ENDIAN);\n                    proto_item_append_text(ti_pa,\": %u\", tvb_get_ntohl(tvb, o + i + aoff));\n                }\n                break;\n            case BGPTYPE_LOCAL_PREF:\n                if (tlen != 4) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Local preference (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                } else {\n                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_local_pref, tvb,\n                                        o + i + aoff, tlen, ENC_BIG_ENDIAN);\n                    proto_item_append_text(ti_pa, \": %u\", tvb_get_ntohl(tvb, o + i + aoff));\n                }\n                break;\n            case BGPTYPE_ATOMIC_AGGREGATE:\n                if (tlen != 0) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Atomic aggregate (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                }\n                break;\n            case BGPTYPE_AGGREGATOR:\n                if (tlen != 6 && tlen != 8) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Aggregator (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                    break;\n                }\n            case BGPTYPE_AS4_AGGREGATOR:\n                if (bgpa_type == BGPTYPE_AS4_AGGREGATOR && tlen != 8)\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Aggregator (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                else {\n                    asn_len = tlen - 4;\n                    aggregator_as = (asn_len == 2) ?\n                        tvb_get_ntohs(tvb, o + i + aoff) :\n                        tvb_get_ntohl(tvb, o + i + aoff);\n                    proto_tree_add_uint(subtree2, hf_bgp_update_path_attribute_aggregator_as, tvb,\n                                        o + i + aoff, asn_len, aggregator_as);\n                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_aggregator_origin, tvb,\n                                        o + i + aoff + asn_len, 4, ENC_BIG_ENDIAN);\n\n                    proto_item_append_text(ti_pa, \": AS: %u origin: %s\", aggregator_as,\n                                           tvb_ip_to_str(tvb, o + i + aoff + asn_len));\n                }\n                break;\n            case BGPTYPE_COMMUNITIES:\n                if (tlen % 4 != 0) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Communities (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                    break;\n                }\n\n                proto_item_append_text(ti_pa, \": \");\n\n                ti_communities = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_communities,\n                                                     tvb, o + i + aoff, tlen, ENC_NA);\n\n                communities_tree = proto_item_add_subtree(ti_communities,\n                                                          ett_bgp_communities);\n                proto_item_append_text(ti_communities, \": \");\n                /* (o + i + aoff) =\n                   (o + current attribute + aoff bytes to first tuple) */\n                q = o + i + aoff;\n                end = q + tlen;\n\n                /* snarf each community */\n                while (q < end) {\n                    /* check for reserved values */\n                    guint32 community = tvb_get_ntohl(tvb, q);\n                    if ((community & 0xFFFF0000) == FOURHEX0 ||\n                        (community & 0xFFFF0000) == FOURHEXF) {\n                        proto_tree_add_item(communities_tree, hf_bgp_update_path_attribute_community_well_known,\n                                            tvb, q - 3 + aoff, 4, ENC_BIG_ENDIAN);\n                        proto_item_append_text(ti_pa, \"%s \", val_to_str_const(community, community_vals, \"Reserved\"));\n                        proto_item_append_text(ti_communities, \"%s \", val_to_str_const(community, community_vals, \"Reserved\"));\n                    }\n                    else {\n                        ti_community = proto_tree_add_item(communities_tree, hf_bgp_update_path_attribute_community, tvb,\n                                                           q - 3 + aoff, 4, ENC_NA);\n                        community_tree = proto_item_add_subtree(ti_community,\n                                                                ett_bgp_community);\n                        proto_tree_add_item(community_tree, hf_bgp_update_path_attribute_community_as,\n                                            tvb, q - 3 + aoff, 2, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(community_tree, hf_bgp_update_path_attribute_community_value,\n                                            tvb, q - 1 + aoff, 2, ENC_BIG_ENDIAN);\n                        proto_item_append_text(ti_pa, \"%u:%u \",tvb_get_ntohs(tvb, q - 3 + aoff),\n                                               tvb_get_ntohs(tvb, q -1 + aoff));\n                        proto_item_append_text(ti_communities, \"%u:%u \",tvb_get_ntohs(tvb, q - 3 + aoff),\n                                               tvb_get_ntohs(tvb, q -1 + aoff));\n                        proto_item_append_text(ti_community, \": %u:%u \",tvb_get_ntohs(tvb, q - 3 + aoff),\n                                               tvb_get_ntohs(tvb, q -1 + aoff));\n                    }\n\n                    q += 4;\n                }\n\n\n                break;\n            case BGPTYPE_ORIGINATOR_ID:\n                if (tlen != 4) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Originator identifier (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                } else {\n                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_originator_id, tvb,\n                                        o + i + aoff, tlen, ENC_BIG_ENDIAN);\n                    proto_item_append_text(ti_pa, \": %s \", tvb_ip_to_str(tvb, o + i + aoff));\n                }\n                break;\n            case BGPTYPE_MP_REACH_NLRI:\n                /*\n                 * RFC 2545 specifies that there may be more than one\n                 * address in the MP_REACH_NLRI attribute in section\n                 * 3, \"Constructing the Next Hop field\".\n                 *\n                 * Yes, RFC 2858 says you can't do that, and, yes, RFC\n                 * 2858 obsoletes RFC 2283, which says you can do that,\n                 * but that doesn't mean we shouldn't dissect packets\n                 * that conform to RFC 2283 but not RFC 2858, as some\n                 * device on the network might implement the 2283-style\n                 * BGP extensions rather than RFC 2858-style extensions.\n                 */\n                af = tvb_get_ntohs(tvb, o + i + aoff);\n                proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_mp_reach_nlri_address_family, tvb,\n                                    o + i + aoff, 2, ENC_BIG_ENDIAN);\n                saf = tvb_get_guint8(tvb, o + i + aoff + 2) ;\n                proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_mp_reach_nlri_safi, tvb,\n                                    o + i + aoff+2, 1, ENC_BIG_ENDIAN);\n                nexthop_len = tvb_get_guint8(tvb, o + i + aoff + 3);\n                subtree3 = proto_tree_add_subtree_format(subtree2, tvb, o + i + aoff + 3,\n                                                         nexthop_len + 1, ett_bgp_mp_nhna, NULL,\n                                                         \"Next hop network address (%d byte%s)\",\n                                                         nexthop_len, plurality(nexthop_len, \"\", \"s\"));\n\n                /*\n                 * The addresses don't contain lengths, so if we\n                 * don't understand the address family type, we\n                 * cannot parse the subsequent addresses as we\n                 * don't know how long they are.\n                 */\n                switch (af) {\n                    default:\n                    proto_tree_add_expert(subtree3, pinfo, &ei_bgp_unknown_afi, tvb, o + i + aoff + 4, nexthop_len);\n                    break;\n\n                    case AFNUM_INET:\n                    case AFNUM_INET6:\n                    case AFNUM_L2VPN:\n                    case AFNUM_L2VPN_OLD:\n                    case AFNUM_LINK_STATE:\n\n                        j = 0;\n                        while (j < nexthop_len) {\n                            advance = mp_addr_to_str(af, saf, tvb, o + i + aoff + 4 + j,\n                                                     junk_emstr, nexthop_len) ;\n                            if (advance == 0) /* catch if this is a unknown AFI type*/\n                                break;\n                            if (j + advance > nexthop_len)\n                                break;\n                            proto_tree_add_string(subtree3, hf_bgp_update_path_attribute_mp_reach_nlri_next_hop, tvb,\n                                                 o + i + aoff + 4 + j, advance, wmem_strbuf_get_str(junk_emstr));\n\n                            j += advance;\n                        }\n                        break;\n                } /* switch (af) */\n\n                aoff_save = aoff;\n                tlen -= nexthop_len + 4;\n                aoff += nexthop_len + 4 ;\n\n                off = 0;\n                snpa = tvb_get_guint8(tvb, o + i + aoff);\n                ti = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_mp_reach_nlri_nbr_snpa, tvb,\n                                         o + i + aoff, 1, ENC_BIG_ENDIAN);\n                off++;\n                if (snpa) {\n                    subtree3 = proto_item_add_subtree(ti, ett_bgp_mp_snpa);\n                    for (/*nothing*/; snpa > 0; snpa--) {\n                        guint8 snpa_length = tvb_get_guint8(tvb, o + i + aoff + off);\n                        proto_tree_add_item(subtree3, hf_bgp_update_path_attribute_mp_reach_nlri_snpa_length, tvb,\n                                            o + i + aoff + off, 1, ENC_BIG_ENDIAN);\n                        off++;\n                        proto_tree_add_item(subtree3, hf_bgp_update_path_attribute_mp_reach_nlri_snpa, tvb,\n                                            o + i + aoff + off, snpa_length, ENC_NA);\n                        off += snpa_length;\n                    }\n                }\n                tlen -= off;\n                aoff += off;\n\n                subtree3 = proto_tree_add_subtree_format(subtree2, tvb, o + i + aoff, tlen,\n                                                         ett_bgp_mp_reach_nlri, NULL, \"Network layer reachability information (%u byte%s)\",\n                                                         tlen, plurality(tlen, \"\", \"s\"));\n                if (tlen)  {\n                    if (af != AFNUM_INET && af != AFNUM_INET6 && af != AFNUM_L2VPN && af != AFNUM_LINK_STATE) {\n                        proto_tree_add_expert(subtree3, pinfo, &ei_bgp_unknown_afi, tvb, o + i + aoff, tlen);\n                    } else {\n                        while (tlen > 0) {\n                            advance = decode_prefix_MP(subtree3,\n                                                       hf_bgp_mp_reach_nlri_ipv4_prefix,\n                                                       hf_bgp_mp_reach_nlri_ipv6_prefix,\n                                                       af, saf,\n                                                       tvb, o + i + aoff, \"MP Reach NLRI\", pinfo);\n                            if (advance < 0)\n                                break;\n                            tlen -= advance;\n                            aoff += advance;\n                        }\n                    }\n                }\n                aoff = aoff_save;\n                break;\n            case BGPTYPE_MP_UNREACH_NLRI:\n                af = tvb_get_ntohs(tvb, o + i + aoff);\n                proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_mp_unreach_nlri_address_family, tvb,\n                                    o + i + aoff, 2, ENC_BIG_ENDIAN);\n                saf = tvb_get_guint8(tvb, o + i + aoff + 2) ;\n                proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_mp_unreach_nlri_safi, tvb,\n                                    o + i + aoff+2, 1, ENC_BIG_ENDIAN);\n\n                subtree3 = proto_tree_add_subtree_format(subtree2, tvb, o + i + aoff + 3,\n                                                         tlen - 3, ett_bgp_mp_unreach_nlri, NULL, \"Withdrawn routes (%u byte%s)\", tlen - 3,\n                                                         plurality(tlen - 3, \"\", \"s\"));\n\n                aoff_save = aoff;\n                tlen -= 3;\n                aoff += 3;\n                if (tlen > 0) {\n\n                    while (tlen > 0) {\n                        advance = decode_prefix_MP(subtree3,\n                                                   hf_bgp_mp_unreach_nlri_ipv4_prefix,\n                                                   hf_bgp_mp_unreach_nlri_ipv6_prefix,\n                                                   af, saf,\n                                                   tvb, o + i + aoff, \"MP Unreach NLRI\", pinfo);\n                        if (advance < 0)\n                            break;\n                        tlen -= advance;\n                        aoff += advance;\n                    }\n                }\n                aoff = aoff_save;\n                break;\n            case BGPTYPE_CLUSTER_LIST:\n                if (tlen % 4 != 0) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Cluster list (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                    break;\n                }\n\n                ti = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_cluster_list,\n                                         tvb, o + i + aoff, tlen, ENC_NA);\n                cluster_list_tree = proto_item_add_subtree(ti,\n                                                               ett_bgp_cluster_list);\n\n                /* (o + i + aoff) =\n                   (o + current attribute + aoff bytes to first tuple) */\n                q = o + i + aoff;\n                end = q + tlen;\n                proto_item_append_text(ti, \":\");\n                proto_item_append_text(ti_pa, \":\");\n                /* snarf each cluster identifier */\n                while (q < end) {\n                    proto_tree_add_item(cluster_list_tree, hf_bgp_update_path_attribute_cluster_id,\n                                        tvb, q - 3 + aoff, 4, ENC_NA);\n                    proto_item_append_text(ti, \" %s\", tvb_ip_to_str(tvb, q-3+aoff));\n                    proto_item_append_text(ti_pa, \" %s\", tvb_ip_to_str(tvb, q-3+aoff));\n                    q += 4;\n                }\n\n                break;\n            case BGPTYPE_EXTENDED_COMMUNITY:\n                if (tlen %8 != 0) {\n                    expert_add_info_format(pinfo, attr_len_item, &ei_bgp_ext_com_len_bad,\n                                           \"Community length %u wrong, must be modulo 8\", tlen);\n                } else {\n                    dissect_bgp_update_ext_com(subtree2, tvb, tlen, o+i+aoff);\n                }\n                break;\n            case BGPTYPE_SAFI_SPECIFIC_ATTR:\n                q = o + i + aoff;\n                end = o + i + aoff + tlen ;\n\n                while(q < end) {\n                    ssa_type = tvb_get_ntohs(tvb, q) & BGP_SSA_TYPE;\n                    ssa_len = tvb_get_ntohs(tvb, q + 2);\n\n                    subtree3 = proto_tree_add_subtree_format(subtree2, tvb, q, MIN(ssa_len + 4, end - q),\n                                                             ett_bgp_ssa, NULL, \"%s Information\",\n                                                             val_to_str_const(ssa_type, bgp_ssa_type, \"Unknown SSA\"));\n\n                    proto_tree_add_item(subtree3, hf_bgp_ssa_t, tvb,\n                                        q, 1, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(subtree3, hf_bgp_ssa_type, tvb, q, 2, ENC_BIG_ENDIAN);\n\n                    proto_tree_add_item(subtree3, hf_bgp_ssa_len, tvb, q + 2, 2, ENC_BIG_ENDIAN);\n\n                    if ((ssa_len == 0) || (q + ssa_len > end)) {\n                        proto_tree_add_expert_format(subtree3, pinfo, &ei_bgp_length_invalid, tvb, q + 2,\n                                                     end - q - 2, \"Invalid Length of %u\", ssa_len);\n                        break;\n                    }\n\n                    switch (ssa_type) {\n                        case BGP_SSA_L2TPv3:\n                            proto_tree_add_item(subtree3, hf_bgp_ssa_l2tpv3_pref, tvb,\n                                                q + 4, 2, ENC_BIG_ENDIAN);\n\n                            subtree4 = proto_tree_add_subtree(subtree3, tvb, q + 6, 1, ett_bgp_ssa_subtree, NULL, \"Flags\");\n                            proto_tree_add_item(subtree4, hf_bgp_ssa_l2tpv3_s, tvb,\n                                                q + 6, 1, ENC_BIG_ENDIAN);\n                            proto_tree_add_item(subtree4, hf_bgp_ssa_l2tpv3_unused, tvb,\n                                                q + 6, 1, ENC_BIG_ENDIAN);\n\n                            ssa_v3_len = tvb_get_guint8(tvb, q + 7);\n                            if (ssa_v3_len + 8 == ssa_len){\n                                proto_tree_add_item(subtree3, hf_bgp_ssa_l2tpv3_cookie_len, tvb,\n                                                    q + 7, 1, ENC_BIG_ENDIAN);\n                            } else {\n                                proto_tree_add_expert_format(subtree3, pinfo, &ei_bgp_length_invalid, tvb, q + 7, 1,\n                                                             \"Invalid Cookie Length of %u\", ssa_v3_len);\n                                q += ssa_len + 4; /* 4 from type and length */\n                                break;\n                            }\n                            proto_tree_add_item(subtree3, hf_bgp_ssa_l2tpv3_session_id, tvb,\n                                                q + 8, 4, ENC_BIG_ENDIAN);\n                            if (ssa_v3_len)\n                                proto_tree_add_item(subtree3, hf_bgp_ssa_l2tpv3_cookie, tvb,\n                                                    q + 12, ssa_v3_len, ENC_NA);\n                            q += ssa_len + 4; /* 4 from type and length */\n                            break;\n                        case BGP_SSA_mGRE:\n                        case BGP_SSA_IPSec:\n                        case BGP_SSA_MPLS:\n                        default:\n                            proto_tree_add_item(subtree3, hf_bgp_ssa_value, tvb,\n                                                q + 4, ssa_len, ENC_NA);\n                            q += ssa_len + 4; /* 4 from type and length */\n                            break;\n                        case BGP_SSA_L2TPv3_IN_IPSec:\n                        case BGP_SSA_mGRE_IN_IPSec:\n                            /* These contain BGP_SSA_IPSec and BGP_SSA_L2TPv3/BGP_SSA_mGRE */\n                            q += 4; /* 4 from type and length */\n                            break;\n                    } /* switch (bgpa.bgpa_type) */\n                }\n                break;\n            case BGPTYPE_TUNNEL_ENCAPS_ATTR:\n                q = o + i + aoff;\n                end = o + i + aoff + tlen;\n\n                subtree3 = proto_tree_add_subtree(subtree2, tvb, q, tlen, ett_bgp_tunnel_tlv, NULL, \"TLV Encodings\");\n\n                while (q < end) {\n                    encaps_tunnel_type = tvb_get_ntohs(tvb, q);\n                    encaps_tunnel_len = tvb_get_ntohs(tvb, q + 2);\n\n                    subtree4 = proto_tree_add_subtree_format(subtree3, tvb, q, encaps_tunnel_len + 4,\n                                         ett_bgp_tunnel_tlv_subtree, NULL, \"%s (%u bytes)\",\n                                         val_to_str_const(encaps_tunnel_type, bgp_attr_tunnel_type, \"Unknown\"), encaps_tunnel_len + 4);\n\n                    proto_tree_add_item(subtree4, hf_bgp_update_encaps_tunnel_tlv_type, tvb, q, 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(subtree4, hf_bgp_update_encaps_tunnel_tlv_len, tvb, q + 2, 2, ENC_BIG_ENDIAN);\n\n                    subtree5 = proto_tree_add_subtree(subtree4, tvb, q + 4, encaps_tunnel_len, ett_bgp_tunnel_subtlv, NULL, \"Sub-TLV Encodings\");\n\n                    q += 4;\n                    j = q + encaps_tunnel_len;\n                    while ( q < j ) {\n                        encaps_tunnel_subtype = tvb_get_guint8(tvb, q);\n                        encaps_tunnel_sublen = tvb_get_guint8(tvb, q + 1);\n\n                        subtree6 = proto_tree_add_subtree_format(subtree5, tvb, q, encaps_tunnel_sublen + 2, ett_bgp_tunnel_tlv_subtree, NULL, \"%s (%u bytes)\", val_to_str_const(encaps_tunnel_subtype, subtlv_type, \"Unknown\"), encaps_tunnel_sublen + 2);\n\n                        proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_type, tvb, q, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_len, tvb, q + 1, 1, ENC_BIG_ENDIAN);\n\n                        switch (encaps_tunnel_subtype) {\n                            case TUNNEL_SUBTLV_ENCAPSULATION:\n                                if (encaps_tunnel_type == TUNNEL_TYPE_L2TP_OVER_IP) {\n                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_session_id, tvb, q + 2, 4, ENC_BIG_ENDIAN);\n                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_cookie, tvb, q + 6, encaps_tunnel_sublen - 4, ENC_NA);\n                                } else if (encaps_tunnel_type == TUNNEL_TYPE_GRE) {\n                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_gre_key, tvb, q + 2, 4, ENC_BIG_ENDIAN);\n                                }\n                                break;\n                            case TUNNEL_SUBTLV_PROTO_TYPE:\n                                proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_gre_key, tvb, q + 2, 2, ENC_BIG_ENDIAN);\n                                break;\n                            case TUNNEL_SUBTLV_COLOR:\n                                proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_color_value, tvb, q + 6, 4, ENC_BIG_ENDIAN);\n                               break;\n                            case TUNNEL_SUBTLV_LOAD_BALANCE:\n                                if (encaps_tunnel_type == TUNNEL_TYPE_L2TP_OVER_IP || encaps_tunnel_type == TUNNEL_TYPE_GRE) {\n                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_lb_block_length, tvb, q + 2, 4, ENC_BIG_ENDIAN);\n                                }\n                                break;\n                            default:\n                                break;\n                        } /* switch (encaps_tunnel_subtype) */\n\n                        q += 2 + encaps_tunnel_sublen; /* type and length + length of value */\n                    }\n\n                }\n\n                break;\n            case BGPTYPE_AIGP:\n                q = o + i + aoff;\n                ti = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_aigp, tvb, q, tlen, ENC_NA);\n                subtree3 = proto_item_add_subtree(ti, ett_bgp_aigp_attr);\n                aigp_type_item =  proto_tree_add_item(subtree3, hf_bgp_aigp_type, tvb, q, 1, ENC_BIG_ENDIAN);\n                aigp_type = tvb_get_guint8(tvb,q);\n                switch (aigp_type) {\n                    case AIGP_TLV_TYPE :\n                        proto_tree_add_item(subtree3, hf_bgp_aigp_tlv_length, tvb, q+1, 2, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(subtree3, hf_bgp_aigp_accu_igp_metric, tvb, q+3, 8, ENC_BIG_ENDIAN);\n                        proto_item_append_text(ti, \": %\" G_GINT64_MODIFIER \"u\", tvb_get_ntoh64(tvb, q+3));\n                        proto_item_append_text(ti_pa, \": %\" G_GINT64_MODIFIER \"u\", tvb_get_ntoh64(tvb, q+3));\n                        break;\n                    default :\n                        expert_add_info_format(pinfo, aigp_type_item, &ei_bgp_attr_aigp_type,\n                                               \"AIGP type %u unknown\", aigp_type);\n                }\n                break;\n            case BGPTYPE_LINK_STATE_ATTR:\n\n                q = o + i + aoff;\n                end = o + i + aoff + tlen;\n\n                ti = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_link_state, tvb, q, tlen, ENC_NA);\n                subtree3 = proto_item_add_subtree(ti, ett_bgp_link_state);\n\n                while (q < end) {\n                    advance = decode_link_state_attribute_tlv(subtree3, tvb, q, pinfo);\n                    if (advance < 0)\n                        break;\n\n                    q += advance;\n                }\n                break;\n\n            case BGPTYPE_PMSI_TUNNEL_ATTR:\n                dissect_bgp_update_pmsi_attr(pinfo, subtree2, tvb, tlen, o+i+aoff);\n                break;\n\n            case BGPTYPE_ATTR_SET:\n                if (alen >= 4) {\n                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_attrset_origin_as, tvb,\n                                        o + i + aoff, 4, ENC_BIG_ENDIAN);\n                    if (alen > 4) {\n                        ti =  proto_tree_add_item(subtree2, hf_bgp_update_path_attributes, tvb, o+i+aoff+4, alen-4, ENC_NA);\n                        attr_set_subtree = proto_item_add_subtree(ti, ett_bgp_attrs);\n                        dissect_bgp_path_attr(attr_set_subtree, tvb, alen-4, o+i+aoff+4, pinfo);\n                    }\n                } else {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, alen,\n                                                 \"Attribute set (invalid): %u bytes%s\",\n                                                 alen, plurality(alen, \"\", \"s\"));\n                }\n                break;\n            default:\n                proto_tree_add_item(subtree2, hf_bgp_update_path_attributes_unknown, tvb, o + i + aoff, tlen, ENC_NA);\n                break;\n        } /* switch (bgpa.bgpa_type) */ /* end of second switch */\n\n        i += alen + aoff;\n    }\n}",
        "func": "static void\ndissect_bgp_path_attr(proto_tree *subtree, tvbuff_t *tvb, guint16 path_attr_len, guint tvb_off, packet_info *pinfo)\n{\n    guint8        bgpa_flags;                 /* path attributes          */\n    guint8        bgpa_type;\n    gint          o;                          /* packet offset            */\n    gint          q=0;                        /* tmp                      */\n    gint          end=0;                      /* message end              */\n    int           advance;                    /* tmp                      */\n    proto_item    *ti;                        /* tree item                */\n    proto_item    *ti_communities;            /* tree communities         */\n    proto_item    *ti_community;              /* tree for each community  */\n    proto_item    *attr_len_item;\n    proto_item    *aigp_type_item;\n    proto_tree    *subtree2;                  /* path attribute subtree   */\n    proto_tree    *subtree3;                  /* subtree for attributes   */\n    proto_tree    *subtree4;                  /* subtree for attributes   */\n    proto_tree    *subtree5;                  /* subtree for attributes   */\n    proto_tree    *subtree6;                  /* subtree for attributes   */\n    proto_tree    *attr_set_subtree;          /* subtree for attr_set     */\n    proto_tree    *as_path_segment_tree;      /* subtree for AS_PATH segments */\n    gint          number_as_segment=0;        /* Number As segment        */\n    proto_tree    *communities_tree;          /* subtree for COMMUNITIES  */\n    proto_tree    *community_tree;            /* subtree for a community  */\n    proto_tree    *cluster_list_tree;         /* subtree for CLUSTER_LIST */\n    int           i=0, j, k;                  /* tmp                      */\n    guint8        type=0;                     /* AS_PATH segment type     */\n    guint8        length=0;                   /* AS_PATH segment length   */\n    wmem_strbuf_t *junk_emstr;                /* tmp                      */\n    guint32       aggregator_as;\n    guint16       ssa_type;                   /* SSA T + Type */\n    guint16       ssa_len;                    /* SSA TLV Length */\n    guint8        ssa_v3_len;                 /* SSA L2TPv3 Cookie Length */\n    guint16       encaps_tunnel_type;         /* Encapsulation Tunnel Type */\n    guint16       encaps_tunnel_len;          /* Encapsulation TLV Length */\n    guint8        encaps_tunnel_subtype;      /* Encapsulation Tunnel Sub-TLV Type */\n    guint8        encaps_tunnel_sublen;       /* Encapsulation TLV Sub-TLV Length */\n    guint8        aigp_type;                  /* AIGP TLV type from AIGP attribute */\n\n    o = tvb_off;\n    junk_emstr = wmem_strbuf_new_label(wmem_packet_scope());\n\n    while (i < path_attr_len) {\n        proto_item *ti_pa, *ti_flags;\n        int     off;\n        gint    alen, aoff, tlen, aoff_save;\n        guint16 af;\n        guint8  saf, snpa;\n        guint8  nexthop_len;\n        guint8  asn_len = 0;\n\n        static const int * path_flags[] = {\n            &hf_bgp_update_path_attribute_flags_optional,\n            &hf_bgp_update_path_attribute_flags_transitive,\n            &hf_bgp_update_path_attribute_flags_partial,\n            &hf_bgp_update_path_attribute_flags_extended_length,\n            NULL\n        };\n\n        bgpa_flags = tvb_get_guint8(tvb, o + i);\n        bgpa_type = tvb_get_guint8(tvb, o + i+1);\n\n        /* check for the Extended Length bit */\n        if (bgpa_flags & BGP_ATTR_FLAG_EXTENDED_LENGTH) {\n            alen = tvb_get_ntohs(tvb, o + i + BGP_SIZE_OF_PATH_ATTRIBUTE);\n            aoff = BGP_SIZE_OF_PATH_ATTRIBUTE+2;\n        } else {\n            alen = tvb_get_guint8(tvb, o + i + BGP_SIZE_OF_PATH_ATTRIBUTE);\n            aoff = BGP_SIZE_OF_PATH_ATTRIBUTE+1;\n        }\n        tlen = alen;\n\n        ti_pa = proto_tree_add_item(subtree, hf_bgp_update_path_attribute, tvb, o + i, tlen + aoff, ENC_NA);\n        proto_item_append_text(ti_pa, \" - %s\", val_to_str(bgpa_type, bgpattr_type, \"Unknown (%u)\"));\n\n        subtree2 = proto_item_add_subtree(ti_pa, ett_bgp_attr);\n\n        ti_flags = proto_tree_add_bitmask(subtree2, tvb, o + i, hf_bgp_update_path_attribute_flags, ett_bgp_attr_flags, path_flags, ENC_NA);\n\n        proto_item_append_text(ti_flags,\"%s%s%s%s\",\n                 ((bgpa_flags & BGP_ATTR_FLAG_OPTIONAL) == 0) ? \": Well-known\" : \": Optional\",\n                 ((bgpa_flags & BGP_ATTR_FLAG_TRANSITIVE) == 0) ? \", Non-transitive\" : \", Transitive\",\n                 ((bgpa_flags & BGP_ATTR_FLAG_PARTIAL) == 0) ? \", Complete\" : \", Partial\",\n                 ((bgpa_flags & BGP_ATTR_FLAG_EXTENDED_LENGTH) == 0) ? \"\" : \", Extended Length\");\n\n        proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_type_code, tvb, o + i + 1, 1, ENC_BIG_ENDIAN);\n\n        attr_len_item = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_length, tvb, o + i + BGP_SIZE_OF_PATH_ATTRIBUTE,\n                                            aoff - BGP_SIZE_OF_PATH_ATTRIBUTE, ENC_BIG_ENDIAN);\n\n        /* Path Attribute Type */\n        switch (bgpa_type) {\n            case BGPTYPE_ORIGIN:\n                if (tlen != 1) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Origin (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                } else {\n                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_origin, tvb,\n                                        o + i + aoff, 1, ENC_BIG_ENDIAN);\n                    proto_item_append_text(ti_pa, \": %s\", val_to_str_const(tvb_get_guint8(tvb, o + i + aoff), bgpattr_origin, \"Unknown\"));\n                }\n                break;\n            case BGPTYPE_AS_PATH:\n            case BGPTYPE_AS4_PATH:\n                /* Apply heuristic to guess if we are facing 2 or 4 bytes ASN\n                   (o + i + aoff) =\n                   (o + current attribute + aoff bytes to first tuple)\n                   heuristic also tell us how many AS segments we have */\n                asn_len = heuristic_as2_or_4_from_as_path(tvb, o+i+aoff, o+i+aoff+tlen,\n                                                          bgpa_type, &number_as_segment);\n                if (asn_len == 255)\n                    {\n                        expert_add_info_format(pinfo, ti_pa, &ei_bgp_attr_as_path_as_len_err,\n                                               \"ASN length uncalculated by heuristic : %u\", asn_len);\n                        break;\n                    }\n                proto_item_append_text(ti_pa,\": \");\n                if(tlen == 0) {\n                    proto_item_append_text(ti_pa,\"empty\");\n                }\n                q = o + i + aoff;\n                for (k=0; k < number_as_segment; k++)\n                {\n                    type = tvb_get_guint8(tvb, q);\n                    length = tvb_get_guint8(tvb, q+1);\n                    ti = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_as_path_segment, tvb,\n                                             q, length * asn_len + 2, ENC_NA);\n                    proto_item_append_text(ti,\": \");\n                    as_path_segment_tree = proto_item_add_subtree(ti, ett_bgp_as_path_segment);\n                    proto_tree_add_item(as_path_segment_tree, hf_bgp_update_path_attribute_as_path_segment_type, tvb,\n                                        q, 1, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(as_path_segment_tree, hf_bgp_update_path_attribute_as_path_segment_length, tvb,\n                                        q+1, 1, ENC_BIG_ENDIAN);\n                    switch(type)\n                    {\n                        case AS_SET:\n                            proto_item_append_text(ti_pa, \"{\");\n                            proto_item_append_text(ti, \"{\");\n                            break;\n                        case AS_CONFED_SET:\n                            proto_item_append_text(ti_pa, \"[\");\n                            proto_item_append_text(ti, \"[\");\n                            break;\n                        case AS_CONFED_SEQUENCE:\n                            proto_item_append_text(ti_pa, \"(\");\n                            proto_item_append_text(ti, \"(\");\n                            break;\n                    }\n\n                    q = q + 2;\n                    for (j = 0; j < length; j++)\n                    {\n                        if(asn_len == 2) {\n                            proto_tree_add_item(as_path_segment_tree,\n                                                hf_bgp_update_path_attribute_as_path_segment_as2,\n                                                tvb, q, 2, ENC_BIG_ENDIAN);\n                            proto_item_append_text(ti_pa, \"%u\",\n                                                   tvb_get_ntohs(tvb, q));\n                            proto_item_append_text(ti, \"%u\",\n                                                   tvb_get_ntohs(tvb, q));\n                        }\n                        else if (asn_len == 4) {\n                            proto_tree_add_item(as_path_segment_tree,\n                                                hf_bgp_update_path_attribute_as_path_segment_as4,\n                                                tvb, q, 4, ENC_BIG_ENDIAN);\n                            proto_item_append_text(ti_pa, \"%u\",\n                                                   tvb_get_ntohl(tvb, q));\n                            proto_item_append_text(ti, \"%u\",\n                                                   tvb_get_ntohl(tvb, q));\n                        }\n                        if (j != length-1)\n                        {\n                            proto_item_append_text(ti_pa, \"%s\",\n                                                   (type == AS_SET || type == AS_CONFED_SET) ?\n                                                   \", \" : \" \");\n                            proto_item_append_text(ti, \"%s\",\n                                                   (type == AS_SET || type == AS_CONFED_SET) ?\n                                                   \", \" : \" \");\n                        }\n                        q += asn_len;\n                    }\n                    switch(type)\n                    {\n                        case AS_SET:\n                            proto_item_append_text(ti_pa, \"} \");\n                            proto_item_append_text(ti, \"}\");\n                            break;\n                        case AS_CONFED_SET:\n                            proto_item_append_text(ti_pa, \"] \");\n                            proto_item_append_text(ti, \"]\");\n                            break;\n                        case AS_CONFED_SEQUENCE:\n                            proto_item_append_text(ti_pa, \") \");\n                            proto_item_append_text(ti, \")\");\n                            break;\n                        default:\n                            proto_item_append_text(ti_pa, \" \");\n                            break;\n                    }\n                }\n\n                break;\n            case BGPTYPE_NEXT_HOP:\n                if (tlen != 4) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Next hop (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                } else {\n                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_next_hop, tvb,\n                                        o + i + aoff, 4, ENC_BIG_ENDIAN);\n                    proto_item_append_text(ti_pa, \": %s \", tvb_ip_to_str(tvb, o + i + aoff));\n                }\n                break;\n            case BGPTYPE_MULTI_EXIT_DISC:\n                if (tlen != 4) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Multiple exit discriminator (invalid): %u byte%s\",\n                                                 tlen, plurality(tlen, \"\", \"s\"));\n                } else {\n                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_multi_exit_disc, tvb,\n                                        o + i + aoff, tlen, ENC_BIG_ENDIAN);\n                    proto_item_append_text(ti_pa,\": %u\", tvb_get_ntohl(tvb, o + i + aoff));\n                }\n                break;\n            case BGPTYPE_LOCAL_PREF:\n                if (tlen != 4) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Local preference (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                } else {\n                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_local_pref, tvb,\n                                        o + i + aoff, tlen, ENC_BIG_ENDIAN);\n                    proto_item_append_text(ti_pa, \": %u\", tvb_get_ntohl(tvb, o + i + aoff));\n                }\n                break;\n            case BGPTYPE_ATOMIC_AGGREGATE:\n                if (tlen != 0) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Atomic aggregate (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                }\n                break;\n            case BGPTYPE_AGGREGATOR:\n                if (tlen != 6 && tlen != 8) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Aggregator (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                    break;\n                }\n            case BGPTYPE_AS4_AGGREGATOR:\n                if (bgpa_type == BGPTYPE_AS4_AGGREGATOR && tlen != 8)\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Aggregator (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                else {\n                    asn_len = tlen - 4;\n                    aggregator_as = (asn_len == 2) ?\n                        tvb_get_ntohs(tvb, o + i + aoff) :\n                        tvb_get_ntohl(tvb, o + i + aoff);\n                    proto_tree_add_uint(subtree2, hf_bgp_update_path_attribute_aggregator_as, tvb,\n                                        o + i + aoff, asn_len, aggregator_as);\n                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_aggregator_origin, tvb,\n                                        o + i + aoff + asn_len, 4, ENC_BIG_ENDIAN);\n\n                    proto_item_append_text(ti_pa, \": AS: %u origin: %s\", aggregator_as,\n                                           tvb_ip_to_str(tvb, o + i + aoff + asn_len));\n                }\n                break;\n            case BGPTYPE_COMMUNITIES:\n                if (tlen % 4 != 0) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Communities (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                    break;\n                }\n\n                proto_item_append_text(ti_pa, \": \");\n\n                ti_communities = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_communities,\n                                                     tvb, o + i + aoff, tlen, ENC_NA);\n\n                communities_tree = proto_item_add_subtree(ti_communities,\n                                                          ett_bgp_communities);\n                proto_item_append_text(ti_communities, \": \");\n                /* (o + i + aoff) =\n                   (o + current attribute + aoff bytes to first tuple) */\n                q = o + i + aoff;\n                end = q + tlen;\n\n                /* snarf each community */\n                while (q < end) {\n                    /* check for reserved values */\n                    guint32 community = tvb_get_ntohl(tvb, q);\n                    if ((community & 0xFFFF0000) == FOURHEX0 ||\n                        (community & 0xFFFF0000) == FOURHEXF) {\n                        proto_tree_add_item(communities_tree, hf_bgp_update_path_attribute_community_well_known,\n                                            tvb, q - 3 + aoff, 4, ENC_BIG_ENDIAN);\n                        proto_item_append_text(ti_pa, \"%s \", val_to_str_const(community, community_vals, \"Reserved\"));\n                        proto_item_append_text(ti_communities, \"%s \", val_to_str_const(community, community_vals, \"Reserved\"));\n                    }\n                    else {\n                        ti_community = proto_tree_add_item(communities_tree, hf_bgp_update_path_attribute_community, tvb,\n                                                           q - 3 + aoff, 4, ENC_NA);\n                        community_tree = proto_item_add_subtree(ti_community,\n                                                                ett_bgp_community);\n                        proto_tree_add_item(community_tree, hf_bgp_update_path_attribute_community_as,\n                                            tvb, q - 3 + aoff, 2, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(community_tree, hf_bgp_update_path_attribute_community_value,\n                                            tvb, q - 1 + aoff, 2, ENC_BIG_ENDIAN);\n                        proto_item_append_text(ti_pa, \"%u:%u \",tvb_get_ntohs(tvb, q - 3 + aoff),\n                                               tvb_get_ntohs(tvb, q -1 + aoff));\n                        proto_item_append_text(ti_communities, \"%u:%u \",tvb_get_ntohs(tvb, q - 3 + aoff),\n                                               tvb_get_ntohs(tvb, q -1 + aoff));\n                        proto_item_append_text(ti_community, \": %u:%u \",tvb_get_ntohs(tvb, q - 3 + aoff),\n                                               tvb_get_ntohs(tvb, q -1 + aoff));\n                    }\n\n                    q += 4;\n                }\n\n\n                break;\n            case BGPTYPE_ORIGINATOR_ID:\n                if (tlen != 4) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Originator identifier (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                } else {\n                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_originator_id, tvb,\n                                        o + i + aoff, tlen, ENC_BIG_ENDIAN);\n                    proto_item_append_text(ti_pa, \": %s \", tvb_ip_to_str(tvb, o + i + aoff));\n                }\n                break;\n            case BGPTYPE_MP_REACH_NLRI:\n                /*\n                 * RFC 2545 specifies that there may be more than one\n                 * address in the MP_REACH_NLRI attribute in section\n                 * 3, \"Constructing the Next Hop field\".\n                 *\n                 * Yes, RFC 2858 says you can't do that, and, yes, RFC\n                 * 2858 obsoletes RFC 2283, which says you can do that,\n                 * but that doesn't mean we shouldn't dissect packets\n                 * that conform to RFC 2283 but not RFC 2858, as some\n                 * device on the network might implement the 2283-style\n                 * BGP extensions rather than RFC 2858-style extensions.\n                 */\n                af = tvb_get_ntohs(tvb, o + i + aoff);\n                proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_mp_reach_nlri_address_family, tvb,\n                                    o + i + aoff, 2, ENC_BIG_ENDIAN);\n                saf = tvb_get_guint8(tvb, o + i + aoff + 2) ;\n                proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_mp_reach_nlri_safi, tvb,\n                                    o + i + aoff+2, 1, ENC_BIG_ENDIAN);\n                nexthop_len = tvb_get_guint8(tvb, o + i + aoff + 3);\n                subtree3 = proto_tree_add_subtree_format(subtree2, tvb, o + i + aoff + 3,\n                                                         nexthop_len + 1, ett_bgp_mp_nhna, NULL,\n                                                         \"Next hop network address (%d byte%s)\",\n                                                         nexthop_len, plurality(nexthop_len, \"\", \"s\"));\n\n                /*\n                 * The addresses don't contain lengths, so if we\n                 * don't understand the address family type, we\n                 * cannot parse the subsequent addresses as we\n                 * don't know how long they are.\n                 */\n                switch (af) {\n                    default:\n                    proto_tree_add_expert(subtree3, pinfo, &ei_bgp_unknown_afi, tvb, o + i + aoff + 4, nexthop_len);\n                    break;\n\n                    case AFNUM_INET:\n                    case AFNUM_INET6:\n                    case AFNUM_L2VPN:\n                    case AFNUM_L2VPN_OLD:\n                    case AFNUM_LINK_STATE:\n\n                        j = 0;\n                        while (j < nexthop_len) {\n                            advance = mp_addr_to_str(af, saf, tvb, o + i + aoff + 4 + j,\n                                                     junk_emstr, nexthop_len) ;\n                            if (advance == 0) /* catch if this is a unknown AFI type*/\n                                break;\n                            if (j + advance > nexthop_len)\n                                break;\n                            proto_tree_add_string(subtree3, hf_bgp_update_path_attribute_mp_reach_nlri_next_hop, tvb,\n                                                 o + i + aoff + 4 + j, advance, wmem_strbuf_get_str(junk_emstr));\n\n                            j += advance;\n                        }\n                        break;\n                } /* switch (af) */\n\n                aoff_save = aoff;\n                tlen -= nexthop_len + 4;\n                aoff += nexthop_len + 4 ;\n\n                off = 0;\n                snpa = tvb_get_guint8(tvb, o + i + aoff);\n                ti = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_mp_reach_nlri_nbr_snpa, tvb,\n                                         o + i + aoff, 1, ENC_BIG_ENDIAN);\n                off++;\n                if (snpa) {\n                    subtree3 = proto_item_add_subtree(ti, ett_bgp_mp_snpa);\n                    for (/*nothing*/; snpa > 0; snpa--) {\n                        guint8 snpa_length = tvb_get_guint8(tvb, o + i + aoff + off);\n                        proto_tree_add_item(subtree3, hf_bgp_update_path_attribute_mp_reach_nlri_snpa_length, tvb,\n                                            o + i + aoff + off, 1, ENC_BIG_ENDIAN);\n                        off++;\n                        proto_tree_add_item(subtree3, hf_bgp_update_path_attribute_mp_reach_nlri_snpa, tvb,\n                                            o + i + aoff + off, snpa_length, ENC_NA);\n                        off += snpa_length;\n                    }\n                }\n                tlen -= off;\n                aoff += off;\n\n                subtree3 = proto_tree_add_subtree_format(subtree2, tvb, o + i + aoff, tlen,\n                                                         ett_bgp_mp_reach_nlri, NULL, \"Network layer reachability information (%u byte%s)\",\n                                                         tlen, plurality(tlen, \"\", \"s\"));\n                if (tlen)  {\n                    if (af != AFNUM_INET && af != AFNUM_INET6 && af != AFNUM_L2VPN && af != AFNUM_LINK_STATE) {\n                        proto_tree_add_expert(subtree3, pinfo, &ei_bgp_unknown_afi, tvb, o + i + aoff, tlen);\n                    } else {\n                        while (tlen > 0) {\n                            advance = decode_prefix_MP(subtree3,\n                                                       hf_bgp_mp_reach_nlri_ipv4_prefix,\n                                                       hf_bgp_mp_reach_nlri_ipv6_prefix,\n                                                       af, saf,\n                                                       tvb, o + i + aoff, \"MP Reach NLRI\", pinfo);\n                            if (advance < 0)\n                                break;\n                            tlen -= advance;\n                            aoff += advance;\n                        }\n                    }\n                }\n                aoff = aoff_save;\n                break;\n            case BGPTYPE_MP_UNREACH_NLRI:\n                af = tvb_get_ntohs(tvb, o + i + aoff);\n                proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_mp_unreach_nlri_address_family, tvb,\n                                    o + i + aoff, 2, ENC_BIG_ENDIAN);\n                saf = tvb_get_guint8(tvb, o + i + aoff + 2) ;\n                proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_mp_unreach_nlri_safi, tvb,\n                                    o + i + aoff+2, 1, ENC_BIG_ENDIAN);\n\n                subtree3 = proto_tree_add_subtree_format(subtree2, tvb, o + i + aoff + 3,\n                                                         tlen - 3, ett_bgp_mp_unreach_nlri, NULL, \"Withdrawn routes (%u byte%s)\", tlen - 3,\n                                                         plurality(tlen - 3, \"\", \"s\"));\n\n                aoff_save = aoff;\n                tlen -= 3;\n                aoff += 3;\n                if (tlen > 0) {\n\n                    while (tlen > 0) {\n                        advance = decode_prefix_MP(subtree3,\n                                                   hf_bgp_mp_unreach_nlri_ipv4_prefix,\n                                                   hf_bgp_mp_unreach_nlri_ipv6_prefix,\n                                                   af, saf,\n                                                   tvb, o + i + aoff, \"MP Unreach NLRI\", pinfo);\n                        if (advance < 0)\n                            break;\n                        tlen -= advance;\n                        aoff += advance;\n                    }\n                }\n                aoff = aoff_save;\n                break;\n            case BGPTYPE_CLUSTER_LIST:\n                if (tlen % 4 != 0) {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,\n                                                 \"Cluster list (invalid): %u byte%s\", tlen,\n                                                 plurality(tlen, \"\", \"s\"));\n                    break;\n                }\n\n                ti = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_cluster_list,\n                                         tvb, o + i + aoff, tlen, ENC_NA);\n                cluster_list_tree = proto_item_add_subtree(ti,\n                                                               ett_bgp_cluster_list);\n\n                /* (o + i + aoff) =\n                   (o + current attribute + aoff bytes to first tuple) */\n                q = o + i + aoff;\n                end = q + tlen;\n                proto_item_append_text(ti, \":\");\n                proto_item_append_text(ti_pa, \":\");\n                /* snarf each cluster identifier */\n                while (q < end) {\n                    proto_tree_add_item(cluster_list_tree, hf_bgp_update_path_attribute_cluster_id,\n                                        tvb, q - 3 + aoff, 4, ENC_NA);\n                    proto_item_append_text(ti, \" %s\", tvb_ip_to_str(tvb, q-3+aoff));\n                    proto_item_append_text(ti_pa, \" %s\", tvb_ip_to_str(tvb, q-3+aoff));\n                    q += 4;\n                }\n\n                break;\n            case BGPTYPE_EXTENDED_COMMUNITY:\n                if (tlen %8 != 0) {\n                    expert_add_info_format(pinfo, attr_len_item, &ei_bgp_ext_com_len_bad,\n                                           \"Community length %u wrong, must be modulo 8\", tlen);\n                } else {\n                    dissect_bgp_update_ext_com(subtree2, tvb, tlen, o+i+aoff);\n                }\n                break;\n            case BGPTYPE_SAFI_SPECIFIC_ATTR:\n                q = o + i + aoff;\n                end = o + i + aoff + tlen ;\n\n                while(q < end) {\n                    ssa_type = tvb_get_ntohs(tvb, q) & BGP_SSA_TYPE;\n                    ssa_len = tvb_get_ntohs(tvb, q + 2);\n\n                    subtree3 = proto_tree_add_subtree_format(subtree2, tvb, q, MIN(ssa_len + 4, end - q),\n                                                             ett_bgp_ssa, NULL, \"%s Information\",\n                                                             val_to_str_const(ssa_type, bgp_ssa_type, \"Unknown SSA\"));\n\n                    proto_tree_add_item(subtree3, hf_bgp_ssa_t, tvb,\n                                        q, 1, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(subtree3, hf_bgp_ssa_type, tvb, q, 2, ENC_BIG_ENDIAN);\n\n                    proto_tree_add_item(subtree3, hf_bgp_ssa_len, tvb, q + 2, 2, ENC_BIG_ENDIAN);\n\n                    if ((ssa_len == 0) || (q + ssa_len > end)) {\n                        proto_tree_add_expert_format(subtree3, pinfo, &ei_bgp_length_invalid, tvb, q + 2,\n                                                     end - q - 2, \"Invalid Length of %u\", ssa_len);\n                        break;\n                    }\n\n                    switch (ssa_type) {\n                        case BGP_SSA_L2TPv3:\n                            proto_tree_add_item(subtree3, hf_bgp_ssa_l2tpv3_pref, tvb,\n                                                q + 4, 2, ENC_BIG_ENDIAN);\n\n                            subtree4 = proto_tree_add_subtree(subtree3, tvb, q + 6, 1, ett_bgp_ssa_subtree, NULL, \"Flags\");\n                            proto_tree_add_item(subtree4, hf_bgp_ssa_l2tpv3_s, tvb,\n                                                q + 6, 1, ENC_BIG_ENDIAN);\n                            proto_tree_add_item(subtree4, hf_bgp_ssa_l2tpv3_unused, tvb,\n                                                q + 6, 1, ENC_BIG_ENDIAN);\n\n                            ssa_v3_len = tvb_get_guint8(tvb, q + 7);\n                            if (ssa_v3_len + 8 == ssa_len){\n                                proto_tree_add_item(subtree3, hf_bgp_ssa_l2tpv3_cookie_len, tvb,\n                                                    q + 7, 1, ENC_BIG_ENDIAN);\n                            } else {\n                                proto_tree_add_expert_format(subtree3, pinfo, &ei_bgp_length_invalid, tvb, q + 7, 1,\n                                                             \"Invalid Cookie Length of %u\", ssa_v3_len);\n                                q += ssa_len + 4; /* 4 from type and length */\n                                break;\n                            }\n                            proto_tree_add_item(subtree3, hf_bgp_ssa_l2tpv3_session_id, tvb,\n                                                q + 8, 4, ENC_BIG_ENDIAN);\n                            if (ssa_v3_len)\n                                proto_tree_add_item(subtree3, hf_bgp_ssa_l2tpv3_cookie, tvb,\n                                                    q + 12, ssa_v3_len, ENC_NA);\n                            q += ssa_len + 4; /* 4 from type and length */\n                            break;\n                        case BGP_SSA_mGRE:\n                        case BGP_SSA_IPSec:\n                        case BGP_SSA_MPLS:\n                        default:\n                            proto_tree_add_item(subtree3, hf_bgp_ssa_value, tvb,\n                                                q + 4, ssa_len, ENC_NA);\n                            q += ssa_len + 4; /* 4 from type and length */\n                            break;\n                        case BGP_SSA_L2TPv3_IN_IPSec:\n                        case BGP_SSA_mGRE_IN_IPSec:\n                            /* These contain BGP_SSA_IPSec and BGP_SSA_L2TPv3/BGP_SSA_mGRE */\n                            q += 4; /* 4 from type and length */\n                            break;\n                    } /* switch (bgpa.bgpa_type) */\n                }\n                break;\n            case BGPTYPE_TUNNEL_ENCAPS_ATTR:\n                q = o + i + aoff;\n                end = o + i + aoff + tlen;\n\n                subtree3 = proto_tree_add_subtree(subtree2, tvb, q, tlen, ett_bgp_tunnel_tlv, NULL, \"TLV Encodings\");\n\n                while (q < end) {\n                    encaps_tunnel_type = tvb_get_ntohs(tvb, q);\n                    encaps_tunnel_len = tvb_get_ntohs(tvb, q + 2);\n\n                    subtree4 = proto_tree_add_subtree_format(subtree3, tvb, q, encaps_tunnel_len + 4,\n                                         ett_bgp_tunnel_tlv_subtree, NULL, \"%s (%u bytes)\",\n                                         val_to_str_const(encaps_tunnel_type, bgp_attr_tunnel_type, \"Unknown\"), encaps_tunnel_len + 4);\n\n                    proto_tree_add_item(subtree4, hf_bgp_update_encaps_tunnel_tlv_type, tvb, q, 2, ENC_BIG_ENDIAN);\n                    proto_tree_add_item(subtree4, hf_bgp_update_encaps_tunnel_tlv_len, tvb, q + 2, 2, ENC_BIG_ENDIAN);\n\n                    subtree5 = proto_tree_add_subtree(subtree4, tvb, q + 4, encaps_tunnel_len, ett_bgp_tunnel_subtlv, NULL, \"Sub-TLV Encodings\");\n\n                    q += 4;\n                    j = q + encaps_tunnel_len;\n                    while ( q < j ) {\n                        encaps_tunnel_subtype = tvb_get_guint8(tvb, q);\n                        encaps_tunnel_sublen = tvb_get_guint8(tvb, q + 1);\n\n                        subtree6 = proto_tree_add_subtree_format(subtree5, tvb, q, encaps_tunnel_sublen + 2, ett_bgp_tunnel_tlv_subtree, NULL, \"%s (%u bytes)\", val_to_str_const(encaps_tunnel_subtype, subtlv_type, \"Unknown\"), encaps_tunnel_sublen + 2);\n\n                        proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_type, tvb, q, 1, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_len, tvb, q + 1, 1, ENC_BIG_ENDIAN);\n\n                        switch (encaps_tunnel_subtype) {\n                            case TUNNEL_SUBTLV_ENCAPSULATION:\n                                if (encaps_tunnel_type == TUNNEL_TYPE_L2TP_OVER_IP) {\n                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_session_id, tvb, q + 2, 4, ENC_BIG_ENDIAN);\n                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_cookie, tvb, q + 6, encaps_tunnel_sublen - 4, ENC_NA);\n                                } else if (encaps_tunnel_type == TUNNEL_TYPE_GRE) {\n                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_gre_key, tvb, q + 2, 4, ENC_BIG_ENDIAN);\n                                }\n                                break;\n                            case TUNNEL_SUBTLV_PROTO_TYPE:\n                                proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_gre_key, tvb, q + 2, 2, ENC_BIG_ENDIAN);\n                                break;\n                            case TUNNEL_SUBTLV_COLOR:\n                                proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_color_value, tvb, q + 6, 4, ENC_BIG_ENDIAN);\n                               break;\n                            case TUNNEL_SUBTLV_LOAD_BALANCE:\n                                if (encaps_tunnel_type == TUNNEL_TYPE_L2TP_OVER_IP || encaps_tunnel_type == TUNNEL_TYPE_GRE) {\n                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_lb_block_length, tvb, q + 2, 4, ENC_BIG_ENDIAN);\n                                }\n                                break;\n                            default:\n                                break;\n                        } /* switch (encaps_tunnel_subtype) */\n\n                        q += 2 + encaps_tunnel_sublen; /* type and length + length of value */\n                    }\n\n                }\n\n                break;\n            case BGPTYPE_AIGP:\n                q = o + i + aoff;\n                ti = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_aigp, tvb, q, tlen, ENC_NA);\n                subtree3 = proto_item_add_subtree(ti, ett_bgp_aigp_attr);\n                aigp_type_item =  proto_tree_add_item(subtree3, hf_bgp_aigp_type, tvb, q, 1, ENC_BIG_ENDIAN);\n                aigp_type = tvb_get_guint8(tvb,q);\n                switch (aigp_type) {\n                    case AIGP_TLV_TYPE :\n                        proto_tree_add_item(subtree3, hf_bgp_aigp_tlv_length, tvb, q+1, 2, ENC_BIG_ENDIAN);\n                        proto_tree_add_item(subtree3, hf_bgp_aigp_accu_igp_metric, tvb, q+3, 8, ENC_BIG_ENDIAN);\n                        proto_item_append_text(ti, \": %\" G_GINT64_MODIFIER \"u\", tvb_get_ntoh64(tvb, q+3));\n                        proto_item_append_text(ti_pa, \": %\" G_GINT64_MODIFIER \"u\", tvb_get_ntoh64(tvb, q+3));\n                        break;\n                    default :\n                        expert_add_info_format(pinfo, aigp_type_item, &ei_bgp_attr_aigp_type,\n                                               \"AIGP type %u unknown\", aigp_type);\n                }\n                break;\n            case BGPTYPE_LINK_STATE_ATTR:\n\n                q = o + i + aoff;\n                end = o + i + aoff + tlen;\n\n                ti = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_link_state, tvb, q, tlen, ENC_NA);\n                subtree3 = proto_item_add_subtree(ti, ett_bgp_link_state);\n\n                while (q < end) {\n                    advance = decode_link_state_attribute_tlv(subtree3, tvb, q, pinfo);\n                    if (advance < 0)\n                        break;\n\n                    q += advance;\n                }\n                break;\n\n            case BGPTYPE_PMSI_TUNNEL_ATTR:\n                dissect_bgp_update_pmsi_attr(pinfo, subtree2, tvb, tlen, o+i+aoff);\n                break;\n\n            case BGPTYPE_ATTR_SET:\n                if (alen >= 4) {\n                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_attrset_origin_as, tvb,\n                                        o + i + aoff, 4, ENC_BIG_ENDIAN);\n                    if (alen > 4) {\n                        ti =  proto_tree_add_item(subtree2, hf_bgp_update_path_attributes, tvb, o+i+aoff+4, alen-4, ENC_NA);\n                        attr_set_subtree = proto_item_add_subtree(ti, ett_bgp_attrs);\n                        dissect_bgp_path_attr(attr_set_subtree, tvb, alen-4, o+i+aoff+4, pinfo);\n                    }\n                } else {\n                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, alen,\n                                                 \"Attribute set (invalid): %u bytes%s\",\n                                                 alen, plurality(alen, \"\", \"s\"));\n                }\n                break;\n            default:\n                proto_tree_add_item(subtree2, hf_bgp_update_path_attributes_unknown, tvb, o + i + aoff, tlen, ENC_NA);\n                break;\n        } /* switch (bgpa.bgpa_type) */ /* end of second switch */\n\n        i += alen + aoff;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -43,7 +43,7 @@\n     while (i < path_attr_len) {\n         proto_item *ti_pa, *ti_flags;\n         int     off;\n-        guint16 alen, aoff, tlen, aoff_save;\n+        gint    alen, aoff, tlen, aoff_save;\n         guint16 af;\n         guint8  saf, snpa;\n         guint8  nexthop_len;",
        "diff_line_info": {
            "deleted_lines": [
                "        guint16 alen, aoff, tlen, aoff_save;"
            ],
            "added_lines": [
                "        gint    alen, aoff, tlen, aoff_save;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7702",
        "func_name": "wireshark/parse_wbxml_attribute_list_defined",
        "description": "In Wireshark 2.2.0 to 2.2.5 and 2.0.0 to 2.0.11, the WBXML dissector could go into an infinite loop, triggered by packet injection or a malformed capture file. This was addressed in epan/dissectors/packet-wbxml.c by adding length validation.",
        "git_url": "https://github.com/wireshark/wireshark/commit/2f322f66cbcca2fefdaa630494f9d6c97eb659b7",
        "commit_title": "packet-wbxml.c: Fix potential infinite loops",
        "commit_text": " Bug: 13477 (cherry picked from commit 8e1befc4777431851f7026b059ecf6ce9a518781)",
        "func_before": "static guint32\nparse_wbxml_attribute_list_defined (proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo,\n\t\t\t\t    guint32 offset, guint32 str_tbl, guint8 level, guint8 *codepage_attr,\n\t\t\t\t    const wbxml_decoding *map)\n{\n\tguint32     tvb_len = tvb_reported_length (tvb);\n\tguint32     off     = offset;\n\tguint32     len;\n\tguint       str_len;\n\tguint32     ent;\n\tguint32     idx;\n\tguint8      peek;\n\tguint8      attr_save_known   = 0; /* Will contain peek & 0x3F (attr identity) */\n\tconst char *attr_save_literal = NULL; /* Will contain the LITERAL attr identity */\n\tgchar      *str;\n\n\tDebugLog((\"parse_wbxml_attr_defined (level = %u, offset = %u)\\n\", level, offset));\n\t/* Parse attributes */\n\twhile (off < tvb_len) {\n\t\tpeek = tvb_get_guint8 (tvb, off);\n\t\tDebugLog((\"ATTR: (top of while) level = %3u, peek = 0x%02X, \"\n\t\t\t  \"off = %u, tvb_len = %u\\n\", level, peek, off, tvb_len));\n\t\tif ((peek & 0x3F) < 5) switch (peek) { /* Global tokens\n\t\t\t\t\t\t\t  in state = ATTR */\n\t\tcase 0x00: /* SWITCH_PAGE */\n\t\t\t*codepage_attr = tvb_get_guint8 (tvb, off+1);\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_switch_page, tvb, off, 2, *codepage_attr,\n                         \"      |  Attr | A -->%3d | SWITCH_PAGE (Attr code page)    |\",\n\t\t\t\t\t     *codepage_attr);\n\t\t\toff += 2;\n\t\t\tbreak;\n\t\tcase 0x01: /* END */\n\t\t\t/* BEWARE\n\t\t\t *   The Attribute END token means either \">\" or \"/>\"\n\t\t\t *   and as a consequence both must be treated separately.\n\t\t\t *   This is done in the TAG state parser.\n\t\t\t */\n\t\t\toff++;\n\t\t\tDebugLog((\"ATTR: level = %u, Return: len = %u\\n\",\n\t\t\t\t  level, off - offset));\n\t\t\treturn (off - offset);\n\t\tcase 0x02: /* ENTITY */\n\t\t\tent = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_entity, tvb, off, 1+len, ent,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | ENTITY                          |     %s'&#%u;'\",\n\t\t\t\t\t     level, *codepage_attr, Indent (level), ent);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x03: /* STR_I */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | STR_I (Inline string)           |     %s\\'%s\\'\",\n\t\t\t\t\t     level, *codepage_attr, Indent (level), str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x04: /* LITERAL */\n\t\t\t/* ALWAYS means the start of a new attribute,\n\t\t\t * and may only contain the NAME of the attribute.\n\t\t\t */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\tattr_save_known = 0;\n\t\t\tattr_save_literal = tvb_format_text (tvb,\n\t\t\t\t\t\t\t     str_tbl+idx, str_len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal, tvb, off, 1+len, attr_save_literal,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | LITERAL (Literal Attribute)     |   %s<%s />\",\n\t\t\t\t\t     level, *codepage_attr, Indent (level), attr_save_literal);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x40: /* EXT_I_0 */\n\t\tcase 0x41: /* EXT_I_1 */\n\t\tcase 0x42: /* EXT_I_2 */\n\t\t\t/* Extension tokens */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | EXT_I_%1x    (Extension Token)    |     %s(%s: \\'%s\\')\",\n\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level),\n\t\t\t\t\t     ((map != NULL) ? map_token (map->global, 0, peek) : \"Inline string extension\"), str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\t\t/* 0x43 impossible in ATTR state */\n\t\t\t/* 0x44 impossible in ATTR state */\n\t\tcase 0x80: /* EXT_T_0 */\n\t\tcase 0x81: /* EXT_T_1 */\n\t\tcase 0x82: /* EXT_T_2 */\n\t\t\t/* Extension tokens */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tif (map != NULL) {\n\n\t\t\t\t\tif (map->ext_t[peek & 0x03])\n\t\t\t\t\t\ts = (map->ext_t[peek & 0x03])(tvb, idx, str_tbl);\n\t\t\t\t\telse\n\t\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \"EXT_T_%1x (%s)\", peek & 0x03,\n\t\t\t\t\t\t\t\t    map_token (map->global, 0, peek));\n\t\t\t\t} else {\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \"Extension Token, integer value: (%u\", idx);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_t, tvb, off, 1+len, s,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_T_%1x    (Extension Token)    | %s%s)\",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level),\n\t\t\t\t\t\t     s);\n\t\t\t}\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x83: /* STR_T */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\tstr = tvb_format_text (tvb, str_tbl+idx, str_len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_t, tvb, off, 1+len, str,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | STR_T (Tableref string)         |     %s\\'%s\\'\",\n\t\t\t\t\t     level, *codepage_attr, Indent (level), str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\t\t/* 0x84 impossible in ATTR state */\n\t\tcase 0xC0: /* EXT_0 */\n\t\tcase 0xC1: /* EXT_1 */\n\t\tcase 0xC2: /* EXT_2 */\n\t\t\t/* Extension tokens */\n\t\t\tstr = (char*)((map != NULL) ? map_token (map->global, 0, peek) : \"Single-byte extension\");\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_extension_token, tvb, off, 1, str,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | EXT_%1x      (Extension Token)    |     %s(%s)\",\n\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level), str);\n\t\t\toff++;\n\t\t\tbreak;\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\n\t\t\tif (tvb_get_guint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\tchar *tmp_str;\n\t\t\t\t\tif (attr_save_known) { /* Knwon attribute */\n\t\t\t\t\t\tif (map->opaque_binary_attr) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_binary_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t      attr_save_known, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_binary_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t attr_save_known, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { /* lITERAL attribute */\n\t\t\t\t\t\tif (map->opaque_literal_tag) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_literal_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t       attr_save_literal, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_literal_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t  attr_save_literal, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len, NULL,\n\t\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    | OPAQUE (Opaque data)            |       %s%s\",\n\t\t\t\t\t\t\t     level, *codepage_attr, Indent (level), tmp_str);\n\t\t\t\t\toff += 1 + len;\n\t\t\t\t} else {\n\t\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,\n\t\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    | OPAQUE (Opaque data)            |       %s(%u bytes of opaque data)\",\n\t\t\t\t\t\t\t     level, *codepage_attr, Indent (level), idx);\n\t\t\t\t\toff += 1+len+idx;\n\t\t\t\t}\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\n\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_reserved_2, tvb, off, 1,\n\t\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    | RESERVED_2     (Invalid Token!) | WBXML 1.0 parsing stops here.\",\n\t\t\t\t\t\t\t     level, *codepage_attr);\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t\tDebugLog((\"ATTR: level = %u, Return: len = %u\\n\",\n\t\t\t\t\t  level, off - offset));\n\t\t\t\treturn (off - offset);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t/* 0xC4 impossible in ATTR state */\n\t\tdefault:\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_invalid_token, tvb, off, 1,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | %-10s     (Invalid Token!) | WBXML parsing stops here.\",\n\t\t\t\t\t     level, *codepage_attr, val_to_str_ext (peek, &vals_wbxml1x_global_tokens_ext, \"(unknown 0x%x)\"));\n\t\t\t/* Move to end of buffer */\n\t\t\toff = tvb_len;\n\t\t\tbreak;\n\t\t} else { /* Known atribute token */\n\t\t\tchar* s;\n\t\t\tif (peek & 0x80) { /* attrValue */\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\ts = (char*)map_token (map->attrValue, *codepage_attr, peek);\n\t\t\t\t} else {\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \"attrValue_0x%02X\", peek);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_attrvalue, tvb, off, 1, s,\n\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    |   Known attrValue 0x%02X          |       %s%s\",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x7f, Indent (level),\n\t\t\t\t\t\t     s);\n\t\t\t\toff++;\n\t\t\t} else { /* attrStart */\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\ts = (char*)map_token (map->attrStart, *codepage_attr, peek);\n\t\t\t\t} else {\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \"attrStart_0x%02X\", peek);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_attrstart, tvb, off, 1, s,\n\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    |   Known attrStart 0x%02X          |   %s%s\",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x7f, Indent (level),\n\t\t\t\t\t\t     s);\n\t\t\t\toff++;\n\t\t\t}\n\t\t}\n\t} /* End WHILE */\n\tDebugLog((\"ATTR: level = %u, Return: len = %u (end of function body)\\n\",\n\t\t  level, off - offset));\n\treturn (off - offset);\n}",
        "func": "static guint32\nparse_wbxml_attribute_list_defined (proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo,\n\t\t\t\t    guint32 offset, guint32 str_tbl, guint8 level, guint8 *codepage_attr,\n\t\t\t\t    const wbxml_decoding *map)\n{\n\tguint32     tvb_len = tvb_reported_length (tvb);\n\tguint32     off     = offset;\n\tguint32     len;\n\tguint       str_len;\n\tguint32     ent;\n\tguint32     idx;\n\tguint8      peek;\n\tguint8      attr_save_known   = 0; /* Will contain peek & 0x3F (attr identity) */\n\tconst char *attr_save_literal = NULL; /* Will contain the LITERAL attr identity */\n\tgchar      *str;\n\n\tDebugLog((\"parse_wbxml_attr_defined (level = %u, offset = %u)\\n\", level, offset));\n\t/* Parse attributes */\n\twhile (off < tvb_len) {\n\t\tpeek = tvb_get_guint8 (tvb, off);\n\t\tDebugLog((\"ATTR: (top of while) level = %3u, peek = 0x%02X, \"\n\t\t\t  \"off = %u, tvb_len = %u\\n\", level, peek, off, tvb_len));\n\t\tif ((peek & 0x3F) < 5) switch (peek) { /* Global tokens\n\t\t\t\t\t\t\t  in state = ATTR */\n\t\tcase 0x00: /* SWITCH_PAGE */\n\t\t\t*codepage_attr = tvb_get_guint8 (tvb, off+1);\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_switch_page, tvb, off, 2, *codepage_attr,\n                         \"      |  Attr | A -->%3d | SWITCH_PAGE (Attr code page)    |\",\n\t\t\t\t\t     *codepage_attr);\n\t\t\toff += 2;\n\t\t\tbreak;\n\t\tcase 0x01: /* END */\n\t\t\t/* BEWARE\n\t\t\t *   The Attribute END token means either \">\" or \"/>\"\n\t\t\t *   and as a consequence both must be treated separately.\n\t\t\t *   This is done in the TAG state parser.\n\t\t\t */\n\t\t\toff++;\n\t\t\tDebugLog((\"ATTR: level = %u, Return: len = %u\\n\",\n\t\t\t\t  level, off - offset));\n\t\t\treturn (off - offset);\n\t\tcase 0x02: /* ENTITY */\n\t\t\tent = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tif (len <= tvb_len) {\n\t\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_entity, tvb, off, 1+len, ent,\n\t\t\t\t\t         \"  %3d |  Attr | A %3d    | ENTITY                          |     %s'&#%u;'\",\n\t\t\t\t\t         level, *codepage_attr, Indent (level), ent);\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x03: /* STR_I */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | STR_I (Inline string)           |     %s\\'%s\\'\",\n\t\t\t\t\t     level, *codepage_attr, Indent (level), str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x04: /* LITERAL */\n\t\t\t/* ALWAYS means the start of a new attribute,\n\t\t\t * and may only contain the NAME of the attribute.\n\t\t\t */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tif (len <= tvb_len) {\n\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\t\tattr_save_known = 0;\n\t\t\t\tattr_save_literal = tvb_format_text (tvb, str_tbl+idx, str_len-1);\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal, tvb, off, 1+len, attr_save_literal,\n\t\t\t\t\t         \"  %3d |  Attr | A %3d    | LITERAL (Literal Attribute)     |   %s<%s />\",\n\t\t\t\t\t         level, *codepage_attr, Indent (level), attr_save_literal);\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x40: /* EXT_I_0 */\n\t\tcase 0x41: /* EXT_I_1 */\n\t\tcase 0x42: /* EXT_I_2 */\n\t\t\t/* Extension tokens */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | EXT_I_%1x    (Extension Token)    |     %s(%s: \\'%s\\')\",\n\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level),\n\t\t\t\t\t     ((map != NULL) ? map_token (map->global, 0, peek) : \"Inline string extension\"), str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\t\t/* 0x43 impossible in ATTR state */\n\t\t\t/* 0x44 impossible in ATTR state */\n\t\tcase 0x80: /* EXT_T_0 */\n\t\tcase 0x81: /* EXT_T_1 */\n\t\tcase 0x82: /* EXT_T_2 */\n\t\t\t/* Extension tokens */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tif (map != NULL) {\n\n\t\t\t\t\tif (map->ext_t[peek & 0x03])\n\t\t\t\t\t\ts = (map->ext_t[peek & 0x03])(tvb, idx, str_tbl);\n\t\t\t\t\telse\n\t\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \"EXT_T_%1x (%s)\", peek & 0x03,\n\t\t\t\t\t\t\t\t    map_token (map->global, 0, peek));\n\t\t\t\t} else {\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \"Extension Token, integer value: (%u\", idx);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_t, tvb, off, 1+len, s,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_T_%1x    (Extension Token)    | %s%s)\",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level),\n\t\t\t\t\t\t     s);\n\t\t\t}\n\t\t\tif (len <= tvb_len) {\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83: /* STR_T */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tif (len <= tvb_len) {\n\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\t\tstr = tvb_format_text (tvb, str_tbl+idx, str_len-1);\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_t, tvb, off, 1+len, str,\n\t\t\t\t\t         \"  %3d |  Attr | A %3d    | STR_T (Tableref string)         |     %s\\'%s\\'\",\n\t\t\t\t\t         level, *codepage_attr, Indent (level), str);\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t/* 0x84 impossible in ATTR state */\n\t\tcase 0xC0: /* EXT_0 */\n\t\tcase 0xC1: /* EXT_1 */\n\t\tcase 0xC2: /* EXT_2 */\n\t\t\t/* Extension tokens */\n\t\t\tstr = (char*)((map != NULL) ? map_token (map->global, 0, peek) : \"Single-byte extension\");\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_extension_token, tvb, off, 1, str,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | EXT_%1x      (Extension Token)    |     %s(%s)\",\n\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level), str);\n\t\t\toff++;\n\t\t\tbreak;\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\n\t\t\tif (tvb_get_guint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\tchar *tmp_str;\n\t\t\t\t\tif (attr_save_known) { /* Knwon attribute */\n\t\t\t\t\t\tif (map->opaque_binary_attr) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_binary_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t      attr_save_known, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_binary_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t attr_save_known, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { /* lITERAL attribute */\n\t\t\t\t\t\tif (map->opaque_literal_tag) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_literal_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t       attr_save_literal, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_literal_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t  attr_save_literal, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (len <= tvb_len) {\n\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len, NULL,\n\t\t\t\t\t\t\t         \"  %3d |  Attr | A %3d    | OPAQUE (Opaque data)            |       %s%s\",\n\t\t\t\t\t\t\t         level, *codepage_attr, Indent (level), tmp_str);\n\t\t\t\t\t\toff += 1 + len;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\t\t\toff = tvb_len;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t\t\tif (len <= tvb_len) {\n\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,\n\t\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    | OPAQUE (Opaque data)            |       %s(%u bytes of opaque data)\",\n\t\t\t\t\t\t\t     level, *codepage_attr, Indent (level), idx);\n\t\t\t\t\t\toff += 1+len+idx;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\t\t\toff = tvb_len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\n\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_reserved_2, tvb, off, 1,\n\t\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    | RESERVED_2     (Invalid Token!) | WBXML 1.0 parsing stops here.\",\n\t\t\t\t\t\t\t     level, *codepage_attr);\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t\tDebugLog((\"ATTR: level = %u, Return: len = %u\\n\",\n\t\t\t\t\t  level, off - offset));\n\t\t\t\treturn (off - offset);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t/* 0xC4 impossible in ATTR state */\n\t\tdefault:\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_invalid_token, tvb, off, 1,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | %-10s     (Invalid Token!) | WBXML parsing stops here.\",\n\t\t\t\t\t     level, *codepage_attr, val_to_str_ext (peek, &vals_wbxml1x_global_tokens_ext, \"(unknown 0x%x)\"));\n\t\t\t/* Move to end of buffer */\n\t\t\toff = tvb_len;\n\t\t\tbreak;\n\t\t} else { /* Known atribute token */\n\t\t\tchar* s;\n\t\t\tif (peek & 0x80) { /* attrValue */\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\ts = (char*)map_token (map->attrValue, *codepage_attr, peek);\n\t\t\t\t} else {\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \"attrValue_0x%02X\", peek);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_attrvalue, tvb, off, 1, s,\n\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    |   Known attrValue 0x%02X          |       %s%s\",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x7f, Indent (level),\n\t\t\t\t\t\t     s);\n\t\t\t\toff++;\n\t\t\t} else { /* attrStart */\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\ts = (char*)map_token (map->attrStart, *codepage_attr, peek);\n\t\t\t\t} else {\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \"attrStart_0x%02X\", peek);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_attrstart, tvb, off, 1, s,\n\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    |   Known attrStart 0x%02X          |   %s%s\",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x7f, Indent (level),\n\t\t\t\t\t\t     s);\n\t\t\t\toff++;\n\t\t\t}\n\t\t}\n\t} /* End WHILE */\n\tDebugLog((\"ATTR: level = %u, Return: len = %u (end of function body)\\n\",\n\t\t  level, off - offset));\n\treturn (off - offset);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -41,10 +41,15 @@\n \t\t\treturn (off - offset);\n \t\tcase 0x02: /* ENTITY */\n \t\t\tent = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n-\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_entity, tvb, off, 1+len, ent,\n-\t\t\t\t\t     \"  %3d |  Attr | A %3d    | ENTITY                          |     %s'&#%u;'\",\n-\t\t\t\t\t     level, *codepage_attr, Indent (level), ent);\n-\t\t\toff += 1+len;\n+\t\t\tif (len <= tvb_len) {\n+\t\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_entity, tvb, off, 1+len, ent,\n+\t\t\t\t\t         \"  %3d |  Attr | A %3d    | ENTITY                          |     %s'&#%u;'\",\n+\t\t\t\t\t         level, *codepage_attr, Indent (level), ent);\n+\t\t\t\toff += 1+len;\n+\t\t\t} else {\n+\t\t\t\t/* Stop processing as it is impossible to parse now */\n+\t\t\t\toff = tvb_len;\n+\t\t\t}\n \t\t\tbreak;\n \t\tcase 0x03: /* STR_I */\n \t\t\tlen = tvb_strsize (tvb, off+1);\n@@ -59,14 +64,18 @@\n \t\t\t * and may only contain the NAME of the attribute.\n \t\t\t */\n \t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n-\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n-\t\t\tattr_save_known = 0;\n-\t\t\tattr_save_literal = tvb_format_text (tvb,\n-\t\t\t\t\t\t\t     str_tbl+idx, str_len-1);\n-\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal, tvb, off, 1+len, attr_save_literal,\n-\t\t\t\t\t     \"  %3d |  Attr | A %3d    | LITERAL (Literal Attribute)     |   %s<%s />\",\n-\t\t\t\t\t     level, *codepage_attr, Indent (level), attr_save_literal);\n-\t\t\toff += 1+len;\n+\t\t\tif (len <= tvb_len) {\n+\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n+\t\t\t\tattr_save_known = 0;\n+\t\t\t\tattr_save_literal = tvb_format_text (tvb, str_tbl+idx, str_len-1);\n+\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal, tvb, off, 1+len, attr_save_literal,\n+\t\t\t\t\t         \"  %3d |  Attr | A %3d    | LITERAL (Literal Attribute)     |   %s<%s />\",\n+\t\t\t\t\t         level, *codepage_attr, Indent (level), attr_save_literal);\n+\t\t\t\toff += 1+len;\n+\t\t\t} else {\n+\t\t\t\t/* Stop processing as it is impossible to parse now */\n+\t\t\t\toff = tvb_len;\n+\t\t\t}\n \t\t\tbreak;\n \t\tcase 0x40: /* EXT_I_0 */\n \t\tcase 0x41: /* EXT_I_1 */\n@@ -104,16 +113,26 @@\n \t\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level),\n \t\t\t\t\t\t     s);\n \t\t\t}\n-\t\t\toff += 1+len;\n+\t\t\tif (len <= tvb_len) {\n+\t\t\t\toff += 1+len;\n+\t\t\t} else {\n+\t\t\t\t/* Stop processing as it is impossible to parse now */\n+\t\t\t\toff = tvb_len;\n+\t\t\t}\n \t\t\tbreak;\n \t\tcase 0x83: /* STR_T */\n \t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n-\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n-\t\t\tstr = tvb_format_text (tvb, str_tbl+idx, str_len-1);\n-\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_t, tvb, off, 1+len, str,\n-\t\t\t\t\t     \"  %3d |  Attr | A %3d    | STR_T (Tableref string)         |     %s\\'%s\\'\",\n-\t\t\t\t\t     level, *codepage_attr, Indent (level), str);\n-\t\t\toff += 1+len;\n+\t\t\tif (len <= tvb_len) {\n+\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n+\t\t\t\tstr = tvb_format_text (tvb, str_tbl+idx, str_len-1);\n+\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_t, tvb, off, 1+len, str,\n+\t\t\t\t\t         \"  %3d |  Attr | A %3d    | STR_T (Tableref string)         |     %s\\'%s\\'\",\n+\t\t\t\t\t         level, *codepage_attr, Indent (level), str);\n+\t\t\t\toff += 1+len;\n+\t\t\t} else {\n+\t\t\t\t/* Stop processing as it is impossible to parse now */\n+\t\t\t\toff = tvb_len;\n+\t\t\t}\n \t\t\tbreak;\n \t\t\t/* 0x84 impossible in ATTR state */\n \t\tcase 0xC0: /* EXT_0 */\n@@ -147,16 +166,27 @@\n \t\t\t\t\t\t\t\t\t\t  attr_save_literal, *codepage_attr, &len, pinfo);\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len, NULL,\n-\t\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    | OPAQUE (Opaque data)            |       %s%s\",\n-\t\t\t\t\t\t\t     level, *codepage_attr, Indent (level), tmp_str);\n-\t\t\t\t\toff += 1 + len;\n+\n+\t\t\t\t\tif (len <= tvb_len) {\n+\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len, NULL,\n+\t\t\t\t\t\t\t         \"  %3d |  Attr | A %3d    | OPAQUE (Opaque data)            |       %s%s\",\n+\t\t\t\t\t\t\t         level, *codepage_attr, Indent (level), tmp_str);\n+\t\t\t\t\t\toff += 1 + len;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\n+\t\t\t\t\t\toff = tvb_len;\n+\t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n-\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,\n+\t\t\t\t\tif (len <= tvb_len) {\n+\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,\n \t\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    | OPAQUE (Opaque data)            |       %s(%u bytes of opaque data)\",\n \t\t\t\t\t\t\t     level, *codepage_attr, Indent (level), idx);\n-\t\t\t\t\toff += 1+len+idx;\n+\t\t\t\t\t\toff += 1+len+idx;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\n+\t\t\t\t\t\toff = tvb_len;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\n \t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_reserved_2, tvb, off, 1,",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_entity, tvb, off, 1+len, ent,",
                "\t\t\t\t\t     \"  %3d |  Attr | A %3d    | ENTITY                          |     %s'&#%u;'\",",
                "\t\t\t\t\t     level, *codepage_attr, Indent (level), ent);",
                "\t\t\toff += 1+len;",
                "\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);",
                "\t\t\tattr_save_known = 0;",
                "\t\t\tattr_save_literal = tvb_format_text (tvb,",
                "\t\t\t\t\t\t\t     str_tbl+idx, str_len-1);",
                "\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal, tvb, off, 1+len, attr_save_literal,",
                "\t\t\t\t\t     \"  %3d |  Attr | A %3d    | LITERAL (Literal Attribute)     |   %s<%s />\",",
                "\t\t\t\t\t     level, *codepage_attr, Indent (level), attr_save_literal);",
                "\t\t\toff += 1+len;",
                "\t\t\toff += 1+len;",
                "\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);",
                "\t\t\tstr = tvb_format_text (tvb, str_tbl+idx, str_len-1);",
                "\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_t, tvb, off, 1+len, str,",
                "\t\t\t\t\t     \"  %3d |  Attr | A %3d    | STR_T (Tableref string)         |     %s\\'%s\\'\",",
                "\t\t\t\t\t     level, *codepage_attr, Indent (level), str);",
                "\t\t\toff += 1+len;",
                "\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len, NULL,",
                "\t\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    | OPAQUE (Opaque data)            |       %s%s\",",
                "\t\t\t\t\t\t\t     level, *codepage_attr, Indent (level), tmp_str);",
                "\t\t\t\t\toff += 1 + len;",
                "\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,",
                "\t\t\t\t\toff += 1+len+idx;"
            ],
            "added_lines": [
                "\t\t\tif (len <= tvb_len) {",
                "\t\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_entity, tvb, off, 1+len, ent,",
                "\t\t\t\t\t         \"  %3d |  Attr | A %3d    | ENTITY                          |     %s'&#%u;'\",",
                "\t\t\t\t\t         level, *codepage_attr, Indent (level), ent);",
                "\t\t\t\toff += 1+len;",
                "\t\t\t} else {",
                "\t\t\t\t/* Stop processing as it is impossible to parse now */",
                "\t\t\t\toff = tvb_len;",
                "\t\t\t}",
                "\t\t\tif (len <= tvb_len) {",
                "\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);",
                "\t\t\t\tattr_save_known = 0;",
                "\t\t\t\tattr_save_literal = tvb_format_text (tvb, str_tbl+idx, str_len-1);",
                "\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal, tvb, off, 1+len, attr_save_literal,",
                "\t\t\t\t\t         \"  %3d |  Attr | A %3d    | LITERAL (Literal Attribute)     |   %s<%s />\",",
                "\t\t\t\t\t         level, *codepage_attr, Indent (level), attr_save_literal);",
                "\t\t\t\toff += 1+len;",
                "\t\t\t} else {",
                "\t\t\t\t/* Stop processing as it is impossible to parse now */",
                "\t\t\t\toff = tvb_len;",
                "\t\t\t}",
                "\t\t\tif (len <= tvb_len) {",
                "\t\t\t\toff += 1+len;",
                "\t\t\t} else {",
                "\t\t\t\t/* Stop processing as it is impossible to parse now */",
                "\t\t\t\toff = tvb_len;",
                "\t\t\t}",
                "\t\t\tif (len <= tvb_len) {",
                "\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);",
                "\t\t\t\tstr = tvb_format_text (tvb, str_tbl+idx, str_len-1);",
                "\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_t, tvb, off, 1+len, str,",
                "\t\t\t\t\t         \"  %3d |  Attr | A %3d    | STR_T (Tableref string)         |     %s\\'%s\\'\",",
                "\t\t\t\t\t         level, *codepage_attr, Indent (level), str);",
                "\t\t\t\toff += 1+len;",
                "\t\t\t} else {",
                "\t\t\t\t/* Stop processing as it is impossible to parse now */",
                "\t\t\t\toff = tvb_len;",
                "\t\t\t}",
                "",
                "\t\t\t\t\tif (len <= tvb_len) {",
                "\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len, NULL,",
                "\t\t\t\t\t\t\t         \"  %3d |  Attr | A %3d    | OPAQUE (Opaque data)            |       %s%s\",",
                "\t\t\t\t\t\t\t         level, *codepage_attr, Indent (level), tmp_str);",
                "\t\t\t\t\t\toff += 1 + len;",
                "\t\t\t\t\t} else {",
                "\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */",
                "\t\t\t\t\t\toff = tvb_len;",
                "\t\t\t\t\t}",
                "\t\t\t\t\tif (len <= tvb_len) {",
                "\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,",
                "\t\t\t\t\t\toff += 1+len+idx;",
                "\t\t\t\t\t} else {",
                "\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */",
                "\t\t\t\t\t\toff = tvb_len;",
                "\t\t\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7704",
        "func_name": "wireshark/sid_buffer_hash_fn",
        "description": "In Wireshark 2.2.0 to 2.2.5, the DOF dissector could go into an infinite loop, triggered by packet injection or a malformed capture file. This was addressed in epan/dissectors/packet-dof.c by using a different integer data type and adjusting a return value.",
        "git_url": "https://github.com/wireshark/wireshark/commit/da53a90b6895e47e03c5de05edf84bd99d535fd8",
        "commit_title": "DOF: fix an infinite loop in sid_buffer_hash_fn()",
        "commit_text": " The sid buffer can contain up to 255 bytes of data, so the loop counter must be a guint16 at least.  Bug: 13453 (cherry picked from commit c3dde590d8226bdb19149013acf9d45781adbd16)",
        "func_before": "static guint sid_buffer_hash_fn(gconstpointer key)\n{\n    /* The sid buffer is a length byte followed by data. */\n    guint hash = 5381;\n    const guint8 *str = (const guint8 *)key;\n    guint8 i;\n\n    for (i = 0; i <= str[0]; i++)\n        hash = ((hash << 5) + hash) + str[i]; /* hash * 33 + c */\n\n    return hash;\n}",
        "func": "static guint sid_buffer_hash_fn(gconstpointer key)\n{\n    /* The sid buffer is a length byte followed by data. */\n    guint hash = 5381;\n    const guint8 *str = (const guint8 *)key;\n    guint16 i;\n\n    for (i = 0; i <= str[0]; i++)\n        hash = ((hash << 5) + hash) + str[i]; /* hash * 33 + c */\n\n    return hash;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n     /* The sid buffer is a length byte followed by data. */\n     guint hash = 5381;\n     const guint8 *str = (const guint8 *)key;\n-    guint8 i;\n+    guint16 i;\n \n     for (i = 0; i <= str[0]; i++)\n         hash = ((hash << 5) + hash) + str[i]; /* hash * 33 + c */",
        "diff_line_info": {
            "deleted_lines": [
                "    guint8 i;"
            ],
            "added_lines": [
                "    guint16 i;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7704",
        "func_name": "wireshark/dissect_dof_tcp",
        "description": "In Wireshark 2.2.0 to 2.2.5, the DOF dissector could go into an infinite loop, triggered by packet injection or a malformed capture file. This was addressed in epan/dissectors/packet-dof.c by using a different integer data type and adjusting a return value.",
        "git_url": "https://github.com/wireshark/wireshark/commit/6032b0fe5fc1176ab77e03e20765f95fbd21b19e",
        "commit_title": "DOF: ensure to return a value different from 0 when asking for more data",
        "commit_text": " Bug: 13453 (cherry picked from commit 78d168fcbb0480109ba637590912f220197737cc)",
        "func_before": "static int dissect_dof_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    conversation_t *conversation;\n    tcp_session_data *session;\n    tcp_packet_data *packet;\n    struct tcpinfo *tcpinfo = (struct tcpinfo *)data;\n    guint8 header;\n\n    /* Get the TCP conversation. TCP creates a new conversation for each TCP connection,12\n     * so we can \"mirror\" that by attaching our own data to that conversation. If our\n     * data cannot be found, then it is a new connection (to us).\n     */\n    conversation = find_conversation(pinfo->fd->num, &pinfo->src, &pinfo->dst, pinfo->ptype, pinfo->srcport, pinfo->destport, 0);\n    {\n        /* This should be impossible - the TCP dissector requires this conversation.\n         * Bail...\n         */\n        DISSECTOR_ASSERT(conversation != NULL);\n    }\n\n\n    /* This requires explanation. TCP will call this dissector, and we know\n     * that the first byte (offset 0 of this tvb) is the first byte of an\n     * DPS packet. The TCP dissector ensures this.\n     *\n     * We do *not* know that this is the only packet, and\n     * so the dissector that we call below must handle framing. All of\n     * this state must be stored, and so we store it in a transport\n     * data structure. DPS packet data is created later and associated\n     * differently.\n     *\n     * Further, this routine MAY be called MULTIPLE times for the SAME\n     * frame with DIFFERENT sequence numbers. This makes handling\n     * retransmissions very difficult - we must track each call to this\n     * routine with its associated offset and ignore flag. However, due\n     * to the way that Wireshark handles asking for more data we cannot\n     * mark an offset as \"duplicate\" until after it has been processed.\n     */\n\n    /* TCP packet data is only associated with TCP frames that hold DPS packets. */\n    session = (tcp_session_data *)conversation_get_proto_data(conversation, proto_2008_1_dof_tcp);\n    if (session == NULL)\n    {\n        session = create_tcp_session_data(pinfo, conversation);\n        if (!session)\n        {\n            fprintf(stderr, \"! session\");\n            return 0;\n        }\n\n        conversation_add_proto_data(conversation, proto_2008_1_dof_tcp, session);\n    }\n\n    if (session->not_dps)\n        return 0;\n\n    packet = (tcp_packet_data *)p_get_proto_data(NULL, pinfo, proto_2008_1_dof_tcp, 0);\n    if (packet == NULL)\n    {\n        packet = (tcp_packet_data *)wmem_alloc0(wmem_file_scope(), sizeof(tcp_packet_data));\n        if (!packet)\n        {\n            fprintf(stderr, \"! packet\");\n            return 0;\n        }\n\n        p_add_proto_data(NULL, pinfo, proto_2008_1_dof_tcp, 0, packet);\n    }\n\n    if (is_retransmission(pinfo, session, packet, tcpinfo))\n        return 0;\n\n    /* Loop, checking all the packets in this frame and communicating with the TCP\n     * desegmenter. The framing dissector entry is used to determine the size\n     * of the current frame.\n     */\n    {\n        /* Note that we must handle fragmentation on TCP... */\n        gint offset = 0;\n\n        while (offset < (gint)tvb_reported_length(tvb))\n        {\n            gint available = tvb_ensure_captured_length_remaining(tvb, offset);\n            int packet_length;\n\n            header = tvb_get_guint8(tvb, offset);\n\n            /* If we are negotiating, then we do not need the framing dissector\n             * as we know the packet length is two. Note that for the first byte\n             * of a TCP session there are only two cases, both handled here. An error\n             * of not understanding the first byte will trigger that this is not\n             * a DPS session.\n             */\n            if (((header & 0x80) == 0) && session->common.negotiation_required && ((pinfo->fd->num < session->common.negotiation_complete_at) || (session->common.negotiation_complete_at == 0)))\n            {\n                packet_length = 2;\n                if (header > DNP_MAX_VERSION)\n                {\n                    session->not_dps = TRUE;\n                    return 0;\n                }\n            }\n            else\n            {\n                packet_length = dof_dissect_dnp_length(tvb, pinfo, header & 0x7F, &offset);\n                if (packet_length < 0)\n                {\n                    session->not_dps = TRUE;\n                    return offset;\n                }\n            }\n\n            if (packet_length == 0)\n            {\n                pinfo->desegment_offset = offset;\n                pinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\n                return offset;\n            }\n\n            if (available < packet_length)\n            {\n                pinfo->desegment_offset = offset;\n                pinfo->desegment_len = packet_length - available;\n                return offset;\n            }\n\n            remember_offset(pinfo, session, packet, tcpinfo);\n            if (is_retransmission(pinfo, session, packet, tcpinfo))\n                return 0;\n\n            /* We have a packet. We have to store the dof_packet_data in a list, as there may be\n             * multiple DPS packets in a single Wireshark frame.\n             */\n            {\n                tvbuff_t *next_tvb = tvb_new_subset(tvb, offset, packet_length, packet_length);\n                tcp_dof_packet_ref *ref;\n                gint raw_offset = tvb_raw_offset(tvb) + offset;\n                gboolean ref_is_new = FALSE;\n\n                /* Get the packet data. This is a list in increasing sequence order. */\n                if (packet->dof_packets == NULL)\n                {\n                    ref_is_new = TRUE;\n                    ref = (tcp_dof_packet_ref *)wmem_alloc0(wmem_file_scope(), sizeof(tcp_dof_packet_ref));\n                    ref->transport_packet.sender_id = assign_addr_port_id(&pinfo->src, pinfo->srcport);\n                    ref->transport_packet.receiver_id = assign_addr_port_id(&pinfo->dst, pinfo->destport);\n                    packet->dof_packets = ref;\n                    ref->start_offset = raw_offset;\n                }\n                else\n                    ref = packet->dof_packets;\n\n                /* Find the entry for our offset. */\n                while (ref->start_offset != raw_offset)\n                {\n                    if (ref->next)\n                    {\n                        ref = ref->next;\n                        continue;\n                    }\n\n                    {\n                        tcp_dof_packet_ref *last = ref;\n\n                        /* This is the default state, NULL and 0. */\n                        ref_is_new = TRUE;\n                        ref = wmem_new0(wmem_file_scope(), tcp_dof_packet_ref);\n                        if (!ref)\n                        {\n                            fprintf(stderr, \"! ref\");\n                            return offset;\n                        }\n\n                        ref->transport_packet.sender_id = last->transport_packet.sender_id;\n                        ref->transport_packet.receiver_id = last->transport_packet.receiver_id;\n                        ref->start_offset = raw_offset;\n                        last->next = ref;\n                    }\n                }\n\n                if (ref_is_new)\n                {\n                    dof_transport_packet *tp = &(ref->transport_packet);\n\n                    tp->is_sent_by_client = FALSE;\n                    if (addresses_equal(&session->client.addr, &pinfo->src) &&\n                        (session->client.port == pinfo->srcport))\n                        tp->is_sent_by_client = TRUE;\n\n                    ref->api_data.transport_session = (dof_transport_session *)&(session->common);\n                    ref->api_data.transport_packet = tp;\n                }\n\n\n                dissect_dof_common(next_tvb, pinfo, tree, &ref->api_data);\n            }\n\n            offset += packet_length;\n        }\n\n        return offset;\n    }\n}",
        "func": "static int dissect_dof_tcp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data)\n{\n    conversation_t *conversation;\n    tcp_session_data *session;\n    tcp_packet_data *packet;\n    struct tcpinfo *tcpinfo = (struct tcpinfo *)data;\n    guint8 header;\n\n    /* Get the TCP conversation. TCP creates a new conversation for each TCP connection,12\n     * so we can \"mirror\" that by attaching our own data to that conversation. If our\n     * data cannot be found, then it is a new connection (to us).\n     */\n    conversation = find_conversation(pinfo->fd->num, &pinfo->src, &pinfo->dst, pinfo->ptype, pinfo->srcport, pinfo->destport, 0);\n    {\n        /* This should be impossible - the TCP dissector requires this conversation.\n         * Bail...\n         */\n        DISSECTOR_ASSERT(conversation != NULL);\n    }\n\n\n    /* This requires explanation. TCP will call this dissector, and we know\n     * that the first byte (offset 0 of this tvb) is the first byte of an\n     * DPS packet. The TCP dissector ensures this.\n     *\n     * We do *not* know that this is the only packet, and\n     * so the dissector that we call below must handle framing. All of\n     * this state must be stored, and so we store it in a transport\n     * data structure. DPS packet data is created later and associated\n     * differently.\n     *\n     * Further, this routine MAY be called MULTIPLE times for the SAME\n     * frame with DIFFERENT sequence numbers. This makes handling\n     * retransmissions very difficult - we must track each call to this\n     * routine with its associated offset and ignore flag. However, due\n     * to the way that Wireshark handles asking for more data we cannot\n     * mark an offset as \"duplicate\" until after it has been processed.\n     */\n\n    /* TCP packet data is only associated with TCP frames that hold DPS packets. */\n    session = (tcp_session_data *)conversation_get_proto_data(conversation, proto_2008_1_dof_tcp);\n    if (session == NULL)\n    {\n        session = create_tcp_session_data(pinfo, conversation);\n        if (!session)\n        {\n            fprintf(stderr, \"! session\");\n            return 0;\n        }\n\n        conversation_add_proto_data(conversation, proto_2008_1_dof_tcp, session);\n    }\n\n    if (session->not_dps)\n        return 0;\n\n    packet = (tcp_packet_data *)p_get_proto_data(NULL, pinfo, proto_2008_1_dof_tcp, 0);\n    if (packet == NULL)\n    {\n        packet = (tcp_packet_data *)wmem_alloc0(wmem_file_scope(), sizeof(tcp_packet_data));\n        if (!packet)\n        {\n            fprintf(stderr, \"! packet\");\n            return 0;\n        }\n\n        p_add_proto_data(NULL, pinfo, proto_2008_1_dof_tcp, 0, packet);\n    }\n\n    if (is_retransmission(pinfo, session, packet, tcpinfo))\n        return 0;\n\n    /* Loop, checking all the packets in this frame and communicating with the TCP\n     * desegmenter. The framing dissector entry is used to determine the size\n     * of the current frame.\n     */\n    {\n        /* Note that we must handle fragmentation on TCP... */\n        gint offset = 0;\n\n        while (offset < (gint)tvb_reported_length(tvb))\n        {\n            gint available = tvb_ensure_captured_length_remaining(tvb, offset);\n            int packet_length;\n\n            header = tvb_get_guint8(tvb, offset);\n\n            /* If we are negotiating, then we do not need the framing dissector\n             * as we know the packet length is two. Note that for the first byte\n             * of a TCP session there are only two cases, both handled here. An error\n             * of not understanding the first byte will trigger that this is not\n             * a DPS session.\n             */\n            if (((header & 0x80) == 0) && session->common.negotiation_required && ((pinfo->fd->num < session->common.negotiation_complete_at) || (session->common.negotiation_complete_at == 0)))\n            {\n                packet_length = 2;\n                if (header > DNP_MAX_VERSION)\n                {\n                    session->not_dps = TRUE;\n                    return 0;\n                }\n            }\n            else\n            {\n                packet_length = dof_dissect_dnp_length(tvb, pinfo, header & 0x7F, &offset);\n                if (packet_length < 0)\n                {\n                    session->not_dps = TRUE;\n                    return offset;\n                }\n            }\n\n            if (packet_length == 0)\n            {\n                pinfo->desegment_offset = offset;\n                pinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\n                return offset + available;\n            }\n\n            if (available < packet_length)\n            {\n                pinfo->desegment_offset = offset;\n                pinfo->desegment_len = packet_length - available;\n                return offset + available;\n            }\n\n            remember_offset(pinfo, session, packet, tcpinfo);\n            if (is_retransmission(pinfo, session, packet, tcpinfo))\n                return 0;\n\n            /* We have a packet. We have to store the dof_packet_data in a list, as there may be\n             * multiple DPS packets in a single Wireshark frame.\n             */\n            {\n                tvbuff_t *next_tvb = tvb_new_subset(tvb, offset, packet_length, packet_length);\n                tcp_dof_packet_ref *ref;\n                gint raw_offset = tvb_raw_offset(tvb) + offset;\n                gboolean ref_is_new = FALSE;\n\n                /* Get the packet data. This is a list in increasing sequence order. */\n                if (packet->dof_packets == NULL)\n                {\n                    ref_is_new = TRUE;\n                    ref = (tcp_dof_packet_ref *)wmem_alloc0(wmem_file_scope(), sizeof(tcp_dof_packet_ref));\n                    ref->transport_packet.sender_id = assign_addr_port_id(&pinfo->src, pinfo->srcport);\n                    ref->transport_packet.receiver_id = assign_addr_port_id(&pinfo->dst, pinfo->destport);\n                    packet->dof_packets = ref;\n                    ref->start_offset = raw_offset;\n                }\n                else\n                    ref = packet->dof_packets;\n\n                /* Find the entry for our offset. */\n                while (ref->start_offset != raw_offset)\n                {\n                    if (ref->next)\n                    {\n                        ref = ref->next;\n                        continue;\n                    }\n\n                    {\n                        tcp_dof_packet_ref *last = ref;\n\n                        /* This is the default state, NULL and 0. */\n                        ref_is_new = TRUE;\n                        ref = wmem_new0(wmem_file_scope(), tcp_dof_packet_ref);\n                        if (!ref)\n                        {\n                            fprintf(stderr, \"! ref\");\n                            return offset;\n                        }\n\n                        ref->transport_packet.sender_id = last->transport_packet.sender_id;\n                        ref->transport_packet.receiver_id = last->transport_packet.receiver_id;\n                        ref->start_offset = raw_offset;\n                        last->next = ref;\n                    }\n                }\n\n                if (ref_is_new)\n                {\n                    dof_transport_packet *tp = &(ref->transport_packet);\n\n                    tp->is_sent_by_client = FALSE;\n                    if (addresses_equal(&session->client.addr, &pinfo->src) &&\n                        (session->client.port == pinfo->srcport))\n                        tp->is_sent_by_client = TRUE;\n\n                    ref->api_data.transport_session = (dof_transport_session *)&(session->common);\n                    ref->api_data.transport_packet = tp;\n                }\n\n\n                dissect_dof_common(next_tvb, pinfo, tree, &ref->api_data);\n            }\n\n            offset += packet_length;\n        }\n\n        return offset;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -114,14 +114,14 @@\n             {\n                 pinfo->desegment_offset = offset;\n                 pinfo->desegment_len = DESEGMENT_ONE_MORE_SEGMENT;\n-                return offset;\n+                return offset + available;\n             }\n \n             if (available < packet_length)\n             {\n                 pinfo->desegment_offset = offset;\n                 pinfo->desegment_len = packet_length - available;\n-                return offset;\n+                return offset + available;\n             }\n \n             remember_offset(pinfo, session, packet, tcpinfo);",
        "diff_line_info": {
            "deleted_lines": [
                "                return offset;",
                "                return offset;"
            ],
            "added_lines": [
                "                return offset + available;",
                "                return offset + available;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7705",
        "func_name": "wireshark/get_write_list_size",
        "description": "In Wireshark 2.2.0 to 2.2.5 and 2.0.0 to 2.0.11, the RPC over RDMA dissector could go into an infinite loop, triggered by packet injection or a malformed capture file. This was addressed in epan/dissectors/packet-rpcrdma.c by correctly checking for going beyond the maximum offset.",
        "git_url": "https://github.com/wireshark/wireshark/commit/08d392bbecc8fb666bf979e70a34536007b83ea2",
        "commit_title": "RPC-over-RDMA: protect against a variable overflow",
        "commit_text": " Bug: 13558 (cherry picked from commit 280f2feeaf95fcf50f028162b49be1bf6866c918) Conflicts: \tepan/dissectors/packet-rpcrdma.c",
        "func_before": "static guint get_write_list_size(tvbuff_t *tvb, guint max_offset, guint offset)\n{\n    guint32 value_follows, segment_count;\n    guint start = offset;\n\n    while (1) {\n        value_follows = tvb_get_ntohl(tvb, offset);\n        offset += 4;\n        if (offset > max_offset)\n            return 0;\n        if (!value_follows)\n            break;\n\n        segment_count = tvb_get_ntohl(tvb, offset);\n        offset += 4;\n        if (offset > max_offset)\n            return 0;\n        offset += (segment_count * 16);\n        if (offset > max_offset)\n            return 0;\n    }\n\n    return offset - start;\n}",
        "func": "static guint get_write_list_size(tvbuff_t *tvb, guint max_offset, guint offset)\n{\n    guint32 value_follows, segment_count;\n    guint start = offset;\n\n    while (1) {\n        value_follows = tvb_get_ntohl(tvb, offset);\n        offset += 4;\n        if (offset > max_offset)\n            return 0;\n        if (!value_follows)\n            break;\n\n        segment_count = tvb_get_ntohl(tvb, offset);\n        offset += 4;\n        if (offset > max_offset)\n            return 0;\n        if ((offset + (segment_count * 16)) < offset ||\n            (offset + (segment_count * 16)) > max_offset)\n            return 0;\n        offset += (segment_count * 16);\n    }\n\n    return offset - start;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,9 +15,10 @@\n         offset += 4;\n         if (offset > max_offset)\n             return 0;\n+        if ((offset + (segment_count * 16)) < offset ||\n+            (offset + (segment_count * 16)) > max_offset)\n+            return 0;\n         offset += (segment_count * 16);\n-        if (offset > max_offset)\n-            return 0;\n     }\n \n     return offset - start;",
        "diff_line_info": {
            "deleted_lines": [
                "        if (offset > max_offset)",
                "            return 0;"
            ],
            "added_lines": [
                "        if ((offset + (segment_count * 16)) < offset ||",
                "            (offset + (segment_count * 16)) > max_offset)",
                "            return 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7748",
        "func_name": "wireshark/add_capabilities",
        "description": "In Wireshark 2.2.0 to 2.2.5 and 2.0.0 to 2.0.11, the WSP dissector could go into an infinite loop, triggered by packet injection or a malformed capture file. This was addressed in epan/dissectors/packet-wsp.c by adding a length check.",
        "git_url": "https://github.com/wireshark/wireshark/commit/f55cbcde2c8f74b652add4450b0592082eb6acff",
        "commit_title": "packet-wsp.c: Fix WSP dissector loop (add_capabilities)",
        "commit_text": " Bug: 13581 (cherry picked from commit a71811af0de3ca9e7b5569f6e0f43dc7d4052d02)",
        "func_before": "static void\nadd_capabilities (proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, guint8 pdu_type)\n{\n    proto_tree *wsp_capabilities, *cap_subtree, *cap_subtree2;\n    proto_item *ti, *cap_item, *cap_item2;\n\n    char       *capaName, *str;\n    guint32     offset       = 0;\n    guint32     len          = 0;\n    guint32     capaStart    = 0; /* Start offset of the capability */\n    guint32     capaLen      = 0; /* Length of the entire capability */\n    guint32     capaValueLen = 0; /* Length of the capability value & type */\n    guint32     tvb_len      = tvb_reported_length(tvb);\n    gboolean    ok           = FALSE;\n    guint8      peek;\n    guint32     value;\n\n    if (tvb_len == 0) {\n        return;\n    }\n\n    ti = proto_tree_add_item(tree, hf_capabilities_section,\n            tvb, 0, tvb_len, ENC_NA);\n    wsp_capabilities = proto_item_add_subtree(ti, ett_capabilities);\n\n    while (offset < tvb_len) {\n        /*\n         * WSP capabilities consist of:\n         *  - a guint32 length field,\n         *  - a capability identifier as Token-text or Short-integer,\n         *  - a capability-specific sequence of <length> octets.\n         */\n        capaStart = offset;\n        /*\n         * Now Offset points to the 1st byte of a capability field.\n         * Get the length of the capability field\n         */\n        capaValueLen = tvb_get_guintvar(tvb, offset, &len, pinfo, &ei_wsp_oversized_uintvar);\n        capaLen = capaValueLen + len;\n\n        cap_subtree = proto_tree_add_subtree(wsp_capabilities, tvb, offset, capaLen, ett_capabilities_entry, &cap_item, \"Capability\");\n        offset += len;\n        /*\n         * Now offset points to the 1st byte of the capability type.\n         * Get the capability identifier.\n         */\n        peek = tvb_get_guint8(tvb, offset);\n        if (is_token_text(peek)) { /* Literal capability name */\n            /* 1. Get the string from the tvb */\n            capaName = (gchar *)tvb_get_stringz_enc(wmem_packet_scope(), tvb, capaStart, (gint *)&len, ENC_ASCII);\n\n            /* 2. Look up the string capability name */\n            if (g_ascii_strcasecmp(capaName, \"client-sdu-size\") == 0) {\n                peek = WSP_CAPA_CLIENT_SDU_SIZE;\n            } else if (g_ascii_strcasecmp(capaName, \"server-sdu-size\") == 0) {\n                peek = WSP_CAPA_SERVER_SDU_SIZE;\n            } else if (g_ascii_strcasecmp(capaName, \"protocol options\") == 0) {\n                peek = WSP_CAPA_PROTOCOL_OPTIONS;\n            } else if (g_ascii_strcasecmp(capaName, \"method-mor\") == 0) {\n                peek = WSP_CAPA_METHOD_MOR;\n            } else if (g_ascii_strcasecmp(capaName, \"push-mor\") == 0) {\n                peek = WSP_CAPA_PUSH_MOR;\n            } else if (g_ascii_strcasecmp(capaName, \"extended methods\") == 0) {\n                peek = WSP_CAPA_EXTENDED_METHODS;\n            } else if (g_ascii_strcasecmp(capaName, \"header code pages\") == 0) {\n                peek = WSP_CAPA_HEADER_CODE_PAGES;\n            } else if (g_ascii_strcasecmp(capaName, \"aliases\") == 0) {\n                peek = WSP_CAPA_ALIASES;\n            } else if (g_ascii_strcasecmp(capaName, \"client-message-size\") == 0) {\n                peek = WSP_CAPA_CLIENT_MESSAGE_SIZE;\n            } else if (g_ascii_strcasecmp(capaName, \"server-message-size\") == 0) {\n                peek = WSP_CAPA_SERVER_MESSAGE_SIZE;\n            } else {\n                expert_add_info_format(pinfo, cap_item, &ei_wsp_capability_invalid,\n                        \"Unknown or invalid textual capability: %s\", capaName);\n                /* Skip this capability */\n                offset = capaStart + capaLen;\n                continue;\n            }\n            offset += len;\n            /* Now offset points to the 1st value byte of the capability. */\n        } else if (peek < 0x80) {\n            expert_add_info_format(pinfo, cap_item, &ei_wsp_capability_invalid,\n                    \"Invalid well-known capability: 0x%02X\", peek);\n            /* Skip further capability parsing */\n            return;\n        }\n        if (peek & 0x80) { /* Well-known capability */\n            peek &= 0x7F;\n            len = 1;\n            offset++;\n            /* Now offset points to the 1st value byte of the capability. */\n        }\n\n        proto_item_append_text(cap_item, \": %s\", val_to_str_const(peek, wsp_capability_vals, \"Invalid capabiliity\"));\n        /* Now the capability type is known */\n        switch (peek) {\n            case WSP_CAPA_CLIENT_SDU_SIZE:\n                value = tvb_get_guintvar(tvb, offset, &len, pinfo, &ei_wsp_oversized_uintvar);\n                proto_tree_add_uint(cap_subtree, hf_capa_client_sdu_size,\n                        tvb, offset, len, value);\n                break;\n            case WSP_CAPA_SERVER_SDU_SIZE:\n                value = tvb_get_guintvar(tvb, offset, &len, pinfo, &ei_wsp_oversized_uintvar);\n                proto_tree_add_uint(cap_subtree, hf_capa_server_sdu_size,\n                        tvb, offset, len, value);\n                break;\n            case WSP_CAPA_PROTOCOL_OPTIONS:\n                /*\n                 * The bits are stored in one or more octets, not an\n                 * uintvar-integer! Note that capability name and value\n                 * have length capaValueLength, and that the capability\n                 * name has length = len. Hence the remaining length is\n                 * given by capaValueLen - len.\n                 */\n                if (capaValueLen - len == 1) {\n                    static const int * capabilities[] = {\n                        &hf_capa_protocol_option_confirmed_push,\n                        &hf_capa_protocol_option_push,\n                        &hf_capa_protocol_option_session_resume,\n                        &hf_capa_protocol_option_ack_headers,\n                        &hf_capa_protocol_option_large_data_transfer,\n                        NULL\n                    };\n\n                    proto_tree_add_bitmask_with_flags(cap_subtree, tvb, offset, hf_capa_protocol_options,\n                                   ett_proto_option_capability, capabilities, ENC_NA, BMT_NO_FALSE);\n                }\n                else\n                {\n                    /*\n                     * The WSP spec foresees that this bit field can be\n                     * extended in the future. This does not make sense yet.\n                     */\n                    proto_item_append_text(cap_item,\n                            \" <warning: bit field too large>\");\n                    offset = capaStart + capaLen;\n                    continue;\n                }\n                break;\n            case WSP_CAPA_METHOD_MOR:\n                proto_tree_add_item(cap_subtree, hf_capa_method_mor, tvb, offset, len, ENC_NA);\n                break;\n            case WSP_CAPA_PUSH_MOR:\n                proto_tree_add_item(cap_subtree, hf_capa_push_mor, tvb, offset, len, ENC_NA);\n               break;\n            case WSP_CAPA_EXTENDED_METHODS:\n                /* Extended Methods capability format:\n                 * Connect PDU: collection of { Method (octet), Method-name (Token-text) }\n                 * ConnectReply PDU: collection of accepted { Method (octet) }\n                 */\n                cap_subtree2 = proto_tree_add_subtree(cap_subtree, tvb, capaStart, capaLen, ett_capabilities_extended_methods, &cap_item2, \"Extended Methods\");\n                if (pdu_type == WSP_PDU_CONNECT) {\n                    while (offset < capaStart + capaLen) {\n                        ti = proto_tree_add_item(cap_subtree2, hf_capa_extended_method, tvb, offset, 1, ENC_NA);\n                        offset++;\n\n                        get_text_string(str, tvb, offset, len, ok);\n                        if (! ok) {\n                            expert_add_info(pinfo, ti, &ei_wsp_capability_encoding_invalid);\n                            return;\n                        }\n                        proto_item_append_text(ti, \" = %s\", str);\n                        proto_item_set_len(ti, len+1);\n                        offset += len;\n                    }\n                } else {\n                    while (offset < capaStart + capaLen) {\n                        proto_tree_add_item(cap_subtree2, hf_capa_extended_method, tvb, offset, 1, ENC_NA);\n                        offset++;\n                    }\n                }\n                break;\n            case WSP_CAPA_HEADER_CODE_PAGES:\n                /* Header Code Pages capability format:\n                 * Connect PDU: collection of { Page-id (octet), Page-name (Token-text) }\n                 * ConnectReply PDU: collection of accepted { Page-id (octet) }\n                 */\n                cap_subtree2 = proto_tree_add_subtree(cap_subtree, tvb, capaStart, capaLen, ett_capabilities_header_code_pages, &cap_item2, \"Header Code Pages\");\n                if (pdu_type == WSP_PDU_CONNECT) {\n                    while (offset < capaStart + capaLen) {\n                        ti = proto_tree_add_item(cap_subtree2, hf_capa_header_code_page, tvb, offset, 1, ENC_NA);\n                        offset++;\n\n                        get_text_string(str, tvb, offset, len, ok);\n                        if (! ok) {\n                            expert_add_info(pinfo, ti, &ei_wsp_capability_encoding_invalid);\n                            return;\n                        }\n                        proto_item_append_text(ti, \" = %s\", str);\n                        proto_item_set_len(ti, len+1);\n                        offset += len;\n                    }\n                } else {\n                    while (offset < capaStart + capaLen) {\n                        proto_tree_add_item(cap_subtree2, hf_capa_header_code_page, tvb, offset, 1, ENC_NA);\n                        offset++;\n                    }\n                }\n                break;\n            case WSP_CAPA_ALIASES:\n                /* TODO - same format as redirect addresses */\n                proto_tree_add_item(cap_subtree, hf_capa_aliases,\n                        tvb, capaStart, capaLen, ENC_NA);\n                break;\n            case WSP_CAPA_CLIENT_MESSAGE_SIZE:\n                value = tvb_get_guintvar(tvb, offset, &len, pinfo, &ei_wsp_oversized_uintvar);\n                proto_tree_add_uint(cap_subtree, hf_capa_client_message_size,\n                        tvb, offset, len, value);\n                break;\n            case WSP_CAPA_SERVER_MESSAGE_SIZE:\n                value = tvb_get_guintvar(tvb, offset, &len, pinfo, &ei_wsp_oversized_uintvar);\n                proto_tree_add_uint(cap_subtree, hf_capa_server_message_size,\n                        tvb, offset, len, value);\n                break;\n            default:\n                expert_add_info_format(pinfo, cap_item, &ei_wsp_capability_invalid,\n                        \"Unknown well-known capability: 0x%02X\", peek);\n                break;\n        }\n        offset = capaStart + capaLen;\n    }\n}",
        "func": "static void\nadd_capabilities (proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, guint8 pdu_type)\n{\n    proto_tree *wsp_capabilities, *cap_subtree, *cap_subtree2;\n    proto_item *ti, *cap_item, *cap_item2;\n\n    char       *capaName, *str;\n    guint32     offset       = 0;\n    guint32     len          = 0;\n    guint32     capaStart    = 0; /* Start offset of the capability */\n    guint32     capaLen      = 0; /* Length of the entire capability */\n    guint32     capaValueLen = 0; /* Length of the capability value & type */\n    guint32     tvb_len      = tvb_reported_length(tvb);\n    gboolean    ok           = FALSE;\n    guint8      peek;\n    guint32     value;\n\n    if (tvb_len == 0) {\n        return;\n    }\n\n    ti = proto_tree_add_item(tree, hf_capabilities_section,\n            tvb, 0, tvb_len, ENC_NA);\n    wsp_capabilities = proto_item_add_subtree(ti, ett_capabilities);\n\n    while (offset < tvb_len) {\n        /*\n         * WSP capabilities consist of:\n         *  - a guint32 length field,\n         *  - a capability identifier as Token-text or Short-integer,\n         *  - a capability-specific sequence of <length> octets.\n         */\n        capaStart = offset;\n        /*\n         * Now Offset points to the 1st byte of a capability field.\n         * Get the length of the capability field\n         */\n        capaValueLen = tvb_get_guintvar(tvb, offset, &len, pinfo, &ei_wsp_oversized_uintvar);\n        capaLen = capaValueLen + len;\n\n        cap_subtree = proto_tree_add_subtree(wsp_capabilities, tvb, offset, capaLen, ett_capabilities_entry, &cap_item, \"Capability\");\n        if (capaValueLen > tvb_len)\n            return;\n        offset += len;\n        /*\n         * Now offset points to the 1st byte of the capability type.\n         * Get the capability identifier.\n         */\n        peek = tvb_get_guint8(tvb, offset);\n        if (is_token_text(peek)) { /* Literal capability name */\n            /* 1. Get the string from the tvb */\n            capaName = (gchar *)tvb_get_stringz_enc(wmem_packet_scope(), tvb, capaStart, (gint *)&len, ENC_ASCII);\n\n            /* 2. Look up the string capability name */\n            if (g_ascii_strcasecmp(capaName, \"client-sdu-size\") == 0) {\n                peek = WSP_CAPA_CLIENT_SDU_SIZE;\n            } else if (g_ascii_strcasecmp(capaName, \"server-sdu-size\") == 0) {\n                peek = WSP_CAPA_SERVER_SDU_SIZE;\n            } else if (g_ascii_strcasecmp(capaName, \"protocol options\") == 0) {\n                peek = WSP_CAPA_PROTOCOL_OPTIONS;\n            } else if (g_ascii_strcasecmp(capaName, \"method-mor\") == 0) {\n                peek = WSP_CAPA_METHOD_MOR;\n            } else if (g_ascii_strcasecmp(capaName, \"push-mor\") == 0) {\n                peek = WSP_CAPA_PUSH_MOR;\n            } else if (g_ascii_strcasecmp(capaName, \"extended methods\") == 0) {\n                peek = WSP_CAPA_EXTENDED_METHODS;\n            } else if (g_ascii_strcasecmp(capaName, \"header code pages\") == 0) {\n                peek = WSP_CAPA_HEADER_CODE_PAGES;\n            } else if (g_ascii_strcasecmp(capaName, \"aliases\") == 0) {\n                peek = WSP_CAPA_ALIASES;\n            } else if (g_ascii_strcasecmp(capaName, \"client-message-size\") == 0) {\n                peek = WSP_CAPA_CLIENT_MESSAGE_SIZE;\n            } else if (g_ascii_strcasecmp(capaName, \"server-message-size\") == 0) {\n                peek = WSP_CAPA_SERVER_MESSAGE_SIZE;\n            } else {\n                expert_add_info_format(pinfo, cap_item, &ei_wsp_capability_invalid,\n                        \"Unknown or invalid textual capability: %s\", capaName);\n                /* Skip this capability */\n                offset = capaStart + capaLen;\n                continue;\n            }\n            offset += len;\n            /* Now offset points to the 1st value byte of the capability. */\n        } else if (peek < 0x80) {\n            expert_add_info_format(pinfo, cap_item, &ei_wsp_capability_invalid,\n                    \"Invalid well-known capability: 0x%02X\", peek);\n            /* Skip further capability parsing */\n            return;\n        }\n        if (peek & 0x80) { /* Well-known capability */\n            peek &= 0x7F;\n            len = 1;\n            offset++;\n            /* Now offset points to the 1st value byte of the capability. */\n        }\n\n        proto_item_append_text(cap_item, \": %s\", val_to_str_const(peek, wsp_capability_vals, \"Invalid capability\"));\n        /* Now the capability type is known */\n        switch (peek) {\n            case WSP_CAPA_CLIENT_SDU_SIZE:\n                value = tvb_get_guintvar(tvb, offset, &len, pinfo, &ei_wsp_oversized_uintvar);\n                proto_tree_add_uint(cap_subtree, hf_capa_client_sdu_size,\n                        tvb, offset, len, value);\n                break;\n            case WSP_CAPA_SERVER_SDU_SIZE:\n                value = tvb_get_guintvar(tvb, offset, &len, pinfo, &ei_wsp_oversized_uintvar);\n                proto_tree_add_uint(cap_subtree, hf_capa_server_sdu_size,\n                        tvb, offset, len, value);\n                break;\n            case WSP_CAPA_PROTOCOL_OPTIONS:\n                /*\n                 * The bits are stored in one or more octets, not an\n                 * uintvar-integer! Note that capability name and value\n                 * have length capaValueLength, and that the capability\n                 * name has length = len. Hence the remaining length is\n                 * given by capaValueLen - len.\n                 */\n                if (capaValueLen - len == 1) {\n                    static const int * capabilities[] = {\n                        &hf_capa_protocol_option_confirmed_push,\n                        &hf_capa_protocol_option_push,\n                        &hf_capa_protocol_option_session_resume,\n                        &hf_capa_protocol_option_ack_headers,\n                        &hf_capa_protocol_option_large_data_transfer,\n                        NULL\n                    };\n\n                    proto_tree_add_bitmask_with_flags(cap_subtree, tvb, offset, hf_capa_protocol_options,\n                                   ett_proto_option_capability, capabilities, ENC_NA, BMT_NO_FALSE);\n                }\n                else\n                {\n                    /*\n                     * The WSP spec foresees that this bit field can be\n                     * extended in the future. This does not make sense yet.\n                     */\n                    proto_item_append_text(cap_item,\n                            \" <warning: bit field too large>\");\n                    offset = capaStart + capaLen;\n                    continue;\n                }\n                break;\n            case WSP_CAPA_METHOD_MOR:\n                proto_tree_add_item(cap_subtree, hf_capa_method_mor, tvb, offset, len, ENC_NA);\n                break;\n            case WSP_CAPA_PUSH_MOR:\n                proto_tree_add_item(cap_subtree, hf_capa_push_mor, tvb, offset, len, ENC_NA);\n               break;\n            case WSP_CAPA_EXTENDED_METHODS:\n                /* Extended Methods capability format:\n                 * Connect PDU: collection of { Method (octet), Method-name (Token-text) }\n                 * ConnectReply PDU: collection of accepted { Method (octet) }\n                 */\n                cap_subtree2 = proto_tree_add_subtree(cap_subtree, tvb, capaStart, capaLen, ett_capabilities_extended_methods, &cap_item2, \"Extended Methods\");\n                if (pdu_type == WSP_PDU_CONNECT) {\n                    while (offset < capaStart + capaLen) {\n                        ti = proto_tree_add_item(cap_subtree2, hf_capa_extended_method, tvb, offset, 1, ENC_NA);\n                        offset++;\n\n                        get_text_string(str, tvb, offset, len, ok);\n                        if (! ok) {\n                            expert_add_info(pinfo, ti, &ei_wsp_capability_encoding_invalid);\n                            return;\n                        }\n                        proto_item_append_text(ti, \" = %s\", str);\n                        proto_item_set_len(ti, len+1);\n                        offset += len;\n                    }\n                } else {\n                    while (offset < capaStart + capaLen) {\n                        proto_tree_add_item(cap_subtree2, hf_capa_extended_method, tvb, offset, 1, ENC_NA);\n                        offset++;\n                    }\n                }\n                break;\n            case WSP_CAPA_HEADER_CODE_PAGES:\n                /* Header Code Pages capability format:\n                 * Connect PDU: collection of { Page-id (octet), Page-name (Token-text) }\n                 * ConnectReply PDU: collection of accepted { Page-id (octet) }\n                 */\n                cap_subtree2 = proto_tree_add_subtree(cap_subtree, tvb, capaStart, capaLen, ett_capabilities_header_code_pages, &cap_item2, \"Header Code Pages\");\n                if (pdu_type == WSP_PDU_CONNECT) {\n                    while (offset < capaStart + capaLen) {\n                        ti = proto_tree_add_item(cap_subtree2, hf_capa_header_code_page, tvb, offset, 1, ENC_NA);\n                        offset++;\n\n                        get_text_string(str, tvb, offset, len, ok);\n                        if (! ok) {\n                            expert_add_info(pinfo, ti, &ei_wsp_capability_encoding_invalid);\n                            return;\n                        }\n                        proto_item_append_text(ti, \" = %s\", str);\n                        proto_item_set_len(ti, len+1);\n                        offset += len;\n                    }\n                } else {\n                    while (offset < capaStart + capaLen) {\n                        proto_tree_add_item(cap_subtree2, hf_capa_header_code_page, tvb, offset, 1, ENC_NA);\n                        offset++;\n                    }\n                }\n                break;\n            case WSP_CAPA_ALIASES:\n                /* TODO - same format as redirect addresses */\n                proto_tree_add_item(cap_subtree, hf_capa_aliases,\n                        tvb, capaStart, capaLen, ENC_NA);\n                break;\n            case WSP_CAPA_CLIENT_MESSAGE_SIZE:\n                value = tvb_get_guintvar(tvb, offset, &len, pinfo, &ei_wsp_oversized_uintvar);\n                proto_tree_add_uint(cap_subtree, hf_capa_client_message_size,\n                        tvb, offset, len, value);\n                break;\n            case WSP_CAPA_SERVER_MESSAGE_SIZE:\n                value = tvb_get_guintvar(tvb, offset, &len, pinfo, &ei_wsp_oversized_uintvar);\n                proto_tree_add_uint(cap_subtree, hf_capa_server_message_size,\n                        tvb, offset, len, value);\n                break;\n            default:\n                expert_add_info_format(pinfo, cap_item, &ei_wsp_capability_invalid,\n                        \"Unknown well-known capability: 0x%02X\", peek);\n                break;\n        }\n        offset = capaStart + capaLen;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,6 +39,8 @@\n         capaLen = capaValueLen + len;\n \n         cap_subtree = proto_tree_add_subtree(wsp_capabilities, tvb, offset, capaLen, ett_capabilities_entry, &cap_item, \"Capability\");\n+        if (capaValueLen > tvb_len)\n+            return;\n         offset += len;\n         /*\n          * Now offset points to the 1st byte of the capability type.\n@@ -92,7 +94,7 @@\n             /* Now offset points to the 1st value byte of the capability. */\n         }\n \n-        proto_item_append_text(cap_item, \": %s\", val_to_str_const(peek, wsp_capability_vals, \"Invalid capabiliity\"));\n+        proto_item_append_text(cap_item, \": %s\", val_to_str_const(peek, wsp_capability_vals, \"Invalid capability\"));\n         /* Now the capability type is known */\n         switch (peek) {\n             case WSP_CAPA_CLIENT_SDU_SIZE:",
        "diff_line_info": {
            "deleted_lines": [
                "        proto_item_append_text(cap_item, \": %s\", val_to_str_const(peek, wsp_capability_vals, \"Invalid capabiliity\"));"
            ],
            "added_lines": [
                "        if (capaValueLen > tvb_len)",
                "            return;",
                "        proto_item_append_text(cap_item, \": %s\", val_to_str_const(peek, wsp_capability_vals, \"Invalid capability\"));"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9093",
        "func_name": "jsummers/imageworsener/my_skip_input_data_fn",
        "description": "The my_skip_input_data_fn function in imagew-jpeg.c in libimageworsener.a in ImageWorsener 1.3.1 allows remote attackers to cause a denial of service (infinite loop) via a crafted image.",
        "git_url": "https://github.com/jsummers/imageworsener/commit/62bfbfb1527953312f8cc10901fccba5d20e3e93",
        "commit_title": "Refactored parts of the JPEG decoder, fixing at least one bug",
        "commit_text": " This fixes a bug that could cause an infinite loop. It also corrects some error messages from \"improper call to jpeg library\" to e.g. \"unexpected end of file\". Fixes issue #26",
        "func_before": "static void my_skip_input_data_fn(j_decompress_ptr cinfo, long num_bytes)\n{\n\tstruct iwjpegrcontext *rctx = (struct iwjpegrcontext*)cinfo->src;\n\tsize_t bytes_still_to_skip;\n\tsize_t nbytes;\n\tint ret;\n\tsize_t bytesread;\n\n\tif(num_bytes<=0) return;\n\tbytes_still_to_skip = (size_t)num_bytes;\n\n\twhile(bytes_still_to_skip>0) {\n\t\tif(rctx->pub.bytes_in_buffer>0) {\n\t\t\t// There are some bytes in the buffer. Skip up to\n\t\t\t// 'bytes_still_to_skip' of them.\n\t\t\tnbytes = rctx->pub.bytes_in_buffer;\n\t\t\tif(nbytes>bytes_still_to_skip)\n\t\t\t\tnbytes = bytes_still_to_skip;\n\n\t\t\trctx->pub.bytes_in_buffer -= nbytes;\n\t\t\trctx->pub.next_input_byte += nbytes;\n\t\t\tbytes_still_to_skip -= nbytes;\n\t\t}\n\n\t\tif(bytes_still_to_skip<1) return;\n\n\t\t// Need to read from the file (or do a seek, but we currently don't\n\t\t// support seeking).\n\t\tret = (*rctx->iodescr->read_fn)(rctx->ctx,rctx->iodescr,\n\t\t\trctx->buffer,rctx->buffer_len,&bytesread);\n\t\tif(!ret) bytesread=0;\n\n\t\trctx->pub.next_input_byte = rctx->buffer;\n\t\trctx->pub.bytes_in_buffer = bytesread;\n\t}\n}",
        "func": "static void my_skip_input_data_fn(j_decompress_ptr cinfo, long num_bytes_to_skip)\n{\n\tstruct iwjpegrcontext *rctx = (struct iwjpegrcontext*)cinfo->src;\n\tsize_t bytes_still_to_skip;\n\tint ret;\n\tsize_t bytesread;\n\n\t// If the skip would leave some valid bytes in the buffer, ...\n\tif(num_bytes_to_skip < (long)rctx->pub.bytes_in_buffer) {\n\t\t// ... just move the pointer.\n\t\trctx->pub.next_input_byte += num_bytes_to_skip;\n\t\trctx->pub.bytes_in_buffer -= num_bytes_to_skip;\n\t\treturn;\n\t}\n\n\t// Otherwise, mark the buffer as empty ...\n\trctx->pub.next_input_byte = rctx->buffer;\n\trctx->pub.bytes_in_buffer = 0;\n\n\t// ... and read + throw away the requested number of bytes\n\tbytes_still_to_skip = (size_t)num_bytes_to_skip;\n\twhile(bytes_still_to_skip>0) {\n\n\t\t// Read from the file (coud do a seek instead, but we currently don't\n\t\t// support seeking).\n\t\tret = (*rctx->iodescr->read_fn)(rctx->ctx,rctx->iodescr,\n\t\t\trctx->buffer,rctx->buffer_len,&bytesread);\n\t\tif(!ret) bytesread=0;\n\t\tif(bytesread==0 || bytesread>bytes_still_to_skip) {\n\t\t\t// If we couldn't read any data, stop.\n\t\t\t// (We don't attempt to robustly support input streams for which\n\t\t\t// not all the data is available yet.)\n\t\t\tbreak;\n\t\t}\n\n\t\tbytes_still_to_skip -= bytesread;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,36 +1,38 @@\n-static void my_skip_input_data_fn(j_decompress_ptr cinfo, long num_bytes)\n+static void my_skip_input_data_fn(j_decompress_ptr cinfo, long num_bytes_to_skip)\n {\n \tstruct iwjpegrcontext *rctx = (struct iwjpegrcontext*)cinfo->src;\n \tsize_t bytes_still_to_skip;\n-\tsize_t nbytes;\n \tint ret;\n \tsize_t bytesread;\n \n-\tif(num_bytes<=0) return;\n-\tbytes_still_to_skip = (size_t)num_bytes;\n+\t// If the skip would leave some valid bytes in the buffer, ...\n+\tif(num_bytes_to_skip < (long)rctx->pub.bytes_in_buffer) {\n+\t\t// ... just move the pointer.\n+\t\trctx->pub.next_input_byte += num_bytes_to_skip;\n+\t\trctx->pub.bytes_in_buffer -= num_bytes_to_skip;\n+\t\treturn;\n+\t}\n \n+\t// Otherwise, mark the buffer as empty ...\n+\trctx->pub.next_input_byte = rctx->buffer;\n+\trctx->pub.bytes_in_buffer = 0;\n+\n+\t// ... and read + throw away the requested number of bytes\n+\tbytes_still_to_skip = (size_t)num_bytes_to_skip;\n \twhile(bytes_still_to_skip>0) {\n-\t\tif(rctx->pub.bytes_in_buffer>0) {\n-\t\t\t// There are some bytes in the buffer. Skip up to\n-\t\t\t// 'bytes_still_to_skip' of them.\n-\t\t\tnbytes = rctx->pub.bytes_in_buffer;\n-\t\t\tif(nbytes>bytes_still_to_skip)\n-\t\t\t\tnbytes = bytes_still_to_skip;\n \n-\t\t\trctx->pub.bytes_in_buffer -= nbytes;\n-\t\t\trctx->pub.next_input_byte += nbytes;\n-\t\t\tbytes_still_to_skip -= nbytes;\n-\t\t}\n-\n-\t\tif(bytes_still_to_skip<1) return;\n-\n-\t\t// Need to read from the file (or do a seek, but we currently don't\n+\t\t// Read from the file (coud do a seek instead, but we currently don't\n \t\t// support seeking).\n \t\tret = (*rctx->iodescr->read_fn)(rctx->ctx,rctx->iodescr,\n \t\t\trctx->buffer,rctx->buffer_len,&bytesread);\n \t\tif(!ret) bytesread=0;\n+\t\tif(bytesread==0 || bytesread>bytes_still_to_skip) {\n+\t\t\t// If we couldn't read any data, stop.\n+\t\t\t// (We don't attempt to robustly support input streams for which\n+\t\t\t// not all the data is available yet.)\n+\t\t\tbreak;\n+\t\t}\n \n-\t\trctx->pub.next_input_byte = rctx->buffer;\n-\t\trctx->pub.bytes_in_buffer = bytesread;\n+\t\tbytes_still_to_skip -= bytesread;\n \t}\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static void my_skip_input_data_fn(j_decompress_ptr cinfo, long num_bytes)",
                "\tsize_t nbytes;",
                "\tif(num_bytes<=0) return;",
                "\tbytes_still_to_skip = (size_t)num_bytes;",
                "\t\tif(rctx->pub.bytes_in_buffer>0) {",
                "\t\t\t// There are some bytes in the buffer. Skip up to",
                "\t\t\t// 'bytes_still_to_skip' of them.",
                "\t\t\tnbytes = rctx->pub.bytes_in_buffer;",
                "\t\t\tif(nbytes>bytes_still_to_skip)",
                "\t\t\t\tnbytes = bytes_still_to_skip;",
                "\t\t\trctx->pub.bytes_in_buffer -= nbytes;",
                "\t\t\trctx->pub.next_input_byte += nbytes;",
                "\t\t\tbytes_still_to_skip -= nbytes;",
                "\t\t}",
                "",
                "\t\tif(bytes_still_to_skip<1) return;",
                "",
                "\t\t// Need to read from the file (or do a seek, but we currently don't",
                "\t\trctx->pub.next_input_byte = rctx->buffer;",
                "\t\trctx->pub.bytes_in_buffer = bytesread;"
            ],
            "added_lines": [
                "static void my_skip_input_data_fn(j_decompress_ptr cinfo, long num_bytes_to_skip)",
                "\t// If the skip would leave some valid bytes in the buffer, ...",
                "\tif(num_bytes_to_skip < (long)rctx->pub.bytes_in_buffer) {",
                "\t\t// ... just move the pointer.",
                "\t\trctx->pub.next_input_byte += num_bytes_to_skip;",
                "\t\trctx->pub.bytes_in_buffer -= num_bytes_to_skip;",
                "\t\treturn;",
                "\t}",
                "\t// Otherwise, mark the buffer as empty ...",
                "\trctx->pub.next_input_byte = rctx->buffer;",
                "\trctx->pub.bytes_in_buffer = 0;",
                "",
                "\t// ... and read + throw away the requested number of bytes",
                "\tbytes_still_to_skip = (size_t)num_bytes_to_skip;",
                "\t\t// Read from the file (coud do a seek instead, but we currently don't",
                "\t\tif(bytesread==0 || bytesread>bytes_still_to_skip) {",
                "\t\t\t// If we couldn't read any data, stop.",
                "\t\t\t// (We don't attempt to robustly support input streams for which",
                "\t\t\t// not all the data is available yet.)",
                "\t\t\tbreak;",
                "\t\t}",
                "\t\tbytes_still_to_skip -= bytesread;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9093",
        "func_name": "jsummers/imageworsener/my_fill_input_buffer_fn",
        "description": "The my_skip_input_data_fn function in imagew-jpeg.c in libimageworsener.a in ImageWorsener 1.3.1 allows remote attackers to cause a denial of service (infinite loop) via a crafted image.",
        "git_url": "https://github.com/jsummers/imageworsener/commit/62bfbfb1527953312f8cc10901fccba5d20e3e93",
        "commit_title": "Refactored parts of the JPEG decoder, fixing at least one bug",
        "commit_text": " This fixes a bug that could cause an infinite loop. It also corrects some error messages from \"improper call to jpeg library\" to e.g. \"unexpected end of file\". Fixes issue #26",
        "func_before": "static boolean my_fill_input_buffer_fn(j_decompress_ptr cinfo)\n{\n\tstruct iwjpegrcontext *rctx = (struct iwjpegrcontext*)cinfo->src;\n\tsize_t bytesread = 0;\n\tint ret;\n\n\tret = (*rctx->iodescr->read_fn)(rctx->ctx,rctx->iodescr,\n\t\trctx->buffer,rctx->buffer_len,&bytesread);\n\tif(!ret) return FALSE;\n\n\trctx->pub.next_input_byte = rctx->buffer;\n\trctx->pub.bytes_in_buffer = bytesread;\n\n\tif(bytesread<1) return FALSE;\n\treturn TRUE;\n}",
        "func": "static boolean my_fill_input_buffer_fn(j_decompress_ptr cinfo)\n{\n\tstruct iwjpegrcontext *rctx = (struct iwjpegrcontext*)cinfo->src;\n\tsize_t bytesread = 0;\n\tint ret;\n\n\tret = (*rctx->iodescr->read_fn)(rctx->ctx,rctx->iodescr,\n\t\trctx->buffer,rctx->buffer_len,&bytesread);\n\tif((!ret) || (bytesread<1)) {\n\t\tiw_set_error(rctx->ctx, \"Unexpected end of file\");\n\t\t// Return a fake EOI marker.\n\t\trctx->buffer[0] = 0xffU;\n\t\trctx->buffer[1] = 0xd9U;\n\t\trctx->pub.bytes_in_buffer = 2;\n\t}\n\telse {\n\t\trctx->pub.bytes_in_buffer = bytesread;\n\t}\n\trctx->pub.next_input_byte = rctx->buffer;\n\n\treturn TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,11 +6,17 @@\n \n \tret = (*rctx->iodescr->read_fn)(rctx->ctx,rctx->iodescr,\n \t\trctx->buffer,rctx->buffer_len,&bytesread);\n-\tif(!ret) return FALSE;\n+\tif((!ret) || (bytesread<1)) {\n+\t\tiw_set_error(rctx->ctx, \"Unexpected end of file\");\n+\t\t// Return a fake EOI marker.\n+\t\trctx->buffer[0] = 0xffU;\n+\t\trctx->buffer[1] = 0xd9U;\n+\t\trctx->pub.bytes_in_buffer = 2;\n+\t}\n+\telse {\n+\t\trctx->pub.bytes_in_buffer = bytesread;\n+\t}\n+\trctx->pub.next_input_byte = rctx->buffer;\n \n-\trctx->pub.next_input_byte = rctx->buffer;\n-\trctx->pub.bytes_in_buffer = bytesread;\n-\n-\tif(bytesread<1) return FALSE;\n \treturn TRUE;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif(!ret) return FALSE;",
                "\trctx->pub.next_input_byte = rctx->buffer;",
                "\trctx->pub.bytes_in_buffer = bytesread;",
                "",
                "\tif(bytesread<1) return FALSE;"
            ],
            "added_lines": [
                "\tif((!ret) || (bytesread<1)) {",
                "\t\tiw_set_error(rctx->ctx, \"Unexpected end of file\");",
                "\t\t// Return a fake EOI marker.",
                "\t\trctx->buffer[0] = 0xffU;",
                "\t\trctx->buffer[1] = 0xd9U;",
                "\t\trctx->pub.bytes_in_buffer = 2;",
                "\t}",
                "\telse {",
                "\t\trctx->pub.bytes_in_buffer = bytesread;",
                "\t}",
                "\trctx->pub.next_input_byte = rctx->buffer;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9093",
        "func_name": "jsummers/imageworsener/iw_read_jpeg_file",
        "description": "The my_skip_input_data_fn function in imagew-jpeg.c in libimageworsener.a in ImageWorsener 1.3.1 allows remote attackers to cause a denial of service (infinite loop) via a crafted image.",
        "git_url": "https://github.com/jsummers/imageworsener/commit/62bfbfb1527953312f8cc10901fccba5d20e3e93",
        "commit_title": "Refactored parts of the JPEG decoder, fixing at least one bug",
        "commit_text": " This fixes a bug that could cause an infinite loop. It also corrects some error messages from \"improper call to jpeg library\" to e.g. \"unexpected end of file\". Fixes issue #26",
        "func_before": "IW_IMPL(int) iw_read_jpeg_file(struct iw_context *ctx, struct iw_iodescr *iodescr)\n{\n\tint retval=0;\n\tstruct jpeg_decompress_struct cinfo;\n\tstruct my_error_mgr jerr;\n\tint cinfo_valid=0;\n\tint colorspace;\n\tJDIMENSION rownum;\n\tJSAMPLE *jsamprow;\n\tint numchannels=0;\n\tstruct iw_image img;\n\tstruct iwjpegrcontext rctx;\n\tJSAMPLE *tmprow = NULL;\n\tint cmyk_flag = 0;\n\n\tiw_zeromem(&img,sizeof(struct iw_image));\n\tiw_zeromem(&cinfo,sizeof(struct jpeg_decompress_struct));\n\tiw_zeromem(&jerr,sizeof(struct my_error_mgr));\n\tiw_zeromem(&rctx,sizeof(struct iwjpegrcontext));\n\n\tcinfo.err = jpeg_std_error(&jerr.pub);\n\tjerr.pub.error_exit = my_error_exit;\n\tjerr.pub.output_message = my_output_message;\n\n\tif (setjmp(jerr.setjmp_buffer)) {\n\t\tchar buffer[JMSG_LENGTH_MAX];\n\n\t\t(*cinfo.err->format_message) ((j_common_ptr)&cinfo, buffer);\n\n\t\tiw_set_errorf(ctx,\"libjpeg reports read error: %s\",buffer);\n\n\t\tgoto done;\n\t}\n\n\tjpeg_create_decompress(&cinfo);\n\tcinfo_valid=1;\n\n\t// Set up our custom source manager.\n\trctx.pub.init_source = my_init_source_fn;\n\trctx.pub.fill_input_buffer = my_fill_input_buffer_fn;\n\trctx.pub.skip_input_data = my_skip_input_data_fn;\n\trctx.pub.resync_to_restart = jpeg_resync_to_restart; // libjpeg default\n\trctx.pub.term_source = my_term_source_fn;\n\trctx.ctx = ctx;\n\trctx.iodescr = iodescr;\n\trctx.buffer_len = 32768;\n\trctx.buffer = iw_malloc(ctx, rctx.buffer_len);\n\tif(!rctx.buffer) goto done;\n\trctx.exif_density_x = -1.0;\n\trctx.exif_density_y = -1.0;\n\tcinfo.src = (struct jpeg_source_mgr*)&rctx;\n\n\t// The lazy way. It would be more efficient to use\n\t// jpeg_set_marker_processor(), instead of saving everything to memory.\n\t// But libjpeg's marker processing functions have fairly complex\n\t// requirements.\n\tjpeg_save_markers(&cinfo, 0xe1, 65535);\n\n\tjpeg_read_header(&cinfo, TRUE);\n\n\trctx.is_jfif = cinfo.saw_JFIF_marker;\n\n\tiwjpeg_read_density(ctx,&img,&cinfo);\n\n\tiwjpeg_read_saved_markers(&rctx,&cinfo);\n\n\tjpeg_start_decompress(&cinfo);\n\n\tcolorspace=cinfo.out_color_space;\n\tnumchannels=cinfo.output_components;\n\n\t// libjpeg will automatically convert YCbCr images to RGB, and YCCK images\n\t// to CMYK. That leaves GRAYSCALE, RGB, and CMYK for us to handle.\n\t// Note: cinfo.jpeg_color_space is the colorspace before conversion, and\n\t// cinfo.out_color_space is the colorspace after conversion.\n\n\tif(colorspace==JCS_GRAYSCALE && numchannels==1) {\n\t\timg.imgtype = IW_IMGTYPE_GRAY;\n\t\timg.native_grayscale = 1;\n\t}\n\telse if((colorspace==JCS_RGB) && numchannels==3) {\n\t\timg.imgtype = IW_IMGTYPE_RGB;\n\t}\n\telse if((colorspace==JCS_CMYK) && numchannels==4) {\n\t\timg.imgtype = IW_IMGTYPE_RGB;\n\t\tcmyk_flag = 1;\n\t}\n\telse {\n\t\tiw_set_error(ctx,\"Unsupported type of JPEG\");\n\t\tgoto done;\n\t}\n\n\timg.width = cinfo.output_width;\n\timg.height = cinfo.output_height;\n\tif(!iw_check_image_dimensions(ctx,img.width,img.height)) {\n\t\tgoto done;\n\t}\n\n\timg.bit_depth = 8;\n\timg.bpr = iw_calc_bytesperrow(img.width,img.bit_depth*numchannels);\n\n\timg.pixels = (iw_byte*)iw_malloc_large(ctx, img.bpr, img.height);\n\tif(!img.pixels) {\n\t\tgoto done;\n\t}\n\n\tif(cmyk_flag) {\n\t\ttmprow = iw_malloc(ctx,4*img.width);\n\t\tif(!tmprow) goto done;\n\t}\n\n\twhile(cinfo.output_scanline < cinfo.output_height) {\n\t\trownum=cinfo.output_scanline;\n\t\tjsamprow = &img.pixels[img.bpr * rownum];\n\t\tif(cmyk_flag) {\n\t\t\t// read into tmprow, then convert and copy to img.pixels\n\t\t\tjpeg_read_scanlines(&cinfo, &tmprow, 1);\n\t\t\tconvert_cmyk_to_rbg(ctx,tmprow,jsamprow,img.width);\n\t\t}\n\t\telse {\n\t\t\t// read directly into img.pixels\n\t\t\tjpeg_read_scanlines(&cinfo, &jsamprow, 1);\n\t\t}\n\t\tif(cinfo.output_scanline<=rownum) {\n\t\t\tiw_set_error(ctx,\"Error reading JPEG file\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\tjpeg_finish_decompress(&cinfo);\n\n\thandle_exif_density(&rctx, &img);\n\n\tiw_set_input_image(ctx, &img);\n\t// The contents of img no longer belong to us.\n\timg.pixels = NULL;\n\n\tif(rctx.exif_orientation>=2 && rctx.exif_orientation<=8) {\n\t\tstatic const unsigned int exif_orient_to_transform[9] =\n\t\t   { 0,0, 1,3,2,4,5,7,6 };\n\n\t\t// An Exif marker indicated an unusual image orientation.\n\n\t\tif(rctx.is_jfif) {\n\t\t\t// The presence of a JFIF marker implies a particular orientation.\n\t\t\t// If there's also an Exif marker that says something different,\n\t\t\t// I'm not sure what we're supposed to do.\n\t\t\tiw_warning(ctx,\"JPEG image has an ambiguous orientation\");\n\t\t}\n\t\tiw_reorient_image(ctx,exif_orient_to_transform[rctx.exif_orientation]);\n\t}\n\n\tretval=1;\n\ndone:\n\tiw_free(ctx, img.pixels);\n\tif(cinfo_valid) jpeg_destroy_decompress(&cinfo);\n\tif(rctx.buffer) iw_free(ctx,rctx.buffer);\n\tif(tmprow) iw_free(ctx,tmprow);\n\treturn retval;\n}",
        "func": "IW_IMPL(int) iw_read_jpeg_file(struct iw_context *ctx, struct iw_iodescr *iodescr)\n{\n\tint retval=0;\n\tstruct jpeg_decompress_struct cinfo;\n\tstruct my_error_mgr jerr;\n\tint cinfo_valid=0;\n\tint colorspace;\n\tJDIMENSION rownum;\n\tJSAMPLE *jsamprow;\n\tint numchannels=0;\n\tstruct iw_image img;\n\tstruct iwjpegrcontext rctx;\n\tJSAMPLE *tmprow = NULL;\n\tint cmyk_flag = 0;\n\tint ret;\n\n\tiw_zeromem(&img,sizeof(struct iw_image));\n\tiw_zeromem(&cinfo,sizeof(struct jpeg_decompress_struct));\n\tiw_zeromem(&jerr,sizeof(struct my_error_mgr));\n\tiw_zeromem(&rctx,sizeof(struct iwjpegrcontext));\n\n\tcinfo.err = jpeg_std_error(&jerr.pub);\n\tjerr.pub.error_exit = my_error_exit;\n\tjerr.pub.output_message = my_output_message;\n\n\tif (setjmp(jerr.setjmp_buffer)) {\n\t\tchar buffer[JMSG_LENGTH_MAX];\n\n\t\t(*cinfo.err->format_message) ((j_common_ptr)&cinfo, buffer);\n\n\t\tiw_set_errorf(ctx,\"libjpeg reports read error: %s\",buffer);\n\n\t\tgoto done;\n\t}\n\n\tjpeg_create_decompress(&cinfo);\n\tcinfo_valid=1;\n\n\t// Set up our custom source manager.\n\trctx.pub.init_source = my_init_source_fn;\n\trctx.pub.fill_input_buffer = my_fill_input_buffer_fn;\n\trctx.pub.skip_input_data = my_skip_input_data_fn;\n\trctx.pub.resync_to_restart = jpeg_resync_to_restart; // libjpeg default\n\trctx.pub.term_source = my_term_source_fn;\n\trctx.ctx = ctx;\n\trctx.iodescr = iodescr;\n\trctx.buffer_len = 32768;\n\trctx.buffer = iw_malloc(ctx, rctx.buffer_len);\n\tif(!rctx.buffer) goto done;\n\trctx.exif_density_x = -1.0;\n\trctx.exif_density_y = -1.0;\n\tcinfo.src = (struct jpeg_source_mgr*)&rctx;\n\n\t// The lazy way. It would be more efficient to use\n\t// jpeg_set_marker_processor(), instead of saving everything to memory.\n\t// But libjpeg's marker processing functions have fairly complex\n\t// requirements.\n\tjpeg_save_markers(&cinfo, 0xe1, 65535);\n\n\tret = jpeg_read_header(&cinfo, TRUE);\n\tif(ret != JPEG_HEADER_OK) {\n\t\t// I don't think this is supposed to be possible, assuming the second\n\t\t// param to jpeg_read_header is TRUE, and our fill_input_buffer\n\t\t// function always returns TRUE.\n\t\tiw_set_error(ctx, \"Unexpected libjpeg error\");\n\t\tgoto done;\n\t}\n\n\trctx.is_jfif = cinfo.saw_JFIF_marker;\n\n\tiwjpeg_read_density(ctx,&img,&cinfo);\n\n\tiwjpeg_read_saved_markers(&rctx,&cinfo);\n\n\tjpeg_start_decompress(&cinfo);\n\n\tcolorspace=cinfo.out_color_space;\n\tnumchannels=cinfo.output_components;\n\n\t// libjpeg will automatically convert YCbCr images to RGB, and YCCK images\n\t// to CMYK. That leaves GRAYSCALE, RGB, and CMYK for us to handle.\n\t// Note: cinfo.jpeg_color_space is the colorspace before conversion, and\n\t// cinfo.out_color_space is the colorspace after conversion.\n\n\tif(colorspace==JCS_GRAYSCALE && numchannels==1) {\n\t\timg.imgtype = IW_IMGTYPE_GRAY;\n\t\timg.native_grayscale = 1;\n\t}\n\telse if((colorspace==JCS_RGB) && numchannels==3) {\n\t\timg.imgtype = IW_IMGTYPE_RGB;\n\t}\n\telse if((colorspace==JCS_CMYK) && numchannels==4) {\n\t\timg.imgtype = IW_IMGTYPE_RGB;\n\t\tcmyk_flag = 1;\n\t}\n\telse {\n\t\tiw_set_error(ctx,\"Unsupported type of JPEG\");\n\t\tgoto done;\n\t}\n\n\timg.width = cinfo.output_width;\n\timg.height = cinfo.output_height;\n\tif(!iw_check_image_dimensions(ctx,img.width,img.height)) {\n\t\tgoto done;\n\t}\n\n\timg.bit_depth = 8;\n\timg.bpr = iw_calc_bytesperrow(img.width,img.bit_depth*numchannels);\n\n\timg.pixels = (iw_byte*)iw_malloc_large(ctx, img.bpr, img.height);\n\tif(!img.pixels) {\n\t\tgoto done;\n\t}\n\n\tif(cmyk_flag) {\n\t\ttmprow = iw_malloc(ctx,4*img.width);\n\t\tif(!tmprow) goto done;\n\t}\n\n\twhile(cinfo.output_scanline < cinfo.output_height) {\n\t\trownum=cinfo.output_scanline;\n\t\tjsamprow = &img.pixels[img.bpr * rownum];\n\t\tif(cmyk_flag) {\n\t\t\t// read into tmprow, then convert and copy to img.pixels\n\t\t\tjpeg_read_scanlines(&cinfo, &tmprow, 1);\n\t\t\tconvert_cmyk_to_rbg(ctx,tmprow,jsamprow,img.width);\n\t\t}\n\t\telse {\n\t\t\t// read directly into img.pixels\n\t\t\tjpeg_read_scanlines(&cinfo, &jsamprow, 1);\n\t\t}\n\t\tif(cinfo.output_scanline<=rownum) {\n\t\t\tiw_set_error(ctx,\"Error reading JPEG file\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\tjpeg_finish_decompress(&cinfo);\n\n\thandle_exif_density(&rctx, &img);\n\n\tiw_set_input_image(ctx, &img);\n\t// The contents of img no longer belong to us.\n\timg.pixels = NULL;\n\n\tif(rctx.exif_orientation>=2 && rctx.exif_orientation<=8) {\n\t\tstatic const unsigned int exif_orient_to_transform[9] =\n\t\t   { 0,0, 1,3,2,4,5,7,6 };\n\n\t\t// An Exif marker indicated an unusual image orientation.\n\n\t\tif(rctx.is_jfif) {\n\t\t\t// The presence of a JFIF marker implies a particular orientation.\n\t\t\t// If there's also an Exif marker that says something different,\n\t\t\t// I'm not sure what we're supposed to do.\n\t\t\tiw_warning(ctx,\"JPEG image has an ambiguous orientation\");\n\t\t}\n\t\tiw_reorient_image(ctx,exif_orient_to_transform[rctx.exif_orientation]);\n\t}\n\n\tretval=1;\n\ndone:\n\tiw_free(ctx, img.pixels);\n\tif(cinfo_valid) jpeg_destroy_decompress(&cinfo);\n\tif(rctx.buffer) iw_free(ctx,rctx.buffer);\n\tif(tmprow) iw_free(ctx,tmprow);\n\treturn retval;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,6 +12,7 @@\n \tstruct iwjpegrcontext rctx;\n \tJSAMPLE *tmprow = NULL;\n \tint cmyk_flag = 0;\n+\tint ret;\n \n \tiw_zeromem(&img,sizeof(struct iw_image));\n \tiw_zeromem(&cinfo,sizeof(struct jpeg_decompress_struct));\n@@ -56,7 +57,14 @@\n \t// requirements.\n \tjpeg_save_markers(&cinfo, 0xe1, 65535);\n \n-\tjpeg_read_header(&cinfo, TRUE);\n+\tret = jpeg_read_header(&cinfo, TRUE);\n+\tif(ret != JPEG_HEADER_OK) {\n+\t\t// I don't think this is supposed to be possible, assuming the second\n+\t\t// param to jpeg_read_header is TRUE, and our fill_input_buffer\n+\t\t// function always returns TRUE.\n+\t\tiw_set_error(ctx, \"Unexpected libjpeg error\");\n+\t\tgoto done;\n+\t}\n \n \trctx.is_jfif = cinfo.saw_JFIF_marker;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tjpeg_read_header(&cinfo, TRUE);"
            ],
            "added_lines": [
                "\tint ret;",
                "\tret = jpeg_read_header(&cinfo, TRUE);",
                "\tif(ret != JPEG_HEADER_OK) {",
                "\t\t// I don't think this is supposed to be possible, assuming the second",
                "\t\t// param to jpeg_read_header is TRUE, and our fill_input_buffer",
                "\t\t// function always returns TRUE.",
                "\t\tiw_set_error(ctx, \"Unexpected libjpeg error\");",
                "\t\tgoto done;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9094",
        "func_name": "jsummers/imageworsener/lzw_process_code",
        "description": "The lzw_add_to_dict function in imagew-gif.c in libimageworsener.a in ImageWorsener 1.3.1 allows remote attackers to cause a denial of service (infinite loop) via a crafted image.",
        "git_url": "https://github.com/jsummers/imageworsener/commit/a75fd4879c55c89651f7f247293a61eef3e51be1",
        "commit_title": "Fixed a bug related to decoding invalid GIF files",
        "commit_text": " The bug could cause an infinite loop, and possibly other problems. Fixes issue #27",
        "func_before": "static int lzw_process_code(struct iwgifrcontext *rctx, struct lzwdeccontext *d,\n\t\tunsigned int code)\n{\n\tif(code==d->eoi_code) {\n\t\td->eoi_flag=1;\n\t\treturn 1;\n\t}\n\n\tif(code==d->clear_code) {\n\t\tlzw_clear(d);\n\t\treturn 1;\n\t}\n\n\td->ncodes_since_clear++;\n\n\tif(d->ncodes_since_clear==1) {\n\t\t// Special case for the first code.\n\t\tlzw_emit_code(rctx,d,code);\n\t\td->oldcode = code;\n\t\treturn 1;\n\t}\n\n\t// Is code in code table?\n\tif(code < d->ct_used) {\n\t\t// Yes, code is in table.\n\t\tlzw_emit_code(rctx,d,code);\n\n\t\t// Let k = the first character of the translation of the code.\n\t\t// Add <oldcode>k to the dictionary.\n\t\tlzw_add_to_dict(d,d->oldcode,d->ct[code].firstchar);\n\t}\n\telse {\n\t\t// No, code is not in table.\n\t\tif(d->oldcode>=d->ct_used) {\n\t\t\tiw_set_error(rctx->ctx,\"GIF decoding error\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Let k = the first char of the translation of oldcode.\n\t\t// Add <oldcode>k to the dictionary.\n\t\tif(lzw_add_to_dict(d,d->oldcode,d->ct[d->oldcode].firstchar)) {\n\t\t\t// Write <oldcode>k to the output stream.\n\t\t\tlzw_emit_code(rctx,d,d->last_code_added);\n\t\t}\n\t}\n\td->oldcode = code;\n\n\treturn 1;\n}",
        "func": "static int lzw_process_code(struct iwgifrcontext *rctx, struct lzwdeccontext *d,\n\t\tunsigned int code)\n{\n\tint ret;\n\n\tif(code==d->eoi_code) {\n\t\td->eoi_flag=1;\n\t\treturn 1;\n\t}\n\n\tif(code==d->clear_code) {\n\t\tlzw_clear(d);\n\t\treturn 1;\n\t}\n\n\td->ncodes_since_clear++;\n\n\tif(d->ncodes_since_clear==1) {\n\t\t// Special case for the first code.\n\t\tlzw_emit_code(rctx,d,code);\n\t\td->oldcode = code;\n\t\treturn 1;\n\t}\n\n\t// Is code in code table?\n\tif(code < d->ct_used) {\n\t\t// Yes, code is in table.\n\t\tlzw_emit_code(rctx,d,code);\n\n\t\t// Let k = the first character of the translation of the code.\n\t\t// Add <oldcode>k to the dictionary.\n\t\tret = lzw_add_to_dict(rctx,d,d->oldcode,d->ct[code].firstchar);\n\t\tif(ret==0) return 0;\n\t}\n\telse {\n\t\t// No, code is not in table.\n\t\tif(d->oldcode>=d->ct_used) {\n\t\t\tiw_set_error(rctx->ctx,\"GIF decoding error\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Let k = the first char of the translation of oldcode.\n\t\t// Add <oldcode>k to the dictionary.\n\t\tret = lzw_add_to_dict(rctx,d,d->oldcode,d->ct[d->oldcode].firstchar);\n\t\tif(ret==0) return 0;\n\t\tif(ret==1) {\n\t\t\t// Write <oldcode>k to the output stream.\n\t\t\tlzw_emit_code(rctx,d,d->last_code_added);\n\t\t}\n\t}\n\td->oldcode = code;\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,8 @@\n static int lzw_process_code(struct iwgifrcontext *rctx, struct lzwdeccontext *d,\n \t\tunsigned int code)\n {\n+\tint ret;\n+\n \tif(code==d->eoi_code) {\n \t\td->eoi_flag=1;\n \t\treturn 1;\n@@ -27,7 +29,8 @@\n \n \t\t// Let k = the first character of the translation of the code.\n \t\t// Add <oldcode>k to the dictionary.\n-\t\tlzw_add_to_dict(d,d->oldcode,d->ct[code].firstchar);\n+\t\tret = lzw_add_to_dict(rctx,d,d->oldcode,d->ct[code].firstchar);\n+\t\tif(ret==0) return 0;\n \t}\n \telse {\n \t\t// No, code is not in table.\n@@ -38,7 +41,9 @@\n \n \t\t// Let k = the first char of the translation of oldcode.\n \t\t// Add <oldcode>k to the dictionary.\n-\t\tif(lzw_add_to_dict(d,d->oldcode,d->ct[d->oldcode].firstchar)) {\n+\t\tret = lzw_add_to_dict(rctx,d,d->oldcode,d->ct[d->oldcode].firstchar);\n+\t\tif(ret==0) return 0;\n+\t\tif(ret==1) {\n \t\t\t// Write <oldcode>k to the output stream.\n \t\t\tlzw_emit_code(rctx,d,d->last_code_added);\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tlzw_add_to_dict(d,d->oldcode,d->ct[code].firstchar);",
                "\t\tif(lzw_add_to_dict(d,d->oldcode,d->ct[d->oldcode].firstchar)) {"
            ],
            "added_lines": [
                "\tint ret;",
                "",
                "\t\tret = lzw_add_to_dict(rctx,d,d->oldcode,d->ct[code].firstchar);",
                "\t\tif(ret==0) return 0;",
                "\t\tret = lzw_add_to_dict(rctx,d,d->oldcode,d->ct[d->oldcode].firstchar);",
                "\t\tif(ret==0) return 0;",
                "\t\tif(ret==1) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9094",
        "func_name": "jsummers/imageworsener/lzw_add_to_dict",
        "description": "The lzw_add_to_dict function in imagew-gif.c in libimageworsener.a in ImageWorsener 1.3.1 allows remote attackers to cause a denial of service (infinite loop) via a crafted image.",
        "git_url": "https://github.com/jsummers/imageworsener/commit/a75fd4879c55c89651f7f247293a61eef3e51be1",
        "commit_title": "Fixed a bug related to decoding invalid GIF files",
        "commit_text": " The bug could cause an infinite loop, and possibly other problems. Fixes issue #27",
        "func_before": "static int lzw_add_to_dict(struct lzwdeccontext *d, unsigned int oldcode, iw_byte val)\n{\n\tstatic const unsigned int last_code_of_size[] = {\n\t\t// The first 3 values are unused.\n\t\t0,0,0,7,15,31,63,127,255,511,1023,2047,4095\n\t};\n\tunsigned int newpos;\n\n\tif(d->ct_used>=4096) {\n\t\td->last_code_added = 0;\n\t\treturn 0;\n\t}\n\n\tnewpos = d->ct_used;\n\td->ct_used++;\n\n\td->ct[newpos].parent = (iw_uint16)oldcode;\n\td->ct[newpos].length = d->ct[oldcode].length + 1;\n\td->ct[newpos].firstchar = d->ct[oldcode].firstchar;\n\td->ct[newpos].lastchar = val;\n\n\t// If we've used the last code of this size, we need to increase the codesize.\n\tif(newpos == last_code_of_size[d->current_codesize]) {\n\t\tif(d->current_codesize<12) {\n\t\t\td->current_codesize++;\n\t\t}\n\t}\n\n\td->last_code_added = newpos;\n\treturn 1;\n}",
        "func": "static int lzw_add_to_dict(struct iwgifrcontext *rctx, struct lzwdeccontext *d,\n\tunsigned int oldcode, iw_byte val)\n{\n\tstatic const unsigned int last_code_of_size[] = {\n\t\t// The first 3 values are unused.\n\t\t0,0,0,7,15,31,63,127,255,511,1023,2047,4095\n\t};\n\tunsigned int newpos;\n\n\tif(d->ct_used>=4096) {\n\t\td->last_code_added = 0;\n\t\treturn 2;\n\t}\n\n\tnewpos = d->ct_used;\n\n\tif(oldcode >= newpos) {\n\t\tiw_set_error(rctx->ctx, \"GIF decoding error\");\n\t\treturn 0;\n\t}\n\n\td->ct_used++;\n\n\td->ct[newpos].parent = (iw_uint16)oldcode;\n\td->ct[newpos].length = d->ct[oldcode].length + 1;\n\td->ct[newpos].firstchar = d->ct[oldcode].firstchar;\n\td->ct[newpos].lastchar = val;\n\n\t// If we've used the last code of this size, we need to increase the codesize.\n\tif(newpos == last_code_of_size[d->current_codesize]) {\n\t\tif(d->current_codesize<12) {\n\t\t\td->current_codesize++;\n\t\t}\n\t}\n\n\td->last_code_added = newpos;\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,5 @@\n-static int lzw_add_to_dict(struct lzwdeccontext *d, unsigned int oldcode, iw_byte val)\n+static int lzw_add_to_dict(struct iwgifrcontext *rctx, struct lzwdeccontext *d,\n+\tunsigned int oldcode, iw_byte val)\n {\n \tstatic const unsigned int last_code_of_size[] = {\n \t\t// The first 3 values are unused.\n@@ -8,10 +9,16 @@\n \n \tif(d->ct_used>=4096) {\n \t\td->last_code_added = 0;\n+\t\treturn 2;\n+\t}\n+\n+\tnewpos = d->ct_used;\n+\n+\tif(oldcode >= newpos) {\n+\t\tiw_set_error(rctx->ctx, \"GIF decoding error\");\n \t\treturn 0;\n \t}\n \n-\tnewpos = d->ct_used;\n \td->ct_used++;\n \n \td->ct[newpos].parent = (iw_uint16)oldcode;",
        "diff_line_info": {
            "deleted_lines": [
                "static int lzw_add_to_dict(struct lzwdeccontext *d, unsigned int oldcode, iw_byte val)",
                "\tnewpos = d->ct_used;"
            ],
            "added_lines": [
                "static int lzw_add_to_dict(struct iwgifrcontext *rctx, struct lzwdeccontext *d,",
                "\tunsigned int oldcode, iw_byte val)",
                "\t\treturn 2;",
                "\t}",
                "",
                "\tnewpos = d->ct_used;",
                "",
                "\tif(oldcode >= newpos) {",
                "\t\tiw_set_error(rctx->ctx, \"GIF decoding error\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9345",
        "func_name": "wireshark/expand_dns_name",
        "description": "In Wireshark 2.2.0 to 2.2.6 and 2.0.0 to 2.0.12, the DNS dissector could go into an infinite loop. This was addressed in epan/dissectors/packet-dns.c by trying to detect self-referencing pointers.",
        "git_url": "https://github.com/wireshark/wireshark/commit/e280c9b637327a65d132bfe72d917b87e6844eb5",
        "commit_title": "dns: improve loop detection in label decompression",
        "commit_text": " Previously the number of allowed pointers within a message is equal to the data in a tvb (16575 in one example). This is still expensive, so implement an alternative detection mechanism that looks for a direct self-loop and limits the total pointers to about 256.  Bug: 13633 Link: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=1206 (cherry picked from commit 129bdb5a164a6386c35ff387e9d8f0d3d6a12dbf)",
        "func_before": "int\nexpand_dns_name(tvbuff_t *tvb, int offset, int max_len, int dns_data_offset,\n    const guchar **name)\n{\n  int     start_offset    = offset;\n  guchar *np;\n  int     len             = -1;\n  int     chars_processed = 0;\n  int     data_size       = tvb_reported_length_remaining(tvb, dns_data_offset);\n  int     component_len;\n  int     indir_offset;\n  int     maxname;\n\n  const int min_len = 1;        /* Minimum length of encoded name (for root) */\n        /* If we're about to return a value (probably negative) which is less\n         * than the minimum length, we're looking at bad data and we're liable\n         * to put the dissector into a loop.  Instead we throw an exception */\n\n  maxname=MAXDNAME;\n  np=(guchar *)wmem_alloc(wmem_packet_scope(), maxname);\n  *name=np;\n\n  maxname--;   /* reserve space for the trailing '\\0' */\n  for (;;) {\n    if (max_len && offset - start_offset > max_len - 1) {\n      break;\n    }\n    component_len = tvb_get_guint8(tvb, offset);\n    offset++;\n    if (component_len == 0) {\n      break;\n    }\n    chars_processed++;\n    switch (component_len & 0xc0) {\n\n      case 0x00:\n        /* Label */\n        if (np != *name) {\n          /* Not the first component - put in a '.'. */\n          if (maxname > 0) {\n            *np++ = '.';\n            maxname--;\n          }\n        }\n        while (component_len > 0) {\n          if (max_len && offset - start_offset > max_len - 1) {\n            THROW(ReportedBoundsError);\n          }\n          if (maxname > 0) {\n            *np++ = tvb_get_guint8(tvb, offset);\n            maxname--;\n          }\n          component_len--;\n          offset++;\n          chars_processed++;\n        }\n        break;\n\n      case 0x40:\n        /* Extended label (RFC 2673) */\n        switch (component_len & 0x3f) {\n\n          case 0x01:\n            /* Bitstring label */\n          {\n            int bit_count;\n            int label_len;\n            int print_len;\n\n            bit_count = tvb_get_guint8(tvb, offset);\n            offset++;\n            label_len = (bit_count - 1) / 8 + 1;\n\n            if (maxname > 0) {\n              print_len = g_snprintf(np, maxname + 1, \"\\\\[x\");\n              if (print_len <= maxname) {\n                np      += print_len;\n                maxname -= print_len;\n              } else {\n                /* Nothing printed, as there's no room.\n                   Suppress all subsequent printing. */\n                maxname = 0;\n              }\n            }\n            while (label_len--) {\n              if (maxname > 0) {\n                print_len = g_snprintf(np, maxname + 1, \"%02x\",\n                                       tvb_get_guint8(tvb, offset));\n                if (print_len <= maxname) {\n                  np      += print_len;\n                  maxname -= print_len;\n                } else {\n                  /* Nothing printed, as there's no room.\n                     Suppress all subsequent printing. */\n                  maxname = 0;\n                }\n              }\n              offset++;\n            }\n            if (maxname > 0) {\n              print_len = g_snprintf(np, maxname + 1, \"/%d]\", bit_count);\n              if (print_len <= maxname) {\n                np      += print_len;\n                maxname -= print_len;\n              } else {\n                /* Nothing printed, as there's no room.\n                   Suppress all subsequent printing. */\n                maxname = 0;\n              }\n            }\n          }\n          break;\n\n          default:\n            *name=\"<Unknown extended label>\";\n            /* Parsing will probably fail from here on, since the */\n            /* label length is unknown... */\n            len = offset - start_offset;\n            if (len < min_len) {\n              THROW(ReportedBoundsError);\n            }\n            return len;\n        }\n        break;\n\n      case 0x80:\n        THROW(ReportedBoundsError);\n        break;\n\n      case 0xc0:\n        /* Pointer. */\n        indir_offset = dns_data_offset +\n          (((component_len & ~0xc0) << 8) | tvb_get_guint8(tvb, offset));\n        offset++;\n        chars_processed++;\n\n        /* If \"len\" is negative, we are still working on the original name,\n           not something pointed to by a pointer, and so we should set \"len\"\n           to the length of the original name. */\n        if (len < 0) {\n          len = offset - start_offset;\n        }\n        /* If we've looked at every character in the message, this pointer\n           will make us look at some character again, which means we're\n           looping. */\n        if (chars_processed >= data_size) {\n          *name=\"<Name contains a pointer that loops>\";\n          if (len < min_len) {\n            THROW(ReportedBoundsError);\n          }\n          return len;\n        }\n\n        offset = indir_offset;\n        break;   /* now continue processing from there */\n    }\n  }\n\n  *np = '\\0';\n  /* If \"len\" is negative, we haven't seen a pointer, and thus haven't\n     set the length, so set it. */\n  if (len < 0) {\n    len = offset - start_offset;\n  }\n  if (len < min_len) {\n    THROW(ReportedBoundsError);\n  }\n  return len;\n}",
        "func": "int\nexpand_dns_name(tvbuff_t *tvb, int offset, int max_len, int dns_data_offset,\n    const guchar **name)\n{\n  int     start_offset    = offset;\n  guchar *np;\n  int     len             = -1;\n  int     pointers_count  = 0;\n  int     component_len;\n  int     indir_offset;\n  int     maxname;\n\n  const int min_len = 1;        /* Minimum length of encoded name (for root) */\n        /* If we're about to return a value (probably negative) which is less\n         * than the minimum length, we're looking at bad data and we're liable\n         * to put the dissector into a loop.  Instead we throw an exception */\n\n  maxname=MAXDNAME;\n  np=(guchar *)wmem_alloc(wmem_packet_scope(), maxname);\n  *name=np;\n\n  maxname--;   /* reserve space for the trailing '\\0' */\n  for (;;) {\n    if (max_len && offset - start_offset > max_len - 1) {\n      break;\n    }\n    component_len = tvb_get_guint8(tvb, offset);\n    offset++;\n    if (component_len == 0) {\n      break;\n    }\n    switch (component_len & 0xc0) {\n\n      case 0x00:\n        /* Label */\n        if (np != *name) {\n          /* Not the first component - put in a '.'. */\n          if (maxname > 0) {\n            *np++ = '.';\n            maxname--;\n          }\n        }\n        while (component_len > 0) {\n          if (max_len && offset - start_offset > max_len - 1) {\n            THROW(ReportedBoundsError);\n          }\n          if (maxname > 0) {\n            *np++ = tvb_get_guint8(tvb, offset);\n            maxname--;\n          }\n          component_len--;\n          offset++;\n        }\n        break;\n\n      case 0x40:\n        /* Extended label (RFC 2673) */\n        switch (component_len & 0x3f) {\n\n          case 0x01:\n            /* Bitstring label */\n          {\n            int bit_count;\n            int label_len;\n            int print_len;\n\n            bit_count = tvb_get_guint8(tvb, offset);\n            offset++;\n            label_len = (bit_count - 1) / 8 + 1;\n\n            if (maxname > 0) {\n              print_len = g_snprintf(np, maxname + 1, \"\\\\[x\");\n              if (print_len <= maxname) {\n                np      += print_len;\n                maxname -= print_len;\n              } else {\n                /* Nothing printed, as there's no room.\n                   Suppress all subsequent printing. */\n                maxname = 0;\n              }\n            }\n            while (label_len--) {\n              if (maxname > 0) {\n                print_len = g_snprintf(np, maxname + 1, \"%02x\",\n                                       tvb_get_guint8(tvb, offset));\n                if (print_len <= maxname) {\n                  np      += print_len;\n                  maxname -= print_len;\n                } else {\n                  /* Nothing printed, as there's no room.\n                     Suppress all subsequent printing. */\n                  maxname = 0;\n                }\n              }\n              offset++;\n            }\n            if (maxname > 0) {\n              print_len = g_snprintf(np, maxname + 1, \"/%d]\", bit_count);\n              if (print_len <= maxname) {\n                np      += print_len;\n                maxname -= print_len;\n              } else {\n                /* Nothing printed, as there's no room.\n                   Suppress all subsequent printing. */\n                maxname = 0;\n              }\n            }\n          }\n          break;\n\n          default:\n            *name=\"<Unknown extended label>\";\n            /* Parsing will probably fail from here on, since the */\n            /* label length is unknown... */\n            len = offset - start_offset;\n            if (len < min_len) {\n              THROW(ReportedBoundsError);\n            }\n            return len;\n        }\n        break;\n\n      case 0x80:\n        THROW(ReportedBoundsError);\n        break;\n\n      case 0xc0:\n        /* Pointer. */\n        indir_offset = dns_data_offset +\n          (((component_len & ~0xc0) << 8) | tvb_get_guint8(tvb, offset));\n        offset++;\n        pointers_count++;\n\n        /* If \"len\" is negative, we are still working on the original name,\n           not something pointed to by a pointer, and so we should set \"len\"\n           to the length of the original name. */\n        if (len < 0) {\n          len = offset - start_offset;\n        }\n        /*\n         * If we find a pointer to itself, it is a trivial loop. Otherwise if we\n         * processed a large number of pointers, assume an indirect loop.\n         */\n        if (indir_offset == offset + 2 || pointers_count > MAXDNAME/4) {\n          *name=\"<Name contains a pointer that loops>\";\n          if (len < min_len) {\n            THROW(ReportedBoundsError);\n          }\n          return len;\n        }\n\n        offset = indir_offset;\n        break;   /* now continue processing from there */\n    }\n  }\n\n  *np = '\\0';\n  /* If \"len\" is negative, we haven't seen a pointer, and thus haven't\n     set the length, so set it. */\n  if (len < 0) {\n    len = offset - start_offset;\n  }\n  if (len < min_len) {\n    THROW(ReportedBoundsError);\n  }\n  return len;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,8 +5,7 @@\n   int     start_offset    = offset;\n   guchar *np;\n   int     len             = -1;\n-  int     chars_processed = 0;\n-  int     data_size       = tvb_reported_length_remaining(tvb, dns_data_offset);\n+  int     pointers_count  = 0;\n   int     component_len;\n   int     indir_offset;\n   int     maxname;\n@@ -30,7 +29,6 @@\n     if (component_len == 0) {\n       break;\n     }\n-    chars_processed++;\n     switch (component_len & 0xc0) {\n \n       case 0x00:\n@@ -52,7 +50,6 @@\n           }\n           component_len--;\n           offset++;\n-          chars_processed++;\n         }\n         break;\n \n@@ -132,7 +129,7 @@\n         indir_offset = dns_data_offset +\n           (((component_len & ~0xc0) << 8) | tvb_get_guint8(tvb, offset));\n         offset++;\n-        chars_processed++;\n+        pointers_count++;\n \n         /* If \"len\" is negative, we are still working on the original name,\n            not something pointed to by a pointer, and so we should set \"len\"\n@@ -140,10 +137,11 @@\n         if (len < 0) {\n           len = offset - start_offset;\n         }\n-        /* If we've looked at every character in the message, this pointer\n-           will make us look at some character again, which means we're\n-           looping. */\n-        if (chars_processed >= data_size) {\n+        /*\n+         * If we find a pointer to itself, it is a trivial loop. Otherwise if we\n+         * processed a large number of pointers, assume an indirect loop.\n+         */\n+        if (indir_offset == offset + 2 || pointers_count > MAXDNAME/4) {\n           *name=\"<Name contains a pointer that loops>\";\n           if (len < min_len) {\n             THROW(ReportedBoundsError);",
        "diff_line_info": {
            "deleted_lines": [
                "  int     chars_processed = 0;",
                "  int     data_size       = tvb_reported_length_remaining(tvb, dns_data_offset);",
                "    chars_processed++;",
                "          chars_processed++;",
                "        chars_processed++;",
                "        /* If we've looked at every character in the message, this pointer",
                "           will make us look at some character again, which means we're",
                "           looping. */",
                "        if (chars_processed >= data_size) {"
            ],
            "added_lines": [
                "  int     pointers_count  = 0;",
                "        pointers_count++;",
                "        /*",
                "         * If we find a pointer to itself, it is a trivial loop. Otherwise if we",
                "         * processed a large number of pointers, assume an indirect loop.",
                "         */",
                "        if (indir_offset == offset + 2 || pointers_count > MAXDNAME/4) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9349",
        "func_name": "wireshark/dissect_dcm_pdu_data",
        "description": "In Wireshark 2.2.0 to 2.2.6 and 2.0.0 to 2.0.12, the DICOM dissector has an infinite loop. This was addressed in epan/dissectors/packet-dcm.c by validating a length value.",
        "git_url": "https://github.com/wireshark/wireshark/commit/cb1b6494c44c9e939d9e2554de6b812de395e3f9",
        "commit_title": "packet-dcm.c: Fix infinite loop",
        "commit_text": " https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=1329 Bug: 13685 (cherry picked from commit 538abdfbc2225e8c39de99811fb9cbef53b0911b)",
        "func_before": "static guint32\ndissect_dcm_pdu_data(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                     dcm_state_assoc_t *assoc, guint32 offset, guint32 pdu_len, gchar **pdu_data_description)\n{\n\n    /*  04 P-DATA-TF\n         1  1 reserved\n         2  4 length\n              - (1+) presentation data value (PDV) items\n         6  4 length\n        10  1 Presentation Context ID (odd ints 1 - 255)\n              - PDV\n        11  1 header\n              0x01 if set, contains Message Command info, else Message Data\n              0x02 if set, contains last fragment\n    */\n\n    proto_tree *pdv_ptree;      /* Tree for item details */\n    proto_item *pdv_pitem, *pdvlen_item;\n\n    gchar  *buf_desc = NULL;            /* PDU description */\n    gchar  *pdv_description = NULL;\n\n    gboolean first_pdv = TRUE;\n\n    guint32 endpos = 0;\n    guint32 pdv_len = 0;\n\n    endpos = offset + pdu_len;\n\n    buf_desc=(gchar *)wmem_alloc0(wmem_file_scope(), MAX_BUF_LEN);      /* Valid for this capture, since we return this buffer */\n\n    /* Loop through multiple PDVs */\n    while (offset < endpos) {\n\n        pdv_len = tvb_get_ntohl(tvb, offset);\n\n        pdv_ptree = proto_tree_add_subtree(tree, tvb, offset, pdv_len+4, ett_dcm_data_pdv, &pdv_pitem, \"PDV\");\n\n        pdvlen_item = proto_tree_add_item(pdv_ptree, hf_dcm_pdv_len, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset += 4;\n\n        if (pdv_len + 4 > pdu_len) {\n            expert_add_info_format(pinfo, pdvlen_item, &ei_dcm_pdv_len, \"Invalid PDV length (too large)\");\n            return endpos;\n        }\n        else if (pdv_len <= 2) {\n            expert_add_info_format(pinfo, pdvlen_item, &ei_dcm_pdv_len, \"Invalid PDV length (too small)\");\n            return endpos;\n        }\n        else if (((pdv_len >> 1) << 1) != pdv_len) {\n            expert_add_info_format(pinfo, pdvlen_item, &ei_dcm_pdv_len, \"Invalid PDV length (not even)\");\n            return endpos;\n        }\n\n        offset = dissect_dcm_pdv_fragmented(tvb, pinfo, pdv_ptree, assoc, offset, pdv_len, &pdv_description);\n\n        /* The following doesn't seem to work anymore */\n        if (pdv_description) {\n            if (first_pdv) {\n                g_snprintf(buf_desc, MAX_BUF_LEN, \"%s\", pdv_description);\n            }\n            else {\n                g_snprintf(buf_desc, MAX_BUF_LEN, \"%s, %s\", buf_desc, pdv_description);\n            }\n        }\n\n        proto_item_append_text(pdv_pitem, \", %s\", pdv_description);\n        first_pdv=FALSE;\n\n    }\n\n    *pdu_data_description = buf_desc;\n\n    return offset;\n}",
        "func": "static guint32\ndissect_dcm_pdu_data(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree,\n                     dcm_state_assoc_t *assoc, guint32 offset, guint32 pdu_len, gchar **pdu_data_description)\n{\n\n    /*  04 P-DATA-TF\n         1  1 reserved\n         2  4 length\n              - (1+) presentation data value (PDV) items\n         6  4 length\n        10  1 Presentation Context ID (odd ints 1 - 255)\n              - PDV\n        11  1 header\n              0x01 if set, contains Message Command info, else Message Data\n              0x02 if set, contains last fragment\n    */\n\n    proto_tree *pdv_ptree;      /* Tree for item details */\n    proto_item *pdv_pitem, *pdvlen_item;\n\n    gchar  *buf_desc = NULL;            /* PDU description */\n    gchar  *pdv_description = NULL;\n\n    gboolean first_pdv = TRUE;\n\n    guint32 endpos = 0;\n    guint32 pdv_len = 0;\n\n    endpos = offset + pdu_len;\n\n    buf_desc=(gchar *)wmem_alloc0(wmem_file_scope(), MAX_BUF_LEN);      /* Valid for this capture, since we return this buffer */\n\n    /* Loop through multiple PDVs */\n    while (offset < endpos) {\n\n        pdv_len = tvb_get_ntohl(tvb, offset);\n\n        pdv_ptree = proto_tree_add_subtree(tree, tvb, offset, pdv_len+4, ett_dcm_data_pdv, &pdv_pitem, \"PDV\");\n\n        pdvlen_item = proto_tree_add_item(pdv_ptree, hf_dcm_pdv_len, tvb, offset, 4, ENC_BIG_ENDIAN);\n        offset += 4;\n\n        if ((pdv_len + 4 > pdu_len)  || (pdv_len + 4 < pdv_len)) {\n            expert_add_info_format(pinfo, pdvlen_item, &ei_dcm_pdv_len, \"Invalid PDV length (too large)\");\n            return endpos;\n        }\n        else if (pdv_len <= 2) {\n            expert_add_info_format(pinfo, pdvlen_item, &ei_dcm_pdv_len, \"Invalid PDV length (too small)\");\n            return endpos;\n        }\n        else if (((pdv_len >> 1) << 1) != pdv_len) {\n            expert_add_info_format(pinfo, pdvlen_item, &ei_dcm_pdv_len, \"Invalid PDV length (not even)\");\n            return endpos;\n        }\n\n        offset = dissect_dcm_pdv_fragmented(tvb, pinfo, pdv_ptree, assoc, offset, pdv_len, &pdv_description);\n\n        /* The following doesn't seem to work anymore */\n        if (pdv_description) {\n            if (first_pdv) {\n                g_snprintf(buf_desc, MAX_BUF_LEN, \"%s\", pdv_description);\n            }\n            else {\n                g_snprintf(buf_desc, MAX_BUF_LEN, \"%s, %s\", buf_desc, pdv_description);\n            }\n        }\n\n        proto_item_append_text(pdv_pitem, \", %s\", pdv_description);\n        first_pdv=FALSE;\n\n    }\n\n    *pdu_data_description = buf_desc;\n\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -40,7 +40,7 @@\n         pdvlen_item = proto_tree_add_item(pdv_ptree, hf_dcm_pdv_len, tvb, offset, 4, ENC_BIG_ENDIAN);\n         offset += 4;\n \n-        if (pdv_len + 4 > pdu_len) {\n+        if ((pdv_len + 4 > pdu_len)  || (pdv_len + 4 < pdv_len)) {\n             expert_add_info_format(pinfo, pdvlen_item, &ei_dcm_pdv_len, \"Invalid PDV length (too large)\");\n             return endpos;\n         }",
        "diff_line_info": {
            "deleted_lines": [
                "        if (pdv_len + 4 > pdu_len) {"
            ],
            "added_lines": [
                "        if ((pdv_len + 4 > pdu_len)  || (pdv_len + 4 < pdv_len)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9352",
        "func_name": "wireshark/get_bzr_pdu_len",
        "description": "In Wireshark 2.2.0 to 2.2.6 and 2.0.0 to 2.0.12, the Bazaar dissector could go into an infinite loop. This was addressed in epan/dissectors/packet-bzr.c by ensuring that backwards parsing cannot occur.",
        "git_url": "https://github.com/wireshark/wireshark/commit/8c5e0cee278ff0678b0ebf4b9c2a614974b4029a",
        "commit_title": "packet-bzr.c: Prevent infinite loop",
        "commit_text": " Bug: 13599 (cherry picked from commit afb4de370a4c54e08e9367b55ae142414efc6e8f)",
        "func_before": "static guint\nget_bzr_pdu_len(packet_info *pinfo _U_, tvbuff_t *tvb, int offset)\n{\n    int    next_offset;\n    gint   len = 0;\n    gint   protocol_version_len;\n    guint8 cmd = 0;\n\n    /* Protocol version */\n    protocol_version_len = tvb_find_line_end(tvb, offset, -1, &next_offset,\n                                             TRUE);\n    if (protocol_version_len == -1) /* End of the packet not seen yet */\n        return -1;\n\n    len += protocol_version_len + 1;\n\n    /* Headers */\n    len += get_bzr_prefixed_len(tvb, next_offset);\n\n    while (tvb_reported_length_remaining(tvb, offset + len) > 0) {\n        cmd = tvb_get_guint8(tvb, offset + len);\n        len += 1;\n\n        switch (cmd) {\n        case 's':\n        case 'b':\n            len += get_bzr_prefixed_len(tvb, offset + len);\n            break;\n        case 'o':\n            len += 1;\n            break;\n        case 'e':\n            return len;\n        }\n    }\n\n    return -1;\n}",
        "func": "static guint\nget_bzr_pdu_len(packet_info *pinfo _U_, tvbuff_t *tvb, int offset)\n{\n    int    next_offset;\n    gint   len = 0, current_len;\n    gint   protocol_version_len;\n    guint8 cmd = 0;\n\n    /* Protocol version */\n    protocol_version_len = tvb_find_line_end(tvb, offset, -1, &next_offset,\n                                             TRUE);\n    if (protocol_version_len == -1) /* End of the packet not seen yet */\n        return -1;\n\n    len += protocol_version_len + 1;\n\n    /* Headers */\n    current_len = len;\n    len += get_bzr_prefixed_len(tvb, next_offset);\n    if (current_len > len) /* Make sure we're not going backwards */\n        return -1;\n\n    while (tvb_reported_length_remaining(tvb, offset + len) > 0) {\n        cmd = tvb_get_guint8(tvb, offset + len);\n        len += 1;\n\n        switch (cmd) {\n        case 's':\n        case 'b':\n            current_len = len;\n            len += get_bzr_prefixed_len(tvb, offset + len);\n            if (current_len > len) /* Make sure we're not going backwards */\n                return -1;\n            break;\n        case 'o':\n            len += 1;\n            break;\n        case 'e':\n            return len;\n        }\n    }\n\n    return -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n get_bzr_pdu_len(packet_info *pinfo _U_, tvbuff_t *tvb, int offset)\n {\n     int    next_offset;\n-    gint   len = 0;\n+    gint   len = 0, current_len;\n     gint   protocol_version_len;\n     guint8 cmd = 0;\n \n@@ -15,7 +15,10 @@\n     len += protocol_version_len + 1;\n \n     /* Headers */\n+    current_len = len;\n     len += get_bzr_prefixed_len(tvb, next_offset);\n+    if (current_len > len) /* Make sure we're not going backwards */\n+        return -1;\n \n     while (tvb_reported_length_remaining(tvb, offset + len) > 0) {\n         cmd = tvb_get_guint8(tvb, offset + len);\n@@ -24,7 +27,10 @@\n         switch (cmd) {\n         case 's':\n         case 'b':\n+            current_len = len;\n             len += get_bzr_prefixed_len(tvb, offset + len);\n+            if (current_len > len) /* Make sure we're not going backwards */\n+                return -1;\n             break;\n         case 'o':\n             len += 1;",
        "diff_line_info": {
            "deleted_lines": [
                "    gint   len = 0;"
            ],
            "added_lines": [
                "    gint   len = 0, current_len;",
                "    current_len = len;",
                "    if (current_len > len) /* Make sure we're not going backwards */",
                "        return -1;",
                "            current_len = len;",
                "            if (current_len > len) /* Make sure we're not going backwards */",
                "                return -1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9310",
        "func_name": "qemu/e1000e_ring_empty",
        "description": "QEMU (aka Quick Emulator), when built with the e1000e NIC emulation support, allows local guest OS privileged users to cause a denial of service (infinite loop) via vectors related to setting the initial receive / transmit descriptor head (TDH/RDH) outside the allocated descriptor buffer.",
        "git_url": "https://github.com/qemu/qemu/commit/4154c7e03fa55b4cf52509a83d50d6c09d743b77",
        "commit_title": "net: e1000e: fix an infinite loop issue",
        "commit_text": " This issue is like the issue in e1000 network card addressed in this commit: e1000: eliminate infinite loops on out-of-bounds transfer start. ",
        "func_before": "static inline bool\ne1000e_ring_empty(E1000ECore *core, const E1000E_RingInfo *r)\n{\n    return core->mac[r->dh] == core->mac[r->dt];\n}",
        "func": "static inline bool\ne1000e_ring_empty(E1000ECore *core, const E1000E_RingInfo *r)\n{\n    return core->mac[r->dh] == core->mac[r->dt] ||\n                core->mac[r->dt] >= core->mac[r->dlen] / E1000_RING_DESC_LEN;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n static inline bool\n e1000e_ring_empty(E1000ECore *core, const E1000E_RingInfo *r)\n {\n-    return core->mac[r->dh] == core->mac[r->dt];\n+    return core->mac[r->dh] == core->mac[r->dt] ||\n+                core->mac[r->dt] >= core->mac[r->dlen] / E1000_RING_DESC_LEN;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    return core->mac[r->dh] == core->mac[r->dt];"
            ],
            "added_lines": [
                "    return core->mac[r->dh] == core->mac[r->dt] ||",
                "                core->mac[r->dt] >= core->mac[r->dlen] / E1000_RING_DESC_LEN;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9310",
        "func_name": "qemu/e1000e_write_packet_to_guest",
        "description": "QEMU (aka Quick Emulator), when built with the e1000e NIC emulation support, allows local guest OS privileged users to cause a denial of service (infinite loop) via vectors related to setting the initial receive / transmit descriptor head (TDH/RDH) outside the allocated descriptor buffer.",
        "git_url": "https://github.com/qemu/qemu/commit/4154c7e03fa55b4cf52509a83d50d6c09d743b77",
        "commit_title": "net: e1000e: fix an infinite loop issue",
        "commit_text": " This issue is like the issue in e1000 network card addressed in this commit: e1000: eliminate infinite loops on out-of-bounds transfer start. ",
        "func_before": "static void\ne1000e_write_packet_to_guest(E1000ECore *core, struct NetRxPkt *pkt,\n                             const E1000E_RxRing *rxr,\n                             const E1000E_RSSInfo *rss_info)\n{\n    PCIDevice *d = core->owner;\n    dma_addr_t base;\n    uint8_t desc[E1000_MAX_RX_DESC_LEN];\n    size_t desc_size;\n    size_t desc_offset = 0;\n    size_t iov_ofs = 0;\n\n    struct iovec *iov = net_rx_pkt_get_iovec(pkt);\n    size_t size = net_rx_pkt_get_total_len(pkt);\n    size_t total_size = size + e1000x_fcs_len(core->mac);\n    const E1000E_RingInfo *rxi;\n    size_t ps_hdr_len = 0;\n    bool do_ps = e1000e_do_ps(core, pkt, &ps_hdr_len);\n    bool is_first = true;\n\n    rxi = rxr->i;\n\n    do {\n        hwaddr ba[MAX_PS_BUFFERS];\n        e1000e_ba_state bastate = { { 0 } };\n        bool is_last = false;\n\n        desc_size = total_size - desc_offset;\n\n        if (desc_size > core->rx_desc_buf_size) {\n            desc_size = core->rx_desc_buf_size;\n        }\n\n        base = e1000e_ring_head_descr(core, rxi);\n\n        pci_dma_read(d, base, &desc, core->rx_desc_len);\n\n        trace_e1000e_rx_descr(rxi->idx, base, core->rx_desc_len);\n\n        e1000e_read_rx_descr(core, desc, &ba);\n\n        if (ba[0]) {\n            if (desc_offset < size) {\n                static const uint32_t fcs_pad;\n                size_t iov_copy;\n                size_t copy_size = size - desc_offset;\n                if (copy_size > core->rx_desc_buf_size) {\n                    copy_size = core->rx_desc_buf_size;\n                }\n\n                /* For PS mode copy the packet header first */\n                if (do_ps) {\n                    if (is_first) {\n                        size_t ps_hdr_copied = 0;\n                        do {\n                            iov_copy = MIN(ps_hdr_len - ps_hdr_copied,\n                                           iov->iov_len - iov_ofs);\n\n                            e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,\n                                                      iov->iov_base, iov_copy);\n\n                            copy_size -= iov_copy;\n                            ps_hdr_copied += iov_copy;\n\n                            iov_ofs += iov_copy;\n                            if (iov_ofs == iov->iov_len) {\n                                iov++;\n                                iov_ofs = 0;\n                            }\n                        } while (ps_hdr_copied < ps_hdr_len);\n\n                        is_first = false;\n                    } else {\n                        /* Leave buffer 0 of each descriptor except first */\n                        /* empty as per spec 7.1.5.1                      */\n                        e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,\n                                                       NULL, 0);\n                    }\n                }\n\n                /* Copy packet payload */\n                while (copy_size) {\n                    iov_copy = MIN(copy_size, iov->iov_len - iov_ofs);\n\n                    e1000e_write_to_rx_buffers(core, &ba, &bastate,\n                                            iov->iov_base + iov_ofs, iov_copy);\n\n                    copy_size -= iov_copy;\n                    iov_ofs += iov_copy;\n                    if (iov_ofs == iov->iov_len) {\n                        iov++;\n                        iov_ofs = 0;\n                    }\n                }\n\n                if (desc_offset + desc_size >= total_size) {\n                    /* Simulate FCS checksum presence in the last descriptor */\n                    e1000e_write_to_rx_buffers(core, &ba, &bastate,\n                          (const char *) &fcs_pad, e1000x_fcs_len(core->mac));\n                }\n            }\n            desc_offset += desc_size;\n            if (desc_offset >= total_size) {\n                is_last = true;\n            }\n        } else { /* as per intel docs; skip descriptors with null buf addr */\n            trace_e1000e_rx_null_descriptor();\n        }\n\n        e1000e_write_rx_descr(core, desc, is_last ? core->rx_pkt : NULL,\n                           rss_info, do_ps ? ps_hdr_len : 0, &bastate.written);\n        pci_dma_write(d, base, &desc, core->rx_desc_len);\n\n        e1000e_ring_advance(core, rxi,\n                            core->rx_desc_len / E1000_MIN_RX_DESC_LEN);\n\n    } while (desc_offset < total_size);\n\n    e1000e_update_rx_stats(core, size, total_size);\n}",
        "func": "static void\ne1000e_write_packet_to_guest(E1000ECore *core, struct NetRxPkt *pkt,\n                             const E1000E_RxRing *rxr,\n                             const E1000E_RSSInfo *rss_info)\n{\n    PCIDevice *d = core->owner;\n    dma_addr_t base;\n    uint8_t desc[E1000_MAX_RX_DESC_LEN];\n    size_t desc_size;\n    size_t desc_offset = 0;\n    size_t iov_ofs = 0;\n\n    struct iovec *iov = net_rx_pkt_get_iovec(pkt);\n    size_t size = net_rx_pkt_get_total_len(pkt);\n    size_t total_size = size + e1000x_fcs_len(core->mac);\n    const E1000E_RingInfo *rxi;\n    size_t ps_hdr_len = 0;\n    bool do_ps = e1000e_do_ps(core, pkt, &ps_hdr_len);\n    bool is_first = true;\n\n    rxi = rxr->i;\n\n    do {\n        hwaddr ba[MAX_PS_BUFFERS];\n        e1000e_ba_state bastate = { { 0 } };\n        bool is_last = false;\n\n        desc_size = total_size - desc_offset;\n\n        if (desc_size > core->rx_desc_buf_size) {\n            desc_size = core->rx_desc_buf_size;\n        }\n\n        if (e1000e_ring_empty(core, rxi)) {\n            return;\n        }\n\n        base = e1000e_ring_head_descr(core, rxi);\n\n        pci_dma_read(d, base, &desc, core->rx_desc_len);\n\n        trace_e1000e_rx_descr(rxi->idx, base, core->rx_desc_len);\n\n        e1000e_read_rx_descr(core, desc, &ba);\n\n        if (ba[0]) {\n            if (desc_offset < size) {\n                static const uint32_t fcs_pad;\n                size_t iov_copy;\n                size_t copy_size = size - desc_offset;\n                if (copy_size > core->rx_desc_buf_size) {\n                    copy_size = core->rx_desc_buf_size;\n                }\n\n                /* For PS mode copy the packet header first */\n                if (do_ps) {\n                    if (is_first) {\n                        size_t ps_hdr_copied = 0;\n                        do {\n                            iov_copy = MIN(ps_hdr_len - ps_hdr_copied,\n                                           iov->iov_len - iov_ofs);\n\n                            e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,\n                                                      iov->iov_base, iov_copy);\n\n                            copy_size -= iov_copy;\n                            ps_hdr_copied += iov_copy;\n\n                            iov_ofs += iov_copy;\n                            if (iov_ofs == iov->iov_len) {\n                                iov++;\n                                iov_ofs = 0;\n                            }\n                        } while (ps_hdr_copied < ps_hdr_len);\n\n                        is_first = false;\n                    } else {\n                        /* Leave buffer 0 of each descriptor except first */\n                        /* empty as per spec 7.1.5.1                      */\n                        e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,\n                                                       NULL, 0);\n                    }\n                }\n\n                /* Copy packet payload */\n                while (copy_size) {\n                    iov_copy = MIN(copy_size, iov->iov_len - iov_ofs);\n\n                    e1000e_write_to_rx_buffers(core, &ba, &bastate,\n                                            iov->iov_base + iov_ofs, iov_copy);\n\n                    copy_size -= iov_copy;\n                    iov_ofs += iov_copy;\n                    if (iov_ofs == iov->iov_len) {\n                        iov++;\n                        iov_ofs = 0;\n                    }\n                }\n\n                if (desc_offset + desc_size >= total_size) {\n                    /* Simulate FCS checksum presence in the last descriptor */\n                    e1000e_write_to_rx_buffers(core, &ba, &bastate,\n                          (const char *) &fcs_pad, e1000x_fcs_len(core->mac));\n                }\n            }\n            desc_offset += desc_size;\n            if (desc_offset >= total_size) {\n                is_last = true;\n            }\n        } else { /* as per intel docs; skip descriptors with null buf addr */\n            trace_e1000e_rx_null_descriptor();\n        }\n\n        e1000e_write_rx_descr(core, desc, is_last ? core->rx_pkt : NULL,\n                           rss_info, do_ps ? ps_hdr_len : 0, &bastate.written);\n        pci_dma_write(d, base, &desc, core->rx_desc_len);\n\n        e1000e_ring_advance(core, rxi,\n                            core->rx_desc_len / E1000_MIN_RX_DESC_LEN);\n\n    } while (desc_offset < total_size);\n\n    e1000e_update_rx_stats(core, size, total_size);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -29,6 +29,10 @@\n \n         if (desc_size > core->rx_desc_buf_size) {\n             desc_size = core->rx_desc_buf_size;\n+        }\n+\n+        if (e1000e_ring_empty(core, rxi)) {\n+            return;\n         }\n \n         base = e1000e_ring_head_descr(core, rxi);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        }",
                "",
                "        if (e1000e_ring_empty(core, rxi)) {",
                "            return;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9330",
        "func_name": "qemu/ohci_service_iso_td",
        "description": "QEMU (aka Quick Emulator) before 2.9.0, when built with the USB OHCI Emulation support, allows local guest OS users to cause a denial of service (infinite loop) by leveraging an incorrect return value, a different vulnerability than CVE-2017-6505.",
        "git_url": "https://github.com/qemu/qemu/commit/26f670a244982335cc08943fb1ec099a2c81e42d",
        "commit_title": "usb: ohci: fix error return code in servicing iso td",
        "commit_text": " It should return 1 if an error occurs when reading iso td. This will avoid an infinite loop issue in ohci_service_ed_list. ",
        "func_before": "static int ohci_service_iso_td(OHCIState *ohci, struct ohci_ed *ed,\n                               int completion)\n{\n    int dir;\n    size_t len = 0;\n    const char *str = NULL;\n    int pid;\n    int ret;\n    int i;\n    USBDevice *dev;\n    USBEndpoint *ep;\n    struct ohci_iso_td iso_td;\n    uint32_t addr;\n    uint16_t starting_frame;\n    int16_t relative_frame_number;\n    int frame_count;\n    uint32_t start_offset, next_offset, end_offset = 0;\n    uint32_t start_addr, end_addr;\n\n    addr = ed->head & OHCI_DPTR_MASK;\n\n    if (ohci_read_iso_td(ohci, addr, &iso_td)) {\n        trace_usb_ohci_iso_td_read_failed(addr);\n        ohci_die(ohci);\n        return 0;\n    }\n\n    starting_frame = OHCI_BM(iso_td.flags, TD_SF);\n    frame_count = OHCI_BM(iso_td.flags, TD_FC);\n    relative_frame_number = USUB(ohci->frame_number, starting_frame); \n\n    trace_usb_ohci_iso_td_head(\n           ed->head & OHCI_DPTR_MASK, ed->tail & OHCI_DPTR_MASK,\n           iso_td.flags, iso_td.bp, iso_td.next, iso_td.be,\n           ohci->frame_number, starting_frame,\n           frame_count, relative_frame_number);\n    trace_usb_ohci_iso_td_head_offset(\n           iso_td.offset[0], iso_td.offset[1],\n           iso_td.offset[2], iso_td.offset[3],\n           iso_td.offset[4], iso_td.offset[5],\n           iso_td.offset[6], iso_td.offset[7]);\n\n    if (relative_frame_number < 0) {\n        trace_usb_ohci_iso_td_relative_frame_number_neg(relative_frame_number);\n        return 1;\n    } else if (relative_frame_number > frame_count) {\n        /* ISO TD expired - retire the TD to the Done Queue and continue with\n           the next ISO TD of the same ED */\n        trace_usb_ohci_iso_td_relative_frame_number_big(relative_frame_number,\n                                                        frame_count);\n        OHCI_SET_BM(iso_td.flags, TD_CC, OHCI_CC_DATAOVERRUN);\n        ed->head &= ~OHCI_DPTR_MASK;\n        ed->head |= (iso_td.next & OHCI_DPTR_MASK);\n        iso_td.next = ohci->done;\n        ohci->done = addr;\n        i = OHCI_BM(iso_td.flags, TD_DI);\n        if (i < ohci->done_count)\n            ohci->done_count = i;\n        if (ohci_put_iso_td(ohci, addr, &iso_td)) {\n            ohci_die(ohci);\n            return 1;\n        }\n        return 0;\n    }\n\n    dir = OHCI_BM(ed->flags, ED_D);\n    switch (dir) {\n    case OHCI_TD_DIR_IN:\n        str = \"in\";\n        pid = USB_TOKEN_IN;\n        break;\n    case OHCI_TD_DIR_OUT:\n        str = \"out\";\n        pid = USB_TOKEN_OUT;\n        break;\n    case OHCI_TD_DIR_SETUP:\n        str = \"setup\";\n        pid = USB_TOKEN_SETUP;\n        break;\n    default:\n        trace_usb_ohci_iso_td_bad_direction(dir);\n        return 1;\n    }\n\n    if (!iso_td.bp || !iso_td.be) {\n        trace_usb_ohci_iso_td_bad_bp_be(iso_td.bp, iso_td.be);\n        return 1;\n    }\n\n    start_offset = iso_td.offset[relative_frame_number];\n    next_offset = iso_td.offset[relative_frame_number + 1];\n\n    if (!(OHCI_BM(start_offset, TD_PSW_CC) & 0xe) || \n        ((relative_frame_number < frame_count) && \n         !(OHCI_BM(next_offset, TD_PSW_CC) & 0xe))) {\n        trace_usb_ohci_iso_td_bad_cc_not_accessed(start_offset, next_offset);\n        return 1;\n    }\n\n    if ((relative_frame_number < frame_count) && (start_offset > next_offset)) {\n        trace_usb_ohci_iso_td_bad_cc_overrun(start_offset, next_offset);\n        return 1;\n    }\n\n    if ((start_offset & 0x1000) == 0) {\n        start_addr = (iso_td.bp & OHCI_PAGE_MASK) |\n            (start_offset & OHCI_OFFSET_MASK);\n    } else {\n        start_addr = (iso_td.be & OHCI_PAGE_MASK) |\n            (start_offset & OHCI_OFFSET_MASK);\n    }\n\n    if (relative_frame_number < frame_count) {\n        end_offset = next_offset - 1;\n        if ((end_offset & 0x1000) == 0) {\n            end_addr = (iso_td.bp & OHCI_PAGE_MASK) |\n                (end_offset & OHCI_OFFSET_MASK);\n        } else {\n            end_addr = (iso_td.be & OHCI_PAGE_MASK) |\n                (end_offset & OHCI_OFFSET_MASK);\n        }\n    } else {\n        /* Last packet in the ISO TD */\n        end_addr = iso_td.be;\n    }\n\n    if ((start_addr & OHCI_PAGE_MASK) != (end_addr & OHCI_PAGE_MASK)) {\n        len = (end_addr & OHCI_OFFSET_MASK) + 0x1001\n            - (start_addr & OHCI_OFFSET_MASK);\n    } else {\n        len = end_addr - start_addr + 1;\n    }\n\n    if (len && dir != OHCI_TD_DIR_IN) {\n        if (ohci_copy_iso_td(ohci, start_addr, end_addr, ohci->usb_buf, len,\n                             DMA_DIRECTION_TO_DEVICE)) {\n            ohci_die(ohci);\n            return 1;\n        }\n    }\n\n    if (!completion) {\n        bool int_req = relative_frame_number == frame_count &&\n                       OHCI_BM(iso_td.flags, TD_DI) == 0;\n        dev = ohci_find_device(ohci, OHCI_BM(ed->flags, ED_FA));\n        ep = usb_ep_get(dev, pid, OHCI_BM(ed->flags, ED_EN));\n        usb_packet_setup(&ohci->usb_packet, pid, ep, 0, addr, false, int_req);\n        usb_packet_addbuf(&ohci->usb_packet, ohci->usb_buf, len);\n        usb_handle_packet(dev, &ohci->usb_packet);\n        if (ohci->usb_packet.status == USB_RET_ASYNC) {\n            usb_device_flush_ep_queue(dev, ep);\n            return 1;\n        }\n    }\n    if (ohci->usb_packet.status == USB_RET_SUCCESS) {\n        ret = ohci->usb_packet.actual_length;\n    } else {\n        ret = ohci->usb_packet.status;\n    }\n\n    trace_usb_ohci_iso_td_so(start_offset, end_offset, start_addr, end_addr,\n                             str, len, ret);\n\n    /* Writeback */\n    if (dir == OHCI_TD_DIR_IN && ret >= 0 && ret <= len) {\n        /* IN transfer succeeded */\n        if (ohci_copy_iso_td(ohci, start_addr, end_addr, ohci->usb_buf, ret,\n                             DMA_DIRECTION_FROM_DEVICE)) {\n            ohci_die(ohci);\n            return 1;\n        }\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                    OHCI_CC_NOERROR);\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE, ret);\n    } else if (dir == OHCI_TD_DIR_OUT && ret == len) {\n        /* OUT transfer succeeded */\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                    OHCI_CC_NOERROR);\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE, 0);\n    } else {\n        if (ret > (ssize_t) len) {\n            trace_usb_ohci_iso_td_data_overrun(ret, len);\n            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                        OHCI_CC_DATAOVERRUN);\n            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,\n                        len);\n        } else if (ret >= 0) {\n            trace_usb_ohci_iso_td_data_underrun(ret);\n            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                        OHCI_CC_DATAUNDERRUN);\n        } else {\n            switch (ret) {\n            case USB_RET_IOERROR:\n            case USB_RET_NODEV:\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                            OHCI_CC_DEVICENOTRESPONDING);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,\n                            0);\n                break;\n            case USB_RET_NAK:\n            case USB_RET_STALL:\n                trace_usb_ohci_iso_td_nak(ret);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                            OHCI_CC_STALL);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,\n                            0);\n                break;\n            default:\n                trace_usb_ohci_iso_td_bad_response(ret);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                            OHCI_CC_UNDEXPETEDPID);\n                break;\n            }\n        }\n    }\n\n    if (relative_frame_number == frame_count) {\n        /* Last data packet of ISO TD - retire the TD to the Done Queue */\n        OHCI_SET_BM(iso_td.flags, TD_CC, OHCI_CC_NOERROR);\n        ed->head &= ~OHCI_DPTR_MASK;\n        ed->head |= (iso_td.next & OHCI_DPTR_MASK);\n        iso_td.next = ohci->done;\n        ohci->done = addr;\n        i = OHCI_BM(iso_td.flags, TD_DI);\n        if (i < ohci->done_count)\n            ohci->done_count = i;\n    }\n    if (ohci_put_iso_td(ohci, addr, &iso_td)) {\n        ohci_die(ohci);\n    }\n    return 1;\n}",
        "func": "static int ohci_service_iso_td(OHCIState *ohci, struct ohci_ed *ed,\n                               int completion)\n{\n    int dir;\n    size_t len = 0;\n    const char *str = NULL;\n    int pid;\n    int ret;\n    int i;\n    USBDevice *dev;\n    USBEndpoint *ep;\n    struct ohci_iso_td iso_td;\n    uint32_t addr;\n    uint16_t starting_frame;\n    int16_t relative_frame_number;\n    int frame_count;\n    uint32_t start_offset, next_offset, end_offset = 0;\n    uint32_t start_addr, end_addr;\n\n    addr = ed->head & OHCI_DPTR_MASK;\n\n    if (ohci_read_iso_td(ohci, addr, &iso_td)) {\n        trace_usb_ohci_iso_td_read_failed(addr);\n        ohci_die(ohci);\n        return 1;\n    }\n\n    starting_frame = OHCI_BM(iso_td.flags, TD_SF);\n    frame_count = OHCI_BM(iso_td.flags, TD_FC);\n    relative_frame_number = USUB(ohci->frame_number, starting_frame); \n\n    trace_usb_ohci_iso_td_head(\n           ed->head & OHCI_DPTR_MASK, ed->tail & OHCI_DPTR_MASK,\n           iso_td.flags, iso_td.bp, iso_td.next, iso_td.be,\n           ohci->frame_number, starting_frame,\n           frame_count, relative_frame_number);\n    trace_usb_ohci_iso_td_head_offset(\n           iso_td.offset[0], iso_td.offset[1],\n           iso_td.offset[2], iso_td.offset[3],\n           iso_td.offset[4], iso_td.offset[5],\n           iso_td.offset[6], iso_td.offset[7]);\n\n    if (relative_frame_number < 0) {\n        trace_usb_ohci_iso_td_relative_frame_number_neg(relative_frame_number);\n        return 1;\n    } else if (relative_frame_number > frame_count) {\n        /* ISO TD expired - retire the TD to the Done Queue and continue with\n           the next ISO TD of the same ED */\n        trace_usb_ohci_iso_td_relative_frame_number_big(relative_frame_number,\n                                                        frame_count);\n        OHCI_SET_BM(iso_td.flags, TD_CC, OHCI_CC_DATAOVERRUN);\n        ed->head &= ~OHCI_DPTR_MASK;\n        ed->head |= (iso_td.next & OHCI_DPTR_MASK);\n        iso_td.next = ohci->done;\n        ohci->done = addr;\n        i = OHCI_BM(iso_td.flags, TD_DI);\n        if (i < ohci->done_count)\n            ohci->done_count = i;\n        if (ohci_put_iso_td(ohci, addr, &iso_td)) {\n            ohci_die(ohci);\n            return 1;\n        }\n        return 0;\n    }\n\n    dir = OHCI_BM(ed->flags, ED_D);\n    switch (dir) {\n    case OHCI_TD_DIR_IN:\n        str = \"in\";\n        pid = USB_TOKEN_IN;\n        break;\n    case OHCI_TD_DIR_OUT:\n        str = \"out\";\n        pid = USB_TOKEN_OUT;\n        break;\n    case OHCI_TD_DIR_SETUP:\n        str = \"setup\";\n        pid = USB_TOKEN_SETUP;\n        break;\n    default:\n        trace_usb_ohci_iso_td_bad_direction(dir);\n        return 1;\n    }\n\n    if (!iso_td.bp || !iso_td.be) {\n        trace_usb_ohci_iso_td_bad_bp_be(iso_td.bp, iso_td.be);\n        return 1;\n    }\n\n    start_offset = iso_td.offset[relative_frame_number];\n    next_offset = iso_td.offset[relative_frame_number + 1];\n\n    if (!(OHCI_BM(start_offset, TD_PSW_CC) & 0xe) || \n        ((relative_frame_number < frame_count) && \n         !(OHCI_BM(next_offset, TD_PSW_CC) & 0xe))) {\n        trace_usb_ohci_iso_td_bad_cc_not_accessed(start_offset, next_offset);\n        return 1;\n    }\n\n    if ((relative_frame_number < frame_count) && (start_offset > next_offset)) {\n        trace_usb_ohci_iso_td_bad_cc_overrun(start_offset, next_offset);\n        return 1;\n    }\n\n    if ((start_offset & 0x1000) == 0) {\n        start_addr = (iso_td.bp & OHCI_PAGE_MASK) |\n            (start_offset & OHCI_OFFSET_MASK);\n    } else {\n        start_addr = (iso_td.be & OHCI_PAGE_MASK) |\n            (start_offset & OHCI_OFFSET_MASK);\n    }\n\n    if (relative_frame_number < frame_count) {\n        end_offset = next_offset - 1;\n        if ((end_offset & 0x1000) == 0) {\n            end_addr = (iso_td.bp & OHCI_PAGE_MASK) |\n                (end_offset & OHCI_OFFSET_MASK);\n        } else {\n            end_addr = (iso_td.be & OHCI_PAGE_MASK) |\n                (end_offset & OHCI_OFFSET_MASK);\n        }\n    } else {\n        /* Last packet in the ISO TD */\n        end_addr = iso_td.be;\n    }\n\n    if ((start_addr & OHCI_PAGE_MASK) != (end_addr & OHCI_PAGE_MASK)) {\n        len = (end_addr & OHCI_OFFSET_MASK) + 0x1001\n            - (start_addr & OHCI_OFFSET_MASK);\n    } else {\n        len = end_addr - start_addr + 1;\n    }\n\n    if (len && dir != OHCI_TD_DIR_IN) {\n        if (ohci_copy_iso_td(ohci, start_addr, end_addr, ohci->usb_buf, len,\n                             DMA_DIRECTION_TO_DEVICE)) {\n            ohci_die(ohci);\n            return 1;\n        }\n    }\n\n    if (!completion) {\n        bool int_req = relative_frame_number == frame_count &&\n                       OHCI_BM(iso_td.flags, TD_DI) == 0;\n        dev = ohci_find_device(ohci, OHCI_BM(ed->flags, ED_FA));\n        ep = usb_ep_get(dev, pid, OHCI_BM(ed->flags, ED_EN));\n        usb_packet_setup(&ohci->usb_packet, pid, ep, 0, addr, false, int_req);\n        usb_packet_addbuf(&ohci->usb_packet, ohci->usb_buf, len);\n        usb_handle_packet(dev, &ohci->usb_packet);\n        if (ohci->usb_packet.status == USB_RET_ASYNC) {\n            usb_device_flush_ep_queue(dev, ep);\n            return 1;\n        }\n    }\n    if (ohci->usb_packet.status == USB_RET_SUCCESS) {\n        ret = ohci->usb_packet.actual_length;\n    } else {\n        ret = ohci->usb_packet.status;\n    }\n\n    trace_usb_ohci_iso_td_so(start_offset, end_offset, start_addr, end_addr,\n                             str, len, ret);\n\n    /* Writeback */\n    if (dir == OHCI_TD_DIR_IN && ret >= 0 && ret <= len) {\n        /* IN transfer succeeded */\n        if (ohci_copy_iso_td(ohci, start_addr, end_addr, ohci->usb_buf, ret,\n                             DMA_DIRECTION_FROM_DEVICE)) {\n            ohci_die(ohci);\n            return 1;\n        }\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                    OHCI_CC_NOERROR);\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE, ret);\n    } else if (dir == OHCI_TD_DIR_OUT && ret == len) {\n        /* OUT transfer succeeded */\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                    OHCI_CC_NOERROR);\n        OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE, 0);\n    } else {\n        if (ret > (ssize_t) len) {\n            trace_usb_ohci_iso_td_data_overrun(ret, len);\n            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                        OHCI_CC_DATAOVERRUN);\n            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,\n                        len);\n        } else if (ret >= 0) {\n            trace_usb_ohci_iso_td_data_underrun(ret);\n            OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                        OHCI_CC_DATAUNDERRUN);\n        } else {\n            switch (ret) {\n            case USB_RET_IOERROR:\n            case USB_RET_NODEV:\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                            OHCI_CC_DEVICENOTRESPONDING);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,\n                            0);\n                break;\n            case USB_RET_NAK:\n            case USB_RET_STALL:\n                trace_usb_ohci_iso_td_nak(ret);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                            OHCI_CC_STALL);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_SIZE,\n                            0);\n                break;\n            default:\n                trace_usb_ohci_iso_td_bad_response(ret);\n                OHCI_SET_BM(iso_td.offset[relative_frame_number], TD_PSW_CC,\n                            OHCI_CC_UNDEXPETEDPID);\n                break;\n            }\n        }\n    }\n\n    if (relative_frame_number == frame_count) {\n        /* Last data packet of ISO TD - retire the TD to the Done Queue */\n        OHCI_SET_BM(iso_td.flags, TD_CC, OHCI_CC_NOERROR);\n        ed->head &= ~OHCI_DPTR_MASK;\n        ed->head |= (iso_td.next & OHCI_DPTR_MASK);\n        iso_td.next = ohci->done;\n        ohci->done = addr;\n        i = OHCI_BM(iso_td.flags, TD_DI);\n        if (i < ohci->done_count)\n            ohci->done_count = i;\n    }\n    if (ohci_put_iso_td(ohci, addr, &iso_td)) {\n        ohci_die(ohci);\n    }\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,7 +22,7 @@\n     if (ohci_read_iso_td(ohci, addr, &iso_td)) {\n         trace_usb_ohci_iso_td_read_failed(addr);\n         ohci_die(ohci);\n-        return 0;\n+        return 1;\n     }\n \n     starting_frame = OHCI_BM(iso_td.flags, TD_SF);",
        "diff_line_info": {
            "deleted_lines": [
                "        return 0;"
            ],
            "added_lines": [
                "        return 1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9375",
        "func_name": "qemu/xhci_kick_ep",
        "description": "QEMU (aka Quick Emulator), when built with USB xHCI controller emulator support, allows local guest OS privileged users to cause a denial of service (infinite recursive call) via vectors involving control transfer descriptors sequencing.",
        "git_url": "https://github.com/qemu/qemu/commit/96d87bdda3919bb16f754b3d3fd1227e1f38f13c",
        "commit_title": "xhci: guard xhci_kick_epctx against recursive calls",
        "commit_text": " Track xhci_kick_epctx processing being active in a variable.  Check the variable before calling xhci_kick_epctx from xhci_kick_ep.  Add an assert to make sure we don't call recursively into xhci_kick_epctx.  Cc: 1653384@bugs.launchpad.net",
        "func_before": "static void xhci_kick_ep(XHCIState *xhci, unsigned int slotid,\n                         unsigned int epid, unsigned int streamid)\n{\n    XHCIEPContext *epctx;\n\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n    assert(epid >= 1 && epid <= 31);\n\n    if (!xhci->slots[slotid-1].enabled) {\n        DPRINTF(\"xhci: xhci_kick_ep for disabled slot %d\\n\", slotid);\n        return;\n    }\n    epctx = xhci->slots[slotid-1].eps[epid-1];\n    if (!epctx) {\n        DPRINTF(\"xhci: xhci_kick_ep for disabled endpoint %d,%d\\n\",\n                epid, slotid);\n        return;\n    }\n\n    xhci_kick_epctx(epctx, streamid);\n}",
        "func": "static void xhci_kick_ep(XHCIState *xhci, unsigned int slotid,\n                         unsigned int epid, unsigned int streamid)\n{\n    XHCIEPContext *epctx;\n\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n    assert(epid >= 1 && epid <= 31);\n\n    if (!xhci->slots[slotid-1].enabled) {\n        DPRINTF(\"xhci: xhci_kick_ep for disabled slot %d\\n\", slotid);\n        return;\n    }\n    epctx = xhci->slots[slotid-1].eps[epid-1];\n    if (!epctx) {\n        DPRINTF(\"xhci: xhci_kick_ep for disabled endpoint %d,%d\\n\",\n                epid, slotid);\n        return;\n    }\n\n    if (epctx->kick_active) {\n        return;\n    }\n    xhci_kick_epctx(epctx, streamid);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,5 +17,8 @@\n         return;\n     }\n \n+    if (epctx->kick_active) {\n+        return;\n+    }\n     xhci_kick_epctx(epctx, streamid);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (epctx->kick_active) {",
                "        return;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9375",
        "func_name": "qemu/xhci_kick_epctx",
        "description": "QEMU (aka Quick Emulator), when built with USB xHCI controller emulator support, allows local guest OS privileged users to cause a denial of service (infinite recursive call) via vectors involving control transfer descriptors sequencing.",
        "git_url": "https://github.com/qemu/qemu/commit/96d87bdda3919bb16f754b3d3fd1227e1f38f13c",
        "commit_title": "xhci: guard xhci_kick_epctx against recursive calls",
        "commit_text": " Track xhci_kick_epctx processing being active in a variable.  Check the variable before calling xhci_kick_epctx from xhci_kick_ep.  Add an assert to make sure we don't call recursively into xhci_kick_epctx.  Cc: 1653384@bugs.launchpad.net",
        "func_before": "static void xhci_kick_epctx(XHCIEPContext *epctx, unsigned int streamid)\n{\n    XHCIState *xhci = epctx->xhci;\n    XHCIStreamContext *stctx;\n    XHCITransfer *xfer;\n    XHCIRing *ring;\n    USBEndpoint *ep = NULL;\n    uint64_t mfindex;\n    int length;\n    int i;\n\n    trace_usb_xhci_ep_kick(epctx->slotid, epctx->epid, streamid);\n\n    /* If the device has been detached, but the guest has not noticed this\n       yet the 2 above checks will succeed, but we must NOT continue */\n    if (!xhci->slots[epctx->slotid - 1].uport ||\n        !xhci->slots[epctx->slotid - 1].uport->dev ||\n        !xhci->slots[epctx->slotid - 1].uport->dev->attached) {\n        return;\n    }\n\n    if (epctx->retry) {\n        XHCITransfer *xfer = epctx->retry;\n\n        trace_usb_xhci_xfer_retry(xfer);\n        assert(xfer->running_retry);\n        if (xfer->timed_xfer) {\n            /* time to kick the transfer? */\n            mfindex = xhci_mfindex_get(xhci);\n            xhci_check_intr_iso_kick(xhci, xfer, epctx, mfindex);\n            if (xfer->running_retry) {\n                return;\n            }\n            xfer->timed_xfer = 0;\n            xfer->running_retry = 1;\n        }\n        if (xfer->iso_xfer) {\n            /* retry iso transfer */\n            if (xhci_setup_packet(xfer) < 0) {\n                return;\n            }\n            usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n            assert(xfer->packet.status != USB_RET_NAK);\n            xhci_try_complete_packet(xfer);\n        } else {\n            /* retry nak'ed transfer */\n            if (xhci_setup_packet(xfer) < 0) {\n                return;\n            }\n            usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n            if (xfer->packet.status == USB_RET_NAK) {\n                return;\n            }\n            xhci_try_complete_packet(xfer);\n        }\n        assert(!xfer->running_retry);\n        if (xfer->complete) {\n            xhci_ep_free_xfer(epctx->retry);\n        }\n        epctx->retry = NULL;\n    }\n\n    if (epctx->state == EP_HALTED) {\n        DPRINTF(\"xhci: ep halted, not running schedule\\n\");\n        return;\n    }\n\n\n    if (epctx->nr_pstreams) {\n        uint32_t err;\n        stctx = xhci_find_stream(epctx, streamid, &err);\n        if (stctx == NULL) {\n            return;\n        }\n        ring = &stctx->ring;\n        xhci_set_ep_state(xhci, epctx, stctx, EP_RUNNING);\n    } else {\n        ring = &epctx->ring;\n        streamid = 0;\n        xhci_set_ep_state(xhci, epctx, NULL, EP_RUNNING);\n    }\n    assert(ring->dequeue != 0);\n\n    while (1) {\n        length = xhci_ring_chain_length(xhci, ring);\n        if (length <= 0) {\n            break;\n        }\n        xfer = xhci_ep_alloc_xfer(epctx, length);\n        if (xfer == NULL) {\n            break;\n        }\n\n        for (i = 0; i < length; i++) {\n            TRBType type;\n            type = xhci_ring_fetch(xhci, ring, &xfer->trbs[i], NULL);\n            assert(type);\n        }\n        xfer->streamid = streamid;\n\n        if (epctx->epid == 1) {\n            xhci_fire_ctl_transfer(xhci, xfer);\n        } else {\n            xhci_fire_transfer(xhci, xfer, epctx);\n        }\n        if (xfer->complete) {\n            xhci_ep_free_xfer(xfer);\n            xfer = NULL;\n        }\n\n        if (epctx->state == EP_HALTED) {\n            break;\n        }\n        if (xfer != NULL && xfer->running_retry) {\n            DPRINTF(\"xhci: xfer nacked, stopping schedule\\n\");\n            epctx->retry = xfer;\n            break;\n        }\n    }\n\n    ep = xhci_epid_to_usbep(epctx);\n    if (ep) {\n        usb_device_flush_ep_queue(ep->dev, ep);\n    }\n}",
        "func": "static void xhci_kick_epctx(XHCIEPContext *epctx, unsigned int streamid)\n{\n    XHCIState *xhci = epctx->xhci;\n    XHCIStreamContext *stctx;\n    XHCITransfer *xfer;\n    XHCIRing *ring;\n    USBEndpoint *ep = NULL;\n    uint64_t mfindex;\n    int length;\n    int i;\n\n    trace_usb_xhci_ep_kick(epctx->slotid, epctx->epid, streamid);\n    assert(!epctx->kick_active);\n\n    /* If the device has been detached, but the guest has not noticed this\n       yet the 2 above checks will succeed, but we must NOT continue */\n    if (!xhci->slots[epctx->slotid - 1].uport ||\n        !xhci->slots[epctx->slotid - 1].uport->dev ||\n        !xhci->slots[epctx->slotid - 1].uport->dev->attached) {\n        return;\n    }\n\n    if (epctx->retry) {\n        XHCITransfer *xfer = epctx->retry;\n\n        trace_usb_xhci_xfer_retry(xfer);\n        assert(xfer->running_retry);\n        if (xfer->timed_xfer) {\n            /* time to kick the transfer? */\n            mfindex = xhci_mfindex_get(xhci);\n            xhci_check_intr_iso_kick(xhci, xfer, epctx, mfindex);\n            if (xfer->running_retry) {\n                return;\n            }\n            xfer->timed_xfer = 0;\n            xfer->running_retry = 1;\n        }\n        if (xfer->iso_xfer) {\n            /* retry iso transfer */\n            if (xhci_setup_packet(xfer) < 0) {\n                return;\n            }\n            usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n            assert(xfer->packet.status != USB_RET_NAK);\n            xhci_try_complete_packet(xfer);\n        } else {\n            /* retry nak'ed transfer */\n            if (xhci_setup_packet(xfer) < 0) {\n                return;\n            }\n            usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n            if (xfer->packet.status == USB_RET_NAK) {\n                return;\n            }\n            xhci_try_complete_packet(xfer);\n        }\n        assert(!xfer->running_retry);\n        if (xfer->complete) {\n            xhci_ep_free_xfer(epctx->retry);\n        }\n        epctx->retry = NULL;\n    }\n\n    if (epctx->state == EP_HALTED) {\n        DPRINTF(\"xhci: ep halted, not running schedule\\n\");\n        return;\n    }\n\n\n    if (epctx->nr_pstreams) {\n        uint32_t err;\n        stctx = xhci_find_stream(epctx, streamid, &err);\n        if (stctx == NULL) {\n            return;\n        }\n        ring = &stctx->ring;\n        xhci_set_ep_state(xhci, epctx, stctx, EP_RUNNING);\n    } else {\n        ring = &epctx->ring;\n        streamid = 0;\n        xhci_set_ep_state(xhci, epctx, NULL, EP_RUNNING);\n    }\n    assert(ring->dequeue != 0);\n\n    epctx->kick_active++;\n    while (1) {\n        length = xhci_ring_chain_length(xhci, ring);\n        if (length <= 0) {\n            break;\n        }\n        xfer = xhci_ep_alloc_xfer(epctx, length);\n        if (xfer == NULL) {\n            break;\n        }\n\n        for (i = 0; i < length; i++) {\n            TRBType type;\n            type = xhci_ring_fetch(xhci, ring, &xfer->trbs[i], NULL);\n            assert(type);\n        }\n        xfer->streamid = streamid;\n\n        if (epctx->epid == 1) {\n            xhci_fire_ctl_transfer(xhci, xfer);\n        } else {\n            xhci_fire_transfer(xhci, xfer, epctx);\n        }\n        if (xfer->complete) {\n            xhci_ep_free_xfer(xfer);\n            xfer = NULL;\n        }\n\n        if (epctx->state == EP_HALTED) {\n            break;\n        }\n        if (xfer != NULL && xfer->running_retry) {\n            DPRINTF(\"xhci: xfer nacked, stopping schedule\\n\");\n            epctx->retry = xfer;\n            break;\n        }\n    }\n    epctx->kick_active--;\n\n    ep = xhci_epid_to_usbep(epctx);\n    if (ep) {\n        usb_device_flush_ep_queue(ep->dev, ep);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,7 @@\n     int i;\n \n     trace_usb_xhci_ep_kick(epctx->slotid, epctx->epid, streamid);\n+    assert(!epctx->kick_active);\n \n     /* If the device has been detached, but the guest has not noticed this\n        yet the 2 above checks will succeed, but we must NOT continue */\n@@ -81,6 +82,7 @@\n     }\n     assert(ring->dequeue != 0);\n \n+    epctx->kick_active++;\n     while (1) {\n         length = xhci_ring_chain_length(xhci, ring);\n         if (length <= 0) {\n@@ -117,6 +119,7 @@\n             break;\n         }\n     }\n+    epctx->kick_active--;\n \n     ep = xhci_epid_to_usbep(epctx);\n     if (ep) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    assert(!epctx->kick_active);",
                "    epctx->kick_active++;",
                "    epctx->kick_active--;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11171",
        "func_name": "GNOME/gnome-session/accept_ice_connection",
        "description": "Bad reference counting in the context of accept_ice_connection() in gsm-xsmp-server.c in old versions of gnome-session up until version 2.29.92 allows a local attacker to establish ICE connections to gnome-session with invalid authentication data (an invalid magic cookie). Each failed authentication attempt will leak a file descriptor in gnome-session. When the maximum number of file descriptors is exhausted in the gnome-session process, it will enter an infinite loop trying to communicate without success, consuming 100% of the CPU. The graphical session associated with the gnome-session process will stop working correctly, because communication with gnome-session is no longer possible.",
        "git_url": "https://github.com/GNOME/gnome-session/commit/b0dc999e0b45355314616321dbb6cb71e729fc9d",
        "commit_title": "[gsm] Delay the creation of the GsmXSMPClient until it really exists",
        "commit_text": " We used to create the GsmXSMPClient before the XSMP connection is really accepted. This can lead to some issues, though. An example is: https://bugzilla.gnome.org/show_bug.cgi?id=598211#c19. Quoting:   \"What is happening is that a new client (probably metacity in your  case) is opening an ICE connection in the GSM_MANAGER_PHASE_END_SESSION  phase, which causes a new GsmXSMPClient to be added to the client  store. The GSM_MANAGER_PHASE_EXIT phase then begins before the client  has had a chance to establish a xsmp connection, which means that  client->priv->conn will not be initialized at the point that xsmp_stop  is called on the new unregistered client.\"  The fix is to create the GsmXSMPClient object when there's a real XSMP connection. This implies moving the timeout that makes sure we don't have an empty client to the XSMP server.  https://bugzilla.gnome.org/show_bug.cgi?id=598211",
        "func_before": "static gboolean\naccept_ice_connection (GIOChannel           *source,\n                       GIOCondition          condition,\n                       GsmIceConnectionData *data)\n{\n        IceListenObj    listener;\n        IceConn         ice_conn;\n        IceAcceptStatus status;\n        GsmClient      *client;\n        GsmXsmpServer  *server;\n\n        listener = data->listener;\n        server = data->server;\n\n        g_debug (\"GsmXsmpServer: accept_ice_connection()\");\n\n        ice_conn = IceAcceptConnection (listener, &status);\n        if (status != IceAcceptSuccess) {\n                g_debug (\"GsmXsmpServer: IceAcceptConnection returned %d\", status);\n                return TRUE;\n        }\n\n        client = gsm_xsmp_client_new (ice_conn);\n        ice_conn->context = client;\n\n        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n        /* the store will own the ref */\n        g_object_unref (client);\n\n        return TRUE;\n}",
        "func": "static gboolean\naccept_ice_connection (GIOChannel           *source,\n                       GIOCondition          condition,\n                       GsmIceConnectionData *data)\n{\n        IceConn         ice_conn;\n        IceAcceptStatus status;\n\n        g_debug (\"GsmXsmpServer: accept_ice_connection()\");\n\n        ice_conn = IceAcceptConnection (data->listener, &status);\n        if (status != IceAcceptSuccess) {\n                g_debug (\"GsmXsmpServer: IceAcceptConnection returned %d\", status);\n                return TRUE;\n        }\n\n        auth_ice_connection (ice_conn);\n\n        return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,29 +3,18 @@\n                        GIOCondition          condition,\n                        GsmIceConnectionData *data)\n {\n-        IceListenObj    listener;\n         IceConn         ice_conn;\n         IceAcceptStatus status;\n-        GsmClient      *client;\n-        GsmXsmpServer  *server;\n-\n-        listener = data->listener;\n-        server = data->server;\n \n         g_debug (\"GsmXsmpServer: accept_ice_connection()\");\n \n-        ice_conn = IceAcceptConnection (listener, &status);\n+        ice_conn = IceAcceptConnection (data->listener, &status);\n         if (status != IceAcceptSuccess) {\n                 g_debug (\"GsmXsmpServer: IceAcceptConnection returned %d\", status);\n                 return TRUE;\n         }\n \n-        client = gsm_xsmp_client_new (ice_conn);\n-        ice_conn->context = client;\n-\n-        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n-        /* the store will own the ref */\n-        g_object_unref (client);\n+        auth_ice_connection (ice_conn);\n \n         return TRUE;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "        IceListenObj    listener;",
                "        GsmClient      *client;",
                "        GsmXsmpServer  *server;",
                "",
                "        listener = data->listener;",
                "        server = data->server;",
                "        ice_conn = IceAcceptConnection (listener, &status);",
                "        client = gsm_xsmp_client_new (ice_conn);",
                "        ice_conn->context = client;",
                "",
                "        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));",
                "        /* the store will own the ref */",
                "        g_object_unref (client);"
            ],
            "added_lines": [
                "        ice_conn = IceAcceptConnection (data->listener, &status);",
                "        auth_ice_connection (ice_conn);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11171",
        "func_name": "GNOME/gnome-session/accept_xsmp_connection",
        "description": "Bad reference counting in the context of accept_ice_connection() in gsm-xsmp-server.c in old versions of gnome-session up until version 2.29.92 allows a local attacker to establish ICE connections to gnome-session with invalid authentication data (an invalid magic cookie). Each failed authentication attempt will leak a file descriptor in gnome-session. When the maximum number of file descriptors is exhausted in the gnome-session process, it will enter an infinite loop trying to communicate without success, consuming 100% of the CPU. The graphical session associated with the gnome-session process will stop working correctly, because communication with gnome-session is no longer possible.",
        "git_url": "https://github.com/GNOME/gnome-session/commit/b0dc999e0b45355314616321dbb6cb71e729fc9d",
        "commit_title": "[gsm] Delay the creation of the GsmXSMPClient until it really exists",
        "commit_text": " We used to create the GsmXSMPClient before the XSMP connection is really accepted. This can lead to some issues, though. An example is: https://bugzilla.gnome.org/show_bug.cgi?id=598211#c19. Quoting:   \"What is happening is that a new client (probably metacity in your  case) is opening an ICE connection in the GSM_MANAGER_PHASE_END_SESSION  phase, which causes a new GsmXSMPClient to be added to the client  store. The GSM_MANAGER_PHASE_EXIT phase then begins before the client  has had a chance to establish a xsmp connection, which means that  client->priv->conn will not be initialized at the point that xsmp_stop  is called on the new unregistered client.\"  The fix is to create the GsmXSMPClient object when there's a real XSMP connection. This implies moving the timeout that makes sure we don't have an empty client to the XSMP server.  https://bugzilla.gnome.org/show_bug.cgi?id=598211",
        "func_before": "static Status\naccept_xsmp_connection (SmsConn        sms_conn,\n                        GsmXsmpServer *server,\n                        unsigned long *mask_ret,\n                        SmsCallbacks  *callbacks_ret,\n                        char         **failure_reason_ret)\n{\n        IceConn        ice_conn;\n        GsmXSMPClient *client;\n\n        /* FIXME: what about during shutdown but before gsm_xsmp_shutdown? */\n        if (server->priv->xsmp_sockets == NULL) {\n                g_debug (\"GsmXsmpServer: In shutdown, rejecting new client\");\n\n                *failure_reason_ret = strdup (_(\"Refusing new client connection because the session is currently being shut down\\n\"));\n                return FALSE;\n        }\n\n        ice_conn = SmsGetIceConnection (sms_conn);\n        client = ice_conn->context;\n\n        g_return_val_if_fail (client != NULL, TRUE);\n\n        gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret);\n\n        return TRUE;\n}",
        "func": "static Status\naccept_xsmp_connection (SmsConn        sms_conn,\n                        GsmXsmpServer *server,\n                        unsigned long *mask_ret,\n                        SmsCallbacks  *callbacks_ret,\n                        char         **failure_reason_ret)\n{\n        IceConn                ice_conn;\n        GsmClient             *client;\n        GsmIceConnectionWatch *data;\n\n        /* FIXME: what about during shutdown but before gsm_xsmp_shutdown? */\n        if (server->priv->xsmp_sockets == NULL) {\n                g_debug (\"GsmXsmpServer: In shutdown, rejecting new client\");\n\n                *failure_reason_ret = strdup (_(\"Refusing new client connection because the session is currently being shut down\\n\"));\n                return FALSE;\n        }\n\n        ice_conn = SmsGetIceConnection (sms_conn);\n        data = ice_conn->context;\n\n        /* Each GsmXSMPClient has its own IceConn watcher */\n        free_ice_connection_watch (data);\n\n        client = gsm_xsmp_client_new (ice_conn);\n\n        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n        /* the store will own the ref */\n        g_object_unref (client);\n\n        gsm_xsmp_client_connect (GSM_XSMP_CLIENT (client), sms_conn, mask_ret, callbacks_ret);\n\n        return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,8 +5,9 @@\n                         SmsCallbacks  *callbacks_ret,\n                         char         **failure_reason_ret)\n {\n-        IceConn        ice_conn;\n-        GsmXSMPClient *client;\n+        IceConn                ice_conn;\n+        GsmClient             *client;\n+        GsmIceConnectionWatch *data;\n \n         /* FIXME: what about during shutdown but before gsm_xsmp_shutdown? */\n         if (server->priv->xsmp_sockets == NULL) {\n@@ -17,11 +18,18 @@\n         }\n \n         ice_conn = SmsGetIceConnection (sms_conn);\n-        client = ice_conn->context;\n+        data = ice_conn->context;\n \n-        g_return_val_if_fail (client != NULL, TRUE);\n+        /* Each GsmXSMPClient has its own IceConn watcher */\n+        free_ice_connection_watch (data);\n \n-        gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret);\n+        client = gsm_xsmp_client_new (ice_conn);\n+\n+        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n+        /* the store will own the ref */\n+        g_object_unref (client);\n+\n+        gsm_xsmp_client_connect (GSM_XSMP_CLIENT (client), sms_conn, mask_ret, callbacks_ret);\n \n         return TRUE;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "        IceConn        ice_conn;",
                "        GsmXSMPClient *client;",
                "        client = ice_conn->context;",
                "        g_return_val_if_fail (client != NULL, TRUE);",
                "        gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret);"
            ],
            "added_lines": [
                "        IceConn                ice_conn;",
                "        GsmClient             *client;",
                "        GsmIceConnectionWatch *data;",
                "        data = ice_conn->context;",
                "        /* Each GsmXSMPClient has its own IceConn watcher */",
                "        free_ice_connection_watch (data);",
                "        client = gsm_xsmp_client_new (ice_conn);",
                "",
                "        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));",
                "        /* the store will own the ref */",
                "        g_object_unref (client);",
                "",
                "        gsm_xsmp_client_connect (GSM_XSMP_CLIENT (client), sms_conn, mask_ret, callbacks_ret);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11171",
        "func_name": "GNOME/gnome-session/gsm_xsmp_client_disconnect",
        "description": "Bad reference counting in the context of accept_ice_connection() in gsm-xsmp-server.c in old versions of gnome-session up until version 2.29.92 allows a local attacker to establish ICE connections to gnome-session with invalid authentication data (an invalid magic cookie). Each failed authentication attempt will leak a file descriptor in gnome-session. When the maximum number of file descriptors is exhausted in the gnome-session process, it will enter an infinite loop trying to communicate without success, consuming 100% of the CPU. The graphical session associated with the gnome-session process will stop working correctly, because communication with gnome-session is no longer possible.",
        "git_url": "https://github.com/GNOME/gnome-session/commit/b0dc999e0b45355314616321dbb6cb71e729fc9d",
        "commit_title": "[gsm] Delay the creation of the GsmXSMPClient until it really exists",
        "commit_text": " We used to create the GsmXSMPClient before the XSMP connection is really accepted. This can lead to some issues, though. An example is: https://bugzilla.gnome.org/show_bug.cgi?id=598211#c19. Quoting:   \"What is happening is that a new client (probably metacity in your  case) is opening an ICE connection in the GSM_MANAGER_PHASE_END_SESSION  phase, which causes a new GsmXSMPClient to be added to the client  store. The GSM_MANAGER_PHASE_EXIT phase then begins before the client  has had a chance to establish a xsmp connection, which means that  client->priv->conn will not be initialized at the point that xsmp_stop  is called on the new unregistered client.\"  The fix is to create the GsmXSMPClient object when there's a real XSMP connection. This implies moving the timeout that makes sure we don't have an empty client to the XSMP server.  https://bugzilla.gnome.org/show_bug.cgi?id=598211",
        "func_before": "static void\ngsm_xsmp_client_disconnect (GsmXSMPClient *client)\n{\n        if (client->priv->watch_id > 0) {\n                g_source_remove (client->priv->watch_id);\n        }\n\n        if (client->priv->conn != NULL) {\n                SmsCleanUp (client->priv->conn);\n        }\n\n        if (client->priv->ice_connection != NULL) {\n                IceSetShutdownNegotiation (client->priv->ice_connection, FALSE);\n                IceCloseConnection (client->priv->ice_connection);\n        }\n\n        if (client->priv->protocol_timeout > 0) {\n                g_source_remove (client->priv->protocol_timeout);\n        }\n}",
        "func": "static void\ngsm_xsmp_client_disconnect (GsmXSMPClient *client)\n{\n        if (client->priv->watch_id > 0) {\n                g_source_remove (client->priv->watch_id);\n        }\n\n        if (client->priv->conn != NULL) {\n                SmsCleanUp (client->priv->conn);\n        }\n\n        if (client->priv->ice_connection != NULL) {\n                IceSetShutdownNegotiation (client->priv->ice_connection, FALSE);\n                IceCloseConnection (client->priv->ice_connection);\n        }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,8 +13,4 @@\n                 IceSetShutdownNegotiation (client->priv->ice_connection, FALSE);\n                 IceCloseConnection (client->priv->ice_connection);\n         }\n-\n-        if (client->priv->protocol_timeout > 0) {\n-                g_source_remove (client->priv->protocol_timeout);\n-        }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "        if (client->priv->protocol_timeout > 0) {",
                "                g_source_remove (client->priv->protocol_timeout);",
                "        }"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2017-11171",
        "func_name": "GNOME/gnome-session/gsm_xsmp_client_connect",
        "description": "Bad reference counting in the context of accept_ice_connection() in gsm-xsmp-server.c in old versions of gnome-session up until version 2.29.92 allows a local attacker to establish ICE connections to gnome-session with invalid authentication data (an invalid magic cookie). Each failed authentication attempt will leak a file descriptor in gnome-session. When the maximum number of file descriptors is exhausted in the gnome-session process, it will enter an infinite loop trying to communicate without success, consuming 100% of the CPU. The graphical session associated with the gnome-session process will stop working correctly, because communication with gnome-session is no longer possible.",
        "git_url": "https://github.com/GNOME/gnome-session/commit/b0dc999e0b45355314616321dbb6cb71e729fc9d",
        "commit_title": "[gsm] Delay the creation of the GsmXSMPClient until it really exists",
        "commit_text": " We used to create the GsmXSMPClient before the XSMP connection is really accepted. This can lead to some issues, though. An example is: https://bugzilla.gnome.org/show_bug.cgi?id=598211#c19. Quoting:   \"What is happening is that a new client (probably metacity in your  case) is opening an ICE connection in the GSM_MANAGER_PHASE_END_SESSION  phase, which causes a new GsmXSMPClient to be added to the client  store. The GSM_MANAGER_PHASE_EXIT phase then begins before the client  has had a chance to establish a xsmp connection, which means that  client->priv->conn will not be initialized at the point that xsmp_stop  is called on the new unregistered client.\"  The fix is to create the GsmXSMPClient object when there's a real XSMP connection. This implies moving the timeout that makes sure we don't have an empty client to the XSMP server.  https://bugzilla.gnome.org/show_bug.cgi?id=598211",
        "func_before": "void\ngsm_xsmp_client_connect (GsmXSMPClient *client,\n                         SmsConn        conn,\n                         unsigned long *mask_ret,\n                         SmsCallbacks  *callbacks_ret)\n{\n        client->priv->conn = conn;\n\n        if (client->priv->protocol_timeout) {\n                g_source_remove (client->priv->protocol_timeout);\n                client->priv->protocol_timeout = 0;\n        }\n\n        g_debug (\"GsmXSMPClient: Initializing client %s\", client->priv->description);\n\n        *mask_ret = 0;\n\n        *mask_ret |= SmsRegisterClientProcMask;\n        callbacks_ret->register_client.callback = register_client_callback;\n        callbacks_ret->register_client.manager_data  = client;\n\n        *mask_ret |= SmsInteractRequestProcMask;\n        callbacks_ret->interact_request.callback = interact_request_callback;\n        callbacks_ret->interact_request.manager_data = client;\n\n        *mask_ret |= SmsInteractDoneProcMask;\n        callbacks_ret->interact_done.callback = interact_done_callback;\n        callbacks_ret->interact_done.manager_data = client;\n\n        *mask_ret |= SmsSaveYourselfRequestProcMask;\n        callbacks_ret->save_yourself_request.callback = save_yourself_request_callback;\n        callbacks_ret->save_yourself_request.manager_data = client;\n\n        *mask_ret |= SmsSaveYourselfP2RequestProcMask;\n        callbacks_ret->save_yourself_phase2_request.callback = save_yourself_phase2_request_callback;\n        callbacks_ret->save_yourself_phase2_request.manager_data = client;\n\n        *mask_ret |= SmsSaveYourselfDoneProcMask;\n        callbacks_ret->save_yourself_done.callback = save_yourself_done_callback;\n        callbacks_ret->save_yourself_done.manager_data = client;\n\n        *mask_ret |= SmsCloseConnectionProcMask;\n        callbacks_ret->close_connection.callback = close_connection_callback;\n        callbacks_ret->close_connection.manager_data  = client;\n\n        *mask_ret |= SmsSetPropertiesProcMask;\n        callbacks_ret->set_properties.callback = set_properties_callback;\n        callbacks_ret->set_properties.manager_data = client;\n\n        *mask_ret |= SmsDeletePropertiesProcMask;\n        callbacks_ret->delete_properties.callback = delete_properties_callback;\n        callbacks_ret->delete_properties.manager_data = client;\n\n        *mask_ret |= SmsGetPropertiesProcMask;\n        callbacks_ret->get_properties.callback = get_properties_callback;\n        callbacks_ret->get_properties.manager_data = client;\n}",
        "func": "void\ngsm_xsmp_client_connect (GsmXSMPClient *client,\n                         SmsConn        conn,\n                         unsigned long *mask_ret,\n                         SmsCallbacks  *callbacks_ret)\n{\n        client->priv->conn = conn;\n\n        g_debug (\"GsmXSMPClient: Initializing client %s\", client->priv->description);\n\n        *mask_ret = 0;\n\n        *mask_ret |= SmsRegisterClientProcMask;\n        callbacks_ret->register_client.callback = register_client_callback;\n        callbacks_ret->register_client.manager_data  = client;\n\n        *mask_ret |= SmsInteractRequestProcMask;\n        callbacks_ret->interact_request.callback = interact_request_callback;\n        callbacks_ret->interact_request.manager_data = client;\n\n        *mask_ret |= SmsInteractDoneProcMask;\n        callbacks_ret->interact_done.callback = interact_done_callback;\n        callbacks_ret->interact_done.manager_data = client;\n\n        *mask_ret |= SmsSaveYourselfRequestProcMask;\n        callbacks_ret->save_yourself_request.callback = save_yourself_request_callback;\n        callbacks_ret->save_yourself_request.manager_data = client;\n\n        *mask_ret |= SmsSaveYourselfP2RequestProcMask;\n        callbacks_ret->save_yourself_phase2_request.callback = save_yourself_phase2_request_callback;\n        callbacks_ret->save_yourself_phase2_request.manager_data = client;\n\n        *mask_ret |= SmsSaveYourselfDoneProcMask;\n        callbacks_ret->save_yourself_done.callback = save_yourself_done_callback;\n        callbacks_ret->save_yourself_done.manager_data = client;\n\n        *mask_ret |= SmsCloseConnectionProcMask;\n        callbacks_ret->close_connection.callback = close_connection_callback;\n        callbacks_ret->close_connection.manager_data  = client;\n\n        *mask_ret |= SmsSetPropertiesProcMask;\n        callbacks_ret->set_properties.callback = set_properties_callback;\n        callbacks_ret->set_properties.manager_data = client;\n\n        *mask_ret |= SmsDeletePropertiesProcMask;\n        callbacks_ret->delete_properties.callback = delete_properties_callback;\n        callbacks_ret->delete_properties.manager_data = client;\n\n        *mask_ret |= SmsGetPropertiesProcMask;\n        callbacks_ret->get_properties.callback = get_properties_callback;\n        callbacks_ret->get_properties.manager_data = client;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,11 +5,6 @@\n                          SmsCallbacks  *callbacks_ret)\n {\n         client->priv->conn = conn;\n-\n-        if (client->priv->protocol_timeout) {\n-                g_source_remove (client->priv->protocol_timeout);\n-                client->priv->protocol_timeout = 0;\n-        }\n \n         g_debug (\"GsmXSMPClient: Initializing client %s\", client->priv->description);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "        if (client->priv->protocol_timeout) {",
                "                g_source_remove (client->priv->protocol_timeout);",
                "                client->priv->protocol_timeout = 0;",
                "        }"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2017-11171",
        "func_name": "GNOME/gnome-session/setup_connection",
        "description": "Bad reference counting in the context of accept_ice_connection() in gsm-xsmp-server.c in old versions of gnome-session up until version 2.29.92 allows a local attacker to establish ICE connections to gnome-session with invalid authentication data (an invalid magic cookie). Each failed authentication attempt will leak a file descriptor in gnome-session. When the maximum number of file descriptors is exhausted in the gnome-session process, it will enter an infinite loop trying to communicate without success, consuming 100% of the CPU. The graphical session associated with the gnome-session process will stop working correctly, because communication with gnome-session is no longer possible.",
        "git_url": "https://github.com/GNOME/gnome-session/commit/b0dc999e0b45355314616321dbb6cb71e729fc9d",
        "commit_title": "[gsm] Delay the creation of the GsmXSMPClient until it really exists",
        "commit_text": " We used to create the GsmXSMPClient before the XSMP connection is really accepted. This can lead to some issues, though. An example is: https://bugzilla.gnome.org/show_bug.cgi?id=598211#c19. Quoting:   \"What is happening is that a new client (probably metacity in your  case) is opening an ICE connection in the GSM_MANAGER_PHASE_END_SESSION  phase, which causes a new GsmXSMPClient to be added to the client  store. The GSM_MANAGER_PHASE_EXIT phase then begins before the client  has had a chance to establish a xsmp connection, which means that  client->priv->conn will not be initialized at the point that xsmp_stop  is called on the new unregistered client.\"  The fix is to create the GsmXSMPClient object when there's a real XSMP connection. This implies moving the timeout that makes sure we don't have an empty client to the XSMP server.  https://bugzilla.gnome.org/show_bug.cgi?id=598211",
        "func_before": "static void\nsetup_connection (GsmXSMPClient *client)\n{\n        GIOChannel    *channel;\n        int            fd;\n\n        g_debug (\"GsmXSMPClient: Setting up new connection\");\n\n        fd = IceConnectionNumber (client->priv->ice_connection);\n        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);\n        channel = g_io_channel_unix_new (fd);\n        client->priv->watch_id = g_io_add_watch (channel,\n                                                 G_IO_IN | G_IO_ERR,\n                                                 (GIOFunc)client_iochannel_watch,\n                                                 client);\n        g_io_channel_unref (channel);\n\n        client->priv->protocol_timeout = g_timeout_add_seconds (5,\n                                                                (GSourceFunc)_client_protocol_timeout,\n                                                                client);\n\n        set_description (client);\n\n        g_debug (\"GsmXSMPClient: New client '%s'\", client->priv->description);\n}",
        "func": "static void\nsetup_connection (GsmXSMPClient *client)\n{\n        GIOChannel    *channel;\n        int            fd;\n\n        g_debug (\"GsmXSMPClient: Setting up new connection\");\n\n        fd = IceConnectionNumber (client->priv->ice_connection);\n        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);\n        channel = g_io_channel_unix_new (fd);\n        client->priv->watch_id = g_io_add_watch (channel,\n                                                 G_IO_IN | G_IO_ERR,\n                                                 (GIOFunc)client_iochannel_watch,\n                                                 client);\n        g_io_channel_unref (channel);\n\n        set_description (client);\n\n        g_debug (\"GsmXSMPClient: New client '%s'\", client->priv->description);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,10 +15,6 @@\n                                                  client);\n         g_io_channel_unref (channel);\n \n-        client->priv->protocol_timeout = g_timeout_add_seconds (5,\n-                                                                (GSourceFunc)_client_protocol_timeout,\n-                                                                client);\n-\n         set_description (client);\n \n         g_debug (\"GsmXSMPClient: New client '%s'\", client->priv->description);",
        "diff_line_info": {
            "deleted_lines": [
                "        client->priv->protocol_timeout = g_timeout_add_seconds (5,",
                "                                                                (GSourceFunc)_client_protocol_timeout,",
                "                                                                client);",
                ""
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2017-18208",
        "func_name": "torvalds/linux/madvise_willneed",
        "description": "The madvise_willneed function in mm/madvise.c in the Linux kernel before 4.14.4 allows local users to cause a denial of service (infinite loop) by triggering use of MADVISE_WILLNEED for a DAX mapping.",
        "git_url": "https://github.com/torvalds/linux/commit/6ea8d958a2c95a1d514015d4e29ba21a8c0a1a91",
        "commit_title": "mm/madvise.c: fix madvise() infinite loop under special circumstances",
        "commit_text": " MADVISE_WILLNEED has always been a noop for DAX (formerly XIP) mappings. Unfortunately madvise_willneed() doesn't communicate this information properly to the generic madvise syscall implementation.  The calling convention is quite subtle there.  madvise_vma() is supposed to either return an error or update &prev otherwise the main loop will never advance to the next vma and it will keep looping for ever without a way to get out of the kernel.  It seems this has been broken since introduction.  Nobody has noticed because nobody seems to be using MADVISE_WILLNEED on these DAX mappings.  [mhocko@suse.com: rewrite changelog] Link: http://lkml.kernel.org/r/20171127115318.911-1-guoxuenan@huawei.com Cc: Minchan Kim <minchan@kernel.org> Cc: zhangyi (F) <yi.zhang@huawei.com> Cc: Miao Xie <miaoxie@huawei.com> Cc: Mike Rapoport <rppt@linux.vnet.ibm.com> Cc: Shaohua Li <shli@fb.com> Cc: Andrea Arcangeli <aarcange@redhat.com> Cc: Mel Gorman <mgorman@techsingularity.net> Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com> Cc: David Rientjes <rientjes@google.com> Cc: Anshuman Khandual <khandual@linux.vnet.ibm.com> Cc: Rik van Riel <riel@redhat.com> Cc: Carsten Otte <cotte@de.ibm.com> Cc: Dan Williams <dan.j.williams@intel.com> Cc: <stable@vger.kernel.org>",
        "func_before": "static long madvise_willneed(struct vm_area_struct *vma,\n\t\t\t     struct vm_area_struct **prev,\n\t\t\t     unsigned long start, unsigned long end)\n{\n\tstruct file *file = vma->vm_file;\n\n#ifdef CONFIG_SWAP\n\tif (!file) {\n\t\t*prev = vma;\n\t\tforce_swapin_readahead(vma, start, end);\n\t\treturn 0;\n\t}\n\n\tif (shmem_mapping(file->f_mapping)) {\n\t\t*prev = vma;\n\t\tforce_shm_swapin_readahead(vma, start, end,\n\t\t\t\t\tfile->f_mapping);\n\t\treturn 0;\n\t}\n#else\n\tif (!file)\n\t\treturn -EBADF;\n#endif\n\n\tif (IS_DAX(file_inode(file))) {\n\t\t/* no bad return value, but ignore advice */\n\t\treturn 0;\n\t}\n\n\t*prev = vma;\n\tstart = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tif (end > vma->vm_end)\n\t\tend = vma->vm_end;\n\tend = ((end - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\n\tforce_page_cache_readahead(file->f_mapping, file, start, end - start);\n\treturn 0;\n}",
        "func": "static long madvise_willneed(struct vm_area_struct *vma,\n\t\t\t     struct vm_area_struct **prev,\n\t\t\t     unsigned long start, unsigned long end)\n{\n\tstruct file *file = vma->vm_file;\n\n\t*prev = vma;\n#ifdef CONFIG_SWAP\n\tif (!file) {\n\t\tforce_swapin_readahead(vma, start, end);\n\t\treturn 0;\n\t}\n\n\tif (shmem_mapping(file->f_mapping)) {\n\t\tforce_shm_swapin_readahead(vma, start, end,\n\t\t\t\t\tfile->f_mapping);\n\t\treturn 0;\n\t}\n#else\n\tif (!file)\n\t\treturn -EBADF;\n#endif\n\n\tif (IS_DAX(file_inode(file))) {\n\t\t/* no bad return value, but ignore advice */\n\t\treturn 0;\n\t}\n\n\tstart = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tif (end > vma->vm_end)\n\t\tend = vma->vm_end;\n\tend = ((end - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\n\tforce_page_cache_readahead(file->f_mapping, file, start, end - start);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,15 +4,14 @@\n {\n \tstruct file *file = vma->vm_file;\n \n+\t*prev = vma;\n #ifdef CONFIG_SWAP\n \tif (!file) {\n-\t\t*prev = vma;\n \t\tforce_swapin_readahead(vma, start, end);\n \t\treturn 0;\n \t}\n \n \tif (shmem_mapping(file->f_mapping)) {\n-\t\t*prev = vma;\n \t\tforce_shm_swapin_readahead(vma, start, end,\n \t\t\t\t\tfile->f_mapping);\n \t\treturn 0;\n@@ -27,7 +26,6 @@\n \t\treturn 0;\n \t}\n \n-\t*prev = vma;\n \tstart = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n \tif (end > vma->vm_end)\n \t\tend = vma->vm_end;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t*prev = vma;",
                "\t\t*prev = vma;",
                "\t*prev = vma;"
            ],
            "added_lines": [
                "\t*prev = vma;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14339",
        "func_name": "wireshark/proto_tree_add_string",
        "description": "In Wireshark 2.6.0 to 2.6.1, 2.4.0 to 2.4.7, and 2.2.0 to 2.2.15, the MMSE dissector could go into an infinite loop. This was addressed in epan/proto.c by adding offset and length validation.",
        "git_url": "https://github.com/wireshark/wireshark/commit/3b77c0a596a8071aebc1de71e3f79e5e15e919ca",
        "commit_title": "Do bounds checking of the offset and length in proto_tree_add_string().",
        "commit_text": " Throw an exception if they don't correspond to data available in the packet - and do so even if the protocol tree argument is null, so that we catch very long strings that could cause the offset to overflow.  Ask why we try to handle a null pointer passed as the string argument, while we're at it.  Bug: 14738 (cherry picked from commit 0fbb5f84d00426040bd37dd89d74e2ecda5b598e)",
        "func_before": "proto_item *\nproto_tree_add_string(proto_tree *tree, int hfindex, tvbuff_t *tvb, gint start,\n\t\t      gint length, const char* value)\n{\n\tproto_item\t  *pi;\n\theader_field_info *hfinfo;\n\n\tCHECK_FOR_NULL_TREE(tree);\n\n\tTRY_TO_FAKE_THIS_ITEM(tree, hfindex, hfinfo);\n\n\tDISSECTOR_ASSERT_FIELD_TYPE_IS_STRING(hfinfo);\n\n\tif (hfinfo->display == STR_UNICODE) {\n\t\tDISSECTOR_ASSERT(g_utf8_validate(value, -1, NULL));\n\t}\n\n\tpi = proto_tree_add_pi(tree, hfinfo, tvb, start, &length);\n\tDISSECTOR_ASSERT(length >= 0);\n\tproto_tree_set_string(PNODE_FINFO(pi), value);\n\n\treturn pi;\n}",
        "func": "proto_item *\nproto_tree_add_string(proto_tree *tree, int hfindex, tvbuff_t *tvb, gint start,\n\t\t      gint length, const char* value)\n{\n\tproto_item\t  *pi;\n\theader_field_info *hfinfo;\n\tgint\t\t  item_length;\n\n\tPROTO_REGISTRAR_GET_NTH(hfindex, hfinfo);\n\tget_hfi_length(hfinfo, tvb, start, &length, &item_length, ENC_NA);\n\t/*\n\t * Special case - if the length is 0, skip the test, so that\n\t * we can have an empty string right after the end of the\n\t * packet.  (This handles URL-encoded forms where the last field\n\t * has no value so the form ends right after the =.)\n\t */\n\tif (item_length != 0)\n\t\ttest_length(hfinfo, tvb, start, item_length, ENC_NA);\n\n\tCHECK_FOR_NULL_TREE(tree);\n\n\tTRY_TO_FAKE_THIS_ITEM(tree, hfindex, hfinfo);\n\n\tDISSECTOR_ASSERT_FIELD_TYPE_IS_STRING(hfinfo);\n\n\tif (hfinfo->display == STR_UNICODE) {\n\t\tDISSECTOR_ASSERT(g_utf8_validate(value, -1, NULL));\n\t}\n\n\tpi = proto_tree_add_pi(tree, hfinfo, tvb, start, &length);\n\tDISSECTOR_ASSERT(length >= 0);\n\tproto_tree_set_string(PNODE_FINFO(pi), value);\n\n\treturn pi;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,18 @@\n {\n \tproto_item\t  *pi;\n \theader_field_info *hfinfo;\n+\tgint\t\t  item_length;\n+\n+\tPROTO_REGISTRAR_GET_NTH(hfindex, hfinfo);\n+\tget_hfi_length(hfinfo, tvb, start, &length, &item_length, ENC_NA);\n+\t/*\n+\t * Special case - if the length is 0, skip the test, so that\n+\t * we can have an empty string right after the end of the\n+\t * packet.  (This handles URL-encoded forms where the last field\n+\t * has no value so the form ends right after the =.)\n+\t */\n+\tif (item_length != 0)\n+\t\ttest_length(hfinfo, tvb, start, item_length, ENC_NA);\n \n \tCHECK_FOR_NULL_TREE(tree);\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tgint\t\t  item_length;",
                "",
                "\tPROTO_REGISTRAR_GET_NTH(hfindex, hfinfo);",
                "\tget_hfi_length(hfinfo, tvb, start, &length, &item_length, ENC_NA);",
                "\t/*",
                "\t * Special case - if the length is 0, skip the test, so that",
                "\t * we can have an empty string right after the end of the",
                "\t * packet.  (This handles URL-encoded forms where the last field",
                "\t * has no value so the form ends right after the =.)",
                "\t */",
                "\tif (item_length != 0)",
                "\t\ttest_length(hfinfo, tvb, start, item_length, ENC_NA);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14339",
        "func_name": "wireshark/proto_tree_set_string",
        "description": "In Wireshark 2.6.0 to 2.6.1, 2.4.0 to 2.4.7, and 2.2.0 to 2.2.15, the MMSE dissector could go into an infinite loop. This was addressed in epan/proto.c by adding offset and length validation.",
        "git_url": "https://github.com/wireshark/wireshark/commit/3b77c0a596a8071aebc1de71e3f79e5e15e919ca",
        "commit_title": "Do bounds checking of the offset and length in proto_tree_add_string().",
        "commit_text": " Throw an exception if they don't correspond to data available in the packet - and do so even if the protocol tree argument is null, so that we catch very long strings that could cause the offset to overflow.  Ask why we try to handle a null pointer passed as the string argument, while we're at it.  Bug: 14738 (cherry picked from commit 0fbb5f84d00426040bd37dd89d74e2ecda5b598e)",
        "func_before": "static void\nproto_tree_set_string(field_info *fi, const char* value)\n{\n\tif (value) {\n\t\tfvalue_set_string(&fi->value, value);\n\t} else {\n\t\tfvalue_set_string(&fi->value, \"[ Null ]\");\n\t}\n}",
        "func": "static void\nproto_tree_set_string(field_info *fi, const char* value)\n{\n\tif (value) {\n\t\tfvalue_set_string(&fi->value, value);\n\t} else {\n\t\t/*\n\t\t * XXX - why is a null value for a string field\n\t\t * considered valid?\n\t\t */\n\t\tfvalue_set_string(&fi->value, \"[ Null ]\");\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,10 @@\n \tif (value) {\n \t\tfvalue_set_string(&fi->value, value);\n \t} else {\n+\t\t/*\n+\t\t * XXX - why is a null value for a string field\n+\t\t * considered valid?\n+\t\t */\n \t\tfvalue_set_string(&fi->value, \"[ Null ]\");\n \t}\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t/*",
                "\t\t * XXX - why is a null value for a string field",
                "\t\t * considered valid?",
                "\t\t */"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14341",
        "func_name": "wireshark/dissect_dcm_tag_value",
        "description": "In Wireshark 2.6.0 to 2.6.1, 2.4.0 to 2.4.7, and 2.2.0 to 2.2.15, the DICOM dissector could go into a large or infinite loop. This was addressed in epan/dissectors/packet-dcm.c by preventing an offset overflow.",
        "git_url": "https://github.com/wireshark/wireshark/commit/2e716c32be6aa20e1813b0002878853e71f8b2f4",
        "commit_title": "Make sure the offset doesn't overflow.",
        "commit_text": " It'd only overflow if the value is *so* large that it won't fit in the packet (given that we have a 2^32-1-byte limit on the packet size), so use tvb_ensure_bytes_exist() to ensure we have the entire value before processing the value.  (The real problem is that we don't handle the case where there's a value multiplicity > 1 for some types; in those cases, we should loop, processing all the values, which would cause us to eventually throw an exception when we ran past the end of the packet.  This is just a quick fix.)  Bug: 14742 (cherry picked from commit 25118898a931589cfdea4693e056a02b7daecf10)",
        "func_before": "static guint32\ndissect_dcm_tag_value(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, dcm_state_pdv_t *pdv,\n                      guint32 offset, guint16 grp, guint16 elm,\n                      guint32 vl, guint32 vl_max, const gchar* vr, gchar **tag_value)\n{\n    /* Based on the value representation, decode the value of one tag. Returns new offset */\n\n    proto_item *pitem = NULL;\n\n    gboolean is_little_endian;\n\n    if (pdv->syntax == DCM_EBE) is_little_endian = FALSE;\n    else                        is_little_endian = TRUE;\n\n\n    /* ---------------------------------------------------------------------------\n       Potentially long types. Obey vl_max\n       ---------------------------------------------------------------------------\n    */\n\n    if ((strncmp(vr, \"AE\", 2) == 0) || (strncmp(vr, \"AS\", 2) == 0) || (strncmp(vr, \"CS\", 2) == 0) ||\n        (strncmp(vr, \"DA\", 2) == 0) || (strncmp(vr, \"DS\", 2) == 0) || (strncmp(vr, \"DT\", 2) == 0) ||\n        (strncmp(vr, \"IS\", 2) == 0) || (strncmp(vr, \"LO\", 2) == 0) || (strncmp(vr, \"LT\", 2) == 0) ||\n        (strncmp(vr, \"PN\", 2) == 0) || (strncmp(vr, \"SH\", 2) == 0) || (strncmp(vr, \"ST\", 2) == 0) ||\n        (strncmp(vr, \"TM\", 2) == 0) || (strncmp(vr, \"UI\", 2) == 0) || (strncmp(vr, \"UT\", 2) == 0) ) {\n        /* 15 ways to represent a string ... */\n\n        gchar   *vals;\n        dcm_uid_t *uid = NULL;\n        guint8 val8;\n\n        val8 = tvb_get_guint8(tvb, offset + vl_max - 1);\n        if (val8 == 0x00) {\n            /* Last byte of string is 0x00, i.e. padded */\n            vals = tvb_format_text(tvb, offset, vl_max - 1);\n        }\n        else {\n            vals = tvb_format_text(tvb, offset, vl_max);\n        }\n\n        if ((strncmp(vr, \"UI\", 2) == 0)) {\n            /* This is a UID. Attempt a lookup. Will only return something for classes of course */\n\n            uid = (dcm_uid_t *)g_hash_table_lookup(dcm_uid_table, (gpointer) vals);\n            if (uid) {\n                g_snprintf(*tag_value, MAX_BUF_LEN, \"%s (%s)\", vals, uid->name);\n            }\n            else {\n                g_snprintf(*tag_value, MAX_BUF_LEN, \"%s\", vals);\n            }\n        }\n        else {\n            if (strlen(vals) > 50) {\n                g_snprintf(*tag_value, MAX_BUF_LEN, \"%-50.50s...\", vals);\n            }\n            else {\n                g_snprintf(*tag_value, MAX_BUF_LEN, \"%s\", vals);\n            }\n        }\n        proto_tree_add_string_format(tree, hf_dcm_tag_value_str, tvb, offset, vl_max, *tag_value, \"%-8.8s%s\", \"Value:\", *tag_value);\n\n        if (grp == 0x0000 && elm == 0x0902) {\n            /* The error comment */\n            pdv->comment = wmem_strdup(wmem_file_scope(), g_strstrip(vals));\n        }\n    }\n    else if ((strncmp(vr, \"OB\", 2) == 0) || (strncmp(vr, \"OF\", 2) == 0) ||\n             (strncmp(vr, \"OW\", 2) == 0)) {\n        /* Array of Bytes, Float or Words. Don't perform any decoding */\n\n        proto_tree_add_bytes_format(tree, hf_dcm_tag_value_byte, tvb, offset, vl_max,\n            NULL, \"%-8.8s%s\", \"Value:\", \"(binary)\");\n\n        g_snprintf(*tag_value, MAX_BUF_LEN, \"(binary)\");\n    }\n    else if (strncmp(vr, \"UN\", 2) == 0) {\n        /* Usually the case for private tags in implicit syntax, since tag was not found and vr not specified */\n        guint8    val8;\n        gchar    *vals;\n        guint32  i;\n\n        /* String detector, i.e. check if we only have alpha-numeric character */\n        gboolean        is_string = TRUE;\n        gboolean        is_padded = FALSE;\n\n        for (i = 0; i < vl_max ; i++) {\n            val8 = tvb_get_guint8(tvb, offset + i);\n\n            if ((val8 == 0x09) || (val8 == 0x0A) || (val8 == 0x0D)) {\n                /* TAB, LF, CR */\n            }\n            else if ((val8 >= 0x20) && (val8 <= 0x7E)) {\n                /* No extended ASCII, 0-9, A-Z, a-z */\n            }\n            else if ((i == vl_max -1) && (val8 == 0x00)) {\n                /* Last Byte can be null*/\n                is_padded = TRUE;\n            }\n            else {\n                /* Here's the code */\n                is_string = FALSE;\n            }\n        }\n\n        if (is_string) {\n            vals = tvb_format_text(tvb, offset, (is_padded ? vl_max - 1 : vl_max));\n            proto_tree_add_string_format(tree, hf_dcm_tag_value_str, tvb, offset, vl_max,\n                vals, \"%-8.8s%s\", \"Value:\", vals);\n\n            g_snprintf(*tag_value, MAX_BUF_LEN, \"%s\", vals);\n        }\n        else {\n            proto_tree_add_bytes_format(tree, hf_dcm_tag_value_byte, tvb, offset, vl_max,\n                NULL, \"%-8.8s%s\", \"Value:\", \"(binary)\");\n\n            g_snprintf(*tag_value, MAX_BUF_LEN, \"(binary)\");\n        }\n    }\n    /* ---------------------------------------------------------------------------\n       Smaller types. vl/vl_max are not used. Fixed item length from 2 to 8 bytes\n       ---------------------------------------------------------------------------\n    */\n    else if (strncmp(vr, \"AT\", 2) == 0)  {      /* Attribute Tag */\n        /* 2*2 Bytes */\n\n        guint16 at_grp;\n        guint16 at_elm;\n        guint32 at_offset = 0;\n        const gchar *at_value = \"\";\n\n        while(at_offset < vl_max-3) {\n            if (is_little_endian)   at_grp = tvb_get_letohs(tvb, offset+at_offset);\n            else                    at_grp = tvb_get_ntohs(tvb, offset+at_offset);\n\n            if (is_little_endian)   at_elm = tvb_get_letohs(tvb, offset+at_offset+2);\n            else                    at_elm = tvb_get_ntohs(tvb, offset+at_offset+2);\n\n            proto_tree_add_uint_format(tree, hf_dcm_tag_value_32u, tvb, offset+at_offset, 4,\n                (at_grp << 16) | at_elm, \"%-8.8s%04x,%04x\", \"Value:\", at_grp, at_elm);\n\n            at_value = wmem_strdup_printf(wmem_packet_scope(),\"%s(%04x,%04x)\", at_value, at_grp, at_elm);\n\n            at_offset += 4;\n        }\n        g_snprintf(*tag_value, MAX_BUF_LEN, \"%s\", at_value);\n    }\n    else if (strncmp(vr, \"FL\", 2) == 0)  {      /* Single Float */\n\n        gfloat valf;\n\n        if (is_little_endian) valf = tvb_get_letohieee_float(tvb, offset);\n        else                  valf = tvb_get_ntohieee_float(tvb, offset);\n\n        proto_tree_add_bytes_format(tree, hf_dcm_tag_value_byte, tvb, offset, 4,\n            NULL, \"%-8.8s%f\", \"Value:\", valf);\n\n        g_snprintf(*tag_value, MAX_BUF_LEN, \"%f\", valf);\n    }\n    else if (strncmp(vr, \"FD\", 2) == 0)  {      /* Double Float */\n\n        gdouble vald;\n\n        if (is_little_endian) vald = tvb_get_letohieee_double(tvb, offset);\n        else                  vald = tvb_get_ntohieee_double(tvb, offset);\n\n        proto_tree_add_bytes_format(tree, hf_dcm_tag_value_byte, tvb, offset, 8,\n            NULL, \"%-8.8s%f\", \"Value:\", vald);\n\n        g_snprintf(*tag_value, MAX_BUF_LEN, \"%f\", vald);\n    }\n    else if (strncmp(vr, \"SL\", 2) == 0)  {          /* Signed Long */\n        gint32  val32;\n\n        if (is_little_endian)   val32 = tvb_get_letohl(tvb, offset);\n        else                    val32 = tvb_get_ntohl(tvb, offset);\n\n        proto_tree_add_int_format(tree, hf_dcm_tag_value_32s, tvb, offset, 4,\n            val32, \"%-8.8s%d\", \"Value:\", val32);\n\n        g_snprintf(*tag_value, MAX_BUF_LEN, \"%d\", val32);\n    }\n    else if (strncmp(vr, \"SS\", 2) == 0)  {          /* Signed Short */\n        gint16  val16;\n\n        if (is_little_endian)   val16 = tvb_get_letohs(tvb, offset);\n        else                    val16 = tvb_get_ntohs(tvb, offset);\n\n        proto_tree_add_int_format(tree, hf_dcm_tag_value_16s, tvb, offset, 2,\n            val16, \"%-8.8s%d\", \"Value:\", val16);\n\n        g_snprintf(*tag_value, MAX_BUF_LEN, \"%d\", val16);\n    }\n    else if (strncmp(vr, \"UL\", 2) == 0)  {          /* Unsigned Long */\n        guint32  val32;\n\n        if (is_little_endian)   val32 = tvb_get_letohl(tvb, offset);\n        else                    val32 = tvb_get_ntohl(tvb, offset);\n\n        proto_tree_add_uint_format(tree, hf_dcm_tag_value_32u, tvb, offset, 4,\n            val32, \"%-8.8s%u\", \"Value:\", val32);\n\n        g_snprintf(*tag_value, MAX_BUF_LEN, \"%u\", val32);\n    }\n    else if (strncmp(vr, \"US\", 2) == 0)  {          /* Unsigned Short */\n        const gchar *status_message = NULL;\n        guint16     val16;\n\n        if (is_little_endian)   val16 = tvb_get_letohs(tvb, offset);\n        else                    val16 = tvb_get_ntohs(tvb, offset);\n\n        if (grp == 0x0000 && elm == 0x0100) {\n            /* This is a command */\n            g_snprintf(*tag_value, MAX_BUF_LEN, \"%s\", dcm_cmd2str(val16));\n\n            pdv->command = wmem_strdup(wmem_file_scope(), *tag_value);\n        }\n        else if (grp == 0x0000 && elm == 0x0900) {\n            /* This is a status message. If value is not 0x0000, add an expert info */\n\n            status_message = dcm_rsp2str(val16);\n            g_snprintf(*tag_value, MAX_BUF_LEN, \"%s (0x%02x)\", status_message, val16);\n\n            if (val16 != 0x0000 && ((val16 & 0xFF00) != 0xFF00)) {\n                /* Not 0x0000 0xFFxx */\n                pdv->is_warning = TRUE;\n            }\n\n            pdv->status = wmem_strdup(wmem_file_scope(), status_message);\n\n        }\n        else {\n            g_snprintf(*tag_value, MAX_BUF_LEN, \"%u\", val16);\n        }\n\n        if (grp == 0x0000) {\n            if (elm == 0x0110) {                /* (0000,0110) Message ID */\n                pdv->message_id = val16;\n            }\n            else if (elm == 0x0120) {           /* (0000,0120) Message ID Being Responded To */\n                pdv->message_id_resp = val16;\n            }\n            else if (elm == 0x1020) {           /* (0000,1020) Number of Remaining Sub-operations */\n                pdv->no_remaining = val16;\n            }\n            else if (elm == 0x1021) {           /* (0000,1021) Number of Completed Sub-operations */\n                pdv->no_completed = val16;\n            }\n            else if (elm == 0x1022) {           /* (0000,1022) Number of Failed Sub-operations  */\n                pdv->no_failed = val16;\n            }\n            else if (elm == 0x1023) {           /* (0000,1023) Number of Warning Sub-operations */\n                pdv->no_warning = val16;\n            }\n        }\n\n        pitem = proto_tree_add_uint_format(tree, hf_dcm_tag_value_16u, tvb, offset, 2,\n                    val16, \"%-8.8s%s\", \"Value:\", *tag_value);\n\n        if (pdv->is_warning && status_message) {\n            expert_add_info(pinfo, pitem, &ei_dcm_status_msg);\n        }\n    }\n    /* Invalid VR, can only occur with Explicit syntax */\n    else {\n        proto_tree_add_bytes_format(tree, hf_dcm_tag_value_byte, tvb, offset, vl_max,\n            NULL, \"%-8.8s%s\", \"Value:\", (vl > vl_max ? \"\" : \"(unknown VR)\"));\n\n        g_snprintf(*tag_value, MAX_BUF_LEN, \"(unknown VR)\");\n    }\n    offset += vl_max;\n\n    return offset;\n\n}",
        "func": "static guint32\ndissect_dcm_tag_value(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, dcm_state_pdv_t *pdv,\n                      guint32 offset, guint16 grp, guint16 elm,\n                      guint32 vl, guint32 vl_max, const gchar* vr, gchar **tag_value)\n{\n    /* Based on the value representation, decode the value of one tag. Returns new offset */\n\n    proto_item *pitem = NULL;\n\n    gboolean is_little_endian;\n\n    if (pdv->syntax == DCM_EBE) is_little_endian = FALSE;\n    else                        is_little_endian = TRUE;\n\n\n    /* Make sure we have all the bytes of the item; this should throw\n       and exception if vl_max is so large that it causes the offset\n       to overflow. */\n    tvb_ensure_bytes_exist(tvb, offset, vl_max);\n\n    /* ---------------------------------------------------------------------------\n       Potentially long types. Obey vl_max\n       ---------------------------------------------------------------------------\n    */\n\n    if ((strncmp(vr, \"AE\", 2) == 0) || (strncmp(vr, \"AS\", 2) == 0) || (strncmp(vr, \"CS\", 2) == 0) ||\n        (strncmp(vr, \"DA\", 2) == 0) || (strncmp(vr, \"DS\", 2) == 0) || (strncmp(vr, \"DT\", 2) == 0) ||\n        (strncmp(vr, \"IS\", 2) == 0) || (strncmp(vr, \"LO\", 2) == 0) || (strncmp(vr, \"LT\", 2) == 0) ||\n        (strncmp(vr, \"PN\", 2) == 0) || (strncmp(vr, \"SH\", 2) == 0) || (strncmp(vr, \"ST\", 2) == 0) ||\n        (strncmp(vr, \"TM\", 2) == 0) || (strncmp(vr, \"UI\", 2) == 0) || (strncmp(vr, \"UT\", 2) == 0) ) {\n        /* 15 ways to represent a string ... */\n\n        gchar   *vals;\n        dcm_uid_t *uid = NULL;\n        guint8 val8;\n\n        val8 = tvb_get_guint8(tvb, offset + vl_max - 1);\n        if (val8 == 0x00) {\n            /* Last byte of string is 0x00, i.e. padded */\n            vals = tvb_format_text(tvb, offset, vl_max - 1);\n        }\n        else {\n            vals = tvb_format_text(tvb, offset, vl_max);\n        }\n\n        if ((strncmp(vr, \"UI\", 2) == 0)) {\n            /* This is a UID. Attempt a lookup. Will only return something for classes of course */\n\n            uid = (dcm_uid_t *)g_hash_table_lookup(dcm_uid_table, (gpointer) vals);\n            if (uid) {\n                g_snprintf(*tag_value, MAX_BUF_LEN, \"%s (%s)\", vals, uid->name);\n            }\n            else {\n                g_snprintf(*tag_value, MAX_BUF_LEN, \"%s\", vals);\n            }\n        }\n        else {\n            if (strlen(vals) > 50) {\n                g_snprintf(*tag_value, MAX_BUF_LEN, \"%-50.50s...\", vals);\n            }\n            else {\n                g_snprintf(*tag_value, MAX_BUF_LEN, \"%s\", vals);\n            }\n        }\n        proto_tree_add_string_format(tree, hf_dcm_tag_value_str, tvb, offset, vl_max, *tag_value, \"%-8.8s%s\", \"Value:\", *tag_value);\n\n        if (grp == 0x0000 && elm == 0x0902) {\n            /* The error comment */\n            pdv->comment = wmem_strdup(wmem_file_scope(), g_strstrip(vals));\n        }\n    }\n    else if ((strncmp(vr, \"OB\", 2) == 0) || (strncmp(vr, \"OF\", 2) == 0) ||\n             (strncmp(vr, \"OW\", 2) == 0)) {\n        /* Array of Bytes, Float or Words. Don't perform any decoding */\n\n        proto_tree_add_bytes_format(tree, hf_dcm_tag_value_byte, tvb, offset, vl_max,\n            NULL, \"%-8.8s%s\", \"Value:\", \"(binary)\");\n\n        g_snprintf(*tag_value, MAX_BUF_LEN, \"(binary)\");\n    }\n    else if (strncmp(vr, \"UN\", 2) == 0) {\n        /* Usually the case for private tags in implicit syntax, since tag was not found and vr not specified */\n        guint8    val8;\n        gchar    *vals;\n        guint32  i;\n\n        /* String detector, i.e. check if we only have alpha-numeric character */\n        gboolean        is_string = TRUE;\n        gboolean        is_padded = FALSE;\n\n        for (i = 0; i < vl_max ; i++) {\n            val8 = tvb_get_guint8(tvb, offset + i);\n\n            if ((val8 == 0x09) || (val8 == 0x0A) || (val8 == 0x0D)) {\n                /* TAB, LF, CR */\n            }\n            else if ((val8 >= 0x20) && (val8 <= 0x7E)) {\n                /* No extended ASCII, 0-9, A-Z, a-z */\n            }\n            else if ((i == vl_max -1) && (val8 == 0x00)) {\n                /* Last Byte can be null*/\n                is_padded = TRUE;\n            }\n            else {\n                /* Here's the code */\n                is_string = FALSE;\n            }\n        }\n\n        if (is_string) {\n            vals = tvb_format_text(tvb, offset, (is_padded ? vl_max - 1 : vl_max));\n            proto_tree_add_string_format(tree, hf_dcm_tag_value_str, tvb, offset, vl_max,\n                vals, \"%-8.8s%s\", \"Value:\", vals);\n\n            g_snprintf(*tag_value, MAX_BUF_LEN, \"%s\", vals);\n        }\n        else {\n            proto_tree_add_bytes_format(tree, hf_dcm_tag_value_byte, tvb, offset, vl_max,\n                NULL, \"%-8.8s%s\", \"Value:\", \"(binary)\");\n\n            g_snprintf(*tag_value, MAX_BUF_LEN, \"(binary)\");\n        }\n    }\n    /* ---------------------------------------------------------------------------\n       Smaller types. vl/vl_max are not used. Fixed item length from 2 to 8 bytes\n       ---------------------------------------------------------------------------\n    */\n    else if (strncmp(vr, \"AT\", 2) == 0)  {      /* Attribute Tag */\n        /* 2*2 Bytes */\n\n        guint16 at_grp;\n        guint16 at_elm;\n        guint32 at_offset = 0;\n        const gchar *at_value = \"\";\n\n        while(at_offset < vl_max-3) {\n            if (is_little_endian)   at_grp = tvb_get_letohs(tvb, offset+at_offset);\n            else                    at_grp = tvb_get_ntohs(tvb, offset+at_offset);\n\n            if (is_little_endian)   at_elm = tvb_get_letohs(tvb, offset+at_offset+2);\n            else                    at_elm = tvb_get_ntohs(tvb, offset+at_offset+2);\n\n            proto_tree_add_uint_format(tree, hf_dcm_tag_value_32u, tvb, offset+at_offset, 4,\n                (at_grp << 16) | at_elm, \"%-8.8s%04x,%04x\", \"Value:\", at_grp, at_elm);\n\n            at_value = wmem_strdup_printf(wmem_packet_scope(),\"%s(%04x,%04x)\", at_value, at_grp, at_elm);\n\n            at_offset += 4;\n        }\n        g_snprintf(*tag_value, MAX_BUF_LEN, \"%s\", at_value);\n    }\n    else if (strncmp(vr, \"FL\", 2) == 0)  {      /* Single Float */\n\n        gfloat valf;\n\n        if (is_little_endian) valf = tvb_get_letohieee_float(tvb, offset);\n        else                  valf = tvb_get_ntohieee_float(tvb, offset);\n\n        proto_tree_add_bytes_format(tree, hf_dcm_tag_value_byte, tvb, offset, 4,\n            NULL, \"%-8.8s%f\", \"Value:\", valf);\n\n        g_snprintf(*tag_value, MAX_BUF_LEN, \"%f\", valf);\n    }\n    else if (strncmp(vr, \"FD\", 2) == 0)  {      /* Double Float */\n\n        gdouble vald;\n\n        if (is_little_endian) vald = tvb_get_letohieee_double(tvb, offset);\n        else                  vald = tvb_get_ntohieee_double(tvb, offset);\n\n        proto_tree_add_bytes_format(tree, hf_dcm_tag_value_byte, tvb, offset, 8,\n            NULL, \"%-8.8s%f\", \"Value:\", vald);\n\n        g_snprintf(*tag_value, MAX_BUF_LEN, \"%f\", vald);\n    }\n    else if (strncmp(vr, \"SL\", 2) == 0)  {          /* Signed Long */\n        gint32  val32;\n\n        if (is_little_endian)   val32 = tvb_get_letohl(tvb, offset);\n        else                    val32 = tvb_get_ntohl(tvb, offset);\n\n        proto_tree_add_int_format(tree, hf_dcm_tag_value_32s, tvb, offset, 4,\n            val32, \"%-8.8s%d\", \"Value:\", val32);\n\n        g_snprintf(*tag_value, MAX_BUF_LEN, \"%d\", val32);\n    }\n    else if (strncmp(vr, \"SS\", 2) == 0)  {          /* Signed Short */\n        gint16  val16;\n\n        if (is_little_endian)   val16 = tvb_get_letohs(tvb, offset);\n        else                    val16 = tvb_get_ntohs(tvb, offset);\n\n        proto_tree_add_int_format(tree, hf_dcm_tag_value_16s, tvb, offset, 2,\n            val16, \"%-8.8s%d\", \"Value:\", val16);\n\n        g_snprintf(*tag_value, MAX_BUF_LEN, \"%d\", val16);\n    }\n    else if (strncmp(vr, \"UL\", 2) == 0)  {          /* Unsigned Long */\n        guint32  val32;\n\n        if (is_little_endian)   val32 = tvb_get_letohl(tvb, offset);\n        else                    val32 = tvb_get_ntohl(tvb, offset);\n\n        proto_tree_add_uint_format(tree, hf_dcm_tag_value_32u, tvb, offset, 4,\n            val32, \"%-8.8s%u\", \"Value:\", val32);\n\n        g_snprintf(*tag_value, MAX_BUF_LEN, \"%u\", val32);\n    }\n    else if (strncmp(vr, \"US\", 2) == 0)  {          /* Unsigned Short */\n        const gchar *status_message = NULL;\n        guint16     val16;\n\n        if (is_little_endian)   val16 = tvb_get_letohs(tvb, offset);\n        else                    val16 = tvb_get_ntohs(tvb, offset);\n\n        if (grp == 0x0000 && elm == 0x0100) {\n            /* This is a command */\n            g_snprintf(*tag_value, MAX_BUF_LEN, \"%s\", dcm_cmd2str(val16));\n\n            pdv->command = wmem_strdup(wmem_file_scope(), *tag_value);\n        }\n        else if (grp == 0x0000 && elm == 0x0900) {\n            /* This is a status message. If value is not 0x0000, add an expert info */\n\n            status_message = dcm_rsp2str(val16);\n            g_snprintf(*tag_value, MAX_BUF_LEN, \"%s (0x%02x)\", status_message, val16);\n\n            if (val16 != 0x0000 && ((val16 & 0xFF00) != 0xFF00)) {\n                /* Not 0x0000 0xFFxx */\n                pdv->is_warning = TRUE;\n            }\n\n            pdv->status = wmem_strdup(wmem_file_scope(), status_message);\n\n        }\n        else {\n            g_snprintf(*tag_value, MAX_BUF_LEN, \"%u\", val16);\n        }\n\n        if (grp == 0x0000) {\n            if (elm == 0x0110) {                /* (0000,0110) Message ID */\n                pdv->message_id = val16;\n            }\n            else if (elm == 0x0120) {           /* (0000,0120) Message ID Being Responded To */\n                pdv->message_id_resp = val16;\n            }\n            else if (elm == 0x1020) {           /* (0000,1020) Number of Remaining Sub-operations */\n                pdv->no_remaining = val16;\n            }\n            else if (elm == 0x1021) {           /* (0000,1021) Number of Completed Sub-operations */\n                pdv->no_completed = val16;\n            }\n            else if (elm == 0x1022) {           /* (0000,1022) Number of Failed Sub-operations  */\n                pdv->no_failed = val16;\n            }\n            else if (elm == 0x1023) {           /* (0000,1023) Number of Warning Sub-operations */\n                pdv->no_warning = val16;\n            }\n        }\n\n        pitem = proto_tree_add_uint_format(tree, hf_dcm_tag_value_16u, tvb, offset, 2,\n                    val16, \"%-8.8s%s\", \"Value:\", *tag_value);\n\n        if (pdv->is_warning && status_message) {\n            expert_add_info(pinfo, pitem, &ei_dcm_status_msg);\n        }\n    }\n    /* Invalid VR, can only occur with Explicit syntax */\n    else {\n        proto_tree_add_bytes_format(tree, hf_dcm_tag_value_byte, tvb, offset, vl_max,\n            NULL, \"%-8.8s%s\", \"Value:\", (vl > vl_max ? \"\" : \"(unknown VR)\"));\n\n        g_snprintf(*tag_value, MAX_BUF_LEN, \"(unknown VR)\");\n    }\n    offset += vl_max;\n\n    return offset;\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,11 @@\n     else                        is_little_endian = TRUE;\n \n \n+    /* Make sure we have all the bytes of the item; this should throw\n+       and exception if vl_max is so large that it causes the offset\n+       to overflow. */\n+    tvb_ensure_bytes_exist(tvb, offset, vl_max);\n+\n     /* ---------------------------------------------------------------------------\n        Potentially long types. Obey vl_max\n        ---------------------------------------------------------------------------",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    /* Make sure we have all the bytes of the item; this should throw",
                "       and exception if vl_max is so large that it causes the offset",
                "       to overflow. */",
                "    tvb_ensure_bytes_exist(tvb, offset, vl_max);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14368",
        "func_name": "wireshark/dissect_prefixed_bencode",
        "description": "In Wireshark 2.6.0 to 2.6.1, 2.4.0 to 2.4.7, and 2.2.0 to 2.2.15, the Bazaar protocol dissector could go into an infinite loop. This was addressed in epan/dissectors/packet-bzr.c by properly handling items that are too long.",
        "git_url": "https://github.com/wireshark/wireshark/commit/6c44312f465014eb409d766a9828b7f101f6251c",
        "commit_title": "Clean up handling of counted blobs of bytes.",
        "commit_text": " Don't treat the count+blob as itself a blob of bytes; use FT_NONE. Create it with an unknown length (-1, meaning \"to end of packet, for now\"), and set its length once we've finished dissecting it.  Dissect the raw bytes of a prefixed-bytes item regardless of whether we're building a protocol tree or not.  This means we do a better job of handling a too-large length; instead of overflowing the offset, we throw an exception and stop dissecting, so we don't run the risk of looping infinitely.  Bug: 14841 (cherry picked from commit a03eacc7aabd04a6fd0db978e0d7597220ac0515)",
        "func_before": "static gint\ndissect_prefixed_bencode(tvbuff_t *tvb, gint offset, packet_info *pinfo,\n                         proto_tree *tree)\n{\n    guint32     plen;\n    proto_tree *prefixed_bencode_tree;\n    proto_item *ti;\n    tvbuff_t *subtvb;\n\n    plen = tvb_get_ntohl(tvb, offset);\n\n    ti = proto_tree_add_item(tree, hf_bzr_prefixed_bencode, tvb, offset, 4 +\n                             plen, ENC_NA);\n    prefixed_bencode_tree = proto_item_add_subtree(ti, ett_prefixed_bencode);\n\n    proto_tree_add_item(prefixed_bencode_tree, hf_bzr_prefixed_bencode_len,\n                            tvb, offset, 4, ENC_BIG_ENDIAN);\n\n    subtvb = tvb_new_subset_length(tvb, offset+4, plen);\n    call_dissector(bencode_handle, subtvb, pinfo, prefixed_bencode_tree);\n\n    return 4 + plen;\n}",
        "func": "static gint\ndissect_prefixed_bencode(tvbuff_t *tvb, gint offset, packet_info *pinfo,\n                         proto_tree *tree)\n{\n    guint32     plen;\n    proto_tree *prefixed_bencode_tree;\n    proto_item *ti;\n    tvbuff_t *subtvb;\n\n    plen = tvb_get_ntohl(tvb, offset);\n\n    ti = proto_tree_add_item(tree, hf_bzr_prefixed_bencode, tvb, offset, -1,\n                             ENC_NA);\n    prefixed_bencode_tree = proto_item_add_subtree(ti, ett_prefixed_bencode);\n\n    proto_tree_add_item(prefixed_bencode_tree, hf_bzr_prefixed_bencode_len,\n                        tvb, offset, 4, ENC_BIG_ENDIAN);\n\n    subtvb = tvb_new_subset_length(tvb, offset+4, plen);\n    call_dissector(bencode_handle, subtvb, pinfo, prefixed_bencode_tree);\n\n    proto_item_set_len(ti, 4 + plen);\n\n    return 4 + plen;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,15 +9,17 @@\n \n     plen = tvb_get_ntohl(tvb, offset);\n \n-    ti = proto_tree_add_item(tree, hf_bzr_prefixed_bencode, tvb, offset, 4 +\n-                             plen, ENC_NA);\n+    ti = proto_tree_add_item(tree, hf_bzr_prefixed_bencode, tvb, offset, -1,\n+                             ENC_NA);\n     prefixed_bencode_tree = proto_item_add_subtree(ti, ett_prefixed_bencode);\n \n     proto_tree_add_item(prefixed_bencode_tree, hf_bzr_prefixed_bencode_len,\n-                            tvb, offset, 4, ENC_BIG_ENDIAN);\n+                        tvb, offset, 4, ENC_BIG_ENDIAN);\n \n     subtvb = tvb_new_subset_length(tvb, offset+4, plen);\n     call_dissector(bencode_handle, subtvb, pinfo, prefixed_bencode_tree);\n \n+    proto_item_set_len(ti, 4 + plen);\n+\n     return 4 + plen;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    ti = proto_tree_add_item(tree, hf_bzr_prefixed_bencode, tvb, offset, 4 +",
                "                             plen, ENC_NA);",
                "                            tvb, offset, 4, ENC_BIG_ENDIAN);"
            ],
            "added_lines": [
                "    ti = proto_tree_add_item(tree, hf_bzr_prefixed_bencode, tvb, offset, -1,",
                "                             ENC_NA);",
                "                        tvb, offset, 4, ENC_BIG_ENDIAN);",
                "    proto_item_set_len(ti, 4 + plen);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14368",
        "func_name": "wireshark/proto_register_bzr",
        "description": "In Wireshark 2.6.0 to 2.6.1, 2.4.0 to 2.4.7, and 2.2.0 to 2.2.15, the Bazaar protocol dissector could go into an infinite loop. This was addressed in epan/dissectors/packet-bzr.c by properly handling items that are too long.",
        "git_url": "https://github.com/wireshark/wireshark/commit/6c44312f465014eb409d766a9828b7f101f6251c",
        "commit_title": "Clean up handling of counted blobs of bytes.",
        "commit_text": " Don't treat the count+blob as itself a blob of bytes; use FT_NONE. Create it with an unknown length (-1, meaning \"to end of packet, for now\"), and set its length once we've finished dissecting it.  Dissect the raw bytes of a prefixed-bytes item regardless of whether we're building a protocol tree or not.  This means we do a better job of handling a too-large length; instead of overflowing the offset, we throw an exception and stop dissecting, so we don't run the risk of looping infinitely.  Bug: 14841 (cherry picked from commit a03eacc7aabd04a6fd0db978e0d7597220ac0515)",
        "func_before": "void\nproto_register_bzr(void)\n{\n    static hf_register_info hf[] = {\n        { &hf_bzr_packet_kind,\n          { \"Packet kind\", \"bzr.kind\", FT_UINT8, BASE_DEC,\n            VALS(message_part_kind), 0x0, NULL, HFILL },\n        },\n        { &hf_bzr_packet_protocol_version,\n          { \"Protocol version\", \"bzr.protocol_version\", FT_STRING, BASE_NONE,\n            NULL, 0x0, NULL, HFILL },\n        },\n        { &hf_bzr_prefixed_bencode,\n          { \"Bencode packet\", \"bzr.bencode\", FT_BYTES, BASE_NONE, NULL, 0x0,\n            \"Serialized structure of integers, dictionaries, strings and \"\n            \"lists.\", HFILL },\n        },\n        { &hf_bzr_prefixed_bencode_len,\n          { \"Bencode packet length\", \"bzr.bencode.length\", FT_UINT32,\n            BASE_HEX, NULL, 0x0, NULL, HFILL },\n        },\n        { &hf_bzr_bytes,\n          { \"Prefixed bytes\", \"bzr.bytes\", FT_BYTES, BASE_NONE, NULL, 0x0,\n            \"Bytes field with prefixed 32-bit length\", HFILL },\n        },\n        { &hf_bzr_bytes_data,\n          { \"Prefixed bytes data\", \"bzr.bytes.data\", FT_BYTES, BASE_NONE,\n            NULL, 0x0, NULL, HFILL },\n        },\n        { &hf_bzr_bytes_length,\n          { \"Prefixed bytes length\", \"bzr.bytes.length\", FT_UINT32, BASE_HEX,\n            NULL, 0x0, NULL, HFILL },\n        },\n        { &hf_bzr_result,\n          { \"Result\", \"bzr.result\", FT_UINT8, BASE_HEX,\n            VALS(message_results), 0x0,\n            \"Command result (success or failure with error message)\", HFILL\n          },\n        },\n    };\n\n    static gint *ett[] = {\n        &ett_bzr,\n        &ett_prefixed_bencode,\n        &ett_prefixed_bytes,\n    };\n\n    module_t *bzr_module;\n    proto_bzr = proto_register_protocol(\"Bazaar Smart Protocol\", \"Bazaar\", \"bzr\");\n    register_dissector(\"bzr\", dissect_bzr, proto_bzr);\n    proto_register_field_array(proto_bzr, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n\n    bzr_module = prefs_register_protocol(proto_bzr, NULL);\n\n    prefs_register_bool_preference(bzr_module, \"desegment\",\n                                   \"Reassemble Bazaar messages spanning multiple TCP segments\",\n                                   \"Whether the Bazaar dissector should reassemble messages spanning multiple TCP segments.\"\n                                   \" To use this option, you must also enable \\\"Allow subdissectors to reassemble TCP streams\\\"\"\n                                   \" in the TCP protocol settings.\",\n                                   &bzr_desegment);\n}",
        "func": "void\nproto_register_bzr(void)\n{\n    static hf_register_info hf[] = {\n        { &hf_bzr_packet_kind,\n          { \"Packet kind\", \"bzr.kind\", FT_UINT8, BASE_DEC,\n            VALS(message_part_kind), 0x0, NULL, HFILL },\n        },\n        { &hf_bzr_packet_protocol_version,\n          { \"Protocol version\", \"bzr.protocol_version\", FT_STRING, BASE_NONE,\n            NULL, 0x0, NULL, HFILL },\n        },\n        { &hf_bzr_prefixed_bencode,\n          { \"Bencode packet\", \"bzr.bencode\", FT_NONE, BASE_NONE, NULL, 0x0,\n            \"Serialized structure of integers, dictionaries, strings and \"\n            \"lists.\", HFILL },\n        },\n        { &hf_bzr_prefixed_bencode_len,\n          { \"Bencode packet length\", \"bzr.bencode.length\", FT_UINT32,\n            BASE_HEX, NULL, 0x0, NULL, HFILL },\n        },\n        { &hf_bzr_bytes,\n          { \"Prefixed bytes\", \"bzr.bytes\", FT_NONE, BASE_NONE, NULL, 0x0,\n            \"Bytes field with prefixed 32-bit length\", HFILL },\n        },\n        { &hf_bzr_bytes_data,\n          { \"Prefixed bytes data\", \"bzr.bytes.data\", FT_BYTES, BASE_NONE,\n            NULL, 0x0, NULL, HFILL },\n        },\n        { &hf_bzr_bytes_length,\n          { \"Prefixed bytes length\", \"bzr.bytes.length\", FT_UINT32, BASE_HEX,\n            NULL, 0x0, NULL, HFILL },\n        },\n        { &hf_bzr_result,\n          { \"Result\", \"bzr.result\", FT_UINT8, BASE_HEX,\n            VALS(message_results), 0x0,\n            \"Command result (success or failure with error message)\", HFILL\n          },\n        },\n    };\n\n    static gint *ett[] = {\n        &ett_bzr,\n        &ett_prefixed_bencode,\n        &ett_prefixed_bytes,\n    };\n\n    module_t *bzr_module;\n    proto_bzr = proto_register_protocol(\"Bazaar Smart Protocol\", \"Bazaar\", \"bzr\");\n    register_dissector(\"bzr\", dissect_bzr, proto_bzr);\n    proto_register_field_array(proto_bzr, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n\n    bzr_module = prefs_register_protocol(proto_bzr, NULL);\n\n    prefs_register_bool_preference(bzr_module, \"desegment\",\n                                   \"Reassemble Bazaar messages spanning multiple TCP segments\",\n                                   \"Whether the Bazaar dissector should reassemble messages spanning multiple TCP segments.\"\n                                   \" To use this option, you must also enable \\\"Allow subdissectors to reassemble TCP streams\\\"\"\n                                   \" in the TCP protocol settings.\",\n                                   &bzr_desegment);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,7 +11,7 @@\n             NULL, 0x0, NULL, HFILL },\n         },\n         { &hf_bzr_prefixed_bencode,\n-          { \"Bencode packet\", \"bzr.bencode\", FT_BYTES, BASE_NONE, NULL, 0x0,\n+          { \"Bencode packet\", \"bzr.bencode\", FT_NONE, BASE_NONE, NULL, 0x0,\n             \"Serialized structure of integers, dictionaries, strings and \"\n             \"lists.\", HFILL },\n         },\n@@ -20,7 +20,7 @@\n             BASE_HEX, NULL, 0x0, NULL, HFILL },\n         },\n         { &hf_bzr_bytes,\n-          { \"Prefixed bytes\", \"bzr.bytes\", FT_BYTES, BASE_NONE, NULL, 0x0,\n+          { \"Prefixed bytes\", \"bzr.bytes\", FT_NONE, BASE_NONE, NULL, 0x0,\n             \"Bytes field with prefixed 32-bit length\", HFILL },\n         },\n         { &hf_bzr_bytes_data,",
        "diff_line_info": {
            "deleted_lines": [
                "          { \"Bencode packet\", \"bzr.bencode\", FT_BYTES, BASE_NONE, NULL, 0x0,",
                "          { \"Prefixed bytes\", \"bzr.bytes\", FT_BYTES, BASE_NONE, NULL, 0x0,"
            ],
            "added_lines": [
                "          { \"Bencode packet\", \"bzr.bencode\", FT_NONE, BASE_NONE, NULL, 0x0,",
                "          { \"Prefixed bytes\", \"bzr.bytes\", FT_NONE, BASE_NONE, NULL, 0x0,"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14368",
        "func_name": "wireshark/dissect_prefixed_bytes",
        "description": "In Wireshark 2.6.0 to 2.6.1, 2.4.0 to 2.4.7, and 2.2.0 to 2.2.15, the Bazaar protocol dissector could go into an infinite loop. This was addressed in epan/dissectors/packet-bzr.c by properly handling items that are too long.",
        "git_url": "https://github.com/wireshark/wireshark/commit/6c44312f465014eb409d766a9828b7f101f6251c",
        "commit_title": "Clean up handling of counted blobs of bytes.",
        "commit_text": " Don't treat the count+blob as itself a blob of bytes; use FT_NONE. Create it with an unknown length (-1, meaning \"to end of packet, for now\"), and set its length once we've finished dissecting it.  Dissect the raw bytes of a prefixed-bytes item regardless of whether we're building a protocol tree or not.  This means we do a better job of handling a too-large length; instead of overflowing the offset, we throw an exception and stop dissecting, so we don't run the risk of looping infinitely.  Bug: 14841 (cherry picked from commit a03eacc7aabd04a6fd0db978e0d7597220ac0515)",
        "func_before": "static gint\ndissect_prefixed_bytes(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\n                       proto_tree *tree)\n{\n    guint32     plen;\n    proto_tree *prefixed_bytes_tree;\n    proto_item *ti;\n\n    plen = tvb_get_ntohl(tvb, offset);\n\n    ti = proto_tree_add_item(tree, hf_bzr_bytes, tvb, offset, 4 +\n                             plen, ENC_NA);\n    prefixed_bytes_tree = proto_item_add_subtree(ti, ett_prefixed_bytes);\n\n    if (prefixed_bytes_tree)\n    {\n        proto_tree_add_item(prefixed_bytes_tree, hf_bzr_bytes_length,\n                            tvb, offset, 4, ENC_BIG_ENDIAN);\n\n        proto_tree_add_item(prefixed_bytes_tree, hf_bzr_bytes_data,\n                            tvb, offset+4, plen, ENC_NA);\n    }\n\n    return 4 + plen;\n}",
        "func": "static gint\ndissect_prefixed_bytes(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\n                       proto_tree *tree)\n{\n    guint32     plen;\n    proto_tree *prefixed_bytes_tree;\n    proto_item *ti;\n\n    plen = tvb_get_ntohl(tvb, offset);\n\n    ti = proto_tree_add_item(tree, hf_bzr_bytes, tvb, offset, -1, ENC_NA);\n    prefixed_bytes_tree = proto_item_add_subtree(ti, ett_prefixed_bytes);\n\n    proto_tree_add_item(prefixed_bytes_tree, hf_bzr_bytes_length,\n                        tvb, offset, 4, ENC_BIG_ENDIAN);\n\n    proto_tree_add_item(prefixed_bytes_tree, hf_bzr_bytes_data,\n                        tvb, offset+4, plen, ENC_NA);\n\n    proto_item_set_len(ti, 4 + plen);\n\n    return 4 + plen;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,18 +8,16 @@\n \n     plen = tvb_get_ntohl(tvb, offset);\n \n-    ti = proto_tree_add_item(tree, hf_bzr_bytes, tvb, offset, 4 +\n-                             plen, ENC_NA);\n+    ti = proto_tree_add_item(tree, hf_bzr_bytes, tvb, offset, -1, ENC_NA);\n     prefixed_bytes_tree = proto_item_add_subtree(ti, ett_prefixed_bytes);\n \n-    if (prefixed_bytes_tree)\n-    {\n-        proto_tree_add_item(prefixed_bytes_tree, hf_bzr_bytes_length,\n-                            tvb, offset, 4, ENC_BIG_ENDIAN);\n+    proto_tree_add_item(prefixed_bytes_tree, hf_bzr_bytes_length,\n+                        tvb, offset, 4, ENC_BIG_ENDIAN);\n \n-        proto_tree_add_item(prefixed_bytes_tree, hf_bzr_bytes_data,\n-                            tvb, offset+4, plen, ENC_NA);\n-    }\n+    proto_tree_add_item(prefixed_bytes_tree, hf_bzr_bytes_data,\n+                        tvb, offset+4, plen, ENC_NA);\n+\n+    proto_item_set_len(ti, 4 + plen);\n \n     return 4 + plen;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    ti = proto_tree_add_item(tree, hf_bzr_bytes, tvb, offset, 4 +",
                "                             plen, ENC_NA);",
                "    if (prefixed_bytes_tree)",
                "    {",
                "        proto_tree_add_item(prefixed_bytes_tree, hf_bzr_bytes_length,",
                "                            tvb, offset, 4, ENC_BIG_ENDIAN);",
                "        proto_tree_add_item(prefixed_bytes_tree, hf_bzr_bytes_data,",
                "                            tvb, offset+4, plen, ENC_NA);",
                "    }"
            ],
            "added_lines": [
                "    ti = proto_tree_add_item(tree, hf_bzr_bytes, tvb, offset, -1, ENC_NA);",
                "    proto_tree_add_item(prefixed_bytes_tree, hf_bzr_bytes_length,",
                "                        tvb, offset, 4, ENC_BIG_ENDIAN);",
                "    proto_tree_add_item(prefixed_bytes_tree, hf_bzr_bytes_data,",
                "                        tvb, offset+4, plen, ENC_NA);",
                "",
                "    proto_item_set_len(ti, 4 + plen);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14445",
        "func_name": "axiomatic-systems/Bento4/AP4_StsdAtom::AP4_StsdAtom",
        "description": "In Bento4 v1.5.1-624, AP4_File::ParseStream in Ap4File.cpp allows remote attackers to cause a denial of service (infinite loop) via a crafted MP4 file.",
        "git_url": "https://github.com/axiomatic-systems/Bento4/commit/6acb92d0beaebf5bb46ebc1ae94ddc64a5f0f6d5",
        "commit_title": "fix #289",
        "commit_text": "",
        "func_before": "AP4_StsdAtom::AP4_StsdAtom(AP4_UI32         size,\n                           AP4_UI08         version,\n                           AP4_UI32         flags,\n                           AP4_ByteStream&  stream,\n                           AP4_AtomFactory& atom_factory) :\n    AP4_ContainerAtom(AP4_ATOM_TYPE_STSD, size, false, version, flags)\n{\n    // read the number of entries\n    AP4_UI32 entry_count;\n    stream.ReadUI32(entry_count);\n\n    // save and switch the factory's context\n    atom_factory.PushContext(m_Type);\n\n    // read all entries\n    AP4_LargeSize bytes_available = size-AP4_FULL_ATOM_HEADER_SIZE-4;\n    for (unsigned int i=0; i<entry_count; i++) {\n        AP4_Atom* atom;\n        if (AP4_SUCCEEDED(atom_factory.CreateAtomFromStream(stream, \n                                                            bytes_available,\n                                                            atom))) {\n            atom->SetParent(this);\n            m_Children.Add(atom);\n        }\n    }\n\n    // restore the saved context\n    atom_factory.PopContext();\n\n    // initialize the sample description cache\n    m_SampleDescriptions.EnsureCapacity(m_Children.ItemCount());\n    for (AP4_Ordinal i=0; i<m_Children.ItemCount(); i++) {\n        m_SampleDescriptions.Append(NULL);\n    }\n}",
        "func": "AP4_StsdAtom::AP4_StsdAtom(AP4_UI32         size,\n                           AP4_UI08         version,\n                           AP4_UI32         flags,\n                           AP4_ByteStream&  stream,\n                           AP4_AtomFactory& atom_factory) :\n    AP4_ContainerAtom(AP4_ATOM_TYPE_STSD, size, false, version, flags)\n{\n    // read the number of entries\n    AP4_UI32 entry_count;\n    stream.ReadUI32(entry_count);\n\n    // save and switch the factory's context\n    atom_factory.PushContext(m_Type);\n\n    // read all entries\n    AP4_LargeSize bytes_available = size-AP4_FULL_ATOM_HEADER_SIZE-4;\n    for (unsigned int i=0; i<entry_count; i++) {\n        AP4_Atom* atom;\n        if (AP4_SUCCEEDED(atom_factory.CreateAtomFromStream(stream, \n                                                            bytes_available,\n                                                            atom))) {\n            atom->SetParent(this);\n            m_Children.Add(atom);\n        } else {\n            break;\n        }\n    }\n\n    // restore the saved context\n    atom_factory.PopContext();\n\n    // initialize the sample description cache\n    m_SampleDescriptions.EnsureCapacity(m_Children.ItemCount());\n    for (AP4_Ordinal i=0; i<m_Children.ItemCount(); i++) {\n        m_SampleDescriptions.Append(NULL);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,6 +21,8 @@\n                                                             atom))) {\n             atom->SetParent(this);\n             m_Children.Add(atom);\n+        } else {\n+            break;\n         }\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        } else {",
                "            break;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-1999012",
        "func_name": "ffmpeg/read_part_of_packet",
        "description": "FFmpeg before commit 9807d3976be0e92e4ece3b4b1701be894cd7c2e1 contains a CWE-835: Infinite loop vulnerability in pva format demuxer that can result in a Vulnerability that allows attackers to consume excessive amount of resources like CPU and RAM. This attack appear to be exploitable via specially crafted PVA file has to be provided as input. This vulnerability appears to have been fixed in 9807d3976be0e92e4ece3b4b1701be894cd7c2e1 and later.",
        "git_url": "https://github.com/FFmpeg/FFmpeg/commit/9807d3976be0e92e4ece3b4b1701be894cd7c2e1",
        "commit_title": "avformat/pva: Check for EOF before retrying in read_part_of_packet()",
        "commit_text": " ",
        "func_before": "static int read_part_of_packet(AVFormatContext *s, int64_t *pts,\n                               int *len, int *strid, int read_packet) {\n    AVIOContext *pb = s->pb;\n    PVAContext *pvactx = s->priv_data;\n    int syncword, streamid, reserved, flags, length, pts_flag;\n    int64_t pva_pts = AV_NOPTS_VALUE, startpos;\n    int ret;\n\nrecover:\n    startpos = avio_tell(pb);\n\n    syncword = avio_rb16(pb);\n    streamid = avio_r8(pb);\n    avio_r8(pb);               /* counter not used */\n    reserved = avio_r8(pb);\n    flags    = avio_r8(pb);\n    length   = avio_rb16(pb);\n\n    pts_flag = flags & 0x10;\n\n    if (syncword != PVA_MAGIC) {\n        pva_log(s, AV_LOG_ERROR, \"invalid syncword\\n\");\n        return AVERROR(EIO);\n    }\n    if (streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD) {\n        pva_log(s, AV_LOG_ERROR, \"invalid streamid\\n\");\n        return AVERROR(EIO);\n    }\n    if (reserved != 0x55) {\n        pva_log(s, AV_LOG_WARNING, \"expected reserved byte to be 0x55\\n\");\n    }\n    if (length > PVA_MAX_PAYLOAD_LENGTH) {\n        pva_log(s, AV_LOG_ERROR, \"invalid payload length %u\\n\", length);\n        return AVERROR(EIO);\n    }\n\n    if (streamid == PVA_VIDEO_PAYLOAD && pts_flag) {\n        pva_pts = avio_rb32(pb);\n        length -= 4;\n    } else if (streamid == PVA_AUDIO_PAYLOAD) {\n        /* PVA Audio Packets either start with a signaled PES packet or\n         * are a continuation of the previous PES packet. New PES packets\n         * always start at the beginning of a PVA Packet, never somewhere in\n         * the middle. */\n        if (!pvactx->continue_pes) {\n            int pes_signal, pes_header_data_length, pes_packet_length,\n                pes_flags;\n            unsigned char pes_header_data[256];\n\n            pes_signal             = avio_rb24(pb);\n            avio_r8(pb);\n            pes_packet_length      = avio_rb16(pb);\n            pes_flags              = avio_rb16(pb);\n            pes_header_data_length = avio_r8(pb);\n\n            if (pes_signal != 1 || pes_header_data_length == 0) {\n                pva_log(s, AV_LOG_WARNING, \"expected non empty signaled PES packet, \"\n                                          \"trying to recover\\n\");\n                avio_skip(pb, length - 9);\n                if (!read_packet)\n                    return AVERROR(EIO);\n                goto recover;\n            }\n\n            ret = avio_read(pb, pes_header_data, pes_header_data_length);\n            if (ret != pes_header_data_length)\n                return ret < 0 ? ret : AVERROR_INVALIDDATA;\n            length -= 9 + pes_header_data_length;\n\n            pes_packet_length -= 3 + pes_header_data_length;\n\n            pvactx->continue_pes = pes_packet_length;\n\n            if (pes_flags & 0x80 && (pes_header_data[0] & 0xf0) == 0x20) {\n                if (pes_header_data_length < 5) {\n                    pva_log(s, AV_LOG_ERROR, \"header too short\\n\");\n                    avio_skip(pb, length);\n                    return AVERROR_INVALIDDATA;\n                }\n                pva_pts = ff_parse_pes_pts(pes_header_data);\n            }\n        }\n\n        pvactx->continue_pes -= length;\n\n        if (pvactx->continue_pes < 0) {\n            pva_log(s, AV_LOG_WARNING, \"audio data corruption\\n\");\n            pvactx->continue_pes = 0;\n        }\n    }\n\n    if (pva_pts != AV_NOPTS_VALUE)\n        av_add_index_entry(s->streams[streamid-1], startpos, pva_pts, 0, 0, AVINDEX_KEYFRAME);\n\n    *pts   = pva_pts;\n    *len   = length;\n    *strid = streamid;\n    return 0;\n}",
        "func": "static int read_part_of_packet(AVFormatContext *s, int64_t *pts,\n                               int *len, int *strid, int read_packet) {\n    AVIOContext *pb = s->pb;\n    PVAContext *pvactx = s->priv_data;\n    int syncword, streamid, reserved, flags, length, pts_flag;\n    int64_t pva_pts = AV_NOPTS_VALUE, startpos;\n    int ret;\n\nrecover:\n    startpos = avio_tell(pb);\n\n    syncword = avio_rb16(pb);\n    streamid = avio_r8(pb);\n    avio_r8(pb);               /* counter not used */\n    reserved = avio_r8(pb);\n    flags    = avio_r8(pb);\n    length   = avio_rb16(pb);\n\n    pts_flag = flags & 0x10;\n\n    if (syncword != PVA_MAGIC) {\n        pva_log(s, AV_LOG_ERROR, \"invalid syncword\\n\");\n        return AVERROR(EIO);\n    }\n    if (streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD) {\n        pva_log(s, AV_LOG_ERROR, \"invalid streamid\\n\");\n        return AVERROR(EIO);\n    }\n    if (reserved != 0x55) {\n        pva_log(s, AV_LOG_WARNING, \"expected reserved byte to be 0x55\\n\");\n    }\n    if (length > PVA_MAX_PAYLOAD_LENGTH) {\n        pva_log(s, AV_LOG_ERROR, \"invalid payload length %u\\n\", length);\n        return AVERROR(EIO);\n    }\n\n    if (streamid == PVA_VIDEO_PAYLOAD && pts_flag) {\n        pva_pts = avio_rb32(pb);\n        length -= 4;\n    } else if (streamid == PVA_AUDIO_PAYLOAD) {\n        /* PVA Audio Packets either start with a signaled PES packet or\n         * are a continuation of the previous PES packet. New PES packets\n         * always start at the beginning of a PVA Packet, never somewhere in\n         * the middle. */\n        if (!pvactx->continue_pes) {\n            int pes_signal, pes_header_data_length, pes_packet_length,\n                pes_flags;\n            unsigned char pes_header_data[256];\n\n            pes_signal             = avio_rb24(pb);\n            avio_r8(pb);\n            pes_packet_length      = avio_rb16(pb);\n            pes_flags              = avio_rb16(pb);\n            pes_header_data_length = avio_r8(pb);\n\n            if (avio_feof(pb)) {\n                return AVERROR_EOF;\n            }\n\n            if (pes_signal != 1 || pes_header_data_length == 0) {\n                pva_log(s, AV_LOG_WARNING, \"expected non empty signaled PES packet, \"\n                                          \"trying to recover\\n\");\n                avio_skip(pb, length - 9);\n                if (!read_packet)\n                    return AVERROR(EIO);\n                goto recover;\n            }\n\n            ret = avio_read(pb, pes_header_data, pes_header_data_length);\n            if (ret != pes_header_data_length)\n                return ret < 0 ? ret : AVERROR_INVALIDDATA;\n            length -= 9 + pes_header_data_length;\n\n            pes_packet_length -= 3 + pes_header_data_length;\n\n            pvactx->continue_pes = pes_packet_length;\n\n            if (pes_flags & 0x80 && (pes_header_data[0] & 0xf0) == 0x20) {\n                if (pes_header_data_length < 5) {\n                    pva_log(s, AV_LOG_ERROR, \"header too short\\n\");\n                    avio_skip(pb, length);\n                    return AVERROR_INVALIDDATA;\n                }\n                pva_pts = ff_parse_pes_pts(pes_header_data);\n            }\n        }\n\n        pvactx->continue_pes -= length;\n\n        if (pvactx->continue_pes < 0) {\n            pva_log(s, AV_LOG_WARNING, \"audio data corruption\\n\");\n            pvactx->continue_pes = 0;\n        }\n    }\n\n    if (pva_pts != AV_NOPTS_VALUE)\n        av_add_index_entry(s->streams[streamid-1], startpos, pva_pts, 0, 0, AVINDEX_KEYFRAME);\n\n    *pts   = pva_pts;\n    *len   = length;\n    *strid = streamid;\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -53,6 +53,10 @@\n             pes_flags              = avio_rb16(pb);\n             pes_header_data_length = avio_r8(pb);\n \n+            if (avio_feof(pb)) {\n+                return AVERROR_EOF;\n+            }\n+\n             if (pes_signal != 1 || pes_header_data_length == 0) {\n                 pva_log(s, AV_LOG_WARNING, \"expected non empty signaled PES packet, \"\n                                           \"trying to recover\\n\");",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            if (avio_feof(pb)) {",
                "                return AVERROR_EOF;",
                "            }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14567",
        "func_name": "GNOME/libxml2/xz_decomp",
        "description": "libxml2 2.9.8, if --with-lzma is used, allows remote attackers to cause a denial of service (infinite loop) via a crafted XML file that triggers LZMA_MEMLIMIT_ERROR, as demonstrated by xmllint, a different vulnerability than CVE-2015-8035 and CVE-2018-9251.",
        "git_url": "https://github.com/GNOME/libxml2/commit/2240fbf5912054af025fb6e01e26375100275e74",
        "commit_title": "Fix infinite loop in LZMA decompression",
        "commit_text": " Check the liblzma error code more thoroughly to avoid infinite loops.  Closes: https://gitlab.gnome.org/GNOME/libxml2/issues/13 Closes: https://bugzilla.gnome.org/show_bug.cgi?id=794914  This is CVE-2018-9251 and CVE-2018-14567.  Thanks to Dongliang Mu and Simon Wrner for the reports.",
        "func_before": "static int\nxz_decomp(xz_statep state)\n{\n    int ret;\n    unsigned had;\n    unsigned long crc, len;\n    lzma_stream *strm = &(state->strm);\n\n    lzma_action action = LZMA_RUN;\n\n    /* fill output buffer up to end of deflate stream */\n    had = strm->avail_out;\n    do {\n        /* get more input for inflate() */\n        if (strm->avail_in == 0 && xz_avail(state) == -1)\n            return -1;\n        if (strm->avail_in == 0) {\n            xz_error(state, LZMA_DATA_ERROR, \"unexpected end of file\");\n            return -1;\n        }\n        if (state->eof)\n            action = LZMA_FINISH;\n\n        /* decompress and handle errors */\n#ifdef LIBXML_ZLIB_ENABLED\n        if (state->how == GZIP) {\n            state->zstrm.avail_in = (uInt) state->strm.avail_in;\n            state->zstrm.next_in = (Bytef *) state->strm.next_in;\n            state->zstrm.avail_out = (uInt) state->strm.avail_out;\n            state->zstrm.next_out = (Bytef *) state->strm.next_out;\n            ret = inflate(&state->zstrm, Z_NO_FLUSH);\n            if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {\n                xz_error(state, Z_STREAM_ERROR,\n                         \"internal error: inflate stream corrupt\");\n                return -1;\n            }\n            if (ret == Z_MEM_ERROR)\n                ret = LZMA_MEM_ERROR;\n            if (ret == Z_DATA_ERROR)\n                ret = LZMA_DATA_ERROR;\n            if (ret == Z_STREAM_END)\n                ret = LZMA_STREAM_END;\n            state->strm.avail_in = state->zstrm.avail_in;\n            state->strm.next_in = state->zstrm.next_in;\n            state->strm.avail_out = state->zstrm.avail_out;\n            state->strm.next_out = state->zstrm.next_out;\n        } else                  /* state->how == LZMA */\n#endif\n            ret = lzma_code(strm, action);\n        if (ret == LZMA_MEM_ERROR) {\n            xz_error(state, LZMA_MEM_ERROR, \"out of memory\");\n            return -1;\n        }\n        if (ret == LZMA_DATA_ERROR) {\n            xz_error(state, LZMA_DATA_ERROR, \"compressed data error\");\n            return -1;\n        }\n        if (ret == LZMA_PROG_ERROR) {\n            xz_error(state, LZMA_PROG_ERROR, \"compression error\");\n            return -1;\n        }\n    } while (strm->avail_out && ret != LZMA_STREAM_END);\n\n    /* update available output and crc check value */\n    state->have = had - strm->avail_out;\n    state->next = strm->next_out - state->have;\n#ifdef LIBXML_ZLIB_ENABLED\n    state->zstrm.adler =\n        crc32(state->zstrm.adler, state->next, state->have);\n#endif\n\n    if (ret == LZMA_STREAM_END) {\n#ifdef LIBXML_ZLIB_ENABLED\n        if (state->how == GZIP) {\n            if (gz_next4(state, &crc) == -1 || gz_next4(state, &len) == -1) {\n                xz_error(state, LZMA_DATA_ERROR, \"unexpected end of file\");\n                return -1;\n            }\n            if (crc != state->zstrm.adler) {\n                xz_error(state, LZMA_DATA_ERROR, \"incorrect data check\");\n                return -1;\n            }\n            if (len != (state->zstrm.total_out & 0xffffffffL)) {\n                xz_error(state, LZMA_DATA_ERROR, \"incorrect length check\");\n                return -1;\n            }\n            state->strm.avail_in = 0;\n            state->strm.next_in = NULL;\n            state->strm.avail_out = 0;\n            state->strm.next_out = NULL;\n        } else\n#endif\n        if (strm->avail_in != 0 || !state->eof) {\n            xz_error(state, LZMA_DATA_ERROR, \"trailing garbage\");\n            return -1;\n        }\n        state->how = LOOK;      /* ready for next stream, once have is 0 (leave\n                                 * state->direct unchanged to remember how) */\n    }\n\n    /* good decompression */\n    return 0;\n}",
        "func": "static int\nxz_decomp(xz_statep state)\n{\n    int ret;\n    unsigned had;\n    unsigned long crc, len;\n    lzma_stream *strm = &(state->strm);\n\n    lzma_action action = LZMA_RUN;\n\n    /* fill output buffer up to end of deflate stream */\n    had = strm->avail_out;\n    do {\n        /* get more input for inflate() */\n        if (strm->avail_in == 0 && xz_avail(state) == -1)\n            return -1;\n        if (strm->avail_in == 0) {\n            xz_error(state, LZMA_DATA_ERROR, \"unexpected end of file\");\n            return -1;\n        }\n        if (state->eof)\n            action = LZMA_FINISH;\n\n        /* decompress and handle errors */\n#ifdef LIBXML_ZLIB_ENABLED\n        if (state->how == GZIP) {\n            state->zstrm.avail_in = (uInt) state->strm.avail_in;\n            state->zstrm.next_in = (Bytef *) state->strm.next_in;\n            state->zstrm.avail_out = (uInt) state->strm.avail_out;\n            state->zstrm.next_out = (Bytef *) state->strm.next_out;\n            ret = inflate(&state->zstrm, Z_NO_FLUSH);\n            if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {\n                xz_error(state, Z_STREAM_ERROR,\n                         \"internal error: inflate stream corrupt\");\n                return -1;\n            }\n            /*\n             * FIXME: Remapping a couple of error codes and falling through\n             * to the LZMA error handling looks fragile.\n             */\n            if (ret == Z_MEM_ERROR)\n                ret = LZMA_MEM_ERROR;\n            if (ret == Z_DATA_ERROR)\n                ret = LZMA_DATA_ERROR;\n            if (ret == Z_STREAM_END)\n                ret = LZMA_STREAM_END;\n            state->strm.avail_in = state->zstrm.avail_in;\n            state->strm.next_in = state->zstrm.next_in;\n            state->strm.avail_out = state->zstrm.avail_out;\n            state->strm.next_out = state->zstrm.next_out;\n        } else                  /* state->how == LZMA */\n#endif\n            ret = lzma_code(strm, action);\n        if (ret == LZMA_MEM_ERROR) {\n            xz_error(state, LZMA_MEM_ERROR, \"out of memory\");\n            return -1;\n        }\n        if (ret == LZMA_DATA_ERROR) {\n            xz_error(state, LZMA_DATA_ERROR, \"compressed data error\");\n            return -1;\n        }\n        if (ret == LZMA_PROG_ERROR) {\n            xz_error(state, LZMA_PROG_ERROR, \"compression error\");\n            return -1;\n        }\n        if ((state->how != GZIP) &&\n            (ret != LZMA_OK) && (ret != LZMA_STREAM_END)) {\n            xz_error(state, ret, \"lzma error\");\n            return -1;\n        }\n    } while (strm->avail_out && ret != LZMA_STREAM_END);\n\n    /* update available output and crc check value */\n    state->have = had - strm->avail_out;\n    state->next = strm->next_out - state->have;\n#ifdef LIBXML_ZLIB_ENABLED\n    state->zstrm.adler =\n        crc32(state->zstrm.adler, state->next, state->have);\n#endif\n\n    if (ret == LZMA_STREAM_END) {\n#ifdef LIBXML_ZLIB_ENABLED\n        if (state->how == GZIP) {\n            if (gz_next4(state, &crc) == -1 || gz_next4(state, &len) == -1) {\n                xz_error(state, LZMA_DATA_ERROR, \"unexpected end of file\");\n                return -1;\n            }\n            if (crc != state->zstrm.adler) {\n                xz_error(state, LZMA_DATA_ERROR, \"incorrect data check\");\n                return -1;\n            }\n            if (len != (state->zstrm.total_out & 0xffffffffL)) {\n                xz_error(state, LZMA_DATA_ERROR, \"incorrect length check\");\n                return -1;\n            }\n            state->strm.avail_in = 0;\n            state->strm.next_in = NULL;\n            state->strm.avail_out = 0;\n            state->strm.next_out = NULL;\n        } else\n#endif\n        if (strm->avail_in != 0 || !state->eof) {\n            xz_error(state, LZMA_DATA_ERROR, \"trailing garbage\");\n            return -1;\n        }\n        state->how = LOOK;      /* ready for next stream, once have is 0 (leave\n                                 * state->direct unchanged to remember how) */\n    }\n\n    /* good decompression */\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -34,6 +34,10 @@\n                          \"internal error: inflate stream corrupt\");\n                 return -1;\n             }\n+            /*\n+             * FIXME: Remapping a couple of error codes and falling through\n+             * to the LZMA error handling looks fragile.\n+             */\n             if (ret == Z_MEM_ERROR)\n                 ret = LZMA_MEM_ERROR;\n             if (ret == Z_DATA_ERROR)\n@@ -57,6 +61,11 @@\n         }\n         if (ret == LZMA_PROG_ERROR) {\n             xz_error(state, LZMA_PROG_ERROR, \"compression error\");\n+            return -1;\n+        }\n+        if ((state->how != GZIP) &&\n+            (ret != LZMA_OK) && (ret != LZMA_STREAM_END)) {\n+            xz_error(state, ret, \"lzma error\");\n             return -1;\n         }\n     } while (strm->avail_out && ret != LZMA_STREAM_END);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            /*",
                "             * FIXME: Remapping a couple of error codes and falling through",
                "             * to the LZMA error handling looks fragile.",
                "             */",
                "            return -1;",
                "        }",
                "        if ((state->how != GZIP) &&",
                "            (ret != LZMA_OK) && (ret != LZMA_STREAM_END)) {",
                "            xz_error(state, ret, \"lzma error\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-15856",
        "func_name": "xkbcommon/libxkbcommon/lex",
        "description": "An infinite loop when reaching EOL unexpectedly in compose/parser.c (aka the keymap parser) in xkbcommon before 0.8.1 could be used by local attackers to cause a denial of service during parsing of crafted keymap files.",
        "git_url": "https://github.com/xkbcommon/libxkbcommon/commit/842e4351c2c97de6051cab6ce36b4a81e709a0e1",
        "commit_title": "compose: fix infinite loop in parser on some inputs",
        "commit_text": " The parser would enter an infinite loop if an unterminated keysym literal occurs at EOF.  Found with the afl fuzzer. ",
        "func_before": "static enum rules_token\nlex(struct scanner *s, union lvalue *val)\n{\nskip_more_whitespace_and_comments:\n    /* Skip spaces. */\n    while (is_space(peek(s)))\n        if (next(s) == '\\n')\n            return TOK_END_OF_LINE;\n\n    /* Skip comments. */\n    if (chr(s, '#')) {\n        skip_to_eol(s);\n        goto skip_more_whitespace_and_comments;\n    }\n\n    /* See if we're done. */\n    if (eof(s)) return TOK_END_OF_FILE;\n\n    /* New token. */\n    s->token_line = s->line;\n    s->token_column = s->column;\n    s->buf_pos = 0;\n\n    /* LHS Keysym. */\n    if (chr(s, '<')) {\n        while (peek(s) != '>' && !eol(s))\n            buf_append(s, next(s));\n        if (!chr(s, '>')) {\n            scanner_err(s, \"unterminated keysym literal\");\n            return TOK_ERROR;\n        }\n        if (!buf_append(s, '\\0')) {\n            scanner_err(s, \"keysym literal is too long\");\n            return TOK_ERROR;\n        }\n        val->string.str = s->buf;\n        val->string.len = s->buf_pos;\n        return TOK_LHS_KEYSYM;\n    }\n\n    /* Colon. */\n    if (chr(s, ':'))\n        return TOK_COLON;\n    if (chr(s, '!'))\n        return TOK_BANG;\n    if (chr(s, '~'))\n        return TOK_TILDE;\n\n    /* String literal. */\n    if (chr(s, '\\\"')) {\n        while (!eof(s) && !eol(s) && peek(s) != '\\\"') {\n            if (chr(s, '\\\\')) {\n                uint8_t o;\n                if (chr(s, '\\\\')) {\n                    buf_append(s, '\\\\');\n                }\n                else if (chr(s, '\"')) {\n                    buf_append(s, '\"');\n                }\n                else if (chr(s, 'x') || chr(s, 'X')) {\n                    if (hex(s, &o))\n                        buf_append(s, (char) o);\n                    else\n                        scanner_warn(s, \"illegal hexadecimal escape sequence in string literal\");\n                }\n                else if (oct(s, &o)) {\n                    buf_append(s, (char) o);\n                }\n                else {\n                    scanner_warn(s, \"unknown escape sequence (%c) in string literal\", peek(s));\n                    /* Ignore. */\n                }\n            } else {\n                buf_append(s, next(s));\n            }\n        }\n        if (!chr(s, '\\\"')) {\n            scanner_err(s, \"unterminated string literal\");\n            return TOK_ERROR;\n        }\n        if (!buf_append(s, '\\0')) {\n            scanner_err(s, \"string literal is too long\");\n            return TOK_ERROR;\n        }\n        if (!is_valid_utf8(s->buf, s->buf_pos - 1)) {\n            scanner_err(s, \"string literal is not a valid UTF-8 string\");\n            return TOK_ERROR;\n        }\n        val->string.str = s->buf;\n        val->string.len = s->buf_pos;\n        return TOK_STRING;\n    }\n\n    /* Identifier or include. */\n    if (is_alpha(peek(s)) || peek(s) == '_') {\n        s->buf_pos = 0;\n        while (is_alnum(peek(s)) || peek(s) == '_')\n            buf_append(s, next(s));\n        if (!buf_append(s, '\\0')) {\n            scanner_err(s, \"identifier is too long\");\n            return TOK_ERROR;\n        }\n\n        if (streq(s->buf, \"include\"))\n            return TOK_INCLUDE;\n\n        val->string.str = s->buf;\n        val->string.len = s->buf_pos;\n        return TOK_IDENT;\n    }\n\n    /* Discard rest of line. */\n    skip_to_eol(s);\n\n    scanner_err(s, \"unrecognized token\");\n    return TOK_ERROR;\n}",
        "func": "static enum rules_token\nlex(struct scanner *s, union lvalue *val)\n{\nskip_more_whitespace_and_comments:\n    /* Skip spaces. */\n    while (is_space(peek(s)))\n        if (next(s) == '\\n')\n            return TOK_END_OF_LINE;\n\n    /* Skip comments. */\n    if (chr(s, '#')) {\n        skip_to_eol(s);\n        goto skip_more_whitespace_and_comments;\n    }\n\n    /* See if we're done. */\n    if (eof(s)) return TOK_END_OF_FILE;\n\n    /* New token. */\n    s->token_line = s->line;\n    s->token_column = s->column;\n    s->buf_pos = 0;\n\n    /* LHS Keysym. */\n    if (chr(s, '<')) {\n        while (peek(s) != '>' && !eol(s) && !eof(s))\n            buf_append(s, next(s));\n        if (!chr(s, '>')) {\n            scanner_err(s, \"unterminated keysym literal\");\n            return TOK_ERROR;\n        }\n        if (!buf_append(s, '\\0')) {\n            scanner_err(s, \"keysym literal is too long\");\n            return TOK_ERROR;\n        }\n        val->string.str = s->buf;\n        val->string.len = s->buf_pos;\n        return TOK_LHS_KEYSYM;\n    }\n\n    /* Colon. */\n    if (chr(s, ':'))\n        return TOK_COLON;\n    if (chr(s, '!'))\n        return TOK_BANG;\n    if (chr(s, '~'))\n        return TOK_TILDE;\n\n    /* String literal. */\n    if (chr(s, '\\\"')) {\n        while (!eof(s) && !eol(s) && peek(s) != '\\\"') {\n            if (chr(s, '\\\\')) {\n                uint8_t o;\n                if (chr(s, '\\\\')) {\n                    buf_append(s, '\\\\');\n                }\n                else if (chr(s, '\"')) {\n                    buf_append(s, '\"');\n                }\n                else if (chr(s, 'x') || chr(s, 'X')) {\n                    if (hex(s, &o))\n                        buf_append(s, (char) o);\n                    else\n                        scanner_warn(s, \"illegal hexadecimal escape sequence in string literal\");\n                }\n                else if (oct(s, &o)) {\n                    buf_append(s, (char) o);\n                }\n                else {\n                    scanner_warn(s, \"unknown escape sequence (%c) in string literal\", peek(s));\n                    /* Ignore. */\n                }\n            } else {\n                buf_append(s, next(s));\n            }\n        }\n        if (!chr(s, '\\\"')) {\n            scanner_err(s, \"unterminated string literal\");\n            return TOK_ERROR;\n        }\n        if (!buf_append(s, '\\0')) {\n            scanner_err(s, \"string literal is too long\");\n            return TOK_ERROR;\n        }\n        if (!is_valid_utf8(s->buf, s->buf_pos - 1)) {\n            scanner_err(s, \"string literal is not a valid UTF-8 string\");\n            return TOK_ERROR;\n        }\n        val->string.str = s->buf;\n        val->string.len = s->buf_pos;\n        return TOK_STRING;\n    }\n\n    /* Identifier or include. */\n    if (is_alpha(peek(s)) || peek(s) == '_') {\n        s->buf_pos = 0;\n        while (is_alnum(peek(s)) || peek(s) == '_')\n            buf_append(s, next(s));\n        if (!buf_append(s, '\\0')) {\n            scanner_err(s, \"identifier is too long\");\n            return TOK_ERROR;\n        }\n\n        if (streq(s->buf, \"include\"))\n            return TOK_INCLUDE;\n\n        val->string.str = s->buf;\n        val->string.len = s->buf_pos;\n        return TOK_IDENT;\n    }\n\n    /* Discard rest of line. */\n    skip_to_eol(s);\n\n    scanner_err(s, \"unrecognized token\");\n    return TOK_ERROR;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,7 +23,7 @@\n \n     /* LHS Keysym. */\n     if (chr(s, '<')) {\n-        while (peek(s) != '>' && !eol(s))\n+        while (peek(s) != '>' && !eol(s) && !eof(s))\n             buf_append(s, next(s));\n         if (!chr(s, '>')) {\n             scanner_err(s, \"unterminated keysym literal\");",
        "diff_line_info": {
            "deleted_lines": [
                "        while (peek(s) != '>' && !eol(s))"
            ],
            "added_lines": [
                "        while (peek(s) != '>' && !eol(s) && !eof(s))"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-10938",
        "func_name": "torvalds/linux/cipso_v4_optptr",
        "description": "A flaw was found in the Linux kernel present since v4.0-rc1 and through v4.13-rc4. A crafted network packet sent remotely by an attacker may force the kernel to enter an infinite loop in the cipso_v4_optptr() function in net/ipv4/cipso_ipv4.c leading to a denial-of-service. A certain non-default configuration of LSM (Linux Security Module) and NetLabel should be set up on a system before an attacker could leverage this flaw.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=40413955ee265a5e42f710940ec78f5450d49149",
        "commit_title": "in for(),if((optlen > 0) && (optptr[1] == 0)), enter infinite loop.",
        "commit_text": " Test: receive a packet which the ip length > 20 and the first byte of ip option is 0, produce this issue  ",
        "func_before": "unsigned char *cipso_v4_optptr(const struct sk_buff *skb)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tunsigned char *optptr = (unsigned char *)&(ip_hdr(skb)[1]);\n\tint optlen;\n\tint taglen;\n\n\tfor (optlen = iph->ihl*4 - sizeof(struct iphdr); optlen > 0; ) {\n\t\tif (optptr[0] == IPOPT_CIPSO)\n\t\t\treturn optptr;\n\t\ttaglen = optptr[1];\n\t\toptlen -= taglen;\n\t\toptptr += taglen;\n\t}\n\n\treturn NULL;\n}",
        "func": "unsigned char *cipso_v4_optptr(const struct sk_buff *skb)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tunsigned char *optptr = (unsigned char *)&(ip_hdr(skb)[1]);\n\tint optlen;\n\tint taglen;\n\n\tfor (optlen = iph->ihl*4 - sizeof(struct iphdr); optlen > 0; ) {\n\t\tswitch (optptr[0]) {\n\t\tcase IPOPT_CIPSO:\n\t\t\treturn optptr;\n\t\tcase IPOPT_END:\n\t\t\treturn NULL;\n\t\tcase IPOPT_NOOP:\n\t\t\ttaglen = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttaglen = optptr[1];\n\t\t}\n\t\toptlen -= taglen;\n\t\toptptr += taglen;\n\t}\n\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,9 +6,17 @@\n \tint taglen;\n \n \tfor (optlen = iph->ihl*4 - sizeof(struct iphdr); optlen > 0; ) {\n-\t\tif (optptr[0] == IPOPT_CIPSO)\n+\t\tswitch (optptr[0]) {\n+\t\tcase IPOPT_CIPSO:\n \t\t\treturn optptr;\n-\t\ttaglen = optptr[1];\n+\t\tcase IPOPT_END:\n+\t\t\treturn NULL;\n+\t\tcase IPOPT_NOOP:\n+\t\t\ttaglen = 1;\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\ttaglen = optptr[1];\n+\t\t}\n \t\toptlen -= taglen;\n \t\toptptr += taglen;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (optptr[0] == IPOPT_CIPSO)",
                "\t\ttaglen = optptr[1];"
            ],
            "added_lines": [
                "\t\tswitch (optptr[0]) {",
                "\t\tcase IPOPT_CIPSO:",
                "\t\tcase IPOPT_END:",
                "\t\t\treturn NULL;",
                "\t\tcase IPOPT_NOOP:",
                "\t\t\ttaglen = 1;",
                "\t\t\tbreak;",
                "\t\tdefault:",
                "\t\t\ttaglen = optptr[1];",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19107",
        "func_name": "Exiv2/exiv2/PsdImage::readMetadata",
        "description": "In Exiv2 0.26, Exiv2::IptcParser::decode in iptc.cpp (called from psdimage.cpp in the PSD image reader) may suffer from a denial of service (heap-based buffer over-read) caused by an integer overflow via a crafted PSD image file.",
        "git_url": "https://github.com/Exiv2/exiv2/commit/b642b97fb9b08f188cfc7d461d60cd6bc971cbbf",
        "commit_title": "PSD: Use Safe::add for preventing overflows in PSD files",
        "commit_text": "",
        "func_before": "void PsdImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Exiv2::PsdImage::readMetadata: Reading Photoshop file \" << io_->path() << \"\\n\";\n#endif\n        if (io_->open() != 0)\n        {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        // Ensure that this is the correct image type\n        if (!isPsdType(*io_, false))\n        {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        clearMetadata();\n\n        /*\n          The Photoshop header goes as follows -- all numbers are in big-endian byte order:\n\n          offset  length   name       description\n          ======  =======  =========  =========\n           0      4 bytes  signature  always '8BPS'\n           4      2 bytes  version    always equal to 1\n           6      6 bytes  reserved   must be zero\n          12      2 bytes  channels   number of channels in the image, including alpha channels (1 to 24)\n          14      4 bytes  rows       the height of the image in pixels\n          18      4 bytes  columns    the width of the image in pixels\n          22      2 bytes  depth      the number of bits per channel\n          24      2 bytes  mode       the color mode of the file; Supported values are: Bitmap=0; Grayscale=1; Indexed=2; RGB=3; CMYK=4; Multichannel=7; Duotone=8; Lab=9\n        */\n        byte buf[26];\n        if (io_->read(buf, 26) != 26)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        pixelWidth_ = getLong(buf + 18, bigEndian);\n        pixelHeight_ = getLong(buf + 14, bigEndian);\n\n        // immediately following the image header is the color mode data section,\n        // the first four bytes of which specify the byte size of the whole section\n        if (io_->read(buf, 4) != 4)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n\n        // skip it\n        uint32_t colorDataLength = getULong(buf, bigEndian);\n        if (io_->seek(colorDataLength, BasicIo::cur))\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n\n        // after the color data section, comes a list of resource blocks, preceded by the total byte size\n        if (io_->read(buf, 4) != 4)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        uint32_t resourcesLength = getULong(buf, bigEndian);\n        while (resourcesLength > 0)\n        {\n            if (io_->read(buf, 8) != 8)\n            {\n                throw Error(kerNotAnImage, \"Photoshop\");\n            }\n\n            if (!Photoshop::isIrb(buf, 4))\n            {\n                break; // bad resource type\n            }\n            uint16_t resourceId = getUShort(buf + 4, bigEndian);\n            uint32_t resourceNameLength = buf[6] & ~1;\n\n            // skip the resource name, plus any padding\n            io_->seek(resourceNameLength, BasicIo::cur);\n\n            // read resource size\n            if (io_->read(buf, 4) != 4)\n            {\n                throw Error(kerNotAnImage, \"Photoshop\");\n            }\n            uint32_t resourceSize = getULong(buf, bigEndian);\n            uint32_t curOffset = io_->tell();\n\n#ifdef DEBUG\n        std::cerr << std::hex << \"resourceId: \" << resourceId << std::dec << \" length: \" << resourceSize << std::hex << \"\\n\";\n#endif\n\n            readResourceBlock(resourceId, resourceSize);\n            resourceSize = (resourceSize + 1) & ~1;        // pad to even\n            io_->seek(curOffset + resourceSize, BasicIo::beg);\n            resourcesLength -= (12 + resourceNameLength + resourceSize);\n        }\n\n    }",
        "func": "void PsdImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Exiv2::PsdImage::readMetadata: Reading Photoshop file \" << io_->path() << \"\\n\";\n#endif\n        if (io_->open() != 0)\n        {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        // Ensure that this is the correct image type\n        if (!isPsdType(*io_, false))\n        {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        clearMetadata();\n\n        /*\n          The Photoshop header goes as follows -- all numbers are in big-endian byte order:\n\n          offset  length   name       description\n          ======  =======  =========  =========\n           0      4 bytes  signature  always '8BPS'\n           4      2 bytes  version    always equal to 1\n           6      6 bytes  reserved   must be zero\n          12      2 bytes  channels   number of channels in the image, including alpha channels (1 to 24)\n          14      4 bytes  rows       the height of the image in pixels\n          18      4 bytes  columns    the width of the image in pixels\n          22      2 bytes  depth      the number of bits per channel\n          24      2 bytes  mode       the color mode of the file; Supported values are: Bitmap=0; Grayscale=1; Indexed=2; RGB=3; CMYK=4; Multichannel=7; Duotone=8; Lab=9\n        */\n        byte buf[26];\n        if (io_->read(buf, 26) != 26)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        pixelWidth_ = getLong(buf + 18, bigEndian);\n        pixelHeight_ = getLong(buf + 14, bigEndian);\n\n        // immediately following the image header is the color mode data section,\n        // the first four bytes of which specify the byte size of the whole section\n        if (io_->read(buf, 4) != 4)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n\n        // skip it\n        uint32_t colorDataLength = getULong(buf, bigEndian);\n        if (io_->seek(colorDataLength, BasicIo::cur))\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n\n        // after the color data section, comes a list of resource blocks, preceded by the total byte size\n        if (io_->read(buf, 4) != 4)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        uint32_t resourcesLength = getULong(buf, bigEndian);\n        while (resourcesLength > 0)\n        {\n            if (io_->read(buf, 8) != 8)\n            {\n                throw Error(kerNotAnImage, \"Photoshop\");\n            }\n\n            if (!Photoshop::isIrb(buf, 4))\n            {\n                break; // bad resource type\n            }\n            uint16_t resourceId = getUShort(buf + 4, bigEndian);\n            uint32_t resourceNameLength = buf[6] & ~1;\n\n            // skip the resource name, plus any padding\n            io_->seek(resourceNameLength, BasicIo::cur);\n\n            // read resource size\n            if (io_->read(buf, 4) != 4)\n            {\n                throw Error(kerNotAnImage, \"Photoshop\");\n            }\n            uint32_t resourceSize = getULong(buf, bigEndian);\n            uint32_t curOffset = io_->tell();\n\n#ifdef DEBUG\n        std::cerr << std::hex << \"resourceId: \" << resourceId << std::dec << \" length: \" << resourceSize << std::hex << \"\\n\";\n#endif\n\n            readResourceBlock(resourceId, resourceSize);\n            resourceSize = (resourceSize + 1) & ~1;        // pad to even\n            io_->seek(curOffset + resourceSize, BasicIo::beg);\n            resourcesLength -= Safe::add(Safe::add(static_cast<uint32_t>(12), resourceNameLength),\n                                         resourceSize);\n        }\n\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -90,7 +90,8 @@\n             readResourceBlock(resourceId, resourceSize);\n             resourceSize = (resourceSize + 1) & ~1;        // pad to even\n             io_->seek(curOffset + resourceSize, BasicIo::beg);\n-            resourcesLength -= (12 + resourceNameLength + resourceSize);\n+            resourcesLength -= Safe::add(Safe::add(static_cast<uint32_t>(12), resourceNameLength),\n+                                         resourceSize);\n         }\n \n     }",
        "diff_line_info": {
            "deleted_lines": [
                "            resourcesLength -= (12 + resourceNameLength + resourceSize);"
            ],
            "added_lines": [
                "            resourcesLength -= Safe::add(Safe::add(static_cast<uint32_t>(12), resourceNameLength),",
                "                                         resourceSize);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19107",
        "func_name": "Exiv2/exiv2/PsdImage::readMetadata",
        "description": "In Exiv2 0.26, Exiv2::IptcParser::decode in iptc.cpp (called from psdimage.cpp in the PSD image reader) may suffer from a denial of service (heap-based buffer over-read) caused by an integer overflow via a crafted PSD image file.",
        "git_url": "https://github.com/Exiv2/exiv2/commit/e4b3bdd712566ffefeec9809043bdfb843e42f53",
        "commit_title": "PSD: enforce Length of image resource section < file size",
        "commit_text": "",
        "func_before": "void PsdImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Exiv2::PsdImage::readMetadata: Reading Photoshop file \" << io_->path() << \"\\n\";\n#endif\n        if (io_->open() != 0)\n        {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        // Ensure that this is the correct image type\n        if (!isPsdType(*io_, false))\n        {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        clearMetadata();\n\n        /*\n          The Photoshop header goes as follows -- all numbers are in big-endian byte order:\n\n          offset  length   name       description\n          ======  =======  =========  =========\n           0      4 bytes  signature  always '8BPS'\n           4      2 bytes  version    always equal to 1\n           6      6 bytes  reserved   must be zero\n          12      2 bytes  channels   number of channels in the image, including alpha channels (1 to 24)\n          14      4 bytes  rows       the height of the image in pixels\n          18      4 bytes  columns    the width of the image in pixels\n          22      2 bytes  depth      the number of bits per channel\n          24      2 bytes  mode       the color mode of the file; Supported values are: Bitmap=0; Grayscale=1; Indexed=2; RGB=3; CMYK=4; Multichannel=7; Duotone=8; Lab=9\n        */\n        byte buf[26];\n        if (io_->read(buf, 26) != 26)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        pixelWidth_ = getLong(buf + 18, bigEndian);\n        pixelHeight_ = getLong(buf + 14, bigEndian);\n\n        // immediately following the image header is the color mode data section,\n        // the first four bytes of which specify the byte size of the whole section\n        if (io_->read(buf, 4) != 4)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n\n        // skip it\n        uint32_t colorDataLength = getULong(buf, bigEndian);\n        if (io_->seek(colorDataLength, BasicIo::cur))\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n\n        // after the color data section, comes a list of resource blocks, preceded by the total byte size\n        if (io_->read(buf, 4) != 4)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        uint32_t resourcesLength = getULong(buf, bigEndian);\n        while (resourcesLength > 0)\n        {\n            if (io_->read(buf, 8) != 8)\n            {\n                throw Error(kerNotAnImage, \"Photoshop\");\n            }\n\n            if (!Photoshop::isIrb(buf, 4))\n            {\n                break; // bad resource type\n            }\n            uint16_t resourceId = getUShort(buf + 4, bigEndian);\n            uint32_t resourceNameLength = buf[6] & ~1;\n\n            // skip the resource name, plus any padding\n            io_->seek(resourceNameLength, BasicIo::cur);\n\n            // read resource size\n            if (io_->read(buf, 4) != 4)\n            {\n                throw Error(kerNotAnImage, \"Photoshop\");\n            }\n            uint32_t resourceSize = getULong(buf, bigEndian);\n            uint32_t curOffset = io_->tell();\n\n#ifdef DEBUG\n        std::cerr << std::hex << \"resourceId: \" << resourceId << std::dec << \" length: \" << resourceSize << std::hex << \"\\n\";\n#endif\n\n            readResourceBlock(resourceId, resourceSize);\n            resourceSize = (resourceSize + 1) & ~1;        // pad to even\n            io_->seek(curOffset + resourceSize, BasicIo::beg);\n            resourcesLength -= Safe::add(Safe::add(static_cast<uint32_t>(12), resourceNameLength),\n                                         resourceSize);\n        }\n\n    }",
        "func": "void PsdImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Exiv2::PsdImage::readMetadata: Reading Photoshop file \" << io_->path() << \"\\n\";\n#endif\n        if (io_->open() != 0)\n        {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        // Ensure that this is the correct image type\n        if (!isPsdType(*io_, false))\n        {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        clearMetadata();\n\n        /*\n          The Photoshop header goes as follows -- all numbers are in big-endian byte order:\n\n          offset  length   name       description\n          ======  =======  =========  =========\n           0      4 bytes  signature  always '8BPS'\n           4      2 bytes  version    always equal to 1\n           6      6 bytes  reserved   must be zero\n          12      2 bytes  channels   number of channels in the image, including alpha channels (1 to 24)\n          14      4 bytes  rows       the height of the image in pixels\n          18      4 bytes  columns    the width of the image in pixels\n          22      2 bytes  depth      the number of bits per channel\n          24      2 bytes  mode       the color mode of the file; Supported values are: Bitmap=0; Grayscale=1; Indexed=2; RGB=3; CMYK=4; Multichannel=7; Duotone=8; Lab=9\n        */\n        byte buf[26];\n        if (io_->read(buf, 26) != 26)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        pixelWidth_ = getLong(buf + 18, bigEndian);\n        pixelHeight_ = getLong(buf + 14, bigEndian);\n\n        // immediately following the image header is the color mode data section,\n        // the first four bytes of which specify the byte size of the whole section\n        if (io_->read(buf, 4) != 4)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n\n        // skip it\n        uint32_t colorDataLength = getULong(buf, bigEndian);\n        if (io_->seek(colorDataLength, BasicIo::cur))\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n\n        // after the color data section, comes a list of resource blocks, preceded by the total byte size\n        if (io_->read(buf, 4) != 4)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        uint32_t resourcesLength = getULong(buf, bigEndian);\n        enforce(resourcesLength < io_->size(), Exiv2::kerCorruptedMetadata);\n\n        while (resourcesLength > 0)\n        {\n            if (io_->read(buf, 8) != 8)\n            {\n                throw Error(kerNotAnImage, \"Photoshop\");\n            }\n\n            if (!Photoshop::isIrb(buf, 4))\n            {\n                break; // bad resource type\n            }\n            uint16_t resourceId = getUShort(buf + 4, bigEndian);\n            uint32_t resourceNameLength = buf[6] & ~1;\n\n            // skip the resource name, plus any padding\n            io_->seek(resourceNameLength, BasicIo::cur);\n\n            // read resource size\n            if (io_->read(buf, 4) != 4)\n            {\n                throw Error(kerNotAnImage, \"Photoshop\");\n            }\n            uint32_t resourceSize = getULong(buf, bigEndian);\n            uint32_t curOffset = io_->tell();\n\n#ifdef DEBUG\n        std::cerr << std::hex << \"resourceId: \" << resourceId << std::dec << \" length: \" << resourceSize << std::hex << \"\\n\";\n#endif\n\n            readResourceBlock(resourceId, resourceSize);\n            resourceSize = (resourceSize + 1) & ~1;        // pad to even\n            io_->seek(curOffset + resourceSize, BasicIo::beg);\n            resourcesLength -= Safe::add(Safe::add(static_cast<uint32_t>(12), resourceNameLength),\n                                         resourceSize);\n        }\n\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -58,6 +58,8 @@\n             throw Error(kerNotAnImage, \"Photoshop\");\n         }\n         uint32_t resourcesLength = getULong(buf, bigEndian);\n+        enforce(resourcesLength < io_->size(), Exiv2::kerCorruptedMetadata);\n+\n         while (resourcesLength > 0)\n         {\n             if (io_->read(buf, 8) != 8)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        enforce(resourcesLength < io_->size(), Exiv2::kerCorruptedMetadata);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19622",
        "func_name": "wireshark/get_value_length",
        "description": "In Wireshark 2.6.0 to 2.6.4 and 2.4.0 to 2.4.10, the MMSE dissector could go into an infinite loop. This was addressed in epan/dissectors/packet-mmse.c by preventing length overflows.",
        "git_url": "https://github.com/wireshark/wireshark/commit/3b7555d32d11862f0e500ec466ad6bfe54190076",
        "commit_title": "MMSE: catch length overflows to avoid infinite loop.",
        "commit_text": " After fetching a length from the packet ensure those bytes exist to avoid integer overflows by callers (while avoiding having to ensure every caller checks for overflows).  Also add a check to ensure the loop in question is progressing through the TVB; report a dissector bug if it doesn't.  Bug: 15250 Bug: 15246 (cherry picked from commit 1ddaf1a0944ffe95d69717ac9fdc60824932f676)",
        "func_before": "static guint\nget_value_length(tvbuff_t *tvb, guint offset, guint *byte_count, packet_info *pinfo)\n{\n    guint        field;\n\n    field = tvb_get_guint8(tvb, offset++);\n    if (field < 31)\n        *byte_count = 1;\n    else {                      /* Must be 31 so, Uintvar follows       */\n        field = tvb_get_guintvar(tvb, offset, byte_count, pinfo, &ei_mmse_oversized_uintvar);\n        (*byte_count)++;\n    }\n    return field;\n}",
        "func": "static guint\nget_value_length(tvbuff_t *tvb, guint offset, guint *byte_count, packet_info *pinfo)\n{\n    guint        field;\n\n    field = tvb_get_guint8(tvb, offset++);\n    if (field < 31)\n        *byte_count = 1;\n    else {                      /* Must be 31 so, Uintvar follows       */\n        field = tvb_get_guintvar(tvb, offset, byte_count, pinfo, &ei_mmse_oversized_uintvar);\n        (*byte_count)++;\n    }\n\n    /* The packet says there are this many bytes; ensure they're there.\n     * We do this here because several callers do math on the length we\n     * return here and may not catch an overflow.\n     */\n    tvb_ensure_bytes_exist(tvb, offset, field);\n    return field;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,5 +10,11 @@\n         field = tvb_get_guintvar(tvb, offset, byte_count, pinfo, &ei_mmse_oversized_uintvar);\n         (*byte_count)++;\n     }\n+\n+    /* The packet says there are this many bytes; ensure they're there.\n+     * We do this here because several callers do math on the length we\n+     * return here and may not catch an overflow.\n+     */\n+    tvb_ensure_bytes_exist(tvb, offset, field);\n     return field;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    /* The packet says there are this many bytes; ensure they're there.",
                "     * We do this here because several callers do math on the length we",
                "     * return here and may not catch an overflow.",
                "     */",
                "    tvb_ensure_bytes_exist(tvb, offset, field);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19622",
        "func_name": "wireshark/dissect_mmse",
        "description": "In Wireshark 2.6.0 to 2.6.4 and 2.4.0 to 2.4.10, the MMSE dissector could go into an infinite loop. This was addressed in epan/dissectors/packet-mmse.c by preventing length overflows.",
        "git_url": "https://github.com/wireshark/wireshark/commit/3b7555d32d11862f0e500ec466ad6bfe54190076",
        "commit_title": "MMSE: catch length overflows to avoid infinite loop.",
        "commit_text": " After fetching a length from the packet ensure those bytes exist to avoid integer overflows by callers (while avoiding having to ensure every caller checks for overflows).  Also add a check to ensure the loop in question is progressing through the TVB; report a dissector bug if it doesn't.  Bug: 15250 Bug: 15246 (cherry picked from commit 1ddaf1a0944ffe95d69717ac9fdc60824932f676)",
        "func_before": "static void\ndissect_mmse(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint8 pdut,\n        const char *message_type)\n{\n    guint        offset;\n    guint8       field = 0;\n    const char   *strval;\n    guint        length;\n    guint        count;\n    guint8       version = 0x80; /* Default to MMSE 1.0 */\n\n    /* Set up structures needed to add the protocol subtree and manage it */\n    proto_item  *ti = NULL;\n    proto_tree  *mmse_tree = NULL;\n\n    DebugLog((\"dissect_mmse() - START (Packet %u)\\n\", pinfo->num));\n\n    ti = proto_tree_add_item(tree, proto_mmse, tvb, 0, -1, ENC_NA);\n    proto_item_append_text(ti, \", Type: %s\", message_type);\n    /* create display subtree for the protocol */\n    mmse_tree = proto_item_add_subtree(ti, ett_mmse);\n\n    /* Report PDU-type      */\n    proto_tree_add_uint(mmse_tree, hf_mmse_message_type, tvb, 0, 2, pdut);\n\n    offset = 2;                 /* Skip Message-Type    */\n\n    /*\n     * Cycle through MMS-headers\n     *\n     * NOTE - some PDUs may convey content that can be handed off\n     *        to subdissectors.\n     */\n    if (tree == NULL && !pdu_has_content(pdut)) {\n        DebugLog((\"tree == NULL and PDU has no potential content\\n\"));\n        return;\n    }\n\n    while ((offset < tvb_reported_length(tvb)) &&\n            (field = tvb_get_guint8(tvb, offset++)) != MM_CTYPE_HDR)\n    {\n        DebugLog((\"\\tField =  0x%02X (offset = %u): %s\\n\",\n                    field, offset,\n                    val_to_str(field, vals_mm_header_names,\n                        \"Unknown MMS header 0x%02X\")));\n        switch (field)\n        {\n            case MM_TID_HDR:                /* Text-string  */\n                length = get_text_string(tvb, offset, &strval);\n                proto_tree_add_string(mmse_tree, hf_mmse_transaction_id,\n                        tvb, offset - 1, length + 1,strval);\n                offset += length;\n                break;\n            case MM_VERSION_HDR:            /* nibble-Major/nibble-minor*/\n                {\n                    guint8   major, minor;\n                    char    *vers_string;\n\n                    version = tvb_get_guint8(tvb, offset++);\n                    major = (version & 0x70) >> 4;\n                    minor = version & 0x0F;\n                    if (minor == 0x0F)\n                        vers_string = wmem_strdup_printf(wmem_packet_scope(), \"%u\", major);\n                    else\n                        vers_string = wmem_strdup_printf(wmem_packet_scope(), \"%u.%u\", major, minor);\n                    proto_tree_add_string(mmse_tree, hf_mmse_mms_version,\n                            tvb, offset - 2, 2, vers_string);\n                }\n                break;\n            case MM_BCC_HDR:                /* Encoded-string-value */\n                length = get_encoded_strval(tvb, offset, &strval, pinfo);\n                proto_tree_add_string(mmse_tree, hf_mmse_bcc, tvb,\n                        offset - 1, length + 1, strval);\n                offset += length;\n                break;\n            case MM_CC_HDR:                 /* Encoded-string-value */\n                length = get_encoded_strval(tvb, offset, &strval, pinfo);\n                proto_tree_add_string(mmse_tree, hf_mmse_cc, tvb,\n                        offset - 1, length + 1, strval);\n                offset += length;\n                break;\n            case MM_CLOCATION_HDR:          /* Uri-value            */\n                if (pdut == PDU_M_MBOX_DELETE_CONF) {\n                    /* General form with length */\n                    length = tvb_get_guint8(tvb, offset);\n                    if (length == 0x1F) {\n                        guint length_len = 0;\n                        length = tvb_get_guintvar(tvb, offset + 1,\n                                &length_len, pinfo, &ei_mmse_oversized_uintvar);\n                        length += 1 + length_len;\n                    } else {\n                        length += 1;\n                    }\n                    proto_tree_add_string(mmse_tree,\n                            hf_mmse_content_location,\n                            tvb, offset - 1, length + 1,\n                            \"<Undecoded value for m-mbox-delete-conf>\");\n                } else {\n                    length = get_text_string(tvb, offset, &strval);\n                    proto_tree_add_string(mmse_tree,\n                            hf_mmse_content_location,\n                            tvb, offset - 1, length + 1, strval);\n                }\n                offset += length;\n                break;\n            case MM_DATE_HDR:               /* Long-integer         */\n                {\n                    guint            tval;\n                    nstime_t         tmptime;\n\n                    tval = get_long_integer(tvb, offset, &count);\n                    tmptime.secs = tval;\n                    tmptime.nsecs = 0;\n                    proto_tree_add_time(mmse_tree, hf_mmse_date, tvb,\n                            offset - 1, count + 1, &tmptime);\n                }\n                offset += count;\n                break;\n            case MM_DREPORT_HDR:            /* Yes|No               */\n                field = tvb_get_guint8(tvb, offset++);\n                proto_tree_add_uint(mmse_tree,\n                        hf_mmse_delivery_report,\n                        tvb, offset - 2, 2, field);\n                break;\n            case MM_DTIME_HDR:\n                {\n                    guint            tval;\n                    nstime_t         tmptime;\n                    guint            cnt;\n\n                    /*\n                     * Value-length(Absolute-token Date-value|\n                     *              Relative-token Delta-seconds-value)\n                     */\n                    length = get_value_length(tvb, offset, &count, pinfo);\n                    field = tvb_get_guint8(tvb, offset + count);\n\n                    tval =  get_long_integer(tvb, offset + count + 1, &cnt);\n                    tmptime.secs = tval;\n                    tmptime.nsecs = 0;\n\n                    if (field == 0x80)\n                        proto_tree_add_time(mmse_tree,\n                                hf_mmse_delivery_time_abs,\n                                tvb, offset - 1,\n                                length + count + 1, &tmptime);\n                    else\n                        proto_tree_add_time(mmse_tree,\n                                hf_mmse_delivery_time_rel,\n                                tvb, offset - 1,\n                                length + count + 1, &tmptime);\n                }\n                offset += length + count;\n                break;\n            case MM_EXPIRY_HDR:\n                {\n                    guint            tval;\n                    nstime_t         tmptime;\n                    guint            cnt;\n\n                    /*\n                     * Value-length(Absolute-token Date-value|\n                     *              Relative-token Delta-seconds-value)\n                     */\n                    length = get_value_length(tvb, offset, &count, pinfo);\n                    field = tvb_get_guint8(tvb, offset + count);\n\n                    tval = get_long_integer(tvb, offset + count + 1, &cnt);\n                    tmptime.secs = tval;\n                    tmptime.nsecs = 0;\n\n                    if (field == 0x80)\n                        proto_tree_add_time(mmse_tree, hf_mmse_expiry_abs,\n                                tvb, offset - 1,\n                                length + count + 1, &tmptime);\n                    else\n                        proto_tree_add_time(mmse_tree, hf_mmse_expiry_rel,\n                                tvb, offset - 1,\n                                length + count + 1, &tmptime);\n                }\n                offset += length + count;\n                break;\n            case MM_FROM_HDR:\n                /*\n                 * Value-length(Address-present-token Encoded-string-value\n                 *              |Insert-address-token)\n                 */\n                length = get_value_length(tvb, offset, &count, pinfo);\n                field = tvb_get_guint8(tvb, offset + count);\n                if (field == 0x81) {\n                    proto_tree_add_string(mmse_tree, hf_mmse_from, tvb,\n                            offset-1, length + count + 1,\n                            \"<insert address>\");\n                } else {\n                    (void) get_encoded_strval(tvb, offset + count + 1,\n                            &strval, pinfo);\n                    proto_tree_add_string(mmse_tree, hf_mmse_from, tvb,\n                            offset-1, length + count + 1, strval);\n                }\n                offset += length + count;\n                break;\n            case MM_MCLASS_HDR:\n                /*\n                 * Class-identifier|Text-string\n                 */\n                field = tvb_get_guint8(tvb, offset);\n                if (field & 0x80) {\n                    offset++;\n                    proto_tree_add_uint(mmse_tree,\n                            hf_mmse_message_class_id,\n                            tvb, offset - 2, 2, field);\n                } else {\n                    length = get_text_string(tvb, offset, &strval);\n                    proto_tree_add_string(mmse_tree,\n                            hf_mmse_message_class_str,\n                            tvb, offset - 1, length + 1,\n                            strval);\n                    offset += length;\n                }\n                break;\n            case MM_MID_HDR:                /* Text-string          */\n                length = get_text_string(tvb, offset, &strval);\n                proto_tree_add_string(mmse_tree, hf_mmse_message_id,\n                        tvb, offset - 1, length + 1, strval);\n                offset += length;\n                break;\n            case MM_MSIZE_HDR:              /* Long-integer         */\n                length = get_long_integer(tvb, offset, &count);\n                proto_tree_add_uint(mmse_tree, hf_mmse_message_size,\n                        tvb, offset - 1, count + 1, length);\n                offset += count;\n                break;\n            case MM_PRIORITY_HDR:           /* Low|Normal|High      */\n                field = tvb_get_guint8(tvb, offset++);\n                proto_tree_add_uint(mmse_tree, hf_mmse_priority, tvb,\n                        offset - 2, 2, field);\n                break;\n            case MM_RREPLY_HDR:             /* Yes|No               */\n                field = tvb_get_guint8(tvb, offset++);\n                if (version == 0x80) { /* MMSE 1.0 */\n                    proto_tree_add_uint(mmse_tree, hf_mmse_read_reply,\n                            tvb, offset - 2, 2, field);\n                } else {\n                    proto_tree_add_uint(mmse_tree, hf_mmse_read_report,\n                            tvb, offset - 2, 2, field);\n                }\n                break;\n            case MM_RALLOWED_HDR:           /* Yes|No               */\n                field = tvb_get_guint8(tvb, offset++);\n                proto_tree_add_uint(mmse_tree, hf_mmse_report_allowed,\n                        tvb, offset - 2, 2, field);\n                break;\n            case MM_RSTATUS_HDR:\n                field = tvb_get_guint8(tvb, offset++);\n                proto_tree_add_uint(mmse_tree, hf_mmse_response_status,\n                        tvb, offset - 2, 2, field);\n                break;\n            case MM_RTEXT_HDR:              /* Encoded-string-value */\n                if (pdut == PDU_M_MBOX_DELETE_CONF) {\n                    /* General form with length */\n                    length = tvb_get_guint8(tvb, offset);\n                    if (length == 0x1F) {\n                        guint length_len = 0;\n                        length = tvb_get_guintvar(tvb, offset + 1,\n                                &length_len, pinfo, &ei_mmse_oversized_uintvar);\n                        length += 1 + length_len;\n                    } else {\n                        length += 1;\n                    }\n                    proto_tree_add_string(mmse_tree,\n                            hf_mmse_content_location,\n                            tvb, offset - 1, length + 1,\n                            \"<Undecoded value for m-mbox-delete-conf>\");\n                } else {\n                    length = get_encoded_strval(tvb, offset, &strval, pinfo);\n                    proto_tree_add_string(mmse_tree,\n                            hf_mmse_response_text, tvb, offset - 1,\n                            length + 1, strval);\n                }\n                offset += length;\n                break;\n            case MM_SVISIBILITY_HDR:        /* Hide|Show            */\n                field = tvb_get_guint8(tvb, offset++);\n                proto_tree_add_uint(mmse_tree,hf_mmse_sender_visibility,\n                        tvb, offset - 2, 2, field);\n                break;\n            case MM_STATUS_HDR:\n                field = tvb_get_guint8(tvb, offset++);\n                proto_tree_add_uint(mmse_tree, hf_mmse_status, tvb,\n                        offset - 2, 2, field);\n                break;\n            case MM_SUBJECT_HDR:            /* Encoded-string-value */\n                length = get_encoded_strval(tvb, offset, &strval, pinfo);\n                proto_tree_add_string(mmse_tree, hf_mmse_subject, tvb,\n                        offset - 1, length + 1, strval);\n                offset += length;\n                break;\n            case MM_TO_HDR:                 /* Encoded-string-value */\n                length = get_encoded_strval(tvb, offset, &strval, pinfo);\n                proto_tree_add_string(mmse_tree, hf_mmse_to, tvb,\n                        offset - 1, length + 1, strval);\n                offset += length;\n                break;\n\n                /*\n                 * MMS Encapsulation 1.1\n                 */\n            case MM_RETRIEVE_STATUS_HDR:    /* Well-known-value */\n                field = tvb_get_guint8(tvb, offset++);\n                proto_tree_add_uint(mmse_tree, hf_mmse_retrieve_status,\n                        tvb, offset - 2, 2, field);\n                break;\n            case MM_RETRIEVE_TEXT_HDR:\n                if (pdut == PDU_M_MBOX_DELETE_CONF) {\n                    /* General form with length */\n                    length = tvb_get_guint8(tvb, offset);\n                    if (length == 0x1F) {\n                        guint length_len = 0;\n                        length = tvb_get_guintvar(tvb, offset + 1,\n                                &length_len, pinfo, &ei_mmse_oversized_uintvar);\n                        length += 1 + length_len;\n                    } else {\n                        length += 1;\n                    }\n\n                    proto_tree_add_string(mmse_tree,\n                            hf_mmse_content_location,\n                            tvb, offset - 1, length + 1,\n                            \"<Undecoded value for m-mbox-delete-conf>\");\n                } else {\n                    /* Encoded-string-value */\n                    length = get_encoded_strval(tvb, offset, &strval, pinfo);\n                    proto_tree_add_string(mmse_tree,\n                            hf_mmse_retrieve_text, tvb, offset - 1,\n                            length + 1, strval);\n                }\n                offset += length;\n                break;\n            case MM_READ_STATUS_HDR:        /* Well-known-value */\n                field = tvb_get_guint8(tvb, offset++);\n                proto_tree_add_uint(mmse_tree, hf_mmse_read_status,\n                        tvb, offset - 2, 2, field);\n                break;\n            case MM_REPLY_CHARGING_HDR:     /* Well-known-value */\n                field = tvb_get_guint8(tvb, offset++);\n                proto_tree_add_uint(mmse_tree, hf_mmse_reply_charging,\n                        tvb, offset - 2, 2, field);\n                break;\n            case MM_REPLY_CHARGING_DEADLINE_HDR:    /* Well-known-value */\n                {\n                    guint            tval;\n                    nstime_t         tmptime;\n                    guint            cnt;\n\n                    /*\n                     * Value-length(Absolute-token Date-value|\n                     *              Relative-token Delta-seconds-value)\n                     */\n\n                    length = get_value_length(tvb, offset, &count, pinfo);\n                    field = tvb_get_guint8(tvb, offset + count);\n\n                    tval = get_long_integer(tvb, offset + count + 1, &cnt);\n                    tmptime.secs = tval;\n                    tmptime.nsecs = 0;\n\n                    if (field == 0x80)\n                        proto_tree_add_time(mmse_tree, hf_mmse_reply_charging_deadline_abs,\n                                tvb, offset - 1,\n                                length + count + 1, &tmptime);\n                    else\n                        proto_tree_add_time(mmse_tree, hf_mmse_reply_charging_deadline_rel,\n                                tvb, offset - 1,\n                                length + count + 1, &tmptime);\n                }\n                offset += length + count;\n                break;\n            case MM_REPLY_CHARGING_ID_HDR:  /* Text-string */\n                length = get_text_string(tvb, offset, &strval);\n                proto_tree_add_string(mmse_tree,\n                        hf_mmse_reply_charging_id,\n                        tvb, offset - 1, length + 1, strval);\n                offset += length;\n                break;\n            case MM_REPLY_CHARGING_SIZE_HDR:        /* Long-integer */\n                length = get_long_integer(tvb, offset, &count);\n                proto_tree_add_uint(mmse_tree,\n                        hf_mmse_reply_charging_size,\n                        tvb, offset - 1, count + 1, length);\n                offset += count;\n                break;\n            case MM_PREV_SENT_BY_HDR:\n                {\n                    guint32 fwd_count, count1, count2;\n                    proto_tree *subtree = NULL;\n                    proto_item *tii = NULL;\n\n                    /* Value-length Integer-value Encoded-string-value */\n                    length = get_value_length(tvb, offset, &count, pinfo);\n\n                    /* 1. Forwarded-count-value := Integer-value */\n                    fwd_count = get_integer_value(tvb, offset + count,\n                            &count1);\n                    /* 2. Encoded-string-value */\n                    count2 = get_encoded_strval(tvb,\n                            offset + count + count1, &strval, pinfo);\n                    /* Now render the fields */\n                    tii = proto_tree_add_string_format(mmse_tree,\n                            hf_mmse_prev_sent_by,\n                            tvb, offset - 1, 1 + count + length,\n                            strval, \"%s (Forwarded-count=%u)\",\n                            format_text(wmem_packet_scope(), strval, strlen(strval)),\n                            fwd_count);\n                    subtree = proto_item_add_subtree(tii,\n                            ett_mmse_hdr_details);\n                    proto_tree_add_uint(subtree,\n                            hf_mmse_prev_sent_by_fwd_count,\n                            tvb, offset + count, count1, fwd_count);\n                    proto_tree_add_string(subtree,\n                            hf_mmse_prev_sent_by_address,\n                            tvb, offset + count + count1, count2, strval);\n                }\n                offset += length + count;\n                break;\n            case MM_PREV_SENT_DATE_HDR:\n                {\n                    guint32 fwd_count, count1, count2;\n                    guint            tval;\n                    nstime_t         tmptime;\n                    proto_tree *subtree = NULL;\n                    proto_item *tii = NULL;\n\n                    /* Value-Length Forwarded-count-value Date-value */\n                    length = get_value_length(tvb, offset, &count, pinfo);\n                    /* 1. Forwarded-count-value := Integer-value */\n                    fwd_count = get_integer_value(tvb, offset + count, &count1);\n                    /* 2. Date-value := Long-integer */\n                    tval = get_long_integer(tvb, offset + count + count1,\n                            &count2);\n                    tmptime.secs = tval;\n                    tmptime.nsecs = 0;\n                    strval = abs_time_to_str(wmem_packet_scope(), &tmptime, ABSOLUTE_TIME_LOCAL,\n                            TRUE);\n                    /* Now render the fields */\n                    tii = proto_tree_add_string_format(mmse_tree,\n                            hf_mmse_prev_sent_date,\n                            tvb, offset - 1, 1 + count + length,\n                            strval, \"%s (Forwarded-count=%u)\",\n                            format_text(wmem_packet_scope(), strval, strlen(strval)),\n                            fwd_count);\n                    subtree = proto_item_add_subtree(tii,\n                            ett_mmse_hdr_details);\n                    proto_tree_add_uint(subtree,\n                            hf_mmse_prev_sent_date_fwd_count,\n                            tvb, offset + count, count1, fwd_count);\n                    proto_tree_add_string(subtree,\n                            hf_mmse_prev_sent_date_date,\n                            tvb, offset + count + count1, count2, strval);\n                }\n                offset += length + count;\n                break;\n\n                /* MMS Encapsulation 1.2 */\n\n            default:\n                if (field & 0x80) { /* Well-known WSP header encoding */\n                    guint8 peek = tvb_get_guint8(tvb, offset);\n                    const char *hdr_name = val_to_str(field, vals_mm_header_names,\n                            \"Unknown field (0x%02x)\");\n                    const char *str;\n                    DebugLog((\"\\t\\tUndecoded well-known header: %s\\n\",\n                                hdr_name));\n\n                    if (peek & 0x80) { /* Well-known value */\n                        length = 1;\n                        proto_tree_add_uint_format(mmse_tree, hf_mmse_header_uint, tvb, offset - 1,\n                                length + 1, peek,\n                                \"%s: <Well-known value 0x%02x>\"\n                                \" (not decoded)\",\n                                hdr_name, peek);\n                    } else if ((peek == 0) || (peek >= 0x20)) { /* Text */\n                        length = get_text_string(tvb, offset, &strval);\n                        str = format_text(wmem_packet_scope(), strval, strlen(strval));\n                        proto_tree_add_string_format(mmse_tree, hf_mmse_header_string, tvb, offset - 1,\n                                length + 1, str, \"%s: %s (Not decoded)\", hdr_name, str);\n                    } else { /* General form with length */\n                        if (peek == 0x1F) { /* Value length in guintvar */\n                            guint length_len = 0;\n                            length = 1 + tvb_get_guintvar(tvb, offset + 1,\n                                    &length_len, pinfo, &ei_mmse_oversized_uintvar);\n                            length += length_len;\n                        } else { /* Value length in octet */\n                            length = 1 + tvb_get_guint8(tvb, offset);\n                        }\n                        proto_tree_add_bytes_format(mmse_tree, hf_mmse_header_bytes, tvb, offset - 1,\n                                length + 1, NULL, \"%s: \"\n                                \"<Value in general form> (not decoded)\",\n                                hdr_name);\n                    }\n                    offset += length;\n                } else { /* Literal WSP header encoding */\n                    guint            length2;\n                    const char       *strval2;\n\n                    --offset;\n                    length = get_text_string(tvb, offset, &strval);\n                    DebugLog((\"\\t\\tUndecoded literal header: %s\\n\",\n                                strval));\n                    length2= get_text_string(tvb, offset+length, &strval2);\n\n                    proto_tree_add_string_format(mmse_tree,\n                            hf_mmse_ffheader, tvb, offset,\n                            length + length2,\n                            tvb_get_string_enc(wmem_packet_scope(), tvb, offset,\n                                length + length2, ENC_ASCII),\n                            \"%s: %s\",\n                            format_text(wmem_packet_scope(), strval, strlen(strval)),\n                            format_text(wmem_packet_scope(), strval2, strlen(strval2)));\n\n                    offset += length + length2;\n                }\n                break;\n        }\n        DebugLog((\"\\tEnd(case)\\n\"));\n    }\n\n    DebugLog((\"\\tEnd(switch)\\n\"));\n    if (field == MM_CTYPE_HDR) {\n        /*\n         * Eeehh, we're now actually back to good old WSP content-type\n         * encoding. Let's steal that from the WSP-dissector.\n         */\n        tvbuff_t    *tmp_tvb;\n        guint        type;\n        const char  *type_str;\n\n        DebugLog((\"Content-Type: [from WSP dissector]\\n\"));\n        DebugLog((\"Calling add_content_type() in WSP dissector\\n\"));\n        offset = add_content_type(mmse_tree, pinfo, tvb, offset, &type, &type_str);\n        DebugLog((\"Generating new TVB subset (offset = %u)\\n\", offset));\n        tmp_tvb = tvb_new_subset_remaining(tvb, offset);\n        DebugLog((\"Add POST data\\n\"));\n        add_post_data(mmse_tree, tmp_tvb, type, type_str, pinfo);\n        DebugLog((\"Done!\\n\"));\n    }\n\n    /* If this protocol has a sub-dissector call it here, see section 1.8 */\n    DebugLog((\"dissect_mmse() - END\\n\"));\n}",
        "func": "static void\ndissect_mmse(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint8 pdut,\n        const char *message_type)\n{\n    guint        offset, old_offset;\n    guint8       field = 0;\n    const char   *strval;\n    guint        length;\n    guint        count;\n    guint8       version = 0x80; /* Default to MMSE 1.0 */\n\n    /* Set up structures needed to add the protocol subtree and manage it */\n    proto_item  *ti = NULL;\n    proto_tree  *mmse_tree = NULL;\n\n    DebugLog((\"dissect_mmse() - START (Packet %u)\\n\", pinfo->num));\n\n    ti = proto_tree_add_item(tree, proto_mmse, tvb, 0, -1, ENC_NA);\n    proto_item_append_text(ti, \", Type: %s\", message_type);\n    /* create display subtree for the protocol */\n    mmse_tree = proto_item_add_subtree(ti, ett_mmse);\n\n    /* Report PDU-type      */\n    proto_tree_add_uint(mmse_tree, hf_mmse_message_type, tvb, 0, 2, pdut);\n\n    offset = 2;                 /* Skip Message-Type    */\n    old_offset = 1;\n\n    /*\n     * Cycle through MMS-headers\n     *\n     * NOTE - some PDUs may convey content that can be handed off\n     *        to subdissectors.\n     */\n    if (tree == NULL && !pdu_has_content(pdut)) {\n        DebugLog((\"tree == NULL and PDU has no potential content\\n\"));\n        return;\n    }\n\n    while ((offset < tvb_reported_length(tvb)) &&\n            (field = tvb_get_guint8(tvb, offset++)) != MM_CTYPE_HDR)\n    {\n        DebugLog((\"\\tField =  0x%02X (offset = %u): %s\\n\",\n                    field, offset,\n                    val_to_str(field, vals_mm_header_names,\n                        \"Unknown MMS header 0x%02X\")));\n        switch (field)\n        {\n            case MM_TID_HDR:                /* Text-string  */\n                length = get_text_string(tvb, offset, &strval);\n                proto_tree_add_string(mmse_tree, hf_mmse_transaction_id,\n                        tvb, offset - 1, length + 1,strval);\n                offset += length;\n                break;\n            case MM_VERSION_HDR:            /* nibble-Major/nibble-minor*/\n                {\n                    guint8   major, minor;\n                    char    *vers_string;\n\n                    version = tvb_get_guint8(tvb, offset++);\n                    major = (version & 0x70) >> 4;\n                    minor = version & 0x0F;\n                    if (minor == 0x0F)\n                        vers_string = wmem_strdup_printf(wmem_packet_scope(), \"%u\", major);\n                    else\n                        vers_string = wmem_strdup_printf(wmem_packet_scope(), \"%u.%u\", major, minor);\n                    proto_tree_add_string(mmse_tree, hf_mmse_mms_version,\n                            tvb, offset - 2, 2, vers_string);\n                }\n                break;\n            case MM_BCC_HDR:                /* Encoded-string-value */\n                length = get_encoded_strval(tvb, offset, &strval, pinfo);\n                proto_tree_add_string(mmse_tree, hf_mmse_bcc, tvb,\n                        offset - 1, length + 1, strval);\n                offset += length;\n                break;\n            case MM_CC_HDR:                 /* Encoded-string-value */\n                length = get_encoded_strval(tvb, offset, &strval, pinfo);\n                proto_tree_add_string(mmse_tree, hf_mmse_cc, tvb,\n                        offset - 1, length + 1, strval);\n                offset += length;\n                break;\n            case MM_CLOCATION_HDR:          /* Uri-value            */\n                if (pdut == PDU_M_MBOX_DELETE_CONF) {\n                    /* General form with length */\n                    length = tvb_get_guint8(tvb, offset);\n                    if (length == 0x1F) {\n                        guint length_len = 0;\n                        length = tvb_get_guintvar(tvb, offset + 1,\n                                &length_len, pinfo, &ei_mmse_oversized_uintvar);\n                        length += 1 + length_len;\n                    } else {\n                        length += 1;\n                    }\n                    proto_tree_add_string(mmse_tree,\n                            hf_mmse_content_location,\n                            tvb, offset - 1, length + 1,\n                            \"<Undecoded value for m-mbox-delete-conf>\");\n                } else {\n                    length = get_text_string(tvb, offset, &strval);\n                    proto_tree_add_string(mmse_tree,\n                            hf_mmse_content_location,\n                            tvb, offset - 1, length + 1, strval);\n                }\n                offset += length;\n                break;\n            case MM_DATE_HDR:               /* Long-integer         */\n                {\n                    guint            tval;\n                    nstime_t         tmptime;\n\n                    tval = get_long_integer(tvb, offset, &count);\n                    tmptime.secs = tval;\n                    tmptime.nsecs = 0;\n                    proto_tree_add_time(mmse_tree, hf_mmse_date, tvb,\n                            offset - 1, count + 1, &tmptime);\n                }\n                offset += count;\n                break;\n            case MM_DREPORT_HDR:            /* Yes|No               */\n                field = tvb_get_guint8(tvb, offset++);\n                proto_tree_add_uint(mmse_tree,\n                        hf_mmse_delivery_report,\n                        tvb, offset - 2, 2, field);\n                break;\n            case MM_DTIME_HDR:\n                {\n                    guint            tval;\n                    nstime_t         tmptime;\n                    guint            cnt;\n\n                    /*\n                     * Value-length(Absolute-token Date-value|\n                     *              Relative-token Delta-seconds-value)\n                     */\n                    length = get_value_length(tvb, offset, &count, pinfo);\n                    field = tvb_get_guint8(tvb, offset + count);\n\n                    tval =  get_long_integer(tvb, offset + count + 1, &cnt);\n                    tmptime.secs = tval;\n                    tmptime.nsecs = 0;\n\n                    if (field == 0x80)\n                        proto_tree_add_time(mmse_tree,\n                                hf_mmse_delivery_time_abs,\n                                tvb, offset - 1,\n                                length + count + 1, &tmptime);\n                    else\n                        proto_tree_add_time(mmse_tree,\n                                hf_mmse_delivery_time_rel,\n                                tvb, offset - 1,\n                                length + count + 1, &tmptime);\n                }\n                offset += length + count;\n                break;\n            case MM_EXPIRY_HDR:\n                {\n                    guint            tval;\n                    nstime_t         tmptime;\n                    guint            cnt;\n\n                    /*\n                     * Value-length(Absolute-token Date-value|\n                     *              Relative-token Delta-seconds-value)\n                     */\n                    length = get_value_length(tvb, offset, &count, pinfo);\n                    field = tvb_get_guint8(tvb, offset + count);\n\n                    tval = get_long_integer(tvb, offset + count + 1, &cnt);\n                    tmptime.secs = tval;\n                    tmptime.nsecs = 0;\n\n                    if (field == 0x80)\n                        proto_tree_add_time(mmse_tree, hf_mmse_expiry_abs,\n                                tvb, offset - 1,\n                                length + count + 1, &tmptime);\n                    else\n                        proto_tree_add_time(mmse_tree, hf_mmse_expiry_rel,\n                                tvb, offset - 1,\n                                length + count + 1, &tmptime);\n                }\n                offset += length + count;\n                break;\n            case MM_FROM_HDR:\n                /*\n                 * Value-length(Address-present-token Encoded-string-value\n                 *              |Insert-address-token)\n                 */\n                length = get_value_length(tvb, offset, &count, pinfo);\n                field = tvb_get_guint8(tvb, offset + count);\n                if (field == 0x81) {\n                    proto_tree_add_string(mmse_tree, hf_mmse_from, tvb,\n                            offset-1, length + count + 1,\n                            \"<insert address>\");\n                } else {\n                    (void) get_encoded_strval(tvb, offset + count + 1,\n                            &strval, pinfo);\n                    proto_tree_add_string(mmse_tree, hf_mmse_from, tvb,\n                            offset-1, length + count + 1, strval);\n                }\n                offset += length + count;\n                break;\n            case MM_MCLASS_HDR:\n                /*\n                 * Class-identifier|Text-string\n                 */\n                field = tvb_get_guint8(tvb, offset);\n                if (field & 0x80) {\n                    offset++;\n                    proto_tree_add_uint(mmse_tree,\n                            hf_mmse_message_class_id,\n                            tvb, offset - 2, 2, field);\n                } else {\n                    length = get_text_string(tvb, offset, &strval);\n                    proto_tree_add_string(mmse_tree,\n                            hf_mmse_message_class_str,\n                            tvb, offset - 1, length + 1,\n                            strval);\n                    offset += length;\n                }\n                break;\n            case MM_MID_HDR:                /* Text-string          */\n                length = get_text_string(tvb, offset, &strval);\n                proto_tree_add_string(mmse_tree, hf_mmse_message_id,\n                        tvb, offset - 1, length + 1, strval);\n                offset += length;\n                break;\n            case MM_MSIZE_HDR:              /* Long-integer         */\n                length = get_long_integer(tvb, offset, &count);\n                proto_tree_add_uint(mmse_tree, hf_mmse_message_size,\n                        tvb, offset - 1, count + 1, length);\n                offset += count;\n                break;\n            case MM_PRIORITY_HDR:           /* Low|Normal|High      */\n                field = tvb_get_guint8(tvb, offset++);\n                proto_tree_add_uint(mmse_tree, hf_mmse_priority, tvb,\n                        offset - 2, 2, field);\n                break;\n            case MM_RREPLY_HDR:             /* Yes|No               */\n                field = tvb_get_guint8(tvb, offset++);\n                if (version == 0x80) { /* MMSE 1.0 */\n                    proto_tree_add_uint(mmse_tree, hf_mmse_read_reply,\n                            tvb, offset - 2, 2, field);\n                } else {\n                    proto_tree_add_uint(mmse_tree, hf_mmse_read_report,\n                            tvb, offset - 2, 2, field);\n                }\n                break;\n            case MM_RALLOWED_HDR:           /* Yes|No               */\n                field = tvb_get_guint8(tvb, offset++);\n                proto_tree_add_uint(mmse_tree, hf_mmse_report_allowed,\n                        tvb, offset - 2, 2, field);\n                break;\n            case MM_RSTATUS_HDR:\n                field = tvb_get_guint8(tvb, offset++);\n                proto_tree_add_uint(mmse_tree, hf_mmse_response_status,\n                        tvb, offset - 2, 2, field);\n                break;\n            case MM_RTEXT_HDR:              /* Encoded-string-value */\n                if (pdut == PDU_M_MBOX_DELETE_CONF) {\n                    /* General form with length */\n                    length = tvb_get_guint8(tvb, offset);\n                    if (length == 0x1F) {\n                        guint length_len = 0;\n                        length = tvb_get_guintvar(tvb, offset + 1,\n                                &length_len, pinfo, &ei_mmse_oversized_uintvar);\n                        length += 1 + length_len;\n                    } else {\n                        length += 1;\n                    }\n                    proto_tree_add_string(mmse_tree,\n                            hf_mmse_content_location,\n                            tvb, offset - 1, length + 1,\n                            \"<Undecoded value for m-mbox-delete-conf>\");\n                } else {\n                    length = get_encoded_strval(tvb, offset, &strval, pinfo);\n                    proto_tree_add_string(mmse_tree,\n                            hf_mmse_response_text, tvb, offset - 1,\n                            length + 1, strval);\n                }\n                offset += length;\n                break;\n            case MM_SVISIBILITY_HDR:        /* Hide|Show            */\n                field = tvb_get_guint8(tvb, offset++);\n                proto_tree_add_uint(mmse_tree,hf_mmse_sender_visibility,\n                        tvb, offset - 2, 2, field);\n                break;\n            case MM_STATUS_HDR:\n                field = tvb_get_guint8(tvb, offset++);\n                proto_tree_add_uint(mmse_tree, hf_mmse_status, tvb,\n                        offset - 2, 2, field);\n                break;\n            case MM_SUBJECT_HDR:            /* Encoded-string-value */\n                length = get_encoded_strval(tvb, offset, &strval, pinfo);\n                proto_tree_add_string(mmse_tree, hf_mmse_subject, tvb,\n                        offset - 1, length + 1, strval);\n                offset += length;\n                break;\n            case MM_TO_HDR:                 /* Encoded-string-value */\n                length = get_encoded_strval(tvb, offset, &strval, pinfo);\n                proto_tree_add_string(mmse_tree, hf_mmse_to, tvb,\n                        offset - 1, length + 1, strval);\n                offset += length;\n                break;\n\n                /*\n                 * MMS Encapsulation 1.1\n                 */\n            case MM_RETRIEVE_STATUS_HDR:    /* Well-known-value */\n                field = tvb_get_guint8(tvb, offset++);\n                proto_tree_add_uint(mmse_tree, hf_mmse_retrieve_status,\n                        tvb, offset - 2, 2, field);\n                break;\n            case MM_RETRIEVE_TEXT_HDR:\n                if (pdut == PDU_M_MBOX_DELETE_CONF) {\n                    /* General form with length */\n                    length = tvb_get_guint8(tvb, offset);\n                    if (length == 0x1F) {\n                        guint length_len = 0;\n                        length = tvb_get_guintvar(tvb, offset + 1,\n                                &length_len, pinfo, &ei_mmse_oversized_uintvar);\n                        length += 1 + length_len;\n                    } else {\n                        length += 1;\n                    }\n\n                    proto_tree_add_string(mmse_tree,\n                            hf_mmse_content_location,\n                            tvb, offset - 1, length + 1,\n                            \"<Undecoded value for m-mbox-delete-conf>\");\n                } else {\n                    /* Encoded-string-value */\n                    length = get_encoded_strval(tvb, offset, &strval, pinfo);\n                    proto_tree_add_string(mmse_tree,\n                            hf_mmse_retrieve_text, tvb, offset - 1,\n                            length + 1, strval);\n                }\n                offset += length;\n                break;\n            case MM_READ_STATUS_HDR:        /* Well-known-value */\n                field = tvb_get_guint8(tvb, offset++);\n                proto_tree_add_uint(mmse_tree, hf_mmse_read_status,\n                        tvb, offset - 2, 2, field);\n                break;\n            case MM_REPLY_CHARGING_HDR:     /* Well-known-value */\n                field = tvb_get_guint8(tvb, offset++);\n                proto_tree_add_uint(mmse_tree, hf_mmse_reply_charging,\n                        tvb, offset - 2, 2, field);\n                break;\n            case MM_REPLY_CHARGING_DEADLINE_HDR:    /* Well-known-value */\n                {\n                    guint            tval;\n                    nstime_t         tmptime;\n                    guint            cnt;\n\n                    /*\n                     * Value-length(Absolute-token Date-value|\n                     *              Relative-token Delta-seconds-value)\n                     */\n\n                    length = get_value_length(tvb, offset, &count, pinfo);\n                    field = tvb_get_guint8(tvb, offset + count);\n\n                    tval = get_long_integer(tvb, offset + count + 1, &cnt);\n                    tmptime.secs = tval;\n                    tmptime.nsecs = 0;\n\n                    if (field == 0x80)\n                        proto_tree_add_time(mmse_tree, hf_mmse_reply_charging_deadline_abs,\n                                tvb, offset - 1,\n                                length + count + 1, &tmptime);\n                    else\n                        proto_tree_add_time(mmse_tree, hf_mmse_reply_charging_deadline_rel,\n                                tvb, offset - 1,\n                                length + count + 1, &tmptime);\n                }\n                offset += length + count;\n                break;\n            case MM_REPLY_CHARGING_ID_HDR:  /* Text-string */\n                length = get_text_string(tvb, offset, &strval);\n                proto_tree_add_string(mmse_tree,\n                        hf_mmse_reply_charging_id,\n                        tvb, offset - 1, length + 1, strval);\n                offset += length;\n                break;\n            case MM_REPLY_CHARGING_SIZE_HDR:        /* Long-integer */\n                length = get_long_integer(tvb, offset, &count);\n                proto_tree_add_uint(mmse_tree,\n                        hf_mmse_reply_charging_size,\n                        tvb, offset - 1, count + 1, length);\n                offset += count;\n                break;\n            case MM_PREV_SENT_BY_HDR:\n                {\n                    guint32 fwd_count, count1, count2;\n                    proto_tree *subtree = NULL;\n                    proto_item *tii = NULL;\n\n                    /* Value-length Integer-value Encoded-string-value */\n                    length = get_value_length(tvb, offset, &count, pinfo);\n\n                    /* 1. Forwarded-count-value := Integer-value */\n                    fwd_count = get_integer_value(tvb, offset + count,\n                            &count1);\n                    /* 2. Encoded-string-value */\n                    count2 = get_encoded_strval(tvb,\n                            offset + count + count1, &strval, pinfo);\n                    /* Now render the fields */\n                    tii = proto_tree_add_string_format(mmse_tree,\n                            hf_mmse_prev_sent_by,\n                            tvb, offset - 1, 1 + count + length,\n                            strval, \"%s (Forwarded-count=%u)\",\n                            format_text(wmem_packet_scope(), strval, strlen(strval)),\n                            fwd_count);\n                    subtree = proto_item_add_subtree(tii,\n                            ett_mmse_hdr_details);\n                    proto_tree_add_uint(subtree,\n                            hf_mmse_prev_sent_by_fwd_count,\n                            tvb, offset + count, count1, fwd_count);\n                    proto_tree_add_string(subtree,\n                            hf_mmse_prev_sent_by_address,\n                            tvb, offset + count + count1, count2, strval);\n                }\n                offset += length + count;\n                break;\n            case MM_PREV_SENT_DATE_HDR:\n                {\n                    guint32 fwd_count, count1, count2;\n                    guint            tval;\n                    nstime_t         tmptime;\n                    proto_tree *subtree = NULL;\n                    proto_item *tii = NULL;\n\n                    /* Value-Length Forwarded-count-value Date-value */\n                    length = get_value_length(tvb, offset, &count, pinfo);\n                    /* 1. Forwarded-count-value := Integer-value */\n                    fwd_count = get_integer_value(tvb, offset + count, &count1);\n                    /* 2. Date-value := Long-integer */\n                    tval = get_long_integer(tvb, offset + count + count1,\n                            &count2);\n                    tmptime.secs = tval;\n                    tmptime.nsecs = 0;\n                    strval = abs_time_to_str(wmem_packet_scope(), &tmptime, ABSOLUTE_TIME_LOCAL,\n                            TRUE);\n                    /* Now render the fields */\n                    tii = proto_tree_add_string_format(mmse_tree,\n                            hf_mmse_prev_sent_date,\n                            tvb, offset - 1, 1 + count + length,\n                            strval, \"%s (Forwarded-count=%u)\",\n                            format_text(wmem_packet_scope(), strval, strlen(strval)),\n                            fwd_count);\n                    subtree = proto_item_add_subtree(tii,\n                            ett_mmse_hdr_details);\n                    proto_tree_add_uint(subtree,\n                            hf_mmse_prev_sent_date_fwd_count,\n                            tvb, offset + count, count1, fwd_count);\n                    proto_tree_add_string(subtree,\n                            hf_mmse_prev_sent_date_date,\n                            tvb, offset + count + count1, count2, strval);\n                }\n                offset += length + count;\n                break;\n\n                /* MMS Encapsulation 1.2 */\n\n            default:\n                if (field & 0x80) { /* Well-known WSP header encoding */\n                    guint8 peek = tvb_get_guint8(tvb, offset);\n                    const char *hdr_name = val_to_str(field, vals_mm_header_names,\n                            \"Unknown field (0x%02x)\");\n                    const char *str;\n                    DebugLog((\"\\t\\tUndecoded well-known header: %s\\n\",\n                                hdr_name));\n\n                    if (peek & 0x80) { /* Well-known value */\n                        length = 1;\n                        proto_tree_add_uint_format(mmse_tree, hf_mmse_header_uint, tvb, offset - 1,\n                                length + 1, peek,\n                                \"%s: <Well-known value 0x%02x>\"\n                                \" (not decoded)\",\n                                hdr_name, peek);\n                    } else if ((peek == 0) || (peek >= 0x20)) { /* Text */\n                        length = get_text_string(tvb, offset, &strval);\n                        str = format_text(wmem_packet_scope(), strval, strlen(strval));\n                        proto_tree_add_string_format(mmse_tree, hf_mmse_header_string, tvb, offset - 1,\n                                length + 1, str, \"%s: %s (Not decoded)\", hdr_name, str);\n                    } else { /* General form with length */\n                        if (peek == 0x1F) { /* Value length in guintvar */\n                            guint length_len = 0;\n                            length = 1 + tvb_get_guintvar(tvb, offset + 1,\n                                    &length_len, pinfo, &ei_mmse_oversized_uintvar);\n                            length += length_len;\n                        } else { /* Value length in octet */\n                            length = 1 + tvb_get_guint8(tvb, offset);\n                        }\n                        proto_tree_add_bytes_format(mmse_tree, hf_mmse_header_bytes, tvb, offset - 1,\n                                length + 1, NULL, \"%s: \"\n                                \"<Value in general form> (not decoded)\",\n                                hdr_name);\n                    }\n                    offset += length;\n                } else { /* Literal WSP header encoding */\n                    guint            length2;\n                    const char       *strval2;\n\n                    --offset;\n                    length = get_text_string(tvb, offset, &strval);\n                    DebugLog((\"\\t\\tUndecoded literal header: %s\\n\",\n                                strval));\n                    length2= get_text_string(tvb, offset+length, &strval2);\n\n                    proto_tree_add_string_format(mmse_tree,\n                            hf_mmse_ffheader, tvb, offset,\n                            length + length2,\n                            tvb_get_string_enc(wmem_packet_scope(), tvb, offset,\n                                length + length2, ENC_ASCII),\n                            \"%s: %s\",\n                            format_text(wmem_packet_scope(), strval, strlen(strval)),\n                            format_text(wmem_packet_scope(), strval2, strlen(strval2)));\n\n                    offset += length + length2;\n                }\n                break;\n        }\n        DebugLog((\"\\tEnd(case)\\n\"));\n\n        if (offset <= old_offset) {\n            REPORT_DISSECTOR_BUG(\"Offset isn't increasing\");\n        }\n        old_offset = offset;\n    }\n\n    DebugLog((\"\\tEnd(switch)\\n\"));\n    if (field == MM_CTYPE_HDR) {\n        /*\n         * Eeehh, we're now actually back to good old WSP content-type\n         * encoding. Let's steal that from the WSP-dissector.\n         */\n        tvbuff_t    *tmp_tvb;\n        guint        type;\n        const char  *type_str;\n\n        DebugLog((\"Content-Type: [from WSP dissector]\\n\"));\n        DebugLog((\"Calling add_content_type() in WSP dissector\\n\"));\n        offset = add_content_type(mmse_tree, pinfo, tvb, offset, &type, &type_str);\n        DebugLog((\"Generating new TVB subset (offset = %u)\\n\", offset));\n        tmp_tvb = tvb_new_subset_remaining(tvb, offset);\n        DebugLog((\"Add POST data\\n\"));\n        add_post_data(mmse_tree, tmp_tvb, type, type_str, pinfo);\n        DebugLog((\"Done!\\n\"));\n    }\n\n    /* If this protocol has a sub-dissector call it here, see section 1.8 */\n    DebugLog((\"dissect_mmse() - END\\n\"));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n dissect_mmse(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint8 pdut,\n         const char *message_type)\n {\n-    guint        offset;\n+    guint        offset, old_offset;\n     guint8       field = 0;\n     const char   *strval;\n     guint        length;\n@@ -24,6 +24,7 @@\n     proto_tree_add_uint(mmse_tree, hf_mmse_message_type, tvb, 0, 2, pdut);\n \n     offset = 2;                 /* Skip Message-Type    */\n+    old_offset = 1;\n \n     /*\n      * Cycle through MMS-headers\n@@ -522,6 +523,11 @@\n                 break;\n         }\n         DebugLog((\"\\tEnd(case)\\n\"));\n+\n+        if (offset <= old_offset) {\n+            REPORT_DISSECTOR_BUG(\"Offset isn't increasing\");\n+        }\n+        old_offset = offset;\n     }\n \n     DebugLog((\"\\tEnd(switch)\\n\"));",
        "diff_line_info": {
            "deleted_lines": [
                "    guint        offset;"
            ],
            "added_lines": [
                "    guint        offset, old_offset;",
                "    old_offset = 1;",
                "",
                "        if (offset <= old_offset) {",
                "            REPORT_DISSECTOR_BUG(\"Offset isn't increasing\");",
                "        }",
                "        old_offset = offset;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19840",
        "func_name": "dbry/WavPack/WavpackSetConfiguration64",
        "description": "The function WavpackPackInit in pack_utils.c in libwavpack.a in WavPack through 5.1.0 allows attackers to cause a denial-of-service (resource exhaustion caused by an infinite loop) via a crafted wav audio file because WavpackSetConfiguration64 mishandles a sample rate of zero.",
        "git_url": "https://github.com/dbry/WavPack/commit/070ef6f138956d9ea9612e69586152339dbefe51",
        "commit_title": "issue #53: error out on zero sample rate",
        "commit_text": "",
        "func_before": "int WavpackSetConfiguration64 (WavpackContext *wpc, WavpackConfig *config, int64_t total_samples, const unsigned char *chan_ids)\n{\n    uint32_t flags, bps = 0;\n    uint32_t chan_mask = config->channel_mask;\n    int num_chans = config->num_channels;\n    int i;\n\n    wpc->stream_version = (config->flags & CONFIG_COMPATIBLE_WRITE) ? CUR_STREAM_VERS : MAX_STREAM_VERS;\n\n    if ((config->qmode & QMODE_DSD_AUDIO) && config->bytes_per_sample == 1 && config->bits_per_sample == 8) {\n#ifdef ENABLE_DSD\n        wpc->dsd_multiplier = 1;\n        flags = DSD_FLAG;\n\n        for (i = 14; i >= 0; --i)\n            if (config->sample_rate % sample_rates [i] == 0) {\n                int divisor = config->sample_rate / sample_rates [i];\n\n                if (divisor && (divisor & (divisor - 1)) == 0) {\n                    config->sample_rate /= divisor;\n                    wpc->dsd_multiplier = divisor;\n                    break;\n                }\n            }\n\n        // most options that don't apply to DSD we can simply ignore for now, but NOT hybrid mode!\n        if (config->flags & CONFIG_HYBRID_FLAG) {\n            strcpy (wpc->error_message, \"hybrid mode not available for DSD!\");\n            return FALSE;\n        }\n\n        // with DSD, very few PCM options work (or make sense), so only allow those that do\n        config->flags &= (CONFIG_HIGH_FLAG | CONFIG_MD5_CHECKSUM | CONFIG_PAIR_UNDEF_CHANS);\n        config->float_norm_exp = config->xmode = 0;\n#else\n        strcpy (wpc->error_message, \"libwavpack not configured for DSD!\");\n        return FALSE;\n#endif\n    }\n    else\n        flags = config->bytes_per_sample - 1;\n\n    wpc->total_samples = total_samples;\n    wpc->config.sample_rate = config->sample_rate;\n    wpc->config.num_channels = config->num_channels;\n    wpc->config.channel_mask = config->channel_mask;\n    wpc->config.bits_per_sample = config->bits_per_sample;\n    wpc->config.bytes_per_sample = config->bytes_per_sample;\n    wpc->config.block_samples = config->block_samples;\n    wpc->config.flags = config->flags;\n    wpc->config.qmode = config->qmode;\n\n    if (config->flags & CONFIG_VERY_HIGH_FLAG)\n        wpc->config.flags |= CONFIG_HIGH_FLAG;\n\n    for (i = 0; i < 15; ++i)\n        if (wpc->config.sample_rate == sample_rates [i])\n            break;\n\n    flags |= i << SRATE_LSB;\n\n    // all of this stuff only applies to PCM\n\n    if (!(flags & DSD_FLAG)) {\n        if (config->float_norm_exp) {\n            wpc->config.float_norm_exp = config->float_norm_exp;\n            wpc->config.flags |= CONFIG_FLOAT_DATA;\n            flags |= FLOAT_DATA;\n        }\n        else\n            flags |= ((config->bytes_per_sample * 8) - config->bits_per_sample) << SHIFT_LSB;\n\n        if (config->flags & CONFIG_HYBRID_FLAG) {\n            flags |= HYBRID_FLAG | HYBRID_BITRATE | HYBRID_BALANCE;\n\n            if (!(wpc->config.flags & CONFIG_SHAPE_OVERRIDE)) {\n                wpc->config.flags |= CONFIG_HYBRID_SHAPE | CONFIG_AUTO_SHAPING;\n                flags |= HYBRID_SHAPE | NEW_SHAPING;\n            }\n            else if (wpc->config.flags & CONFIG_HYBRID_SHAPE) {\n                wpc->config.shaping_weight = config->shaping_weight;\n                flags |= HYBRID_SHAPE | NEW_SHAPING;\n            }\n\n            if (wpc->config.flags & (CONFIG_CROSS_DECORR | CONFIG_OPTIMIZE_WVC))\n                flags |= CROSS_DECORR;\n\n            if (config->flags & CONFIG_BITRATE_KBPS) {\n                bps = (uint32_t) floor (config->bitrate * 256000.0 / config->sample_rate / config->num_channels + 0.5);\n\n                if (bps > (64 << 8))\n                    bps = 64 << 8;\n            }\n            else\n                bps = (uint32_t) floor (config->bitrate * 256.0 + 0.5);\n        }\n        else\n            flags |= CROSS_DECORR;\n\n        if (!(config->flags & CONFIG_JOINT_OVERRIDE) || (config->flags & CONFIG_JOINT_STEREO))\n            flags |= JOINT_STEREO;\n\n        if (config->flags & CONFIG_CREATE_WVC)\n            wpc->wvc_flag = TRUE;\n    }\n\n    // if a channel-identities string was specified, process that here, otherwise all channels\n    // not present in the channel mask are considered \"unassigned\"\n\n    if (chan_ids) {\n        int lastchan = 0, mask_copy = chan_mask;\n\n        if ((int) strlen ((char *) chan_ids) > num_chans) {          // can't be more than num channels!\n            strcpy (wpc->error_message, \"chan_ids longer than num channels!\");\n            return FALSE;\n        }\n\n        // skip past channels that are specified in the channel mask (no reason to store those)\n\n        while (*chan_ids)\n            if (*chan_ids <= 32 && *chan_ids > lastchan && (mask_copy & (1 << (*chan_ids-1)))) {\n                mask_copy &= ~(1 << (*chan_ids-1));\n                lastchan = *chan_ids++;\n            }\n            else\n                break;\n\n        // now scan the string for an actually defined channel (and don't store if there aren't any)\n\n        for (i = 0; chan_ids [i]; i++)\n            if (chan_ids [i] != 0xff) {\n                wpc->channel_identities = (unsigned char *) strdup ((char *) chan_ids);\n                break;\n            }\n    }\n\n    // This loop goes through all the channels and creates the Wavpack \"streams\" for them to go in.\n    // A stream can hold either one or two channels, so we have several rules to determine how many\n    // channels will go in each stream.\n\n    for (wpc->current_stream = 0; num_chans; wpc->current_stream++) {\n        WavpackStream *wps = malloc (sizeof (WavpackStream));\n        unsigned char left_chan_id = 0, right_chan_id = 0;\n        int pos, chans = 1;\n\n        // allocate the stream and initialize the pointer to it\n        wpc->streams = realloc (wpc->streams, (wpc->current_stream + 1) * sizeof (wpc->streams [0]));\n        wpc->streams [wpc->current_stream] = wps;\n        CLEAR (*wps);\n\n        // if there are any bits [still] set in the channel_mask, get the next one or two IDs from there\n        if (chan_mask)\n            for (pos = 0; pos < 32; ++pos)\n                if (chan_mask & (1 << pos)) {\n                    if (left_chan_id) {\n                        right_chan_id = pos + 1;\n                        break;\n                    }\n                    else {\n                        chan_mask &= ~(1 << pos);\n                        left_chan_id = pos + 1;\n                    }\n                }\n\n        // next check for any channels identified in the channel-identities string\n        while (!right_chan_id && chan_ids && *chan_ids)\n            if (left_chan_id)\n                right_chan_id = *chan_ids;\n            else\n                left_chan_id = *chan_ids++;\n\n        // assume anything we did not get is \"unassigned\"\n        if (!left_chan_id)\n            left_chan_id = right_chan_id = 0xff;\n        else if (!right_chan_id)\n            right_chan_id = 0xff;\n\n        // if we have 2 channels, this is where we decide if we can combine them into one stream:\n        // 1. they are \"unassigned\" and we've been told to combine unassigned pairs, or\n        // 2. they appear together in the valid \"pairings\" list\n        if (num_chans >= 2) {\n            if ((config->flags & CONFIG_PAIR_UNDEF_CHANS) && left_chan_id == 0xff && right_chan_id == 0xff)\n                chans = 2;\n            else\n                for (i = 0; i < NUM_STEREO_PAIRS; ++i)\n                    if ((left_chan_id == stereo_pairs [i].a && right_chan_id == stereo_pairs [i].b) ||\n                        (left_chan_id == stereo_pairs [i].b && right_chan_id == stereo_pairs [i].a)) {\n                            if (right_chan_id <= 32 && (chan_mask & (1 << (right_chan_id-1))))\n                                chan_mask &= ~(1 << (right_chan_id-1));\n                            else if (chan_ids && *chan_ids == right_chan_id)\n                                chan_ids++;\n\n                            chans = 2;\n                            break;\n                        }\n        }\n\n        num_chans -= chans;\n\n        if (num_chans && wpc->current_stream == NEW_MAX_STREAMS - 1)\n            break;\n\n        memcpy (wps->wphdr.ckID, \"wvpk\", 4);\n        wps->wphdr.ckSize = sizeof (WavpackHeader) - 8;\n        SET_TOTAL_SAMPLES (wps->wphdr, wpc->total_samples);\n        wps->wphdr.version = wpc->stream_version;\n        wps->wphdr.flags = flags;\n        wps->bits = bps;\n\n        if (!wpc->current_stream)\n            wps->wphdr.flags |= INITIAL_BLOCK;\n\n        if (!num_chans)\n            wps->wphdr.flags |= FINAL_BLOCK;\n\n        if (chans == 1) {\n            wps->wphdr.flags &= ~(JOINT_STEREO | CROSS_DECORR | HYBRID_BALANCE);\n            wps->wphdr.flags |= MONO_FLAG;\n        }\n    }\n\n    wpc->num_streams = wpc->current_stream;\n    wpc->current_stream = 0;\n\n    if (num_chans) {\n        strcpy (wpc->error_message, \"too many channels!\");\n        return FALSE;\n    }\n\n    if (config->flags & CONFIG_EXTRA_MODE)\n        wpc->config.xmode = config->xmode ? config->xmode : 1;\n\n    return TRUE;\n}",
        "func": "int WavpackSetConfiguration64 (WavpackContext *wpc, WavpackConfig *config, int64_t total_samples, const unsigned char *chan_ids)\n{\n    uint32_t flags, bps = 0;\n    uint32_t chan_mask = config->channel_mask;\n    int num_chans = config->num_channels;\n    int i;\n\n    if (!config->sample_rate) {\n        strcpy (wpc->error_message, \"sample rate cannot be zero!\");\n        return FALSE;\n    }\n\n    wpc->stream_version = (config->flags & CONFIG_COMPATIBLE_WRITE) ? CUR_STREAM_VERS : MAX_STREAM_VERS;\n\n    if ((config->qmode & QMODE_DSD_AUDIO) && config->bytes_per_sample == 1 && config->bits_per_sample == 8) {\n#ifdef ENABLE_DSD\n        wpc->dsd_multiplier = 1;\n        flags = DSD_FLAG;\n\n        for (i = 14; i >= 0; --i)\n            if (config->sample_rate % sample_rates [i] == 0) {\n                int divisor = config->sample_rate / sample_rates [i];\n\n                if (divisor && (divisor & (divisor - 1)) == 0) {\n                    config->sample_rate /= divisor;\n                    wpc->dsd_multiplier = divisor;\n                    break;\n                }\n            }\n\n        // most options that don't apply to DSD we can simply ignore for now, but NOT hybrid mode!\n        if (config->flags & CONFIG_HYBRID_FLAG) {\n            strcpy (wpc->error_message, \"hybrid mode not available for DSD!\");\n            return FALSE;\n        }\n\n        // with DSD, very few PCM options work (or make sense), so only allow those that do\n        config->flags &= (CONFIG_HIGH_FLAG | CONFIG_MD5_CHECKSUM | CONFIG_PAIR_UNDEF_CHANS);\n        config->float_norm_exp = config->xmode = 0;\n#else\n        strcpy (wpc->error_message, \"libwavpack not configured for DSD!\");\n        return FALSE;\n#endif\n    }\n    else\n        flags = config->bytes_per_sample - 1;\n\n    wpc->total_samples = total_samples;\n    wpc->config.sample_rate = config->sample_rate;\n    wpc->config.num_channels = config->num_channels;\n    wpc->config.channel_mask = config->channel_mask;\n    wpc->config.bits_per_sample = config->bits_per_sample;\n    wpc->config.bytes_per_sample = config->bytes_per_sample;\n    wpc->config.block_samples = config->block_samples;\n    wpc->config.flags = config->flags;\n    wpc->config.qmode = config->qmode;\n\n    if (config->flags & CONFIG_VERY_HIGH_FLAG)\n        wpc->config.flags |= CONFIG_HIGH_FLAG;\n\n    for (i = 0; i < 15; ++i)\n        if (wpc->config.sample_rate == sample_rates [i])\n            break;\n\n    flags |= i << SRATE_LSB;\n\n    // all of this stuff only applies to PCM\n\n    if (!(flags & DSD_FLAG)) {\n        if (config->float_norm_exp) {\n            wpc->config.float_norm_exp = config->float_norm_exp;\n            wpc->config.flags |= CONFIG_FLOAT_DATA;\n            flags |= FLOAT_DATA;\n        }\n        else\n            flags |= ((config->bytes_per_sample * 8) - config->bits_per_sample) << SHIFT_LSB;\n\n        if (config->flags & CONFIG_HYBRID_FLAG) {\n            flags |= HYBRID_FLAG | HYBRID_BITRATE | HYBRID_BALANCE;\n\n            if (!(wpc->config.flags & CONFIG_SHAPE_OVERRIDE)) {\n                wpc->config.flags |= CONFIG_HYBRID_SHAPE | CONFIG_AUTO_SHAPING;\n                flags |= HYBRID_SHAPE | NEW_SHAPING;\n            }\n            else if (wpc->config.flags & CONFIG_HYBRID_SHAPE) {\n                wpc->config.shaping_weight = config->shaping_weight;\n                flags |= HYBRID_SHAPE | NEW_SHAPING;\n            }\n\n            if (wpc->config.flags & (CONFIG_CROSS_DECORR | CONFIG_OPTIMIZE_WVC))\n                flags |= CROSS_DECORR;\n\n            if (config->flags & CONFIG_BITRATE_KBPS) {\n                bps = (uint32_t) floor (config->bitrate * 256000.0 / config->sample_rate / config->num_channels + 0.5);\n\n                if (bps > (64 << 8))\n                    bps = 64 << 8;\n            }\n            else\n                bps = (uint32_t) floor (config->bitrate * 256.0 + 0.5);\n        }\n        else\n            flags |= CROSS_DECORR;\n\n        if (!(config->flags & CONFIG_JOINT_OVERRIDE) || (config->flags & CONFIG_JOINT_STEREO))\n            flags |= JOINT_STEREO;\n\n        if (config->flags & CONFIG_CREATE_WVC)\n            wpc->wvc_flag = TRUE;\n    }\n\n    // if a channel-identities string was specified, process that here, otherwise all channels\n    // not present in the channel mask are considered \"unassigned\"\n\n    if (chan_ids) {\n        int lastchan = 0, mask_copy = chan_mask;\n\n        if ((int) strlen ((char *) chan_ids) > num_chans) {          // can't be more than num channels!\n            strcpy (wpc->error_message, \"chan_ids longer than num channels!\");\n            return FALSE;\n        }\n\n        // skip past channels that are specified in the channel mask (no reason to store those)\n\n        while (*chan_ids)\n            if (*chan_ids <= 32 && *chan_ids > lastchan && (mask_copy & (1 << (*chan_ids-1)))) {\n                mask_copy &= ~(1 << (*chan_ids-1));\n                lastchan = *chan_ids++;\n            }\n            else\n                break;\n\n        // now scan the string for an actually defined channel (and don't store if there aren't any)\n\n        for (i = 0; chan_ids [i]; i++)\n            if (chan_ids [i] != 0xff) {\n                wpc->channel_identities = (unsigned char *) strdup ((char *) chan_ids);\n                break;\n            }\n    }\n\n    // This loop goes through all the channels and creates the Wavpack \"streams\" for them to go in.\n    // A stream can hold either one or two channels, so we have several rules to determine how many\n    // channels will go in each stream.\n\n    for (wpc->current_stream = 0; num_chans; wpc->current_stream++) {\n        WavpackStream *wps = malloc (sizeof (WavpackStream));\n        unsigned char left_chan_id = 0, right_chan_id = 0;\n        int pos, chans = 1;\n\n        // allocate the stream and initialize the pointer to it\n        wpc->streams = realloc (wpc->streams, (wpc->current_stream + 1) * sizeof (wpc->streams [0]));\n        wpc->streams [wpc->current_stream] = wps;\n        CLEAR (*wps);\n\n        // if there are any bits [still] set in the channel_mask, get the next one or two IDs from there\n        if (chan_mask)\n            for (pos = 0; pos < 32; ++pos)\n                if (chan_mask & (1 << pos)) {\n                    if (left_chan_id) {\n                        right_chan_id = pos + 1;\n                        break;\n                    }\n                    else {\n                        chan_mask &= ~(1 << pos);\n                        left_chan_id = pos + 1;\n                    }\n                }\n\n        // next check for any channels identified in the channel-identities string\n        while (!right_chan_id && chan_ids && *chan_ids)\n            if (left_chan_id)\n                right_chan_id = *chan_ids;\n            else\n                left_chan_id = *chan_ids++;\n\n        // assume anything we did not get is \"unassigned\"\n        if (!left_chan_id)\n            left_chan_id = right_chan_id = 0xff;\n        else if (!right_chan_id)\n            right_chan_id = 0xff;\n\n        // if we have 2 channels, this is where we decide if we can combine them into one stream:\n        // 1. they are \"unassigned\" and we've been told to combine unassigned pairs, or\n        // 2. they appear together in the valid \"pairings\" list\n        if (num_chans >= 2) {\n            if ((config->flags & CONFIG_PAIR_UNDEF_CHANS) && left_chan_id == 0xff && right_chan_id == 0xff)\n                chans = 2;\n            else\n                for (i = 0; i < NUM_STEREO_PAIRS; ++i)\n                    if ((left_chan_id == stereo_pairs [i].a && right_chan_id == stereo_pairs [i].b) ||\n                        (left_chan_id == stereo_pairs [i].b && right_chan_id == stereo_pairs [i].a)) {\n                            if (right_chan_id <= 32 && (chan_mask & (1 << (right_chan_id-1))))\n                                chan_mask &= ~(1 << (right_chan_id-1));\n                            else if (chan_ids && *chan_ids == right_chan_id)\n                                chan_ids++;\n\n                            chans = 2;\n                            break;\n                        }\n        }\n\n        num_chans -= chans;\n\n        if (num_chans && wpc->current_stream == NEW_MAX_STREAMS - 1)\n            break;\n\n        memcpy (wps->wphdr.ckID, \"wvpk\", 4);\n        wps->wphdr.ckSize = sizeof (WavpackHeader) - 8;\n        SET_TOTAL_SAMPLES (wps->wphdr, wpc->total_samples);\n        wps->wphdr.version = wpc->stream_version;\n        wps->wphdr.flags = flags;\n        wps->bits = bps;\n\n        if (!wpc->current_stream)\n            wps->wphdr.flags |= INITIAL_BLOCK;\n\n        if (!num_chans)\n            wps->wphdr.flags |= FINAL_BLOCK;\n\n        if (chans == 1) {\n            wps->wphdr.flags &= ~(JOINT_STEREO | CROSS_DECORR | HYBRID_BALANCE);\n            wps->wphdr.flags |= MONO_FLAG;\n        }\n    }\n\n    wpc->num_streams = wpc->current_stream;\n    wpc->current_stream = 0;\n\n    if (num_chans) {\n        strcpy (wpc->error_message, \"too many channels!\");\n        return FALSE;\n    }\n\n    if (config->flags & CONFIG_EXTRA_MODE)\n        wpc->config.xmode = config->xmode ? config->xmode : 1;\n\n    return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,11 @@\n     uint32_t chan_mask = config->channel_mask;\n     int num_chans = config->num_channels;\n     int i;\n+\n+    if (!config->sample_rate) {\n+        strcpy (wpc->error_message, \"sample rate cannot be zero!\");\n+        return FALSE;\n+    }\n \n     wpc->stream_version = (config->flags & CONFIG_COMPATIBLE_WRITE) ? CUR_STREAM_VERS : MAX_STREAM_VERS;\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    if (!config->sample_rate) {",
                "        strcpy (wpc->error_message, \"sample rate cannot be zero!\");",
                "        return FALSE;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-5813",
        "func_name": "LibRaw/parse_minolta",
        "description": "An error within the \"parse_minolta()\" function (dcraw/dcraw.c) in LibRaw versions prior to 0.18.11 can be exploited to trigger an infinite loop via a specially crafted file.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/e47384546b43d0fd536e933249047bc397a4d88b",
        "commit_title": "Secunia Advisory SA83050: possible infinite loop in parse_minolta()",
        "commit_text": "",
        "func_before": "void CLASS parse_minolta(int base)\n{\n  int save, tag, len, offset, high = 0, wide = 0, i, c;\n  short sorder = order;\n\n  fseek(ifp, base, SEEK_SET);\n  if (fgetc(ifp) || fgetc(ifp) - 'M' || fgetc(ifp) - 'R')\n    return;\n  order = fgetc(ifp) * 0x101;\n  offset = base + get4() + 8;\n  while ((save = ftell(ifp)) < offset)\n  {\n    for (tag = i = 0; i < 4; i++)\n      tag = tag << 8 | fgetc(ifp);\n    len = get4();\n    switch (tag)\n    {\n    case 0x505244: /* PRD */\n      fseek(ifp, 8, SEEK_CUR);\n      high = get2();\n      wide = get2();\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.makernotes.sony.prd_ImageHeight = get2();\n      imgdata.makernotes.sony.prd_ImageWidth = get2();\n      fseek(ifp, 1L, SEEK_CUR);\n      imgdata.makernotes.sony.prd_RawBitDepth = (ushort)fgetc(ifp);\n      imgdata.makernotes.sony.prd_StorageMethod = (ushort)fgetc(ifp);\n      fseek(ifp, 4L, SEEK_CUR);\n      imgdata.makernotes.sony.prd_BayerPattern = (ushort)fgetc(ifp);\n#endif\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0x524946: /* RIF */\n      if (!strncasecmp(model, \"DSLR-A100\", 9))\n      {\n        fseek(ifp, 8, SEEK_CUR);\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();\n        get4();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] =\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] =\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] =\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] =\n                        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] =\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] =\n                                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1] =\n                                    imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] =\n                                        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] =\n                                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] =\n                                                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][1] =\n                                                    imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][3] = 0x100;\n      }\n      break;\n#endif\n    case 0x574247: /* WBG */\n      get4();\n      i = strcmp(model, \"DiMAGE A200\") ? 0 : 3;\n      FORC4 cam_mul[c ^ (c >> 1) ^ i] = get2();\n      break;\n    case 0x545457: /* TTW */\n      parse_tiff(ftell(ifp));\n      data_offset = offset;\n    }\n    fseek(ifp, save + len + 8, SEEK_SET);\n  }\n  raw_height = high;\n  raw_width = wide;\n  order = sorder;\n}",
        "func": "void CLASS parse_minolta(int base)\n{\n  int save, tag, len, offset, high = 0, wide = 0, i, c;\n  short sorder = order;\n\n  fseek(ifp, base, SEEK_SET);\n  if (fgetc(ifp) || fgetc(ifp) - 'M' || fgetc(ifp) - 'R')\n    return;\n  order = fgetc(ifp) * 0x101;\n  offset = base + get4() + 8;\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(offset>ifp->size()-8) // At least 8 bytes for tag/len\n    offset = ifp->size()-8;\n#endif\n\n  while ((save = ftell(ifp)) < offset)\n  {\n    for (tag = i = 0; i < 4; i++)\n      tag = tag << 8 | fgetc(ifp);\n    len = get4();\n    if(len < 0)\n      return; // just ignore wrong len?? or raise bad file exception?\n    switch (tag)\n    {\n    case 0x505244: /* PRD */\n      fseek(ifp, 8, SEEK_CUR);\n      high = get2();\n      wide = get2();\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.makernotes.sony.prd_ImageHeight = get2();\n      imgdata.makernotes.sony.prd_ImageWidth = get2();\n      fseek(ifp, 1L, SEEK_CUR);\n      imgdata.makernotes.sony.prd_RawBitDepth = (ushort)fgetc(ifp);\n      imgdata.makernotes.sony.prd_StorageMethod = (ushort)fgetc(ifp);\n      fseek(ifp, 4L, SEEK_CUR);\n      imgdata.makernotes.sony.prd_BayerPattern = (ushort)fgetc(ifp);\n#endif\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0x524946: /* RIF */\n      if (!strncasecmp(model, \"DSLR-A100\", 9))\n      {\n        fseek(ifp, 8, SEEK_CUR);\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();\n        get4();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] =\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] =\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] =\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] =\n                        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] =\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] =\n                                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1] =\n                                    imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] =\n                                        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] =\n                                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] =\n                                                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][1] =\n                                                    imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][3] = 0x100;\n      }\n      break;\n#endif\n    case 0x574247: /* WBG */\n      get4();\n      i = strcmp(model, \"DiMAGE A200\") ? 0 : 3;\n      FORC4 cam_mul[c ^ (c >> 1) ^ i] = get2();\n      break;\n    case 0x545457: /* TTW */\n      parse_tiff(ftell(ifp));\n      data_offset = offset;\n    }\n    fseek(ifp, save + len + 8, SEEK_SET);\n  }\n  raw_height = high;\n  raw_width = wide;\n  order = sorder;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,11 +8,18 @@\n     return;\n   order = fgetc(ifp) * 0x101;\n   offset = base + get4() + 8;\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(offset>ifp->size()-8) // At least 8 bytes for tag/len\n+    offset = ifp->size()-8;\n+#endif\n+\n   while ((save = ftell(ifp)) < offset)\n   {\n     for (tag = i = 0; i < 4; i++)\n       tag = tag << 8 | fgetc(ifp);\n     len = get4();\n+    if(len < 0)\n+      return; // just ignore wrong len?? or raise bad file exception?\n     switch (tag)\n     {\n     case 0x505244: /* PRD */",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifdef LIBRAW_LIBRARY_BUILD",
                "  if(offset>ifp->size()-8) // At least 8 bytes for tag/len",
                "    offset = ifp->size()-8;",
                "#endif",
                "",
                "    if(len < 0)",
                "      return; // just ignore wrong len?? or raise bad file exception?"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-5813",
        "func_name": "LibRaw/parse_minolta",
        "description": "An error within the \"parse_minolta()\" function (dcraw/dcraw.c) in LibRaw versions prior to 0.18.11 can be exploited to trigger an infinite loop via a specially crafted file.",
        "git_url": "https://github.com/LibRaw/LibRaw/commit/e47384546b43d0fd536e933249047bc397a4d88b",
        "commit_title": "Secunia Advisory SA83050: possible infinite loop in parse_minolta()",
        "commit_text": "",
        "func_before": "void CLASS parse_minolta(int base)\n{\n  int save, tag, len, offset, high = 0, wide = 0, i, c;\n  short sorder = order;\n\n  fseek(ifp, base, SEEK_SET);\n  if (fgetc(ifp) || fgetc(ifp) - 'M' || fgetc(ifp) - 'R')\n    return;\n  order = fgetc(ifp) * 0x101;\n  offset = base + get4() + 8;\n  while ((save = ftell(ifp)) < offset)\n  {\n    for (tag = i = 0; i < 4; i++)\n      tag = tag << 8 | fgetc(ifp);\n    len = get4();\n    switch (tag)\n    {\n    case 0x505244: /* PRD */\n      fseek(ifp, 8, SEEK_CUR);\n      high = get2();\n      wide = get2();\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.makernotes.sony.prd_ImageHeight = get2();\n      imgdata.makernotes.sony.prd_ImageWidth = get2();\n      fseek(ifp, 1L, SEEK_CUR);\n      imgdata.makernotes.sony.prd_RawBitDepth = (ushort)fgetc(ifp);\n      imgdata.makernotes.sony.prd_StorageMethod = (ushort)fgetc(ifp);\n      fseek(ifp, 4L, SEEK_CUR);\n      imgdata.makernotes.sony.prd_BayerPattern = (ushort)fgetc(ifp);\n#endif\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0x524946: /* RIF */\n      if (!strncasecmp(model, \"DSLR-A100\", 9))\n      {\n        fseek(ifp, 8, SEEK_CUR);\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();\n        get4();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] =\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] =\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] =\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] =\n                        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] =\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] =\n                                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1] =\n                                    imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] =\n                                        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] =\n                                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] =\n                                                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][1] =\n                                                    imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][3] = 0x100;\n      }\n      break;\n#endif\n    case 0x574247: /* WBG */\n      get4();\n      i = strcmp(model, \"DiMAGE A200\") ? 0 : 3;\n      FORC4 cam_mul[c ^ (c >> 1) ^ i] = get2();\n      break;\n    case 0x545457: /* TTW */\n      parse_tiff(ftell(ifp));\n      data_offset = offset;\n    }\n    fseek(ifp, save + len + 8, SEEK_SET);\n  }\n  raw_height = high;\n  raw_width = wide;\n  order = sorder;\n}",
        "func": "void CLASS parse_minolta(int base)\n{\n  int save, tag, len, offset, high = 0, wide = 0, i, c;\n  short sorder = order;\n\n  fseek(ifp, base, SEEK_SET);\n  if (fgetc(ifp) || fgetc(ifp) - 'M' || fgetc(ifp) - 'R')\n    return;\n  order = fgetc(ifp) * 0x101;\n  offset = base + get4() + 8;\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(offset>ifp->size()-8) // At least 8 bytes for tag/len\n    offset = ifp->size()-8;\n#endif\n\n  while ((save = ftell(ifp)) < offset)\n  {\n    for (tag = i = 0; i < 4; i++)\n      tag = tag << 8 | fgetc(ifp);\n    len = get4();\n    if(len < 0)\n      return; // just ignore wrong len?? or raise bad file exception?\n    switch (tag)\n    {\n    case 0x505244: /* PRD */\n      fseek(ifp, 8, SEEK_CUR);\n      high = get2();\n      wide = get2();\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.makernotes.sony.prd_ImageHeight = get2();\n      imgdata.makernotes.sony.prd_ImageWidth = get2();\n      fseek(ifp, 1L, SEEK_CUR);\n      imgdata.makernotes.sony.prd_RawBitDepth = (ushort)fgetc(ifp);\n      imgdata.makernotes.sony.prd_StorageMethod = (ushort)fgetc(ifp);\n      fseek(ifp, 4L, SEEK_CUR);\n      imgdata.makernotes.sony.prd_BayerPattern = (ushort)fgetc(ifp);\n#endif\n      break;\n#ifdef LIBRAW_LIBRARY_BUILD\n    case 0x524946: /* RIF */\n      if (!strncasecmp(model, \"DSLR-A100\", 9))\n      {\n        fseek(ifp, 8, SEEK_CUR);\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][2] = get2();\n        get4();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][0] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][2] = get2();\n        imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][3] =\n            imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][3] =\n                imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][3] =\n                    imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][3] =\n                        imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][3] =\n                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][1] = imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_D][3] =\n                                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][1] =\n                                    imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_N][3] =\n                                        imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][1] =\n                                            imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][3] =\n                                                imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][1] =\n                                                    imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_WW][3] = 0x100;\n      }\n      break;\n#endif\n    case 0x574247: /* WBG */\n      get4();\n      i = strcmp(model, \"DiMAGE A200\") ? 0 : 3;\n      FORC4 cam_mul[c ^ (c >> 1) ^ i] = get2();\n      break;\n    case 0x545457: /* TTW */\n      parse_tiff(ftell(ifp));\n      data_offset = offset;\n    }\n    fseek(ifp, save + len + 8, SEEK_SET);\n  }\n  raw_height = high;\n  raw_width = wide;\n  order = sorder;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,11 +8,18 @@\n     return;\n   order = fgetc(ifp) * 0x101;\n   offset = base + get4() + 8;\n+#ifdef LIBRAW_LIBRARY_BUILD\n+  if(offset>ifp->size()-8) // At least 8 bytes for tag/len\n+    offset = ifp->size()-8;\n+#endif\n+\n   while ((save = ftell(ifp)) < offset)\n   {\n     for (tag = i = 0; i < 4; i++)\n       tag = tag << 8 | fgetc(ifp);\n     len = get4();\n+    if(len < 0)\n+      return; // just ignore wrong len?? or raise bad file exception?\n     switch (tag)\n     {\n     case 0x505244: /* PRD */",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifdef LIBRAW_LIBRARY_BUILD",
                "  if(offset>ifp->size()-8) // At least 8 bytes for tag/len",
                "    offset = ifp->size()-8;",
                "#endif",
                "",
                "    if(len < 0)",
                "      return; // just ignore wrong len?? or raise bad file exception?"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-20096",
        "func_name": "Exiv2/exiv2/TiffParserWorker::findPrimaryGroups",
        "description": "There is a heap-based buffer over-read in the Exiv2::tEXtToDataBuf function of pngimage.cpp in Exiv2 0.27-RC3. A crafted input will lead to a remote denial of service attack.",
        "git_url": "https://github.com/Exiv2/exiv2/commit/203ab0db28c9666b16069d4056ac5f66f753a51d",
        "commit_title": "Fixing #590 for tiffimage_int-out-of-bound-read-poc-2.dms",
        "commit_text": "",
        "func_before": "void TiffParserWorker::findPrimaryGroups(PrimaryGroups& primaryGroups,\n                                             TiffComponent* pSourceDir)\n    {\n        if (0 == pSourceDir) return;\n\n        const IfdId imageGroups[] = {\n            ifd0Id,\n            ifd1Id,\n            ifd2Id,\n            ifd3Id,\n            subImage1Id,\n            subImage2Id,\n            subImage3Id,\n            subImage4Id,\n            subImage5Id,\n            subImage6Id,\n            subImage7Id,\n            subImage8Id,\n            subImage9Id\n        };\n\n        for (unsigned int i = 0; i < EXV_COUNTOF(imageGroups); ++i) {\n            TiffFinder finder(0x00fe, imageGroups[i]);\n            pSourceDir->accept(finder);\n            TiffEntryBase* te = dynamic_cast<TiffEntryBase*>(finder.result());\n            if (   te\n                && te->pValue()->typeId() == unsignedLong\n                && te->pValue()->count() == 1\n                && (te->pValue()->toLong() & 1) == 0) {\n                primaryGroups.push_back(te->group());\n            }\n        }\n\n    }",
        "func": "void TiffParserWorker::findPrimaryGroups(PrimaryGroups& primaryGroups,\n                                             TiffComponent* pSourceDir)\n    {\n        if (0 == pSourceDir) return;\n\n        const IfdId imageGroups[] = {\n            ifd0Id,\n            ifd1Id,\n            ifd2Id,\n            ifd3Id,\n            subImage1Id,\n            subImage2Id,\n            subImage3Id,\n            subImage4Id,\n            subImage5Id,\n            subImage6Id,\n            subImage7Id,\n            subImage8Id,\n            subImage9Id\n        };\n\n        for (unsigned int i = 0; i < EXV_COUNTOF(imageGroups); ++i) {\n            TiffFinder finder(0x00fe, imageGroups[i]);\n            pSourceDir->accept(finder);\n            TiffEntryBase* te = dynamic_cast<TiffEntryBase*>(finder.result());\n            if (   te ) {\n                if (te->pValue()) {\n                    if (te->pValue()->typeId() == unsignedLong\n                        && te->pValue()->count() == 1\n                        && (te->pValue()->toLong() & 1) == 0) {\n                        primaryGroups.push_back(te->group());\n                    }\n                }\n            }\n        }\n\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,11 +23,14 @@\n             TiffFinder finder(0x00fe, imageGroups[i]);\n             pSourceDir->accept(finder);\n             TiffEntryBase* te = dynamic_cast<TiffEntryBase*>(finder.result());\n-            if (   te\n-                && te->pValue()->typeId() == unsignedLong\n-                && te->pValue()->count() == 1\n-                && (te->pValue()->toLong() & 1) == 0) {\n-                primaryGroups.push_back(te->group());\n+            if (   te ) {\n+                if (te->pValue()) {\n+                    if (te->pValue()->typeId() == unsignedLong\n+                        && te->pValue()->count() == 1\n+                        && (te->pValue()->toLong() & 1) == 0) {\n+                        primaryGroups.push_back(te->group());\n+                    }\n+                }\n             }\n         }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "            if (   te",
                "                && te->pValue()->typeId() == unsignedLong",
                "                && te->pValue()->count() == 1",
                "                && (te->pValue()->toLong() & 1) == 0) {",
                "                primaryGroups.push_back(te->group());"
            ],
            "added_lines": [
                "            if (   te ) {",
                "                if (te->pValue()) {",
                "                    if (te->pValue()->typeId() == unsignedLong",
                "                        && te->pValue()->count() == 1",
                "                        && (te->pValue()->toLong() & 1) == 0) {",
                "                        primaryGroups.push_back(te->group());",
                "                    }",
                "                }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-20096",
        "func_name": "Exiv2/exiv2/Jp2Image::readMetadata",
        "description": "There is a heap-based buffer over-read in the Exiv2::tEXtToDataBuf function of pngimage.cpp in Exiv2 0.27-RC3. A crafted input will lead to a remote denial of service attack.",
        "git_url": "https://github.com/Exiv2/exiv2/commit/eff0f52d0466d81beabf304e2500f3039fd90252",
        "commit_title": "Fix JP2000 pocs in https://github.com/Exiv2/exiv2/issues/590",
        "commit_text": "",
        "func_before": "void Jp2Image::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Exiv2::Jp2Image::readMetadata: Reading JPEG-2000 file \" << io_->path() << std::endl;\n#endif\n        if (io_->open() != 0)\n        {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        // Ensure that this is the correct image type\n        if (!isJp2Type(*io_, true))\n        {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"JPEG-2000\");\n        }\n\n        long              position  = 0;\n        Jp2BoxHeader      box       = {0,0};\n        Jp2BoxHeader      subBox    = {0,0};\n        Jp2ImageHeaderBox ihdr      = {0,0,0,0,0,0,0,0};\n        Jp2UuidBox        uuid      = {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};\n\n        while (io_->read((byte*)&box, sizeof(box)) == sizeof(box))\n        {\n            position   = io_->tell();\n            box.length = getLong((byte*)&box.length, bigEndian);\n            box.type   = getLong((byte*)&box.type, bigEndian);\n#ifdef DEBUG\n            std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                      << \"Position: \" << position\n                      << \" box type: \" << toAscii(box.type)\n                      << \" length: \" << box.length\n                      << std::endl;\n#endif\n\n            if (box.length == 0) return ;\n\n            if (box.length == 1)\n            {\n                // FIXME. Special case. the real box size is given in another place.\n            }\n\n            switch(box.type)\n            {\n                case kJp2BoxTypeJp2Header:\n                {\n#ifdef DEBUG\n                    std::cout << \"Exiv2::Jp2Image::readMetadata: JP2Header box found\" << std::endl;\n#endif\n                    long restore = io_->tell();\n\n                    while (io_->read((byte*)&subBox, sizeof(subBox)) == sizeof(subBox) && subBox.length )\n                    {\n                        subBox.length = getLong((byte*)&subBox.length, bigEndian);\n                        subBox.type   = getLong((byte*)&subBox.type, bigEndian);\n#ifdef DEBUG\n                        std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                        << \"subBox = \" << toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;\n#endif\n                        if(subBox.type == kJp2BoxTypeColorHeader && subBox.length != 15)\n                        {\n#ifdef DEBUG\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                                     << \"Color data found\" << std::endl;\n#endif\n\n                            const long pad = 3 ; // 3 padding bytes 2 0 0\n                            const size_t data_length = Safe::add(subBox.length, static_cast<uint32_t>(8));\n                            // data_length makes no sense if it is larger than the rest of the file\n                            if (data_length > io_->size() - io_->tell()) {\n                                throw Error(kerCorruptedMetadata);\n                            }\n                            DataBuf data(static_cast<long>(data_length));\n                            io_->read(data.pData_,data.size_);\n                            const long    iccLength = getULong(data.pData_+pad, bigEndian);\n                            // subtracting pad from data.size_ is safe:\n                            // size_ is at least 8 and pad = 3\n                            if (iccLength > data.size_ - pad) {\n                                throw Error(kerCorruptedMetadata);\n                            }\n                            DataBuf icc(iccLength);\n                            ::memcpy(icc.pData_,data.pData_+pad,icc.size_);\n#ifdef DEBUG\n                            const char* iccPath = \"/tmp/libexiv2_jp2.icc\";\n                            FILE* f = fopen(iccPath,\"wb\");\n                            if ( f ) {\n                                fwrite(icc.pData_,icc.size_,1,f);\n                                fclose(f);\n                            }\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: wrote iccProfile \" << icc.size_<< \" bytes to \" << iccPath << std::endl ;\n#endif\n                            setIccProfile(icc);\n                        }\n\n                        if( subBox.type == kJp2BoxTypeImageHeader)\n                        {\n                            io_->read((byte*)&ihdr, sizeof(ihdr));\n#ifdef DEBUG\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: Ihdr data found\" << std::endl;\n#endif\n                            ihdr.imageHeight            = getLong((byte*)&ihdr.imageHeight, bigEndian);\n                            ihdr.imageWidth             = getLong((byte*)&ihdr.imageWidth, bigEndian);\n                            ihdr.componentCount         = getShort((byte*)&ihdr.componentCount, bigEndian);\n                            ihdr.compressionTypeProfile = getShort((byte*)&ihdr.compressionTypeProfile, bigEndian);\n\n                            pixelWidth_  = ihdr.imageWidth;\n                            pixelHeight_ = ihdr.imageHeight;\n                        }\n\n                        io_->seek(restore,BasicIo::beg);\n                        io_->seek(subBox.length, Exiv2::BasicIo::cur);\n                        restore = io_->tell();\n                    }\n                    break;\n                }\n\n                case kJp2BoxTypeUuid:\n                {\n#ifdef DEBUG\n                    std::cout << \"Exiv2::Jp2Image::readMetadata: UUID box found\" << std::endl;\n#endif\n\n                    if (io_->read((byte*)&uuid, sizeof(uuid)) == sizeof(uuid))\n                    {\n                        DataBuf rawData;\n                        long    bufRead;\n                        bool    bIsExif = memcmp(uuid.uuid, kJp2UuidExif, sizeof(uuid))==0;\n                        bool    bIsIPTC = memcmp(uuid.uuid, kJp2UuidIptc, sizeof(uuid))==0;\n                        bool    bIsXMP  = memcmp(uuid.uuid, kJp2UuidXmp , sizeof(uuid))==0;\n\n                        if(bIsExif)\n                        {\n#ifdef DEBUG\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Exif data found\" << std::endl ;\n#endif\n                            rawData.alloc(box.length - (sizeof(box) + sizeof(uuid)));\n                            bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error()) throw Error(kerFailedToReadImageData);\n                            if (bufRead != rawData.size_) throw Error(kerInputDataReadFailed);\n\n                            if (rawData.size_ > 0)\n                            {\n                                // Find the position of Exif header in bytes array.\n                                long pos = (     (rawData.pData_[0]      == rawData.pData_[1])\n                                           &&    (rawData.pData_[0]=='I' || rawData.pData_[0]=='M')\n                                           )  ? 0 : -1;\n\n                                // #1242  Forgive having Exif\\0\\0 in rawData.pData_\n                                const byte exifHeader[] = { 0x45, 0x78, 0x69, 0x66, 0x00, 0x00 };\n                                for (long i=0 ; pos < 0 && i < rawData.size_-(long)sizeof(exifHeader) ; i++)\n                                {\n                                    if (memcmp(exifHeader, &rawData.pData_[i], sizeof(exifHeader)) == 0)\n                                    {\n                                        pos = i+sizeof(exifHeader);\n#ifndef SUPPRESS_WARNINGS\n                                        EXV_WARNING << \"Reading non-standard UUID-EXIF_bad box in \" << io_->path() << std::endl;\n#endif\n\n                                    }\n                                }\n\n                                // If found it, store only these data at from this place.\n                                if (pos >= 0 )\n                                {\n#ifdef DEBUG\n                                    std::cout << \"Exiv2::Jp2Image::readMetadata: Exif header found at position \" << pos << std::endl;\n#endif\n                                    ByteOrder bo = TiffParser::decode(exifData(),\n                                                                      iptcData(),\n                                                                      xmpData(),\n                                                                      rawData.pData_ + pos,\n                                                                      rawData.size_ - pos);\n                                    setByteOrder(bo);\n                                }\n                            }\n                            else\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Failed to decode Exif metadata.\" << std::endl;\n#endif\n                                exifData_.clear();\n                            }\n                        }\n\n                        if(bIsIPTC)\n                        {\n#ifdef DEBUG\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Iptc data found\" << std::endl;\n#endif\n                            rawData.alloc(box.length - (sizeof(box) + sizeof(uuid)));\n                            bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error()) throw Error(kerFailedToReadImageData);\n                            if (bufRead != rawData.size_) throw Error(kerInputDataReadFailed);\n\n                            if (IptcParser::decode(iptcData_, rawData.pData_, rawData.size_))\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Failed to decode IPTC metadata.\" << std::endl;\n#endif\n                                iptcData_.clear();\n                            }\n                        }\n\n                        if(bIsXMP)\n                        {\n#ifdef DEBUG\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Xmp data found\" << std::endl;\n#endif\n                            rawData.alloc(box.length - (uint32_t)(sizeof(box) + sizeof(uuid)));\n                            bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error()) throw Error(kerFailedToReadImageData);\n                            if (bufRead != rawData.size_) throw Error(kerInputDataReadFailed);\n                            xmpPacket_.assign(reinterpret_cast<char *>(rawData.pData_), rawData.size_);\n\n                            std::string::size_type idx = xmpPacket_.find_first_of('<');\n                            if (idx != std::string::npos && idx > 0)\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Removing \" << static_cast<uint32_t>(idx)\n                                            << \" characters from the beginning of the XMP packet\" << std::endl;\n#endif\n                                xmpPacket_ = xmpPacket_.substr(idx);\n                            }\n\n                            if (xmpPacket_.size() > 0 && XmpParser::decode(xmpData_, xmpPacket_))\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Failed to decode XMP metadata.\" << std::endl;\n#endif\n                            }\n                        }\n                    }\n                    break;\n                }\n\n                default:\n                {\n                    break;\n                }\n            }\n\n            // Move to the next box.\n            io_->seek(static_cast<long>(position - sizeof(box) + box.length), BasicIo::beg);\n            if (io_->error()) throw Error(kerFailedToReadImageData);\n        }\n\n    }",
        "func": "void Jp2Image::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Exiv2::Jp2Image::readMetadata: Reading JPEG-2000 file \" << io_->path() << std::endl;\n#endif\n        if (io_->open() != 0)\n        {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        // Ensure that this is the correct image type\n        if (!isJp2Type(*io_, true))\n        {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"JPEG-2000\");\n        }\n\n        long              position  = 0;\n        Jp2BoxHeader      box       = {0,0};\n        Jp2BoxHeader      subBox    = {0,0};\n        Jp2ImageHeaderBox ihdr      = {0,0,0,0,0,0,0,0};\n        Jp2UuidBox        uuid      = {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};\n\n        while (io_->read((byte*)&box, sizeof(box)) == sizeof(box))\n        {\n            position   = io_->tell();\n            box.length = getLong((byte*)&box.length, bigEndian);\n            box.type   = getLong((byte*)&box.type, bigEndian);\n            if ( box.length > io_->size() ) {\n                throw Error(kerCorruptedMetadata);\n            }\n#ifdef DEBUG\n            std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                      << \"Position: \" << position\n                      << \" box type: \" << toAscii(box.type)\n                      << \" length: \" << box.length\n                      << std::endl;\n#endif\n\n            if (box.length == 0) return ;\n\n            if (box.length == 1)\n            {\n                // FIXME. Special case. the real box size is given in another place.\n            }\n\n            switch(box.type)\n            {\n                case kJp2BoxTypeJp2Header:\n                {\n#ifdef DEBUG\n                    std::cout << \"Exiv2::Jp2Image::readMetadata: JP2Header box found\" << std::endl;\n#endif\n                    long restore = io_->tell();\n\n                    while (io_->read((byte*)&subBox, sizeof(subBox)) == sizeof(subBox) && subBox.length )\n                    {\n                        subBox.length = getLong((byte*)&subBox.length, bigEndian);\n                        subBox.type   = getLong((byte*)&subBox.type, bigEndian);\n                        if ( subBox.length > io().size() ) {\n                            throw Error(kerCorruptedMetadata);\n                        }\n#ifdef DEBUG\n                        std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                        << \"subBox = \" << toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;\n#endif\n                        if(subBox.type == kJp2BoxTypeColorHeader && subBox.length != 15)\n                        {\n#ifdef DEBUG\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                                     << \"Color data found\" << std::endl;\n#endif\n\n                            const long pad = 3 ; // 3 padding bytes 2 0 0\n                            const size_t data_length = Safe::add(subBox.length, static_cast<uint32_t>(8));\n                            // data_length makes no sense if it is larger than the rest of the file\n                            if (data_length > io_->size() - io_->tell()) {\n                                throw Error(kerCorruptedMetadata);\n                            }\n                            DataBuf data(static_cast<long>(data_length));\n                            io_->read(data.pData_,data.size_);\n                            const long    iccLength = getULong(data.pData_+pad, bigEndian);\n                            // subtracting pad from data.size_ is safe:\n                            // size_ is at least 8 and pad = 3\n                            if (iccLength > data.size_ - pad) {\n                                throw Error(kerCorruptedMetadata);\n                            }\n                            DataBuf icc(iccLength);\n                            ::memcpy(icc.pData_,data.pData_+pad,icc.size_);\n#ifdef DEBUG\n                            const char* iccPath = \"/tmp/libexiv2_jp2.icc\";\n                            FILE* f = fopen(iccPath,\"wb\");\n                            if ( f ) {\n                                fwrite(icc.pData_,icc.size_,1,f);\n                                fclose(f);\n                            }\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: wrote iccProfile \" << icc.size_<< \" bytes to \" << iccPath << std::endl ;\n#endif\n                            setIccProfile(icc);\n                        }\n\n                        if( subBox.type == kJp2BoxTypeImageHeader)\n                        {\n                            io_->read((byte*)&ihdr, sizeof(ihdr));\n#ifdef DEBUG\n                            std::cout << \"Exiv2::Jp2Image::readMetadata: Ihdr data found\" << std::endl;\n#endif\n                            ihdr.imageHeight            = getLong((byte*)&ihdr.imageHeight, bigEndian);\n                            ihdr.imageWidth             = getLong((byte*)&ihdr.imageWidth, bigEndian);\n                            ihdr.componentCount         = getShort((byte*)&ihdr.componentCount, bigEndian);\n                            ihdr.compressionTypeProfile = getShort((byte*)&ihdr.compressionTypeProfile, bigEndian);\n\n                            pixelWidth_  = ihdr.imageWidth;\n                            pixelHeight_ = ihdr.imageHeight;\n                        }\n\n                        io_->seek(restore,BasicIo::beg);\n                        io_->seek(subBox.length, Exiv2::BasicIo::cur);\n                        restore = io_->tell();\n                    }\n                    break;\n                }\n\n                case kJp2BoxTypeUuid:\n                {\n#ifdef DEBUG\n                    std::cout << \"Exiv2::Jp2Image::readMetadata: UUID box found\" << std::endl;\n#endif\n\n                    if (io_->read((byte*)&uuid, sizeof(uuid)) == sizeof(uuid))\n                    {\n                        DataBuf rawData;\n                        long    bufRead;\n                        bool    bIsExif = memcmp(uuid.uuid, kJp2UuidExif, sizeof(uuid))==0;\n                        bool    bIsIPTC = memcmp(uuid.uuid, kJp2UuidIptc, sizeof(uuid))==0;\n                        bool    bIsXMP  = memcmp(uuid.uuid, kJp2UuidXmp , sizeof(uuid))==0;\n\n                        if(bIsExif)\n                        {\n#ifdef DEBUG\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Exif data found\" << std::endl ;\n#endif\n                            rawData.alloc(box.length - (sizeof(box) + sizeof(uuid)));\n                            bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error()) throw Error(kerFailedToReadImageData);\n                            if (bufRead != rawData.size_) throw Error(kerInputDataReadFailed);\n\n                            if (rawData.size_ > 0)\n                            {\n                                // Find the position of Exif header in bytes array.\n                                long pos = (     (rawData.pData_[0]      == rawData.pData_[1])\n                                           &&    (rawData.pData_[0]=='I' || rawData.pData_[0]=='M')\n                                           )  ? 0 : -1;\n\n                                // #1242  Forgive having Exif\\0\\0 in rawData.pData_\n                                const byte exifHeader[] = { 0x45, 0x78, 0x69, 0x66, 0x00, 0x00 };\n                                for (long i=0 ; pos < 0 && i < rawData.size_-(long)sizeof(exifHeader) ; i++)\n                                {\n                                    if (memcmp(exifHeader, &rawData.pData_[i], sizeof(exifHeader)) == 0)\n                                    {\n                                        pos = i+sizeof(exifHeader);\n#ifndef SUPPRESS_WARNINGS\n                                        EXV_WARNING << \"Reading non-standard UUID-EXIF_bad box in \" << io_->path() << std::endl;\n#endif\n\n                                    }\n                                }\n\n                                // If found it, store only these data at from this place.\n                                if (pos >= 0 )\n                                {\n#ifdef DEBUG\n                                    std::cout << \"Exiv2::Jp2Image::readMetadata: Exif header found at position \" << pos << std::endl;\n#endif\n                                    ByteOrder bo = TiffParser::decode(exifData(),\n                                                                      iptcData(),\n                                                                      xmpData(),\n                                                                      rawData.pData_ + pos,\n                                                                      rawData.size_ - pos);\n                                    setByteOrder(bo);\n                                }\n                            }\n                            else\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Failed to decode Exif metadata.\" << std::endl;\n#endif\n                                exifData_.clear();\n                            }\n                        }\n\n                        if(bIsIPTC)\n                        {\n#ifdef DEBUG\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Iptc data found\" << std::endl;\n#endif\n                            rawData.alloc(box.length - (sizeof(box) + sizeof(uuid)));\n                            bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error()) throw Error(kerFailedToReadImageData);\n                            if (bufRead != rawData.size_) throw Error(kerInputDataReadFailed);\n\n                            if (IptcParser::decode(iptcData_, rawData.pData_, rawData.size_))\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Failed to decode IPTC metadata.\" << std::endl;\n#endif\n                                iptcData_.clear();\n                            }\n                        }\n\n                        if(bIsXMP)\n                        {\n#ifdef DEBUG\n                           std::cout << \"Exiv2::Jp2Image::readMetadata: Xmp data found\" << std::endl;\n#endif\n                            rawData.alloc(box.length - (uint32_t)(sizeof(box) + sizeof(uuid)));\n                            bufRead = io_->read(rawData.pData_, rawData.size_);\n                            if (io_->error()) throw Error(kerFailedToReadImageData);\n                            if (bufRead != rawData.size_) throw Error(kerInputDataReadFailed);\n                            xmpPacket_.assign(reinterpret_cast<char *>(rawData.pData_), rawData.size_);\n\n                            std::string::size_type idx = xmpPacket_.find_first_of('<');\n                            if (idx != std::string::npos && idx > 0)\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Removing \" << static_cast<uint32_t>(idx)\n                                            << \" characters from the beginning of the XMP packet\" << std::endl;\n#endif\n                                xmpPacket_ = xmpPacket_.substr(idx);\n                            }\n\n                            if (xmpPacket_.size() > 0 && XmpParser::decode(xmpData_, xmpPacket_))\n                            {\n#ifndef SUPPRESS_WARNINGS\n                                EXV_WARNING << \"Failed to decode XMP metadata.\" << std::endl;\n#endif\n                            }\n                        }\n                    }\n                    break;\n                }\n\n                default:\n                {\n                    break;\n                }\n            }\n\n            // Move to the next box.\n            io_->seek(static_cast<long>(position - sizeof(box) + box.length), BasicIo::beg);\n            if (io_->error()) throw Error(kerFailedToReadImageData);\n        }\n\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,6 +26,9 @@\n             position   = io_->tell();\n             box.length = getLong((byte*)&box.length, bigEndian);\n             box.type   = getLong((byte*)&box.type, bigEndian);\n+            if ( box.length > io_->size() ) {\n+                throw Error(kerCorruptedMetadata);\n+            }\n #ifdef DEBUG\n             std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                       << \"Position: \" << position\n@@ -54,6 +57,9 @@\n                     {\n                         subBox.length = getLong((byte*)&subBox.length, bigEndian);\n                         subBox.type   = getLong((byte*)&subBox.type, bigEndian);\n+                        if ( subBox.length > io().size() ) {\n+                            throw Error(kerCorruptedMetadata);\n+                        }\n #ifdef DEBUG\n                         std::cout << \"Exiv2::Jp2Image::readMetadata: \"\n                         << \"subBox = \" << toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            if ( box.length > io_->size() ) {",
                "                throw Error(kerCorruptedMetadata);",
                "            }",
                "                        if ( subBox.length > io().size() ) {",
                "                            throw Error(kerCorruptedMetadata);",
                "                        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-20096",
        "func_name": "Exiv2/exiv2/Jp2Image::encodeJp2Header",
        "description": "There is a heap-based buffer over-read in the Exiv2::tEXtToDataBuf function of pngimage.cpp in Exiv2 0.27-RC3. A crafted input will lead to a remote denial of service attack.",
        "git_url": "https://github.com/Exiv2/exiv2/commit/eff0f52d0466d81beabf304e2500f3039fd90252",
        "commit_title": "Fix JP2000 pocs in https://github.com/Exiv2/exiv2/issues/590",
        "commit_text": "",
        "func_before": "void Jp2Image::encodeJp2Header(const DataBuf& boxBuf,DataBuf& outBuf)\n    {\n        DataBuf output(boxBuf.size_ + iccProfile_.size_ + 100); // allocate sufficient space\n        int     outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?\n        int      inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?\n        Jp2BoxHeader* pBox   = (Jp2BoxHeader*) boxBuf.pData_;\n        int32_t       length = getLong((byte*)&pBox->length, bigEndian);\n        int32_t       count  = sizeof (Jp2BoxHeader);\n        char*         p      = (char*) boxBuf.pData_;\n        bool          bWroteColor = false ;\n\n        while ( count < length || !bWroteColor ) {\n            Jp2BoxHeader* pSubBox = (Jp2BoxHeader*) (p+count) ;\n\n            // copy data.  pointer could be into a memory mapped file which we will decode!\n            Jp2BoxHeader   subBox = *pSubBox ;\n            Jp2BoxHeader   newBox =  subBox;\n\n            if ( count < length ) {\n                subBox.length = getLong((byte*)&subBox.length, bigEndian);\n                subBox.type   = getLong((byte*)&subBox.type  , bigEndian);\n#ifdef DEBUG\n                std::cout << \"Jp2Image::encodeJp2Header subbox: \"<< toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;\n#endif\n                count        += subBox.length;\n                newBox.type   = subBox.type;\n            } else {\n                subBox.length=0;\n                newBox.type = kJp2BoxTypeColorHeader;\n                count = length;\n            }\n\n            int32_t newlen = subBox.length;\n            if ( newBox.type == kJp2BoxTypeColorHeader ) {\n                bWroteColor = true ;\n                if ( ! iccProfileDefined() ) {\n                    const char* pad   = \"\\x01\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x05\\x1cuuid\";\n                    uint32_t    psize = 15;\n                    ul2Data((byte*)&newBox.length,psize      ,bigEndian);\n                    ul2Data((byte*)&newBox.type  ,newBox.type,bigEndian);\n                    ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox));\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)      ,pad                ,psize         );\n                    newlen = psize ;\n                } else {\n                    const char* pad   = \"\\0x02\\x00\\x00\";\n                    uint32_t    psize = 3;\n                    ul2Data((byte*)&newBox.length,psize+iccProfile_.size_,bigEndian);\n                    ul2Data((byte*)&newBox.type,newBox.type,bigEndian);\n                    ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)  );\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)      , pad               ,psize           );\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)+psize,iccProfile_.pData_,iccProfile_.size_);\n                    newlen = psize + iccProfile_.size_;\n                }\n            } else {\n                ::memcpy(output.pData_+outlen,boxBuf.pData_+inlen,subBox.length);\n            }\n\n            outlen += newlen;\n            inlen  += subBox.length;\n        }\n\n        // allocate the correct number of bytes, copy the data and update the box header\n        outBuf.alloc(outlen);\n        ::memcpy(outBuf.pData_,output.pData_,outlen);\n        pBox   = (Jp2BoxHeader*) outBuf.pData_;\n        ul2Data((byte*)&pBox->type,kJp2BoxTypeJp2Header,bigEndian);\n        ul2Data((byte*)&pBox->length,outlen,bigEndian);\n    }",
        "func": "void Jp2Image::encodeJp2Header(const DataBuf& boxBuf,DataBuf& outBuf)\n    {\n        DataBuf output(boxBuf.size_ + iccProfile_.size_ + 100); // allocate sufficient space\n        int     outlen = sizeof(Jp2BoxHeader) ; // now many bytes have we written to output?\n        int      inlen = sizeof(Jp2BoxHeader) ; // how many bytes have we read from boxBuf?\n        Jp2BoxHeader* pBox   = (Jp2BoxHeader*) boxBuf.pData_;\n        int32_t       length = getLong((byte*)&pBox->length, bigEndian);\n        int32_t       count  = sizeof (Jp2BoxHeader);\n        char*         p      = (char*) boxBuf.pData_;\n        bool          bWroteColor = false ;\n        int           loops  = 0;\n\n        while ( count < length || !bWroteColor ) {\n            if (++loops > 100 ) {\n                throw Error(kerCorruptedMetadata);\n            }\n            Jp2BoxHeader* pSubBox = (Jp2BoxHeader*) (p+count) ;\n\n            // copy data.  pointer could be into a memory mapped file which we will decode!\n            Jp2BoxHeader   subBox = *pSubBox ;\n            Jp2BoxHeader   newBox =  subBox;\n\n            if ( count < length ) {\n                subBox.length = getLong((byte*)&subBox.length, bigEndian);\n                subBox.type   = getLong((byte*)&subBox.type  , bigEndian);\n#ifdef DEBUG\n                std::cout << \"Jp2Image::encodeJp2Header subbox: \"<< toAscii(subBox.type) << \" length = \" << subBox.length << std::endl;\n#endif\n                count        += subBox.length;\n                newBox.type   = subBox.type;\n            } else {\n                subBox.length=0;\n                newBox.type = kJp2BoxTypeColorHeader;\n                count = length;\n            }\n\n            int32_t newlen = subBox.length;\n            if ( newBox.type == kJp2BoxTypeColorHeader ) {\n                bWroteColor = true ;\n                if ( ! iccProfileDefined() ) {\n                    const char* pad   = \"\\x01\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x05\\x1cuuid\";\n                    uint32_t    psize = 15;\n                    ul2Data((byte*)&newBox.length,psize      ,bigEndian);\n                    ul2Data((byte*)&newBox.type  ,newBox.type,bigEndian);\n                    ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox));\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)      ,pad                ,psize         );\n                    newlen = psize ;\n                } else {\n                    const char* pad   = \"\\0x02\\x00\\x00\";\n                    uint32_t    psize = 3;\n                    ul2Data((byte*)&newBox.length,psize+iccProfile_.size_,bigEndian);\n                    ul2Data((byte*)&newBox.type,newBox.type,bigEndian);\n                    ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)  );\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)      , pad               ,psize           );\n                    ::memcpy(output.pData_+outlen+sizeof(newBox)+psize,iccProfile_.pData_,iccProfile_.size_);\n                    newlen = psize + iccProfile_.size_;\n                }\n            } else {\n                ::memcpy(output.pData_+outlen,boxBuf.pData_+inlen,subBox.length);\n            }\n\n            outlen += newlen;\n            inlen  += subBox.length;\n        }\n\n        // allocate the correct number of bytes, copy the data and update the box header\n        outBuf.alloc(outlen);\n        ::memcpy(outBuf.pData_,output.pData_,outlen);\n        pBox   = (Jp2BoxHeader*) outBuf.pData_;\n        ul2Data((byte*)&pBox->type,kJp2BoxTypeJp2Header,bigEndian);\n        ul2Data((byte*)&pBox->length,outlen,bigEndian);\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,8 +8,12 @@\n         int32_t       count  = sizeof (Jp2BoxHeader);\n         char*         p      = (char*) boxBuf.pData_;\n         bool          bWroteColor = false ;\n+        int           loops  = 0;\n \n         while ( count < length || !bWroteColor ) {\n+            if (++loops > 100 ) {\n+                throw Error(kerCorruptedMetadata);\n+            }\n             Jp2BoxHeader* pSubBox = (Jp2BoxHeader*) (p+count) ;\n \n             // copy data.  pointer could be into a memory mapped file which we will decode!",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        int           loops  = 0;",
                "            if (++loops > 100 ) {",
                "                throw Error(kerCorruptedMetadata);",
                "            }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-20096",
        "func_name": "Exiv2/exiv2/PngImage::printStructure",
        "description": "There is a heap-based buffer over-read in the Exiv2::tEXtToDataBuf function of pngimage.cpp in Exiv2 0.27-RC3. A crafted input will lead to a remote denial of service attack.",
        "git_url": "https://github.com/Exiv2/exiv2/commit/4f9c912c2267f1bc33d9c28f1b063d571770af75",
        "commit_title": "Fixing bin/exiv2 -pR ~/Downloads/bugs/pngimage-heap-bof-poc-1.dms in #590",
        "commit_text": "",
        "func_before": "void PngImage::printStructure(std::ostream& out, PrintStructureOption option, int depth)\n    {\n        if (io_->open() != 0) {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        // Ensure that this is the correct image type\n        if (!isPngType(*io_, true)) {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"PNG\");\n        }\n\n        char    chType[5];\n        chType[0]=0;\n        chType[4]=0;\n\n        if ( option == kpsBasic || option == kpsXMP || option == kpsIccProfile || option == kpsRecursive ) {\n\n            const std::string xmpKey  = \"XML:com.adobe.xmp\";\n            const std::string exifKey = \"Raw profile type exif\";\n            const std::string app1Key = \"Raw profile type APP1\";\n            const std::string iptcKey = \"Raw profile type iptc\";\n            const std::string iccKey  = \"icc\";\n            const std::string softKey = \"Software\";\n            const std::string commKey = \"Comment\";\n            const std::string descKey = \"Description\";\n\n            bool bPrint = option == kpsBasic || option == kpsRecursive ;\n            if ( bPrint ) {\n                out << \"STRUCTURE OF PNG FILE: \" << io_->path() << std::endl;\n                out << \" address | chunk |  length | data                           | checksum\" << std::endl;\n            }\n\n            const long imgSize = (long) io_->size();\n            DataBuf    cheaderBuf(8);\n\n            while( !io_->eof() && ::strcmp(chType,\"IEND\") ) {\n                size_t address = io_->tell();\n\n                std::memset(cheaderBuf.pData_, 0x0, cheaderBuf.size_);\n                long bufRead = io_->read(cheaderBuf.pData_, cheaderBuf.size_);\n                if (io_->error()) throw Error(kerFailedToReadImageData);\n                if (bufRead != cheaderBuf.size_) throw Error(kerInputDataReadFailed);\n\n                // Decode chunk data length.\n                uint32_t dataOffset = Exiv2::getULong(cheaderBuf.pData_, Exiv2::bigEndian);\n                for (int i = 4; i < 8; i++) {\n                    chType[i-4]=cheaderBuf.pData_[i];\n                }\n\n                // test that we haven't hit EOF, or wanting to read excessive data\n                long restore = io_->tell();\n                if(  restore == -1\n                ||  dataOffset > uint32_t(0x7FFFFFFF)\n                ||  static_cast<long>(dataOffset) > imgSize - restore\n                ){\n                    throw Exiv2::Error(kerFailedToReadImageData);\n                }\n\n                DataBuf   buff(dataOffset);\n                io_->read(buff.pData_,dataOffset);\n                io_->seek(restore, BasicIo::beg);\n\n                // format output\n                const int    iMax = 30 ;\n                const uint32_t blen = dataOffset > iMax ? iMax : dataOffset ;\n                std::string dataString = \"\";\n                // if blen == 0 => slice construction fails\n                if (blen > 0) {\n                    std::stringstream ss;\n                    ss << Internal::binaryToString(makeSlice(buff, 0, blen));\n                    dataString = ss.str();\n                }\n                while (      dataString.size() < iMax ) dataString += ' ';\n                dataString = dataString.substr(0,iMax);\n\n                if ( bPrint ) {\n                    io_->seek(dataOffset, BasicIo::cur);// jump to checksum\n                    byte checksum[4];\n                    io_->read(checksum,4);\n                    io_->seek(restore, BasicIo::beg)   ;// restore file pointer\n\n                    out << Internal::stringFormat(\"%8d | %-5s |%8d | \"\n                                                  ,(uint32_t)address, chType,dataOffset)\n                        << dataString\n                        << Internal::stringFormat(\" | 0x%02x%02x%02x%02x\"\n                                                   ,checksum[0],checksum[1],checksum[2],checksum[3])\n                        << std::endl;\n                }\n\n                // chunk type\n                bool tEXt  = std::strcmp(chType,\"tEXt\")== 0;\n                bool zTXt  = std::strcmp(chType,\"zTXt\")== 0;\n                bool iCCP  = std::strcmp(chType,\"iCCP\")== 0;\n                bool iTXt  = std::strcmp(chType,\"iTXt\")== 0;\n\n                // for XMP, ICC etc: read and format data\n                bool bXMP  = option == kpsXMP        && findi(dataString,xmpKey)==0;\n                bool bICC  = option == kpsIccProfile && findi(dataString,iccKey)==0;\n                bool bExif = option == kpsRecursive  &&(findi(dataString,exifKey)==0 || findi(dataString,app1Key)==0);\n                bool bIptc = option == kpsRecursive  && findi(dataString,iptcKey)==0;\n                bool bSoft = option == kpsRecursive  && findi(dataString,softKey)==0;\n                bool bComm = option == kpsRecursive  && findi(dataString,commKey)==0;\n                bool bDesc = option == kpsRecursive  && findi(dataString,descKey)==0;\n                bool bDump = bXMP || bICC || bExif || bIptc || bSoft || bComm || bDesc ;\n\n                if( bDump ) {\n                    DataBuf   dataBuf;\n                    byte*     data   = new byte[dataOffset+1];\n                    data[dataOffset] = 0;\n                    io_->read(data,dataOffset);\n                    io_->seek(restore, BasicIo::beg);\n                    uint32_t  name_l = (uint32_t) std::strlen((const char*)data)+1; // leading string length\n                    uint32_t  start  = name_l;\n                    bool      bLF    = false;\n\n                    // decode the chunk\n                    bool bGood = false;\n                    if ( tEXt ) {\n                        bGood = tEXtToDataBuf(data+name_l,dataOffset-name_l,dataBuf);\n                    }\n                    if ( zTXt || iCCP ) {\n                        bGood = zlibToDataBuf(data+name_l+1,dataOffset-name_l-1,dataBuf); // +1 = 'compressed' flag\n                    }\n                    if ( iTXt ) {\n                        bGood = (start+3) < dataOffset ;    // good if not a nul chunk\n                    }\n\n                    // format is content dependent\n                    if ( bGood ) {\n                        if ( bXMP ) {\n                            while ( !data[start] && start < dataOffset) start++; // skip leading nul bytes\n                            out <<  data+start;             // output the xmp\n                        }\n\n                        if ( bExif || bIptc ) {\n                            DataBuf parsedBuf = PngChunk::readRawProfile(dataBuf,tEXt);\n#if DEBUG\n                            std::cerr << Exiv2::Internal::binaryToString(parsedBuf.pData_, parsedBuf.size_>50?50:parsedBuf.size_,0) << std::endl;\n#endif\n                            if ( parsedBuf.size_ ) {\n                                if ( bExif ) {\n                                    // create memio object with the data, then print the structure\n                                    BasicIo::AutoPtr p = BasicIo::AutoPtr(new MemIo(parsedBuf.pData_+6,parsedBuf.size_-6));\n                                    printTiffStructure(*p,out,option,depth);\n                                }\n                                if ( bIptc ) {\n                                    IptcData::printStructure(out, makeSlice(parsedBuf.pData_, 0, parsedBuf.size_), depth);\n                                }\n                            }\n                        }\n\n                        if ( bSoft && dataBuf.size_ > 0) {\n                            DataBuf     s(dataBuf.size_+1);               // allocate buffer with an extra byte\n                            memcpy(s.pData_,dataBuf.pData_,dataBuf.size_);// copy in the dataBuf\n                            s.pData_[dataBuf.size_] = 0 ;                 // nul terminate it\n                            const char* str = (const char*) s.pData_;     // give it name\n                            out << Internal::indent(depth) << (const char*) buff.pData_ << \": \" << str ;\n                            bLF=true;\n                        }\n\n                        if ( bICC || bComm ) {\n                            out.write((const char*) dataBuf.pData_,dataBuf.size_);\n                            bLF = bComm ;\n                        }\n\n                        if ( bDesc && iTXt ) {\n                            DataBuf decoded = PngChunk::decodeTXTChunk(buff,PngChunk::iTXt_Chunk );\n                            out.write((const char*)decoded.pData_,decoded.size_);\n                            bLF = true;\n                        }\n\n                        if ( bLF ) out << std::endl;\n                    }\n                    delete[] data;\n                }\n                io_->seek(dataOffset+4, BasicIo::cur);// jump past checksum\n                if (io_->error()) throw Error(kerFailedToReadImageData);\n            }\n        }\n    }",
        "func": "void PngImage::printStructure(std::ostream& out, PrintStructureOption option, int depth)\n    {\n        if (io_->open() != 0) {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        // Ensure that this is the correct image type\n        if (!isPngType(*io_, true)) {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"PNG\");\n        }\n\n        char    chType[5];\n        chType[0]=0;\n        chType[4]=0;\n\n        if ( option == kpsBasic || option == kpsXMP || option == kpsIccProfile || option == kpsRecursive ) {\n\n            const std::string xmpKey  = \"XML:com.adobe.xmp\";\n            const std::string exifKey = \"Raw profile type exif\";\n            const std::string app1Key = \"Raw profile type APP1\";\n            const std::string iptcKey = \"Raw profile type iptc\";\n            const std::string iccKey  = \"icc\";\n            const std::string softKey = \"Software\";\n            const std::string commKey = \"Comment\";\n            const std::string descKey = \"Description\";\n\n            bool bPrint = option == kpsBasic || option == kpsRecursive ;\n            if ( bPrint ) {\n                out << \"STRUCTURE OF PNG FILE: \" << io_->path() << std::endl;\n                out << \" address | chunk |  length | data                           | checksum\" << std::endl;\n            }\n\n            const long imgSize = (long) io_->size();\n            DataBuf    cheaderBuf(8);\n\n            while( !io_->eof() && ::strcmp(chType,\"IEND\") ) {\n                size_t address = io_->tell();\n\n                std::memset(cheaderBuf.pData_, 0x0, cheaderBuf.size_);\n                long bufRead = io_->read(cheaderBuf.pData_, cheaderBuf.size_);\n                if (io_->error()) throw Error(kerFailedToReadImageData);\n                if (bufRead != cheaderBuf.size_) throw Error(kerInputDataReadFailed);\n\n                // Decode chunk data length.\n                uint32_t dataOffset = Exiv2::getULong(cheaderBuf.pData_, Exiv2::bigEndian);\n                for (int i = 4; i < 8; i++) {\n                    chType[i-4]=cheaderBuf.pData_[i];\n                }\n\n                // test that we haven't hit EOF, or wanting to read excessive data\n                long restore = io_->tell();\n                if(  restore == -1\n                ||  dataOffset > uint32_t(0x7FFFFFFF)\n                ||  static_cast<long>(dataOffset) > imgSize - restore\n                ){\n                    throw Exiv2::Error(kerFailedToReadImageData);\n                }\n\n                DataBuf   buff(dataOffset);\n                io_->read(buff.pData_,dataOffset);\n                io_->seek(restore, BasicIo::beg);\n\n                // format output\n                const int    iMax = 30 ;\n                const uint32_t blen = dataOffset > iMax ? iMax : dataOffset ;\n                std::string dataString = \"\";\n                // if blen == 0 => slice construction fails\n                if (blen > 0) {\n                    std::stringstream ss;\n                    ss << Internal::binaryToString(makeSlice(buff, 0, blen));\n                    dataString = ss.str();\n                }\n                while (      dataString.size() < iMax ) dataString += ' ';\n                dataString = dataString.substr(0,iMax);\n\n                if ( bPrint ) {\n                    io_->seek(dataOffset, BasicIo::cur);// jump to checksum\n                    byte checksum[4];\n                    io_->read(checksum,4);\n                    io_->seek(restore, BasicIo::beg)   ;// restore file pointer\n\n                    out << Internal::stringFormat(\"%8d | %-5s |%8d | \"\n                                                  ,(uint32_t)address, chType,dataOffset)\n                        << dataString\n                        << Internal::stringFormat(\" | 0x%02x%02x%02x%02x\"\n                                                   ,checksum[0],checksum[1],checksum[2],checksum[3])\n                        << std::endl;\n                }\n\n                // chunk type\n                bool tEXt  = std::strcmp(chType,\"tEXt\")== 0;\n                bool zTXt  = std::strcmp(chType,\"zTXt\")== 0;\n                bool iCCP  = std::strcmp(chType,\"iCCP\")== 0;\n                bool iTXt  = std::strcmp(chType,\"iTXt\")== 0;\n\n                // for XMP, ICC etc: read and format data\n                bool bXMP  = option == kpsXMP        && findi(dataString,xmpKey)==0;\n                bool bICC  = option == kpsIccProfile && findi(dataString,iccKey)==0;\n                bool bExif = option == kpsRecursive  &&(findi(dataString,exifKey)==0 || findi(dataString,app1Key)==0);\n                bool bIptc = option == kpsRecursive  && findi(dataString,iptcKey)==0;\n                bool bSoft = option == kpsRecursive  && findi(dataString,softKey)==0;\n                bool bComm = option == kpsRecursive  && findi(dataString,commKey)==0;\n                bool bDesc = option == kpsRecursive  && findi(dataString,descKey)==0;\n                bool bDump = bXMP || bICC || bExif || bIptc || bSoft || bComm || bDesc ;\n\n                if( bDump ) {\n                    DataBuf   dataBuf;\n                    byte*     data   = new byte[dataOffset+1];\n                    data[dataOffset] = 0;\n                    io_->read(data,dataOffset);\n                    io_->seek(restore, BasicIo::beg);\n                    uint32_t  name_l = (uint32_t) std::strlen((const char*)data)+1; // leading string length\n                    uint32_t  start  = name_l;\n                    bool      bLF    = false;\n\n                    // decode the chunk\n                    bool bGood = false;\n                    if ( dataOffset > name_l + 2 ) {\n                        if ( tEXt ) {\n                            bGood = tEXtToDataBuf(data + name_l, dataOffset - name_l, dataBuf);\n                        }\n                        if (zTXt || iCCP) {\n                            bGood = zlibToDataBuf(data + name_l + 1, dataOffset - name_l - 1,\n                                                  dataBuf); // +1 = 'compressed' flag\n                        }\n                    }\n\n                    if ( zTXt || iCCP ) {\n                        bGood = zlibToDataBuf(data+name_l+1,dataOffset-name_l-1,dataBuf); // +1 = 'compressed' flag\n                    }\n                    if ( iTXt ) {\n                        bGood = (start+3) < dataOffset ;    // good if not a nul chunk\n                    }\n\n                    // format is content dependent\n                    if ( bGood ) {\n                        if ( bXMP ) {\n                            while ( !data[start] && start < dataOffset) start++; // skip leading nul bytes\n                            out <<  data+start;             // output the xmp\n                        }\n\n                        if ( bExif || bIptc ) {\n                            DataBuf parsedBuf = PngChunk::readRawProfile(dataBuf,tEXt);\n#if DEBUG\n                            std::cerr << Exiv2::Internal::binaryToString(parsedBuf.pData_, parsedBuf.size_>50?50:parsedBuf.size_,0) << std::endl;\n#endif\n                            if ( parsedBuf.size_ ) {\n                                if ( bExif ) {\n                                    // create memio object with the data, then print the structure\n                                    BasicIo::AutoPtr p = BasicIo::AutoPtr(new MemIo(parsedBuf.pData_+6,parsedBuf.size_-6));\n                                    printTiffStructure(*p,out,option,depth);\n                                }\n                                if ( bIptc ) {\n                                    IptcData::printStructure(out, makeSlice(parsedBuf.pData_, 0, parsedBuf.size_), depth);\n                                }\n                            }\n                        }\n\n                        if ( bSoft && dataBuf.size_ > 0) {\n                            DataBuf     s(dataBuf.size_+1);               // allocate buffer with an extra byte\n                            memcpy(s.pData_,dataBuf.pData_,dataBuf.size_);// copy in the dataBuf\n                            s.pData_[dataBuf.size_] = 0 ;                 // nul terminate it\n                            const char* str = (const char*) s.pData_;     // give it name\n                            out << Internal::indent(depth) << (const char*) buff.pData_ << \": \" << str ;\n                            bLF=true;\n                        }\n\n                        if ( bICC || bComm ) {\n                            out.write((const char*) dataBuf.pData_,dataBuf.size_);\n                            bLF = bComm ;\n                        }\n\n                        if ( bDesc && iTXt ) {\n                            DataBuf decoded = PngChunk::decodeTXTChunk(buff,PngChunk::iTXt_Chunk );\n                            out.write((const char*)decoded.pData_,decoded.size_);\n                            bLF = true;\n                        }\n\n                        if ( bLF ) out << std::endl;\n                    }\n                    delete[] data;\n                }\n                io_->seek(dataOffset+4, BasicIo::cur);// jump past checksum\n                if (io_->error()) throw Error(kerFailedToReadImageData);\n            }\n        }\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -115,9 +115,16 @@\n \n                     // decode the chunk\n                     bool bGood = false;\n-                    if ( tEXt ) {\n-                        bGood = tEXtToDataBuf(data+name_l,dataOffset-name_l,dataBuf);\n+                    if ( dataOffset > name_l + 2 ) {\n+                        if ( tEXt ) {\n+                            bGood = tEXtToDataBuf(data + name_l, dataOffset - name_l, dataBuf);\n+                        }\n+                        if (zTXt || iCCP) {\n+                            bGood = zlibToDataBuf(data + name_l + 1, dataOffset - name_l - 1,\n+                                                  dataBuf); // +1 = 'compressed' flag\n+                        }\n                     }\n+\n                     if ( zTXt || iCCP ) {\n                         bGood = zlibToDataBuf(data+name_l+1,dataOffset-name_l-1,dataBuf); // +1 = 'compressed' flag\n                     }",
        "diff_line_info": {
            "deleted_lines": [
                "                    if ( tEXt ) {",
                "                        bGood = tEXtToDataBuf(data+name_l,dataOffset-name_l,dataBuf);"
            ],
            "added_lines": [
                "                    if ( dataOffset > name_l + 2 ) {",
                "                        if ( tEXt ) {",
                "                            bGood = tEXtToDataBuf(data + name_l, dataOffset - name_l, dataBuf);",
                "                        }",
                "                        if (zTXt || iCCP) {",
                "                            bGood = zlibToDataBuf(data + name_l + 1, dataOffset - name_l - 1,",
                "                                                  dataBuf); // +1 = 'compressed' flag",
                "                        }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2017-6214",
        "func_name": "torvalds/linux/tcp_splice_read",
        "description": "The tcp_splice_read function in net/ipv4/tcp.c in the Linux kernel before 4.9.11 allows remote attackers to cause a denial of service (infinite loop and soft lockup) via vectors involving a TCP packet with the URG flag.",
        "git_url": "https://github.com/torvalds/linux/commit/ccf7abb93af09ad0868ae9033d1ca8108bdaec82",
        "commit_title": "tcp: avoid infinite loop in tcp_splice_read()",
        "commit_text": " Splicing from TCP socket is vulnerable when a packet with URG flag is received and stored into receive queue.  __tcp_splice_read() returns 0, and sk_wait_data() immediately returns since there is the problematic skb in queue.  This is a nice way to burn cpu (aka infinite loop) and trigger soft lockups.  Again, this gem was found by syzkaller tool.  Cc: Willy Tarreau <w@1wt.eu>",
        "func_before": "ssize_t tcp_splice_read(struct socket *sock, loff_t *ppos,\n\t\t\tstruct pipe_inode_info *pipe, size_t len,\n\t\t\tunsigned int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct tcp_splice_state tss = {\n\t\t.pipe = pipe,\n\t\t.len = len,\n\t\t.flags = flags,\n\t};\n\tlong timeo;\n\tssize_t spliced;\n\tint ret;\n\n\tsock_rps_record_flow(sk);\n\t/*\n\t * We can't seek on a socket input\n\t */\n\tif (unlikely(*ppos))\n\t\treturn -ESPIPE;\n\n\tret = spliced = 0;\n\n\tlock_sock(sk);\n\n\ttimeo = sock_rcvtimeo(sk, sock->file->f_flags & O_NONBLOCK);\n\twhile (tss.len) {\n\t\tret = __tcp_splice_read(sk, &tss);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\telse if (!ret) {\n\t\t\tif (spliced)\n\t\t\t\tbreak;\n\t\t\tif (sock_flag(sk, SOCK_DONE))\n\t\t\t\tbreak;\n\t\t\tif (sk->sk_err) {\n\t\t\t\tret = sock_error(sk);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\t\tbreak;\n\t\t\tif (sk->sk_state == TCP_CLOSE) {\n\t\t\t\t/*\n\t\t\t\t * This occurs when user tries to read\n\t\t\t\t * from never connected socket.\n\t\t\t\t */\n\t\t\t\tif (!sock_flag(sk, SOCK_DONE))\n\t\t\t\t\tret = -ENOTCONN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!timeo) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsk_wait_data(sk, &timeo, NULL);\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tret = sock_intr_errno(timeo);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\ttss.len -= ret;\n\t\tspliced += ret;\n\n\t\tif (!timeo)\n\t\t\tbreak;\n\t\trelease_sock(sk);\n\t\tlock_sock(sk);\n\n\t\tif (sk->sk_err || sk->sk_state == TCP_CLOSE ||\n\t\t    (sk->sk_shutdown & RCV_SHUTDOWN) ||\n\t\t    signal_pending(current))\n\t\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\n\tif (spliced)\n\t\treturn spliced;\n\n\treturn ret;\n}",
        "func": "ssize_t tcp_splice_read(struct socket *sock, loff_t *ppos,\n\t\t\tstruct pipe_inode_info *pipe, size_t len,\n\t\t\tunsigned int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct tcp_splice_state tss = {\n\t\t.pipe = pipe,\n\t\t.len = len,\n\t\t.flags = flags,\n\t};\n\tlong timeo;\n\tssize_t spliced;\n\tint ret;\n\n\tsock_rps_record_flow(sk);\n\t/*\n\t * We can't seek on a socket input\n\t */\n\tif (unlikely(*ppos))\n\t\treturn -ESPIPE;\n\n\tret = spliced = 0;\n\n\tlock_sock(sk);\n\n\ttimeo = sock_rcvtimeo(sk, sock->file->f_flags & O_NONBLOCK);\n\twhile (tss.len) {\n\t\tret = __tcp_splice_read(sk, &tss);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\telse if (!ret) {\n\t\t\tif (spliced)\n\t\t\t\tbreak;\n\t\t\tif (sock_flag(sk, SOCK_DONE))\n\t\t\t\tbreak;\n\t\t\tif (sk->sk_err) {\n\t\t\t\tret = sock_error(sk);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\t\tbreak;\n\t\t\tif (sk->sk_state == TCP_CLOSE) {\n\t\t\t\t/*\n\t\t\t\t * This occurs when user tries to read\n\t\t\t\t * from never connected socket.\n\t\t\t\t */\n\t\t\t\tif (!sock_flag(sk, SOCK_DONE))\n\t\t\t\t\tret = -ENOTCONN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!timeo) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* if __tcp_splice_read() got nothing while we have\n\t\t\t * an skb in receive queue, we do not want to loop.\n\t\t\t * This might happen with URG data.\n\t\t\t */\n\t\t\tif (!skb_queue_empty(&sk->sk_receive_queue))\n\t\t\t\tbreak;\n\t\t\tsk_wait_data(sk, &timeo, NULL);\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tret = sock_intr_errno(timeo);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\ttss.len -= ret;\n\t\tspliced += ret;\n\n\t\tif (!timeo)\n\t\t\tbreak;\n\t\trelease_sock(sk);\n\t\tlock_sock(sk);\n\n\t\tif (sk->sk_err || sk->sk_state == TCP_CLOSE ||\n\t\t    (sk->sk_shutdown & RCV_SHUTDOWN) ||\n\t\t    signal_pending(current))\n\t\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\n\tif (spliced)\n\t\treturn spliced;\n\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -52,6 +52,12 @@\n \t\t\t\tret = -EAGAIN;\n \t\t\t\tbreak;\n \t\t\t}\n+\t\t\t/* if __tcp_splice_read() got nothing while we have\n+\t\t\t * an skb in receive queue, we do not want to loop.\n+\t\t\t * This might happen with URG data.\n+\t\t\t */\n+\t\t\tif (!skb_queue_empty(&sk->sk_receive_queue))\n+\t\t\t\tbreak;\n \t\t\tsk_wait_data(sk, &timeo, NULL);\n \t\t\tif (signal_pending(current)) {\n \t\t\t\tret = sock_intr_errno(timeo);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\t/* if __tcp_splice_read() got nothing while we have",
                "\t\t\t * an skb in receive queue, we do not want to loop.",
                "\t\t\t * This might happen with URG data.",
                "\t\t\t */",
                "\t\t\tif (!skb_queue_empty(&sk->sk_receive_queue))",
                "\t\t\t\tbreak;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-8900",
        "func_name": "ImageMagick/ReadHDRImage",
        "description": "The ReadHDRImage function in coders/hdr.c in ImageMagick 6.x and 7.x allows remote attackers to cause a denial of service (infinite loop) via a crafted HDR file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/97aa7d7cfd2027f6ba7ce42caf8b798541b9cdc6",
        "commit_title": "Fixed infinite loop and added checks for the sscanf result.",
        "commit_text": "",
        "func_before": "static Image *ReadHDRImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    format[MaxTextExtent],\n    keyword[MaxTextExtent],\n    tag[MaxTextExtent],\n    value[MaxTextExtent];\n\n  double\n    gamma;\n\n  Image\n    *image;\n\n  int\n    c;\n\n  MagickBooleanType\n    status,\n    value_expected;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *end,\n    pixel[4],\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Decode image header.\n  */\n  image->columns=0;\n  image->rows=0;\n  *format='\\0';\n  c=ReadBlobByte(image);\n  if (c == EOF)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  while (isgraph(c) && (image->columns == 0) && (image->rows == 0))\n  {\n    if (c == (int) '#')\n      {\n        char\n          *comment;\n\n        register char\n          *p;\n\n        size_t\n          length;\n\n        /*\n          Read comment-- any text between # and end-of-line.\n        */\n        length=MaxTextExtent;\n        comment=AcquireString((char *) NULL);\n        for (p=comment; comment != (char *) NULL; p++)\n        {\n          c=ReadBlobByte(image);\n          if ((c == EOF) || (c == (int) '\\n'))\n            break;\n          if ((size_t) (p-comment+1) >= length)\n            {\n              *p='\\0';\n              length<<=1;\n              comment=(char *) ResizeQuantumMemory(comment,length+\n                MaxTextExtent,sizeof(*comment));\n              if (comment == (char *) NULL)\n                break;\n              p=comment+strlen(comment);\n            }\n          *p=(char) c;\n        }\n        if (comment == (char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        *p='\\0';\n        (void) SetImageProperty(image,\"comment\",comment,exception);\n        comment=DestroyString(comment);\n        c=ReadBlobByte(image);\n      }\n    else\n      if (isalnum(c) == MagickFalse)\n        c=ReadBlobByte(image);\n      else\n        {\n          register char\n            *p;\n\n          /*\n            Determine a keyword and its value.\n          */\n          p=keyword;\n          do\n          {\n            if ((size_t) (p-keyword) < (MaxTextExtent-1))\n              *p++=c;\n            c=ReadBlobByte(image);\n          } while (isalnum(c) || (c == '_'));\n          *p='\\0';\n          value_expected=MagickFalse;\n          while ((isspace((int) ((unsigned char) c)) != 0) || (c == '='))\n          {\n            if (c == '=')\n              value_expected=MagickTrue;\n            c=ReadBlobByte(image);\n          }\n          if (LocaleCompare(keyword,\"Y\") == 0)\n            value_expected=MagickTrue;\n          if (value_expected == MagickFalse)\n            continue;\n          p=value;\n          while ((c != '\\n') && (c != '\\0'))\n          {\n            if ((size_t) (p-value) < (MaxTextExtent-1))\n              *p++=c;\n            c=ReadBlobByte(image);\n          }\n          *p='\\0';\n          /*\n            Assign a value to the specified keyword.\n          */\n          switch (*keyword)\n          {\n            case 'F':\n            case 'f':\n            {\n              if (LocaleCompare(keyword,\"format\") == 0)\n                {\n                  (void) CopyMagickString(format,value,MaxTextExtent);\n                  break;\n                }\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'G':\n            case 'g':\n            {\n              if (LocaleCompare(keyword,\"gamma\") == 0)\n                {\n                  image->gamma=StringToDouble(value,(char **) NULL);\n                  break;\n                }\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'P':\n            case 'p':\n            {\n              if (LocaleCompare(keyword,\"primaries\") == 0)\n                {\n                  float\n                    chromaticity[6],\n                    white_point[2];\n\n                  (void) sscanf(value,\"%g %g %g %g %g %g %g %g\",\n                    &chromaticity[0],&chromaticity[1],&chromaticity[2],\n                    &chromaticity[3],&chromaticity[4],&chromaticity[5],\n                    &white_point[0],&white_point[1]);\n                  image->chromaticity.red_primary.x=chromaticity[0];\n                  image->chromaticity.red_primary.y=chromaticity[1];\n                  image->chromaticity.green_primary.x=chromaticity[2];\n                  image->chromaticity.green_primary.y=chromaticity[3];\n                  image->chromaticity.blue_primary.x=chromaticity[4];\n                  image->chromaticity.blue_primary.y=chromaticity[5];\n                  image->chromaticity.white_point.x=white_point[0],\n                  image->chromaticity.white_point.y=white_point[1];\n                  break;\n                }\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'Y':\n            case 'y':\n            {\n              char\n                target[] = \"Y\";\n\n              if (strcmp(keyword,target) == 0)\n                {\n                  int\n                    height,\n                    width;\n\n                  (void) sscanf(value,\"%d +X %d\",&height,&width);\n                  image->columns=(size_t) width;\n                  image->rows=(size_t) height;\n                  break;\n                }\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            default:\n            {\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n          }\n        }\n    if ((image->columns == 0) && (image->rows == 0))\n      while (isspace((int) ((unsigned char) c)) != 0)\n        c=ReadBlobByte(image);\n  }\n  if ((LocaleCompare(format,\"32-bit_rle_rgbe\") != 0) &&\n      (LocaleCompare(format,\"32-bit_rle_xyze\") != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n  (void) SetImageColorspace(image,RGBColorspace,exception);\n  if (LocaleCompare(format,\"32-bit_rle_xyze\") == 0)\n    (void) SetImageColorspace(image,XYZColorspace,exception);\n  image->compression=(image->columns < 8) || (image->columns > 0x7ffff) ?\n    NoCompression : RLECompression;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Read RGBE (red+green+blue+exponent) pixels.\n  */\n  pixels=(unsigned char *) AcquireQuantumMemory(image->columns,4*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    if (image->compression != RLECompression)\n      {\n        count=ReadBlob(image,4*image->columns*sizeof(*pixels),pixels);\n        if (count != (ssize_t) (4*image->columns*sizeof(*pixels)))\n          break;\n      }\n    else\n      {\n        count=ReadBlob(image,4*sizeof(*pixel),pixel);\n        if (count != 4)\n          break;\n        if ((size_t) ((((size_t) pixel[2]) << 8) | pixel[3]) != image->columns)\n          {\n            (void) memcpy(pixels,pixel,4*sizeof(*pixel));\n            count=ReadBlob(image,4*(image->columns-1)*sizeof(*pixels),pixels+4);\n            image->compression=NoCompression;\n          }\n        else\n          {\n            p=pixels;\n            for (i=0; i < 4; i++)\n            {\n              end=&pixels[(i+1)*image->columns];\n              while (p < end)\n              {\n                count=ReadBlob(image,2*sizeof(*pixel),pixel);\n                if (count < 1)\n                  break;\n                if (pixel[0] > 128)\n                  {\n                    count=(ssize_t) pixel[0]-128;\n                    if ((count == 0) || (count > (ssize_t) (end-p)))\n                      break;\n                    while (count-- > 0)\n                      *p++=pixel[1];\n                  }\n                else\n                  {\n                    count=(ssize_t) pixel[0];\n                    if ((count == 0) || (count > (ssize_t) (end-p)))\n                      break;\n                    *p++=pixel[1];\n                    if (--count > 0)\n                      {\n                        count=ReadBlob(image,(size_t) count*sizeof(*p),p);\n                        if (count < 1)\n                          break;\n                        p+=count;\n                      }\n                  }\n              }\n            }\n          }\n      }\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    i=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (image->compression == RLECompression)\n        {\n          pixel[0]=pixels[x];\n          pixel[1]=pixels[x+image->columns];\n          pixel[2]=pixels[x+2*image->columns];\n          pixel[3]=pixels[x+3*image->columns];\n        }\n      else\n        {\n          pixel[0]=pixels[i++];\n          pixel[1]=pixels[i++];\n          pixel[2]=pixels[i++];\n          pixel[3]=pixels[i++];\n        }\n      SetPixelRed(image,0,q);\n      SetPixelGreen(image,0,q);\n      SetPixelBlue(image,0,q);\n      if (pixel[3] != 0)\n        {\n          gamma=pow(2.0,pixel[3]-(128.0+8.0));\n          SetPixelRed(image,ClampToQuantum(QuantumRange*gamma*pixel[0]),q);\n          SetPixelGreen(image,ClampToQuantum(QuantumRange*gamma*pixel[1]),q);\n          SetPixelBlue(image,ClampToQuantum(QuantumRange*gamma*pixel[2]),q);\n        }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadHDRImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    format[MaxTextExtent],\n    keyword[MaxTextExtent],\n    tag[MaxTextExtent],\n    value[MaxTextExtent];\n\n  double\n    gamma;\n\n  Image\n    *image;\n\n  int\n    c;\n\n  MagickBooleanType\n    status,\n    value_expected;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  register unsigned char\n    *p;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *end,\n    pixel[4],\n    *pixels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Decode image header.\n  */\n  image->columns=0;\n  image->rows=0;\n  *format='\\0';\n  c=ReadBlobByte(image);\n  if (c == EOF)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  while (isgraph(c) && (image->columns == 0) && (image->rows == 0))\n  {\n    if (c == (int) '#')\n      {\n        char\n          *comment;\n\n        register char\n          *p;\n\n        size_t\n          length;\n\n        /*\n          Read comment-- any text between # and end-of-line.\n        */\n        length=MaxTextExtent;\n        comment=AcquireString((char *) NULL);\n        for (p=comment; comment != (char *) NULL; p++)\n        {\n          c=ReadBlobByte(image);\n          if ((c == EOF) || (c == (int) '\\n'))\n            break;\n          if ((size_t) (p-comment+1) >= length)\n            {\n              *p='\\0';\n              length<<=1;\n              comment=(char *) ResizeQuantumMemory(comment,length+\n                MaxTextExtent,sizeof(*comment));\n              if (comment == (char *) NULL)\n                break;\n              p=comment+strlen(comment);\n            }\n          *p=(char) c;\n        }\n        if (comment == (char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        *p='\\0';\n        (void) SetImageProperty(image,\"comment\",comment,exception);\n        comment=DestroyString(comment);\n        c=ReadBlobByte(image);\n      }\n    else\n      if (isalnum(c) == MagickFalse)\n        c=ReadBlobByte(image);\n      else\n        {\n          register char\n            *p;\n\n          /*\n            Determine a keyword and its value.\n          */\n          p=keyword;\n          do\n          {\n            if ((size_t) (p-keyword) < (MaxTextExtent-1))\n              *p++=c;\n            c=ReadBlobByte(image);\n          } while (isalnum(c) || (c == '_'));\n          *p='\\0';\n          value_expected=MagickFalse;\n          while ((isspace((int) ((unsigned char) c)) != 0) || (c == '='))\n          {\n            if (c == '=')\n              value_expected=MagickTrue;\n            c=ReadBlobByte(image);\n          }\n          if (LocaleCompare(keyword,\"Y\") == 0)\n            value_expected=MagickTrue;\n          if (value_expected == MagickFalse)\n            continue;\n          p=value;\n          while ((c != '\\n') && (c != '\\0') && (c != EOF))\n          {\n            if ((size_t) (p-value) < (MaxTextExtent-1))\n              *p++=c;\n            c=ReadBlobByte(image);\n          }\n          *p='\\0';\n          /*\n            Assign a value to the specified keyword.\n          */\n          switch (*keyword)\n          {\n            case 'F':\n            case 'f':\n            {\n              if (LocaleCompare(keyword,\"format\") == 0)\n                {\n                  (void) CopyMagickString(format,value,MaxTextExtent);\n                  break;\n                }\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'G':\n            case 'g':\n            {\n              if (LocaleCompare(keyword,\"gamma\") == 0)\n                {\n                  image->gamma=StringToDouble(value,(char **) NULL);\n                  break;\n                }\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'P':\n            case 'p':\n            {\n              if (LocaleCompare(keyword,\"primaries\") == 0)\n                {\n                  float\n                    chromaticity[6],\n                    white_point[2];\n\n                  if (sscanf(value,\"%g %g %g %g %g %g %g %g\",&chromaticity[0],\n                      &chromaticity[1],&chromaticity[2],&chromaticity[3],\n                      &chromaticity[4],&chromaticity[5],&white_point[0],\n                      &white_point[1]) == 8)\n                    {\n                      image->chromaticity.red_primary.x=chromaticity[0];\n                      image->chromaticity.red_primary.y=chromaticity[1];\n                      image->chromaticity.green_primary.x=chromaticity[2];\n                      image->chromaticity.green_primary.y=chromaticity[3];\n                      image->chromaticity.blue_primary.x=chromaticity[4];\n                      image->chromaticity.blue_primary.y=chromaticity[5];\n                      image->chromaticity.white_point.x=white_point[0],\n                      image->chromaticity.white_point.y=white_point[1];\n                    }\n                  break;\n                }\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            case 'Y':\n            case 'y':\n            {\n              char\n                target[] = \"Y\";\n\n              if (strcmp(keyword,target) == 0)\n                {\n                  int\n                    height,\n                    width;\n\n                  if (sscanf(value,\"%d +X %d\",&height,&width) == 2)\n                    {\n                      image->columns=(size_t) width;\n                      image->rows=(size_t) height;\n                    }\n                  break;\n                }\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n            default:\n            {\n              (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n              (void) SetImageProperty(image,tag,value,exception);\n              break;\n            }\n          }\n        }\n    if ((image->columns == 0) && (image->rows == 0))\n      while (isspace((int) ((unsigned char) c)) != 0)\n        c=ReadBlobByte(image);\n  }\n  if ((LocaleCompare(format,\"32-bit_rle_rgbe\") != 0) &&\n      (LocaleCompare(format,\"32-bit_rle_xyze\") != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowReaderException(CorruptImageError,\"NegativeOrZeroImageSize\");\n  (void) SetImageColorspace(image,RGBColorspace,exception);\n  if (LocaleCompare(format,\"32-bit_rle_xyze\") == 0)\n    (void) SetImageColorspace(image,XYZColorspace,exception);\n  image->compression=(image->columns < 8) || (image->columns > 0x7ffff) ?\n    NoCompression : RLECompression;\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(GetFirstImageInList(image));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Read RGBE (red+green+blue+exponent) pixels.\n  */\n  pixels=(unsigned char *) AcquireQuantumMemory(image->columns,4*\n    sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    if (image->compression != RLECompression)\n      {\n        count=ReadBlob(image,4*image->columns*sizeof(*pixels),pixels);\n        if (count != (ssize_t) (4*image->columns*sizeof(*pixels)))\n          break;\n      }\n    else\n      {\n        count=ReadBlob(image,4*sizeof(*pixel),pixel);\n        if (count != 4)\n          break;\n        if ((size_t) ((((size_t) pixel[2]) << 8) | pixel[3]) != image->columns)\n          {\n            (void) memcpy(pixels,pixel,4*sizeof(*pixel));\n            count=ReadBlob(image,4*(image->columns-1)*sizeof(*pixels),pixels+4);\n            image->compression=NoCompression;\n          }\n        else\n          {\n            p=pixels;\n            for (i=0; i < 4; i++)\n            {\n              end=&pixels[(i+1)*image->columns];\n              while (p < end)\n              {\n                count=ReadBlob(image,2*sizeof(*pixel),pixel);\n                if (count < 1)\n                  break;\n                if (pixel[0] > 128)\n                  {\n                    count=(ssize_t) pixel[0]-128;\n                    if ((count == 0) || (count > (ssize_t) (end-p)))\n                      break;\n                    while (count-- > 0)\n                      *p++=pixel[1];\n                  }\n                else\n                  {\n                    count=(ssize_t) pixel[0];\n                    if ((count == 0) || (count > (ssize_t) (end-p)))\n                      break;\n                    *p++=pixel[1];\n                    if (--count > 0)\n                      {\n                        count=ReadBlob(image,(size_t) count*sizeof(*p),p);\n                        if (count < 1)\n                          break;\n                        p+=count;\n                      }\n                  }\n              }\n            }\n          }\n      }\n    q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    i=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (image->compression == RLECompression)\n        {\n          pixel[0]=pixels[x];\n          pixel[1]=pixels[x+image->columns];\n          pixel[2]=pixels[x+2*image->columns];\n          pixel[3]=pixels[x+3*image->columns];\n        }\n      else\n        {\n          pixel[0]=pixels[i++];\n          pixel[1]=pixels[i++];\n          pixel[2]=pixels[i++];\n          pixel[3]=pixels[i++];\n        }\n      SetPixelRed(image,0,q);\n      SetPixelGreen(image,0,q);\n      SetPixelBlue(image,0,q);\n      if (pixel[3] != 0)\n        {\n          gamma=pow(2.0,pixel[3]-(128.0+8.0));\n          SetPixelRed(image,ClampToQuantum(QuantumRange*gamma*pixel[0]),q);\n          SetPixelGreen(image,ClampToQuantum(QuantumRange*gamma*pixel[1]),q);\n          SetPixelBlue(image,ClampToQuantum(QuantumRange*gamma*pixel[2]),q);\n        }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -140,7 +140,7 @@\n           if (value_expected == MagickFalse)\n             continue;\n           p=value;\n-          while ((c != '\\n') && (c != '\\0'))\n+          while ((c != '\\n') && (c != '\\0') && (c != EOF))\n           {\n             if ((size_t) (p-value) < (MaxTextExtent-1))\n               *p++=c;\n@@ -185,18 +185,20 @@\n                     chromaticity[6],\n                     white_point[2];\n \n-                  (void) sscanf(value,\"%g %g %g %g %g %g %g %g\",\n-                    &chromaticity[0],&chromaticity[1],&chromaticity[2],\n-                    &chromaticity[3],&chromaticity[4],&chromaticity[5],\n-                    &white_point[0],&white_point[1]);\n-                  image->chromaticity.red_primary.x=chromaticity[0];\n-                  image->chromaticity.red_primary.y=chromaticity[1];\n-                  image->chromaticity.green_primary.x=chromaticity[2];\n-                  image->chromaticity.green_primary.y=chromaticity[3];\n-                  image->chromaticity.blue_primary.x=chromaticity[4];\n-                  image->chromaticity.blue_primary.y=chromaticity[5];\n-                  image->chromaticity.white_point.x=white_point[0],\n-                  image->chromaticity.white_point.y=white_point[1];\n+                  if (sscanf(value,\"%g %g %g %g %g %g %g %g\",&chromaticity[0],\n+                      &chromaticity[1],&chromaticity[2],&chromaticity[3],\n+                      &chromaticity[4],&chromaticity[5],&white_point[0],\n+                      &white_point[1]) == 8)\n+                    {\n+                      image->chromaticity.red_primary.x=chromaticity[0];\n+                      image->chromaticity.red_primary.y=chromaticity[1];\n+                      image->chromaticity.green_primary.x=chromaticity[2];\n+                      image->chromaticity.green_primary.y=chromaticity[3];\n+                      image->chromaticity.blue_primary.x=chromaticity[4];\n+                      image->chromaticity.blue_primary.y=chromaticity[5];\n+                      image->chromaticity.white_point.x=white_point[0],\n+                      image->chromaticity.white_point.y=white_point[1];\n+                    }\n                   break;\n                 }\n               (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);\n@@ -215,9 +217,11 @@\n                     height,\n                     width;\n \n-                  (void) sscanf(value,\"%d +X %d\",&height,&width);\n-                  image->columns=(size_t) width;\n-                  image->rows=(size_t) height;\n+                  if (sscanf(value,\"%d +X %d\",&height,&width) == 2)\n+                    {\n+                      image->columns=(size_t) width;\n+                      image->rows=(size_t) height;\n+                    }\n                   break;\n                 }\n               (void) FormatLocaleString(tag,MaxTextExtent,\"hdr:%s\",keyword);",
        "diff_line_info": {
            "deleted_lines": [
                "          while ((c != '\\n') && (c != '\\0'))",
                "                  (void) sscanf(value,\"%g %g %g %g %g %g %g %g\",",
                "                    &chromaticity[0],&chromaticity[1],&chromaticity[2],",
                "                    &chromaticity[3],&chromaticity[4],&chromaticity[5],",
                "                    &white_point[0],&white_point[1]);",
                "                  image->chromaticity.red_primary.x=chromaticity[0];",
                "                  image->chromaticity.red_primary.y=chromaticity[1];",
                "                  image->chromaticity.green_primary.x=chromaticity[2];",
                "                  image->chromaticity.green_primary.y=chromaticity[3];",
                "                  image->chromaticity.blue_primary.x=chromaticity[4];",
                "                  image->chromaticity.blue_primary.y=chromaticity[5];",
                "                  image->chromaticity.white_point.x=white_point[0],",
                "                  image->chromaticity.white_point.y=white_point[1];",
                "                  (void) sscanf(value,\"%d +X %d\",&height,&width);",
                "                  image->columns=(size_t) width;",
                "                  image->rows=(size_t) height;"
            ],
            "added_lines": [
                "          while ((c != '\\n') && (c != '\\0') && (c != EOF))",
                "                  if (sscanf(value,\"%g %g %g %g %g %g %g %g\",&chromaticity[0],",
                "                      &chromaticity[1],&chromaticity[2],&chromaticity[3],",
                "                      &chromaticity[4],&chromaticity[5],&white_point[0],",
                "                      &white_point[1]) == 8)",
                "                    {",
                "                      image->chromaticity.red_primary.x=chromaticity[0];",
                "                      image->chromaticity.red_primary.y=chromaticity[1];",
                "                      image->chromaticity.green_primary.x=chromaticity[2];",
                "                      image->chromaticity.green_primary.y=chromaticity[3];",
                "                      image->chromaticity.blue_primary.x=chromaticity[4];",
                "                      image->chromaticity.blue_primary.y=chromaticity[5];",
                "                      image->chromaticity.white_point.x=white_point[0],",
                "                      image->chromaticity.white_point.y=white_point[1];",
                "                    }",
                "                  if (sscanf(value,\"%d +X %d\",&height,&width) == 2)",
                "                    {",
                "                      image->columns=(size_t) width;",
                "                      image->rows=(size_t) height;",
                "                    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-29591",
        "func_name": "tensorflow/Subgraph::AllocateTensors",
        "description": "TensorFlow is an end-to-end open source platform for machine learning. TFlite graphs must not have loops between nodes. However, this condition was not checked and an attacker could craft models that would result in infinite loop during evaluation. In certain cases, the infinite loop would be replaced by stack overflow due to too many recursive calls. For example, the `While` implementation(https://github.com/tensorflow/tensorflow/blob/106d8f4fb89335a2c52d7c895b7a7485465ca8d9/tensorflow/lite/kernels/while.cc) could be tricked into a scneario where both the body and the loop subgraphs are the same. Evaluating one of the subgraphs means calling the `Eval` function for the other and this quickly exhaust all stack space. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range. Please consult our security guide(https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.",
        "git_url": "https://github.com/tensorflow/tensorflow/commit/c6173f5fe66cdbab74f4f869311fe6aae2ba35f4",
        "commit_title": "TFLite: Error out when the graph has a recurion.",
        "commit_text": " Recursion is currently unsupported.  PiperOrigin-RevId: 371708957",
        "func_before": "TfLiteStatus Subgraph::AllocateTensors() {\n  TFLITE_SCOPED_TAGGED_DEFAULT_PROFILE(profiler_.get(), \"AllocateTensors\");\n  if (!consistent_) {\n    ReportError(\"AllocateTensors() called on inconsistent model.\");\n    return kTfLiteError;\n  }\n\n  // Restore delegation state if applicable.\n  TF_LITE_ENSURE_STATUS(RedoAllDelegates());\n\n  // Explicit (re)allocation is necessary if nodes have been changed or tensors\n  // have been resized. For inputs marked as dynamic, we can't short-circuit the\n  // allocation as the client may have done the resize manually.\n  if (state_ != kStateUninvokable &&\n      !HasDynamicTensorImpl(context_, inputs())) {\n    if (memory_planner_ && !memory_planner_->HasNonPersistentMemory()) {\n      // If the only change was the release of non-persistent memory via\n      // ReleaseNonPersistentMemory(), just re-allocate it. For any other type\n      // of memory-planning change (for eg, ResizeInputTensor), the state would\n      // be kStateUninvokable.\n      memory_planner_->AcquireNonPersistentMemory();\n    }\n    return kTfLiteOk;\n  }\n\n  next_execution_plan_index_to_prepare_ = 0;\n  next_execution_plan_index_to_plan_allocation_ = 0;\n  next_original_execution_plan_index_to_prepare_ = 0;\n  if (memory_planner_) {\n    TF_LITE_ENSURE_STATUS(memory_planner_->ResetAllocations());\n  }\n\n  TF_LITE_ENSURE_STATUS(PrepareOpsAndTensors());\n\n  state_ = kStateInvokable;\n\n  // Reset the variable tensors to zero after (re)allocating the tensors.\n  // Developers shouldn't rely on the side effect of this function to reset\n  // variable tensors. They should call `ResetVariableTensors` directly\n  // instead.\n  ResetVariableTensors();\n\n  return kTfLiteOk;\n}",
        "func": "TfLiteStatus Subgraph::AllocateTensors() {\n  TFLITE_SCOPED_TAGGED_DEFAULT_PROFILE(profiler_.get(), \"AllocateTensors\");\n\n  if (!consistent_) {\n    ReportError(\"AllocateTensors() called on inconsistent model.\");\n    return kTfLiteError;\n  }\n\n  // Restore delegation state if applicable.\n  TF_LITE_ENSURE_STATUS(RedoAllDelegates());\n\n  // Explicit (re)allocation is necessary if nodes have been changed or tensors\n  // have been resized. For inputs marked as dynamic, we can't short-circuit the\n  // allocation as the client may have done the resize manually.\n  if (state_ != kStateUninvokable &&\n      !HasDynamicTensorImpl(context_, inputs())) {\n    if (memory_planner_ && !memory_planner_->HasNonPersistentMemory()) {\n      // If the only change was the release of non-persistent memory via\n      // ReleaseNonPersistentMemory(), just re-allocate it. For any other type\n      // of memory-planning change (for eg, ResizeInputTensor), the state would\n      // be kStateUninvokable.\n      memory_planner_->AcquireNonPersistentMemory();\n    }\n    return kTfLiteOk;\n  }\n\n  // Note `AllocateTensors` sometimes calls itself recursively above\n  // for delegates. Therefore only the logic below need to be guarded\n  // by `SubgraphGuard`.\n  SubgraphGuard guard(&context_, &is_subgraph_in_use_);\n  TF_LITE_ENSURE_OK(&context_, guard.status());\n\n  next_execution_plan_index_to_prepare_ = 0;\n  next_execution_plan_index_to_plan_allocation_ = 0;\n  next_original_execution_plan_index_to_prepare_ = 0;\n  if (memory_planner_) {\n    TF_LITE_ENSURE_STATUS(memory_planner_->ResetAllocations());\n  }\n\n  TF_LITE_ENSURE_STATUS(PrepareOpsAndTensors());\n\n  state_ = kStateInvokable;\n\n  // Reset the variable tensors to zero after (re)allocating the tensors.\n  // Developers shouldn't rely on the side effect of this function to reset\n  // variable tensors. They should call `ResetVariableTensors` directly\n  // instead.\n  ResetVariableTensors();\n\n  return kTfLiteOk;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n TfLiteStatus Subgraph::AllocateTensors() {\n   TFLITE_SCOPED_TAGGED_DEFAULT_PROFILE(profiler_.get(), \"AllocateTensors\");\n+\n   if (!consistent_) {\n     ReportError(\"AllocateTensors() called on inconsistent model.\");\n     return kTfLiteError;\n@@ -23,6 +24,12 @@\n     return kTfLiteOk;\n   }\n \n+  // Note `AllocateTensors` sometimes calls itself recursively above\n+  // for delegates. Therefore only the logic below need to be guarded\n+  // by `SubgraphGuard`.\n+  SubgraphGuard guard(&context_, &is_subgraph_in_use_);\n+  TF_LITE_ENSURE_OK(&context_, guard.status());\n+\n   next_execution_plan_index_to_prepare_ = 0;\n   next_execution_plan_index_to_plan_allocation_ = 0;\n   next_original_execution_plan_index_to_prepare_ = 0;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  // Note `AllocateTensors` sometimes calls itself recursively above",
                "  // for delegates. Therefore only the logic below need to be guarded",
                "  // by `SubgraphGuard`.",
                "  SubgraphGuard guard(&context_, &is_subgraph_in_use_);",
                "  TF_LITE_ENSURE_OK(&context_, guard.status());",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-29591",
        "func_name": "tensorflow/Subgraph::Invoke",
        "description": "TensorFlow is an end-to-end open source platform for machine learning. TFlite graphs must not have loops between nodes. However, this condition was not checked and an attacker could craft models that would result in infinite loop during evaluation. In certain cases, the infinite loop would be replaced by stack overflow due to too many recursive calls. For example, the `While` implementation(https://github.com/tensorflow/tensorflow/blob/106d8f4fb89335a2c52d7c895b7a7485465ca8d9/tensorflow/lite/kernels/while.cc) could be tricked into a scneario where both the body and the loop subgraphs are the same. Evaluating one of the subgraphs means calling the `Eval` function for the other and this quickly exhaust all stack space. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range. Please consult our security guide(https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.",
        "git_url": "https://github.com/tensorflow/tensorflow/commit/c6173f5fe66cdbab74f4f869311fe6aae2ba35f4",
        "commit_title": "TFLite: Error out when the graph has a recurion.",
        "commit_text": " Recursion is currently unsupported.  PiperOrigin-RevId: 371708957",
        "func_before": "TfLiteStatus Subgraph::Invoke() {\n  if (!consistent_) {\n    ReportError(\"Invoke called on model that is not consistent.\");\n    return kTfLiteError;\n  }\n\n  TfLiteStatus status = kTfLiteOk;\n  if (state_ == kStateUninvokable) {\n    ReportError(\"Invoke called on model that is not ready.\");\n    return kTfLiteError;\n  } else if (memory_planner_ && !memory_planner_->HasNonPersistentMemory()) {\n    ReportError(\"Non-persistent memory is not available.\");\n    return kTfLiteError;\n  }\n  TFLITE_SCOPED_TAGGED_DEFAULT_PROFILE(profiler_.get(), \"Invoke\");\n\n  // Invocations are always done in node order.\n  // Note that calling Invoke repeatedly will cause the original memory plan to\n  // be reused, unless either ResizeInputTensor() or AllocateTensors() has been\n  // called.\n  for (int execution_plan_index = 0;\n       execution_plan_index < execution_plan_.size(); execution_plan_index++) {\n    if (execution_plan_index == next_execution_plan_index_to_prepare_) {\n      TF_LITE_ENSURE_STATUS(PrepareOpsAndTensors());\n      TF_LITE_ENSURE(&context_, next_execution_plan_index_to_prepare_ >=\n                                    execution_plan_index);\n    }\n    int node_index = execution_plan_[execution_plan_index];\n    TfLiteNode& node = nodes_and_registration_[node_index].first;\n    const TfLiteRegistration& registration =\n        nodes_and_registration_[node_index].second;\n\n    const char* op_name = nullptr;\n    if (profiler_) op_name = GetTFLiteOpName(registration);\n    TFLITE_SCOPED_TAGGED_OPERATOR_PROFILE(profiler_.get(), op_name, node_index);\n\n    for (int i = 0; i < node.inputs->size; ++i) {\n      int tensor_index = node.inputs->data[i];\n      if (tensor_index == kTfLiteOptionalTensor) {\n        continue;\n      }\n      TfLiteTensor* tensor = &tensors_[tensor_index];\n      if (tensor->delegate && tensor->delegate != node.delegate &&\n          tensor->data_is_stale) {\n        TF_LITE_ENSURE_STATUS(EnsureTensorDataIsReadable(tensor_index));\n      }\n      if (tensor->data.raw == nullptr && tensor->bytes > 0) {\n        if (registration.builtin_code == kTfLiteBuiltinReshape && i == 1 &&\n            tensor->dims->size != 1) {\n          // In general, having a tensor here with no buffer will be an error.\n          // However, for the reshape operator, the second input tensor is\n          // sometimes only used for the shape, not for the data. Thus, null\n          // buffer is ok in this situation.\n          // The situation where null buffer is not ok for reshape operator is\n          // only when there are 2 inputs given to the node and the one\n          // corresponding to the shape (i == 1) is a vector that contains all\n          // dimensions. See `GetOutputShape()` function in\n          // `tensorflow/lite/kernels/reshape.cc`\n          continue;\n        } else {\n          // In all other cases, we need to return an error as otherwise we will\n          // trigger a null pointer dereference (likely).\n          ReportError(\"Input tensor %d lacks data\", tensor_index);\n          return kTfLiteError;\n        }\n      }\n    }\n\n    if (check_cancelled_func_ != nullptr &&\n        check_cancelled_func_(cancellation_data_)) {\n      ReportError(\"Client requested cancel during Invoke()\");\n      return kTfLiteError;\n    }\n\n    EnsureTensorsVectorCapacity();\n    tensor_resized_since_op_invoke_ = false;\n    if (OpInvoke(registration, &node) != kTfLiteOk) {\n      return ReportOpError(&context_, node, registration, node_index,\n                           \"failed to invoke\");\n    }\n\n    // Force execution prep for downstream ops if the latest op triggered the\n    // resize of a dynamic tensor.\n    if (tensor_resized_since_op_invoke_ &&\n        HasDynamicTensor(context_, node.outputs)) {\n      next_execution_plan_index_to_prepare_ = execution_plan_index + 1;\n\n      // This happens when an intermediate dynamic tensor is resized.\n      // We don't have to prepare all the ops, but we need to recompute\n      // the allocation plan.\n      if (next_execution_plan_index_to_plan_allocation_ >\n          next_execution_plan_index_to_prepare_) {\n        next_execution_plan_index_to_plan_allocation_ =\n            next_execution_plan_index_to_prepare_;\n        if (memory_planner_) {\n          TF_LITE_ENSURE_STATUS(memory_planner_->ResetAllocationsAfter(\n              next_execution_plan_index_to_plan_allocation_ - 1));\n        }\n      }\n    }\n  }\n\n  return status;\n}",
        "func": "TfLiteStatus Subgraph::Invoke() {\n  SubgraphGuard guard(&context_, &is_subgraph_in_use_);\n  TF_LITE_ENSURE_OK(&context_, guard.status());\n\n  if (!consistent_) {\n    ReportError(\"Invoke called on model that is not consistent.\");\n    return kTfLiteError;\n  }\n\n  TfLiteStatus status = kTfLiteOk;\n  if (state_ == kStateUninvokable) {\n    ReportError(\"Invoke called on model that is not ready.\");\n    return kTfLiteError;\n  } else if (memory_planner_ && !memory_planner_->HasNonPersistentMemory()) {\n    ReportError(\"Non-persistent memory is not available.\");\n    return kTfLiteError;\n  }\n  TFLITE_SCOPED_TAGGED_DEFAULT_PROFILE(profiler_.get(), \"Invoke\");\n\n  // Invocations are always done in node order.\n  // Note that calling Invoke repeatedly will cause the original memory plan to\n  // be reused, unless either ResizeInputTensor() or AllocateTensors() has been\n  // called.\n  for (int execution_plan_index = 0;\n       execution_plan_index < execution_plan_.size(); execution_plan_index++) {\n    if (execution_plan_index == next_execution_plan_index_to_prepare_) {\n      TF_LITE_ENSURE_STATUS(PrepareOpsAndTensors());\n      TF_LITE_ENSURE(&context_, next_execution_plan_index_to_prepare_ >=\n                                    execution_plan_index);\n    }\n    int node_index = execution_plan_[execution_plan_index];\n    TfLiteNode& node = nodes_and_registration_[node_index].first;\n    const TfLiteRegistration& registration =\n        nodes_and_registration_[node_index].second;\n\n    const char* op_name = nullptr;\n    if (profiler_) op_name = GetTFLiteOpName(registration);\n    TFLITE_SCOPED_TAGGED_OPERATOR_PROFILE(profiler_.get(), op_name, node_index);\n\n    for (int i = 0; i < node.inputs->size; ++i) {\n      int tensor_index = node.inputs->data[i];\n      if (tensor_index == kTfLiteOptionalTensor) {\n        continue;\n      }\n      TfLiteTensor* tensor = &tensors_[tensor_index];\n      if (tensor->delegate && tensor->delegate != node.delegate &&\n          tensor->data_is_stale) {\n        TF_LITE_ENSURE_STATUS(EnsureTensorDataIsReadable(tensor_index));\n      }\n      if (tensor->data.raw == nullptr && tensor->bytes > 0) {\n        if (registration.builtin_code == kTfLiteBuiltinReshape && i == 1 &&\n            tensor->dims->size != 1) {\n          // In general, having a tensor here with no buffer will be an error.\n          // However, for the reshape operator, the second input tensor is\n          // sometimes only used for the shape, not for the data. Thus, null\n          // buffer is ok in this situation.\n          // The situation where null buffer is not ok for reshape operator is\n          // only when there are 2 inputs given to the node and the one\n          // corresponding to the shape (i == 1) is a vector that contains all\n          // dimensions. See `GetOutputShape()` function in\n          // `tensorflow/lite/kernels/reshape.cc`\n          continue;\n        } else {\n          // In all other cases, we need to return an error as otherwise we will\n          // trigger a null pointer dereference (likely).\n          ReportError(\"Input tensor %d lacks data\", tensor_index);\n          return kTfLiteError;\n        }\n      }\n    }\n\n    if (check_cancelled_func_ != nullptr &&\n        check_cancelled_func_(cancellation_data_)) {\n      ReportError(\"Client requested cancel during Invoke()\");\n      return kTfLiteError;\n    }\n\n    EnsureTensorsVectorCapacity();\n    tensor_resized_since_op_invoke_ = false;\n    if (OpInvoke(registration, &node) != kTfLiteOk) {\n      return ReportOpError(&context_, node, registration, node_index,\n                           \"failed to invoke\");\n    }\n\n    // Force execution prep for downstream ops if the latest op triggered the\n    // resize of a dynamic tensor.\n    if (tensor_resized_since_op_invoke_ &&\n        HasDynamicTensor(context_, node.outputs)) {\n      next_execution_plan_index_to_prepare_ = execution_plan_index + 1;\n\n      // This happens when an intermediate dynamic tensor is resized.\n      // We don't have to prepare all the ops, but we need to recompute\n      // the allocation plan.\n      if (next_execution_plan_index_to_plan_allocation_ >\n          next_execution_plan_index_to_prepare_) {\n        next_execution_plan_index_to_plan_allocation_ =\n            next_execution_plan_index_to_prepare_;\n        if (memory_planner_) {\n          TF_LITE_ENSURE_STATUS(memory_planner_->ResetAllocationsAfter(\n              next_execution_plan_index_to_plan_allocation_ - 1));\n        }\n      }\n    }\n  }\n\n  return status;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,7 @@\n TfLiteStatus Subgraph::Invoke() {\n+  SubgraphGuard guard(&context_, &is_subgraph_in_use_);\n+  TF_LITE_ENSURE_OK(&context_, guard.status());\n+\n   if (!consistent_) {\n     ReportError(\"Invoke called on model that is not consistent.\");\n     return kTfLiteError;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  SubgraphGuard guard(&context_, &is_subgraph_in_use_);",
                "  TF_LITE_ENSURE_OK(&context_, guard.status());",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-29591",
        "func_name": "tensorflow/Prepare",
        "description": "TensorFlow is an end-to-end open source platform for machine learning. TFlite graphs must not have loops between nodes. However, this condition was not checked and an attacker could craft models that would result in infinite loop during evaluation. In certain cases, the infinite loop would be replaced by stack overflow due to too many recursive calls. For example, the `While` implementation(https://github.com/tensorflow/tensorflow/blob/106d8f4fb89335a2c52d7c895b7a7485465ca8d9/tensorflow/lite/kernels/while.cc) could be tricked into a scneario where both the body and the loop subgraphs are the same. Evaluating one of the subgraphs means calling the `Eval` function for the other and this quickly exhaust all stack space. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range. Please consult our security guide(https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.",
        "git_url": "https://github.com/tensorflow/tensorflow/commit/c6173f5fe66cdbab74f4f869311fe6aae2ba35f4",
        "commit_title": "TFLite: Error out when the graph has a recurion.",
        "commit_text": " Recursion is currently unsupported.  PiperOrigin-RevId: 371708957",
        "func_before": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n  int num_inputs = node->inputs->size;\n  // The number of outputs should be the same as number of inputs.\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, num_inputs);\n\n  // Check subgraph indices and get subgraphs.\n  Subgraph* this_subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto* subgraphs = this_subgraph->GetSubgraphs();\n  TF_LITE_ENSURE(context, op_data->cond_subgraph_index < subgraphs->size());\n  TF_LITE_ENSURE(context, op_data->body_subgraph_index < subgraphs->size());\n  TF_LITE_ENSURE(context,\n                 op_data->cond_subgraph_index != op_data->body_subgraph_index);\n\n  Subgraph* cond_subgraph = (*subgraphs)[op_data->cond_subgraph_index].get();\n  Subgraph* body_subgraph = (*subgraphs)[op_data->body_subgraph_index].get();\n\n  // Check input & output count of the condition subgraph.\n  TF_LITE_ENSURE_EQ(context, cond_subgraph->inputs().size(), num_inputs);\n  TF_LITE_ENSURE_EQ(context, cond_subgraph->outputs().size(), 1);\n\n  // Check input & output count of the body subgraph.\n  TF_LITE_ENSURE_EQ(context, body_subgraph->inputs().size(), num_inputs);\n  TF_LITE_ENSURE_EQ(context, body_subgraph->outputs().size(), num_inputs);\n\n  // Prepare and check the condition subgraph.\n  TF_LITE_ENSURE_OK(\n      context, CopyTensorsShapeAndType(\n                   context, this_subgraph, TfLiteIntArrayView(node->inputs),\n                   cond_subgraph, cond_subgraph->inputs(), true));\n  TF_LITE_ENSURE_OK(context, cond_subgraph->AllocateTensors());\n  TfLiteTensor* cond_output =\n      cond_subgraph->tensor(cond_subgraph->outputs()[0]);\n  // This should rarely happens. In most cases the output is static with shape\n  // [1]. However theoretically intermediate tensors in the cond subgraph\n  // can be dynamic.\n  if (IsDynamicTensor(cond_output)) {\n    op_data->cond_has_dynamic_output_tensors = true;\n  } else {\n    TF_LITE_ENSURE_STATUS(CheckCondOutput(context, cond_output));\n  }\n\n  // Prepare and check the body subgraph.\n  TF_LITE_ENSURE_OK(\n      context, CopyTensorsShapeAndType(\n                   context, this_subgraph, TfLiteIntArrayView(node->inputs),\n                   body_subgraph, body_subgraph->inputs(), true));\n  TF_LITE_ENSURE_OK(context, body_subgraph->AllocateTensors());\n  if (body_subgraph->HasDynamicTensors()) {\n    op_data->body_has_dynamic_output_tensors = true;\n  } else {\n    for (int i = 0; i < num_inputs; ++i) {\n      TfLiteTensor* body_input =\n          body_subgraph->tensor(body_subgraph->inputs()[i]);\n      TfLiteTensor* body_output =\n          body_subgraph->tensor(body_subgraph->outputs()[i]);\n      TF_LITE_ENSURE_TYPES_EQ(context, body_input->type, body_output->type);\n\n      TF_LITE_ENSURE(context, !IsDynamicTensor(body_output));\n      if (!TfLiteIntArrayEqual(body_input->dims, body_output->dims)) {\n        // If the output shape of the body subgraph is static w.r.t. a fixed\n        // input size, but it's different from input size, it's still considered\n        // dynamic. For example: If a subgraph keeps padding its input with a\n        // fixed padding, the output shape is static w.r.t the input shape and\n        // padding, but running it in a loop will keep bloating the tensor.\n        op_data->body_has_dynamic_output_tensors = true;\n        break;\n      }\n    }\n  }\n  for (int i = 0; i < num_inputs; ++i) {\n    TfLiteTensor* output;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));\n    if (op_data->body_has_dynamic_output_tensors) {\n      SetTensorToDynamic(output);\n    } else {\n      TfLiteTensor* body_output =\n          body_subgraph->tensor(body_subgraph->outputs()[i]);\n      TfLiteIntArray* output_size = TfLiteIntArrayCopy(body_output->dims);\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, output, output_size));\n    }\n  }\n  return kTfLiteOk;\n}",
        "func": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n  int num_inputs = node->inputs->size;\n  // The number of outputs should be the same as number of inputs.\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, num_inputs);\n\n  // Check subgraph indices and get subgraphs.\n  Subgraph* this_subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto* subgraphs = this_subgraph->GetSubgraphs();\n  TF_LITE_ENSURE(context, op_data->cond_subgraph_index < subgraphs->size());\n  TF_LITE_ENSURE(context, op_data->body_subgraph_index < subgraphs->size());\n\n  Subgraph* cond_subgraph = (*subgraphs)[op_data->cond_subgraph_index].get();\n  Subgraph* body_subgraph = (*subgraphs)[op_data->body_subgraph_index].get();\n\n  // Check input & output count of the condition subgraph.\n  TF_LITE_ENSURE_EQ(context, cond_subgraph->inputs().size(), num_inputs);\n  TF_LITE_ENSURE_EQ(context, cond_subgraph->outputs().size(), 1);\n\n  // Check input & output count of the body subgraph.\n  TF_LITE_ENSURE_EQ(context, body_subgraph->inputs().size(), num_inputs);\n  TF_LITE_ENSURE_EQ(context, body_subgraph->outputs().size(), num_inputs);\n\n  // Prepare and check the condition subgraph.\n  TF_LITE_ENSURE_OK(\n      context, CopyTensorsShapeAndType(\n                   context, this_subgraph, TfLiteIntArrayView(node->inputs),\n                   cond_subgraph, cond_subgraph->inputs(), true));\n  TF_LITE_ENSURE_OK(context, cond_subgraph->AllocateTensors());\n  TfLiteTensor* cond_output =\n      cond_subgraph->tensor(cond_subgraph->outputs()[0]);\n  // This should rarely happens. In most cases the output is static with shape\n  // [1]. However theoretically intermediate tensors in the cond subgraph\n  // can be dynamic.\n  if (IsDynamicTensor(cond_output)) {\n    op_data->cond_has_dynamic_output_tensors = true;\n  } else {\n    TF_LITE_ENSURE_STATUS(CheckCondOutput(context, cond_output));\n  }\n\n  // Prepare and check the body subgraph.\n  TF_LITE_ENSURE_OK(\n      context, CopyTensorsShapeAndType(\n                   context, this_subgraph, TfLiteIntArrayView(node->inputs),\n                   body_subgraph, body_subgraph->inputs(), true));\n  TF_LITE_ENSURE_OK(context, body_subgraph->AllocateTensors());\n  if (body_subgraph->HasDynamicTensors()) {\n    op_data->body_has_dynamic_output_tensors = true;\n  } else {\n    for (int i = 0; i < num_inputs; ++i) {\n      TfLiteTensor* body_input =\n          body_subgraph->tensor(body_subgraph->inputs()[i]);\n      TfLiteTensor* body_output =\n          body_subgraph->tensor(body_subgraph->outputs()[i]);\n      TF_LITE_ENSURE_TYPES_EQ(context, body_input->type, body_output->type);\n\n      TF_LITE_ENSURE(context, !IsDynamicTensor(body_output));\n      if (!TfLiteIntArrayEqual(body_input->dims, body_output->dims)) {\n        // If the output shape of the body subgraph is static w.r.t. a fixed\n        // input size, but it's different from input size, it's still considered\n        // dynamic. For example: If a subgraph keeps padding its input with a\n        // fixed padding, the output shape is static w.r.t the input shape and\n        // padding, but running it in a loop will keep bloating the tensor.\n        op_data->body_has_dynamic_output_tensors = true;\n        break;\n      }\n    }\n  }\n  for (int i = 0; i < num_inputs; ++i) {\n    TfLiteTensor* output;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));\n    if (op_data->body_has_dynamic_output_tensors) {\n      SetTensorToDynamic(output);\n    } else {\n      TfLiteTensor* body_output =\n          body_subgraph->tensor(body_subgraph->outputs()[i]);\n      TfLiteIntArray* output_size = TfLiteIntArrayCopy(body_output->dims);\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, output, output_size));\n    }\n  }\n  return kTfLiteOk;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,8 +9,6 @@\n   auto* subgraphs = this_subgraph->GetSubgraphs();\n   TF_LITE_ENSURE(context, op_data->cond_subgraph_index < subgraphs->size());\n   TF_LITE_ENSURE(context, op_data->body_subgraph_index < subgraphs->size());\n-  TF_LITE_ENSURE(context,\n-                 op_data->cond_subgraph_index != op_data->body_subgraph_index);\n \n   Subgraph* cond_subgraph = (*subgraphs)[op_data->cond_subgraph_index].get();\n   Subgraph* body_subgraph = (*subgraphs)[op_data->body_subgraph_index].get();",
        "diff_line_info": {
            "deleted_lines": [
                "  TF_LITE_ENSURE(context,",
                "                 op_data->cond_subgraph_index != op_data->body_subgraph_index);"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2021-29591",
        "func_name": "tensorflow/Prepare",
        "description": "TensorFlow is an end-to-end open source platform for machine learning. TFlite graphs must not have loops between nodes. However, this condition was not checked and an attacker could craft models that would result in infinite loop during evaluation. In certain cases, the infinite loop would be replaced by stack overflow due to too many recursive calls. For example, the `While` implementation(https://github.com/tensorflow/tensorflow/blob/106d8f4fb89335a2c52d7c895b7a7485465ca8d9/tensorflow/lite/kernels/while.cc) could be tricked into a scneario where both the body and the loop subgraphs are the same. Evaluating one of the subgraphs means calling the `Eval` function for the other and this quickly exhaust all stack space. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range. Please consult our security guide(https://github.com/tensorflow/tensorflow/blob/master/SECURITY.md) for more information regarding the security model and how to contact us with issues and questions.",
        "git_url": "https://github.com/tensorflow/tensorflow/commit/9c1dc920d8ffb4893d6c9d27d1f039607b326743",
        "commit_title": "Prevent infinite loop/stack overflow in TFLite `while` op.",
        "commit_text": " PiperOrigin-RevId: 370800333",
        "func_before": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n  int num_inputs = node->inputs->size;\n  // The number of outputs should be the same as number of inputs.\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, num_inputs);\n\n  // Check subgraph indices and get subgraphs.\n  Subgraph* this_subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto* subgraphs = this_subgraph->GetSubgraphs();\n  TF_LITE_ENSURE(context, op_data->cond_subgraph_index < subgraphs->size());\n  TF_LITE_ENSURE(context, op_data->body_subgraph_index < subgraphs->size());\n\n  Subgraph* cond_subgraph = (*subgraphs)[op_data->cond_subgraph_index].get();\n  Subgraph* body_subgraph = (*subgraphs)[op_data->body_subgraph_index].get();\n\n  // Check input & output count of the condition subgraph.\n  TF_LITE_ENSURE_EQ(context, cond_subgraph->inputs().size(), num_inputs);\n  TF_LITE_ENSURE_EQ(context, cond_subgraph->outputs().size(), 1);\n\n  // Check input & output count of the body subgraph.\n  TF_LITE_ENSURE_EQ(context, body_subgraph->inputs().size(), num_inputs);\n  TF_LITE_ENSURE_EQ(context, body_subgraph->outputs().size(), num_inputs);\n\n  // Prepare and check the condition subgraph.\n  TF_LITE_ENSURE_OK(\n      context, CopyTensorsShapeAndType(\n                   context, this_subgraph, TfLiteIntArrayView(node->inputs),\n                   cond_subgraph, cond_subgraph->inputs(), true));\n  TF_LITE_ENSURE_OK(context, cond_subgraph->AllocateTensors());\n  TfLiteTensor* cond_output =\n      cond_subgraph->tensor(cond_subgraph->outputs()[0]);\n  // This should rarely happens. In most cases the output is static with shape\n  // [1]. However theoretically intermediate tensors in the cond subgraph\n  // can be dynamic.\n  if (IsDynamicTensor(cond_output)) {\n    op_data->cond_has_dynamic_output_tensors = true;\n  } else {\n    TF_LITE_ENSURE_STATUS(CheckCondOutput(context, cond_output));\n  }\n\n  // Prepare and check the body subgraph.\n  TF_LITE_ENSURE_OK(\n      context, CopyTensorsShapeAndType(\n                   context, this_subgraph, TfLiteIntArrayView(node->inputs),\n                   body_subgraph, body_subgraph->inputs(), true));\n  TF_LITE_ENSURE_OK(context, body_subgraph->AllocateTensors());\n  if (body_subgraph->HasDynamicTensors()) {\n    op_data->body_has_dynamic_output_tensors = true;\n  } else {\n    for (int i = 0; i < num_inputs; ++i) {\n      TfLiteTensor* body_input =\n          body_subgraph->tensor(body_subgraph->inputs()[i]);\n      TfLiteTensor* body_output =\n          body_subgraph->tensor(body_subgraph->outputs()[i]);\n      TF_LITE_ENSURE_TYPES_EQ(context, body_input->type, body_output->type);\n\n      TF_LITE_ENSURE(context, !IsDynamicTensor(body_output));\n      if (!TfLiteIntArrayEqual(body_input->dims, body_output->dims)) {\n        // If the output shape of the body subgraph is static w.r.t. a fixed\n        // input size, but it's different from input size, it's still considered\n        // dynamic. For example: If a subgraph keeps padding its input with a\n        // fixed padding, the output shape is static w.r.t the input shape and\n        // padding, but running it in a loop will keep bloating the tensor.\n        op_data->body_has_dynamic_output_tensors = true;\n        break;\n      }\n    }\n  }\n  for (int i = 0; i < num_inputs; ++i) {\n    TfLiteTensor* output;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));\n    if (op_data->body_has_dynamic_output_tensors) {\n      SetTensorToDynamic(output);\n    } else {\n      TfLiteTensor* body_output =\n          body_subgraph->tensor(body_subgraph->outputs()[i]);\n      TfLiteIntArray* output_size = TfLiteIntArrayCopy(body_output->dims);\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, output, output_size));\n    }\n  }\n  return kTfLiteOk;\n}",
        "func": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n  int num_inputs = node->inputs->size;\n  // The number of outputs should be the same as number of inputs.\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, num_inputs);\n\n  // Check subgraph indices and get subgraphs.\n  Subgraph* this_subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto* subgraphs = this_subgraph->GetSubgraphs();\n  TF_LITE_ENSURE(context, op_data->cond_subgraph_index < subgraphs->size());\n  TF_LITE_ENSURE(context, op_data->body_subgraph_index < subgraphs->size());\n  TF_LITE_ENSURE(context,\n                 op_data->cond_subgraph_index != op_data->body_subgraph_index);\n\n  Subgraph* cond_subgraph = (*subgraphs)[op_data->cond_subgraph_index].get();\n  Subgraph* body_subgraph = (*subgraphs)[op_data->body_subgraph_index].get();\n\n  // Check input & output count of the condition subgraph.\n  TF_LITE_ENSURE_EQ(context, cond_subgraph->inputs().size(), num_inputs);\n  TF_LITE_ENSURE_EQ(context, cond_subgraph->outputs().size(), 1);\n\n  // Check input & output count of the body subgraph.\n  TF_LITE_ENSURE_EQ(context, body_subgraph->inputs().size(), num_inputs);\n  TF_LITE_ENSURE_EQ(context, body_subgraph->outputs().size(), num_inputs);\n\n  // Prepare and check the condition subgraph.\n  TF_LITE_ENSURE_OK(\n      context, CopyTensorsShapeAndType(\n                   context, this_subgraph, TfLiteIntArrayView(node->inputs),\n                   cond_subgraph, cond_subgraph->inputs(), true));\n  TF_LITE_ENSURE_OK(context, cond_subgraph->AllocateTensors());\n  TfLiteTensor* cond_output =\n      cond_subgraph->tensor(cond_subgraph->outputs()[0]);\n  // This should rarely happens. In most cases the output is static with shape\n  // [1]. However theoretically intermediate tensors in the cond subgraph\n  // can be dynamic.\n  if (IsDynamicTensor(cond_output)) {\n    op_data->cond_has_dynamic_output_tensors = true;\n  } else {\n    TF_LITE_ENSURE_STATUS(CheckCondOutput(context, cond_output));\n  }\n\n  // Prepare and check the body subgraph.\n  TF_LITE_ENSURE_OK(\n      context, CopyTensorsShapeAndType(\n                   context, this_subgraph, TfLiteIntArrayView(node->inputs),\n                   body_subgraph, body_subgraph->inputs(), true));\n  TF_LITE_ENSURE_OK(context, body_subgraph->AllocateTensors());\n  if (body_subgraph->HasDynamicTensors()) {\n    op_data->body_has_dynamic_output_tensors = true;\n  } else {\n    for (int i = 0; i < num_inputs; ++i) {\n      TfLiteTensor* body_input =\n          body_subgraph->tensor(body_subgraph->inputs()[i]);\n      TfLiteTensor* body_output =\n          body_subgraph->tensor(body_subgraph->outputs()[i]);\n      TF_LITE_ENSURE_TYPES_EQ(context, body_input->type, body_output->type);\n\n      TF_LITE_ENSURE(context, !IsDynamicTensor(body_output));\n      if (!TfLiteIntArrayEqual(body_input->dims, body_output->dims)) {\n        // If the output shape of the body subgraph is static w.r.t. a fixed\n        // input size, but it's different from input size, it's still considered\n        // dynamic. For example: If a subgraph keeps padding its input with a\n        // fixed padding, the output shape is static w.r.t the input shape and\n        // padding, but running it in a loop will keep bloating the tensor.\n        op_data->body_has_dynamic_output_tensors = true;\n        break;\n      }\n    }\n  }\n  for (int i = 0; i < num_inputs; ++i) {\n    TfLiteTensor* output;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));\n    if (op_data->body_has_dynamic_output_tensors) {\n      SetTensorToDynamic(output);\n    } else {\n      TfLiteTensor* body_output =\n          body_subgraph->tensor(body_subgraph->outputs()[i]);\n      TfLiteIntArray* output_size = TfLiteIntArrayCopy(body_output->dims);\n      TF_LITE_ENSURE_OK(context,\n                        context->ResizeTensor(context, output, output_size));\n    }\n  }\n  return kTfLiteOk;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,6 +9,8 @@\n   auto* subgraphs = this_subgraph->GetSubgraphs();\n   TF_LITE_ENSURE(context, op_data->cond_subgraph_index < subgraphs->size());\n   TF_LITE_ENSURE(context, op_data->body_subgraph_index < subgraphs->size());\n+  TF_LITE_ENSURE(context,\n+                 op_data->cond_subgraph_index != op_data->body_subgraph_index);\n \n   Subgraph* cond_subgraph = (*subgraphs)[op_data->cond_subgraph_index].get();\n   Subgraph* body_subgraph = (*subgraphs)[op_data->body_subgraph_index].get();",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  TF_LITE_ENSURE(context,",
                "                 op_data->cond_subgraph_index != op_data->body_subgraph_index);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28676",
        "func_name": "python-pillow/Pillow/ImagingFliDecode",
        "description": "An issue was discovered in Pillow before 8.2.0. For FLI data, FliDecode did not properly check that the block advance was non-zero, potentially leading to an infinite loop on load.",
        "git_url": "https://github.com/python-pillow/Pillow/commit/bb6c11fb889e6c11b0ee122b828132ee763b5856",
        "commit_title": "Fix FLI DOS -- CVE-2021-28676",
        "commit_text": " * FliDecode did not properly check that the block advance was   non-zero, potentally leading to an infinite loop on load. * This dates to the PIL Fork * Found with oss-fuzz",
        "func_before": "int\nImagingFliDecode(Imaging im, ImagingCodecState state, UINT8 *buf, Py_ssize_t bytes) {\n    UINT8 *ptr;\n    int framesize;\n    int c, chunks, advance;\n    int l, lines;\n    int i, j, x = 0, y, ymax;\n\n    /* If not even the chunk size is present, we'd better leave */\n\n    if (bytes < 4) {\n        return 0;\n    }\n\n    /* We don't decode anything unless we have a full chunk in the\n       input buffer */\n\n    ptr = buf;\n\n    framesize = I32(ptr);\n    if (framesize < I32(ptr)) {\n        return 0;\n    }\n\n    /* Make sure this is a frame chunk.  The Python driver takes\n       case of other chunk types. */\n\n    if (bytes < 8) {\n        state->errcode = IMAGING_CODEC_OVERRUN;\n        return -1;\n    }\n    if (I16(ptr + 4) != 0xF1FA) {\n        state->errcode = IMAGING_CODEC_UNKNOWN;\n        return -1;\n    }\n\n    chunks = I16(ptr + 6);\n    ptr += 16;\n    bytes -= 16;\n\n    /* Process subchunks */\n    for (c = 0; c < chunks; c++) {\n        UINT8 *data;\n        if (bytes < 10) {\n            state->errcode = IMAGING_CODEC_OVERRUN;\n            return -1;\n        }\n        data = ptr + 6;\n        switch (I16(ptr + 4)) {\n            case 4:\n            case 11:\n                /* FLI COLOR chunk */\n                break; /* ignored; handled by Python code */\n            case 7:\n                /* FLI SS2 chunk (word delta) */\n                /* OOB ok, we've got 4 bytes min on entry */\n                lines = I16(data);\n                data += 2;\n                for (l = y = 0; l < lines && y < state->ysize; l++, y++) {\n                    UINT8 *local_buf = (UINT8 *)im->image[y];\n                    int p, packets;\n                    ERR_IF_DATA_OOB(2)\n                    packets = I16(data);\n                    data += 2;\n                    while (packets & 0x8000) {\n                        /* flag word */\n                        if (packets & 0x4000) {\n                            y += 65536 - packets; /* skip lines */\n                            if (y >= state->ysize) {\n                                state->errcode = IMAGING_CODEC_OVERRUN;\n                                return -1;\n                            }\n                            local_buf = (UINT8 *)im->image[y];\n                        } else {\n                            /* store last byte (used if line width is odd) */\n                            local_buf[state->xsize - 1] = (UINT8)packets;\n                        }\n                        ERR_IF_DATA_OOB(2)\n                        packets = I16(data);\n                        data += 2;\n                    }\n                    for (p = x = 0; p < packets; p++) {\n                        ERR_IF_DATA_OOB(2)\n                        x += data[0]; /* pixel skip */\n                        if (data[1] >= 128) {\n                            ERR_IF_DATA_OOB(4)\n                            i = 256 - data[1]; /* run */\n                            if (x + i + i > state->xsize) {\n                                break;\n                            }\n                            for (j = 0; j < i; j++) {\n                                local_buf[x++] = data[2];\n                                local_buf[x++] = data[3];\n                            }\n                            data += 2 + 2;\n                        } else {\n                            i = 2 * (int)data[1]; /* chunk */\n                            if (x + i > state->xsize) {\n                                break;\n                            }\n                            ERR_IF_DATA_OOB(2 + i)\n                            memcpy(local_buf + x, data + 2, i);\n                            data += 2 + i;\n                            x += i;\n                        }\n                    }\n                    if (p < packets) {\n                        break; /* didn't process all packets */\n                    }\n                }\n                if (l < lines) {\n                    /* didn't process all lines */\n                    state->errcode = IMAGING_CODEC_OVERRUN;\n                    return -1;\n                }\n                break;\n            case 12:\n                /* FLI LC chunk (byte delta) */\n                /* OOB Check ok, we have 4 bytes min here */\n                y = I16(data);\n                ymax = y + I16(data + 2);\n                data += 4;\n                for (; y < ymax && y < state->ysize; y++) {\n                    UINT8 *out = (UINT8 *)im->image[y];\n                    ERR_IF_DATA_OOB(1)\n                    int p, packets = *data++;\n                    for (p = x = 0; p < packets; p++, x += i) {\n                        ERR_IF_DATA_OOB(2)\n                        x += data[0]; /* skip pixels */\n                        if (data[1] & 0x80) {\n                            i = 256 - data[1]; /* run */\n                            if (x + i > state->xsize) {\n                                break;\n                            }\n                            ERR_IF_DATA_OOB(3)\n                            memset(out + x, data[2], i);\n                            data += 3;\n                        } else {\n                            i = data[1]; /* chunk */\n                            if (x + i > state->xsize) {\n                                break;\n                            }\n                            ERR_IF_DATA_OOB(2 + i)\n                            memcpy(out + x, data + 2, i);\n                            data += i + 2;\n                        }\n                    }\n                    if (p < packets) {\n                        break; /* didn't process all packets */\n                    }\n                }\n                if (y < ymax) {\n                    /* didn't process all lines */\n                    state->errcode = IMAGING_CODEC_OVERRUN;\n                    return -1;\n                }\n                break;\n            case 13:\n                /* FLI BLACK chunk */\n                for (y = 0; y < state->ysize; y++) {\n                    memset(im->image[y], 0, state->xsize);\n                }\n                break;\n            case 15:\n                /* FLI BRUN chunk */\n                /* OOB, ok, we've got 4 bytes min on entry */\n                for (y = 0; y < state->ysize; y++) {\n                    UINT8 *out = (UINT8 *)im->image[y];\n                    data += 1; /* ignore packetcount byte */\n                    for (x = 0; x < state->xsize; x += i) {\n                        ERR_IF_DATA_OOB(2)\n                        if (data[0] & 0x80) {\n                            i = 256 - data[0];\n                            if (x + i > state->xsize) {\n                                break; /* safety first */\n                            }\n                            ERR_IF_DATA_OOB(i + 1)\n                            memcpy(out + x, data + 1, i);\n                            data += i + 1;\n                        } else {\n                            i = data[0];\n                            if (x + i > state->xsize) {\n                                break; /* safety first */\n                            }\n                            memset(out + x, data[1], i);\n                            data += 2;\n                        }\n                    }\n                    if (x != state->xsize) {\n                        /* didn't unpack whole line */\n                        state->errcode = IMAGING_CODEC_OVERRUN;\n                        return -1;\n                    }\n                }\n                break;\n            case 16:\n                /* COPY chunk */\n                if (state->xsize > bytes / state->ysize) {\n                    /* not enough data for frame */\n                    return ptr - buf; /* bytes consumed */\n                }\n                for (y = 0; y < state->ysize; y++) {\n                    UINT8 *local_buf = (UINT8 *)im->image[y];\n                    memcpy(local_buf, data, state->xsize);\n                    data += state->xsize;\n                }\n                break;\n            case 18:\n                /* PSTAMP chunk */\n                break; /* ignored */\n            default:\n                /* unknown chunk */\n                /* printf(\"unknown FLI/FLC chunk: %d\\n\", I16(ptr+4)); */\n                state->errcode = IMAGING_CODEC_UNKNOWN;\n                return -1;\n        }\n        advance = I32(ptr);\n        if (advance < 0 || advance > bytes) {\n            state->errcode = IMAGING_CODEC_OVERRUN;\n            return -1;\n        }\n        ptr += advance;\n        bytes -= advance;\n    }\n\n    return -1; /* end of frame */\n}",
        "func": "int\nImagingFliDecode(Imaging im, ImagingCodecState state, UINT8 *buf, Py_ssize_t bytes) {\n    UINT8 *ptr;\n    int framesize;\n    int c, chunks, advance;\n    int l, lines;\n    int i, j, x = 0, y, ymax;\n\n    /* If not even the chunk size is present, we'd better leave */\n\n    if (bytes < 4) {\n        return 0;\n    }\n\n    /* We don't decode anything unless we have a full chunk in the\n       input buffer */\n\n    ptr = buf;\n\n    framesize = I32(ptr);\n    if (framesize < I32(ptr)) {\n        return 0;\n    }\n\n    /* Make sure this is a frame chunk.  The Python driver takes\n       case of other chunk types. */\n\n    if (bytes < 8) {\n        state->errcode = IMAGING_CODEC_OVERRUN;\n        return -1;\n    }\n    if (I16(ptr + 4) != 0xF1FA) {\n        state->errcode = IMAGING_CODEC_UNKNOWN;\n        return -1;\n    }\n\n    chunks = I16(ptr + 6);\n    ptr += 16;\n    bytes -= 16;\n\n    /* Process subchunks */\n    for (c = 0; c < chunks; c++) {\n        UINT8 *data;\n        if (bytes < 10) {\n            state->errcode = IMAGING_CODEC_OVERRUN;\n            return -1;\n        }\n        data = ptr + 6;\n        switch (I16(ptr + 4)) {\n            case 4:\n            case 11:\n                /* FLI COLOR chunk */\n                break; /* ignored; handled by Python code */\n            case 7:\n                /* FLI SS2 chunk (word delta) */\n                /* OOB ok, we've got 4 bytes min on entry */\n                lines = I16(data);\n                data += 2;\n                for (l = y = 0; l < lines && y < state->ysize; l++, y++) {\n                    UINT8 *local_buf = (UINT8 *)im->image[y];\n                    int p, packets;\n                    ERR_IF_DATA_OOB(2)\n                    packets = I16(data);\n                    data += 2;\n                    while (packets & 0x8000) {\n                        /* flag word */\n                        if (packets & 0x4000) {\n                            y += 65536 - packets; /* skip lines */\n                            if (y >= state->ysize) {\n                                state->errcode = IMAGING_CODEC_OVERRUN;\n                                return -1;\n                            }\n                            local_buf = (UINT8 *)im->image[y];\n                        } else {\n                            /* store last byte (used if line width is odd) */\n                            local_buf[state->xsize - 1] = (UINT8)packets;\n                        }\n                        ERR_IF_DATA_OOB(2)\n                        packets = I16(data);\n                        data += 2;\n                    }\n                    for (p = x = 0; p < packets; p++) {\n                        ERR_IF_DATA_OOB(2)\n                        x += data[0]; /* pixel skip */\n                        if (data[1] >= 128) {\n                            ERR_IF_DATA_OOB(4)\n                            i = 256 - data[1]; /* run */\n                            if (x + i + i > state->xsize) {\n                                break;\n                            }\n                            for (j = 0; j < i; j++) {\n                                local_buf[x++] = data[2];\n                                local_buf[x++] = data[3];\n                            }\n                            data += 2 + 2;\n                        } else {\n                            i = 2 * (int)data[1]; /* chunk */\n                            if (x + i > state->xsize) {\n                                break;\n                            }\n                            ERR_IF_DATA_OOB(2 + i)\n                            memcpy(local_buf + x, data + 2, i);\n                            data += 2 + i;\n                            x += i;\n                        }\n                    }\n                    if (p < packets) {\n                        break; /* didn't process all packets */\n                    }\n                }\n                if (l < lines) {\n                    /* didn't process all lines */\n                    state->errcode = IMAGING_CODEC_OVERRUN;\n                    return -1;\n                }\n                break;\n            case 12:\n                /* FLI LC chunk (byte delta) */\n                /* OOB Check ok, we have 4 bytes min here */\n                y = I16(data);\n                ymax = y + I16(data + 2);\n                data += 4;\n                for (; y < ymax && y < state->ysize; y++) {\n                    UINT8 *out = (UINT8 *)im->image[y];\n                    ERR_IF_DATA_OOB(1)\n                    int p, packets = *data++;\n                    for (p = x = 0; p < packets; p++, x += i) {\n                        ERR_IF_DATA_OOB(2)\n                        x += data[0]; /* skip pixels */\n                        if (data[1] & 0x80) {\n                            i = 256 - data[1]; /* run */\n                            if (x + i > state->xsize) {\n                                break;\n                            }\n                            ERR_IF_DATA_OOB(3)\n                            memset(out + x, data[2], i);\n                            data += 3;\n                        } else {\n                            i = data[1]; /* chunk */\n                            if (x + i > state->xsize) {\n                                break;\n                            }\n                            ERR_IF_DATA_OOB(2 + i)\n                            memcpy(out + x, data + 2, i);\n                            data += i + 2;\n                        }\n                    }\n                    if (p < packets) {\n                        break; /* didn't process all packets */\n                    }\n                }\n                if (y < ymax) {\n                    /* didn't process all lines */\n                    state->errcode = IMAGING_CODEC_OVERRUN;\n                    return -1;\n                }\n                break;\n            case 13:\n                /* FLI BLACK chunk */\n                for (y = 0; y < state->ysize; y++) {\n                    memset(im->image[y], 0, state->xsize);\n                }\n                break;\n            case 15:\n                /* FLI BRUN chunk */\n                /* OOB, ok, we've got 4 bytes min on entry */\n                for (y = 0; y < state->ysize; y++) {\n                    UINT8 *out = (UINT8 *)im->image[y];\n                    data += 1; /* ignore packetcount byte */\n                    for (x = 0; x < state->xsize; x += i) {\n                        ERR_IF_DATA_OOB(2)\n                        if (data[0] & 0x80) {\n                            i = 256 - data[0];\n                            if (x + i > state->xsize) {\n                                break; /* safety first */\n                            }\n                            ERR_IF_DATA_OOB(i + 1)\n                            memcpy(out + x, data + 1, i);\n                            data += i + 1;\n                        } else {\n                            i = data[0];\n                            if (x + i > state->xsize) {\n                                break; /* safety first */\n                            }\n                            memset(out + x, data[1], i);\n                            data += 2;\n                        }\n                    }\n                    if (x != state->xsize) {\n                        /* didn't unpack whole line */\n                        state->errcode = IMAGING_CODEC_OVERRUN;\n                        return -1;\n                    }\n                }\n                break;\n            case 16:\n                /* COPY chunk */\n                if (state->xsize > bytes / state->ysize) {\n                    /* not enough data for frame */\n                    return ptr - buf; /* bytes consumed */\n                }\n                for (y = 0; y < state->ysize; y++) {\n                    UINT8 *local_buf = (UINT8 *)im->image[y];\n                    memcpy(local_buf, data, state->xsize);\n                    data += state->xsize;\n                }\n                break;\n            case 18:\n                /* PSTAMP chunk */\n                break; /* ignored */\n            default:\n                /* unknown chunk */\n                /* printf(\"unknown FLI/FLC chunk: %d\\n\", I16(ptr+4)); */\n                state->errcode = IMAGING_CODEC_UNKNOWN;\n                return -1;\n        }\n        advance = I32(ptr);\n        if (advance == 0 ) {\n            // If there's no advance, we're in in infinite loop\n            state->errcode = IMAGING_CODEC_BROKEN;\n            return -1;\n        }\n        if (advance < 0 || advance > bytes) {\n            state->errcode = IMAGING_CODEC_OVERRUN;\n            return -1;\n        }\n        ptr += advance;\n        bytes -= advance;\n    }\n\n    return -1; /* end of frame */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -215,6 +215,11 @@\n                 return -1;\n         }\n         advance = I32(ptr);\n+        if (advance == 0 ) {\n+            // If there's no advance, we're in in infinite loop\n+            state->errcode = IMAGING_CODEC_BROKEN;\n+            return -1;\n+        }\n         if (advance < 0 || advance > bytes) {\n             state->errcode = IMAGING_CODEC_OVERRUN;\n             return -1;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (advance == 0 ) {",
                "            // If there's no advance, we're in in infinite loop",
                "            state->errcode = IMAGING_CODEC_BROKEN;",
                "            return -1;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22222",
        "func_name": "wireshark/dissect_dvb_s2_bb",
        "description": "Infinite loop in DVB-S2-BB dissector in Wireshark 3.4.0 to 3.4.5 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/0137c24d60934f131b25506a88c9464e4dc827de",
        "commit_title": "DVB-S2-BB: Prevent infinite loop",
        "commit_text": " Commit 4bf4ee88f0544727e7f89f3f288c6afd2f650a4c removed an else statement that broke out of the BBFrame processing loop. Without it, infinite loops might be possible if the GSE frames have bit errors in the length field. ",
        "func_before": "static int dissect_dvb_s2_bb(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\n{\n    proto_item *ti;\n    proto_tree *dvb_s2_bb_tree;\n\n    guint8      input8, matype1;\n    guint8      sync_flag = 0;\n    guint16     input16, bb_data_len = 0, user_packet_length;\n\n    int         sub_dissected        = 0, flag_is_ms = 0, new_off = 0;\n\n    static int * const bb_header_bitfields[] = {\n        &hf_dvb_s2_bb_matype1_gs,\n        &hf_dvb_s2_bb_matype1_mis,\n        &hf_dvb_s2_bb_matype1_acm,\n        &hf_dvb_s2_bb_matype1_issyi,\n        &hf_dvb_s2_bb_matype1_npd,\n        &hf_dvb_s2_bb_matype1_low_ro,\n        NULL\n    };\n\n    col_append_str(pinfo->cinfo, COL_PROTOCOL, \"BB \");\n    col_append_str(pinfo->cinfo, COL_INFO, \"Baseband \");\n\n    /* create display subtree for the protocol */\n    ti = proto_tree_add_item(tree, proto_dvb_s2_bb, tvb, 0, DVB_S2_BB_HEADER_LEN, ENC_NA);\n    dvb_s2_bb_tree = proto_item_add_subtree(ti, ett_dvb_s2_bb);\n\n    matype1 = tvb_get_guint8(tvb, DVB_S2_BB_OFFS_MATYPE1);\n    new_off += 1;\n\n    if (BIT_IS_CLEAR(matype1, DVB_S2_BB_MIS_POS))\n        flag_is_ms = 1;\n\n    proto_tree_add_bitmask_with_flags(dvb_s2_bb_tree, tvb, DVB_S2_BB_OFFS_MATYPE1, hf_dvb_s2_bb_matype1,\n        ett_dvb_s2_bb_matype1, bb_header_bitfields, ENC_BIG_ENDIAN, BMT_NO_FLAGS);\n\n    input8 = tvb_get_guint8(tvb, DVB_S2_BB_OFFS_MATYPE1);\n\n    if ((pinfo->fd->num == 1) && (_use_low_rolloff_value != 0)) {\n        _use_low_rolloff_value = 0;\n    }\n    if (((input8 & 0x03) == 3) && !_use_low_rolloff_value) {\n      _use_low_rolloff_value = 1;\n    }\n    if (_use_low_rolloff_value) {\n       proto_tree_add_item(dvb_s2_bb_tree, hf_dvb_s2_bb_matype1_low_ro, tvb,\n                           DVB_S2_BB_OFFS_MATYPE1, 1, ENC_BIG_ENDIAN);\n    } else {\n       proto_tree_add_item(dvb_s2_bb_tree, hf_dvb_s2_bb_matype1_high_ro, tvb,\n                           DVB_S2_BB_OFFS_MATYPE1, 1, ENC_BIG_ENDIAN);\n    }\n\n    input8 = tvb_get_guint8(tvb, DVB_S2_BB_OFFS_MATYPE2);\n    new_off += 1;\n    if (flag_is_ms) {\n        proto_tree_add_uint_format_value(dvb_s2_bb_tree, hf_dvb_s2_bb_matype2, tvb,\n                                   DVB_S2_BB_OFFS_MATYPE2, 1, input8, \"Input Stream Identifier (ISI): %d\",\n                                   input8);\n    } else {\n        proto_tree_add_uint_format_value(dvb_s2_bb_tree, hf_dvb_s2_bb_matype2, tvb,\n                                   DVB_S2_BB_OFFS_MATYPE2, 1, input8, \"reserved\");\n    }\n\n    user_packet_length = input16 = tvb_get_ntohs(tvb, DVB_S2_BB_OFFS_UPL);\n    new_off += 2;\n\n    proto_tree_add_uint_format(dvb_s2_bb_tree, hf_dvb_s2_bb_upl, tvb,\n                               DVB_S2_BB_OFFS_UPL, 2, input16, \"User Packet Length: %d bits (%d bytes)\",\n                               (guint16) input16, (guint16) input16 / 8);\n\n    bb_data_len = input16 = tvb_get_ntohs(tvb, DVB_S2_BB_OFFS_DFL);\n    bb_data_len /= 8;\n    new_off += 2;\n\n    proto_tree_add_uint_format_value(dvb_s2_bb_tree, hf_dvb_s2_bb_dfl, tvb,\n                               DVB_S2_BB_OFFS_DFL, 2, input16, \"%d bits (%d bytes)\", input16, input16 / 8);\n\n    new_off += 1;\n    sync_flag = tvb_get_guint8(tvb, DVB_S2_BB_OFFS_SYNC);\n    proto_tree_add_item(dvb_s2_bb_tree, hf_dvb_s2_bb_sync, tvb, DVB_S2_BB_OFFS_SYNC, 1, ENC_BIG_ENDIAN);\n\n    new_off += 2;\n    proto_tree_add_item(dvb_s2_bb_tree, hf_dvb_s2_bb_syncd, tvb, DVB_S2_BB_OFFS_SYNCD, 2, ENC_BIG_ENDIAN);\n\n    new_off += 1;\n    proto_tree_add_checksum(dvb_s2_bb_tree, tvb, DVB_S2_BB_OFFS_CRC, hf_dvb_s2_bb_crc, hf_dvb_s2_bb_crc_status, &ei_dvb_s2_bb_crc, pinfo,\n        compute_crc8(tvb, DVB_S2_BB_HEADER_LEN - 1, 0), ENC_NA, PROTO_CHECKSUM_VERIFY);\n\n    switch (matype1 & DVB_S2_BB_TSGS_MASK) {\n    case DVB_S2_BB_TSGS_GENERIC_CONTINUOUS:\n        /* Check GSE constraints on the BB header per 9.2.1 of ETSI TS 102 771 */\n        if (BIT_IS_SET(matype1, DVB_S2_BB_ISSYI_POS)) {\n            expert_add_info(pinfo, ti, &ei_dvb_s2_bb_issy_invalid);\n        }\n        if (BIT_IS_SET(matype1, DVB_S2_BB_NPD_POS)) {\n            expert_add_info(pinfo, ti, &ei_dvb_s2_bb_npd_invalid);\n        }\n        if (user_packet_length != 0x0000) {\n            expert_add_info_format(pinfo, ti, &ei_dvb_s2_bb_upl_invalid,\n                \"UPL is 0x%04x. It must be 0x0000 for GSE packets.\", user_packet_length);\n        }\n\n\n        if (dvb_s2_df_dissection) {\n            while (bb_data_len) {\n                if (sync_flag == DVB_S2_BB_SYNC_EIP_CRC32 && bb_data_len == DVB_S2_BB_EIP_CRC32_LEN) {\n                    proto_tree_add_item(dvb_s2_bb_tree, hf_dvb_s2_bb_eip_crc32, tvb, new_off, bb_data_len, ENC_NA);\n                    bb_data_len = 0;\n                    new_off += DVB_S2_BB_EIP_CRC32_LEN;\n                } else {\n                    /* start DVB-GSE dissector */\n                    sub_dissected = dissect_dvb_s2_gse(tvb_new_subset_length(tvb, new_off, bb_data_len), pinfo, tree, NULL);\n                    new_off += sub_dissected;\n\n                    if ((sub_dissected <= bb_data_len) && (sub_dissected >= DVB_S2_GSE_MINSIZE)) {\n                        bb_data_len -= sub_dissected;\n                        if (bb_data_len < DVB_S2_GSE_MINSIZE)\n                            bb_data_len = 0;\n                    }\n                }\n            }\n        } else {\n            proto_tree_add_item(dvb_s2_bb_tree, hf_dvb_s2_bb_df, tvb, new_off, bb_data_len, ENC_NA);\n            new_off += bb_data_len;\n        }\n        break;\n\n    case DVB_S2_BB_TSGS_GENERIC_PACKETIZED:\n        proto_tree_add_item(tree, hf_dvb_s2_bb_packetized, tvb, new_off, bb_data_len, ENC_NA);\n        new_off += bb_data_len;\n        break;\n\n    case DVB_S2_BB_TSGS_TRANSPORT_STREAM:\n        proto_tree_add_item(tree, hf_dvb_s2_bb_transport, tvb, new_off, bb_data_len, ENC_NA);\n        new_off += bb_data_len;\n        break;\n\n    default:\n        proto_tree_add_item(tree, hf_dvb_s2_bb_reserved, tvb, new_off, bb_data_len, ENC_NA);\n        new_off += bb_data_len;\n        expert_add_info(pinfo, ti, &ei_dvb_s2_bb_reserved);\n        break;\n    }\n\n    return new_off;\n}",
        "func": "static int dissect_dvb_s2_bb(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\n{\n    proto_item *ti;\n    proto_tree *dvb_s2_bb_tree;\n\n    guint8      input8, matype1;\n    guint8      sync_flag = 0;\n    guint16     input16, bb_data_len = 0, user_packet_length;\n\n    int         sub_dissected        = 0, flag_is_ms = 0, new_off = 0;\n\n    static int * const bb_header_bitfields[] = {\n        &hf_dvb_s2_bb_matype1_gs,\n        &hf_dvb_s2_bb_matype1_mis,\n        &hf_dvb_s2_bb_matype1_acm,\n        &hf_dvb_s2_bb_matype1_issyi,\n        &hf_dvb_s2_bb_matype1_npd,\n        &hf_dvb_s2_bb_matype1_low_ro,\n        NULL\n    };\n\n    col_append_str(pinfo->cinfo, COL_PROTOCOL, \"BB \");\n    col_append_str(pinfo->cinfo, COL_INFO, \"Baseband \");\n\n    /* create display subtree for the protocol */\n    ti = proto_tree_add_item(tree, proto_dvb_s2_bb, tvb, 0, DVB_S2_BB_HEADER_LEN, ENC_NA);\n    dvb_s2_bb_tree = proto_item_add_subtree(ti, ett_dvb_s2_bb);\n\n    matype1 = tvb_get_guint8(tvb, DVB_S2_BB_OFFS_MATYPE1);\n    new_off += 1;\n\n    if (BIT_IS_CLEAR(matype1, DVB_S2_BB_MIS_POS))\n        flag_is_ms = 1;\n\n    proto_tree_add_bitmask_with_flags(dvb_s2_bb_tree, tvb, DVB_S2_BB_OFFS_MATYPE1, hf_dvb_s2_bb_matype1,\n        ett_dvb_s2_bb_matype1, bb_header_bitfields, ENC_BIG_ENDIAN, BMT_NO_FLAGS);\n\n    input8 = tvb_get_guint8(tvb, DVB_S2_BB_OFFS_MATYPE1);\n\n    if ((pinfo->fd->num == 1) && (_use_low_rolloff_value != 0)) {\n        _use_low_rolloff_value = 0;\n    }\n    if (((input8 & 0x03) == 3) && !_use_low_rolloff_value) {\n      _use_low_rolloff_value = 1;\n    }\n    if (_use_low_rolloff_value) {\n       proto_tree_add_item(dvb_s2_bb_tree, hf_dvb_s2_bb_matype1_low_ro, tvb,\n                           DVB_S2_BB_OFFS_MATYPE1, 1, ENC_BIG_ENDIAN);\n    } else {\n       proto_tree_add_item(dvb_s2_bb_tree, hf_dvb_s2_bb_matype1_high_ro, tvb,\n                           DVB_S2_BB_OFFS_MATYPE1, 1, ENC_BIG_ENDIAN);\n    }\n\n    input8 = tvb_get_guint8(tvb, DVB_S2_BB_OFFS_MATYPE2);\n    new_off += 1;\n    if (flag_is_ms) {\n        proto_tree_add_uint_format_value(dvb_s2_bb_tree, hf_dvb_s2_bb_matype2, tvb,\n                                   DVB_S2_BB_OFFS_MATYPE2, 1, input8, \"Input Stream Identifier (ISI): %d\",\n                                   input8);\n    } else {\n        proto_tree_add_uint_format_value(dvb_s2_bb_tree, hf_dvb_s2_bb_matype2, tvb,\n                                   DVB_S2_BB_OFFS_MATYPE2, 1, input8, \"reserved\");\n    }\n\n    user_packet_length = input16 = tvb_get_ntohs(tvb, DVB_S2_BB_OFFS_UPL);\n    new_off += 2;\n\n    proto_tree_add_uint_format(dvb_s2_bb_tree, hf_dvb_s2_bb_upl, tvb,\n                               DVB_S2_BB_OFFS_UPL, 2, input16, \"User Packet Length: %d bits (%d bytes)\",\n                               (guint16) input16, (guint16) input16 / 8);\n\n    bb_data_len = input16 = tvb_get_ntohs(tvb, DVB_S2_BB_OFFS_DFL);\n    bb_data_len /= 8;\n    new_off += 2;\n\n    proto_tree_add_uint_format_value(dvb_s2_bb_tree, hf_dvb_s2_bb_dfl, tvb,\n                               DVB_S2_BB_OFFS_DFL, 2, input16, \"%d bits (%d bytes)\", input16, input16 / 8);\n\n    new_off += 1;\n    sync_flag = tvb_get_guint8(tvb, DVB_S2_BB_OFFS_SYNC);\n    proto_tree_add_item(dvb_s2_bb_tree, hf_dvb_s2_bb_sync, tvb, DVB_S2_BB_OFFS_SYNC, 1, ENC_BIG_ENDIAN);\n\n    new_off += 2;\n    proto_tree_add_item(dvb_s2_bb_tree, hf_dvb_s2_bb_syncd, tvb, DVB_S2_BB_OFFS_SYNCD, 2, ENC_BIG_ENDIAN);\n\n    new_off += 1;\n    proto_tree_add_checksum(dvb_s2_bb_tree, tvb, DVB_S2_BB_OFFS_CRC, hf_dvb_s2_bb_crc, hf_dvb_s2_bb_crc_status, &ei_dvb_s2_bb_crc, pinfo,\n        compute_crc8(tvb, DVB_S2_BB_HEADER_LEN - 1, 0), ENC_NA, PROTO_CHECKSUM_VERIFY);\n\n    switch (matype1 & DVB_S2_BB_TSGS_MASK) {\n    case DVB_S2_BB_TSGS_GENERIC_CONTINUOUS:\n        /* Check GSE constraints on the BB header per 9.2.1 of ETSI TS 102 771 */\n        if (BIT_IS_SET(matype1, DVB_S2_BB_ISSYI_POS)) {\n            expert_add_info(pinfo, ti, &ei_dvb_s2_bb_issy_invalid);\n        }\n        if (BIT_IS_SET(matype1, DVB_S2_BB_NPD_POS)) {\n            expert_add_info(pinfo, ti, &ei_dvb_s2_bb_npd_invalid);\n        }\n        if (user_packet_length != 0x0000) {\n            expert_add_info_format(pinfo, ti, &ei_dvb_s2_bb_upl_invalid,\n                \"UPL is 0x%04x. It must be 0x0000 for GSE packets.\", user_packet_length);\n        }\n\n\n        if (dvb_s2_df_dissection) {\n            while (bb_data_len) {\n                if (sync_flag == DVB_S2_BB_SYNC_EIP_CRC32 && bb_data_len == DVB_S2_BB_EIP_CRC32_LEN) {\n                    proto_tree_add_item(dvb_s2_bb_tree, hf_dvb_s2_bb_eip_crc32, tvb, new_off, bb_data_len, ENC_NA);\n                    bb_data_len = 0;\n                    new_off += DVB_S2_BB_EIP_CRC32_LEN;\n                } else {\n                    /* start DVB-GSE dissector */\n                    sub_dissected = dissect_dvb_s2_gse(tvb_new_subset_length(tvb, new_off, bb_data_len), pinfo, tree, NULL);\n                    new_off += sub_dissected;\n\n                    if ((sub_dissected <= bb_data_len) && (sub_dissected >= DVB_S2_GSE_MINSIZE)) {\n                        bb_data_len -= sub_dissected;\n                        if (bb_data_len < DVB_S2_GSE_MINSIZE)\n                            bb_data_len = 0;\n                    } else {\n                        bb_data_len = 0;\n                    }\n                }\n            }\n        } else {\n            proto_tree_add_item(dvb_s2_bb_tree, hf_dvb_s2_bb_df, tvb, new_off, bb_data_len, ENC_NA);\n            new_off += bb_data_len;\n        }\n        break;\n\n    case DVB_S2_BB_TSGS_GENERIC_PACKETIZED:\n        proto_tree_add_item(tree, hf_dvb_s2_bb_packetized, tvb, new_off, bb_data_len, ENC_NA);\n        new_off += bb_data_len;\n        break;\n\n    case DVB_S2_BB_TSGS_TRANSPORT_STREAM:\n        proto_tree_add_item(tree, hf_dvb_s2_bb_transport, tvb, new_off, bb_data_len, ENC_NA);\n        new_off += bb_data_len;\n        break;\n\n    default:\n        proto_tree_add_item(tree, hf_dvb_s2_bb_reserved, tvb, new_off, bb_data_len, ENC_NA);\n        new_off += bb_data_len;\n        expert_add_info(pinfo, ti, &ei_dvb_s2_bb_reserved);\n        break;\n    }\n\n    return new_off;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -117,6 +117,8 @@\n                         bb_data_len -= sub_dissected;\n                         if (bb_data_len < DVB_S2_GSE_MINSIZE)\n                             bb_data_len = 0;\n+                    } else {\n+                        bb_data_len = 0;\n                     }\n                 }\n             }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "                    } else {",
                "                        bb_data_len = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-30300",
        "func_name": "WebAssembly/wabt/ProgramMain",
        "description": "An issue in the component hang.wasm of WebAssembly 1.0 causes an infinite loop.",
        "git_url": "https://github.com/WebAssembly/wabt/commit/d6dada6ee5071dd7ab3c66ca0bed8eaa9cbc1fe9",
        "commit_title": "wasm2c: use CHECK_RESULT throughout workhorse function",
        "commit_text": " Make sure to validate module before generating names.",
        "func_before": "int ProgramMain(int argc, char** argv) {\n  Result result;\n\n  InitStdio();\n  ParseOptions(argc, argv);\n\n  std::vector<uint8_t> file_data;\n  result = ReadFile(s_infile.c_str(), &file_data);\n  if (Succeeded(result)) {\n    Errors errors;\n    Module module;\n    const bool kStopOnFirstError = true;\n    const bool kFailOnCustomSectionError = true;\n    ReadBinaryOptions options(s_features, s_log_stream.get(),\n                              s_read_debug_names, kStopOnFirstError,\n                              kFailOnCustomSectionError);\n    result = ReadBinaryIr(s_infile.c_str(), file_data.data(), file_data.size(),\n                          options, &errors, &module);\n    if (Succeeded(result)) {\n      if (Succeeded(result)) {\n        ValidateOptions options(s_features);\n        result = ValidateModule(&module, &errors, options);\n        result |= GenerateNames(&module);\n      }\n\n      if (Succeeded(result)) {\n        /* TODO(binji): This shouldn't fail; if a name can't be applied\n         * (because the index is invalid, say) it should just be skipped. */\n        Result dummy_result = ApplyNames(&module);\n        WABT_USE(dummy_result);\n      }\n\n      if (Succeeded(result)) {\n        if (!s_outfile.empty()) {\n          std::string header_name_full =\n              std::string(strip_extension(s_outfile)) + \".h\";\n          FileStream c_stream(s_outfile.c_str());\n          FileStream h_stream(header_name_full);\n          std::string_view header_name = GetBasename(header_name_full);\n          if (s_write_c_options.module_name.empty()) {\n            s_write_c_options.module_name = module.name;\n            if (s_write_c_options.module_name.empty()) {\n              // In the absence of module name in the names section use the\n              // filename.\n              s_write_c_options.module_name =\n                  StripExtension(GetBasename(s_infile));\n            }\n          }\n          result =\n              WriteC(&c_stream, &h_stream, std::string(header_name).c_str(),\n                     &module, s_write_c_options);\n        } else {\n          FileStream stream(stdout);\n          result =\n              WriteC(&stream, &stream, \"wasm.h\", &module, s_write_c_options);\n        }\n      }\n    }\n    FormatErrorsToFile(errors, Location::Type::Binary);\n  }\n  return result != Result::Ok;\n}",
        "func": "int ProgramMain(int argc, char** argv) {\n  Result result;\n\n  InitStdio();\n  ParseOptions(argc, argv);\n\n  Errors errors;\n  result = wasm2c(errors);\n  FormatErrorsToFile(errors, Location::Type::Binary);\n\n  return result != Result::Ok;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,59 +4,9 @@\n   InitStdio();\n   ParseOptions(argc, argv);\n \n-  std::vector<uint8_t> file_data;\n-  result = ReadFile(s_infile.c_str(), &file_data);\n-  if (Succeeded(result)) {\n-    Errors errors;\n-    Module module;\n-    const bool kStopOnFirstError = true;\n-    const bool kFailOnCustomSectionError = true;\n-    ReadBinaryOptions options(s_features, s_log_stream.get(),\n-                              s_read_debug_names, kStopOnFirstError,\n-                              kFailOnCustomSectionError);\n-    result = ReadBinaryIr(s_infile.c_str(), file_data.data(), file_data.size(),\n-                          options, &errors, &module);\n-    if (Succeeded(result)) {\n-      if (Succeeded(result)) {\n-        ValidateOptions options(s_features);\n-        result = ValidateModule(&module, &errors, options);\n-        result |= GenerateNames(&module);\n-      }\n+  Errors errors;\n+  result = wasm2c(errors);\n+  FormatErrorsToFile(errors, Location::Type::Binary);\n \n-      if (Succeeded(result)) {\n-        /* TODO(binji): This shouldn't fail; if a name can't be applied\n-         * (because the index is invalid, say) it should just be skipped. */\n-        Result dummy_result = ApplyNames(&module);\n-        WABT_USE(dummy_result);\n-      }\n-\n-      if (Succeeded(result)) {\n-        if (!s_outfile.empty()) {\n-          std::string header_name_full =\n-              std::string(strip_extension(s_outfile)) + \".h\";\n-          FileStream c_stream(s_outfile.c_str());\n-          FileStream h_stream(header_name_full);\n-          std::string_view header_name = GetBasename(header_name_full);\n-          if (s_write_c_options.module_name.empty()) {\n-            s_write_c_options.module_name = module.name;\n-            if (s_write_c_options.module_name.empty()) {\n-              // In the absence of module name in the names section use the\n-              // filename.\n-              s_write_c_options.module_name =\n-                  StripExtension(GetBasename(s_infile));\n-            }\n-          }\n-          result =\n-              WriteC(&c_stream, &h_stream, std::string(header_name).c_str(),\n-                     &module, s_write_c_options);\n-        } else {\n-          FileStream stream(stdout);\n-          result =\n-              WriteC(&stream, &stream, \"wasm.h\", &module, s_write_c_options);\n-        }\n-      }\n-    }\n-    FormatErrorsToFile(errors, Location::Type::Binary);\n-  }\n   return result != Result::Ok;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  std::vector<uint8_t> file_data;",
                "  result = ReadFile(s_infile.c_str(), &file_data);",
                "  if (Succeeded(result)) {",
                "    Errors errors;",
                "    Module module;",
                "    const bool kStopOnFirstError = true;",
                "    const bool kFailOnCustomSectionError = true;",
                "    ReadBinaryOptions options(s_features, s_log_stream.get(),",
                "                              s_read_debug_names, kStopOnFirstError,",
                "                              kFailOnCustomSectionError);",
                "    result = ReadBinaryIr(s_infile.c_str(), file_data.data(), file_data.size(),",
                "                          options, &errors, &module);",
                "    if (Succeeded(result)) {",
                "      if (Succeeded(result)) {",
                "        ValidateOptions options(s_features);",
                "        result = ValidateModule(&module, &errors, options);",
                "        result |= GenerateNames(&module);",
                "      }",
                "      if (Succeeded(result)) {",
                "        /* TODO(binji): This shouldn't fail; if a name can't be applied",
                "         * (because the index is invalid, say) it should just be skipped. */",
                "        Result dummy_result = ApplyNames(&module);",
                "        WABT_USE(dummy_result);",
                "      }",
                "",
                "      if (Succeeded(result)) {",
                "        if (!s_outfile.empty()) {",
                "          std::string header_name_full =",
                "              std::string(strip_extension(s_outfile)) + \".h\";",
                "          FileStream c_stream(s_outfile.c_str());",
                "          FileStream h_stream(header_name_full);",
                "          std::string_view header_name = GetBasename(header_name_full);",
                "          if (s_write_c_options.module_name.empty()) {",
                "            s_write_c_options.module_name = module.name;",
                "            if (s_write_c_options.module_name.empty()) {",
                "              // In the absence of module name in the names section use the",
                "              // filename.",
                "              s_write_c_options.module_name =",
                "                  StripExtension(GetBasename(s_infile));",
                "            }",
                "          }",
                "          result =",
                "              WriteC(&c_stream, &h_stream, std::string(header_name).c_str(),",
                "                     &module, s_write_c_options);",
                "        } else {",
                "          FileStream stream(stdout);",
                "          result =",
                "              WriteC(&stream, &stream, \"wasm.h\", &module, s_write_c_options);",
                "        }",
                "      }",
                "    }",
                "    FormatErrorsToFile(errors, Location::Type::Binary);",
                "  }"
            ],
            "added_lines": [
                "  Errors errors;",
                "  result = wasm2c(errors);",
                "  FormatErrorsToFile(errors, Location::Type::Binary);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-30300",
        "func_name": "WebAssembly/wabt/ProgramMain",
        "description": "An issue in the component hang.wasm of WebAssembly 1.0 causes an infinite loop.",
        "git_url": "https://github.com/WebAssembly/wabt/commit/07a33969cbc4d3b346891d062b76b29be6705c01",
        "commit_title": "Respond to review",
        "commit_text": "",
        "func_before": "int ProgramMain(int argc, char** argv) {\n  Result result;\n\n  InitStdio();\n  ParseOptions(argc, argv);\n\n  Errors errors;\n  result = wasm2c(errors);\n  FormatErrorsToFile(errors, Location::Type::Binary);\n\n  return result != Result::Ok;\n}",
        "func": "int ProgramMain(int argc, char** argv) {\n  Result result;\n\n  InitStdio();\n  ParseOptions(argc, argv);\n\n  Errors errors;\n  result = Wasm2cMain(errors);\n  FormatErrorsToFile(errors, Location::Type::Binary);\n\n  return result != Result::Ok;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n   ParseOptions(argc, argv);\n \n   Errors errors;\n-  result = wasm2c(errors);\n+  result = Wasm2cMain(errors);\n   FormatErrorsToFile(errors, Location::Type::Binary);\n \n   return result != Result::Ok;",
        "diff_line_info": {
            "deleted_lines": [
                "  result = wasm2c(errors);"
            ],
            "added_lines": [
                "  result = Wasm2cMain(errors);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-2879",
        "func_name": "wireshark/add_uint_string",
        "description": "GDSDB infinite loop in Wireshark 4.0.0 to 4.0.5 and 3.6.0 to 3.6.13 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/118815ca7c9f82c1f83f8f64d9e0e54673f31677",
        "commit_title": "GDSDB: Make sure our offset advances.",
        "commit_text": " add_uint_string() returns the next offset to use, not the number of bytes consumed. So to consume all the bytes and make sure the offset advances, return the entire reported tvb length, not the number of bytes remaining.  Fixup 8d3c2177793e900cfc7cfaac776a2807e4ea289f  Fixes #19068 ",
        "func_before": "static int add_uint_string(proto_tree *tree, int hf_string, tvbuff_t *tvb, int offset)\n{\n\tproto_item* ti;\n\tint length;\n\n\tti = proto_tree_add_item(tree, hf_string, tvb,\n\t\t\t\t\t\toffset, 4, ENC_ASCII|ENC_BIG_ENDIAN);\n\tlength = dword_align(tvb_get_ntohl(tvb, offset))+4;\n\tproto_item_set_len(ti, length);\n\tint ret_offset = offset + length;\n\tif (length < 4 || ret_offset < offset) {\n\t\texpert_add_info_format(NULL, ti, &ei_gdsdb_invalid_length, \"Invalid length: %d\", length);\n\t\treturn tvb_reported_length_remaining(tvb, offset);\n\t}\n\treturn ret_offset;\n}",
        "func": "static int add_uint_string(proto_tree *tree, int hf_string, tvbuff_t *tvb, int offset)\n{\n\tproto_item* ti;\n\tint length;\n\n\tti = proto_tree_add_item(tree, hf_string, tvb,\n\t\t\t\t\t\toffset, 4, ENC_ASCII|ENC_BIG_ENDIAN);\n\tlength = dword_align(tvb_get_ntohl(tvb, offset))+4;\n\tproto_item_set_len(ti, length);\n\tint ret_offset = offset + length;\n\tif (length < 4 || ret_offset < offset) {\n\t\texpert_add_info_format(NULL, ti, &ei_gdsdb_invalid_length, \"Invalid length: %d\", length);\n\t\treturn tvb_reported_length(tvb);\n\t}\n\treturn ret_offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,7 @@\n \tint ret_offset = offset + length;\n \tif (length < 4 || ret_offset < offset) {\n \t\texpert_add_info_format(NULL, ti, &ei_gdsdb_invalid_length, \"Invalid length: %d\", length);\n-\t\treturn tvb_reported_length_remaining(tvb, offset);\n+\t\treturn tvb_reported_length(tvb);\n \t}\n \treturn ret_offset;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treturn tvb_reported_length_remaining(tvb, offset);"
            ],
            "added_lines": [
                "\t\treturn tvb_reported_length(tvb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-2952",
        "func_name": "wireshark/dissect_xra_tlv_burst_info",
        "description": "XRA dissector infinite loop in Wireshark 4.0.0 to 4.0.5 and 3.6.0 to 3.6.13 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/ce87eac0325581b600b3093fcd75080df14ccfda",
        "commit_title": "XRA: Fix an infinite loop",
        "commit_text": " C compilers don't care what size a value was on the wire. Use naturally-sized ints, including in dissect_message_channel_mb where we would otherwise overflow and loop infinitely.  Fixes #19100 ",
        "func_before": "static int\ndissect_xra_tlv_burst_info(tvbuff_t * tvb, proto_tree * tree, void* data _U_, guint16 tlv_length) {\n  proto_item *it;\n  proto_tree *xra_tlv_burst_info_tree;\n\n  it = proto_tree_add_item (tree, hf_xra_tlv_burst_info, tvb, 0, tlv_length, ENC_NA);\n  xra_tlv_burst_info_tree = proto_item_add_subtree (it, ett_xra_tlv_burst_info);\n\n  guint32 tlv_index =0;\n  while (tlv_index < tlv_length) {\n    guint8 type = tvb_get_guint8 (tvb, tlv_index);\n    ++tlv_index;\n    guint8 length = tvb_get_guint8 (tvb, tlv_index);\n    ++tlv_index;\n    switch (type) {\n      case XRA_BURST_INFO_BURST_ID_REFERENCE:\n        proto_tree_add_item (xra_tlv_burst_info_tree, hf_xra_tlv_burst_info_burst_id_reference, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_US_CHANNEL_ID:\n        proto_tree_add_item (xra_tlv_burst_info_tree, hf_xra_tlv_us_channel_id, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_SID:\n        proto_tree_add_item (xra_tlv_burst_info_tree, hf_xra_tlv_sid, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_IUC:\n        proto_tree_add_item (xra_tlv_burst_info_tree, hf_xra_tlv_iuc, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n\n      default:\n        proto_tree_add_item (xra_tlv_burst_info_tree, hf_xra_unknown, tvb, tlv_index, length, ENC_NA);\n        break;\n    }\n    tlv_index+=length;\n  }\n\n  return tvb_captured_length(tvb);\n}",
        "func": "static int\ndissect_xra_tlv_burst_info(tvbuff_t * tvb, proto_tree * tree, void* data _U_, guint16 tlv_length) {\n  proto_item *it;\n  proto_tree *xra_tlv_burst_info_tree;\n\n  it = proto_tree_add_item (tree, hf_xra_tlv_burst_info, tvb, 0, tlv_length, ENC_NA);\n  xra_tlv_burst_info_tree = proto_item_add_subtree (it, ett_xra_tlv_burst_info);\n\n  unsigned tlv_index = 0;\n  while (tlv_index < tlv_length) {\n    guint8 type = tvb_get_guint8 (tvb, tlv_index);\n    ++tlv_index;\n    guint8 length = tvb_get_guint8 (tvb, tlv_index);\n    ++tlv_index;\n    switch (type) {\n      case XRA_BURST_INFO_BURST_ID_REFERENCE:\n        proto_tree_add_item (xra_tlv_burst_info_tree, hf_xra_tlv_burst_info_burst_id_reference, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_US_CHANNEL_ID:\n        proto_tree_add_item (xra_tlv_burst_info_tree, hf_xra_tlv_us_channel_id, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_SID:\n        proto_tree_add_item (xra_tlv_burst_info_tree, hf_xra_tlv_sid, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_IUC:\n        proto_tree_add_item (xra_tlv_burst_info_tree, hf_xra_tlv_iuc, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n\n      default:\n        proto_tree_add_item (xra_tlv_burst_info_tree, hf_xra_unknown, tvb, tlv_index, length, ENC_NA);\n        break;\n    }\n    tlv_index+=length;\n  }\n\n  return tvb_captured_length(tvb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n   it = proto_tree_add_item (tree, hf_xra_tlv_burst_info, tvb, 0, tlv_length, ENC_NA);\n   xra_tlv_burst_info_tree = proto_item_add_subtree (it, ett_xra_tlv_burst_info);\n \n-  guint32 tlv_index =0;\n+  unsigned tlv_index = 0;\n   while (tlv_index < tlv_length) {\n     guint8 type = tvb_get_guint8 (tvb, tlv_index);\n     ++tlv_index;",
        "diff_line_info": {
            "deleted_lines": [
                "  guint32 tlv_index =0;"
            ],
            "added_lines": [
                "  unsigned tlv_index = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-2952",
        "func_name": "wireshark/dissect_ncp",
        "description": "XRA dissector infinite loop in Wireshark 4.0.0 to 4.0.5 and 3.6.0 to 3.6.13 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/ce87eac0325581b600b3093fcd75080df14ccfda",
        "commit_title": "XRA: Fix an infinite loop",
        "commit_text": " C compilers don't care what size a value was on the wire. Use naturally-sized ints, including in dissect_message_channel_mb where we would otherwise overflow and loop infinitely.  Fixes #19100 ",
        "func_before": "static int\ndissect_ncp(tvbuff_t * tvb, proto_tree * tree, void* data _U_) {\n  guint16 offset = 0;\n  proto_tree *ncp_tree;\n  proto_item *ncp_item;\n  tvbuff_t *ncp_mb_tvb;\n\n  ncp_item = proto_tree_add_protocol_format (tree, proto_ncp, tvb, 0, -1, \"DOCSIS NCP\");\n  ncp_tree = proto_item_add_subtree (ncp_item, ett_ncp);\n\n  while (tvb_captured_length_remaining(tvb, offset) > 3) {\n    ncp_mb_tvb = tvb_new_subset_length(tvb, offset, 3);\n    dissect_ncp_message_block(ncp_mb_tvb, ncp_tree);\n\n    offset+= 3;\n  }\n  proto_tree_add_item (ncp_tree, hf_ncp_crc, tvb, offset, 3, ENC_NA);\n\n  return tvb_captured_length(tvb);\n}",
        "func": "static int\ndissect_ncp(tvbuff_t * tvb, proto_tree * tree, void* data _U_) {\n  int offset = 0;\n  proto_tree *ncp_tree;\n  proto_item *ncp_item;\n  tvbuff_t *ncp_mb_tvb;\n\n  ncp_item = proto_tree_add_protocol_format (tree, proto_ncp, tvb, 0, -1, \"DOCSIS NCP\");\n  ncp_tree = proto_item_add_subtree (ncp_item, ett_ncp);\n\n  while (tvb_captured_length_remaining(tvb, offset) > 3) {\n    ncp_mb_tvb = tvb_new_subset_length(tvb, offset, 3);\n    dissect_ncp_message_block(ncp_mb_tvb, ncp_tree);\n\n    offset+= 3;\n  }\n  proto_tree_add_item (ncp_tree, hf_ncp_crc, tvb, offset, 3, ENC_NA);\n\n  return tvb_captured_length(tvb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n static int\n dissect_ncp(tvbuff_t * tvb, proto_tree * tree, void* data _U_) {\n-  guint16 offset = 0;\n+  int offset = 0;\n   proto_tree *ncp_tree;\n   proto_item *ncp_item;\n   tvbuff_t *ncp_mb_tvb;",
        "diff_line_info": {
            "deleted_lines": [
                "  guint16 offset = 0;"
            ],
            "added_lines": [
                "  int offset = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-2952",
        "func_name": "wireshark/dissect_xra_tlv_ms_info",
        "description": "XRA dissector infinite loop in Wireshark 4.0.0 to 4.0.5 and 3.6.0 to 3.6.13 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/ce87eac0325581b600b3093fcd75080df14ccfda",
        "commit_title": "XRA: Fix an infinite loop",
        "commit_text": " C compilers don't care what size a value was on the wire. Use naturally-sized ints, including in dissect_message_channel_mb where we would otherwise overflow and loop infinitely.  Fixes #19100 ",
        "func_before": "static int\ndissect_xra_tlv_ms_info(tvbuff_t * tvb, proto_tree * tree, void* data _U_, guint16 tlv_length) {\n  proto_item *it;\n  proto_tree *xra_tlv_ms_info_tree;\n\n  it = proto_tree_add_item (tree, hf_xra_tlv_ms_info, tvb, 0, tlv_length, ENC_NA);\n  xra_tlv_ms_info_tree = proto_item_add_subtree (it, ett_xra_tlv_ms_info);\n\n  guint32 tlv_index =0;\n  while (tlv_index < tlv_length) {\n    guint8 type = tvb_get_guint8 (tvb, tlv_index);\n    ++tlv_index;\n    guint8 length = tvb_get_guint8 (tvb, tlv_index);\n    ++tlv_index;\n    switch (type) {\n      case XRA_TLV_MINISLOT_INFO_START_MINISLOT_ID:\n        proto_tree_add_item (xra_tlv_ms_info_tree, hf_xra_tlv_start_minislot_id_abs, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_TLV_MINISLOT_INFO_REL_START_MINISLOT:\n        proto_tree_add_item (xra_tlv_ms_info_tree, hf_xra_tlv_start_minislot_id_rel, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_TLV_MINISLOT_INFO_REL_STOP_MINISLOT:\n        proto_tree_add_item (xra_tlv_ms_info_tree, hf_xra_tlv_stop_minislot_id_rel, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      default:\n        proto_tree_add_item (xra_tlv_ms_info_tree, hf_xra_unknown, tvb, tlv_index, length, ENC_NA);\n        break;\n    }\n    tlv_index+=length;\n  }\n\n  return tvb_captured_length(tvb);\n}",
        "func": "static int\ndissect_xra_tlv_ms_info(tvbuff_t * tvb, proto_tree * tree, void* data _U_, guint16 tlv_length) {\n  proto_item *it;\n  proto_tree *xra_tlv_ms_info_tree;\n\n  it = proto_tree_add_item (tree, hf_xra_tlv_ms_info, tvb, 0, tlv_length, ENC_NA);\n  xra_tlv_ms_info_tree = proto_item_add_subtree (it, ett_xra_tlv_ms_info);\n\n  unsigned tlv_index = 0;\n  while (tlv_index < tlv_length) {\n    guint8 type = tvb_get_guint8 (tvb, tlv_index);\n    ++tlv_index;\n    guint8 length = tvb_get_guint8 (tvb, tlv_index);\n    ++tlv_index;\n    switch (type) {\n      case XRA_TLV_MINISLOT_INFO_START_MINISLOT_ID:\n        proto_tree_add_item (xra_tlv_ms_info_tree, hf_xra_tlv_start_minislot_id_abs, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_TLV_MINISLOT_INFO_REL_START_MINISLOT:\n        proto_tree_add_item (xra_tlv_ms_info_tree, hf_xra_tlv_start_minislot_id_rel, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_TLV_MINISLOT_INFO_REL_STOP_MINISLOT:\n        proto_tree_add_item (xra_tlv_ms_info_tree, hf_xra_tlv_stop_minislot_id_rel, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      default:\n        proto_tree_add_item (xra_tlv_ms_info_tree, hf_xra_unknown, tvb, tlv_index, length, ENC_NA);\n        break;\n    }\n    tlv_index+=length;\n  }\n\n  return tvb_captured_length(tvb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n   it = proto_tree_add_item (tree, hf_xra_tlv_ms_info, tvb, 0, tlv_length, ENC_NA);\n   xra_tlv_ms_info_tree = proto_item_add_subtree (it, ett_xra_tlv_ms_info);\n \n-  guint32 tlv_index =0;\n+  unsigned tlv_index = 0;\n   while (tlv_index < tlv_length) {\n     guint8 type = tvb_get_guint8 (tvb, tlv_index);\n     ++tlv_index;",
        "diff_line_info": {
            "deleted_lines": [
                "  guint32 tlv_index =0;"
            ],
            "added_lines": [
                "  unsigned tlv_index = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-2952",
        "func_name": "wireshark/dissect_plc",
        "description": "XRA dissector infinite loop in Wireshark 4.0.0 to 4.0.5 and 3.6.0 to 3.6.13 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/ce87eac0325581b600b3093fcd75080df14ccfda",
        "commit_title": "XRA: Fix an infinite loop",
        "commit_text": " C compilers don't care what size a value was on the wire. Use naturally-sized ints, including in dissect_message_channel_mb where we would otherwise overflow and loop infinitely.  Fixes #19100 ",
        "func_before": "static int\ndissect_plc(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void* data _U_) {\n\n  guint16 offset = 0;\n  proto_tree *plc_tree;\n  proto_item *plc_item;\n  tvbuff_t *mb_tvb;\n\n  plc_item = proto_tree_add_protocol_format (tree, proto_plc, tvb, 0, -1, \"DOCSIS PLC\");\n  plc_tree = proto_item_add_subtree (plc_item, ett_plc);\n\n  while (tvb_reported_length_remaining(tvb, offset) > 0) {\n    guint8 mb_type = tvb_get_guint8 (tvb, offset) >>4;\n    guint8 mb_nibble2 = tvb_get_guint8 (tvb, offset) & 0x0F;\n    guint8 mb_byte2 = tvb_get_guint8 (tvb, offset+1);\n    guint8 last_mb = 0;\n\n    /* Do not initialize with 0, otherwise an infinite loop results in case mbLength is not initialized. */\n    guint16 mb_length = 1000;\n\n    if(mb_type == 0xFF) {\n      break;\n    }\n    switch (mb_type) {\n      case PLC_TIMESTAMP_MB:\n        mb_length =12;\n        /* Note that a Timestamp Message Block is mandatory and always comes first. */\n        col_append_str(pinfo->cinfo, COL_INFO, \": TS-MB\");\n        break;\n      case PLC_ENERGY_MANAGEMENT_MB:\n        mb_length = 4 + mb_nibble2*6;\n        col_append_str(pinfo->cinfo, COL_INFO, \", EM-MB\");\n        break;\n      case PLC_MESSAGE_CHANNEL_MB:\n        last_mb = 1;\n        mb_length = tvb_reported_length_remaining(tvb, offset);\n        col_append_str(pinfo->cinfo, COL_INFO, \", MC-MB\");\n        break;\n      case PLC_TRIGGER_MB:\n        mb_length = 9;\n        col_append_str(pinfo->cinfo, COL_INFO, \", TR-MB\");\n        break;\n      /* Future Use Message Block */\n      default:\n        mb_length = 5 + 256*(mb_nibble2 &0x01) + mb_byte2;\n        col_append_str(pinfo->cinfo, COL_INFO, \", FUT-MB\");\n        break;\n    }\n    mb_tvb = tvb_new_subset_remaining(tvb, offset);\n    dissect_message_block(mb_tvb,pinfo, plc_tree, mb_type, mb_length);\n\n    if (last_mb) {\n      break;\n    }\n\n    offset+= mb_length;\n  }\n\n  return tvb_captured_length(tvb);\n}",
        "func": "static int\ndissect_plc(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void* data _U_) {\n\n  int offset = 0;\n  proto_tree *plc_tree;\n  proto_item *plc_item;\n  tvbuff_t *mb_tvb;\n\n  plc_item = proto_tree_add_protocol_format (tree, proto_plc, tvb, 0, -1, \"DOCSIS PLC\");\n  plc_tree = proto_item_add_subtree (plc_item, ett_plc);\n\n  while (tvb_reported_length_remaining(tvb, offset) > 0) {\n    guint8 mb_type = tvb_get_guint8 (tvb, offset) >>4;\n    guint8 mb_nibble2 = tvb_get_guint8 (tvb, offset) & 0x0F;\n    guint8 mb_byte2 = tvb_get_guint8 (tvb, offset+1);\n    guint8 last_mb = 0;\n\n    /* Do not initialize with 0, otherwise an infinite loop results in case mbLength is not initialized. */\n    guint16 mb_length = 1000;\n\n    if(mb_type == 0xFF) {\n      break;\n    }\n    switch (mb_type) {\n      case PLC_TIMESTAMP_MB:\n        mb_length =12;\n        /* Note that a Timestamp Message Block is mandatory and always comes first. */\n        col_append_str(pinfo->cinfo, COL_INFO, \": TS-MB\");\n        break;\n      case PLC_ENERGY_MANAGEMENT_MB:\n        mb_length = 4 + mb_nibble2*6;\n        col_append_str(pinfo->cinfo, COL_INFO, \", EM-MB\");\n        break;\n      case PLC_MESSAGE_CHANNEL_MB:\n        last_mb = 1;\n        mb_length = tvb_reported_length_remaining(tvb, offset);\n        col_append_str(pinfo->cinfo, COL_INFO, \", MC-MB\");\n        break;\n      case PLC_TRIGGER_MB:\n        mb_length = 9;\n        col_append_str(pinfo->cinfo, COL_INFO, \", TR-MB\");\n        break;\n      /* Future Use Message Block */\n      default:\n        mb_length = 5 + 256*(mb_nibble2 &0x01) + mb_byte2;\n        col_append_str(pinfo->cinfo, COL_INFO, \", FUT-MB\");\n        break;\n    }\n    mb_tvb = tvb_new_subset_remaining(tvb, offset);\n    dissect_message_block(mb_tvb,pinfo, plc_tree, mb_type, mb_length);\n\n    if (last_mb) {\n      break;\n    }\n\n    offset+= mb_length;\n  }\n\n  return tvb_captured_length(tvb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n static int\n dissect_plc(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void* data _U_) {\n \n-  guint16 offset = 0;\n+  int offset = 0;\n   proto_tree *plc_tree;\n   proto_item *plc_item;\n   tvbuff_t *mb_tvb;",
        "diff_line_info": {
            "deleted_lines": [
                "  guint16 offset = 0;"
            ],
            "added_lines": [
                "  int offset = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-2952",
        "func_name": "wireshark/dissect_xra_tlv",
        "description": "XRA dissector infinite loop in Wireshark 4.0.0 to 4.0.5 and 3.6.0 to 3.6.13 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/ce87eac0325581b600b3093fcd75080df14ccfda",
        "commit_title": "XRA: Fix an infinite loop",
        "commit_text": " C compilers don't care what size a value was on the wire. Use naturally-sized ints, including in dissect_message_channel_mb where we would otherwise overflow and loop infinitely.  Fixes #19100 ",
        "func_before": "static int\ndissect_xra_tlv(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void* data _U_, guint16 tlv_length, guint* segment_header_present) {\n  proto_item *it;\n  proto_tree *xra_tlv_tree;\n  guint symbol_id;\n  double mer, power_level;\n\n  it = proto_tree_add_item (tree, hf_xra_tlv, tvb, 0, tlv_length, ENC_NA);\n  xra_tlv_tree = proto_item_add_subtree (it, ett_xra_tlv);\n\n  guint32 tlv_index =0;\n  tvbuff_t *xra_tlv_cw_info_tvb, *xra_tlv_ms_info_tvb, *xra_tlv_burst_info_tvb;\n\n  while (tlv_index < tlv_length) {\n    guint8 type = tvb_get_guint8 (tvb, tlv_index);\n    ++tlv_index;\n    guint8 length = tvb_get_guint8 (tvb, tlv_index);\n    ++tlv_index;\n    switch (type) {\n      case XRA_DS_CHANNEL_ID:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_ds_channel_id, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_DS_FREQUENCY:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_ds_channel_frequency, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_MODULATION:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_modulation, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_ANNEX:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_annex, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_PROFILE_ID:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_profile_id, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_CODEWORD_INFO:\n        xra_tlv_cw_info_tvb = tvb_new_subset_length(tvb, tlv_index, length);\n        dissect_xra_tlv_cw_info(xra_tlv_cw_info_tvb, xra_tlv_tree, data, length);\n        break;\n      case XRA_NCP_TRUNC:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_ncp_trunc, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_NCP_SYMBOLID:\n        proto_tree_add_item_ret_uint (xra_tlv_tree, hf_xra_tlv_ncp_symbolid, tvb, tlv_index, length, FALSE, &symbol_id);\n        col_append_fstr(pinfo->cinfo, COL_INFO, \": (Symbol ID: %u):\", symbol_id);\n        break;\n      case XRA_MER:\n        mer = tvb_get_guint8(tvb, tlv_index)/4.0;\n        proto_tree_add_double_format_value(xra_tlv_tree, hf_xra_tlv_mer, tvb, tlv_index, length, mer, \"%.2f dB\", mer);\n        break;\n      case XRA_US_CHANNEL_ID:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_us_channel_id, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_SID:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_sid, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_IUC:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_iuc, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_BURST_ID:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_burstid, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_BURST_INFO:\n        xra_tlv_burst_info_tvb = tvb_new_subset_length(tvb, tlv_index, length);\n        dissect_xra_tlv_burst_info(xra_tlv_burst_info_tvb, xra_tlv_tree, data, length);\n        break;\n      case XRA_MINISLOT_INFO:\n        xra_tlv_ms_info_tvb = tvb_new_subset_length(tvb, tlv_index, length);\n        dissect_xra_tlv_ms_info(xra_tlv_ms_info_tvb, xra_tlv_tree, data, length);\n        break;\n      case XRA_UCD_CCC_PARITY:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_ucd_ccc_parity, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_GRANT_SIZE:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_grant_size, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_SEGMENT_HEADER_PRESENT:\n        proto_tree_add_item_ret_uint (xra_tlv_tree, hf_xra_tlv_segment_header_present, tvb, tlv_index, length, FALSE, segment_header_present);\n        break;\n      case XRA_NUMBER_OFDMA_FRAMES:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_ranging_number_ofdma_frames, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_ESTIMATED_TIMING_ADJUST:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_ranging_timing_adjust, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_ESTIMATED_POWER_LEVEL:\n        power_level = ((gint16) (256*tvb_get_guint8(tvb, tlv_index) + tvb_get_guint8(tvb, tlv_index+1)) )/10.0;\n        proto_tree_add_double_format_value(xra_tlv_tree, hf_xra_tlv_power_level, tvb, tlv_index, length, power_level, \"%.1f dBmV\", power_level);\n        break;\n      case XRA_SUBSLOT_ID:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_subslot_id, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_CONTROL_WORD:\n         proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_control_word, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      default:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_unknown, tvb, tlv_index, length, ENC_NA);\n        break;\n    }\n    tlv_index+=length;\n  }\n\n  return tvb_captured_length(tvb);\n}",
        "func": "static int\ndissect_xra_tlv(tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void* data _U_, guint16 tlv_length, guint* segment_header_present) {\n  proto_item *it;\n  proto_tree *xra_tlv_tree;\n  guint symbol_id;\n  double mer, power_level;\n\n  it = proto_tree_add_item (tree, hf_xra_tlv, tvb, 0, tlv_length, ENC_NA);\n  xra_tlv_tree = proto_item_add_subtree (it, ett_xra_tlv);\n\n  unsigned tlv_index = 0;\n  tvbuff_t *xra_tlv_cw_info_tvb, *xra_tlv_ms_info_tvb, *xra_tlv_burst_info_tvb;\n\n  while (tlv_index < tlv_length) {\n    guint8 type = tvb_get_guint8 (tvb, tlv_index);\n    ++tlv_index;\n    guint8 length = tvb_get_guint8 (tvb, tlv_index);\n    ++tlv_index;\n    switch (type) {\n      case XRA_DS_CHANNEL_ID:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_ds_channel_id, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_DS_FREQUENCY:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_ds_channel_frequency, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_MODULATION:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_modulation, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_ANNEX:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_annex, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_PROFILE_ID:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_profile_id, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_CODEWORD_INFO:\n        xra_tlv_cw_info_tvb = tvb_new_subset_length(tvb, tlv_index, length);\n        dissect_xra_tlv_cw_info(xra_tlv_cw_info_tvb, xra_tlv_tree, data, length);\n        break;\n      case XRA_NCP_TRUNC:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_ncp_trunc, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_NCP_SYMBOLID:\n        proto_tree_add_item_ret_uint (xra_tlv_tree, hf_xra_tlv_ncp_symbolid, tvb, tlv_index, length, FALSE, &symbol_id);\n        col_append_fstr(pinfo->cinfo, COL_INFO, \": (Symbol ID: %u):\", symbol_id);\n        break;\n      case XRA_MER:\n        mer = tvb_get_guint8(tvb, tlv_index)/4.0;\n        proto_tree_add_double_format_value(xra_tlv_tree, hf_xra_tlv_mer, tvb, tlv_index, length, mer, \"%.2f dB\", mer);\n        break;\n      case XRA_US_CHANNEL_ID:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_us_channel_id, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_SID:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_sid, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_IUC:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_iuc, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_BURST_ID:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_burstid, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_BURST_INFO:\n        xra_tlv_burst_info_tvb = tvb_new_subset_length(tvb, tlv_index, length);\n        dissect_xra_tlv_burst_info(xra_tlv_burst_info_tvb, xra_tlv_tree, data, length);\n        break;\n      case XRA_MINISLOT_INFO:\n        xra_tlv_ms_info_tvb = tvb_new_subset_length(tvb, tlv_index, length);\n        dissect_xra_tlv_ms_info(xra_tlv_ms_info_tvb, xra_tlv_tree, data, length);\n        break;\n      case XRA_UCD_CCC_PARITY:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_ucd_ccc_parity, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_GRANT_SIZE:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_grant_size, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_SEGMENT_HEADER_PRESENT:\n        proto_tree_add_item_ret_uint (xra_tlv_tree, hf_xra_tlv_segment_header_present, tvb, tlv_index, length, FALSE, segment_header_present);\n        break;\n      case XRA_NUMBER_OFDMA_FRAMES:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_ranging_number_ofdma_frames, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_ESTIMATED_TIMING_ADJUST:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_ranging_timing_adjust, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_ESTIMATED_POWER_LEVEL:\n        power_level = ((gint16) (256*tvb_get_guint8(tvb, tlv_index) + tvb_get_guint8(tvb, tlv_index+1)) )/10.0;\n        proto_tree_add_double_format_value(xra_tlv_tree, hf_xra_tlv_power_level, tvb, tlv_index, length, power_level, \"%.1f dBmV\", power_level);\n        break;\n      case XRA_SUBSLOT_ID:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_subslot_id, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_CONTROL_WORD:\n         proto_tree_add_item (xra_tlv_tree, hf_xra_tlv_control_word, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      default:\n        proto_tree_add_item (xra_tlv_tree, hf_xra_unknown, tvb, tlv_index, length, ENC_NA);\n        break;\n    }\n    tlv_index+=length;\n  }\n\n  return tvb_captured_length(tvb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,7 @@\n   it = proto_tree_add_item (tree, hf_xra_tlv, tvb, 0, tlv_length, ENC_NA);\n   xra_tlv_tree = proto_item_add_subtree (it, ett_xra_tlv);\n \n-  guint32 tlv_index =0;\n+  unsigned tlv_index = 0;\n   tvbuff_t *xra_tlv_cw_info_tvb, *xra_tlv_ms_info_tvb, *xra_tlv_burst_info_tvb;\n \n   while (tlv_index < tlv_length) {",
        "diff_line_info": {
            "deleted_lines": [
                "  guint32 tlv_index =0;"
            ],
            "added_lines": [
                "  unsigned tlv_index = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-2952",
        "func_name": "wireshark/dissect_message_channel_mb",
        "description": "XRA dissector infinite loop in Wireshark 4.0.0 to 4.0.5 and 3.6.0 to 3.6.13 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/ce87eac0325581b600b3093fcd75080df14ccfda",
        "commit_title": "XRA: Fix an infinite loop",
        "commit_text": " C compilers don't care what size a value was on the wire. Use naturally-sized ints, including in dissect_message_channel_mb where we would otherwise overflow and loop infinitely.  Fixes #19100 ",
        "func_before": "static void\ndissect_message_channel_mb(tvbuff_t * tvb, packet_info * pinfo, proto_tree* tree, guint16 remaining_length) {\n  proto_tree_add_item (tree, hf_plc_mb_mc_reserved, tvb, 0, 1, ENC_BIG_ENDIAN);\n\n  gboolean packet_start_pointer_field_present;\n  guint packet_start_pointer;\n\n  proto_tree_add_item_ret_boolean(tree, hf_plc_mb_mc_pspf_present, tvb, 0, 1, FALSE, &packet_start_pointer_field_present);\n\n  /* If not present, this contains stuff from other packet. We can't do much in this case */\n  if(packet_start_pointer_field_present) {\n    proto_tree_add_item_ret_uint (tree, hf_plc_mb_mc_psp, tvb, 1, 2, FALSE, &packet_start_pointer);\n\n    guint16 docsis_start = 3 + packet_start_pointer;\n    while (docsis_start + 6 < remaining_length) {\n      /* DOCSIS header in packet */\n      guint8 fc = tvb_get_guint8(tvb,docsis_start + 0);\n      if (fc == 0xFF) {\n        /* Skip fill bytes */\n        docsis_start += 1;\n        continue;\n      }\n      guint16 docsis_length = 256*tvb_get_guint8(tvb,docsis_start + 2) + tvb_get_guint8(tvb,docsis_start + 3);\n      if (docsis_start + 6 + docsis_length <= remaining_length) {\n        /* DOCSIS packet included in packet */\n        tvbuff_t *docsis_tvb;\n\n        docsis_tvb = tvb_new_subset_length(tvb, docsis_start, docsis_length + 6);\n        if (docsis_handle) {\n          call_dissector (docsis_handle, docsis_tvb, pinfo, tree);\n          col_append_str(pinfo->cinfo, COL_INFO, \"; \");\n          col_set_fence(pinfo->cinfo,COL_INFO);\n        }\n      }\n      docsis_start += 6 + docsis_length;\n    }\n  }\n}",
        "func": "static void\ndissect_message_channel_mb(tvbuff_t * tvb, packet_info * pinfo, proto_tree* tree, guint16 remaining_length) {\n  proto_tree_add_item (tree, hf_plc_mb_mc_reserved, tvb, 0, 1, ENC_BIG_ENDIAN);\n\n  gboolean packet_start_pointer_field_present;\n  unsigned packet_start_pointer;\n\n  proto_tree_add_item_ret_boolean(tree, hf_plc_mb_mc_pspf_present, tvb, 0, 1, FALSE, &packet_start_pointer_field_present);\n\n  /* If not present, this contains stuff from other packet. We can't do much in this case */\n  if(packet_start_pointer_field_present) {\n    proto_tree_add_item_ret_uint (tree, hf_plc_mb_mc_psp, tvb, 1, 2, FALSE, &packet_start_pointer);\n\n    unsigned docsis_start = 3 + packet_start_pointer;\n    while (docsis_start + 6 < remaining_length) {\n      /* DOCSIS header in packet */\n      guint8 fc = tvb_get_guint8(tvb,docsis_start + 0);\n      if (fc == 0xFF) {\n        /* Skip fill bytes */\n        docsis_start += 1;\n        continue;\n      }\n      unsigned docsis_length = 256*tvb_get_guint8(tvb,docsis_start + 2) + tvb_get_guint8(tvb,docsis_start + 3);\n      if (docsis_start + 6 + docsis_length <= remaining_length) {\n        /* DOCSIS packet included in packet */\n        tvbuff_t *docsis_tvb;\n\n        docsis_tvb = tvb_new_subset_length(tvb, docsis_start, docsis_length + 6);\n        if (docsis_handle) {\n          call_dissector (docsis_handle, docsis_tvb, pinfo, tree);\n          col_append_str(pinfo->cinfo, COL_INFO, \"; \");\n          col_set_fence(pinfo->cinfo,COL_INFO);\n        }\n      }\n      docsis_start += 6 + docsis_length;\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n   proto_tree_add_item (tree, hf_plc_mb_mc_reserved, tvb, 0, 1, ENC_BIG_ENDIAN);\n \n   gboolean packet_start_pointer_field_present;\n-  guint packet_start_pointer;\n+  unsigned packet_start_pointer;\n \n   proto_tree_add_item_ret_boolean(tree, hf_plc_mb_mc_pspf_present, tvb, 0, 1, FALSE, &packet_start_pointer_field_present);\n \n@@ -11,7 +11,7 @@\n   if(packet_start_pointer_field_present) {\n     proto_tree_add_item_ret_uint (tree, hf_plc_mb_mc_psp, tvb, 1, 2, FALSE, &packet_start_pointer);\n \n-    guint16 docsis_start = 3 + packet_start_pointer;\n+    unsigned docsis_start = 3 + packet_start_pointer;\n     while (docsis_start + 6 < remaining_length) {\n       /* DOCSIS header in packet */\n       guint8 fc = tvb_get_guint8(tvb,docsis_start + 0);\n@@ -20,7 +20,7 @@\n         docsis_start += 1;\n         continue;\n       }\n-      guint16 docsis_length = 256*tvb_get_guint8(tvb,docsis_start + 2) + tvb_get_guint8(tvb,docsis_start + 3);\n+      unsigned docsis_length = 256*tvb_get_guint8(tvb,docsis_start + 2) + tvb_get_guint8(tvb,docsis_start + 3);\n       if (docsis_start + 6 + docsis_length <= remaining_length) {\n         /* DOCSIS packet included in packet */\n         tvbuff_t *docsis_tvb;",
        "diff_line_info": {
            "deleted_lines": [
                "  guint packet_start_pointer;",
                "    guint16 docsis_start = 3 + packet_start_pointer;",
                "      guint16 docsis_length = 256*tvb_get_guint8(tvb,docsis_start + 2) + tvb_get_guint8(tvb,docsis_start + 3);"
            ],
            "added_lines": [
                "  unsigned packet_start_pointer;",
                "    unsigned docsis_start = 3 + packet_start_pointer;",
                "      unsigned docsis_length = 256*tvb_get_guint8(tvb,docsis_start + 2) + tvb_get_guint8(tvb,docsis_start + 3);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-2952",
        "func_name": "wireshark/dissect_xra_tlv_cw_info",
        "description": "XRA dissector infinite loop in Wireshark 4.0.0 to 4.0.5 and 3.6.0 to 3.6.13 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/ce87eac0325581b600b3093fcd75080df14ccfda",
        "commit_title": "XRA: Fix an infinite loop",
        "commit_text": " C compilers don't care what size a value was on the wire. Use naturally-sized ints, including in dissect_message_channel_mb where we would otherwise overflow and loop infinitely.  Fixes #19100 ",
        "func_before": "static int\ndissect_xra_tlv_cw_info(tvbuff_t * tvb, proto_tree * tree, void* data _U_, guint16 tlv_length) {\n  proto_item *it;\n  proto_tree *xra_tlv_cw_info_tree;\n\n  it = proto_tree_add_item (tree, hf_xra_tlv_cw_info, tvb, 0, tlv_length, ENC_NA);\n  xra_tlv_cw_info_tree = proto_item_add_subtree (it, ett_xra_tlv_cw_info);\n\n  guint32 tlv_index =0;\n  while (tlv_index < tlv_length) {\n    guint8 type = tvb_get_guint8 (tvb, tlv_index);\n    ++tlv_index;\n    guint8 length = tvb_get_guint8 (tvb, tlv_index);\n    ++tlv_index;\n    switch (type) {\n      case XRA_TLV_CW_INFO_NR_OF_INFO_BYTES:\n        proto_tree_add_item (xra_tlv_cw_info_tree, hf_xra_tlv_cw_info_nr_of_info_bytes, tvb, tlv_index, length, ENC_NA);\n        break;\n      case XRA_TLV_CW_INFO_BCH_DECODING_SUCCESFUL:\n        proto_tree_add_item (xra_tlv_cw_info_tree, hf_xra_tlv_cw_info_bch_decoding_successful, tvb, tlv_index, length, ENC_NA);\n        break;\n      case XRA_TLV_CW_INFO_PROFILE_PARITY:\n        proto_tree_add_item (xra_tlv_cw_info_tree, hf_xra_tlv_cw_info_profile_parity, tvb, tlv_index, length, ENC_NA);\n        break;\n      case XRA_TLV_CW_INFO_BCH_NUMBER_OF_CORRECTED_BITS:\n        proto_tree_add_item (xra_tlv_cw_info_tree, hf_xra_tlv_cw_info_bch_number_of_corrected_bits, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_TLV_CW_INFO_LDPC_NUMBER_OF_CODE_BITS:\n        proto_tree_add_item (xra_tlv_cw_info_tree, hf_xra_tlv_cw_info_ldpc_nr_of_code_bits, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_TLV_CW_INFO_LDPC_DECODING_SUCCESSFUL:\n        proto_tree_add_item (xra_tlv_cw_info_tree, hf_xra_tlv_cw_info_ldpc_decoding_successful, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_TLV_CW_INFO_LDPC_NUMBER_OF_CORRECTED_BITS:\n        proto_tree_add_item (xra_tlv_cw_info_tree, hf_xra_tlv_cw_info_ldpc_number_of_corrected_bits, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_TLV_CW_INFO_LDPC_NUMBER_OF_ITERATIONS:\n        proto_tree_add_item (xra_tlv_cw_info_tree, hf_xra_tlv_cw_info_ldpc_number_of_iterations, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_TLV_CW_INFO_RS_DECODING_SUCCESFUL:\n        proto_tree_add_item(xra_tlv_cw_info_tree, hf_xra_tlv_cw_info_rs_decoding_successful, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_TLV_CW_INFO_RS_NUMBER_OF_CORRECTED_SYMBOLS:\n        proto_tree_add_item(xra_tlv_cw_info_tree, hf_xra_tlv_cw_info_rs_number_of_corrected_symbols, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      default:\n        proto_tree_add_item (xra_tlv_cw_info_tree, hf_xra_unknown, tvb, tlv_index, length, ENC_NA);\n        break;\n    }\n    tlv_index+=length;\n  }\n\n  return tvb_captured_length(tvb);\n}",
        "func": "static int\ndissect_xra_tlv_cw_info(tvbuff_t * tvb, proto_tree * tree, void* data _U_, guint16 tlv_length) {\n  proto_item *it;\n  proto_tree *xra_tlv_cw_info_tree;\n\n  it = proto_tree_add_item (tree, hf_xra_tlv_cw_info, tvb, 0, tlv_length, ENC_NA);\n  xra_tlv_cw_info_tree = proto_item_add_subtree (it, ett_xra_tlv_cw_info);\n\n  unsigned tlv_index = 0;\n  while (tlv_index < tlv_length) {\n    guint8 type = tvb_get_guint8 (tvb, tlv_index);\n    ++tlv_index;\n    guint8 length = tvb_get_guint8 (tvb, tlv_index);\n    ++tlv_index;\n    switch (type) {\n      case XRA_TLV_CW_INFO_NR_OF_INFO_BYTES:\n        proto_tree_add_item (xra_tlv_cw_info_tree, hf_xra_tlv_cw_info_nr_of_info_bytes, tvb, tlv_index, length, ENC_NA);\n        break;\n      case XRA_TLV_CW_INFO_BCH_DECODING_SUCCESFUL:\n        proto_tree_add_item (xra_tlv_cw_info_tree, hf_xra_tlv_cw_info_bch_decoding_successful, tvb, tlv_index, length, ENC_NA);\n        break;\n      case XRA_TLV_CW_INFO_PROFILE_PARITY:\n        proto_tree_add_item (xra_tlv_cw_info_tree, hf_xra_tlv_cw_info_profile_parity, tvb, tlv_index, length, ENC_NA);\n        break;\n      case XRA_TLV_CW_INFO_BCH_NUMBER_OF_CORRECTED_BITS:\n        proto_tree_add_item (xra_tlv_cw_info_tree, hf_xra_tlv_cw_info_bch_number_of_corrected_bits, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_TLV_CW_INFO_LDPC_NUMBER_OF_CODE_BITS:\n        proto_tree_add_item (xra_tlv_cw_info_tree, hf_xra_tlv_cw_info_ldpc_nr_of_code_bits, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_TLV_CW_INFO_LDPC_DECODING_SUCCESSFUL:\n        proto_tree_add_item (xra_tlv_cw_info_tree, hf_xra_tlv_cw_info_ldpc_decoding_successful, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_TLV_CW_INFO_LDPC_NUMBER_OF_CORRECTED_BITS:\n        proto_tree_add_item (xra_tlv_cw_info_tree, hf_xra_tlv_cw_info_ldpc_number_of_corrected_bits, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_TLV_CW_INFO_LDPC_NUMBER_OF_ITERATIONS:\n        proto_tree_add_item (xra_tlv_cw_info_tree, hf_xra_tlv_cw_info_ldpc_number_of_iterations, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_TLV_CW_INFO_RS_DECODING_SUCCESFUL:\n        proto_tree_add_item(xra_tlv_cw_info_tree, hf_xra_tlv_cw_info_rs_decoding_successful, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      case XRA_TLV_CW_INFO_RS_NUMBER_OF_CORRECTED_SYMBOLS:\n        proto_tree_add_item(xra_tlv_cw_info_tree, hf_xra_tlv_cw_info_rs_number_of_corrected_symbols, tvb, tlv_index, length, ENC_BIG_ENDIAN);\n        break;\n      default:\n        proto_tree_add_item (xra_tlv_cw_info_tree, hf_xra_unknown, tvb, tlv_index, length, ENC_NA);\n        break;\n    }\n    tlv_index+=length;\n  }\n\n  return tvb_captured_length(tvb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n   it = proto_tree_add_item (tree, hf_xra_tlv_cw_info, tvb, 0, tlv_length, ENC_NA);\n   xra_tlv_cw_info_tree = proto_item_add_subtree (it, ett_xra_tlv_cw_info);\n \n-  guint32 tlv_index =0;\n+  unsigned tlv_index = 0;\n   while (tlv_index < tlv_length) {\n     guint8 type = tvb_get_guint8 (tvb, tlv_index);\n     ++tlv_index;",
        "diff_line_info": {
            "deleted_lines": [
                "  guint32 tlv_index =0;"
            ],
            "added_lines": [
                "  unsigned tlv_index = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11410",
        "func_name": "wireshark/parse_wbxml_attribute_list_defined",
        "description": "In Wireshark through 2.0.13 and 2.2.x through 2.2.7, the WBXML dissector could go into an infinite loop, triggered by packet injection or a malformed capture file. This was addressed in epan/dissectors/packet-wbxml.c by adding validation of the relationships between indexes and lengths. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-7702.",
        "git_url": "https://github.com/wireshark/wireshark/commit/3c7168cc5f044b4da8747d35da0b2b204dabf398",
        "commit_title": "WBXML: Fix some more potential infinite loops.",
        "commit_text": " tvb_get_guintvar can generate some unrealistic values so do some sanity checking on them.  Bug: 13796 (cherry picked from commit 50fa2d95833ec2e2b0de3000eda7b290fc23eaeb)",
        "func_before": "static guint32\nparse_wbxml_attribute_list_defined (proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo,\n\t\t\t\t    guint32 offset, guint32 str_tbl, guint8 level, guint8 *codepage_attr,\n\t\t\t\t    const wbxml_decoding *map)\n{\n\tguint32     tvb_len = tvb_reported_length (tvb);\n\tguint32     off     = offset;\n\tguint32     len;\n\tguint       str_len;\n\tguint32     ent;\n\tguint32     idx;\n\tguint8      peek;\n\tguint8      attr_save_known   = 0; /* Will contain peek & 0x3F (attr identity) */\n\tconst char *attr_save_literal = NULL; /* Will contain the LITERAL attr identity */\n\tgchar      *str;\n\n\tDebugLog((\"parse_wbxml_attr_defined (level = %u, offset = %u)\\n\", level, offset));\n\t/* Parse attributes */\n\twhile (off < tvb_len) {\n\t\tpeek = tvb_get_guint8 (tvb, off);\n\t\tDebugLog((\"ATTR: (top of while) level = %3u, peek = 0x%02X, \"\n\t\t\t  \"off = %u, tvb_len = %u\\n\", level, peek, off, tvb_len));\n\t\tif ((peek & 0x3F) < 5) switch (peek) { /* Global tokens\n\t\t\t\t\t\t\t  in state = ATTR */\n\t\tcase 0x00: /* SWITCH_PAGE */\n\t\t\t*codepage_attr = tvb_get_guint8 (tvb, off+1);\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_switch_page, tvb, off, 2, *codepage_attr,\n                         \"      |  Attr | A -->%3d | SWITCH_PAGE (Attr code page)    |\",\n\t\t\t\t\t     *codepage_attr);\n\t\t\toff += 2;\n\t\t\tbreak;\n\t\tcase 0x01: /* END */\n\t\t\t/* BEWARE\n\t\t\t *   The Attribute END token means either \">\" or \"/>\"\n\t\t\t *   and as a consequence both must be treated separately.\n\t\t\t *   This is done in the TAG state parser.\n\t\t\t */\n\t\t\toff++;\n\t\t\tDebugLog((\"ATTR: level = %u, Return: len = %u\\n\",\n\t\t\t\t  level, off - offset));\n\t\t\treturn (off - offset);\n\t\tcase 0x02: /* ENTITY */\n\t\t\tent = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tif (len <= tvb_len) {\n\t\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_entity, tvb, off, 1+len, ent,\n\t\t\t\t\t         \"  %3d |  Attr | A %3d    | ENTITY                          |     %s'&#%u;'\",\n\t\t\t\t\t         level, *codepage_attr, Indent (level), ent);\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x03: /* STR_I */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | STR_I (Inline string)           |     %s\\'%s\\'\",\n\t\t\t\t\t     level, *codepage_attr, Indent (level), str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x04: /* LITERAL */\n\t\t\t/* ALWAYS means the start of a new attribute,\n\t\t\t * and may only contain the NAME of the attribute.\n\t\t\t */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tif (len <= tvb_len) {\n\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\t\tattr_save_known = 0;\n\t\t\t\tattr_save_literal = tvb_format_text (tvb, str_tbl+idx, str_len-1);\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal, tvb, off, 1+len, attr_save_literal,\n\t\t\t\t\t         \"  %3d |  Attr | A %3d    | LITERAL (Literal Attribute)     |   %s<%s />\",\n\t\t\t\t\t         level, *codepage_attr, Indent (level), attr_save_literal);\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x40: /* EXT_I_0 */\n\t\tcase 0x41: /* EXT_I_1 */\n\t\tcase 0x42: /* EXT_I_2 */\n\t\t\t/* Extension tokens */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | EXT_I_%1x    (Extension Token)    |     %s(%s: \\'%s\\')\",\n\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level),\n\t\t\t\t\t     ((map != NULL) ? map_token (map->global, 0, peek) : \"Inline string extension\"), str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\t\t/* 0x43 impossible in ATTR state */\n\t\t\t/* 0x44 impossible in ATTR state */\n\t\tcase 0x80: /* EXT_T_0 */\n\t\tcase 0x81: /* EXT_T_1 */\n\t\tcase 0x82: /* EXT_T_2 */\n\t\t\t/* Extension tokens */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tif (map != NULL) {\n\n\t\t\t\t\tif (map->ext_t[peek & 0x03])\n\t\t\t\t\t\ts = (map->ext_t[peek & 0x03])(tvb, idx, str_tbl);\n\t\t\t\t\telse\n\t\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \"EXT_T_%1x (%s)\", peek & 0x03,\n\t\t\t\t\t\t\t\t    map_token (map->global, 0, peek));\n\t\t\t\t} else {\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \"Extension Token, integer value: (%u\", idx);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_t, tvb, off, 1+len, s,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_T_%1x    (Extension Token)    | %s%s)\",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level),\n\t\t\t\t\t\t     s);\n\t\t\t}\n\t\t\tif (len <= tvb_len) {\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83: /* STR_T */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tif (len <= tvb_len) {\n\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\t\tstr = tvb_format_text (tvb, str_tbl+idx, str_len-1);\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_t, tvb, off, 1+len, str,\n\t\t\t\t\t         \"  %3d |  Attr | A %3d    | STR_T (Tableref string)         |     %s\\'%s\\'\",\n\t\t\t\t\t         level, *codepage_attr, Indent (level), str);\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t/* 0x84 impossible in ATTR state */\n\t\tcase 0xC0: /* EXT_0 */\n\t\tcase 0xC1: /* EXT_1 */\n\t\tcase 0xC2: /* EXT_2 */\n\t\t\t/* Extension tokens */\n\t\t\tstr = (char*)((map != NULL) ? map_token (map->global, 0, peek) : \"Single-byte extension\");\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_extension_token, tvb, off, 1, str,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | EXT_%1x      (Extension Token)    |     %s(%s)\",\n\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level), str);\n\t\t\toff++;\n\t\t\tbreak;\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\n\t\t\tif (tvb_get_guint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\tchar *tmp_str;\n\t\t\t\t\tif (attr_save_known) { /* Knwon attribute */\n\t\t\t\t\t\tif (map->opaque_binary_attr) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_binary_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t      attr_save_known, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_binary_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t attr_save_known, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { /* lITERAL attribute */\n\t\t\t\t\t\tif (map->opaque_literal_tag) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_literal_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t       attr_save_literal, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_literal_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t  attr_save_literal, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (len <= tvb_len) {\n\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len, NULL,\n\t\t\t\t\t\t\t         \"  %3d |  Attr | A %3d    | OPAQUE (Opaque data)            |       %s%s\",\n\t\t\t\t\t\t\t         level, *codepage_attr, Indent (level), tmp_str);\n\t\t\t\t\t\toff += 1 + len;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\t\t\toff = tvb_len;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t\t\tif (len <= tvb_len) {\n\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,\n\t\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    | OPAQUE (Opaque data)            |       %s(%u bytes of opaque data)\",\n\t\t\t\t\t\t\t     level, *codepage_attr, Indent (level), idx);\n\t\t\t\t\t\toff += 1+len+idx;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\t\t\toff = tvb_len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\n\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_reserved_2, tvb, off, 1,\n\t\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    | RESERVED_2     (Invalid Token!) | WBXML 1.0 parsing stops here.\",\n\t\t\t\t\t\t\t     level, *codepage_attr);\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t\tDebugLog((\"ATTR: level = %u, Return: len = %u\\n\",\n\t\t\t\t\t  level, off - offset));\n\t\t\t\treturn (off - offset);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t/* 0xC4 impossible in ATTR state */\n\t\tdefault:\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_invalid_token, tvb, off, 1,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | %-10s     (Invalid Token!) | WBXML parsing stops here.\",\n\t\t\t\t\t     level, *codepage_attr, val_to_str_ext (peek, &vals_wbxml1x_global_tokens_ext, \"(unknown 0x%x)\"));\n\t\t\t/* Move to end of buffer */\n\t\t\toff = tvb_len;\n\t\t\tbreak;\n\t\t} else { /* Known atribute token */\n\t\t\tchar* s;\n\t\t\tif (peek & 0x80) { /* attrValue */\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\ts = (char*)map_token (map->attrValue, *codepage_attr, peek);\n\t\t\t\t} else {\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \"attrValue_0x%02X\", peek);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_attrvalue, tvb, off, 1, s,\n\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    |   Known attrValue 0x%02X          |       %s%s\",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x7f, Indent (level),\n\t\t\t\t\t\t     s);\n\t\t\t\toff++;\n\t\t\t} else { /* attrStart */\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\ts = (char*)map_token (map->attrStart, *codepage_attr, peek);\n\t\t\t\t} else {\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \"attrStart_0x%02X\", peek);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_attrstart, tvb, off, 1, s,\n\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    |   Known attrStart 0x%02X          |   %s%s\",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x7f, Indent (level),\n\t\t\t\t\t\t     s);\n\t\t\t\toff++;\n\t\t\t}\n\t\t}\n\t} /* End WHILE */\n\tDebugLog((\"ATTR: level = %u, Return: len = %u (end of function body)\\n\",\n\t\t  level, off - offset));\n\treturn (off - offset);\n}",
        "func": "static guint32\nparse_wbxml_attribute_list_defined (proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo,\n\t\t\t\t    guint32 offset, guint32 str_tbl, guint8 level, guint8 *codepage_attr,\n\t\t\t\t    const wbxml_decoding *map)\n{\n\tguint32     tvb_len = tvb_reported_length (tvb);\n\tguint32     off     = offset;\n\tguint32     len;\n\tguint       str_len;\n\tguint32     ent;\n\tguint32     idx;\n\tguint8      peek;\n\tguint8      attr_save_known   = 0; /* Will contain peek & 0x3F (attr identity) */\n\tconst char *attr_save_literal = NULL; /* Will contain the LITERAL attr identity */\n\tgchar      *str;\n\n\tDebugLog((\"parse_wbxml_attr_defined (level = %u, offset = %u)\\n\", level, offset));\n\t/* Parse attributes */\n\twhile (off < tvb_len) {\n\t\tpeek = tvb_get_guint8 (tvb, off);\n\t\tDebugLog((\"ATTR: (top of while) level = %3u, peek = 0x%02X, \"\n\t\t\t  \"off = %u, tvb_len = %u\\n\", level, peek, off, tvb_len));\n\t\tif ((peek & 0x3F) < 5) switch (peek) { /* Global tokens\n\t\t\t\t\t\t\t  in state = ATTR */\n\t\tcase 0x00: /* SWITCH_PAGE */\n\t\t\t*codepage_attr = tvb_get_guint8 (tvb, off+1);\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_switch_page, tvb, off, 2, *codepage_attr,\n                         \"      |  Attr | A -->%3d | SWITCH_PAGE (Attr code page)    |\",\n\t\t\t\t\t     *codepage_attr);\n\t\t\toff += 2;\n\t\t\tbreak;\n\t\tcase 0x01: /* END */\n\t\t\t/* BEWARE\n\t\t\t *   The Attribute END token means either \">\" or \"/>\"\n\t\t\t *   and as a consequence both must be treated separately.\n\t\t\t *   This is done in the TAG state parser.\n\t\t\t */\n\t\t\toff++;\n\t\t\tDebugLog((\"ATTR: level = %u, Return: len = %u\\n\",\n\t\t\t\t  level, off - offset));\n\t\t\treturn (off - offset);\n\t\tcase 0x02: /* ENTITY */\n\t\t\tent = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tif (len <= tvb_len) {\n\t\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_entity, tvb, off, 1+len, ent,\n\t\t\t\t\t         \"  %3d |  Attr | A %3d    | ENTITY                          |     %s'&#%u;'\",\n\t\t\t\t\t         level, *codepage_attr, Indent (level), ent);\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x03: /* STR_I */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | STR_I (Inline string)           |     %s\\'%s\\'\",\n\t\t\t\t\t     level, *codepage_attr, Indent (level), str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x04: /* LITERAL */\n\t\t\t/* ALWAYS means the start of a new attribute,\n\t\t\t * and may only contain the NAME of the attribute.\n\t\t\t */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tif (len <= tvb_len) {\n\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\t\tattr_save_known = 0;\n\t\t\t\tattr_save_literal = tvb_format_text (tvb, str_tbl+idx, str_len-1);\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal, tvb, off, 1+len, attr_save_literal,\n\t\t\t\t\t         \"  %3d |  Attr | A %3d    | LITERAL (Literal Attribute)     |   %s<%s />\",\n\t\t\t\t\t         level, *codepage_attr, Indent (level), attr_save_literal);\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x40: /* EXT_I_0 */\n\t\tcase 0x41: /* EXT_I_1 */\n\t\tcase 0x42: /* EXT_I_2 */\n\t\t\t/* Extension tokens */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | EXT_I_%1x    (Extension Token)    |     %s(%s: \\'%s\\')\",\n\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level),\n\t\t\t\t\t     ((map != NULL) ? map_token (map->global, 0, peek) : \"Inline string extension\"), str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\t\t/* 0x43 impossible in ATTR state */\n\t\t\t/* 0x44 impossible in ATTR state */\n\t\tcase 0x80: /* EXT_T_0 */\n\t\tcase 0x81: /* EXT_T_1 */\n\t\tcase 0x82: /* EXT_T_2 */\n\t\t\t/* Extension tokens */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tif (map != NULL) {\n\n\t\t\t\t\tif (map->ext_t[peek & 0x03])\n\t\t\t\t\t\ts = (map->ext_t[peek & 0x03])(tvb, idx, str_tbl);\n\t\t\t\t\telse\n\t\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \"EXT_T_%1x (%s)\", peek & 0x03,\n\t\t\t\t\t\t\t\t    map_token (map->global, 0, peek));\n\t\t\t\t} else {\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \"Extension Token, integer value: (%u\", idx);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_t, tvb, off, 1+len, s,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_T_%1x    (Extension Token)    | %s%s)\",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level),\n\t\t\t\t\t\t     s);\n\t\t\t}\n\t\t\tif (len <= tvb_len) {\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83: /* STR_T */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tif (len <= tvb_len) {\n\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\t\tstr = tvb_format_text (tvb, str_tbl+idx, str_len-1);\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_t, tvb, off, 1+len, str,\n\t\t\t\t\t         \"  %3d |  Attr | A %3d    | STR_T (Tableref string)         |     %s\\'%s\\'\",\n\t\t\t\t\t         level, *codepage_attr, Indent (level), str);\n\t\t\t\toff += 1+len;\n\t\t\t} else {\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t/* 0x84 impossible in ATTR state */\n\t\tcase 0xC0: /* EXT_0 */\n\t\tcase 0xC1: /* EXT_1 */\n\t\tcase 0xC2: /* EXT_2 */\n\t\t\t/* Extension tokens */\n\t\t\tstr = (char*)((map != NULL) ? map_token (map->global, 0, peek) : \"Single-byte extension\");\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_extension_token, tvb, off, 1, str,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | EXT_%1x      (Extension Token)    |     %s(%s)\",\n\t\t\t\t\t     level, *codepage_attr, peek & 0x0f, Indent (level), str);\n\t\t\toff++;\n\t\t\tbreak;\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\n\t\t\tif (tvb_get_guint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\tchar *tmp_str;\n\t\t\t\t\tif (attr_save_known) { /* Knwon attribute */\n\t\t\t\t\t\tif (map->opaque_binary_attr) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_binary_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t      attr_save_known, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_binary_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t attr_save_known, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { /* lITERAL attribute */\n\t\t\t\t\t\tif (map->opaque_literal_tag) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_literal_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t       attr_save_literal, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_literal_attr(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t  attr_save_literal, *codepage_attr, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (len <= tvb_len) {\n\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len, NULL,\n\t\t\t\t\t\t\t         \"  %3d |  Attr | A %3d    | OPAQUE (Opaque data)            |       %s%s\",\n\t\t\t\t\t\t\t         level, *codepage_attr, Indent (level), tmp_str);\n\t\t\t\t\t\toff += 1 + len;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\t\t\toff = tvb_len;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t\t\tif ((len <= tvb_len) && (idx < tvb_len)) {\n\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,\n\t\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    | OPAQUE (Opaque data)            |       %s(%u bytes of opaque data)\",\n\t\t\t\t\t\t\t     level, *codepage_attr, Indent (level), idx);\n\t\t\t\t\t\toff += 1+len+idx;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\t\t\toff = tvb_len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\n\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_reserved_2, tvb, off, 1,\n\t\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    | RESERVED_2     (Invalid Token!) | WBXML 1.0 parsing stops here.\",\n\t\t\t\t\t\t\t     level, *codepage_attr);\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t\tDebugLog((\"ATTR: level = %u, Return: len = %u\\n\",\n\t\t\t\t\t  level, off - offset));\n\t\t\t\treturn (off - offset);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t/* 0xC4 impossible in ATTR state */\n\t\tdefault:\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_invalid_token, tvb, off, 1,\n\t\t\t\t\t     \"  %3d |  Attr | A %3d    | %-10s     (Invalid Token!) | WBXML parsing stops here.\",\n\t\t\t\t\t     level, *codepage_attr, val_to_str_ext (peek, &vals_wbxml1x_global_tokens_ext, \"(unknown 0x%x)\"));\n\t\t\t/* Move to end of buffer */\n\t\t\toff = tvb_len;\n\t\t\tbreak;\n\t\t} else { /* Known atribute token */\n\t\t\tchar* s;\n\t\t\tif (peek & 0x80) { /* attrValue */\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\ts = (char*)map_token (map->attrValue, *codepage_attr, peek);\n\t\t\t\t} else {\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \"attrValue_0x%02X\", peek);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_attrvalue, tvb, off, 1, s,\n\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    |   Known attrValue 0x%02X          |       %s%s\",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x7f, Indent (level),\n\t\t\t\t\t\t     s);\n\t\t\t\toff++;\n\t\t\t} else { /* attrStart */\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\ts = (char*)map_token (map->attrStart, *codepage_attr, peek);\n\t\t\t\t} else {\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \"attrStart_0x%02X\", peek);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_attrstart, tvb, off, 1, s,\n\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    |   Known attrStart 0x%02X          |   %s%s\",\n\t\t\t\t\t\t     level, *codepage_attr, peek & 0x7f, Indent (level),\n\t\t\t\t\t\t     s);\n\t\t\t\toff++;\n\t\t\t}\n\t\t}\n\t} /* End WHILE */\n\tDebugLog((\"ATTR: level = %u, Return: len = %u (end of function body)\\n\",\n\t\t  level, off - offset));\n\treturn (off - offset);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -178,7 +178,7 @@\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n-\t\t\t\t\tif (len <= tvb_len) {\n+\t\t\t\t\tif ((len <= tvb_len) && (idx < tvb_len)) {\n \t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,\n \t\t\t\t\t\t\t     \"  %3d |  Attr | A %3d    | OPAQUE (Opaque data)            |       %s(%u bytes of opaque data)\",\n \t\t\t\t\t\t\t     level, *codepage_attr, Indent (level), idx);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t\tif (len <= tvb_len) {"
            ],
            "added_lines": [
                "\t\t\t\t\tif ((len <= tvb_len) && (idx < tvb_len)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11410",
        "func_name": "wireshark/parse_wbxml_tag_defined",
        "description": "In Wireshark through 2.0.13 and 2.2.x through 2.2.7, the WBXML dissector could go into an infinite loop, triggered by packet injection or a malformed capture file. This was addressed in epan/dissectors/packet-wbxml.c by adding validation of the relationships between indexes and lengths. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-7702.",
        "git_url": "https://github.com/wireshark/wireshark/commit/3c7168cc5f044b4da8747d35da0b2b204dabf398",
        "commit_title": "WBXML: Fix some more potential infinite loops.",
        "commit_text": " tvb_get_guintvar can generate some unrealistic values so do some sanity checking on them.  Bug: 13796 (cherry picked from commit 50fa2d95833ec2e2b0de3000eda7b290fc23eaeb)",
        "func_before": "static guint32\nparse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, guint32 offset,\n\t\t\t guint32 str_tbl, guint8 *level, guint8 *codepage_stag, guint8 *codepage_attr,\n\t\t\t const wbxml_decoding *map)\n{\n\tguint32     tvb_len  = tvb_reported_length (tvb);\n\tguint32     off      = offset;\n\tguint32     len;\n\tguint       str_len;\n\tguint32     ent;\n\tguint32     idx;\n\tguint8      peek;\n\tguint32     tag_len;                     /* Length of the index (uintvar) from a LITERAL tag */\n\tguint8      tag_save_known      = 0;     /* Will contain peek & 0x3F (tag identity) */\n\tguint8      tag_new_known       = 0;     /* Will contain peek & 0x3F (tag identity) */\n\tconst char *tag_save_literal    = NULL;  /* Will contain the LITERAL tag identity */\n\tconst char *tag_new_literal;             /* Will contain the LITERAL tag identity */\n\tgchar      *str;\n\tguint8      parsing_tag_content = FALSE; /* Are we parsing content from a\n\t\t\t\t\t            tag with content: <x>Content</x>\n\n\t\t\t\t\t            The initial state is FALSE.\n\t\t\t\t\t            This state will trigger recursion. */\n\n\tif (*level == 255) {\n\t\tproto_tree_add_expert(tree, pinfo, &ei_wbxml_too_much_recursion, tvb, offset, tvb_captured_length_remaining(tvb, offset));\n\t\treturn tvb_len;\n\t}\n\tDebugLog((\"parse_wbxml_tag_defined (level = %u, offset = %u)\\n\", *level, offset));\n\twhile (off < tvb_len) {\n\t\tpeek = tvb_get_guint8 (tvb, off);\n\t\tDebugLog((\"STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\\n\", *level, peek, off, tvb_len));\n\t\tif ((peek & 0x3F) < 4) switch (peek) { /* Global tokens in state = STAG\n\t\t\t\t\t\t\t  but not the LITERAL tokens */\n\t\tcase 0x00: /* SWITCH_PAGE */\n\t\t\t*codepage_stag = tvb_get_guint8 (tvb, off+1);\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_switch_page, tvb, off, 2, *codepage_stag,\n\t\t\t\t\t     \"      | Tag   | T -->%3d | SWITCH_PAGE (Tag code page)     |\",\n\t\t\t\t\t     *codepage_stag);\n\t\t\toff += 2;\n\t\t\tbreak;\n\t\tcase 0x01: /* END: only possible for Tag with Content */\n\t\t\tif (tag_save_known) { /* Known TAG */\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_known_tag, tvb, off, 1, tag_save_literal,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Known Tag 0x%02X)            | %s</%s>\",\n\t\t\t\t\t\t     *level, *codepage_stag,\n\t\t\t\t\t\t     tag_save_known, Indent (*level),\n\t\t\t\t\t\t     tag_save_literal); /* We already looked it up! */\n\t\t\t} else { /* Literal TAG */\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_literal_tag, tvb, off, 1, tag_save_literal ? tag_save_literal : \"\",\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Literal Tag)               | %s</%s>\",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_save_literal ? tag_save_literal : \"\");\n\t\t\t}\n\t\t\t(*level)--;\n\t\t\toff++;\n\t\t\t/* Reset code page: not needed as return from recursion */\n\t\t\tDebugLog((\"STAG: level = %u, Return: len = %u\\n\", *level, off - offset));\n\t\t\treturn (off - offset);\n\t\tcase 0x02: /* ENTITY */\n\t\t\tent = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_entity, tvb, off, 1+len, ent,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | ENTITY                          | %s'&#%u;'\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level), ent);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x03: /* STR_I */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | STR_I (Inline string)           | %s\\'%s\\'\",\n\t\t\t\t\t     *level, *codepage_stag, Indent(*level),\n\t\t\t\t\t     str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x40: /* EXT_I_0 */\n\t\tcase 0x41: /* EXT_I_1 */\n\t\tcase 0x42: /* EXT_I_2 */\n\t\t\t/* Extension tokens */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_I_%1x    (Extension Token)    | %s(%s: \\'%s\\')\",\n\t\t\t\t\t     *level, *codepage_stag,\n\t\t\t\t\t     peek & 0x0f, Indent (*level),\n\t\t\t\t\t     ((map != NULL) ? map_token (map->global, 0, peek) : \"Inline string extension\"),\n\t\t\t\t\t     str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x43: /* PI */\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_pi_xml, tvb, off, 1,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | PI (XML Processing Instruction) | %s<?xml\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo, off,\n\t\t\t\t\t\t\t\t  str_tbl, *level, codepage_attr, map);\n\t\t\t/* Check that there is still room in packet */\n\t\t\toff += len;\n\t\t\tif (off >= tvb_len) {\n\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\", *level, off - offset));\n\t\t\t\t/*\n\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t */\n\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t}\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_end_pi, tvb, off-1, 1,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (PI)                        | %s?>\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\tbreak;\n\t\tcase 0x80: /* EXT_T_0 */\n\t\tcase 0x81: /* EXT_T_1 */\n\t\tcase 0x82: /* EXT_T_2 */\n\t\t\t/* Extension tokens */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tif (map)\n\t\t\t\t{\n\t\t\t\t\tif (map->ext_t[peek & 0x03])\n\t\t\t\t\t\ts = (map->ext_t[peek & 0x03])(tvb, idx, str_tbl);\n\t\t\t\t\telse\n\t\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \"EXT_T_%1x (%s)\", peek & 0x03,\n\t\t\t\t\t\t\t        map_token (map->global, 0, peek));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \"(Extension Token, integer value: %u)\", idx);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_t, tvb, off, 1+len, s,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_T_%1x    (Extension Token)    | %s%s\",\n\t\t\t\t\t\t     *level, *codepage_stag, peek & 0x0f, Indent (*level), s);\n\t\t\t}\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x83: /* STR_T */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\tstr = tvb_format_text (tvb, str_tbl+idx, str_len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_t, tvb, off, 1+len, str,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | STR_T (Tableref string)         | %s\\'%s\\'\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level), str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0xC0: /* EXT_0 */\n\t\tcase 0xC1: /* EXT_1 */\n\t\tcase 0xC2: /* EXT_2 */\n\t\t\t/* Extension tokens */\n\t\t\tstr = (char*)((map != NULL) ? map_token (map->global, 0, peek) : \"Single-byte extension\");\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_extension_token, tvb, off, 1, str,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_%1x      (Extension Token)    | %s(%s)\",\n\t\t\t\t\t     *level, *codepage_stag, peek & 0x0f, Indent (*level), str);\n\t\t\toff++;\n\t\t\tbreak;\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\n\t\t\tif (tvb_get_guint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\n\t\t\t\tif (map != NULL)\n\t\t\t\t{\n\t\t\t\t\tchar *tmp_str;\n\t\t\t\t\tif (tag_save_known) { /* Knwon tag */\n\t\t\t\t\t\tif (map->opaque_binary_tag) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_binary_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t     tag_save_known, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_binary_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t\ttag_save_known, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { /* lITERAL tag */\n\t\t\t\t\t\tif (map->opaque_literal_tag) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_literal_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t      tag_save_literal, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_literal_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t\t tag_save_literal, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len, NULL,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s%s\",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tmp_str);\n\t\t\t\t\toff += 1 + len;\n\t\t\t\t} else {\n\t\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s(%u bytes of opaque data)\",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), idx);\n\t\t\t\t\toff += 1+len+idx;\n\t\t\t\t}\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\n\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_reserved_2, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | RESERVED_2     (Invalid Token!) | WBXML 1.0 parsing stops here.\",\n\t\t\t\t\t\t     *level, *codepage_stag);\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t\tDebugLog((\"STAG: level = %u, Return: len = %u\\n\", *level, off - offset));\n\t\t\t\treturn (off - offset);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* No default clause, as all cases have been treated */\n\t\t} else { /* LITERAL or Known TAG */\n\t\t\t/* We must store the initial tag, and also retrieve the new tag.\n\t\t\t * For efficiency reasons, we store the literal tag representation\n\t\t\t * for known tags too, so we can easily close the tag without the\n\t\t\t * need of a new lookup and avoiding storage of token codepage.\n\t\t\t *\n\t\t\t * There are 4 possibilities:\n\t\t\t *\n\t\t\t *  1. Known tag followed by a known tag\n\t\t\t *  2. Known tag followed by a LITERAL tag\n\t\t\t *  3. LITERAL tag followed by Known tag\n\t\t\t *  4. LITERAL tag followed by LITERAL tag\n\t\t\t */\n\n\t\t\t/* Store the new tag */\n\t\t\ttag_len = 0;\n\t\t\tif ((peek & 0x3F) == 4) { /* LITERAL */\n\t\t\t\tDebugLog((\"STAG: LITERAL tag (peek = 0x%02X, off = %u) - TableRef follows!\\n\", peek, off));\n\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &tag_len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\t\ttag_new_literal = (const gchar*)tvb_get_ptr (tvb, str_tbl+idx, str_len);\n\t\t\t\ttag_new_known = 0; /* invalidate known tag_new */\n\t\t\t} else { /* Known tag */\n\t\t\t\ttag_new_known = peek & 0x3F;\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\ttag_new_literal = map_token (map->tags, *codepage_stag,\n\t\t\t\t\t\t\t     tag_new_known);\n\t\t\t\t} else {\n\t\t\t\t\ttag_new_literal = wmem_strdup_printf(wmem_packet_scope(), \"Tag_0x%02X\",\n\t\t\t\t\t\t\ttag_new_known);\n\t\t\t\t}\n\t\t\t\t/* Stored looked up tag name string */\n\t\t\t}\n\n\t\t\t/* Parsing of TAG starts HERE */\n\t\t\tif (peek & 0x40) { /* Content present */\n\t\t\t\t/* Content follows\n\t\t\t\t * [!] An explicit END token is expected in these cases!\n\t\t\t\t * ==> Recursion possible if we encounter a tag with content;\n\t\t\t\t *     recursion will return at the explicit END token.\n\t\t\t\t */\n\t\t\t\tif (parsing_tag_content) { /* Recurse */\n\t\t\t\t\tDebugLog((\"STAG: Tag in Tag - RECURSE! (off = %u)\\n\", off));\n\t\t\t\t\t/* Do not process the attribute list:\n\t\t\t\t\t * recursion will take care of it */\n\t\t\t\t\t(*level)++;\n\t\t\t\t\tlen = parse_wbxml_tag_defined (tree, tvb, pinfo, off, str_tbl,\n\t\t\t\t\t\t\t\t       level, codepage_stag, codepage_attr, map);\n\t\t\t\t\toff += len;\n\t\t\t\t} else { /* Now we will have content to parse */\n\t\t\t\t\t/* Save the start tag so we can properly close it later. */\n\t\t\t\t\tif ((peek & 0x3F) == 4) { /* Literal tag */\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\n\t\t\t\t\t\ttag_save_known = 0;\n\t\t\t\t\t} else { /* Known tag */\n\t\t\t\t\t\ttag_save_known = tag_new_known;\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\n\t\t\t\t\t\t/* The last statement avoids needless lookups */\n\t\t\t\t\t}\n\t\t\t\t\t/* Process the attribute list if present */\n\t\t\t\t\tif (peek & 0x80) { /* Content and Attribute list present */\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (AC) | %s<%s\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\t\toff++;\n\t\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_ac, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL_AC (Literal tag)   (AC) | %s<%s\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\n\t\t\t\t\t\t\t\t  *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_end_attribute_list, tvb, off-1, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (attribute list)            | %s>\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t} else { /* Content, no Attribute list */\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (.C) | %s<%s>\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\t\toff++;\n\t\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_c, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL_C  (Literal Tag)   (.C) | %s<%s>\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* The data that follows in the parsing process\n\t\t\t\t\t * represents content for the opening tag\n\t\t\t\t\t * we've just processed in the lines above.\n\t\t\t\t\t * Next time we encounter a tag with content: recurse\n\t\t\t\t\t */\n\t\t\t\t\tparsing_tag_content = TRUE;\n\t\t\t\t\tDebugLog((\"Tag in Tag - No recursion this time! (off = %u)\\n\", off));\n\t\t\t\t}\n\t\t\t} else { /* No Content */\n\t\t\t\tDebugLog((\"<Tag/> in Tag - No recursion! (off = %u)\\n\", off));\n\t\t\t\t(*level)++;\n\t\t\t\tif (peek & 0x80) { /* No Content, Attribute list present */\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (A.) | %s<%s\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\toff++;\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off > tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\", *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_end_known_tag_uint, tvb, off-1, 1, *codepage_stag,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Known Tag)                 | %s/>\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_a, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL_A  (Literal Tag)   (A.) | %s<%s\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_new_literal);\n\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\", *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_literal_tag, tvb, off-1, 1, \"\",\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Literal Tag)               | %s/>\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t}\n\t\t\t\t} else { /* No Content, No Attribute list */\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02x           (..) | %s<%s />\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\toff++;\n\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL    (Literal Tag)   (..) | %s<%s />\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t\t\t\t     tag_new_literal);\n\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(*level)--;\n\t\t\t\t/* TODO: Do I have to reset code page here? */\n\t\t\t}\n\t\t} /* if (tag & 0x3F) >= 5 */\n\t} /* while */\n\tDebugLog((\"STAG: level = %u, Return: len = %u (end of function body)\\n\", *level, off - offset));\n\treturn (off - offset);\n}",
        "func": "static guint32\nparse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, guint32 offset,\n\t\t\t guint32 str_tbl, guint8 *level, guint8 *codepage_stag, guint8 *codepage_attr,\n\t\t\t const wbxml_decoding *map)\n{\n\tguint32     tvb_len  = tvb_reported_length (tvb);\n\tguint32     off      = offset;\n\tguint32     len;\n\tguint       str_len;\n\tguint32     ent;\n\tguint32     idx;\n\tguint8      peek;\n\tguint32     tag_len;                     /* Length of the index (uintvar) from a LITERAL tag */\n\tguint8      tag_save_known      = 0;     /* Will contain peek & 0x3F (tag identity) */\n\tguint8      tag_new_known       = 0;     /* Will contain peek & 0x3F (tag identity) */\n\tconst char *tag_save_literal    = NULL;  /* Will contain the LITERAL tag identity */\n\tconst char *tag_new_literal;             /* Will contain the LITERAL tag identity */\n\tgchar      *str;\n\tguint8      parsing_tag_content = FALSE; /* Are we parsing content from a\n\t\t\t\t\t            tag with content: <x>Content</x>\n\n\t\t\t\t\t            The initial state is FALSE.\n\t\t\t\t\t            This state will trigger recursion. */\n\n\tif (*level == 255) {\n\t\tproto_tree_add_expert(tree, pinfo, &ei_wbxml_too_much_recursion, tvb, offset, tvb_captured_length_remaining(tvb, offset));\n\t\treturn tvb_len;\n\t}\n\tDebugLog((\"parse_wbxml_tag_defined (level = %u, offset = %u)\\n\", *level, offset));\n\twhile (off < tvb_len) {\n\t\tpeek = tvb_get_guint8 (tvb, off);\n\t\tDebugLog((\"STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\\n\", *level, peek, off, tvb_len));\n\t\tif ((peek & 0x3F) < 4) switch (peek) { /* Global tokens in state = STAG\n\t\t\t\t\t\t\t  but not the LITERAL tokens */\n\t\tcase 0x00: /* SWITCH_PAGE */\n\t\t\t*codepage_stag = tvb_get_guint8 (tvb, off+1);\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_switch_page, tvb, off, 2, *codepage_stag,\n\t\t\t\t\t     \"      | Tag   | T -->%3d | SWITCH_PAGE (Tag code page)     |\",\n\t\t\t\t\t     *codepage_stag);\n\t\t\toff += 2;\n\t\t\tbreak;\n\t\tcase 0x01: /* END: only possible for Tag with Content */\n\t\t\tif (tag_save_known) { /* Known TAG */\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_known_tag, tvb, off, 1, tag_save_literal,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Known Tag 0x%02X)            | %s</%s>\",\n\t\t\t\t\t\t     *level, *codepage_stag,\n\t\t\t\t\t\t     tag_save_known, Indent (*level),\n\t\t\t\t\t\t     tag_save_literal); /* We already looked it up! */\n\t\t\t} else { /* Literal TAG */\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_literal_tag, tvb, off, 1, tag_save_literal ? tag_save_literal : \"\",\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Literal Tag)               | %s</%s>\",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_save_literal ? tag_save_literal : \"\");\n\t\t\t}\n\t\t\t(*level)--;\n\t\t\toff++;\n\t\t\t/* Reset code page: not needed as return from recursion */\n\t\t\tDebugLog((\"STAG: level = %u, Return: len = %u\\n\", *level, off - offset));\n\t\t\treturn (off - offset);\n\t\tcase 0x02: /* ENTITY */\n\t\t\tent = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_entity, tvb, off, 1+len, ent,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | ENTITY                          | %s'&#%u;'\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level), ent);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x03: /* STR_I */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | STR_I (Inline string)           | %s\\'%s\\'\",\n\t\t\t\t\t     *level, *codepage_stag, Indent(*level),\n\t\t\t\t\t     str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x40: /* EXT_I_0 */\n\t\tcase 0x41: /* EXT_I_1 */\n\t\tcase 0x42: /* EXT_I_2 */\n\t\t\t/* Extension tokens */\n\t\t\tlen = tvb_strsize (tvb, off+1);\n\t\t\tstr = tvb_format_text (tvb, off+1, len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_i, tvb, off, 1+len, str,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_I_%1x    (Extension Token)    | %s(%s: \\'%s\\')\",\n\t\t\t\t\t     *level, *codepage_stag,\n\t\t\t\t\t     peek & 0x0f, Indent (*level),\n\t\t\t\t\t     ((map != NULL) ? map_token (map->global, 0, peek) : \"Inline string extension\"),\n\t\t\t\t\t     str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x43: /* PI */\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_pi_xml, tvb, off, 1,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | PI (XML Processing Instruction) | %s<?xml\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo, off,\n\t\t\t\t\t\t\t\t  str_tbl, *level, codepage_attr, map);\n\t\t\t/* Check that there is still room in packet */\n\t\t\toff += len;\n\t\t\tif (off >= tvb_len) {\n\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\", *level, off - offset));\n\t\t\t\t/*\n\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t */\n\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t}\n\t\t\tproto_tree_add_none_format(tree, hf_wbxml_end_pi, tvb, off-1, 1,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (PI)                        | %s?>\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\tbreak;\n\t\tcase 0x80: /* EXT_T_0 */\n\t\tcase 0x81: /* EXT_T_1 */\n\t\tcase 0x82: /* EXT_T_2 */\n\t\t\t/* Extension tokens */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t{\n\t\t\t\tchar *s;\n\t\t\t\tif (map)\n\t\t\t\t{\n\t\t\t\t\tif (map->ext_t[peek & 0x03])\n\t\t\t\t\t\ts = (map->ext_t[peek & 0x03])(tvb, idx, str_tbl);\n\t\t\t\t\telse\n\t\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \"EXT_T_%1x (%s)\", peek & 0x03,\n\t\t\t\t\t\t\t        map_token (map->global, 0, peek));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts = wmem_strdup_printf(wmem_packet_scope(), \"(Extension Token, integer value: %u)\", idx);\n\t\t\t\t}\n\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_ext_t, tvb, off, 1+len, s,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_T_%1x    (Extension Token)    | %s%s\",\n\t\t\t\t\t\t     *level, *codepage_stag, peek & 0x0f, Indent (*level), s);\n\t\t\t}\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0x83: /* STR_T */\n\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\tstr = tvb_format_text (tvb, str_tbl+idx, str_len-1);\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_str_t, tvb, off, 1+len, str,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | STR_T (Tableref string)         | %s\\'%s\\'\",\n\t\t\t\t\t     *level, *codepage_stag, Indent (*level), str);\n\t\t\toff += 1+len;\n\t\t\tbreak;\n\t\tcase 0xC0: /* EXT_0 */\n\t\tcase 0xC1: /* EXT_1 */\n\t\tcase 0xC2: /* EXT_2 */\n\t\t\t/* Extension tokens */\n\t\t\tstr = (char*)((map != NULL) ? map_token (map->global, 0, peek) : \"Single-byte extension\");\n\t\t\tproto_tree_add_string_format(tree, hf_wbxml_extension_token, tvb, off, 1, str,\n\t\t\t\t\t     \"  %3d | Tag   | T %3d    | EXT_%1x      (Extension Token)    | %s(%s)\",\n\t\t\t\t\t     *level, *codepage_stag, peek & 0x0f, Indent (*level), str);\n\t\t\toff++;\n\t\t\tbreak;\n\t\tcase 0xC3: /* OPAQUE - WBXML 1.1 and newer */\n\t\t\tif (tvb_get_guint8 (tvb, 0)) { /* WBXML 1.x (x > 0) */\n\t\t\t\tif (map != NULL)\n\t\t\t\t{\n\t\t\t\t\tchar *tmp_str;\n\t\t\t\t\tif (tag_save_known) { /* Knwon tag */\n\t\t\t\t\t\tif (map->opaque_binary_tag) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_binary_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t     tag_save_known, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_binary_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t\ttag_save_known, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { /* lITERAL tag */\n\t\t\t\t\t\tif (map->opaque_literal_tag) {\n\t\t\t\t\t\t\ttmp_str = map->opaque_literal_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t      tag_save_literal, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttmp_str = default_opaque_literal_tag(tvb, off + 1,\n\t\t\t\t\t\t\t\t\t\t\t tag_save_literal, *codepage_stag, &len, pinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len, NULL,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s%s\",\n\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tmp_str);\n\t\t\t\t\toff += 1 + len;\n\t\t\t\t} else {\n\t\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t\t\tif ((len <= tvb_len) && (idx < tvb_len))\n\t\t\t\t\t{\n\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,\n\t\t\t\t\t\t         \"  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s(%u bytes of opaque data)\",\n\t\t\t\t\t\t         *level, *codepage_stag, Indent (*level), idx);\n\t\t\t\t\t\toff += 1+len+idx;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\t\t\toff = tvb_len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\n\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_reserved_2, tvb, off, 1,\n\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | RESERVED_2     (Invalid Token!) | WBXML 1.0 parsing stops here.\",\n\t\t\t\t\t\t     *level, *codepage_stag);\n\t\t\t\t/* Stop processing as it is impossible to parse now */\n\t\t\t\toff = tvb_len;\n\t\t\t\tDebugLog((\"STAG: level = %u, Return: len = %u\\n\", *level, off - offset));\n\t\t\t\treturn (off - offset);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t\t/* No default clause, as all cases have been treated */\n\t\t} else { /* LITERAL or Known TAG */\n\t\t\t/* We must store the initial tag, and also retrieve the new tag.\n\t\t\t * For efficiency reasons, we store the literal tag representation\n\t\t\t * for known tags too, so we can easily close the tag without the\n\t\t\t * need of a new lookup and avoiding storage of token codepage.\n\t\t\t *\n\t\t\t * There are 4 possibilities:\n\t\t\t *\n\t\t\t *  1. Known tag followed by a known tag\n\t\t\t *  2. Known tag followed by a LITERAL tag\n\t\t\t *  3. LITERAL tag followed by Known tag\n\t\t\t *  4. LITERAL tag followed by LITERAL tag\n\t\t\t */\n\n\t\t\t/* Store the new tag */\n\t\t\ttag_len = 0;\n\t\t\tif ((peek & 0x3F) == 4) { /* LITERAL */\n\t\t\t\tDebugLog((\"STAG: LITERAL tag (peek = 0x%02X, off = %u) - TableRef follows!\\n\", peek, off));\n\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &tag_len, pinfo, &ei_wbxml_oversized_uintvar);\n\t\t\t\tstr_len = tvb_strsize (tvb, str_tbl+idx);\n\t\t\t\ttag_new_literal = (const gchar*)tvb_get_ptr (tvb, str_tbl+idx, str_len);\n\t\t\t\ttag_new_known = 0; /* invalidate known tag_new */\n\t\t\t} else { /* Known tag */\n\t\t\t\ttag_new_known = peek & 0x3F;\n\t\t\t\tif (map != NULL) {\n\t\t\t\t\ttag_new_literal = map_token (map->tags, *codepage_stag,\n\t\t\t\t\t\t\t     tag_new_known);\n\t\t\t\t} else {\n\t\t\t\t\ttag_new_literal = wmem_strdup_printf(wmem_packet_scope(), \"Tag_0x%02X\",\n\t\t\t\t\t\t\ttag_new_known);\n\t\t\t\t}\n\t\t\t\t/* Stored looked up tag name string */\n\t\t\t}\n\n\t\t\t/* Parsing of TAG starts HERE */\n\t\t\tif (peek & 0x40) { /* Content present */\n\t\t\t\t/* Content follows\n\t\t\t\t * [!] An explicit END token is expected in these cases!\n\t\t\t\t * ==> Recursion possible if we encounter a tag with content;\n\t\t\t\t *     recursion will return at the explicit END token.\n\t\t\t\t */\n\t\t\t\tif (parsing_tag_content) { /* Recurse */\n\t\t\t\t\tDebugLog((\"STAG: Tag in Tag - RECURSE! (off = %u)\\n\", off));\n\t\t\t\t\t/* Do not process the attribute list:\n\t\t\t\t\t * recursion will take care of it */\n\t\t\t\t\t(*level)++;\n\t\t\t\t\tlen = parse_wbxml_tag_defined (tree, tvb, pinfo, off, str_tbl,\n\t\t\t\t\t\t\t\t       level, codepage_stag, codepage_attr, map);\n\t\t\t\t\toff += len;\n\t\t\t\t} else { /* Now we will have content to parse */\n\t\t\t\t\t/* Save the start tag so we can properly close it later. */\n\t\t\t\t\tif ((peek & 0x3F) == 4) { /* Literal tag */\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\n\t\t\t\t\t\ttag_save_known = 0;\n\t\t\t\t\t} else { /* Known tag */\n\t\t\t\t\t\ttag_save_known = tag_new_known;\n\t\t\t\t\t\ttag_save_literal = tag_new_literal;\n\t\t\t\t\t\t/* The last statement avoids needless lookups */\n\t\t\t\t\t}\n\t\t\t\t\t/* Process the attribute list if present */\n\t\t\t\t\tif (peek & 0x80) { /* Content and Attribute list present */\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (AC) | %s<%s\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\t\toff++;\n\t\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_ac, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL_AC (Literal tag)   (AC) | %s<%s\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\",\n\t\t\t\t\t\t\t\t  *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_end_attribute_list, tvb, off-1, 1,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (attribute list)            | %s>\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t} else { /* Content, no Attribute list */\n\t\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (.C) | %s<%s>\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\t\toff++;\n\t\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_c, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL_C  (Literal Tag)   (.C) | %s<%s>\",\n\t\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_new_literal);\n\t\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* The data that follows in the parsing process\n\t\t\t\t\t * represents content for the opening tag\n\t\t\t\t\t * we've just processed in the lines above.\n\t\t\t\t\t * Next time we encounter a tag with content: recurse\n\t\t\t\t\t */\n\t\t\t\t\tparsing_tag_content = TRUE;\n\t\t\t\t\tDebugLog((\"Tag in Tag - No recursion this time! (off = %u)\\n\", off));\n\t\t\t\t}\n\t\t\t} else { /* No Content */\n\t\t\t\tDebugLog((\"<Tag/> in Tag - No recursion! (off = %u)\\n\", off));\n\t\t\t\t(*level)++;\n\t\t\t\tif (peek & 0x80) { /* No Content, Attribute list present */\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (A.) | %s<%s\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\toff++;\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off > tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\", *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_uint_format(tree, hf_wbxml_end_known_tag_uint, tvb, off-1, 1, *codepage_stag,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Known Tag)                 | %s/>\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal_a, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL_A  (Literal Tag)   (A.) | %s<%s\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), tag_new_literal);\n\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t\tlen = parse_wbxml_attribute_list_defined (tree, tvb, pinfo,\n\t\t\t\t\t\t\t\t\t\t\t  off, str_tbl, *level, codepage_attr, map);\n\t\t\t\t\t\t/* Check that there is still room in packet */\n\t\t\t\t\t\toff += len;\n\t\t\t\t\t\tif (off >= tvb_len) {\n\t\t\t\t\t\t\tDebugLog((\"STAG: level = %u, ThrowException: len = %u (short frame)\\n\", *level, off - offset));\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * TODO - Do we need to free g_malloc()ed memory?\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tTHROW(ReportedBoundsError);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_end_literal_tag, tvb, off-1, 1, \"\",\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | END (Literal Tag)               | %s/>\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level));\n\t\t\t\t\t}\n\t\t\t\t} else { /* No Content, No Attribute list */\n\t\t\t\t\tif (tag_new_known) { /* Known tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    |   Known Tag 0x%02x           (..) | %s<%s />\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, tag_new_known,\n\t\t\t\t\t\t\t\t     Indent (*level), tag_new_literal);\n\t\t\t\t\t\t/* Tag string already looked up earlier! */\n\t\t\t\t\t\toff++;\n\t\t\t\t\t} else { /* LITERAL tag */\n\t\t\t\t\t\tproto_tree_add_string_format(tree, hf_wbxml_literal, tvb, off, 1, tag_new_literal,\n\t\t\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | LITERAL    (Literal Tag)   (..) | %s<%s />\",\n\t\t\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level),\n\t\t\t\t\t\t\t\t     tag_new_literal);\n\t\t\t\t\t\toff += 1 + tag_len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(*level)--;\n\t\t\t\t/* TODO: Do I have to reset code page here? */\n\t\t\t}\n\t\t} /* if (tag & 0x3F) >= 5 */\n\t} /* while */\n\tDebugLog((\"STAG: level = %u, Return: len = %u (end of function body)\\n\", *level, off - offset));\n\treturn (off - offset);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -177,10 +177,16 @@\n \t\t\t\t\toff += 1 + len;\n \t\t\t\t} else {\n \t\t\t\t\tidx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar);\n-\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,\n-\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s(%u bytes of opaque data)\",\n-\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), idx);\n-\t\t\t\t\toff += 1+len+idx;\n+\t\t\t\t\tif ((len <= tvb_len) && (idx < tvb_len))\n+\t\t\t\t\t{\n+\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,\n+\t\t\t\t\t\t         \"  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s(%u bytes of opaque data)\",\n+\t\t\t\t\t\t         *level, *codepage_stag, Indent (*level), idx);\n+\t\t\t\t\t\toff += 1+len+idx;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */\n+\t\t\t\t\t\toff = tvb_len;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else { /* WBXML 1.0 - RESERVED_2 token (invalid) */\n \t\t\t\tproto_tree_add_none_format(tree, hf_wbxml_reserved_2, tvb, off, 1,",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,",
                "\t\t\t\t\t\t     \"  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s(%u bytes of opaque data)\",",
                "\t\t\t\t\t\t     *level, *codepage_stag, Indent (*level), idx);",
                "\t\t\t\t\toff += 1+len+idx;"
            ],
            "added_lines": [
                "\t\t\t\t\tif ((len <= tvb_len) && (idx < tvb_len))",
                "\t\t\t\t\t{",
                "\t\t\t\t\t\tproto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL,",
                "\t\t\t\t\t\t         \"  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s(%u bytes of opaque data)\",",
                "\t\t\t\t\t\t         *level, *codepage_stag, Indent (*level), idx);",
                "\t\t\t\t\t\toff += 1+len+idx;",
                "\t\t\t\t\t} else {",
                "\t\t\t\t\t\t/* Stop processing as it is impossible to parse now */",
                "\t\t\t\t\t\toff = tvb_len;",
                "\t\t\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11446",
        "func_name": "ImageMagick/ReadPESImage",
        "description": "The ReadPESImage function in coders\\pes.c in ImageMagick 7.0.6-1 has an infinite loop vulnerability that can cause CPU exhaustion via a crafted PES file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/787ee25e9fb0e4e0509121342371d925fe5044f8",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/537",
        "commit_text": "",
        "func_before": "static Image *ReadPESImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    delta_x,\n    delta_y,\n    j,\n    unique_file,\n    x,\n    y;\n\n  MagickBooleanType\n    status;\n\n  PESBlockInfo\n    blocks[256];\n\n  PointInfo\n    *stitches;\n\n  SegmentInfo\n    bounds;\n\n  register ssize_t\n    i;\n\n  size_t\n    number_blocks,\n    number_colors,\n    number_stitches;\n\n  ssize_t\n    count,\n    offset;\n\n  unsigned char\n    magick[4],\n    version[4];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Verify PES identifier.\n  */\n  count=ReadBlob(image,4,magick);\n  if ((count != 4) || (LocaleNCompare((char *) magick,\"#PES\",4) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  count=ReadBlob(image,4,version);\n  offset=ReadBlobLSBSignedLong(image);\n  if (DiscardBlobBytes(image,offset+36) == MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  /*\n    Get PES colors.\n  */\n  number_colors=(size_t) ReadBlobByte(image)+1;\n  for (i=0; i < (ssize_t) number_colors; i++)\n  {\n    j=ReadBlobByte(image);\n    blocks[i].color=PESColor+(j < 0 ? 0 : j);\n    blocks[i].offset=0;\n  }\n  for ( ; i < 256L; i++)\n  {\n    blocks[i].offset=0;\n    blocks[i].color=PESColor;\n  }\n  if (DiscardBlobBytes(image,532L-number_colors-21) == MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  /*\n    Stitch away.\n  */\n  number_stitches=64;\n  stitches=(PointInfo *) AcquireQuantumMemory(number_stitches,\n    sizeof(*stitches));\n  if (stitches == (PointInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  bounds.x1=65535.0;\n  bounds.y1=65535.0;\n  bounds.x2=(-65535.0);\n  bounds.y2=(-65535.0);\n  i=0;\n  j=0;\n  delta_x=0;\n  delta_y=0;\n  while (EOFBlob(image) != EOF)\n  {\n    x=ReadBlobByte(image);\n    y=ReadBlobByte(image);\n    if ((x == 0xff) && (y == 0))\n      break;\n    if ((x == 254) && (y == 176))\n      {\n        /*\n          Start a new stitch block.\n        */\n        j++;\n        blocks[j].offset=(ssize_t) i;\n        if (j >= 256)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) ReadBlobByte(image);\n        continue;\n      }\n    if ((x & 0x80) == 0)\n      {\n        /*\n          Normal stitch.\n        */\n        if ((x & 0x40) != 0)\n          x-=0x80;\n      }\n    else\n      {\n        /*\n          Jump stitch.\n        */\n        x=((x & 0x0f) << 8)+y;\n        if ((x & 0x800) != 0)\n          x-=0x1000;\n        y=ReadBlobByte(image);\n      }\n    if ((y & 0x80) == 0)\n      {\n        /*\n          Normal stitch.\n        */\n        if ((y & 0x40) != 0)\n          y-=0x80;\n      }\n    else\n      {\n        /*\n          Jump stitch.\n        */\n        y=((y & 0x0f) << 8)+ReadBlobByte(image);\n        if ((y & 0x800) != 0)\n          y-=0x1000;\n      }\n    /*\n      Note stitch (x,y).\n    */\n    x+=delta_x;\n    y+=delta_y;\n    delta_x=x;\n    delta_y=y;\n    stitches[i].x=(double) x;\n    stitches[i].y=(double) y;\n    if ((double) x < bounds.x1)\n      bounds.x1=(double) x;\n    if ((double) x > bounds.x2)\n      bounds.x2=(double) x;\n    if ((double) y < bounds.y1)\n      bounds.y1=(double) y;\n    if ((double) y > bounds.y2)\n      bounds.y2=(double) y;\n    i++;\n    if (i >= (ssize_t) number_stitches)\n      {\n        /*\n          Make room for more stitches.\n        */\n        number_stitches<<=1;\n        stitches=(PointInfo *)  ResizeQuantumMemory(stitches,(size_t)\n          number_stitches,sizeof(*stitches));\n        if (stitches == (PointInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     }\n  }\n  j++;\n  blocks[j].offset=(ssize_t) i;\n  number_blocks=(size_t) j;\n  /*\n    Write stitches as SVG file.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n  (void) FormatLocaleFile(file,\"<?xml version=\\\"1.0\\\"?>\\n\");\n  (void) FormatLocaleFile(file,\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" \"\n    \"xlink=\\\"http://www.w3.org/1999/xlink\\\" \"\n    \"ev=\\\"http://www.w3.org/2001/xml-events\\\" version=\\\"1.1\\\" \"\n    \"baseProfile=\\\"full\\\" width=\\\"%g\\\" height=\\\"%g\\\">\\n\",bounds.x2-bounds.x1,\n    bounds.y2-bounds.y1);\n  for (i=0; i < (ssize_t) number_blocks; i++)\n  {\n    offset=blocks[i].offset;\n    (void) FormatLocaleFile(file,\"  <path stroke=\\\"#%02x%02x%02x\\\" \"\n      \"fill=\\\"none\\\" d=\\\"M %g %g\",blocks[i].color->red,blocks[i].color->green,\n      blocks[i].color->blue,stitches[offset].x-bounds.x1,\n      stitches[offset].y-bounds.y1);\n    for (j=1; j < (ssize_t) (blocks[i+1].offset-offset); j++)\n      (void) FormatLocaleFile(file,\" L %g %g\",stitches[offset+j].x-bounds.x1,\n        stitches[offset+j].y-bounds.y1);\n    (void) FormatLocaleFile(file,\"\\\"/>\\n\");\n  }\n  (void) FormatLocaleFile(file,\"</svg>\\n\");\n  (void) fclose(file);\n  (void) CloseBlob(image);\n  image=DestroyImage(image);\n  /*\n    Read SVG file.\n  */\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"svg:%s\",\n    filename);\n  image=ReadImage(read_info,exception);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick_filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick,\"PES\",MagickPathExtent);\n    }\n  read_info=DestroyImageInfo(read_info);\n  (void) RelinquishUniqueFileResource(filename);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadPESImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    delta_x,\n    delta_y,\n    j,\n    unique_file,\n    x,\n    y;\n\n  MagickBooleanType\n    status;\n\n  PESBlockInfo\n    blocks[256];\n\n  PointInfo\n    *stitches;\n\n  SegmentInfo\n    bounds;\n\n  register ssize_t\n    i;\n\n  size_t\n    number_blocks,\n    number_colors,\n    number_stitches;\n\n  ssize_t\n    count,\n    offset;\n\n  unsigned char\n    magick[4],\n    version[4];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Verify PES identifier.\n  */\n  count=ReadBlob(image,4,magick);\n  if ((count != 4) || (LocaleNCompare((char *) magick,\"#PES\",4) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  count=ReadBlob(image,4,version);\n  offset=ReadBlobLSBSignedLong(image);\n  if (DiscardBlobBytes(image,offset+36) == MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  /*\n    Get PES colors.\n  */\n  number_colors=(size_t) ReadBlobByte(image)+1;\n  for (i=0; i < (ssize_t) number_colors; i++)\n  {\n    j=ReadBlobByte(image);\n    blocks[i].color=PESColor+(j < 0 ? 0 : j);\n    blocks[i].offset=0;\n  }\n  for ( ; i < 256L; i++)\n  {\n    blocks[i].offset=0;\n    blocks[i].color=PESColor;\n  }\n  if (DiscardBlobBytes(image,532L-number_colors-21) == MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n  /*\n    Stitch away.\n  */\n  number_stitches=64;\n  stitches=(PointInfo *) AcquireQuantumMemory(number_stitches,\n    sizeof(*stitches));\n  if (stitches == (PointInfo *) NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n  bounds.x1=65535.0;\n  bounds.y1=65535.0;\n  bounds.x2=(-65535.0);\n  bounds.y2=(-65535.0);\n  i=0;\n  j=0;\n  delta_x=0;\n  delta_y=0;\n  while (EOFBlob(image) == MagickFalse)\n  {\n    x=ReadBlobByte(image);\n    y=ReadBlobByte(image);\n    if ((x == 0xff) && (y == 0))\n      break;\n    if ((x == 254) && (y == 176))\n      {\n        /*\n          Start a new stitch block.\n        */\n        j++;\n        blocks[j].offset=(ssize_t) i;\n        if (j >= 256)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) ReadBlobByte(image);\n        continue;\n      }\n    if ((x & 0x80) == 0)\n      {\n        /*\n          Normal stitch.\n        */\n        if ((x & 0x40) != 0)\n          x-=0x80;\n      }\n    else\n      {\n        /*\n          Jump stitch.\n        */\n        x=((x & 0x0f) << 8)+y;\n        if ((x & 0x800) != 0)\n          x-=0x1000;\n        y=ReadBlobByte(image);\n      }\n    if ((y & 0x80) == 0)\n      {\n        /*\n          Normal stitch.\n        */\n        if ((y & 0x40) != 0)\n          y-=0x80;\n      }\n    else\n      {\n        /*\n          Jump stitch.\n        */\n        y=((y & 0x0f) << 8)+ReadBlobByte(image);\n        if ((y & 0x800) != 0)\n          y-=0x1000;\n      }\n    /*\n      Note stitch (x,y).\n    */\n    x+=delta_x;\n    y+=delta_y;\n    delta_x=x;\n    delta_y=y;\n    stitches[i].x=(double) x;\n    stitches[i].y=(double) y;\n    if ((double) x < bounds.x1)\n      bounds.x1=(double) x;\n    if ((double) x > bounds.x2)\n      bounds.x2=(double) x;\n    if ((double) y < bounds.y1)\n      bounds.y1=(double) y;\n    if ((double) y > bounds.y2)\n      bounds.y2=(double) y;\n    i++;\n    if (i >= (ssize_t) number_stitches)\n      {\n        /*\n          Make room for more stitches.\n        */\n        number_stitches<<=1;\n        stitches=(PointInfo *)  ResizeQuantumMemory(stitches,(size_t)\n          number_stitches,sizeof(*stitches));\n        if (stitches == (PointInfo *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n     }\n  }\n  j++;\n  blocks[j].offset=(ssize_t) i;\n  number_blocks=(size_t) j;\n  image->columns=bounds.x2-bounds.x1;\n  image->rows=bounds.y2-bounds.y1;\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Write stitches as SVG file.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n  (void) FormatLocaleFile(file,\"<?xml version=\\\"1.0\\\"?>\\n\");\n  (void) FormatLocaleFile(file,\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" \"\n    \"xlink=\\\"http://www.w3.org/1999/xlink\\\" \"\n    \"ev=\\\"http://www.w3.org/2001/xml-events\\\" version=\\\"1.1\\\" \"\n    \"baseProfile=\\\"full\\\" width=\\\"%g\\\" height=\\\"%g\\\">\\n\",(double)\n    image->columns,(double) image->rows);\n  for (i=0; i < (ssize_t) number_blocks; i++)\n  {\n    offset=blocks[i].offset;\n    (void) FormatLocaleFile(file,\"  <path stroke=\\\"#%02x%02x%02x\\\" \"\n      \"fill=\\\"none\\\" d=\\\"M %g %g\",blocks[i].color->red,blocks[i].color->green,\n      blocks[i].color->blue,stitches[offset].x-bounds.x1,\n      stitches[offset].y-bounds.y1);\n    for (j=1; j < (ssize_t) (blocks[i+1].offset-offset); j++)\n      (void) FormatLocaleFile(file,\" L %g %g\",stitches[offset+j].x-bounds.x1,\n        stitches[offset+j].y-bounds.y1);\n    (void) FormatLocaleFile(file,\"\\\"/>\\n\");\n  }\n  (void) FormatLocaleFile(file,\"</svg>\\n\");\n  (void) fclose(file);\n  (void) CloseBlob(image);\n  image=DestroyImage(image);\n  /*\n    Read SVG file.\n  */\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"svg:%s\",\n    filename);\n  image=ReadImage(read_info,exception);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick_filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick,\"PES\",MagickPathExtent);\n    }\n  read_info=DestroyImageInfo(read_info);\n  (void) RelinquishUniqueFileResource(filename);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -114,7 +114,7 @@\n   j=0;\n   delta_x=0;\n   delta_y=0;\n-  while (EOFBlob(image) != EOF)\n+  while (EOFBlob(image) == MagickFalse)\n   {\n     x=ReadBlobByte(image);\n     y=ReadBlobByte(image);\n@@ -200,6 +200,11 @@\n   j++;\n   blocks[j].offset=(ssize_t) i;\n   number_blocks=(size_t) j;\n+  image->columns=bounds.x2-bounds.x1;\n+  image->rows=bounds.y2-bounds.y1;\n+  status=SetImageExtent(image,image->columns,image->rows,exception);\n+  if (status == MagickFalse)\n+    return(DestroyImageList(image));\n   /*\n     Write stitches as SVG file.\n   */\n@@ -213,8 +218,8 @@\n   (void) FormatLocaleFile(file,\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" \"\n     \"xlink=\\\"http://www.w3.org/1999/xlink\\\" \"\n     \"ev=\\\"http://www.w3.org/2001/xml-events\\\" version=\\\"1.1\\\" \"\n-    \"baseProfile=\\\"full\\\" width=\\\"%g\\\" height=\\\"%g\\\">\\n\",bounds.x2-bounds.x1,\n-    bounds.y2-bounds.y1);\n+    \"baseProfile=\\\"full\\\" width=\\\"%g\\\" height=\\\"%g\\\">\\n\",(double)\n+    image->columns,(double) image->rows);\n   for (i=0; i < (ssize_t) number_blocks; i++)\n   {\n     offset=blocks[i].offset;",
        "diff_line_info": {
            "deleted_lines": [
                "  while (EOFBlob(image) != EOF)",
                "    \"baseProfile=\\\"full\\\" width=\\\"%g\\\" height=\\\"%g\\\">\\n\",bounds.x2-bounds.x1,",
                "    bounds.y2-bounds.y1);"
            ],
            "added_lines": [
                "  while (EOFBlob(image) == MagickFalse)",
                "  image->columns=bounds.x2-bounds.x1;",
                "  image->rows=bounds.y2-bounds.y1;",
                "  status=SetImageExtent(image,image->columns,image->rows,exception);",
                "  if (status == MagickFalse)",
                "    return(DestroyImageList(image));",
                "    \"baseProfile=\\\"full\\\" width=\\\"%g\\\" height=\\\"%g\\\">\\n\",(double)",
                "    image->columns,(double) image->rows);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11478",
        "func_name": "ImageMagick/ReadOneDJVUImage",
        "description": "The ReadOneDJVUImage function in coders/djvu.c in ImageMagick through 6.9.9-0 and 7.x through 7.0.6-1 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via a malformed DJVU image.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/78b819628b6a9429f0c33b72e695b4df0b32faea",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/528",
        "commit_text": "",
        "func_before": "static Image *ReadOneDJVUImage(LoadContext* lc,const int pagenum,\n  const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  ddjvu_page_type_t\n     type;\n\n  ddjvu_pageinfo_t info;\n  ddjvu_message_t *message;\n  Image *image;\n  int logging;\n  int tag;\n  MagickBooleanType status;\n\n        /* so, we know that the page is there! Get its dimension, and  */\n\n        /* Read one DJVU image */\n        image = lc->image;\n\n        /* register PixelPacket *q; */\n\n        logging=LogMagickEvent(CoderEvent,GetMagickModule(), \"  enter ReadOneDJVUImage()\");\n        (void) logging;\n\n#if DEBUG\n        printf(\"====  Loading the page %d\\n\", pagenum);\n#endif\n        lc->page = ddjvu_page_create_by_pageno(lc->document, pagenum); /*  0? */\n\n        /* pump data untill the page is ready for rendering. */\n        tag=(-1);\n        do {\n                while ((message = ddjvu_message_peek(lc->context)))\n                        {\n                                tag=process_message(message);\n                                if (tag == 0) break;\n                                ddjvu_message_pop(lc->context);\n                        }\n                /* fixme: maybe exit? */\n                /* if (lc->error) break; */\n\n                message = pump_data_until_message(lc,image);\n                if (message)\n                        do {\n                                tag=process_message(message);\n                                if (tag == 0) break;\n                                ddjvu_message_pop(lc->context);\n                        } while ((message = ddjvu_message_peek(lc->context)));\n        } while (!ddjvu_page_decoding_done(lc->page));\n\n        ddjvu_document_get_pageinfo(lc->document, pagenum, &info);\n\n        image->x_resolution = (float) info.dpi;\n        image->y_resolution =(float) info.dpi;\n        if (image_info->density != (char *) NULL)\n          {\n            int\n              flags;\n\n            GeometryInfo\n              geometry_info;\n\n            /*\n              Set rendering resolution.\n            */\n            flags=ParseGeometry(image_info->density,&geometry_info);\n            image->x_resolution=geometry_info.rho;\n            image->y_resolution=geometry_info.sigma;\n            if ((flags & SigmaValue) == 0)\n              image->y_resolution=image->x_resolution;\n            info.width=(int) (info.width*image->x_resolution/info.dpi);\n            info.height=(int) (info.height*image->y_resolution/info.dpi);\n            info.dpi=(int) MagickMax(image->x_resolution,image->y_resolution);\n          }\n        type = ddjvu_page_get_type(lc->page);\n\n        /* double -> float! */\n        /* image->gamma = (float)ddjvu_page_get_gamma(lc->page); */\n\n        /* mmc:  set  image->depth  */\n        /* mmc:  This from the type */\n\n        image->columns=(size_t) info.width;\n        image->rows=(size_t) info.height;\n\n        /* mmc: bitonal should be palettized, and compressed! */\n        if (type == DDJVU_PAGETYPE_BITONAL){\n                image->colorspace = GRAYColorspace;\n                image->storage_class = PseudoClass;\n                image->depth =  8UL;    /* i only support that? */\n                image->colors= 2;\n                if (AcquireImageColormap(image,image->colors) == MagickFalse)\n                  ThrowReaderException(ResourceLimitError,\n                   \"MemoryAllocationFailed\");\n        } else {\n                image->colorspace = RGBColorspace;\n                image->storage_class = DirectClass;\n                /* fixme:  MAGICKCORE_QUANTUM_DEPTH ?*/\n                image->depth =  8UL;    /* i only support that? */\n\n                image->matte = MagickTrue;\n                /* is this useful? */\n        }\n        status=SetImageExtent(image,image->columns,image->rows);\n        if (status == MagickFalse)\n          {\n            InheritException(exception,&image->exception);\n            return(DestroyImageList(image));\n          }\n#if DEBUG\n        printf(\"now filling %.20g x %.20g\\n\",(double) image->columns,(double)\n          image->rows);\n#endif\n\n\n#if 1                           /* per_line */\n\n        /* q = QueueAuthenticPixels(image,0,0,image->columns,image->rows); */\n        get_page_image(lc, lc->page, 0, 0, info.width, info.height, image_info);\n#else\n        int i;\n        for (i = 0;i< image->rows; i++)\n                {\n                        printf(\"%d\\n\",i);\n                        q = QueueAuthenticPixels(image,0,i,image->columns,1);\n                        get_page_line(lc, i, quantum_info);\n                        SyncAuthenticPixels(image);\n                }\n\n#endif /* per_line */\n\n\n#if DEBUG\n        printf(\"END: finished filling %.20g x %.20g\\n\",(double) image->columns,\n          (double) image->rows);\n#endif\n\n        if (!image->ping)\n          SyncImage(image);\n        /* indexes=GetAuthenticIndexQueue(image); */\n        /* mmc: ??? Convert PNM pixels to runlength-encoded MIFF packets. */\n        /* image->colors =  */\n\n        /* how is the line padding  / stride? */\n\n        if (lc->page) {\n                ddjvu_page_release(lc->page);\n                lc->page = NULL;\n        }\n\n        /* image->page.y=mng_info->y_off[mng_info->object_id]; */\n        if (tag == 0)\n          image=DestroyImage(image);\n        return image;\n        /* end of reading one DJVU page/image */\n}",
        "func": "static Image *ReadOneDJVUImage(LoadContext* lc,const int pagenum,\n  const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  ddjvu_page_type_t\n     type;\n\n  ddjvu_pageinfo_t info;\n  ddjvu_message_t *message;\n  Image *image;\n  int logging;\n  int tag;\n  MagickBooleanType status;\n\n        /* so, we know that the page is there! Get its dimension, and  */\n\n        /* Read one DJVU image */\n        image = lc->image;\n\n        /* register PixelPacket *q; */\n\n        logging=LogMagickEvent(CoderEvent,GetMagickModule(), \"  enter ReadOneDJVUImage()\");\n        (void) logging;\n\n#if DEBUG\n        printf(\"====  Loading the page %d\\n\", pagenum);\n#endif\n        lc->page = ddjvu_page_create_by_pageno(lc->document, pagenum); /*  0? */\n\n        /* pump data untill the page is ready for rendering. */\n        tag=(-1);\n        do {\n                while ((message = ddjvu_message_peek(lc->context)))\n                        {\n                                tag=process_message(message);\n                                if (tag == 0) break;\n                                ddjvu_message_pop(lc->context);\n                        }\n                /* fixme: maybe exit? */\n                /* if (lc->error) break; */\n\n                message = pump_data_until_message(lc,image);\n                if (message)\n                        do {\n                                tag=process_message(message);\n                                if (tag == 0) break;\n                                ddjvu_message_pop(lc->context);\n                        } while ((message = ddjvu_message_peek(lc->context)));\n                if (tag == 0) break;\n        } while (!ddjvu_page_decoding_done(lc->page));\n\n        ddjvu_document_get_pageinfo(lc->document, pagenum, &info);\n\n        image->x_resolution = (float) info.dpi;\n        image->y_resolution =(float) info.dpi;\n        if (image_info->density != (char *) NULL)\n          {\n            int\n              flags;\n\n            GeometryInfo\n              geometry_info;\n\n            /*\n              Set rendering resolution.\n            */\n            flags=ParseGeometry(image_info->density,&geometry_info);\n            image->x_resolution=geometry_info.rho;\n            image->y_resolution=geometry_info.sigma;\n            if ((flags & SigmaValue) == 0)\n              image->y_resolution=image->x_resolution;\n            info.width=(int) (info.width*image->x_resolution/info.dpi);\n            info.height=(int) (info.height*image->y_resolution/info.dpi);\n            info.dpi=(int) MagickMax(image->x_resolution,image->y_resolution);\n          }\n        type = ddjvu_page_get_type(lc->page);\n\n        /* double -> float! */\n        /* image->gamma = (float)ddjvu_page_get_gamma(lc->page); */\n\n        /* mmc:  set  image->depth  */\n        /* mmc:  This from the type */\n\n        image->columns=(size_t) info.width;\n        image->rows=(size_t) info.height;\n\n        /* mmc: bitonal should be palettized, and compressed! */\n        if (type == DDJVU_PAGETYPE_BITONAL){\n                image->colorspace = GRAYColorspace;\n                image->storage_class = PseudoClass;\n                image->depth =  8UL;    /* i only support that? */\n                image->colors= 2;\n                if (AcquireImageColormap(image,image->colors) == MagickFalse)\n                  ThrowReaderException(ResourceLimitError,\n                   \"MemoryAllocationFailed\");\n        } else {\n                image->colorspace = RGBColorspace;\n                image->storage_class = DirectClass;\n                /* fixme:  MAGICKCORE_QUANTUM_DEPTH ?*/\n                image->depth =  8UL;    /* i only support that? */\n\n                image->matte = MagickTrue;\n                /* is this useful? */\n        }\n        status=SetImageExtent(image,image->columns,image->rows);\n        if (status == MagickFalse)\n          {\n            InheritException(exception,&image->exception);\n            return(DestroyImageList(image));\n          }\n#if DEBUG\n        printf(\"now filling %.20g x %.20g\\n\",(double) image->columns,(double)\n          image->rows);\n#endif\n\n\n#if 1                           /* per_line */\n\n        /* q = QueueAuthenticPixels(image,0,0,image->columns,image->rows); */\n        get_page_image(lc, lc->page, 0, 0, info.width, info.height, image_info);\n#else\n        int i;\n        for (i = 0;i< image->rows; i++)\n                {\n                        printf(\"%d\\n\",i);\n                        q = QueueAuthenticPixels(image,0,i,image->columns,1);\n                        get_page_line(lc, i, quantum_info);\n                        SyncAuthenticPixels(image);\n                }\n\n#endif /* per_line */\n\n\n#if DEBUG\n        printf(\"END: finished filling %.20g x %.20g\\n\",(double) image->columns,\n          (double) image->rows);\n#endif\n\n        if (!image->ping)\n          SyncImage(image);\n        /* indexes=GetAuthenticIndexQueue(image); */\n        /* mmc: ??? Convert PNM pixels to runlength-encoded MIFF packets. */\n        /* image->colors =  */\n\n        /* how is the line padding  / stride? */\n\n        if (lc->page) {\n                ddjvu_page_release(lc->page);\n                lc->page = NULL;\n        }\n\n        /* image->page.y=mng_info->y_off[mng_info->object_id]; */\n        if (tag == 0)\n          image=DestroyImage(image);\n        return image;\n        /* end of reading one DJVU page/image */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -45,6 +45,7 @@\n                                 if (tag == 0) break;\n                                 ddjvu_message_pop(lc->context);\n                         } while ((message = ddjvu_message_peek(lc->context)));\n+                if (tag == 0) break;\n         } while (!ddjvu_page_decoding_done(lc->page));\n \n         ddjvu_document_get_pageinfo(lc->document, pagenum, &info);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "                if (tag == 0) break;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11478",
        "func_name": "ImageMagick/ReadDJVUImage",
        "description": "The ReadOneDJVUImage function in coders/djvu.c in ImageMagick through 6.9.9-0 and 7.x through 7.0.6-1 allows remote attackers to cause a denial of service (infinite loop and CPU consumption) via a malformed DJVU image.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/78b819628b6a9429f0c33b72e695b4df0b32faea",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/528",
        "commit_text": "",
        "func_before": "static Image *ReadDJVUImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const char\n    *url;\n\n  ddjvu_message_t\n    *message;\n\n  Image\n    *image,\n    *images;\n\n  int\n    logging,\n    use_cache;\n\n  LoadContext\n    *lc;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  /*\n   * Open image file.\n   */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n\n\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\", image_info->filename);\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n\n\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter ReadDJVUImage()\");\n  (void) logging;\n\n  image = AcquireImage(image_info); /* mmc: ?? */\n\n\n  lc = (LoadContext *) NULL;\n  status = OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    ThrowReaderException(FileOpenError,\"UnableToOpenFile\");\n  /*\n    Verify DJVU signature.\n  */\n#if 0\n  count = ReadBlob(image,8,(unsigned char *) magic_number);\n\n  /* IsDJVU(const unsigned char *magick,const size_t length) */\n  if (memcmp(magic_number,\"AT&TFORM\",8) != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n#endif\n\n\n  /*\n   * Allocate a LoadContext structure.\n   */\n  lc = (LoadContext *) AcquireMagickMemory(sizeof(*lc));\n  if (lc == NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n\n  /*\n   * Initialize members of the MngInfo structure.\n   */\n  (void) ResetMagickMemory(lc,0,sizeof(LoadContext));\n\n  lc->image = image;\n  lc->pages = 0;\n  lc->context = ddjvu_context_create(\"ImageMagick djvu loader\"); /* g_program_name */\n\n  ddjvu_cache_set_size(lc->context, 1); /* right? */\n  use_cache = 0;\n  /* document: here we don't have a filename, but, for the sake of generality, a FILE* ! */\n  url=\"http://www.imagemagick.org/fake.djvu\";\n  lc->document = ddjvu_document_create(lc->context, url, use_cache); /* don't cache */\n  ddjvu_document_set_user_data(lc->document, lc);\n\n\n  /* now we wait the message-request for data: */\n  message = ddjvu_message_wait(lc->context);\n\n  if (message->m_any.tag != DDJVU_NEWSTREAM) {\n          /* fixme: the djvu context, document! */\n\n          ddjvu_document_release(lc->document);\n          ddjvu_context_release(lc->context);\n\n          RelinquishMagickMemory(lc);\n\n          ThrowReaderException(ResourceLimitError,\"Djvu initial message: unexpected type\");\n          return NULL;    /* error! */\n  };\n\n  lc->streamid = message->m_newstream.streamid;\n  ddjvu_message_pop(lc->context);\n\n  message = pump_data_until_message(lc,image);\n  /* now process the messages: */\n\n\n  if (message) do {\n          process_message(message);\n          ddjvu_message_pop(lc->context);\n  } while ((message = ddjvu_message_peek(lc->context)));\n\n  /* fixme: i hope we have not read any messages pertinent(?) related to the page itself!  */\n\n  while (lc->pages == 0) {\n          message = ddjvu_message_wait(lc->context);\n          process_message(message);\n          ddjvu_message_pop(lc->context);\n  }\n\n  images=NewImageList();\n  i=0;\n  if (image_info->number_scenes != 0)\n    i=image_info->scene;\n  for ( ; i < (ssize_t) lc->pages; i++)\n  {\n    image=ReadOneDJVUImage(lc,i,image_info,exception);\n    if (image == (Image *) NULL)\n      break;\n    image->scene=i;\n    AppendImageToList(&images,CloneImageList(image,exception));\n    images->extent=GetBlobSize(image);\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n  }\n  djvu_close_lc(lc);\n  (void) CloseBlob(images);\n  if (image != (Image *) NULL)\n    image=DestroyImageList(image);\n\n#if 0\n  if ((image->page.width == 0) && (image->page.height == 0))\n    {\n      image->page.width = image->columns+image->page.x;\n      image->page.height = image->rows+image->page.y;\n    }\n  if (image->columns == 0 || image->rows == 0)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"exit ReadDJVUImage() with error.\");\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"exit ReadDJVUImage()\");\n#endif\n\n\n  return(GetFirstImageInList(images));\n}",
        "func": "static Image *ReadDJVUImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const char\n    *url;\n\n  ddjvu_message_t\n    *message;\n\n  Image\n    *image,\n    *images;\n\n  int\n    logging,\n    use_cache;\n\n  LoadContext\n    *lc;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  /*\n   * Open image file.\n   */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n\n\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\", image_info->filename);\n\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n\n\n  logging = LogMagickEvent(CoderEvent,GetMagickModule(),\"enter ReadDJVUImage()\");\n  (void) logging;\n\n  image = AcquireImage(image_info); /* mmc: ?? */\n\n\n  lc = (LoadContext *) NULL;\n  status = OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    ThrowReaderException(FileOpenError,\"UnableToOpenFile\");\n  /*\n    Verify DJVU signature.\n  */\n#if 0\n  count = ReadBlob(image,8,(unsigned char *) magic_number);\n\n  /* IsDJVU(const unsigned char *magick,const size_t length) */\n  if (memcmp(magic_number,\"AT&TFORM\",8) != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n#endif\n\n\n  /*\n   * Allocate a LoadContext structure.\n   */\n  lc = (LoadContext *) AcquireMagickMemory(sizeof(*lc));\n  if (lc == NULL)\n    ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n\n\n  /*\n   * Initialize members of the MngInfo structure.\n   */\n  (void) ResetMagickMemory(lc,0,sizeof(LoadContext));\n\n  lc->image = image;\n  lc->pages = 0;\n  lc->context = ddjvu_context_create(\"ImageMagick djvu loader\"); /* g_program_name */\n\n  ddjvu_cache_set_size(lc->context, 1); /* right? */\n  use_cache = 0;\n  /* document: here we don't have a filename, but, for the sake of generality, a FILE* ! */\n  url=\"http://www.imagemagick.org/fake.djvu\";\n  lc->document = ddjvu_document_create(lc->context, url, use_cache); /* don't cache */\n  ddjvu_document_set_user_data(lc->document, lc);\n\n\n  /* now we wait the message-request for data: */\n  message = ddjvu_message_wait(lc->context);\n\n  if (message->m_any.tag != DDJVU_NEWSTREAM) {\n          /* fixme: the djvu context, document! */\n\n          ddjvu_document_release(lc->document);\n          ddjvu_context_release(lc->context);\n\n          RelinquishMagickMemory(lc);\n\n          ThrowReaderException(ResourceLimitError,\"Djvu initial message: unexpected type\");\n          return NULL;    /* error! */\n  };\n\n  lc->streamid = message->m_newstream.streamid;\n  ddjvu_message_pop(lc->context);\n\n  message = pump_data_until_message(lc,image);\n  /* now process the messages: */\n\n\n  if (message) do {\n          process_message(message);\n          ddjvu_message_pop(lc->context);\n  } while ((message = ddjvu_message_peek(lc->context)));\n\n  /* fixme: i hope we have not read any messages pertinent(?) related to the page itself!  */\n\n  while (lc->pages == 0) {\n          message = ddjvu_message_wait(lc->context);\n          process_message(message);\n          ddjvu_message_pop(lc->context);\n  }\n\n  images=NewImageList();\n  i=0;\n  if (image_info->number_scenes != 0)\n    i=image_info->scene;\n  for ( ; i < (ssize_t) lc->pages; i++)\n  {\n    image=ReadOneDJVUImage(lc,i,image_info,exception);\n    if (image == (Image *) NULL)\n      break;\n    image->scene=i;\n    AppendImageToList(&images,CloneImageList(image,exception));\n    images->extent=GetBlobSize(image);\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n  }\n  djvu_close_lc(lc);\n  if (images != (Image *) NULL)\n    (void) CloseBlob(images);\n  if (image != (Image *) NULL)\n    image=DestroyImageList(image);\n\n#if 0\n  if ((image->page.width == 0) && (image->page.height == 0))\n    {\n      image->page.width = image->columns+image->page.x;\n      image->page.height = image->rows+image->page.y;\n    }\n  if (image->columns == 0 || image->rows == 0)\n    {\n      if (logging != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"exit ReadDJVUImage() with error.\");\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n    }\n\n  if (logging != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"exit ReadDJVUImage()\");\n#endif\n\n\n  return(GetFirstImageInList(images));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -137,7 +137,8 @@\n         break;\n   }\n   djvu_close_lc(lc);\n-  (void) CloseBlob(images);\n+  if (images != (Image *) NULL)\n+    (void) CloseBlob(images);\n   if (image != (Image *) NULL)\n     image=DestroyImageList(image);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "  (void) CloseBlob(images);"
            ],
            "added_lines": [
                "  if (images != (Image *) NULL)",
                "    (void) CloseBlob(images);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11523",
        "func_name": "ImageMagick/ReadTXTImage",
        "description": "The ReadTXTImage function in coders/txt.c in ImageMagick through 6.9.9-0 and 7.x through 7.0.6-1 allows remote attackers to cause a denial of service (infinite loop) via a crafted file, because the end-of-file condition is not considered.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/a8f9c2aabed37cd6a728532d1aed13ae0f3dfd78",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/591",
        "commit_text": "",
        "func_before": "static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    colorspace[MaxTextExtent],\n    text[MaxTextExtent];\n\n  Image\n    *image;\n\n  IndexPacket\n    *indexes;\n\n  long\n    x_offset,\n    y_offset;\n\n  MagickBooleanType\n    status;\n\n  MagickPixelPacket\n    pixel;\n\n  QuantumAny\n    range;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  ssize_t\n    count,\n    type,\n    y;\n\n  unsigned long\n    depth,\n    height,\n    max_value,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) ResetMagickMemory(text,0,sizeof(text));\n  (void) ReadBlobString(image,text);\n  if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    width=0;\n    height=0;\n    max_value=0;\n    *colorspace='\\0';\n    count=(ssize_t) sscanf(text+32,\"%lu,%lu,%lu,%s\",&width,&height,&max_value,\n      colorspace);\n    if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->columns=width;\n    image->rows=height;\n    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;\n    image->depth=depth;\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    LocaleLower(colorspace);\n    i=(ssize_t) strlen(colorspace)-1;\n    image->matte=MagickFalse;\n    if ((i > 0) && (colorspace[i] == 'a'))\n      {\n        colorspace[i]='\\0';\n        image->matte=MagickTrue;\n      }\n    type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);\n    if (type < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->colorspace=(ColorspaceType) type;\n    (void) ResetMagickMemory(&pixel,0,sizeof(pixel));\n    (void) SetImageBackgroundColor(image);\n    range=GetQuantumRange(image->depth);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      double\n        blue,\n        green,\n        index,\n        opacity,\n        red;\n\n      red=0.0;\n      green=0.0;\n      blue=0.0;\n      index=0.0;\n      opacity=0.0;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        if (ReadBlobString(image,text) == (char *) NULL)\n          break;\n        switch (image->colorspace)\n        {\n          case GRAYColorspace:\n          {\n            if (image->matte != MagickFalse)\n              {\n                (void) sscanf(text,\"%ld,%ld: (%lf%*[%,]%lf%*[%,]\",&x_offset,\n                  &y_offset,&red,&opacity);\n                green=red;\n                blue=red;\n                break;\n              }\n            (void) sscanf(text,\"%ld,%ld: (%lf%*[%,]\",&x_offset,&y_offset,&red);\n            green=red;\n            blue=red;\n            break;\n          }\n          case CMYKColorspace:\n          {\n            if (image->matte != MagickFalse)\n              {\n                (void) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&index,&opacity);\n                break;\n              }\n            (void) sscanf(text,\n              \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue,&index);\n            break;\n          }\n          default:\n          {\n            if (image->matte != MagickFalse)\n              {\n                (void) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&opacity);\n                break;\n              }\n            (void) sscanf(text,\"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n              &x_offset,&y_offset,&red,&green,&blue);\n            break;\n          }\n        }\n        if (strchr(text,'%') != (char *) NULL)\n          {\n            red*=0.01*range;\n            green*=0.01*range;\n            blue*=0.01*range;\n            index*=0.01*range;\n            opacity*=0.01*range;\n          }\n        if (image->colorspace == LabColorspace)\n          {\n            green+=(range+1)/2.0;\n            blue+=(range+1)/2.0;\n          }\n        pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),\n          range);\n        pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),\n          range);\n        pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),\n          range);\n        pixel.index=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (index+0.5),\n          range);\n        pixel.opacity=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (opacity+\n          0.5),range);\n        q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,\n          exception);\n        if (q == (PixelPacket *) NULL)\n          continue;\n        SetPixelRed(q,pixel.red);\n        SetPixelGreen(q,pixel.green);\n        SetPixelBlue(q,pixel.blue);\n        if (image->colorspace == CMYKColorspace)\n          {\n            indexes=GetAuthenticIndexQueue(image);\n            SetPixelIndex(indexes,pixel.index);\n          }\n        if (image->matte != MagickFalse)\n          SetPixelAlpha(q,pixel.opacity);\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n    }\n    (void) ReadBlobString(image,text);\n    if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    colorspace[MaxTextExtent],\n    text[MaxTextExtent];\n\n  Image\n    *image;\n\n  IndexPacket\n    *indexes;\n\n  long\n    x_offset,\n    y_offset;\n\n  MagickBooleanType\n    status;\n\n  MagickPixelPacket\n    pixel;\n\n  QuantumAny\n    range;\n\n  register ssize_t\n    i,\n    x;\n\n  register PixelPacket\n    *q;\n\n  ssize_t\n    count,\n    type,\n    y;\n\n  unsigned long\n    depth,\n    height,\n    max_value,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  image=AcquireImage(image_info);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) ResetMagickMemory(text,0,sizeof(text));\n  (void) ReadBlobString(image,text);\n  if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    width=0;\n    height=0;\n    max_value=0;\n    *colorspace='\\0';\n    count=(ssize_t) sscanf(text+32,\"%lu,%lu,%lu,%s\",&width,&height,&max_value,\n      colorspace);\n    if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->columns=width;\n    image->rows=height;\n    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;\n    image->depth=depth;\n    status=SetImageExtent(image,image->columns,image->rows);\n    if (status == MagickFalse)\n      {\n        InheritException(exception,&image->exception);\n        return(DestroyImageList(image));\n      }\n    LocaleLower(colorspace);\n    i=(ssize_t) strlen(colorspace)-1;\n    image->matte=MagickFalse;\n    if ((i > 0) && (colorspace[i] == 'a'))\n      {\n        colorspace[i]='\\0';\n        image->matte=MagickTrue;\n      }\n    type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);\n    if (type < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->colorspace=(ColorspaceType) type;\n    (void) ResetMagickMemory(&pixel,0,sizeof(pixel));\n    (void) SetImageBackgroundColor(image);\n    range=GetQuantumRange(image->depth);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      double\n        blue,\n        green,\n        index,\n        opacity,\n        red;\n\n      red=0.0;\n      green=0.0;\n      blue=0.0;\n      index=0.0;\n      opacity=0.0;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        if (ReadBlobString(image,text) == (char *) NULL)\n          break;\n        switch (image->colorspace)\n        {\n          case GRAYColorspace:\n          {\n            if (image->matte != MagickFalse)\n              {\n                (void) sscanf(text,\"%ld,%ld: (%lf%*[%,]%lf%*[%,]\",&x_offset,\n                  &y_offset,&red,&opacity);\n                green=red;\n                blue=red;\n                break;\n              }\n            (void) sscanf(text,\"%ld,%ld: (%lf%*[%,]\",&x_offset,&y_offset,&red);\n            green=red;\n            blue=red;\n            break;\n          }\n          case CMYKColorspace:\n          {\n            if (image->matte != MagickFalse)\n              {\n                (void) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&index,&opacity);\n                break;\n              }\n            (void) sscanf(text,\n              \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue,&index);\n            break;\n          }\n          default:\n          {\n            if (image->matte != MagickFalse)\n              {\n                (void) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&opacity);\n                break;\n              }\n            (void) sscanf(text,\"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n              &x_offset,&y_offset,&red,&green,&blue);\n            break;\n          }\n        }\n        if (strchr(text,'%') != (char *) NULL)\n          {\n            red*=0.01*range;\n            green*=0.01*range;\n            blue*=0.01*range;\n            index*=0.01*range;\n            opacity*=0.01*range;\n          }\n        if (image->colorspace == LabColorspace)\n          {\n            green+=(range+1)/2.0;\n            blue+=(range+1)/2.0;\n          }\n        pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),\n          range);\n        pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),\n          range);\n        pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),\n          range);\n        pixel.index=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (index+0.5),\n          range);\n        pixel.opacity=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (opacity+\n          0.5),range);\n        q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,\n          exception);\n        if (q == (PixelPacket *) NULL)\n          continue;\n        SetPixelRed(q,pixel.red);\n        SetPixelGreen(q,pixel.green);\n        SetPixelBlue(q,pixel.blue);\n        if (image->colorspace == CMYKColorspace)\n          {\n            indexes=GetAuthenticIndexQueue(image);\n            SetPixelIndex(indexes,pixel.index);\n          }\n        if (image->matte != MagickFalse)\n          SetPixelAlpha(q,pixel.opacity);\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n    }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    (void) ReadBlobString(image,text);\n    if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -201,6 +201,12 @@\n           break;\n       }\n     }\n+    if (EOFBlob(image) != MagickFalse)\n+      {\n+        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n+          image->filename);\n+        break;\n+      }\n     (void) ReadBlobString(image,text);\n     if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)\n       {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (EOFBlob(image) != MagickFalse)",
                "      {",
                "        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",",
                "          image->filename);",
                "        break;",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-13756",
        "func_name": "sleuthkit/dos_load_ext_table",
        "description": "In The Sleuth Kit (TSK) 4.4.2, opening a crafted disk image triggers infinite recursion in dos_load_ext_table() in tsk/vs/dos.c in libtskvs.a, as demonstrated by mmls.",
        "git_url": "https://github.com/sleuthkit/sleuthkit/commit/5d187980cf2f4d320670f9f3ebf6e08966bd3d35",
        "commit_title": "Avoid infinite loop in dos_load_ext_table(). (Fixes: #914)",
        "commit_text": " If dos_load_ext_table() was called with a zero offset, the loop would repeat the exact same conditions ad infinitum.",
        "func_before": "static uint8_t\ndos_load_ext_table(TSK_VS_INFO * vs, TSK_DADDR_T sect_cur,\n    TSK_DADDR_T sect_ext_base, int table)\n{\n    dos_sect *sect;\n    char *sect_buf;\n    int i;\n    char *table_str;\n    ssize_t cnt;\n    TSK_DADDR_T max_addr = (vs->img_info->size - vs->offset) / vs->block_size;  // max sector\n\n    if (tsk_verbose)\n        tsk_fprintf(stderr,\n            \"dos_load_ext: Table Sector: %\" PRIuDADDR\n            \", Primary Base Sector: %\" PRIuDADDR \"\\n\", sect_cur,\n            sect_ext_base);\n\n    if ((sect_buf = tsk_malloc(vs->block_size)) == NULL)\n        return 1;\n    sect = (dos_sect *) sect_buf;\n\n    /* Read the partition table sector */\n    cnt = tsk_vs_read_block(vs, sect_cur, sect_buf, vs->block_size);\n    if (cnt != vs->block_size) {\n        if (cnt >= 0) {\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_VS_READ);\n        }\n        tsk_error_set_errstr2(\"Extended DOS table sector %\" PRIuDADDR,\n            sect_cur);\n        free(sect_buf);\n        return 1;\n    }\n\n    /* Sanity Check */\n    if (tsk_getu16(vs->endian, sect->magic) != DOS_MAGIC) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_VS_MAGIC);\n        tsk_error_set_errstr(\"Extended DOS partition table in sector %\"\n            PRIuDADDR, sect_cur);\n        free(sect_buf);\n        return 1;\n    }\n\n    /* Add an entry of 1 length for the table  to the internal structure */\n    if ((table_str = tsk_malloc(32)) == NULL) {\n        free(sect_buf);\n        return 1;\n    }\n\n    snprintf(table_str, 32, \"Extended Table (#%d)\", table);\n    if (NULL == tsk_vs_part_add(vs, (TSK_DADDR_T) sect_cur,\n            (TSK_DADDR_T) 1, TSK_VS_PART_FLAG_META, table_str, table,\n            -1)) {\n        free(sect_buf);\n        return 1;\n    }\n\n    /* Cycle through the four partitions in the table\n     *\n     * When another extended partition is found, it is processed\n     * inside of the loop\n     */\n    for (i = 0; i < 4; i++) {\n        dos_part *part = &sect->ptable[i];\n\n        /* Get the starting sector and size, we currently\n         * ignore CHS */\n        uint32_t part_start = tsk_getu32(vs->endian, part->start_sec);\n        uint32_t part_size = tsk_getu32(vs->endian, part->size_sec);\n\n        if (tsk_verbose)\n            tsk_fprintf(stderr,\n                \"load_ext: %d:%d    Start: %\" PRIu32 \"   Size: %\"\n                PRIu32 \"  Type: %d\\n\", table, i, part_start, part_size,\n                part->ptype);\n\n        if (part_size == 0)\n            continue;\n\n        /* partitions are addressed differently\n         * in extended partitions */\n        if (dos_is_ext(part->ptype)) {\n\n            /* part start is added to the start of the\n             * first extended partition (the primary\n             * extended partition) */\n\n            if (NULL == tsk_vs_part_add(vs,\n                    (TSK_DADDR_T) (sect_ext_base + part_start),\n                    (TSK_DADDR_T) part_size, TSK_VS_PART_FLAG_META,\n                    dos_get_desc(part->ptype), table, i)) {\n                free(sect_buf);\n                return 1;\n            }\n\n            if (sect_ext_base + part_start > max_addr) {\n                if (tsk_verbose)\n                    tsk_fprintf(stderr,\n                        \"Starting sector %\" PRIuDADDR\n                        \" of extended partition too large for image\\n\",\n                        sect_ext_base + part_start);\n            }\n            /* Process the extended partition */\n            else if (dos_load_ext_table(vs, sect_ext_base + part_start,\n                    sect_ext_base, table + 1)) {\n                free(sect_buf);\n                return 1;\n            }\n        }\n\n        else {\n            /* part_start is added to the start of the\n             * current partition for the actual\n             * starting location */\n\n            // we ignore the max_addr checks on extended partitions...\n\n            if (NULL == tsk_vs_part_add(vs,\n                    (TSK_DADDR_T) (sect_cur + part_start),\n                    (TSK_DADDR_T) part_size, TSK_VS_PART_FLAG_ALLOC,\n                    dos_get_desc(part->ptype), table, i)) {\n                free(sect_buf);\n                return 1;\n            }\n        }\n    }\n\n    free(sect_buf);\n    return 0;\n}",
        "func": "static uint8_t\ndos_load_ext_table(TSK_VS_INFO * vs, TSK_DADDR_T sect_cur,\n    TSK_DADDR_T sect_ext_base, int table)\n{\n    dos_sect *sect;\n    char *sect_buf;\n    int i;\n    char *table_str;\n    ssize_t cnt;\n    TSK_DADDR_T max_addr = (vs->img_info->size - vs->offset) / vs->block_size;  // max sector\n\n    if (tsk_verbose)\n        tsk_fprintf(stderr,\n            \"dos_load_ext: Table Sector: %\" PRIuDADDR\n            \", Primary Base Sector: %\" PRIuDADDR \"\\n\", sect_cur,\n            sect_ext_base);\n\n    if ((sect_buf = tsk_malloc(vs->block_size)) == NULL)\n        return 1;\n    sect = (dos_sect *) sect_buf;\n\n    /* Read the partition table sector */\n    cnt = tsk_vs_read_block(vs, sect_cur, sect_buf, vs->block_size);\n    if (cnt != vs->block_size) {\n        if (cnt >= 0) {\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_VS_READ);\n        }\n        tsk_error_set_errstr2(\"Extended DOS table sector %\" PRIuDADDR,\n            sect_cur);\n        free(sect_buf);\n        return 1;\n    }\n\n    /* Sanity Check */\n    if (tsk_getu16(vs->endian, sect->magic) != DOS_MAGIC) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_VS_MAGIC);\n        tsk_error_set_errstr(\"Extended DOS partition table in sector %\"\n            PRIuDADDR, sect_cur);\n        free(sect_buf);\n        return 1;\n    }\n\n    /* Add an entry of 1 length for the table  to the internal structure */\n    if ((table_str = tsk_malloc(32)) == NULL) {\n        free(sect_buf);\n        return 1;\n    }\n\n    snprintf(table_str, 32, \"Extended Table (#%d)\", table);\n    if (NULL == tsk_vs_part_add(vs, (TSK_DADDR_T) sect_cur,\n            (TSK_DADDR_T) 1, TSK_VS_PART_FLAG_META, table_str, table,\n            -1)) {\n        free(sect_buf);\n        return 1;\n    }\n\n    /* Cycle through the four partitions in the table\n     *\n     * When another extended partition is found, it is processed\n     * inside of the loop\n     */\n    for (i = 0; i < 4; i++) {\n        dos_part *part = &sect->ptable[i];\n\n        /* Get the starting sector and size, we currently\n         * ignore CHS */\n        uint32_t part_start = tsk_getu32(vs->endian, part->start_sec);\n        uint32_t part_size = tsk_getu32(vs->endian, part->size_sec);\n\n        if (tsk_verbose)\n            tsk_fprintf(stderr,\n                \"load_ext: %d:%d    Start: %\" PRIu32 \"   Size: %\"\n                PRIu32 \"  Type: %d\\n\", table, i, part_start, part_size,\n                part->ptype);\n\n        /* part_start == 0 would cause infinite recursion */\n        if (part_size == 0 || part_start == 0)\n            continue;\n\n        /* partitions are addressed differently\n         * in extended partitions */\n        if (dos_is_ext(part->ptype)) {\n\n            /* part start is added to the start of the\n             * first extended partition (the primary\n             * extended partition) */\n\n            if (NULL == tsk_vs_part_add(vs,\n                    (TSK_DADDR_T) (sect_ext_base + part_start),\n                    (TSK_DADDR_T) part_size, TSK_VS_PART_FLAG_META,\n                    dos_get_desc(part->ptype), table, i)) {\n                free(sect_buf);\n                return 1;\n            }\n\n            if (sect_ext_base + part_start > max_addr) {\n                if (tsk_verbose)\n                    tsk_fprintf(stderr,\n                        \"Starting sector %\" PRIuDADDR\n                        \" of extended partition too large for image\\n\",\n                        sect_ext_base + part_start);\n            }\n            /* Process the extended partition */\n            else if (dos_load_ext_table(vs, sect_ext_base + part_start,\n                    sect_ext_base, table + 1)) {\n                free(sect_buf);\n                return 1;\n            }\n        }\n\n        else {\n            /* part_start is added to the start of the\n             * current partition for the actual\n             * starting location */\n\n            // we ignore the max_addr checks on extended partitions...\n\n            if (NULL == tsk_vs_part_add(vs,\n                    (TSK_DADDR_T) (sect_cur + part_start),\n                    (TSK_DADDR_T) part_size, TSK_VS_PART_FLAG_ALLOC,\n                    dos_get_desc(part->ptype), table, i)) {\n                free(sect_buf);\n                return 1;\n            }\n        }\n    }\n\n    free(sect_buf);\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -75,7 +75,8 @@\n                 PRIu32 \"  Type: %d\\n\", table, i, part_start, part_size,\n                 part->ptype);\n \n-        if (part_size == 0)\n+        /* part_start == 0 would cause infinite recursion */\n+        if (part_size == 0 || part_start == 0)\n             continue;\n \n         /* partitions are addressed differently",
        "diff_line_info": {
            "deleted_lines": [
                "        if (part_size == 0)"
            ],
            "added_lines": [
                "        /* part_start == 0 would cause infinite recursion */",
                "        if (part_size == 0 || part_start == 0)"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14058",
        "func_name": "ffmpeg/read_data",
        "description": "In FFmpeg 2.4 and 3.3.3, the read_data function in libavformat/hls.c does not restrict reload attempts for an insufficient list, which allows remote attackers to cause a denial of service (infinite loop).",
        "git_url": "https://github.com/FFmpeg/FFmpeg/commit/7ba100d3e6e8b1e5d5342feb960a7f081d6e15af",
        "commit_title": "avformat/hls: Fix DoS due to infinite loop",
        "commit_text": "  The default max iteration count of 1000 is arbitrary and ideas for a better solution are welcome   Previous version reviewed-by: Steven Liu <lingjiujianke@gmail.com> (cherry picked from commit 7ec414892ddcad88313848494b6fc5f437c9ca4a)",
        "func_before": "static int read_data(void *opaque, uint8_t *buf, int buf_size)\n{\n    struct playlist *v = opaque;\n    HLSContext *c = v->parent->priv_data;\n    int ret, i;\n    int just_opened = 0;\n\nrestart:\n    if (!v->needed)\n        return AVERROR_EOF;\n\n    if (!v->input) {\n        int64_t reload_interval;\n\n        /* Check that the playlist is still needed before opening a new\n         * segment. */\n        if (v->ctx && v->ctx->nb_streams &&\n            v->parent->nb_streams >= v->stream_offset + v->ctx->nb_streams) {\n            v->needed = 0;\n            for (i = v->stream_offset; i < v->stream_offset + v->ctx->nb_streams;\n                i++) {\n                if (v->parent->streams[i]->discard < AVDISCARD_ALL)\n                    v->needed = 1;\n            }\n        }\n        if (!v->needed) {\n            av_log(v->parent, AV_LOG_INFO, \"No longer receiving playlist %d\\n\",\n                v->index);\n            return AVERROR_EOF;\n        }\n\n        /* If this is a live stream and the reload interval has elapsed since\n         * the last playlist reload, reload the playlists now. */\n        reload_interval = default_reload_interval(v);\n\nreload:\n        if (!v->finished &&\n            av_gettime() - v->last_load_time >= reload_interval) {\n            if ((ret = parse_playlist(c, v->url, v, NULL)) < 0) {\n                av_log(v->parent, AV_LOG_WARNING, \"Failed to reload playlist %d\\n\",\n                       v->index);\n                return ret;\n            }\n            /* If we need to reload the playlist again below (if\n             * there's still no more segments), switch to a reload\n             * interval of half the target duration. */\n            reload_interval = v->target_duration / 2;\n        }\n        if (v->cur_seq_no < v->start_seq_no) {\n            av_log(NULL, AV_LOG_WARNING,\n                   \"skipping %d segments ahead, expired from playlists\\n\",\n                   v->start_seq_no - v->cur_seq_no);\n            v->cur_seq_no = v->start_seq_no;\n        }\n        if (v->cur_seq_no >= v->start_seq_no + v->n_segments) {\n            if (v->finished)\n                return AVERROR_EOF;\n            while (av_gettime() - v->last_load_time < reload_interval) {\n                if (ff_check_interrupt(c->interrupt_callback))\n                    return AVERROR_EXIT;\n                av_usleep(100*1000);\n            }\n            /* Enough time has elapsed since the last reload */\n            goto reload;\n        }\n\n        ret = open_input(c, v);\n        if (ret < 0) {\n            av_log(v->parent, AV_LOG_WARNING, \"Failed to open segment of playlist %d\\n\",\n                   v->index);\n            return ret;\n        }\n        just_opened = 1;\n    }\n\n    ret = read_from_url(v, buf, buf_size, READ_NORMAL);\n    if (ret > 0) {\n        if (just_opened && v->is_id3_timestamped != 0) {\n            /* Intercept ID3 tags here, elementary audio streams are required\n             * to convey timestamps using them in the beginning of each segment. */\n            intercept_id3(v, buf, buf_size, &ret);\n        }\n\n        return ret;\n    }\n    ffurl_close(v->input);\n    v->input = NULL;\n    v->cur_seq_no++;\n\n    c->cur_seq_no = v->cur_seq_no;\n\n    goto restart;\n}",
        "func": "static int read_data(void *opaque, uint8_t *buf, int buf_size)\n{\n    struct playlist *v = opaque;\n    HLSContext *c = v->parent->priv_data;\n    int ret, i;\n    int just_opened = 0;\n    int reload_count = 0;\n\nrestart:\n    if (!v->needed)\n        return AVERROR_EOF;\n\n    if (!v->input) {\n        int64_t reload_interval;\n\n        /* Check that the playlist is still needed before opening a new\n         * segment. */\n        if (v->ctx && v->ctx->nb_streams &&\n            v->parent->nb_streams >= v->stream_offset + v->ctx->nb_streams) {\n            v->needed = 0;\n            for (i = v->stream_offset; i < v->stream_offset + v->ctx->nb_streams;\n                i++) {\n                if (v->parent->streams[i]->discard < AVDISCARD_ALL)\n                    v->needed = 1;\n            }\n        }\n        if (!v->needed) {\n            av_log(v->parent, AV_LOG_INFO, \"No longer receiving playlist %d\\n\",\n                v->index);\n            return AVERROR_EOF;\n        }\n\n        /* If this is a live stream and the reload interval has elapsed since\n         * the last playlist reload, reload the playlists now. */\n        reload_interval = default_reload_interval(v);\n\nreload:\n        reload_count++;\n        if (reload_count > c->max_reload)\n            return AVERROR_EOF;\n        if (!v->finished &&\n            av_gettime() - v->last_load_time >= reload_interval) {\n            if ((ret = parse_playlist(c, v->url, v, NULL)) < 0) {\n                av_log(v->parent, AV_LOG_WARNING, \"Failed to reload playlist %d\\n\",\n                       v->index);\n                return ret;\n            }\n            /* If we need to reload the playlist again below (if\n             * there's still no more segments), switch to a reload\n             * interval of half the target duration. */\n            reload_interval = v->target_duration / 2;\n        }\n        if (v->cur_seq_no < v->start_seq_no) {\n            av_log(NULL, AV_LOG_WARNING,\n                   \"skipping %d segments ahead, expired from playlists\\n\",\n                   v->start_seq_no - v->cur_seq_no);\n            v->cur_seq_no = v->start_seq_no;\n        }\n        if (v->cur_seq_no >= v->start_seq_no + v->n_segments) {\n            if (v->finished)\n                return AVERROR_EOF;\n            while (av_gettime() - v->last_load_time < reload_interval) {\n                if (ff_check_interrupt(c->interrupt_callback))\n                    return AVERROR_EXIT;\n                av_usleep(100*1000);\n            }\n            /* Enough time has elapsed since the last reload */\n            goto reload;\n        }\n\n        ret = open_input(c, v);\n        if (ret < 0) {\n            av_log(v->parent, AV_LOG_WARNING, \"Failed to open segment of playlist %d\\n\",\n                   v->index);\n            return ret;\n        }\n        just_opened = 1;\n    }\n\n    ret = read_from_url(v, buf, buf_size, READ_NORMAL);\n    if (ret > 0) {\n        if (just_opened && v->is_id3_timestamped != 0) {\n            /* Intercept ID3 tags here, elementary audio streams are required\n             * to convey timestamps using them in the beginning of each segment. */\n            intercept_id3(v, buf, buf_size, &ret);\n        }\n\n        return ret;\n    }\n    ffurl_close(v->input);\n    v->input = NULL;\n    v->cur_seq_no++;\n\n    c->cur_seq_no = v->cur_seq_no;\n\n    goto restart;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,7 @@\n     HLSContext *c = v->parent->priv_data;\n     int ret, i;\n     int just_opened = 0;\n+    int reload_count = 0;\n \n restart:\n     if (!v->needed)\n@@ -34,6 +35,9 @@\n         reload_interval = default_reload_interval(v);\n \n reload:\n+        reload_count++;\n+        if (reload_count > c->max_reload)\n+            return AVERROR_EOF;\n         if (!v->finished &&\n             av_gettime() - v->last_load_time >= reload_interval) {\n             if ((ret = parse_playlist(c, v->url, v, NULL)) < 0) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    int reload_count = 0;",
                "        reload_count++;",
                "        if (reload_count > c->max_reload)",
                "            return AVERROR_EOF;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-42715",
        "func_name": "nothings/stb/stbi__hdr_load",
        "description": "An issue was discovered in stb stb_image.h 1.33 through 2.27. The HDR loader parsed truncated end-of-file RLE scanlines as an infinite sequence of zero-length runs. An attacker could potentially have caused denial of service in applications using stb_image by submitting crafted HDR files.",
        "git_url": "https://github.com/nothings/stb/commit/2a02ff76b5f4d2a0b01f0eee289c47e0901c49b6",
        "commit_title": "Fixes two stb_image issues that could occur with specially constructed HDR and PGM files.",
        "commit_text": "",
        "func_before": "static float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   char buffer[STBI__HDR_BUFLEN];\n   char *token;\n   int valid = 0;\n   int width, height;\n   stbi_uc *scanline;\n   float *hdr_data;\n   int len;\n   unsigned char count, value;\n   int i, j, k, c1,c2, z;\n   const char *headerToken;\n   STBI_NOTUSED(ri);\n\n   // Check identifier\n   headerToken = stbi__hdr_gettoken(s,buffer);\n   if (strcmp(headerToken, \"#?RADIANCE\") != 0 && strcmp(headerToken, \"#?RGBE\") != 0)\n      return stbi__errpf(\"not HDR\", \"Corrupt HDR image\");\n\n   // Parse header\n   for(;;) {\n      token = stbi__hdr_gettoken(s,buffer);\n      if (token[0] == 0) break;\n      if (strcmp(token, \"FORMAT=32-bit_rle_rgbe\") == 0) valid = 1;\n   }\n\n   if (!valid)    return stbi__errpf(\"unsupported format\", \"Unsupported HDR format\");\n\n   // Parse width and height\n   // can't use sscanf() if we're not using stdio!\n   token = stbi__hdr_gettoken(s,buffer);\n   if (strncmp(token, \"-Y \", 3))  return stbi__errpf(\"unsupported data layout\", \"Unsupported HDR format\");\n   token += 3;\n   height = (int) strtol(token, &token, 10);\n   while (*token == ' ') ++token;\n   if (strncmp(token, \"+X \", 3))  return stbi__errpf(\"unsupported data layout\", \"Unsupported HDR format\");\n   token += 3;\n   width = (int) strtol(token, NULL, 10);\n\n   if (height > STBI_MAX_DIMENSIONS) return stbi__errpf(\"too large\",\"Very large image (corrupt?)\");\n   if (width > STBI_MAX_DIMENSIONS) return stbi__errpf(\"too large\",\"Very large image (corrupt?)\");\n\n   *x = width;\n   *y = height;\n\n   if (comp) *comp = 3;\n   if (req_comp == 0) req_comp = 3;\n\n   if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))\n      return stbi__errpf(\"too large\", \"HDR image is too large\");\n\n   // Read data\n   hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);\n   if (!hdr_data)\n      return stbi__errpf(\"outofmem\", \"Out of memory\");\n\n   // Load image data\n   // image data is stored as some number of sca\n   if ( width < 8 || width >= 32768) {\n      // Read flat data\n      for (j=0; j < height; ++j) {\n         for (i=0; i < width; ++i) {\n            stbi_uc rgbe[4];\n           main_decode_loop:\n            stbi__getn(s, rgbe, 4);\n            stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);\n         }\n      }\n   } else {\n      // Read RLE-encoded data\n      scanline = NULL;\n\n      for (j = 0; j < height; ++j) {\n         c1 = stbi__get8(s);\n         c2 = stbi__get8(s);\n         len = stbi__get8(s);\n         if (c1 != 2 || c2 != 2 || (len & 0x80)) {\n            // not run-length encoded, so we have to actually use THIS data as a decoded\n            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)\n            stbi_uc rgbe[4];\n            rgbe[0] = (stbi_uc) c1;\n            rgbe[1] = (stbi_uc) c2;\n            rgbe[2] = (stbi_uc) len;\n            rgbe[3] = (stbi_uc) stbi__get8(s);\n            stbi__hdr_convert(hdr_data, rgbe, req_comp);\n            i = 1;\n            j = 0;\n            STBI_FREE(scanline);\n            goto main_decode_loop; // yes, this makes no sense\n         }\n         len <<= 8;\n         len |= stbi__get8(s);\n         if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"invalid decoded scanline length\", \"corrupt HDR\"); }\n         if (scanline == NULL) {\n            scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);\n            if (!scanline) {\n               STBI_FREE(hdr_data);\n               return stbi__errpf(\"outofmem\", \"Out of memory\");\n            }\n         }\n\n         for (k = 0; k < 4; ++k) {\n            int nleft;\n            i = 0;\n            while ((nleft = width - i) > 0) {\n               count = stbi__get8(s);\n               if (count > 128) {\n                  // Run\n                  value = stbi__get8(s);\n                  count -= 128;\n                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\n                  for (z = 0; z < count; ++z)\n                     scanline[i++ * 4 + k] = value;\n               } else {\n                  // Dump\n                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\n                  for (z = 0; z < count; ++z)\n                     scanline[i++ * 4 + k] = stbi__get8(s);\n               }\n            }\n         }\n         for (i=0; i < width; ++i)\n            stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);\n      }\n      if (scanline)\n         STBI_FREE(scanline);\n   }\n\n   return hdr_data;\n}",
        "func": "static float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   char buffer[STBI__HDR_BUFLEN];\n   char *token;\n   int valid = 0;\n   int width, height;\n   stbi_uc *scanline;\n   float *hdr_data;\n   int len;\n   unsigned char count, value;\n   int i, j, k, c1,c2, z;\n   const char *headerToken;\n   STBI_NOTUSED(ri);\n\n   // Check identifier\n   headerToken = stbi__hdr_gettoken(s,buffer);\n   if (strcmp(headerToken, \"#?RADIANCE\") != 0 && strcmp(headerToken, \"#?RGBE\") != 0)\n      return stbi__errpf(\"not HDR\", \"Corrupt HDR image\");\n\n   // Parse header\n   for(;;) {\n      token = stbi__hdr_gettoken(s,buffer);\n      if (token[0] == 0) break;\n      if (strcmp(token, \"FORMAT=32-bit_rle_rgbe\") == 0) valid = 1;\n   }\n\n   if (!valid)    return stbi__errpf(\"unsupported format\", \"Unsupported HDR format\");\n\n   // Parse width and height\n   // can't use sscanf() if we're not using stdio!\n   token = stbi__hdr_gettoken(s,buffer);\n   if (strncmp(token, \"-Y \", 3))  return stbi__errpf(\"unsupported data layout\", \"Unsupported HDR format\");\n   token += 3;\n   height = (int) strtol(token, &token, 10);\n   while (*token == ' ') ++token;\n   if (strncmp(token, \"+X \", 3))  return stbi__errpf(\"unsupported data layout\", \"Unsupported HDR format\");\n   token += 3;\n   width = (int) strtol(token, NULL, 10);\n\n   if (height > STBI_MAX_DIMENSIONS) return stbi__errpf(\"too large\",\"Very large image (corrupt?)\");\n   if (width > STBI_MAX_DIMENSIONS) return stbi__errpf(\"too large\",\"Very large image (corrupt?)\");\n\n   *x = width;\n   *y = height;\n\n   if (comp) *comp = 3;\n   if (req_comp == 0) req_comp = 3;\n\n   if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))\n      return stbi__errpf(\"too large\", \"HDR image is too large\");\n\n   // Read data\n   hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);\n   if (!hdr_data)\n      return stbi__errpf(\"outofmem\", \"Out of memory\");\n\n   // Load image data\n   // image data is stored as some number of sca\n   if ( width < 8 || width >= 32768) {\n      // Read flat data\n      for (j=0; j < height; ++j) {\n         for (i=0; i < width; ++i) {\n            stbi_uc rgbe[4];\n           main_decode_loop:\n            stbi__getn(s, rgbe, 4);\n            stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);\n         }\n      }\n   } else {\n      // Read RLE-encoded data\n      scanline = NULL;\n\n      for (j = 0; j < height; ++j) {\n         c1 = stbi__get8(s);\n         c2 = stbi__get8(s);\n         len = stbi__get8(s);\n         if (c1 != 2 || c2 != 2 || (len & 0x80)) {\n            // not run-length encoded, so we have to actually use THIS data as a decoded\n            // pixel (note this can't be a valid pixel--one of RGB must be >= 128)\n            stbi_uc rgbe[4];\n            rgbe[0] = (stbi_uc) c1;\n            rgbe[1] = (stbi_uc) c2;\n            rgbe[2] = (stbi_uc) len;\n            rgbe[3] = (stbi_uc) stbi__get8(s);\n            stbi__hdr_convert(hdr_data, rgbe, req_comp);\n            i = 1;\n            j = 0;\n            STBI_FREE(scanline);\n            goto main_decode_loop; // yes, this makes no sense\n         }\n         len <<= 8;\n         len |= stbi__get8(s);\n         if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"invalid decoded scanline length\", \"corrupt HDR\"); }\n         if (scanline == NULL) {\n            scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);\n            if (!scanline) {\n               STBI_FREE(hdr_data);\n               return stbi__errpf(\"outofmem\", \"Out of memory\");\n            }\n         }\n\n         for (k = 0; k < 4; ++k) {\n            int nleft;\n            i = 0;\n            while ((nleft = width - i) > 0) {\n               count = stbi__get8(s);\n               if (count > 128) {\n                  // Run\n                  value = stbi__get8(s);\n                  count -= 128;\n                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\n                  for (z = 0; z < count; ++z)\n                     scanline[i++ * 4 + k] = value;\n               } else {\n                  // Dump\n                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\n                  for (z = 0; z < count; ++z)\n                     scanline[i++ * 4 + k] = stbi__get8(s);\n               }\n            }\n         }\n         for (i=0; i < width; ++i)\n            stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);\n      }\n      if (scanline)\n         STBI_FREE(scanline);\n   }\n\n   return hdr_data;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -108,12 +108,12 @@\n                   // Run\n                   value = stbi__get8(s);\n                   count -= 128;\n-                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\n+                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\n                   for (z = 0; z < count; ++z)\n                      scanline[i++ * 4 + k] = value;\n                } else {\n                   // Dump\n-                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\n+                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }\n                   for (z = 0; z < count; ++z)\n                      scanline[i++ * 4 + k] = stbi__get8(s);\n                }",
        "diff_line_info": {
            "deleted_lines": [
                "                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }",
                "                  if (count > nleft) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }"
            ],
            "added_lines": [
                "                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }",
                "                  if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf(\"corrupt\", \"bad RLE data in HDR\"); }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-42715",
        "func_name": "nothings/stb/stbi__pnm_load",
        "description": "An issue was discovered in stb stb_image.h 1.33 through 2.27. The HDR loader parsed truncated end-of-file RLE scanlines as an infinite sequence of zero-length runs. An attacker could potentially have caused denial of service in applications using stb_image by submitting crafted HDR files.",
        "git_url": "https://github.com/nothings/stb/commit/2a02ff76b5f4d2a0b01f0eee289c47e0901c49b6",
        "commit_title": "Fixes two stb_image issues that could occur with specially constructed HDR and PGM files.",
        "commit_text": "",
        "func_before": "static void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   stbi_uc *out;\n   STBI_NOTUSED(ri);\n\n   ri->bits_per_channel = stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n);\n   if (ri->bits_per_channel == 0)\n      return 0;\n\n   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n\n   *x = s->img_x;\n   *y = s->img_y;\n   if (comp) *comp = s->img_n;\n\n   if (!stbi__mad4sizes_valid(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0))\n      return stbi__errpuc(\"too large\", \"PNM too large\");\n\n   out = (stbi_uc *) stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);\n   if (!out) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n   stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8));\n\n   if (req_comp && req_comp != s->img_n) {\n      out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);\n      if (out == NULL) return out; // stbi__convert_format frees input on failure\n   }\n   return out;\n}",
        "func": "static void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)\n{\n   stbi_uc *out;\n   STBI_NOTUSED(ri);\n\n   ri->bits_per_channel = stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n);\n   if (ri->bits_per_channel == 0)\n      return 0;\n\n   if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n   if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc(\"too large\",\"Very large image (corrupt?)\");\n\n   *x = s->img_x;\n   *y = s->img_y;\n   if (comp) *comp = s->img_n;\n\n   if (!stbi__mad4sizes_valid(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0))\n      return stbi__errpuc(\"too large\", \"PNM too large\");\n\n   out = (stbi_uc *) stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);\n   if (!out) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n   if (!stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8))) {\n      STBI_FREE(out);\n      return stbi__errpuc(\"bad PNM\", \"PNM file truncated\");\n   }\n\n   if (req_comp && req_comp != s->img_n) {\n      if (ri->bits_per_channel == 16) {\n         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, s->img_n, req_comp, s->img_x, s->img_y);\n      } else {\n         out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);\n      }\n      if (out == NULL) return out; // stbi__convert_format frees input on failure\n   }\n   return out;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,10 +19,17 @@\n \n    out = (stbi_uc *) stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);\n    if (!out) return stbi__errpuc(\"outofmem\", \"Out of memory\");\n-   stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8));\n+   if (!stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8))) {\n+      STBI_FREE(out);\n+      return stbi__errpuc(\"bad PNM\", \"PNM file truncated\");\n+   }\n \n    if (req_comp && req_comp != s->img_n) {\n-      out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);\n+      if (ri->bits_per_channel == 16) {\n+         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, s->img_n, req_comp, s->img_x, s->img_y);\n+      } else {\n+         out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);\n+      }\n       if (out == NULL) return out; // stbi__convert_format frees input on failure\n    }\n    return out;",
        "diff_line_info": {
            "deleted_lines": [
                "   stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8));",
                "      out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);"
            ],
            "added_lines": [
                "   if (!stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8))) {",
                "      STBI_FREE(out);",
                "      return stbi__errpuc(\"bad PNM\", \"PNM file truncated\");",
                "   }",
                "      if (ri->bits_per_channel == 16) {",
                "         out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, s->img_n, req_comp, s->img_x, s->img_y);",
                "      } else {",
                "         out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-4044",
        "func_name": "openssl/ssl_verify_cert_chain",
        "description": "Internally libssl in OpenSSL calls X509_verify_cert() on the client side to verify a certificate supplied by a server. That function may return a negative return value to indicate an internal error (for example out of memory). Such a negative return value is mishandled by OpenSSL and will cause an IO function (such as SSL_connect() or SSL_do_handshake()) to not indicate success and a subsequent call to SSL_get_error() to return the value SSL_ERROR_WANT_RETRY_VERIFY. This return value is only supposed to be returned by OpenSSL if the application has previously called SSL_CTX_set_cert_verify_callback(). Since most applications do not do this the SSL_ERROR_WANT_RETRY_VERIFY return value from SSL_get_error() will be totally unexpected and applications may not behave correctly as a result. The exact behaviour will depend on the application but it could result in crashes, infinite loops or other similar incorrect responses. This issue is made more serious in combination with a separate bug in OpenSSL 3.0 that will cause X509_verify_cert() to indicate an internal error when processing a certificate chain. This will occur where a certificate does not include the Subject Alternative Name extension but where a Certificate Authority has enforced name constraints. This issue can occur even with valid chains. By combining the two issues an attacker could induce incorrect, application dependent behaviour. Fixed in OpenSSL 3.0.1 (Affected 3.0.0).",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=758754966791c537ea95241438454aa86f91f256",
        "commit_title": "",
        "commit_text": "Fix invalid handling of verify errors in libssl  In the event that X509_verify() returned an internal error result then libssl would mishandle this and set rwstate to SSL_RETRY_VERIFY. This subsequently causes SSL_get_error() to return SSL_ERROR_WANT_RETRY_VERIFY. That return code is supposed to only ever be returned if an application is using an app verify callback to complete replace the use of X509_verify(). Applications may not be written to expect that return code and could therefore crash (or misbehave in some other way) as a result.  CVE-2021-4044  ",
        "func_before": "int ssl_verify_cert_chain(SSL *s, STACK_OF(X509) *sk)\n{\n    X509 *x;\n    int i = 0;\n    X509_STORE *verify_store;\n    X509_STORE_CTX *ctx = NULL;\n    X509_VERIFY_PARAM *param;\n\n    if ((sk == NULL) || (sk_X509_num(sk) == 0))\n        return 0;\n\n    if (s->cert->verify_store)\n        verify_store = s->cert->verify_store;\n    else\n        verify_store = s->ctx->cert_store;\n\n    ctx = X509_STORE_CTX_new_ex(s->ctx->libctx, s->ctx->propq);\n    if (ctx == NULL) {\n        ERR_raise(ERR_LIB_SSL, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n\n    x = sk_X509_value(sk, 0);\n    if (!X509_STORE_CTX_init(ctx, verify_store, x, sk)) {\n        ERR_raise(ERR_LIB_SSL, ERR_R_X509_LIB);\n        goto end;\n    }\n    param = X509_STORE_CTX_get0_param(ctx);\n    /*\n     * XXX: Separate @AUTHSECLEVEL and @TLSSECLEVEL would be useful at some\n     * point, for now a single @SECLEVEL sets the same policy for TLS crypto\n     * and PKI authentication.\n     */\n    X509_VERIFY_PARAM_set_auth_level(param, SSL_get_security_level(s));\n\n    /* Set suite B flags if needed */\n    X509_STORE_CTX_set_flags(ctx, tls1_suiteb(s));\n    if (!X509_STORE_CTX_set_ex_data\n        (ctx, SSL_get_ex_data_X509_STORE_CTX_idx(), s)) {\n        goto end;\n    }\n\n    /* Verify via DANE if enabled */\n    if (DANETLS_ENABLED(&s->dane))\n        X509_STORE_CTX_set0_dane(ctx, &s->dane);\n\n    /*\n     * We need to inherit the verify parameters. These can be determined by\n     * the context: if its a server it will verify SSL client certificates or\n     * vice versa.\n     */\n\n    X509_STORE_CTX_set_default(ctx, s->server ? \"ssl_client\" : \"ssl_server\");\n    /*\n     * Anything non-default in \"s->param\" should overwrite anything in the ctx.\n     */\n    X509_VERIFY_PARAM_set1(param, s->param);\n\n    if (s->verify_callback)\n        X509_STORE_CTX_set_verify_cb(ctx, s->verify_callback);\n\n    if (s->ctx->app_verify_callback != NULL)\n        i = s->ctx->app_verify_callback(ctx, s->ctx->app_verify_arg);\n    else\n        i = X509_verify_cert(ctx);\n\n    s->verify_result = X509_STORE_CTX_get_error(ctx);\n    sk_X509_pop_free(s->verified_chain, X509_free);\n    s->verified_chain = NULL;\n    if (X509_STORE_CTX_get0_chain(ctx) != NULL) {\n        s->verified_chain = X509_STORE_CTX_get1_chain(ctx);\n        if (s->verified_chain == NULL) {\n            ERR_raise(ERR_LIB_SSL, ERR_R_MALLOC_FAILURE);\n            i = 0;\n        }\n    }\n\n    /* Move peername from the store context params to the SSL handle's */\n    X509_VERIFY_PARAM_move_peername(s->param, param);\n\n end:\n    X509_STORE_CTX_free(ctx);\n    return i;\n}",
        "func": "int ssl_verify_cert_chain(SSL *s, STACK_OF(X509) *sk)\n{\n    X509 *x;\n    int i = 0;\n    X509_STORE *verify_store;\n    X509_STORE_CTX *ctx = NULL;\n    X509_VERIFY_PARAM *param;\n\n    if ((sk == NULL) || (sk_X509_num(sk) == 0))\n        return 0;\n\n    if (s->cert->verify_store)\n        verify_store = s->cert->verify_store;\n    else\n        verify_store = s->ctx->cert_store;\n\n    ctx = X509_STORE_CTX_new_ex(s->ctx->libctx, s->ctx->propq);\n    if (ctx == NULL) {\n        ERR_raise(ERR_LIB_SSL, ERR_R_MALLOC_FAILURE);\n        return 0;\n    }\n\n    x = sk_X509_value(sk, 0);\n    if (!X509_STORE_CTX_init(ctx, verify_store, x, sk)) {\n        ERR_raise(ERR_LIB_SSL, ERR_R_X509_LIB);\n        goto end;\n    }\n    param = X509_STORE_CTX_get0_param(ctx);\n    /*\n     * XXX: Separate @AUTHSECLEVEL and @TLSSECLEVEL would be useful at some\n     * point, for now a single @SECLEVEL sets the same policy for TLS crypto\n     * and PKI authentication.\n     */\n    X509_VERIFY_PARAM_set_auth_level(param, SSL_get_security_level(s));\n\n    /* Set suite B flags if needed */\n    X509_STORE_CTX_set_flags(ctx, tls1_suiteb(s));\n    if (!X509_STORE_CTX_set_ex_data\n        (ctx, SSL_get_ex_data_X509_STORE_CTX_idx(), s)) {\n        goto end;\n    }\n\n    /* Verify via DANE if enabled */\n    if (DANETLS_ENABLED(&s->dane))\n        X509_STORE_CTX_set0_dane(ctx, &s->dane);\n\n    /*\n     * We need to inherit the verify parameters. These can be determined by\n     * the context: if its a server it will verify SSL client certificates or\n     * vice versa.\n     */\n\n    X509_STORE_CTX_set_default(ctx, s->server ? \"ssl_client\" : \"ssl_server\");\n    /*\n     * Anything non-default in \"s->param\" should overwrite anything in the ctx.\n     */\n    X509_VERIFY_PARAM_set1(param, s->param);\n\n    if (s->verify_callback)\n        X509_STORE_CTX_set_verify_cb(ctx, s->verify_callback);\n\n    if (s->ctx->app_verify_callback != NULL) {\n        i = s->ctx->app_verify_callback(ctx, s->ctx->app_verify_arg);\n    } else {\n        i = X509_verify_cert(ctx);\n        /* We treat an error in the same way as a failure to verify */\n        if (i < 0)\n            i = 0;\n    }\n\n    s->verify_result = X509_STORE_CTX_get_error(ctx);\n    sk_X509_pop_free(s->verified_chain, X509_free);\n    s->verified_chain = NULL;\n    if (X509_STORE_CTX_get0_chain(ctx) != NULL) {\n        s->verified_chain = X509_STORE_CTX_get1_chain(ctx);\n        if (s->verified_chain == NULL) {\n            ERR_raise(ERR_LIB_SSL, ERR_R_MALLOC_FAILURE);\n            i = 0;\n        }\n    }\n\n    /* Move peername from the store context params to the SSL handle's */\n    X509_VERIFY_PARAM_move_peername(s->param, param);\n\n end:\n    X509_STORE_CTX_free(ctx);\n    return i;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -59,10 +59,14 @@\n     if (s->verify_callback)\n         X509_STORE_CTX_set_verify_cb(ctx, s->verify_callback);\n \n-    if (s->ctx->app_verify_callback != NULL)\n+    if (s->ctx->app_verify_callback != NULL) {\n         i = s->ctx->app_verify_callback(ctx, s->ctx->app_verify_arg);\n-    else\n+    } else {\n         i = X509_verify_cert(ctx);\n+        /* We treat an error in the same way as a failure to verify */\n+        if (i < 0)\n+            i = 0;\n+    }\n \n     s->verify_result = X509_STORE_CTX_get_error(ctx);\n     sk_X509_pop_free(s->verified_chain, X509_free);",
        "diff_line_info": {
            "deleted_lines": [
                "    if (s->ctx->app_verify_callback != NULL)",
                "    else"
            ],
            "added_lines": [
                "    if (s->ctx->app_verify_callback != NULL) {",
                "    } else {",
                "        /* We treat an error in the same way as a failure to verify */",
                "        if (i < 0)",
                "            i = 0;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-4044",
        "func_name": "openssl/tls_post_process_server_certificate",
        "description": "Internally libssl in OpenSSL calls X509_verify_cert() on the client side to verify a certificate supplied by a server. That function may return a negative return value to indicate an internal error (for example out of memory). Such a negative return value is mishandled by OpenSSL and will cause an IO function (such as SSL_connect() or SSL_do_handshake()) to not indicate success and a subsequent call to SSL_get_error() to return the value SSL_ERROR_WANT_RETRY_VERIFY. This return value is only supposed to be returned by OpenSSL if the application has previously called SSL_CTX_set_cert_verify_callback(). Since most applications do not do this the SSL_ERROR_WANT_RETRY_VERIFY return value from SSL_get_error() will be totally unexpected and applications may not behave correctly as a result. The exact behaviour will depend on the application but it could result in crashes, infinite loops or other similar incorrect responses. This issue is made more serious in combination with a separate bug in OpenSSL 3.0 that will cause X509_verify_cert() to indicate an internal error when processing a certificate chain. This will occur where a certificate does not include the Subject Alternative Name extension but where a Certificate Authority has enforced name constraints. This issue can occur even with valid chains. By combining the two issues an attacker could induce incorrect, application dependent behaviour. Fixed in OpenSSL 3.0.1 (Affected 3.0.0).",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=758754966791c537ea95241438454aa86f91f256",
        "commit_title": "",
        "commit_text": "Fix invalid handling of verify errors in libssl  In the event that X509_verify() returned an internal error result then libssl would mishandle this and set rwstate to SSL_RETRY_VERIFY. This subsequently causes SSL_get_error() to return SSL_ERROR_WANT_RETRY_VERIFY. That return code is supposed to only ever be returned if an application is using an app verify callback to complete replace the use of X509_verify(). Applications may not be written to expect that return code and could therefore crash (or misbehave in some other way) as a result.  CVE-2021-4044  ",
        "func_before": "WORK_STATE tls_post_process_server_certificate(SSL *s, WORK_STATE wst)\n{\n    X509 *x;\n    EVP_PKEY *pkey = NULL;\n    const SSL_CERT_LOOKUP *clu;\n    size_t certidx;\n    int i;\n\n    i = ssl_verify_cert_chain(s, s->session->peer_chain);\n    if (i == -1) {\n        s->rwstate = SSL_RETRY_VERIFY;\n        return WORK_MORE_A;\n    }\n    /*\n     * The documented interface is that SSL_VERIFY_PEER should be set in order\n     * for client side verification of the server certificate to take place.\n     * However, historically the code has only checked that *any* flag is set\n     * to cause server verification to take place. Use of the other flags makes\n     * no sense in client mode. An attempt to clean up the semantics was\n     * reverted because at least one application *only* set\n     * SSL_VERIFY_FAIL_IF_NO_PEER_CERT. Prior to the clean up this still caused\n     * server verification to take place, after the clean up it silently did\n     * nothing. SSL_CTX_set_verify()/SSL_set_verify() cannot validate the flags\n     * sent to them because they are void functions. Therefore, we now use the\n     * (less clean) historic behaviour of performing validation if any flag is\n     * set. The *documented* interface remains the same.\n     */\n    if (s->verify_mode != SSL_VERIFY_NONE && i <= 0) {\n        SSLfatal(s, ssl_x509err2alert(s->verify_result),\n                 SSL_R_CERTIFICATE_VERIFY_FAILED);\n        return WORK_ERROR;\n    }\n    ERR_clear_error();          /* but we keep s->verify_result */\n\n    /*\n     * Inconsistency alert: cert_chain does include the peer's certificate,\n     * which we don't include in statem_srvr.c\n     */\n    x = sk_X509_value(s->session->peer_chain, 0);\n\n    pkey = X509_get0_pubkey(x);\n\n    if (pkey == NULL || EVP_PKEY_missing_parameters(pkey)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                 SSL_R_UNABLE_TO_FIND_PUBLIC_KEY_PARAMETERS);\n        return WORK_ERROR;\n    }\n\n    if ((clu = ssl_cert_lookup_by_pkey(pkey, &certidx)) == NULL) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_UNKNOWN_CERTIFICATE_TYPE);\n        return WORK_ERROR;\n    }\n    /*\n     * Check certificate type is consistent with ciphersuite. For TLS 1.3\n     * skip check since TLS 1.3 ciphersuites can be used with any certificate\n     * type.\n     */\n    if (!SSL_IS_TLS13(s)) {\n        if ((clu->amask & s->s3.tmp.new_cipher->algorithm_auth) == 0) {\n            SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_CERTIFICATE_TYPE);\n            return WORK_ERROR;\n        }\n    }\n\n    X509_free(s->session->peer);\n    X509_up_ref(x);\n    s->session->peer = x;\n    s->session->verify_result = s->verify_result;\n\n    /* Save the current hash state for when we receive the CertificateVerify */\n    if (SSL_IS_TLS13(s)\n            && !ssl_handshake_hash(s, s->cert_verify_hash,\n                                   sizeof(s->cert_verify_hash),\n                                   &s->cert_verify_hash_len)) {\n        /* SSLfatal() already called */;\n        return WORK_ERROR;\n    }\n    return WORK_FINISHED_CONTINUE;\n}",
        "func": "WORK_STATE tls_post_process_server_certificate(SSL *s, WORK_STATE wst)\n{\n    X509 *x;\n    EVP_PKEY *pkey = NULL;\n    const SSL_CERT_LOOKUP *clu;\n    size_t certidx;\n    int i;\n\n    i = ssl_verify_cert_chain(s, s->session->peer_chain);\n    if (i == -1) {\n        s->rwstate = SSL_RETRY_VERIFY;\n        return WORK_MORE_A;\n    }\n    /*\n     * The documented interface is that SSL_VERIFY_PEER should be set in order\n     * for client side verification of the server certificate to take place.\n     * However, historically the code has only checked that *any* flag is set\n     * to cause server verification to take place. Use of the other flags makes\n     * no sense in client mode. An attempt to clean up the semantics was\n     * reverted because at least one application *only* set\n     * SSL_VERIFY_FAIL_IF_NO_PEER_CERT. Prior to the clean up this still caused\n     * server verification to take place, after the clean up it silently did\n     * nothing. SSL_CTX_set_verify()/SSL_set_verify() cannot validate the flags\n     * sent to them because they are void functions. Therefore, we now use the\n     * (less clean) historic behaviour of performing validation if any flag is\n     * set. The *documented* interface remains the same.\n     */\n    if (s->verify_mode != SSL_VERIFY_NONE && i == 0) {\n        SSLfatal(s, ssl_x509err2alert(s->verify_result),\n                 SSL_R_CERTIFICATE_VERIFY_FAILED);\n        return WORK_ERROR;\n    }\n    ERR_clear_error();          /* but we keep s->verify_result */\n\n    /*\n     * Inconsistency alert: cert_chain does include the peer's certificate,\n     * which we don't include in statem_srvr.c\n     */\n    x = sk_X509_value(s->session->peer_chain, 0);\n\n    pkey = X509_get0_pubkey(x);\n\n    if (pkey == NULL || EVP_PKEY_missing_parameters(pkey)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR,\n                 SSL_R_UNABLE_TO_FIND_PUBLIC_KEY_PARAMETERS);\n        return WORK_ERROR;\n    }\n\n    if ((clu = ssl_cert_lookup_by_pkey(pkey, &certidx)) == NULL) {\n        SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_UNKNOWN_CERTIFICATE_TYPE);\n        return WORK_ERROR;\n    }\n    /*\n     * Check certificate type is consistent with ciphersuite. For TLS 1.3\n     * skip check since TLS 1.3 ciphersuites can be used with any certificate\n     * type.\n     */\n    if (!SSL_IS_TLS13(s)) {\n        if ((clu->amask & s->s3.tmp.new_cipher->algorithm_auth) == 0) {\n            SSLfatal(s, SSL_AD_ILLEGAL_PARAMETER, SSL_R_WRONG_CERTIFICATE_TYPE);\n            return WORK_ERROR;\n        }\n    }\n\n    X509_free(s->session->peer);\n    X509_up_ref(x);\n    s->session->peer = x;\n    s->session->verify_result = s->verify_result;\n\n    /* Save the current hash state for when we receive the CertificateVerify */\n    if (SSL_IS_TLS13(s)\n            && !ssl_handshake_hash(s, s->cert_verify_hash,\n                                   sizeof(s->cert_verify_hash),\n                                   &s->cert_verify_hash_len)) {\n        /* SSLfatal() already called */;\n        return WORK_ERROR;\n    }\n    return WORK_FINISHED_CONTINUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,7 +25,7 @@\n      * (less clean) historic behaviour of performing validation if any flag is\n      * set. The *documented* interface remains the same.\n      */\n-    if (s->verify_mode != SSL_VERIFY_NONE && i <= 0) {\n+    if (s->verify_mode != SSL_VERIFY_NONE && i == 0) {\n         SSLfatal(s, ssl_x509err2alert(s->verify_result),\n                  SSL_R_CERTIFICATE_VERIFY_FAILED);\n         return WORK_ERROR;",
        "diff_line_info": {
            "deleted_lines": [
                "    if (s->verify_mode != SSL_VERIFY_NONE && i <= 0) {"
            ],
            "added_lines": [
                "    if (s->verify_mode != SSL_VERIFY_NONE && i == 0) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-45297",
        "func_name": "gpac/gf_get_bit_size",
        "description": "An infinite loop vulnerability exists in Gpac 1.0.1 in gf_get_bit_size.",
        "git_url": "https://github.com/gpac/gpac/commit/fb13af36286b9d898e332e8762a286eb83bd1770",
        "commit_title": "fixed #1973",
        "commit_text": "",
        "func_before": "GF_EXPORT\nu32 gf_get_bit_size(u32 MaxVal)\n{\n\tu32 k=0;\n\twhile ((s32) MaxVal > ((1<<k)-1) ) k+=1;\n\treturn k;\n}",
        "func": "GF_EXPORT\nu32 gf_get_bit_size(u32 MaxVal)\n{\n\tu32 k=0;\n\twhile (MaxVal > (((u32)1<<k)-1) )\n\t\tk+=1;\n\treturn k;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,7 @@\n u32 gf_get_bit_size(u32 MaxVal)\n {\n \tu32 k=0;\n-\twhile ((s32) MaxVal > ((1<<k)-1) ) k+=1;\n+\twhile (MaxVal > (((u32)1<<k)-1) )\n+\t\tk+=1;\n \treturn k;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\twhile ((s32) MaxVal > ((1<<k)-1) ) k+=1;"
            ],
            "added_lines": [
                "\twhile (MaxVal > (((u32)1<<k)-1) )",
                "\t\tk+=1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-44924",
        "func_name": "gpac/gf_avc_read_sps_bs_internal",
        "description": "An infinite loop vulnerability exists in gpac 1.1.0 in the gf_log function, which causes a Denial of Service.",
        "git_url": "https://github.com/gpac/gpac/commit/e2acb1511d1e69115141ea3080afd1cce6a15497",
        "commit_title": "fixed #1959",
        "commit_text": "",
        "func_before": "static s32 gf_avc_read_sps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos, u32 nal_hdr)\n{\n\tAVC_SPS *sps;\n\ts32 mb_width, mb_height, sps_id = -1;\n\tu32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl = 0, cr = 0, ct = 0, cb = 0, luma_bd, chroma_bd;\n\tu8 separate_colour_plane_flag = 0;\n\n\tif (!vui_flag_pos) {\n\t\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\t}\n\n\tif (!bs) {\n\t\treturn -1;\n\t}\n\n\tif (!nal_hdr) {\n\t\tgf_bs_read_int_log(bs, 1, \"forbidden_zero_bit\");\n\t\tgf_bs_read_int_log(bs, 2, \"nal_ref_idc\");\n\t\tgf_bs_read_int_log(bs, 5, \"nal_unit_type\");\n\t}\n\tprofile_idc = gf_bs_read_int_log(bs, 8, \"profile_idc\");\n\n\tpcomp = gf_bs_read_int_log(bs, 8, \"profile_compatibility\");\n\t/*sanity checks*/\n\tif (pcomp & 0x3)\n\t\treturn -1;\n\n\tlevel_idc = gf_bs_read_int_log(bs, 8, \"level_idc\");\n\n\t/*SubsetSps is used to be sure that AVC SPS are not going to be scratched\n\tby subset SPS. According to the SVC standard, subset SPS can have the same sps_id\n\tthan its base layer, but it does not refer to the same SPS. */\n\tsps_id = gf_bs_read_ue_log(bs, \"sps_id\") + GF_SVC_SSPS_ID_SHIFT * subseq_sps;\n\tif ((sps_id < 0) || (sps_id >= 32)) {\n\t\treturn -1;\n\t}\n\n\tluma_bd = chroma_bd = 0;\n\tsps = &avc->sps[sps_id];\n\tchroma_format_idc = sps->ChromaArrayType = 1;\n\tsps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;\n\n\t/*High Profile and SVC*/\n\tswitch (profile_idc) {\n\tcase 100:\n\tcase 110:\n\tcase 122:\n\tcase 244:\n\tcase 44:\n\t\t/*sanity checks: note1 from 7.4.2.1.1 of iso/iec 14496-10-N11084*/\n\t\tif (pcomp & 0xE0)\n\t\t\treturn -1;\n\tcase 83:\n\tcase 86:\n\tcase 118:\n\tcase 128:\n\t\tchroma_format_idc = gf_bs_read_ue_log(bs, \"chroma_format_idc\");\n\t\tsps->ChromaArrayType = chroma_format_idc;\n\t\tif (chroma_format_idc == 3) {\n\t\t\tseparate_colour_plane_flag = gf_bs_read_int_log(bs, 1, \"separate_colour_plane_flag\");\n\t\t\t/*\n\t\t\tDepending on the value of separate_colour_plane_flag, the value of the variable ChromaArrayType is assigned as follows.\n\t\t\t\\96\tIf separate_colour_plane_flag is equal to 0, ChromaArrayType is set equal to chroma_format_idc.\n\t\t\t\\96\tOtherwise (separate_colour_plane_flag is equal to 1), ChromaArrayType is set equal to 0.\n\t\t\t*/\n\t\t\tif (separate_colour_plane_flag) sps->ChromaArrayType = 0;\n\t\t}\n\t\tluma_bd = gf_bs_read_ue_log(bs, \"luma_bit_depth\");\n\t\tchroma_bd = gf_bs_read_ue_log(bs, \"chroma_bit_depth\");\n\t\t/*qpprime_y_zero_transform_bypass_flag = */ gf_bs_read_int_log(bs, 1, \"qpprime_y_zero_transform_bypass_flag\");\n\t\t/*seq_scaling_matrix_present_flag*/\n\t\tif (gf_bs_read_int_log(bs, 1, \"seq_scaling_matrix_present_flag\")) {\n\t\t\tu32 k;\n\t\t\tfor (k = 0; k < 8; k++) {\n\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"seq_scaling_list_present_flag\", k)) {\n\t\t\t\t\tu32 z, last = 8, next = 8;\n\t\t\t\t\tu32 sl = k < 6 ? 16 : 64;\n\t\t\t\t\tfor (z = 0; z < sl; z++) {\n\t\t\t\t\t\tif (next) {\n\t\t\t\t\t\t\ts32 delta = gf_bs_read_se(bs);\n\t\t\t\t\t\t\tnext = (last + delta + 256) % 256;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast = next ? next : last;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tsps->profile_idc = profile_idc;\n\tsps->level_idc = level_idc;\n\tsps->prof_compat = pcomp;\n\tsps->log2_max_frame_num = gf_bs_read_ue_log(bs, \"log2_max_frame_num\") + 4;\n\tsps->poc_type = gf_bs_read_ue_log(bs, \"poc_type\");\n\tsps->chroma_format = chroma_format_idc;\n\tsps->luma_bit_depth_m8 = luma_bd;\n\tsps->chroma_bit_depth_m8 = chroma_bd;\n\n\tif (sps->poc_type == 0) {\n\t\tsps->log2_max_poc_lsb = gf_bs_read_ue_log(bs, \"log2_max_poc_lsb\") + 4;\n\t}\n\telse if (sps->poc_type == 1) {\n\t\tsps->delta_pic_order_always_zero_flag = gf_bs_read_int_log(bs, 1, \"delta_pic_order_always_zero_flag\");\n\t\tsps->offset_for_non_ref_pic = gf_bs_read_se_log(bs, \"offset_for_non_ref_pic\");\n\t\tsps->offset_for_top_to_bottom_field = gf_bs_read_se_log(bs, \"offset_for_top_to_bottom_field\");\n\t\tsps->poc_cycle_length = gf_bs_read_ue_log(bs, \"poc_cycle_length\");\n\t\tif (sps->poc_cycle_length > GF_ARRAY_LENGTH(sps->offset_for_ref_frame)) {\n\t\t\tsps->poc_cycle_length = 255;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = 0; i < sps->poc_cycle_length; i++)\n\t\t\tsps->offset_for_ref_frame[i] = gf_bs_read_se_log_idx(bs, \"offset_for_ref_frame\", i);\n\t}\n\tif (sps->poc_type > 2) {\n\t\treturn -1;\n\t}\n\tsps->max_num_ref_frames = gf_bs_read_ue_log(bs, \"max_num_ref_frames\");\n\tsps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int_log(bs, 1, \"gaps_in_frame_num_value_allowed_flag\");\n\tmb_width = gf_bs_read_ue_log(bs, \"pic_width_in_mbs_minus1\") + 1;\n\tmb_height = gf_bs_read_ue_log(bs, \"pic_height_in_map_units_minus1\") + 1;\n\n\tsps->frame_mbs_only_flag = gf_bs_read_int_log(bs, 1, \"frame_mbs_only_flag\");\n\n\tsps->width = mb_width * 16;\n\tsps->height = (2 - sps->frame_mbs_only_flag) * mb_height * 16;\n\n\tif (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int_log(bs, 1, \"mb_adaptive_frame_field_flag\");\n\tgf_bs_read_int_log(bs, 1, \"direct_8x8_inference_flag\");\n\n\tif (gf_bs_read_int_log(bs, 1, \"frame_cropping_flag\")) {\n\t\tint CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1;\n\n\t\tif (chroma_format_idc == 1) {\n\t\t\tSubWidthC = 2; SubHeightC = 2;\n\t\t}\n\t\telse if (chroma_format_idc == 2) {\n\t\t\tSubWidthC = 2; SubHeightC = 1;\n\t\t}\n\t\telse if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) {\n\t\t\tSubWidthC = 1; SubHeightC = 1;\n\t\t}\n\n\t\tif (sps->ChromaArrayType == 0) {\n\t\t\tassert(SubWidthC == -1);\n\t\t\tCropUnitX = 1;\n\t\t\tCropUnitY = 2 - sps->frame_mbs_only_flag;\n\t\t}\n\t\telse {\n\t\t\tCropUnitX = SubWidthC;\n\t\t\tCropUnitY = SubHeightC * (2 - sps->frame_mbs_only_flag);\n\t\t}\n\n\t\tcl = gf_bs_read_ue_log(bs, \"frame_crop_left_offset\");\n\t\tcr = gf_bs_read_ue_log(bs, \"frame_crop_right_offset\");\n\t\tct = gf_bs_read_ue_log(bs, \"frame_crop_top_offset\");\n\t\tcb = gf_bs_read_ue_log(bs, \"frame_crop_bottom_offset\");\n\n\t\tsps->width -= CropUnitX * (cl + cr);\n\t\tsps->height -= CropUnitY * (ct + cb);\n\t\tcl *= CropUnitX;\n\t\tcr *= CropUnitX;\n\t\tct *= CropUnitY;\n\t\tcb *= CropUnitY;\n\t}\n\tsps->crop.left = cl;\n\tsps->crop.right = cr;\n\tsps->crop.top = ct;\n\tsps->crop.bottom = cb;\n\n\tif (vui_flag_pos) {\n\t\t*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);\n\t}\n\t/*vui_parameters_present_flag*/\n\tsps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_parameters_present_flag\");\n\tif (sps->vui_parameters_present_flag) {\n\t\tsps->vui.aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, \"aspect_ratio_info_present_flag\");\n\t\tif (sps->vui.aspect_ratio_info_present_flag) {\n\t\t\ts32 aspect_ratio_idc = gf_bs_read_int_log(bs, 8, \"aspect_ratio_idc\");\n\t\t\tif (aspect_ratio_idc == 255) {\n\t\t\t\tsps->vui.par_num = gf_bs_read_int_log(bs, 16, \"aspect_ratio_num\");\n\t\t\t\tsps->vui.par_den = gf_bs_read_int_log(bs, 16, \"aspect_ratio_den\");\n\t\t\t}\n\t\t\telse if (aspect_ratio_idc < GF_ARRAY_LENGTH(avc_hevc_sar) ) {\n\t\t\t\tsps->vui.par_num = avc_hevc_sar[aspect_ratio_idc].w;\n\t\t\t\tsps->vui.par_den = avc_hevc_sar[aspect_ratio_idc].h;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] Unknown aspect_ratio_idc: your video may have a wrong aspect ratio. Contact the GPAC team!\\n\"));\n\t\t\t}\n\t\t}\n\t\tsps->vui.overscan_info_present_flag = gf_bs_read_int_log(bs, 1, \"overscan_info_present_flag\");\n\t\tif (sps->vui.overscan_info_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 1, \"overscan_appropriate_flag\");\n\n\t\t/* default values */\n\t\tsps->vui.video_format = 5;\n\t\tsps->vui.colour_primaries = 2;\n\t\tsps->vui.transfer_characteristics = 2;\n\t\tsps->vui.matrix_coefficients = 2;\n\t\t/* now read values if possible */\n\t\tsps->vui.video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, \"video_signal_type_present_flag\");\n\t\tif (sps->vui.video_signal_type_present_flag) {\n\t\t\tsps->vui.video_format = gf_bs_read_int_log(bs, 3, \"video_format\");\n\t\t\tsps->vui.video_full_range_flag = gf_bs_read_int_log(bs, 1, \"video_full_range_flag\");\n\t\t\tsps->vui.colour_description_present_flag = gf_bs_read_int_log(bs, 1, \"colour_description_present_flag\");\n\t\t\tif (sps->vui.colour_description_present_flag) {\n\t\t\t\tsps->vui.colour_primaries = gf_bs_read_int_log(bs, 8, \"colour_primaries\");\n\t\t\t\tsps->vui.transfer_characteristics = gf_bs_read_int_log(bs, 8, \"transfer_characteristics\");\n\t\t\t\tsps->vui.matrix_coefficients = gf_bs_read_int_log(bs, 8, \"matrix_coefficients\");\n\t\t\t}\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \"chroma_location_info_present_flag\")) {\n\t\t\tgf_bs_read_ue_log(bs, \"chroma_sample_location_type_top_field\");\n\t\t\tgf_bs_read_ue_log(bs, \"chroma_sample_location_type_bottom_field\");\n\t\t}\n\n\t\tsps->vui.timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"timing_info_present_flag\");\n\t\tif (sps->vui.timing_info_present_flag) {\n\t\t\tsps->vui.num_units_in_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_tick\");\n\t\t\tsps->vui.time_scale = gf_bs_read_int_log(bs, 32, \"time_scale\");\n\t\t\tsps->vui.fixed_frame_rate_flag = gf_bs_read_int_log(bs, 1, \"fixed_frame_rate_flag\");\n\t\t}\n\n\t\tsps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"nal_hrd_parameters_present_flag\");\n\t\tif (sps->vui.nal_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tsps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vcl_hrd_parameters_present_flag\");\n\t\tif (sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tif (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tsps->vui.low_delay_hrd_flag = gf_bs_read_int_log(bs, 1, \"low_delay_hrd_flag\");\n\n\t\tsps->vui.pic_struct_present_flag = gf_bs_read_int_log(bs, 1, \"pic_struct_present_flag\");\n\t}\n\t/*end of seq_parameter_set_data*/\n\n\tif (subseq_sps) {\n\t\tif ((profile_idc == 83) || (profile_idc == 86)) {\n\t\t\tu8 extended_spatial_scalability_idc;\n\t\t\t/*parsing seq_parameter_set_svc_extension*/\n\n\t\t\tgf_bs_read_int_log(bs, 1, \"inter_layer_deblocking_filter_control_present_flag\");\n\t\t\textended_spatial_scalability_idc = gf_bs_read_int_log(bs, 2, \"extended_spatial_scalability_idc\");\n\t\t\tif (sps->ChromaArrayType == 1 || sps->ChromaArrayType == 2) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"chroma_phase_x_plus1_flag\");\n\t\t\t}\n\t\t\tif (sps->ChromaArrayType == 1) {\n\t\t\t\tgf_bs_read_int_log(bs, 2, \"chroma_phase_y_plus1\");\n\t\t\t}\n\t\t\tif (extended_spatial_scalability_idc == 1) {\n\t\t\t\tif (sps->ChromaArrayType > 0) {\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"seq_ref_layer_chroma_phase_x_plus1_flag\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 2, \"seq_ref_layer_chroma_phase_y_plus1\");\n\t\t\t\t}\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_left_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_top_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_right_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_bottom_offset\");\n\t\t\t}\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"seq_tcoeff_level_prediction_flag\")) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"adaptive_tcoeff_level_prediction_flag\");\n\t\t\t}\n\t\t\tgf_bs_read_int_log(bs, 1, \"slice_header_restriction_flag\");\n\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"svc_vui_parameters_present\")) {\n\t\t\t\tu32 vui_ext_num_entries_minus1 = gf_bs_read_ue_log(bs, \"vui_ext_num_entries_minus1\");\n\n\t\t\t\tfor (i = 0; i <= vui_ext_num_entries_minus1; i++) {\n\t\t\t\t\tu8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag;\n\t\t\t\t\tgf_bs_read_int_log(bs, 3, \"vui_ext_dependency_id\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 4, \"vui_ext_quality_id\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 3, \"vui_ext_temporal_id\");\n\t\t\t\t\tvui_ext_timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_timing_info_present_flag\");\n\t\t\t\t\tif (vui_ext_timing_info_present_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 32, \"vui_ext_num_units_in_tick\");\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 32, \"vui_ext_time_scale\");\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_fixed_frame_rate_flag\");\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_nal_hrd_parameters_present_flag\");\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_vcl_hrd_parameters_present_flag\");\n\t\t\t\t\tif (vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag || vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_low_delay_hrd_flag\");\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_pic_struct_present_flag\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ((profile_idc == 118) || (profile_idc == 128)) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\"[avc-h264] MVC parsing not implemented - skipping parsing end of Subset SPS\\n\"));\n\t\t\treturn sps_id;\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \"additional_extension2\")) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\\n\"));\n\t\t\treturn sps_id;\n\t\t}\n\t}\n\treturn sps_id;\n}",
        "func": "static s32 gf_avc_read_sps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos, u32 nal_hdr)\n{\n\tAVC_SPS *sps;\n\ts32 mb_width, mb_height, sps_id = -1;\n\tu32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl = 0, cr = 0, ct = 0, cb = 0, luma_bd, chroma_bd;\n\tu8 separate_colour_plane_flag = 0;\n\n\tif (!vui_flag_pos) {\n\t\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\t}\n\n\tif (!bs) {\n\t\treturn -1;\n\t}\n\n\tif (!nal_hdr) {\n\t\tgf_bs_read_int_log(bs, 1, \"forbidden_zero_bit\");\n\t\tgf_bs_read_int_log(bs, 2, \"nal_ref_idc\");\n\t\tgf_bs_read_int_log(bs, 5, \"nal_unit_type\");\n\t}\n\tprofile_idc = gf_bs_read_int_log(bs, 8, \"profile_idc\");\n\n\tpcomp = gf_bs_read_int_log(bs, 8, \"profile_compatibility\");\n\t/*sanity checks*/\n\tif (pcomp & 0x3)\n\t\treturn -1;\n\n\tlevel_idc = gf_bs_read_int_log(bs, 8, \"level_idc\");\n\n\t/*SubsetSps is used to be sure that AVC SPS are not going to be scratched\n\tby subset SPS. According to the SVC standard, subset SPS can have the same sps_id\n\tthan its base layer, but it does not refer to the same SPS. */\n\tsps_id = gf_bs_read_ue_log(bs, \"sps_id\") + GF_SVC_SSPS_ID_SHIFT * subseq_sps;\n\tif ((sps_id < 0) || (sps_id >= 32)) {\n\t\treturn -1;\n\t}\n\n\tluma_bd = chroma_bd = 0;\n\tsps = &avc->sps[sps_id];\n\tchroma_format_idc = sps->ChromaArrayType = 1;\n\tsps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;\n\n\t/*High Profile and SVC*/\n\tswitch (profile_idc) {\n\tcase 100:\n\tcase 110:\n\tcase 122:\n\tcase 244:\n\tcase 44:\n\t\t/*sanity checks: note1 from 7.4.2.1.1 of iso/iec 14496-10-N11084*/\n\t\tif (pcomp & 0xE0)\n\t\t\treturn -1;\n\tcase 83:\n\tcase 86:\n\tcase 118:\n\tcase 128:\n\t\tchroma_format_idc = gf_bs_read_ue_log(bs, \"chroma_format_idc\");\n\t\tsps->ChromaArrayType = chroma_format_idc;\n\t\tif (chroma_format_idc == 3) {\n\t\t\tseparate_colour_plane_flag = gf_bs_read_int_log(bs, 1, \"separate_colour_plane_flag\");\n\t\t\t/*\n\t\t\tDepending on the value of separate_colour_plane_flag, the value of the variable ChromaArrayType is assigned as follows.\n\t\t\t\\96\tIf separate_colour_plane_flag is equal to 0, ChromaArrayType is set equal to chroma_format_idc.\n\t\t\t\\96\tOtherwise (separate_colour_plane_flag is equal to 1), ChromaArrayType is set equal to 0.\n\t\t\t*/\n\t\t\tif (separate_colour_plane_flag) sps->ChromaArrayType = 0;\n\t\t}\n\t\tluma_bd = gf_bs_read_ue_log(bs, \"luma_bit_depth\");\n\t\tchroma_bd = gf_bs_read_ue_log(bs, \"chroma_bit_depth\");\n\t\t/*qpprime_y_zero_transform_bypass_flag = */ gf_bs_read_int_log(bs, 1, \"qpprime_y_zero_transform_bypass_flag\");\n\t\t/*seq_scaling_matrix_present_flag*/\n\t\tif (gf_bs_read_int_log(bs, 1, \"seq_scaling_matrix_present_flag\")) {\n\t\t\tu32 k;\n\t\t\tfor (k = 0; k < 8; k++) {\n\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"seq_scaling_list_present_flag\", k)) {\n\t\t\t\t\tu32 z, last = 8, next = 8;\n\t\t\t\t\tu32 sl = k < 6 ? 16 : 64;\n\t\t\t\t\tfor (z = 0; z < sl; z++) {\n\t\t\t\t\t\tif (next) {\n\t\t\t\t\t\t\ts32 delta = gf_bs_read_se(bs);\n\t\t\t\t\t\t\tnext = (last + delta + 256) % 256;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast = next ? next : last;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tsps->profile_idc = profile_idc;\n\tsps->level_idc = level_idc;\n\tsps->prof_compat = pcomp;\n\tsps->log2_max_frame_num = gf_bs_read_ue_log(bs, \"log2_max_frame_num\") + 4;\n\tsps->poc_type = gf_bs_read_ue_log(bs, \"poc_type\");\n\tsps->chroma_format = chroma_format_idc;\n\tsps->luma_bit_depth_m8 = luma_bd;\n\tsps->chroma_bit_depth_m8 = chroma_bd;\n\n\tif (sps->poc_type == 0) {\n\t\tsps->log2_max_poc_lsb = gf_bs_read_ue_log(bs, \"log2_max_poc_lsb\") + 4;\n\t}\n\telse if (sps->poc_type == 1) {\n\t\tsps->delta_pic_order_always_zero_flag = gf_bs_read_int_log(bs, 1, \"delta_pic_order_always_zero_flag\");\n\t\tsps->offset_for_non_ref_pic = gf_bs_read_se_log(bs, \"offset_for_non_ref_pic\");\n\t\tsps->offset_for_top_to_bottom_field = gf_bs_read_se_log(bs, \"offset_for_top_to_bottom_field\");\n\t\tsps->poc_cycle_length = gf_bs_read_ue_log(bs, \"poc_cycle_length\");\n\t\tif (sps->poc_cycle_length > GF_ARRAY_LENGTH(sps->offset_for_ref_frame)) {\n\t\t\tsps->poc_cycle_length = 255;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = 0; i < sps->poc_cycle_length; i++)\n\t\t\tsps->offset_for_ref_frame[i] = gf_bs_read_se_log_idx(bs, \"offset_for_ref_frame\", i);\n\t}\n\tif (sps->poc_type > 2) {\n\t\treturn -1;\n\t}\n\tsps->max_num_ref_frames = gf_bs_read_ue_log(bs, \"max_num_ref_frames\");\n\tsps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int_log(bs, 1, \"gaps_in_frame_num_value_allowed_flag\");\n\tmb_width = gf_bs_read_ue_log(bs, \"pic_width_in_mbs_minus1\") + 1;\n\tmb_height = gf_bs_read_ue_log(bs, \"pic_height_in_map_units_minus1\") + 1;\n\n\tsps->frame_mbs_only_flag = gf_bs_read_int_log(bs, 1, \"frame_mbs_only_flag\");\n\n\tsps->width = mb_width * 16;\n\tsps->height = (2 - sps->frame_mbs_only_flag) * mb_height * 16;\n\n\tif (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int_log(bs, 1, \"mb_adaptive_frame_field_flag\");\n\tgf_bs_read_int_log(bs, 1, \"direct_8x8_inference_flag\");\n\n\tif (gf_bs_read_int_log(bs, 1, \"frame_cropping_flag\")) {\n\t\tint CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1;\n\n\t\tif (chroma_format_idc == 1) {\n\t\t\tSubWidthC = 2; SubHeightC = 2;\n\t\t}\n\t\telse if (chroma_format_idc == 2) {\n\t\t\tSubWidthC = 2; SubHeightC = 1;\n\t\t}\n\t\telse if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) {\n\t\t\tSubWidthC = 1; SubHeightC = 1;\n\t\t}\n\n\t\tif (sps->ChromaArrayType == 0) {\n\t\t\tassert(SubWidthC == -1);\n\t\t\tCropUnitX = 1;\n\t\t\tCropUnitY = 2 - sps->frame_mbs_only_flag;\n\t\t}\n\t\telse {\n\t\t\tCropUnitX = SubWidthC;\n\t\t\tCropUnitY = SubHeightC * (2 - sps->frame_mbs_only_flag);\n\t\t}\n\n\t\tcl = gf_bs_read_ue_log(bs, \"frame_crop_left_offset\");\n\t\tcr = gf_bs_read_ue_log(bs, \"frame_crop_right_offset\");\n\t\tct = gf_bs_read_ue_log(bs, \"frame_crop_top_offset\");\n\t\tcb = gf_bs_read_ue_log(bs, \"frame_crop_bottom_offset\");\n\n\t\tsps->width -= CropUnitX * (cl + cr);\n\t\tsps->height -= CropUnitY * (ct + cb);\n\t\tcl *= CropUnitX;\n\t\tcr *= CropUnitX;\n\t\tct *= CropUnitY;\n\t\tcb *= CropUnitY;\n\t}\n\tsps->crop.left = cl;\n\tsps->crop.right = cr;\n\tsps->crop.top = ct;\n\tsps->crop.bottom = cb;\n\n\tif (vui_flag_pos) {\n\t\t*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);\n\t}\n\t/*vui_parameters_present_flag*/\n\tsps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_parameters_present_flag\");\n\tif (sps->vui_parameters_present_flag) {\n\t\tsps->vui.aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, \"aspect_ratio_info_present_flag\");\n\t\tif (sps->vui.aspect_ratio_info_present_flag) {\n\t\t\ts32 aspect_ratio_idc = gf_bs_read_int_log(bs, 8, \"aspect_ratio_idc\");\n\t\t\tif (aspect_ratio_idc == 255) {\n\t\t\t\tsps->vui.par_num = gf_bs_read_int_log(bs, 16, \"aspect_ratio_num\");\n\t\t\t\tsps->vui.par_den = gf_bs_read_int_log(bs, 16, \"aspect_ratio_den\");\n\t\t\t}\n\t\t\telse if (aspect_ratio_idc < GF_ARRAY_LENGTH(avc_hevc_sar) ) {\n\t\t\t\tsps->vui.par_num = avc_hevc_sar[aspect_ratio_idc].w;\n\t\t\t\tsps->vui.par_den = avc_hevc_sar[aspect_ratio_idc].h;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] Unknown aspect_ratio_idc: your video may have a wrong aspect ratio. Contact the GPAC team!\\n\"));\n\t\t\t}\n\t\t}\n\t\tsps->vui.overscan_info_present_flag = gf_bs_read_int_log(bs, 1, \"overscan_info_present_flag\");\n\t\tif (sps->vui.overscan_info_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 1, \"overscan_appropriate_flag\");\n\n\t\t/* default values */\n\t\tsps->vui.video_format = 5;\n\t\tsps->vui.colour_primaries = 2;\n\t\tsps->vui.transfer_characteristics = 2;\n\t\tsps->vui.matrix_coefficients = 2;\n\t\t/* now read values if possible */\n\t\tsps->vui.video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, \"video_signal_type_present_flag\");\n\t\tif (sps->vui.video_signal_type_present_flag) {\n\t\t\tsps->vui.video_format = gf_bs_read_int_log(bs, 3, \"video_format\");\n\t\t\tsps->vui.video_full_range_flag = gf_bs_read_int_log(bs, 1, \"video_full_range_flag\");\n\t\t\tsps->vui.colour_description_present_flag = gf_bs_read_int_log(bs, 1, \"colour_description_present_flag\");\n\t\t\tif (sps->vui.colour_description_present_flag) {\n\t\t\t\tsps->vui.colour_primaries = gf_bs_read_int_log(bs, 8, \"colour_primaries\");\n\t\t\t\tsps->vui.transfer_characteristics = gf_bs_read_int_log(bs, 8, \"transfer_characteristics\");\n\t\t\t\tsps->vui.matrix_coefficients = gf_bs_read_int_log(bs, 8, \"matrix_coefficients\");\n\t\t\t}\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \"chroma_location_info_present_flag\")) {\n\t\t\tgf_bs_read_ue_log(bs, \"chroma_sample_location_type_top_field\");\n\t\t\tgf_bs_read_ue_log(bs, \"chroma_sample_location_type_bottom_field\");\n\t\t}\n\n\t\tsps->vui.timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"timing_info_present_flag\");\n\t\tif (sps->vui.timing_info_present_flag) {\n\t\t\tsps->vui.num_units_in_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_tick\");\n\t\t\tsps->vui.time_scale = gf_bs_read_int_log(bs, 32, \"time_scale\");\n\t\t\tsps->vui.fixed_frame_rate_flag = gf_bs_read_int_log(bs, 1, \"fixed_frame_rate_flag\");\n\t\t}\n\n\t\tsps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"nal_hrd_parameters_present_flag\");\n\t\tif (sps->vui.nal_hrd_parameters_present_flag)\n\t\t\tif (avc_parse_hrd_parameters(bs, &sps->vui.hrd)<0) return -1;\n\n\t\tsps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vcl_hrd_parameters_present_flag\");\n\t\tif (sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tif (avc_parse_hrd_parameters(bs, &sps->vui.hrd)<0) return -1;\n\n\t\tif (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tsps->vui.low_delay_hrd_flag = gf_bs_read_int_log(bs, 1, \"low_delay_hrd_flag\");\n\n\t\tsps->vui.pic_struct_present_flag = gf_bs_read_int_log(bs, 1, \"pic_struct_present_flag\");\n\t}\n\t/*end of seq_parameter_set_data*/\n\n\tif (subseq_sps) {\n\t\tif ((profile_idc == 83) || (profile_idc == 86)) {\n\t\t\tu8 extended_spatial_scalability_idc;\n\t\t\t/*parsing seq_parameter_set_svc_extension*/\n\n\t\t\tgf_bs_read_int_log(bs, 1, \"inter_layer_deblocking_filter_control_present_flag\");\n\t\t\textended_spatial_scalability_idc = gf_bs_read_int_log(bs, 2, \"extended_spatial_scalability_idc\");\n\t\t\tif (sps->ChromaArrayType == 1 || sps->ChromaArrayType == 2) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"chroma_phase_x_plus1_flag\");\n\t\t\t}\n\t\t\tif (sps->ChromaArrayType == 1) {\n\t\t\t\tgf_bs_read_int_log(bs, 2, \"chroma_phase_y_plus1\");\n\t\t\t}\n\t\t\tif (extended_spatial_scalability_idc == 1) {\n\t\t\t\tif (sps->ChromaArrayType > 0) {\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"seq_ref_layer_chroma_phase_x_plus1_flag\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 2, \"seq_ref_layer_chroma_phase_y_plus1\");\n\t\t\t\t}\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_left_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_top_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_right_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_bottom_offset\");\n\t\t\t}\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"seq_tcoeff_level_prediction_flag\")) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"adaptive_tcoeff_level_prediction_flag\");\n\t\t\t}\n\t\t\tgf_bs_read_int_log(bs, 1, \"slice_header_restriction_flag\");\n\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"svc_vui_parameters_present\")) {\n\t\t\t\tu32 vui_ext_num_entries_minus1 = gf_bs_read_ue_log(bs, \"vui_ext_num_entries_minus1\");\n\n\t\t\t\tfor (i = 0; i <= vui_ext_num_entries_minus1; i++) {\n\t\t\t\t\tu8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag;\n\t\t\t\t\tgf_bs_read_int_log(bs, 3, \"vui_ext_dependency_id\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 4, \"vui_ext_quality_id\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 3, \"vui_ext_temporal_id\");\n\t\t\t\t\tvui_ext_timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_timing_info_present_flag\");\n\t\t\t\t\tif (vui_ext_timing_info_present_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 32, \"vui_ext_num_units_in_tick\");\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 32, \"vui_ext_time_scale\");\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_fixed_frame_rate_flag\");\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_nal_hrd_parameters_present_flag\");\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_vcl_hrd_parameters_present_flag\");\n\t\t\t\t\tif (vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag || vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_low_delay_hrd_flag\");\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_pic_struct_present_flag\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ((profile_idc == 118) || (profile_idc == 128)) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\"[avc-h264] MVC parsing not implemented - skipping parsing end of Subset SPS\\n\"));\n\t\t\treturn sps_id;\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \"additional_extension2\")) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\\n\"));\n\t\t\treturn sps_id;\n\t\t}\n\t}\n\treturn sps_id;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -226,11 +226,11 @@\n \n \t\tsps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"nal_hrd_parameters_present_flag\");\n \t\tif (sps->vui.nal_hrd_parameters_present_flag)\n-\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n+\t\t\tif (avc_parse_hrd_parameters(bs, &sps->vui.hrd)<0) return -1;\n \n \t\tsps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vcl_hrd_parameters_present_flag\");\n \t\tif (sps->vui.vcl_hrd_parameters_present_flag)\n-\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n+\t\t\tif (avc_parse_hrd_parameters(bs, &sps->vui.hrd)<0) return -1;\n \n \t\tif (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)\n \t\t\tsps->vui.low_delay_hrd_flag = gf_bs_read_int_log(bs, 1, \"low_delay_hrd_flag\");",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);",
                "\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);"
            ],
            "added_lines": [
                "\t\t\tif (avc_parse_hrd_parameters(bs, &sps->vui.hrd)<0) return -1;",
                "\t\t\tif (avc_parse_hrd_parameters(bs, &sps->vui.hrd)<0) return -1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-44924",
        "func_name": "gpac/avc_parse_hrd_parameters",
        "description": "An infinite loop vulnerability exists in gpac 1.1.0 in the gf_log function, which causes a Denial of Service.",
        "git_url": "https://github.com/gpac/gpac/commit/e2acb1511d1e69115141ea3080afd1cce6a15497",
        "commit_title": "fixed #1959",
        "commit_text": "",
        "func_before": "static void avc_parse_hrd_parameters(GF_BitStream *bs, AVC_HRD *hrd)\n{\n\tint i, cpb_cnt_minus1;\n\n\tcpb_cnt_minus1 = gf_bs_read_ue_log(bs, \"cpb_cnt_minus1\");\n\tif (cpb_cnt_minus1 > 31)\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] invalid cpb_cnt_minus1 value: %d (expected in [0;31])\\n\", cpb_cnt_minus1));\n\tgf_bs_read_int_log(bs, 4, \"bit_rate_scale\");\n\tgf_bs_read_int_log(bs, 4, \"cpb_size_scale\");\n\n\t/*for( SchedSelIdx = 0; SchedSelIdx <= cpb_cnt_minus1; SchedSelIdx++ ) {*/\n\tfor (i = 0; i <= cpb_cnt_minus1; i++) {\n\t\tgf_bs_read_ue_log_idx(bs, \"bit_rate_value_minus1\", i);\n\t\tgf_bs_read_ue_log_idx(bs, \"cpb_size_value_minus1\", i);\n\t\tgf_bs_read_int_log_idx(bs, 1, \"cbr_flag\", i);\n\t}\n\tgf_bs_read_int_log(bs, 5, \"initial_cpb_removal_delay_length_minus1\");\n\thrd->cpb_removal_delay_length_minus1 = gf_bs_read_int_log(bs, 5, \"cpb_removal_delay_length_minus1\");\n\thrd->dpb_output_delay_length_minus1 = gf_bs_read_int_log(bs, 5, \"dpb_output_delay_length_minus1\");\n\thrd->time_offset_length = gf_bs_read_int_log(bs, 5, \"time_offset_length\");\n\treturn;\n}",
        "func": "static s32 avc_parse_hrd_parameters(GF_BitStream *bs, AVC_HRD *hrd)\n{\n\tint i, cpb_cnt_minus1;\n\n\tcpb_cnt_minus1 = gf_bs_read_ue_log(bs, \"cpb_cnt_minus1\");\n\tif (cpb_cnt_minus1 > 31) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] invalid cpb_cnt_minus1 value: %d (expected in [0;31])\\n\", cpb_cnt_minus1));\n\t\treturn -1;\n\t}\n\tgf_bs_read_int_log(bs, 4, \"bit_rate_scale\");\n\tgf_bs_read_int_log(bs, 4, \"cpb_size_scale\");\n\n\t/*for( SchedSelIdx = 0; SchedSelIdx <= cpb_cnt_minus1; SchedSelIdx++ ) {*/\n\tfor (i = 0; i <= cpb_cnt_minus1; i++) {\n\t\tgf_bs_read_ue_log_idx(bs, \"bit_rate_value_minus1\", i);\n\t\tgf_bs_read_ue_log_idx(bs, \"cpb_size_value_minus1\", i);\n\t\tgf_bs_read_int_log_idx(bs, 1, \"cbr_flag\", i);\n\t}\n\tgf_bs_read_int_log(bs, 5, \"initial_cpb_removal_delay_length_minus1\");\n\thrd->cpb_removal_delay_length_minus1 = gf_bs_read_int_log(bs, 5, \"cpb_removal_delay_length_minus1\");\n\thrd->dpb_output_delay_length_minus1 = gf_bs_read_int_log(bs, 5, \"dpb_output_delay_length_minus1\");\n\thrd->time_offset_length = gf_bs_read_int_log(bs, 5, \"time_offset_length\");\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,12 @@\n-static void avc_parse_hrd_parameters(GF_BitStream *bs, AVC_HRD *hrd)\n+static s32 avc_parse_hrd_parameters(GF_BitStream *bs, AVC_HRD *hrd)\n {\n \tint i, cpb_cnt_minus1;\n \n \tcpb_cnt_minus1 = gf_bs_read_ue_log(bs, \"cpb_cnt_minus1\");\n-\tif (cpb_cnt_minus1 > 31)\n+\tif (cpb_cnt_minus1 > 31) {\n \t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] invalid cpb_cnt_minus1 value: %d (expected in [0;31])\\n\", cpb_cnt_minus1));\n+\t\treturn -1;\n+\t}\n \tgf_bs_read_int_log(bs, 4, \"bit_rate_scale\");\n \tgf_bs_read_int_log(bs, 4, \"cpb_size_scale\");\n \n@@ -18,5 +20,5 @@\n \thrd->cpb_removal_delay_length_minus1 = gf_bs_read_int_log(bs, 5, \"cpb_removal_delay_length_minus1\");\n \thrd->dpb_output_delay_length_minus1 = gf_bs_read_int_log(bs, 5, \"dpb_output_delay_length_minus1\");\n \thrd->time_offset_length = gf_bs_read_int_log(bs, 5, \"time_offset_length\");\n-\treturn;\n+\treturn 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static void avc_parse_hrd_parameters(GF_BitStream *bs, AVC_HRD *hrd)",
                "\tif (cpb_cnt_minus1 > 31)",
                "\treturn;"
            ],
            "added_lines": [
                "static s32 avc_parse_hrd_parameters(GF_BitStream *bs, AVC_HRD *hrd)",
                "\tif (cpb_cnt_minus1 > 31) {",
                "\t\treturn -1;",
                "\t}",
                "\treturn 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-4182",
        "func_name": "wireshark/dissect_rfc7468",
        "description": "Crash in the RFC 7468 dissector in Wireshark 3.6.0 and 3.4.0 to 3.4.10 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/b3215d99cacbcd2613157d10f11b233b35b5d10b",
        "commit_title": "rfc7468: don't use for (;;) for tvb_find_line_end() loops.",
        "commit_text": " If you're past the end of the tvbuff, tvb_find_line_end() will, when reassembly is not being done, return a zero-length line without advancing next_offset, so, unless you check for being past the end of the tvbuff, you'll loop forever.  Fixes #17801. ",
        "func_before": "static gint\ndissect_rfc7468(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\n{\n    int offset;\n    int linelen;\n    int next_offset;\n    const guchar *line;\n    const guchar *labelp;\n    int labellen;\n    char *label;\n    proto_tree *rfc7468_tree, *preeb_tree, *posteb_tree;\n    proto_item *rfc7468_item, *ti;\n\n    offset = 0;\n    rfc7468_item = proto_tree_add_item(tree, proto_rfc7468, tvb, offset, -1, ENC_NA);\n    rfc7468_tree = proto_item_add_subtree(rfc7468_item, ett_rfc7468);\n\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"rfc7468\");\n\n    /*\n     * First, process the text lines prior to the pre-encapsulation\n     * boundary; they're explanatory text lines.\n     */\n    for (;;) {\n        linelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);\n        if (linelen == -1) {\n            /* No complete line was found.  Nothing more to do. */\n            return tvb_captured_length(tvb);\n        }\n\n        /*\n         * Get a buffer that refers to the line.\n         *\n         * Note that \"tvb_find_line_end()\" will return a value that\n         * is not longer than what's in the buffer, so the\n         * \"tvb_get_ptr()\" call won't throw an exception.\n         */\n        line = tvb_get_ptr(tvb, offset, linelen);\n\n        /*\n         * Is this line a pre-encapulation boundary?\n         */\n        if (line_is_eb(line, linelen, preeb_prefix, sizeof preeb_prefix - 1,\n                       &labelp, &labellen)) {\n            /*\n             * Yes - we're finished with the explanatory text lines.\n             */\n            break;\n        }\n\n        /*\n         * Add this line to the dissection.\n         */\n        proto_tree_add_format_text(rfc7468_tree, tvb, offset, next_offset - offset);\n\n        /*\n         * Step to the next line.\n         */\n        offset = next_offset;\n    }\n\n    /*\n     * This line is the pre-encapsulation boundary.\n     * Put it into the protocol tree, and create a subtree under it.\n     */\n    ti = proto_tree_add_format_text(rfc7468_tree, tvb, offset, next_offset - offset);\n    preeb_tree = proto_item_add_subtree(ti, ett_rfc7468_preeb);\n\n    /*\n     * Extract the label, and put it in that subtree.\n     */\n    label = wmem_strndup(pinfo->pool, labelp, labellen);\n    proto_tree_add_item(preeb_tree, hf_rfc7468_preeb_label, tvb,\n                        offset + (int)preeb_prefix_len, labellen,  ENC_ASCII|ENC_NA);\n\n    col_add_fstr(pinfo->cinfo, COL_INFO, \"Label: %s\", label);\n\n    /*\n     * Step to the next line.\n     */\n    offset = next_offset;\n\n    /*\n     * Skip over any blank lines before the base64 information.\n     */\n    for (;;) {\n        linelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);\n        if (linelen == -1) {\n            /* No complete line was found.  We're done. */\n            return tvb_captured_length(tvb);\n        }\n\n        /*\n         * Get a buffer that refers to the line.\n         *\n         * Note that \"tvb_find_line_end()\" will return a value that\n         * is not longer than what's in the buffer, so the\n         * \"tvb_get_ptr()\" call won't throw an exception.\n         */\n        line = tvb_get_ptr(tvb, offset, linelen);\n\n        /*\n         * Is the line entirely blank (space or tab)?\n         */\n        if (!line_is_blank(line, linelen)) {\n            /*\n             * No.\n             */\n            break;\n        }\n\n        /*\n         * Add this line to the dissection.\n         */\n        proto_tree_add_format_text(rfc7468_tree, tvb, offset, next_offset - offset);\n\n        /*\n         * Step to the next line.\n         */\n        offset = next_offset;\n    }\n\n    /*\n     * OK, this should be base64-encoded binary data.\n     */\n    guint8 *databuf = NULL;\n    gsize databufsize = 0;\n    gint base64_state = 0;\n    guint base64_save = 0;\n    guint datasize = 0;\n    for (;;) {\n        linelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);\n        if (linelen == -1) {\n            /*\n             * No complete line was found.  Nothing more to do.\n             */\n            return tvb_captured_length(tvb);\n        }\n\n        /*\n         * Get a buffer that refers to the line.\n         *\n         * Note that \"tvb_find_line_end()\" will return a value that\n         * is not longer than what's in the buffer, so the\n         * \"tvb_get_ptr()\" call won't throw an exception.\n         */\n        line = tvb_get_ptr(tvb, offset, linelen);\n\n        /*\n         * Is this line a post-encapulation boundary?\n         */\n        if (line_is_eb(line, linelen, posteb_prefix, sizeof posteb_prefix - 1,\n                       &labelp, &labellen)) {\n            /*\n             * Yes - we're done with the base64 data.\n             */\n            break;\n        }\n\n        /*\n         * Add this line to the dissection.\n         */\n        proto_tree_add_format_text(rfc7468_tree, tvb, offset, next_offset - offset);\n\n        /*\n         * Decode it and add that to the buffer.\n         * First, grow the buffer as needed.\n         */\n        databufsize += (linelen / 4) * 3 + 3;\n        databuf = (guint8 *)wmem_realloc(pinfo->pool, databuf, databufsize);\n\n        /*\n         * Now decode into it.\n         */\n        guint decodesize = (guint)g_base64_decode_step(line, linelen,\n                                                       &databuf[datasize],\n                                                       &base64_state,\n                                                       &base64_save);\n        datasize += decodesize;\n\n        /*\n         * Step to the next line.\n         */\n        offset = next_offset;\n    }\n\n    /*\n     * Make a tvbuff for the data, and put it into the protocol tree,\n     * if we have any.\n     */\n    if (datasize != 0) {\n        tvbuff_t *data_tvb;\n\n        data_tvb = tvb_new_child_real_data(tvb, databuf, datasize, datasize);\n        add_new_data_source(pinfo, data_tvb, \"Base64-encoded data\");\n\n        /*\n         * Try to decode it based on the label.\n         */\n        if (dissector_try_string(rfc7468_label_table, label, data_tvb, pinfo,\n                                 tree, NULL) == 0) {\n            proto_tree *data_tree;\n\n            /*\n             * No known dissector; decode it as BER.\n             */\n            ti = proto_tree_add_item(tree, hf_rfc7468_ber_data, data_tvb, 0, -1, ENC_NA);\n            data_tree = proto_item_add_subtree(ti, ett_rfc7468_data);\n            call_dissector(ber_handle, data_tvb, pinfo, data_tree);\n        }\n    }\n\n    /*\n     * This line is the post-encapsulation boundary.\n     * Put it into the protocol tree, and create a subtree under it.\n     */\n    ti = proto_tree_add_format_text(rfc7468_tree, tvb, offset, next_offset - offset);\n    posteb_tree = proto_item_add_subtree(ti, ett_rfc7468_posteb);\n\n    /*\n     * Extract the label, and put it in that subtree.\n     */\n    proto_tree_add_item(posteb_tree, hf_rfc7468_posteb_label, tvb,\n                        offset + (int)posteb_prefix_len, labellen,  ENC_ASCII|ENC_NA);\n\n    return tvb_captured_length(tvb);\n}",
        "func": "static gint\ndissect_rfc7468(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_)\n{\n    int offset;\n    int linelen;\n    int next_offset;\n    const guchar *line;\n    const guchar *labelp;\n    int labellen;\n    char *label;\n    proto_tree *rfc7468_tree, *preeb_tree, *posteb_tree;\n    proto_item *rfc7468_item, *ti;\n\n    offset = 0;\n    rfc7468_item = proto_tree_add_item(tree, proto_rfc7468, tvb, offset, -1, ENC_NA);\n    rfc7468_tree = proto_item_add_subtree(rfc7468_item, ett_rfc7468);\n\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"rfc7468\");\n\n    /*\n     * First, process the text lines prior to the pre-encapsulation\n     * boundary; they're explanatory text lines.\n     */\n    while (tvb_offset_exists(tvb, offset)) {\n        linelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);\n        if (linelen == -1) {\n            /* No complete line was found.  Nothing more to do. */\n            return tvb_captured_length(tvb);\n        }\n\n        /*\n         * Get a buffer that refers to the line.\n         *\n         * Note that \"tvb_find_line_end()\" will return a value that\n         * is not longer than what's in the buffer, so the\n         * \"tvb_get_ptr()\" call won't throw an exception.\n         */\n        line = tvb_get_ptr(tvb, offset, linelen);\n\n        /*\n         * Is this line a pre-encapulation boundary?\n         */\n        if (line_is_eb(line, linelen, preeb_prefix, sizeof preeb_prefix - 1,\n                       &labelp, &labellen)) {\n            /*\n             * Yes - we're finished with the explanatory text lines.\n             */\n            break;\n        }\n\n        /*\n         * Add this line to the dissection.\n         */\n        proto_tree_add_format_text(rfc7468_tree, tvb, offset, next_offset - offset);\n\n        /*\n         * Step to the next line.\n         */\n        offset = next_offset;\n    }\n\n    /*\n     * This line is the pre-encapsulation boundary.\n     * Put it into the protocol tree, and create a subtree under it.\n     */\n    ti = proto_tree_add_format_text(rfc7468_tree, tvb, offset, next_offset - offset);\n    preeb_tree = proto_item_add_subtree(ti, ett_rfc7468_preeb);\n\n    /*\n     * Extract the label, and put it in that subtree.\n     */\n    label = wmem_strndup(pinfo->pool, labelp, labellen);\n    proto_tree_add_item(preeb_tree, hf_rfc7468_preeb_label, tvb,\n                        offset + (int)preeb_prefix_len, labellen,  ENC_ASCII|ENC_NA);\n\n    col_add_fstr(pinfo->cinfo, COL_INFO, \"Label: %s\", label);\n\n    /*\n     * Step to the next line.\n     */\n    offset = next_offset;\n\n    /*\n     * Skip over any blank lines before the base64 information.\n     */\n    while (tvb_offset_exists(tvb, offset)) {\n        linelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);\n        if (linelen == -1) {\n            /* No complete line was found.  We're done. */\n            return tvb_captured_length(tvb);\n        }\n\n        /*\n         * Get a buffer that refers to the line.\n         *\n         * Note that \"tvb_find_line_end()\" will return a value that\n         * is not longer than what's in the buffer, so the\n         * \"tvb_get_ptr()\" call won't throw an exception.\n         */\n        line = tvb_get_ptr(tvb, offset, linelen);\n\n        /*\n         * Is the line entirely blank (space or tab)?\n         */\n        if (!line_is_blank(line, linelen)) {\n            /*\n             * No.\n             */\n            break;\n        }\n\n        /*\n         * Add this line to the dissection.\n         */\n        proto_tree_add_format_text(rfc7468_tree, tvb, offset, next_offset - offset);\n\n        /*\n         * Step to the next line.\n         */\n        offset = next_offset;\n    }\n\n    /*\n     * OK, this should be base64-encoded binary data.\n     */\n    guint8 *databuf = NULL;\n    gsize databufsize = 0;\n    gint base64_state = 0;\n    guint base64_save = 0;\n    guint datasize = 0;\n    while (tvb_offset_exists(tvb, offset)) {\n        linelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);\n        if (linelen == -1) {\n            /*\n             * No complete line was found.  Nothing more to do.\n             */\n            return tvb_captured_length(tvb);\n        }\n\n        /*\n         * Get a buffer that refers to the line.\n         *\n         * Note that \"tvb_find_line_end()\" will return a value that\n         * is not longer than what's in the buffer, so the\n         * \"tvb_get_ptr()\" call won't throw an exception.\n         */\n        line = tvb_get_ptr(tvb, offset, linelen);\n\n        /*\n         * Is this line a post-encapulation boundary?\n         */\n        if (line_is_eb(line, linelen, posteb_prefix, sizeof posteb_prefix - 1,\n                       &labelp, &labellen)) {\n            /*\n             * Yes - we're done with the base64 data.\n             */\n            break;\n        }\n\n        /*\n         * Add this line to the dissection.\n         */\n        proto_tree_add_format_text(rfc7468_tree, tvb, offset, next_offset - offset);\n\n        /*\n         * Decode it and add that to the buffer.\n         * First, grow the buffer as needed.\n         */\n        databufsize += (linelen / 4) * 3 + 3;\n        databuf = (guint8 *)wmem_realloc(pinfo->pool, databuf, databufsize);\n\n        /*\n         * Now decode into it.\n         */\n        guint decodesize = (guint)g_base64_decode_step(line, linelen,\n                                                       &databuf[datasize],\n                                                       &base64_state,\n                                                       &base64_save);\n        datasize += decodesize;\n\n        /*\n         * Step to the next line.\n         */\n        offset = next_offset;\n    }\n\n    /*\n     * Make a tvbuff for the data, and put it into the protocol tree,\n     * if we have any.\n     */\n    if (datasize != 0) {\n        tvbuff_t *data_tvb;\n\n        data_tvb = tvb_new_child_real_data(tvb, databuf, datasize, datasize);\n        add_new_data_source(pinfo, data_tvb, \"Base64-encoded data\");\n\n        /*\n         * Try to decode it based on the label.\n         */\n        if (dissector_try_string(rfc7468_label_table, label, data_tvb, pinfo,\n                                 tree, NULL) == 0) {\n            proto_tree *data_tree;\n\n            /*\n             * No known dissector; decode it as BER.\n             */\n            ti = proto_tree_add_item(tree, hf_rfc7468_ber_data, data_tvb, 0, -1, ENC_NA);\n            data_tree = proto_item_add_subtree(ti, ett_rfc7468_data);\n            call_dissector(ber_handle, data_tvb, pinfo, data_tree);\n        }\n    }\n\n    /*\n     * This line is the post-encapsulation boundary.\n     * Put it into the protocol tree, and create a subtree under it.\n     */\n    ti = proto_tree_add_format_text(rfc7468_tree, tvb, offset, next_offset - offset);\n    posteb_tree = proto_item_add_subtree(ti, ett_rfc7468_posteb);\n\n    /*\n     * Extract the label, and put it in that subtree.\n     */\n    proto_tree_add_item(posteb_tree, hf_rfc7468_posteb_label, tvb,\n                        offset + (int)posteb_prefix_len, labellen,  ENC_ASCII|ENC_NA);\n\n    return tvb_captured_length(tvb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,7 +21,7 @@\n      * First, process the text lines prior to the pre-encapsulation\n      * boundary; they're explanatory text lines.\n      */\n-    for (;;) {\n+    while (tvb_offset_exists(tvb, offset)) {\n         linelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);\n         if (linelen == -1) {\n             /* No complete line was found.  Nothing more to do. */\n@@ -83,7 +83,7 @@\n     /*\n      * Skip over any blank lines before the base64 information.\n      */\n-    for (;;) {\n+    while (tvb_offset_exists(tvb, offset)) {\n         linelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);\n         if (linelen == -1) {\n             /* No complete line was found.  We're done. */\n@@ -128,7 +128,7 @@\n     gint base64_state = 0;\n     guint base64_save = 0;\n     guint datasize = 0;\n-    for (;;) {\n+    while (tvb_offset_exists(tvb, offset)) {\n         linelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);\n         if (linelen == -1) {\n             /*",
        "diff_line_info": {
            "deleted_lines": [
                "    for (;;) {",
                "    for (;;) {",
                "    for (;;) {"
            ],
            "added_lines": [
                "    while (tvb_offset_exists(tvb, offset)) {",
                "    while (tvb_offset_exists(tvb, offset)) {",
                "    while (tvb_offset_exists(tvb, offset)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-4184",
        "func_name": "wireshark/dissect_bt_dht_values",
        "description": "Infinite loop in the BitTorrent DHT dissector in Wireshark 3.6.0 and 3.4.0 to 3.4.10 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/ebcba787a0c27183db63fc8a1fae798f2d09633a",
        "commit_title": "BT-DHT: Fix endless loop",
        "commit_text": " The correct return value for an error condition is 0, which will cause the caller to then report an error. Fix #17754. ",
        "func_before": "static int\ndissect_bt_dht_values(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint offset, const char **result, const char *label )\n{\n  proto_item *ti;\n  proto_tree *sub_tree;\n  proto_item *value_ti;\n  proto_tree *value_tree;\n\n  guint       peer_index;\n  guint       string_len;\n\n  ti = proto_tree_add_item( tree, hf_bt_dht_peers, tvb, offset, 0, ENC_NA );\n  sub_tree = proto_item_add_subtree( ti, ett_bt_dht_peers);\n\n  peer_index = 0;\n  /* we has confirmed that the first byte is 'l' */\n  offset += 1;\n\n  /* dissect bt-dht values */\n  while( tvb_get_guint8(tvb,offset)!='e' )\n  {\n    string_len = bencoded_string_length(pinfo, tvb, &offset);\n\n    if (string_len == 0)\n    {\n      expert_add_info(pinfo, ti, &ei_invalid_len);\n      // Fail hard here rather than potentially looping excessively.\n      return tvb_reported_length_remaining(tvb, offset);\n    }\n    else if (string_len == 6)\n    {\n      /* 4 bytes ip, 2 bytes port */\n      peer_index += 1;\n\n      value_ti = proto_tree_add_item( sub_tree, hf_bt_dht_peer, tvb, offset, 6, ENC_NA );\n      proto_item_append_text(value_ti, \" %d\", peer_index);\n      value_tree = proto_item_add_subtree( value_ti, ett_bt_dht_peers);\n\n      proto_tree_add_item( value_tree, hf_ip, tvb, offset, 4, ENC_BIG_ENDIAN);\n      proto_item_append_text(value_ti, \" (IP/Port: %s\", tvb_ip_to_str(pinfo->pool, tvb, offset));\n      proto_tree_add_item( value_tree, hf_port, tvb, offset+4, 2, ENC_BIG_ENDIAN);\n      proto_item_append_text(value_ti, \":%u)\", tvb_get_ntohs( tvb, offset+4 ));\n    }\n    else if (string_len == 18)\n    {\n      /* 16 bytes ip, 2 bytes port */\n      peer_index += 1;\n\n      value_ti = proto_tree_add_item( sub_tree, hf_bt_dht_peer, tvb, offset, 18, ENC_NA );\n      proto_item_append_text(value_ti, \" %d\", peer_index);\n      value_tree = proto_item_add_subtree( value_ti, ett_bt_dht_peers);\n\n      proto_tree_add_item( value_tree, hf_ip6, tvb, offset, 16, ENC_NA);\n      proto_item_append_text(value_ti, \" (IPv6/Port: [%s]\", tvb_ip6_to_str(pinfo->pool, tvb, offset));\n      proto_tree_add_item( value_tree, hf_port, tvb, offset+16, 2, ENC_BIG_ENDIAN);\n      proto_item_append_text(value_ti, \":%u)\", tvb_get_ntohs( tvb, offset+16 ));\n    }\n    else\n    {\n      /* truncated data */\n      proto_tree_add_item( tree, hf_truncated_data, tvb, offset, string_len, ENC_NA );\n    }\n\n    offset += string_len;\n  }\n\n  if (tvb_get_guint8(tvb,offset)=='e') { /* list ending delimiter */\n    proto_tree_add_item(sub_tree, hf_bencoded_list_terminator, tvb, offset, 1, ENC_ASCII|ENC_NA);\n    offset++;\n  }\n\n  proto_item_set_text( ti, \"%s: %d peers\", label, peer_index );\n  col_append_fstr( pinfo->cinfo, COL_INFO, \" reply=%d peers\", peer_index );\n  *result = wmem_strdup_printf(pinfo->pool, \"%d peers\", peer_index);\n\n  return offset;\n}",
        "func": "static int\ndissect_bt_dht_values(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint offset, const char **result, const char *label )\n{\n  proto_item *ti;\n  proto_tree *sub_tree;\n  proto_item *value_ti;\n  proto_tree *value_tree;\n\n  guint       peer_index;\n  guint       string_len;\n\n  ti = proto_tree_add_item( tree, hf_bt_dht_peers, tvb, offset, 0, ENC_NA );\n  sub_tree = proto_item_add_subtree( ti, ett_bt_dht_peers);\n\n  peer_index = 0;\n  /* we has confirmed that the first byte is 'l' */\n  offset += 1;\n\n  /* dissect bt-dht values */\n  while( tvb_get_guint8(tvb,offset)!='e' )\n  {\n    string_len = bencoded_string_length(pinfo, tvb, &offset);\n\n    if (string_len == 0)\n    {\n      expert_add_info(pinfo, ti, &ei_invalid_len);\n      // Fail hard here rather than potentially looping excessively.\n      return 0;\n    }\n    else if (string_len == 6)\n    {\n      /* 4 bytes ip, 2 bytes port */\n      peer_index += 1;\n\n      value_ti = proto_tree_add_item( sub_tree, hf_bt_dht_peer, tvb, offset, 6, ENC_NA );\n      proto_item_append_text(value_ti, \" %d\", peer_index);\n      value_tree = proto_item_add_subtree( value_ti, ett_bt_dht_peers);\n\n      proto_tree_add_item( value_tree, hf_ip, tvb, offset, 4, ENC_BIG_ENDIAN);\n      proto_item_append_text(value_ti, \" (IP/Port: %s\", tvb_ip_to_str(pinfo->pool, tvb, offset));\n      proto_tree_add_item( value_tree, hf_port, tvb, offset+4, 2, ENC_BIG_ENDIAN);\n      proto_item_append_text(value_ti, \":%u)\", tvb_get_ntohs( tvb, offset+4 ));\n    }\n    else if (string_len == 18)\n    {\n      /* 16 bytes ip, 2 bytes port */\n      peer_index += 1;\n\n      value_ti = proto_tree_add_item( sub_tree, hf_bt_dht_peer, tvb, offset, 18, ENC_NA );\n      proto_item_append_text(value_ti, \" %d\", peer_index);\n      value_tree = proto_item_add_subtree( value_ti, ett_bt_dht_peers);\n\n      proto_tree_add_item( value_tree, hf_ip6, tvb, offset, 16, ENC_NA);\n      proto_item_append_text(value_ti, \" (IPv6/Port: [%s]\", tvb_ip6_to_str(pinfo->pool, tvb, offset));\n      proto_tree_add_item( value_tree, hf_port, tvb, offset+16, 2, ENC_BIG_ENDIAN);\n      proto_item_append_text(value_ti, \":%u)\", tvb_get_ntohs( tvb, offset+16 ));\n    }\n    else\n    {\n      /* truncated data */\n      proto_tree_add_item( tree, hf_truncated_data, tvb, offset, string_len, ENC_NA );\n    }\n\n    offset += string_len;\n  }\n\n  if (tvb_get_guint8(tvb,offset)=='e') { /* list ending delimiter */\n    proto_tree_add_item(sub_tree, hf_bencoded_list_terminator, tvb, offset, 1, ENC_ASCII|ENC_NA);\n    offset++;\n  }\n\n  proto_item_set_text( ti, \"%s: %d peers\", label, peer_index );\n  col_append_fstr( pinfo->cinfo, COL_INFO, \" reply=%d peers\", peer_index );\n  *result = wmem_strdup_printf(pinfo->pool, \"%d peers\", peer_index);\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,7 +25,7 @@\n     {\n       expert_add_info(pinfo, ti, &ei_invalid_len);\n       // Fail hard here rather than potentially looping excessively.\n-      return tvb_reported_length_remaining(tvb, offset);\n+      return 0;\n     }\n     else if (string_len == 6)\n     {",
        "diff_line_info": {
            "deleted_lines": [
                "      return tvb_reported_length_remaining(tvb, offset);"
            ],
            "added_lines": [
                "      return 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-4185",
        "func_name": "wireshark/dissect_rtmpt_common",
        "description": "Infinite loop in the RTMPT dissector in Wireshark 3.6.0 and 3.4.0 to 3.4.10 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/32bb2a19ee58194a530a3c09a3494b22f99ea583",
        "commit_title": "RTMPT: Fix infinite loop",
        "commit_text": " The RTMPT dissector when over TCP reuses the TCP sequence numbers, so it needs to consider wraparound, which can occur both with the tcp.relative_sequence_numbers preference set to FALSE, or in some unusual cases (such as a SYN packet with a bogus sequence number so that later packets overlap its sequence number.)  Change a sequence number comparison to use the wrap around aware macros from packet-tcp.h Fix #17745. ",
        "func_before": "static void\ndissect_rtmpt_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, rtmpt_conv_t *rconv, int cdir, guint32 seq, guint32 lastackseq)\n{\n        int     offset = 0;\n        int     remain;\n        int     want;\n\n        guint8  header_type;\n        int     basic_hlen;\n        int     message_hlen;\n\n        guint32 id;\n        guint32 ts     = 0;\n        guint32 tsd    = 0;\n        int     body_len;\n        guint8  cmd;\n        guint32 src;\n        int     chunk_size;\n\n        rtmpt_frag_t   *tf;\n        rtmpt_id_t     *ti;\n        rtmpt_packet_t *tp;\n        tvbuff_t       *pktbuf;\n\n        remain = tvb_reported_length(tvb);\n        if (!remain)\n                return;\n\n        RTMPT_DEBUG(\"Segment: cdir=%d seq=%d-%d\\n\", cdir, seq, seq+remain-1);\n\n        if (pinfo->fd->visited) {\n                /* Already done the work, so just dump the existing state */\n                wmem_stack_t *packets;\n\n                /* List all RTMP packets terminating in this TCP segment, from end to beginning */\n\n                packets = wmem_stack_new(wmem_packet_scope());\n                wmem_stack_push(packets, 0);\n\n                tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(rconv->packets[cdir], seq+remain-1);\n                while (tp && tp->lastseq >= seq) {\n                        wmem_stack_push(packets, tp);\n                        if (tp->seq == 0) {\n                                // reached first segment.\n                                break;\n                        }\n                        tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(rconv->packets[cdir], tp->seq-1);\n                }\n\n                /* Dissect the generated list in reverse order (beginning to end) */\n\n                while ((tp=(rtmpt_packet_t *)wmem_stack_pop(packets)) != NULL) {\n                        if (tp->resident) {\n                                pktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have);\n                                add_new_data_source(pinfo, pktbuf, \"Unchunked RTMP\");\n                        } else {\n                                pktbuf = tvb_new_subset_length(tvb, tp->data.offset, tp->have);\n                        }\n                        dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp);\n                }\n\n                return;\n        }\n\n        while (remain>0) {\n                tf = NULL;\n                ti = NULL;\n                tp = NULL;\n\n                /* Check for outstanding fragmented headers/chunks first */\n\n                if (offset == 0) {\n                        tf = (rtmpt_frag_t *)wmem_tree_lookup32_le(rconv->frags[cdir], seq+offset-1);\n\n                        if (tf) {\n                                /* May need to reassemble cross-TCP-segment fragments */\n                                RTMPT_DEBUG(\"  tf seq=%d lseq=%d h=%d l=%d\\n\", tf->seq, tf->lastseq, tf->have, tf->len);\n                                if (tf->have >= tf->len || seq+offset < tf->seq || seq+offset > tf->lastseq+tf->len-tf->have) {\n                                        tf = NULL;\n                                } else if (!tf->ishdr) {\n                                        ti = (rtmpt_id_t *)wmem_tree_lookup32(rconv->ids[cdir], tf->saved.id);\n                                        if (ti) {\n                                                tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(ti->packets, seq+offset-1);\n                                        }\n                                        if (tp && tp->chunkwant) {\n                                                goto unchunk;\n                                        }\n                                        tf = NULL;\n                                        ti = NULL;\n                                        tp = NULL;\n                                }\n\n                                if (tf) {\n                                        /* The preceding segment contained an incomplete chunk header */\n\n                                        want = tf->len - tf->have;\n                                        if (remain<want)\n                                                want = remain;\n\n                                        tvb_memcpy(tvb, tf->saved.d+tf->have, offset, want);\n\n                                        id = tf->saved.d[0];\n                                        header_type = (id>>6) & 3;\n                                        basic_hlen = rtmpt_basic_header_length(id);\n\n                                        if ((header_type < 3) && (tf->have < (basic_hlen+3)) && (tf->have+want >= (basic_hlen+3))) {\n                                                if (pntoh24(tf->saved.d+basic_hlen) == 0xffffff) {\n                                                        tf->len += 4;\n                                                }\n                                        }\n\n                                        tf->have += want;\n                                        tf->lastseq = seq+want-1;\n                                        remain -= want;\n                                        offset += want;\n\n                                        if (tf->have < tf->len) {\n                                                return;\n                                        }\n                                }\n                        }\n                }\n\n                if (!tf) {\n                        /* No preceeding data, get header data starting at current position */\n                        id = tvb_get_guint8(tvb, offset);\n\n                        if (id == RTMPT_MAGIC && seq+offset == RTMPT_HANDSHAKE_OFFSET_1) {\n                                header_type = 4;\n                                basic_hlen = 1;\n                                message_hlen = 0;\n                                id = lastackseq == 1 ? RTMPT_TYPE_HANDSHAKE_1 : RTMPT_TYPE_HANDSHAKE_2;\n                        } else if (seq+offset == RTMPT_HANDSHAKE_OFFSET_2) {\n                                header_type = 4;\n                                basic_hlen = 0;\n                                message_hlen = 0;\n                                id = RTMPT_TYPE_HANDSHAKE_3;\n                        } else {\n                                header_type = (id>>6) & 3;\n                                basic_hlen = rtmpt_basic_header_length(id);\n                                message_hlen = rtmpt_message_header_length(id);\n\n                                if ((header_type < 3) && (remain >= (basic_hlen+3))) {\n                                        if (tvb_get_ntoh24(tvb, offset+basic_hlen) == 0xffffff) {\n                                                message_hlen += 4;\n                                        }\n                                }\n\n                                if (remain < (basic_hlen+message_hlen)) {\n                                        /* Ran out of packet mid-header, save and try again next time */\n                                        tf = wmem_new(wmem_file_scope(), rtmpt_frag_t);\n                                        tf->ishdr = 1;\n                                        tf->seq = seq + offset;\n                                        tf->lastseq = tf->seq + remain - 1;\n                                        tf->len = basic_hlen + message_hlen;\n                                        tvb_memcpy(tvb, tf->saved.d, offset, remain);\n                                        tf->have = remain;\n                                        wmem_tree_insert32(rconv->frags[cdir], seq+offset, tf);\n                                        return;\n                                }\n\n                                id = id & 0x3f;\n                                if (id == 0)\n                                        id = tvb_get_guint8(tvb, offset+1) + 64;\n                                else if (id == 1)\n                                        id = tvb_get_letohs(tvb, offset+1) + 64;\n                        }\n\n                } else {\n                        /* Use reassembled header data */\n                        id = tf->saved.d[0];\n                        header_type = (id>>6) & 3;\n                        basic_hlen = rtmpt_basic_header_length(id);\n                        message_hlen = tf->len - basic_hlen;\n\n                        id = id & 0x3f;\n                        if (id == 0)\n                                id = tf->saved.d[1] + 64;\n                        else if (id == 1)\n                                id = pletoh16(tf->saved.d+1) + 64;\n                }\n\n                /* Calculate header values, defaulting from previous packets with same id */\n\n                if (id <= RTMPT_ID_MAX)\n                        ti = (rtmpt_id_t *)wmem_tree_lookup32(rconv->ids[cdir], id);\n                if (ti)\n                        tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(ti->packets, seq+offset-1);\n\n                if (header_type == 0)\n                        src = tf ? pntoh32(tf->saved.d+basic_hlen+7) : tvb_get_ntohl(tvb, offset+basic_hlen+7);\n                else if (ti)\n                        src = ti->src;\n                else src = 0;\n\n                if (header_type < 2)\n                        cmd = tf ? tf->saved.d[basic_hlen+6] : tvb_get_guint8(tvb, offset+basic_hlen+6);\n                else if (ti)\n                        cmd = ti->cmd;\n                else\n                        cmd = 0;\n\n                /* Calculate chunk_size now as a last-resort default payload length */\n                if (id > RTMPT_ID_MAX) {\n                        if (id == RTMPT_TYPE_HANDSHAKE_1)\n                                chunk_size = body_len = 1536;\n                        else if (id == RTMPT_TYPE_HANDSHAKE_2)\n                                chunk_size = body_len = 3072;\n                        else /* if (id == RTMPT_TYPE_HANDSHAKE_3) */\n                                chunk_size = body_len = 1536;\n                } else {\n                        chunk_size = GPOINTER_TO_INT(wmem_tree_lookup32_le(rconv->chunksize[cdir], seq+offset-1));\n                        if (!chunk_size)\n                                chunk_size = RTMPT_DEFAULT_CHUNK_SIZE;\n\n                        if (header_type < 2)\n                                body_len = tf ? pntoh24(tf->saved.d+basic_hlen+3) : tvb_get_ntoh24(tvb, offset+basic_hlen+3);\n                        else if (ti)\n                                body_len = ti->len;\n                        else\n                                body_len = chunk_size;\n\n                        if (body_len > (gint)rtmpt_max_packet_size) {\n                                return;\n                        }\n                }\n\n                if (!ti || !tp || header_type<3 || tp->have == tp->want || tp->chunkhave != tp->chunkwant) {\n                        /* Start a new packet if:\n                         *   no previous packet with same id\n                         *   not a short 1-byte header\n                         *   previous packet with same id was complete\n                         *   previous incomplete chunk not handled by fragment handler\n                         */\n                        RTMPT_DEBUG(\"New packet cdir=%d seq=%d ti=%p tp=%p header_type=%d header_len=%d id=%d tph=%d tpw=%d len=%d cs=%d\\n\",\n                                    cdir, seq+offset,\n                                    ti, tp, header_type, basic_hlen+message_hlen, id, tp?tp->have:0, tp?tp->want:0, body_len, chunk_size);\n\n                        if (!ti) {\n                                ti = wmem_new(wmem_file_scope(), rtmpt_id_t);\n                                ti->packets = wmem_tree_new(wmem_file_scope());\n                                ti->ts  = 0;\n                                ti->tsd = 0;\n                                wmem_tree_insert32(rconv->ids[cdir], id, ti);\n                        }\n\n                        if (header_type == 0) {\n                                ts = tf ? pntoh24(tf->saved.d+basic_hlen) : tvb_get_ntoh24(tvb, offset+basic_hlen);\n                                if (ts == 0xffffff) {\n                                        ts = tf ? pntoh32(tf->saved.d+basic_hlen+11) : tvb_get_ntohl(tvb, offset+basic_hlen+11);\n                                }\n                                tsd = ts - ti->ts;\n                        } else if (header_type < 3) {\n                                tsd = tf ? pntoh24(tf->saved.d+basic_hlen) : tvb_get_ntoh24(tvb, offset+basic_hlen);\n                                if (tsd == 0xffffff) {\n                                        ts  = tf ? pntoh32(tf->saved.d+basic_hlen+message_hlen-4) : tvb_get_ntohl(tvb, offset+basic_hlen+message_hlen-4);\n                                        tsd = ti->tsd; /* questionable */\n                                } else {\n                                        ts  = ti->ts + tsd;\n                                }\n                        } else {\n                                ts  = ti->ts + ti->tsd;\n                                tsd = ti->tsd;\n                        }\n\n                        /* create a new packet structure */\n                        tp             = wmem_new(wmem_file_scope(), rtmpt_packet_t);\n                        tp->seq        = tp->lastseq = tf ? tf->seq : seq+offset;\n                        tp->have       = 0;\n                        tp->want       = basic_hlen + message_hlen + body_len;\n                        tp->chunkwant  = 0;\n                        tp->chunkhave  = 0;\n                        tp->bhlen      = basic_hlen;\n                        tp->mhlen      = message_hlen;\n                        tp->fmt        = header_type;\n                        tp->id         = id;\n                        tp->ts         = ts;\n                        tp->len        = body_len;\n                        if (id > RTMPT_ID_MAX)\n                                tp->cmd = id;\n                        else\n                                tp->cmd = cmd & 0x7f;\n                        tp->src        = src;\n                        tp->txid       = 0;\n                        tp->isresponse = FALSE;\n                        tp->otherframe = 0;\n\n                        /* Save the header information for future defaulting needs */\n                        ti->ts  = ts;\n                        ti->tsd = tsd;\n                        ti->len = body_len;\n                        ti->cmd = cmd;\n                        ti->src = src;\n\n                        /* store against the id only until unchunking is complete */\n                        wmem_tree_insert32(ti->packets, tp->seq, tp);\n\n                        if (!tf && body_len <= chunk_size && tp->want <= remain) {\n                                /* The easy case - a whole packet contiguous and fully within this segment */\n                                tp->resident    = FALSE;\n                                tp->data.offset = offset;\n                                tp->lastseq     = seq+offset+tp->want-1;\n                                tp->have        = tp->want;\n\n                                wmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp);\n\n                                pktbuf = tvb_new_subset_length(tvb, tp->data.offset, tp->have);\n                                dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp);\n\n                                offset += tp->want;\n                                remain -= tp->want;\n                                continue;\n\n                        } else {\n                                /* Some more reassembly required */\n                                tp->resident = TRUE;\n                                tp->data.p = (guint8 *)wmem_alloc(wmem_file_scope(), tp->bhlen+tp->mhlen+tp->len);\n\n                                if (tf && tf->ishdr) {\n                                        memcpy(tp->data.p, tf->saved.d, tf->len);\n                                } else {\n                                        tvb_memcpy(tvb, tp->data.p, offset, basic_hlen+message_hlen);\n                                        offset += basic_hlen + message_hlen;\n                                        remain -= basic_hlen + message_hlen;\n                                }\n\n                                tp->lastseq = seq+offset-1;\n                                tp->have = basic_hlen + message_hlen;\n\n                                if (tp->have == tp->want) {\n                                        wmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp);\n\n                                        pktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have);\n                                        add_new_data_source(pinfo, pktbuf, \"Unchunked RTMP\");\n                                        dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp);\n                                        continue;\n                                }\n\n                                tp->chunkwant = chunk_size;\n                                if (tp->chunkwant > tp->want-tp->have)\n                                        tp->chunkwant = tp->want - tp->have;\n                        }\n                } else {\n                        if (header_type == 3 && tp->resident && tp->have > tp->bhlen + 3\n                            && pntoh24(tp->data.p+tp->bhlen) == 0xffffff) {\n                                /* Header type 3 resends the extended time stamp if the last message on the chunk\n                                 * stream had an extended timestamp.\n                                 * See: https://gitlab.com/wireshark/wireshark/-/issues/15718\n                                 */\n                                message_hlen += 4;\n                        }\n                        RTMPT_DEBUG(\"Old packet cdir=%d seq=%d ti=%p tp=%p header_len=%d id=%d tph=%d tpw=%d len=%d cs=%d\\n\",\n                                    cdir, seq+offset,\n                                    ti, tp, basic_hlen+message_hlen, id, tp?tp->have:0, tp?tp->want:0, body_len, chunk_size);\n\n                        tp->chunkwant = chunk_size;\n                        if (tp->chunkwant > tp->want-tp->have)\n                                tp->chunkwant = tp->want - tp->have;\n\n                        offset += basic_hlen + message_hlen;\n                        remain -= basic_hlen + message_hlen;\n                }\n\n                tf = NULL;\n\n                /* Last case to deal with is unchunking the packet body */\n        unchunk:\n                want = tp->chunkwant - tp->chunkhave;\n                if (want > remain)\n                        want = remain;\n                RTMPT_DEBUG(\"  cw=%d ch=%d r=%d w=%d\\n\", tp->chunkwant, tp->chunkhave, remain, want);\n\n                tvb_memcpy(tvb, tp->data.p+tp->have, offset, want);\n\n                if (tf) {\n                        tf->have += want;\n                        tf->lastseq = seq+offset+want-1;\n                }\n                tp->lastseq = seq+offset+want-1;\n                tp->have += want;\n                tp->chunkhave += want;\n\n                offset += want;\n                remain -= want;\n\n                if (tp->chunkhave == tp->chunkwant) {\n                        /* Chunk is complete - wait for next header */\n                        tp->chunkhave = 0;\n                        tp->chunkwant = 0;\n                }\n\n                if (tp->have == tp->want) {\n                        /* Whole packet is complete */\n                        wmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp);\n\n                        pktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have);\n                        add_new_data_source(pinfo, pktbuf, \"Unchunked RTMP\");\n                        dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp);\n                } else if (tp->chunkhave < tp->chunkwant) {\n                        /* Chunk is split across segment boundary */\n                        rtmpt_frag_t *tf2 = wmem_new(wmem_file_scope(), rtmpt_frag_t);\n                        tf2->ishdr    = 0;\n                        tf2->seq      = seq + offset - want;\n                        tf2->lastseq  = tf2->seq + remain - 1 + want;\n                        tf2->have     = tp->chunkhave;\n                        tf2->len      = tp->chunkwant;\n                        tf2->saved.id = tp->id;\n                        RTMPT_DEBUG(\"  inserting tf @ %d\\n\", seq+offset-want-1);\n                        wmem_tree_insert32(rconv->frags[cdir], seq+offset-want-1, tf2);\n                }\n        }\n}",
        "func": "static void\ndissect_rtmpt_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, rtmpt_conv_t *rconv, int cdir, guint32 seq, guint32 lastackseq)\n{\n        int     offset = 0;\n        int     remain;\n        int     want;\n\n        guint8  header_type;\n        int     basic_hlen;\n        int     message_hlen;\n\n        guint32 id;\n        guint32 ts     = 0;\n        guint32 tsd    = 0;\n        int     body_len;\n        guint8  cmd;\n        guint32 src;\n        int     chunk_size;\n\n        rtmpt_frag_t   *tf;\n        rtmpt_id_t     *ti;\n        rtmpt_packet_t *tp;\n        tvbuff_t       *pktbuf;\n\n        remain = tvb_reported_length(tvb);\n        if (!remain)\n                return;\n\n        RTMPT_DEBUG(\"Segment: cdir=%d seq=%d-%d\\n\", cdir, seq, seq+remain-1);\n\n        if (pinfo->fd->visited) {\n                /* Already done the work, so just dump the existing state */\n                /* XXX: If there's bogus sequence numbers and the\n                 * tcp.analyze_sequence_numbers pref is TRUE, we can't actually\n                 * assume that we processed this frame the first time around,\n                 * since the TCP dissector might not have given it to us.\n                 */\n                wmem_stack_t *packets;\n\n                /* List all RTMP packets terminating in this TCP segment, from end to beginning */\n\n                packets = wmem_stack_new(wmem_packet_scope());\n                wmem_stack_push(packets, 0);\n\n                tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(rconv->packets[cdir], seq+remain-1);\n                while (tp && GE_SEQ(tp->lastseq, seq)) {\n                        /* Sequence numbers can wrap around (especially with\n                         * tcp.relative_sequence_numbers FALSE), so use the\n                         * wrap around aware comparison from packet-tcp.h\n                         */\n                        wmem_stack_push(packets, tp);\n                        if (tp->seq == 0) {\n                                // reached first segment.\n                                /* XXX: Assuming tcp.relative_sequence_numbers\n                                 * is TRUE, that is, since on TCP we just\n                                 * reuse the sequence numbers from tcpinfo.\n                                 */\n                                break;\n                        }\n                        tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(rconv->packets[cdir], tp->seq-1);\n                }\n\n                /* Dissect the generated list in reverse order (beginning to end) */\n\n                while ((tp=(rtmpt_packet_t *)wmem_stack_pop(packets)) != NULL) {\n                        if (tp->resident) {\n                                pktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have);\n                                add_new_data_source(pinfo, pktbuf, \"Unchunked RTMP\");\n                        } else {\n                                pktbuf = tvb_new_subset_length(tvb, tp->data.offset, tp->have);\n                        }\n                        dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp);\n                }\n\n                return;\n        }\n\n        while (remain>0) {\n                tf = NULL;\n                ti = NULL;\n                tp = NULL;\n\n                /* Check for outstanding fragmented headers/chunks first */\n\n                if (offset == 0) {\n                        tf = (rtmpt_frag_t *)wmem_tree_lookup32_le(rconv->frags[cdir], seq+offset-1);\n\n                        if (tf) {\n                                /* May need to reassemble cross-TCP-segment fragments */\n                                RTMPT_DEBUG(\"  tf seq=%d lseq=%d h=%d l=%d\\n\", tf->seq, tf->lastseq, tf->have, tf->len);\n                                if (tf->have >= tf->len || seq+offset < tf->seq || seq+offset > tf->lastseq+tf->len-tf->have) {\n                                        tf = NULL;\n                                } else if (!tf->ishdr) {\n                                        ti = (rtmpt_id_t *)wmem_tree_lookup32(rconv->ids[cdir], tf->saved.id);\n                                        if (ti) {\n                                                tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(ti->packets, seq+offset-1);\n                                        }\n                                        if (tp && tp->chunkwant) {\n                                                goto unchunk;\n                                        }\n                                        tf = NULL;\n                                        ti = NULL;\n                                        tp = NULL;\n                                }\n\n                                if (tf) {\n                                        /* The preceding segment contained an incomplete chunk header */\n\n                                        want = tf->len - tf->have;\n                                        if (remain<want)\n                                                want = remain;\n\n                                        tvb_memcpy(tvb, tf->saved.d+tf->have, offset, want);\n\n                                        id = tf->saved.d[0];\n                                        header_type = (id>>6) & 3;\n                                        basic_hlen = rtmpt_basic_header_length(id);\n\n                                        if ((header_type < 3) && (tf->have < (basic_hlen+3)) && (tf->have+want >= (basic_hlen+3))) {\n                                                if (pntoh24(tf->saved.d+basic_hlen) == 0xffffff) {\n                                                        tf->len += 4;\n                                                }\n                                        }\n\n                                        tf->have += want;\n                                        tf->lastseq = seq+want-1;\n                                        remain -= want;\n                                        offset += want;\n\n                                        if (tf->have < tf->len) {\n                                                return;\n                                        }\n                                }\n                        }\n                }\n\n                if (!tf) {\n                        /* No preceeding data, get header data starting at current position */\n                        id = tvb_get_guint8(tvb, offset);\n\n                        if (id == RTMPT_MAGIC && seq+offset == RTMPT_HANDSHAKE_OFFSET_1) {\n                                header_type = 4;\n                                basic_hlen = 1;\n                                message_hlen = 0;\n                                id = lastackseq == 1 ? RTMPT_TYPE_HANDSHAKE_1 : RTMPT_TYPE_HANDSHAKE_2;\n                        } else if (seq+offset == RTMPT_HANDSHAKE_OFFSET_2) {\n                                header_type = 4;\n                                basic_hlen = 0;\n                                message_hlen = 0;\n                                id = RTMPT_TYPE_HANDSHAKE_3;\n                        } else {\n                                header_type = (id>>6) & 3;\n                                basic_hlen = rtmpt_basic_header_length(id);\n                                message_hlen = rtmpt_message_header_length(id);\n\n                                if ((header_type < 3) && (remain >= (basic_hlen+3))) {\n                                        if (tvb_get_ntoh24(tvb, offset+basic_hlen) == 0xffffff) {\n                                                message_hlen += 4;\n                                        }\n                                }\n\n                                if (remain < (basic_hlen+message_hlen)) {\n                                        /* Ran out of packet mid-header, save and try again next time */\n                                        tf = wmem_new(wmem_file_scope(), rtmpt_frag_t);\n                                        tf->ishdr = 1;\n                                        tf->seq = seq + offset;\n                                        tf->lastseq = tf->seq + remain - 1;\n                                        tf->len = basic_hlen + message_hlen;\n                                        tvb_memcpy(tvb, tf->saved.d, offset, remain);\n                                        tf->have = remain;\n                                        wmem_tree_insert32(rconv->frags[cdir], seq+offset, tf);\n                                        return;\n                                }\n\n                                id = id & 0x3f;\n                                if (id == 0)\n                                        id = tvb_get_guint8(tvb, offset+1) + 64;\n                                else if (id == 1)\n                                        id = tvb_get_letohs(tvb, offset+1) + 64;\n                        }\n\n                } else {\n                        /* Use reassembled header data */\n                        id = tf->saved.d[0];\n                        header_type = (id>>6) & 3;\n                        basic_hlen = rtmpt_basic_header_length(id);\n                        message_hlen = tf->len - basic_hlen;\n\n                        id = id & 0x3f;\n                        if (id == 0)\n                                id = tf->saved.d[1] + 64;\n                        else if (id == 1)\n                                id = pletoh16(tf->saved.d+1) + 64;\n                }\n\n                /* Calculate header values, defaulting from previous packets with same id */\n\n                if (id <= RTMPT_ID_MAX)\n                        ti = (rtmpt_id_t *)wmem_tree_lookup32(rconv->ids[cdir], id);\n                if (ti)\n                        tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(ti->packets, seq+offset-1);\n\n                if (header_type == 0)\n                        src = tf ? pntoh32(tf->saved.d+basic_hlen+7) : tvb_get_ntohl(tvb, offset+basic_hlen+7);\n                else if (ti)\n                        src = ti->src;\n                else src = 0;\n\n                if (header_type < 2)\n                        cmd = tf ? tf->saved.d[basic_hlen+6] : tvb_get_guint8(tvb, offset+basic_hlen+6);\n                else if (ti)\n                        cmd = ti->cmd;\n                else\n                        cmd = 0;\n\n                /* Calculate chunk_size now as a last-resort default payload length */\n                if (id > RTMPT_ID_MAX) {\n                        if (id == RTMPT_TYPE_HANDSHAKE_1)\n                                chunk_size = body_len = 1536;\n                        else if (id == RTMPT_TYPE_HANDSHAKE_2)\n                                chunk_size = body_len = 3072;\n                        else /* if (id == RTMPT_TYPE_HANDSHAKE_3) */\n                                chunk_size = body_len = 1536;\n                } else {\n                        chunk_size = GPOINTER_TO_INT(wmem_tree_lookup32_le(rconv->chunksize[cdir], seq+offset-1));\n                        if (!chunk_size)\n                                chunk_size = RTMPT_DEFAULT_CHUNK_SIZE;\n\n                        if (header_type < 2)\n                                body_len = tf ? pntoh24(tf->saved.d+basic_hlen+3) : tvb_get_ntoh24(tvb, offset+basic_hlen+3);\n                        else if (ti)\n                                body_len = ti->len;\n                        else\n                                body_len = chunk_size;\n\n                        if (body_len > (gint)rtmpt_max_packet_size) {\n                                return;\n                        }\n                }\n\n                if (!ti || !tp || header_type<3 || tp->have == tp->want || tp->chunkhave != tp->chunkwant) {\n                        /* Start a new packet if:\n                         *   no previous packet with same id\n                         *   not a short 1-byte header\n                         *   previous packet with same id was complete\n                         *   previous incomplete chunk not handled by fragment handler\n                         */\n                        RTMPT_DEBUG(\"New packet cdir=%d seq=%d ti=%p tp=%p header_type=%d header_len=%d id=%d tph=%d tpw=%d len=%d cs=%d\\n\",\n                                    cdir, seq+offset,\n                                    ti, tp, header_type, basic_hlen+message_hlen, id, tp?tp->have:0, tp?tp->want:0, body_len, chunk_size);\n\n                        if (!ti) {\n                                ti = wmem_new(wmem_file_scope(), rtmpt_id_t);\n                                ti->packets = wmem_tree_new(wmem_file_scope());\n                                ti->ts  = 0;\n                                ti->tsd = 0;\n                                wmem_tree_insert32(rconv->ids[cdir], id, ti);\n                        }\n\n                        if (header_type == 0) {\n                                ts = tf ? pntoh24(tf->saved.d+basic_hlen) : tvb_get_ntoh24(tvb, offset+basic_hlen);\n                                if (ts == 0xffffff) {\n                                        ts = tf ? pntoh32(tf->saved.d+basic_hlen+11) : tvb_get_ntohl(tvb, offset+basic_hlen+11);\n                                }\n                                tsd = ts - ti->ts;\n                        } else if (header_type < 3) {\n                                tsd = tf ? pntoh24(tf->saved.d+basic_hlen) : tvb_get_ntoh24(tvb, offset+basic_hlen);\n                                if (tsd == 0xffffff) {\n                                        ts  = tf ? pntoh32(tf->saved.d+basic_hlen+message_hlen-4) : tvb_get_ntohl(tvb, offset+basic_hlen+message_hlen-4);\n                                        tsd = ti->tsd; /* questionable */\n                                } else {\n                                        ts  = ti->ts + tsd;\n                                }\n                        } else {\n                                ts  = ti->ts + ti->tsd;\n                                tsd = ti->tsd;\n                        }\n\n                        /* create a new packet structure */\n                        tp             = wmem_new(wmem_file_scope(), rtmpt_packet_t);\n                        tp->seq        = tp->lastseq = tf ? tf->seq : seq+offset;\n                        tp->have       = 0;\n                        tp->want       = basic_hlen + message_hlen + body_len;\n                        tp->chunkwant  = 0;\n                        tp->chunkhave  = 0;\n                        tp->bhlen      = basic_hlen;\n                        tp->mhlen      = message_hlen;\n                        tp->fmt        = header_type;\n                        tp->id         = id;\n                        tp->ts         = ts;\n                        tp->len        = body_len;\n                        if (id > RTMPT_ID_MAX)\n                                tp->cmd = id;\n                        else\n                                tp->cmd = cmd & 0x7f;\n                        tp->src        = src;\n                        tp->txid       = 0;\n                        tp->isresponse = FALSE;\n                        tp->otherframe = 0;\n\n                        /* Save the header information for future defaulting needs */\n                        ti->ts  = ts;\n                        ti->tsd = tsd;\n                        ti->len = body_len;\n                        ti->cmd = cmd;\n                        ti->src = src;\n\n                        /* store against the id only until unchunking is complete */\n                        wmem_tree_insert32(ti->packets, tp->seq, tp);\n\n                        if (!tf && body_len <= chunk_size && tp->want <= remain) {\n                                /* The easy case - a whole packet contiguous and fully within this segment */\n                                tp->resident    = FALSE;\n                                tp->data.offset = offset;\n                                tp->lastseq     = seq+offset+tp->want-1;\n                                tp->have        = tp->want;\n\n                                wmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp);\n\n                                pktbuf = tvb_new_subset_length(tvb, tp->data.offset, tp->have);\n                                dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp);\n\n                                offset += tp->want;\n                                remain -= tp->want;\n                                continue;\n\n                        } else {\n                                /* Some more reassembly required */\n                                tp->resident = TRUE;\n                                tp->data.p = (guint8 *)wmem_alloc(wmem_file_scope(), tp->bhlen+tp->mhlen+tp->len);\n\n                                if (tf && tf->ishdr) {\n                                        memcpy(tp->data.p, tf->saved.d, tf->len);\n                                } else {\n                                        tvb_memcpy(tvb, tp->data.p, offset, basic_hlen+message_hlen);\n                                        offset += basic_hlen + message_hlen;\n                                        remain -= basic_hlen + message_hlen;\n                                }\n\n                                tp->lastseq = seq+offset-1;\n                                tp->have = basic_hlen + message_hlen;\n\n                                if (tp->have == tp->want) {\n                                        wmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp);\n\n                                        pktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have);\n                                        add_new_data_source(pinfo, pktbuf, \"Unchunked RTMP\");\n                                        dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp);\n                                        continue;\n                                }\n\n                                tp->chunkwant = chunk_size;\n                                if (tp->chunkwant > tp->want-tp->have)\n                                        tp->chunkwant = tp->want - tp->have;\n                        }\n                } else {\n                        if (header_type == 3 && tp->resident && tp->have > tp->bhlen + 3\n                            && pntoh24(tp->data.p+tp->bhlen) == 0xffffff) {\n                                /* Header type 3 resends the extended time stamp if the last message on the chunk\n                                 * stream had an extended timestamp.\n                                 * See: https://gitlab.com/wireshark/wireshark/-/issues/15718\n                                 */\n                                message_hlen += 4;\n                        }\n                        RTMPT_DEBUG(\"Old packet cdir=%d seq=%d ti=%p tp=%p header_len=%d id=%d tph=%d tpw=%d len=%d cs=%d\\n\",\n                                    cdir, seq+offset,\n                                    ti, tp, basic_hlen+message_hlen, id, tp?tp->have:0, tp?tp->want:0, body_len, chunk_size);\n\n                        tp->chunkwant = chunk_size;\n                        if (tp->chunkwant > tp->want-tp->have)\n                                tp->chunkwant = tp->want - tp->have;\n\n                        offset += basic_hlen + message_hlen;\n                        remain -= basic_hlen + message_hlen;\n                }\n\n                tf = NULL;\n\n                /* Last case to deal with is unchunking the packet body */\n        unchunk:\n                want = tp->chunkwant - tp->chunkhave;\n                if (want > remain)\n                        want = remain;\n                RTMPT_DEBUG(\"  cw=%d ch=%d r=%d w=%d\\n\", tp->chunkwant, tp->chunkhave, remain, want);\n\n                tvb_memcpy(tvb, tp->data.p+tp->have, offset, want);\n\n                if (tf) {\n                        tf->have += want;\n                        tf->lastseq = seq+offset+want-1;\n                }\n                tp->lastseq = seq+offset+want-1;\n                tp->have += want;\n                tp->chunkhave += want;\n\n                offset += want;\n                remain -= want;\n\n                if (tp->chunkhave == tp->chunkwant) {\n                        /* Chunk is complete - wait for next header */\n                        tp->chunkhave = 0;\n                        tp->chunkwant = 0;\n                }\n\n                if (tp->have == tp->want) {\n                        /* Whole packet is complete */\n                        wmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp);\n\n                        pktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have);\n                        add_new_data_source(pinfo, pktbuf, \"Unchunked RTMP\");\n                        dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp);\n                } else if (tp->chunkhave < tp->chunkwant) {\n                        /* Chunk is split across segment boundary */\n                        rtmpt_frag_t *tf2 = wmem_new(wmem_file_scope(), rtmpt_frag_t);\n                        tf2->ishdr    = 0;\n                        tf2->seq      = seq + offset - want;\n                        tf2->lastseq  = tf2->seq + remain - 1 + want;\n                        tf2->have     = tp->chunkhave;\n                        tf2->len      = tp->chunkwant;\n                        tf2->saved.id = tp->id;\n                        RTMPT_DEBUG(\"  inserting tf @ %d\\n\", seq+offset-want-1);\n                        wmem_tree_insert32(rconv->frags[cdir], seq+offset-want-1, tf2);\n                }\n        }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,6 +30,11 @@\n \n         if (pinfo->fd->visited) {\n                 /* Already done the work, so just dump the existing state */\n+                /* XXX: If there's bogus sequence numbers and the\n+                 * tcp.analyze_sequence_numbers pref is TRUE, we can't actually\n+                 * assume that we processed this frame the first time around,\n+                 * since the TCP dissector might not have given it to us.\n+                 */\n                 wmem_stack_t *packets;\n \n                 /* List all RTMP packets terminating in this TCP segment, from end to beginning */\n@@ -38,10 +43,18 @@\n                 wmem_stack_push(packets, 0);\n \n                 tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(rconv->packets[cdir], seq+remain-1);\n-                while (tp && tp->lastseq >= seq) {\n+                while (tp && GE_SEQ(tp->lastseq, seq)) {\n+                        /* Sequence numbers can wrap around (especially with\n+                         * tcp.relative_sequence_numbers FALSE), so use the\n+                         * wrap around aware comparison from packet-tcp.h\n+                         */\n                         wmem_stack_push(packets, tp);\n                         if (tp->seq == 0) {\n                                 // reached first segment.\n+                                /* XXX: Assuming tcp.relative_sequence_numbers\n+                                 * is TRUE, that is, since on TCP we just\n+                                 * reuse the sequence numbers from tcpinfo.\n+                                 */\n                                 break;\n                         }\n                         tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(rconv->packets[cdir], tp->seq-1);",
        "diff_line_info": {
            "deleted_lines": [
                "                while (tp && tp->lastseq >= seq) {"
            ],
            "added_lines": [
                "                /* XXX: If there's bogus sequence numbers and the",
                "                 * tcp.analyze_sequence_numbers pref is TRUE, we can't actually",
                "                 * assume that we processed this frame the first time around,",
                "                 * since the TCP dissector might not have given it to us.",
                "                 */",
                "                while (tp && GE_SEQ(tp->lastseq, seq)) {",
                "                        /* Sequence numbers can wrap around (especially with",
                "                         * tcp.relative_sequence_numbers FALSE), so use the",
                "                         * wrap around aware comparison from packet-tcp.h",
                "                         */",
                "                                /* XXX: Assuming tcp.relative_sequence_numbers",
                "                                 * is TRUE, that is, since on TCP we just",
                "                                 * reuse the sequence numbers from tcpinfo.",
                "                                 */"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-6467",
        "func_name": "wireshark/nstrace_read_v30",
        "description": "In Wireshark 2.2.0 to 2.2.4 and 2.0.0 to 2.0.10, there is a Netscaler file parser infinite loop, triggered by a malformed capture file. This was addressed in wiretap/netscaler.c by changing the restrictions on file size.",
        "git_url": "https://github.com/wireshark/wireshark/commit/284ad58d288722a8725401967bff0c4455488f0c",
        "commit_title": "nstrace: Allow opening of files that are not multiples of 16kB",
        "commit_text": "in size.  Wireshark/Tshark hangs when netscaler trace file smaller than 16KB is opened.  It also hangs when a gzipped trace file is opened. With this fix,  Files with sizes that are not multiple of 16KB and gzipped files can be opened.  Bug: 12083 (cherry picked from commit 875d95ea605758308fc2369d83a41a34a6adbe53)",
        "func_before": "static gboolean nstrace_read_v30(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)\n{\n    nstrace_t *nstrace = (nstrace_t *)wth->priv;\n    guint64 nsg_creltime;\n    gchar *nstrace_buf = nstrace->pnstrace_buf;\n    gint32 nstrace_buf_offset = nstrace->nstrace_buf_offset;\n    gint32 nstrace_buflen = nstrace->nstrace_buflen;\n    guint8 nstrace_tmpbuff[65536];\n    guint32 nstrace_tmpbuff_off=0,nst_dataSize=0,rec_size=0,nsg_nextPageOffset=0;\n    nspr_hd_v20_t *hdp;\n    int bytes_read = 0;\n    *err = 0;\n    *err_info = NULL;\n\n    do\n    {\n        if (!nstrace_buf[nstrace_buf_offset] && nstrace_buf_offset <= NSPR_PAGESIZE_TRACE){\n            nstrace_buf_offset = NSPR_PAGESIZE_TRACE;\n        }\n        if(file_eof(wth->fh) && bytes_read>0 ){\n            memset(&nstrace_buf[bytes_read], 0, NSPR_PAGESIZE_TRACE-bytes_read);\n        }\n        while ((nstrace_buf_offset < NSPR_PAGESIZE_TRACE) &&\n            nstrace_buf[nstrace_buf_offset])\n        {\n            hdp = (nspr_hd_v20_t *) &nstrace_buf[nstrace_buf_offset];\n            switch (hdp->phd_RecordType)\n            {\n\n#define GENERATE_CASE_FULL_V30(phdr,ver,HEADERVER) \\\n        case NSPR_PDPKTRACEFULLTX_V##ver:\\\n        case NSPR_PDPKTRACEFULLTXB_V##ver:\\\n        case NSPR_PDPKTRACEFULLRX_V##ver:\\\n        case NSPR_PDPKTRACEFULLNEWRX_V##ver:\\\n            PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);\n\n                GENERATE_CASE_FULL_V30(&wth->phdr,30,300);\n\n#undef GENERATE_CASE_FULL_V30\n\n#define GENERATE_CASE_FULL_V35(phdr,ver,HEADERVER) \\\n        case NSPR_PDPKTRACEFULLTX_V##ver:\\\n        case NSPR_PDPKTRACEFULLTXB_V##ver:\\\n        case NSPR_PDPKTRACEFULLRX_V##ver:\\\n        case NSPR_PDPKTRACEFULLNEWRX_V##ver:\\\n            PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);\n                GENERATE_CASE_FULL_V35(&wth->phdr,35,350);\n\n#undef GENERATE_CASE_FULL_V35\n\n                case NSPR_ABSTIME_V20:\n                {\n                    nstrace_buf_offset += nspr_getv20recordsize(hdp);\n                    ns_setabstime(nstrace, pletoh32(&((nspr_abstime_v20_t *) &nstrace_buf[nstrace_buf_offset])->abs_Time), pletoh16(&((nspr_abstime_v20_t *) &nstrace_buf[nstrace_buf_offset])->abs_RelTime));\n                    break;\n                }\n\n                case NSPR_RELTIME_V20:\n                {\n                    ns_setrelativetime(nstrace, pletoh16(&((nspr_abstime_v20_t *) &nstrace_buf[nstrace_buf_offset])->abs_RelTime));\n                    nstrace_buf_offset += nspr_getv20recordsize(hdp);\n                    break;\n                }\n\n                default:\n                {\n                    nstrace_buf_offset += nspr_getv20recordsize(hdp);\n                    break;\n                }\n            }\n        }\n        nstrace_buf_offset = 0;\n        nstrace->xxx_offset += nstrace_buflen;\n        nstrace_buflen = NSPR_PAGESIZE_TRACE;\n    } while((nstrace_buflen > 0) && (bytes_read = file_read(nstrace_buf, nstrace_buflen, wth->fh)) && (file_eof(wth->fh) || bytes_read == nstrace_buflen));\n\n    return FALSE;\n}",
        "func": "static gboolean nstrace_read_v30(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)\n{\n    nstrace_t *nstrace = (nstrace_t *)wth->priv;\n    guint64 nsg_creltime;\n    gchar *nstrace_buf = nstrace->pnstrace_buf;\n    gint32 nstrace_buf_offset = nstrace->nstrace_buf_offset;\n    gint32 nstrace_buflen = nstrace->nstrace_buflen;\n    guint8 nstrace_tmpbuff[65536];\n    guint32 nstrace_tmpbuff_off=0,nst_dataSize=0,rec_size=0,nsg_nextPageOffset=0;\n    nspr_hd_v20_t *hdp;\n    int bytes_read = 0;\n    *err = 0;\n    *err_info = NULL;\n    if(nstrace_buflen == 0){\n      return FALSE; /* Reached End Of File */\n    }\n\n    do\n    {\n        if (!nstrace_buf[nstrace_buf_offset] && nstrace_buf_offset <= NSPR_PAGESIZE_TRACE){\n            nstrace_buf_offset = NSPR_PAGESIZE_TRACE;\n        }\n        if(file_eof(wth->fh) && bytes_read>0 ){\n            memset(&nstrace_buf[bytes_read], 0, NSPR_PAGESIZE_TRACE-bytes_read);\n        }\n        while ((nstrace_buf_offset < NSPR_PAGESIZE_TRACE) &&\n            nstrace_buf[nstrace_buf_offset])\n        {\n            hdp = (nspr_hd_v20_t *) &nstrace_buf[nstrace_buf_offset];\n            if(nspr_getv20recordsize(hdp) == 0){\n              *err=WTAP_ERR_BAD_FILE;\n              *err_info = g_strdup(\"Zero size record found\");\n              return FALSE;\n            }\n            switch (hdp->phd_RecordType)\n            {\n\n#define GENERATE_CASE_FULL_V30(phdr,ver,HEADERVER) \\\n        case NSPR_PDPKTRACEFULLTX_V##ver:\\\n        case NSPR_PDPKTRACEFULLTXB_V##ver:\\\n        case NSPR_PDPKTRACEFULLRX_V##ver:\\\n        case NSPR_PDPKTRACEFULLNEWRX_V##ver:\\\n            PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);\n\n                GENERATE_CASE_FULL_V30(&wth->phdr,30,300);\n\n#undef GENERATE_CASE_FULL_V30\n\n#define GENERATE_CASE_FULL_V35(phdr,ver,HEADERVER) \\\n        case NSPR_PDPKTRACEFULLTX_V##ver:\\\n        case NSPR_PDPKTRACEFULLTXB_V##ver:\\\n        case NSPR_PDPKTRACEFULLRX_V##ver:\\\n        case NSPR_PDPKTRACEFULLNEWRX_V##ver:\\\n            PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);\n                GENERATE_CASE_FULL_V35(&wth->phdr,35,350);\n\n#undef GENERATE_CASE_FULL_V35\n\n                case NSPR_ABSTIME_V20:\n                {\n                    nstrace_buf_offset += nspr_getv20recordsize(hdp);\n                    ns_setabstime(nstrace, pletoh32(&((nspr_abstime_v20_t *) &nstrace_buf[nstrace_buf_offset])->abs_Time), pletoh16(&((nspr_abstime_v20_t *) &nstrace_buf[nstrace_buf_offset])->abs_RelTime));\n                    break;\n                }\n\n                case NSPR_RELTIME_V20:\n                {\n                    ns_setrelativetime(nstrace, pletoh16(&((nspr_abstime_v20_t *) &nstrace_buf[nstrace_buf_offset])->abs_RelTime));\n                    nstrace_buf_offset += nspr_getv20recordsize(hdp);\n                    break;\n                }\n\n                default:\n                {\n                    nstrace_buf_offset += nspr_getv20recordsize(hdp);\n                    break;\n                }\n            }\n        }\n        nstrace_buf_offset = 0;\n        nstrace->xxx_offset += nstrace_buflen;\n        nstrace_buflen = NSPR_PAGESIZE_TRACE;\n    } while((nstrace_buflen > 0) && (bytes_read = file_read(nstrace_buf, nstrace_buflen, wth->fh)) && (file_eof(wth->fh) || bytes_read == nstrace_buflen));\n\n    return FALSE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,6 +11,9 @@\n     int bytes_read = 0;\n     *err = 0;\n     *err_info = NULL;\n+    if(nstrace_buflen == 0){\n+      return FALSE; /* Reached End Of File */\n+    }\n \n     do\n     {\n@@ -24,6 +27,11 @@\n             nstrace_buf[nstrace_buf_offset])\n         {\n             hdp = (nspr_hd_v20_t *) &nstrace_buf[nstrace_buf_offset];\n+            if(nspr_getv20recordsize(hdp) == 0){\n+              *err=WTAP_ERR_BAD_FILE;\n+              *err_info = g_strdup(\"Zero size record found\");\n+              return FALSE;\n+            }\n             switch (hdp->phd_RecordType)\n             {\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if(nstrace_buflen == 0){",
                "      return FALSE; /* Reached End Of File */",
                "    }",
                "            if(nspr_getv20recordsize(hdp) == 0){",
                "              *err=WTAP_ERR_BAD_FILE;",
                "              *err_info = g_strdup(\"Zero size record found\");",
                "              return FALSE;",
                "            }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-6470",
        "func_name": "wireshark/dissect_fullpacket",
        "description": "In Wireshark 2.2.0 to 2.2.4 and 2.0.0 to 2.0.10, there is an IAX2 infinite loop, triggered by packet injection or a malformed capture file. This was addressed in epan/dissectors/packet-iax2.c by constraining packet lateness.",
        "git_url": "https://github.com/wireshark/wireshark/commit/0b89174ef4c531a1917437fff586fe525ee7bf2d",
        "commit_title": "IAX2: Add a timestamp check.",
        "commit_text": " Don't try to process timestamps that are more than 60 seconds apart. Avoids the infinite loop in bug 13432.  Bug: 13432 (cherry picked from commit ca68749606bb78a333a0961dbf9fa74c65fa72aa) (cherry picked from commit 9f297d6d51d7daab0c5a6a8d2800e07c29539c2e)",
        "func_before": "static guint32\ndissect_fullpacket(tvbuff_t *tvb, guint32 offset,\n                   guint16 scallno,\n                   packet_info *pinfo, proto_tree *iax2_tree,\n                   proto_tree *main_tree)\n{\n  guint16 dcallno;\n  guint32 ts;\n  guint8  type;\n  guint8  csub;\n  guint32 codec;\n\n  proto_tree      *packet_type_tree = NULL;\n  iax_call_data   *iax_call;\n  iax_packet_data *iax_packet;\n  gboolean         reversed;\n  gboolean         rtp_marker;\n\n  /*\n   * remove the top bit for retransmission detection\n   */\n  dcallno = tvb_get_ntohs(tvb, offset) & 0x7FFF;\n  ts = tvb_get_ntohl(tvb, offset + 2);\n  type = tvb_get_guint8(tvb, offset + 8);\n  csub = tvb_get_guint8(tvb, offset + 9);\n  iax2_info->ftype   = type;\n  iax2_info->csub    = csub;\n  iax2_info->scallno = scallno;\n  iax2_info->dcallno = dcallno;\n\n  /* see if we've seen this packet before */\n  iax_packet = (iax_packet_data *)p_get_proto_data(wmem_file_scope(), pinfo, proto_iax2, 0);\n  if (!iax_packet) {\n    /* if not, find or create an iax_call info structure for this IAX session. */\n\n    if (type == AST_FRAME_IAX && csub == IAX_COMMAND_NEW) {\n      /* NEW packets start a new call */\n      iax_call = iax_new_call(pinfo, scallno);\n      reversed = FALSE;\n    } else {\n      iax_call = iax_lookup_call(pinfo, scallno, dcallno,\n                                 &reversed);\n    }\n\n    iax_packet = iax_new_packet_data(iax_call, reversed);\n    p_add_proto_data(wmem_file_scope(), pinfo, proto_iax2, 0, iax_packet);\n  } else {\n    iax_call = iax_packet->call_data;\n    reversed = iax_packet->reversed;\n  }\n\n  iax2_populate_pinfo_from_packet_data(pinfo, iax_packet);\n\n  if (iax2_tree) {\n      proto_item *packet_type_base;\n\n      proto_tree_add_item(iax2_tree, hf_iax2_dcallno, tvb, offset, 2, ENC_BIG_ENDIAN);\n\n      proto_tree_add_item(iax2_tree, hf_iax2_retransmission, tvb, offset, 2, ENC_BIG_ENDIAN);\n\n      if (iax_call) {\n        proto_item *item =\n          proto_tree_add_uint(iax2_tree, hf_iax2_callno, tvb, 0, 4,\n                              iax_call->forward_circuit_ids[0]);\n        PROTO_ITEM_SET_GENERATED(item);\n      }\n\n      proto_tree_add_uint(iax2_tree, hf_iax2_ts, tvb, offset+2, 4, ts);\n      iax2_add_ts_fields(pinfo, iax2_tree, iax_packet, (guint16)ts);\n\n      proto_tree_add_item(iax2_tree, hf_iax2_oseqno, tvb, offset+6, 1,\n                          ENC_BIG_ENDIAN);\n\n      proto_tree_add_item(iax2_tree, hf_iax2_iseqno, tvb, offset+7, 1,\n                          ENC_BIG_ENDIAN);\n      packet_type_base = proto_tree_add_uint(iax2_tree, hf_iax2_type, tvb,\n                                             offset+8, 1, type);\n\n      /* add the type-specific subtree */\n      packet_type_tree = proto_item_add_subtree(packet_type_base, ett_iax2_type);\n  } else {\n    iax2_add_ts_fields(pinfo, iax2_tree, iax_packet, (guint16)ts);\n  }\n\n\n  /* add frame type to info line */\n  col_add_fstr(pinfo->cinfo, COL_INFO, \"%s, source call# %d, timestamp %ums\",\n                 val_to_str_ext(type, &iax_frame_types_ext, \"Unknown (0x%02x)\"),\n                 scallno, ts);\n\n  iax2_info->messageName = val_to_str_ext(type, &iax_frame_types_ext, \"Unknown (0x%02x)\");\n\n  switch (type) {\n  case AST_FRAME_IAX:\n    offset=dissect_iax2_command(tvb, offset+9, pinfo, packet_type_tree, iax_packet);\n    iax2_info->messageName = val_to_str_ext(csub, &iax_iax_subclasses_ext, \"unknown (0x%02x)\");\n    if (csub < NUM_TAP_IAX_VOIP_STATES) iax2_info->callState = tap_iax_voip_state[csub];\n    break;\n\n  case AST_FRAME_DTMF_BEGIN:\n  case AST_FRAME_DTMF_END:\n    proto_tree_add_item(packet_type_tree, hf_iax2_dtmf_csub, tvb, offset+9, 1, ENC_ASCII|ENC_NA);\n    offset += 10;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" digit %c\", csub);\n    break;\n\n  case AST_FRAME_CONTROL:\n    /* add the subclass */\n    proto_tree_add_uint(packet_type_tree, hf_iax2_cmd_csub, tvb,\n                         offset+9, 1, csub);\n    offset += 10;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" %s\",\n                      val_to_str_ext(csub, &iax_cmd_subclasses_ext, \"unknown (0x%02x)\"));\n    iax2_info->messageName = val_to_str_ext (csub, &iax_cmd_subclasses_ext, \"unknown (0x%02x)\");\n    if (csub < NUM_TAP_CMD_VOIP_STATES) iax2_info->callState = tap_cmd_voip_state[csub];\n    break;\n\n  case AST_FRAME_VOICE:\n    /* add the codec */\n    iax_packet -> codec = codec = uncompress_subclass(csub);\n\n    if (packet_type_tree) {\n      proto_item *item;\n      proto_tree_add_item(packet_type_tree, hf_iax2_voice_csub, tvb, offset+9, 1, ENC_BIG_ENDIAN);\n      item = proto_tree_add_uint(packet_type_tree, hf_iax2_voice_codec, tvb, offset+9, 1, codec);\n      PROTO_ITEM_SET_GENERATED(item);\n    }\n\n    offset += 10;\n\n    if (iax_call) {\n      if (reversed) {\n        iax_call->dst_codec = codec;\n      } else {\n        iax_call->src_codec = codec;\n      }\n    }\n\n    dissect_payload(tvb, offset, pinfo, iax2_tree, main_tree, ts, FALSE, iax_packet);\n    break;\n\n  case AST_FRAME_VIDEO:\n    /* bit 6 of the csub is used to represent the rtp 'marker' bit */\n    rtp_marker = csub & 0x40 ? TRUE:FALSE;\n    iax_packet -> codec = codec = uncompress_subclass((guint8)(csub & ~40));\n\n    if (packet_type_tree) {\n      proto_item *item;\n      proto_tree_add_item(packet_type_tree, hf_iax2_video_csub, tvb, offset+9, 1, ENC_BIG_ENDIAN);\n      proto_tree_add_item(packet_type_tree, hf_iax2_marker, tvb, offset+9, 1, ENC_BIG_ENDIAN);\n      item = proto_tree_add_uint(packet_type_tree, hf_iax2_video_codec, tvb, offset+9, 1, codec);\n      PROTO_ITEM_SET_GENERATED(item);\n    }\n\n    offset += 10;\n\n    if (iax_call && iax_packet -> first_time) {\n      if (reversed) {\n        iax_call->dst_vformat = codec;\n      } else {\n        iax_call->src_vformat = codec;\n      }\n    }\n\n    if (rtp_marker)\n      col_append_str(pinfo->cinfo, COL_INFO, \", Mark\");\n\n\n    dissect_payload(tvb, offset, pinfo, iax2_tree, main_tree, ts, TRUE, iax_packet);\n    break;\n\n  case AST_FRAME_MODEM:\n    proto_tree_add_item(packet_type_tree, hf_iax2_modem_csub, tvb, offset+9, 1, ENC_BIG_ENDIAN);\n    offset += 10;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" %s\",\n                      val_to_str(csub, iax_modem_subclasses, \"unknown (0x%02x)\"));\n    break;\n\n  case AST_FRAME_TEXT:\n    proto_tree_add_item(packet_type_tree, hf_iax2_text_csub, tvb, offset+9, 1, ENC_BIG_ENDIAN);\n    offset += 10;\n\n    {\n      int textlen = tvb_captured_length_remaining(tvb, offset);\n      if (textlen > 0)\n      {\n        proto_tree_add_item(packet_type_tree, hf_iax2_text_text, tvb, offset, textlen, ENC_UTF_8|ENC_NA);\n        offset += textlen;\n      }\n    }\n    break;\n\n  case AST_FRAME_HTML:\n    proto_tree_add_item(packet_type_tree, hf_iax2_html_csub, tvb, offset+9, 1, ENC_BIG_ENDIAN);\n    offset += 10;\n\n    if (csub == 0x01)\n    {\n      int urllen = tvb_captured_length_remaining(tvb, offset);\n      if (urllen > 0)\n      {\n        proto_item *pi = proto_tree_add_item(packet_type_tree, hf_iax2_html_url, tvb, offset, urllen, ENC_UTF_8|ENC_NA);\n        PROTO_ITEM_SET_URL(pi);\n        offset += urllen;\n      }\n    }\n    break;\n\n  case AST_FRAME_CNG:\n  default:\n    proto_tree_add_uint(packet_type_tree, hf_iax2_csub, tvb, offset+9,\n                        1, csub);\n    offset += 10;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" subclass %d\", csub);\n    break;\n  }\n\n  /* next time we come to parse this packet, don't propagate the codec into the\n   * call_data */\n  iax_packet->first_time = FALSE;\n\n  return offset;\n}",
        "func": "static guint32\ndissect_fullpacket(tvbuff_t *tvb, guint32 offset,\n                   guint16 scallno,\n                   packet_info *pinfo, proto_tree *iax2_tree,\n                   proto_tree *main_tree)\n{\n  guint16 dcallno;\n  guint32 ts;\n  guint8  type;\n  guint8  csub;\n  guint32 codec;\n\n  proto_tree      *packet_type_tree = NULL;\n  iax_call_data   *iax_call;\n  iax_packet_data *iax_packet;\n  gboolean         reversed;\n  gboolean         rtp_marker;\n\n  /*\n   * remove the top bit for retransmission detection\n   */\n  dcallno = tvb_get_ntohs(tvb, offset) & 0x7FFF;\n  ts = tvb_get_ntohl(tvb, offset + 2);\n  type = tvb_get_guint8(tvb, offset + 8);\n  csub = tvb_get_guint8(tvb, offset + 9);\n  iax2_info->ftype   = type;\n  iax2_info->csub    = csub;\n  iax2_info->scallno = scallno;\n  iax2_info->dcallno = dcallno;\n\n  /* see if we've seen this packet before */\n  iax_packet = (iax_packet_data *)p_get_proto_data(wmem_file_scope(), pinfo, proto_iax2, 0);\n  if (!iax_packet) {\n    /* if not, find or create an iax_call info structure for this IAX session. */\n\n    if (type == AST_FRAME_IAX && csub == IAX_COMMAND_NEW) {\n      /* NEW packets start a new call */\n      iax_call = iax_new_call(pinfo, scallno);\n      reversed = FALSE;\n    } else {\n      iax_call = iax_lookup_call(pinfo, scallno, dcallno,\n                                 &reversed);\n    }\n\n    iax_packet = iax_new_packet_data(iax_call, reversed);\n    p_add_proto_data(wmem_file_scope(), pinfo, proto_iax2, 0, iax_packet);\n  } else {\n    iax_call = iax_packet->call_data;\n    reversed = iax_packet->reversed;\n  }\n\n  iax2_populate_pinfo_from_packet_data(pinfo, iax_packet);\n\n  if (iax2_tree) {\n      proto_item *packet_type_base;\n\n      proto_tree_add_item(iax2_tree, hf_iax2_dcallno, tvb, offset, 2, ENC_BIG_ENDIAN);\n\n      proto_tree_add_item(iax2_tree, hf_iax2_retransmission, tvb, offset, 2, ENC_BIG_ENDIAN);\n\n      if (iax_call) {\n        proto_item *item =\n          proto_tree_add_uint(iax2_tree, hf_iax2_callno, tvb, 0, 4,\n                              iax_call->forward_circuit_ids[0]);\n        PROTO_ITEM_SET_GENERATED(item);\n      }\n\n      proto_tree_add_uint(iax2_tree, hf_iax2_ts, tvb, offset+2, 4, ts);\n      iax2_add_ts_fields(pinfo, iax2_tree, tvb, iax_packet, (guint16)ts);\n\n      proto_tree_add_item(iax2_tree, hf_iax2_oseqno, tvb, offset+6, 1,\n                          ENC_BIG_ENDIAN);\n\n      proto_tree_add_item(iax2_tree, hf_iax2_iseqno, tvb, offset+7, 1,\n                          ENC_BIG_ENDIAN);\n      packet_type_base = proto_tree_add_uint(iax2_tree, hf_iax2_type, tvb,\n                                             offset+8, 1, type);\n\n      /* add the type-specific subtree */\n      packet_type_tree = proto_item_add_subtree(packet_type_base, ett_iax2_type);\n  } else {\n    iax2_add_ts_fields(pinfo, iax2_tree, tvb, iax_packet, (guint16)ts);\n  }\n\n\n  /* add frame type to info line */\n  col_add_fstr(pinfo->cinfo, COL_INFO, \"%s, source call# %d, timestamp %ums\",\n                 val_to_str_ext(type, &iax_frame_types_ext, \"Unknown (0x%02x)\"),\n                 scallno, ts);\n\n  iax2_info->messageName = val_to_str_ext(type, &iax_frame_types_ext, \"Unknown (0x%02x)\");\n\n  switch (type) {\n  case AST_FRAME_IAX:\n    offset=dissect_iax2_command(tvb, offset+9, pinfo, packet_type_tree, iax_packet);\n    iax2_info->messageName = val_to_str_ext(csub, &iax_iax_subclasses_ext, \"unknown (0x%02x)\");\n    if (csub < NUM_TAP_IAX_VOIP_STATES) iax2_info->callState = tap_iax_voip_state[csub];\n    break;\n\n  case AST_FRAME_DTMF_BEGIN:\n  case AST_FRAME_DTMF_END:\n    proto_tree_add_item(packet_type_tree, hf_iax2_dtmf_csub, tvb, offset+9, 1, ENC_ASCII|ENC_NA);\n    offset += 10;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" digit %c\", csub);\n    break;\n\n  case AST_FRAME_CONTROL:\n    /* add the subclass */\n    proto_tree_add_uint(packet_type_tree, hf_iax2_cmd_csub, tvb,\n                         offset+9, 1, csub);\n    offset += 10;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" %s\",\n                      val_to_str_ext(csub, &iax_cmd_subclasses_ext, \"unknown (0x%02x)\"));\n    iax2_info->messageName = val_to_str_ext (csub, &iax_cmd_subclasses_ext, \"unknown (0x%02x)\");\n    if (csub < NUM_TAP_CMD_VOIP_STATES) iax2_info->callState = tap_cmd_voip_state[csub];\n    break;\n\n  case AST_FRAME_VOICE:\n    /* add the codec */\n    iax_packet -> codec = codec = uncompress_subclass(csub);\n\n    if (packet_type_tree) {\n      proto_item *item;\n      proto_tree_add_item(packet_type_tree, hf_iax2_voice_csub, tvb, offset+9, 1, ENC_BIG_ENDIAN);\n      item = proto_tree_add_uint(packet_type_tree, hf_iax2_voice_codec, tvb, offset+9, 1, codec);\n      PROTO_ITEM_SET_GENERATED(item);\n    }\n\n    offset += 10;\n\n    if (iax_call) {\n      if (reversed) {\n        iax_call->dst_codec = codec;\n      } else {\n        iax_call->src_codec = codec;\n      }\n    }\n\n    dissect_payload(tvb, offset, pinfo, iax2_tree, main_tree, ts, FALSE, iax_packet);\n    break;\n\n  case AST_FRAME_VIDEO:\n    /* bit 6 of the csub is used to represent the rtp 'marker' bit */\n    rtp_marker = csub & 0x40 ? TRUE:FALSE;\n    iax_packet -> codec = codec = uncompress_subclass((guint8)(csub & ~40));\n\n    if (packet_type_tree) {\n      proto_item *item;\n      proto_tree_add_item(packet_type_tree, hf_iax2_video_csub, tvb, offset+9, 1, ENC_BIG_ENDIAN);\n      proto_tree_add_item(packet_type_tree, hf_iax2_marker, tvb, offset+9, 1, ENC_BIG_ENDIAN);\n      item = proto_tree_add_uint(packet_type_tree, hf_iax2_video_codec, tvb, offset+9, 1, codec);\n      PROTO_ITEM_SET_GENERATED(item);\n    }\n\n    offset += 10;\n\n    if (iax_call && iax_packet -> first_time) {\n      if (reversed) {\n        iax_call->dst_vformat = codec;\n      } else {\n        iax_call->src_vformat = codec;\n      }\n    }\n\n    if (rtp_marker)\n      col_append_str(pinfo->cinfo, COL_INFO, \", Mark\");\n\n\n    dissect_payload(tvb, offset, pinfo, iax2_tree, main_tree, ts, TRUE, iax_packet);\n    break;\n\n  case AST_FRAME_MODEM:\n    proto_tree_add_item(packet_type_tree, hf_iax2_modem_csub, tvb, offset+9, 1, ENC_BIG_ENDIAN);\n    offset += 10;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" %s\",\n                      val_to_str(csub, iax_modem_subclasses, \"unknown (0x%02x)\"));\n    break;\n\n  case AST_FRAME_TEXT:\n    proto_tree_add_item(packet_type_tree, hf_iax2_text_csub, tvb, offset+9, 1, ENC_BIG_ENDIAN);\n    offset += 10;\n\n    {\n      int textlen = tvb_captured_length_remaining(tvb, offset);\n      if (textlen > 0)\n      {\n        proto_tree_add_item(packet_type_tree, hf_iax2_text_text, tvb, offset, textlen, ENC_UTF_8|ENC_NA);\n        offset += textlen;\n      }\n    }\n    break;\n\n  case AST_FRAME_HTML:\n    proto_tree_add_item(packet_type_tree, hf_iax2_html_csub, tvb, offset+9, 1, ENC_BIG_ENDIAN);\n    offset += 10;\n\n    if (csub == 0x01)\n    {\n      int urllen = tvb_captured_length_remaining(tvb, offset);\n      if (urllen > 0)\n      {\n        proto_item *pi = proto_tree_add_item(packet_type_tree, hf_iax2_html_url, tvb, offset, urllen, ENC_UTF_8|ENC_NA);\n        PROTO_ITEM_SET_URL(pi);\n        offset += urllen;\n      }\n    }\n    break;\n\n  case AST_FRAME_CNG:\n  default:\n    proto_tree_add_uint(packet_type_tree, hf_iax2_csub, tvb, offset+9,\n                        1, csub);\n    offset += 10;\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" subclass %d\", csub);\n    break;\n  }\n\n  /* next time we come to parse this packet, don't propagate the codec into the\n   * call_data */\n  iax_packet->first_time = FALSE;\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -66,7 +66,7 @@\n       }\n \n       proto_tree_add_uint(iax2_tree, hf_iax2_ts, tvb, offset+2, 4, ts);\n-      iax2_add_ts_fields(pinfo, iax2_tree, iax_packet, (guint16)ts);\n+      iax2_add_ts_fields(pinfo, iax2_tree, tvb, iax_packet, (guint16)ts);\n \n       proto_tree_add_item(iax2_tree, hf_iax2_oseqno, tvb, offset+6, 1,\n                           ENC_BIG_ENDIAN);\n@@ -79,7 +79,7 @@\n       /* add the type-specific subtree */\n       packet_type_tree = proto_item_add_subtree(packet_type_base, ett_iax2_type);\n   } else {\n-    iax2_add_ts_fields(pinfo, iax2_tree, iax_packet, (guint16)ts);\n+    iax2_add_ts_fields(pinfo, iax2_tree, tvb, iax_packet, (guint16)ts);\n   }\n \n ",
        "diff_line_info": {
            "deleted_lines": [
                "      iax2_add_ts_fields(pinfo, iax2_tree, iax_packet, (guint16)ts);",
                "    iax2_add_ts_fields(pinfo, iax2_tree, iax_packet, (guint16)ts);"
            ],
            "added_lines": [
                "      iax2_add_ts_fields(pinfo, iax2_tree, tvb, iax_packet, (guint16)ts);",
                "    iax2_add_ts_fields(pinfo, iax2_tree, tvb, iax_packet, (guint16)ts);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-6470",
        "func_name": "wireshark/proto_register_iax2",
        "description": "In Wireshark 2.2.0 to 2.2.4 and 2.0.0 to 2.0.10, there is an IAX2 infinite loop, triggered by packet injection or a malformed capture file. This was addressed in epan/dissectors/packet-iax2.c by constraining packet lateness.",
        "git_url": "https://github.com/wireshark/wireshark/commit/0b89174ef4c531a1917437fff586fe525ee7bf2d",
        "commit_title": "IAX2: Add a timestamp check.",
        "commit_text": " Don't try to process timestamps that are more than 60 seconds apart. Avoids the infinite loop in bug 13432.  Bug: 13432 (cherry picked from commit ca68749606bb78a333a0961dbf9fa74c65fa72aa) (cherry picked from commit 9f297d6d51d7daab0c5a6a8d2800e07c29539c2e)",
        "func_before": "void\nproto_register_iax2(void)\n{\n  /* A header field is something you can search/filter on.\n   *\n   * We create a structure to register our fields. It consists of an\n   * array of hf_register_info structures, each of which are of the format\n   * {&(field id), {name, abbrev, type, display, strings, bitmask, blurb, HFILL}}.\n   */\n\n  static hf_register_info hf[] = {\n\n    {&hf_iax2_packet_type,\n     {\"Packet type\", \"iax2.packet_type\",\n      FT_UINT8, BASE_DEC, VALS(iax_packet_types), 0,\n      \"Full/minivoice/minivideo/trunk packet\",\n      HFILL}},\n\n    {&hf_iax2_callno,\n     {\"Call identifier\", \"iax2.call\",\n      FT_UINT32, BASE_DEC, NULL, 0,\n      \"This is the identifier Wireshark assigns to identify this call.\"\n      \" It does not correspond to any real field in the protocol\",\n      HFILL }},\n\n    {&hf_iax2_scallno,\n     {\"Source call\", \"iax2.src_call\",\n      FT_UINT16, BASE_DEC, NULL, 0x7FFF,\n      \"src_call holds the number of this call at the packet source pbx\",\n      HFILL}},\n\n    /* FIXME could this be turned into a FRAMENUM field? */\n    {&hf_iax2_dcallno,\n     {\"Destination call\", \"iax2.dst_call\",\n      FT_UINT16, BASE_DEC, NULL, 0x7FFF,\n      \"dst_call holds the number of this call at the packet destination\",\n      HFILL}},\n\n    {&hf_iax2_retransmission,\n     {\"Retransmission\", \"iax2.retransmission\",\n      FT_BOOLEAN, 16, NULL, 0x8000,\n      \"retransmission is set if this packet is a retransmission of an earlier failed packet\",\n      HFILL}},\n\n    {&hf_iax2_ts,\n     {\"Timestamp\", \"iax2.timestamp\",\n      FT_UINT32, BASE_DEC, NULL, 0x0,\n      \"timestamp is the time, in ms after the start of this call, at which this packet was transmitted\",\n      HFILL}},\n\n    {&hf_iax2_minits,\n     {\"Timestamp\", \"iax2.timestamp\",\n      FT_UINT16, BASE_DEC, NULL, 0x0,\n      \"timestamp is the time, in ms after the start of this call, at which this packet was transmitted\",\n      HFILL}},\n\n    {&hf_iax2_minividts,\n     {\"Timestamp\", \"iax2.timestamp\",\n      FT_UINT16, BASE_DEC, NULL, 0x7FFF,\n      \"timestamp is the time, in ms after the start of this call, at which this packet was transmitted\",\n      HFILL}},\n\n    {&hf_iax2_absts,\n     {\"Absolute Time\", \"iax2.abstime\",\n      FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL, NULL, 0x0,\n      \"The absolute time of this packet (calculated by adding the IAX timestamp to  the start time of this call)\",\n      HFILL}},\n\n    {&hf_iax2_lateness,\n     {\"Lateness\", \"iax2.lateness\",\n      FT_RELATIVE_TIME, BASE_NONE, NULL, 0x0,\n      \"The lateness of this packet compared to its timestamp\",\n      HFILL}},\n\n    {&hf_iax2_minividmarker,\n     {\"Marker\", \"iax2.video.marker\",\n      FT_UINT16, BASE_DEC, NULL, 0x8000,\n      \"RTP end-of-frame marker\",\n      HFILL}},\n\n    {&hf_iax2_oseqno,\n     {\"Outbound seq.no.\", \"iax2.oseqno\",\n      FT_UINT16, BASE_DEC, NULL, 0x0,\n      \"oseqno is the sequence no of this packet. The first packet has oseqno==0,\"\n      \" and subsequent packets increment the oseqno by 1\",\n      HFILL}},\n\n    {&hf_iax2_iseqno,\n     {\"Inbound seq.no.\", \"iax2.iseqno\",\n      FT_UINT16, BASE_DEC, NULL, 0x0,\n      \"iseqno is the sequence no of the last successfully received packet\",\n      HFILL}},\n\n    {&hf_iax2_type,\n     {\"Type\", \"iax2.type\",\n      FT_UINT8, BASE_DEC | BASE_EXT_STRING, &iax_frame_types_ext, 0x0,\n      \"For full IAX2 frames, type is the type of frame\",\n      HFILL}},\n\n    {&hf_iax2_csub,\n     {\"Unknown subclass\", \"iax2.subclass\",\n      FT_UINT8, BASE_DEC, NULL, 0x0,\n      \"Subclass of unknown type of full IAX2 frame\",\n      HFILL}},\n\n    {&hf_iax2_dtmf_csub,\n     {\"DTMF subclass (digit)\", \"iax2.dtmf.subclass\",\n      FT_STRINGZ, BASE_NONE, NULL, 0x0,\n      \"DTMF subclass gives the DTMF digit\",\n      HFILL}},\n\n    {&hf_iax2_cmd_csub,\n     {\"Control subclass\", \"iax2.control.subclass\",\n      FT_UINT8, BASE_DEC | BASE_EXT_STRING, &iax_cmd_subclasses_ext, 0x0,\n      \"This gives the command number for a Control packet.\",\n      HFILL}},\n\n    {&hf_iax2_iax_csub,\n     {\"IAX subclass\", \"iax2.iax.subclass\",\n      FT_UINT8, BASE_DEC | BASE_EXT_STRING, &iax_iax_subclasses_ext, 0x0,\n      \"IAX subclass gives the command number for IAX signaling packets\",\n      HFILL}},\n\n    {&hf_iax2_voice_csub,\n     {\"Voice Subclass (compressed codec no)\", \"iax2.voice.subclass\",\n      FT_UINT8, BASE_DEC, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_voice_codec,\n     {\"CODEC\", \"iax2.voice.codec\",\n      FT_UINT32, BASE_HEX | BASE_EXT_STRING, &codec_types_ext, 0x0,\n      \"CODEC gives the codec used to encode audio data\",\n      HFILL}},\n\n    {&hf_iax2_video_csub,\n     {\"Video Subclass (compressed codec no)\", \"iax2.video.subclass\",\n      FT_UINT8, BASE_DEC, NULL, 0xBF,\n      NULL, HFILL}},\n\n    {&hf_iax2_marker,\n     {\"Marker\", \"iax2.video.marker\",\n      FT_BOOLEAN, 8, NULL, 0x40,\n      \"RTP end-of-frame marker\",\n      HFILL}},\n\n    {&hf_iax2_video_codec,\n     {\"CODEC\", \"iax2.video.codec\",\n      FT_UINT32, BASE_HEX | BASE_EXT_STRING, &codec_types_ext, 0,\n      \"The codec used to encode video data\",\n      HFILL}},\n\n    {&hf_iax2_modem_csub,\n     {\"Modem subclass\", \"iax2.modem.subclass\",\n      FT_UINT8, BASE_DEC, VALS(iax_modem_subclasses), 0x0,\n      \"Modem subclass gives the type of modem\",\n      HFILL}},\n\n    {&hf_iax2_text_csub,\n     {\"Text subclass\", \"iax2.text.subclass\",\n      FT_UINT8, BASE_DEC, VALS(iax_text_subclasses), 0x0,\n      NULL,\n      HFILL}},\n\n    {&hf_iax2_text_text,\n     {\"Text\", \"iax2.text.text\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL,\n      HFILL}},\n\n    {&hf_iax2_html_csub,\n     {\"HTML subclass\", \"iax2.html.subclass\",\n      FT_UINT8, BASE_DEC, VALS(iax_html_subclasses), 0x0,\n      NULL,\n      HFILL}},\n\n    {&hf_iax2_html_url,\n     {\"HTML URL\", \"iax2.html.url\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL,\n      HFILL}},\n\n    {&hf_iax2_trunk_ts,\n     {\"Timestamp\", \"iax2.timestamp\",\n      FT_UINT32, BASE_DEC, NULL, 0x0,\n      \"timestamp is the time, in ms after the start of Command data this call,\"\n      \" at which this trunk packet was transmitted\",\n      HFILL}},\n\n    {&hf_iax2_trunk_metacmd,\n     {\"Meta command\", \"iax2.trunk.metacmd\",\n      FT_UINT8, BASE_DEC, NULL, 0x7F,\n      \"Meta command indicates whether or not the Meta Frame is a trunk.\",\n      HFILL}},\n\n    {&hf_iax2_trunk_cmddata,\n     {\"Command data\", \"iax2.trunk.cmddata\",\n      FT_UINT8, BASE_HEX, NULL, 0x0,\n      \"Flags for options that apply to a trunked call\",\n      HFILL}},\n\n    {&hf_iax2_trunk_cmddata_ts,\n     {\"Trunk timestamps\", \"iax2.trunk.cmddata.ts\",\n      FT_BOOLEAN, 8, NULL, IAX2_TRUNK_TS,\n      \"True: calls do each include their own timestamp\",\n      HFILL}},\n\n    {&hf_iax2_trunk_call_len,\n     {\"Data length\", \"iax2.trunk.call.len\",\n      FT_UINT16, BASE_DEC, NULL, 0x0,\n      \"Trunk call data length in octets\",\n      HFILL}},\n\n    {&hf_iax2_trunk_call_scallno,\n     {\"Source call number\", \"iax2.trunk.call.scallno\",\n      FT_UINT16, BASE_DEC, NULL, 0x7FFF,\n      \"Trunk call source call number\",\n      HFILL}},\n\n    {&hf_iax2_trunk_call_ts,\n     {\"Timestamp\", \"iax2.trunk.call.ts\",\n      FT_UINT16, BASE_DEC, NULL, 0x0,\n      \"timestamp is the time, in ms after the start of this call, at which this packet was transmitted\",\n      HFILL}},\n\n    {&hf_iax2_trunk_call_data,\n     {\"Data\", \"iax2.trunk.call.payload\",\n      FT_BYTES, BASE_NONE, NULL, 0x0,\n      \"Payload carried by this trunked packet.\",\n      HFILL}},\n\n    {&hf_iax2_trunk_ncalls,\n     {\"Number of calls\", \"iax2.trunk.ncalls\",\n      FT_UINT16, BASE_DEC, NULL, 0x0,\n      \"Number of calls in this trunk packet\",\n      HFILL}},\n\n    /*\n     * Decoding for the ies\n     */\n\n    {&hf_IAX_IE_APPARENTADDR_SINFAMILY,\n     {\"Family\", \"iax2.iax.app_addr.sinfamily\",\n      FT_UINT16, BASE_DEC, NULL, 0,\n      NULL, HFILL }},\n\n    {&hf_IAX_IE_APPARENTADDR_SINPORT,\n     {\"Port\", \"iax2.iax.app_addr.sinport\",\n      FT_UINT16, BASE_DEC, NULL, 0,\n      NULL, HFILL }},\n\n    {&hf_IAX_IE_APPARENTADDR_SINADDR,\n     {\"Address\", \"iax2.iax.app_addr.sinaddr\",\n      FT_IPv4, BASE_NONE, NULL, 0,\n      NULL, HFILL }},\n\n    {&hf_iax2_ies[IAX_IE_CALLED_NUMBER],\n     {\"Number/extension being called\", \"iax2.iax.called_number\",\n      FT_STRING,\n      BASE_NONE, NULL, 0x0, NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_CALLING_NUMBER],\n     {\"Calling number\", \"iax2.iax.calling_number\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n\n    {&hf_iax2_ies[IAX_IE_CALLING_ANI],\n     {\"Calling number ANI for billing\", \"iax2.iax.calling_ani\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_CALLING_NAME],\n     {\"Name of caller\", \"iax2.iax.calling_name\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_CALLED_CONTEXT],\n     {\"Context for number\", \"iax2.iax.called_context\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_USERNAME],\n     {\"Username (peer or user) for authentication\", \"iax2.iax.username\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_PASSWORD],\n     {\"Password for authentication\", \"iax2.iax.password\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_CAPABILITY],\n     {\"Actual codec capability\", \"iax2.iax.capability\",\n      FT_UINT32, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_FORMAT],\n     {\"Desired codec format\", \"iax2.iax.format\",\n      FT_UINT32, BASE_HEX | BASE_EXT_STRING, &codec_types_ext, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_LANGUAGE],\n     {\"Desired language\", \"iax2.iax.language\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_VERSION],\n     {\"Protocol version\", \"iax2.iax.version\",\n      FT_UINT16, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_ADSICPE],\n     {\"CPE ADSI capability\", \"iax2.iax.cpe_adsi\",\n      FT_UINT16, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_DNID],\n     {\"Originally dialed DNID\", \"iax2.iax.dnid\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_AUTHMETHODS],\n     {\"Authentication method(s)\", \"iax2.iax.auth.methods\",\n      FT_UINT16, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_CHALLENGE],\n     {\"Challenge data for MD5/RSA\", \"iax2.iax.auth.challenge\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_MD5_RESULT],\n     {\"MD5 challenge result\", \"iax2.iax.auth.md5\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_RSA_RESULT],\n     {\"RSA challenge result\", \"iax2.iax.auth.rsa\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_REFRESH],\n     {\"When to refresh registration\", \"iax2.iax.refresh\",\n      FT_INT16, BASE_DEC, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_DPSTATUS],\n     {\"Dialplan status\", \"iax2.iax.dialplan_status\",\n      FT_UINT16, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_CALLNO],\n     {\"Call number of peer\", \"iax2.iax.call_no\",\n      FT_UINT16, BASE_DEC, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_CAUSE],\n     {\"Cause\", \"iax2.iax.cause\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_IAX_UNKNOWN],\n     {\"Unknown IAX command\", \"iax2.iax.iax_unknown\",\n      FT_BYTES, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_MSGCOUNT],\n     {\"How many messages waiting\", \"iax2.iax.msg_count\",\n      FT_INT16, BASE_DEC, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_AUTOANSWER],\n     {\"Request auto-answering\", \"iax2.iax.autoanswer\",\n      FT_NONE, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_MUSICONHOLD],\n     {\"Request musiconhold with QUELCH\", \"iax2.iax.moh\",\n      FT_NONE, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_TRANSFERID],\n     {\"Transfer Request Identifier\", \"iax2.iax.transferid\",\n      FT_UINT32, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_RDNIS],\n     {\"Referring DNIS\", \"iax2.iax.rdnis\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_PROVISIONING],\n     {\"Provisioning info\", \"iax2.iax.provisioning\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_AESPROVISIONING],\n     {\"AES Provisioning info\", \"iax2.iax.aesprovisioning\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_DATETIME],\n     {\"Date/Time\", \"iax2.iax.datetime.raw\",\n      FT_UINT32, BASE_DEC, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ie_datetime,\n     {\"Date/Time\", \"iax2.iax.datetime\",\n      FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL, NULL, 0x0,\n      NULL, HFILL }},\n\n    {&hf_iax2_ies[IAX_IE_DEVICETYPE],\n     {\"Device type\", \"iax2.iax.devicetype\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_SERVICEIDENT],\n     {\"Service identifier\", \"iax2.iax.serviceident\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_FIRMWAREVER],\n     {\"Firmware version\", \"iax2.iax.firmwarever\",\n      FT_UINT16, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_FWBLOCKDESC],\n     {\"Firmware block description\", \"iax2.iax.fwblockdesc\",\n      FT_UINT32, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_FWBLOCKDATA],\n     {\"Firmware block of data\", \"iax2.iax.fwblockdata\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_PROVVER],\n     {\"Provisioning version\", \"iax2.iax.provver\",\n      FT_UINT32, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_CALLINGPRES],\n     {\"Calling presentation\", \"iax2.iax.callingpres\",\n      FT_UINT8, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_CALLINGTON],\n     {\"Calling type of number\", \"iax2.iax.callington\",\n      FT_UINT8, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_CALLINGTNS],\n     {\"Calling transit network select\", \"iax2.iax.callingtns\",\n      FT_UINT16, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_SAMPLINGRATE],\n     {\"Supported sampling rates\", \"iax2.iax.samplingrate\",\n      FT_UINT16, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_CAUSECODE],\n     {\"Hangup cause\", \"iax2.iax.causecode\",\n      FT_UINT8, BASE_HEX | BASE_EXT_STRING, &iax_causecodes_ext, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_ENCRYPTION],\n     {\"Encryption format\", \"iax2.iax.encryption\",\n      FT_UINT16, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_ENCKEY],\n     {\"Encryption key\", \"iax2.iax.enckey\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_CODEC_PREFS],\n     {\"Codec negotiation\", \"iax2.iax.codecprefs\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_RR_JITTER],\n     {\"Received jitter (as in RFC1889)\", \"iax2.iax.rrjitter\",\n      FT_UINT32, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_RR_LOSS],\n     {\"Received loss (high byte loss pct, low 24 bits loss count, as in rfc1889)\", \"iax2.iax.rrloss\",\n       FT_UINT32, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_RR_PKTS],\n     {\"Total frames received\", \"iax2.iax.rrpkts\",\n      FT_UINT32, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_RR_DELAY],\n     {\"Max playout delay in ms for received frames\", \"iax2.iax.rrdelay\",\n      FT_UINT16, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_RR_DROPPED],\n     {\"Dropped frames (presumably by jitterbuffer)\", \"iax2.iax.rrdropped\",\n      FT_UINT32, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_RR_OOO],\n     {\"Frame received out of order\", \"iax2.iax.rrooo\",\n      FT_UINT32, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_DATAFORMAT],\n     {\"Data call format\", \"iax2.iax.dataformat\",\n      FT_UINT32, BASE_HEX, VALS(iax_dataformats), 0x0,\n      NULL, HFILL}},\n\n    {&hf_IAX_IE_UNKNOWN_BYTE,\n     {\"Unknown\", \"iax2.iax.unknownbyte\",\n      FT_UINT8, BASE_HEX, NULL, 0x0,\n      \"Raw data for unknown IEs\", HFILL}},\n\n    {&hf_IAX_IE_UNKNOWN_I16,\n     {\"Unknown\", \"iax2.iax.unknownshort\",\n      FT_UINT16, BASE_HEX, NULL, 0x0,\n      \"Raw data for unknown IEs\", HFILL}},\n\n    {&hf_IAX_IE_UNKNOWN_I32,\n     {\"Unknown\", \"iax2.iax.unknownlong\",\n      FT_UINT32, BASE_HEX, NULL, 0x0,\n      \"Raw data for unknown IEs\", HFILL}},\n\n    {&hf_IAX_IE_UNKNOWN_BYTES,\n     {\"Unknown\", \"iax2.iax.unknownstring\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      \"Raw data for unknown IEs\", HFILL}},\n\n    {&hf_iax2_ie_id,\n     {\"IE id\", \"iax2.ie_id\",\n      FT_UINT8, BASE_DEC|BASE_EXT_STRING, &iax_ies_type_ext, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_length,\n     {\"Length\", \"iax2.length\",\n      FT_UINT8, BASE_DEC, NULL, 0x0,\n      NULL, HFILL}},\n\n    /* capabilities */\n    {&hf_iax2_cap_g723_1,\n     {\"G.723.1 compression\", \"iax2.cap.g723_1\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_G723_1,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_gsm,\n     {\"GSM compression\", \"iax2.cap.gsm\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_GSM,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_ulaw,\n     {\"Raw mu-law data (G.711)\", \"iax2.cap.ulaw\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_ULAW,\n      NULL, HFILL }},\n\n     {&hf_iax2_cap_alaw,\n      {\"Raw A-law data (G.711)\", \"iax2.cap.alaw\",\n       FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_ALAW,\n       NULL, HFILL } },\n\n    {&hf_iax2_cap_g726_aal2,\n     {\"G.726 compression (AAL2 packing)\", \"iax2.cap.g726_aal2\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_G726_AAL2,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_adpcm,\n     {\"ADPCM\", \"iax2.cap.adpcm\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_ADPCM,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_slinear,\n     {\"Raw 16-bit Signed Linear (8000 Hz) PCM\", \"iax2.cap.slinear\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_SLINEAR,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_lpc10,\n     {\"LPC10, 180 samples/frame\",\n      \"iax2.cap.lpc10\", FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported),\n      AST_FORMAT_LPC10, NULL, HFILL }},\n\n    {&hf_iax2_cap_g729a,\n     {\"G.729a Audio\", \"iax2.cap.g729a\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_G729A,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_speex,\n     {\"SPEEX Audio\", \"iax2.cap.speex\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_SPEEX,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_ilbc,\n     {\"iLBC Free compressed Audio\", \"iax2.cap.ilbc\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_ILBC,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_g726,\n     {\"ADPCM (G.726, 32kbps, RFC3551 codeword packing)\", \"iax2.cap.g726\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_G726,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_g722,\n     {\"G.722 wideband audio\", \"iax2.cap.g722\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_G722,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_siren7,\n     {\"G.722.1 (also known as Siren7, 32kbps assumed)\", \"iax2.cap.siren7\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_SIREN7,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_siren14,\n     {\"G.722.1 Annex C (also known as Siren14, 48kbps assumed)\", \"iax2.cap.siren14\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_SIREN14,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_slinear16,\n     {\"Raw 16-bit Signed Linear (16000 Hz) PCM\", \"iax2.cap.slinear16\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_SLINEAR16,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_jpeg,\n     {\"JPEG images\", \"iax2.cap.jpeg\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_JPEG,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_png,\n     {\"PNG images\", \"iax2.cap.png\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_PNG,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_h261,\n     {\"H.261 video\", \"iax2.cap.h261\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_H261,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_h263,\n     {\"H.263 video\", \"iax2.cap.h263\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_H263,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_h263_plus,\n     {\"H.263+ video\", \"iax2.cap.h263_plus\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_H263_PLUS,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_h264,\n     {\"H.264 video\", \"iax2.cap.h264\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_H264,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_mpeg4,\n     {\"MPEG4 video\", \"iax2.cap.mpeg4\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_MP4_VIDEO,\n      NULL, HFILL }},\n\n    {&hf_iax2_fragment_unfinished,\n     {\"IAX2 fragment, unfinished\", \"iax2.fragment_unfinished\",\n      FT_BYTES, BASE_NONE, NULL, 0x0,\n      NULL, HFILL }},\n\n    {&hf_iax2_payload_data,\n     {\"IAX2 payload\", \"iax2.payload_data\",\n      FT_BYTES, BASE_NONE, NULL, 0x0,\n      NULL, HFILL }},\n\n    /* reassembly stuff */\n    {&hf_iax2_fragments,\n     {\"IAX2 Fragments\", \"iax2.fragments\",\n      FT_NONE, BASE_NONE, NULL, 0x0,\n      NULL, HFILL }},\n\n    {&hf_iax2_fragment,\n     {\"IAX2 Fragment data\", \"iax2.fragment\",\n      FT_FRAMENUM, BASE_NONE, NULL, 0x0,\n      NULL, HFILL }},\n\n    {&hf_iax2_fragment_overlap,\n     {\"Fragment overlap\", \"iax2.fragment.overlap\",\n      FT_BOOLEAN, BASE_NONE, NULL, 0x0,\n      \"Fragment overlaps with other fragments\", HFILL }},\n\n    {&hf_iax2_fragment_overlap_conflict,\n     {\"Conflicting data in fragment overlap\", \"iax2.fragment.overlap.conflict\",\n      FT_BOOLEAN, BASE_NONE, NULL, 0x0,\n      \"Overlapping fragments contained conflicting data\", HFILL }},\n\n    {&hf_iax2_fragment_multiple_tails,\n     {\"Multiple tail fragments found\", \"iax2.fragment.multipletails\",\n      FT_BOOLEAN, BASE_NONE, NULL, 0x0,\n      \"Several tails were found when defragmenting the packet\", HFILL }},\n\n    {&hf_iax2_fragment_too_long_fragment,\n     {\"Fragment too long\", \"iax2.fragment.toolongfragment\",\n      FT_BOOLEAN, BASE_NONE, NULL, 0x0,\n      \"Fragment contained data past end of packet\", HFILL }},\n\n    {&hf_iax2_fragment_error,\n     {\"Defragmentation error\", \"iax2.fragment.error\",\n      FT_FRAMENUM, BASE_NONE, NULL, 0x0,\n      \"Defragmentation error due to illegal fragments\", HFILL }},\n\n    {&hf_iax2_fragment_count,\n     {\"Fragment count\", \"iax2.fragment.count\",\n      FT_UINT32, BASE_DEC, NULL, 0x0,\n      NULL, HFILL }},\n\n    {&hf_iax2_reassembled_in,\n     {\"IAX2 fragment, reassembled in frame\", \"iax2.reassembled_in\",\n      FT_FRAMENUM, BASE_NONE, NULL, 0x0,\n      \"This IAX2 packet is reassembled in this frame\", HFILL }},\n\n    {&hf_iax2_reassembled_length,\n     {\"Reassembled IAX2 length\", \"iax2.reassembled.length\",\n      FT_UINT32, BASE_DEC, NULL, 0x0,\n      \"The total length of the reassembled payload\", HFILL }}\n  };\n\n  static gint *ett[] = {\n    &ett_iax2,\n    &ett_iax2_full_mini_subtree,\n    &ett_iax2_type,\n    &ett_iax2_ie,\n    &ett_iax2_codecs,\n    &ett_iax2_ies_apparent_addr,\n    &ett_iax2_fragment,\n    &ett_iax2_fragments,\n    &ett_iax2_trunk_cmddata,\n    &ett_iax2_trunk_call\n  };\n\n  static ei_register_info ei[] = {\n    { &ei_iax_too_many_transfers, { \"iax2.too_many_transfers\", PI_PROTOCOL, PI_WARN, \"Too many transfers for iax_call\", EXPFILL }},\n    { &ei_iax_circuit_id_conflict, { \"iax2.circuit_id_conflict\", PI_PROTOCOL, PI_WARN, \"Circuit ID conflict\", EXPFILL }},\n    { &ei_iax_peer_address_unsupported, { \"iax2.peer_address_unsupported\", PI_PROTOCOL, PI_WARN, \"Peer address unsupported\", EXPFILL }},\n    { &ei_iax_invalid_len, { \"iax2.invalid_len\", PI_PROTOCOL, PI_WARN, \"Invalid length\", EXPFILL }}\n  };\n\n  expert_module_t* expert_iax;\n\n  /* initialize the hf_iax2_ies[] array to -1 */\n  memset(hf_iax2_ies, 0xff, sizeof(hf_iax2_ies));\n\n  proto_iax2 =\n    proto_register_protocol(\"Inter-Asterisk eXchange v2\", \"IAX2\", \"iax2\");\n  proto_register_field_array(proto_iax2, hf, array_length(hf));\n  proto_register_subtree_array(ett, array_length(ett));\n  expert_iax = expert_register_protocol(proto_iax2);\n  expert_register_field_array(expert_iax, ei, array_length(ei));\n\n  register_dissector(\"iax2\", dissect_iax2, proto_iax2);\n\n  iax2_codec_dissector_table = register_dissector_table(\n    \"iax2.codec\", \"IAX codec number\", FT_UINT32, BASE_HEX);\n  iax2_dataformat_dissector_table = register_dissector_table(\n    \"iax2.dataformat\", \"IAX dataformat number\", FT_UINT32, BASE_HEX);\n\n  /* register our init routine to be called at the start of a capture,\n     to clear out our hash tables etc */\n  register_init_routine(&iax_init_protocol);\n  register_cleanup_routine(&iax_cleanup_protocol);\n  iax2_tap = register_tap(\"IAX2\");\n}",
        "func": "void\nproto_register_iax2(void)\n{\n  /* A header field is something you can search/filter on.\n   *\n   * We create a structure to register our fields. It consists of an\n   * array of hf_register_info structures, each of which are of the format\n   * {&(field id), {name, abbrev, type, display, strings, bitmask, blurb, HFILL}}.\n   */\n\n  static hf_register_info hf[] = {\n\n    {&hf_iax2_packet_type,\n     {\"Packet type\", \"iax2.packet_type\",\n      FT_UINT8, BASE_DEC, VALS(iax_packet_types), 0,\n      \"Full/minivoice/minivideo/trunk packet\",\n      HFILL}},\n\n    {&hf_iax2_callno,\n     {\"Call identifier\", \"iax2.call\",\n      FT_UINT32, BASE_DEC, NULL, 0,\n      \"This is the identifier Wireshark assigns to identify this call.\"\n      \" It does not correspond to any real field in the protocol\",\n      HFILL }},\n\n    {&hf_iax2_scallno,\n     {\"Source call\", \"iax2.src_call\",\n      FT_UINT16, BASE_DEC, NULL, 0x7FFF,\n      \"src_call holds the number of this call at the packet source pbx\",\n      HFILL}},\n\n    /* FIXME could this be turned into a FRAMENUM field? */\n    {&hf_iax2_dcallno,\n     {\"Destination call\", \"iax2.dst_call\",\n      FT_UINT16, BASE_DEC, NULL, 0x7FFF,\n      \"dst_call holds the number of this call at the packet destination\",\n      HFILL}},\n\n    {&hf_iax2_retransmission,\n     {\"Retransmission\", \"iax2.retransmission\",\n      FT_BOOLEAN, 16, NULL, 0x8000,\n      \"retransmission is set if this packet is a retransmission of an earlier failed packet\",\n      HFILL}},\n\n    {&hf_iax2_ts,\n     {\"Timestamp\", \"iax2.timestamp\",\n      FT_UINT32, BASE_DEC, NULL, 0x0,\n      \"timestamp is the time, in ms after the start of this call, at which this packet was transmitted\",\n      HFILL}},\n\n    {&hf_iax2_minits,\n     {\"Timestamp\", \"iax2.timestamp\",\n      FT_UINT16, BASE_DEC, NULL, 0x0,\n      \"timestamp is the time, in ms after the start of this call, at which this packet was transmitted\",\n      HFILL}},\n\n    {&hf_iax2_minividts,\n     {\"Timestamp\", \"iax2.timestamp\",\n      FT_UINT16, BASE_DEC, NULL, 0x7FFF,\n      \"timestamp is the time, in ms after the start of this call, at which this packet was transmitted\",\n      HFILL}},\n\n    {&hf_iax2_absts,\n     {\"Absolute Time\", \"iax2.abstime\",\n      FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL, NULL, 0x0,\n      \"The absolute time of this packet (calculated by adding the IAX timestamp to  the start time of this call)\",\n      HFILL}},\n\n    {&hf_iax2_lateness,\n     {\"Lateness\", \"iax2.lateness\",\n      FT_RELATIVE_TIME, BASE_NONE, NULL, 0x0,\n      \"The lateness of this packet compared to its timestamp\",\n      HFILL}},\n\n    {&hf_iax2_minividmarker,\n     {\"Marker\", \"iax2.video.marker\",\n      FT_UINT16, BASE_DEC, NULL, 0x8000,\n      \"RTP end-of-frame marker\",\n      HFILL}},\n\n    {&hf_iax2_oseqno,\n     {\"Outbound seq.no.\", \"iax2.oseqno\",\n      FT_UINT16, BASE_DEC, NULL, 0x0,\n      \"oseqno is the sequence no of this packet. The first packet has oseqno==0,\"\n      \" and subsequent packets increment the oseqno by 1\",\n      HFILL}},\n\n    {&hf_iax2_iseqno,\n     {\"Inbound seq.no.\", \"iax2.iseqno\",\n      FT_UINT16, BASE_DEC, NULL, 0x0,\n      \"iseqno is the sequence no of the last successfully received packet\",\n      HFILL}},\n\n    {&hf_iax2_type,\n     {\"Type\", \"iax2.type\",\n      FT_UINT8, BASE_DEC | BASE_EXT_STRING, &iax_frame_types_ext, 0x0,\n      \"For full IAX2 frames, type is the type of frame\",\n      HFILL}},\n\n    {&hf_iax2_csub,\n     {\"Unknown subclass\", \"iax2.subclass\",\n      FT_UINT8, BASE_DEC, NULL, 0x0,\n      \"Subclass of unknown type of full IAX2 frame\",\n      HFILL}},\n\n    {&hf_iax2_dtmf_csub,\n     {\"DTMF subclass (digit)\", \"iax2.dtmf.subclass\",\n      FT_STRINGZ, BASE_NONE, NULL, 0x0,\n      \"DTMF subclass gives the DTMF digit\",\n      HFILL}},\n\n    {&hf_iax2_cmd_csub,\n     {\"Control subclass\", \"iax2.control.subclass\",\n      FT_UINT8, BASE_DEC | BASE_EXT_STRING, &iax_cmd_subclasses_ext, 0x0,\n      \"This gives the command number for a Control packet.\",\n      HFILL}},\n\n    {&hf_iax2_iax_csub,\n     {\"IAX subclass\", \"iax2.iax.subclass\",\n      FT_UINT8, BASE_DEC | BASE_EXT_STRING, &iax_iax_subclasses_ext, 0x0,\n      \"IAX subclass gives the command number for IAX signaling packets\",\n      HFILL}},\n\n    {&hf_iax2_voice_csub,\n     {\"Voice Subclass (compressed codec no)\", \"iax2.voice.subclass\",\n      FT_UINT8, BASE_DEC, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_voice_codec,\n     {\"CODEC\", \"iax2.voice.codec\",\n      FT_UINT32, BASE_HEX | BASE_EXT_STRING, &codec_types_ext, 0x0,\n      \"CODEC gives the codec used to encode audio data\",\n      HFILL}},\n\n    {&hf_iax2_video_csub,\n     {\"Video Subclass (compressed codec no)\", \"iax2.video.subclass\",\n      FT_UINT8, BASE_DEC, NULL, 0xBF,\n      NULL, HFILL}},\n\n    {&hf_iax2_marker,\n     {\"Marker\", \"iax2.video.marker\",\n      FT_BOOLEAN, 8, NULL, 0x40,\n      \"RTP end-of-frame marker\",\n      HFILL}},\n\n    {&hf_iax2_video_codec,\n     {\"CODEC\", \"iax2.video.codec\",\n      FT_UINT32, BASE_HEX | BASE_EXT_STRING, &codec_types_ext, 0,\n      \"The codec used to encode video data\",\n      HFILL}},\n\n    {&hf_iax2_modem_csub,\n     {\"Modem subclass\", \"iax2.modem.subclass\",\n      FT_UINT8, BASE_DEC, VALS(iax_modem_subclasses), 0x0,\n      \"Modem subclass gives the type of modem\",\n      HFILL}},\n\n    {&hf_iax2_text_csub,\n     {\"Text subclass\", \"iax2.text.subclass\",\n      FT_UINT8, BASE_DEC, VALS(iax_text_subclasses), 0x0,\n      NULL,\n      HFILL}},\n\n    {&hf_iax2_text_text,\n     {\"Text\", \"iax2.text.text\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL,\n      HFILL}},\n\n    {&hf_iax2_html_csub,\n     {\"HTML subclass\", \"iax2.html.subclass\",\n      FT_UINT8, BASE_DEC, VALS(iax_html_subclasses), 0x0,\n      NULL,\n      HFILL}},\n\n    {&hf_iax2_html_url,\n     {\"HTML URL\", \"iax2.html.url\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL,\n      HFILL}},\n\n    {&hf_iax2_trunk_ts,\n     {\"Timestamp\", \"iax2.timestamp\",\n      FT_UINT32, BASE_DEC, NULL, 0x0,\n      \"timestamp is the time, in ms after the start of Command data this call,\"\n      \" at which this trunk packet was transmitted\",\n      HFILL}},\n\n    {&hf_iax2_trunk_metacmd,\n     {\"Meta command\", \"iax2.trunk.metacmd\",\n      FT_UINT8, BASE_DEC, NULL, 0x7F,\n      \"Meta command indicates whether or not the Meta Frame is a trunk.\",\n      HFILL}},\n\n    {&hf_iax2_trunk_cmddata,\n     {\"Command data\", \"iax2.trunk.cmddata\",\n      FT_UINT8, BASE_HEX, NULL, 0x0,\n      \"Flags for options that apply to a trunked call\",\n      HFILL}},\n\n    {&hf_iax2_trunk_cmddata_ts,\n     {\"Trunk timestamps\", \"iax2.trunk.cmddata.ts\",\n      FT_BOOLEAN, 8, NULL, IAX2_TRUNK_TS,\n      \"True: calls do each include their own timestamp\",\n      HFILL}},\n\n    {&hf_iax2_trunk_call_len,\n     {\"Data length\", \"iax2.trunk.call.len\",\n      FT_UINT16, BASE_DEC, NULL, 0x0,\n      \"Trunk call data length in octets\",\n      HFILL}},\n\n    {&hf_iax2_trunk_call_scallno,\n     {\"Source call number\", \"iax2.trunk.call.scallno\",\n      FT_UINT16, BASE_DEC, NULL, 0x7FFF,\n      \"Trunk call source call number\",\n      HFILL}},\n\n    {&hf_iax2_trunk_call_ts,\n     {\"Timestamp\", \"iax2.trunk.call.ts\",\n      FT_UINT16, BASE_DEC, NULL, 0x0,\n      \"timestamp is the time, in ms after the start of this call, at which this packet was transmitted\",\n      HFILL}},\n\n    {&hf_iax2_trunk_call_data,\n     {\"Data\", \"iax2.trunk.call.payload\",\n      FT_BYTES, BASE_NONE, NULL, 0x0,\n      \"Payload carried by this trunked packet.\",\n      HFILL}},\n\n    {&hf_iax2_trunk_ncalls,\n     {\"Number of calls\", \"iax2.trunk.ncalls\",\n      FT_UINT16, BASE_DEC, NULL, 0x0,\n      \"Number of calls in this trunk packet\",\n      HFILL}},\n\n    /*\n     * Decoding for the ies\n     */\n\n    {&hf_IAX_IE_APPARENTADDR_SINFAMILY,\n     {\"Family\", \"iax2.iax.app_addr.sinfamily\",\n      FT_UINT16, BASE_DEC, NULL, 0,\n      NULL, HFILL }},\n\n    {&hf_IAX_IE_APPARENTADDR_SINPORT,\n     {\"Port\", \"iax2.iax.app_addr.sinport\",\n      FT_UINT16, BASE_DEC, NULL, 0,\n      NULL, HFILL }},\n\n    {&hf_IAX_IE_APPARENTADDR_SINADDR,\n     {\"Address\", \"iax2.iax.app_addr.sinaddr\",\n      FT_IPv4, BASE_NONE, NULL, 0,\n      NULL, HFILL }},\n\n    {&hf_iax2_ies[IAX_IE_CALLED_NUMBER],\n     {\"Number/extension being called\", \"iax2.iax.called_number\",\n      FT_STRING,\n      BASE_NONE, NULL, 0x0, NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_CALLING_NUMBER],\n     {\"Calling number\", \"iax2.iax.calling_number\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n\n    {&hf_iax2_ies[IAX_IE_CALLING_ANI],\n     {\"Calling number ANI for billing\", \"iax2.iax.calling_ani\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_CALLING_NAME],\n     {\"Name of caller\", \"iax2.iax.calling_name\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_CALLED_CONTEXT],\n     {\"Context for number\", \"iax2.iax.called_context\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_USERNAME],\n     {\"Username (peer or user) for authentication\", \"iax2.iax.username\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_PASSWORD],\n     {\"Password for authentication\", \"iax2.iax.password\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_CAPABILITY],\n     {\"Actual codec capability\", \"iax2.iax.capability\",\n      FT_UINT32, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_FORMAT],\n     {\"Desired codec format\", \"iax2.iax.format\",\n      FT_UINT32, BASE_HEX | BASE_EXT_STRING, &codec_types_ext, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_LANGUAGE],\n     {\"Desired language\", \"iax2.iax.language\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_VERSION],\n     {\"Protocol version\", \"iax2.iax.version\",\n      FT_UINT16, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_ADSICPE],\n     {\"CPE ADSI capability\", \"iax2.iax.cpe_adsi\",\n      FT_UINT16, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_DNID],\n     {\"Originally dialed DNID\", \"iax2.iax.dnid\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_AUTHMETHODS],\n     {\"Authentication method(s)\", \"iax2.iax.auth.methods\",\n      FT_UINT16, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_CHALLENGE],\n     {\"Challenge data for MD5/RSA\", \"iax2.iax.auth.challenge\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_MD5_RESULT],\n     {\"MD5 challenge result\", \"iax2.iax.auth.md5\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_RSA_RESULT],\n     {\"RSA challenge result\", \"iax2.iax.auth.rsa\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_REFRESH],\n     {\"When to refresh registration\", \"iax2.iax.refresh\",\n      FT_INT16, BASE_DEC, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_DPSTATUS],\n     {\"Dialplan status\", \"iax2.iax.dialplan_status\",\n      FT_UINT16, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_CALLNO],\n     {\"Call number of peer\", \"iax2.iax.call_no\",\n      FT_UINT16, BASE_DEC, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_CAUSE],\n     {\"Cause\", \"iax2.iax.cause\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_IAX_UNKNOWN],\n     {\"Unknown IAX command\", \"iax2.iax.iax_unknown\",\n      FT_BYTES, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_MSGCOUNT],\n     {\"How many messages waiting\", \"iax2.iax.msg_count\",\n      FT_INT16, BASE_DEC, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_AUTOANSWER],\n     {\"Request auto-answering\", \"iax2.iax.autoanswer\",\n      FT_NONE, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_MUSICONHOLD],\n     {\"Request musiconhold with QUELCH\", \"iax2.iax.moh\",\n      FT_NONE, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_TRANSFERID],\n     {\"Transfer Request Identifier\", \"iax2.iax.transferid\",\n      FT_UINT32, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_RDNIS],\n     {\"Referring DNIS\", \"iax2.iax.rdnis\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_PROVISIONING],\n     {\"Provisioning info\", \"iax2.iax.provisioning\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_AESPROVISIONING],\n     {\"AES Provisioning info\", \"iax2.iax.aesprovisioning\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_DATETIME],\n     {\"Date/Time\", \"iax2.iax.datetime.raw\",\n      FT_UINT32, BASE_DEC, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ie_datetime,\n     {\"Date/Time\", \"iax2.iax.datetime\",\n      FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL, NULL, 0x0,\n      NULL, HFILL }},\n\n    {&hf_iax2_ies[IAX_IE_DEVICETYPE],\n     {\"Device type\", \"iax2.iax.devicetype\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_SERVICEIDENT],\n     {\"Service identifier\", \"iax2.iax.serviceident\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_FIRMWAREVER],\n     {\"Firmware version\", \"iax2.iax.firmwarever\",\n      FT_UINT16, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_FWBLOCKDESC],\n     {\"Firmware block description\", \"iax2.iax.fwblockdesc\",\n      FT_UINT32, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_FWBLOCKDATA],\n     {\"Firmware block of data\", \"iax2.iax.fwblockdata\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_PROVVER],\n     {\"Provisioning version\", \"iax2.iax.provver\",\n      FT_UINT32, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_CALLINGPRES],\n     {\"Calling presentation\", \"iax2.iax.callingpres\",\n      FT_UINT8, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_CALLINGTON],\n     {\"Calling type of number\", \"iax2.iax.callington\",\n      FT_UINT8, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_CALLINGTNS],\n     {\"Calling transit network select\", \"iax2.iax.callingtns\",\n      FT_UINT16, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_SAMPLINGRATE],\n     {\"Supported sampling rates\", \"iax2.iax.samplingrate\",\n      FT_UINT16, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_CAUSECODE],\n     {\"Hangup cause\", \"iax2.iax.causecode\",\n      FT_UINT8, BASE_HEX | BASE_EXT_STRING, &iax_causecodes_ext, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_ENCRYPTION],\n     {\"Encryption format\", \"iax2.iax.encryption\",\n      FT_UINT16, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_ENCKEY],\n     {\"Encryption key\", \"iax2.iax.enckey\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_CODEC_PREFS],\n     {\"Codec negotiation\", \"iax2.iax.codecprefs\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_RR_JITTER],\n     {\"Received jitter (as in RFC1889)\", \"iax2.iax.rrjitter\",\n      FT_UINT32, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_RR_LOSS],\n     {\"Received loss (high byte loss pct, low 24 bits loss count, as in rfc1889)\", \"iax2.iax.rrloss\",\n       FT_UINT32, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_RR_PKTS],\n     {\"Total frames received\", \"iax2.iax.rrpkts\",\n      FT_UINT32, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_RR_DELAY],\n     {\"Max playout delay in ms for received frames\", \"iax2.iax.rrdelay\",\n      FT_UINT16, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_RR_DROPPED],\n     {\"Dropped frames (presumably by jitterbuffer)\", \"iax2.iax.rrdropped\",\n      FT_UINT32, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_RR_OOO],\n     {\"Frame received out of order\", \"iax2.iax.rrooo\",\n      FT_UINT32, BASE_HEX, NULL, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_ies[IAX_IE_DATAFORMAT],\n     {\"Data call format\", \"iax2.iax.dataformat\",\n      FT_UINT32, BASE_HEX, VALS(iax_dataformats), 0x0,\n      NULL, HFILL}},\n\n    {&hf_IAX_IE_UNKNOWN_BYTE,\n     {\"Unknown\", \"iax2.iax.unknownbyte\",\n      FT_UINT8, BASE_HEX, NULL, 0x0,\n      \"Raw data for unknown IEs\", HFILL}},\n\n    {&hf_IAX_IE_UNKNOWN_I16,\n     {\"Unknown\", \"iax2.iax.unknownshort\",\n      FT_UINT16, BASE_HEX, NULL, 0x0,\n      \"Raw data for unknown IEs\", HFILL}},\n\n    {&hf_IAX_IE_UNKNOWN_I32,\n     {\"Unknown\", \"iax2.iax.unknownlong\",\n      FT_UINT32, BASE_HEX, NULL, 0x0,\n      \"Raw data for unknown IEs\", HFILL}},\n\n    {&hf_IAX_IE_UNKNOWN_BYTES,\n     {\"Unknown\", \"iax2.iax.unknownstring\",\n      FT_STRING, BASE_NONE, NULL, 0x0,\n      \"Raw data for unknown IEs\", HFILL}},\n\n    {&hf_iax2_ie_id,\n     {\"IE id\", \"iax2.ie_id\",\n      FT_UINT8, BASE_DEC|BASE_EXT_STRING, &iax_ies_type_ext, 0x0,\n      NULL, HFILL}},\n\n    {&hf_iax2_length,\n     {\"Length\", \"iax2.length\",\n      FT_UINT8, BASE_DEC, NULL, 0x0,\n      NULL, HFILL}},\n\n    /* capabilities */\n    {&hf_iax2_cap_g723_1,\n     {\"G.723.1 compression\", \"iax2.cap.g723_1\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_G723_1,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_gsm,\n     {\"GSM compression\", \"iax2.cap.gsm\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_GSM,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_ulaw,\n     {\"Raw mu-law data (G.711)\", \"iax2.cap.ulaw\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_ULAW,\n      NULL, HFILL }},\n\n     {&hf_iax2_cap_alaw,\n      {\"Raw A-law data (G.711)\", \"iax2.cap.alaw\",\n       FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_ALAW,\n       NULL, HFILL } },\n\n    {&hf_iax2_cap_g726_aal2,\n     {\"G.726 compression (AAL2 packing)\", \"iax2.cap.g726_aal2\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_G726_AAL2,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_adpcm,\n     {\"ADPCM\", \"iax2.cap.adpcm\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_ADPCM,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_slinear,\n     {\"Raw 16-bit Signed Linear (8000 Hz) PCM\", \"iax2.cap.slinear\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_SLINEAR,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_lpc10,\n     {\"LPC10, 180 samples/frame\",\n      \"iax2.cap.lpc10\", FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported),\n      AST_FORMAT_LPC10, NULL, HFILL }},\n\n    {&hf_iax2_cap_g729a,\n     {\"G.729a Audio\", \"iax2.cap.g729a\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_G729A,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_speex,\n     {\"SPEEX Audio\", \"iax2.cap.speex\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_SPEEX,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_ilbc,\n     {\"iLBC Free compressed Audio\", \"iax2.cap.ilbc\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_ILBC,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_g726,\n     {\"ADPCM (G.726, 32kbps, RFC3551 codeword packing)\", \"iax2.cap.g726\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_G726,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_g722,\n     {\"G.722 wideband audio\", \"iax2.cap.g722\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_G722,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_siren7,\n     {\"G.722.1 (also known as Siren7, 32kbps assumed)\", \"iax2.cap.siren7\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_SIREN7,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_siren14,\n     {\"G.722.1 Annex C (also known as Siren14, 48kbps assumed)\", \"iax2.cap.siren14\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_SIREN14,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_slinear16,\n     {\"Raw 16-bit Signed Linear (16000 Hz) PCM\", \"iax2.cap.slinear16\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_SLINEAR16,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_jpeg,\n     {\"JPEG images\", \"iax2.cap.jpeg\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_JPEG,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_png,\n     {\"PNG images\", \"iax2.cap.png\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_PNG,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_h261,\n     {\"H.261 video\", \"iax2.cap.h261\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_H261,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_h263,\n     {\"H.263 video\", \"iax2.cap.h263\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_H263,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_h263_plus,\n     {\"H.263+ video\", \"iax2.cap.h263_plus\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_H263_PLUS,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_h264,\n     {\"H.264 video\", \"iax2.cap.h264\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_H264,\n      NULL, HFILL }},\n\n    {&hf_iax2_cap_mpeg4,\n     {\"MPEG4 video\", \"iax2.cap.mpeg4\",\n      FT_BOOLEAN, 32, TFS(&tfs_supported_not_supported), AST_FORMAT_MP4_VIDEO,\n      NULL, HFILL }},\n\n    {&hf_iax2_fragment_unfinished,\n     {\"IAX2 fragment, unfinished\", \"iax2.fragment_unfinished\",\n      FT_BYTES, BASE_NONE, NULL, 0x0,\n      NULL, HFILL }},\n\n    {&hf_iax2_payload_data,\n     {\"IAX2 payload\", \"iax2.payload_data\",\n      FT_BYTES, BASE_NONE, NULL, 0x0,\n      NULL, HFILL }},\n\n    /* reassembly stuff */\n    {&hf_iax2_fragments,\n     {\"IAX2 Fragments\", \"iax2.fragments\",\n      FT_NONE, BASE_NONE, NULL, 0x0,\n      NULL, HFILL }},\n\n    {&hf_iax2_fragment,\n     {\"IAX2 Fragment data\", \"iax2.fragment\",\n      FT_FRAMENUM, BASE_NONE, NULL, 0x0,\n      NULL, HFILL }},\n\n    {&hf_iax2_fragment_overlap,\n     {\"Fragment overlap\", \"iax2.fragment.overlap\",\n      FT_BOOLEAN, BASE_NONE, NULL, 0x0,\n      \"Fragment overlaps with other fragments\", HFILL }},\n\n    {&hf_iax2_fragment_overlap_conflict,\n     {\"Conflicting data in fragment overlap\", \"iax2.fragment.overlap.conflict\",\n      FT_BOOLEAN, BASE_NONE, NULL, 0x0,\n      \"Overlapping fragments contained conflicting data\", HFILL }},\n\n    {&hf_iax2_fragment_multiple_tails,\n     {\"Multiple tail fragments found\", \"iax2.fragment.multipletails\",\n      FT_BOOLEAN, BASE_NONE, NULL, 0x0,\n      \"Several tails were found when defragmenting the packet\", HFILL }},\n\n    {&hf_iax2_fragment_too_long_fragment,\n     {\"Fragment too long\", \"iax2.fragment.toolongfragment\",\n      FT_BOOLEAN, BASE_NONE, NULL, 0x0,\n      \"Fragment contained data past end of packet\", HFILL }},\n\n    {&hf_iax2_fragment_error,\n     {\"Defragmentation error\", \"iax2.fragment.error\",\n      FT_FRAMENUM, BASE_NONE, NULL, 0x0,\n      \"Defragmentation error due to illegal fragments\", HFILL }},\n\n    {&hf_iax2_fragment_count,\n     {\"Fragment count\", \"iax2.fragment.count\",\n      FT_UINT32, BASE_DEC, NULL, 0x0,\n      NULL, HFILL }},\n\n    {&hf_iax2_reassembled_in,\n     {\"IAX2 fragment, reassembled in frame\", \"iax2.reassembled_in\",\n      FT_FRAMENUM, BASE_NONE, NULL, 0x0,\n      \"This IAX2 packet is reassembled in this frame\", HFILL }},\n\n    {&hf_iax2_reassembled_length,\n     {\"Reassembled IAX2 length\", \"iax2.reassembled.length\",\n      FT_UINT32, BASE_DEC, NULL, 0x0,\n      \"The total length of the reassembled payload\", HFILL }}\n  };\n\n  static gint *ett[] = {\n    &ett_iax2,\n    &ett_iax2_full_mini_subtree,\n    &ett_iax2_type,\n    &ett_iax2_ie,\n    &ett_iax2_codecs,\n    &ett_iax2_ies_apparent_addr,\n    &ett_iax2_fragment,\n    &ett_iax2_fragments,\n    &ett_iax2_trunk_cmddata,\n    &ett_iax2_trunk_call\n  };\n\n  static ei_register_info ei[] = {\n    { &ei_iax_too_many_transfers, { \"iax2.too_many_transfers\", PI_PROTOCOL, PI_WARN, \"Too many transfers for iax_call\", EXPFILL }},\n    { &ei_iax_circuit_id_conflict, { \"iax2.circuit_id_conflict\", PI_PROTOCOL, PI_WARN, \"Circuit ID conflict\", EXPFILL }},\n    { &ei_iax_peer_address_unsupported, { \"iax2.peer_address_unsupported\", PI_PROTOCOL, PI_WARN, \"Peer address unsupported\", EXPFILL }},\n    { &ei_iax_invalid_len, { \"iax2.invalid_len\", PI_PROTOCOL, PI_WARN, \"Invalid length\", EXPFILL }},\n    { &ei_iax_invalid_ts, { \"iax2.invalid_ts\", PI_PROTOCOL, PI_WARN, \"Invalid timestamp\", EXPFILL }}\n  };\n\n  expert_module_t* expert_iax;\n\n  /* initialize the hf_iax2_ies[] array to -1 */\n  memset(hf_iax2_ies, 0xff, sizeof(hf_iax2_ies));\n\n  proto_iax2 =\n    proto_register_protocol(\"Inter-Asterisk eXchange v2\", \"IAX2\", \"iax2\");\n  proto_register_field_array(proto_iax2, hf, array_length(hf));\n  proto_register_subtree_array(ett, array_length(ett));\n  expert_iax = expert_register_protocol(proto_iax2);\n  expert_register_field_array(expert_iax, ei, array_length(ei));\n\n  register_dissector(\"iax2\", dissect_iax2, proto_iax2);\n\n  iax2_codec_dissector_table = register_dissector_table(\n    \"iax2.codec\", \"IAX codec number\", FT_UINT32, BASE_HEX);\n  iax2_dataformat_dissector_table = register_dissector_table(\n    \"iax2.dataformat\", \"IAX dataformat number\", FT_UINT32, BASE_HEX);\n\n  /* register our init routine to be called at the start of a capture,\n     to clear out our hash tables etc */\n  register_init_routine(&iax_init_protocol);\n  register_cleanup_routine(&iax_cleanup_protocol);\n  iax2_tap = register_tap(\"IAX2\");\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -739,7 +739,8 @@\n     { &ei_iax_too_many_transfers, { \"iax2.too_many_transfers\", PI_PROTOCOL, PI_WARN, \"Too many transfers for iax_call\", EXPFILL }},\n     { &ei_iax_circuit_id_conflict, { \"iax2.circuit_id_conflict\", PI_PROTOCOL, PI_WARN, \"Circuit ID conflict\", EXPFILL }},\n     { &ei_iax_peer_address_unsupported, { \"iax2.peer_address_unsupported\", PI_PROTOCOL, PI_WARN, \"Peer address unsupported\", EXPFILL }},\n-    { &ei_iax_invalid_len, { \"iax2.invalid_len\", PI_PROTOCOL, PI_WARN, \"Invalid length\", EXPFILL }}\n+    { &ei_iax_invalid_len, { \"iax2.invalid_len\", PI_PROTOCOL, PI_WARN, \"Invalid length\", EXPFILL }},\n+    { &ei_iax_invalid_ts, { \"iax2.invalid_ts\", PI_PROTOCOL, PI_WARN, \"Invalid timestamp\", EXPFILL }}\n   };\n \n   expert_module_t* expert_iax;",
        "diff_line_info": {
            "deleted_lines": [
                "    { &ei_iax_invalid_len, { \"iax2.invalid_len\", PI_PROTOCOL, PI_WARN, \"Invalid length\", EXPFILL }}"
            ],
            "added_lines": [
                "    { &ei_iax_invalid_len, { \"iax2.invalid_len\", PI_PROTOCOL, PI_WARN, \"Invalid length\", EXPFILL }},",
                "    { &ei_iax_invalid_ts, { \"iax2.invalid_ts\", PI_PROTOCOL, PI_WARN, \"Invalid timestamp\", EXPFILL }}"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-6470",
        "func_name": "wireshark/iax2_add_ts_fields",
        "description": "In Wireshark 2.2.0 to 2.2.4 and 2.0.0 to 2.0.10, there is an IAX2 infinite loop, triggered by packet injection or a malformed capture file. This was addressed in epan/dissectors/packet-iax2.c by constraining packet lateness.",
        "git_url": "https://github.com/wireshark/wireshark/commit/0b89174ef4c531a1917437fff586fe525ee7bf2d",
        "commit_title": "IAX2: Add a timestamp check.",
        "commit_text": " Don't try to process timestamps that are more than 60 seconds apart. Avoids the infinite loop in bug 13432.  Bug: 13432 (cherry picked from commit ca68749606bb78a333a0961dbf9fa74c65fa72aa) (cherry picked from commit 9f297d6d51d7daab0c5a6a8d2800e07c29539c2e)",
        "func_before": "static void iax2_add_ts_fields(packet_info *pinfo, proto_tree *iax2_tree, iax_packet_data *iax_packet, guint16 shortts)\n{\n  guint32     longts =shortts;\n  nstime_t    ts;\n  proto_item *item;\n\n  if (iax_packet->call_data == NULL) {\n    /* no call info for this frame; perhaps we missed the NEW packet */\n    return;\n  }\n\n  if (iax_packet->abstime.secs == -1) {\n    time_t start_secs = iax_packet->call_data->start_time.secs;\n    time_t abs_secs = start_secs + longts/1000;\n\n    /* deal with short timestamps by assuming that packets are never more than\n     * 16 seconds late */\n    while(abs_secs < pinfo->fd->abs_ts.secs - 16) {\n      longts += 32768;\n      abs_secs = start_secs + longts/1000;\n    }\n\n    iax_packet->abstime.secs=abs_secs;\n    iax_packet->abstime.nsecs=iax_packet->call_data->start_time.nsecs + (longts % 1000) * 1000000;\n    if (iax_packet->abstime.nsecs >= 1000000000) {\n      iax_packet->abstime.nsecs -= 1000000000;\n      iax_packet->abstime.secs ++;\n    }\n  }\n  iax2_info->timestamp = longts;\n\n  if (iax2_tree) {\n    item = proto_tree_add_time(iax2_tree, hf_iax2_absts, NULL, 0, 0, &iax_packet->abstime);\n    PROTO_ITEM_SET_GENERATED(item);\n\n    ts  = pinfo->fd->abs_ts;\n    nstime_delta(&ts, &ts, &iax_packet->abstime);\n\n    item = proto_tree_add_time(iax2_tree, hf_iax2_lateness, NULL, 0, 0, &ts);\n    PROTO_ITEM_SET_GENERATED(item);\n  }\n}",
        "func": "static void iax2_add_ts_fields(packet_info *pinfo, proto_tree *iax2_tree, tvbuff_t *tvb, iax_packet_data *iax_packet, guint16 shortts)\n{\n  guint       longts =shortts;\n  nstime_t    ts;\n  proto_item *item;\n\n  if (iax_packet->call_data == NULL) {\n    /* no call info for this frame; perhaps we missed the NEW packet */\n    return;\n  }\n\n  if (iax_packet->abstime.secs == -1) {\n    time_t start_secs = iax_packet->call_data->start_time.secs;\n    time_t abs_secs = start_secs + longts/1000;\n\n    if (pinfo->abs_ts.secs - abs_secs > MAX_SECS_DIFF) {\n      proto_tree_add_expert(iax2_tree, pinfo, &ei_iax_invalid_ts, tvb, 0, 0);\n    } else {\n      /* deal with short timestamps by assuming that packets are never more than\n       * 16 seconds late */\n      while(abs_secs < pinfo->fd->abs_ts.secs - 16) {\n        longts += 32768;\n        abs_secs = start_secs + longts/1000;\n      }\n    }\n\n    iax_packet->abstime.secs=abs_secs;\n    iax_packet->abstime.nsecs=iax_packet->call_data->start_time.nsecs + (longts % 1000) * 1000000;\n    if (iax_packet->abstime.nsecs >= 1000000000) {\n      iax_packet->abstime.nsecs -= 1000000000;\n      iax_packet->abstime.secs ++;\n    }\n  }\n  iax2_info->timestamp = longts;\n\n  if (iax2_tree) {\n    item = proto_tree_add_time(iax2_tree, hf_iax2_absts, tvb, 0, 0, &iax_packet->abstime);\n    PROTO_ITEM_SET_GENERATED(item);\n\n    ts  = pinfo->fd->abs_ts;\n    nstime_delta(&ts, &ts, &iax_packet->abstime);\n\n    item = proto_tree_add_time(iax2_tree, hf_iax2_lateness, tvb, 0, 0, &ts);\n    PROTO_ITEM_SET_GENERATED(item);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n-static void iax2_add_ts_fields(packet_info *pinfo, proto_tree *iax2_tree, iax_packet_data *iax_packet, guint16 shortts)\n+static void iax2_add_ts_fields(packet_info *pinfo, proto_tree *iax2_tree, tvbuff_t *tvb, iax_packet_data *iax_packet, guint16 shortts)\n {\n-  guint32     longts =shortts;\n+  guint       longts =shortts;\n   nstime_t    ts;\n   proto_item *item;\n \n@@ -13,11 +13,15 @@\n     time_t start_secs = iax_packet->call_data->start_time.secs;\n     time_t abs_secs = start_secs + longts/1000;\n \n-    /* deal with short timestamps by assuming that packets are never more than\n-     * 16 seconds late */\n-    while(abs_secs < pinfo->fd->abs_ts.secs - 16) {\n-      longts += 32768;\n-      abs_secs = start_secs + longts/1000;\n+    if (pinfo->abs_ts.secs - abs_secs > MAX_SECS_DIFF) {\n+      proto_tree_add_expert(iax2_tree, pinfo, &ei_iax_invalid_ts, tvb, 0, 0);\n+    } else {\n+      /* deal with short timestamps by assuming that packets are never more than\n+       * 16 seconds late */\n+      while(abs_secs < pinfo->fd->abs_ts.secs - 16) {\n+        longts += 32768;\n+        abs_secs = start_secs + longts/1000;\n+      }\n     }\n \n     iax_packet->abstime.secs=abs_secs;\n@@ -30,13 +34,13 @@\n   iax2_info->timestamp = longts;\n \n   if (iax2_tree) {\n-    item = proto_tree_add_time(iax2_tree, hf_iax2_absts, NULL, 0, 0, &iax_packet->abstime);\n+    item = proto_tree_add_time(iax2_tree, hf_iax2_absts, tvb, 0, 0, &iax_packet->abstime);\n     PROTO_ITEM_SET_GENERATED(item);\n \n     ts  = pinfo->fd->abs_ts;\n     nstime_delta(&ts, &ts, &iax_packet->abstime);\n \n-    item = proto_tree_add_time(iax2_tree, hf_iax2_lateness, NULL, 0, 0, &ts);\n+    item = proto_tree_add_time(iax2_tree, hf_iax2_lateness, tvb, 0, 0, &ts);\n     PROTO_ITEM_SET_GENERATED(item);\n   }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static void iax2_add_ts_fields(packet_info *pinfo, proto_tree *iax2_tree, iax_packet_data *iax_packet, guint16 shortts)",
                "  guint32     longts =shortts;",
                "    /* deal with short timestamps by assuming that packets are never more than",
                "     * 16 seconds late */",
                "    while(abs_secs < pinfo->fd->abs_ts.secs - 16) {",
                "      longts += 32768;",
                "      abs_secs = start_secs + longts/1000;",
                "    item = proto_tree_add_time(iax2_tree, hf_iax2_absts, NULL, 0, 0, &iax_packet->abstime);",
                "    item = proto_tree_add_time(iax2_tree, hf_iax2_lateness, NULL, 0, 0, &ts);"
            ],
            "added_lines": [
                "static void iax2_add_ts_fields(packet_info *pinfo, proto_tree *iax2_tree, tvbuff_t *tvb, iax_packet_data *iax_packet, guint16 shortts)",
                "  guint       longts =shortts;",
                "    if (pinfo->abs_ts.secs - abs_secs > MAX_SECS_DIFF) {",
                "      proto_tree_add_expert(iax2_tree, pinfo, &ei_iax_invalid_ts, tvb, 0, 0);",
                "    } else {",
                "      /* deal with short timestamps by assuming that packets are never more than",
                "       * 16 seconds late */",
                "      while(abs_secs < pinfo->fd->abs_ts.secs - 16) {",
                "        longts += 32768;",
                "        abs_secs = start_secs + longts/1000;",
                "      }",
                "    item = proto_tree_add_time(iax2_tree, hf_iax2_absts, tvb, 0, 0, &iax_packet->abstime);",
                "    item = proto_tree_add_time(iax2_tree, hf_iax2_lateness, tvb, 0, 0, &ts);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-6470",
        "func_name": "wireshark/dissect_minipacket",
        "description": "In Wireshark 2.2.0 to 2.2.4 and 2.0.0 to 2.0.10, there is an IAX2 infinite loop, triggered by packet injection or a malformed capture file. This was addressed in epan/dissectors/packet-iax2.c by constraining packet lateness.",
        "git_url": "https://github.com/wireshark/wireshark/commit/0b89174ef4c531a1917437fff586fe525ee7bf2d",
        "commit_title": "IAX2: Add a timestamp check.",
        "commit_text": " Don't try to process timestamps that are more than 60 seconds apart. Avoids the infinite loop in bug 13432.  Bug: 13432 (cherry picked from commit ca68749606bb78a333a0961dbf9fa74c65fa72aa) (cherry picked from commit 9f297d6d51d7daab0c5a6a8d2800e07c29539c2e)",
        "func_before": "static guint32 dissect_minipacket(tvbuff_t *tvb, guint32 offset, guint16 scallno,\n                                  packet_info *pinfo, proto_tree *iax2_tree,\n                                  proto_tree *main_tree)\n{\n  guint32          ts;\n  iax_packet_data *iax_packet;\n  proto_item      *item;\n\n  ts = tvb_get_ntohs(tvb, offset);\n\n  iax_packet = iax2_get_packet_data_for_minipacket(pinfo, scallno, FALSE);\n\n  if (iax2_tree) {\n    if (iax_packet->call_data) {\n      item = proto_tree_add_uint(iax2_tree, hf_iax2_callno, tvb, 0, 4,\n                                 iax_packet->call_data->forward_circuit_ids[0]);\n      PROTO_ITEM_SET_GENERATED(item);\n    }\n\n    proto_tree_add_uint(iax2_tree, hf_iax2_minits, tvb, offset, 2, ts);\n    iax2_add_ts_fields(pinfo, iax2_tree, iax_packet, (guint16)ts);\n  } else {\n    iax2_add_ts_fields(pinfo, iax2_tree, iax_packet, (guint16)ts);\n  }\n\n\n  offset += 2;\n\n  col_add_fstr(pinfo->cinfo, COL_INFO,\n                    \"Mini packet, source call# %d, timestamp %ums\",\n                    scallno, ts);\n\n\n  /* XXX fix the timestamp logic */\n  dissect_payload(tvb, offset, pinfo, iax2_tree, main_tree, ts, FALSE, iax_packet);\n\n\n  /* next time we come to parse this packet, don't propagate the codec into the\n   * call_data */\n  iax_packet->first_time = FALSE;\n\n  return offset;\n}",
        "func": "static guint32 dissect_minipacket(tvbuff_t *tvb, guint32 offset, guint16 scallno,\n                                  packet_info *pinfo, proto_tree *iax2_tree,\n                                  proto_tree *main_tree)\n{\n  guint32          ts;\n  iax_packet_data *iax_packet;\n  proto_item      *item;\n\n  ts = tvb_get_ntohs(tvb, offset);\n\n  iax_packet = iax2_get_packet_data_for_minipacket(pinfo, scallno, FALSE);\n\n  if (iax2_tree) {\n    if (iax_packet->call_data) {\n      item = proto_tree_add_uint(iax2_tree, hf_iax2_callno, tvb, 0, 4,\n                                 iax_packet->call_data->forward_circuit_ids[0]);\n      PROTO_ITEM_SET_GENERATED(item);\n    }\n\n    proto_tree_add_uint(iax2_tree, hf_iax2_minits, tvb, offset, 2, ts);\n    iax2_add_ts_fields(pinfo, iax2_tree, tvb, iax_packet, (guint16)ts);\n  } else {\n    iax2_add_ts_fields(pinfo, iax2_tree, tvb, iax_packet, (guint16)ts);\n  }\n\n\n  offset += 2;\n\n  col_add_fstr(pinfo->cinfo, COL_INFO,\n                    \"Mini packet, source call# %d, timestamp %ums\",\n                    scallno, ts);\n\n\n  /* XXX fix the timestamp logic */\n  dissect_payload(tvb, offset, pinfo, iax2_tree, main_tree, ts, FALSE, iax_packet);\n\n\n  /* next time we come to parse this packet, don't propagate the codec into the\n   * call_data */\n  iax_packet->first_time = FALSE;\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,9 +18,9 @@\n     }\n \n     proto_tree_add_uint(iax2_tree, hf_iax2_minits, tvb, offset, 2, ts);\n-    iax2_add_ts_fields(pinfo, iax2_tree, iax_packet, (guint16)ts);\n+    iax2_add_ts_fields(pinfo, iax2_tree, tvb, iax_packet, (guint16)ts);\n   } else {\n-    iax2_add_ts_fields(pinfo, iax2_tree, iax_packet, (guint16)ts);\n+    iax2_add_ts_fields(pinfo, iax2_tree, tvb, iax_packet, (guint16)ts);\n   }\n \n ",
        "diff_line_info": {
            "deleted_lines": [
                "    iax2_add_ts_fields(pinfo, iax2_tree, iax_packet, (guint16)ts);",
                "    iax2_add_ts_fields(pinfo, iax2_tree, iax_packet, (guint16)ts);"
            ],
            "added_lines": [
                "    iax2_add_ts_fields(pinfo, iax2_tree, tvb, iax_packet, (guint16)ts);",
                "    iax2_add_ts_fields(pinfo, iax2_tree, tvb, iax_packet, (guint16)ts);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-6470",
        "func_name": "wireshark/dissect_minivideopacket",
        "description": "In Wireshark 2.2.0 to 2.2.4 and 2.0.0 to 2.0.10, there is an IAX2 infinite loop, triggered by packet injection or a malformed capture file. This was addressed in epan/dissectors/packet-iax2.c by constraining packet lateness.",
        "git_url": "https://github.com/wireshark/wireshark/commit/0b89174ef4c531a1917437fff586fe525ee7bf2d",
        "commit_title": "IAX2: Add a timestamp check.",
        "commit_text": " Don't try to process timestamps that are more than 60 seconds apart. Avoids the infinite loop in bug 13432.  Bug: 13432 (cherry picked from commit ca68749606bb78a333a0961dbf9fa74c65fa72aa) (cherry picked from commit 9f297d6d51d7daab0c5a6a8d2800e07c29539c2e)",
        "func_before": "static guint32 dissect_minivideopacket(tvbuff_t *tvb, guint32 offset,\n                                       guint16 scallno, packet_info *pinfo,\n                                       proto_tree *iax2_tree, proto_tree *main_tree)\n{\n  guint32          ts;\n  iax_packet_data *iax_packet;\n  gboolean         rtp_marker;\n  proto_item      *item;\n\n  ts = tvb_get_ntohs(tvb, offset);\n\n  /* bit 15 of the ts is used to represent the rtp 'marker' bit */\n  rtp_marker = ts & 0x8000 ? TRUE:FALSE;\n  ts &= ~0x8000;\n\n  iax_packet = iax2_get_packet_data_for_minipacket(pinfo, scallno, TRUE);\n\n  if (iax2_tree) {\n    if (iax_packet->call_data) {\n      item =\n        proto_tree_add_uint(iax2_tree, hf_iax2_callno, tvb, 0, 4,\n                            iax_packet->call_data->forward_circuit_ids[0]);\n      PROTO_ITEM_SET_GENERATED(item);\n    }\n\n    proto_tree_add_item(iax2_tree, hf_iax2_minividts, tvb, offset, 2, ENC_BIG_ENDIAN);\n    iax2_add_ts_fields(pinfo, iax2_tree, iax_packet, (guint16)ts);\n    proto_tree_add_item(iax2_tree, hf_iax2_minividmarker, tvb, offset, 2, ENC_BIG_ENDIAN);\n  } else {\n    iax2_add_ts_fields(pinfo, iax2_tree, iax_packet, (guint16)ts);\n  }\n\n  offset += 2;\n\n  col_add_fstr(pinfo->cinfo, COL_INFO,\n                   \"Mini video packet, source call# %d, timestamp %ums%s\",\n                   scallno, ts, rtp_marker?\", Mark\":\"\");\n\n\n  dissect_payload(tvb, offset, pinfo, iax2_tree, main_tree, ts, TRUE, iax_packet);\n\n  /* next time we come to parse this packet, don't propagate the codec into the\n   * call_data */\n  iax_packet->first_time = FALSE;\n\n  return offset;\n}",
        "func": "static guint32 dissect_minivideopacket(tvbuff_t *tvb, guint32 offset,\n                                       guint16 scallno, packet_info *pinfo,\n                                       proto_tree *iax2_tree, proto_tree *main_tree)\n{\n  guint32          ts;\n  iax_packet_data *iax_packet;\n  gboolean         rtp_marker;\n  proto_item      *item;\n\n  ts = tvb_get_ntohs(tvb, offset);\n\n  /* bit 15 of the ts is used to represent the rtp 'marker' bit */\n  rtp_marker = ts & 0x8000 ? TRUE:FALSE;\n  ts &= ~0x8000;\n\n  iax_packet = iax2_get_packet_data_for_minipacket(pinfo, scallno, TRUE);\n\n  if (iax2_tree) {\n    if (iax_packet->call_data) {\n      item =\n        proto_tree_add_uint(iax2_tree, hf_iax2_callno, tvb, 0, 4,\n                            iax_packet->call_data->forward_circuit_ids[0]);\n      PROTO_ITEM_SET_GENERATED(item);\n    }\n\n    proto_tree_add_item(iax2_tree, hf_iax2_minividts, tvb, offset, 2, ENC_BIG_ENDIAN);\n    iax2_add_ts_fields(pinfo, iax2_tree, tvb, iax_packet, (guint16)ts);\n    proto_tree_add_item(iax2_tree, hf_iax2_minividmarker, tvb, offset, 2, ENC_BIG_ENDIAN);\n  } else {\n    iax2_add_ts_fields(pinfo, iax2_tree, tvb, iax_packet, (guint16)ts);\n  }\n\n  offset += 2;\n\n  col_add_fstr(pinfo->cinfo, COL_INFO,\n                   \"Mini video packet, source call# %d, timestamp %ums%s\",\n                   scallno, ts, rtp_marker?\", Mark\":\"\");\n\n\n  dissect_payload(tvb, offset, pinfo, iax2_tree, main_tree, ts, TRUE, iax_packet);\n\n  /* next time we come to parse this packet, don't propagate the codec into the\n   * call_data */\n  iax_packet->first_time = FALSE;\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,10 +24,10 @@\n     }\n \n     proto_tree_add_item(iax2_tree, hf_iax2_minividts, tvb, offset, 2, ENC_BIG_ENDIAN);\n-    iax2_add_ts_fields(pinfo, iax2_tree, iax_packet, (guint16)ts);\n+    iax2_add_ts_fields(pinfo, iax2_tree, tvb, iax_packet, (guint16)ts);\n     proto_tree_add_item(iax2_tree, hf_iax2_minividmarker, tvb, offset, 2, ENC_BIG_ENDIAN);\n   } else {\n-    iax2_add_ts_fields(pinfo, iax2_tree, iax_packet, (guint16)ts);\n+    iax2_add_ts_fields(pinfo, iax2_tree, tvb, iax_packet, (guint16)ts);\n   }\n \n   offset += 2;",
        "diff_line_info": {
            "deleted_lines": [
                "    iax2_add_ts_fields(pinfo, iax2_tree, iax_packet, (guint16)ts);",
                "    iax2_add_ts_fields(pinfo, iax2_tree, iax_packet, (guint16)ts);"
            ],
            "added_lines": [
                "    iax2_add_ts_fields(pinfo, iax2_tree, tvb, iax_packet, (guint16)ts);",
                "    iax2_add_ts_fields(pinfo, iax2_tree, tvb, iax_packet, (guint16)ts);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-6472",
        "func_name": "wireshark/dissect_rtmpt_common",
        "description": "In Wireshark 2.2.0 to 2.2.4 and 2.0.0 to 2.0.10, there is an RTMPT dissector infinite loop, triggered by packet injection or a malformed capture file. This was addressed in epan/dissectors/packet-rtmpt.c by properly incrementing a certain sequence value.",
        "git_url": "https://github.com/wireshark/wireshark/commit/2b3a0909beff8963b390034c594e0b6be6a4e531",
        "commit_title": "rtmpt: Ensure sequence count is incremented for stored fragments",
        "commit_text": " Bug: 13347 (cherry picked from commit ee185445f410b6bc54831ea0923af08cbcd75d00)",
        "func_before": "static void\ndissect_rtmpt_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, rtmpt_conv_t *rconv, int cdir, guint32 seq, guint32 lastackseq)\n{\n        int     offset = 0;\n        int     remain;\n        int     want;\n\n        guint8  header_type;\n        int     basic_hlen;\n        int     message_hlen;\n\n        guint32 id;\n        guint32 ts     = 0;\n        guint32 tsd    = 0;\n        int     body_len;\n        guint8  cmd;\n        guint32 src;\n        int     chunk_size;\n\n        rtmpt_frag_t   *tf;\n        rtmpt_id_t     *ti;\n        rtmpt_packet_t *tp;\n        tvbuff_t       *pktbuf;\n\n        remain = tvb_reported_length(tvb);\n        if (!remain)\n                return;\n\n        RTMPT_DEBUG(\"Segment: cdir=%d seq=%d-%d\\n\", cdir, seq, seq+remain-1);\n\n        if (pinfo->fd->flags.visited) {\n                /* Already done the work, so just dump the existing state */\n                wmem_stack_t *packets;\n\n                /* List all RTMP packets terminating in this TCP segment, from end to beginning */\n\n                packets = wmem_stack_new(wmem_packet_scope());\n                wmem_stack_push(packets, 0);\n\n                tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(rconv->packets[cdir], seq+remain-1);\n                while (tp && tp->lastseq >= seq) {\n                        wmem_stack_push(packets, tp);\n                        tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(rconv->packets[cdir], tp->lastseq-1);\n                }\n\n                /* Dissect the generated list in reverse order (beginning to end) */\n\n                while ((tp=(rtmpt_packet_t *)wmem_stack_pop(packets)) != NULL) {\n                        if (tp->resident) {\n                                pktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have);\n                                add_new_data_source(pinfo, pktbuf, \"Unchunked RTMP\");\n                        } else {\n                                pktbuf = tvb_new_subset_length(tvb, tp->data.offset, tp->have);\n                        }\n                        dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp);\n                }\n\n                return;\n        }\n\n        while (remain>0) {\n                tf = NULL;\n                ti = NULL;\n                tp = NULL;\n\n                /* Check for outstanding fragmented headers/chunks first */\n\n                if (offset == 0) {\n                        tf = (rtmpt_frag_t *)wmem_tree_lookup32_le(rconv->frags[cdir], seq+offset-1);\n\n                        if (tf) {\n                                /* May need to reassemble cross-TCP-segment fragments */\n                                RTMPT_DEBUG(\"  tf seq=%d lseq=%d h=%d l=%d\\n\", tf->seq, tf->lastseq, tf->have, tf->len);\n                                if (tf->have >= tf->len || seq+offset < tf->seq || seq+offset > tf->lastseq+tf->len-tf->have) {\n                                        tf = NULL;\n                                } else if (!tf->ishdr) {\n                                        ti = (rtmpt_id_t *)wmem_tree_lookup32(rconv->ids[cdir], tf->saved.id);\n                                        if (ti) {\n                                                tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(ti->packets, seq+offset-1);\n                                        }\n                                        if (tp && tp->chunkwant) {\n                                                goto unchunk;\n                                        }\n                                        tf = NULL;\n                                        ti = NULL;\n                                        tp = NULL;\n                                }\n\n                                if (tf) {\n                                        /* The preceding segment contained an incomplete chunk header */\n\n                                        want = tf->len - tf->have;\n                                        if (remain<want)\n                                                want = remain;\n\n                                        tvb_memcpy(tvb, tf->saved.d+tf->have, offset, want);\n\n                                        id = tf->saved.d[0];\n                                        header_type = (id>>6) & 3;\n                                        basic_hlen = rtmpt_basic_header_length(id);\n\n                                        if ((header_type < 3) && (tf->have < (basic_hlen+3)) && (tf->have+want >= (basic_hlen+3))) {\n                                                if (pntoh24(tf->saved.d+basic_hlen) == 0xffffff) {\n                                                        tf->len += 4;\n                                                }\n                                        }\n\n                                        tf->have += want;\n                                        tf->lastseq = seq+want-1;\n                                        remain -= want;\n                                        offset += want;\n\n                                        if (tf->have < tf->len) {\n                                                return;\n                                        }\n                                }\n                        }\n                }\n\n                if (!tf) {\n                        /* No preceeding data, get header data starting at current position */\n                        id = tvb_get_guint8(tvb, offset);\n\n                        if (id == RTMPT_MAGIC && seq+offset == RTMPT_HANDSHAKE_OFFSET_1) {\n                                header_type = 4;\n                                basic_hlen = 1;\n                                message_hlen = 0;\n                                id = lastackseq == 1 ? RTMPT_TYPE_HANDSHAKE_1 : RTMPT_TYPE_HANDSHAKE_2;\n                        } else if (seq+offset == RTMPT_HANDSHAKE_OFFSET_2) {\n                                header_type = 4;\n                                basic_hlen = 0;\n                                message_hlen = 0;\n                                id = RTMPT_TYPE_HANDSHAKE_3;\n                        } else {\n                                header_type = (id>>6) & 3;\n                                basic_hlen = rtmpt_basic_header_length(id);\n                                message_hlen = rtmpt_message_header_length(id);\n\n                                if ((header_type < 3) && (remain >= (basic_hlen+3))) {\n                                        if (tvb_get_ntoh24(tvb, offset+basic_hlen) == 0xffffff) {\n                                                message_hlen += 4;\n                                        }\n                                }\n\n                                if (remain < (basic_hlen+message_hlen)) {\n                                        /* Ran out of packet mid-header, save and try again next time */\n                                        tf = wmem_new(wmem_file_scope(), rtmpt_frag_t);\n                                        tf->ishdr = 1;\n                                        tf->seq = seq + offset;\n                                        tf->lastseq = tf->seq + remain - 1;\n                                        tf->len = basic_hlen + message_hlen;\n                                        tvb_memcpy(tvb, tf->saved.d, offset, remain);\n                                        tf->have = remain;\n                                        wmem_tree_insert32(rconv->frags[cdir], seq+offset, tf);\n                                        return;\n                                }\n\n                                id = id & 0x3f;\n                                if (id == 0)\n                                        id = tvb_get_guint8(tvb, offset+1) + 64;\n                                else if (id == 1)\n                                        id = tvb_get_letohs(tvb, offset+1) + 64;\n                        }\n\n                } else {\n                        /* Use reassembled header data */\n                        id = tf->saved.d[0];\n                        header_type = (id>>6) & 3;\n                        basic_hlen = rtmpt_basic_header_length(id);\n                        message_hlen = tf->len - basic_hlen;\n\n                        id = id & 0x3f;\n                        if (id == 0)\n                                id = tf->saved.d[1] + 64;\n                        else if (id == 1)\n                                id = pletoh16(tf->saved.d+1) + 64;\n                }\n\n                /* Calculate header values, defaulting from previous packets with same id */\n\n                if (id <= RTMPT_ID_MAX)\n                        ti = (rtmpt_id_t *)wmem_tree_lookup32(rconv->ids[cdir], id);\n                if (ti)\n                        tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(ti->packets, seq+offset-1);\n\n                if (header_type == 0)\n                        src = tf ? pntoh32(tf->saved.d+basic_hlen+7) : tvb_get_ntohl(tvb, offset+basic_hlen+7);\n                else if (ti)\n                        src = ti->src;\n                else src = 0;\n\n                if (header_type < 2)\n                        cmd = tf ? tf->saved.d[basic_hlen+6] : tvb_get_guint8(tvb, offset+basic_hlen+6);\n                else if (ti)\n                        cmd = ti->cmd;\n                else\n                        cmd = 0;\n\n                /* Calculate chunk_size now as a last-resort default payload length */\n                if (id > RTMPT_ID_MAX) {\n                        if (id == RTMPT_TYPE_HANDSHAKE_1)\n                                chunk_size = body_len = 1536;\n                        else if (id == RTMPT_TYPE_HANDSHAKE_2)\n                                chunk_size = body_len = 3072;\n                        else /* if (id == RTMPT_TYPE_HANDSHAKE_3) */\n                                chunk_size = body_len = 1536;\n                } else {\n                        chunk_size = GPOINTER_TO_INT(wmem_tree_lookup32_le(rconv->chunksize[cdir], seq+offset-1));\n                        if (!chunk_size)\n                                chunk_size = RTMPT_DEFAULT_CHUNK_SIZE;\n\n                        if (header_type < 2)\n                                body_len = tf ? pntoh24(tf->saved.d+basic_hlen+3) : tvb_get_ntoh24(tvb, offset+basic_hlen+3);\n                        else if (ti)\n                                body_len = ti->len;\n                        else\n                                body_len = chunk_size;\n\n                        if (body_len > (gint)rtmpt_max_packet_size) {\n                                return;\n                        }\n                }\n\n                if (!ti || !tp || header_type<3 || tp->have == tp->want || tp->chunkhave != tp->chunkwant) {\n                        /* Start a new packet if:\n                         *   no previous packet with same id\n                         *   not a short 1-byte header\n                         *   previous packet with same id was complete\n                         *   previous incomplete chunk not handled by fragment handler\n                         */\n                        RTMPT_DEBUG(\"New packet cdir=%d seq=%d ti=%p tp=%p header_type=%d header_len=%d id=%d tph=%d tpw=%d len=%d cs=%d\\n\",\n                                    cdir, seq+offset,\n                                    ti, tp, header_type, basic_hlen+message_hlen, id, tp?tp->have:0, tp?tp->want:0, body_len, chunk_size);\n\n                        if (!ti) {\n                                ti = wmem_new(wmem_file_scope(), rtmpt_id_t);\n                                ti->packets = wmem_tree_new(wmem_file_scope());\n                                ti->ts  = 0;\n                                ti->tsd = 0;\n                                wmem_tree_insert32(rconv->ids[cdir], id, ti);\n                        }\n\n                        if (header_type == 0) {\n                                ts = tf ? pntoh24(tf->saved.d+basic_hlen) : tvb_get_ntoh24(tvb, offset+basic_hlen);\n                                if (ts == 0xffffff) {\n                                        ts = tf ? pntoh32(tf->saved.d+basic_hlen+11) : tvb_get_ntohl(tvb, offset+basic_hlen+11);\n                                }\n                                tsd = ts - ti->ts;\n                        } else if (header_type < 3) {\n                                tsd = tf ? pntoh24(tf->saved.d+basic_hlen) : tvb_get_ntoh24(tvb, offset+basic_hlen);\n                                if (tsd == 0xffffff) {\n                                        ts  = tf ? pntoh32(tf->saved.d+basic_hlen+message_hlen-4) : tvb_get_ntohl(tvb, offset+basic_hlen+message_hlen-4);\n                                        tsd = ti->tsd; /* questionable */\n                                } else {\n                                        ts  = ti->ts + tsd;\n                                }\n                        } else {\n                                ts  = ti->ts + ti->tsd;\n                                tsd = ti->tsd;\n                        }\n\n                        /* create a new packet structure */\n                        tp             = wmem_new(wmem_file_scope(), rtmpt_packet_t);\n                        tp->seq        = tp->lastseq = tf ? tf->seq : seq+offset;\n                        tp->have       = 0;\n                        tp->want       = basic_hlen + message_hlen + body_len;\n                        tp->chunkwant  = 0;\n                        tp->chunkhave  = 0;\n                        tp->bhlen      = basic_hlen;\n                        tp->mhlen      = message_hlen;\n                        tp->fmt        = header_type;\n                        tp->id         = id;\n                        tp->ts         = ts;\n                        tp->len        = body_len;\n                        if (id > RTMPT_ID_MAX)\n                                tp->cmd = id;\n                        else\n                                tp->cmd = cmd & 0x7f;\n                        tp->src        = src;\n                        tp->txid       = 0;\n                        tp->isresponse = FALSE;\n                        tp->otherframe = 0;\n\n                        /* Save the header information for future defaulting needs */\n                        ti->ts  = ts;\n                        ti->tsd = tsd;\n                        ti->len = body_len;\n                        ti->cmd = cmd;\n                        ti->src = src;\n\n                        /* store against the id only until unchunking is complete */\n                        wmem_tree_insert32(ti->packets, tp->seq, tp);\n\n                        if (!tf && body_len <= chunk_size && tp->want <= remain) {\n                                /* The easy case - a whole packet contiguous and fully within this segment */\n                                tp->resident    = FALSE;\n                                tp->data.offset = offset;\n                                tp->lastseq     = seq+offset+tp->want-1;\n                                tp->have        = tp->want;\n\n                                wmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp);\n\n                                pktbuf = tvb_new_subset_length(tvb, tp->data.offset, tp->have);\n                                dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp);\n\n                                offset += tp->want;\n                                remain -= tp->want;\n                                continue;\n\n                        } else {\n                                /* Some more reassembly required */\n                                tp->resident = TRUE;\n                                tp->data.p = (guint8 *)wmem_alloc(wmem_file_scope(), tp->bhlen+tp->mhlen+tp->len);\n\n                                if (tf && tf->ishdr) {\n                                        memcpy(tp->data.p, tf->saved.d, tf->len);\n                                } else {\n                                        tvb_memcpy(tvb, tp->data.p, offset, basic_hlen+message_hlen);\n                                        offset += basic_hlen + message_hlen;\n                                        remain -= basic_hlen + message_hlen;\n                                }\n\n                                tp->lastseq = seq+offset-1;\n                                tp->have = basic_hlen + message_hlen;\n\n                                if (tp->have == tp->want) {\n                                        wmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp);\n\n                                        pktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have);\n                                        add_new_data_source(pinfo, pktbuf, \"Unchunked RTMP\");\n                                        dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp);\n                                        continue;\n                                }\n\n                                tp->chunkwant = chunk_size;\n                                if (tp->chunkwant > tp->want-tp->have)\n                                        tp->chunkwant = tp->want - tp->have;\n                        }\n                } else {\n                        RTMPT_DEBUG(\"Old packet cdir=%d seq=%d ti=%p tp=%p header_len=%d id=%d tph=%d tpw=%d len=%d cs=%d\\n\",\n                                    cdir, seq+offset,\n                                    ti, tp, basic_hlen+message_hlen, id, tp?tp->have:0, tp?tp->want:0, body_len, chunk_size);\n\n                        tp->chunkwant = chunk_size;\n                        if (tp->chunkwant > tp->want-tp->have)\n                                tp->chunkwant = tp->want - tp->have;\n\n                        offset += basic_hlen + message_hlen;\n                        remain -= basic_hlen + message_hlen;\n                }\n\n                tf = NULL;\n\n                /* Last case to deal with is unchunking the packet body */\n        unchunk:\n                want = tp->chunkwant - tp->chunkhave;\n                if (want > remain)\n                        want = remain;\n                RTMPT_DEBUG(\"  cw=%d ch=%d r=%d w=%d\\n\", tp->chunkwant, tp->chunkhave, remain, want);\n\n                tvb_memcpy(tvb, tp->data.p+tp->have, offset, want);\n\n                if (tf) {\n                        tf->have += want;\n                        tf->lastseq = seq+offset+want-1;\n                }\n                tp->lastseq = seq+offset+want-1;\n                tp->have += want;\n                tp->chunkhave += want;\n\n                offset += want;\n                remain -= want;\n\n                if (tp->chunkhave == tp->chunkwant) {\n                        /* Chunk is complete - wait for next header */\n                        tp->chunkhave = 0;\n                        tp->chunkwant = 0;\n                }\n\n                if (tp->have == tp->want) {\n                        /* Whole packet is complete */\n                        wmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp);\n\n                        pktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have);\n                        add_new_data_source(pinfo, pktbuf, \"Unchunked RTMP\");\n                        dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp);\n                } else if (tp->chunkhave < tp->chunkwant) {\n                        /* Chunk is split across segment boundary */\n                        rtmpt_frag_t *tf2 = wmem_new(wmem_file_scope(), rtmpt_frag_t);\n                        tf2->ishdr    = 0;\n                        tf2->seq      = seq + offset - want;\n                        tf2->lastseq  = tf2->seq + remain - 1 + want;\n                        tf2->have     = tp->chunkhave;\n                        tf2->len      = tp->chunkwant;\n                        tf2->saved.id = tp->id;\n                        RTMPT_DEBUG(\"  inserting tf @ %d\\n\", seq+offset-want-1);\n                        wmem_tree_insert32(rconv->frags[cdir], seq+offset-want-1, tf2);\n                }\n        }\n}",
        "func": "static void\ndissect_rtmpt_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, rtmpt_conv_t *rconv, int cdir, guint32 seq, guint32 lastackseq)\n{\n        int     offset = 0;\n        int     remain;\n        int     want;\n\n        guint8  header_type;\n        int     basic_hlen;\n        int     message_hlen;\n\n        guint32 id;\n        guint32 ts     = 0;\n        guint32 tsd    = 0;\n        int     body_len;\n        guint8  cmd;\n        guint32 src;\n        int     chunk_size;\n        guint32 save_seq = 0;\n\n        rtmpt_frag_t   *tf;\n        rtmpt_id_t     *ti;\n        rtmpt_packet_t *tp;\n        tvbuff_t       *pktbuf;\n\n        remain = tvb_reported_length(tvb);\n        if (!remain)\n                return;\n\n        RTMPT_DEBUG(\"Segment: cdir=%d seq=%d-%d\\n\", cdir, seq, seq+remain-1);\n\n        if (pinfo->fd->flags.visited) {\n                /* Already done the work, so just dump the existing state */\n                wmem_stack_t *packets;\n\n                /* List all RTMP packets terminating in this TCP segment, from end to beginning */\n\n                packets = wmem_stack_new(wmem_packet_scope());\n                wmem_stack_push(packets, 0);\n\n                tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(rconv->packets[cdir], seq+remain-1);\n                while (tp && tp->lastseq >= seq && tp->lastseq >= save_seq) {\n                        wmem_stack_push(packets, tp);\n                        save_seq = tp->lastseq+1; /* Ensure sequence is increasing */\n                        tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(rconv->packets[cdir], tp->lastseq-1);\n                }\n\n                /* Dissect the generated list in reverse order (beginning to end) */\n\n                while ((tp=(rtmpt_packet_t *)wmem_stack_pop(packets)) != NULL) {\n                        if (tp->resident) {\n                                pktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have);\n                                add_new_data_source(pinfo, pktbuf, \"Unchunked RTMP\");\n                        } else {\n                                pktbuf = tvb_new_subset_length(tvb, tp->data.offset, tp->have);\n                        }\n                        dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp);\n                }\n\n                return;\n        }\n\n        while (remain>0) {\n                tf = NULL;\n                ti = NULL;\n                tp = NULL;\n\n                /* Check for outstanding fragmented headers/chunks first */\n\n                if (offset == 0) {\n                        tf = (rtmpt_frag_t *)wmem_tree_lookup32_le(rconv->frags[cdir], seq+offset-1);\n\n                        if (tf) {\n                                /* May need to reassemble cross-TCP-segment fragments */\n                                RTMPT_DEBUG(\"  tf seq=%d lseq=%d h=%d l=%d\\n\", tf->seq, tf->lastseq, tf->have, tf->len);\n                                if (tf->have >= tf->len || seq+offset < tf->seq || seq+offset > tf->lastseq+tf->len-tf->have) {\n                                        tf = NULL;\n                                } else if (!tf->ishdr) {\n                                        ti = (rtmpt_id_t *)wmem_tree_lookup32(rconv->ids[cdir], tf->saved.id);\n                                        if (ti) {\n                                                tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(ti->packets, seq+offset-1);\n                                        }\n                                        if (tp && tp->chunkwant) {\n                                                goto unchunk;\n                                        }\n                                        tf = NULL;\n                                        ti = NULL;\n                                        tp = NULL;\n                                }\n\n                                if (tf) {\n                                        /* The preceding segment contained an incomplete chunk header */\n\n                                        want = tf->len - tf->have;\n                                        if (remain<want)\n                                                want = remain;\n\n                                        tvb_memcpy(tvb, tf->saved.d+tf->have, offset, want);\n\n                                        id = tf->saved.d[0];\n                                        header_type = (id>>6) & 3;\n                                        basic_hlen = rtmpt_basic_header_length(id);\n\n                                        if ((header_type < 3) && (tf->have < (basic_hlen+3)) && (tf->have+want >= (basic_hlen+3))) {\n                                                if (pntoh24(tf->saved.d+basic_hlen) == 0xffffff) {\n                                                        tf->len += 4;\n                                                }\n                                        }\n\n                                        tf->have += want;\n                                        tf->lastseq = seq+want-1;\n                                        remain -= want;\n                                        offset += want;\n\n                                        if (tf->have < tf->len) {\n                                                return;\n                                        }\n                                }\n                        }\n                }\n\n                if (!tf) {\n                        /* No preceeding data, get header data starting at current position */\n                        id = tvb_get_guint8(tvb, offset);\n\n                        if (id == RTMPT_MAGIC && seq+offset == RTMPT_HANDSHAKE_OFFSET_1) {\n                                header_type = 4;\n                                basic_hlen = 1;\n                                message_hlen = 0;\n                                id = lastackseq == 1 ? RTMPT_TYPE_HANDSHAKE_1 : RTMPT_TYPE_HANDSHAKE_2;\n                        } else if (seq+offset == RTMPT_HANDSHAKE_OFFSET_2) {\n                                header_type = 4;\n                                basic_hlen = 0;\n                                message_hlen = 0;\n                                id = RTMPT_TYPE_HANDSHAKE_3;\n                        } else {\n                                header_type = (id>>6) & 3;\n                                basic_hlen = rtmpt_basic_header_length(id);\n                                message_hlen = rtmpt_message_header_length(id);\n\n                                if ((header_type < 3) && (remain >= (basic_hlen+3))) {\n                                        if (tvb_get_ntoh24(tvb, offset+basic_hlen) == 0xffffff) {\n                                                message_hlen += 4;\n                                        }\n                                }\n\n                                if (remain < (basic_hlen+message_hlen)) {\n                                        /* Ran out of packet mid-header, save and try again next time */\n                                        tf = wmem_new(wmem_file_scope(), rtmpt_frag_t);\n                                        tf->ishdr = 1;\n                                        tf->seq = seq + offset;\n                                        tf->lastseq = tf->seq + remain - 1;\n                                        tf->len = basic_hlen + message_hlen;\n                                        tvb_memcpy(tvb, tf->saved.d, offset, remain);\n                                        tf->have = remain;\n                                        wmem_tree_insert32(rconv->frags[cdir], seq+offset, tf);\n                                        return;\n                                }\n\n                                id = id & 0x3f;\n                                if (id == 0)\n                                        id = tvb_get_guint8(tvb, offset+1) + 64;\n                                else if (id == 1)\n                                        id = tvb_get_letohs(tvb, offset+1) + 64;\n                        }\n\n                } else {\n                        /* Use reassembled header data */\n                        id = tf->saved.d[0];\n                        header_type = (id>>6) & 3;\n                        basic_hlen = rtmpt_basic_header_length(id);\n                        message_hlen = tf->len - basic_hlen;\n\n                        id = id & 0x3f;\n                        if (id == 0)\n                                id = tf->saved.d[1] + 64;\n                        else if (id == 1)\n                                id = pletoh16(tf->saved.d+1) + 64;\n                }\n\n                /* Calculate header values, defaulting from previous packets with same id */\n\n                if (id <= RTMPT_ID_MAX)\n                        ti = (rtmpt_id_t *)wmem_tree_lookup32(rconv->ids[cdir], id);\n                if (ti)\n                        tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(ti->packets, seq+offset-1);\n\n                if (header_type == 0)\n                        src = tf ? pntoh32(tf->saved.d+basic_hlen+7) : tvb_get_ntohl(tvb, offset+basic_hlen+7);\n                else if (ti)\n                        src = ti->src;\n                else src = 0;\n\n                if (header_type < 2)\n                        cmd = tf ? tf->saved.d[basic_hlen+6] : tvb_get_guint8(tvb, offset+basic_hlen+6);\n                else if (ti)\n                        cmd = ti->cmd;\n                else\n                        cmd = 0;\n\n                /* Calculate chunk_size now as a last-resort default payload length */\n                if (id > RTMPT_ID_MAX) {\n                        if (id == RTMPT_TYPE_HANDSHAKE_1)\n                                chunk_size = body_len = 1536;\n                        else if (id == RTMPT_TYPE_HANDSHAKE_2)\n                                chunk_size = body_len = 3072;\n                        else /* if (id == RTMPT_TYPE_HANDSHAKE_3) */\n                                chunk_size = body_len = 1536;\n                } else {\n                        chunk_size = GPOINTER_TO_INT(wmem_tree_lookup32_le(rconv->chunksize[cdir], seq+offset-1));\n                        if (!chunk_size)\n                                chunk_size = RTMPT_DEFAULT_CHUNK_SIZE;\n\n                        if (header_type < 2)\n                                body_len = tf ? pntoh24(tf->saved.d+basic_hlen+3) : tvb_get_ntoh24(tvb, offset+basic_hlen+3);\n                        else if (ti)\n                                body_len = ti->len;\n                        else\n                                body_len = chunk_size;\n\n                        if (body_len > (gint)rtmpt_max_packet_size) {\n                                return;\n                        }\n                }\n\n                if (!ti || !tp || header_type<3 || tp->have == tp->want || tp->chunkhave != tp->chunkwant) {\n                        /* Start a new packet if:\n                         *   no previous packet with same id\n                         *   not a short 1-byte header\n                         *   previous packet with same id was complete\n                         *   previous incomplete chunk not handled by fragment handler\n                         */\n                        RTMPT_DEBUG(\"New packet cdir=%d seq=%d ti=%p tp=%p header_type=%d header_len=%d id=%d tph=%d tpw=%d len=%d cs=%d\\n\",\n                                    cdir, seq+offset,\n                                    ti, tp, header_type, basic_hlen+message_hlen, id, tp?tp->have:0, tp?tp->want:0, body_len, chunk_size);\n\n                        if (!ti) {\n                                ti = wmem_new(wmem_file_scope(), rtmpt_id_t);\n                                ti->packets = wmem_tree_new(wmem_file_scope());\n                                ti->ts  = 0;\n                                ti->tsd = 0;\n                                wmem_tree_insert32(rconv->ids[cdir], id, ti);\n                        }\n\n                        if (header_type == 0) {\n                                ts = tf ? pntoh24(tf->saved.d+basic_hlen) : tvb_get_ntoh24(tvb, offset+basic_hlen);\n                                if (ts == 0xffffff) {\n                                        ts = tf ? pntoh32(tf->saved.d+basic_hlen+11) : tvb_get_ntohl(tvb, offset+basic_hlen+11);\n                                }\n                                tsd = ts - ti->ts;\n                        } else if (header_type < 3) {\n                                tsd = tf ? pntoh24(tf->saved.d+basic_hlen) : tvb_get_ntoh24(tvb, offset+basic_hlen);\n                                if (tsd == 0xffffff) {\n                                        ts  = tf ? pntoh32(tf->saved.d+basic_hlen+message_hlen-4) : tvb_get_ntohl(tvb, offset+basic_hlen+message_hlen-4);\n                                        tsd = ti->tsd; /* questionable */\n                                } else {\n                                        ts  = ti->ts + tsd;\n                                }\n                        } else {\n                                ts  = ti->ts + ti->tsd;\n                                tsd = ti->tsd;\n                        }\n\n                        /* create a new packet structure */\n                        tp             = wmem_new(wmem_file_scope(), rtmpt_packet_t);\n                        tp->seq        = tp->lastseq = tf ? tf->seq : seq+offset;\n                        tp->have       = 0;\n                        tp->want       = basic_hlen + message_hlen + body_len;\n                        tp->chunkwant  = 0;\n                        tp->chunkhave  = 0;\n                        tp->bhlen      = basic_hlen;\n                        tp->mhlen      = message_hlen;\n                        tp->fmt        = header_type;\n                        tp->id         = id;\n                        tp->ts         = ts;\n                        tp->len        = body_len;\n                        if (id > RTMPT_ID_MAX)\n                                tp->cmd = id;\n                        else\n                                tp->cmd = cmd & 0x7f;\n                        tp->src        = src;\n                        tp->txid       = 0;\n                        tp->isresponse = FALSE;\n                        tp->otherframe = 0;\n\n                        /* Save the header information for future defaulting needs */\n                        ti->ts  = ts;\n                        ti->tsd = tsd;\n                        ti->len = body_len;\n                        ti->cmd = cmd;\n                        ti->src = src;\n\n                        /* store against the id only until unchunking is complete */\n                        wmem_tree_insert32(ti->packets, tp->seq, tp);\n\n                        if (!tf && body_len <= chunk_size && tp->want <= remain) {\n                                /* The easy case - a whole packet contiguous and fully within this segment */\n                                tp->resident    = FALSE;\n                                tp->data.offset = offset;\n                                tp->lastseq     = seq+offset+tp->want-1;\n                                tp->have        = tp->want;\n\n                                wmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp);\n\n                                pktbuf = tvb_new_subset_length(tvb, tp->data.offset, tp->have);\n                                dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp);\n\n                                offset += tp->want;\n                                remain -= tp->want;\n                                continue;\n\n                        } else {\n                                /* Some more reassembly required */\n                                tp->resident = TRUE;\n                                tp->data.p = (guint8 *)wmem_alloc(wmem_file_scope(), tp->bhlen+tp->mhlen+tp->len);\n\n                                if (tf && tf->ishdr) {\n                                        memcpy(tp->data.p, tf->saved.d, tf->len);\n                                } else {\n                                        tvb_memcpy(tvb, tp->data.p, offset, basic_hlen+message_hlen);\n                                        offset += basic_hlen + message_hlen;\n                                        remain -= basic_hlen + message_hlen;\n                                }\n\n                                tp->lastseq = seq+offset-1;\n                                tp->have = basic_hlen + message_hlen;\n\n                                if (tp->have == tp->want) {\n                                        wmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp);\n\n                                        pktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have);\n                                        add_new_data_source(pinfo, pktbuf, \"Unchunked RTMP\");\n                                        dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp);\n                                        continue;\n                                }\n\n                                tp->chunkwant = chunk_size;\n                                if (tp->chunkwant > tp->want-tp->have)\n                                        tp->chunkwant = tp->want - tp->have;\n                        }\n                } else {\n                        RTMPT_DEBUG(\"Old packet cdir=%d seq=%d ti=%p tp=%p header_len=%d id=%d tph=%d tpw=%d len=%d cs=%d\\n\",\n                                    cdir, seq+offset,\n                                    ti, tp, basic_hlen+message_hlen, id, tp?tp->have:0, tp?tp->want:0, body_len, chunk_size);\n\n                        tp->chunkwant = chunk_size;\n                        if (tp->chunkwant > tp->want-tp->have)\n                                tp->chunkwant = tp->want - tp->have;\n\n                        offset += basic_hlen + message_hlen;\n                        remain -= basic_hlen + message_hlen;\n                }\n\n                tf = NULL;\n\n                /* Last case to deal with is unchunking the packet body */\n        unchunk:\n                want = tp->chunkwant - tp->chunkhave;\n                if (want > remain)\n                        want = remain;\n                RTMPT_DEBUG(\"  cw=%d ch=%d r=%d w=%d\\n\", tp->chunkwant, tp->chunkhave, remain, want);\n\n                tvb_memcpy(tvb, tp->data.p+tp->have, offset, want);\n\n                if (tf) {\n                        tf->have += want;\n                        tf->lastseq = seq+offset+want-1;\n                }\n                tp->lastseq = seq+offset+want-1;\n                tp->have += want;\n                tp->chunkhave += want;\n\n                offset += want;\n                remain -= want;\n\n                if (tp->chunkhave == tp->chunkwant) {\n                        /* Chunk is complete - wait for next header */\n                        tp->chunkhave = 0;\n                        tp->chunkwant = 0;\n                }\n\n                if (tp->have == tp->want) {\n                        /* Whole packet is complete */\n                        wmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp);\n\n                        pktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have);\n                        add_new_data_source(pinfo, pktbuf, \"Unchunked RTMP\");\n                        dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp);\n                } else if (tp->chunkhave < tp->chunkwant) {\n                        /* Chunk is split across segment boundary */\n                        rtmpt_frag_t *tf2 = wmem_new(wmem_file_scope(), rtmpt_frag_t);\n                        tf2->ishdr    = 0;\n                        tf2->seq      = seq + offset - want;\n                        tf2->lastseq  = tf2->seq + remain - 1 + want;\n                        tf2->have     = tp->chunkhave;\n                        tf2->len      = tp->chunkwant;\n                        tf2->saved.id = tp->id;\n                        RTMPT_DEBUG(\"  inserting tf @ %d\\n\", seq+offset-want-1);\n                        wmem_tree_insert32(rconv->frags[cdir], seq+offset-want-1, tf2);\n                }\n        }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,6 +16,7 @@\n         guint8  cmd;\n         guint32 src;\n         int     chunk_size;\n+        guint32 save_seq = 0;\n \n         rtmpt_frag_t   *tf;\n         rtmpt_id_t     *ti;\n@@ -38,8 +39,9 @@\n                 wmem_stack_push(packets, 0);\n \n                 tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(rconv->packets[cdir], seq+remain-1);\n-                while (tp && tp->lastseq >= seq) {\n+                while (tp && tp->lastseq >= seq && tp->lastseq >= save_seq) {\n                         wmem_stack_push(packets, tp);\n+                        save_seq = tp->lastseq+1; /* Ensure sequence is increasing */\n                         tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(rconv->packets[cdir], tp->lastseq-1);\n                 }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "                while (tp && tp->lastseq >= seq) {"
            ],
            "added_lines": [
                "        guint32 save_seq = 0;",
                "                while (tp && tp->lastseq >= seq && tp->lastseq >= save_seq) {",
                "                        save_seq = tp->lastseq+1; /* Ensure sequence is increasing */"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-6474",
        "func_name": "wireshark/nstrace_read_v30",
        "description": "In Wireshark 2.2.0 to 2.2.4 and 2.0.0 to 2.0.10, there is a NetScaler file parser infinite loop, triggered by a malformed capture file. This was addressed in wiretap/netscaler.c by validating record sizes.",
        "git_url": "https://github.com/wireshark/wireshark/commit/a998c9195f183d85f5b0bbeebba21a2d4d303d47",
        "commit_title": "Do more record length checks.",
        "commit_text": " Do the check early in the process of processing the record, and do it for all record types.  Bug: 13429 (cherry picked from commit e4dfeed2ca2491fa944dc9cd5180ec202313b5b6)",
        "func_before": "static gboolean nstrace_read_v30(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)\n{\n    nstrace_t *nstrace = (nstrace_t *)wth->priv;\n    guint64 nsg_creltime;\n    gchar *nstrace_buf = nstrace->pnstrace_buf;\n    guint32 nstrace_buf_offset = nstrace->nstrace_buf_offset;\n    guint32 nstrace_buflen = nstrace->nstrace_buflen;\n    guint8 nstrace_tmpbuff[65536];\n    guint32 nstrace_tmpbuff_off=0,nst_dataSize=0,rec_size=0,nsg_nextPageOffset=0;\n    nspr_hd_v20_t *hdp;\n    int bytes_read = 0;\n    *err = 0;\n    *err_info = NULL;\n    if(nstrace_buflen == 0){\n      return FALSE; /* Reached End Of File */\n    }\n\n    do\n    {\n        if (!nstrace_buf[nstrace_buf_offset] && nstrace_buf_offset <= NSPR_PAGESIZE_TRACE){\n            nstrace_buf_offset = NSPR_PAGESIZE_TRACE;\n        }\n        if (file_eof(wth->fh) && bytes_read > 0 && bytes_read < NSPR_PAGESIZE_TRACE){\n            memset(&nstrace_buf[bytes_read], 0, NSPR_PAGESIZE_TRACE-bytes_read);\n        }\n        while ((nstrace_buf_offset < NSPR_PAGESIZE_TRACE) &&\n            nstrace_buf[nstrace_buf_offset])\n        {\n            hdp = (nspr_hd_v20_t *) &nstrace_buf[nstrace_buf_offset];\n            if(nspr_getv20recordsize(hdp) == 0){\n              *err=WTAP_ERR_BAD_FILE;\n              *err_info = g_strdup(\"nstrace: zero size record found\");\n              return FALSE;\n            }\n            switch (hdp->phd_RecordType)\n            {\n\n#define GENERATE_CASE_FULL_V30(phdr,ver,HEADERVER) \\\n        case NSPR_PDPKTRACEFULLTX_V##ver:\\\n        case NSPR_PDPKTRACEFULLTXB_V##ver:\\\n        case NSPR_PDPKTRACEFULLRX_V##ver:\\\n        case NSPR_PDPKTRACEFULLNEWRX_V##ver:\\\n            PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);\n\n                GENERATE_CASE_FULL_V30(&wth->phdr,30,300);\n\n#undef GENERATE_CASE_FULL_V30\n\n#define GENERATE_CASE_FULL_V35(phdr,ver,HEADERVER) \\\n        case NSPR_PDPKTRACEFULLTX_V##ver:\\\n        case NSPR_PDPKTRACEFULLTXB_V##ver:\\\n        case NSPR_PDPKTRACEFULLRX_V##ver:\\\n        case NSPR_PDPKTRACEFULLNEWRX_V##ver:\\\n            PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);\n                GENERATE_CASE_FULL_V35(&wth->phdr,35,350);\n\n#undef GENERATE_CASE_FULL_V35\n\n                case NSPR_ABSTIME_V20:\n                {\n                    nstrace_buf_offset += nspr_getv20recordsize(hdp);\n                    ns_setabstime(nstrace, pletoh32(&((nspr_abstime_v20_t *) &nstrace_buf[nstrace_buf_offset])->abs_Time), pletoh16(&((nspr_abstime_v20_t *) &nstrace_buf[nstrace_buf_offset])->abs_RelTime));\n                    break;\n                }\n\n                case NSPR_RELTIME_V20:\n                {\n                    ns_setrelativetime(nstrace, pletoh16(&((nspr_abstime_v20_t *) &nstrace_buf[nstrace_buf_offset])->abs_RelTime));\n                    nstrace_buf_offset += nspr_getv20recordsize(hdp);\n                    break;\n                }\n\n                default:\n                {\n                    nstrace_buf_offset += nspr_getv20recordsize(hdp);\n                    break;\n                }\n            }\n        }\n        nstrace_buf_offset = 0;\n        nstrace->xxx_offset += nstrace_buflen;\n        nstrace_buflen = NSPR_PAGESIZE_TRACE;\n    } while((nstrace_buflen > 0) && (bytes_read = file_read(nstrace_buf, nstrace_buflen, wth->fh)) > 0 && (file_eof(wth->fh) || (guint32)bytes_read == nstrace_buflen));\n\n    return FALSE;\n}",
        "func": "static gboolean nstrace_read_v30(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)\n{\n    nstrace_t *nstrace = (nstrace_t *)wth->priv;\n    guint64 nsg_creltime;\n    gchar *nstrace_buf = nstrace->pnstrace_buf;\n    guint32 nstrace_buf_offset = nstrace->nstrace_buf_offset;\n    guint32 nstrace_buflen = nstrace->nstrace_buflen;\n    guint8 nstrace_tmpbuff[65536];\n    guint32 nstrace_tmpbuff_off=0,nst_dataSize=0,rec_size=0,nsg_nextPageOffset=0;\n    nspr_hd_v20_t *hdp;\n    int bytes_read = 0;\n    *err = 0;\n    *err_info = NULL;\n    if(nstrace_buflen == 0){\n      return FALSE; /* Reached End Of File */\n    }\n\n    do\n    {\n        if (!nstrace_buf[nstrace_buf_offset] && nstrace_buf_offset <= NSPR_PAGESIZE_TRACE){\n            nstrace_buf_offset = NSPR_PAGESIZE_TRACE;\n        }\n        if (file_eof(wth->fh) && bytes_read > 0 && bytes_read < NSPR_PAGESIZE_TRACE){\n            memset(&nstrace_buf[bytes_read], 0, NSPR_PAGESIZE_TRACE-bytes_read);\n        }\n        while ((nstrace_buf_offset < NSPR_PAGESIZE_TRACE) &&\n            nstrace_buf[nstrace_buf_offset])\n        {\n            hdp = (nspr_hd_v20_t *) &nstrace_buf[nstrace_buf_offset];\n            if (nspr_getv20recordsize(hdp) == 0) {\n                *err = WTAP_ERR_BAD_FILE;\n                *err_info = g_strdup(\"nstrace: zero size record found\");\n                return FALSE;\n            }\n            switch (hdp->phd_RecordType)\n            {\n\n#define GENERATE_CASE_FULL_V30(phdr,ver,HEADERVER) \\\n        case NSPR_PDPKTRACEFULLTX_V##ver:\\\n        case NSPR_PDPKTRACEFULLTXB_V##ver:\\\n        case NSPR_PDPKTRACEFULLRX_V##ver:\\\n        case NSPR_PDPKTRACEFULLNEWRX_V##ver:\\\n            PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);\n\n                GENERATE_CASE_FULL_V30(&wth->phdr,30,300);\n\n#undef GENERATE_CASE_FULL_V30\n\n#define GENERATE_CASE_FULL_V35(phdr,ver,HEADERVER) \\\n        case NSPR_PDPKTRACEFULLTX_V##ver:\\\n        case NSPR_PDPKTRACEFULLTXB_V##ver:\\\n        case NSPR_PDPKTRACEFULLRX_V##ver:\\\n        case NSPR_PDPKTRACEFULLNEWRX_V##ver:\\\n            PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);\n                GENERATE_CASE_FULL_V35(&wth->phdr,35,350);\n\n#undef GENERATE_CASE_FULL_V35\n\n                case NSPR_ABSTIME_V20:\n                {\n                    nstrace_buf_offset += nspr_getv20recordsize(hdp);\n                    ns_setabstime(nstrace, pletoh32(&((nspr_abstime_v20_t *) &nstrace_buf[nstrace_buf_offset])->abs_Time), pletoh16(&((nspr_abstime_v20_t *) &nstrace_buf[nstrace_buf_offset])->abs_RelTime));\n                    break;\n                }\n\n                case NSPR_RELTIME_V20:\n                {\n                    ns_setrelativetime(nstrace, pletoh16(&((nspr_abstime_v20_t *) &nstrace_buf[nstrace_buf_offset])->abs_RelTime));\n                    nstrace_buf_offset += nspr_getv20recordsize(hdp);\n                    break;\n                }\n\n                default:\n                {\n                    nstrace_buf_offset += nspr_getv20recordsize(hdp);\n                    break;\n                }\n            }\n        }\n        nstrace_buf_offset = 0;\n        nstrace->xxx_offset += nstrace_buflen;\n        nstrace_buflen = NSPR_PAGESIZE_TRACE;\n    } while((nstrace_buflen > 0) && (bytes_read = file_read(nstrace_buf, nstrace_buflen, wth->fh)) > 0 && (file_eof(wth->fh) || (guint32)bytes_read == nstrace_buflen));\n\n    return FALSE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -27,10 +27,10 @@\n             nstrace_buf[nstrace_buf_offset])\n         {\n             hdp = (nspr_hd_v20_t *) &nstrace_buf[nstrace_buf_offset];\n-            if(nspr_getv20recordsize(hdp) == 0){\n-              *err=WTAP_ERR_BAD_FILE;\n-              *err_info = g_strdup(\"nstrace: zero size record found\");\n-              return FALSE;\n+            if (nspr_getv20recordsize(hdp) == 0) {\n+                *err = WTAP_ERR_BAD_FILE;\n+                *err_info = g_strdup(\"nstrace: zero size record found\");\n+                return FALSE;\n             }\n             switch (hdp->phd_RecordType)\n             {",
        "diff_line_info": {
            "deleted_lines": [
                "            if(nspr_getv20recordsize(hdp) == 0){",
                "              *err=WTAP_ERR_BAD_FILE;",
                "              *err_info = g_strdup(\"nstrace: zero size record found\");",
                "              return FALSE;"
            ],
            "added_lines": [
                "            if (nspr_getv20recordsize(hdp) == 0) {",
                "                *err = WTAP_ERR_BAD_FILE;",
                "                *err_info = g_strdup(\"nstrace: zero size record found\");",
                "                return FALSE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-6474",
        "func_name": "wireshark/nstrace_read_v10",
        "description": "In Wireshark 2.2.0 to 2.2.4 and 2.0.0 to 2.0.10, there is a NetScaler file parser infinite loop, triggered by a malformed capture file. This was addressed in wiretap/netscaler.c by validating record sizes.",
        "git_url": "https://github.com/wireshark/wireshark/commit/a998c9195f183d85f5b0bbeebba21a2d4d303d47",
        "commit_title": "Do more record length checks.",
        "commit_text": " Do the check early in the process of processing the record, and do it for all record types.  Bug: 13429 (cherry picked from commit e4dfeed2ca2491fa944dc9cd5180ec202313b5b6)",
        "func_before": "static gboolean nstrace_read_v10(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)\n{\n    nstrace_t *nstrace = (nstrace_t *)wth->priv;\n    guint64 nsg_creltime = nstrace->nsg_creltime;\n    gchar *nstrace_buf = nstrace->pnstrace_buf;\n    guint32 nstrace_buf_offset = nstrace->nstrace_buf_offset;\n    guint32 nstrace_buflen = nstrace->nstrace_buflen;\n    int bytes_read;\n\n    *err = 0;\n    *err_info = NULL;\n    do\n    {\n        while ((nstrace_buf_offset < nstrace_buflen) &&\n            ((nstrace_buflen - nstrace_buf_offset) >= ((gint32)sizeof((( nspr_header_v10_t*)&nstrace_buf[nstrace_buf_offset])->ph_RecordType))))\n        {\n\n#define GENERATE_CASE_FULL(phdr,ver,HEADERVER) \\\n        case NSPR_PDPKTRACEFULLTX_V##ver:\\\n        case NSPR_PDPKTRACEFULLTXB_V##ver:\\\n        case NSPR_PDPKTRACEFULLRX_V##ver:\\\n            PACKET_DESCRIBE(phdr,FULL,full,ver,fp,HEADERVER);\n\n#define GENERATE_CASE_PART(phdr,ver,HEADERVER) \\\n        case NSPR_PDPKTRACEPARTTX_V##ver:\\\n        case NSPR_PDPKTRACEPARTTXB_V##ver:\\\n        case NSPR_PDPKTRACEPARTRX_V##ver:\\\n            PACKET_DESCRIBE(phdr,PART,part,ver,pp,HEADERVER);\n\n            switch (pletoh16(&(( nspr_header_v10_t*)&nstrace_buf[nstrace_buf_offset])->ph_RecordType))\n            {\n                GENERATE_CASE_FULL(&wth->phdr,10,100)\n                GENERATE_CASE_PART(&wth->phdr,10,100)\n\n#undef GENERATE_CASE_FULL\n#undef GENERATE_CASE_PART\n\n                case NSPR_ABSTIME_V10:\n                {\n                    nspr_pktracefull_v10_t *fp = (nspr_pktracefull_v10_t *) &nstrace_buf[nstrace_buf_offset];\n                    ns_setabstime(nstrace, pletoh32(((nspr_abstime_v10_t *) fp)->abs_Time), pletoh32(&((nspr_abstime_v10_t *) fp)->abs_RelTime));\n                    nstrace_buf_offset += pletoh16(&fp->nsprRecordSize);\n                    break;\n                }\n\n                case NSPR_RELTIME_V10:\n                {\n                    nspr_pktracefull_v10_t *fp = (nspr_pktracefull_v10_t *) &nstrace_buf[nstrace_buf_offset];\n                    ns_setrelativetime(nstrace, pletoh32(((nspr_abstime_v10_t *) fp)->abs_RelTime));\n                    nstrace_buf_offset += pletoh16(&fp->nsprRecordSize);\n                    break;\n                }\n\n                case NSPR_UNUSEDSPACE_V10:\n                    nstrace_buf_offset = nstrace_buflen;\n                    break;\n\n                default:\n                {\n                    nspr_pktracefull_v10_t *fp = (nspr_pktracefull_v10_t *) &nstrace_buf[nstrace_buf_offset];\n                    nstrace_buf_offset += pletoh16(&fp->nsprRecordSize);\n                    break;\n                }\n            }\n        }\n\n        nstrace_buf_offset = 0;\n        nstrace->xxx_offset += nstrace_buflen;\n        nstrace_buflen = GET_READ_PAGE_SIZE((nstrace->file_size - nstrace->xxx_offset));\n    }while((nstrace_buflen > 0) && (bytes_read = file_read(nstrace_buf, nstrace_buflen, wth->fh)) > 0 && ((guint32)bytes_read == nstrace_buflen));\n\n    return FALSE;\n}",
        "func": "static gboolean nstrace_read_v10(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)\n{\n    nstrace_t *nstrace = (nstrace_t *)wth->priv;\n    guint64 nsg_creltime = nstrace->nsg_creltime;\n    gchar *nstrace_buf = nstrace->pnstrace_buf;\n    guint32 nstrace_buf_offset = nstrace->nstrace_buf_offset;\n    guint32 nstrace_buflen = nstrace->nstrace_buflen;\n    int bytes_read;\n\n    *err = 0;\n    *err_info = NULL;\n    do\n    {\n        while ((nstrace_buf_offset < nstrace_buflen) &&\n            ((nstrace_buflen - nstrace_buf_offset) >= ((gint32)sizeof((( nspr_header_v10_t*)&nstrace_buf[nstrace_buf_offset])->ph_RecordType))))\n        {\n\n#define GENERATE_CASE_FULL(phdr,ver,HEADERVER) \\\n        case NSPR_PDPKTRACEFULLTX_V##ver:\\\n        case NSPR_PDPKTRACEFULLTXB_V##ver:\\\n        case NSPR_PDPKTRACEFULLRX_V##ver:\\\n            PACKET_DESCRIBE(phdr,FULL,full,ver,fp,HEADERVER);\n\n#define GENERATE_CASE_PART(phdr,ver,HEADERVER) \\\n        case NSPR_PDPKTRACEPARTTX_V##ver:\\\n        case NSPR_PDPKTRACEPARTTXB_V##ver:\\\n        case NSPR_PDPKTRACEPARTRX_V##ver:\\\n            PACKET_DESCRIBE(phdr,PART,part,ver,pp,HEADERVER);\n\n            switch (pletoh16(&(( nspr_header_v10_t*)&nstrace_buf[nstrace_buf_offset])->ph_RecordType))\n            {\n                GENERATE_CASE_FULL(&wth->phdr,10,100)\n                GENERATE_CASE_PART(&wth->phdr,10,100)\n\n#undef GENERATE_CASE_FULL\n#undef GENERATE_CASE_PART\n\n                case NSPR_ABSTIME_V10:\n                {\n                    nspr_pktracefull_v10_t *fp = (nspr_pktracefull_v10_t *) &nstrace_buf[nstrace_buf_offset];\n                    if (pletoh16(&fp->nsprRecordSize) == 0) {\n                        *err = WTAP_ERR_BAD_FILE;\n                        *err_info = g_strdup(\"nstrace: zero size record found\");\n                        return FALSE;\n                    }\n                    ns_setabstime(nstrace, pletoh32(((nspr_abstime_v10_t *) fp)->abs_Time), pletoh32(&((nspr_abstime_v10_t *) fp)->abs_RelTime));\n                    nstrace_buf_offset += pletoh16(&fp->nsprRecordSize);\n                    break;\n                }\n\n                case NSPR_RELTIME_V10:\n                {\n                    nspr_pktracefull_v10_t *fp = (nspr_pktracefull_v10_t *) &nstrace_buf[nstrace_buf_offset];\n                    if (pletoh16(&fp->nsprRecordSize) == 0) {\n                        *err = WTAP_ERR_BAD_FILE;\n                        *err_info = g_strdup(\"nstrace: zero size record found\");\n                        return FALSE;\n                    }\n                    ns_setrelativetime(nstrace, pletoh32(((nspr_abstime_v10_t *) fp)->abs_RelTime));\n                    nstrace_buf_offset += pletoh16(&fp->nsprRecordSize);\n                    break;\n                }\n\n                case NSPR_UNUSEDSPACE_V10:\n                    nstrace_buf_offset = nstrace_buflen;\n                    break;\n\n                default:\n                {\n                    nspr_pktracefull_v10_t *fp = (nspr_pktracefull_v10_t *) &nstrace_buf[nstrace_buf_offset];\n                    if (pletoh16(&fp->nsprRecordSize) == 0) {\n                        *err = WTAP_ERR_BAD_FILE;\n                        *err_info = g_strdup(\"nstrace: zero size record found\");\n                        return FALSE;\n                    }\n                    nstrace_buf_offset += pletoh16(&fp->nsprRecordSize);\n                    break;\n                }\n            }\n        }\n\n        nstrace_buf_offset = 0;\n        nstrace->xxx_offset += nstrace_buflen;\n        nstrace_buflen = GET_READ_PAGE_SIZE((nstrace->file_size - nstrace->xxx_offset));\n    }while((nstrace_buflen > 0) && (bytes_read = file_read(nstrace_buf, nstrace_buflen, wth->fh)) > 0 && ((guint32)bytes_read == nstrace_buflen));\n\n    return FALSE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -38,6 +38,11 @@\n                 case NSPR_ABSTIME_V10:\n                 {\n                     nspr_pktracefull_v10_t *fp = (nspr_pktracefull_v10_t *) &nstrace_buf[nstrace_buf_offset];\n+                    if (pletoh16(&fp->nsprRecordSize) == 0) {\n+                        *err = WTAP_ERR_BAD_FILE;\n+                        *err_info = g_strdup(\"nstrace: zero size record found\");\n+                        return FALSE;\n+                    }\n                     ns_setabstime(nstrace, pletoh32(((nspr_abstime_v10_t *) fp)->abs_Time), pletoh32(&((nspr_abstime_v10_t *) fp)->abs_RelTime));\n                     nstrace_buf_offset += pletoh16(&fp->nsprRecordSize);\n                     break;\n@@ -46,6 +51,11 @@\n                 case NSPR_RELTIME_V10:\n                 {\n                     nspr_pktracefull_v10_t *fp = (nspr_pktracefull_v10_t *) &nstrace_buf[nstrace_buf_offset];\n+                    if (pletoh16(&fp->nsprRecordSize) == 0) {\n+                        *err = WTAP_ERR_BAD_FILE;\n+                        *err_info = g_strdup(\"nstrace: zero size record found\");\n+                        return FALSE;\n+                    }\n                     ns_setrelativetime(nstrace, pletoh32(((nspr_abstime_v10_t *) fp)->abs_RelTime));\n                     nstrace_buf_offset += pletoh16(&fp->nsprRecordSize);\n                     break;\n@@ -58,6 +68,11 @@\n                 default:\n                 {\n                     nspr_pktracefull_v10_t *fp = (nspr_pktracefull_v10_t *) &nstrace_buf[nstrace_buf_offset];\n+                    if (pletoh16(&fp->nsprRecordSize) == 0) {\n+                        *err = WTAP_ERR_BAD_FILE;\n+                        *err_info = g_strdup(\"nstrace: zero size record found\");\n+                        return FALSE;\n+                    }\n                     nstrace_buf_offset += pletoh16(&fp->nsprRecordSize);\n                     break;\n                 }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "                    if (pletoh16(&fp->nsprRecordSize) == 0) {",
                "                        *err = WTAP_ERR_BAD_FILE;",
                "                        *err_info = g_strdup(\"nstrace: zero size record found\");",
                "                        return FALSE;",
                "                    }",
                "                    if (pletoh16(&fp->nsprRecordSize) == 0) {",
                "                        *err = WTAP_ERR_BAD_FILE;",
                "                        *err_info = g_strdup(\"nstrace: zero size record found\");",
                "                        return FALSE;",
                "                    }",
                "                    if (pletoh16(&fp->nsprRecordSize) == 0) {",
                "                        *err = WTAP_ERR_BAD_FILE;",
                "                        *err_info = g_strdup(\"nstrace: zero size record found\");",
                "                        return FALSE;",
                "                    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-6474",
        "func_name": "wireshark/nstrace_read_v20",
        "description": "In Wireshark 2.2.0 to 2.2.4 and 2.0.0 to 2.0.10, there is a NetScaler file parser infinite loop, triggered by a malformed capture file. This was addressed in wiretap/netscaler.c by validating record sizes.",
        "git_url": "https://github.com/wireshark/wireshark/commit/a998c9195f183d85f5b0bbeebba21a2d4d303d47",
        "commit_title": "Do more record length checks.",
        "commit_text": " Do the check early in the process of processing the record, and do it for all record types.  Bug: 13429 (cherry picked from commit e4dfeed2ca2491fa944dc9cd5180ec202313b5b6)",
        "func_before": "static gboolean nstrace_read_v20(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)\n{\n    nstrace_t *nstrace = (nstrace_t *)wth->priv;\n    guint64 nsg_creltime = nstrace->nsg_creltime;\n    gchar *nstrace_buf = nstrace->pnstrace_buf;\n    guint32 nstrace_buf_offset = nstrace->nstrace_buf_offset;\n    guint32 nstrace_buflen = nstrace->nstrace_buflen;\n    int bytes_read;\n\n    *err = 0;\n    *err_info = NULL;\n    do\n    {\n        while ((nstrace_buf_offset < nstrace_buflen) &&\n            ((nstrace_buflen - nstrace_buf_offset) >= ((gint32)sizeof((( nspr_hd_v20_t*)&nstrace_buf[nstrace_buf_offset])->phd_RecordType))))\n        {\n            switch ((( nspr_hd_v20_t*)&nstrace_buf[nstrace_buf_offset])->phd_RecordType)\n            {\n\n#define GENERATE_CASE_FULL(phdr,ver,HEADERVER) \\\n        case NSPR_PDPKTRACEFULLTX_V##ver:\\\n        case NSPR_PDPKTRACEFULLTXB_V##ver:\\\n        case NSPR_PDPKTRACEFULLRX_V##ver:\\\n            PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);\n\n#define GENERATE_CASE_FULL_V25(phdr,ver,HEADERVER) \\\n        case NSPR_PDPKTRACEFULLTX_V##ver:\\\n        case NSPR_PDPKTRACEFULLTXB_V##ver:\\\n        case NSPR_PDPKTRACEFULLRX_V##ver:\\\n        case NSPR_PDPKTRACEFULLNEWRX_V##ver:\\\n            PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);\n\n#define GENERATE_CASE_PART(phdr,ver,HEADERVER) \\\n        case NSPR_PDPKTRACEPARTTX_V##ver:\\\n        case NSPR_PDPKTRACEPARTTXB_V##ver:\\\n        case NSPR_PDPKTRACEPARTRX_V##ver:\\\n            PACKET_DESCRIBE(phdr,PART,ver,v##ver##_part,pp,pktracepart_v##ver,HEADERVER);\n\n#define GENERATE_CASE_PART_V25(phdr,ver,HEADERVER) \\\n        case NSPR_PDPKTRACEPARTTX_V##ver:\\\n        case NSPR_PDPKTRACEPARTTXB_V##ver:\\\n        case NSPR_PDPKTRACEPARTRX_V##ver:\\\n        case NSPR_PDPKTRACEPARTNEWRX_V##ver:\\\n            PACKET_DESCRIBE(phdr,PART,ver,v##ver##_part,pp,pktracepart_v##ver,HEADERVER);\n\n                GENERATE_CASE_FULL(&wth->phdr,20,200);\n                GENERATE_CASE_PART(&wth->phdr,20,200);\n                GENERATE_CASE_FULL(&wth->phdr,21,201);\n                GENERATE_CASE_PART(&wth->phdr,21,201);\n                GENERATE_CASE_FULL(&wth->phdr,22,202);\n                GENERATE_CASE_PART(&wth->phdr,22,202);\n                GENERATE_CASE_FULL(&wth->phdr,23,203);\n                GENERATE_CASE_PART(&wth->phdr,23,203);\n                GENERATE_CASE_FULL_V25(&wth->phdr,24,204);\n                GENERATE_CASE_PART_V25(&wth->phdr,24,204);\n                GENERATE_CASE_FULL_V25(&wth->phdr,25,205);\n                GENERATE_CASE_PART_V25(&wth->phdr,25,205);\n                GENERATE_CASE_FULL_V25(&wth->phdr,26,206);\n                GENERATE_CASE_PART_V25(&wth->phdr,26,206);\n\n#undef GENERATE_CASE_FULL\n#undef GENERATE_CASE_FULL_V25\n#undef GENERATE_CASE_PART\n#undef GENERATE_CASE_PART_V25\n\n                case NSPR_ABSTIME_V20:\n                {\n                    nspr_pktracefull_v20_t *fp20 = (nspr_pktracefull_v20_t *) &nstrace_buf[nstrace_buf_offset];\n                    nstrace_buf_offset += nspr_getv20recordsize((nspr_hd_v20_t *)fp20);\n                    ns_setabstime(nstrace, pletoh32(&((nspr_abstime_v20_t *) fp20)->abs_Time), pletoh16(&((nspr_abstime_v20_t *) fp20)->abs_RelTime));\n                    break;\n                }\n\n                case NSPR_RELTIME_V20:\n                {\n                    nspr_pktracefull_v20_t *fp20 = (nspr_pktracefull_v20_t *) &nstrace_buf[nstrace_buf_offset];\n                    ns_setrelativetime(nstrace, pletoh16(&((nspr_abstime_v20_t *) fp20)->abs_RelTime));\n                    nstrace_buf_offset += nspr_getv20recordsize((nspr_hd_v20_t *)fp20);\n                    break;\n                  }\n\n                case NSPR_UNUSEDSPACE_V20:\n                {\n                    if (nstrace_buf_offset >= NSPR_PAGESIZE/2)\n                        nstrace_buf_offset = nstrace_buflen;\n                    else\n                        nstrace_buf_offset = NSPR_PAGESIZE/2;\n                    break;\n                  }\n\n                default:\n                {\n                    nspr_pktracefull_v20_t *fp20 = (nspr_pktracefull_v20_t *) &nstrace_buf[nstrace_buf_offset];\n                    nstrace_buf_offset += nspr_getv20recordsize((nspr_hd_v20_t *)fp20);\n                    break;\n                }\n            }\n        }\n\n        nstrace_buf_offset = 0;\n        nstrace->xxx_offset += nstrace_buflen;\n        nstrace_buflen = GET_READ_PAGE_SIZE((nstrace->file_size - nstrace->xxx_offset));\n    }while((nstrace_buflen > 0) && (bytes_read = file_read(nstrace_buf, nstrace_buflen, wth->fh)) > 0 && ((guint32)bytes_read == nstrace_buflen));\n\n    return FALSE;\n}",
        "func": "static gboolean nstrace_read_v20(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)\n{\n    nstrace_t *nstrace = (nstrace_t *)wth->priv;\n    guint64 nsg_creltime = nstrace->nsg_creltime;\n    gchar *nstrace_buf = nstrace->pnstrace_buf;\n    guint32 nstrace_buf_offset = nstrace->nstrace_buf_offset;\n    guint32 nstrace_buflen = nstrace->nstrace_buflen;\n    int bytes_read;\n\n    *err = 0;\n    *err_info = NULL;\n    do\n    {\n        while ((nstrace_buf_offset < nstrace_buflen) &&\n            ((nstrace_buflen - nstrace_buf_offset) >= ((gint32)sizeof((( nspr_hd_v20_t*)&nstrace_buf[nstrace_buf_offset])->phd_RecordType))))\n        {\n            switch ((( nspr_hd_v20_t*)&nstrace_buf[nstrace_buf_offset])->phd_RecordType)\n            {\n\n#define GENERATE_CASE_FULL(phdr,ver,HEADERVER) \\\n        case NSPR_PDPKTRACEFULLTX_V##ver:\\\n        case NSPR_PDPKTRACEFULLTXB_V##ver:\\\n        case NSPR_PDPKTRACEFULLRX_V##ver:\\\n            PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);\n\n#define GENERATE_CASE_FULL_V25(phdr,ver,HEADERVER) \\\n        case NSPR_PDPKTRACEFULLTX_V##ver:\\\n        case NSPR_PDPKTRACEFULLTXB_V##ver:\\\n        case NSPR_PDPKTRACEFULLRX_V##ver:\\\n        case NSPR_PDPKTRACEFULLNEWRX_V##ver:\\\n            PACKET_DESCRIBE(phdr,FULL,ver,v##ver##_full,fp,pktracefull_v##ver,HEADERVER);\n\n#define GENERATE_CASE_PART(phdr,ver,HEADERVER) \\\n        case NSPR_PDPKTRACEPARTTX_V##ver:\\\n        case NSPR_PDPKTRACEPARTTXB_V##ver:\\\n        case NSPR_PDPKTRACEPARTRX_V##ver:\\\n            PACKET_DESCRIBE(phdr,PART,ver,v##ver##_part,pp,pktracepart_v##ver,HEADERVER);\n\n#define GENERATE_CASE_PART_V25(phdr,ver,HEADERVER) \\\n        case NSPR_PDPKTRACEPARTTX_V##ver:\\\n        case NSPR_PDPKTRACEPARTTXB_V##ver:\\\n        case NSPR_PDPKTRACEPARTRX_V##ver:\\\n        case NSPR_PDPKTRACEPARTNEWRX_V##ver:\\\n            PACKET_DESCRIBE(phdr,PART,ver,v##ver##_part,pp,pktracepart_v##ver,HEADERVER);\n\n                GENERATE_CASE_FULL(&wth->phdr,20,200);\n                GENERATE_CASE_PART(&wth->phdr,20,200);\n                GENERATE_CASE_FULL(&wth->phdr,21,201);\n                GENERATE_CASE_PART(&wth->phdr,21,201);\n                GENERATE_CASE_FULL(&wth->phdr,22,202);\n                GENERATE_CASE_PART(&wth->phdr,22,202);\n                GENERATE_CASE_FULL(&wth->phdr,23,203);\n                GENERATE_CASE_PART(&wth->phdr,23,203);\n                GENERATE_CASE_FULL_V25(&wth->phdr,24,204);\n                GENERATE_CASE_PART_V25(&wth->phdr,24,204);\n                GENERATE_CASE_FULL_V25(&wth->phdr,25,205);\n                GENERATE_CASE_PART_V25(&wth->phdr,25,205);\n                GENERATE_CASE_FULL_V25(&wth->phdr,26,206);\n                GENERATE_CASE_PART_V25(&wth->phdr,26,206);\n\n#undef GENERATE_CASE_FULL\n#undef GENERATE_CASE_FULL_V25\n#undef GENERATE_CASE_PART\n#undef GENERATE_CASE_PART_V25\n\n                case NSPR_ABSTIME_V20:\n                {\n                    nspr_pktracefull_v20_t *fp20 = (nspr_pktracefull_v20_t *) &nstrace_buf[nstrace_buf_offset];\n                    if (nspr_getv20recordsize((nspr_hd_v20_t *)fp20) == 0) {\n                        *err = WTAP_ERR_BAD_FILE;\n                        *err_info = g_strdup(\"nstrace: zero size record found\");\n                        return FALSE;\n                    }\n                    nstrace_buf_offset += nspr_getv20recordsize((nspr_hd_v20_t *)fp20);\n                    ns_setabstime(nstrace, pletoh32(&((nspr_abstime_v20_t *) fp20)->abs_Time), pletoh16(&((nspr_abstime_v20_t *) fp20)->abs_RelTime));\n                    break;\n                }\n\n                case NSPR_RELTIME_V20:\n                {\n                    nspr_pktracefull_v20_t *fp20 = (nspr_pktracefull_v20_t *) &nstrace_buf[nstrace_buf_offset];\n                    if (nspr_getv20recordsize((nspr_hd_v20_t *)fp20) == 0) {\n                        *err = WTAP_ERR_BAD_FILE;\n                        *err_info = g_strdup(\"nstrace: zero size record found\");\n                        return FALSE;\n                    }\n                    ns_setrelativetime(nstrace, pletoh16(&((nspr_abstime_v20_t *) fp20)->abs_RelTime));\n                    nstrace_buf_offset += nspr_getv20recordsize((nspr_hd_v20_t *)fp20);\n                    break;\n                  }\n\n                case NSPR_UNUSEDSPACE_V20:\n                {\n                    if (nstrace_buf_offset >= NSPR_PAGESIZE/2)\n                        nstrace_buf_offset = nstrace_buflen;\n                    else\n                        nstrace_buf_offset = NSPR_PAGESIZE/2;\n                    break;\n                  }\n\n                default:\n                {\n                    nspr_pktracefull_v20_t *fp20 = (nspr_pktracefull_v20_t *) &nstrace_buf[nstrace_buf_offset];\n                    if (nspr_getv20recordsize((nspr_hd_v20_t *)fp20) == 0) {\n                        *err = WTAP_ERR_BAD_FILE;\n                        *err_info = g_strdup(\"nstrace: zero size record found\");\n                        return FALSE;\n                    }\n                    nstrace_buf_offset += nspr_getv20recordsize((nspr_hd_v20_t *)fp20);\n                    break;\n                }\n            }\n        }\n\n        nstrace_buf_offset = 0;\n        nstrace->xxx_offset += nstrace_buflen;\n        nstrace_buflen = GET_READ_PAGE_SIZE((nstrace->file_size - nstrace->xxx_offset));\n    }while((nstrace_buflen > 0) && (bytes_read = file_read(nstrace_buf, nstrace_buflen, wth->fh)) > 0 && ((guint32)bytes_read == nstrace_buflen));\n\n    return FALSE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -66,6 +66,11 @@\n                 case NSPR_ABSTIME_V20:\n                 {\n                     nspr_pktracefull_v20_t *fp20 = (nspr_pktracefull_v20_t *) &nstrace_buf[nstrace_buf_offset];\n+                    if (nspr_getv20recordsize((nspr_hd_v20_t *)fp20) == 0) {\n+                        *err = WTAP_ERR_BAD_FILE;\n+                        *err_info = g_strdup(\"nstrace: zero size record found\");\n+                        return FALSE;\n+                    }\n                     nstrace_buf_offset += nspr_getv20recordsize((nspr_hd_v20_t *)fp20);\n                     ns_setabstime(nstrace, pletoh32(&((nspr_abstime_v20_t *) fp20)->abs_Time), pletoh16(&((nspr_abstime_v20_t *) fp20)->abs_RelTime));\n                     break;\n@@ -74,6 +79,11 @@\n                 case NSPR_RELTIME_V20:\n                 {\n                     nspr_pktracefull_v20_t *fp20 = (nspr_pktracefull_v20_t *) &nstrace_buf[nstrace_buf_offset];\n+                    if (nspr_getv20recordsize((nspr_hd_v20_t *)fp20) == 0) {\n+                        *err = WTAP_ERR_BAD_FILE;\n+                        *err_info = g_strdup(\"nstrace: zero size record found\");\n+                        return FALSE;\n+                    }\n                     ns_setrelativetime(nstrace, pletoh16(&((nspr_abstime_v20_t *) fp20)->abs_RelTime));\n                     nstrace_buf_offset += nspr_getv20recordsize((nspr_hd_v20_t *)fp20);\n                     break;\n@@ -91,6 +101,11 @@\n                 default:\n                 {\n                     nspr_pktracefull_v20_t *fp20 = (nspr_pktracefull_v20_t *) &nstrace_buf[nstrace_buf_offset];\n+                    if (nspr_getv20recordsize((nspr_hd_v20_t *)fp20) == 0) {\n+                        *err = WTAP_ERR_BAD_FILE;\n+                        *err_info = g_strdup(\"nstrace: zero size record found\");\n+                        return FALSE;\n+                    }\n                     nstrace_buf_offset += nspr_getv20recordsize((nspr_hd_v20_t *)fp20);\n                     break;\n                 }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "                    if (nspr_getv20recordsize((nspr_hd_v20_t *)fp20) == 0) {",
                "                        *err = WTAP_ERR_BAD_FILE;",
                "                        *err_info = g_strdup(\"nstrace: zero size record found\");",
                "                        return FALSE;",
                "                    }",
                "                    if (nspr_getv20recordsize((nspr_hd_v20_t *)fp20) == 0) {",
                "                        *err = WTAP_ERR_BAD_FILE;",
                "                        *err_info = g_strdup(\"nstrace: zero size record found\");",
                "                        return FALSE;",
                "                    }",
                "                    if (nspr_getv20recordsize((nspr_hd_v20_t *)fp20) == 0) {",
                "                        *err = WTAP_ERR_BAD_FILE;",
                "                        *err_info = g_strdup(\"nstrace: zero size record found\");",
                "                        return FALSE;",
                "                    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-50120",
        "func_name": "gpac/av1_uvlc",
        "description": "MP4Box GPAC version 2.3-DEV-rev636-gfbd7e13aa-master was discovered to contain an infinite loop in the function av1_uvlc at media_tools/av_parsers.c. This vulnerability allows attackers to cause a Denial of Service (DoS) via a crafted MP4 file.",
        "git_url": "https://github.com/gpac/gpac/commit/b655955b840ccd7c7198bb15375aa510e76208eb",
        "commit_title": "fix #2698",
        "commit_text": "",
        "func_before": "static u32 av1_uvlc(GF_BitStream *bs, const char *fname)\n{\n\tu32 res;\n\tu8 leadingZeros = 0;\n\twhile (1) {\n\t\tBool done = gf_bs_read_int(bs, 1);\n\t\tif (done)\n\t\t\tbreak;\n\t\tleadingZeros++;\n\t}\n\tif (leadingZeros >= 32) {\n\t\treturn 0xFFFFFFFF;\n\t}\n\tres = gf_bs_read_int(bs, leadingZeros) + (1 << leadingZeros) - 1;\n\tgf_bs_log(bs, 2*leadingZeros, fname, res);\n\treturn res;\n}",
        "func": "static u32 av1_uvlc(GF_BitStream *bs, const char *fname)\n{\n\tu32 res;\n\tu8 leadingZeros = 0;\n\twhile (gf_bs_available(bs)) {\n\t\tBool done = gf_bs_read_int(bs, 1);\n\t\tif (done)\n\t\t\tbreak;\n\t\tleadingZeros++;\n\t}\n\tif (leadingZeros >= 32) {\n\t\treturn 0xFFFFFFFF;\n\t}\n\tres = gf_bs_read_int(bs, leadingZeros) + (1 << leadingZeros) - 1;\n\tgf_bs_log(bs, 2*leadingZeros, fname, res);\n\treturn res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n {\n \tu32 res;\n \tu8 leadingZeros = 0;\n-\twhile (1) {\n+\twhile (gf_bs_available(bs)) {\n \t\tBool done = gf_bs_read_int(bs, 1);\n \t\tif (done)\n \t\t\tbreak;",
        "diff_line_info": {
            "deleted_lines": [
                "\twhile (1) {"
            ],
            "added_lines": [
                "\twhile (gf_bs_available(bs)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-50120",
        "func_name": "gpac/gf_bs_read_bit",
        "description": "MP4Box GPAC version 2.3-DEV-rev636-gfbd7e13aa-master was discovered to contain an infinite loop in the function av1_uvlc at media_tools/av_parsers.c. This vulnerability allows attackers to cause a Denial of Service (DoS) via a crafted MP4 file.",
        "git_url": "https://github.com/gpac/gpac/commit/b655955b840ccd7c7198bb15375aa510e76208eb",
        "commit_title": "fix #2698",
        "commit_text": "",
        "func_before": "GF_EXPORT\nu8 gf_bs_read_bit(GF_BitStream *bs)\n{\n\tif (bs->nbBits == 8) {\n\t\tbs->current = BS_ReadByte(bs);\n\t\tbs->nbBits = 0;\n\t}\n#ifdef NO_OPTS\n\t{\n\t\ts32 ret;\n\t\tbs->current <<= 1;\n\t\tbs->nbBits++;\n\t\tret = (bs->current & 0x100) >> 8;\n\t\treturn (u8) ret;\n\t}\n#else\n\treturn (u8) (bs->current & bit_mask[bs->nbBits++]) ? 1 : 0;\n#endif\n\n}",
        "func": "GF_EXPORT\nu8 gf_bs_read_bit(GF_BitStream *bs)\n{\n\tif (bs->nbBits == 8) {\n\t\tbs->current = BS_ReadByte(bs);\n\t\tbs->nbBits = 0;\n\t}\n#ifdef NO_OPTS\n\t{\n\t\ts32 ret;\n\t\tbs->current <<= 1;\n\t\tbs->nbBits++;\n\t\tret = (bs->current & 0x100) >> 8;\n\t\treturn (u8) ret;\n\t}\n#else\n\treturn (u8) (bs->current & bit_mask[bs->nbBits++]) ? 1 : 0;\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,5 +16,4 @@\n #else\n \treturn (u8) (bs->current & bit_mask[bs->nbBits++]) ? 1 : 0;\n #endif\n-\n }",
        "diff_line_info": {
            "deleted_lines": [
                ""
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2020-7595",
        "func_name": "GNOME/libxml2/xmlStringLenDecodeEntities",
        "description": "xmlStringLenDecodeEntities in parser.c in libxml2 2.9.10 has an infinite loop in a certain end-of-file situation.",
        "git_url": "https://github.com/GNOME/libxml2/commit/0e1a49c8907645d2e155f0d89d4d9895ac5112b5",
        "commit_title": "Fix infinite loop in xmlStringLenDecodeEntities",
        "commit_text": " When ctxt->instate == XML_PARSER_EOF,xmlParseStringEntityRef return NULL which cause a infinite loop in xmlStringLenDecodeEntities  Found with libFuzzer. ",
        "func_before": "xmlChar *\nxmlStringLenDecodeEntities(xmlParserCtxtPtr ctxt, const xmlChar *str, int len,\n\t\t      int what, xmlChar end, xmlChar  end2, xmlChar end3) {\n    xmlChar *buffer = NULL;\n    size_t buffer_size = 0;\n    size_t nbchars = 0;\n\n    xmlChar *current = NULL;\n    xmlChar *rep = NULL;\n    const xmlChar *last;\n    xmlEntityPtr ent;\n    int c,l;\n\n    if ((ctxt == NULL) || (str == NULL) || (len < 0))\n\treturn(NULL);\n    last = str + len;\n\n    if (((ctxt->depth > 40) &&\n         ((ctxt->options & XML_PARSE_HUGE) == 0)) ||\n\t(ctxt->depth > 1024)) {\n\txmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n\treturn(NULL);\n    }\n\n    /*\n     * allocate a translation buffer.\n     */\n    buffer_size = XML_PARSER_BIG_BUFFER_SIZE;\n    buffer = (xmlChar *) xmlMallocAtomic(buffer_size);\n    if (buffer == NULL) goto mem_error;\n\n    /*\n     * OK loop until we reach one of the ending char or a size limit.\n     * we are operating on already parsed values.\n     */\n    if (str < last)\n\tc = CUR_SCHAR(str, l);\n    else\n        c = 0;\n    while ((c != 0) && (c != end) && /* non input consuming loop */\n\t   (c != end2) && (c != end3)) {\n\n\tif (c == 0) break;\n        if ((c == '&') && (str[1] == '#')) {\n\t    int val = xmlParseStringCharRef(ctxt, &str);\n\t    if (val == 0)\n                goto int_error;\n\t    COPY_BUF(0,buffer,nbchars,val);\n\t    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {\n\t        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t    }\n\t} else if ((c == '&') && (what & XML_SUBSTITUTE_REF)) {\n\t    if (xmlParserDebugEntities)\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"String decoding Entity Reference: %.30s\\n\",\n\t\t\tstr);\n\t    ent = xmlParseStringEntityRef(ctxt, &str);\n\t    xmlParserEntityCheck(ctxt, 0, ent, 0);\n\t    if (ent != NULL)\n\t        ctxt->nbentities += ent->checked / 2;\n\t    if ((ent != NULL) &&\n\t\t(ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n\t\tif (ent->content != NULL) {\n\t\t    COPY_BUF(0,buffer,nbchars,ent->content[0]);\n\t\t    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {\n\t\t\tgrowBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t\t    }\n\t\t} else {\n\t\t    xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t\t    \"predefined entity has no content\\n\");\n                    goto int_error;\n\t\t}\n\t    } else if ((ent != NULL) && (ent->content != NULL)) {\n\t\tctxt->depth++;\n\t\trep = xmlStringDecodeEntities(ctxt, ent->content, what,\n\t\t\t                      0, 0, 0);\n\t\tctxt->depth--;\n\t\tif (rep == NULL)\n                    goto int_error;\n\n                current = rep;\n                while (*current != 0) { /* non input consuming loop */\n                    buffer[nbchars++] = *current++;\n                    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {\n                        if (xmlParserEntityCheck(ctxt, nbchars, ent, 0))\n                            goto int_error;\n                        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n                    }\n                }\n                xmlFree(rep);\n                rep = NULL;\n\t    } else if (ent != NULL) {\n\t\tint i = xmlStrlen(ent->name);\n\t\tconst xmlChar *cur = ent->name;\n\n\t\tbuffer[nbchars++] = '&';\n\t\tif (nbchars + i + XML_PARSER_BUFFER_SIZE > buffer_size) {\n\t\t    growBuffer(buffer, i + XML_PARSER_BUFFER_SIZE);\n\t\t}\n\t\tfor (;i > 0;i--)\n\t\t    buffer[nbchars++] = *cur++;\n\t\tbuffer[nbchars++] = ';';\n\t    }\n\t} else if (c == '%' && (what & XML_SUBSTITUTE_PEREF)) {\n\t    if (xmlParserDebugEntities)\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"String decoding PE Reference: %.30s\\n\", str);\n\t    ent = xmlParseStringPEReference(ctxt, &str);\n\t    xmlParserEntityCheck(ctxt, 0, ent, 0);\n\t    if (ent != NULL)\n\t        ctxt->nbentities += ent->checked / 2;\n\t    if (ent != NULL) {\n                if (ent->content == NULL) {\n\t\t    /*\n\t\t     * Note: external parsed entities will not be loaded,\n\t\t     * it is not required for a non-validating parser to\n\t\t     * complete external PEReferences coming from the\n\t\t     * internal subset\n\t\t     */\n\t\t    if (((ctxt->options & XML_PARSE_NOENT) != 0) ||\n\t\t\t((ctxt->options & XML_PARSE_DTDVALID) != 0) ||\n\t\t\t(ctxt->validate != 0)) {\n\t\t\txmlLoadEntityContent(ctxt, ent);\n\t\t    } else {\n\t\t\txmlWarningMsg(ctxt, XML_ERR_ENTITY_PROCESSING,\n\t\t  \"not validating will not read content for PE entity %s\\n\",\n\t\t                      ent->name, NULL);\n\t\t    }\n\t\t}\n\t\tctxt->depth++;\n\t\trep = xmlStringDecodeEntities(ctxt, ent->content, what,\n\t\t\t                      0, 0, 0);\n\t\tctxt->depth--;\n\t\tif (rep == NULL)\n                    goto int_error;\n                current = rep;\n                while (*current != 0) { /* non input consuming loop */\n                    buffer[nbchars++] = *current++;\n                    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {\n                        if (xmlParserEntityCheck(ctxt, nbchars, ent, 0))\n                            goto int_error;\n                        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n                    }\n                }\n                xmlFree(rep);\n                rep = NULL;\n\t    }\n\t} else {\n\t    COPY_BUF(l,buffer,nbchars,c);\n\t    str += l;\n\t    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {\n\t        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t    }\n\t}\n\tif (str < last)\n\t    c = CUR_SCHAR(str, l);\n\telse\n\t    c = 0;\n    }\n    buffer[nbchars] = 0;\n    return(buffer);\n\nmem_error:\n    xmlErrMemory(ctxt, NULL);\nint_error:\n    if (rep != NULL)\n        xmlFree(rep);\n    if (buffer != NULL)\n        xmlFree(buffer);\n    return(NULL);\n}",
        "func": "xmlChar *\nxmlStringLenDecodeEntities(xmlParserCtxtPtr ctxt, const xmlChar *str, int len,\n\t\t      int what, xmlChar end, xmlChar  end2, xmlChar end3) {\n    xmlChar *buffer = NULL;\n    size_t buffer_size = 0;\n    size_t nbchars = 0;\n\n    xmlChar *current = NULL;\n    xmlChar *rep = NULL;\n    const xmlChar *last;\n    xmlEntityPtr ent;\n    int c,l;\n\n    if ((ctxt == NULL) || (str == NULL) || (len < 0))\n\treturn(NULL);\n    last = str + len;\n\n    if (((ctxt->depth > 40) &&\n         ((ctxt->options & XML_PARSE_HUGE) == 0)) ||\n\t(ctxt->depth > 1024)) {\n\txmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n\treturn(NULL);\n    }\n\n    /*\n     * allocate a translation buffer.\n     */\n    buffer_size = XML_PARSER_BIG_BUFFER_SIZE;\n    buffer = (xmlChar *) xmlMallocAtomic(buffer_size);\n    if (buffer == NULL) goto mem_error;\n\n    /*\n     * OK loop until we reach one of the ending char or a size limit.\n     * we are operating on already parsed values.\n     */\n    if (str < last)\n\tc = CUR_SCHAR(str, l);\n    else\n        c = 0;\n    while ((c != 0) && (c != end) && /* non input consuming loop */\n           (c != end2) && (c != end3) &&\n           (ctxt->instate != XML_PARSER_EOF)) {\n\n\tif (c == 0) break;\n        if ((c == '&') && (str[1] == '#')) {\n\t    int val = xmlParseStringCharRef(ctxt, &str);\n\t    if (val == 0)\n                goto int_error;\n\t    COPY_BUF(0,buffer,nbchars,val);\n\t    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {\n\t        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t    }\n\t} else if ((c == '&') && (what & XML_SUBSTITUTE_REF)) {\n\t    if (xmlParserDebugEntities)\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"String decoding Entity Reference: %.30s\\n\",\n\t\t\tstr);\n\t    ent = xmlParseStringEntityRef(ctxt, &str);\n\t    xmlParserEntityCheck(ctxt, 0, ent, 0);\n\t    if (ent != NULL)\n\t        ctxt->nbentities += ent->checked / 2;\n\t    if ((ent != NULL) &&\n\t\t(ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n\t\tif (ent->content != NULL) {\n\t\t    COPY_BUF(0,buffer,nbchars,ent->content[0]);\n\t\t    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {\n\t\t\tgrowBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t\t    }\n\t\t} else {\n\t\t    xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,\n\t\t\t    \"predefined entity has no content\\n\");\n                    goto int_error;\n\t\t}\n\t    } else if ((ent != NULL) && (ent->content != NULL)) {\n\t\tctxt->depth++;\n\t\trep = xmlStringDecodeEntities(ctxt, ent->content, what,\n\t\t\t                      0, 0, 0);\n\t\tctxt->depth--;\n\t\tif (rep == NULL)\n                    goto int_error;\n\n                current = rep;\n                while (*current != 0) { /* non input consuming loop */\n                    buffer[nbchars++] = *current++;\n                    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {\n                        if (xmlParserEntityCheck(ctxt, nbchars, ent, 0))\n                            goto int_error;\n                        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n                    }\n                }\n                xmlFree(rep);\n                rep = NULL;\n\t    } else if (ent != NULL) {\n\t\tint i = xmlStrlen(ent->name);\n\t\tconst xmlChar *cur = ent->name;\n\n\t\tbuffer[nbchars++] = '&';\n\t\tif (nbchars + i + XML_PARSER_BUFFER_SIZE > buffer_size) {\n\t\t    growBuffer(buffer, i + XML_PARSER_BUFFER_SIZE);\n\t\t}\n\t\tfor (;i > 0;i--)\n\t\t    buffer[nbchars++] = *cur++;\n\t\tbuffer[nbchars++] = ';';\n\t    }\n\t} else if (c == '%' && (what & XML_SUBSTITUTE_PEREF)) {\n\t    if (xmlParserDebugEntities)\n\t\txmlGenericError(xmlGenericErrorContext,\n\t\t\t\"String decoding PE Reference: %.30s\\n\", str);\n\t    ent = xmlParseStringPEReference(ctxt, &str);\n\t    xmlParserEntityCheck(ctxt, 0, ent, 0);\n\t    if (ent != NULL)\n\t        ctxt->nbentities += ent->checked / 2;\n\t    if (ent != NULL) {\n                if (ent->content == NULL) {\n\t\t    /*\n\t\t     * Note: external parsed entities will not be loaded,\n\t\t     * it is not required for a non-validating parser to\n\t\t     * complete external PEReferences coming from the\n\t\t     * internal subset\n\t\t     */\n\t\t    if (((ctxt->options & XML_PARSE_NOENT) != 0) ||\n\t\t\t((ctxt->options & XML_PARSE_DTDVALID) != 0) ||\n\t\t\t(ctxt->validate != 0)) {\n\t\t\txmlLoadEntityContent(ctxt, ent);\n\t\t    } else {\n\t\t\txmlWarningMsg(ctxt, XML_ERR_ENTITY_PROCESSING,\n\t\t  \"not validating will not read content for PE entity %s\\n\",\n\t\t                      ent->name, NULL);\n\t\t    }\n\t\t}\n\t\tctxt->depth++;\n\t\trep = xmlStringDecodeEntities(ctxt, ent->content, what,\n\t\t\t                      0, 0, 0);\n\t\tctxt->depth--;\n\t\tif (rep == NULL)\n                    goto int_error;\n                current = rep;\n                while (*current != 0) { /* non input consuming loop */\n                    buffer[nbchars++] = *current++;\n                    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {\n                        if (xmlParserEntityCheck(ctxt, nbchars, ent, 0))\n                            goto int_error;\n                        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n                    }\n                }\n                xmlFree(rep);\n                rep = NULL;\n\t    }\n\t} else {\n\t    COPY_BUF(l,buffer,nbchars,c);\n\t    str += l;\n\t    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {\n\t        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n\t    }\n\t}\n\tif (str < last)\n\t    c = CUR_SCHAR(str, l);\n\telse\n\t    c = 0;\n    }\n    buffer[nbchars] = 0;\n    return(buffer);\n\nmem_error:\n    xmlErrMemory(ctxt, NULL);\nint_error:\n    if (rep != NULL)\n        xmlFree(rep);\n    if (buffer != NULL)\n        xmlFree(buffer);\n    return(NULL);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -38,7 +38,8 @@\n     else\n         c = 0;\n     while ((c != 0) && (c != end) && /* non input consuming loop */\n-\t   (c != end2) && (c != end3)) {\n+           (c != end2) && (c != end3) &&\n+           (ctxt->instate != XML_PARSER_EOF)) {\n \n \tif (c == 0) break;\n         if ((c == '&') && (str[1] == '#')) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t   (c != end2) && (c != end3)) {"
            ],
            "added_lines": [
                "           (c != end2) && (c != end3) &&",
                "           (ctxt->instate != XML_PARSER_EOF)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-5239",
        "func_name": "qemu/protocol_client_msg",
        "description": "Integer overflow in the VNC display driver in QEMU before 2.1.0 allows attachers to cause a denial of service (process crash) via a CLIENT_CUT_TEXT message, which triggers an infinite loop.",
        "git_url": "https://github.com/qemu/qemu/commit/f9a70e79391f6d7c2a912d785239ee8effc1922d",
        "commit_title": "ui/vnc: limit client_cut_text msg payload size",
        "commit_text": " currently a malicious client could define a payload size of 2^32 - 1 bytes and send up to that size of data to the vnc server. The server would allocated that amount of memory which could easily create an out of memory condition.  This patch limits the payload size to 1MB max.  Please note that client_cut_text messages are currently silently ignored. ",
        "func_before": "static int protocol_client_msg(VncState *vs, uint8_t *data, size_t len)\n{\n    int i;\n    uint16_t limit;\n    VncDisplay *vd = vs->vd;\n\n    if (data[0] > 3) {\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n    }\n\n    switch (data[0]) {\n    case VNC_MSG_CLIENT_SET_PIXEL_FORMAT:\n        if (len == 1)\n            return 20;\n\n        set_pixel_format(vs, read_u8(data, 4), read_u8(data, 5),\n                         read_u8(data, 6), read_u8(data, 7),\n                         read_u16(data, 8), read_u16(data, 10),\n                         read_u16(data, 12), read_u8(data, 14),\n                         read_u8(data, 15), read_u8(data, 16));\n        break;\n    case VNC_MSG_CLIENT_SET_ENCODINGS:\n        if (len == 1)\n            return 4;\n\n        if (len == 4) {\n            limit = read_u16(data, 2);\n            if (limit > 0)\n                return 4 + (limit * 4);\n        } else\n            limit = read_u16(data, 2);\n\n        for (i = 0; i < limit; i++) {\n            int32_t val = read_s32(data, 4 + (i * 4));\n            memcpy(data + 4 + (i * 4), &val, sizeof(val));\n        }\n\n        set_encodings(vs, (int32_t *)(data + 4), limit);\n        break;\n    case VNC_MSG_CLIENT_FRAMEBUFFER_UPDATE_REQUEST:\n        if (len == 1)\n            return 10;\n\n        framebuffer_update_request(vs,\n                                   read_u8(data, 1), read_u16(data, 2), read_u16(data, 4),\n                                   read_u16(data, 6), read_u16(data, 8));\n        break;\n    case VNC_MSG_CLIENT_KEY_EVENT:\n        if (len == 1)\n            return 8;\n\n        key_event(vs, read_u8(data, 1), read_u32(data, 4));\n        break;\n    case VNC_MSG_CLIENT_POINTER_EVENT:\n        if (len == 1)\n            return 6;\n\n        pointer_event(vs, read_u8(data, 1), read_u16(data, 2), read_u16(data, 4));\n        break;\n    case VNC_MSG_CLIENT_CUT_TEXT:\n        if (len == 1)\n            return 8;\n\n        if (len == 8) {\n            uint32_t dlen = read_u32(data, 4);\n            if (dlen > 0)\n                return 8 + dlen;\n        }\n\n        client_cut_text(vs, read_u32(data, 4), data + 8);\n        break;\n    case VNC_MSG_CLIENT_QEMU:\n        if (len == 1)\n            return 2;\n\n        switch (read_u8(data, 1)) {\n        case VNC_MSG_CLIENT_QEMU_EXT_KEY_EVENT:\n            if (len == 2)\n                return 12;\n\n            ext_key_event(vs, read_u16(data, 2),\n                          read_u32(data, 4), read_u32(data, 8));\n            break;\n        case VNC_MSG_CLIENT_QEMU_AUDIO:\n            if (len == 2)\n                return 4;\n\n            switch (read_u16 (data, 2)) {\n            case VNC_MSG_CLIENT_QEMU_AUDIO_ENABLE:\n                audio_add(vs);\n                break;\n            case VNC_MSG_CLIENT_QEMU_AUDIO_DISABLE:\n                audio_del(vs);\n                break;\n            case VNC_MSG_CLIENT_QEMU_AUDIO_SET_FORMAT:\n                if (len == 4)\n                    return 10;\n                switch (read_u8(data, 4)) {\n                case 0: vs->as.fmt = AUD_FMT_U8; break;\n                case 1: vs->as.fmt = AUD_FMT_S8; break;\n                case 2: vs->as.fmt = AUD_FMT_U16; break;\n                case 3: vs->as.fmt = AUD_FMT_S16; break;\n                case 4: vs->as.fmt = AUD_FMT_U32; break;\n                case 5: vs->as.fmt = AUD_FMT_S32; break;\n                default:\n                    printf(\"Invalid audio format %d\\n\", read_u8(data, 4));\n                    vnc_client_error(vs);\n                    break;\n                }\n                vs->as.nchannels = read_u8(data, 5);\n                if (vs->as.nchannels != 1 && vs->as.nchannels != 2) {\n                    printf(\"Invalid audio channel coount %d\\n\",\n                           read_u8(data, 5));\n                    vnc_client_error(vs);\n                    break;\n                }\n                vs->as.freq = read_u32(data, 6);\n                break;\n            default:\n                printf (\"Invalid audio message %d\\n\", read_u8(data, 4));\n                vnc_client_error(vs);\n                break;\n            }\n            break;\n\n        default:\n            printf(\"Msg: %d\\n\", read_u16(data, 0));\n            vnc_client_error(vs);\n            break;\n        }\n        break;\n    default:\n        printf(\"Msg: %d\\n\", data[0]);\n        vnc_client_error(vs);\n        break;\n    }\n\n    vnc_read_when(vs, protocol_client_msg, 1);\n    return 0;\n}",
        "func": "static int protocol_client_msg(VncState *vs, uint8_t *data, size_t len)\n{\n    int i;\n    uint16_t limit;\n    VncDisplay *vd = vs->vd;\n\n    if (data[0] > 3) {\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n    }\n\n    switch (data[0]) {\n    case VNC_MSG_CLIENT_SET_PIXEL_FORMAT:\n        if (len == 1)\n            return 20;\n\n        set_pixel_format(vs, read_u8(data, 4), read_u8(data, 5),\n                         read_u8(data, 6), read_u8(data, 7),\n                         read_u16(data, 8), read_u16(data, 10),\n                         read_u16(data, 12), read_u8(data, 14),\n                         read_u8(data, 15), read_u8(data, 16));\n        break;\n    case VNC_MSG_CLIENT_SET_ENCODINGS:\n        if (len == 1)\n            return 4;\n\n        if (len == 4) {\n            limit = read_u16(data, 2);\n            if (limit > 0)\n                return 4 + (limit * 4);\n        } else\n            limit = read_u16(data, 2);\n\n        for (i = 0; i < limit; i++) {\n            int32_t val = read_s32(data, 4 + (i * 4));\n            memcpy(data + 4 + (i * 4), &val, sizeof(val));\n        }\n\n        set_encodings(vs, (int32_t *)(data + 4), limit);\n        break;\n    case VNC_MSG_CLIENT_FRAMEBUFFER_UPDATE_REQUEST:\n        if (len == 1)\n            return 10;\n\n        framebuffer_update_request(vs,\n                                   read_u8(data, 1), read_u16(data, 2), read_u16(data, 4),\n                                   read_u16(data, 6), read_u16(data, 8));\n        break;\n    case VNC_MSG_CLIENT_KEY_EVENT:\n        if (len == 1)\n            return 8;\n\n        key_event(vs, read_u8(data, 1), read_u32(data, 4));\n        break;\n    case VNC_MSG_CLIENT_POINTER_EVENT:\n        if (len == 1)\n            return 6;\n\n        pointer_event(vs, read_u8(data, 1), read_u16(data, 2), read_u16(data, 4));\n        break;\n    case VNC_MSG_CLIENT_CUT_TEXT:\n        if (len == 1) {\n            return 8;\n        }\n        if (len == 8) {\n            uint32_t dlen = read_u32(data, 4);\n            if (dlen > (1 << 20)) {\n                error_report(\"vnc: client_cut_text msg payload has %u bytes\"\n                             \" which exceeds our limit of 1MB.\", dlen);\n                vnc_client_error(vs);\n                break;\n            }\n            if (dlen > 0) {\n                return 8 + dlen;\n            }\n        }\n\n        client_cut_text(vs, read_u32(data, 4), data + 8);\n        break;\n    case VNC_MSG_CLIENT_QEMU:\n        if (len == 1)\n            return 2;\n\n        switch (read_u8(data, 1)) {\n        case VNC_MSG_CLIENT_QEMU_EXT_KEY_EVENT:\n            if (len == 2)\n                return 12;\n\n            ext_key_event(vs, read_u16(data, 2),\n                          read_u32(data, 4), read_u32(data, 8));\n            break;\n        case VNC_MSG_CLIENT_QEMU_AUDIO:\n            if (len == 2)\n                return 4;\n\n            switch (read_u16 (data, 2)) {\n            case VNC_MSG_CLIENT_QEMU_AUDIO_ENABLE:\n                audio_add(vs);\n                break;\n            case VNC_MSG_CLIENT_QEMU_AUDIO_DISABLE:\n                audio_del(vs);\n                break;\n            case VNC_MSG_CLIENT_QEMU_AUDIO_SET_FORMAT:\n                if (len == 4)\n                    return 10;\n                switch (read_u8(data, 4)) {\n                case 0: vs->as.fmt = AUD_FMT_U8; break;\n                case 1: vs->as.fmt = AUD_FMT_S8; break;\n                case 2: vs->as.fmt = AUD_FMT_U16; break;\n                case 3: vs->as.fmt = AUD_FMT_S16; break;\n                case 4: vs->as.fmt = AUD_FMT_U32; break;\n                case 5: vs->as.fmt = AUD_FMT_S32; break;\n                default:\n                    printf(\"Invalid audio format %d\\n\", read_u8(data, 4));\n                    vnc_client_error(vs);\n                    break;\n                }\n                vs->as.nchannels = read_u8(data, 5);\n                if (vs->as.nchannels != 1 && vs->as.nchannels != 2) {\n                    printf(\"Invalid audio channel coount %d\\n\",\n                           read_u8(data, 5));\n                    vnc_client_error(vs);\n                    break;\n                }\n                vs->as.freq = read_u32(data, 6);\n                break;\n            default:\n                printf (\"Invalid audio message %d\\n\", read_u8(data, 4));\n                vnc_client_error(vs);\n                break;\n            }\n            break;\n\n        default:\n            printf(\"Msg: %d\\n\", read_u16(data, 0));\n            vnc_client_error(vs);\n            break;\n        }\n        break;\n    default:\n        printf(\"Msg: %d\\n\", data[0]);\n        vnc_client_error(vs);\n        break;\n    }\n\n    vnc_read_when(vs, protocol_client_msg, 1);\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -58,13 +58,20 @@\n         pointer_event(vs, read_u8(data, 1), read_u16(data, 2), read_u16(data, 4));\n         break;\n     case VNC_MSG_CLIENT_CUT_TEXT:\n-        if (len == 1)\n+        if (len == 1) {\n             return 8;\n-\n+        }\n         if (len == 8) {\n             uint32_t dlen = read_u32(data, 4);\n-            if (dlen > 0)\n+            if (dlen > (1 << 20)) {\n+                error_report(\"vnc: client_cut_text msg payload has %u bytes\"\n+                             \" which exceeds our limit of 1MB.\", dlen);\n+                vnc_client_error(vs);\n+                break;\n+            }\n+            if (dlen > 0) {\n                 return 8 + dlen;\n+            }\n         }\n \n         client_cut_text(vs, read_u32(data, 4), data + 8);",
        "diff_line_info": {
            "deleted_lines": [
                "        if (len == 1)",
                "",
                "            if (dlen > 0)"
            ],
            "added_lines": [
                "        if (len == 1) {",
                "        }",
                "            if (dlen > (1 << 20)) {",
                "                error_report(\"vnc: client_cut_text msg payload has %u bytes\"",
                "                             \" which exceeds our limit of 1MB.\", dlen);",
                "                vnc_client_error(vs);",
                "                break;",
                "            }",
                "            if (dlen > 0) {",
                "            }"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-3722",
        "func_name": "OpenSIPS/opensips/lookup",
        "description": "A Denial of Service (infinite loop) exists in OpenSIPS before 1.10 in lookup.c.",
        "git_url": "https://github.com/OpenSIPS/opensips/commit/54e027adfa486cfcf993828512b2e273aeb163c2",
        "commit_title": "backport from 1.9 (rev #9980)",
        "commit_text": "fixed temporary GRUU bug that lead to infinite loop Credits to Tolga Tarhan   ",
        "func_before": "int lookup(struct sip_msg* _m, char* _t, char* _f, char* _s)\n{\n\tunsigned int flags;\n\turecord_t* r;\n\tstr aor, uri;\n\tucontact_t* ptr,*it;\n\tint res;\n\tint ret;\n\tstr path_dst;\n\tstr flags_s;\n\tpv_value_t val;\n\tint_str istr;\n\tstr sip_instance = {0,0},call_id = {0,0};\n\n\tflags = 0;\n\tif (_f && _f[0]!=0) {\n\t\tif (fixup_get_svalue( _m, (gparam_p)_f, &flags_s)!=0) {\n\t\t\tLM_ERR(\"invalid owner uri parameter\");\n\t\t\treturn -1;\n\t\t}\n\t\tfor( res=0 ; res< flags_s.len ; res++ ) {\n\t\t\tswitch (flags_s.s[res]) {\n\t\t\t\tcase 'm': flags |= REG_LOOKUP_METHODFILTER_FLAG; break;\n\t\t\t\tcase 'b': flags |= REG_LOOKUP_NOBRANCH_FLAG; break;\n\t\t\t\tdefault: LM_WARN(\"unsuported flag %c \\n\",flags_s.s[res]);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (_s) {\n\t\tif (pv_get_spec_value( _m, (pv_spec_p)_s, &val)!=0) {\n\t\t\tLM_ERR(\"failed to get PV value\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif ( (val.flags&PV_VAL_STR)==0 ) {\n\t\t\tLM_ERR(\"PV vals is not string\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\turi = val.rs;\n\t} else {\n\t\tif (_m->new_uri.s) uri = _m->new_uri;\n\t\telse uri = _m->first_line.u.request.uri;\n\t}\n\n\tif (extract_aor(&uri, &aor,&sip_instance,&call_id) < 0) {\n\t\tLM_ERR(\"failed to extract address of record\\n\");\n\t\treturn -3;\n\t}\n\n\tget_act_time();\n\n\tul.lock_udomain((udomain_t*)_t, &aor);\n\tres = ul.get_urecord((udomain_t*)_t, &aor, &r);\n\tif (res > 0) {\n\t\tLM_DBG(\"'%.*s' Not found in usrloc\\n\", aor.len, ZSW(aor.s));\n\t\tul.unlock_udomain((udomain_t*)_t, &aor);\n\t\treturn -1;\n\t}\n\n\tptr = r->contacts;\n\tret = -1;\n\t/* look first for an un-expired and suported contact */\nsearch_valid_contact:\n\twhile ( (ptr) &&\n\t!(VALID_CONTACT(ptr,act_time) && (ret=-2) && allowed_method(_m,ptr,flags)))\n\t\tptr = ptr->next;\n\tif (ptr==0) {\n\t\t/* nothing found */\n\t\tLM_DBG(\"nothing found !\\n\");\n\t\tgoto done;\n\t}\n\n\tif (sip_instance.len && sip_instance.s) {\n\t\tLM_DBG(\"ruri has gruu in lookup\\n\");\n\t\t/* uri has GRUU */\n\t\tif (ptr->instance.len-2 != sip_instance.len || \n\t\t\t\tmemcmp(ptr->instance.s+1,sip_instance.s,sip_instance.len)) {\n\t\t\tLM_DBG(\"no match to sip instace - [%.*s] - [%.*s]\\n\",ptr->instance.len-2,ptr->instance.s+1,\n\t\t\t\t\tsip_instance.len,sip_instance.s);\n\t\t\t/* not the targeted instance, search some more */\n\t\t\tptr = ptr->next;\n\t\t\tgoto search_valid_contact;\n\t\t}\n\n\t\tLM_DBG(\"matched sip instace\\n\");\n\t}\n\n\tif (call_id.len && call_id.s) {\n\t\t/* decide whether GRUU is expired or not\n\t\t *\n\t\t * first - match call-id */\n\t\tif (ptr->callid.len != call_id.len ||\n\t\t\t\tmemcmp(ptr->callid.s,call_id.s,call_id.len)) {\n\t\t\tLM_DBG(\"no match to call id - [%.*s] - [%.*s]\\n\",ptr->callid.len,ptr->callid.s,\n\t\t\t\t\tcall_id.len,call_id.s);\n\t\t\tptr = ptr->next;\n\t\t\tgoto search_valid_contact;\n\t\t}\n\n\t\t/* matched call-id, check if there are newer contacts with\n\t\t * same sip instace bup newer last_modified */\n\n\t\tit = ptr->next;\n\t\twhile ( it ) {\n\t\t\tif (VALID_CONTACT(it,act_time)) {\n\t\t\t\tif (it->instance.len-2 == sip_instance.len &&\n\t\t\t\t\t\tmemcmp(it->instance.s+1,sip_instance.s,sip_instance.len) == 0)\n\t\t\t\t\tif (it->last_modified > ptr->last_modified) {\n\t\t\t\t\t\t/* same instance id, but newer modified -> expired GRUU, no match at all */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (it != NULL) {\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tLM_DBG(\"found a complete match\\n\");\n\n\tret = 1;\n\tif (ptr) {\n\t\tLM_DBG(\"setting as ruri <%.*s>\\n\",ptr->c.len,ptr->c.s);\n\t\tif (set_ruri(_m, &ptr->c) < 0) {\n\t\t\tLM_ERR(\"unable to rewrite Request-URI\\n\");\n\t\t\tret = -3;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* If a Path is present, use first path-uri in favour of\n\t\t * received-uri because in that case the last hop towards the uac\n\t\t * has to handle NAT. - agranig */\n\t\tif (ptr->path.s && ptr->path.len) {\n\t\t\tif (get_path_dst_uri(&ptr->path, &path_dst) < 0) {\n\t\t\t\tLM_ERR(\"failed to get dst_uri for Path\\n\");\n\t\t\t\tret = -3;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (set_path_vector(_m, &ptr->path) < 0) {\n\t\t\t\tLM_ERR(\"failed to set path vector\\n\");\n\t\t\t\tret = -3;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (set_dst_uri(_m, &path_dst) < 0) {\n\t\t\t\tLM_ERR(\"failed to set dst_uri of Path\\n\");\n\t\t\t\tret = -3;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else if (ptr->received.s && ptr->received.len) {\n\t\t\tif (set_dst_uri(_m, &ptr->received) < 0) {\n\t\t\t\tret = -3;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\tset_ruri_q(ptr->q);\n\n\t\tsetbflag( 0, ptr->cflags);\n\n\t\tif (ptr->sock)\n\t\t\t_m->force_send_socket = ptr->sock;\n\n\t\t/* populate the 'attributes' avp */\n\t\tif (attr_avp_name != -1) {\n\t\t\tistr.s = ptr->attr;\n\t\t\tif (add_avp_last(AVP_VAL_STR, attr_avp_name, istr) != 0) {\n\t\t\t\tLM_ERR(\"Failed to populate attr avp!\\n\");\n\t\t\t}\n\t\t}\n\n\t\tptr = ptr->next;\n\t}\n\n\t/* Append branches if enabled */\n\t/* If we got to this point and the URI had a ;gr parameter and it was matched\n\t * to a contact. No point in branching */\n\tif ( flags&REG_LOOKUP_NOBRANCH_FLAG || (sip_instance.len && sip_instance.s) ) goto done;\n\tLM_DBG(\"looking for branches\\n\");\n\n\tfor( ; ptr ; ptr = ptr->next ) {\n\t\tif (VALID_CONTACT(ptr, act_time) && allowed_method(_m,ptr,flags)) {\n\t\t\tpath_dst.len = 0;\n\t\t\tif(ptr->path.s && ptr->path.len \n\t\t\t&& get_path_dst_uri(&ptr->path, &path_dst) < 0) {\n\t\t\t\tLM_ERR(\"failed to get dst_uri for Path\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* The same as for the first contact applies for branches \n\t\t\t * regarding path vs. received. */\n\t\t\tLM_DBG(\"setting branch <%.*s>\\n\",ptr->c.len,ptr->c.s);\n\t\t\tif (append_branch(_m,&ptr->c,path_dst.len?&path_dst:&ptr->received,\n\t\t\t&ptr->path, ptr->q, ptr->cflags, ptr->sock) == -1) {\n\t\t\t\tLM_ERR(\"failed to append a branch\\n\");\n\t\t\t\t/* Also give a chance to the next branches*/\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* populate the 'attributes' avp */\n\t\t\tif (attr_avp_name != -1) {\n\t\t\t\tistr.s = ptr->attr;\n\t\t\t\tif (add_avp_last(AVP_VAL_STR, attr_avp_name, istr) != 0) {\n\t\t\t\t\tLM_ERR(\"Failed to populate attr avp!\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\tul.release_urecord(r);\n\tul.unlock_udomain((udomain_t*)_t, &aor);\n\treturn ret;\n}",
        "func": "int lookup(struct sip_msg* _m, char* _t, char* _f, char* _s)\n{\n\tunsigned int flags;\n\turecord_t* r;\n\tstr aor, uri;\n\tucontact_t* ptr,*it;\n\tint res;\n\tint ret;\n\tstr path_dst;\n\tstr flags_s;\n\tpv_value_t val;\n\tint_str istr;\n\tstr sip_instance = {0,0},call_id = {0,0};\n\n\tflags = 0;\n\tif (_f && _f[0]!=0) {\n\t\tif (fixup_get_svalue( _m, (gparam_p)_f, &flags_s)!=0) {\n\t\t\tLM_ERR(\"invalid owner uri parameter\");\n\t\t\treturn -1;\n\t\t}\n\t\tfor( res=0 ; res< flags_s.len ; res++ ) {\n\t\t\tswitch (flags_s.s[res]) {\n\t\t\t\tcase 'm': flags |= REG_LOOKUP_METHODFILTER_FLAG; break;\n\t\t\t\tcase 'b': flags |= REG_LOOKUP_NOBRANCH_FLAG; break;\n\t\t\t\tdefault: LM_WARN(\"unsuported flag %c \\n\",flags_s.s[res]);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (_s) {\n\t\tif (pv_get_spec_value( _m, (pv_spec_p)_s, &val)!=0) {\n\t\t\tLM_ERR(\"failed to get PV value\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tif ( (val.flags&PV_VAL_STR)==0 ) {\n\t\t\tLM_ERR(\"PV vals is not string\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\turi = val.rs;\n\t} else {\n\t\tif (_m->new_uri.s) uri = _m->new_uri;\n\t\telse uri = _m->first_line.u.request.uri;\n\t}\n\n\tif (extract_aor(&uri, &aor,&sip_instance,&call_id) < 0) {\n\t\tLM_ERR(\"failed to extract address of record\\n\");\n\t\treturn -3;\n\t}\n\n\tget_act_time();\n\n\tul.lock_udomain((udomain_t*)_t, &aor);\n\tres = ul.get_urecord((udomain_t*)_t, &aor, &r);\n\tif (res > 0) {\n\t\tLM_DBG(\"'%.*s' Not found in usrloc\\n\", aor.len, ZSW(aor.s));\n\t\tul.unlock_udomain((udomain_t*)_t, &aor);\n\t\treturn -1;\n\t}\n\n\tptr = r->contacts;\n\tret = -1;\n\t/* look first for an un-expired and suported contact */\nsearch_valid_contact:\n\twhile ( (ptr) &&\n\t!(VALID_CONTACT(ptr,act_time) && (ret=-2) && allowed_method(_m,ptr,flags)))\n\t\tptr = ptr->next;\n\tif (ptr==0) {\n\t\t/* nothing found */\n\t\tLM_DBG(\"nothing found !\\n\");\n\t\tgoto done;\n\t}\n\n\tif (sip_instance.len && sip_instance.s) {\n\t\tLM_DBG(\"ruri has gruu in lookup\\n\");\n\t\t/* uri has GRUU */\n\t\tif (ptr->instance.len-2 != sip_instance.len || \n\t\t\t\tmemcmp(ptr->instance.s+1,sip_instance.s,sip_instance.len)) {\n\t\t\tLM_DBG(\"no match to sip instace - [%.*s] - [%.*s]\\n\",ptr->instance.len-2,ptr->instance.s+1,\n\t\t\t\t\tsip_instance.len,sip_instance.s);\n\t\t\t/* not the targeted instance, search some more */\n\t\t\tptr = ptr->next;\n\t\t\tgoto search_valid_contact;\n\t\t}\n\n\t\tLM_DBG(\"matched sip instace\\n\");\n\t}\n\n\tif (call_id.len && call_id.s) {\n\t\t/* decide whether GRUU is expired or not\n\t\t *\n\t\t * first - match call-id */\n\t\tif (ptr->callid.len != call_id.len ||\n\t\t\t\tmemcmp(ptr->callid.s,call_id.s,call_id.len)) {\n\t\t\tLM_DBG(\"no match to call id - [%.*s] - [%.*s]\\n\",ptr->callid.len,ptr->callid.s,\n\t\t\t\t\tcall_id.len,call_id.s);\n\t\t\tptr = ptr->next;\n\t\t\tgoto search_valid_contact;\n\t\t}\n\n\t\t/* matched call-id, check if there are newer contacts with\n\t\t * same sip instace bup newer last_modified */\n\n\t\tit = ptr->next;\n\t\twhile ( it ) {\n\t\t\tif (VALID_CONTACT(it,act_time)) {\n\t\t\t\tif (it->instance.len-2 == sip_instance.len &&\n\t\t\t\t\t\tmemcmp(it->instance.s+1,sip_instance.s,sip_instance.len) == 0)\n\t\t\t\t\tif (it->last_modified > ptr->last_modified) {\n\t\t\t\t\t\t/* same instance id, but newer modified -> expired GRUU, no match at all */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tit=it->next;\n\t\t}\n\n\t\tif (it != NULL) {\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tLM_DBG(\"found a complete match\\n\");\n\n\tret = 1;\n\tif (ptr) {\n\t\tLM_DBG(\"setting as ruri <%.*s>\\n\",ptr->c.len,ptr->c.s);\n\t\tif (set_ruri(_m, &ptr->c) < 0) {\n\t\t\tLM_ERR(\"unable to rewrite Request-URI\\n\");\n\t\t\tret = -3;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* If a Path is present, use first path-uri in favour of\n\t\t * received-uri because in that case the last hop towards the uac\n\t\t * has to handle NAT. - agranig */\n\t\tif (ptr->path.s && ptr->path.len) {\n\t\t\tif (get_path_dst_uri(&ptr->path, &path_dst) < 0) {\n\t\t\t\tLM_ERR(\"failed to get dst_uri for Path\\n\");\n\t\t\t\tret = -3;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (set_path_vector(_m, &ptr->path) < 0) {\n\t\t\t\tLM_ERR(\"failed to set path vector\\n\");\n\t\t\t\tret = -3;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (set_dst_uri(_m, &path_dst) < 0) {\n\t\t\t\tLM_ERR(\"failed to set dst_uri of Path\\n\");\n\t\t\t\tret = -3;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else if (ptr->received.s && ptr->received.len) {\n\t\t\tif (set_dst_uri(_m, &ptr->received) < 0) {\n\t\t\t\tret = -3;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\tset_ruri_q(ptr->q);\n\n\t\tsetbflag( 0, ptr->cflags);\n\n\t\tif (ptr->sock)\n\t\t\t_m->force_send_socket = ptr->sock;\n\n\t\t/* populate the 'attributes' avp */\n\t\tif (attr_avp_name != -1) {\n\t\t\tistr.s = ptr->attr;\n\t\t\tif (add_avp_last(AVP_VAL_STR, attr_avp_name, istr) != 0) {\n\t\t\t\tLM_ERR(\"Failed to populate attr avp!\\n\");\n\t\t\t}\n\t\t}\n\n\t\tptr = ptr->next;\n\t}\n\n\t/* Append branches if enabled */\n\t/* If we got to this point and the URI had a ;gr parameter and it was matched\n\t * to a contact. No point in branching */\n\tif ( flags&REG_LOOKUP_NOBRANCH_FLAG || (sip_instance.len && sip_instance.s) ) goto done;\n\tLM_DBG(\"looking for branches\\n\");\n\n\tfor( ; ptr ; ptr = ptr->next ) {\n\t\tif (VALID_CONTACT(ptr, act_time) && allowed_method(_m,ptr,flags)) {\n\t\t\tpath_dst.len = 0;\n\t\t\tif(ptr->path.s && ptr->path.len \n\t\t\t&& get_path_dst_uri(&ptr->path, &path_dst) < 0) {\n\t\t\t\tLM_ERR(\"failed to get dst_uri for Path\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* The same as for the first contact applies for branches \n\t\t\t * regarding path vs. received. */\n\t\t\tLM_DBG(\"setting branch <%.*s>\\n\",ptr->c.len,ptr->c.s);\n\t\t\tif (append_branch(_m,&ptr->c,path_dst.len?&path_dst:&ptr->received,\n\t\t\t&ptr->path, ptr->q, ptr->cflags, ptr->sock) == -1) {\n\t\t\t\tLM_ERR(\"failed to append a branch\\n\");\n\t\t\t\t/* Also give a chance to the next branches*/\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* populate the 'attributes' avp */\n\t\t\tif (attr_avp_name != -1) {\n\t\t\t\tistr.s = ptr->attr;\n\t\t\t\tif (add_avp_last(AVP_VAL_STR, attr_avp_name, istr) != 0) {\n\t\t\t\t\tLM_ERR(\"Failed to populate attr avp!\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\tul.release_urecord(r);\n\tul.unlock_udomain((udomain_t*)_t, &aor);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -110,6 +110,7 @@\n \t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n \t\t\t}\n+\t\t\tit=it->next;\n \t\t}\n \n \t\tif (it != NULL) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\tit=it->next;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-28030",
        "func_name": "wireshark/dissect_fb_zero_tag",
        "description": "In Wireshark 3.2.0 to 3.2.7, the GQUIC dissector could crash. This was addressed in epan/dissectors/packet-gquic.c by correcting the implementation of offset advancement.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/3ff940652962c099b73ae3233322b8697b0d10ab",
        "commit_title": "FBZERO: Make sure our offset advances.",
        "commit_text": " Make sure our offset advances so that we don't infinitely loop. Fixes #16887. ",
        "func_before": "static guint32\ndissect_fb_zero_tag(tvbuff_t *tvb, packet_info *pinfo, proto_tree *fb_zero_tree, guint offset, guint32 tag_number){\n    guint32 tag_offset_start = offset + tag_number*4*2;\n    guint32 tag_offset = 0, total_tag_len = 0;\n    gint32 tag_len;\n\n    while(tag_number){\n        proto_tree *tag_tree, *ti_len, *ti_tag, *ti_type;\n        guint32 offset_end, tag;\n        const guint8* tag_str;\n\n        ti_tag = proto_tree_add_item(fb_zero_tree, hf_fb_zero_tags, tvb, offset, 8, ENC_NA);\n        tag_tree = proto_item_add_subtree(ti_tag, ett_fb_zero_tag_value);\n        ti_type = proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_type, tvb, offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n        tag = tvb_get_ntohl(tvb, offset);\n        proto_item_append_text(ti_type, \" (%s)\", val_to_str(tag, tag_vals, \"Unknown\"));\n        proto_item_append_text(ti_tag, \": %s (%s)\", tag_str, val_to_str(tag, tag_vals, \"Unknown\"));\n        offset += 4;\n\n        proto_tree_add_item(tag_tree, hf_fb_zero_tag_offset_end, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset_end = tvb_get_letohl(tvb, offset);\n\n        tag_len = offset_end - tag_offset;\n        total_tag_len += tag_len;\n        ti_len = proto_tree_add_uint(tag_tree, hf_fb_zero_tag_length, tvb, offset, 4, tag_len);\n        proto_item_append_text(ti_tag, \" (l=%u)\", tag_len);\n        proto_item_set_generated(ti_len);\n        offset += 4;\n\n        /* Fix issue with CRT.. (Fragmentation ?) */\n        if( tag_len > tvb_reported_length_remaining(tvb, tag_offset_start + tag_offset)){\n            tag_len = tvb_reported_length_remaining(tvb, tag_offset_start + tag_offset);\n            offset_end = tag_offset + tag_len;\n            expert_add_info(pinfo, ti_len, &ei_fb_zero_tag_length);\n        }\n\n        proto_tree_add_item(tag_tree, hf_fb_zero_tag_value, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n\n        switch(tag){\n            case TAG_SNI:\n                proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_sni, tvb, tag_offset_start + tag_offset, tag_len, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += tag_len;\n            break;\n            case TAG_VERS:\n                proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_vers, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += 4;\n            break;\n            case TAG_SNO:\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_sno, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_AEAD:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree *ti_aead;\n                    ti_aead = proto_tree_add_item(tag_tree, hf_fb_zero_tag_aead, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    proto_item_append_text(ti_aead, \" (%s)\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_aead_vals, \"Unknown\"));\n                    proto_item_append_text(ti_tag, \", %s\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_aead_vals, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_SCID:\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_scid, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_TIME:\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_time, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_letohl(tvb, tag_offset_start + tag_offset));\n                tag_offset += 4;\n            break;\n            case TAG_ALPN:\n                proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_alpn, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += 4;\n            break;\n            case TAG_PUBS:\n                /*TODO FIX: 24 Length + Pubs key?.. ! */\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_pubs, tvb, tag_offset_start + tag_offset, 2, ENC_LITTLE_ENDIAN);\n                tag_offset += 2;\n                while(offset_end - tag_offset >= 3){\n                    proto_tree_add_item(tag_tree, hf_fb_zero_tag_pubs, tvb, tag_offset_start + tag_offset, 3, ENC_LITTLE_ENDIAN);\n                    tag_offset += 3;\n                }\n            break;\n            case TAG_KEXS:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree *ti_kexs;\n                    ti_kexs = proto_tree_add_item(tag_tree, hf_fb_zero_tag_kexs, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    proto_item_append_text(ti_kexs, \" (%s)\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_kexs_vals, \"Unknown\"));\n                    proto_item_append_text(ti_tag, \", %s\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_kexs_vals, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_NONC:\n                /*TODO: Enhance display: 32 bytes consisting of 4 bytes of timestamp (big-endian, UNIX epoch seconds), 8 bytes of server orbit and 20 bytes of random data. */\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_nonc, tvb, tag_offset_start + tag_offset, 32, ENC_NA);\n                tag_offset += 32;\n            break;\n\n            default:\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_unknown, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                expert_add_info_format(pinfo, ti_tag, &ei_fb_zero_tag_undecoded,\n                                 \"Dissector for FB Zero Tag\"\n                                 \" %s (%s) code not implemented, Contact\"\n                                 \" Wireshark developers if you want this supported\", tvb_get_string_enc(wmem_packet_scope(), tvb, offset-8, 4, ENC_ASCII|ENC_NA), val_to_str(tag, tag_vals, \"Unknown\"));\n                tag_offset += tag_len;\n            break;\n        }\n\n        if(tag_offset != offset_end){\n            /* Wrong Tag len... */\n            proto_tree_add_expert(tag_tree, pinfo, &ei_fb_zero_tag_unknown, tvb, tag_offset_start + tag_offset, offset_end - tag_offset);\n            tag_offset = offset_end;\n        }\n\n        tag_number--;\n    }\n    return offset + total_tag_len;\n\n}",
        "func": "static guint32\ndissect_fb_zero_tag(tvbuff_t *tvb, packet_info *pinfo, proto_tree *fb_zero_tree, guint offset, guint32 tag_number){\n    guint32 tag_offset_start = offset + tag_number*4*2;\n    guint32 tag_offset = 0, total_tag_len = 0;\n    gint32 tag_len;\n\n    while(tag_number){\n        proto_tree *tag_tree, *ti_len, *ti_tag, *ti_type;\n        guint32 offset_end, tag;\n        const guint8* tag_str;\n\n        ti_tag = proto_tree_add_item(fb_zero_tree, hf_fb_zero_tags, tvb, offset, 8, ENC_NA);\n        tag_tree = proto_item_add_subtree(ti_tag, ett_fb_zero_tag_value);\n        ti_type = proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_type, tvb, offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n        tag = tvb_get_ntohl(tvb, offset);\n        proto_item_append_text(ti_type, \" (%s)\", val_to_str(tag, tag_vals, \"Unknown\"));\n        proto_item_append_text(ti_tag, \": %s (%s)\", tag_str, val_to_str(tag, tag_vals, \"Unknown\"));\n        offset += 4;\n\n        proto_tree_add_item(tag_tree, hf_fb_zero_tag_offset_end, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset_end = tvb_get_letohl(tvb, offset);\n\n        tag_len = offset_end - tag_offset;\n        total_tag_len += tag_len;\n        ti_len = proto_tree_add_uint(tag_tree, hf_fb_zero_tag_length, tvb, offset, 4, tag_len);\n        proto_item_append_text(ti_tag, \" (l=%u)\", tag_len);\n        proto_item_set_generated(ti_len);\n        offset += 4;\n\n        /* Fix issue with CRT.. (Fragmentation ?) */\n        if( tag_len > tvb_reported_length_remaining(tvb, tag_offset_start + tag_offset)){\n            tag_len = tvb_reported_length_remaining(tvb, tag_offset_start + tag_offset);\n            offset_end = tag_offset + tag_len;\n            expert_add_info(pinfo, ti_len, &ei_fb_zero_tag_length);\n        }\n\n        proto_tree_add_item(tag_tree, hf_fb_zero_tag_value, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n\n        switch(tag){\n            case TAG_SNI:\n                proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_sni, tvb, tag_offset_start + tag_offset, tag_len, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += tag_len;\n            break;\n            case TAG_VERS:\n                proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_vers, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += 4;\n            break;\n            case TAG_SNO:\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_sno, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_AEAD:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree *ti_aead;\n                    ti_aead = proto_tree_add_item(tag_tree, hf_fb_zero_tag_aead, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    proto_item_append_text(ti_aead, \" (%s)\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_aead_vals, \"Unknown\"));\n                    proto_item_append_text(ti_tag, \", %s\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_aead_vals, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_SCID:\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_scid, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_TIME:\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_time, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_letohl(tvb, tag_offset_start + tag_offset));\n                tag_offset += 4;\n            break;\n            case TAG_ALPN:\n                proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_alpn, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += 4;\n            break;\n            case TAG_PUBS:\n                /*TODO FIX: 24 Length + Pubs key?.. ! */\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_pubs, tvb, tag_offset_start + tag_offset, 2, ENC_LITTLE_ENDIAN);\n                tag_offset += 2;\n                while(offset_end - tag_offset >= 3){\n                    proto_tree_add_item(tag_tree, hf_fb_zero_tag_pubs, tvb, tag_offset_start + tag_offset, 3, ENC_LITTLE_ENDIAN);\n                    tag_offset += 3;\n                }\n            break;\n            case TAG_KEXS:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree *ti_kexs;\n                    ti_kexs = proto_tree_add_item(tag_tree, hf_fb_zero_tag_kexs, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    proto_item_append_text(ti_kexs, \" (%s)\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_kexs_vals, \"Unknown\"));\n                    proto_item_append_text(ti_tag, \", %s\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_kexs_vals, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_NONC:\n                /*TODO: Enhance display: 32 bytes consisting of 4 bytes of timestamp (big-endian, UNIX epoch seconds), 8 bytes of server orbit and 20 bytes of random data. */\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_nonc, tvb, tag_offset_start + tag_offset, 32, ENC_NA);\n                tag_offset += 32;\n            break;\n\n            default:\n                proto_tree_add_item(tag_tree, hf_fb_zero_tag_unknown, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                expert_add_info_format(pinfo, ti_tag, &ei_fb_zero_tag_undecoded,\n                                 \"Dissector for FB Zero Tag\"\n                                 \" %s (%s) code not implemented, Contact\"\n                                 \" Wireshark developers if you want this supported\", tvb_get_string_enc(wmem_packet_scope(), tvb, offset-8, 4, ENC_ASCII|ENC_NA), val_to_str(tag, tag_vals, \"Unknown\"));\n                goto end;\n            break;\n        }\n\n        if(tag_offset != offset_end){\n            /* Wrong Tag len... */\n            proto_tree_add_expert(tag_tree, pinfo, &ei_fb_zero_tag_unknown, tvb, tag_offset_start + tag_offset, offset_end - tag_offset);\n            // XXX Return instead?\n            goto end;\n        }\n\n        tag_number--;\n    }\n\n    end:\n    if (offset + total_tag_len <= offset) {\n        expert_add_info_format(pinfo, fb_zero_tree, &ei_fb_zero_length_invalid,\n                         \"Invalid total tag length: %u\", total_tag_len);\n        return offset + tvb_reported_length_remaining(tvb, offset);\n    }\n    return offset + total_tag_len;\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -104,18 +104,26 @@\n                                  \"Dissector for FB Zero Tag\"\n                                  \" %s (%s) code not implemented, Contact\"\n                                  \" Wireshark developers if you want this supported\", tvb_get_string_enc(wmem_packet_scope(), tvb, offset-8, 4, ENC_ASCII|ENC_NA), val_to_str(tag, tag_vals, \"Unknown\"));\n-                tag_offset += tag_len;\n+                goto end;\n             break;\n         }\n \n         if(tag_offset != offset_end){\n             /* Wrong Tag len... */\n             proto_tree_add_expert(tag_tree, pinfo, &ei_fb_zero_tag_unknown, tvb, tag_offset_start + tag_offset, offset_end - tag_offset);\n-            tag_offset = offset_end;\n+            // XXX Return instead?\n+            goto end;\n         }\n \n         tag_number--;\n     }\n+\n+    end:\n+    if (offset + total_tag_len <= offset) {\n+        expert_add_info_format(pinfo, fb_zero_tree, &ei_fb_zero_length_invalid,\n+                         \"Invalid total tag length: %u\", total_tag_len);\n+        return offset + tvb_reported_length_remaining(tvb, offset);\n+    }\n     return offset + total_tag_len;\n \n }",
        "diff_line_info": {
            "deleted_lines": [
                "                tag_offset += tag_len;",
                "            tag_offset = offset_end;"
            ],
            "added_lines": [
                "                goto end;",
                "            // XXX Return instead?",
                "            goto end;",
                "",
                "    end:",
                "    if (offset + total_tag_len <= offset) {",
                "        expert_add_info_format(pinfo, fb_zero_tree, &ei_fb_zero_length_invalid,",
                "                         \"Invalid total tag length: %u\", total_tag_len);",
                "        return offset + tvb_reported_length_remaining(tvb, offset);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-28030",
        "func_name": "wireshark/proto_register_fb_zero",
        "description": "In Wireshark 3.2.0 to 3.2.7, the GQUIC dissector could crash. This was addressed in epan/dissectors/packet-gquic.c by correcting the implementation of offset advancement.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/3ff940652962c099b73ae3233322b8697b0d10ab",
        "commit_title": "FBZERO: Make sure our offset advances.",
        "commit_text": " Make sure our offset advances so that we don't infinitely loop. Fixes #16887. ",
        "func_before": "void\nproto_register_fb_zero(void)\n{\n    static hf_register_info hf[] = {\n        { &hf_fb_zero_puflags,\n            { \"Public Flags\", \"fb_zero.puflags\",\n              FT_UINT8, BASE_HEX, NULL, 0x0,\n              \"Specifying per-packet public flags\", HFILL }\n        },\n        { &hf_fb_zero_puflags_vrsn,\n            { \"Version\", \"fb_zero.puflags.version\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_VRSN,\n              \"Signifies that this packet also contains the version of the FB Zero protocol\", HFILL }\n        },\n        { &hf_fb_zero_puflags_unknown,\n            { \"Unknown\", \"fb_zero.puflags.unknown\",\n              FT_UINT8, BASE_HEX, NULL, PUFLAGS_UNKN,\n              NULL, HFILL }\n        },\n\n        { &hf_fb_zero_version,\n            { \"Version\", \"fb_zero.version\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"32 bit opaque tag that represents the version of the ZB Zero (Always QTV)\", HFILL }\n        },\n        { &hf_fb_zero_length,\n            { \"Length\", \"fb_zero.length\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag,\n            { \"Tag\", \"fb_zero.tag\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_number,\n            { \"Tag Number\", \"fb_zero.tag_number\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tags,\n            { \"Tag/value\", \"fb_zero.tags\",\n              FT_NONE, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_type,\n            { \"Tag Type\", \"fb_zero.tag_type\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_offset_end,\n            { \"Tag offset end\", \"fb_zero.tag_offset_end\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_length,\n            { \"Tag length\", \"fb_zero.tag_offset_length\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_value,\n            { \"Tag/value\", \"fb_zero.tag_value\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_sni,\n            { \"Server Name Indication\", \"fb_zero.tag.sni\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"The fully qualified DNS name of the server, canonicalised to lowercase with no trailing period\", HFILL }\n        },\n        { &hf_fb_zero_tag_vers,\n            { \"Version\", \"fb_zero.tag.version\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"Version of FB Zero supported\", HFILL }\n        },\n        { &hf_fb_zero_tag_sno,\n            { \"Server nonce\", \"fb_zero.tag.sno\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_aead,\n            { \"Authenticated encryption algorithms\", \"fb_zero.tag.aead\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"A list of tags, in preference order, specifying the AEAD primitives supported by the server\", HFILL }\n        },\n        { &hf_fb_zero_tag_scid,\n            { \"Server Config ID\", \"fb_zero.tag.scid\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"An opaque, 16-byte identifier for this server config\", HFILL }\n        },\n        { &hf_fb_zero_tag_time,\n            { \"Time\", \"fb_zero.tag.time\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_alpn,\n            { \"ALPN\", \"fb_zero.tag.alpn\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"Application-Layer Protocol Negotiation supported\", HFILL }\n        },\n        { &hf_fb_zero_tag_pubs,\n            { \"Public value\", \"fb_zero.tag.pubs\",\n              FT_UINT24, BASE_DEC_HEX, NULL, 0x0,\n              \"A list of public values, 24-bit, little-endian length prefixed\", HFILL }\n        },\n        { &hf_fb_zero_tag_kexs,\n            { \"Key exchange algorithms\", \"fb_zero.tag.kexs\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"A list of tags, in preference order, specifying the key exchange algorithms that the server supports\", HFILL }\n        },\n        { &hf_fb_zero_tag_nonc,\n            { \"Client nonce\", \"fb_zero.tag.nonc\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"32 bytes consisting of 4 bytes of timestamp (big-endian, UNIX epoch seconds), 8 bytes of server orbit and 20 bytes of random data\", HFILL }\n        },\n        { &hf_fb_zero_tag_unknown,\n            { \"Unknown tag\", \"fb_zero.tag.unknown\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_padding,\n            { \"Padding\", \"fb_zero.padding\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_payload,\n            { \"Payload\", \"fb_zero.payload\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"Fb Zero Payload..\", HFILL }\n        },\n        { &hf_fb_zero_unknown,\n            { \"Unknown\", \"fb_zero.unknown\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"Unknown Data\", HFILL }\n        },\n    };\n\n\n    static gint *ett[] = {\n        &ett_fb_zero,\n        &ett_fb_zero_puflags,\n        &ett_fb_zero_prflags,\n        &ett_fb_zero_ft,\n        &ett_fb_zero_ftflags,\n        &ett_fb_zero_tag_value\n    };\n\n    static ei_register_info ei[] = {\n        { &ei_fb_zero_tag_undecoded, { \"fb_zero.tag.undecoded\", PI_UNDECODED, PI_NOTE, \"Dissector for FB Zero Tag code not implemented, Contact Wireshark developers if you want this supported\", EXPFILL }},\n        { &ei_fb_zero_tag_length, { \"fb_zero.tag.length.truncated\", PI_MALFORMED, PI_NOTE, \"Truncated Tag Length...\", EXPFILL }},\n        { &ei_fb_zero_tag_unknown, { \"fb_zero.tag.unknown.data\", PI_UNDECODED, PI_NOTE, \"Unknown Data\", EXPFILL }},\n    };\n\n    expert_module_t *expert_fb_zero;\n\n    proto_fb_zero = proto_register_protocol(\"(Facebook) Zero Protocol\", \"FBZERO\", \"fb_zero\");\n\n    fb_zero_handle = register_dissector(\"fb_zero\", dissect_fb_zero, proto_fb_zero);\n\n    proto_register_field_array(proto_fb_zero, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n\n    expert_fb_zero = expert_register_protocol(proto_fb_zero);\n    expert_register_field_array(expert_fb_zero, ei, array_length(ei));\n}",
        "func": "void\nproto_register_fb_zero(void)\n{\n    static hf_register_info hf[] = {\n        { &hf_fb_zero_puflags,\n            { \"Public Flags\", \"fb_zero.puflags\",\n              FT_UINT8, BASE_HEX, NULL, 0x0,\n              \"Specifying per-packet public flags\", HFILL }\n        },\n        { &hf_fb_zero_puflags_vrsn,\n            { \"Version\", \"fb_zero.puflags.version\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_VRSN,\n              \"Signifies that this packet also contains the version of the FB Zero protocol\", HFILL }\n        },\n        { &hf_fb_zero_puflags_unknown,\n            { \"Unknown\", \"fb_zero.puflags.unknown\",\n              FT_UINT8, BASE_HEX, NULL, PUFLAGS_UNKN,\n              NULL, HFILL }\n        },\n\n        { &hf_fb_zero_version,\n            { \"Version\", \"fb_zero.version\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"32 bit opaque tag that represents the version of the ZB Zero (Always QTV)\", HFILL }\n        },\n        { &hf_fb_zero_length,\n            { \"Length\", \"fb_zero.length\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag,\n            { \"Tag\", \"fb_zero.tag\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_number,\n            { \"Tag Number\", \"fb_zero.tag_number\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tags,\n            { \"Tag/value\", \"fb_zero.tags\",\n              FT_NONE, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_type,\n            { \"Tag Type\", \"fb_zero.tag_type\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_offset_end,\n            { \"Tag offset end\", \"fb_zero.tag_offset_end\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_length,\n            { \"Tag length\", \"fb_zero.tag_offset_length\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_value,\n            { \"Tag/value\", \"fb_zero.tag_value\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_sni,\n            { \"Server Name Indication\", \"fb_zero.tag.sni\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"The fully qualified DNS name of the server, canonicalised to lowercase with no trailing period\", HFILL }\n        },\n        { &hf_fb_zero_tag_vers,\n            { \"Version\", \"fb_zero.tag.version\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"Version of FB Zero supported\", HFILL }\n        },\n        { &hf_fb_zero_tag_sno,\n            { \"Server nonce\", \"fb_zero.tag.sno\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_aead,\n            { \"Authenticated encryption algorithms\", \"fb_zero.tag.aead\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"A list of tags, in preference order, specifying the AEAD primitives supported by the server\", HFILL }\n        },\n        { &hf_fb_zero_tag_scid,\n            { \"Server Config ID\", \"fb_zero.tag.scid\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"An opaque, 16-byte identifier for this server config\", HFILL }\n        },\n        { &hf_fb_zero_tag_time,\n            { \"Time\", \"fb_zero.tag.time\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_tag_alpn,\n            { \"ALPN\", \"fb_zero.tag.alpn\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"Application-Layer Protocol Negotiation supported\", HFILL }\n        },\n        { &hf_fb_zero_tag_pubs,\n            { \"Public value\", \"fb_zero.tag.pubs\",\n              FT_UINT24, BASE_DEC_HEX, NULL, 0x0,\n              \"A list of public values, 24-bit, little-endian length prefixed\", HFILL }\n        },\n        { &hf_fb_zero_tag_kexs,\n            { \"Key exchange algorithms\", \"fb_zero.tag.kexs\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"A list of tags, in preference order, specifying the key exchange algorithms that the server supports\", HFILL }\n        },\n        { &hf_fb_zero_tag_nonc,\n            { \"Client nonce\", \"fb_zero.tag.nonc\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"32 bytes consisting of 4 bytes of timestamp (big-endian, UNIX epoch seconds), 8 bytes of server orbit and 20 bytes of random data\", HFILL }\n        },\n        { &hf_fb_zero_tag_unknown,\n            { \"Unknown tag\", \"fb_zero.tag.unknown\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_padding,\n            { \"Padding\", \"fb_zero.padding\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_fb_zero_payload,\n            { \"Payload\", \"fb_zero.payload\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"Fb Zero Payload..\", HFILL }\n        },\n        { &hf_fb_zero_unknown,\n            { \"Unknown\", \"fb_zero.unknown\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"Unknown Data\", HFILL }\n        },\n    };\n\n\n    static gint *ett[] = {\n        &ett_fb_zero,\n        &ett_fb_zero_puflags,\n        &ett_fb_zero_prflags,\n        &ett_fb_zero_ft,\n        &ett_fb_zero_ftflags,\n        &ett_fb_zero_tag_value\n    };\n\n    static ei_register_info ei[] = {\n        { &ei_fb_zero_tag_undecoded, { \"fb_zero.tag.undecoded\", PI_UNDECODED, PI_NOTE, \"Dissector for FB Zero Tag code not implemented, Contact Wireshark developers if you want this supported\", EXPFILL }},\n        { &ei_fb_zero_tag_length, { \"fb_zero.tag.length.truncated\", PI_MALFORMED, PI_NOTE, \"Truncated Tag Length...\", EXPFILL }},\n        { &ei_fb_zero_tag_unknown, { \"fb_zero.tag.unknown.data\", PI_UNDECODED, PI_NOTE, \"Unknown Data\", EXPFILL }},\n        { &ei_fb_zero_length_invalid, { \"fb_zero.length.invalid\", PI_PROTOCOL, PI_WARN, \"Invalid length\", EXPFILL }},\n    };\n\n    expert_module_t *expert_fb_zero;\n\n    proto_fb_zero = proto_register_protocol(\"(Facebook) Zero Protocol\", \"FBZERO\", \"fb_zero\");\n\n    fb_zero_handle = register_dissector(\"fb_zero\", dissect_fb_zero, proto_fb_zero);\n\n    proto_register_field_array(proto_fb_zero, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n\n    expert_fb_zero = expert_register_protocol(proto_fb_zero);\n    expert_register_field_array(expert_fb_zero, ei, array_length(ei));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -149,6 +149,7 @@\n         { &ei_fb_zero_tag_undecoded, { \"fb_zero.tag.undecoded\", PI_UNDECODED, PI_NOTE, \"Dissector for FB Zero Tag code not implemented, Contact Wireshark developers if you want this supported\", EXPFILL }},\n         { &ei_fb_zero_tag_length, { \"fb_zero.tag.length.truncated\", PI_MALFORMED, PI_NOTE, \"Truncated Tag Length...\", EXPFILL }},\n         { &ei_fb_zero_tag_unknown, { \"fb_zero.tag.unknown.data\", PI_UNDECODED, PI_NOTE, \"Unknown Data\", EXPFILL }},\n+        { &ei_fb_zero_length_invalid, { \"fb_zero.length.invalid\", PI_PROTOCOL, PI_WARN, \"Invalid length\", EXPFILL }},\n     };\n \n     expert_module_t *expert_fb_zero;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        { &ei_fb_zero_length_invalid, { \"fb_zero.length.invalid\", PI_PROTOCOL, PI_WARN, \"Invalid length\", EXPFILL }},"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-28030",
        "func_name": "wireshark/proto_register_gquic",
        "description": "In Wireshark 3.2.0 to 3.2.7, the GQUIC dissector could crash. This was addressed in epan/dissectors/packet-gquic.c by correcting the implementation of offset advancement.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/b287e7165e8aa89cde6ae37e7c257c5d87d16b9b",
        "commit_title": "GQUIC: make sure our tag offset advances.",
        "commit_text": " Make sure gquic tag offset advances so that we don't infinitely loop. ",
        "func_before": "void\nproto_register_gquic(void)\n{\n    module_t *gquic_module;\n\n    static hf_register_info hf[] = {\n        /* Long/Short header for Q046 */\n        { &hf_gquic_header_form,\n          { \"Header Form\", \"gquic.header_form\",\n            FT_UINT8, BASE_DEC, VALS(gquic_short_long_header_vals), 0x80,\n            \"The most significant bit (0x80) of the first octet is set to 1 for long headers and 0 for short headers.\", HFILL }\n        },\n        { &hf_gquic_fixed_bit,\n          { \"Fixed Bit\", \"gquic.fixed_bit\",\n            FT_BOOLEAN, 8, NULL, 0x40,\n            \"Must be 1\", HFILL }\n        },\n        { &hf_gquic_long_packet_type,\n          { \"Packet Type\", \"gquic.long.packet_type\",\n            FT_UINT8, BASE_DEC, VALS(gquic_long_packet_type_vals), 0x30,\n            \"Long Header Packet Type\", HFILL }\n        },\n        { &hf_gquic_long_reserved,\n          { \"Reserved\", \"gquic.long.reserved\",\n            FT_UINT8, BASE_DEC, NULL, 0x0c,\n            \"Reserved bits\", HFILL }\n        },\n        { &hf_gquic_packet_number_length,\n          { \"Packet Number Length\", \"gquic.packet_number_length\",\n            FT_UINT8, BASE_DEC, VALS(gquic_packet_number_lengths), 0x03,\n            \"Packet Number field length\", HFILL }\n\t},\n        { &hf_gquic_dcil,\n          { \"Destination Connection ID Length\", \"gquic.dcil\",\n            FT_UINT8, BASE_DEC, VALS(quic_cid_lengths), 0xF0,\n            NULL, HFILL }\n        },\n        { &hf_gquic_scil,\n          { \"Source Connection ID Length\", \"gquic.scil\",\n            FT_UINT8, BASE_DEC, VALS(quic_cid_lengths), 0x0F,\n            NULL, HFILL }\n        },\n\n        /* Public header for < Q046 */\n        { &hf_gquic_puflags,\n            { \"Public Flags\", \"gquic.puflags\",\n              FT_UINT8, BASE_HEX, NULL, 0x0,\n              \"Specifying per-packet public flags\", HFILL }\n        },\n        { &hf_gquic_puflags_vrsn,\n            { \"Version\", \"gquic.puflags.version\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_VRSN,\n              \"Signifies that this packet also contains the version of the (Google)QUIC protocol\", HFILL }\n        },\n        { &hf_gquic_puflags_rst,\n            { \"Reset\", \"gquic.puflags.reset\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_RST,\n              \"Signifies that this packet is a public reset packet\", HFILL }\n        },\n        { &hf_gquic_puflags_dnonce,\n            { \"Diversification nonce\", \"gquic.puflags.nonce\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_DNONCE,\n              \"Indicates the presence of a 32 byte diversification nonce\", HFILL }\n        },\n        { &hf_gquic_puflags_cid,\n            { \"CID Length\", \"gquic.puflags.cid\",\n              FT_BOOLEAN, 8, TFS(&puflags_cid_tfs), PUFLAGS_CID,\n              \"Indicates the full 8 byte Connection ID is present\", HFILL }\n        },\n        { &hf_gquic_puflags_cid_old,\n            { \"CID Length\", \"gquic.puflags.cid.old\",\n              FT_UINT8, BASE_HEX, VALS(puflags_cid_old_vals), PUFLAGS_CID_OLD,\n              \"Signifies the Length of CID\", HFILL }\n        },\n        { &hf_gquic_puflags_pkn,\n            { \"Packet Number Length\", \"gquic.puflags.pkn\",\n              FT_UINT8, BASE_HEX, VALS(puflags_pkn_vals), PUFLAGS_PKN,\n              \"Signifies the Length of packet number\", HFILL }\n        },\n        { &hf_gquic_puflags_mpth,\n            { \"Multipath\", \"gquic.puflags.mpth\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_MPTH,\n              \"Reserved for multipath use\", HFILL }\n        },\n        { &hf_gquic_puflags_rsv,\n            { \"Reserved\", \"gquic.puflags.rsv\",\n              FT_UINT8, BASE_HEX, NULL, PUFLAGS_RSV,\n              \"Must be Zero\", HFILL }\n        },\n        { &hf_gquic_cid,\n            { \"CID\", \"gquic.cid\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Connection ID 64 bit pseudo random number\", HFILL }\n        },\n        { &hf_gquic_version,\n            { \"Version\", \"gquic.version\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"32 bit opaque tag that represents the version of the (Google)QUIC\", HFILL }\n        },\n        { &hf_gquic_diversification_nonce,\n            { \"Diversification nonce\", \"gquic.diversification_nonce\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_packet_number,\n            { \"Packet Number\", \"gquic.packet_number\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"The lower 8, 16, 32, or 48 bits of the packet number\", HFILL }\n        },\n\n        { &hf_gquic_prflags,\n            { \"Private Flags\", \"gquic.prflags\",\n              FT_UINT8, BASE_HEX, NULL, 0x0,\n              \"Specifying per-packet Private flags\", HFILL }\n        },\n\n        { &hf_gquic_prflags_entropy,\n            { \"Entropy\", \"gquic.prflags.entropy\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PRFLAGS_ENTROPY,\n              \"For data packets, signifies that this packet contains the 1 bit of entropy, for fec packets, contains the xor of the entropy of protected packets\", HFILL }\n        },\n        { &hf_gquic_prflags_fecg,\n            { \"FEC Group\", \"gquic.prflags.fecg\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PRFLAGS_FECG,\n              \"Indicates whether the fec byte is present.\", HFILL }\n        },\n        { &hf_gquic_prflags_fec,\n            { \"FEC\", \"gquic.prflags.fec\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PRFLAGS_FEC,\n              \"Signifies that this packet represents an FEC packet\", HFILL }\n        },\n        { &hf_gquic_prflags_rsv,\n            { \"Reserved\", \"gquic.prflags.rsv\",\n              FT_UINT8, BASE_HEX, NULL, PRFLAGS_RSV,\n              \"Must be Zero\", HFILL }\n        },\n\n        { &hf_gquic_message_authentication_hash,\n            { \"Message Authentication Hash\", \"gquic.message_authentication_hash\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"The hash is an FNV1a-128 hash, serialized in little endian order\", HFILL }\n        },\n        { &hf_gquic_frame,\n            { \"Frame\", \"gquic.frame\",\n              FT_NONE, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type,\n            { \"Frame Type\", \"gquic.frame_type\",\n              FT_UINT8 ,BASE_RANGE_STRING | BASE_HEX, RVALS(frame_type_vals), 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_padding_length,\n            { \"Padding Length\", \"gquic.frame_type.padding.length\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_padding,\n            { \"Padding\", \"gquic.frame_type.padding\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"Must be zero\", HFILL }\n        },\n        { &hf_gquic_frame_type_rsts_stream_id,\n            { \"Stream ID\", \"gquic.frame_type.rsts.stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"Stream ID of the stream being terminated\", HFILL }\n        },\n        { &hf_gquic_frame_type_rsts_byte_offset,\n            { \"Byte offset\", \"gquic.frame_type.rsts.byte_offset\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Indicating the absolute byte offset of the end of data for this stream\", HFILL }\n        },\n        { &hf_gquic_frame_type_rsts_error_code,\n            { \"Error code\", \"gquic.frame_type.rsts.error_code\",\n              FT_UINT32, BASE_DEC|BASE_EXT_STRING, &rststream_error_code_vals_ext, 0x0,\n              \"Indicates why the stream is being closed\", HFILL }\n        },\n        { &hf_gquic_frame_type_cc_error_code,\n            { \"Error code\", \"gquic.frame_type.cc.error_code\",\n              FT_UINT32, BASE_DEC|BASE_EXT_STRING, &error_code_vals_ext, 0x0,\n              \"Indicates the reason for closing this connection\", HFILL }\n        },\n        { &hf_gquic_frame_type_cc_reason_phrase_length,\n            { \"Reason phrase Length\", \"gquic.frame_type.cc.reason_phrase.length\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"Specifying the length of the reason phrase\", HFILL }\n        },\n        { &hf_gquic_frame_type_cc_reason_phrase,\n            { \"Reason phrase\", \"gquic.frame_type.cc.reason_phrase\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"An optional human-readable explanation for why the connection was closed\", HFILL }\n        },\n        { &hf_gquic_frame_type_goaway_error_code,\n            { \"Error code\", \"gquic.frame_type.goaway.error_code\",\n              FT_UINT32, BASE_DEC|BASE_EXT_STRING, &error_code_vals_ext, 0x0,\n              \"Indicates the reason for closing this connection\", HFILL }\n        },\n        { &hf_gquic_frame_type_goaway_last_good_stream_id,\n            { \"Last Good Stream ID\", \"gquic.frame_type.goaway.last_good_stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"last Stream ID which was accepted by the sender of the GOAWAY message\", HFILL }\n        },\n        { &hf_gquic_frame_type_goaway_reason_phrase_length,\n            { \"Reason phrase Length\", \"gquic.frame_type.goaway.reason_phrase.length\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"Specifying the length of the reason phrase\", HFILL }\n        },\n        { &hf_gquic_frame_type_goaway_reason_phrase,\n            { \"Reason phrase\", \"gquic.frame_type.goaway.reason_phrase\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"An optional human-readable explanation for why the connection was closed\", HFILL }\n        },\n        { &hf_gquic_frame_type_wu_stream_id,\n            { \"Stream ID\", \"gquic.frame_type.wu.stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"ID of the stream whose flow control windows is begin updated, or 0 to specify the connection-level flow control window\", HFILL }\n        },\n        { &hf_gquic_frame_type_wu_byte_offset,\n            { \"Byte offset\", \"gquic.frame_type.wu.byte_offset\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Indicating the absolute byte offset of data which can be sent on the given stream\", HFILL }\n        },\n        { &hf_gquic_frame_type_blocked_stream_id,\n            { \"Stream ID\", \"gquic.frame_type.blocked.stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"Indicating the stream which is flow control blocked\", HFILL }\n        },\n        { &hf_gquic_frame_type_sw_send_entropy,\n            { \"Send Entropy\", \"gquic.frame_type.sw.send_entropy\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the cumulative hash of entropy in all sent packets up to the packet with packet number one less than the least unacked packet\", HFILL }\n        },\n        { &hf_gquic_frame_type_sw_least_unacked_delta,\n            { \"Least unacked delta\", \"gquic.frame_type.sw.least_unacked_delta\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"A variable length packet number delta with the same length as the packet header's packet number\", HFILL }\n        },\n        { &hf_gquic_crypto_offset,\n            { \"Offset\", \"gquic.crypto.offset\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Byte offset into the stream\", HFILL }\n        },\n        { &hf_gquic_crypto_length,\n            { \"Length\", \"gquic.crypto.length\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Length of the Crypto Data field\", HFILL }\n        },\n        { &hf_gquic_crypto_crypto_data,\n            { \"Crypto Data\", \"gquic.crypto.crypto_data\",\n              FT_NONE, BASE_NONE, NULL, 0x0,\n              \"The cryptographic message data\", HFILL }\n        },\n        { &hf_gquic_frame_type_stream,\n            { \"Stream\", \"gquic.frame_type.stream\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_STREAM,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_stream_f,\n            { \"FIN\", \"gquic.frame_type.stream.f\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_STREAM_F,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_stream_d,\n            { \"Data Length\", \"gquic.frame_type.stream.d\",\n              FT_BOOLEAN, 8, TFS(&len_data_vals), FTFLAGS_STREAM_D,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_stream_ooo,\n            { \"Offset Length\", \"gquic.frame_type.stream.ooo\",\n              FT_UINT8, BASE_DEC, VALS(len_offset_vals), FTFLAGS_STREAM_OOO,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_stream_ss,\n            { \"Stream Length\", \"gquic.frame_type.stream.ss\",\n              FT_UINT8, BASE_DEC, VALS(len_stream_vals), FTFLAGS_STREAM_SS,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack,\n            { \"ACK\", \"gquic.frame_type.ack\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_ACK,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_n,\n            { \"NACK\", \"gquic.frame_type.ack.n\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_ACK_N,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_u,\n            { \"Unused\", \"gquic.frame_type.ack.u\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_ACK_U,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_t,\n            { \"Truncated\", \"gquic.frame_type.ack.t\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_ACK_T,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_ll,\n            { \"Largest Observed Length\", \"gquic.frame_type.ack.ll\",\n              FT_UINT8, BASE_DEC, VALS(len_largest_observed_vals), FTFLAGS_ACK_LL,\n              \"Length of the Largest Observed field as 1, 2, 4, or 6 bytes long\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_mm,\n            { \"Missing Packet Length\", \"gquic.frame_type.ack.mm\",\n              FT_UINT8, BASE_DEC, VALS(len_missing_packet_vals), FTFLAGS_ACK_MM,\n              \"Length of the Missing Packet Number Delta field as 1, 2, 4, or 6 bytes long\", HFILL }\n        },\n        /* ACK before Q034 */\n        { &hf_gquic_frame_type_ack_received_entropy,\n            { \"Received Entropy\", \"gquic.frame_type.ack.received_entropy\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the cumulative hash of entropy in all received packets up to the largest observed packet\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_largest_observed,\n            { \"Largest Observed\", \"gquic.frame_type.ack.largest_observed\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Representing the largest packet number the peer has observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_ack_delay_time,\n            { \"Ack Delay time\", \"gquic.frame_type.ack.ack_delay_time\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"Specifying the time elapsed in microseconds from when largest observed was received until this Ack frame was sent\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_num_timestamp,\n            { \"Num Timestamp\", \"gquic.frame_type.ack.num_timestamp\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the number of TCP timestamps that are included in this frame\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_delta_largest_observed,\n            { \"Delta Largest Observed\", \"gquic.frame_type.ack.delta_largest_observed\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the packet number delta from the first timestamp to the largest observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_first_timestamp,\n            { \"First Timestamp\", \"gquic.frame_type.ack.first_timestamp\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"Specifying the time delta in microseconds, from the beginning of the connection of the arrival of the packet specified by Largest Observed minus Delta Largest Observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_time_since_previous_timestamp,\n            { \"Time since Previous timestamp\", \"gquic.frame_type.ack.time_since_previous_timestamp\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"This is the time delta from the previous timestamp\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_num_ranges,\n            { \"Num Ranges\", \"gquic.frame_type.ack.num_ranges\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the number of missing packet ranges between largest observed and least unacked\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_missing_packet,\n            { \"Missing Packet Packet Number Delta\", \"gquic.frame_type.ack.missing_packet\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_range_length,\n            { \"Range Length\", \"gquic.frame_type.ack.range_length\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying one less than the number of sequential nacks in the range\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_num_revived,\n            { \"Num Revived\", \"gquic.frame_type.ack.num_revived\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the number of revived packets, recovered via FEC\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_revived_packet,\n            { \"Revived Packet Packet Number\", \"gquic.frame_type.ack.revived_packet\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Representing a packet the peer has revived via FEC\", HFILL }\n        },\n        /* ACK after Q034 */\n        { &hf_gquic_frame_type_ack_largest_acked,\n            { \"Largest Acked\", \"gquic.frame_type.ack.largest_acked\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Representing the largest packet number the peer has observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_largest_acked_delta_time,\n            { \"Largest Acked Delta Time\", \"gquic.frame_type.ack.largest_acked_delta_time\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"Specifying the time elapsed in microseconds from when largest acked was received until this Ack frame was sent\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_num_blocks,\n            { \"Num blocks\", \"gquic.frame_type.ack.num_blocks\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying one less than the number of ack blocks\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_first_ack_block_length,\n            { \"First Ack block length\", \"gquic.frame_type.ack.first_ack_block_length\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_gap_to_next_block,\n            { \"Gap to next block\", \"gquic.frame_type.ack.gap_to_next_block\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the number of packets between ack blocks\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_ack_block_length,\n            { \"Ack block length\", \"gquic.frame_type.ack.ack_block_length\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_delta_largest_acked,\n            { \"Delta Largest Observed\", \"gquic.frame_type.ack.delta_largest_acked\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the packet number delta from the first timestamp to the largest observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_time_since_largest_acked,\n            { \"Time Since Largest Acked\", \"gquic.frame_type.ack.time_since_largest_acked\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"Specifying the time delta in microseconds, from the beginning of the connection of the arrival of the packet specified by Largest Observed minus Delta Largest Observed\", HFILL }\n        },\n\n\n\n        { &hf_gquic_stream_id,\n            { \"Stream ID\", \"gquic.stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_offset,\n            { \"Offset\", \"gquic.offset\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_data_len,\n            { \"Data Length\", \"gquic.data_len\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag,\n            { \"Tag\", \"gquic.tag\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_number,\n            { \"Tag Number\", \"gquic.tag_number\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tags,\n            { \"Tag/value\", \"gquic.tags\",\n              FT_NONE, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_type,\n            { \"Tag Type\", \"gquic.tag_type\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_offset_end,\n            { \"Tag offset end\", \"gquic.tag_offset_end\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_length,\n            { \"Tag length\", \"gquic.tag_offset_length\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_value,\n            { \"Tag/value\", \"gquic.tag_value\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_sni,\n            { \"Server Name Indication\", \"gquic.tag.sni\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"The fully qualified DNS name of the server, canonicalised to lowercase with no trailing period\", HFILL }\n        },\n        { &hf_gquic_tag_pad,\n            { \"Padding\", \"gquic.tag.pad\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"Pad.....\", HFILL }\n        },\n        { &hf_gquic_tag_ver,\n            { \"Version\", \"gquic.tag.version\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"Version of gquic supported\", HFILL }\n        },\n        { &hf_gquic_tag_pdmd,\n            { \"Proof demand\", \"gquic.tag.pdmd\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"a list of tags describing the types of proof acceptable to the client, in preference order\", HFILL }\n        },\n        { &hf_gquic_tag_ccs,\n            { \"Common certificate sets\", \"gquic.tag.ccs\",\n              FT_UINT64, BASE_HEX, NULL, 0x0,\n              \"A series of 64-bit, FNV-1a hashes of sets of common certificates that the client possesses\", HFILL }\n        },\n        { &hf_gquic_tag_uaid,\n            { \"Client's User Agent ID\", \"gquic.tag.uaid\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_stk,\n            { \"Source-address token\", \"gquic.tag.stk\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_sno,\n            { \"Server nonce\", \"gquic.tag.sno\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_prof,\n            { \"Proof (Signature)\", \"gquic.tag.prof\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_scfg,\n            { \"Server Config Tag\", \"gquic.tag.scfg\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_scfg_number,\n            { \"Number Server Config Tag\", \"gquic.tag.scfg.number\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_rrej,\n            { \"Reasons for server sending\", \"gquic.tag.rrej\",\n              FT_UINT32, BASE_DEC|BASE_EXT_STRING, &handshake_failure_reason_vals_ext, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_crt,\n            { \"Certificate chain\", \"gquic.tag.crt\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_aead,\n            { \"Authenticated encryption algorithms\", \"gquic.tag.aead\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"A list of tags, in preference order, specifying the AEAD primitives supported by the server\", HFILL }\n        },\n        { &hf_gquic_tag_scid,\n            { \"Server Config ID\", \"gquic.tag.scid\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"An opaque, 16-byte identifier for this server config\", HFILL }\n        },\n        { &hf_gquic_tag_pubs,\n            { \"Public value\", \"gquic.tag.pubs\",\n              FT_UINT24, BASE_DEC_HEX, NULL, 0x0,\n              \"A list of public values, 24-bit, little-endian length prefixed\", HFILL }\n        },\n        { &hf_gquic_tag_kexs,\n            { \"Key exchange algorithms\", \"gquic.tag.kexs\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"A list of tags, in preference order, specifying the key exchange algorithms that the server supports\", HFILL }\n        },\n        { &hf_gquic_tag_obit,\n            { \"Server orbit\", \"gquic.tag.obit\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_expy,\n            { \"Expiry\", \"gquic.tag.expy\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"a 64-bit expiry time for the server config in UNIX epoch seconds\", HFILL }\n        },\n        { &hf_gquic_tag_nonc,\n            { \"Client nonce\", \"gquic.tag.nonc\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"32 bytes consisting of 4 bytes of timestamp (big-endian, UNIX epoch seconds), 8 bytes of server orbit and 20 bytes of random data\", HFILL }\n        },\n        { &hf_gquic_tag_mspc,\n            { \"Max streams per connection\", \"gquic.tag.mspc\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_tcid,\n            { \"Connection ID truncation\", \"gquic.tag.tcid\",\n              FT_UINT32, BASE_DEC_HEX, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_srbf,\n            { \"Socket receive buffer\", \"gquic.tag.srbf\",\n              FT_UINT32, BASE_DEC_HEX, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_icsl,\n            { \"Idle connection state\", \"gquic.tag.icsl\",\n              FT_UINT32, BASE_DEC_HEX, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_scls,\n            { \"Silently close on timeout\", \"gquic.tag.scls\",\n              FT_UINT32, BASE_DEC_HEX, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_copt,\n            { \"Connection options\", \"gquic.tag.copt\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_ccrt,\n            { \"Cached certificates\", \"gquic.tag.ccrt\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_irtt,\n            { \"Estimated initial RTT\", \"gquic.tag.irtt\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"in us\", HFILL }\n        },\n        { &hf_gquic_tag_cfcw,\n            { \"Initial session/connection\", \"gquic.tag.cfcw\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_sfcw,\n            { \"Initial stream flow control\", \"gquic.tag.sfcw\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cetv,\n            { \"Client encrypted tag-value\", \"gquic.tag.cetv\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_xlct,\n            { \"Expected leaf certificate\", \"gquic.tag.xlct\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_nonp,\n            { \"Client Proof nonce\", \"gquic.tag.nonp\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_csct,\n            { \"Signed cert timestamp\", \"gquic.tag.csct\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_ctim,\n            { \"Client Timestamp\", \"gquic.tag.ctim\",\n              FT_ABSOLUTE_TIME, ABSOLUTE_TIME_UTC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_rnon,\n            { \"Public reset nonce proof\", \"gquic.tag.rnon\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_rseq,\n            { \"Rejected Packet Number\", \"gquic.tag.rseq\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"a 64-bit packet number\", HFILL }\n        },\n        { &hf_gquic_tag_cadr_addr_type,\n            { \"Client IP Address Type\", \"gquic.tag.caddr.addr.type\",\n              FT_UINT16, BASE_DEC, VALS(cadr_type_vals), 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cadr_addr_ipv4,\n            { \"Client IP Address\", \"gquic.tag.caddr.addr.ipv4\",\n              FT_IPv4, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cadr_addr_ipv6,\n            { \"Client IP Address\", \"gquic.tag.caddr.addr.ipv6\",\n              FT_IPv6, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cadr_addr,\n            { \"Client IP Address\", \"gquic.tag.caddr.addr\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cadr_port,\n            { \"Client Port (Source)\", \"gquic.tag.caddr.port\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_mids,\n            { \"Max incoming dynamic streams\", \"gquic.tag.mids\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_fhol,\n            { \"Force Head Of Line blocking\", \"gquic.tag.fhol\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_sttl,\n            { \"Server Config TTL\", \"gquic.tag.sttl\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_smhl,\n            { \"Support Max Header List (size)\", \"gquic.tag.smhl\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_tbkp,\n            { \"Token Binding Key Params.\", \"gquic.tag.tbkp\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_mad0,\n            { \"Max Ack Delay\", \"gquic.tag.mad0\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n\n        { &hf_gquic_tag_unknown,\n            { \"Unknown tag\", \"gquic.tag.unknown\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_padding,\n            { \"Padding\", \"gquic.padding\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_stream_data,\n            { \"Stream Data\", \"gquic.stream_data\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_payload,\n            { \"Payload\", \"gquic.payload\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"(Google) QUIC Payload..\", HFILL }\n        },\n    };\n\n\n    static gint *ett[] = {\n        &ett_gquic,\n        &ett_gquic_puflags,\n        &ett_gquic_prflags,\n        &ett_gquic_ft,\n        &ett_gquic_ftflags,\n        &ett_gquic_tag_value\n    };\n\n    static ei_register_info ei[] = {\n        { &ei_gquic_tag_undecoded, { \"gquic.tag.undecoded\", PI_UNDECODED, PI_NOTE, \"Dissector for (Google)QUIC Tag code not implemented, Contact Wireshark developers if you want this supported\", EXPFILL }},\n        { &ei_gquic_tag_length, { \"gquic.tag.length.truncated\", PI_MALFORMED, PI_NOTE, \"Truncated Tag Length...\", EXPFILL }},\n        { &ei_gquic_tag_unknown, { \"gquic.tag.unknown.data\", PI_UNDECODED, PI_NOTE, \"Unknown Data\", EXPFILL }},\n        { &ei_gquic_version_invalid, { \"gquic.version.invalid\", PI_MALFORMED, PI_ERROR, \"Invalid Version\", EXPFILL }},\n        { &ei_gquic_invalid_parameter, { \"gquic.invalid.parameter\", PI_MALFORMED, PI_ERROR, \"Invalid Parameter\", EXPFILL }}\n    };\n\n    expert_module_t *expert_gquic;\n\n    proto_gquic = proto_register_protocol(\"GQUIC (Google Quick UDP Internet Connections)\", \"GQUIC\", \"gquic\");\n\n    proto_register_field_array(proto_gquic, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n\n    gquic_module = prefs_register_protocol(proto_gquic, NULL);\n\n    prefs_register_bool_preference(gquic_module, \"debug.quic\",\n                       \"Force decode of all (Google) QUIC Payload\",\n                       \"Help for debug...\",\n                       &g_gquic_debug);\n\n    expert_gquic = expert_register_protocol(proto_gquic);\n    expert_register_field_array(expert_gquic, ei, array_length(ei));\n\n    gquic_handle = register_dissector(\"gquic\", dissect_gquic, proto_gquic);\n}",
        "func": "void\nproto_register_gquic(void)\n{\n    module_t *gquic_module;\n\n    static hf_register_info hf[] = {\n        /* Long/Short header for Q046 */\n        { &hf_gquic_header_form,\n          { \"Header Form\", \"gquic.header_form\",\n            FT_UINT8, BASE_DEC, VALS(gquic_short_long_header_vals), 0x80,\n            \"The most significant bit (0x80) of the first octet is set to 1 for long headers and 0 for short headers.\", HFILL }\n        },\n        { &hf_gquic_fixed_bit,\n          { \"Fixed Bit\", \"gquic.fixed_bit\",\n            FT_BOOLEAN, 8, NULL, 0x40,\n            \"Must be 1\", HFILL }\n        },\n        { &hf_gquic_long_packet_type,\n          { \"Packet Type\", \"gquic.long.packet_type\",\n            FT_UINT8, BASE_DEC, VALS(gquic_long_packet_type_vals), 0x30,\n            \"Long Header Packet Type\", HFILL }\n        },\n        { &hf_gquic_long_reserved,\n          { \"Reserved\", \"gquic.long.reserved\",\n            FT_UINT8, BASE_DEC, NULL, 0x0c,\n            \"Reserved bits\", HFILL }\n        },\n        { &hf_gquic_packet_number_length,\n          { \"Packet Number Length\", \"gquic.packet_number_length\",\n            FT_UINT8, BASE_DEC, VALS(gquic_packet_number_lengths), 0x03,\n            \"Packet Number field length\", HFILL }\n\t},\n        { &hf_gquic_dcil,\n          { \"Destination Connection ID Length\", \"gquic.dcil\",\n            FT_UINT8, BASE_DEC, VALS(quic_cid_lengths), 0xF0,\n            NULL, HFILL }\n        },\n        { &hf_gquic_scil,\n          { \"Source Connection ID Length\", \"gquic.scil\",\n            FT_UINT8, BASE_DEC, VALS(quic_cid_lengths), 0x0F,\n            NULL, HFILL }\n        },\n\n        /* Public header for < Q046 */\n        { &hf_gquic_puflags,\n            { \"Public Flags\", \"gquic.puflags\",\n              FT_UINT8, BASE_HEX, NULL, 0x0,\n              \"Specifying per-packet public flags\", HFILL }\n        },\n        { &hf_gquic_puflags_vrsn,\n            { \"Version\", \"gquic.puflags.version\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_VRSN,\n              \"Signifies that this packet also contains the version of the (Google)QUIC protocol\", HFILL }\n        },\n        { &hf_gquic_puflags_rst,\n            { \"Reset\", \"gquic.puflags.reset\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_RST,\n              \"Signifies that this packet is a public reset packet\", HFILL }\n        },\n        { &hf_gquic_puflags_dnonce,\n            { \"Diversification nonce\", \"gquic.puflags.nonce\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_DNONCE,\n              \"Indicates the presence of a 32 byte diversification nonce\", HFILL }\n        },\n        { &hf_gquic_puflags_cid,\n            { \"CID Length\", \"gquic.puflags.cid\",\n              FT_BOOLEAN, 8, TFS(&puflags_cid_tfs), PUFLAGS_CID,\n              \"Indicates the full 8 byte Connection ID is present\", HFILL }\n        },\n        { &hf_gquic_puflags_cid_old,\n            { \"CID Length\", \"gquic.puflags.cid.old\",\n              FT_UINT8, BASE_HEX, VALS(puflags_cid_old_vals), PUFLAGS_CID_OLD,\n              \"Signifies the Length of CID\", HFILL }\n        },\n        { &hf_gquic_puflags_pkn,\n            { \"Packet Number Length\", \"gquic.puflags.pkn\",\n              FT_UINT8, BASE_HEX, VALS(puflags_pkn_vals), PUFLAGS_PKN,\n              \"Signifies the Length of packet number\", HFILL }\n        },\n        { &hf_gquic_puflags_mpth,\n            { \"Multipath\", \"gquic.puflags.mpth\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PUFLAGS_MPTH,\n              \"Reserved for multipath use\", HFILL }\n        },\n        { &hf_gquic_puflags_rsv,\n            { \"Reserved\", \"gquic.puflags.rsv\",\n              FT_UINT8, BASE_HEX, NULL, PUFLAGS_RSV,\n              \"Must be Zero\", HFILL }\n        },\n        { &hf_gquic_cid,\n            { \"CID\", \"gquic.cid\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Connection ID 64 bit pseudo random number\", HFILL }\n        },\n        { &hf_gquic_version,\n            { \"Version\", \"gquic.version\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"32 bit opaque tag that represents the version of the (Google)QUIC\", HFILL }\n        },\n        { &hf_gquic_diversification_nonce,\n            { \"Diversification nonce\", \"gquic.diversification_nonce\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_packet_number,\n            { \"Packet Number\", \"gquic.packet_number\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"The lower 8, 16, 32, or 48 bits of the packet number\", HFILL }\n        },\n\n        { &hf_gquic_prflags,\n            { \"Private Flags\", \"gquic.prflags\",\n              FT_UINT8, BASE_HEX, NULL, 0x0,\n              \"Specifying per-packet Private flags\", HFILL }\n        },\n\n        { &hf_gquic_prflags_entropy,\n            { \"Entropy\", \"gquic.prflags.entropy\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PRFLAGS_ENTROPY,\n              \"For data packets, signifies that this packet contains the 1 bit of entropy, for fec packets, contains the xor of the entropy of protected packets\", HFILL }\n        },\n        { &hf_gquic_prflags_fecg,\n            { \"FEC Group\", \"gquic.prflags.fecg\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PRFLAGS_FECG,\n              \"Indicates whether the fec byte is present.\", HFILL }\n        },\n        { &hf_gquic_prflags_fec,\n            { \"FEC\", \"gquic.prflags.fec\",\n              FT_BOOLEAN, 8, TFS(&tfs_yes_no), PRFLAGS_FEC,\n              \"Signifies that this packet represents an FEC packet\", HFILL }\n        },\n        { &hf_gquic_prflags_rsv,\n            { \"Reserved\", \"gquic.prflags.rsv\",\n              FT_UINT8, BASE_HEX, NULL, PRFLAGS_RSV,\n              \"Must be Zero\", HFILL }\n        },\n\n        { &hf_gquic_message_authentication_hash,\n            { \"Message Authentication Hash\", \"gquic.message_authentication_hash\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"The hash is an FNV1a-128 hash, serialized in little endian order\", HFILL }\n        },\n        { &hf_gquic_frame,\n            { \"Frame\", \"gquic.frame\",\n              FT_NONE, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type,\n            { \"Frame Type\", \"gquic.frame_type\",\n              FT_UINT8 ,BASE_RANGE_STRING | BASE_HEX, RVALS(frame_type_vals), 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_padding_length,\n            { \"Padding Length\", \"gquic.frame_type.padding.length\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_padding,\n            { \"Padding\", \"gquic.frame_type.padding\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"Must be zero\", HFILL }\n        },\n        { &hf_gquic_frame_type_rsts_stream_id,\n            { \"Stream ID\", \"gquic.frame_type.rsts.stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"Stream ID of the stream being terminated\", HFILL }\n        },\n        { &hf_gquic_frame_type_rsts_byte_offset,\n            { \"Byte offset\", \"gquic.frame_type.rsts.byte_offset\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Indicating the absolute byte offset of the end of data for this stream\", HFILL }\n        },\n        { &hf_gquic_frame_type_rsts_error_code,\n            { \"Error code\", \"gquic.frame_type.rsts.error_code\",\n              FT_UINT32, BASE_DEC|BASE_EXT_STRING, &rststream_error_code_vals_ext, 0x0,\n              \"Indicates why the stream is being closed\", HFILL }\n        },\n        { &hf_gquic_frame_type_cc_error_code,\n            { \"Error code\", \"gquic.frame_type.cc.error_code\",\n              FT_UINT32, BASE_DEC|BASE_EXT_STRING, &error_code_vals_ext, 0x0,\n              \"Indicates the reason for closing this connection\", HFILL }\n        },\n        { &hf_gquic_frame_type_cc_reason_phrase_length,\n            { \"Reason phrase Length\", \"gquic.frame_type.cc.reason_phrase.length\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"Specifying the length of the reason phrase\", HFILL }\n        },\n        { &hf_gquic_frame_type_cc_reason_phrase,\n            { \"Reason phrase\", \"gquic.frame_type.cc.reason_phrase\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"An optional human-readable explanation for why the connection was closed\", HFILL }\n        },\n        { &hf_gquic_frame_type_goaway_error_code,\n            { \"Error code\", \"gquic.frame_type.goaway.error_code\",\n              FT_UINT32, BASE_DEC|BASE_EXT_STRING, &error_code_vals_ext, 0x0,\n              \"Indicates the reason for closing this connection\", HFILL }\n        },\n        { &hf_gquic_frame_type_goaway_last_good_stream_id,\n            { \"Last Good Stream ID\", \"gquic.frame_type.goaway.last_good_stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"last Stream ID which was accepted by the sender of the GOAWAY message\", HFILL }\n        },\n        { &hf_gquic_frame_type_goaway_reason_phrase_length,\n            { \"Reason phrase Length\", \"gquic.frame_type.goaway.reason_phrase.length\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"Specifying the length of the reason phrase\", HFILL }\n        },\n        { &hf_gquic_frame_type_goaway_reason_phrase,\n            { \"Reason phrase\", \"gquic.frame_type.goaway.reason_phrase\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"An optional human-readable explanation for why the connection was closed\", HFILL }\n        },\n        { &hf_gquic_frame_type_wu_stream_id,\n            { \"Stream ID\", \"gquic.frame_type.wu.stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"ID of the stream whose flow control windows is begin updated, or 0 to specify the connection-level flow control window\", HFILL }\n        },\n        { &hf_gquic_frame_type_wu_byte_offset,\n            { \"Byte offset\", \"gquic.frame_type.wu.byte_offset\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Indicating the absolute byte offset of data which can be sent on the given stream\", HFILL }\n        },\n        { &hf_gquic_frame_type_blocked_stream_id,\n            { \"Stream ID\", \"gquic.frame_type.blocked.stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"Indicating the stream which is flow control blocked\", HFILL }\n        },\n        { &hf_gquic_frame_type_sw_send_entropy,\n            { \"Send Entropy\", \"gquic.frame_type.sw.send_entropy\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the cumulative hash of entropy in all sent packets up to the packet with packet number one less than the least unacked packet\", HFILL }\n        },\n        { &hf_gquic_frame_type_sw_least_unacked_delta,\n            { \"Least unacked delta\", \"gquic.frame_type.sw.least_unacked_delta\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"A variable length packet number delta with the same length as the packet header's packet number\", HFILL }\n        },\n        { &hf_gquic_crypto_offset,\n            { \"Offset\", \"gquic.crypto.offset\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Byte offset into the stream\", HFILL }\n        },\n        { &hf_gquic_crypto_length,\n            { \"Length\", \"gquic.crypto.length\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Length of the Crypto Data field\", HFILL }\n        },\n        { &hf_gquic_crypto_crypto_data,\n            { \"Crypto Data\", \"gquic.crypto.crypto_data\",\n              FT_NONE, BASE_NONE, NULL, 0x0,\n              \"The cryptographic message data\", HFILL }\n        },\n        { &hf_gquic_frame_type_stream,\n            { \"Stream\", \"gquic.frame_type.stream\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_STREAM,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_stream_f,\n            { \"FIN\", \"gquic.frame_type.stream.f\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_STREAM_F,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_stream_d,\n            { \"Data Length\", \"gquic.frame_type.stream.d\",\n              FT_BOOLEAN, 8, TFS(&len_data_vals), FTFLAGS_STREAM_D,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_stream_ooo,\n            { \"Offset Length\", \"gquic.frame_type.stream.ooo\",\n              FT_UINT8, BASE_DEC, VALS(len_offset_vals), FTFLAGS_STREAM_OOO,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_stream_ss,\n            { \"Stream Length\", \"gquic.frame_type.stream.ss\",\n              FT_UINT8, BASE_DEC, VALS(len_stream_vals), FTFLAGS_STREAM_SS,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack,\n            { \"ACK\", \"gquic.frame_type.ack\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_ACK,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_n,\n            { \"NACK\", \"gquic.frame_type.ack.n\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_ACK_N,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_u,\n            { \"Unused\", \"gquic.frame_type.ack.u\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_ACK_U,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_t,\n            { \"Truncated\", \"gquic.frame_type.ack.t\",\n              FT_BOOLEAN, 8, NULL, FTFLAGS_ACK_T,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_ll,\n            { \"Largest Observed Length\", \"gquic.frame_type.ack.ll\",\n              FT_UINT8, BASE_DEC, VALS(len_largest_observed_vals), FTFLAGS_ACK_LL,\n              \"Length of the Largest Observed field as 1, 2, 4, or 6 bytes long\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_mm,\n            { \"Missing Packet Length\", \"gquic.frame_type.ack.mm\",\n              FT_UINT8, BASE_DEC, VALS(len_missing_packet_vals), FTFLAGS_ACK_MM,\n              \"Length of the Missing Packet Number Delta field as 1, 2, 4, or 6 bytes long\", HFILL }\n        },\n        /* ACK before Q034 */\n        { &hf_gquic_frame_type_ack_received_entropy,\n            { \"Received Entropy\", \"gquic.frame_type.ack.received_entropy\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the cumulative hash of entropy in all received packets up to the largest observed packet\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_largest_observed,\n            { \"Largest Observed\", \"gquic.frame_type.ack.largest_observed\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Representing the largest packet number the peer has observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_ack_delay_time,\n            { \"Ack Delay time\", \"gquic.frame_type.ack.ack_delay_time\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"Specifying the time elapsed in microseconds from when largest observed was received until this Ack frame was sent\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_num_timestamp,\n            { \"Num Timestamp\", \"gquic.frame_type.ack.num_timestamp\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the number of TCP timestamps that are included in this frame\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_delta_largest_observed,\n            { \"Delta Largest Observed\", \"gquic.frame_type.ack.delta_largest_observed\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the packet number delta from the first timestamp to the largest observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_first_timestamp,\n            { \"First Timestamp\", \"gquic.frame_type.ack.first_timestamp\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"Specifying the time delta in microseconds, from the beginning of the connection of the arrival of the packet specified by Largest Observed minus Delta Largest Observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_time_since_previous_timestamp,\n            { \"Time since Previous timestamp\", \"gquic.frame_type.ack.time_since_previous_timestamp\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"This is the time delta from the previous timestamp\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_num_ranges,\n            { \"Num Ranges\", \"gquic.frame_type.ack.num_ranges\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the number of missing packet ranges between largest observed and least unacked\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_missing_packet,\n            { \"Missing Packet Packet Number Delta\", \"gquic.frame_type.ack.missing_packet\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_range_length,\n            { \"Range Length\", \"gquic.frame_type.ack.range_length\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying one less than the number of sequential nacks in the range\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_num_revived,\n            { \"Num Revived\", \"gquic.frame_type.ack.num_revived\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the number of revived packets, recovered via FEC\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_revived_packet,\n            { \"Revived Packet Packet Number\", \"gquic.frame_type.ack.revived_packet\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Representing a packet the peer has revived via FEC\", HFILL }\n        },\n        /* ACK after Q034 */\n        { &hf_gquic_frame_type_ack_largest_acked,\n            { \"Largest Acked\", \"gquic.frame_type.ack.largest_acked\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"Representing the largest packet number the peer has observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_largest_acked_delta_time,\n            { \"Largest Acked Delta Time\", \"gquic.frame_type.ack.largest_acked_delta_time\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              \"Specifying the time elapsed in microseconds from when largest acked was received until this Ack frame was sent\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_num_blocks,\n            { \"Num blocks\", \"gquic.frame_type.ack.num_blocks\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying one less than the number of ack blocks\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_first_ack_block_length,\n            { \"First Ack block length\", \"gquic.frame_type.ack.first_ack_block_length\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_gap_to_next_block,\n            { \"Gap to next block\", \"gquic.frame_type.ack.gap_to_next_block\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the number of packets between ack blocks\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_ack_block_length,\n            { \"Ack block length\", \"gquic.frame_type.ack.ack_block_length\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_frame_type_ack_delta_largest_acked,\n            { \"Delta Largest Observed\", \"gquic.frame_type.ack.delta_largest_acked\",\n              FT_UINT8, BASE_DEC, NULL, 0x0,\n              \"Specifying the packet number delta from the first timestamp to the largest observed\", HFILL }\n        },\n        { &hf_gquic_frame_type_ack_time_since_largest_acked,\n            { \"Time Since Largest Acked\", \"gquic.frame_type.ack.time_since_largest_acked\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"Specifying the time delta in microseconds, from the beginning of the connection of the arrival of the packet specified by Largest Observed minus Delta Largest Observed\", HFILL }\n        },\n\n\n\n        { &hf_gquic_stream_id,\n            { \"Stream ID\", \"gquic.stream_id\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_offset,\n            { \"Offset\", \"gquic.offset\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_data_len,\n            { \"Data Length\", \"gquic.data_len\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag,\n            { \"Tag\", \"gquic.tag\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_number,\n            { \"Tag Number\", \"gquic.tag_number\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tags,\n            { \"Tag/value\", \"gquic.tags\",\n              FT_NONE, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_type,\n            { \"Tag Type\", \"gquic.tag_type\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_offset_end,\n            { \"Tag offset end\", \"gquic.tag_offset_end\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_length,\n            { \"Tag length\", \"gquic.tag_offset_length\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_value,\n            { \"Tag/value\", \"gquic.tag_value\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_sni,\n            { \"Server Name Indication\", \"gquic.tag.sni\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"The fully qualified DNS name of the server, canonicalised to lowercase with no trailing period\", HFILL }\n        },\n        { &hf_gquic_tag_pad,\n            { \"Padding\", \"gquic.tag.pad\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"Pad.....\", HFILL }\n        },\n        { &hf_gquic_tag_ver,\n            { \"Version\", \"gquic.tag.version\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"Version of gquic supported\", HFILL }\n        },\n        { &hf_gquic_tag_pdmd,\n            { \"Proof demand\", \"gquic.tag.pdmd\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"a list of tags describing the types of proof acceptable to the client, in preference order\", HFILL }\n        },\n        { &hf_gquic_tag_ccs,\n            { \"Common certificate sets\", \"gquic.tag.ccs\",\n              FT_UINT64, BASE_HEX, NULL, 0x0,\n              \"A series of 64-bit, FNV-1a hashes of sets of common certificates that the client possesses\", HFILL }\n        },\n        { &hf_gquic_tag_uaid,\n            { \"Client's User Agent ID\", \"gquic.tag.uaid\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_stk,\n            { \"Source-address token\", \"gquic.tag.stk\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_sno,\n            { \"Server nonce\", \"gquic.tag.sno\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_prof,\n            { \"Proof (Signature)\", \"gquic.tag.prof\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_scfg,\n            { \"Server Config Tag\", \"gquic.tag.scfg\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_scfg_number,\n            { \"Number Server Config Tag\", \"gquic.tag.scfg.number\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_rrej,\n            { \"Reasons for server sending\", \"gquic.tag.rrej\",\n              FT_UINT32, BASE_DEC|BASE_EXT_STRING, &handshake_failure_reason_vals_ext, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_crt,\n            { \"Certificate chain\", \"gquic.tag.crt\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_aead,\n            { \"Authenticated encryption algorithms\", \"gquic.tag.aead\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"A list of tags, in preference order, specifying the AEAD primitives supported by the server\", HFILL }\n        },\n        { &hf_gquic_tag_scid,\n            { \"Server Config ID\", \"gquic.tag.scid\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"An opaque, 16-byte identifier for this server config\", HFILL }\n        },\n        { &hf_gquic_tag_pubs,\n            { \"Public value\", \"gquic.tag.pubs\",\n              FT_UINT24, BASE_DEC_HEX, NULL, 0x0,\n              \"A list of public values, 24-bit, little-endian length prefixed\", HFILL }\n        },\n        { &hf_gquic_tag_kexs,\n            { \"Key exchange algorithms\", \"gquic.tag.kexs\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              \"A list of tags, in preference order, specifying the key exchange algorithms that the server supports\", HFILL }\n        },\n        { &hf_gquic_tag_obit,\n            { \"Server orbit\", \"gquic.tag.obit\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_expy,\n            { \"Expiry\", \"gquic.tag.expy\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"a 64-bit expiry time for the server config in UNIX epoch seconds\", HFILL }\n        },\n        { &hf_gquic_tag_nonc,\n            { \"Client nonce\", \"gquic.tag.nonc\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"32 bytes consisting of 4 bytes of timestamp (big-endian, UNIX epoch seconds), 8 bytes of server orbit and 20 bytes of random data\", HFILL }\n        },\n        { &hf_gquic_tag_mspc,\n            { \"Max streams per connection\", \"gquic.tag.mspc\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_tcid,\n            { \"Connection ID truncation\", \"gquic.tag.tcid\",\n              FT_UINT32, BASE_DEC_HEX, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_srbf,\n            { \"Socket receive buffer\", \"gquic.tag.srbf\",\n              FT_UINT32, BASE_DEC_HEX, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_icsl,\n            { \"Idle connection state\", \"gquic.tag.icsl\",\n              FT_UINT32, BASE_DEC_HEX, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_scls,\n            { \"Silently close on timeout\", \"gquic.tag.scls\",\n              FT_UINT32, BASE_DEC_HEX, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_copt,\n            { \"Connection options\", \"gquic.tag.copt\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_ccrt,\n            { \"Cached certificates\", \"gquic.tag.ccrt\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_irtt,\n            { \"Estimated initial RTT\", \"gquic.tag.irtt\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              \"in us\", HFILL }\n        },\n        { &hf_gquic_tag_cfcw,\n            { \"Initial session/connection\", \"gquic.tag.cfcw\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_sfcw,\n            { \"Initial stream flow control\", \"gquic.tag.sfcw\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cetv,\n            { \"Client encrypted tag-value\", \"gquic.tag.cetv\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_xlct,\n            { \"Expected leaf certificate\", \"gquic.tag.xlct\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_nonp,\n            { \"Client Proof nonce\", \"gquic.tag.nonp\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_csct,\n            { \"Signed cert timestamp\", \"gquic.tag.csct\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_ctim,\n            { \"Client Timestamp\", \"gquic.tag.ctim\",\n              FT_ABSOLUTE_TIME, ABSOLUTE_TIME_UTC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_rnon,\n            { \"Public reset nonce proof\", \"gquic.tag.rnon\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_rseq,\n            { \"Rejected Packet Number\", \"gquic.tag.rseq\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              \"a 64-bit packet number\", HFILL }\n        },\n        { &hf_gquic_tag_cadr_addr_type,\n            { \"Client IP Address Type\", \"gquic.tag.caddr.addr.type\",\n              FT_UINT16, BASE_DEC, VALS(cadr_type_vals), 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cadr_addr_ipv4,\n            { \"Client IP Address\", \"gquic.tag.caddr.addr.ipv4\",\n              FT_IPv4, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cadr_addr_ipv6,\n            { \"Client IP Address\", \"gquic.tag.caddr.addr.ipv6\",\n              FT_IPv6, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cadr_addr,\n            { \"Client IP Address\", \"gquic.tag.caddr.addr\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_cadr_port,\n            { \"Client Port (Source)\", \"gquic.tag.caddr.port\",\n              FT_UINT16, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_mids,\n            { \"Max incoming dynamic streams\", \"gquic.tag.mids\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_fhol,\n            { \"Force Head Of Line blocking\", \"gquic.tag.fhol\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_sttl,\n            { \"Server Config TTL\", \"gquic.tag.sttl\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_smhl,\n            { \"Support Max Header List (size)\", \"gquic.tag.smhl\",\n              FT_UINT64, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_tbkp,\n            { \"Token Binding Key Params.\", \"gquic.tag.tbkp\",\n              FT_STRING, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_tag_mad0,\n            { \"Max Ack Delay\", \"gquic.tag.mad0\",\n              FT_UINT32, BASE_DEC, NULL, 0x0,\n              NULL, HFILL }\n        },\n\n        { &hf_gquic_tag_unknown,\n            { \"Unknown tag\", \"gquic.tag.unknown\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_padding,\n            { \"Padding\", \"gquic.padding\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_stream_data,\n            { \"Stream Data\", \"gquic.stream_data\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              NULL, HFILL }\n        },\n        { &hf_gquic_payload,\n            { \"Payload\", \"gquic.payload\",\n              FT_BYTES, BASE_NONE, NULL, 0x0,\n              \"(Google) QUIC Payload..\", HFILL }\n        },\n    };\n\n\n    static gint *ett[] = {\n        &ett_gquic,\n        &ett_gquic_puflags,\n        &ett_gquic_prflags,\n        &ett_gquic_ft,\n        &ett_gquic_ftflags,\n        &ett_gquic_tag_value\n    };\n\n    static ei_register_info ei[] = {\n        { &ei_gquic_tag_undecoded, { \"gquic.tag.undecoded\", PI_UNDECODED, PI_NOTE, \"Dissector for (Google)QUIC Tag code not implemented, Contact Wireshark developers if you want this supported\", EXPFILL }},\n        { &ei_gquic_tag_length, { \"gquic.tag.length.truncated\", PI_MALFORMED, PI_NOTE, \"Truncated Tag Length...\", EXPFILL }},\n        { &ei_gquic_tag_unknown, { \"gquic.tag.unknown.data\", PI_UNDECODED, PI_NOTE, \"Unknown Data\", EXPFILL }},\n        { &ei_gquic_version_invalid, { \"gquic.version.invalid\", PI_MALFORMED, PI_ERROR, \"Invalid Version\", EXPFILL }},\n        { &ei_gquic_invalid_parameter, { \"gquic.invalid.parameter\", PI_MALFORMED, PI_ERROR, \"Invalid Parameter\", EXPFILL }},\n        { &ei_gquic_length_invalid, { \"gquic.length.invalid\", PI_PROTOCOL, PI_WARN, \"Invalid Length\", EXPFILL }}\n    };\n\n    expert_module_t *expert_gquic;\n\n    proto_gquic = proto_register_protocol(\"GQUIC (Google Quick UDP Internet Connections)\", \"GQUIC\", \"gquic\");\n\n    proto_register_field_array(proto_gquic, hf, array_length(hf));\n    proto_register_subtree_array(ett, array_length(ett));\n\n    gquic_module = prefs_register_protocol(proto_gquic, NULL);\n\n    prefs_register_bool_preference(gquic_module, \"debug.quic\",\n                       \"Force decode of all (Google) QUIC Payload\",\n                       \"Help for debug...\",\n                       &g_gquic_debug);\n\n    expert_gquic = expert_register_protocol(proto_gquic);\n    expert_register_field_array(expert_gquic, ei, array_length(ei));\n\n    gquic_handle = register_dissector(\"gquic\", dissect_gquic, proto_gquic);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -738,7 +738,8 @@\n         { &ei_gquic_tag_length, { \"gquic.tag.length.truncated\", PI_MALFORMED, PI_NOTE, \"Truncated Tag Length...\", EXPFILL }},\n         { &ei_gquic_tag_unknown, { \"gquic.tag.unknown.data\", PI_UNDECODED, PI_NOTE, \"Unknown Data\", EXPFILL }},\n         { &ei_gquic_version_invalid, { \"gquic.version.invalid\", PI_MALFORMED, PI_ERROR, \"Invalid Version\", EXPFILL }},\n-        { &ei_gquic_invalid_parameter, { \"gquic.invalid.parameter\", PI_MALFORMED, PI_ERROR, \"Invalid Parameter\", EXPFILL }}\n+        { &ei_gquic_invalid_parameter, { \"gquic.invalid.parameter\", PI_MALFORMED, PI_ERROR, \"Invalid Parameter\", EXPFILL }},\n+        { &ei_gquic_length_invalid, { \"gquic.length.invalid\", PI_PROTOCOL, PI_WARN, \"Invalid Length\", EXPFILL }}\n     };\n \n     expert_module_t *expert_gquic;",
        "diff_line_info": {
            "deleted_lines": [
                "        { &ei_gquic_invalid_parameter, { \"gquic.invalid.parameter\", PI_MALFORMED, PI_ERROR, \"Invalid Parameter\", EXPFILL }}"
            ],
            "added_lines": [
                "        { &ei_gquic_invalid_parameter, { \"gquic.invalid.parameter\", PI_MALFORMED, PI_ERROR, \"Invalid Parameter\", EXPFILL }},",
                "        { &ei_gquic_length_invalid, { \"gquic.length.invalid\", PI_PROTOCOL, PI_WARN, \"Invalid Length\", EXPFILL }}"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-28030",
        "func_name": "wireshark/dissect_gquic_tag",
        "description": "In Wireshark 3.2.0 to 3.2.7, the GQUIC dissector could crash. This was addressed in epan/dissectors/packet-gquic.c by correcting the implementation of offset advancement.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/b287e7165e8aa89cde6ae37e7c257c5d87d16b9b",
        "commit_title": "GQUIC: make sure our tag offset advances.",
        "commit_text": " Make sure gquic tag offset advances so that we don't infinitely loop. ",
        "func_before": "static guint32\ndissect_gquic_tag(tvbuff_t *tvb, packet_info *pinfo, proto_tree *gquic_tree, guint offset, guint32 tag_number){\n    guint32 tag_offset_start = offset + tag_number*4*2;\n    guint32 tag_offset = 0, total_tag_len = 0;\n    gint32 tag_len;\n\n    while(tag_number){\n        proto_tree *tag_tree, *ti_len, *ti_tag, *ti_type;\n        guint32 offset_end, tag;\n        const guint8* tag_str;\n\n        ti_tag = proto_tree_add_item(gquic_tree, hf_gquic_tags, tvb, offset, 8, ENC_NA);\n        tag_tree = proto_item_add_subtree(ti_tag, ett_gquic_tag_value);\n        ti_type = proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_type, tvb, offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n        tag = tvb_get_ntohl(tvb, offset);\n        proto_item_append_text(ti_type, \" (%s)\", val_to_str(tag, tag_vals, \"Unknown\"));\n        proto_item_append_text(ti_tag, \": %s (%s)\", tag_str, val_to_str(tag, tag_vals, \"Unknown\"));\n        offset += 4;\n\n        proto_tree_add_item(tag_tree, hf_gquic_tag_offset_end, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset_end = tvb_get_guint32(tvb, offset, ENC_LITTLE_ENDIAN);\n\n        tag_len = offset_end - tag_offset;\n        total_tag_len += tag_len;\n        ti_len = proto_tree_add_uint(tag_tree, hf_gquic_tag_length, tvb, offset, 4, tag_len);\n        proto_item_append_text(ti_tag, \" (l=%u)\", tag_len);\n        proto_item_set_generated(ti_len);\n        offset += 4;\n\n        /* Fix issue with CRT.. (Fragmentation ?) */\n        if( tag_len > tvb_reported_length_remaining(tvb, tag_offset_start + tag_offset)){\n            tag_len = tvb_reported_length_remaining(tvb, tag_offset_start + tag_offset);\n            offset_end = tag_offset + tag_len;\n            expert_add_info(pinfo, ti_len, &ei_gquic_tag_length);\n        }\n\n        proto_tree_add_item(tag_tree, hf_gquic_tag_value, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n\n        switch(tag){\n            case TAG_PAD:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_pad, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_SNI:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_sni, tvb, tag_offset_start + tag_offset, tag_len, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += tag_len;\n            break;\n            case TAG_VER:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_ver, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += 4;\n            break;\n            case TAG_CCS:\n                while(offset_end - tag_offset >= 8){\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_ccs, tvb, tag_offset_start + tag_offset, 8, ENC_NA);\n                    tag_offset += 8;\n                }\n            break;\n            case TAG_PDMD:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_pdmd, tvb, tag_offset_start + tag_offset, tag_len, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += tag_len;\n            break;\n            case TAG_UAID:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_uaid, tvb, tag_offset_start + tag_offset, tag_len, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += tag_len;\n            break;\n            case TAG_STK:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_stk, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_SNO:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_sno, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_PROF:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_prof, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_SCFG:{\n                guint32 scfg_tag_number;\n\n                proto_tree_add_item(tag_tree, hf_gquic_tag_scfg, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                tag_offset += 4;\n                proto_tree_add_item(tag_tree, hf_gquic_tag_scfg_number, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                scfg_tag_number = tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n\n                dissect_gquic_tag(tvb, pinfo, tag_tree, tag_offset_start + tag_offset, scfg_tag_number);\n                tag_offset += tag_len - 4 - 4;\n                }\n            break;\n            case TAG_RREJ:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_rrej, tvb, tag_offset_start + tag_offset, 4,  ENC_LITTLE_ENDIAN);\n                    proto_item_append_text(ti_tag, \", Code %s\", val_to_str_ext(tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN), &handshake_failure_reason_vals_ext, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_CRT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_crt, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_AEAD:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree *ti_aead;\n                    ti_aead = proto_tree_add_item(tag_tree, hf_gquic_tag_aead, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    proto_item_append_text(ti_aead, \" (%s)\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_aead_vals, \"Unknown\"));\n                    proto_item_append_text(ti_tag, \", %s\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_aead_vals, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_SCID:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_scid, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_PUBS:\n                /*TODO FIX: 24 Length + Pubs key?.. ! */\n                proto_tree_add_item(tag_tree, hf_gquic_tag_pubs, tvb, tag_offset_start + tag_offset, 2, ENC_LITTLE_ENDIAN);\n                tag_offset += 2;\n                while(offset_end - tag_offset >= 3){\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_pubs, tvb, tag_offset_start + tag_offset, 3, ENC_LITTLE_ENDIAN);\n                    tag_offset += 3;\n                }\n            break;\n            case TAG_KEXS:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree *ti_kexs;\n                    ti_kexs = proto_tree_add_item(tag_tree, hf_gquic_tag_kexs, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    proto_item_append_text(ti_kexs, \" (%s)\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_kexs_vals, \"Unknown\"));\n                    proto_item_append_text(ti_tag, \", %s\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_kexs_vals, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_OBIT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_obit, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_EXPY:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_expy, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN);\n                tag_offset += 8;\n            break;\n            case TAG_NONC:\n                /*TODO: Enhance display: 32 bytes consisting of 4 bytes of timestamp (big-endian, UNIX epoch seconds), 8 bytes of server orbit and 20 bytes of random data. */\n                proto_tree_add_item(tag_tree, hf_gquic_tag_nonc, tvb, tag_offset_start + tag_offset, 32, ENC_NA);\n                tag_offset += 32;\n            break;\n            case TAG_MSPC:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_mspc, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_TCID:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_tcid, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n            break;\n            case TAG_SRBF:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_srbf, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n            break;\n            case TAG_ICSL:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_icsl, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n            break;\n            case TAG_SCLS:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_scls, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n            break;\n            case TAG_COPT:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_copt, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_CCRT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_ccrt, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_IRTT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_irtt, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_CFCW:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_cfcw, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_SFCW:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_sfcw, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_CETV:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_cetv, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_XLCT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_xlct, tvb, tag_offset_start + tag_offset, 8, ENC_NA);\n                tag_offset += 8;\n            break;\n            case TAG_NONP:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_nonp, tvb, tag_offset_start + tag_offset, 32, ENC_NA);\n                tag_offset += 32;\n            break;\n            case TAG_CSCT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_csct, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_CTIM:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_ctim, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN|ENC_TIME_SECS_NSECS);\n                tag_offset += 8;\n            break;\n            case TAG_RNON: /* Public Reset Tag */\n                proto_tree_add_item(tag_tree, hf_gquic_tag_rnon, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN);\n                tag_offset += 8;\n            break;\n            case TAG_RSEQ: /* Public Reset Tag */\n                proto_tree_add_item(tag_tree, hf_gquic_tag_rseq, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN);\n                tag_offset += 8;\n            break;\n            case TAG_CADR: /* Public Reset Tag */{\n                guint32 addr_type;\n                proto_tree_add_item_ret_uint(tag_tree, hf_gquic_tag_cadr_addr_type, tvb, tag_offset_start + tag_offset, 2, ENC_LITTLE_ENDIAN, &addr_type);\n                tag_offset += 2;\n                switch(addr_type){\n                    case 2: /* IPv4 */\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_cadr_addr_ipv4, tvb, tag_offset_start + tag_offset, 4, ENC_NA);\n                    tag_offset += 4;\n                    break;\n                    case 10: /* IPv6 */\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_cadr_addr_ipv6, tvb, tag_offset_start + tag_offset, 16, ENC_NA);\n                    tag_offset += 16;\n                    break;\n                    default: /* Unknown */\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_cadr_addr, tvb, tag_offset_start + tag_offset, tag_len - 2 - 2, ENC_NA);\n                    tag_offset += tag_len + 2 + 2 ;\n                    break;\n                }\n                proto_tree_add_item(tag_tree, hf_gquic_tag_cadr_port, tvb, tag_offset_start + tag_offset, 2, ENC_LITTLE_ENDIAN);\n                tag_offset += 2;\n            }\n            break;\n            case TAG_MIDS:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_mids, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_FHOL:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_fhol, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_STTL:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_sttl, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN);\n                tag_offset += 8;\n            break;\n            case TAG_SMHL:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_smhl, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_TBKP:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_tbkp, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += 4;\n            break;\n            case TAG_MAD0:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_mad0, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            default:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_unknown, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                expert_add_info_format(pinfo, ti_tag, &ei_gquic_tag_undecoded,\n                                 \"Dissector for (Google) QUIC Tag\"\n                                 \" %s (%s) code not implemented, Contact\"\n                                 \" Wireshark developers if you want this supported\", tvb_get_string_enc(wmem_packet_scope(), tvb, offset-8, 4, ENC_ASCII|ENC_NA), val_to_str(tag, tag_vals, \"Unknown\"));\n                tag_offset += tag_len;\n            break;\n        }\n        if(tag_offset != offset_end){\n            /* Wrong Tag len... */\n            proto_tree_add_expert(tag_tree, pinfo, &ei_gquic_tag_unknown, tvb, tag_offset_start + tag_offset, tag_len);\n            tag_offset = offset_end;\n        }\n\n        tag_number--;\n    }\n    return offset + total_tag_len;\n\n}",
        "func": "static guint32\ndissect_gquic_tag(tvbuff_t *tvb, packet_info *pinfo, proto_tree *gquic_tree, guint offset, guint32 tag_number){\n    guint32 tag_offset_start = offset + tag_number*4*2;\n    guint32 tag_offset = 0, total_tag_len = 0;\n    gint32 tag_len;\n\n    while(tag_number){\n        proto_tree *tag_tree, *ti_len, *ti_tag, *ti_type;\n        guint32 offset_end, tag;\n        const guint8* tag_str;\n\n        ti_tag = proto_tree_add_item(gquic_tree, hf_gquic_tags, tvb, offset, 8, ENC_NA);\n        tag_tree = proto_item_add_subtree(ti_tag, ett_gquic_tag_value);\n        ti_type = proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_type, tvb, offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n        tag = tvb_get_ntohl(tvb, offset);\n        proto_item_append_text(ti_type, \" (%s)\", val_to_str(tag, tag_vals, \"Unknown\"));\n        proto_item_append_text(ti_tag, \": %s (%s)\", tag_str, val_to_str(tag, tag_vals, \"Unknown\"));\n        offset += 4;\n\n        proto_tree_add_item(tag_tree, hf_gquic_tag_offset_end, tvb, offset, 4, ENC_LITTLE_ENDIAN);\n        offset_end = tvb_get_guint32(tvb, offset, ENC_LITTLE_ENDIAN);\n\n        tag_len = offset_end - tag_offset;\n        total_tag_len += tag_len;\n        ti_len = proto_tree_add_uint(tag_tree, hf_gquic_tag_length, tvb, offset, 4, tag_len);\n        proto_item_append_text(ti_tag, \" (l=%u)\", tag_len);\n        proto_item_set_generated(ti_len);\n        offset += 4;\n\n        /* Fix issue with CRT.. (Fragmentation ?) */\n        if( tag_len > tvb_reported_length_remaining(tvb, tag_offset_start + tag_offset)){\n            tag_len = tvb_reported_length_remaining(tvb, tag_offset_start + tag_offset);\n            offset_end = tag_offset + tag_len;\n            expert_add_info(pinfo, ti_len, &ei_gquic_tag_length);\n        }\n\n        proto_tree_add_item(tag_tree, hf_gquic_tag_value, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n\n        switch(tag){\n            case TAG_PAD:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_pad, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_SNI:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_sni, tvb, tag_offset_start + tag_offset, tag_len, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += tag_len;\n            break;\n            case TAG_VER:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_ver, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += 4;\n            break;\n            case TAG_CCS:\n                while(offset_end - tag_offset >= 8){\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_ccs, tvb, tag_offset_start + tag_offset, 8, ENC_NA);\n                    tag_offset += 8;\n                }\n            break;\n            case TAG_PDMD:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_pdmd, tvb, tag_offset_start + tag_offset, tag_len, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += tag_len;\n            break;\n            case TAG_UAID:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_uaid, tvb, tag_offset_start + tag_offset, tag_len, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += tag_len;\n            break;\n            case TAG_STK:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_stk, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_SNO:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_sno, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_PROF:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_prof, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_SCFG:{\n                guint32 scfg_tag_number;\n\n                proto_tree_add_item(tag_tree, hf_gquic_tag_scfg, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                tag_offset += 4;\n                proto_tree_add_item(tag_tree, hf_gquic_tag_scfg_number, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                scfg_tag_number = tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n\n                dissect_gquic_tag(tvb, pinfo, tag_tree, tag_offset_start + tag_offset, scfg_tag_number);\n                tag_offset += tag_len - 4 - 4;\n                }\n            break;\n            case TAG_RREJ:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_rrej, tvb, tag_offset_start + tag_offset, 4,  ENC_LITTLE_ENDIAN);\n                    proto_item_append_text(ti_tag, \", Code %s\", val_to_str_ext(tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN), &handshake_failure_reason_vals_ext, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_CRT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_crt, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_AEAD:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree *ti_aead;\n                    ti_aead = proto_tree_add_item(tag_tree, hf_gquic_tag_aead, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    proto_item_append_text(ti_aead, \" (%s)\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_aead_vals, \"Unknown\"));\n                    proto_item_append_text(ti_tag, \", %s\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_aead_vals, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_SCID:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_scid, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_PUBS:\n                /*TODO FIX: 24 Length + Pubs key?.. ! */\n                proto_tree_add_item(tag_tree, hf_gquic_tag_pubs, tvb, tag_offset_start + tag_offset, 2, ENC_LITTLE_ENDIAN);\n                tag_offset += 2;\n                while(offset_end - tag_offset >= 3){\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_pubs, tvb, tag_offset_start + tag_offset, 3, ENC_LITTLE_ENDIAN);\n                    tag_offset += 3;\n                }\n            break;\n            case TAG_KEXS:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree *ti_kexs;\n                    ti_kexs = proto_tree_add_item(tag_tree, hf_gquic_tag_kexs, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    proto_item_append_text(ti_kexs, \" (%s)\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_kexs_vals, \"Unknown\"));\n                    proto_item_append_text(ti_tag, \", %s\", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_kexs_vals, \"Unknown\"));\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_OBIT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_obit, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_EXPY:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_expy, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN);\n                tag_offset += 8;\n            break;\n            case TAG_NONC:\n                /*TODO: Enhance display: 32 bytes consisting of 4 bytes of timestamp (big-endian, UNIX epoch seconds), 8 bytes of server orbit and 20 bytes of random data. */\n                proto_tree_add_item(tag_tree, hf_gquic_tag_nonc, tvb, tag_offset_start + tag_offset, 32, ENC_NA);\n                tag_offset += 32;\n            break;\n            case TAG_MSPC:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_mspc, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_TCID:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_tcid, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n            break;\n            case TAG_SRBF:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_srbf, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n            break;\n            case TAG_ICSL:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_icsl, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n            break;\n            case TAG_SCLS:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_scls, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                tag_offset += 4;\n            break;\n            case TAG_COPT:\n                while(offset_end - tag_offset >= 4){\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_copt, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA);\n                    tag_offset += 4;\n                }\n            break;\n            case TAG_CCRT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_ccrt, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_IRTT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_irtt, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_CFCW:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_cfcw, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_SFCW:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_sfcw, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_CETV:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_cetv, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_XLCT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_xlct, tvb, tag_offset_start + tag_offset, 8, ENC_NA);\n                tag_offset += 8;\n            break;\n            case TAG_NONP:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_nonp, tvb, tag_offset_start + tag_offset, 32, ENC_NA);\n                tag_offset += 32;\n            break;\n            case TAG_CSCT:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_csct, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                tag_offset += tag_len;\n            break;\n            case TAG_CTIM:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_ctim, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN|ENC_TIME_SECS_NSECS);\n                tag_offset += 8;\n            break;\n            case TAG_RNON: /* Public Reset Tag */\n                proto_tree_add_item(tag_tree, hf_gquic_tag_rnon, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN);\n                tag_offset += 8;\n            break;\n            case TAG_RSEQ: /* Public Reset Tag */\n                proto_tree_add_item(tag_tree, hf_gquic_tag_rseq, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN);\n                tag_offset += 8;\n            break;\n            case TAG_CADR: /* Public Reset Tag */{\n                guint32 addr_type;\n                proto_tree_add_item_ret_uint(tag_tree, hf_gquic_tag_cadr_addr_type, tvb, tag_offset_start + tag_offset, 2, ENC_LITTLE_ENDIAN, &addr_type);\n                tag_offset += 2;\n                switch(addr_type){\n                    case 2: /* IPv4 */\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_cadr_addr_ipv4, tvb, tag_offset_start + tag_offset, 4, ENC_NA);\n                    tag_offset += 4;\n                    break;\n                    case 10: /* IPv6 */\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_cadr_addr_ipv6, tvb, tag_offset_start + tag_offset, 16, ENC_NA);\n                    tag_offset += 16;\n                    break;\n                    default: /* Unknown */\n                    proto_tree_add_item(tag_tree, hf_gquic_tag_cadr_addr, tvb, tag_offset_start + tag_offset, tag_len - 2 - 2, ENC_NA);\n                    tag_offset += tag_len + 2 + 2 ;\n                    break;\n                }\n                proto_tree_add_item(tag_tree, hf_gquic_tag_cadr_port, tvb, tag_offset_start + tag_offset, 2, ENC_LITTLE_ENDIAN);\n                tag_offset += 2;\n            }\n            break;\n            case TAG_MIDS:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_mids, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_FHOL:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_fhol, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_STTL:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_sttl, tvb, tag_offset_start + tag_offset, 8, ENC_LITTLE_ENDIAN);\n                tag_offset += 8;\n            break;\n            case TAG_SMHL:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_smhl, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            case TAG_TBKP:\n                proto_tree_add_item_ret_string(tag_tree, hf_gquic_tag_tbkp, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str);\n                proto_item_append_text(ti_tag, \": %s\", tag_str);\n                tag_offset += 4;\n            break;\n            case TAG_MAD0:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_mad0, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN);\n                proto_item_append_text(ti_tag, \": %u\", tvb_get_guint32(tvb, tag_offset_start + tag_offset, ENC_LITTLE_ENDIAN));\n                tag_offset += 4;\n            break;\n            default:\n                proto_tree_add_item(tag_tree, hf_gquic_tag_unknown, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA);\n                expert_add_info_format(pinfo, ti_tag, &ei_gquic_tag_undecoded,\n                                 \"Dissector for (Google) QUIC Tag\"\n                                 \" %s (%s) code not implemented, Contact\"\n                                 \" Wireshark developers if you want this supported\", tvb_get_string_enc(wmem_packet_scope(), tvb, offset-8, 4, ENC_ASCII|ENC_NA), val_to_str(tag, tag_vals, \"Unknown\"));\n                goto end;\n            break;\n        }\n        if(tag_offset != offset_end){\n            /* Wrong Tag len... */\n            proto_tree_add_expert(tag_tree, pinfo, &ei_gquic_tag_unknown, tvb, tag_offset_start + tag_offset, tag_len);\n            tag_offset = offset_end;\n        }\n\n        tag_number--;\n    }\n\n    end:\n    if (offset + total_tag_len <= offset) {\n        expert_add_info_format(pinfo, gquic_tree, &ei_gquic_length_invalid,\n                                \"Invalid total tag length: %u\", total_tag_len);\n        return offset + tvb_reported_length_remaining(tvb, offset);\n    }\n    return offset + total_tag_len;\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -278,7 +278,7 @@\n                                  \"Dissector for (Google) QUIC Tag\"\n                                  \" %s (%s) code not implemented, Contact\"\n                                  \" Wireshark developers if you want this supported\", tvb_get_string_enc(wmem_packet_scope(), tvb, offset-8, 4, ENC_ASCII|ENC_NA), val_to_str(tag, tag_vals, \"Unknown\"));\n-                tag_offset += tag_len;\n+                goto end;\n             break;\n         }\n         if(tag_offset != offset_end){\n@@ -289,6 +289,13 @@\n \n         tag_number--;\n     }\n+\n+    end:\n+    if (offset + total_tag_len <= offset) {\n+        expert_add_info_format(pinfo, gquic_tree, &ei_gquic_length_invalid,\n+                                \"Invalid total tag length: %u\", total_tag_len);\n+        return offset + tvb_reported_length_remaining(tvb, offset);\n+    }\n     return offset + total_tag_len;\n \n }",
        "diff_line_info": {
            "deleted_lines": [
                "                tag_offset += tag_len;"
            ],
            "added_lines": [
                "                goto end;",
                "",
                "    end:",
                "    if (offset + total_tag_len <= offset) {",
                "        expert_add_info_format(pinfo, gquic_tree, &ei_gquic_length_invalid,",
                "                                \"Invalid total tag length: %u\", total_tag_len);",
                "        return offset + tvb_reported_length_remaining(tvb, offset);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27152",
        "func_name": "torvalds/linux/ioapic_lazy_update_eoi",
        "description": "An issue was discovered in ioapic_lazy_update_eoi in arch/x86/kvm/ioapic.c in the Linux kernel before 5.9.2. It has an infinite loop related to improper interaction between a resampler and edge triggering, aka CID-77377064c3a9.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=77377064c3a94911339f13ce113b3abf265e06da",
        "commit_title": "During shutdown the IOAPIC trigger mode is reset to edge triggered",
        "commit_text": "while the vfio-pci INTx is still registered with a resampler. This allows us to get into an infinite loop:  ioapic_set_irq   -> ioapic_lazy_update_eoi   -> kvm_ioapic_update_eoi_one   -> kvm_notify_acked_irq   -> kvm_notify_acked_gsi   -> (via irq_acked fn ptr) irqfd_resampler_ack   -> kvm_set_irq   -> (via set fn ptr) kvm_set_ioapic_irq   -> kvm_ioapic_set_irq   -> ioapic_set_irq  Commit 8be8f932e3db (\"kvm: ioapic: Restrict lazy EOI update to edge-triggered interrupts\", 2020-05-04) acknowledges that this recursion loop exists and tries to avoid it at the call to ioapic_lazy_update_eoi, but at this point the scenario is already set, we have an edge interrupt with resampler on the same gsi.  Fortunately, the only user of irq ack notifiers (in addition to resamplefd) is i8254 timer interrupt reinjection.  These are edge-triggered, so in principle they would need the call to kvm_ioapic_update_eoi_one from ioapic_lazy_update_eoi, but they already disable AVIC(*), so they don't need the lazy EOI behavior.  Therefore, remove the call to kvm_ioapic_update_eoi_one from ioapic_lazy_update_eoi.  This fixes CVE-2020-27152.  Note that this issue cannot happen with SR-IOV assigned devices because virtual functions do not have INTx, only MSI.  Suggested-by: Paolo Bonzini <pbonzini@redhat.com> ",
        "func_before": "static void ioapic_lazy_update_eoi(struct kvm_ioapic *ioapic, int irq)\n{\n\tint i;\n\tstruct kvm_vcpu *vcpu;\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\n\tkvm_for_each_vcpu(i, vcpu, ioapic->kvm) {\n\t\tif (!kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,\n\t\t\t\t\t entry->fields.dest_id,\n\t\t\t\t\t entry->fields.dest_mode) ||\n\t\t    kvm_apic_pending_eoi(vcpu, entry->fields.vector))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If no longer has pending EOI in LAPICs, update\n\t\t * EOI for this vetor.\n\t\t */\n\t\trtc_irq_eoi(ioapic, vcpu, entry->fields.vector);\n\t\tkvm_ioapic_update_eoi_one(vcpu, ioapic,\n\t\t\t\t\t  entry->fields.trig_mode,\n\t\t\t\t\t  irq);\n\t\tbreak;\n\t}\n}",
        "func": "static void ioapic_lazy_update_eoi(struct kvm_ioapic *ioapic, int irq)\n{\n\tint i;\n\tstruct kvm_vcpu *vcpu;\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\n\tkvm_for_each_vcpu(i, vcpu, ioapic->kvm) {\n\t\tif (!kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,\n\t\t\t\t\t entry->fields.dest_id,\n\t\t\t\t\t entry->fields.dest_mode) ||\n\t\t    kvm_apic_pending_eoi(vcpu, entry->fields.vector))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If no longer has pending EOI in LAPICs, update\n\t\t * EOI for this vector.\n\t\t */\n\t\trtc_irq_eoi(ioapic, vcpu, entry->fields.vector);\n\t\tbreak;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,12 +13,9 @@\n \n \t\t/*\n \t\t * If no longer has pending EOI in LAPICs, update\n-\t\t * EOI for this vetor.\n+\t\t * EOI for this vector.\n \t\t */\n \t\trtc_irq_eoi(ioapic, vcpu, entry->fields.vector);\n-\t\tkvm_ioapic_update_eoi_one(vcpu, ioapic,\n-\t\t\t\t\t  entry->fields.trig_mode,\n-\t\t\t\t\t  irq);\n \t\tbreak;\n \t}\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t * EOI for this vetor.",
                "\t\tkvm_ioapic_update_eoi_one(vcpu, ioapic,",
                "\t\t\t\t\t  entry->fields.trig_mode,",
                "\t\t\t\t\t  irq);"
            ],
            "added_lines": [
                "\t\t * EOI for this vector."
            ]
        }
    },
    {
        "cve_id": "CVE-2020-29385",
        "func_name": "GNOME/gdk-pixbuf/lzw_decoder_feed",
        "description": "GNOME gdk-pixbuf (aka GdkPixbuf) before 2.42.2 allows a denial of service (infinite loop) in lzw.c in the function write_indexes. if c->self_code equals 10, self->code_table[10].extends will assign the value 11 to c. The next execution in the loop will assign self->code_table[11].extends to c, which will give the value of 10. This will make the loop run infinitely. This bug can, for example, be triggered by calling this function with a GIF image with LZW compression that is crafted in a special way.",
        "git_url": "https://github.com/GNOME/gdk-pixbuf/commit/bdd3acbd48a575d418ba6bf1b32d7bda2fae1c81",
        "commit_title": "gif: Fix LZW decoder accepting invalid LZW code.",
        "commit_text": " The code value after a reset wasn't being validated, which means we would accept invalid codes. This could cause an infinite loop in the decoder.  Fixes CVE-2020-29385  Fixes https://gitlab.gnome.org/GNOME/gdk-pixbuf/-/issues/164",
        "func_before": "gsize\nlzw_decoder_feed (LZWDecoder *self,\n                  guint8     *input,\n                  gsize       input_length,\n                  guint8     *output,\n                  gsize       output_length)\n{\n        gsize i, n_written = 0;\n\n        g_return_val_if_fail (LZW_IS_DECODER (self), 0);\n\n        /* Ignore data after \"end of information\" codeword */\n        if (self->last_code == self->eoi_code)\n                return 0;\n\n        /* Processes each octet of input */\n        for (i = 0; i < input_length; i++) {\n                guint8 d = input[i];\n                int n_available;\n\n                /* Process the bits of the octet into codewords */\n                for (n_available = 8; n_available > 0; ) {\n                        int n_bits, new_bits;\n\n                        /* Extract up the the required number of bits from the octet */\n                        n_bits = MIN (self->code_size - self->code_bits, n_available);\n                        new_bits = d & ((1 << n_bits) - 1);\n                        d = d >> n_bits;\n                        n_available -= n_bits;\n\n                        /* Add the new bits to the code until we have a full codeword */\n                        self->code = new_bits << self->code_bits | self->code;\n                        self->code_bits += n_bits;\n                        if (self->code_bits < self->code_size)\n                                continue;\n\n                        /* Stop on \"end of information\" codeword */\n                        if (self->code == self->eoi_code) {\n                                self->last_code = self->code;\n                                return n_written;\n                        }\n\n                        /* Reset the code table on \"clear\" */\n                        if (self->code == self->clear_code) {\n                                self->code_table_size = self->eoi_code + 1;\n                                self->code_size = self->min_code_size;\n                        } else {\n                                /* Add a new code word if space.\n                                 * The first code after a clear is skipped */\n                                if (self->last_code != self->clear_code && self->code_table_size < MAX_CODES) {\n                                        if (self->code < self->code_table_size)\n                                                add_code (self, self->code);\n                                        else if (self->code == self->code_table_size)\n                                                add_code (self, self->last_code);\n                                        else {\n                                                /* Invalid code received - just stop here */\n                                                self->last_code = self->eoi_code;\n                                                return output_length;\n                                        }\n\n                                        /* When table is full increase code size */\n                                        if (self->code_table_size == (1 << self->code_size) && self->code_size < LZW_CODE_MAX)\n                                                self->code_size++;\n                                }\n\n                                /* Convert codeword into indexes */\n                                n_written += write_indexes (self, output + n_written, output_length - n_written);\n                        }\n\n                        self->last_code = self->code;\n                        self->code = 0;\n                        self->code_bits = 0;\n\n                        /* Out of space */\n                        if (n_written >= output_length)\n                                return output_length;\n                }\n        }\n\n        return n_written;\n}",
        "func": "gsize\nlzw_decoder_feed (LZWDecoder *self,\n                  guint8     *input,\n                  gsize       input_length,\n                  guint8     *output,\n                  gsize       output_length)\n{\n        gsize i, n_written = 0;\n\n        g_return_val_if_fail (LZW_IS_DECODER (self), 0);\n\n        /* Ignore data after \"end of information\" codeword */\n        if (self->last_code == self->eoi_code)\n                return 0;\n\n        /* Processes each octet of input */\n        for (i = 0; i < input_length; i++) {\n                guint8 d = input[i];\n                int n_available;\n\n                /* Process the bits of the octet into codewords */\n                for (n_available = 8; n_available > 0; ) {\n                        int n_bits, new_bits;\n\n                        /* Extract up the the required number of bits from the octet */\n                        n_bits = MIN (self->code_size - self->code_bits, n_available);\n                        new_bits = d & ((1 << n_bits) - 1);\n                        d = d >> n_bits;\n                        n_available -= n_bits;\n\n                        /* Add the new bits to the code until we have a full codeword */\n                        self->code = new_bits << self->code_bits | self->code;\n                        self->code_bits += n_bits;\n                        if (self->code_bits < self->code_size)\n                                continue;\n\n                        /* Stop on \"end of information\" codeword */\n                        if (self->code == self->eoi_code) {\n                                self->last_code = self->code;\n                                return n_written;\n                        }\n\n                        /* Reset the code table on \"clear\" */\n                        if (self->code == self->clear_code) {\n                                self->code_table_size = self->eoi_code + 1;\n                                self->code_size = self->min_code_size;\n                        } else {\n                                /* Add a new code word if space.\n                                 * The first code after a clear is skipped */\n                                if (self->last_code != self->clear_code && self->code_table_size < MAX_CODES) {\n                                        if (self->code < self->code_table_size)\n                                                add_code (self, self->code);\n                                        else\n                                                add_code (self, self->last_code);\n\n                                        /* When table is full increase code size */\n                                        if (self->code_table_size == (1 << self->code_size) && self->code_size < LZW_CODE_MAX)\n                                                self->code_size++;\n                                }\n\n                                /* Invalid code received - just stop here */\n                                if (self->code >= self->code_table_size) {\n                                        self->last_code = self->eoi_code;\n                                        return output_length;\n                                }\n\n                                /* Convert codeword into indexes */\n                                n_written += write_indexes (self, output + n_written, output_length - n_written);\n                        }\n\n                        self->last_code = self->code;\n                        self->code = 0;\n                        self->code_bits = 0;\n\n                        /* Out of space */\n                        if (n_written >= output_length)\n                                return output_length;\n                }\n        }\n\n        return n_written;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -50,17 +50,18 @@\n                                 if (self->last_code != self->clear_code && self->code_table_size < MAX_CODES) {\n                                         if (self->code < self->code_table_size)\n                                                 add_code (self, self->code);\n-                                        else if (self->code == self->code_table_size)\n+                                        else\n                                                 add_code (self, self->last_code);\n-                                        else {\n-                                                /* Invalid code received - just stop here */\n-                                                self->last_code = self->eoi_code;\n-                                                return output_length;\n-                                        }\n \n                                         /* When table is full increase code size */\n                                         if (self->code_table_size == (1 << self->code_size) && self->code_size < LZW_CODE_MAX)\n                                                 self->code_size++;\n+                                }\n+\n+                                /* Invalid code received - just stop here */\n+                                if (self->code >= self->code_table_size) {\n+                                        self->last_code = self->eoi_code;\n+                                        return output_length;\n                                 }\n \n                                 /* Convert codeword into indexes */",
        "diff_line_info": {
            "deleted_lines": [
                "                                        else if (self->code == self->code_table_size)",
                "                                        else {",
                "                                                /* Invalid code received - just stop here */",
                "                                                self->last_code = self->eoi_code;",
                "                                                return output_length;",
                "                                        }"
            ],
            "added_lines": [
                "                                        else",
                "                                }",
                "",
                "                                /* Invalid code received - just stop here */",
                "                                if (self->code >= self->code_table_size) {",
                "                                        self->last_code = self->eoi_code;",
                "                                        return output_length;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-24944",
        "func_name": "private-octopus/picoquic/picoquic_decode_new_connection_id_frame",
        "description": "picoquic (before 3rd of July 2020) allows attackers to cause a denial of service (infinite loop) via a crafted QUIC frame, related to the picoquic_decode_frames and picoquic_decode_stream_frame functions and epoch==3.",
        "git_url": "https://github.com/private-octopus/picoquic/commit/340cff2af3879e4c7fb59698f04e0b4bbd33decb",
        "commit_title": "Reproduce and fix stream decode loop, add tests",
        "commit_text": "",
        "func_before": "uint8_t* picoquic_decode_new_connection_id_frame(picoquic_cnx_t* cnx, uint8_t* bytes, const uint8_t* bytes_max, uint64_t current_time)\n{\n    /* store the connection ID in order to support migration. */\n    uint64_t sequence = 0;\n    uint64_t retire_before = 0;\n    uint8_t cid_length = 0;\n    uint8_t * cnxid_bytes = NULL;\n    uint8_t * secret_bytes = NULL;\n\n    if ((bytes = picoquic_frames_varint_decode(bytes + 1, bytes_max, &sequence)) != NULL) {\n        bytes = picoquic_frames_varint_decode(bytes, bytes_max, &retire_before);\n        if (bytes != NULL) {\n            bytes = picoquic_frames_uint8_decode(bytes, bytes_max, &cid_length);\n        }\n    }\n\n    if (bytes != NULL) {\n        cnxid_bytes = bytes;\n        secret_bytes = bytes + cid_length;\n        bytes = picoquic_frames_fixed_skip(bytes, bytes_max, (size_t)cid_length + PICOQUIC_RESET_SECRET_SIZE);\n    }\n\n    if (bytes == NULL || cid_length > PICOQUIC_CONNECTION_ID_MAX_SIZE ||\n        retire_before > sequence) {\n        picoquic_connection_error(cnx, (bytes == NULL) ? PICOQUIC_TRANSPORT_FRAME_FORMAT_ERROR : PICOQUIC_TRANSPORT_PROTOCOL_VIOLATION,\n            picoquic_frame_type_new_connection_id);\n    } else {\n        uint16_t ret = 0;\n\n        if (bytes != NULL && retire_before > cnx->retire_cnxid_before) {\n            /* TODO: retire the now deprecated CID */\n            ret = (uint16_t)picoquic_remove_not_before_cid(cnx, retire_before, current_time);\n        }\n        if (ret == 0 && sequence >= cnx->retire_cnxid_before) {\n            ret = (uint16_t)picoquic_enqueue_cnxid_stash(cnx, sequence, cid_length, cnxid_bytes, secret_bytes, NULL);\n        }\n        if (ret != 0) {\n            picoquic_connection_error(cnx, ret, picoquic_frame_type_new_connection_id);\n            bytes = NULL;\n        }\n    }\n\n    return bytes;\n}",
        "func": "uint8_t* picoquic_decode_new_connection_id_frame(picoquic_cnx_t* cnx, uint8_t* bytes, const uint8_t* bytes_max, uint64_t current_time)\n{\n    /* store the connection ID in order to support migration. */\n    uint64_t sequence = 0;\n    uint64_t retire_before = 0;\n    uint8_t cid_length = 0;\n    uint8_t * cnxid_bytes = NULL;\n    uint8_t * secret_bytes = NULL;\n\n    if ((bytes = picoquic_frames_varint_decode(bytes + 1, bytes_max, &sequence)) != NULL) {\n        bytes = picoquic_frames_varint_decode(bytes, bytes_max, &retire_before);\n        if (bytes != NULL) {\n            bytes = picoquic_frames_uint8_decode(bytes, bytes_max, &cid_length);\n        }\n    }\n\n    if (bytes != NULL) {\n        cnxid_bytes = bytes;\n        secret_bytes = bytes + cid_length;\n        bytes = picoquic_frames_fixed_skip(bytes, bytes_max, (size_t)cid_length + PICOQUIC_RESET_SECRET_SIZE);\n    }\n\n    if (bytes == NULL || cid_length > PICOQUIC_CONNECTION_ID_MAX_SIZE ||\n        retire_before > sequence) {\n        picoquic_connection_error(cnx, (bytes == NULL) ? PICOQUIC_TRANSPORT_FRAME_FORMAT_ERROR : PICOQUIC_TRANSPORT_PROTOCOL_VIOLATION,\n            picoquic_frame_type_new_connection_id);\n        bytes = NULL;\n    } else {\n        uint16_t ret = 0;\n\n        if (bytes != NULL && retire_before > cnx->retire_cnxid_before) {\n            /* TODO: retire the now deprecated CID */\n            ret = (uint16_t)picoquic_remove_not_before_cid(cnx, retire_before, current_time);\n        }\n        if (ret == 0 && sequence >= cnx->retire_cnxid_before) {\n            ret = (uint16_t)picoquic_enqueue_cnxid_stash(cnx, sequence, cid_length, cnxid_bytes, secret_bytes, NULL);\n        }\n        if (ret != 0) {\n            picoquic_connection_error(cnx, ret, picoquic_frame_type_new_connection_id);\n            bytes = NULL;\n        }\n    }\n\n    return bytes;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,6 +24,7 @@\n         retire_before > sequence) {\n         picoquic_connection_error(cnx, (bytes == NULL) ? PICOQUIC_TRANSPORT_FRAME_FORMAT_ERROR : PICOQUIC_TRANSPORT_PROTOCOL_VIOLATION,\n             picoquic_frame_type_new_connection_id);\n+        bytes = NULL;\n     } else {\n         uint16_t ret = 0;\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        bytes = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-24944",
        "func_name": "private-octopus/picoquic/picoquic_decode_stop_sending_frame",
        "description": "picoquic (before 3rd of July 2020) allows attackers to cause a denial of service (infinite loop) via a crafted QUIC frame, related to the picoquic_decode_frames and picoquic_decode_stream_frame functions and epoch==3.",
        "git_url": "https://github.com/private-octopus/picoquic/commit/340cff2af3879e4c7fb59698f04e0b4bbd33decb",
        "commit_title": "Reproduce and fix stream decode loop, add tests",
        "commit_text": "",
        "func_before": "uint8_t* picoquic_decode_stop_sending_frame(picoquic_cnx_t* cnx, uint8_t* bytes, const uint8_t* bytes_max)\n{\n    uint64_t stream_id = 0;\n    uint64_t error_code = 0;\n    picoquic_stream_head_t* stream;\n\n    if ((bytes = picoquic_frames_varint_decode(bytes+1, bytes_max, &stream_id))  == NULL ||\n        (bytes = picoquic_frames_varint_decode(bytes,   bytes_max, &error_code)) == NULL)\n    {\n        picoquic_connection_error(cnx, PICOQUIC_TRANSPORT_FRAME_FORMAT_ERROR,\n            picoquic_frame_type_stop_sending);\n\n    }\n    else if ((stream = picoquic_find_or_create_stream(cnx, stream_id, 1)) == NULL) {\n        bytes = NULL;  // Error already signaled\n    } else if (!IS_BIDIR_STREAM_ID(stream_id) && !IS_LOCAL_STREAM_ID(stream_id, cnx->client_mode)) {\n        picoquic_connection_error(cnx, PICOQUIC_TRANSPORT_PROTOCOL_VIOLATION,\n            picoquic_frame_type_stop_sending);\n    } else if (!stream->stop_sending_received && !stream->reset_requested) {\n        stream->stop_sending_received = 1;\n        stream->remote_stop_error = error_code;\n\n        if (cnx->callback_fn != NULL && !stream->stop_sending_signalled) {\n            if (cnx->callback_fn(cnx, stream->stream_id, NULL, 0, picoquic_callback_stop_sending, cnx->callback_ctx, stream->app_stream_ctx) != 0) {\n                picoquic_log_app_message(cnx->quic, &cnx->initial_cnxid, \"Stop sending callback on stream %\" PRIu64 \" returns error 0x%x\",\n                    stream->stream_id, PICOQUIC_TRANSPORT_INTERNAL_ERROR);\n                picoquic_connection_error(cnx, PICOQUIC_TRANSPORT_INTERNAL_ERROR,\n                    picoquic_frame_type_stop_sending);\n            }\n            stream->stop_sending_signalled = 1;\n        }\n    }\n\n    return bytes;\n}",
        "func": "uint8_t* picoquic_decode_stop_sending_frame(picoquic_cnx_t* cnx, uint8_t* bytes, const uint8_t* bytes_max)\n{\n    uint64_t stream_id = 0;\n    uint64_t error_code = 0;\n    picoquic_stream_head_t* stream;\n\n    if ((bytes = picoquic_frames_varint_decode(bytes+1, bytes_max, &stream_id))  == NULL ||\n        (bytes = picoquic_frames_varint_decode(bytes,   bytes_max, &error_code)) == NULL)\n    {\n        picoquic_connection_error(cnx, PICOQUIC_TRANSPORT_FRAME_FORMAT_ERROR,\n            picoquic_frame_type_stop_sending);\n\n    }\n    else if ((stream = picoquic_find_or_create_stream(cnx, stream_id, 1)) == NULL) {\n        bytes = NULL;  // Error already signaled\n    } else if (!IS_BIDIR_STREAM_ID(stream_id) && !IS_LOCAL_STREAM_ID(stream_id, cnx->client_mode)) {\n        picoquic_connection_error(cnx, PICOQUIC_TRANSPORT_PROTOCOL_VIOLATION,\n            picoquic_frame_type_stop_sending);\n        bytes = NULL;\n    } else if (!stream->stop_sending_received && !stream->reset_requested) {\n        stream->stop_sending_received = 1;\n        stream->remote_stop_error = error_code;\n\n        if (cnx->callback_fn != NULL && !stream->stop_sending_signalled) {\n            if (cnx->callback_fn(cnx, stream->stream_id, NULL, 0, picoquic_callback_stop_sending, cnx->callback_ctx, stream->app_stream_ctx) != 0) {\n                picoquic_log_app_message(cnx->quic, &cnx->initial_cnxid, \"Stop sending callback on stream %\" PRIu64 \" returns error 0x%x\",\n                    stream->stream_id, PICOQUIC_TRANSPORT_INTERNAL_ERROR);\n                picoquic_connection_error(cnx, PICOQUIC_TRANSPORT_INTERNAL_ERROR,\n                    picoquic_frame_type_stop_sending);\n            }\n            stream->stop_sending_signalled = 1;\n        }\n    }\n\n    return bytes;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,6 +16,7 @@\n     } else if (!IS_BIDIR_STREAM_ID(stream_id) && !IS_LOCAL_STREAM_ID(stream_id, cnx->client_mode)) {\n         picoquic_connection_error(cnx, PICOQUIC_TRANSPORT_PROTOCOL_VIOLATION,\n             picoquic_frame_type_stop_sending);\n+        bytes = NULL;\n     } else if (!stream->stop_sending_received && !stream->reset_requested) {\n         stream->stop_sending_received = 1;\n         stream->remote_stop_error = error_code;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        bytes = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-24944",
        "func_name": "private-octopus/picoquic/picoquic_decode_stream_frame",
        "description": "picoquic (before 3rd of July 2020) allows attackers to cause a denial of service (infinite loop) via a crafted QUIC frame, related to the picoquic_decode_frames and picoquic_decode_stream_frame functions and epoch==3.",
        "git_url": "https://github.com/private-octopus/picoquic/commit/340cff2af3879e4c7fb59698f04e0b4bbd33decb",
        "commit_title": "Reproduce and fix stream decode loop, add tests",
        "commit_text": "",
        "func_before": "uint8_t* picoquic_decode_stream_frame(picoquic_cnx_t* cnx, uint8_t* bytes, const uint8_t* bytes_max, uint64_t current_time)\n{\n    uint64_t stream_id;\n    size_t   data_length;\n    uint64_t offset;\n    int      fin;\n    size_t   consumed;\n\n    if (picoquic_parse_stream_header(bytes, bytes_max - bytes, &stream_id, &offset, &data_length, &fin, &consumed) != 0) {\n        bytes = NULL;\n    }else if (offset + data_length >= (1ull<<62)){\n        picoquic_connection_error(cnx, PICOQUIC_TRANSPORT_FINAL_OFFSET_ERROR, 0);\n    } else if (picoquic_stream_network_input(cnx, stream_id, offset, fin, (bytes += consumed), data_length, current_time) != 0) {\n        bytes = NULL;\n    } else {\n        bytes += data_length;\n    }\n\n    return bytes;\n}",
        "func": "uint8_t* picoquic_decode_stream_frame(picoquic_cnx_t* cnx, uint8_t* bytes, const uint8_t* bytes_max, uint64_t current_time)\n{\n    uint64_t stream_id;\n    size_t   data_length;\n    uint64_t offset;\n    int      fin;\n    size_t   consumed;\n\n    if (picoquic_parse_stream_header(bytes, bytes_max - bytes, &stream_id, &offset, &data_length, &fin, &consumed) != 0) {\n        bytes = NULL;\n    }else if (offset + data_length >= (1ull<<62)){\n        picoquic_connection_error(cnx, PICOQUIC_TRANSPORT_FINAL_OFFSET_ERROR, 0);\n        bytes = NULL;\n    } else if (picoquic_stream_network_input(cnx, stream_id, offset, fin, (bytes += consumed), data_length, current_time) != 0) {\n        bytes = NULL;\n    } else {\n        bytes += data_length;\n    }\n\n    return bytes;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,7 @@\n         bytes = NULL;\n     }else if (offset + data_length >= (1ull<<62)){\n         picoquic_connection_error(cnx, PICOQUIC_TRANSPORT_FINAL_OFFSET_ERROR, 0);\n+        bytes = NULL;\n     } else if (picoquic_stream_network_input(cnx, stream_id, offset, fin, (bytes += consumed), data_length, current_time) != 0) {\n         bytes = NULL;\n     } else {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        bytes = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-36310",
        "func_name": "torvalds/linux/svm_need_emulation_on_page_fault",
        "description": "An issue was discovered in the Linux kernel before 5.8. arch/x86/kvm/svm/svm.c allows a set_memory_region_test infinite loop for certain nested page faults, aka CID-e72436bc3a52.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=e72436bc3a5206f95bb384e741154166ddb3202e",
        "commit_title": "When a nested page fault is taken from an address that does not have",
        "commit_text": "a memslot associated to it, kvm_mmu_do_page_fault returns RET_PF_EMULATE (via mmu_set_spte) and kvm_mmu_page_fault then invokes svm_need_emulation_on_page_fault.  The default answer there is to return false, but in this case this just causes the page fault to be retried ad libitum.  Since this is not a fast path, and the only other case where it is taken is an erratum, just stick a kvm_vcpu_gfn_to_memslot check in there to detect the common case where the erratum is not happening.  This fixes an infinite loop in the new set_memory_region_test.  ",
        "func_before": "static bool svm_need_emulation_on_page_fault(struct kvm_vcpu *vcpu)\n{\n\tunsigned long cr4 = kvm_read_cr4(vcpu);\n\tbool smep = cr4 & X86_CR4_SMEP;\n\tbool smap = cr4 & X86_CR4_SMAP;\n\tbool is_user = svm_get_cpl(vcpu) == 3;\n\n\t/*\n\t * Detect and workaround Errata 1096 Fam_17h_00_0Fh.\n\t *\n\t * Errata:\n\t * When CPU raise #NPF on guest data access and vCPU CR4.SMAP=1, it is\n\t * possible that CPU microcode implementing DecodeAssist will fail\n\t * to read bytes of instruction which caused #NPF. In this case,\n\t * GuestIntrBytes field of the VMCB on a VMEXIT will incorrectly\n\t * return 0 instead of the correct guest instruction bytes.\n\t *\n\t * This happens because CPU microcode reading instruction bytes\n\t * uses a special opcode which attempts to read data using CPL=0\n\t * priviledges. The microcode reads CS:RIP and if it hits a SMAP\n\t * fault, it gives up and returns no instruction bytes.\n\t *\n\t * Detection:\n\t * We reach here in case CPU supports DecodeAssist, raised #NPF and\n\t * returned 0 in GuestIntrBytes field of the VMCB.\n\t * First, errata can only be triggered in case vCPU CR4.SMAP=1.\n\t * Second, if vCPU CR4.SMEP=1, errata could only be triggered\n\t * in case vCPU CPL==3 (Because otherwise guest would have triggered\n\t * a SMEP fault instead of #NPF).\n\t * Otherwise, vCPU CR4.SMEP=0, errata could be triggered by any vCPU CPL.\n\t * As most guests enable SMAP if they have also enabled SMEP, use above\n\t * logic in order to attempt minimize false-positive of detecting errata\n\t * while still preserving all cases semantic correctness.\n\t *\n\t * Workaround:\n\t * To determine what instruction the guest was executing, the hypervisor\n\t * will have to decode the instruction at the instruction pointer.\n\t *\n\t * In non SEV guest, hypervisor will be able to read the guest\n\t * memory to decode the instruction pointer when insn_len is zero\n\t * so we return true to indicate that decoding is possible.\n\t *\n\t * But in the SEV guest, the guest memory is encrypted with the\n\t * guest specific key and hypervisor will not be able to decode the\n\t * instruction pointer so we will not able to workaround it. Lets\n\t * print the error and request to kill the guest.\n\t */\n\tif (smap && (!smep || is_user)) {\n\t\tif (!sev_guest(vcpu->kvm))\n\t\t\treturn true;\n\n\t\tpr_err_ratelimited(\"KVM: SEV Guest triggered AMD Erratum 1096\\n\");\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t}\n\n\treturn false;\n}",
        "func": "static bool svm_need_emulation_on_page_fault(struct kvm_vcpu *vcpu)\n{\n\tunsigned long cr4 = kvm_read_cr4(vcpu);\n\tbool smep = cr4 & X86_CR4_SMEP;\n\tbool smap = cr4 & X86_CR4_SMAP;\n\tbool is_user = svm_get_cpl(vcpu) == 3;\n\n\t/*\n\t * If RIP is invalid, go ahead with emulation which will cause an\n\t * internal error exit.\n\t */\n\tif (!kvm_vcpu_gfn_to_memslot(vcpu, kvm_rip_read(vcpu) >> PAGE_SHIFT))\n\t\treturn true;\n\n\t/*\n\t * Detect and workaround Errata 1096 Fam_17h_00_0Fh.\n\t *\n\t * Errata:\n\t * When CPU raise #NPF on guest data access and vCPU CR4.SMAP=1, it is\n\t * possible that CPU microcode implementing DecodeAssist will fail\n\t * to read bytes of instruction which caused #NPF. In this case,\n\t * GuestIntrBytes field of the VMCB on a VMEXIT will incorrectly\n\t * return 0 instead of the correct guest instruction bytes.\n\t *\n\t * This happens because CPU microcode reading instruction bytes\n\t * uses a special opcode which attempts to read data using CPL=0\n\t * priviledges. The microcode reads CS:RIP and if it hits a SMAP\n\t * fault, it gives up and returns no instruction bytes.\n\t *\n\t * Detection:\n\t * We reach here in case CPU supports DecodeAssist, raised #NPF and\n\t * returned 0 in GuestIntrBytes field of the VMCB.\n\t * First, errata can only be triggered in case vCPU CR4.SMAP=1.\n\t * Second, if vCPU CR4.SMEP=1, errata could only be triggered\n\t * in case vCPU CPL==3 (Because otherwise guest would have triggered\n\t * a SMEP fault instead of #NPF).\n\t * Otherwise, vCPU CR4.SMEP=0, errata could be triggered by any vCPU CPL.\n\t * As most guests enable SMAP if they have also enabled SMEP, use above\n\t * logic in order to attempt minimize false-positive of detecting errata\n\t * while still preserving all cases semantic correctness.\n\t *\n\t * Workaround:\n\t * To determine what instruction the guest was executing, the hypervisor\n\t * will have to decode the instruction at the instruction pointer.\n\t *\n\t * In non SEV guest, hypervisor will be able to read the guest\n\t * memory to decode the instruction pointer when insn_len is zero\n\t * so we return true to indicate that decoding is possible.\n\t *\n\t * But in the SEV guest, the guest memory is encrypted with the\n\t * guest specific key and hypervisor will not be able to decode the\n\t * instruction pointer so we will not able to workaround it. Lets\n\t * print the error and request to kill the guest.\n\t */\n\tif (smap && (!smep || is_user)) {\n\t\tif (!sev_guest(vcpu->kvm))\n\t\t\treturn true;\n\n\t\tpr_err_ratelimited(\"KVM: SEV Guest triggered AMD Erratum 1096\\n\");\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t}\n\n\treturn false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,13 @@\n \tbool smep = cr4 & X86_CR4_SMEP;\n \tbool smap = cr4 & X86_CR4_SMAP;\n \tbool is_user = svm_get_cpl(vcpu) == 3;\n+\n+\t/*\n+\t * If RIP is invalid, go ahead with emulation which will cause an\n+\t * internal error exit.\n+\t */\n+\tif (!kvm_vcpu_gfn_to_memslot(vcpu, kvm_rip_read(vcpu) >> PAGE_SHIFT))\n+\t\treturn true;\n \n \t/*\n \t * Detect and workaround Errata 1096 Fam_17h_00_0Fh.",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\t/*",
                "\t * If RIP is invalid, go ahead with emulation which will cause an",
                "\t * internal error exit.",
                "\t */",
                "\tif (!kvm_vcpu_gfn_to_memslot(vcpu, kvm_rip_read(vcpu) >> PAGE_SHIFT))",
                "\t\treturn true;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-4511",
        "func_name": "wireshark/dissect_data_element",
        "description": "BT SDP dissector infinite loop in Wireshark 4.0.0 to 4.0.7 and 3.6.0 to 3.6.15 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/ef9c79ae81b00a63aa8638076ec81dc9482972e9",
        "commit_title": "btsdp: Keep offset advancing",
        "commit_text": " hf_data_element_value is a FT_NONE, so we can add the item with the expected length and get_hfi_length() will adjust the length without throwing an exception. There's no need to add it with zero length and call proto_item_set_len. Also, don't increment the offset by 0 instead of the real length when there isn't enough data in the packet, as that can lead to failing to advance the offset.  When dissecting a sequence type (sequence or alternative) and recursing into the sequence member, instead of using the main packet tvb directly, create a subset using the indicated length of the sequence. That will properly throw an exception if a contained item is larger than the containing sequence, instead of dissecting the same bytes as several different items (inside the sequence recursively, as well in the outer loop.)  Fix #19258 ",
        "func_before": "static gint\ndissect_data_element(proto_tree *tree, proto_tree **next_tree,\n        packet_info *pinfo, tvbuff_t *tvb, gint offset)\n{\n    proto_item  *pitem;\n    proto_tree  *ptree;\n    gint        new_offset;\n    gint        length;\n    gint        len;\n    guint8      type;\n    guint8      size;\n\n    new_offset = get_type_length(tvb, offset, &length) - 1;\n    type = tvb_get_guint8(tvb, offset);\n    size = type & 0x07;\n    type = type >> 3;\n\n    pitem = proto_tree_add_none_format(tree, hf_data_element, tvb, offset, 0, \"Data Element: %s %s\",\n            val_to_str_const(type, vs_data_element_type, \"Unknown Type\"),\n            val_to_str_const(size, vs_data_element_size, \"Unknown Size\"));\n    ptree = proto_item_add_subtree(pitem, ett_btsdp_data_element);\n\n    len = (new_offset - offset) + length;\n\n    proto_item_set_len(pitem, len + 1);\n\n    proto_tree_add_item(ptree, hf_data_element_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item(ptree, hf_data_element_size, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n\n    if (new_offset > offset - 1) {\n        proto_tree_add_uint(ptree, hf_data_element_var_size, tvb,\n                offset, len - length, length);\n        proto_item_append_text(pitem, (length != 1) ? \" %u bytes\" : \" %u byte\", length);\n        offset += len - length;\n    }\n\n    pitem = proto_tree_add_item(ptree, hf_data_element_value, tvb, offset,  0, ENC_NA);\n    if (length > tvb_reported_length_remaining(tvb, offset)) {\n        expert_add_info(pinfo, pitem, &ei_data_element_value_large);\n        length = 0;\n    }\n    proto_item_set_len(pitem, length);\n    if (length == 0)\n        proto_item_append_text(pitem, \": MISSING\");\n\n    if (next_tree) *next_tree = proto_item_add_subtree(pitem, ett_btsdp_data_element_value);\n    offset += length;\n\n    return offset;\n}",
        "func": "static gint\ndissect_data_element(proto_tree *tree, proto_tree **next_tree,\n        packet_info *pinfo, tvbuff_t *tvb, gint offset)\n{\n    proto_item  *pitem;\n    proto_tree  *ptree;\n    gint        new_offset;\n    gint        length;\n    gint        len;\n    guint8      type;\n    guint8      size;\n\n    new_offset = get_type_length(tvb, offset, &length) - 1;\n    type = tvb_get_guint8(tvb, offset);\n    size = type & 0x07;\n    type = type >> 3;\n\n    pitem = proto_tree_add_none_format(tree, hf_data_element, tvb, offset, 0, \"Data Element: %s %s\",\n            val_to_str_const(type, vs_data_element_type, \"Unknown Type\"),\n            val_to_str_const(size, vs_data_element_size, \"Unknown Size\"));\n    ptree = proto_item_add_subtree(pitem, ett_btsdp_data_element);\n\n    len = (new_offset - offset) + length;\n\n    proto_item_set_len(pitem, len + 1);\n\n    proto_tree_add_item(ptree, hf_data_element_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n    proto_tree_add_item(ptree, hf_data_element_size, tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset += 1;\n\n    if (new_offset > offset - 1) {\n        proto_tree_add_uint(ptree, hf_data_element_var_size, tvb,\n                offset, len - length, length);\n        proto_item_append_text(pitem, (length != 1) ? \" %u bytes\" : \" %u byte\", length);\n        offset += len - length;\n    }\n\n    pitem = proto_tree_add_item(ptree, hf_data_element_value, tvb, offset, length, ENC_NA);\n    if (length > tvb_reported_length_remaining(tvb, offset)) {\n        expert_add_info(pinfo, pitem, &ei_data_element_value_large);\n        proto_item_append_text(pitem, \": MISSING\");\n    } else if (length == 0)\n        proto_item_append_text(pitem, \": MISSING\");\n\n    if (next_tree) *next_tree = proto_item_add_subtree(pitem, ett_btsdp_data_element_value);\n    offset += length;\n\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -35,13 +35,11 @@\n         offset += len - length;\n     }\n \n-    pitem = proto_tree_add_item(ptree, hf_data_element_value, tvb, offset,  0, ENC_NA);\n+    pitem = proto_tree_add_item(ptree, hf_data_element_value, tvb, offset, length, ENC_NA);\n     if (length > tvb_reported_length_remaining(tvb, offset)) {\n         expert_add_info(pinfo, pitem, &ei_data_element_value_large);\n-        length = 0;\n-    }\n-    proto_item_set_len(pitem, length);\n-    if (length == 0)\n+        proto_item_append_text(pitem, \": MISSING\");\n+    } else if (length == 0)\n         proto_item_append_text(pitem, \": MISSING\");\n \n     if (next_tree) *next_tree = proto_item_add_subtree(pitem, ett_btsdp_data_element_value);",
        "diff_line_info": {
            "deleted_lines": [
                "    pitem = proto_tree_add_item(ptree, hf_data_element_value, tvb, offset,  0, ENC_NA);",
                "        length = 0;",
                "    }",
                "    proto_item_set_len(pitem, length);",
                "    if (length == 0)"
            ],
            "added_lines": [
                "    pitem = proto_tree_add_item(ptree, hf_data_element_value, tvb, offset, length, ENC_NA);",
                "        proto_item_append_text(pitem, \": MISSING\");",
                "    } else if (length == 0)"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11406",
        "func_name": "wireshark/dissect_docsis",
        "description": "In Wireshark 2.2.0 to 2.2.7 and 2.0.0 to 2.0.13, the DOCSIS dissector could go into an infinite loop. This was addressed in plugins/docsis/packet-docsis.c by rejecting invalid Frame Control parameter values.",
        "git_url": "https://github.com/wireshark/wireshark/commit/250216263c3a3f2c651e80d9c6b3dc0adc53dc2c",
        "commit_title": "DOCSIS: Prevent infinite loop from unknown FCParm.",
        "commit_text": " concatlen was not updated if FCParm was unknown, leading to an infinite loop.  # Conflicts: #\tplugins/docsis/packet-docsis.c  Bug: 13797 (cherry picked from commit 26a6881014c85c935f2794f6eeb852849137c20a)",
        "func_before": "static int\ndissect_docsis (tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void* data _U_)\n{\n  guint8 fc;\n  guint8 fctype;\n  guint8 fcparm;\n  guint8 ehdron;\n  gint mac_parm;\n  gint hdrlen;\n  guint16 len_sid;\n  tvbuff_t *next_tvb, *mgt_tvb;\n  gint pdulen, captured_length;\n  gint framelen;\n  gboolean isfrag = FALSE;\n  gint oldconcatlen;\n\n  proto_item *ti;\n  proto_tree *docsis_tree;\n  /* concatlen and concatpos are declared static to allow for recursive calls to\n   * the dissect_docsis routine when dissecting Concatenated frames\n   */\n  static gint concatlen;\n  static gint concatpos;\n\n  /* Extract important fields */\n  fc = tvb_get_guint8 (tvb, 0); /* Frame Control Byte */\n  fctype = (fc >> 6) & 0x03;    /* Frame Control Type:  2 MSB Bits */\n  fcparm = (fc >> 1) & 0x1F;    /* Frame Control Parameter: Next 5 Bits */\n  ehdron = (fc & 0x01);         /* Extended Header Bit: LSB */\n\n  if (fcparm == 0x04) {\n    mac_parm = tvb_get_ntohs (tvb, 1);\n    len_sid = tvb_get_ntohs (tvb, 3);\n  } else {\n    mac_parm = tvb_get_guint8 (tvb, 1);\n    len_sid = tvb_get_ntohs (tvb, 2);\n  }\n\n  /* set Header length based on presence of Extended header */\n  if (ehdron == 0x00) {\n    if (fcparm == 0x04)\n      hdrlen = 7;\n    else\n      hdrlen = 6;\n  } else {\n    hdrlen = 6 + mac_parm;\n  }\n\n  /* Captured PDU Length is based on the length of the header */\n  captured_length = tvb_captured_length_remaining (tvb, hdrlen);\n\n  /* If this is a Request Frame, then pdulen is 0 and framelen is 6 */\n  if ((fctype == FCTYPE_MACSPC) && (fcparm == 0x02 || fcparm == 0x04))\n    {\n      pdulen = 0;\n      framelen = 6;\n    }\n  else\n    {\n      framelen = 6 + len_sid;\n      pdulen = len_sid - (mac_parm + 2);\n    }\n\n  /* if this is a concatenated frame setup the length of the concatenated\n   * frame and set the position to the first byte of the first frame */\n  if ((fctype == FCTYPE_MACSPC) && (fcparm == 0x1c))\n    {\n      concatlen = len_sid;\n      concatpos = 6;\n    }\n\n  /* Make entries in Protocol column and Info column on summary display */\n  col_set_str (pinfo->cinfo, COL_PROTOCOL, \"DOCSIS\");\n\n  switch (fctype)\n    {\n      case FCTYPE_PACKET:\n        col_set_str (pinfo->cinfo, COL_INFO, \"Packet PDU\");\n        break;\n      case FCTYPE_ATMPDU:\n        col_set_str (pinfo->cinfo, COL_INFO, \"ATM PDU\");\n        break;\n      case FCTYPE_RESRVD:\n        col_set_str (pinfo->cinfo, COL_INFO, \"Reserved PDU\");\n        break;\n      case FCTYPE_MACSPC:\n        if (fcparm == 0x02)\n          col_add_fstr (pinfo->cinfo, COL_INFO,\n                        \"Request Frame SID = %u Mini Slots = %u\", len_sid,\n                        mac_parm);\n        else if (fcparm == 0x04)\n          col_add_fstr (pinfo->cinfo, COL_INFO,\n                        \"Request Frame SID = %u Bytes Requested = %u\", len_sid,\n                        mac_parm);\n        else if (fcparm == 0x03)\n          col_set_str (pinfo->cinfo, COL_INFO, \"Fragmented Frame\");\n        else\n          col_set_str (pinfo->cinfo, COL_INFO, \"Mac Specific\");\n        break;\n    }  /* switch */\n\n  /* In the interest of speed, if \"tree\" is NULL, don't do any work not\n     necessary to generate protocol tree items. */\n  if (tree)\n    {\n      ti = proto_tree_add_protocol_format (tree, proto_docsis, tvb, 0,\n                                           hdrlen, \"DOCSIS\");\n      docsis_tree = proto_item_add_subtree (ti, ett_docsis);\n\n      /* add an item to the subtree, see section 1.6 for more information */\n      proto_tree_add_item (docsis_tree, hf_docsis_fctype, tvb, 0, 1, ENC_BIG_ENDIAN);\n      switch (fctype)\n        {\n          case FCTYPE_PACKET:\n          case FCTYPE_ATMPDU:\n          case FCTYPE_RESRVD:\n            proto_tree_add_item (docsis_tree, hf_docsis_fcparm, tvb, 0, 1,\n                                 ENC_BIG_ENDIAN);\n            proto_tree_add_item (docsis_tree, hf_docsis_ehdron, tvb, 0, 1,\n                                 ENC_BIG_ENDIAN);\n            if (ehdron == 0x01)\n              {\n                proto_tree_add_item (docsis_tree, hf_docsis_ehdrlen, tvb, 1, 1,\n                                     ENC_BIG_ENDIAN);\n                proto_tree_add_item (docsis_tree, hf_docsis_len, tvb, 2, 2,\n                                     ENC_BIG_ENDIAN);\n                dissect_ehdr (tvb, docsis_tree, isfrag);\n                proto_tree_add_item (docsis_tree, hf_docsis_hcs, tvb,\n                                     4 + mac_parm, 2, ENC_BIG_ENDIAN);\n              }\n            else\n              {\n                proto_tree_add_item (docsis_tree, hf_docsis_macparm, tvb, 1, 1,\n                                     ENC_BIG_ENDIAN);\n                proto_tree_add_item (docsis_tree, hf_docsis_len, tvb, 2, 2,\n                                     ENC_BIG_ENDIAN);\n                proto_tree_add_item (docsis_tree, hf_docsis_hcs, tvb, 4, 2,\n                                     ENC_BIG_ENDIAN);\n              }\n            break;\n          case FCTYPE_MACSPC:\n            proto_tree_add_item (docsis_tree, hf_docsis_machdr_fcparm, tvb, 0,\n                                 1, ENC_BIG_ENDIAN);\n            proto_tree_add_item (docsis_tree, hf_docsis_ehdron, tvb, 0, 1,\n                                 ENC_BIG_ENDIAN);\n            /* Decode for a Request Frame.  No extended header */\n            if (fcparm == 0x02)\n              {\n                proto_tree_add_uint (docsis_tree, hf_docsis_mini_slots, tvb, 1,\n                                     1, mac_parm);\n                proto_tree_add_uint (docsis_tree, hf_docsis_sid, tvb, 2, 2,\n                                     len_sid);\n                proto_tree_add_item (docsis_tree, hf_docsis_hcs, tvb, 4, 2,\n                                     ENC_BIG_ENDIAN);\n                break;\n              }\n            /* Decode for a Queue-depth Based Request */\n            if (fcparm == 0x04)\n              {\n                proto_tree_add_uint (docsis_tree, hf_docsis_requested_size, tvb, 1,\n                                     2, mac_parm);\n                proto_tree_add_uint (docsis_tree, hf_docsis_sid, tvb, 3, 2,\n                                     len_sid);\n                proto_tree_add_item (docsis_tree, hf_docsis_hcs, tvb, 5, 2,\n                                     ENC_BIG_ENDIAN);\n                break;\n              }\n            /* Check if this is a fragmentation header */\n            if (fcparm == 0x03)\n              {\n                isfrag = TRUE;\n              }\n            /* Decode for a Concatenated Header.  No Extended Header */\n            if (fcparm == 0x1c)\n              {\n                proto_item_append_text (ti, \" (Concatenated Header)\");\n                proto_tree_add_item (docsis_tree, hf_docsis_concat_cnt, tvb, 1,\n                                     1, ENC_BIG_ENDIAN);\n                proto_tree_add_item (docsis_tree, hf_docsis_len, tvb, 2, 2,\n                                     ENC_BIG_ENDIAN);\n                proto_tree_add_item (docsis_tree, hf_docsis_hcs, tvb, 4, 2,\n                                     ENC_BIG_ENDIAN);\n                break;\n              }\n            /* If Extended header is present then decode it */\n            if (ehdron == 0x01)\n              {\n                proto_tree_add_item (docsis_tree, hf_docsis_ehdrlen, tvb, 1, 1,\n                                     ENC_BIG_ENDIAN);\n                proto_tree_add_item (docsis_tree, hf_docsis_len, tvb, 2, 2,\n                                     ENC_BIG_ENDIAN);\n                dissect_ehdr (tvb, docsis_tree, isfrag);\n                proto_tree_add_item (docsis_tree, hf_docsis_hcs, tvb,\n                                     4 + mac_parm, 2, ENC_BIG_ENDIAN);\n                break;\n              }\n            /* default case for all other Mac Frame Types */\n            proto_tree_add_item (docsis_tree, hf_docsis_macparm, tvb, 1, 1,\n                                 ENC_BIG_ENDIAN);\n            proto_tree_add_item (docsis_tree, hf_docsis_len, tvb, 2, 2,\n                                 ENC_BIG_ENDIAN);\n            proto_tree_add_item (docsis_tree, hf_docsis_hcs, tvb, 4, 2, ENC_BIG_ENDIAN);\n            break;\n        }\n    }\n\n  switch (fctype)\n    {\n      case FCTYPE_PACKET:\n      case FCTYPE_RESRVD:\n        if (pdulen >= 0)\n          {\n            if (pdulen > 0)\n              {\n                next_tvb = tvb_new_subset (tvb, hdrlen, captured_length, pdulen);\n                call_dissector (eth_withoutfcs_handle, next_tvb, pinfo, tree);\n              }\n            if (concatlen > 0)\n              {\n                concatlen = concatlen - framelen;\n                concatpos += framelen;\n              }\n          }\n        break;\n      case FCTYPE_MACSPC:\n        switch (fcparm)\n          {\n            case 0x00:\n            case 0x01:\n              if (pdulen > 0)\n                {\n                  mgt_tvb = tvb_new_subset (tvb, hdrlen, captured_length, pdulen);\n                  call_dissector (docsis_mgmt_handle, mgt_tvb, pinfo, tree);\n                }\n              if (concatlen > 0)\n                {\n                  concatlen = concatlen - framelen;\n                  concatpos += framelen;\n                }\n              break;\n            case 0x02:\n              /* Don't do anything for a Request Frame */\n              break;\n            case 0x03:\n              /* For Fragmentation Frames simply dissect using the data\n               * dissector as we don't handle them yet\n               */\n              if (pdulen > 0)\n                {\n                  mgt_tvb = tvb_new_subset (tvb, hdrlen, captured_length, pdulen);\n                  call_data_dissector(mgt_tvb, pinfo, tree);\n                }\n              if (concatlen > 0)\n                {\n                  concatlen = concatlen - framelen;\n                  concatpos += framelen;\n                }\n              break;\n            case 0x1c:\n              /* call the docsis dissector on the same frame\n               * to dissect DOCSIS frames within the concatenated\n               * frame.  concatpos and concatlen are declared\n               * static and are decremented and incremented\n               * respectively when the inner\n               * docsis frames are dissected. */\n              while (concatlen > 0)\n                {\n                  oldconcatlen = concatlen;\n                  next_tvb = tvb_new_subset (tvb, concatpos, -1, concatlen);\n                  call_dissector (docsis_handle, next_tvb, pinfo, tree);\n                  if (oldconcatlen <= concatlen)\n                    THROW(ReportedBoundsError);\n                }\n              concatlen = 0;\n              concatpos = 0;\n              col_set_str(pinfo->cinfo, COL_INFO, \"Concatenated Frame\");\n              break;\n          }\n        break;\n    }\n    return tvb_captured_length(tvb);\n}",
        "func": "static int\ndissect_docsis (tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void* data _U_)\n{\n  guint8 fc;\n  guint8 fctype;\n  guint8 fcparm;\n  guint8 ehdron;\n  gint mac_parm;\n  gint hdrlen;\n  guint16 len_sid;\n  tvbuff_t *next_tvb, *mgt_tvb;\n  gint pdulen, captured_length;\n  gint framelen;\n  gboolean isfrag = FALSE;\n  gint oldconcatlen;\n\n  proto_item *ti;\n  proto_tree *docsis_tree;\n  /* concatlen and concatpos are declared static to allow for recursive calls to\n   * the dissect_docsis routine when dissecting Concatenated frames\n   */\n  static gint concatlen;\n  static gint concatpos;\n\n  /* Extract important fields */\n  fc = tvb_get_guint8 (tvb, 0); /* Frame Control Byte */\n  fctype = (fc >> 6) & 0x03;    /* Frame Control Type:  2 MSB Bits */\n  fcparm = (fc >> 1) & 0x1F;    /* Frame Control Parameter: Next 5 Bits */\n  ehdron = (fc & 0x01);         /* Extended Header Bit: LSB */\n\n  if (fcparm == 0x04) {\n    mac_parm = tvb_get_ntohs (tvb, 1);\n    len_sid = tvb_get_ntohs (tvb, 3);\n  } else {\n    mac_parm = tvb_get_guint8 (tvb, 1);\n    len_sid = tvb_get_ntohs (tvb, 2);\n  }\n\n  /* set Header length based on presence of Extended header */\n  if (ehdron == 0x00) {\n    if (fcparm == 0x04)\n      hdrlen = 7;\n    else\n      hdrlen = 6;\n  } else {\n    hdrlen = 6 + mac_parm;\n  }\n\n  /* Captured PDU Length is based on the length of the header */\n  captured_length = tvb_captured_length_remaining (tvb, hdrlen);\n\n  /* If this is a Request Frame, then pdulen is 0 and framelen is 6 */\n  if ((fctype == FCTYPE_MACSPC) && (fcparm == 0x02 || fcparm == 0x04))\n    {\n      pdulen = 0;\n      framelen = 6;\n    }\n  else\n    {\n      framelen = 6 + len_sid;\n      pdulen = len_sid - (mac_parm + 2);\n    }\n\n  /* if this is a concatenated frame setup the length of the concatenated\n   * frame and set the position to the first byte of the first frame */\n  if ((fctype == FCTYPE_MACSPC) && (fcparm == 0x1c))\n    {\n      concatlen = len_sid;\n      concatpos = 6;\n    }\n\n  /* Make entries in Protocol column and Info column on summary display */\n  col_set_str (pinfo->cinfo, COL_PROTOCOL, \"DOCSIS\");\n\n  switch (fctype)\n    {\n      case FCTYPE_PACKET:\n        col_set_str (pinfo->cinfo, COL_INFO, \"Packet PDU\");\n        break;\n      case FCTYPE_ATMPDU:\n        col_set_str (pinfo->cinfo, COL_INFO, \"ATM PDU\");\n        break;\n      case FCTYPE_RESRVD:\n        col_set_str (pinfo->cinfo, COL_INFO, \"Reserved PDU\");\n        break;\n      case FCTYPE_MACSPC:\n        if (fcparm == 0x02)\n          col_add_fstr (pinfo->cinfo, COL_INFO,\n                        \"Request Frame SID = %u Mini Slots = %u\", len_sid,\n                        mac_parm);\n        else if (fcparm == 0x04)\n          col_add_fstr (pinfo->cinfo, COL_INFO,\n                        \"Request Frame SID = %u Bytes Requested = %u\", len_sid,\n                        mac_parm);\n        else if (fcparm == 0x03)\n          col_set_str (pinfo->cinfo, COL_INFO, \"Fragmented Frame\");\n        else\n          col_set_str (pinfo->cinfo, COL_INFO, \"Mac Specific\");\n        break;\n    }  /* switch */\n\n  /* In the interest of speed, if \"tree\" is NULL, don't do any work not\n     necessary to generate protocol tree items. */\n  if (tree)\n    {\n      ti = proto_tree_add_protocol_format (tree, proto_docsis, tvb, 0,\n                                           hdrlen, \"DOCSIS\");\n      docsis_tree = proto_item_add_subtree (ti, ett_docsis);\n\n      /* add an item to the subtree, see section 1.6 for more information */\n      proto_tree_add_item (docsis_tree, hf_docsis_fctype, tvb, 0, 1, ENC_BIG_ENDIAN);\n      switch (fctype)\n        {\n          case FCTYPE_PACKET:\n          case FCTYPE_ATMPDU:\n          case FCTYPE_RESRVD:\n            proto_tree_add_item (docsis_tree, hf_docsis_fcparm, tvb, 0, 1,\n                                 ENC_BIG_ENDIAN);\n            proto_tree_add_item (docsis_tree, hf_docsis_ehdron, tvb, 0, 1,\n                                 ENC_BIG_ENDIAN);\n            if (ehdron == 0x01)\n              {\n                proto_tree_add_item (docsis_tree, hf_docsis_ehdrlen, tvb, 1, 1,\n                                     ENC_BIG_ENDIAN);\n                proto_tree_add_item (docsis_tree, hf_docsis_len, tvb, 2, 2,\n                                     ENC_BIG_ENDIAN);\n                dissect_ehdr (tvb, docsis_tree, isfrag);\n                proto_tree_add_item (docsis_tree, hf_docsis_hcs, tvb,\n                                     4 + mac_parm, 2, ENC_BIG_ENDIAN);\n              }\n            else\n              {\n                proto_tree_add_item (docsis_tree, hf_docsis_macparm, tvb, 1, 1,\n                                     ENC_BIG_ENDIAN);\n                proto_tree_add_item (docsis_tree, hf_docsis_len, tvb, 2, 2,\n                                     ENC_BIG_ENDIAN);\n                proto_tree_add_item (docsis_tree, hf_docsis_hcs, tvb, 4, 2,\n                                     ENC_BIG_ENDIAN);\n              }\n            break;\n          case FCTYPE_MACSPC:\n            proto_tree_add_item (docsis_tree, hf_docsis_machdr_fcparm, tvb, 0,\n                                 1, ENC_BIG_ENDIAN);\n            proto_tree_add_item (docsis_tree, hf_docsis_ehdron, tvb, 0, 1,\n                                 ENC_BIG_ENDIAN);\n            /* Decode for a Request Frame.  No extended header */\n            if (fcparm == 0x02)\n              {\n                proto_tree_add_uint (docsis_tree, hf_docsis_mini_slots, tvb, 1,\n                                     1, mac_parm);\n                proto_tree_add_uint (docsis_tree, hf_docsis_sid, tvb, 2, 2,\n                                     len_sid);\n                proto_tree_add_item (docsis_tree, hf_docsis_hcs, tvb, 4, 2,\n                                     ENC_BIG_ENDIAN);\n                break;\n              }\n            /* Decode for a Queue-depth Based Request */\n            if (fcparm == 0x04)\n              {\n                proto_tree_add_uint (docsis_tree, hf_docsis_requested_size, tvb, 1,\n                                     2, mac_parm);\n                proto_tree_add_uint (docsis_tree, hf_docsis_sid, tvb, 3, 2,\n                                     len_sid);\n                proto_tree_add_item (docsis_tree, hf_docsis_hcs, tvb, 5, 2,\n                                     ENC_BIG_ENDIAN);\n                break;\n              }\n            /* Check if this is a fragmentation header */\n            if (fcparm == 0x03)\n              {\n                isfrag = TRUE;\n              }\n            /* Decode for a Concatenated Header.  No Extended Header */\n            if (fcparm == 0x1c)\n              {\n                proto_item_append_text (ti, \" (Concatenated Header)\");\n                proto_tree_add_item (docsis_tree, hf_docsis_concat_cnt, tvb, 1,\n                                     1, ENC_BIG_ENDIAN);\n                proto_tree_add_item (docsis_tree, hf_docsis_len, tvb, 2, 2,\n                                     ENC_BIG_ENDIAN);\n                proto_tree_add_item (docsis_tree, hf_docsis_hcs, tvb, 4, 2,\n                                     ENC_BIG_ENDIAN);\n                break;\n              }\n            /* If Extended header is present then decode it */\n            if (ehdron == 0x01)\n              {\n                proto_tree_add_item (docsis_tree, hf_docsis_ehdrlen, tvb, 1, 1,\n                                     ENC_BIG_ENDIAN);\n                proto_tree_add_item (docsis_tree, hf_docsis_len, tvb, 2, 2,\n                                     ENC_BIG_ENDIAN);\n                dissect_ehdr (tvb, docsis_tree, isfrag);\n                proto_tree_add_item (docsis_tree, hf_docsis_hcs, tvb,\n                                     4 + mac_parm, 2, ENC_BIG_ENDIAN);\n                break;\n              }\n            /* default case for all other Mac Frame Types */\n            proto_tree_add_item (docsis_tree, hf_docsis_macparm, tvb, 1, 1,\n                                 ENC_BIG_ENDIAN);\n            proto_tree_add_item (docsis_tree, hf_docsis_len, tvb, 2, 2,\n                                 ENC_BIG_ENDIAN);\n            proto_tree_add_item (docsis_tree, hf_docsis_hcs, tvb, 4, 2, ENC_BIG_ENDIAN);\n            break;\n        }\n    }\n\n  switch (fctype)\n    {\n      case FCTYPE_PACKET:\n      case FCTYPE_RESRVD:\n        if (pdulen >= 0)\n          {\n            if (pdulen > 0)\n              {\n                next_tvb = tvb_new_subset (tvb, hdrlen, captured_length, pdulen);\n                call_dissector (eth_withoutfcs_handle, next_tvb, pinfo, tree);\n              }\n            if (concatlen > 0)\n              {\n                concatlen = concatlen - framelen;\n                concatpos += framelen;\n              }\n          }\n        break;\n      case FCTYPE_MACSPC:\n        switch (fcparm)\n          {\n            case 0x00:\n            case 0x01:\n              if (pdulen > 0)\n                {\n                  mgt_tvb = tvb_new_subset (tvb, hdrlen, captured_length, pdulen);\n                  call_dissector (docsis_mgmt_handle, mgt_tvb, pinfo, tree);\n                }\n              if (concatlen > 0)\n                {\n                  concatlen = concatlen - framelen;\n                  concatpos += framelen;\n                }\n              break;\n            case 0x02:\n              /* Don't do anything for a Request Frame */\n              break;\n            case 0x03:\n              /* For Fragmentation Frames simply dissect using the data\n               * dissector as we don't handle them yet\n               */\n              if (pdulen > 0)\n                {\n                  mgt_tvb = tvb_new_subset (tvb, hdrlen, captured_length, pdulen);\n                  call_data_dissector(mgt_tvb, pinfo, tree);\n                }\n              if (concatlen > 0)\n                {\n                  concatlen = concatlen - framelen;\n                  concatpos += framelen;\n                }\n              break;\n            case 0x1c:\n              /* call the docsis dissector on the same frame\n               * to dissect DOCSIS frames within the concatenated\n               * frame.  concatpos and concatlen are declared\n               * static and are decremented and incremented\n               * respectively when the inner\n               * docsis frames are dissected. */\n              while (concatlen > 0)\n                {\n                  oldconcatlen = concatlen;\n                  next_tvb = tvb_new_subset (tvb, concatpos, -1, concatlen);\n                  call_dissector (docsis_handle, next_tvb, pinfo, tree);\n                  if (oldconcatlen <= concatlen)\n                    THROW(ReportedBoundsError);\n                }\n              concatlen = 0;\n              concatpos = 0;\n              col_set_str(pinfo->cinfo, COL_INFO, \"Concatenated Frame\");\n              break;\n            default:\n              /* Unknown parameter, stop dissection */\n              concatlen = 0;\n              break;\n          } /* switch fcparm */\n        break;\n    }\n    return tvb_captured_length(tvb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -275,7 +275,11 @@\n               concatpos = 0;\n               col_set_str(pinfo->cinfo, COL_INFO, \"Concatenated Frame\");\n               break;\n-          }\n+            default:\n+              /* Unknown parameter, stop dissection */\n+              concatlen = 0;\n+              break;\n+          } /* switch fcparm */\n         break;\n     }\n     return tvb_captured_length(tvb);",
        "diff_line_info": {
            "deleted_lines": [
                "          }"
            ],
            "added_lines": [
                "            default:",
                "              /* Unknown parameter, stop dissection */",
                "              concatlen = 0;",
                "              break;",
                "          } /* switch fcparm */"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-18233",
        "func_name": "exempi/Chunk::Chunk",
        "description": "An issue was discovered in Exempi before 2.4.4. Integer overflow in the Chunk class in XMPFiles/source/FormatSupport/RIFF.cpp allows remote attackers to cause a denial of service (infinite loop) via crafted XMP data in a .avi file.",
        "git_url": "https://cgit.freedesktop.org/exempi/commit/?id=65a8492832b7335ffabd01f5f64d89dec757c260",
        "commit_title": "",
        "commit_text": "",
        "func_before": "Chunk::Chunk( ContainerChunk* parent, RIFF_MetaHandler* handler, bool skip, ChunkType c )\n{\n\tchunkType = c; // base class assumption\n\tthis->parent = parent;\n\tthis->oldSize = 0;\n\tthis->hasChange = false; // [2414649] valid assumption at creation time\n\n\tXMP_IO* file = handler->parent->ioRef;\n\n\tthis->oldPos = file->Offset();\n\tthis->id = XIO::ReadUns32_LE( file );\n\tthis->oldSize = XIO::ReadUns32_LE( file ) + 8;\n\n\t// Make sure the size is within expected bounds.\n\tXMP_Int64 chunkEnd = this->oldPos + this->oldSize;\n\tXMP_Int64 chunkLimit = handler->oldFileSize;\n\tif ( parent != 0 ) chunkLimit = parent->oldPos + parent->oldSize;\n\tif ( chunkEnd > chunkLimit ) {\n\t\tbool isUpdate = XMP_OptionIsSet ( handler->parent->openFlags, kXMPFiles_OpenForUpdate );\n\t\tbool repairFile = XMP_OptionIsSet ( handler->parent->openFlags, kXMPFiles_OpenRepairFile );\n\t\tif ( (! isUpdate) || (repairFile && (parent == 0)) ) {\n\t\t\tthis->oldSize = chunkLimit - this->oldPos;\n\t\t} else {\n\t\t\tXMP_Throw ( \"Bad RIFF chunk size\", kXMPErr_BadFileFormat );\n\t\t}\n\t}\n\n\tthis->newSize = this->oldSize;\n\tthis->needSizeFix = false;\n\n\tif ( skip ) file->Seek ( (this->oldSize - 8), kXMP_SeekFromCurrent );\n\n\t// \"good parenting\", essential for latter destruction.\n\tif ( this->parent != NULL )\n\t{\n\t\tthis->parent->children.push_back( this );\n\t\tif( this->chunkType == chunk_VALUE )\n\t\t\tthis->parent->childmap.insert( std::make_pair( this->id, (ValueChunk*) this ) );\n\t}\n}",
        "func": "Chunk::Chunk( ContainerChunk* parent, RIFF_MetaHandler* handler, bool skip, ChunkType c )\n{\n\tchunkType = c; // base class assumption\n\tthis->parent = parent;\n\tthis->oldSize = 0;\n\tthis->hasChange = false; // [2414649] valid assumption at creation time\n\n\tXMP_IO* file = handler->parent->ioRef;\n\n\tthis->oldPos = file->Offset();\n\tthis->id = XIO::ReadUns32_LE( file );\n\tthis->oldSize = XIO::ReadUns32_LE( file );\n\tthis->oldSize += 8;\n\n\t// Make sure the size is within expected bounds.\n\tXMP_Int64 chunkEnd = this->oldPos + this->oldSize;\n\tXMP_Int64 chunkLimit = handler->oldFileSize;\n\tif ( parent != 0 ) chunkLimit = parent->oldPos + parent->oldSize;\n\tif ( chunkEnd > chunkLimit ) {\n\t\tbool isUpdate = XMP_OptionIsSet ( handler->parent->openFlags, kXMPFiles_OpenForUpdate );\n\t\tbool repairFile = XMP_OptionIsSet ( handler->parent->openFlags, kXMPFiles_OpenRepairFile );\n\t\tif ( (! isUpdate) || (repairFile && (parent == 0)) ) {\n\t\t\tthis->oldSize = chunkLimit - this->oldPos;\n\t\t} else {\n\t\t\tXMP_Throw ( \"Bad RIFF chunk size\", kXMPErr_BadFileFormat );\n\t\t}\n\t}\n\n\tthis->newSize = this->oldSize;\n\tthis->needSizeFix = false;\n\n\tif ( skip ) file->Seek ( (this->oldSize - 8), kXMP_SeekFromCurrent );\n\n\t// \"good parenting\", essential for latter destruction.\n\tif ( this->parent != NULL )\n\t{\n\t\tthis->parent->children.push_back( this );\n\t\tif( this->chunkType == chunk_VALUE )\n\t\t\tthis->parent->childmap.insert( std::make_pair( this->id, (ValueChunk*) this ) );\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,8 @@\n \n \tthis->oldPos = file->Offset();\n \tthis->id = XIO::ReadUns32_LE( file );\n-\tthis->oldSize = XIO::ReadUns32_LE( file ) + 8;\n+\tthis->oldSize = XIO::ReadUns32_LE( file );\n+\tthis->oldSize += 8;\n \n \t// Make sure the size is within expected bounds.\n \tXMP_Int64 chunkEnd = this->oldPos + this->oldSize;",
        "diff_line_info": {
            "deleted_lines": [
                "\tthis->oldSize = XIO::ReadUns32_LE( file ) + 8;"
            ],
            "added_lines": [
                "\tthis->oldSize = XIO::ReadUns32_LE( file );",
                "\tthis->oldSize += 8;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-18236",
        "func_name": "exempi/ASF_Support::ReadHeaderObject",
        "description": "An issue was discovered in Exempi before 2.4.4. The ASF_Support::ReadHeaderObject function in XMPFiles/source/FormatSupport/ASF_Support.cpp allows remote attackers to cause a denial of service (infinite loop) via a crafted .asf file.",
        "git_url": "https://cgit.freedesktop.org/exempi/commit/?id=fe59605d3520bf2ca4e0a963d194f10e9fee5806",
        "commit_title": "",
        "commit_text": "",
        "func_before": "bool ASF_Support::ReadHeaderObject ( XMP_IO* fileRef, ObjectState& inOutObjectState, const ObjectData& newObject )\n{\n\tif ( ! IsEqualGUID ( ASF_Header_Object, newObject.guid) || (! legacyManager ) ) return false;\n\n\tstd::string buffer;\n\n\tlegacyManager->SetPadding(0);\n\n\ttry {\n\n\t\t// read header-object structure\n\t\tXMP_Uns64 pos = newObject.pos;\n\t\tXMP_Uns32 bufferSize = kASF_ObjectBaseLen + 6;\n\n\t\tbuffer.clear();\n\t\tbuffer.reserve ( bufferSize );\n\t\tbuffer.assign ( bufferSize, ' ' );\n\t\tfileRef->Seek ( pos, kXMP_SeekFromStart );\n\t\tfileRef->ReadAll ( const_cast<char*>(buffer.data()), bufferSize );\n\n\t\tXMP_Uns64 read = bufferSize;\n\t\tpos += bufferSize;\n\n\t\t// read contained header objects\n\t\tXMP_Uns32 numberOfHeaders = GetUns32LE ( &buffer[24] );\n\t\tASF_ObjectBase objectBase;\n\n\t\twhile ( read < newObject.len ) {\n\n\t\t\tfileRef->Seek ( pos, kXMP_SeekFromStart );\n\t\t\tif ( kASF_ObjectBaseLen != fileRef->Read ( &objectBase, kASF_ObjectBaseLen, true ) ) break;\n\n\t\t\tfileRef->Seek ( pos, kXMP_SeekFromStart );\n\t\t\tobjectBase.size = GetUns64LE ( &objectBase.size );\n\n\t\t\tif ( IsEqualGUID ( ASF_File_Properties_Object, objectBase.guid) && (objectBase.size >= 104 ) ) {\n\n\t\t\t\tbuffer.clear();\n\t\t\t\tbuffer.reserve ( XMP_Uns32( objectBase.size ) );\n\t\t\t\tbuffer.assign ( XMP_Uns32( objectBase.size ), ' ' );\n\t\t\t\tfileRef->ReadAll ( const_cast<char*>(buffer.data()), XMP_Int32(objectBase.size) );\n\n\t\t\t\t// save position of filesize-information\n\t\t\t\tposFileSizeInfo = (pos + 40);\n\n\t\t\t\t// creation date\n\t\t\t\tstd::string sub ( buffer.substr ( 48, 8 ) );\n\t\t\t\tlegacyManager->SetField ( ASF_LegacyManager::fieldCreationDate, sub );\n\n\t\t\t\t// broadcast flag set ?\n\t\t\t\tXMP_Uns32 flags = GetUns32LE ( &buffer[88] );\n\t\t\t\tinOutObjectState.broadcast = (flags & 1);\n\t\t\t\tlegacyManager->SetBroadcast ( inOutObjectState.broadcast );\n\n\t\t\t\tlegacyManager->SetObjectExists ( ASF_LegacyManager::objectFileProperties );\n\n\t\t\t} else if ( IsEqualGUID ( ASF_Content_Description_Object, objectBase.guid) && (objectBase.size >= 34 ) ) {\n\n\t\t\t\tbuffer.clear();\n\t\t\t\tbuffer.reserve ( XMP_Uns32( objectBase.size ) );\n\t\t\t\tbuffer.assign ( XMP_Uns32( objectBase.size ), ' ' );\n\t\t\t\tfileRef->ReadAll ( const_cast<char*>(buffer.data()), XMP_Int32(objectBase.size) );\n\n\t\t\t\tXMP_Uns16 titleLen = GetUns16LE ( &buffer[24] );\n\t\t\t\tXMP_Uns16 authorLen = GetUns16LE ( &buffer[26] );\n\t\t\t\tXMP_Uns16 copyrightLen = GetUns16LE ( &buffer[28] );\n\t\t\t\tXMP_Uns16 descriptionLen = GetUns16LE ( &buffer[30] );\n\t\t\t\tXMP_Uns16 ratingLen = GetUns16LE ( &buffer[32] );\n\n\t\t\t\tXMP_Uns16 fieldPos = 34;\n\n\t\t\t\tstd::string titleStr = buffer.substr ( fieldPos, titleLen );\n\t\t\t\tfieldPos += titleLen;\n\t\t\t\tlegacyManager->SetField ( ASF_LegacyManager::fieldTitle, titleStr );\n\n\t\t\t\tstd::string authorStr = buffer.substr ( fieldPos, authorLen );\n\t\t\t\tfieldPos += authorLen;\n\t\t\t\tlegacyManager->SetField ( ASF_LegacyManager::fieldAuthor, authorStr );\n\n\t\t\t\tstd::string copyrightStr = buffer.substr ( fieldPos, copyrightLen );\n\t\t\t\tfieldPos += copyrightLen;\n\t\t\t\tlegacyManager->SetField ( ASF_LegacyManager::fieldCopyright, copyrightStr );\n\n\t\t\t\tstd::string descriptionStr = buffer.substr ( fieldPos, descriptionLen );\n\t\t\t\tfieldPos += descriptionLen;\n\t\t\t\tlegacyManager->SetField ( ASF_LegacyManager::fieldDescription, descriptionStr );\n\n\t\t\t\t/* rating is currently not part of reconciliation\n\t\t\t\tstd::string ratingStr = buffer.substr ( fieldPos, ratingLen );\n\t\t\t\tfieldPos += ratingLen;\n\t\t\t\tlegacyData.append ( titleStr );\n\t\t\t\t*/\n\n\t\t\t\tlegacyManager->SetObjectExists ( ASF_LegacyManager::objectContentDescription );\n\n\t\t\t} else if ( IsEqualGUID ( ASF_Content_Branding_Object, objectBase.guid ) ) {\n\n\t\t\t\tbuffer.clear();\n\t\t\t\tbuffer.reserve ( XMP_Uns32( objectBase.size ) );\n\t\t\t\tbuffer.assign ( XMP_Uns32( objectBase.size ), ' ' );\n\t\t\t\tfileRef->ReadAll ( const_cast<char*>(buffer.data()), XMP_Int32(objectBase.size) );\n\n\t\t\t\tXMP_Uns32 fieldPos = 28;\n\n\t\t\t\t// copyright URL is 3. element with variable size\n\t\t\t\tfor ( int i = 1; i <= 3 ; ++i ) {\n\t\t\t\t\tXMP_Uns32 len = GetUns32LE ( &buffer[fieldPos] );\n\t\t\t\t\tif ( i == 3 ) {\n\t\t\t\t\t\tstd::string copyrightURLStr = buffer.substr ( fieldPos + 4, len );\n\t\t\t\t\t\tlegacyManager->SetField ( ASF_LegacyManager::fieldCopyrightURL, copyrightURLStr );\n\t\t\t\t\t}\n\t\t\t\t\tfieldPos += (len + 4);\n\t\t\t\t}\n\n\t\t\t\tlegacyManager->SetObjectExists ( ASF_LegacyManager::objectContentBranding );\n\n#if ! Exclude_LicenseURL_Recon\n\n\t\t\t} else if ( IsEqualGUID ( ASF_Content_Encryption_Object, objectBase.guid ) ) {\n\n\t\t\t\tbuffer.clear();\n\t\t\t\tbuffer.reserve ( XMP_Uns32( objectBase.size ) );\n\t\t\t\tbuffer.assign ( XMP_Uns32( objectBase.size ), ' ' );\n\t\t\t\tfileRef->ReadAll ( const_cast<char*>(buffer.data()), XMP_Int32(objectBase.size) );\n\n\t\t\t\tXMP_Uns32 fieldPos = 24;\n\n\t\t\t\t// license URL is 4. element with variable size\n\t\t\t\tfor ( int i = 1; i <= 4 ; ++i ) {\n\t\t\t\t\tXMP_Uns32 len = GetUns32LE ( &buffer[fieldPos] );\n\t\t\t\t\tif ( i == 4 ) {\n\t\t\t\t\t\tstd::string licenseURLStr = buffer.substr ( fieldPos + 4, len );\n\t\t\t\t\t\tlegacyManager->SetField ( ASF_LegacyManager::fieldLicenseURL, licenseURLStr );\n\t\t\t\t\t}\n\t\t\t\t\tfieldPos += (len + 4);\n\t\t\t\t}\n\n\t\t\t\tlegacyManager->SetObjectExists ( objectContentEncryption );\n\n#endif\n\n\t\t\t} else if ( IsEqualGUID ( ASF_Padding_Object, objectBase.guid ) ) {\n\n\t\t\t\tlegacyManager->SetPadding ( legacyManager->GetPadding() + (objectBase.size - 24) );\n\n\t\t\t} else if ( IsEqualGUID ( ASF_Header_Extension_Object, objectBase.guid ) ) {\n\n\t\t\t\tthis->ReadHeaderExtensionObject ( fileRef, inOutObjectState, pos, objectBase );\n\n\t\t\t}\n\n\t\t\tpos += objectBase.size;\n\t\t\tread += objectBase.size;\n\t\t}\n\n\t} catch ( ... ) {\n\n\t\treturn false;\n\n\t}\n\n\tlegacyManager->ComputeDigest();\n\n\treturn true;\n}",
        "func": "bool ASF_Support::ReadHeaderObject ( XMP_IO* fileRef, ObjectState& inOutObjectState, const ObjectData& newObject )\n{\n\tif ( ! IsEqualGUID ( ASF_Header_Object, newObject.guid) || (! legacyManager ) ) return false;\n\n\tstd::string buffer;\n\n\tlegacyManager->SetPadding(0);\n\n\ttry {\n\n\t\t// read header-object structure\n\t\tXMP_Uns64 pos = newObject.pos;\n\t\tXMP_Uns32 bufferSize = kASF_ObjectBaseLen + 6;\n\n\t\tbuffer.clear();\n\t\tbuffer.reserve ( bufferSize );\n\t\tbuffer.assign ( bufferSize, ' ' );\n\t\tfileRef->Seek ( pos, kXMP_SeekFromStart );\n\t\tfileRef->ReadAll ( const_cast<char*>(buffer.data()), bufferSize );\n\n\t\tXMP_Uns64 read = bufferSize;\n\t\tpos += bufferSize;\n\n\t\t// read contained header objects\n\t\tXMP_Uns32 numberOfHeaders = GetUns32LE ( &buffer[24] );\n\t\tASF_ObjectBase objectBase;\n\n\t\twhile ( read < newObject.len ) {\n\n\t\t\tfileRef->Seek ( pos, kXMP_SeekFromStart );\n\t\t\tif ( kASF_ObjectBaseLen != fileRef->Read ( &objectBase, kASF_ObjectBaseLen, true ) ) break;\n\n\t\t\tfileRef->Seek ( pos, kXMP_SeekFromStart );\n\t\t\tobjectBase.size = GetUns64LE ( &objectBase.size );\n\n\t\t\tif ( IsEqualGUID ( ASF_File_Properties_Object, objectBase.guid) && (objectBase.size >= 104 ) ) {\n\n\t\t\t\tbuffer.clear();\n\t\t\t\tbuffer.reserve ( XMP_Uns32( objectBase.size ) );\n\t\t\t\tbuffer.assign ( XMP_Uns32( objectBase.size ), ' ' );\n\t\t\t\tfileRef->ReadAll ( const_cast<char*>(buffer.data()), XMP_Int32(objectBase.size) );\n\n\t\t\t\t// save position of filesize-information\n\t\t\t\tposFileSizeInfo = (pos + 40);\n\n\t\t\t\t// creation date\n\t\t\t\tstd::string sub ( buffer.substr ( 48, 8 ) );\n\t\t\t\tlegacyManager->SetField ( ASF_LegacyManager::fieldCreationDate, sub );\n\n\t\t\t\t// broadcast flag set ?\n\t\t\t\tXMP_Uns32 flags = GetUns32LE ( &buffer[88] );\n\t\t\t\tinOutObjectState.broadcast = (flags & 1);\n\t\t\t\tlegacyManager->SetBroadcast ( inOutObjectState.broadcast );\n\n\t\t\t\tlegacyManager->SetObjectExists ( ASF_LegacyManager::objectFileProperties );\n\n\t\t\t} else if ( IsEqualGUID ( ASF_Content_Description_Object, objectBase.guid) && (objectBase.size >= 34 ) ) {\n\n\t\t\t\tbuffer.clear();\n\t\t\t\tbuffer.reserve ( XMP_Uns32( objectBase.size ) );\n\t\t\t\tbuffer.assign ( XMP_Uns32( objectBase.size ), ' ' );\n\t\t\t\tfileRef->ReadAll ( const_cast<char*>(buffer.data()), XMP_Int32(objectBase.size) );\n\n\t\t\t\tXMP_Uns16 titleLen = GetUns16LE ( &buffer[24] );\n\t\t\t\tXMP_Uns16 authorLen = GetUns16LE ( &buffer[26] );\n\t\t\t\tXMP_Uns16 copyrightLen = GetUns16LE ( &buffer[28] );\n\t\t\t\tXMP_Uns16 descriptionLen = GetUns16LE ( &buffer[30] );\n\t\t\t\tXMP_Uns16 ratingLen = GetUns16LE ( &buffer[32] );\n\n\t\t\t\tXMP_Uns16 fieldPos = 34;\n\n\t\t\t\tstd::string titleStr = buffer.substr ( fieldPos, titleLen );\n\t\t\t\tfieldPos += titleLen;\n\t\t\t\tlegacyManager->SetField ( ASF_LegacyManager::fieldTitle, titleStr );\n\n\t\t\t\tstd::string authorStr = buffer.substr ( fieldPos, authorLen );\n\t\t\t\tfieldPos += authorLen;\n\t\t\t\tlegacyManager->SetField ( ASF_LegacyManager::fieldAuthor, authorStr );\n\n\t\t\t\tstd::string copyrightStr = buffer.substr ( fieldPos, copyrightLen );\n\t\t\t\tfieldPos += copyrightLen;\n\t\t\t\tlegacyManager->SetField ( ASF_LegacyManager::fieldCopyright, copyrightStr );\n\n\t\t\t\tstd::string descriptionStr = buffer.substr ( fieldPos, descriptionLen );\n\t\t\t\tfieldPos += descriptionLen;\n\t\t\t\tlegacyManager->SetField ( ASF_LegacyManager::fieldDescription, descriptionStr );\n\n\t\t\t\t/* rating is currently not part of reconciliation\n\t\t\t\tstd::string ratingStr = buffer.substr ( fieldPos, ratingLen );\n\t\t\t\tfieldPos += ratingLen;\n\t\t\t\tlegacyData.append ( titleStr );\n\t\t\t\t*/\n\n\t\t\t\tlegacyManager->SetObjectExists ( ASF_LegacyManager::objectContentDescription );\n\n\t\t\t} else if ( IsEqualGUID ( ASF_Content_Branding_Object, objectBase.guid ) ) {\n\n\t\t\t\tbuffer.clear();\n\t\t\t\tbuffer.reserve ( XMP_Uns32( objectBase.size ) );\n\t\t\t\tbuffer.assign ( XMP_Uns32( objectBase.size ), ' ' );\n\t\t\t\tfileRef->ReadAll ( const_cast<char*>(buffer.data()), XMP_Int32(objectBase.size) );\n\n\t\t\t\tXMP_Uns32 fieldPos = 28;\n\n\t\t\t\t// copyright URL is 3. element with variable size\n\t\t\t\tfor ( int i = 1; i <= 3 ; ++i ) {\n\t\t\t\t\tXMP_Uns32 len = GetUns32LE ( &buffer[fieldPos] );\n\t\t\t\t\tif ( i == 3 ) {\n\t\t\t\t\t\tstd::string copyrightURLStr = buffer.substr ( fieldPos + 4, len );\n\t\t\t\t\t\tlegacyManager->SetField ( ASF_LegacyManager::fieldCopyrightURL, copyrightURLStr );\n\t\t\t\t\t}\n\t\t\t\t\tfieldPos += (len + 4);\n\t\t\t\t}\n\n\t\t\t\tlegacyManager->SetObjectExists ( ASF_LegacyManager::objectContentBranding );\n\n#if ! Exclude_LicenseURL_Recon\n\n\t\t\t} else if ( IsEqualGUID ( ASF_Content_Encryption_Object, objectBase.guid ) ) {\n\n\t\t\t\tbuffer.clear();\n\t\t\t\tbuffer.reserve ( XMP_Uns32( objectBase.size ) );\n\t\t\t\tbuffer.assign ( XMP_Uns32( objectBase.size ), ' ' );\n\t\t\t\tfileRef->ReadAll ( const_cast<char*>(buffer.data()), XMP_Int32(objectBase.size) );\n\n\t\t\t\tXMP_Uns32 fieldPos = 24;\n\n\t\t\t\t// license URL is 4. element with variable size\n\t\t\t\tfor ( int i = 1; i <= 4 ; ++i ) {\n\t\t\t\t\tXMP_Uns32 len = GetUns32LE ( &buffer[fieldPos] );\n\t\t\t\t\tif ( i == 4 ) {\n\t\t\t\t\t\tstd::string licenseURLStr = buffer.substr ( fieldPos + 4, len );\n\t\t\t\t\t\tlegacyManager->SetField ( ASF_LegacyManager::fieldLicenseURL, licenseURLStr );\n\t\t\t\t\t}\n\t\t\t\t\tfieldPos += (len + 4);\n\t\t\t\t}\n\n\t\t\t\tlegacyManager->SetObjectExists ( objectContentEncryption );\n\n#endif\n\n\t\t\t} else if ( IsEqualGUID ( ASF_Padding_Object, objectBase.guid ) ) {\n\n\t\t\t\tlegacyManager->SetPadding ( legacyManager->GetPadding() + (objectBase.size - 24) );\n\n\t\t\t} else if ( IsEqualGUID ( ASF_Header_Extension_Object, objectBase.guid ) ) {\n\n\t\t\t\tthis->ReadHeaderExtensionObject ( fileRef, inOutObjectState, pos, objectBase );\n\n\t\t\t} else if (objectBase.size == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpos += objectBase.size;\n\t\t\tread += objectBase.size;\n\t\t}\n\n\t} catch ( ... ) {\n\n\t\treturn false;\n\n\t}\n\n\tlegacyManager->ComputeDigest();\n\n\treturn true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -147,6 +147,8 @@\n \n \t\t\t\tthis->ReadHeaderExtensionObject ( fileRef, inOutObjectState, pos, objectBase );\n \n+\t\t\t} else if (objectBase.size == 0) {\n+\t\t\t\tbreak;\n \t\t\t}\n \n \t\t\tpos += objectBase.size;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\t} else if (objectBase.size == 0) {",
                "\t\t\t\tbreak;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-18238",
        "func_name": "exempi/TradQT_Manager::ParseCachedBoxes",
        "description": "An issue was discovered in Exempi before 2.4.4. The TradQT_Manager::ParseCachedBoxes function in XMPFiles/source/FormatSupport/QuickTime_Support.cpp allows remote attackers to cause a denial of service (infinite loop) via crafted XMP data in a .qt file.",
        "git_url": "https://cgit.freedesktop.org/exempi/commit/?id=886cd1d2314755adb1f4cdb99c16ff00830f0331",
        "commit_title": "",
        "commit_text": "",
        "func_before": "bool TradQT_Manager::ParseCachedBoxes ( const MOOV_Manager & moovMgr )\n{\n\tMOOV_Manager::BoxInfo udtaInfo;\n\tMOOV_Manager::BoxRef  udtaRef = moovMgr.GetBox ( \"moov/udta\", &udtaInfo );\n\tif ( udtaRef == 0 ) return false;\n\n\tfor ( XMP_Uns32 i = 0; i < udtaInfo.childCount; ++i ) {\n\n\t\tMOOV_Manager::BoxInfo currInfo;\n\t\tMOOV_Manager::BoxRef  currRef = moovMgr.GetNthChild ( udtaRef, i, &currInfo );\n\t\tif ( currRef == 0 ) break;\t// Sanity check, should not happen.\n\t\tif ( (currInfo.boxType >> 24) != 0xA9 ) continue;\n\t\tif ( currInfo.contentSize < 2+2+1 ) continue;\t// Want enough for a non-empty value.\n\t\t\n\t\tInfoMapPos newInfo = this->parsedBoxes.insert ( this->parsedBoxes.end(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tInfoMap::value_type ( currInfo.boxType, ParsedBoxInfo ( currInfo.boxType ) ) );\n\t\tstd::vector<ValueInfo> * newValues = &newInfo->second.values;\n\t\t\n\t\tXMP_Uns8 * boxPtr = (XMP_Uns8*) currInfo.content;\n\t\tXMP_Uns8 * boxEnd = boxPtr + currInfo.contentSize;\n\t\tXMP_Uns16 miniLen, macLang;\n\n\t\tfor ( ; boxPtr < boxEnd-4; boxPtr += miniLen ) {\n\n\t\t\tminiLen = 4 + GetUns16BE ( boxPtr );\t// ! Include header in local miniLen.\n\t\t\tmacLang  = GetUns16BE ( boxPtr+2);\n\t\t\tif ( (miniLen <= 4) || (miniLen > (boxEnd - boxPtr)) ) continue;\t// Ignore bad or empty values.\n\t\t\t\n\t\t\tXMP_StringPtr valuePtr = (char*)(boxPtr+4);\n\t\t\tsize_t valueLen = miniLen - 4;\n\n\t\t\tnewValues->push_back ( ValueInfo() );\n\t\t\tValueInfo * newValue = &newValues->back();\n\t\t\t\n\t\t\t// Only set the XMP language if the Mac script is known, i.e. the value can be converted.\n\t\t\t\n\t\t\tnewValue->macLang = macLang;\n\t\t\tif ( IsMacLangKnown ( macLang ) ) newValue->xmpLang = GetXMPLang ( macLang );\n\t\t\tnewValue->macValue.assign ( valuePtr, valueLen );\n\n\t\t}\n\n\t}\n\t\n\treturn (! this->parsedBoxes.empty());\n\n}",
        "func": "bool TradQT_Manager::ParseCachedBoxes ( const MOOV_Manager & moovMgr )\n{\n\tMOOV_Manager::BoxInfo udtaInfo;\n\tMOOV_Manager::BoxRef  udtaRef = moovMgr.GetBox ( \"moov/udta\", &udtaInfo );\n\tif ( udtaRef == 0 ) return false;\n\n\tfor ( XMP_Uns32 i = 0; i < udtaInfo.childCount; ++i ) {\n\n\t\tMOOV_Manager::BoxInfo currInfo;\n\t\tMOOV_Manager::BoxRef  currRef = moovMgr.GetNthChild ( udtaRef, i, &currInfo );\n\t\tif ( currRef == 0 ) break;\t// Sanity check, should not happen.\n\t\tif ( (currInfo.boxType >> 24) != 0xA9 ) continue;\n\t\tif ( currInfo.contentSize < 2+2+1 ) continue;\t// Want enough for a non-empty value.\n\t\t\n\t\tInfoMapPos newInfo = this->parsedBoxes.insert ( this->parsedBoxes.end(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tInfoMap::value_type ( currInfo.boxType, ParsedBoxInfo ( currInfo.boxType ) ) );\n\t\tstd::vector<ValueInfo> * newValues = &newInfo->second.values;\n\t\t\n\t\tXMP_Uns8 * boxPtr = (XMP_Uns8*) currInfo.content;\n\t\tXMP_Uns8 * boxEnd = boxPtr + currInfo.contentSize;\n\t\tXMP_Uns16 miniLen, macLang;\n\n\t\tfor ( ; boxPtr < boxEnd-4; boxPtr += miniLen ) {\n\n\t\t\tminiLen = 4 + GetUns16BE ( boxPtr );\t// ! Include header in local miniLen.\n\t\t\tmacLang  = GetUns16BE ( boxPtr+2);\n\t\t\tif ( (miniLen <= 4) || (miniLen > (boxEnd - boxPtr)) )\n\t\t\t\tbreak;\t// Ignore bad or empty values.\n\t\t\t\n\t\t\tXMP_StringPtr valuePtr = (char*)(boxPtr+4);\n\t\t\tsize_t valueLen = miniLen - 4;\n\n\t\t\tnewValues->push_back ( ValueInfo() );\n\t\t\tValueInfo * newValue = &newValues->back();\n\t\t\t\n\t\t\t// Only set the XMP language if the Mac script is known, i.e. the value can be converted.\n\t\t\t\n\t\t\tnewValue->macLang = macLang;\n\t\t\tif ( IsMacLangKnown ( macLang ) ) newValue->xmpLang = GetXMPLang ( macLang );\n\t\t\tnewValue->macValue.assign ( valuePtr, valueLen );\n\n\t\t}\n\n\t}\n\t\n\treturn (! this->parsedBoxes.empty());\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,7 +24,8 @@\n \n \t\t\tminiLen = 4 + GetUns16BE ( boxPtr );\t// ! Include header in local miniLen.\n \t\t\tmacLang  = GetUns16BE ( boxPtr+2);\n-\t\t\tif ( (miniLen <= 4) || (miniLen > (boxEnd - boxPtr)) ) continue;\t// Ignore bad or empty values.\n+\t\t\tif ( (miniLen <= 4) || (miniLen > (boxEnd - boxPtr)) )\n+\t\t\t\tbreak;\t// Ignore bad or empty values.\n \t\t\t\n \t\t\tXMP_StringPtr valuePtr = (char*)(boxPtr+4);\n \t\t\tsize_t valueLen = miniLen - 4;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tif ( (miniLen <= 4) || (miniLen > (boxEnd - boxPtr)) ) continue;\t// Ignore bad or empty values."
            ],
            "added_lines": [
                "\t\t\tif ( (miniLen <= 4) || (miniLen > (boxEnd - boxPtr)) )",
                "\t\t\t\tbreak;\t// Ignore bad or empty values."
            ]
        }
    },
    {
        "cve_id": "CVE-2018-9251",
        "func_name": "GNOME/libxml2/xz_head",
        "description": "The xz_decomp function in xzlib.c in libxml2 2.9.8, if --with-lzma is used, allows remote attackers to cause a denial of service (infinite loop) via a crafted XML file that triggers LZMA_MEMLIMIT_ERROR, as demonstrated by xmllint, a different vulnerability than CVE-2015-8035.",
        "git_url": "https://github.com/GNOME/libxml2/commit/e2a9122b8dde53d320750451e9907a7dcb2ca8bb",
        "commit_title": "Set memory limit for LZMA decompression",
        "commit_text": " Otherwise malicious LZMA compressed files could consume large amounts of memory when decompressed.  According to the xz man page, files compressed with `xz -9` currently require 65 MB to decompress, so set the limit to 100 MB.  Should fix bug 786696.",
        "func_before": "static int\nxz_head(xz_statep state)\n{\n    lzma_stream *strm = &(state->strm);\n    lzma_stream init = LZMA_STREAM_INIT;\n    int flags;\n    unsigned len;\n\n    /* allocate read buffers and inflate memory */\n    if (state->size == 0) {\n        /* allocate buffers */\n        state->in = xmlMalloc(state->want);\n        state->out = xmlMalloc(state->want << 1);\n        if (state->in == NULL || state->out == NULL) {\n            if (state->out != NULL)\n                xmlFree(state->out);\n            if (state->in != NULL)\n                xmlFree(state->in);\n            xz_error(state, LZMA_MEM_ERROR, \"out of memory\");\n            return -1;\n        }\n        state->size = state->want;\n\n        /* allocate decoder memory */\n        state->strm = init;\n        state->strm.avail_in = 0;\n        state->strm.next_in = NULL;\n        if (lzma_auto_decoder(&state->strm, UINT64_MAX, 0) != LZMA_OK) {\n            xmlFree(state->out);\n            xmlFree(state->in);\n            state->size = 0;\n            xz_error(state, LZMA_MEM_ERROR, \"out of memory\");\n            return -1;\n        }\n#ifdef HAVE_ZLIB_H\n        /* allocate inflate memory */\n        state->zstrm.zalloc = Z_NULL;\n        state->zstrm.zfree = Z_NULL;\n        state->zstrm.opaque = Z_NULL;\n        state->zstrm.avail_in = 0;\n        state->zstrm.next_in = Z_NULL;\n        if (state->init == 0) {\n            if (inflateInit2(&(state->zstrm), -15) != Z_OK) {/* raw inflate */\n                xmlFree(state->out);\n                xmlFree(state->in);\n                state->size = 0;\n                xz_error(state, LZMA_MEM_ERROR, \"out of memory\");\n                return -1;\n            }\n            state->init = 1;\n        }\n#endif\n    }\n\n    /* get some data in the input buffer */\n    if (strm->avail_in == 0) {\n        if (xz_avail(state) == -1)\n            return -1;\n        if (strm->avail_in == 0)\n            return 0;\n    }\n\n    /* look for the xz magic header bytes */\n    if (is_format_xz(state) || is_format_lzma(state)) {\n        state->how = LZMA;\n        state->direct = 0;\n        return 0;\n    }\n#ifdef HAVE_ZLIB_H\n    /* look for the gzip magic header bytes 31 and 139 */\n    if (strm->next_in[0] == 31) {\n        strm->avail_in--;\n        strm->next_in++;\n        if (strm->avail_in == 0 && xz_avail(state) == -1)\n            return -1;\n        if (strm->avail_in && strm->next_in[0] == 139) {\n            /* we have a gzip header, woo hoo! */\n            strm->avail_in--;\n            strm->next_in++;\n\n            /* skip rest of header */\n            if (NEXT() != 8) {  /* compression method */\n                xz_error(state, LZMA_DATA_ERROR,\n                         \"unknown compression method\");\n                return -1;\n            }\n            flags = NEXT();\n            if (flags & 0xe0) { /* reserved flag bits */\n                xz_error(state, LZMA_DATA_ERROR,\n                         \"unknown header flags set\");\n                return -1;\n            }\n            NEXT();             /* modification time */\n            NEXT();\n            NEXT();\n            NEXT();\n            NEXT();             /* extra flags */\n            NEXT();             /* operating system */\n            if (flags & 4) {    /* extra field */\n                len = (unsigned) NEXT();\n                len += (unsigned) NEXT() << 8;\n                while (len--)\n                    if (NEXT() < 0)\n                        break;\n            }\n            if (flags & 8)      /* file name */\n                while (NEXT() > 0) ;\n            if (flags & 16)     /* comment */\n                while (NEXT() > 0) ;\n            if (flags & 2) {    /* header crc */\n                NEXT();\n                NEXT();\n            }\n            /* an unexpected end of file is not checked for here -- it will be\n             * noticed on the first request for uncompressed data */\n\n            /* set up for decompression */\n            inflateReset(&state->zstrm);\n            state->zstrm.adler = crc32(0L, Z_NULL, 0);\n            state->how = GZIP;\n            state->direct = 0;\n            return 0;\n        } else {\n            /* not a gzip file -- save first byte (31) and fall to raw i/o */\n            state->out[0] = 31;\n            state->have = 1;\n        }\n    }\n#endif\n\n    /* doing raw i/o, save start of raw data for seeking, copy any leftover\n     * input to output -- this assumes that the output buffer is larger than\n     * the input buffer, which also assures space for gzungetc() */\n    state->raw = state->pos;\n    state->next = state->out;\n    if (strm->avail_in) {\n        memcpy(state->next + state->have, strm->next_in, strm->avail_in);\n        state->have += strm->avail_in;\n        strm->avail_in = 0;\n    }\n    state->how = COPY;\n    state->direct = 1;\n    return 0;\n}",
        "func": "static int\nxz_head(xz_statep state)\n{\n    lzma_stream *strm = &(state->strm);\n    lzma_stream init = LZMA_STREAM_INIT;\n    int flags;\n    unsigned len;\n\n    /* allocate read buffers and inflate memory */\n    if (state->size == 0) {\n        /* allocate buffers */\n        state->in = xmlMalloc(state->want);\n        state->out = xmlMalloc(state->want << 1);\n        if (state->in == NULL || state->out == NULL) {\n            if (state->out != NULL)\n                xmlFree(state->out);\n            if (state->in != NULL)\n                xmlFree(state->in);\n            xz_error(state, LZMA_MEM_ERROR, \"out of memory\");\n            return -1;\n        }\n        state->size = state->want;\n\n        /* allocate decoder memory */\n        state->strm = init;\n        state->strm.avail_in = 0;\n        state->strm.next_in = NULL;\n        if (lzma_auto_decoder(&state->strm, 100000000, 0) != LZMA_OK) {\n            xmlFree(state->out);\n            xmlFree(state->in);\n            state->size = 0;\n            xz_error(state, LZMA_MEM_ERROR, \"out of memory\");\n            return -1;\n        }\n#ifdef HAVE_ZLIB_H\n        /* allocate inflate memory */\n        state->zstrm.zalloc = Z_NULL;\n        state->zstrm.zfree = Z_NULL;\n        state->zstrm.opaque = Z_NULL;\n        state->zstrm.avail_in = 0;\n        state->zstrm.next_in = Z_NULL;\n        if (state->init == 0) {\n            if (inflateInit2(&(state->zstrm), -15) != Z_OK) {/* raw inflate */\n                xmlFree(state->out);\n                xmlFree(state->in);\n                state->size = 0;\n                xz_error(state, LZMA_MEM_ERROR, \"out of memory\");\n                return -1;\n            }\n            state->init = 1;\n        }\n#endif\n    }\n\n    /* get some data in the input buffer */\n    if (strm->avail_in == 0) {\n        if (xz_avail(state) == -1)\n            return -1;\n        if (strm->avail_in == 0)\n            return 0;\n    }\n\n    /* look for the xz magic header bytes */\n    if (is_format_xz(state) || is_format_lzma(state)) {\n        state->how = LZMA;\n        state->direct = 0;\n        return 0;\n    }\n#ifdef HAVE_ZLIB_H\n    /* look for the gzip magic header bytes 31 and 139 */\n    if (strm->next_in[0] == 31) {\n        strm->avail_in--;\n        strm->next_in++;\n        if (strm->avail_in == 0 && xz_avail(state) == -1)\n            return -1;\n        if (strm->avail_in && strm->next_in[0] == 139) {\n            /* we have a gzip header, woo hoo! */\n            strm->avail_in--;\n            strm->next_in++;\n\n            /* skip rest of header */\n            if (NEXT() != 8) {  /* compression method */\n                xz_error(state, LZMA_DATA_ERROR,\n                         \"unknown compression method\");\n                return -1;\n            }\n            flags = NEXT();\n            if (flags & 0xe0) { /* reserved flag bits */\n                xz_error(state, LZMA_DATA_ERROR,\n                         \"unknown header flags set\");\n                return -1;\n            }\n            NEXT();             /* modification time */\n            NEXT();\n            NEXT();\n            NEXT();\n            NEXT();             /* extra flags */\n            NEXT();             /* operating system */\n            if (flags & 4) {    /* extra field */\n                len = (unsigned) NEXT();\n                len += (unsigned) NEXT() << 8;\n                while (len--)\n                    if (NEXT() < 0)\n                        break;\n            }\n            if (flags & 8)      /* file name */\n                while (NEXT() > 0) ;\n            if (flags & 16)     /* comment */\n                while (NEXT() > 0) ;\n            if (flags & 2) {    /* header crc */\n                NEXT();\n                NEXT();\n            }\n            /* an unexpected end of file is not checked for here -- it will be\n             * noticed on the first request for uncompressed data */\n\n            /* set up for decompression */\n            inflateReset(&state->zstrm);\n            state->zstrm.adler = crc32(0L, Z_NULL, 0);\n            state->how = GZIP;\n            state->direct = 0;\n            return 0;\n        } else {\n            /* not a gzip file -- save first byte (31) and fall to raw i/o */\n            state->out[0] = 31;\n            state->have = 1;\n        }\n    }\n#endif\n\n    /* doing raw i/o, save start of raw data for seeking, copy any leftover\n     * input to output -- this assumes that the output buffer is larger than\n     * the input buffer, which also assures space for gzungetc() */\n    state->raw = state->pos;\n    state->next = state->out;\n    if (strm->avail_in) {\n        memcpy(state->next + state->have, strm->next_in, strm->avail_in);\n        state->have += strm->avail_in;\n        strm->avail_in = 0;\n    }\n    state->how = COPY;\n    state->direct = 1;\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,7 +25,7 @@\n         state->strm = init;\n         state->strm.avail_in = 0;\n         state->strm.next_in = NULL;\n-        if (lzma_auto_decoder(&state->strm, UINT64_MAX, 0) != LZMA_OK) {\n+        if (lzma_auto_decoder(&state->strm, 100000000, 0) != LZMA_OK) {\n             xmlFree(state->out);\n             xmlFree(state->in);\n             state->size = 0;",
        "diff_line_info": {
            "deleted_lines": [
                "        if (lzma_auto_decoder(&state->strm, UINT64_MAX, 0) != LZMA_OK) {"
            ],
            "added_lines": [
                "        if (lzma_auto_decoder(&state->strm, 100000000, 0) != LZMA_OK) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-9257",
        "func_name": "wireshark/dissect_cql_tcp_pdu",
        "description": "In Wireshark 2.4.0 to 2.4.5, the CQL dissector could go into an infinite loop. This was addressed in epan/dissectors/packet-cql.c by checking for a nonzero number of columns.",
        "git_url": "https://github.com/wireshark/wireshark/commit/d7a9501b0439a5dbf24016a95b4896170d789dc2",
        "commit_title": "CQL: ensure that there is at least one column to display rows",
        "commit_text": " Bug: 14530 (cherry picked from commit b4498c964f58a241e0706e19391c8c300dfa0395)",
        "func_before": "static int\ndissect_cql_tcp_pdu(tvbuff_t* raw_tvb, packet_info* pinfo, proto_tree* tree, void* data _U_)\n{\n\tproto_item* ti;\n\ttvbuff_t* tvb = NULL;\n\tproto_tree* cql_tree;\n\tproto_tree* version_tree;\n\tproto_tree* cql_subtree = NULL;\n\tproto_tree* rows_subtree = NULL;\n\tproto_tree* columns_subtree = NULL;\n\tproto_tree* metadata_subtree = NULL;\n\n\tgint offset = 0;\n\tgint offset_row_metadata = 0;\n\tguint8 flags = 0;\n\tguint8 first_byte = 0;\n\tguint8 cql_version = 0;\n\tguint8 server_to_client = 0;\n\tguint8 opcode = 0;\n\tguint32 message_length = 0;\n\tguint32 map_size = 0;\n\tguint64 i = 0;\n\tguint32 string_length = 0;\n\tgint32 stream = 0;\n\tguint32 batch_size = 0;\n\tguint32 batch_query_type = 0;\n\tguint32 result_kind = 0;\n\tgint32 result_rows_flags = 0;\n\tgint32 result_rows_columns_count = 0;\n\tgint64 j = 0;\n\tgint64 k = 0;\n\tgint32 bytes_length = 0;\n\tgint32 result_rows_row_count = 0;\n\n\tconversation_t* conversation;\n\tcql_conversation_type* cql_conv;\n\tcql_transaction_type* cql_trans = NULL;\n\tcql_compression_level compression_level = CQL_COMPRESSION_NONE;\n\n\tstatic const int * cql_batch_flags_bitmaps[] = {\n\t\t&hf_cql_batch_flag_serial_consistency,\n\t\t&hf_cql_batch_flag_default_timestamp,\n\t\t&hf_cql_batch_flag_with_name_for_values,\n\t\tNULL\n\t};\n\n\tstatic const int * cql_header_bitmaps_v3[] = {\n\t\t&hf_cql_flag_compression,\n\t\t&hf_cql_flag_tracing,\n\t\t&hf_cql_flag_reserved3,\n\t\tNULL\n\t};\n\n\tstatic const int * cql_header_bitmaps_v4[] = {\n\t\t&hf_cql_flag_compression,\n\t\t&hf_cql_flag_tracing,\n\t\t&hf_cql_flag_custom_payload,\n\t\t&hf_cql_flag_warning,\n\t\t&hf_cql_flag_reserved4,\n\t\tNULL\n\t};\n\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"CQL\");\n\tcol_clear(pinfo->cinfo, COL_INFO);\n\n\tfirst_byte = tvb_get_guint8(raw_tvb, 0);\n\tcql_version = first_byte & (guint8)0x7F;\n\tserver_to_client = first_byte & (guint8)0x80;\n\topcode = tvb_get_guint8(raw_tvb, 4);\n\n\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"v%d %s Type %s\",\n\t\tcql_version,\n\t\tserver_to_client == 0 ? \"C->S\" : \"S->C\",\n\t\tval_to_str(opcode, cql_opcode_names, \"Unknown (0x%02x)\")\n\t);\n\n\tconversation = find_or_create_conversation(pinfo);\n\tcql_conv = (cql_conversation_type*) conversation_get_proto_data(conversation, proto_cql);\n\tif(!cql_conv) {\n\t\tcql_conv = wmem_new(wmem_file_scope(), cql_conversation_type);\n\t\tcql_conv->streams = wmem_map_new(wmem_file_scope(), g_direct_hash, g_direct_equal);\n\t\tconversation_add_proto_data(conversation, proto_cql, cql_conv);\n\t}\n\n\tti = proto_tree_add_item(tree, proto_cql, raw_tvb, 0, -1, ENC_NA);\n\tcql_tree = proto_item_add_subtree(ti, ett_cql_protocol);\n\n\tti = proto_tree_add_item(cql_tree, hf_cql_version, raw_tvb, offset, 1, ENC_BIG_ENDIAN);\n\tversion_tree = proto_item_add_subtree(ti, ett_cql_version);\n\tproto_tree_add_item(version_tree, hf_cql_protocol_version, raw_tvb, offset, 1, ENC_BIG_ENDIAN);\n\tproto_tree_add_item(version_tree, hf_cql_direction, raw_tvb, offset, 1, ENC_BIG_ENDIAN);\n\toffset += 1;\n\tswitch(cql_version){\n\t\tcase 3:\n\t\tproto_tree_add_bitmask(cql_tree, raw_tvb, offset, hf_cql_flags_bitmap, ett_cql_header_flags_bitmap, cql_header_bitmaps_v3, ENC_BIG_ENDIAN);\n\t\tbreak;\n\t\tcase 4:\n\t\tproto_tree_add_bitmask(cql_tree, raw_tvb, offset, hf_cql_flags_bitmap, ett_cql_header_flags_bitmap, cql_header_bitmaps_v4, ENC_BIG_ENDIAN);\n\t\tbreak;\n\t\tdefault:\n\t\tproto_tree_add_item(cql_tree, hf_cql_flags_bitmap, raw_tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\tbreak;\n\t}\n\tflags = tvb_get_guint8(raw_tvb, offset);\n\toffset += 1;\n\tproto_tree_add_item_ret_int(cql_tree, hf_cql_stream, raw_tvb, offset, 2, ENC_BIG_ENDIAN, &stream);\n\toffset += 2;\n\tproto_tree_add_item(cql_tree, hf_cql_opcode, raw_tvb, offset, 1, ENC_BIG_ENDIAN);\n\toffset += 1;\n\tproto_tree_add_item_ret_uint(cql_tree, hf_cql_length, raw_tvb, offset, 4, ENC_BIG_ENDIAN, &message_length);\n\toffset += 4;\n\n\t/* Track the request/response. */\n\tif (!pinfo->fd->flags.visited) {\n\t\tif (server_to_client == 0) {\n\t\t\t/* This is a request, add it to this stream tracking */\n\t\t\tcql_trans = cql_transaction_add_request(cql_conv, pinfo, stream, 0);\n\t\t} else {\n\t\t\t/* This is a response, bind the response with the latest request */\n\t\t\tcql_trans = cql_enrich_transaction_with_response(cql_conv, pinfo, stream);\n\t\t}\n\t} else {\n\t\t/* Search for any packet having this packed id as request or response */\n\t\tcql_trans = cql_transaction_lookup(cql_conv, pinfo, stream);\n\t}\n\n\tif (!cql_trans) {\n\t\t/* Add a fake request to this stream tracking */\n\t\tcql_trans = cql_transaction_add_request(cql_conv, pinfo, stream, 1);\n\t}\n\n\t/* Add state tracking to tree */\n\tif (server_to_client == 0 && cql_trans->rep_frame) {\n\t\t/* request */\n\t\tti = proto_tree_add_uint(cql_tree, hf_cql_response_in, raw_tvb, 0, 0, cql_trans->rep_frame);\n\t\tPROTO_ITEM_SET_GENERATED(ti);\n\t}\n\tif (server_to_client && cql_trans->req_frame) {\n\t\t/* reply */\n\t\tnstime_t ns;\n\n\t\tti = proto_tree_add_uint(cql_tree, hf_cql_response_to, raw_tvb, 0, 0, cql_trans->req_frame);\n\t\tPROTO_ITEM_SET_GENERATED(ti);\n\t\tnstime_delta(&ns, &pinfo->fd->abs_ts, &cql_trans->req_time);\n\t\tti = proto_tree_add_time(cql_tree, hf_cql_response_time, raw_tvb, 0, 0, &ns);\n\t\tPROTO_ITEM_SET_GENERATED(ti);\n\t}\n\n\t/* We cannot rely on compression negociation in the STARTUP message because the\n\t * capture can be done at a random time hence missing the negociation.\n\t * So we will first try to decompress LZ4 then snappy\n\t */\n\tif (flags & CQL_HEADER_FLAG_COMPRESSION) {\n\t\tcompression_level = CQL_DECOMPRESSION_ATTEMPTED;\n#ifdef HAVE_LZ4\n\t\tif (tvb_captured_length_remaining(raw_tvb, offset) > 4) {\n\t\t\t/* Set ret == 0 to make it fail in case decompression is skipped\n\t\t\t * due to orig_size being too big\n\t\t\t */\n\t\t\tguint32 ret = 0, orig_size = tvb_get_ntohl(raw_tvb, offset);\n\t\t\tguchar *decompressed_buffer = NULL;\n\t\t\toffset += 4;\n\n\t\t\t/* if the decompressed size is reasonably small try to decompress data */\n\t\t\tif (orig_size <= MAX_UNCOMPRESSED_SIZE) {\n\t\t\t\tdecompressed_buffer = (guchar*)wmem_alloc(pinfo->pool, orig_size);\n\t\t\t\tret = LZ4_decompress_safe(tvb_get_ptr(raw_tvb, offset, -1),\n\t\t\t\t\t\t\t  decompressed_buffer,\n\t\t\t\t\t\t\t  tvb_captured_length_remaining(raw_tvb, offset),\n\t\t\t\t\t\t\t  orig_size);\n\t\t\t}\n\t\t\t/* Decompression attempt failed: rewind offset */\n\t\t\tif (ret != orig_size) {\n\t\t\t\twmem_free(pinfo->pool, decompressed_buffer);\n\t\t\t\toffset -= 4;\n\t\t\t} else {\n\t\t\t\t/* Now re-setup the tvb buffer to have the new data */\n\t\t\t\ttvb = tvb_new_child_real_data(raw_tvb, decompressed_buffer, orig_size, orig_size);\n\t\t\t\tadd_new_data_source(pinfo, tvb, \"Decompressed Data\");\n\t\t\t\t/* mark the decompression as successfull */\n\t\t\t\tcompression_level = CQL_COMPRESSION_LZ4;\n\t\t\t\tmessage_length= orig_size;\n\t\t\t}\n\t\t}\n#endif\n#ifdef HAVE_SNAPPY\n\t\tif (compression_level == CQL_DECOMPRESSION_ATTEMPTED) {\n\t\t\tguchar *decompressed_buffer = NULL;\n\t\t\tsize_t orig_size = 0;\n\t\t\tsnappy_status ret;\n\n\t\t\t/* get the raw data length */\n\t\t\tret = snappy_uncompressed_length(tvb_get_ptr(raw_tvb, offset, -1),\n\t\t\t\t\t\t\t tvb_captured_length_remaining(raw_tvb, offset),\n\t\t\t\t\t\t\t &orig_size);\n\t\t\t/* if we get the length and it's reasonably short to allocate a buffer for it\n\t\t\t * proceed to try decompressing the data\n\t\t\t */\n\t\t\tif (ret == SNAPPY_OK && orig_size <= MAX_UNCOMPRESSED_SIZE) {\n\t\t\t\tdecompressed_buffer = (guchar*)wmem_alloc(pinfo->pool, orig_size);\n\n\t\t\t\tret = snappy_uncompress(tvb_get_ptr(raw_tvb, offset, -1),\n\t\t\t\t\t\t\ttvb_captured_length_remaining(raw_tvb, offset),\n\t\t\t\t\t\t\tdecompressed_buffer,\n\t\t\t\t\t\t\t&orig_size);\n\t\t\t} else {\n\t\t\t\t/* else mark the input as invalid in order to skip the rest of the\n\t\t\t\t * procedure\n\t\t\t\t */\n\t\t\t\tret = SNAPPY_INVALID_INPUT;\n\t\t\t}\n\t\t\t/* if the decompression succeeded build the new tvb */\n\t\t\tif (ret == SNAPPY_OK) {\n\t\t\t\ttvb = tvb_new_child_real_data(raw_tvb, decompressed_buffer, (guint32)orig_size, (guint32)orig_size);\n\t\t\t\tadd_new_data_source(pinfo, tvb, \"Decompressed Data\");\n\t\t\t\tcompression_level = CQL_COMPRESSION_SNAPPY;\n\t\t\t\tmessage_length = (guint32)orig_size;\n\t\t\t} else {\n\t\t\t\twmem_free(pinfo->pool, decompressed_buffer);\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tif (compression_level == CQL_COMPRESSION_NONE) {\n\t\t/* In case of decompression failure or uncompressed packet */\n\t\ttvb = tvb_new_subset_remaining(raw_tvb, offset);\n\t} else if (compression_level == CQL_DECOMPRESSION_ATTEMPTED) {\n\t\tproto_tree_add_item(cql_tree, hf_cql_raw_compressed_bytes, raw_tvb, offset,\n\t\t\t\t\ttvb_captured_length_remaining(raw_tvb, offset), ENC_NA);\n\t\treturn tvb_captured_length(raw_tvb);\n\t}\n\toffset = 0;\n\n\n\t/* Dissect the operation. */\n\tif (server_to_client == 0) {\n\t\tswitch (opcode) {\n\t\t\tcase CQL_OPCODE_STARTUP:\n\t\t\t\tcql_subtree = proto_tree_add_subtree(cql_tree, tvb, offset, message_length, ett_cql_message, &ti, \"Message STARTUP\");\n\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_string_map_size, tvb, offset, 2, ENC_BIG_ENDIAN, &map_size);\n\t\t\t\toffset += 2;\n\t\t\t\tfor(i = 0; i < map_size; ++i) {\n\t\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_string_length, tvb, offset, 2, ENC_BIG_ENDIAN, &string_length);\n\t\t\t\t\toffset += 2;\n\t\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_string, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\t\toffset += string_length;\n\n\t\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_string_length, tvb, offset, 2, ENC_BIG_ENDIAN, &string_length);\n\t\t\t\t\toffset += 2;\n\t\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_string, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\t\toffset += string_length;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CQL_OPCODE_AUTH_RESPONSE:\n\t\t\t\t/* not implemented */\n\t\t\t\tbreak;\n\n\t\t\tcase CQL_OPCODE_OPTIONS:\n\t\t\t\t/* body should be empty */\n\t\t\t\tbreak;\n\n\t\t\tcase CQL_OPCODE_QUERY:\n\t\t\t\tcql_subtree = proto_tree_add_subtree(cql_tree, tvb, offset, message_length, ett_cql_message, &ti, \"Query\");\n\n\t\t\t\t/* Query */\n\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_string_length, tvb, offset, 4, ENC_BIG_ENDIAN, &string_length);\n\t\t\t\toffset += 4;\n\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_string, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\toffset += string_length;\n\n\t\t\t\t/* Query parameters */\n\t\t\t\tdissect_cql_query_parameters(cql_subtree, tvb, offset, 0);\n\n\t\t\t\tbreak;\n\n\n\t\t\tcase CQL_OPCODE_PREPARE:\n\t\t\t\tcql_subtree = proto_tree_add_subtree(cql_tree, tvb, offset, message_length, ett_cql_message, &ti, \"Message PREPARE\");\n\n\t\t\t\t/* TODO: Link for later use by EXECUTE? */\n\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_string_length, tvb, offset, 4, ENC_BIG_ENDIAN, &string_length);\n\t\t\t\toffset += 4;\n\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_string, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\tbreak;\n\n\n\t\t\tcase CQL_OPCODE_EXECUTE:\n\t\t\t\tcql_subtree = proto_tree_add_subtree(cql_tree, tvb, offset, message_length, ett_cql_message, &ti, \"Message EXECUTE\");\n\n\t\t\t\t/* TODO: link to original PREPARE? */\n\n\t\t\t\t/* Query ID */\n\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_short_bytes_length, tvb, offset, 2, ENC_BIG_ENDIAN, &bytes_length);\n\t\t\t\toffset += 2;\n\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_query_id, tvb, offset, bytes_length, ENC_NA);\n\t\t\t\toffset += bytes_length;\n\n\t\t\t\t/* Query parameters */\n\t\t\t\tdissect_cql_query_parameters(cql_subtree, tvb, offset, 1);\n\t\t\t\tbreak;\n\n\n\t\t\tcase CQL_OPCODE_BATCH:\n\t\t\t\t/* TODO NOT DONE */\n\t\t\t\tcql_subtree = proto_tree_add_subtree(cql_tree, tvb, offset, message_length, ett_cql_message, &ti, \"Message BATCH\");\n\n\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_batch_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\t\t\toffset += 1;\n\n\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_batch_query_size, tvb, offset, 2, ENC_BIG_ENDIAN, &batch_size);\n\t\t\t\toffset += 2;\n\n\t\t\t\tfor (i = 0; i < batch_size; ++i) {\n\t\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_batch_query_type, tvb, offset, 1, ENC_BIG_ENDIAN, &batch_query_type);\n\t\t\t\t\tbatch_query_type = tvb_get_guint8(tvb, offset);\n\t\t\t\t\toffset += 1;\n\t\t\t\t\tif (batch_query_type == 0) {\n\t\t\t\t\t\t/* Query */\n\t\t\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_string_length, tvb, offset, 4, ENC_BIG_ENDIAN, &string_length);\n\t\t\t\t\t\toffset += 4;\n\t\t\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_string, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\t\t\toffset += string_length;\n\n\t\t\t\t\t\t/* Query parameters */\n\t\t\t\t\t\toffset = dissect_cql_query_parameters(cql_subtree, tvb, offset, 0);\n\t\t\t\t\t} else if (batch_query_type == 1) {\n\t\t\t\t\t\tguint32 value_count = 0;\n\t\t\t\t\t\tguint32 query_id_bytes_length;\n\n\t\t\t\t\t\t/* Query ID */\n\t\t\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_short_bytes_length, tvb, offset, 2, ENC_BIG_ENDIAN, &query_id_bytes_length);\n\t\t\t\t\t\toffset += 2;\n\t\t\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_query_id, tvb, offset, query_id_bytes_length, ENC_NA);\n\t\t\t\t\t\toffset += query_id_bytes_length;\n\n\t\t\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_value_count, tvb, offset, 2, ENC_BIG_ENDIAN, &value_count);\n\t\t\t\t\t\toffset += 2;\n\t\t\t\t\t\tfor (k = 0; k < value_count; ++k) {\n\t\t\t\t\t\t\tguint32 batch_bytes_length = 0;\n\t\t\t\t\t\t\tproto_tree_add_item_ret_int(cql_subtree, hf_cql_bytes_length, tvb, offset, 4, ENC_BIG_ENDIAN, &batch_bytes_length);\n\t\t\t\t\t\t\toffset += 4;\n\t\t\t\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_bytes, tvb, offset, batch_bytes_length, ENC_NA);\n\t\t\t\t\t\t\toffset += batch_bytes_length;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* consistency */\n\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_consistency, tvb, offset, 2, ENC_BIG_ENDIAN);\n\t\t\t\toffset += 2;\n\t\t\t\tproto_tree_add_bitmask(cql_subtree, tvb, offset, hf_cql_batch_flags_bitmap, ett_cql_batch_flags_bitmap, cql_batch_flags_bitmaps, ENC_BIG_ENDIAN);\n\t\t\t\tbreak;\n\n\t\t\tcase CQL_OPCODE_REGISTER:\n\t\t\t\tcql_subtree = proto_tree_add_subtree(cql_tree, tvb, offset, message_length, ett_cql_message, &ti, \"Message REGISTER\");\n\n\t\t\t\t/* string list */\n\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_string_list_size, tvb, offset, 2, ENC_BIG_ENDIAN, &map_size);\n\t\t\t\toffset += 2;\n\t\t\t\tfor(i = 0; i < map_size; ++i) {\n\t\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_string_length, tvb, offset, 2, ENC_BIG_ENDIAN, &string_length);\n\t\t\t\t\toffset += 2;\n\t\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_string, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\t\toffset += string_length;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tproto_tree_add_expert(cql_tree, pinfo, &ei_cql_data_not_dissected_yet, tvb, 0, message_length);\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (opcode) {\n\t\t\tcase CQL_OPCODE_ERROR:\n\t\t\t\tcql_subtree = proto_tree_add_subtree(cql_tree, tvb, offset, message_length, ett_cql_message, &ti, \"Message ERROR\");\n\n\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_error_code, tvb, offset, 4, ENC_BIG_ENDIAN);\n\n\t\t\t\t/* string  */\n\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_string_length, tvb, offset, 2, ENC_BIG_ENDIAN, &string_length);\n\t\t\t\toffset += 2;\n\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_string, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\tbreak;\n\n\n\t\t\tcase CQL_OPCODE_AUTHENTICATE:\n\t\t\t\t/* Not implemented. */\n\t\t\t\tbreak;\n\n\n\t\t\tcase CQL_OPCODE_SUPPORTED:\n\t\t\t\t/* Not implemented. */\n\t\t\t\tbreak;\n\n\n\t\t\tcase CQL_OPCODE_RESULT:\n\t\t\t\tcql_subtree = proto_tree_add_subtree(cql_tree, tvb, offset, message_length, ett_cql_message, &ti, \"Message RESULT\");\n\n\t\t\t\tproto_tree_add_item_ret_int(cql_subtree, hf_cql_result_kind, tvb, offset, 4, ENC_BIG_ENDIAN, &result_kind);\n\t\t\t\toffset += 4;\n\n\t\t\t\tswitch (result_kind) {\n\t\t\t\t\tcase CQL_RESULT_KIND_VOID:\n\t\t\t\t\t\t/* Nothing */\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CQL_RESULT_KIND_ROWS:\n\t\t\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_result_rows_flags_values, tvb, offset, 4, ENC_BIG_ENDIAN, &result_rows_flags);\n\t\t\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_result_rows_flag_global_tables_spec, tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_result_rows_flag_has_more_pages, tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_result_rows_flag_no_metadata, tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t\tmetadata_subtree = proto_tree_add_subtree(cql_subtree, tvb, offset, 0, ett_cql_result_metadata, &ti, \"Metadata\");\n\n\t\t\t\t\t\tti = proto_tree_add_item_ret_int(metadata_subtree, hf_cql_result_rows_column_count, tvb, offset, 4, ENC_BIG_ENDIAN, &result_rows_columns_count);\n\t\t\t\t\t\tif (result_rows_columns_count < 0) {\n\t\t\t\t\t\t\texpert_add_info(pinfo, ti, &ei_cql_unexpected_negative_value);\n\t\t\t\t\t\t\treturn tvb_reported_length(tvb);\n\t\t\t\t\t\t}\n\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t\tif (result_rows_flags & CQL_RESULT_ROWS_FLAG_GLOBAL_TABLES_SPEC) {\n\t\t\t\t\t\t\tproto_tree_add_item_ret_uint(metadata_subtree, hf_cql_string_length, tvb, offset, 2, ENC_BIG_ENDIAN, &string_length);\n\t\t\t\t\t\t\toffset += 2;\n\t\t\t\t\t\t\tproto_tree_add_item(metadata_subtree, hf_cql_string_result_rows_global_table_spec_ksname, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\t\t\t\toffset += string_length;\n\n\t\t\t\t\t\t\tproto_tree_add_item_ret_uint(metadata_subtree, hf_cql_string_length, tvb, offset, 2, ENC_BIG_ENDIAN, &string_length);\n\t\t\t\t\t\t\toffset += 2;\n\t\t\t\t\t\t\tproto_tree_add_item(metadata_subtree, hf_cql_string_result_rows_global_table_spec_table_name, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\t\t\t\toffset += string_length;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (result_rows_flags & CQL_RESULT_ROWS_FLAG_HAS_MORE_PAGES) {\n\t\t\t\t\t\t\t/* show paging state */\n\t\t\t\t\t\t\tproto_tree_add_item_ret_int(metadata_subtree, hf_cql_bytes_length, tvb, offset, 4, ENC_BIG_ENDIAN, &bytes_length);\n\t\t\t\t\t\t\toffset += 4;\n\t\t\t\t\t\t\tif (bytes_length > 0) {\n\t\t\t\t\t\t\t\tproto_tree_add_item(metadata_subtree, hf_cql_paging_state, tvb, offset, bytes_length, ENC_NA);\n\t\t\t\t\t\t\t\toffset += bytes_length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (result_rows_flags & CQL_RESULT_ROWS_FLAG_NO_METADATA) {\n\t\t\t\t\t\t\t/* There will be no col_spec elements. */\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* Instead of bloating everything by creating a duplicate structure hierarchy in memory\n\t\t\t\t\t\t\t * simply remember the offset of the row metadata for later parsing of the actual rows.\n\t\t\t\t\t\t\t **/\n\t\t\t\t\t\t\toffset_row_metadata = offset;\n\n\t\t\t\t\t\t\tfor (j = 0; j < result_rows_columns_count; ++j) {\n\t\t\t\t\t\t\t\tif (!(result_rows_flags & CQL_RESULT_ROWS_FLAG_GLOBAL_TABLES_SPEC)) {\n\t\t\t\t\t\t\t\t\t/* ksname and tablename */\n\t\t\t\t\t\t\t\t\tproto_tree_add_item_ret_uint(metadata_subtree, hf_cql_string_length, tvb, offset, 2, ENC_BIG_ENDIAN, &string_length);\n\t\t\t\t\t\t\t\t\toffset += 2;\n\t\t\t\t\t\t\t\t\tproto_tree_add_item(metadata_subtree, hf_cql_string_result_rows_keyspace_name, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\t\t\t\t\t\toffset += string_length;\n\t\t\t\t\t\t\t\t\tproto_tree_add_item_ret_uint(metadata_subtree, hf_cql_string_length, tvb, offset, 2, ENC_BIG_ENDIAN, &string_length);\n\t\t\t\t\t\t\t\t\toffset += 2;\n\t\t\t\t\t\t\t\t\tproto_tree_add_item(metadata_subtree, hf_cql_string_result_rows_table_name, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\t\t\t\t\t\toffset += string_length;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t/* column name */\n\t\t\t\t\t\t\t\tproto_tree_add_item_ret_uint(metadata_subtree, hf_cql_string_length, tvb, offset, 2, ENC_BIG_ENDIAN, &string_length);\n\t\t\t\t\t\t\t\toffset += 2;\n\t\t\t\t\t\t\t\tproto_tree_add_item(metadata_subtree, hf_cql_string_result_rows_column_name, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\t\t\t\t\toffset += string_length;\n\n\n\t\t\t\t\t\t\t\t/* type \"option\" */\n\t\t\t\t\t\t\t\toffset = parse_option(metadata_subtree, tvb, offset);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trows_subtree = proto_tree_add_subtree(cql_subtree, tvb, offset, 0, ett_cql_result_rows, &ti, \"Rows\");\n\t\t\t\t\t\tti = proto_tree_add_item_ret_int(rows_subtree, hf_cql_result_rows_row_count, tvb, offset, 4, ENC_BIG_ENDIAN, &result_rows_row_count);\n\t\t\t\t\t\tif (result_rows_row_count < 0) {\n\t\t\t\t\t\t\texpert_add_info(pinfo, ti, &ei_cql_unexpected_negative_value);\n\t\t\t\t\t\t\treturn tvb_reported_length(tvb);\n\t\t\t\t\t\t}\n\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t\tfor (j = 0; j < result_rows_row_count; ++j) {\n\t\t\t\t\t\t\tcolumns_subtree = proto_tree_add_subtree(rows_subtree, tvb, offset, 0, ett_cql_result_columns, &ti, \"Data (Columns)\");\n\n\t\t\t\t\t\t\tif (offset_row_metadata) {\n\t\t\t\t\t\t\t\toffset = parse_row(columns_subtree, pinfo, tvb, offset_row_metadata, offset, result_rows_columns_count);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (k = 0; k < result_rows_columns_count; ++k) {\n\t\t\t\t\t\t\t\t\tproto_tree_add_item_ret_int(columns_subtree, hf_cql_bytes_length, tvb, offset, 4, ENC_BIG_ENDIAN, &bytes_length);\n\t\t\t\t\t\t\t\t\toffset += 4;\n\t\t\t\t\t\t\t\t\tproto_tree_add_item(columns_subtree, hf_cql_bytes, tvb, offset, bytes_length, ENC_NA);\n\t\t\t\t\t\t\t\t\toffset += bytes_length;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tcase CQL_RESULT_KIND_SET_KEYSPACE:\n\t\t\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_string_length, tvb, offset, 2, ENC_BIG_ENDIAN, &string_length);\n\t\t\t\t\t\toffset += 2;\n\t\t\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_string, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tcase CQL_RESULT_KIND_PREPARED:\n\t\t\t\t\t\t/* Query ID */\n\t\t\t\t\t\tproto_tree_add_item_ret_uint(metadata_subtree, hf_cql_short_bytes_length, tvb, offset, 2, ENC_BIG_ENDIAN, &bytes_length);\n\t\t\t\t\t\toffset += 2;\n\t\t\t\t\t\tproto_tree_add_item(metadata_subtree, hf_cql_query_id, tvb, offset, bytes_length, ENC_NA);\n\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tcase CQL_RESULT_KIND_SCHEMA_CHANGE:\n\t\t\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_string, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\t\t\toffset += string_length;\n\t\t\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_string, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\t\t\toffset += string_length;\n\t\t\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_string, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tproto_tree_add_expert(cql_subtree, pinfo, &ei_cql_data_not_dissected_yet, tvb, 0, message_length);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\n\t\t\tcase CQL_OPCODE_EVENT:\n\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_string, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\tbreak;\n\n\n\t\t\tcase CQL_OPCODE_AUTH_CHALLENGE:\n\t\t\t\tbreak;\n\n\n\t\t\tcase CQL_OPCODE_AUTH_SUCCESS:\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tproto_tree_add_expert(cql_subtree, pinfo, &ei_cql_data_not_dissected_yet, tvb, 0, message_length);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn tvb_reported_length(tvb);\n}",
        "func": "static int\ndissect_cql_tcp_pdu(tvbuff_t* raw_tvb, packet_info* pinfo, proto_tree* tree, void* data _U_)\n{\n\tproto_item* ti;\n\ttvbuff_t* tvb = NULL;\n\tproto_tree* cql_tree;\n\tproto_tree* version_tree;\n\tproto_tree* cql_subtree = NULL;\n\tproto_tree* rows_subtree = NULL;\n\tproto_tree* columns_subtree = NULL;\n\tproto_tree* metadata_subtree = NULL;\n\n\tgint offset = 0;\n\tgint offset_row_metadata = 0;\n\tguint8 flags = 0;\n\tguint8 first_byte = 0;\n\tguint8 cql_version = 0;\n\tguint8 server_to_client = 0;\n\tguint8 opcode = 0;\n\tguint32 message_length = 0;\n\tguint32 map_size = 0;\n\tguint64 i = 0;\n\tguint32 string_length = 0;\n\tgint32 stream = 0;\n\tguint32 batch_size = 0;\n\tguint32 batch_query_type = 0;\n\tguint32 result_kind = 0;\n\tgint32 result_rows_flags = 0;\n\tgint32 result_rows_columns_count = 0;\n\tgint64 j = 0;\n\tgint64 k = 0;\n\tgint32 bytes_length = 0;\n\tgint32 result_rows_row_count = 0;\n\n\tconversation_t* conversation;\n\tcql_conversation_type* cql_conv;\n\tcql_transaction_type* cql_trans = NULL;\n\tcql_compression_level compression_level = CQL_COMPRESSION_NONE;\n\n\tstatic const int * cql_batch_flags_bitmaps[] = {\n\t\t&hf_cql_batch_flag_serial_consistency,\n\t\t&hf_cql_batch_flag_default_timestamp,\n\t\t&hf_cql_batch_flag_with_name_for_values,\n\t\tNULL\n\t};\n\n\tstatic const int * cql_header_bitmaps_v3[] = {\n\t\t&hf_cql_flag_compression,\n\t\t&hf_cql_flag_tracing,\n\t\t&hf_cql_flag_reserved3,\n\t\tNULL\n\t};\n\n\tstatic const int * cql_header_bitmaps_v4[] = {\n\t\t&hf_cql_flag_compression,\n\t\t&hf_cql_flag_tracing,\n\t\t&hf_cql_flag_custom_payload,\n\t\t&hf_cql_flag_warning,\n\t\t&hf_cql_flag_reserved4,\n\t\tNULL\n\t};\n\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"CQL\");\n\tcol_clear(pinfo->cinfo, COL_INFO);\n\n\tfirst_byte = tvb_get_guint8(raw_tvb, 0);\n\tcql_version = first_byte & (guint8)0x7F;\n\tserver_to_client = first_byte & (guint8)0x80;\n\topcode = tvb_get_guint8(raw_tvb, 4);\n\n\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"v%d %s Type %s\",\n\t\tcql_version,\n\t\tserver_to_client == 0 ? \"C->S\" : \"S->C\",\n\t\tval_to_str(opcode, cql_opcode_names, \"Unknown (0x%02x)\")\n\t);\n\n\tconversation = find_or_create_conversation(pinfo);\n\tcql_conv = (cql_conversation_type*) conversation_get_proto_data(conversation, proto_cql);\n\tif(!cql_conv) {\n\t\tcql_conv = wmem_new(wmem_file_scope(), cql_conversation_type);\n\t\tcql_conv->streams = wmem_map_new(wmem_file_scope(), g_direct_hash, g_direct_equal);\n\t\tconversation_add_proto_data(conversation, proto_cql, cql_conv);\n\t}\n\n\tti = proto_tree_add_item(tree, proto_cql, raw_tvb, 0, -1, ENC_NA);\n\tcql_tree = proto_item_add_subtree(ti, ett_cql_protocol);\n\n\tti = proto_tree_add_item(cql_tree, hf_cql_version, raw_tvb, offset, 1, ENC_BIG_ENDIAN);\n\tversion_tree = proto_item_add_subtree(ti, ett_cql_version);\n\tproto_tree_add_item(version_tree, hf_cql_protocol_version, raw_tvb, offset, 1, ENC_BIG_ENDIAN);\n\tproto_tree_add_item(version_tree, hf_cql_direction, raw_tvb, offset, 1, ENC_BIG_ENDIAN);\n\toffset += 1;\n\tswitch(cql_version){\n\t\tcase 3:\n\t\tproto_tree_add_bitmask(cql_tree, raw_tvb, offset, hf_cql_flags_bitmap, ett_cql_header_flags_bitmap, cql_header_bitmaps_v3, ENC_BIG_ENDIAN);\n\t\tbreak;\n\t\tcase 4:\n\t\tproto_tree_add_bitmask(cql_tree, raw_tvb, offset, hf_cql_flags_bitmap, ett_cql_header_flags_bitmap, cql_header_bitmaps_v4, ENC_BIG_ENDIAN);\n\t\tbreak;\n\t\tdefault:\n\t\tproto_tree_add_item(cql_tree, hf_cql_flags_bitmap, raw_tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\tbreak;\n\t}\n\tflags = tvb_get_guint8(raw_tvb, offset);\n\toffset += 1;\n\tproto_tree_add_item_ret_int(cql_tree, hf_cql_stream, raw_tvb, offset, 2, ENC_BIG_ENDIAN, &stream);\n\toffset += 2;\n\tproto_tree_add_item(cql_tree, hf_cql_opcode, raw_tvb, offset, 1, ENC_BIG_ENDIAN);\n\toffset += 1;\n\tproto_tree_add_item_ret_uint(cql_tree, hf_cql_length, raw_tvb, offset, 4, ENC_BIG_ENDIAN, &message_length);\n\toffset += 4;\n\n\t/* Track the request/response. */\n\tif (!pinfo->fd->flags.visited) {\n\t\tif (server_to_client == 0) {\n\t\t\t/* This is a request, add it to this stream tracking */\n\t\t\tcql_trans = cql_transaction_add_request(cql_conv, pinfo, stream, 0);\n\t\t} else {\n\t\t\t/* This is a response, bind the response with the latest request */\n\t\t\tcql_trans = cql_enrich_transaction_with_response(cql_conv, pinfo, stream);\n\t\t}\n\t} else {\n\t\t/* Search for any packet having this packed id as request or response */\n\t\tcql_trans = cql_transaction_lookup(cql_conv, pinfo, stream);\n\t}\n\n\tif (!cql_trans) {\n\t\t/* Add a fake request to this stream tracking */\n\t\tcql_trans = cql_transaction_add_request(cql_conv, pinfo, stream, 1);\n\t}\n\n\t/* Add state tracking to tree */\n\tif (server_to_client == 0 && cql_trans->rep_frame) {\n\t\t/* request */\n\t\tti = proto_tree_add_uint(cql_tree, hf_cql_response_in, raw_tvb, 0, 0, cql_trans->rep_frame);\n\t\tPROTO_ITEM_SET_GENERATED(ti);\n\t}\n\tif (server_to_client && cql_trans->req_frame) {\n\t\t/* reply */\n\t\tnstime_t ns;\n\n\t\tti = proto_tree_add_uint(cql_tree, hf_cql_response_to, raw_tvb, 0, 0, cql_trans->req_frame);\n\t\tPROTO_ITEM_SET_GENERATED(ti);\n\t\tnstime_delta(&ns, &pinfo->fd->abs_ts, &cql_trans->req_time);\n\t\tti = proto_tree_add_time(cql_tree, hf_cql_response_time, raw_tvb, 0, 0, &ns);\n\t\tPROTO_ITEM_SET_GENERATED(ti);\n\t}\n\n\t/* We cannot rely on compression negociation in the STARTUP message because the\n\t * capture can be done at a random time hence missing the negociation.\n\t * So we will first try to decompress LZ4 then snappy\n\t */\n\tif (flags & CQL_HEADER_FLAG_COMPRESSION) {\n\t\tcompression_level = CQL_DECOMPRESSION_ATTEMPTED;\n#ifdef HAVE_LZ4\n\t\tif (tvb_captured_length_remaining(raw_tvb, offset) > 4) {\n\t\t\t/* Set ret == 0 to make it fail in case decompression is skipped\n\t\t\t * due to orig_size being too big\n\t\t\t */\n\t\t\tguint32 ret = 0, orig_size = tvb_get_ntohl(raw_tvb, offset);\n\t\t\tguchar *decompressed_buffer = NULL;\n\t\t\toffset += 4;\n\n\t\t\t/* if the decompressed size is reasonably small try to decompress data */\n\t\t\tif (orig_size <= MAX_UNCOMPRESSED_SIZE) {\n\t\t\t\tdecompressed_buffer = (guchar*)wmem_alloc(pinfo->pool, orig_size);\n\t\t\t\tret = LZ4_decompress_safe(tvb_get_ptr(raw_tvb, offset, -1),\n\t\t\t\t\t\t\t  decompressed_buffer,\n\t\t\t\t\t\t\t  tvb_captured_length_remaining(raw_tvb, offset),\n\t\t\t\t\t\t\t  orig_size);\n\t\t\t}\n\t\t\t/* Decompression attempt failed: rewind offset */\n\t\t\tif (ret != orig_size) {\n\t\t\t\twmem_free(pinfo->pool, decompressed_buffer);\n\t\t\t\toffset -= 4;\n\t\t\t} else {\n\t\t\t\t/* Now re-setup the tvb buffer to have the new data */\n\t\t\t\ttvb = tvb_new_child_real_data(raw_tvb, decompressed_buffer, orig_size, orig_size);\n\t\t\t\tadd_new_data_source(pinfo, tvb, \"Decompressed Data\");\n\t\t\t\t/* mark the decompression as successfull */\n\t\t\t\tcompression_level = CQL_COMPRESSION_LZ4;\n\t\t\t\tmessage_length= orig_size;\n\t\t\t}\n\t\t}\n#endif\n#ifdef HAVE_SNAPPY\n\t\tif (compression_level == CQL_DECOMPRESSION_ATTEMPTED) {\n\t\t\tguchar *decompressed_buffer = NULL;\n\t\t\tsize_t orig_size = 0;\n\t\t\tsnappy_status ret;\n\n\t\t\t/* get the raw data length */\n\t\t\tret = snappy_uncompressed_length(tvb_get_ptr(raw_tvb, offset, -1),\n\t\t\t\t\t\t\t tvb_captured_length_remaining(raw_tvb, offset),\n\t\t\t\t\t\t\t &orig_size);\n\t\t\t/* if we get the length and it's reasonably short to allocate a buffer for it\n\t\t\t * proceed to try decompressing the data\n\t\t\t */\n\t\t\tif (ret == SNAPPY_OK && orig_size <= MAX_UNCOMPRESSED_SIZE) {\n\t\t\t\tdecompressed_buffer = (guchar*)wmem_alloc(pinfo->pool, orig_size);\n\n\t\t\t\tret = snappy_uncompress(tvb_get_ptr(raw_tvb, offset, -1),\n\t\t\t\t\t\t\ttvb_captured_length_remaining(raw_tvb, offset),\n\t\t\t\t\t\t\tdecompressed_buffer,\n\t\t\t\t\t\t\t&orig_size);\n\t\t\t} else {\n\t\t\t\t/* else mark the input as invalid in order to skip the rest of the\n\t\t\t\t * procedure\n\t\t\t\t */\n\t\t\t\tret = SNAPPY_INVALID_INPUT;\n\t\t\t}\n\t\t\t/* if the decompression succeeded build the new tvb */\n\t\t\tif (ret == SNAPPY_OK) {\n\t\t\t\ttvb = tvb_new_child_real_data(raw_tvb, decompressed_buffer, (guint32)orig_size, (guint32)orig_size);\n\t\t\t\tadd_new_data_source(pinfo, tvb, \"Decompressed Data\");\n\t\t\t\tcompression_level = CQL_COMPRESSION_SNAPPY;\n\t\t\t\tmessage_length = (guint32)orig_size;\n\t\t\t} else {\n\t\t\t\twmem_free(pinfo->pool, decompressed_buffer);\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tif (compression_level == CQL_COMPRESSION_NONE) {\n\t\t/* In case of decompression failure or uncompressed packet */\n\t\ttvb = tvb_new_subset_remaining(raw_tvb, offset);\n\t} else if (compression_level == CQL_DECOMPRESSION_ATTEMPTED) {\n\t\tproto_tree_add_item(cql_tree, hf_cql_raw_compressed_bytes, raw_tvb, offset,\n\t\t\t\t\ttvb_captured_length_remaining(raw_tvb, offset), ENC_NA);\n\t\treturn tvb_captured_length(raw_tvb);\n\t}\n\toffset = 0;\n\n\n\t/* Dissect the operation. */\n\tif (server_to_client == 0) {\n\t\tswitch (opcode) {\n\t\t\tcase CQL_OPCODE_STARTUP:\n\t\t\t\tcql_subtree = proto_tree_add_subtree(cql_tree, tvb, offset, message_length, ett_cql_message, &ti, \"Message STARTUP\");\n\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_string_map_size, tvb, offset, 2, ENC_BIG_ENDIAN, &map_size);\n\t\t\t\toffset += 2;\n\t\t\t\tfor(i = 0; i < map_size; ++i) {\n\t\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_string_length, tvb, offset, 2, ENC_BIG_ENDIAN, &string_length);\n\t\t\t\t\toffset += 2;\n\t\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_string, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\t\toffset += string_length;\n\n\t\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_string_length, tvb, offset, 2, ENC_BIG_ENDIAN, &string_length);\n\t\t\t\t\toffset += 2;\n\t\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_string, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\t\toffset += string_length;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase CQL_OPCODE_AUTH_RESPONSE:\n\t\t\t\t/* not implemented */\n\t\t\t\tbreak;\n\n\t\t\tcase CQL_OPCODE_OPTIONS:\n\t\t\t\t/* body should be empty */\n\t\t\t\tbreak;\n\n\t\t\tcase CQL_OPCODE_QUERY:\n\t\t\t\tcql_subtree = proto_tree_add_subtree(cql_tree, tvb, offset, message_length, ett_cql_message, &ti, \"Query\");\n\n\t\t\t\t/* Query */\n\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_string_length, tvb, offset, 4, ENC_BIG_ENDIAN, &string_length);\n\t\t\t\toffset += 4;\n\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_string, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\toffset += string_length;\n\n\t\t\t\t/* Query parameters */\n\t\t\t\tdissect_cql_query_parameters(cql_subtree, tvb, offset, 0);\n\n\t\t\t\tbreak;\n\n\n\t\t\tcase CQL_OPCODE_PREPARE:\n\t\t\t\tcql_subtree = proto_tree_add_subtree(cql_tree, tvb, offset, message_length, ett_cql_message, &ti, \"Message PREPARE\");\n\n\t\t\t\t/* TODO: Link for later use by EXECUTE? */\n\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_string_length, tvb, offset, 4, ENC_BIG_ENDIAN, &string_length);\n\t\t\t\toffset += 4;\n\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_string, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\tbreak;\n\n\n\t\t\tcase CQL_OPCODE_EXECUTE:\n\t\t\t\tcql_subtree = proto_tree_add_subtree(cql_tree, tvb, offset, message_length, ett_cql_message, &ti, \"Message EXECUTE\");\n\n\t\t\t\t/* TODO: link to original PREPARE? */\n\n\t\t\t\t/* Query ID */\n\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_short_bytes_length, tvb, offset, 2, ENC_BIG_ENDIAN, &bytes_length);\n\t\t\t\toffset += 2;\n\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_query_id, tvb, offset, bytes_length, ENC_NA);\n\t\t\t\toffset += bytes_length;\n\n\t\t\t\t/* Query parameters */\n\t\t\t\tdissect_cql_query_parameters(cql_subtree, tvb, offset, 1);\n\t\t\t\tbreak;\n\n\n\t\t\tcase CQL_OPCODE_BATCH:\n\t\t\t\t/* TODO NOT DONE */\n\t\t\t\tcql_subtree = proto_tree_add_subtree(cql_tree, tvb, offset, message_length, ett_cql_message, &ti, \"Message BATCH\");\n\n\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_batch_type, tvb, offset, 1, ENC_BIG_ENDIAN);\n\t\t\t\toffset += 1;\n\n\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_batch_query_size, tvb, offset, 2, ENC_BIG_ENDIAN, &batch_size);\n\t\t\t\toffset += 2;\n\n\t\t\t\tfor (i = 0; i < batch_size; ++i) {\n\t\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_batch_query_type, tvb, offset, 1, ENC_BIG_ENDIAN, &batch_query_type);\n\t\t\t\t\tbatch_query_type = tvb_get_guint8(tvb, offset);\n\t\t\t\t\toffset += 1;\n\t\t\t\t\tif (batch_query_type == 0) {\n\t\t\t\t\t\t/* Query */\n\t\t\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_string_length, tvb, offset, 4, ENC_BIG_ENDIAN, &string_length);\n\t\t\t\t\t\toffset += 4;\n\t\t\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_string, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\t\t\toffset += string_length;\n\n\t\t\t\t\t\t/* Query parameters */\n\t\t\t\t\t\toffset = dissect_cql_query_parameters(cql_subtree, tvb, offset, 0);\n\t\t\t\t\t} else if (batch_query_type == 1) {\n\t\t\t\t\t\tguint32 value_count = 0;\n\t\t\t\t\t\tguint32 query_id_bytes_length;\n\n\t\t\t\t\t\t/* Query ID */\n\t\t\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_short_bytes_length, tvb, offset, 2, ENC_BIG_ENDIAN, &query_id_bytes_length);\n\t\t\t\t\t\toffset += 2;\n\t\t\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_query_id, tvb, offset, query_id_bytes_length, ENC_NA);\n\t\t\t\t\t\toffset += query_id_bytes_length;\n\n\t\t\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_value_count, tvb, offset, 2, ENC_BIG_ENDIAN, &value_count);\n\t\t\t\t\t\toffset += 2;\n\t\t\t\t\t\tfor (k = 0; k < value_count; ++k) {\n\t\t\t\t\t\t\tguint32 batch_bytes_length = 0;\n\t\t\t\t\t\t\tproto_tree_add_item_ret_int(cql_subtree, hf_cql_bytes_length, tvb, offset, 4, ENC_BIG_ENDIAN, &batch_bytes_length);\n\t\t\t\t\t\t\toffset += 4;\n\t\t\t\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_bytes, tvb, offset, batch_bytes_length, ENC_NA);\n\t\t\t\t\t\t\toffset += batch_bytes_length;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* consistency */\n\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_consistency, tvb, offset, 2, ENC_BIG_ENDIAN);\n\t\t\t\toffset += 2;\n\t\t\t\tproto_tree_add_bitmask(cql_subtree, tvb, offset, hf_cql_batch_flags_bitmap, ett_cql_batch_flags_bitmap, cql_batch_flags_bitmaps, ENC_BIG_ENDIAN);\n\t\t\t\tbreak;\n\n\t\t\tcase CQL_OPCODE_REGISTER:\n\t\t\t\tcql_subtree = proto_tree_add_subtree(cql_tree, tvb, offset, message_length, ett_cql_message, &ti, \"Message REGISTER\");\n\n\t\t\t\t/* string list */\n\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_string_list_size, tvb, offset, 2, ENC_BIG_ENDIAN, &map_size);\n\t\t\t\toffset += 2;\n\t\t\t\tfor(i = 0; i < map_size; ++i) {\n\t\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_string_length, tvb, offset, 2, ENC_BIG_ENDIAN, &string_length);\n\t\t\t\t\toffset += 2;\n\t\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_string, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\t\toffset += string_length;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tproto_tree_add_expert(cql_tree, pinfo, &ei_cql_data_not_dissected_yet, tvb, 0, message_length);\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (opcode) {\n\t\t\tcase CQL_OPCODE_ERROR:\n\t\t\t\tcql_subtree = proto_tree_add_subtree(cql_tree, tvb, offset, message_length, ett_cql_message, &ti, \"Message ERROR\");\n\n\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_error_code, tvb, offset, 4, ENC_BIG_ENDIAN);\n\n\t\t\t\t/* string  */\n\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_string_length, tvb, offset, 2, ENC_BIG_ENDIAN, &string_length);\n\t\t\t\toffset += 2;\n\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_string, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\tbreak;\n\n\n\t\t\tcase CQL_OPCODE_AUTHENTICATE:\n\t\t\t\t/* Not implemented. */\n\t\t\t\tbreak;\n\n\n\t\t\tcase CQL_OPCODE_SUPPORTED:\n\t\t\t\t/* Not implemented. */\n\t\t\t\tbreak;\n\n\n\t\t\tcase CQL_OPCODE_RESULT:\n\t\t\t\tcql_subtree = proto_tree_add_subtree(cql_tree, tvb, offset, message_length, ett_cql_message, &ti, \"Message RESULT\");\n\n\t\t\t\tproto_tree_add_item_ret_int(cql_subtree, hf_cql_result_kind, tvb, offset, 4, ENC_BIG_ENDIAN, &result_kind);\n\t\t\t\toffset += 4;\n\n\t\t\t\tswitch (result_kind) {\n\t\t\t\t\tcase CQL_RESULT_KIND_VOID:\n\t\t\t\t\t\t/* Nothing */\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase CQL_RESULT_KIND_ROWS:\n\t\t\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_result_rows_flags_values, tvb, offset, 4, ENC_BIG_ENDIAN, &result_rows_flags);\n\t\t\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_result_rows_flag_global_tables_spec, tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_result_rows_flag_has_more_pages, tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_result_rows_flag_no_metadata, tvb, offset, 4, ENC_BIG_ENDIAN);\n\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t\tmetadata_subtree = proto_tree_add_subtree(cql_subtree, tvb, offset, 0, ett_cql_result_metadata, &ti, \"Metadata\");\n\n\t\t\t\t\t\tti = proto_tree_add_item_ret_int(metadata_subtree, hf_cql_result_rows_column_count, tvb, offset, 4, ENC_BIG_ENDIAN, &result_rows_columns_count);\n\t\t\t\t\t\tif (result_rows_columns_count < 0) {\n\t\t\t\t\t\t\texpert_add_info(pinfo, ti, &ei_cql_unexpected_negative_value);\n\t\t\t\t\t\t\treturn tvb_reported_length(tvb);\n\t\t\t\t\t\t}\n\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t\tif (result_rows_flags & CQL_RESULT_ROWS_FLAG_GLOBAL_TABLES_SPEC) {\n\t\t\t\t\t\t\tproto_tree_add_item_ret_uint(metadata_subtree, hf_cql_string_length, tvb, offset, 2, ENC_BIG_ENDIAN, &string_length);\n\t\t\t\t\t\t\toffset += 2;\n\t\t\t\t\t\t\tproto_tree_add_item(metadata_subtree, hf_cql_string_result_rows_global_table_spec_ksname, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\t\t\t\toffset += string_length;\n\n\t\t\t\t\t\t\tproto_tree_add_item_ret_uint(metadata_subtree, hf_cql_string_length, tvb, offset, 2, ENC_BIG_ENDIAN, &string_length);\n\t\t\t\t\t\t\toffset += 2;\n\t\t\t\t\t\t\tproto_tree_add_item(metadata_subtree, hf_cql_string_result_rows_global_table_spec_table_name, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\t\t\t\toffset += string_length;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (result_rows_flags & CQL_RESULT_ROWS_FLAG_HAS_MORE_PAGES) {\n\t\t\t\t\t\t\t/* show paging state */\n\t\t\t\t\t\t\tproto_tree_add_item_ret_int(metadata_subtree, hf_cql_bytes_length, tvb, offset, 4, ENC_BIG_ENDIAN, &bytes_length);\n\t\t\t\t\t\t\toffset += 4;\n\t\t\t\t\t\t\tif (bytes_length > 0) {\n\t\t\t\t\t\t\t\tproto_tree_add_item(metadata_subtree, hf_cql_paging_state, tvb, offset, bytes_length, ENC_NA);\n\t\t\t\t\t\t\t\toffset += bytes_length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (result_rows_flags & CQL_RESULT_ROWS_FLAG_NO_METADATA) {\n\t\t\t\t\t\t\t/* There will be no col_spec elements. */\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t/* Instead of bloating everything by creating a duplicate structure hierarchy in memory\n\t\t\t\t\t\t\t * simply remember the offset of the row metadata for later parsing of the actual rows.\n\t\t\t\t\t\t\t **/\n\t\t\t\t\t\t\toffset_row_metadata = offset;\n\n\t\t\t\t\t\t\tfor (j = 0; j < result_rows_columns_count; ++j) {\n\t\t\t\t\t\t\t\tif (!(result_rows_flags & CQL_RESULT_ROWS_FLAG_GLOBAL_TABLES_SPEC)) {\n\t\t\t\t\t\t\t\t\t/* ksname and tablename */\n\t\t\t\t\t\t\t\t\tproto_tree_add_item_ret_uint(metadata_subtree, hf_cql_string_length, tvb, offset, 2, ENC_BIG_ENDIAN, &string_length);\n\t\t\t\t\t\t\t\t\toffset += 2;\n\t\t\t\t\t\t\t\t\tproto_tree_add_item(metadata_subtree, hf_cql_string_result_rows_keyspace_name, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\t\t\t\t\t\toffset += string_length;\n\t\t\t\t\t\t\t\t\tproto_tree_add_item_ret_uint(metadata_subtree, hf_cql_string_length, tvb, offset, 2, ENC_BIG_ENDIAN, &string_length);\n\t\t\t\t\t\t\t\t\toffset += 2;\n\t\t\t\t\t\t\t\t\tproto_tree_add_item(metadata_subtree, hf_cql_string_result_rows_table_name, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\t\t\t\t\t\toffset += string_length;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t/* column name */\n\t\t\t\t\t\t\t\tproto_tree_add_item_ret_uint(metadata_subtree, hf_cql_string_length, tvb, offset, 2, ENC_BIG_ENDIAN, &string_length);\n\t\t\t\t\t\t\t\toffset += 2;\n\t\t\t\t\t\t\t\tproto_tree_add_item(metadata_subtree, hf_cql_string_result_rows_column_name, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\t\t\t\t\toffset += string_length;\n\n\n\t\t\t\t\t\t\t\t/* type \"option\" */\n\t\t\t\t\t\t\t\toffset = parse_option(metadata_subtree, tvb, offset);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trows_subtree = proto_tree_add_subtree(cql_subtree, tvb, offset, 0, ett_cql_result_rows, &ti, \"Rows\");\n\t\t\t\t\t\tti = proto_tree_add_item_ret_int(rows_subtree, hf_cql_result_rows_row_count, tvb, offset, 4, ENC_BIG_ENDIAN, &result_rows_row_count);\n\t\t\t\t\t\tif (result_rows_row_count < 0) {\n\t\t\t\t\t\t\texpert_add_info(pinfo, ti, &ei_cql_unexpected_negative_value);\n\t\t\t\t\t\t\treturn tvb_reported_length(tvb);\n\t\t\t\t\t\t}\n\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t\tif (result_rows_columns_count) {\n\t\t\t\t\t\t\tfor (j = 0; j < result_rows_row_count; ++j) {\n\t\t\t\t\t\t\t\tcolumns_subtree = proto_tree_add_subtree(rows_subtree, tvb, offset, 0, ett_cql_result_columns, &ti, \"Data (Columns)\");\n\n\t\t\t\t\t\t\t\tif (offset_row_metadata) {\n\t\t\t\t\t\t\t\t\toffset = parse_row(columns_subtree, pinfo, tvb, offset_row_metadata, offset, result_rows_columns_count);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfor (k = 0; k < result_rows_columns_count; ++k) {\n\t\t\t\t\t\t\t\t\t\tproto_tree_add_item_ret_int(columns_subtree, hf_cql_bytes_length, tvb, offset, 4, ENC_BIG_ENDIAN, &bytes_length);\n\t\t\t\t\t\t\t\t\t\toffset += 4;\n\t\t\t\t\t\t\t\t\t\tproto_tree_add_item(columns_subtree, hf_cql_bytes, tvb, offset, bytes_length, ENC_NA);\n\t\t\t\t\t\t\t\t\t\toffset += bytes_length;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tcase CQL_RESULT_KIND_SET_KEYSPACE:\n\t\t\t\t\t\tproto_tree_add_item_ret_uint(cql_subtree, hf_cql_string_length, tvb, offset, 2, ENC_BIG_ENDIAN, &string_length);\n\t\t\t\t\t\toffset += 2;\n\t\t\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_string, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tcase CQL_RESULT_KIND_PREPARED:\n\t\t\t\t\t\t/* Query ID */\n\t\t\t\t\t\tproto_tree_add_item_ret_uint(metadata_subtree, hf_cql_short_bytes_length, tvb, offset, 2, ENC_BIG_ENDIAN, &bytes_length);\n\t\t\t\t\t\toffset += 2;\n\t\t\t\t\t\tproto_tree_add_item(metadata_subtree, hf_cql_query_id, tvb, offset, bytes_length, ENC_NA);\n\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tcase CQL_RESULT_KIND_SCHEMA_CHANGE:\n\t\t\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_string, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\t\t\toffset += string_length;\n\t\t\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_string, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\t\t\toffset += string_length;\n\t\t\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_string, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tproto_tree_add_expert(cql_subtree, pinfo, &ei_cql_data_not_dissected_yet, tvb, 0, message_length);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\n\t\t\tcase CQL_OPCODE_EVENT:\n\t\t\t\tproto_tree_add_item(cql_subtree, hf_cql_string, tvb, offset, string_length, ENC_UTF_8 | ENC_NA);\n\t\t\t\tbreak;\n\n\n\t\t\tcase CQL_OPCODE_AUTH_CHALLENGE:\n\t\t\t\tbreak;\n\n\n\t\t\tcase CQL_OPCODE_AUTH_SUCCESS:\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tproto_tree_add_expert(cql_subtree, pinfo, &ei_cql_data_not_dissected_yet, tvb, 0, message_length);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn tvb_reported_length(tvb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -485,17 +485,19 @@\n \t\t\t\t\t\t}\n \t\t\t\t\t\toffset += 4;\n \n-\t\t\t\t\t\tfor (j = 0; j < result_rows_row_count; ++j) {\n-\t\t\t\t\t\t\tcolumns_subtree = proto_tree_add_subtree(rows_subtree, tvb, offset, 0, ett_cql_result_columns, &ti, \"Data (Columns)\");\n-\n-\t\t\t\t\t\t\tif (offset_row_metadata) {\n-\t\t\t\t\t\t\t\toffset = parse_row(columns_subtree, pinfo, tvb, offset_row_metadata, offset, result_rows_columns_count);\n-\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\tfor (k = 0; k < result_rows_columns_count; ++k) {\n-\t\t\t\t\t\t\t\t\tproto_tree_add_item_ret_int(columns_subtree, hf_cql_bytes_length, tvb, offset, 4, ENC_BIG_ENDIAN, &bytes_length);\n-\t\t\t\t\t\t\t\t\toffset += 4;\n-\t\t\t\t\t\t\t\t\tproto_tree_add_item(columns_subtree, hf_cql_bytes, tvb, offset, bytes_length, ENC_NA);\n-\t\t\t\t\t\t\t\t\toffset += bytes_length;\n+\t\t\t\t\t\tif (result_rows_columns_count) {\n+\t\t\t\t\t\t\tfor (j = 0; j < result_rows_row_count; ++j) {\n+\t\t\t\t\t\t\t\tcolumns_subtree = proto_tree_add_subtree(rows_subtree, tvb, offset, 0, ett_cql_result_columns, &ti, \"Data (Columns)\");\n+\n+\t\t\t\t\t\t\t\tif (offset_row_metadata) {\n+\t\t\t\t\t\t\t\t\toffset = parse_row(columns_subtree, pinfo, tvb, offset_row_metadata, offset, result_rows_columns_count);\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tfor (k = 0; k < result_rows_columns_count; ++k) {\n+\t\t\t\t\t\t\t\t\t\tproto_tree_add_item_ret_int(columns_subtree, hf_cql_bytes_length, tvb, offset, 4, ENC_BIG_ENDIAN, &bytes_length);\n+\t\t\t\t\t\t\t\t\t\toffset += 4;\n+\t\t\t\t\t\t\t\t\t\tproto_tree_add_item(columns_subtree, hf_cql_bytes, tvb, offset, bytes_length, ENC_NA);\n+\t\t\t\t\t\t\t\t\t\toffset += bytes_length;\n+\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t\t\tfor (j = 0; j < result_rows_row_count; ++j) {",
                "\t\t\t\t\t\t\tcolumns_subtree = proto_tree_add_subtree(rows_subtree, tvb, offset, 0, ett_cql_result_columns, &ti, \"Data (Columns)\");",
                "",
                "\t\t\t\t\t\t\tif (offset_row_metadata) {",
                "\t\t\t\t\t\t\t\toffset = parse_row(columns_subtree, pinfo, tvb, offset_row_metadata, offset, result_rows_columns_count);",
                "\t\t\t\t\t\t\t} else {",
                "\t\t\t\t\t\t\t\tfor (k = 0; k < result_rows_columns_count; ++k) {",
                "\t\t\t\t\t\t\t\t\tproto_tree_add_item_ret_int(columns_subtree, hf_cql_bytes_length, tvb, offset, 4, ENC_BIG_ENDIAN, &bytes_length);",
                "\t\t\t\t\t\t\t\t\toffset += 4;",
                "\t\t\t\t\t\t\t\t\tproto_tree_add_item(columns_subtree, hf_cql_bytes, tvb, offset, bytes_length, ENC_NA);",
                "\t\t\t\t\t\t\t\t\toffset += bytes_length;"
            ],
            "added_lines": [
                "\t\t\t\t\t\tif (result_rows_columns_count) {",
                "\t\t\t\t\t\t\tfor (j = 0; j < result_rows_row_count; ++j) {",
                "\t\t\t\t\t\t\t\tcolumns_subtree = proto_tree_add_subtree(rows_subtree, tvb, offset, 0, ett_cql_result_columns, &ti, \"Data (Columns)\");",
                "",
                "\t\t\t\t\t\t\t\tif (offset_row_metadata) {",
                "\t\t\t\t\t\t\t\t\toffset = parse_row(columns_subtree, pinfo, tvb, offset_row_metadata, offset, result_rows_columns_count);",
                "\t\t\t\t\t\t\t\t} else {",
                "\t\t\t\t\t\t\t\t\tfor (k = 0; k < result_rows_columns_count; ++k) {",
                "\t\t\t\t\t\t\t\t\t\tproto_tree_add_item_ret_int(columns_subtree, hf_cql_bytes_length, tvb, offset, 4, ENC_BIG_ENDIAN, &bytes_length);",
                "\t\t\t\t\t\t\t\t\t\toffset += 4;",
                "\t\t\t\t\t\t\t\t\t\tproto_tree_add_item(columns_subtree, hf_cql_bytes, tvb, offset, bytes_length, ENC_NA);",
                "\t\t\t\t\t\t\t\t\t\toffset += bytes_length;",
                "\t\t\t\t\t\t\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-10289",
        "func_name": "ArtifexSoftware/mupdf/fz_skip_space",
        "description": "In MuPDF 1.13.0, there is an infinite loop in the fz_skip_space function of the pdf/pdf-xref.c file. A remote adversary could leverage this vulnerability to cause a denial of service via a crafted pdf file.",
        "git_url": "https://github.com/ArtifexSoftware/mupdf/commit/2e43685dc8a8a886fc9df9b3663cf199404f7637",
        "commit_title": "Bug 699271: Fix eternal loop when skipping space before EOF.",
        "commit_text": " Thanks to Michael J Gruber for providing this oneliner.",
        "func_before": "static void\nfz_skip_space(fz_context *ctx, fz_stream *stm)\n{\n\tdo\n\t{\n\t\tint c = fz_peek_byte(ctx, stm);\n\t\tif (c > 32 && c != EOF)\n\t\t\treturn;\n\t\t(void)fz_read_byte(ctx, stm);\n\t}\n\twhile (1);\n}",
        "func": "static void\nfz_skip_space(fz_context *ctx, fz_stream *stm)\n{\n\tdo\n\t{\n\t\tint c = fz_peek_byte(ctx, stm);\n\t\tif (c == EOF || c > 32)\n\t\t\treturn;\n\t\t(void)fz_read_byte(ctx, stm);\n\t}\n\twhile (1);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n \tdo\n \t{\n \t\tint c = fz_peek_byte(ctx, stm);\n-\t\tif (c > 32 && c != EOF)\n+\t\tif (c == EOF || c > 32)\n \t\t\treturn;\n \t\t(void)fz_read_byte(ctx, stm);\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (c > 32 && c != EOF)"
            ],
            "added_lines": [
                "\t\tif (c == EOF || c > 32)"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-10981",
        "func_name": "xen-project/xen/hvm_wait_for_io",
        "description": "An issue was discovered in Xen through 4.10.x allowing x86 HVM guest OS users to cause a denial of service (host OS infinite loop) in situations where a QEMU device model attempts to make invalid transitions between states of a request.",
        "git_url": "https://github.com/xen-project/xen/commit/92938e5d149669033aecdfb3d1396948d49d1887",
        "commit_title": "x86/HVM: guard against emulator driving ioreq state in weird ways",
        "commit_text": " In the case where hvm_wait_for_io() calls wait_on_xen_event_channel(), p->state ends up being read twice in succession: once to determine that state != p->state, and then again at the top of the loop.  This gives a compromised emulator a chance to change the state back between the two reads, potentially keeping Xen in a loop indefinitely.  Instead: * Read p->state once in each of the wait_on_xen_event_channel() tests, * re-use that value the next time around, * and insist that the states continue to transition \"forward\" (with the   exception of the transition to STATE_IOREQ_NONE).  This is XSA-262. ",
        "func_before": "static bool hvm_wait_for_io(struct hvm_ioreq_vcpu *sv, ioreq_t *p)\n{\n    while ( sv->pending )\n    {\n        unsigned int state = p->state;\n\n        smp_rmb();\n        switch ( state )\n        {\n        case STATE_IOREQ_NONE:\n            /*\n             * The only reason we should see this case is when an\n             * emulator is dying and it races with an I/O being\n             * requested.\n             */\n            hvm_io_assist(sv, ~0ul);\n            break;\n        case STATE_IORESP_READY: /* IORESP_READY -> NONE */\n            p->state = STATE_IOREQ_NONE;\n            hvm_io_assist(sv, p->data);\n            break;\n        case STATE_IOREQ_READY:  /* IOREQ_{READY,INPROCESS} -> IORESP_READY */\n        case STATE_IOREQ_INPROCESS:\n            wait_on_xen_event_channel(sv->ioreq_evtchn, p->state != state);\n            break;\n        default:\n            gdprintk(XENLOG_ERR, \"Weird HVM iorequest state %u\\n\", state);\n            sv->pending = false;\n            domain_crash(sv->vcpu->domain);\n            return false; /* bail */\n        }\n    }\n\n    return true;\n}",
        "func": "static bool hvm_wait_for_io(struct hvm_ioreq_vcpu *sv, ioreq_t *p)\n{\n    unsigned int prev_state = STATE_IOREQ_NONE;\n\n    while ( sv->pending )\n    {\n        unsigned int state = p->state;\n\n        smp_rmb();\n\n    recheck:\n        if ( unlikely(state == STATE_IOREQ_NONE) )\n        {\n            /*\n             * The only reason we should see this case is when an\n             * emulator is dying and it races with an I/O being\n             * requested.\n             */\n            hvm_io_assist(sv, ~0ul);\n            break;\n        }\n\n        if ( unlikely(state < prev_state) )\n        {\n            gdprintk(XENLOG_ERR, \"Weird HVM ioreq state transition %u -> %u\\n\",\n                     prev_state, state);\n            sv->pending = false;\n            domain_crash(sv->vcpu->domain);\n            return false; /* bail */\n        }\n\n        switch ( prev_state = state )\n        {\n        case STATE_IORESP_READY: /* IORESP_READY -> NONE */\n            p->state = STATE_IOREQ_NONE;\n            hvm_io_assist(sv, p->data);\n            break;\n        case STATE_IOREQ_READY:  /* IOREQ_{READY,INPROCESS} -> IORESP_READY */\n        case STATE_IOREQ_INPROCESS:\n            wait_on_xen_event_channel(sv->ioreq_evtchn,\n                                      ({ state = p->state;\n                                         smp_rmb();\n                                         state != prev_state; }));\n            goto recheck;\n        default:\n            gdprintk(XENLOG_ERR, \"Weird HVM iorequest state %u\\n\", state);\n            sv->pending = false;\n            domain_crash(sv->vcpu->domain);\n            return false; /* bail */\n        }\n    }\n\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,13 +1,16 @@\n static bool hvm_wait_for_io(struct hvm_ioreq_vcpu *sv, ioreq_t *p)\n {\n+    unsigned int prev_state = STATE_IOREQ_NONE;\n+\n     while ( sv->pending )\n     {\n         unsigned int state = p->state;\n \n         smp_rmb();\n-        switch ( state )\n+\n+    recheck:\n+        if ( unlikely(state == STATE_IOREQ_NONE) )\n         {\n-        case STATE_IOREQ_NONE:\n             /*\n              * The only reason we should see this case is when an\n              * emulator is dying and it races with an I/O being\n@@ -15,14 +18,30 @@\n              */\n             hvm_io_assist(sv, ~0ul);\n             break;\n+        }\n+\n+        if ( unlikely(state < prev_state) )\n+        {\n+            gdprintk(XENLOG_ERR, \"Weird HVM ioreq state transition %u -> %u\\n\",\n+                     prev_state, state);\n+            sv->pending = false;\n+            domain_crash(sv->vcpu->domain);\n+            return false; /* bail */\n+        }\n+\n+        switch ( prev_state = state )\n+        {\n         case STATE_IORESP_READY: /* IORESP_READY -> NONE */\n             p->state = STATE_IOREQ_NONE;\n             hvm_io_assist(sv, p->data);\n             break;\n         case STATE_IOREQ_READY:  /* IOREQ_{READY,INPROCESS} -> IORESP_READY */\n         case STATE_IOREQ_INPROCESS:\n-            wait_on_xen_event_channel(sv->ioreq_evtchn, p->state != state);\n-            break;\n+            wait_on_xen_event_channel(sv->ioreq_evtchn,\n+                                      ({ state = p->state;\n+                                         smp_rmb();\n+                                         state != prev_state; }));\n+            goto recheck;\n         default:\n             gdprintk(XENLOG_ERR, \"Weird HVM iorequest state %u\\n\", state);\n             sv->pending = false;",
        "diff_line_info": {
            "deleted_lines": [
                "        switch ( state )",
                "        case STATE_IOREQ_NONE:",
                "            wait_on_xen_event_channel(sv->ioreq_evtchn, p->state != state);",
                "            break;"
            ],
            "added_lines": [
                "    unsigned int prev_state = STATE_IOREQ_NONE;",
                "",
                "",
                "    recheck:",
                "        if ( unlikely(state == STATE_IOREQ_NONE) )",
                "        }",
                "",
                "        if ( unlikely(state < prev_state) )",
                "        {",
                "            gdprintk(XENLOG_ERR, \"Weird HVM ioreq state transition %u -> %u\\n\",",
                "                     prev_state, state);",
                "            sv->pending = false;",
                "            domain_crash(sv->vcpu->domain);",
                "            return false; /* bail */",
                "        }",
                "",
                "        switch ( prev_state = state )",
                "        {",
                "            wait_on_xen_event_channel(sv->ioreq_evtchn,",
                "                                      ({ state = p->state;",
                "                                         smp_rmb();",
                "                                         state != prev_state; }));",
                "            goto recheck;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-18273",
        "func_name": "ImageMagick/ReadTXTImage",
        "description": "In ImageMagick 7.0.7-16 Q16 x86_64 2017-12-22, an infinite loop vulnerability was found in the function ReadTXTImage in coders/txt.c, which allows attackers to cause a denial of service (CPU exhaustion) via a crafted image file that is mishandled in a GetImageIndexInList call.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/b8fcb59e9e1d1189caf2e0f5e39346944dcd6b9d",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/910",
        "commit_text": "",
        "func_before": "static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    colorspace[MagickPathExtent],\n    text[MagickPathExtent];\n\n  Image\n    *image;\n\n  long\n    x_offset,\n    y_offset;\n\n  PixelInfo\n    pixel;\n\n  MagickBooleanType\n    status;\n\n  QuantumAny\n    range;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    count,\n    type,\n    y;\n\n  unsigned long\n    depth,\n    height,\n    max_value,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) ResetMagickMemory(text,0,sizeof(text));\n  (void) ReadBlobString(image,text);\n  if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    width=0;\n    height=0;\n    max_value=0;\n    *colorspace='\\0';\n    count=(ssize_t) sscanf(text+32,\"%lu,%lu,%lu,%32s\",&width,&height,&max_value,\n      colorspace);\n    if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->columns=width;\n    image->rows=height;\n    if ((max_value == 0) || (max_value > 4294967295UL))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;\n    image->depth=depth;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    LocaleLower(colorspace);\n    i=(ssize_t) strlen(colorspace)-1;\n    image->alpha_trait=UndefinedPixelTrait;\n    if ((i > 0) && (colorspace[i] == 'a'))\n      {\n        colorspace[i]='\\0';\n        image->alpha_trait=BlendPixelTrait;\n      }\n    type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);\n    if (type < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    (void) SetImageBackgroundColor(image,exception);\n    (void) SetImageColorspace(image,(ColorspaceType) type,exception);\n    GetPixelInfo(image,&pixel);\n    range=GetQuantumRange(image->depth);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      double\n        alpha,\n        black,\n        blue,\n        green,\n        red;\n\n      red=0.0;\n      green=0.0;\n      blue=0.0;\n      black=0.0;\n      alpha=0.0;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        if (ReadBlobString(image,text) == (char *) NULL)\n          break;\n        switch (image->colorspace)\n        {\n          case GRAYColorspace:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\"%ld,%ld: (%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&alpha);\n                green=red;\n                blue=red;\n                break;\n              }\n            count=(ssize_t) sscanf(text,\"%ld,%ld: (%lf%*[%,]\",&x_offset,\n              &y_offset,&red);\n            green=red;\n            blue=red;\n            break;       \n          }\n          case CMYKColorspace:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&black,&alpha);\n                break;\n              }\n            count=(ssize_t) sscanf(text,\n              \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue,&black);\n            break;\n          }\n          default:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&alpha);\n                break;\n              }\n            count=(ssize_t) sscanf(text,\n              \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue);\n            break;       \n          }\n        }\n        if (strchr(text,'%') != (char *) NULL)\n          {\n            red*=0.01*range;\n            green*=0.01*range;\n            blue*=0.01*range;\n            black*=0.01*range;\n            alpha*=0.01*range;\n          }\n        if (image->colorspace == LabColorspace)\n          {\n            green+=(range+1)/2.0;\n            blue+=(range+1)/2.0;\n          }\n        pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),\n          range);\n        pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),\n          range);\n        pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),\n          range);\n        pixel.black=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (black+0.5),\n          range);\n        pixel.alpha=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (alpha+0.5),\n          range);\n        q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          continue;\n        SetPixelViaPixelInfo(image,&pixel,q);\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n    }\n    (void) ReadBlobString(image,text);\n    if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    colorspace[MagickPathExtent],\n    text[MagickPathExtent];\n\n  Image\n    *image;\n\n  long\n    x_offset,\n    y_offset;\n\n  PixelInfo\n    pixel;\n\n  MagickBooleanType\n    status;\n\n  QuantumAny\n    range;\n\n  register ssize_t\n    i,\n    x;\n\n  register Quantum\n    *q;\n\n  ssize_t\n    count,\n    type,\n    y;\n\n  unsigned long\n    depth,\n    height,\n    max_value,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) ResetMagickMemory(text,0,sizeof(text));\n  (void) ReadBlobString(image,text);\n  if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0)\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  do\n  {\n    width=0;\n    height=0;\n    max_value=0;\n    *colorspace='\\0';\n    count=(ssize_t) sscanf(text+32,\"%lu,%lu,%lu,%32s\",&width,&height,&max_value,\n      colorspace);\n    if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    image->columns=width;\n    image->rows=height;\n    if ((max_value == 0) || (max_value > 4294967295UL))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ;\n    image->depth=depth;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    LocaleLower(colorspace);\n    i=(ssize_t) strlen(colorspace)-1;\n    image->alpha_trait=UndefinedPixelTrait;\n    if ((i > 0) && (colorspace[i] == 'a'))\n      {\n        colorspace[i]='\\0';\n        image->alpha_trait=BlendPixelTrait;\n      }\n    type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace);\n    if (type < 0)\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    (void) SetImageBackgroundColor(image,exception);\n    (void) SetImageColorspace(image,(ColorspaceType) type,exception);\n    GetPixelInfo(image,&pixel);\n    range=GetQuantumRange(image->depth);\n    for (y=0; y < (ssize_t) image->rows; y++)\n    {\n      double\n        alpha,\n        black,\n        blue,\n        green,\n        red;\n\n      red=0.0;\n      green=0.0;\n      blue=0.0;\n      black=0.0;\n      alpha=0.0;\n      for (x=0; x < (ssize_t) image->columns; x++)\n      {\n        if (ReadBlobString(image,text) == (char *) NULL)\n          break;\n        switch (image->colorspace)\n        {\n          case GRAYColorspace:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\"%ld,%ld: (%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&alpha);\n                green=red;\n                blue=red;\n                break;\n              }\n            count=(ssize_t) sscanf(text,\"%ld,%ld: (%lf%*[%,]\",&x_offset,\n              &y_offset,&red);\n            green=red;\n            blue=red;\n            break;       \n          }\n          case CMYKColorspace:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&black,&alpha);\n                break;\n              }\n            count=(ssize_t) sscanf(text,\n              \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue,&black);\n            break;\n          }\n          default:\n          {\n            if (image->alpha_trait != UndefinedPixelTrait)\n              {\n                count=(ssize_t) sscanf(text,\n                  \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]\",\n                  &x_offset,&y_offset,&red,&green,&blue,&alpha);\n                break;\n              }\n            count=(ssize_t) sscanf(text,\n              \"%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]\",&x_offset,\n              &y_offset,&red,&green,&blue);\n            break;       \n          }\n        }\n        if (strchr(text,'%') != (char *) NULL)\n          {\n            red*=0.01*range;\n            green*=0.01*range;\n            blue*=0.01*range;\n            black*=0.01*range;\n            alpha*=0.01*range;\n          }\n        if (image->colorspace == LabColorspace)\n          {\n            green+=(range+1)/2.0;\n            blue+=(range+1)/2.0;\n          }\n        pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5),\n          range);\n        pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5),\n          range);\n        pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5),\n          range);\n        pixel.black=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (black+0.5),\n          range);\n        pixel.alpha=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (alpha+0.5),\n          range);\n        q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          continue;\n        SetPixelViaPixelInfo(image,&pixel,q);\n        if (SyncAuthenticPixels(image,exception) == MagickFalse)\n          break;\n      }\n    }\n    *text='\\0';\n    (void) ReadBlobString(image,text);\n    if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -190,6 +190,7 @@\n           break;\n       }\n     }\n+    *text='\\0';\n     (void) ReadBlobString(image,text);\n     if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0)\n       {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    *text='\\0';"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-12655",
        "func_name": "torvalds/linux/xfs_agf_verify",
        "description": "An issue was discovered in xfs_agf_verify in fs/xfs/libxfs/xfs_alloc.c in the Linux kernel through 5.6.10. Attackers may trigger a sync of excessive duration via an XFS v5 image with crafted metadata, aka CID-d0c7feaf8767.",
        "git_url": "https://github.com/torvalds/linux/commit/d0c7feaf87678371c2c09b3709400be416b2dc62",
        "commit_title": "xfs: add agf freeblocks verify in xfs_agf_verify",
        "commit_text": " We recently used fuzz(hydra) to test XFS and automatically generate tmp.img(XFS v5 format, but some metadata is wrong)  xfs_repair information(just one AG): agf_freeblks 0, counted 3224 in ag 0 agf_longest 536874136, counted 3224 in ag 0 sb_fdblocks 613, counted 3228  Test as follows: mount tmp.img tmpdir cp file1M tmpdir sync  In 4.19-stable, sync will stuck, the reason is: xfs_mountfs   xfs_check_summary_counts     if ((!xfs_sb_version_haslazysbcount(&mp->m_sb) ||        XFS_LAST_UNMOUNT_WAS_CLEAN(mp)) &&        !xfs_fs_has_sickness(mp, XFS_SICK_FS_COUNTERS)) \treturn 0;  -->just return, incore sb_fdblocks still be 613     xfs_initialize_perag_data  cp file1M tmpdir -->ok(write file to pagecache) sync -->stuck(write pagecache to disk) xfs_map_blocks   xfs_iomap_write_allocate     while (count_fsb != 0) {       nimaps = 0;       while (nimaps == 0) { --> endless loop          nimaps = 1;          xfs_bmapi_write(..., &nimaps) --> nimaps becomes 0 again xfs_bmapi_write   xfs_bmap_alloc     xfs_bmap_btalloc       xfs_alloc_vextent         xfs_alloc_fix_freelist           xfs_alloc_space_available -->fail(agf_freeblks is 0)  In linux-next, sync not stuck, cause commit c2b3164320b5 (\"xfs: use the latest extent at writeback delalloc conversion time\") remove the above while, dmesg is as follows: [   55.250114] XFS (loop0): page discard on page ffffea0008bc7380, inode 0x1b0c, offset 0.  Users do not know why this page is discard, the better soultion is: 1. Like xfs_repair, make sure sb_fdblocks is equal to counted (xfs_initialize_perag_data did this, who is not called at this mount) 2. Add agf verify, if fail, will tell users to repair  This patch use the second soultion. ",
        "func_before": "static xfs_failaddr_t\nxfs_agf_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_mount;\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(bp);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tif (!uuid_equal(&agf->agf_uuid, &mp->m_sb.sb_meta_uuid))\n\t\t\treturn __this_address;\n\t\tif (!xfs_log_check_lsn(mp,\n\t\t\t\tbe64_to_cpu(XFS_BUF_TO_AGF(bp)->agf_lsn)))\n\t\t\treturn __this_address;\n\t}\n\n\tif (!xfs_verify_magic(bp, agf->agf_magicnum))\n\t\treturn __this_address;\n\n\tif (!(XFS_AGF_GOOD_VERSION(be32_to_cpu(agf->agf_versionnum)) &&\n\t      be32_to_cpu(agf->agf_freeblks) <= be32_to_cpu(agf->agf_length) &&\n\t      be32_to_cpu(agf->agf_flfirst) < xfs_agfl_size(mp) &&\n\t      be32_to_cpu(agf->agf_fllast) < xfs_agfl_size(mp) &&\n\t      be32_to_cpu(agf->agf_flcount) <= xfs_agfl_size(mp)))\n\t\treturn __this_address;\n\n\tif (be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]) < 1 ||\n\t    be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]) < 1 ||\n\t    be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]) > XFS_BTREE_MAXLEVELS ||\n\t    be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]) > XFS_BTREE_MAXLEVELS)\n\t\treturn __this_address;\n\n\tif (xfs_sb_version_hasrmapbt(&mp->m_sb) &&\n\t    (be32_to_cpu(agf->agf_levels[XFS_BTNUM_RMAP]) < 1 ||\n\t     be32_to_cpu(agf->agf_levels[XFS_BTNUM_RMAP]) > XFS_BTREE_MAXLEVELS))\n\t\treturn __this_address;\n\n\t/*\n\t * during growfs operations, the perag is not fully initialised,\n\t * so we can't use it for any useful checking. growfs ensures we can't\n\t * use it by using uncached buffers that don't have the perag attached\n\t * so we can detect and avoid this problem.\n\t */\n\tif (bp->b_pag && be32_to_cpu(agf->agf_seqno) != bp->b_pag->pag_agno)\n\t\treturn __this_address;\n\n\tif (xfs_sb_version_haslazysbcount(&mp->m_sb) &&\n\t    be32_to_cpu(agf->agf_btreeblks) > be32_to_cpu(agf->agf_length))\n\t\treturn __this_address;\n\n\tif (xfs_sb_version_hasreflink(&mp->m_sb) &&\n\t    (be32_to_cpu(agf->agf_refcount_level) < 1 ||\n\t     be32_to_cpu(agf->agf_refcount_level) > XFS_BTREE_MAXLEVELS))\n\t\treturn __this_address;\n\n\treturn NULL;\n\n}",
        "func": "static xfs_failaddr_t\nxfs_agf_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_mount;\n\tstruct xfs_agf\t\t*agf = XFS_BUF_TO_AGF(bp);\n\n\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\tif (!uuid_equal(&agf->agf_uuid, &mp->m_sb.sb_meta_uuid))\n\t\t\treturn __this_address;\n\t\tif (!xfs_log_check_lsn(mp,\n\t\t\t\tbe64_to_cpu(XFS_BUF_TO_AGF(bp)->agf_lsn)))\n\t\t\treturn __this_address;\n\t}\n\n\tif (!xfs_verify_magic(bp, agf->agf_magicnum))\n\t\treturn __this_address;\n\n\tif (!(XFS_AGF_GOOD_VERSION(be32_to_cpu(agf->agf_versionnum)) &&\n\t      be32_to_cpu(agf->agf_freeblks) <= be32_to_cpu(agf->agf_length) &&\n\t      be32_to_cpu(agf->agf_flfirst) < xfs_agfl_size(mp) &&\n\t      be32_to_cpu(agf->agf_fllast) < xfs_agfl_size(mp) &&\n\t      be32_to_cpu(agf->agf_flcount) <= xfs_agfl_size(mp)))\n\t\treturn __this_address;\n\n\tif (be32_to_cpu(agf->agf_length) > mp->m_sb.sb_dblocks)\n\t\treturn __this_address;\n\n\tif (be32_to_cpu(agf->agf_freeblks) < be32_to_cpu(agf->agf_longest) ||\n\t    be32_to_cpu(agf->agf_freeblks) > be32_to_cpu(agf->agf_length))\n\t\treturn __this_address;\n\n\tif (be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]) < 1 ||\n\t    be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]) < 1 ||\n\t    be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]) > XFS_BTREE_MAXLEVELS ||\n\t    be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]) > XFS_BTREE_MAXLEVELS)\n\t\treturn __this_address;\n\n\tif (xfs_sb_version_hasrmapbt(&mp->m_sb) &&\n\t    (be32_to_cpu(agf->agf_levels[XFS_BTNUM_RMAP]) < 1 ||\n\t     be32_to_cpu(agf->agf_levels[XFS_BTNUM_RMAP]) > XFS_BTREE_MAXLEVELS))\n\t\treturn __this_address;\n\n\tif (xfs_sb_version_hasrmapbt(&mp->m_sb) &&\n\t    be32_to_cpu(agf->agf_rmap_blocks) > be32_to_cpu(agf->agf_length))\n\t\treturn __this_address;\n\n\t/*\n\t * during growfs operations, the perag is not fully initialised,\n\t * so we can't use it for any useful checking. growfs ensures we can't\n\t * use it by using uncached buffers that don't have the perag attached\n\t * so we can detect and avoid this problem.\n\t */\n\tif (bp->b_pag && be32_to_cpu(agf->agf_seqno) != bp->b_pag->pag_agno)\n\t\treturn __this_address;\n\n\tif (xfs_sb_version_haslazysbcount(&mp->m_sb) &&\n\t    be32_to_cpu(agf->agf_btreeblks) > be32_to_cpu(agf->agf_length))\n\t\treturn __this_address;\n\n\tif (xfs_sb_version_hasreflink(&mp->m_sb) &&\n\t    be32_to_cpu(agf->agf_refcount_blocks) >\n\t    be32_to_cpu(agf->agf_length))\n\t\treturn __this_address;\n\n\tif (xfs_sb_version_hasreflink(&mp->m_sb) &&\n\t    (be32_to_cpu(agf->agf_refcount_level) < 1 ||\n\t     be32_to_cpu(agf->agf_refcount_level) > XFS_BTREE_MAXLEVELS))\n\t\treturn __this_address;\n\n\treturn NULL;\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,6 +23,13 @@\n \t      be32_to_cpu(agf->agf_flcount) <= xfs_agfl_size(mp)))\n \t\treturn __this_address;\n \n+\tif (be32_to_cpu(agf->agf_length) > mp->m_sb.sb_dblocks)\n+\t\treturn __this_address;\n+\n+\tif (be32_to_cpu(agf->agf_freeblks) < be32_to_cpu(agf->agf_longest) ||\n+\t    be32_to_cpu(agf->agf_freeblks) > be32_to_cpu(agf->agf_length))\n+\t\treturn __this_address;\n+\n \tif (be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]) < 1 ||\n \t    be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]) < 1 ||\n \t    be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]) > XFS_BTREE_MAXLEVELS ||\n@@ -32,6 +39,10 @@\n \tif (xfs_sb_version_hasrmapbt(&mp->m_sb) &&\n \t    (be32_to_cpu(agf->agf_levels[XFS_BTNUM_RMAP]) < 1 ||\n \t     be32_to_cpu(agf->agf_levels[XFS_BTNUM_RMAP]) > XFS_BTREE_MAXLEVELS))\n+\t\treturn __this_address;\n+\n+\tif (xfs_sb_version_hasrmapbt(&mp->m_sb) &&\n+\t    be32_to_cpu(agf->agf_rmap_blocks) > be32_to_cpu(agf->agf_length))\n \t\treturn __this_address;\n \n \t/*\n@@ -48,6 +59,11 @@\n \t\treturn __this_address;\n \n \tif (xfs_sb_version_hasreflink(&mp->m_sb) &&\n+\t    be32_to_cpu(agf->agf_refcount_blocks) >\n+\t    be32_to_cpu(agf->agf_length))\n+\t\treturn __this_address;\n+\n+\tif (xfs_sb_version_hasreflink(&mp->m_sb) &&\n \t    (be32_to_cpu(agf->agf_refcount_level) < 1 ||\n \t     be32_to_cpu(agf->agf_refcount_level) > XFS_BTREE_MAXLEVELS))\n \t\treturn __this_address;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (be32_to_cpu(agf->agf_length) > mp->m_sb.sb_dblocks)",
                "\t\treturn __this_address;",
                "",
                "\tif (be32_to_cpu(agf->agf_freeblks) < be32_to_cpu(agf->agf_longest) ||",
                "\t    be32_to_cpu(agf->agf_freeblks) > be32_to_cpu(agf->agf_length))",
                "\t\treturn __this_address;",
                "",
                "\t\treturn __this_address;",
                "",
                "\tif (xfs_sb_version_hasrmapbt(&mp->m_sb) &&",
                "\t    be32_to_cpu(agf->agf_rmap_blocks) > be32_to_cpu(agf->agf_length))",
                "\t    be32_to_cpu(agf->agf_refcount_blocks) >",
                "\t    be32_to_cpu(agf->agf_length))",
                "\t\treturn __this_address;",
                "",
                "\tif (xfs_sb_version_hasreflink(&mp->m_sb) &&"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-14398",
        "func_name": "LibVNC/libvncserver/ReadFromRFBServer",
        "description": "An issue was discovered in LibVNCServer before 0.9.13. An improperly closed TCP connection causes an infinite loop in libvncclient/sockets.c.",
        "git_url": "https://github.com/LibVNC/libvncserver/commit/57433015f856cc12753378254ce4f1c78f5d9c7b",
        "commit_title": "libvncclient: handle half-open TCP connections",
        "commit_text": " When a connection is not reset properly at the TCP level (e.g. sudden power loss or process crash) the TCP connection becomes half-open and read() always returns -1 with errno = EAGAIN while select() always returns 0. This leads to an infinite loop and can be fixed by closing the connection after a certain number of retries (based on a timeout) has been exceeded.",
        "func_before": "rfbBool\nReadFromRFBServer(rfbClient* client, char *out, unsigned int n)\n{\n#undef DEBUG_READ_EXACT\n#ifdef DEBUG_READ_EXACT\n\tchar* oout=out;\n\tunsigned int nn=n;\n\trfbClientLog(\"ReadFromRFBServer %d bytes\\n\",n);\n#endif\n\n  /* Handle attempts to write to NULL out buffer that might occur\n     when an outside malloc() fails. For instance, memcpy() to NULL\n     results in undefined behaviour and probably memory corruption.*/\n  if(!out)\n    return FALSE;\n\n  if (client->serverPort==-1) {\n    /* vncrec playing */\n    rfbVNCRec* rec = client->vncRec;\n    struct timeval tv;\n\n    if (rec->readTimestamp) {\n      rec->readTimestamp = FALSE;\n      if (!fread(&tv,sizeof(struct timeval),1,rec->file))\n        return FALSE;\n\n      tv.tv_sec = rfbClientSwap32IfLE (tv.tv_sec);\n      tv.tv_usec = rfbClientSwap32IfLE (tv.tv_usec);\n\n      if (rec->tv.tv_sec!=0 && !rec->doNotSleep) {\n        struct timeval diff;\n        diff.tv_sec = tv.tv_sec - rec->tv.tv_sec;\n        diff.tv_usec = tv.tv_usec - rec->tv.tv_usec;\n        if(diff.tv_usec<0) {\n\t  diff.tv_sec--;\n\t  diff.tv_usec+=1000000;\n        }\n#ifndef WIN32\n        sleep (diff.tv_sec);\n        usleep (diff.tv_usec);\n#else\n\tSleep (diff.tv_sec * 1000 + diff.tv_usec/1000);\n#endif\n      }\n\n      rec->tv=tv;\n    }\n    \n    return (fread(out,1,n,rec->file) != n ? FALSE : TRUE);\n  }\n  \n  if (n <= client->buffered) {\n    memcpy(out, client->bufoutptr, n);\n    client->bufoutptr += n;\n    client->buffered -= n;\n#ifdef DEBUG_READ_EXACT\n    goto hexdump;\n#endif\n    return TRUE;\n  }\n\n  memcpy(out, client->bufoutptr, client->buffered);\n\n  out += client->buffered;\n  n -= client->buffered;\n\n  client->bufoutptr = client->buf;\n  client->buffered = 0;\n\n  if (n <= RFB_BUF_SIZE) {\n\n    while (client->buffered < n) {\n      int i;\n      if (client->tlsSession)\n        i = ReadFromTLS(client, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n      else\n#ifdef LIBVNCSERVER_HAVE_SASL\n      if (client->saslconn)\n        i = ReadFromSASL(client, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n      else {\n#endif /* LIBVNCSERVER_HAVE_SASL */\n        i = read(client->sock, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n#ifdef WIN32\n\tif (i < 0) errno=WSAGetLastError();\n#endif\n#ifdef LIBVNCSERVER_HAVE_SASL\n      }\n#endif\n  \n      if (i <= 0) {\n\tif (i < 0) {\n\t  if (errno == EWOULDBLOCK || errno == EAGAIN) {\n\t    /* TODO:\n\t       ProcessXtEvents();\n\t    */\n\t    WaitForMessage(client, 100000);\n\t    i = 0;\n\t  } else {\n\t    rfbClientErr(\"read (%d: %s)\\n\",errno,strerror(errno));\n\t    return FALSE;\n\t  }\n\t} else {\n\t  if (errorMessageOnReadFailure) {\n\t    rfbClientLog(\"VNC server closed connection\\n\");\n\t  }\n\t  return FALSE;\n\t}\n      }\n      client->buffered += i;\n    }\n\n    memcpy(out, client->bufoutptr, n);\n    client->bufoutptr += n;\n    client->buffered -= n;\n\n  } else {\n\n    while (n > 0) {\n      int i;\n      if (client->tlsSession)\n        i = ReadFromTLS(client, out, n);\n      else\n#ifdef LIBVNCSERVER_HAVE_SASL\n      if (client->saslconn)\n        i = ReadFromSASL(client, out, n);\n      else\n#endif\n        i = read(client->sock, out, n);\n\n      if (i <= 0) {\n\tif (i < 0) {\n#ifdef WIN32\n\t  errno=WSAGetLastError();\n#endif\n\t  if (errno == EWOULDBLOCK || errno == EAGAIN) {\n\t    /* TODO:\n\t       ProcessXtEvents();\n\t    */\n\t    WaitForMessage(client, 100000);\n\t    i = 0;\n\t  } else {\n\t    rfbClientErr(\"read (%s)\\n\",strerror(errno));\n\t    return FALSE;\n\t  }\n\t} else {\n\t  if (errorMessageOnReadFailure) {\n\t    rfbClientLog(\"VNC server closed connection\\n\");\n\t  }\n\t  return FALSE;\n\t}\n      }\n      out += i;\n      n -= i;\n    }\n  }\n\n#ifdef DEBUG_READ_EXACT\nhexdump:\n  { unsigned int ii;\n    for(ii=0;ii<nn;ii++)\n      fprintf(stderr,\"%02x \",(unsigned char)oout[ii]);\n    fprintf(stderr,\"\\n\");\n  }\n#endif\n\n  return TRUE;\n}",
        "func": "rfbBool\nReadFromRFBServer(rfbClient* client, char *out, unsigned int n)\n{\n  const int USECS_WAIT_PER_RETRY = 100000;\n  int retries = 0;\n#undef DEBUG_READ_EXACT\n#ifdef DEBUG_READ_EXACT\n\tchar* oout=out;\n\tunsigned int nn=n;\n\trfbClientLog(\"ReadFromRFBServer %d bytes\\n\",n);\n#endif\n\n  /* Handle attempts to write to NULL out buffer that might occur\n     when an outside malloc() fails. For instance, memcpy() to NULL\n     results in undefined behaviour and probably memory corruption.*/\n  if(!out)\n    return FALSE;\n\n  if (client->serverPort==-1) {\n    /* vncrec playing */\n    rfbVNCRec* rec = client->vncRec;\n    struct timeval tv;\n\n    if (rec->readTimestamp) {\n      rec->readTimestamp = FALSE;\n      if (!fread(&tv,sizeof(struct timeval),1,rec->file))\n        return FALSE;\n\n      tv.tv_sec = rfbClientSwap32IfLE (tv.tv_sec);\n      tv.tv_usec = rfbClientSwap32IfLE (tv.tv_usec);\n\n      if (rec->tv.tv_sec!=0 && !rec->doNotSleep) {\n        struct timeval diff;\n        diff.tv_sec = tv.tv_sec - rec->tv.tv_sec;\n        diff.tv_usec = tv.tv_usec - rec->tv.tv_usec;\n        if(diff.tv_usec<0) {\n\t  diff.tv_sec--;\n\t  diff.tv_usec+=1000000;\n        }\n#ifndef WIN32\n        sleep (diff.tv_sec);\n        usleep (diff.tv_usec);\n#else\n\tSleep (diff.tv_sec * 1000 + diff.tv_usec/1000);\n#endif\n      }\n\n      rec->tv=tv;\n    }\n    \n    return (fread(out,1,n,rec->file) != n ? FALSE : TRUE);\n  }\n  \n  if (n <= client->buffered) {\n    memcpy(out, client->bufoutptr, n);\n    client->bufoutptr += n;\n    client->buffered -= n;\n#ifdef DEBUG_READ_EXACT\n    goto hexdump;\n#endif\n    return TRUE;\n  }\n\n  memcpy(out, client->bufoutptr, client->buffered);\n\n  out += client->buffered;\n  n -= client->buffered;\n\n  client->bufoutptr = client->buf;\n  client->buffered = 0;\n\n  if (n <= RFB_BUF_SIZE) {\n\n    while (client->buffered < n) {\n      int i;\n      if (client->tlsSession)\n        i = ReadFromTLS(client, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n      else\n#ifdef LIBVNCSERVER_HAVE_SASL\n      if (client->saslconn)\n        i = ReadFromSASL(client, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n      else {\n#endif /* LIBVNCSERVER_HAVE_SASL */\n        i = read(client->sock, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n#ifdef WIN32\n\tif (i < 0) errno=WSAGetLastError();\n#endif\n#ifdef LIBVNCSERVER_HAVE_SASL\n      }\n#endif\n  \n      if (i <= 0) {\n\tif (i < 0) {\n\t  if (errno == EWOULDBLOCK || errno == EAGAIN) {\n\t    if (client->readTimeout > 0 &&\n\t\t++retries > (client->readTimeout * 1000 * 1000 / USECS_WAIT_PER_RETRY))\n\t    {\n\t      rfbClientLog(\"Connection timed out\\n\");\n\t      return FALSE;\n\t    }\n\t    /* TODO:\n\t       ProcessXtEvents();\n\t    */\n\t    WaitForMessage(client, USECS_WAIT_PER_RETRY);\n\t    i = 0;\n\t  } else {\n\t    rfbClientErr(\"read (%d: %s)\\n\",errno,strerror(errno));\n\t    return FALSE;\n\t  }\n\t} else {\n\t  if (errorMessageOnReadFailure) {\n\t    rfbClientLog(\"VNC server closed connection\\n\");\n\t  }\n\t  return FALSE;\n\t}\n      }\n      client->buffered += i;\n    }\n\n    memcpy(out, client->bufoutptr, n);\n    client->bufoutptr += n;\n    client->buffered -= n;\n\n  } else {\n\n    while (n > 0) {\n      int i;\n      if (client->tlsSession)\n        i = ReadFromTLS(client, out, n);\n      else\n#ifdef LIBVNCSERVER_HAVE_SASL\n      if (client->saslconn)\n        i = ReadFromSASL(client, out, n);\n      else\n#endif\n        i = read(client->sock, out, n);\n\n      if (i <= 0) {\n\tif (i < 0) {\n#ifdef WIN32\n\t  errno=WSAGetLastError();\n#endif\n\t  if (errno == EWOULDBLOCK || errno == EAGAIN) {\n\t    if (client->readTimeout > 0 &&\n\t\t++retries > (client->readTimeout * 1000 * 1000 / USECS_WAIT_PER_RETRY))\n\t    {\n\t\trfbClientLog(\"Connection timed out\\n\");\n\t\treturn FALSE;\n\t    }\n\t    /* TODO:\n\t       ProcessXtEvents();\n\t    */\n\t    WaitForMessage(client, USECS_WAIT_PER_RETRY);\n\t    i = 0;\n\t  } else {\n\t    rfbClientErr(\"read (%s)\\n\",strerror(errno));\n\t    return FALSE;\n\t  }\n\t} else {\n\t  if (errorMessageOnReadFailure) {\n\t    rfbClientLog(\"VNC server closed connection\\n\");\n\t  }\n\t  return FALSE;\n\t}\n      }\n      out += i;\n      n -= i;\n    }\n  }\n\n#ifdef DEBUG_READ_EXACT\nhexdump:\n  { unsigned int ii;\n    for(ii=0;ii<nn;ii++)\n      fprintf(stderr,\"%02x \",(unsigned char)oout[ii]);\n    fprintf(stderr,\"\\n\");\n  }\n#endif\n\n  return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,8 @@\n rfbBool\n ReadFromRFBServer(rfbClient* client, char *out, unsigned int n)\n {\n+  const int USECS_WAIT_PER_RETRY = 100000;\n+  int retries = 0;\n #undef DEBUG_READ_EXACT\n #ifdef DEBUG_READ_EXACT\n \tchar* oout=out;\n@@ -90,10 +92,16 @@\n       if (i <= 0) {\n \tif (i < 0) {\n \t  if (errno == EWOULDBLOCK || errno == EAGAIN) {\n+\t    if (client->readTimeout > 0 &&\n+\t\t++retries > (client->readTimeout * 1000 * 1000 / USECS_WAIT_PER_RETRY))\n+\t    {\n+\t      rfbClientLog(\"Connection timed out\\n\");\n+\t      return FALSE;\n+\t    }\n \t    /* TODO:\n \t       ProcessXtEvents();\n \t    */\n-\t    WaitForMessage(client, 100000);\n+\t    WaitForMessage(client, USECS_WAIT_PER_RETRY);\n \t    i = 0;\n \t  } else {\n \t    rfbClientErr(\"read (%d: %s)\\n\",errno,strerror(errno));\n@@ -133,10 +141,16 @@\n \t  errno=WSAGetLastError();\n #endif\n \t  if (errno == EWOULDBLOCK || errno == EAGAIN) {\n+\t    if (client->readTimeout > 0 &&\n+\t\t++retries > (client->readTimeout * 1000 * 1000 / USECS_WAIT_PER_RETRY))\n+\t    {\n+\t\trfbClientLog(\"Connection timed out\\n\");\n+\t\treturn FALSE;\n+\t    }\n \t    /* TODO:\n \t       ProcessXtEvents();\n \t    */\n-\t    WaitForMessage(client, 100000);\n+\t    WaitForMessage(client, USECS_WAIT_PER_RETRY);\n \t    i = 0;\n \t  } else {\n \t    rfbClientErr(\"read (%s)\\n\",strerror(errno));",
        "diff_line_info": {
            "deleted_lines": [
                "\t    WaitForMessage(client, 100000);",
                "\t    WaitForMessage(client, 100000);"
            ],
            "added_lines": [
                "  const int USECS_WAIT_PER_RETRY = 100000;",
                "  int retries = 0;",
                "\t    if (client->readTimeout > 0 &&",
                "\t\t++retries > (client->readTimeout * 1000 * 1000 / USECS_WAIT_PER_RETRY))",
                "\t    {",
                "\t      rfbClientLog(\"Connection timed out\\n\");",
                "\t      return FALSE;",
                "\t    }",
                "\t    WaitForMessage(client, USECS_WAIT_PER_RETRY);",
                "\t    if (client->readTimeout > 0 &&",
                "\t\t++retries > (client->readTimeout * 1000 * 1000 / USECS_WAIT_PER_RETRY))",
                "\t    {",
                "\t\trfbClientLog(\"Connection timed out\\n\");",
                "\t\treturn FALSE;",
                "\t    }",
                "\t    WaitForMessage(client, USECS_WAIT_PER_RETRY);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-14398",
        "func_name": "LibVNC/libvncserver/rfbGetClient",
        "description": "An issue was discovered in LibVNCServer before 0.9.13. An improperly closed TCP connection causes an infinite loop in libvncclient/sockets.c.",
        "git_url": "https://github.com/LibVNC/libvncserver/commit/57433015f856cc12753378254ce4f1c78f5d9c7b",
        "commit_title": "libvncclient: handle half-open TCP connections",
        "commit_text": " When a connection is not reset properly at the TCP level (e.g. sudden power loss or process crash) the TCP connection becomes half-open and read() always returns -1 with errno = EAGAIN while select() always returns 0. This leads to an infinite loop and can be fixed by closing the connection after a certain number of retries (based on a timeout) has been exceeded.",
        "func_before": "rfbClient* rfbGetClient(int bitsPerSample,int samplesPerPixel,\n\t\t\tint bytesPerPixel) {\n#ifdef WIN32\n    WSADATA unused;\n#endif\n  rfbClient* client=(rfbClient*)calloc(sizeof(rfbClient),1);\n  if(!client) {\n    rfbClientErr(\"Couldn't allocate client structure!\\n\");\n    return NULL;\n  }\n#ifdef WIN32\n  if((errno = WSAStartup(MAKEWORD(2,0), &unused)) != 0) {\n      rfbClientErr(\"Could not init Windows Sockets: %s\\n\", strerror(errno));\n      return NULL;\n  }\n#endif\n  initAppData(&client->appData);\n  client->endianTest = 1;\n  client->programName=\"\";\n  client->serverHost=strdup(\"\");\n  client->serverPort=5900;\n\n  client->destHost = NULL;\n  client->destPort = 5900;\n  \n  client->connectTimeout = DEFAULT_CONNECT_TIMEOUT;\n\n  client->CurrentKeyboardLedState = 0;\n  client->HandleKeyboardLedState = (HandleKeyboardLedStateProc)DummyPoint;\n\n  /* default: use complete frame buffer */ \n  client->updateRect.x = -1;\n \n  client->frameBuffer = NULL;\n  client->outputWindow = 0;\n \n  client->format.bitsPerPixel = bytesPerPixel*8;\n  client->format.depth = bitsPerSample*samplesPerPixel;\n  client->appData.requestedDepth=client->format.depth;\n  client->format.bigEndian = *(char *)&client->endianTest?FALSE:TRUE;\n  client->format.trueColour = 1;\n\n  if (client->format.bitsPerPixel == 8) {\n    client->format.redMax = 7;\n    client->format.greenMax = 7;\n    client->format.blueMax = 3;\n    client->format.redShift = 0;\n    client->format.greenShift = 3;\n    client->format.blueShift = 6;\n  } else {\n    client->format.redMax = (1 << bitsPerSample) - 1;\n    client->format.greenMax = (1 << bitsPerSample) - 1;\n    client->format.blueMax = (1 << bitsPerSample) - 1;\n    if(!client->format.bigEndian) {\n      client->format.redShift = 0;\n      client->format.greenShift = bitsPerSample;\n      client->format.blueShift = bitsPerSample * 2;\n    } else {\n      if(client->format.bitsPerPixel==8*3) {\n\tclient->format.redShift = bitsPerSample*2;\n\tclient->format.greenShift = bitsPerSample*1;\n\tclient->format.blueShift = 0;\n      } else {\n\tclient->format.redShift = bitsPerSample*3;\n\tclient->format.greenShift = bitsPerSample*2;\n\tclient->format.blueShift = bitsPerSample;\n      }\n    }\n  }\n\n  client->bufoutptr=client->buf;\n  client->buffered=0;\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n  client->raw_buffer_size = -1;\n  client->decompStreamInited = FALSE;\n\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n  memset(client->zlibStreamActive,0,sizeof(rfbBool)*4);\n#endif\n#endif\n\n  client->HandleCursorPos = DummyPoint;\n  client->SoftCursorLockArea = DummyRect;\n  client->SoftCursorUnlockScreen = Dummy;\n  client->GotFrameBufferUpdate = DummyRect;\n  client->GotCopyRect = CopyRectangleFromRectangle;\n  client->GotFillRect = FillRectangle;\n  client->GotBitmap = CopyRectangle;\n  client->FinishedFrameBufferUpdate = NULL;\n  client->GetPassword = ReadPassword;\n  client->MallocFrameBuffer = MallocFrameBuffer;\n  client->Bell = Dummy;\n  client->CurrentKeyboardLedState = 0;\n  client->HandleKeyboardLedState = (HandleKeyboardLedStateProc)DummyPoint;\n  client->QoS_DSCP = 0;\n\n  client->authScheme = 0;\n  client->subAuthScheme = 0;\n  client->GetCredential = NULL;\n  client->tlsSession = NULL;\n  client->LockWriteToTLS = NULL;\n  client->UnlockWriteToTLS = NULL;\n  client->sock = RFB_INVALID_SOCKET;\n  client->listenSock = RFB_INVALID_SOCKET;\n  client->listenAddress = NULL;\n  client->listen6Sock = RFB_INVALID_SOCKET;\n  client->listen6Address = NULL;\n  client->clientAuthSchemes = NULL;\n\n#ifdef LIBVNCSERVER_HAVE_SASL\n  client->GetSASLMechanism = NULL;\n  client->GetUser = NULL;\n  client->saslSecret = NULL;\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n  return client;\n}",
        "func": "rfbClient* rfbGetClient(int bitsPerSample,int samplesPerPixel,\n\t\t\tint bytesPerPixel) {\n#ifdef WIN32\n    WSADATA unused;\n#endif\n  rfbClient* client=(rfbClient*)calloc(sizeof(rfbClient),1);\n  if(!client) {\n    rfbClientErr(\"Couldn't allocate client structure!\\n\");\n    return NULL;\n  }\n#ifdef WIN32\n  if((errno = WSAStartup(MAKEWORD(2,0), &unused)) != 0) {\n      rfbClientErr(\"Could not init Windows Sockets: %s\\n\", strerror(errno));\n      return NULL;\n  }\n#endif\n  initAppData(&client->appData);\n  client->endianTest = 1;\n  client->programName=\"\";\n  client->serverHost=strdup(\"\");\n  client->serverPort=5900;\n\n  client->destHost = NULL;\n  client->destPort = 5900;\n  \n  client->connectTimeout = DEFAULT_CONNECT_TIMEOUT;\n  client->readTimeout = DEFAULT_READ_TIMEOUT;\n\n  client->CurrentKeyboardLedState = 0;\n  client->HandleKeyboardLedState = (HandleKeyboardLedStateProc)DummyPoint;\n\n  /* default: use complete frame buffer */ \n  client->updateRect.x = -1;\n \n  client->frameBuffer = NULL;\n  client->outputWindow = 0;\n \n  client->format.bitsPerPixel = bytesPerPixel*8;\n  client->format.depth = bitsPerSample*samplesPerPixel;\n  client->appData.requestedDepth=client->format.depth;\n  client->format.bigEndian = *(char *)&client->endianTest?FALSE:TRUE;\n  client->format.trueColour = 1;\n\n  if (client->format.bitsPerPixel == 8) {\n    client->format.redMax = 7;\n    client->format.greenMax = 7;\n    client->format.blueMax = 3;\n    client->format.redShift = 0;\n    client->format.greenShift = 3;\n    client->format.blueShift = 6;\n  } else {\n    client->format.redMax = (1 << bitsPerSample) - 1;\n    client->format.greenMax = (1 << bitsPerSample) - 1;\n    client->format.blueMax = (1 << bitsPerSample) - 1;\n    if(!client->format.bigEndian) {\n      client->format.redShift = 0;\n      client->format.greenShift = bitsPerSample;\n      client->format.blueShift = bitsPerSample * 2;\n    } else {\n      if(client->format.bitsPerPixel==8*3) {\n\tclient->format.redShift = bitsPerSample*2;\n\tclient->format.greenShift = bitsPerSample*1;\n\tclient->format.blueShift = 0;\n      } else {\n\tclient->format.redShift = bitsPerSample*3;\n\tclient->format.greenShift = bitsPerSample*2;\n\tclient->format.blueShift = bitsPerSample;\n      }\n    }\n  }\n\n  client->bufoutptr=client->buf;\n  client->buffered=0;\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n  client->raw_buffer_size = -1;\n  client->decompStreamInited = FALSE;\n\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n  memset(client->zlibStreamActive,0,sizeof(rfbBool)*4);\n#endif\n#endif\n\n  client->HandleCursorPos = DummyPoint;\n  client->SoftCursorLockArea = DummyRect;\n  client->SoftCursorUnlockScreen = Dummy;\n  client->GotFrameBufferUpdate = DummyRect;\n  client->GotCopyRect = CopyRectangleFromRectangle;\n  client->GotFillRect = FillRectangle;\n  client->GotBitmap = CopyRectangle;\n  client->FinishedFrameBufferUpdate = NULL;\n  client->GetPassword = ReadPassword;\n  client->MallocFrameBuffer = MallocFrameBuffer;\n  client->Bell = Dummy;\n  client->CurrentKeyboardLedState = 0;\n  client->HandleKeyboardLedState = (HandleKeyboardLedStateProc)DummyPoint;\n  client->QoS_DSCP = 0;\n\n  client->authScheme = 0;\n  client->subAuthScheme = 0;\n  client->GetCredential = NULL;\n  client->tlsSession = NULL;\n  client->LockWriteToTLS = NULL;\n  client->UnlockWriteToTLS = NULL;\n  client->sock = RFB_INVALID_SOCKET;\n  client->listenSock = RFB_INVALID_SOCKET;\n  client->listenAddress = NULL;\n  client->listen6Sock = RFB_INVALID_SOCKET;\n  client->listen6Address = NULL;\n  client->clientAuthSchemes = NULL;\n\n#ifdef LIBVNCSERVER_HAVE_SASL\n  client->GetSASLMechanism = NULL;\n  client->GetUser = NULL;\n  client->saslSecret = NULL;\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n  return client;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,6 +24,7 @@\n   client->destPort = 5900;\n   \n   client->connectTimeout = DEFAULT_CONNECT_TIMEOUT;\n+  client->readTimeout = DEFAULT_READ_TIMEOUT;\n \n   client->CurrentKeyboardLedState = 0;\n   client->HandleKeyboardLedState = (HandleKeyboardLedStateProc)DummyPoint;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  client->readTimeout = DEFAULT_READ_TIMEOUT;"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-4621",
        "func_name": "torvalds/linux/dup_task_struct",
        "description": "The Linux kernel before 2.6.37 does not properly implement a certain clock-update optimization, which allows local users to cause a denial of service (system hang) via an application that executes code in a loop.",
        "git_url": "https://github.com/torvalds/linux/commit/f26f9aff6aaf67e9a430d16c266f91b13a5bff64",
        "commit_title": "Sched: fix skip_clock_update optimization",
        "commit_text": " idle_balance() drops/retakes rq->lock, leaving the previous task vulnerable to set_tsk_need_resched().  Clear it after we return from balancing instead, and in setup_thread_stack() as well, so no successfully descheduled or never scheduled task has it set.  Need resched confused the skip_clock_update logic, which assumes that the next call to update_rq_clock() will come nearly immediately after being set.  Make the optimization robust against the waking a sleeper before it sucessfully deschedules case by checking that the current task has not been dequeued before setting the flag, since it is that useless clock update we're trying to save, and clear unconditionally in schedule() proper instead of conditionally in put_prev_task().  Cc: stable@kernel.org LKML-Reference: <1291802742.1417.9.camel@marge.simson.net>",
        "func_before": "static struct task_struct *dup_task_struct(struct task_struct *orig)\n{\n\tstruct task_struct *tsk;\n\tstruct thread_info *ti;\n\tunsigned long *stackend;\n\n\tint err;\n\n\tprepare_to_copy(orig);\n\n\ttsk = alloc_task_struct();\n\tif (!tsk)\n\t\treturn NULL;\n\n\tti = alloc_thread_info(tsk);\n\tif (!ti) {\n\t\tfree_task_struct(tsk);\n\t\treturn NULL;\n\t}\n\n \terr = arch_dup_task_struct(tsk, orig);\n\tif (err)\n\t\tgoto out;\n\n\ttsk->stack = ti;\n\n\terr = prop_local_init_single(&tsk->dirties);\n\tif (err)\n\t\tgoto out;\n\n\tsetup_thread_stack(tsk, orig);\n\tclear_user_return_notifier(tsk);\n\tstackend = end_of_stack(tsk);\n\t*stackend = STACK_END_MAGIC;\t/* for overflow detection */\n\n#ifdef CONFIG_CC_STACKPROTECTOR\n\ttsk->stack_canary = get_random_int();\n#endif\n\n\t/* One for us, one for whoever does the \"release_task()\" (usually parent) */\n\tatomic_set(&tsk->usage,2);\n\tatomic_set(&tsk->fs_excl, 0);\n#ifdef CONFIG_BLK_DEV_IO_TRACE\n\ttsk->btrace_seq = 0;\n#endif\n\ttsk->splice_pipe = NULL;\n\n\taccount_kernel_stack(ti, 1);\n\n\treturn tsk;\n\nout:\n\tfree_thread_info(ti);\n\tfree_task_struct(tsk);\n\treturn NULL;\n}",
        "func": "static struct task_struct *dup_task_struct(struct task_struct *orig)\n{\n\tstruct task_struct *tsk;\n\tstruct thread_info *ti;\n\tunsigned long *stackend;\n\n\tint err;\n\n\tprepare_to_copy(orig);\n\n\ttsk = alloc_task_struct();\n\tif (!tsk)\n\t\treturn NULL;\n\n\tti = alloc_thread_info(tsk);\n\tif (!ti) {\n\t\tfree_task_struct(tsk);\n\t\treturn NULL;\n\t}\n\n \terr = arch_dup_task_struct(tsk, orig);\n\tif (err)\n\t\tgoto out;\n\n\ttsk->stack = ti;\n\n\terr = prop_local_init_single(&tsk->dirties);\n\tif (err)\n\t\tgoto out;\n\n\tsetup_thread_stack(tsk, orig);\n\tclear_user_return_notifier(tsk);\n\tclear_tsk_need_resched(tsk);\n\tstackend = end_of_stack(tsk);\n\t*stackend = STACK_END_MAGIC;\t/* for overflow detection */\n\n#ifdef CONFIG_CC_STACKPROTECTOR\n\ttsk->stack_canary = get_random_int();\n#endif\n\n\t/* One for us, one for whoever does the \"release_task()\" (usually parent) */\n\tatomic_set(&tsk->usage,2);\n\tatomic_set(&tsk->fs_excl, 0);\n#ifdef CONFIG_BLK_DEV_IO_TRACE\n\ttsk->btrace_seq = 0;\n#endif\n\ttsk->splice_pipe = NULL;\n\n\taccount_kernel_stack(ti, 1);\n\n\treturn tsk;\n\nout:\n\tfree_thread_info(ti);\n\tfree_task_struct(tsk);\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,6 +30,7 @@\n \n \tsetup_thread_stack(tsk, orig);\n \tclear_user_return_notifier(tsk);\n+\tclear_tsk_need_resched(tsk);\n \tstackend = end_of_stack(tsk);\n \t*stackend = STACK_END_MAGIC;\t/* for overflow detection */\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tclear_tsk_need_resched(tsk);"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-4621",
        "func_name": "torvalds/linux/update_rq_clock",
        "description": "The Linux kernel before 2.6.37 does not properly implement a certain clock-update optimization, which allows local users to cause a denial of service (system hang) via an application that executes code in a loop.",
        "git_url": "https://github.com/torvalds/linux/commit/f26f9aff6aaf67e9a430d16c266f91b13a5bff64",
        "commit_title": "Sched: fix skip_clock_update optimization",
        "commit_text": " idle_balance() drops/retakes rq->lock, leaving the previous task vulnerable to set_tsk_need_resched().  Clear it after we return from balancing instead, and in setup_thread_stack() as well, so no successfully descheduled or never scheduled task has it set.  Need resched confused the skip_clock_update logic, which assumes that the next call to update_rq_clock() will come nearly immediately after being set.  Make the optimization robust against the waking a sleeper before it sucessfully deschedules case by checking that the current task has not been dequeued before setting the flag, since it is that useless clock update we're trying to save, and clear unconditionally in schedule() proper instead of conditionally in put_prev_task().  Cc: stable@kernel.org LKML-Reference: <1291802742.1417.9.camel@marge.simson.net>",
        "func_before": "inline void update_rq_clock(struct rq *rq)\n{\n\tif (!rq->skip_clock_update) {\n\t\tint cpu = cpu_of(rq);\n\t\tu64 irq_time;\n\n\t\trq->clock = sched_clock_cpu(cpu);\n\t\tirq_time = irq_time_cpu(cpu);\n\t\tif (rq->clock - irq_time > rq->clock_task)\n\t\t\trq->clock_task = rq->clock - irq_time;\n\n\t\tsched_irq_time_avg_update(rq, irq_time);\n\t}\n}",
        "func": "inline void update_rq_clock(struct rq *rq)\n{\n\tint cpu = cpu_of(rq);\n\tu64 irq_time;\n\n\tif (rq->skip_clock_update)\n\t\treturn;\n\n\trq->clock = sched_clock_cpu(cpu);\n\tirq_time = irq_time_cpu(cpu);\n\tif (rq->clock - irq_time > rq->clock_task)\n\t\trq->clock_task = rq->clock - irq_time;\n\n\tsched_irq_time_avg_update(rq, irq_time);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,14 +1,15 @@\n inline void update_rq_clock(struct rq *rq)\n {\n-\tif (!rq->skip_clock_update) {\n-\t\tint cpu = cpu_of(rq);\n-\t\tu64 irq_time;\n+\tint cpu = cpu_of(rq);\n+\tu64 irq_time;\n \n-\t\trq->clock = sched_clock_cpu(cpu);\n-\t\tirq_time = irq_time_cpu(cpu);\n-\t\tif (rq->clock - irq_time > rq->clock_task)\n-\t\t\trq->clock_task = rq->clock - irq_time;\n+\tif (rq->skip_clock_update)\n+\t\treturn;\n \n-\t\tsched_irq_time_avg_update(rq, irq_time);\n-\t}\n+\trq->clock = sched_clock_cpu(cpu);\n+\tirq_time = irq_time_cpu(cpu);\n+\tif (rq->clock - irq_time > rq->clock_task)\n+\t\trq->clock_task = rq->clock - irq_time;\n+\n+\tsched_irq_time_avg_update(rq, irq_time);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!rq->skip_clock_update) {",
                "\t\tint cpu = cpu_of(rq);",
                "\t\tu64 irq_time;",
                "\t\trq->clock = sched_clock_cpu(cpu);",
                "\t\tirq_time = irq_time_cpu(cpu);",
                "\t\tif (rq->clock - irq_time > rq->clock_task)",
                "\t\t\trq->clock_task = rq->clock - irq_time;",
                "\t\tsched_irq_time_avg_update(rq, irq_time);",
                "\t}"
            ],
            "added_lines": [
                "\tint cpu = cpu_of(rq);",
                "\tu64 irq_time;",
                "\tif (rq->skip_clock_update)",
                "\t\treturn;",
                "\trq->clock = sched_clock_cpu(cpu);",
                "\tirq_time = irq_time_cpu(cpu);",
                "\tif (rq->clock - irq_time > rq->clock_task)",
                "\t\trq->clock_task = rq->clock - irq_time;",
                "",
                "\tsched_irq_time_avg_update(rq, irq_time);"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-4621",
        "func_name": "torvalds/linux/put_prev_task",
        "description": "The Linux kernel before 2.6.37 does not properly implement a certain clock-update optimization, which allows local users to cause a denial of service (system hang) via an application that executes code in a loop.",
        "git_url": "https://github.com/torvalds/linux/commit/f26f9aff6aaf67e9a430d16c266f91b13a5bff64",
        "commit_title": "Sched: fix skip_clock_update optimization",
        "commit_text": " idle_balance() drops/retakes rq->lock, leaving the previous task vulnerable to set_tsk_need_resched().  Clear it after we return from balancing instead, and in setup_thread_stack() as well, so no successfully descheduled or never scheduled task has it set.  Need resched confused the skip_clock_update logic, which assumes that the next call to update_rq_clock() will come nearly immediately after being set.  Make the optimization robust against the waking a sleeper before it sucessfully deschedules case by checking that the current task has not been dequeued before setting the flag, since it is that useless clock update we're trying to save, and clear unconditionally in schedule() proper instead of conditionally in put_prev_task().  Cc: stable@kernel.org LKML-Reference: <1291802742.1417.9.camel@marge.simson.net>",
        "func_before": "static void put_prev_task(struct rq *rq, struct task_struct *prev)\n{\n\tif (prev->se.on_rq)\n\t\tupdate_rq_clock(rq);\n\trq->skip_clock_update = 0;\n\tprev->sched_class->put_prev_task(rq, prev);\n}",
        "func": "static void put_prev_task(struct rq *rq, struct task_struct *prev)\n{\n\tif (prev->se.on_rq)\n\t\tupdate_rq_clock(rq);\n\tprev->sched_class->put_prev_task(rq, prev);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,5 @@\n {\n \tif (prev->se.on_rq)\n \t\tupdate_rq_clock(rq);\n-\trq->skip_clock_update = 0;\n \tprev->sched_class->put_prev_task(rq, prev);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\trq->skip_clock_update = 0;"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2011-4621",
        "func_name": "torvalds/linux/schedule",
        "description": "The Linux kernel before 2.6.37 does not properly implement a certain clock-update optimization, which allows local users to cause a denial of service (system hang) via an application that executes code in a loop.",
        "git_url": "https://github.com/torvalds/linux/commit/f26f9aff6aaf67e9a430d16c266f91b13a5bff64",
        "commit_title": "Sched: fix skip_clock_update optimization",
        "commit_text": " idle_balance() drops/retakes rq->lock, leaving the previous task vulnerable to set_tsk_need_resched().  Clear it after we return from balancing instead, and in setup_thread_stack() as well, so no successfully descheduled or never scheduled task has it set.  Need resched confused the skip_clock_update logic, which assumes that the next call to update_rq_clock() will come nearly immediately after being set.  Make the optimization robust against the waking a sleeper before it sucessfully deschedules case by checking that the current task has not been dequeued before setting the flag, since it is that useless clock update we're trying to save, and clear unconditionally in schedule() proper instead of conditionally in put_prev_task().  Cc: stable@kernel.org LKML-Reference: <1291802742.1417.9.camel@marge.simson.net>",
        "func_before": "asmlinkage void __sched schedule(void)\n{\n\tstruct task_struct *prev, *next;\n\tunsigned long *switch_count;\n\tstruct rq *rq;\n\tint cpu;\n\nneed_resched:\n\tpreempt_disable();\n\tcpu = smp_processor_id();\n\trq = cpu_rq(cpu);\n\trcu_note_context_switch(cpu);\n\tprev = rq->curr;\n\n\trelease_kernel_lock(prev);\nneed_resched_nonpreemptible:\n\n\tschedule_debug(prev);\n\n\tif (sched_feat(HRTICK))\n\t\thrtick_clear(rq);\n\n\traw_spin_lock_irq(&rq->lock);\n\tclear_tsk_need_resched(prev);\n\n\tswitch_count = &prev->nivcsw;\n\tif (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) {\n\t\tif (unlikely(signal_pending_state(prev->state, prev))) {\n\t\t\tprev->state = TASK_RUNNING;\n\t\t} else {\n\t\t\t/*\n\t\t\t * If a worker is going to sleep, notify and\n\t\t\t * ask workqueue whether it wants to wake up a\n\t\t\t * task to maintain concurrency.  If so, wake\n\t\t\t * up the task.\n\t\t\t */\n\t\t\tif (prev->flags & PF_WQ_WORKER) {\n\t\t\t\tstruct task_struct *to_wakeup;\n\n\t\t\t\tto_wakeup = wq_worker_sleeping(prev, cpu);\n\t\t\t\tif (to_wakeup)\n\t\t\t\t\ttry_to_wake_up_local(to_wakeup);\n\t\t\t}\n\t\t\tdeactivate_task(rq, prev, DEQUEUE_SLEEP);\n\t\t}\n\t\tswitch_count = &prev->nvcsw;\n\t}\n\n\tpre_schedule(rq, prev);\n\n\tif (unlikely(!rq->nr_running))\n\t\tidle_balance(cpu, rq);\n\n\tput_prev_task(rq, prev);\n\tnext = pick_next_task(rq);\n\n\tif (likely(prev != next)) {\n\t\tsched_info_switch(prev, next);\n\t\tperf_event_task_sched_out(prev, next);\n\n\t\trq->nr_switches++;\n\t\trq->curr = next;\n\t\t++*switch_count;\n\n\t\tcontext_switch(rq, prev, next); /* unlocks the rq */\n\t\t/*\n\t\t * The context switch have flipped the stack from under us\n\t\t * and restored the local variables which were saved when\n\t\t * this task called schedule() in the past. prev == current\n\t\t * is still correct, but it can be moved to another cpu/rq.\n\t\t */\n\t\tcpu = smp_processor_id();\n\t\trq = cpu_rq(cpu);\n\t} else\n\t\traw_spin_unlock_irq(&rq->lock);\n\n\tpost_schedule(rq);\n\n\tif (unlikely(reacquire_kernel_lock(prev)))\n\t\tgoto need_resched_nonpreemptible;\n\n\tpreempt_enable_no_resched();\n\tif (need_resched())\n\t\tgoto need_resched;\n}",
        "func": "asmlinkage void __sched schedule(void)\n{\n\tstruct task_struct *prev, *next;\n\tunsigned long *switch_count;\n\tstruct rq *rq;\n\tint cpu;\n\nneed_resched:\n\tpreempt_disable();\n\tcpu = smp_processor_id();\n\trq = cpu_rq(cpu);\n\trcu_note_context_switch(cpu);\n\tprev = rq->curr;\n\n\trelease_kernel_lock(prev);\nneed_resched_nonpreemptible:\n\n\tschedule_debug(prev);\n\n\tif (sched_feat(HRTICK))\n\t\thrtick_clear(rq);\n\n\traw_spin_lock_irq(&rq->lock);\n\n\tswitch_count = &prev->nivcsw;\n\tif (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) {\n\t\tif (unlikely(signal_pending_state(prev->state, prev))) {\n\t\t\tprev->state = TASK_RUNNING;\n\t\t} else {\n\t\t\t/*\n\t\t\t * If a worker is going to sleep, notify and\n\t\t\t * ask workqueue whether it wants to wake up a\n\t\t\t * task to maintain concurrency.  If so, wake\n\t\t\t * up the task.\n\t\t\t */\n\t\t\tif (prev->flags & PF_WQ_WORKER) {\n\t\t\t\tstruct task_struct *to_wakeup;\n\n\t\t\t\tto_wakeup = wq_worker_sleeping(prev, cpu);\n\t\t\t\tif (to_wakeup)\n\t\t\t\t\ttry_to_wake_up_local(to_wakeup);\n\t\t\t}\n\t\t\tdeactivate_task(rq, prev, DEQUEUE_SLEEP);\n\t\t}\n\t\tswitch_count = &prev->nvcsw;\n\t}\n\n\tpre_schedule(rq, prev);\n\n\tif (unlikely(!rq->nr_running))\n\t\tidle_balance(cpu, rq);\n\n\tput_prev_task(rq, prev);\n\tnext = pick_next_task(rq);\n\tclear_tsk_need_resched(prev);\n\trq->skip_clock_update = 0;\n\n\tif (likely(prev != next)) {\n\t\tsched_info_switch(prev, next);\n\t\tperf_event_task_sched_out(prev, next);\n\n\t\trq->nr_switches++;\n\t\trq->curr = next;\n\t\t++*switch_count;\n\t\tWARN_ON_ONCE(test_tsk_need_resched(next));\n\n\t\tcontext_switch(rq, prev, next); /* unlocks the rq */\n\t\t/*\n\t\t * The context switch have flipped the stack from under us\n\t\t * and restored the local variables which were saved when\n\t\t * this task called schedule() in the past. prev == current\n\t\t * is still correct, but it can be moved to another cpu/rq.\n\t\t */\n\t\tcpu = smp_processor_id();\n\t\trq = cpu_rq(cpu);\n\t} else\n\t\traw_spin_unlock_irq(&rq->lock);\n\n\tpost_schedule(rq);\n\n\tif (unlikely(reacquire_kernel_lock(prev)))\n\t\tgoto need_resched_nonpreemptible;\n\n\tpreempt_enable_no_resched();\n\tif (need_resched())\n\t\tgoto need_resched;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,7 +21,6 @@\n \t\thrtick_clear(rq);\n \n \traw_spin_lock_irq(&rq->lock);\n-\tclear_tsk_need_resched(prev);\n \n \tswitch_count = &prev->nivcsw;\n \tif (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) {\n@@ -53,6 +52,8 @@\n \n \tput_prev_task(rq, prev);\n \tnext = pick_next_task(rq);\n+\tclear_tsk_need_resched(prev);\n+\trq->skip_clock_update = 0;\n \n \tif (likely(prev != next)) {\n \t\tsched_info_switch(prev, next);\n@@ -61,6 +62,7 @@\n \t\trq->nr_switches++;\n \t\trq->curr = next;\n \t\t++*switch_count;\n+\t\tWARN_ON_ONCE(test_tsk_need_resched(next));\n \n \t\tcontext_switch(rq, prev, next); /* unlocks the rq */\n \t\t/*",
        "diff_line_info": {
            "deleted_lines": [
                "\tclear_tsk_need_resched(prev);"
            ],
            "added_lines": [
                "\tclear_tsk_need_resched(prev);",
                "\trq->skip_clock_update = 0;",
                "\t\tWARN_ON_ONCE(test_tsk_need_resched(next));"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-4621",
        "func_name": "torvalds/linux/check_preempt_curr",
        "description": "The Linux kernel before 2.6.37 does not properly implement a certain clock-update optimization, which allows local users to cause a denial of service (system hang) via an application that executes code in a loop.",
        "git_url": "https://github.com/torvalds/linux/commit/f26f9aff6aaf67e9a430d16c266f91b13a5bff64",
        "commit_title": "Sched: fix skip_clock_update optimization",
        "commit_text": " idle_balance() drops/retakes rq->lock, leaving the previous task vulnerable to set_tsk_need_resched().  Clear it after we return from balancing instead, and in setup_thread_stack() as well, so no successfully descheduled or never scheduled task has it set.  Need resched confused the skip_clock_update logic, which assumes that the next call to update_rq_clock() will come nearly immediately after being set.  Make the optimization robust against the waking a sleeper before it sucessfully deschedules case by checking that the current task has not been dequeued before setting the flag, since it is that useless clock update we're trying to save, and clear unconditionally in schedule() proper instead of conditionally in put_prev_task().  Cc: stable@kernel.org LKML-Reference: <1291802742.1417.9.camel@marge.simson.net>",
        "func_before": "static void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n\tconst struct sched_class *class;\n\n\tif (p->sched_class == rq->curr->sched_class) {\n\t\trq->curr->sched_class->check_preempt_curr(rq, p, flags);\n\t} else {\n\t\tfor_each_class(class) {\n\t\t\tif (class == rq->curr->sched_class)\n\t\t\t\tbreak;\n\t\t\tif (class == p->sched_class) {\n\t\t\t\tresched_task(rq->curr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * A queue event has occurred, and we're going to schedule.  In\n\t * this case, we can save a useless back to back clock update.\n\t */\n\tif (test_tsk_need_resched(rq->curr))\n\t\trq->skip_clock_update = 1;\n}",
        "func": "static void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n\tconst struct sched_class *class;\n\n\tif (p->sched_class == rq->curr->sched_class) {\n\t\trq->curr->sched_class->check_preempt_curr(rq, p, flags);\n\t} else {\n\t\tfor_each_class(class) {\n\t\t\tif (class == rq->curr->sched_class)\n\t\t\t\tbreak;\n\t\t\tif (class == p->sched_class) {\n\t\t\t\tresched_task(rq->curr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * A queue event has occurred, and we're going to schedule.  In\n\t * this case, we can save a useless back to back clock update.\n\t */\n\tif (rq->curr->se.on_rq && test_tsk_need_resched(rq->curr))\n\t\trq->skip_clock_update = 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,6 +19,6 @@\n \t * A queue event has occurred, and we're going to schedule.  In\n \t * this case, we can save a useless back to back clock update.\n \t */\n-\tif (test_tsk_need_resched(rq->curr))\n+\tif (rq->curr->se.on_rq && test_tsk_need_resched(rq->curr))\n \t\trq->skip_clock_update = 1;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (test_tsk_need_resched(rq->curr))"
            ],
            "added_lines": [
                "\tif (rq->curr->se.on_rq && test_tsk_need_resched(rq->curr))"
            ]
        }
    }
]