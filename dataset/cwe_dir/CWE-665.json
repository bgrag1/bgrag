[
    {
        "cve_id": "CVE-2019-12977",
        "func_name": "ImageMagick/WriteJP2Image",
        "description": "ImageMagick 7.0.8-34 has a \"use of uninitialized value\" vulnerability in the WriteJP2Image function in coders/jp2.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/90c4afcde1bf3ad5aead4477716161c350b049f8",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1518",
        "commit_text": "",
        "func_before": "static MagickBooleanType WriteJP2Image(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  const char\n    *option,\n    *property;\n\n  int\n    jp2_status;\n\n  MagickBooleanType\n    status;\n\n  opj_codec_t\n    *jp2_codec;\n\n  OPJ_COLOR_SPACE\n    jp2_colorspace;\n\n  opj_cparameters_t\n    parameters;\n\n  opj_image_cmptparm_t\n    jp2_info[5];\n\n  opj_image_t\n    *jp2_image;\n\n  opj_stream_t\n    *jp2_stream;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  unsigned int\n    channels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Initialize JPEG 2000 API.\n  */\n  opj_set_default_encoder_parameters(&parameters);\n  for (i=1; i < 6; i++)\n    if (((size_t) (1UL << (i+2)) > image->columns) &&\n        ((size_t) (1UL << (i+2)) > image->rows))\n      break;\n  parameters.numresolution=i;\n  option=GetImageOption(image_info,\"jp2:number-resolutions\");\n  if (option != (const char *) NULL)\n    parameters.numresolution=StringToInteger(option);\n  parameters.tcp_numlayers=1;\n  parameters.tcp_rates[0]=0;  /* lossless */\n  parameters.cp_disto_alloc=1;\n  if ((image_info->quality != 0) && (image_info->quality != 100))\n    {\n      parameters.tcp_distoratio[0]=(double) image_info->quality;\n      parameters.cp_fixed_quality=OPJ_TRUE;\n    }\n  if (image_info->extract != (char *) NULL)\n    {\n      RectangleInfo\n        geometry;\n\n      int\n        flags;\n\n      /*\n        Set tile size.\n      */\n      flags=ParseAbsoluteGeometry(image_info->extract,&geometry);\n      parameters.cp_tdx=(int) geometry.width;\n      parameters.cp_tdy=(int) geometry.width;\n      if ((flags & HeightValue) != 0)\n        parameters.cp_tdy=(int) geometry.height;\n      if ((flags & XValue) != 0)\n        parameters.cp_tx0=geometry.x;\n      if ((flags & YValue) != 0)\n        parameters.cp_ty0=geometry.y;\n      parameters.tile_size_on=OPJ_TRUE;\n    }\n  option=GetImageOption(image_info,\"jp2:quality\");\n  if (option != (const char *) NULL)\n    {\n      register const char\n        *p;\n\n      /*\n        Set quality PSNR.\n      */\n      p=option;\n      for (i=0; sscanf(p,\"%f\",&parameters.tcp_distoratio[i]) == 1; i++)\n      {\n        if (i > 100)\n          break;\n        while ((*p != '\\0') && (*p != ','))\n          p++;\n        if (*p == '\\0')\n          break;\n        p++;\n      }\n      parameters.tcp_numlayers=i+1;\n      parameters.cp_fixed_quality=OPJ_TRUE;\n    }\n  option=GetImageOption(image_info,\"jp2:progression-order\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"LRCP\") == 0)\n        parameters.prog_order=OPJ_LRCP;\n      if (LocaleCompare(option,\"RLCP\") == 0)\n        parameters.prog_order=OPJ_RLCP;\n      if (LocaleCompare(option,\"RPCL\") == 0)\n        parameters.prog_order=OPJ_RPCL;\n      if (LocaleCompare(option,\"PCRL\") == 0)\n        parameters.prog_order=OPJ_PCRL;\n      if (LocaleCompare(option,\"CPRL\") == 0)\n        parameters.prog_order=OPJ_CPRL;\n    }\n  option=GetImageOption(image_info,\"jp2:rate\");\n  if (option != (const char *) NULL)\n    {\n      register const char\n        *p;\n\n      /*\n        Set compression rate.\n      */\n      p=option;\n      for (i=0; sscanf(p,\"%f\",&parameters.tcp_rates[i]) == 1; i++)\n      {\n        if (i >= 100)\n          break;\n        while ((*p != '\\0') && (*p != ','))\n          p++;\n        if (*p == '\\0')\n          break;\n        p++;\n      }\n      parameters.tcp_numlayers=i+1;\n      parameters.cp_disto_alloc=OPJ_TRUE;\n    }\n  if (image_info->sampling_factor != (const char *) NULL)\n    (void) sscanf(image_info->sampling_factor,\"%d,%d\",\n      &parameters.subsampling_dx,&parameters.subsampling_dy);\n  property=GetImageProperty(image,\"comment\",exception);\n  if (property != (const char *) NULL)\n    parameters.cp_comment=(char *) property;\n  channels=3;\n  jp2_colorspace=OPJ_CLRSPC_SRGB;\n  if (image->colorspace == YUVColorspace)\n    {\n      jp2_colorspace=OPJ_CLRSPC_SYCC;\n      parameters.subsampling_dx=2;\n    }\n  else\n    {\n      if (IsGrayColorspace(image->colorspace) != MagickFalse)\n        {\n          channels=1;\n          jp2_colorspace=OPJ_CLRSPC_GRAY;\n        }\n      else\n        (void) TransformImageColorspace(image,sRGBColorspace,exception);\n      if (image->alpha_trait != UndefinedPixelTrait)\n        channels++;\n    }\n  parameters.tcp_mct=channels == 3 ? 1 : 0;\n  memset(jp2_info,0,sizeof(jp2_info));\n  for (i=0; i < (ssize_t) channels; i++)\n  {\n    jp2_info[i].prec=(OPJ_UINT32) image->depth;\n    jp2_info[i].bpp=(OPJ_UINT32) image->depth;\n    if ((image->depth == 1) &&\n        ((LocaleCompare(image_info->magick,\"JPT\") == 0) ||\n         (LocaleCompare(image_info->magick,\"JP2\") == 0)))\n      {\n        jp2_info[i].prec++;  /* OpenJPEG returns exception for depth @ 1 */\n        jp2_info[i].bpp++;\n      }\n    jp2_info[i].sgnd=0;\n    jp2_info[i].dx=parameters.subsampling_dx;\n    jp2_info[i].dy=parameters.subsampling_dy;\n    jp2_info[i].w=(OPJ_UINT32) image->columns;\n    jp2_info[i].h=(OPJ_UINT32) image->rows;\n  }\n  jp2_image=opj_image_create((OPJ_UINT32) channels,jp2_info,jp2_colorspace);\n  if (jp2_image == (opj_image_t *) NULL)\n    ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n  jp2_image->x0=parameters.image_offset_x0;\n  jp2_image->y0=parameters.image_offset_y0;\n  jp2_image->x1=(unsigned int) (2*parameters.image_offset_x0+(image->columns-1)*\n    parameters.subsampling_dx+1);\n  jp2_image->y1=(unsigned int) (2*parameters.image_offset_y0+(image->rows-1)*\n    parameters.subsampling_dx+1);\n  if ((image->depth == 12) &&\n      ((image->columns == 2048) || (image->rows == 1080) ||\n       (image->columns == 4096) || (image->rows == 2160)))\n    CinemaProfileCompliance(jp2_image,&parameters);\n  if (channels == 4)\n    jp2_image->comps[3].alpha=1;\n  else\n   if ((channels == 2) && (jp2_colorspace == OPJ_CLRSPC_GRAY))\n     jp2_image->comps[1].alpha=1;\n  /*\n    Convert to JP2 pixels.\n  */\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *p;\n\n    ssize_t\n      x;\n\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      for (i=0; i < (ssize_t) channels; i++)\n      {\n        double\n          scale;\n\n        register int\n          *q;\n\n        scale=(double) ((1UL << jp2_image->comps[i].prec)-1)/QuantumRange;\n        q=jp2_image->comps[i].data+(y/jp2_image->comps[i].dy*\n          image->columns/jp2_image->comps[i].dx+x/jp2_image->comps[i].dx);\n        switch (i)\n        {\n          case 0:\n          {\n            if (jp2_colorspace == OPJ_CLRSPC_GRAY)\n              {\n                *q=(int) (scale*GetPixelGray(image,p));\n                break;\n              }\n            *q=(int) (scale*GetPixelRed(image,p));\n            break;\n          }\n          case 1:\n          {\n            if (jp2_colorspace == OPJ_CLRSPC_GRAY)\n              {\n                *q=(int) (scale*GetPixelAlpha(image,p));\n                break;\n              }\n            *q=(int) (scale*GetPixelGreen(image,p));\n            break;\n          }\n          case 2:\n          {\n            *q=(int) (scale*GetPixelBlue(image,p));\n            break;\n          }\n          case 3:\n          {\n            *q=(int) (scale*GetPixelAlpha(image,p));\n            break;\n          }\n        }\n      }\n      p+=GetPixelChannels(image);\n    }\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  if (LocaleCompare(image_info->magick,\"JPT\") == 0)\n    jp2_codec=opj_create_compress(OPJ_CODEC_JPT);\n  else\n    if (LocaleCompare(image_info->magick,\"J2K\") == 0)\n      jp2_codec=opj_create_compress(OPJ_CODEC_J2K);\n    else\n      jp2_codec=opj_create_compress(OPJ_CODEC_JP2);\n  opj_set_warning_handler(jp2_codec,JP2WarningHandler,exception);\n  opj_set_error_handler(jp2_codec,JP2ErrorHandler,exception);\n  opj_setup_encoder(jp2_codec,&parameters,jp2_image);\n  jp2_stream=opj_stream_create(OPJ_J2K_STREAM_CHUNK_SIZE,OPJ_FALSE);\n  if (jp2_stream == (opj_stream_t *) NULL)\n    {\n      opj_destroy_codec(jp2_codec);\n      opj_image_destroy(jp2_image);\n      ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n    }\n  opj_stream_set_read_function(jp2_stream,JP2ReadHandler);\n  opj_stream_set_write_function(jp2_stream,JP2WriteHandler);\n  opj_stream_set_seek_function(jp2_stream,JP2SeekHandler);\n  opj_stream_set_skip_function(jp2_stream,JP2SkipHandler);\n  opj_stream_set_user_data(jp2_stream,image,NULL);\n  jp2_status=opj_start_compress(jp2_codec,jp2_image,jp2_stream);\n  if ((jp2_status == 0) || (opj_encode(jp2_codec,jp2_stream) == 0) ||\n      (opj_end_compress(jp2_codec,jp2_stream) == 0))\n    {\n      opj_stream_destroy(jp2_stream);\n      opj_destroy_codec(jp2_codec);\n      opj_image_destroy(jp2_image);\n      ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n    }\n  /*\n    Free resources.\n  */\n  opj_stream_destroy(jp2_stream);\n  opj_destroy_codec(jp2_codec);\n  opj_image_destroy(jp2_image);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
        "func": "static MagickBooleanType WriteJP2Image(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  const char\n    *option,\n    *property;\n\n  int\n    jp2_status;\n\n  MagickBooleanType\n    status;\n\n  opj_codec_t\n    *jp2_codec;\n\n  OPJ_COLOR_SPACE\n    jp2_colorspace;\n\n  opj_cparameters_t\n    parameters;\n\n  opj_image_cmptparm_t\n    jp2_info[5];\n\n  opj_image_t\n    *jp2_image;\n\n  opj_stream_t\n    *jp2_stream;\n\n  register ssize_t\n    i;\n\n  ssize_t\n    y;\n\n  unsigned int\n    channels;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    return(status);\n  /*\n    Initialize JPEG 2000 API.\n  */\n  opj_set_default_encoder_parameters(&parameters);\n  for (i=1; i < 6; i++)\n    if (((size_t) (1UL << (i+2)) > image->columns) &&\n        ((size_t) (1UL << (i+2)) > image->rows))\n      break;\n  parameters.numresolution=i;\n  option=GetImageOption(image_info,\"jp2:number-resolutions\");\n  if (option != (const char *) NULL)\n    parameters.numresolution=StringToInteger(option);\n  parameters.tcp_numlayers=1;\n  parameters.tcp_rates[0]=0;  /* lossless */\n  parameters.cp_disto_alloc=1;\n  if ((image_info->quality != 0) && (image_info->quality != 100))\n    {\n      parameters.tcp_distoratio[0]=(double) image_info->quality;\n      parameters.cp_fixed_quality=OPJ_TRUE;\n    }\n  if (image_info->extract != (char *) NULL)\n    {\n      RectangleInfo\n        geometry;\n\n      int\n        flags;\n\n      /*\n        Set tile size.\n      */\n      (void) memset(&geometry,0,sizeof(geometry));\n      flags=ParseAbsoluteGeometry(image_info->extract,&geometry);\n      parameters.cp_tdx=(int) geometry.width;\n      parameters.cp_tdy=(int) geometry.width;\n      if ((flags & HeightValue) != 0)\n        parameters.cp_tdy=(int) geometry.height;\n      if ((flags & XValue) != 0)\n        parameters.cp_tx0=geometry.x;\n      if ((flags & YValue) != 0)\n        parameters.cp_ty0=geometry.y;\n      parameters.tile_size_on=OPJ_TRUE;\n    }\n  option=GetImageOption(image_info,\"jp2:quality\");\n  if (option != (const char *) NULL)\n    {\n      register const char\n        *p;\n\n      /*\n        Set quality PSNR.\n      */\n      p=option;\n      for (i=0; sscanf(p,\"%f\",&parameters.tcp_distoratio[i]) == 1; i++)\n      {\n        if (i > 100)\n          break;\n        while ((*p != '\\0') && (*p != ','))\n          p++;\n        if (*p == '\\0')\n          break;\n        p++;\n      }\n      parameters.tcp_numlayers=i+1;\n      parameters.cp_fixed_quality=OPJ_TRUE;\n    }\n  option=GetImageOption(image_info,\"jp2:progression-order\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"LRCP\") == 0)\n        parameters.prog_order=OPJ_LRCP;\n      if (LocaleCompare(option,\"RLCP\") == 0)\n        parameters.prog_order=OPJ_RLCP;\n      if (LocaleCompare(option,\"RPCL\") == 0)\n        parameters.prog_order=OPJ_RPCL;\n      if (LocaleCompare(option,\"PCRL\") == 0)\n        parameters.prog_order=OPJ_PCRL;\n      if (LocaleCompare(option,\"CPRL\") == 0)\n        parameters.prog_order=OPJ_CPRL;\n    }\n  option=GetImageOption(image_info,\"jp2:rate\");\n  if (option != (const char *) NULL)\n    {\n      register const char\n        *p;\n\n      /*\n        Set compression rate.\n      */\n      p=option;\n      for (i=0; sscanf(p,\"%f\",&parameters.tcp_rates[i]) == 1; i++)\n      {\n        if (i >= 100)\n          break;\n        while ((*p != '\\0') && (*p != ','))\n          p++;\n        if (*p == '\\0')\n          break;\n        p++;\n      }\n      parameters.tcp_numlayers=i+1;\n      parameters.cp_disto_alloc=OPJ_TRUE;\n    }\n  if (image_info->sampling_factor != (const char *) NULL)\n    (void) sscanf(image_info->sampling_factor,\"%d,%d\",\n      &parameters.subsampling_dx,&parameters.subsampling_dy);\n  property=GetImageProperty(image,\"comment\",exception);\n  if (property != (const char *) NULL)\n    parameters.cp_comment=(char *) property;\n  channels=3;\n  jp2_colorspace=OPJ_CLRSPC_SRGB;\n  if (image->colorspace == YUVColorspace)\n    {\n      jp2_colorspace=OPJ_CLRSPC_SYCC;\n      parameters.subsampling_dx=2;\n    }\n  else\n    {\n      if (IsGrayColorspace(image->colorspace) != MagickFalse)\n        {\n          channels=1;\n          jp2_colorspace=OPJ_CLRSPC_GRAY;\n        }\n      else\n        (void) TransformImageColorspace(image,sRGBColorspace,exception);\n      if (image->alpha_trait != UndefinedPixelTrait)\n        channels++;\n    }\n  parameters.tcp_mct=channels == 3 ? 1 : 0;\n  memset(jp2_info,0,sizeof(jp2_info));\n  for (i=0; i < (ssize_t) channels; i++)\n  {\n    jp2_info[i].prec=(OPJ_UINT32) image->depth;\n    jp2_info[i].bpp=(OPJ_UINT32) image->depth;\n    if ((image->depth == 1) &&\n        ((LocaleCompare(image_info->magick,\"JPT\") == 0) ||\n         (LocaleCompare(image_info->magick,\"JP2\") == 0)))\n      {\n        jp2_info[i].prec++;  /* OpenJPEG returns exception for depth @ 1 */\n        jp2_info[i].bpp++;\n      }\n    jp2_info[i].sgnd=0;\n    jp2_info[i].dx=parameters.subsampling_dx;\n    jp2_info[i].dy=parameters.subsampling_dy;\n    jp2_info[i].w=(OPJ_UINT32) image->columns;\n    jp2_info[i].h=(OPJ_UINT32) image->rows;\n  }\n  jp2_image=opj_image_create((OPJ_UINT32) channels,jp2_info,jp2_colorspace);\n  if (jp2_image == (opj_image_t *) NULL)\n    ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n  jp2_image->x0=parameters.image_offset_x0;\n  jp2_image->y0=parameters.image_offset_y0;\n  jp2_image->x1=(unsigned int) (2*parameters.image_offset_x0+(image->columns-1)*\n    parameters.subsampling_dx+1);\n  jp2_image->y1=(unsigned int) (2*parameters.image_offset_y0+(image->rows-1)*\n    parameters.subsampling_dx+1);\n  if ((image->depth == 12) &&\n      ((image->columns == 2048) || (image->rows == 1080) ||\n       (image->columns == 4096) || (image->rows == 2160)))\n    CinemaProfileCompliance(jp2_image,&parameters);\n  if (channels == 4)\n    jp2_image->comps[3].alpha=1;\n  else\n   if ((channels == 2) && (jp2_colorspace == OPJ_CLRSPC_GRAY))\n     jp2_image->comps[1].alpha=1;\n  /*\n    Convert to JP2 pixels.\n  */\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *p;\n\n    ssize_t\n      x;\n\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      for (i=0; i < (ssize_t) channels; i++)\n      {\n        double\n          scale;\n\n        register int\n          *q;\n\n        scale=(double) ((1UL << jp2_image->comps[i].prec)-1)/QuantumRange;\n        q=jp2_image->comps[i].data+(y/jp2_image->comps[i].dy*\n          image->columns/jp2_image->comps[i].dx+x/jp2_image->comps[i].dx);\n        switch (i)\n        {\n          case 0:\n          {\n            if (jp2_colorspace == OPJ_CLRSPC_GRAY)\n              {\n                *q=(int) (scale*GetPixelGray(image,p));\n                break;\n              }\n            *q=(int) (scale*GetPixelRed(image,p));\n            break;\n          }\n          case 1:\n          {\n            if (jp2_colorspace == OPJ_CLRSPC_GRAY)\n              {\n                *q=(int) (scale*GetPixelAlpha(image,p));\n                break;\n              }\n            *q=(int) (scale*GetPixelGreen(image,p));\n            break;\n          }\n          case 2:\n          {\n            *q=(int) (scale*GetPixelBlue(image,p));\n            break;\n          }\n          case 3:\n          {\n            *q=(int) (scale*GetPixelAlpha(image,p));\n            break;\n          }\n        }\n      }\n      p+=GetPixelChannels(image);\n    }\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  if (LocaleCompare(image_info->magick,\"JPT\") == 0)\n    jp2_codec=opj_create_compress(OPJ_CODEC_JPT);\n  else\n    if (LocaleCompare(image_info->magick,\"J2K\") == 0)\n      jp2_codec=opj_create_compress(OPJ_CODEC_J2K);\n    else\n      jp2_codec=opj_create_compress(OPJ_CODEC_JP2);\n  opj_set_warning_handler(jp2_codec,JP2WarningHandler,exception);\n  opj_set_error_handler(jp2_codec,JP2ErrorHandler,exception);\n  opj_setup_encoder(jp2_codec,&parameters,jp2_image);\n  jp2_stream=opj_stream_create(OPJ_J2K_STREAM_CHUNK_SIZE,OPJ_FALSE);\n  if (jp2_stream == (opj_stream_t *) NULL)\n    {\n      opj_destroy_codec(jp2_codec);\n      opj_image_destroy(jp2_image);\n      ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n    }\n  opj_stream_set_read_function(jp2_stream,JP2ReadHandler);\n  opj_stream_set_write_function(jp2_stream,JP2WriteHandler);\n  opj_stream_set_seek_function(jp2_stream,JP2SeekHandler);\n  opj_stream_set_skip_function(jp2_stream,JP2SkipHandler);\n  opj_stream_set_user_data(jp2_stream,image,NULL);\n  jp2_status=opj_start_compress(jp2_codec,jp2_image,jp2_stream);\n  if ((jp2_status == 0) || (opj_encode(jp2_codec,jp2_stream) == 0) ||\n      (opj_end_compress(jp2_codec,jp2_stream) == 0))\n    {\n      opj_stream_destroy(jp2_stream);\n      opj_destroy_codec(jp2_codec);\n      opj_image_destroy(jp2_image);\n      ThrowWriterException(DelegateError,\"UnableToEncodeImageFile\");\n    }\n  /*\n    Free resources.\n  */\n  opj_stream_destroy(jp2_stream);\n  opj_destroy_codec(jp2_codec);\n  opj_image_destroy(jp2_image);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -83,6 +83,7 @@\n       /*\n         Set tile size.\n       */\n+      (void) memset(&geometry,0,sizeof(geometry));\n       flags=ParseAbsoluteGeometry(image_info->extract,&geometry);\n       parameters.cp_tdx=(int) geometry.width;\n       parameters.cp_tdy=(int) geometry.width;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      (void) memset(&geometry,0,sizeof(geometry));"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-12978",
        "func_name": "ImageMagick/ReadPANGOImage",
        "description": "ImageMagick 7.0.8-34 has a \"use of uninitialized value\" vulnerability in the ReadPANGOImage function in coders/pango.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/ee60b346b8fce70eb3b239a78e2486fba9615069",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1519",
        "commit_text": "",
        "func_before": "static Image *ReadPANGOImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  cairo_font_options_t\n    *font_options;\n\n  cairo_surface_t\n    *surface;\n\n  char\n    *caption,\n    *property;\n\n  cairo_t\n    *cairo_image;\n\n  const char\n    *option;\n\n  DrawInfo\n    *draw_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *pixel_info;\n\n  PangoAlignment\n    align;\n\n  PangoContext\n    *context;\n\n  PangoFontDescription\n    *description;\n\n  PangoFontMap\n    *fontmap;\n\n  PangoGravity\n    gravity;\n\n  PangoLayout\n    *layout;\n\n  PangoRectangle\n    extent;\n\n  PixelInfo\n    fill_color;\n\n  RectangleInfo\n    page;\n\n  register unsigned char\n    *p;\n\n  size_t\n    stride;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Initialize Image structure.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  (void) ResetImagePage(image,\"0x0+0+0\");\n  /*\n    Format caption.\n  */\n  option=GetImageOption(image_info,\"filename\");\n  if (option == (const char *) NULL)\n    property=InterpretImageProperties((ImageInfo *) image_info,image,\n      image_info->filename,exception);\n  else\n    if (LocaleNCompare(option,\"pango:\",6) == 0)\n      property=InterpretImageProperties((ImageInfo *) image_info,image,option+6,\n        exception);\n    else\n      property=InterpretImageProperties((ImageInfo *) image_info,image,option,\n        exception);\n  (void) SetImageProperty(image,\"caption\",property,exception);\n  property=DestroyString(property);\n  caption=ConstantString(GetImageProperty(image,\"caption\",exception));\n  /*\n    Get context.\n  */\n  fontmap=pango_cairo_font_map_new();\n  pango_cairo_font_map_set_resolution(PANGO_CAIRO_FONT_MAP(fontmap),\n    image->resolution.x == 0.0 ? DefaultSVGDensity : image->resolution.x);\n  font_options=cairo_font_options_create();\n  option=GetImageOption(image_info,\"pango:hinting\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"none\") != 0)\n        cairo_font_options_set_hint_style(font_options,CAIRO_HINT_STYLE_NONE);\n      if (LocaleCompare(option,\"full\") != 0)\n        cairo_font_options_set_hint_style(font_options,CAIRO_HINT_STYLE_FULL);\n    }\n  context=pango_font_map_create_context(fontmap);\n  pango_cairo_context_set_font_options(context,font_options);\n  cairo_font_options_destroy(font_options);\n  option=GetImageOption(image_info,\"pango:language\");\n  if (option != (const char *) NULL)\n    pango_context_set_language(context,pango_language_from_string(option));\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  pango_context_set_base_dir(context,draw_info->direction ==\n    RightToLeftDirection ? PANGO_DIRECTION_RTL : PANGO_DIRECTION_LTR);\n  switch (draw_info->gravity)\n  {\n    case NorthGravity:\n    {\n      gravity=PANGO_GRAVITY_NORTH;\n      break;\n    }\n    case NorthWestGravity:\n    case WestGravity:\n    case SouthWestGravity:\n    {\n      gravity=PANGO_GRAVITY_WEST;\n      break;\n    }\n    case NorthEastGravity:\n    case EastGravity:\n    case SouthEastGravity:\n    {\n      gravity=PANGO_GRAVITY_EAST;\n      break;\n    }\n    case SouthGravity:\n    {\n      gravity=PANGO_GRAVITY_SOUTH;\n      break;\n    }\n    default:\n    {\n      gravity=PANGO_GRAVITY_AUTO;\n      break;\n    }\n  }\n  pango_context_set_base_gravity(context,gravity);\n  option=GetImageOption(image_info,\"pango:gravity-hint\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"line\") == 0)\n        pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_LINE);\n      if (LocaleCompare(option,\"natural\") == 0)\n        pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_NATURAL);\n      if (LocaleCompare(option,\"strong\") == 0)\n        pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_STRONG);\n    }\n  /*\n    Configure layout.\n  */\n  layout=pango_layout_new(context);\n  option=GetImageOption(image_info,\"pango:auto-dir\");\n  if (option != (const char *) NULL)\n    pango_layout_set_auto_dir(layout,1);\n  option=GetImageOption(image_info,\"pango:ellipsize\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"end\") == 0)\n        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_END);\n      if (LocaleCompare(option,\"middle\") == 0)\n        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_MIDDLE);\n      if (LocaleCompare(option,\"none\") == 0)\n        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_NONE);\n      if (LocaleCompare(option,\"start\") == 0)\n        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_START);\n    }\n  option=GetImageOption(image_info,\"pango:justify\");\n  if (IsStringTrue(option) != MagickFalse)\n    pango_layout_set_justify(layout,1);\n  option=GetImageOption(image_info,\"pango:single-paragraph\");\n  if (IsStringTrue(option) != MagickFalse)\n    pango_layout_set_single_paragraph_mode(layout,1);\n  option=GetImageOption(image_info,\"pango:wrap\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"char\") == 0)\n        pango_layout_set_wrap(layout,PANGO_WRAP_CHAR);\n      if (LocaleCompare(option,\"word\") == 0)\n        pango_layout_set_wrap(layout,PANGO_WRAP_WORD);\n      if (LocaleCompare(option,\"word-char\") == 0)\n        pango_layout_set_wrap(layout,PANGO_WRAP_WORD_CHAR);\n    }\n  option=GetImageOption(image_info,\"pango:indent\");\n  if (option != (const char *) NULL)\n    pango_layout_set_indent(layout,(int) ((StringToLong(option)*\n      (image->resolution.x == 0.0 ? DefaultSVGDensity : image->resolution.x)*\n      PANGO_SCALE+DefaultSVGDensity/2)/DefaultSVGDensity+0.5));\n  switch (draw_info->align)\n  {\n    case CenterAlign: align=PANGO_ALIGN_CENTER; break;\n    case RightAlign: align=PANGO_ALIGN_RIGHT; break;\n    case LeftAlign: align=PANGO_ALIGN_LEFT; break;\n    default:\n    {\n      if (draw_info->gravity == CenterGravity)\n        {\n          align=PANGO_ALIGN_CENTER;\n          break;\n        }\n      align=PANGO_ALIGN_LEFT;\n      break;\n    }\n  }\n  if ((align != PANGO_ALIGN_CENTER) &&\n      (draw_info->direction == RightToLeftDirection))\n    align=(PangoAlignment) (PANGO_ALIGN_LEFT+PANGO_ALIGN_RIGHT-align);\n  option=GetImageOption(image_info,\"pango:align\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"center\") == 0)\n        align=PANGO_ALIGN_CENTER;\n      if (LocaleCompare(option,\"left\") == 0)\n        align=PANGO_ALIGN_LEFT;\n      if (LocaleCompare(option,\"right\") == 0)\n        align=PANGO_ALIGN_RIGHT;\n    }\n  pango_layout_set_alignment(layout,align);\n  if (draw_info->font == (char *) NULL)\n    description=pango_font_description_new();\n  else\n    description=pango_font_description_from_string(draw_info->font);\n  pango_font_description_set_size(description,(int) (PANGO_SCALE*\n    draw_info->pointsize+0.5));\n  pango_layout_set_font_description(layout,description);\n  pango_font_description_free(description);\n  option=GetImageOption(image_info,\"pango:markup\");\n  if ((option != (const char *) NULL) && (IsStringTrue(option) == MagickFalse))\n    pango_layout_set_text(layout,caption,-1);\n  else\n    {\n      GError\n        *error;\n\n      error=(GError *) NULL;\n      if (pango_parse_markup(caption,-1,0,NULL,NULL,NULL,&error) == 0)\n        (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n          error->message,\"`%s'\",image_info->filename);\n      pango_layout_set_markup(layout,caption,-1);\n    }\n  pango_layout_context_changed(layout);\n  page.x=0;\n  page.y=0;\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  if (image->columns == 0)\n    {\n      pango_layout_get_extents(layout,NULL,&extent);\n      image->columns=(extent.x+extent.width+PANGO_SCALE/2)/PANGO_SCALE+2*page.x;\n    }\n  else\n    {\n      image->columns-=2*page.x;\n      pango_layout_set_width(layout,(int) ((PANGO_SCALE*image->columns*\n        (image->resolution.x == 0.0 ? DefaultSVGDensity : image->resolution.x)+\n        DefaultSVGDensity/2)/DefaultSVGDensity+0.5));\n    }\n  if (image->rows == 0)\n    {\n      pango_layout_get_extents(layout,NULL,&extent);\n      image->rows=(extent.y+extent.height+PANGO_SCALE/2)/PANGO_SCALE+2*page.y;\n    }\n  else\n    {\n      image->rows-=2*page.y;\n      pango_layout_set_height(layout,(int) ((PANGO_SCALE*image->rows*\n        (image->resolution.y == 0.0 ? DefaultSVGDensity : image->resolution.y)+\n        DefaultSVGDensity/2)/DefaultSVGDensity+0.5));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Render markup.\n  */\n  stride=(size_t) cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32,\n    (int) image->columns);\n  pixel_info=AcquireVirtualMemory(image->rows,stride*sizeof(*pixels));\n  if (pixel_info == (MemoryInfo *) NULL)\n    {\n      draw_info=DestroyDrawInfo(draw_info);\n      caption=DestroyString(caption);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n  surface=cairo_image_surface_create_for_data(pixels,CAIRO_FORMAT_ARGB32,\n    (int) image->columns,(int) image->rows,(int) stride);\n  cairo_image=cairo_create(surface);\n  cairo_set_operator(cairo_image,CAIRO_OPERATOR_CLEAR);\n  cairo_paint(cairo_image);\n  cairo_set_operator(cairo_image,CAIRO_OPERATOR_OVER);\n  cairo_translate(cairo_image,page.x,page.y);\n  cairo_set_source_rgba(cairo_image,QuantumScale*draw_info->fill.red,\n    QuantumScale*draw_info->fill.green,QuantumScale*draw_info->fill.blue,\n    QuantumScale*draw_info->fill.alpha);\n  pango_cairo_show_layout(cairo_image,layout);\n  cairo_destroy(cairo_image);\n  cairo_surface_destroy(surface);\n  g_object_unref(layout);\n  g_object_unref(fontmap);\n  /*\n    Convert surface to image.\n  */\n  (void) SetImageBackgroundColor(image,exception);\n  p=pixels;\n  GetPixelInfo(image,&fill_color);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *q;\n\n    register ssize_t\n      x;\n\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        gamma;\n\n      fill_color.blue=(double) ScaleCharToQuantum(*p++);\n      fill_color.green=(double) ScaleCharToQuantum(*p++);\n      fill_color.red=(double) ScaleCharToQuantum(*p++);\n      fill_color.alpha=(double) ScaleCharToQuantum(*p++);\n      /*\n        Disassociate alpha.\n      */\n      gamma=QuantumScale*fill_color.alpha;\n      gamma=PerceptibleReciprocal(gamma);\n      fill_color.blue*=gamma;\n      fill_color.green*=gamma;\n      fill_color.red*=gamma;\n      CompositePixelOver(image,&fill_color,fill_color.alpha,q,(double)\n        GetPixelAlpha(image,q),q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n        image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  /*\n    Relinquish resources.\n  */\n  pixel_info=RelinquishVirtualMemory(pixel_info);\n  draw_info=DestroyDrawInfo(draw_info);\n  caption=DestroyString(caption);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadPANGOImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  cairo_font_options_t\n    *font_options;\n\n  cairo_surface_t\n    *surface;\n\n  char\n    *caption,\n    *property;\n\n  cairo_t\n    *cairo_image;\n\n  const char\n    *option;\n\n  DrawInfo\n    *draw_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *pixel_info;\n\n  PangoAlignment\n    align;\n\n  PangoContext\n    *context;\n\n  PangoFontDescription\n    *description;\n\n  PangoFontMap\n    *fontmap;\n\n  PangoGravity\n    gravity;\n\n  PangoLayout\n    *layout;\n\n  PangoRectangle\n    extent;\n\n  PixelInfo\n    fill_color;\n\n  RectangleInfo\n    page;\n\n  register unsigned char\n    *p;\n\n  size_t\n    stride;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pixels;\n\n  /*\n    Initialize Image structure.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  (void) ResetImagePage(image,\"0x0+0+0\");\n  if ((image->columns != 0) && (image->rows != 0))\n    (void) SetImageBackgroundColor(image,exception);\n  /*\n    Format caption.\n  */\n  option=GetImageOption(image_info,\"filename\");\n  if (option == (const char *) NULL)\n    property=InterpretImageProperties((ImageInfo *) image_info,image,\n      image_info->filename,exception);\n  else\n    if (LocaleNCompare(option,\"pango:\",6) == 0)\n      property=InterpretImageProperties((ImageInfo *) image_info,image,option+6,\n        exception);\n    else\n      property=InterpretImageProperties((ImageInfo *) image_info,image,option,\n        exception);\n  (void) SetImageProperty(image,\"caption\",property,exception);\n  property=DestroyString(property);\n  caption=ConstantString(GetImageProperty(image,\"caption\",exception));\n  /*\n    Get context.\n  */\n  fontmap=pango_cairo_font_map_new();\n  pango_cairo_font_map_set_resolution(PANGO_CAIRO_FONT_MAP(fontmap),\n    image->resolution.x == 0.0 ? DefaultSVGDensity : image->resolution.x);\n  font_options=cairo_font_options_create();\n  option=GetImageOption(image_info,\"pango:hinting\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"none\") != 0)\n        cairo_font_options_set_hint_style(font_options,CAIRO_HINT_STYLE_NONE);\n      if (LocaleCompare(option,\"full\") != 0)\n        cairo_font_options_set_hint_style(font_options,CAIRO_HINT_STYLE_FULL);\n    }\n  context=pango_font_map_create_context(fontmap);\n  pango_cairo_context_set_font_options(context,font_options);\n  cairo_font_options_destroy(font_options);\n  option=GetImageOption(image_info,\"pango:language\");\n  if (option != (const char *) NULL)\n    pango_context_set_language(context,pango_language_from_string(option));\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  pango_context_set_base_dir(context,draw_info->direction ==\n    RightToLeftDirection ? PANGO_DIRECTION_RTL : PANGO_DIRECTION_LTR);\n  switch (draw_info->gravity)\n  {\n    case NorthGravity:\n    {\n      gravity=PANGO_GRAVITY_NORTH;\n      break;\n    }\n    case NorthWestGravity:\n    case WestGravity:\n    case SouthWestGravity:\n    {\n      gravity=PANGO_GRAVITY_WEST;\n      break;\n    }\n    case NorthEastGravity:\n    case EastGravity:\n    case SouthEastGravity:\n    {\n      gravity=PANGO_GRAVITY_EAST;\n      break;\n    }\n    case SouthGravity:\n    {\n      gravity=PANGO_GRAVITY_SOUTH;\n      break;\n    }\n    default:\n    {\n      gravity=PANGO_GRAVITY_AUTO;\n      break;\n    }\n  }\n  pango_context_set_base_gravity(context,gravity);\n  option=GetImageOption(image_info,\"pango:gravity-hint\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"line\") == 0)\n        pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_LINE);\n      if (LocaleCompare(option,\"natural\") == 0)\n        pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_NATURAL);\n      if (LocaleCompare(option,\"strong\") == 0)\n        pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_STRONG);\n    }\n  /*\n    Configure layout.\n  */\n  layout=pango_layout_new(context);\n  option=GetImageOption(image_info,\"pango:auto-dir\");\n  if (option != (const char *) NULL)\n    pango_layout_set_auto_dir(layout,1);\n  option=GetImageOption(image_info,\"pango:ellipsize\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"end\") == 0)\n        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_END);\n      if (LocaleCompare(option,\"middle\") == 0)\n        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_MIDDLE);\n      if (LocaleCompare(option,\"none\") == 0)\n        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_NONE);\n      if (LocaleCompare(option,\"start\") == 0)\n        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_START);\n    }\n  option=GetImageOption(image_info,\"pango:justify\");\n  if (IsStringTrue(option) != MagickFalse)\n    pango_layout_set_justify(layout,1);\n  option=GetImageOption(image_info,\"pango:single-paragraph\");\n  if (IsStringTrue(option) != MagickFalse)\n    pango_layout_set_single_paragraph_mode(layout,1);\n  option=GetImageOption(image_info,\"pango:wrap\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"char\") == 0)\n        pango_layout_set_wrap(layout,PANGO_WRAP_CHAR);\n      if (LocaleCompare(option,\"word\") == 0)\n        pango_layout_set_wrap(layout,PANGO_WRAP_WORD);\n      if (LocaleCompare(option,\"word-char\") == 0)\n        pango_layout_set_wrap(layout,PANGO_WRAP_WORD_CHAR);\n    }\n  option=GetImageOption(image_info,\"pango:indent\");\n  if (option != (const char *) NULL)\n    pango_layout_set_indent(layout,(int) ((StringToLong(option)*\n      (image->resolution.x == 0.0 ? DefaultSVGDensity : image->resolution.x)*\n      PANGO_SCALE+DefaultSVGDensity/2)/DefaultSVGDensity+0.5));\n  switch (draw_info->align)\n  {\n    case CenterAlign: align=PANGO_ALIGN_CENTER; break;\n    case RightAlign: align=PANGO_ALIGN_RIGHT; break;\n    case LeftAlign: align=PANGO_ALIGN_LEFT; break;\n    default:\n    {\n      if (draw_info->gravity == CenterGravity)\n        {\n          align=PANGO_ALIGN_CENTER;\n          break;\n        }\n      align=PANGO_ALIGN_LEFT;\n      break;\n    }\n  }\n  if ((align != PANGO_ALIGN_CENTER) &&\n      (draw_info->direction == RightToLeftDirection))\n    align=(PangoAlignment) (PANGO_ALIGN_LEFT+PANGO_ALIGN_RIGHT-align);\n  option=GetImageOption(image_info,\"pango:align\");\n  if (option != (const char *) NULL)\n    {\n      if (LocaleCompare(option,\"center\") == 0)\n        align=PANGO_ALIGN_CENTER;\n      if (LocaleCompare(option,\"left\") == 0)\n        align=PANGO_ALIGN_LEFT;\n      if (LocaleCompare(option,\"right\") == 0)\n        align=PANGO_ALIGN_RIGHT;\n    }\n  pango_layout_set_alignment(layout,align);\n  if (draw_info->font == (char *) NULL)\n    description=pango_font_description_new();\n  else\n    description=pango_font_description_from_string(draw_info->font);\n  pango_font_description_set_size(description,(int) (PANGO_SCALE*\n    draw_info->pointsize+0.5));\n  pango_layout_set_font_description(layout,description);\n  pango_font_description_free(description);\n  option=GetImageOption(image_info,\"pango:markup\");\n  if ((option != (const char *) NULL) && (IsStringTrue(option) == MagickFalse))\n    pango_layout_set_text(layout,caption,-1);\n  else\n    {\n      GError\n        *error;\n\n      error=(GError *) NULL;\n      if (pango_parse_markup(caption,-1,0,NULL,NULL,NULL,&error) == 0)\n        (void) ThrowMagickException(exception,GetMagickModule(),CoderError,\n          error->message,\"`%s'\",image_info->filename);\n      pango_layout_set_markup(layout,caption,-1);\n    }\n  pango_layout_context_changed(layout);\n  page.x=0;\n  page.y=0;\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  if (image->columns == 0)\n    {\n      pango_layout_get_extents(layout,NULL,&extent);\n      image->columns=(extent.x+extent.width+PANGO_SCALE/2)/PANGO_SCALE+2*page.x;\n    }\n  else\n    {\n      image->columns-=2*page.x;\n      pango_layout_set_width(layout,(int) ((PANGO_SCALE*image->columns*\n        (image->resolution.x == 0.0 ? DefaultSVGDensity : image->resolution.x)+\n        DefaultSVGDensity/2)/DefaultSVGDensity+0.5));\n    }\n  if (image->rows == 0)\n    {\n      pango_layout_get_extents(layout,NULL,&extent);\n      image->rows=(extent.y+extent.height+PANGO_SCALE/2)/PANGO_SCALE+2*page.y;\n    }\n  else\n    {\n      image->rows-=2*page.y;\n      pango_layout_set_height(layout,(int) ((PANGO_SCALE*image->rows*\n        (image->resolution.y == 0.0 ? DefaultSVGDensity : image->resolution.y)+\n        DefaultSVGDensity/2)/DefaultSVGDensity+0.5));\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Render markup.\n  */\n  stride=(size_t) cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32,\n    (int) image->columns);\n  pixel_info=AcquireVirtualMemory(image->rows,stride*sizeof(*pixels));\n  if (pixel_info == (MemoryInfo *) NULL)\n    {\n      draw_info=DestroyDrawInfo(draw_info);\n      caption=DestroyString(caption);\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n  surface=cairo_image_surface_create_for_data(pixels,CAIRO_FORMAT_ARGB32,\n    (int) image->columns,(int) image->rows,(int) stride);\n  cairo_image=cairo_create(surface);\n  cairo_set_operator(cairo_image,CAIRO_OPERATOR_CLEAR);\n  cairo_paint(cairo_image);\n  cairo_set_operator(cairo_image,CAIRO_OPERATOR_OVER);\n  cairo_translate(cairo_image,page.x,page.y);\n  cairo_set_source_rgba(cairo_image,QuantumScale*draw_info->fill.red,\n    QuantumScale*draw_info->fill.green,QuantumScale*draw_info->fill.blue,\n    QuantumScale*draw_info->fill.alpha);\n  pango_cairo_show_layout(cairo_image,layout);\n  cairo_destroy(cairo_image);\n  cairo_surface_destroy(surface);\n  g_object_unref(layout);\n  g_object_unref(fontmap);\n  /*\n    Convert surface to image.\n  */\n  (void) SetImageBackgroundColor(image,exception);\n  p=pixels;\n  GetPixelInfo(image,&fill_color);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *q;\n\n    register ssize_t\n      x;\n\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        gamma;\n\n      fill_color.blue=(double) ScaleCharToQuantum(*p++);\n      fill_color.green=(double) ScaleCharToQuantum(*p++);\n      fill_color.red=(double) ScaleCharToQuantum(*p++);\n      fill_color.alpha=(double) ScaleCharToQuantum(*p++);\n      /*\n        Disassociate alpha.\n      */\n      gamma=QuantumScale*fill_color.alpha;\n      gamma=PerceptibleReciprocal(gamma);\n      fill_color.blue*=gamma;\n      fill_color.green*=gamma;\n      fill_color.red*=gamma;\n      CompositePixelOver(image,&fill_color,fill_color.alpha,q,(double)\n        GetPixelAlpha(image,q),q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n        image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  /*\n    Relinquish resources.\n  */\n  pixel_info=RelinquishVirtualMemory(pixel_info);\n  draw_info=DestroyDrawInfo(draw_info);\n  caption=DestroyString(caption);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -80,6 +80,8 @@\n   assert(exception->signature == MagickCoreSignature);\n   image=AcquireImage(image_info,exception);\n   (void) ResetImagePage(image,\"0x0+0+0\");\n+  if ((image->columns != 0) && (image->rows != 0))\n+    (void) SetImageBackgroundColor(image,exception);\n   /*\n     Format caption.\n   */",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  if ((image->columns != 0) && (image->rows != 0))",
                "    (void) SetImageBackgroundColor(image,exception);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-12979",
        "func_name": "ImageMagick/AcquireImage",
        "description": "ImageMagick 7.0.8-34 has a \"use of uninitialized value\" vulnerability in the SyncImageSettings function in MagickCore/image.c. This is related to AcquireImage in magick/image.c.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/ee3dae8624e69261760754442827aea4d0254a6f",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1522",
        "commit_text": "",
        "func_before": "MagickExport Image *AcquireImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  Image\n    *image;\n\n  MagickStatusType\n    flags;\n\n  /*\n    Allocate image structure.\n  */\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  image=(Image *) AcquireCriticalMemory(sizeof(*image));\n  (void) memset(image,0,sizeof(*image));\n  /*\n    Initialize Image structure.\n  */\n  (void) CopyMagickString(image->magick,\"MIFF\",MagickPathExtent);\n  image->storage_class=DirectClass;\n  image->depth=MAGICKCORE_QUANTUM_DEPTH;\n  image->colorspace=sRGBColorspace;\n  image->rendering_intent=PerceptualIntent;\n  image->gamma=1.000f/2.200f;\n  image->chromaticity.red_primary.x=0.6400f;\n  image->chromaticity.red_primary.y=0.3300f;\n  image->chromaticity.red_primary.z=0.0300f;\n  image->chromaticity.green_primary.x=0.3000f;\n  image->chromaticity.green_primary.y=0.6000f;\n  image->chromaticity.green_primary.z=0.1000f;\n  image->chromaticity.blue_primary.x=0.1500f;\n  image->chromaticity.blue_primary.y=0.0600f;\n  image->chromaticity.blue_primary.z=0.7900f;\n  image->chromaticity.white_point.x=0.3127f;\n  image->chromaticity.white_point.y=0.3290f;\n  image->chromaticity.white_point.z=0.3583f;\n  image->interlace=NoInterlace;\n  image->ticks_per_second=UndefinedTicksPerSecond;\n  image->compose=OverCompositeOp;\n  (void) QueryColorCompliance(MatteColor,AllCompliance,&image->matte_color,\n    exception);\n  (void) QueryColorCompliance(BackgroundColor,AllCompliance,\n    &image->background_color,exception);\n  (void) QueryColorCompliance(BorderColor,AllCompliance,&image->border_color,\n    exception);\n  (void) QueryColorCompliance(TransparentColor,AllCompliance,\n    &image->transparent_color,exception);\n  GetTimerInfo(&image->timer);\n  image->cache=AcquirePixelCache(0);\n  image->channel_mask=DefaultChannels;\n  image->channel_map=AcquirePixelChannelMap();\n  image->blob=CloneBlobInfo((BlobInfo *) NULL);\n  image->timestamp=time((time_t *) NULL);\n  image->debug=IsEventLogging();\n  image->reference_count=1;\n  image->semaphore=AcquireSemaphoreInfo();\n  image->signature=MagickCoreSignature;\n  if (image_info == (ImageInfo *) NULL)\n    return(image);\n  /*\n    Transfer image info.\n  */\n  SetBlobExempt(image,image_info->file != (FILE *) NULL ? MagickTrue :\n    MagickFalse);\n  (void) CopyMagickString(image->filename,image_info->filename,\n    MagickPathExtent);\n  (void) CopyMagickString(image->magick_filename,image_info->filename,\n    MagickPathExtent);\n  (void) CopyMagickString(image->magick,image_info->magick,MagickPathExtent);\n  if (image_info->size != (char *) NULL)\n    {\n      (void) ParseAbsoluteGeometry(image_info->size,&image->extract_info);\n      image->columns=image->extract_info.width;\n      image->rows=image->extract_info.height;\n      image->offset=image->extract_info.x;\n      image->extract_info.x=0;\n      image->extract_info.y=0;\n    }\n  if (image_info->extract != (char *) NULL)\n    {\n      RectangleInfo\n        geometry;\n\n      (void) memset(&geometry,0,sizeof(geometry));\n      flags=ParseAbsoluteGeometry(image_info->extract,&geometry);\n      if (((flags & XValue) != 0) || ((flags & YValue) != 0))\n        {\n          image->extract_info=geometry;\n          Swap(image->columns,image->extract_info.width);\n          Swap(image->rows,image->extract_info.height);\n        }\n    }\n  image->compression=image_info->compression;\n  image->quality=image_info->quality;\n  image->endian=image_info->endian;\n  image->interlace=image_info->interlace;\n  image->units=image_info->units;\n  if (image_info->density != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      flags=ParseGeometry(image_info->density,&geometry_info);\n      image->resolution.x=geometry_info.rho;\n      image->resolution.y=geometry_info.sigma;\n      if ((flags & SigmaValue) == 0)\n        image->resolution.y=image->resolution.x;\n    }\n  if (image_info->page != (char *) NULL)\n    {\n      char\n        *geometry;\n\n      image->page=image->extract_info;\n      geometry=GetPageGeometry(image_info->page);\n      (void) ParseAbsoluteGeometry(geometry,&image->page);\n      geometry=DestroyString(geometry);\n    }\n  if (image_info->depth != 0)\n    image->depth=image_info->depth;\n  image->dither=image_info->dither;\n  image->matte_color=image_info->matte_color;\n  image->background_color=image_info->background_color;\n  image->border_color=image_info->border_color;\n  image->transparent_color=image_info->transparent_color;\n  image->ping=image_info->ping;\n  image->progress_monitor=image_info->progress_monitor;\n  image->client_data=image_info->client_data;\n  if (image_info->cache != (void *) NULL)\n    ClonePixelCacheMethods(image->cache,image_info->cache);\n  /*\n    Set all global options that map to per-image settings.\n  */\n  (void) SyncImageSettings(image_info,image,exception);\n  /*\n    Global options that are only set for new images.\n  */\n  option=GetImageOption(image_info,\"delay\");\n  if (option != (const char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      flags=ParseGeometry(option,&geometry_info);\n      if ((flags & GreaterValue) != 0)\n        {\n          if (image->delay > (size_t) floor(geometry_info.rho+0.5))\n            image->delay=(size_t) floor(geometry_info.rho+0.5);\n        }\n      else\n        if ((flags & LessValue) != 0)\n          {\n            if (image->delay < (size_t) floor(geometry_info.rho+0.5))\n              image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n          }\n        else\n          image->delay=(size_t) floor(geometry_info.rho+0.5);\n      if ((flags & SigmaValue) != 0)\n        image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n    }\n  option=GetImageOption(image_info,\"dispose\");\n  if (option != (const char *) NULL)\n    image->dispose=(DisposeType) ParseCommandOption(MagickDisposeOptions,\n      MagickFalse,option);\n  return(image);\n}",
        "func": "MagickExport Image *AcquireImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const char\n    *option;\n\n  Image\n    *image;\n\n  MagickStatusType\n    flags;\n\n  /*\n    Allocate image structure.\n  */\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  image=(Image *) AcquireCriticalMemory(sizeof(*image));\n  (void) memset(image,0,sizeof(*image));\n  /*\n    Initialize Image structure.\n  */\n  (void) CopyMagickString(image->magick,\"MIFF\",MagickPathExtent);\n  image->storage_class=DirectClass;\n  image->depth=MAGICKCORE_QUANTUM_DEPTH;\n  image->colorspace=sRGBColorspace;\n  image->rendering_intent=PerceptualIntent;\n  image->gamma=1.000f/2.200f;\n  image->chromaticity.red_primary.x=0.6400f;\n  image->chromaticity.red_primary.y=0.3300f;\n  image->chromaticity.red_primary.z=0.0300f;\n  image->chromaticity.green_primary.x=0.3000f;\n  image->chromaticity.green_primary.y=0.6000f;\n  image->chromaticity.green_primary.z=0.1000f;\n  image->chromaticity.blue_primary.x=0.1500f;\n  image->chromaticity.blue_primary.y=0.0600f;\n  image->chromaticity.blue_primary.z=0.7900f;\n  image->chromaticity.white_point.x=0.3127f;\n  image->chromaticity.white_point.y=0.3290f;\n  image->chromaticity.white_point.z=0.3583f;\n  image->interlace=NoInterlace;\n  image->ticks_per_second=UndefinedTicksPerSecond;\n  image->compose=OverCompositeOp;\n  (void) QueryColorCompliance(MatteColor,AllCompliance,&image->matte_color,\n    exception);\n  (void) QueryColorCompliance(BackgroundColor,AllCompliance,\n    &image->background_color,exception);\n  (void) QueryColorCompliance(BorderColor,AllCompliance,&image->border_color,\n    exception);\n  (void) QueryColorCompliance(TransparentColor,AllCompliance,\n    &image->transparent_color,exception);\n  GetTimerInfo(&image->timer);\n  image->cache=AcquirePixelCache(0);\n  image->channel_mask=DefaultChannels;\n  image->channel_map=AcquirePixelChannelMap();\n  image->blob=CloneBlobInfo((BlobInfo *) NULL);\n  image->timestamp=time((time_t *) NULL);\n  image->debug=IsEventLogging();\n  image->reference_count=1;\n  image->semaphore=AcquireSemaphoreInfo();\n  image->signature=MagickCoreSignature;\n  if (image_info == (ImageInfo *) NULL)\n    return(image);\n  /*\n    Transfer image info.\n  */\n  SetBlobExempt(image,image_info->file != (FILE *) NULL ? MagickTrue :\n    MagickFalse);\n  (void) CopyMagickString(image->filename,image_info->filename,\n    MagickPathExtent);\n  (void) CopyMagickString(image->magick_filename,image_info->filename,\n    MagickPathExtent);\n  (void) CopyMagickString(image->magick,image_info->magick,MagickPathExtent);\n  if (image_info->size != (char *) NULL)\n    {\n      (void) ParseAbsoluteGeometry(image_info->size,&image->extract_info);\n      image->columns=image->extract_info.width;\n      image->rows=image->extract_info.height;\n      image->offset=image->extract_info.x;\n      image->extract_info.x=0;\n      image->extract_info.y=0;\n    }\n  if (image_info->extract != (char *) NULL)\n    {\n      RectangleInfo\n        geometry;\n\n      (void) memset(&geometry,0,sizeof(geometry));\n      flags=ParseAbsoluteGeometry(image_info->extract,&geometry);\n      if (((flags & XValue) != 0) || ((flags & YValue) != 0))\n        {\n          image->extract_info=geometry;\n          Swap(image->columns,image->extract_info.width);\n          Swap(image->rows,image->extract_info.height);\n        }\n    }\n  image->compression=image_info->compression;\n  image->quality=image_info->quality;\n  image->endian=image_info->endian;\n  image->interlace=image_info->interlace;\n  image->units=image_info->units;\n  if (image_info->density != (char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      flags=ParseGeometry(image_info->density,&geometry_info);\n      if ((flags & RhoValue) != 0)\n        image->resolution.x=geometry_info.rho;\n      image->resolution.y=image->resolution.x;\n      if ((flags & SigmaValue) != 0)\n        image->resolution.y=geometry_info.sigma;\n    }\n  if (image_info->page != (char *) NULL)\n    {\n      char\n        *geometry;\n\n      image->page=image->extract_info;\n      geometry=GetPageGeometry(image_info->page);\n      (void) ParseAbsoluteGeometry(geometry,&image->page);\n      geometry=DestroyString(geometry);\n    }\n  if (image_info->depth != 0)\n    image->depth=image_info->depth;\n  image->dither=image_info->dither;\n  image->matte_color=image_info->matte_color;\n  image->background_color=image_info->background_color;\n  image->border_color=image_info->border_color;\n  image->transparent_color=image_info->transparent_color;\n  image->ping=image_info->ping;\n  image->progress_monitor=image_info->progress_monitor;\n  image->client_data=image_info->client_data;\n  if (image_info->cache != (void *) NULL)\n    ClonePixelCacheMethods(image->cache,image_info->cache);\n  /*\n    Set all global options that map to per-image settings.\n  */\n  (void) SyncImageSettings(image_info,image,exception);\n  /*\n    Global options that are only set for new images.\n  */\n  option=GetImageOption(image_info,\"delay\");\n  if (option != (const char *) NULL)\n    {\n      GeometryInfo\n        geometry_info;\n\n      flags=ParseGeometry(option,&geometry_info);\n      if ((flags & GreaterValue) != 0)\n        {\n          if (image->delay > (size_t) floor(geometry_info.rho+0.5))\n            image->delay=(size_t) floor(geometry_info.rho+0.5);\n        }\n      else\n        if ((flags & LessValue) != 0)\n          {\n            if (image->delay < (size_t) floor(geometry_info.rho+0.5))\n              image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n          }\n        else\n          image->delay=(size_t) floor(geometry_info.rho+0.5);\n      if ((flags & SigmaValue) != 0)\n        image->ticks_per_second=(ssize_t) floor(geometry_info.sigma+0.5);\n    }\n  option=GetImageOption(image_info,\"dispose\");\n  if (option != (const char *) NULL)\n    image->dispose=(DisposeType) ParseCommandOption(MagickDisposeOptions,\n      MagickFalse,option);\n  return(image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -104,10 +104,11 @@\n         geometry_info;\n \n       flags=ParseGeometry(image_info->density,&geometry_info);\n-      image->resolution.x=geometry_info.rho;\n-      image->resolution.y=geometry_info.sigma;\n-      if ((flags & SigmaValue) == 0)\n-        image->resolution.y=image->resolution.x;\n+      if ((flags & RhoValue) != 0)\n+        image->resolution.x=geometry_info.rho;\n+      image->resolution.y=image->resolution.x;\n+      if ((flags & SigmaValue) != 0)\n+        image->resolution.y=geometry_info.sigma;\n     }\n   if (image_info->page != (char *) NULL)\n     {",
        "diff_line_info": {
            "deleted_lines": [
                "      image->resolution.x=geometry_info.rho;",
                "      image->resolution.y=geometry_info.sigma;",
                "      if ((flags & SigmaValue) == 0)",
                "        image->resolution.y=image->resolution.x;"
            ],
            "added_lines": [
                "      if ((flags & RhoValue) != 0)",
                "        image->resolution.x=geometry_info.rho;",
                "      image->resolution.y=image->resolution.x;",
                "      if ((flags & SigmaValue) != 0)",
                "        image->resolution.y=geometry_info.sigma;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16921",
        "func_name": "torvalds/linux/hns_roce_alloc_ucontext",
        "description": "In the Linux kernel before 4.17, hns_roce_alloc_ucontext in drivers/infiniband/hw/hns/hns_roce_main.c does not initialize the resp data structure, which might allow attackers to obtain sensitive information from kernel stack memory, aka CID-df7e40425813.",
        "git_url": "https://github.com/torvalds/linux/commit/df7e40425813c50cd252e6f5e348a81ef1acae56",
        "commit_title": "RDMA/hns: Fix init resp when alloc ucontext",
        "commit_text": " The data in resp will be copied from kernel to userspace, thus it needs to be initialized to zeros to avoid copying uninited stack memory. ",
        "func_before": "static struct ib_ucontext *hns_roce_alloc_ucontext(struct ib_device *ib_dev,\n\t\t\t\t\t\t   struct ib_udata *udata)\n{\n\tint ret = 0;\n\tstruct hns_roce_ucontext *context;\n\tstruct hns_roce_ib_alloc_ucontext_resp resp;\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);\n\n\tresp.qp_tab_size = hr_dev->caps.num_qps;\n\n\tcontext = kmalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = hns_roce_uar_alloc(hr_dev, &context->uar);\n\tif (ret)\n\t\tgoto error_fail_uar_alloc;\n\n\tif (hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_RECORD_DB) {\n\t\tINIT_LIST_HEAD(&context->page_list);\n\t\tmutex_init(&context->page_mutex);\n\t}\n\n\tret = ib_copy_to_udata(udata, &resp, sizeof(resp));\n\tif (ret)\n\t\tgoto error_fail_copy_to_udata;\n\n\treturn &context->ibucontext;\n\nerror_fail_copy_to_udata:\n\thns_roce_uar_free(hr_dev, &context->uar);\n\nerror_fail_uar_alloc:\n\tkfree(context);\n\n\treturn ERR_PTR(ret);\n}",
        "func": "static struct ib_ucontext *hns_roce_alloc_ucontext(struct ib_device *ib_dev,\n\t\t\t\t\t\t   struct ib_udata *udata)\n{\n\tint ret = 0;\n\tstruct hns_roce_ucontext *context;\n\tstruct hns_roce_ib_alloc_ucontext_resp resp = {};\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);\n\n\tresp.qp_tab_size = hr_dev->caps.num_qps;\n\n\tcontext = kmalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = hns_roce_uar_alloc(hr_dev, &context->uar);\n\tif (ret)\n\t\tgoto error_fail_uar_alloc;\n\n\tif (hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_RECORD_DB) {\n\t\tINIT_LIST_HEAD(&context->page_list);\n\t\tmutex_init(&context->page_mutex);\n\t}\n\n\tret = ib_copy_to_udata(udata, &resp, sizeof(resp));\n\tif (ret)\n\t\tgoto error_fail_copy_to_udata;\n\n\treturn &context->ibucontext;\n\nerror_fail_copy_to_udata:\n\thns_roce_uar_free(hr_dev, &context->uar);\n\nerror_fail_uar_alloc:\n\tkfree(context);\n\n\treturn ERR_PTR(ret);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n {\n \tint ret = 0;\n \tstruct hns_roce_ucontext *context;\n-\tstruct hns_roce_ib_alloc_ucontext_resp resp;\n+\tstruct hns_roce_ib_alloc_ucontext_resp resp = {};\n \tstruct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);\n \n \tresp.qp_tab_size = hr_dev->caps.num_qps;",
        "diff_line_info": {
            "deleted_lines": [
                "\tstruct hns_roce_ib_alloc_ucontext_resp resp;"
            ],
            "added_lines": [
                "\tstruct hns_roce_ib_alloc_ucontext_resp resp = {};"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15681",
        "func_name": "LibVNC/libvncserver/rfbSendServerCutText",
        "description": "LibVNC commit before d01e1bb4246323ba6fcee3b82ef1faa9b1dac82a contains a memory leak (CWE-655) in VNC server code, which allow an attacker to read stack memory and can be abused for information disclosure. Combined with another vulnerability, it can be used to leak stack memory and bypass ASLR. This attack appear to be exploitable via network connectivity. These vulnerabilities have been fixed in commit d01e1bb4246323ba6fcee3b82ef1faa9b1dac82a.",
        "git_url": "https://github.com/LibVNC/libvncserver/commit/d01e1bb4246323ba6fcee3b82ef1faa9b1dac82a",
        "commit_title": "rfbserver: don't leak stack memory to the remote",
        "commit_text": " Thanks go to Pavel Cheremushkin of Kaspersky for reporting.",
        "func_before": "void\nrfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)\n{\n    rfbClientPtr cl;\n    rfbServerCutTextMsg sct;\n    rfbClientIteratorPtr iterator;\n\n    iterator = rfbGetClientIterator(rfbScreen);\n    while ((cl = rfbClientIteratorNext(iterator)) != NULL) {\n        sct.type = rfbServerCutText;\n        sct.length = Swap32IfLE(len);\n        LOCK(cl->sendMutex);\n        if (rfbWriteExact(cl, (char *)&sct,\n                       sz_rfbServerCutTextMsg) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n            UNLOCK(cl->sendMutex);\n            continue;\n        }\n        if (rfbWriteExact(cl, str, len) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n        }\n        UNLOCK(cl->sendMutex);\n        rfbStatRecordMessageSent(cl, rfbServerCutText, sz_rfbServerCutTextMsg+len, sz_rfbServerCutTextMsg+len);\n    }\n    rfbReleaseClientIterator(iterator);\n}",
        "func": "void\nrfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)\n{\n    rfbClientPtr cl;\n    rfbServerCutTextMsg sct;\n    rfbClientIteratorPtr iterator;\n\n    memset((char *)&sct, 0, sizeof(sct));\n\n    iterator = rfbGetClientIterator(rfbScreen);\n    while ((cl = rfbClientIteratorNext(iterator)) != NULL) {\n        sct.type = rfbServerCutText;\n        sct.length = Swap32IfLE(len);\n        LOCK(cl->sendMutex);\n        if (rfbWriteExact(cl, (char *)&sct,\n                       sz_rfbServerCutTextMsg) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n            UNLOCK(cl->sendMutex);\n            continue;\n        }\n        if (rfbWriteExact(cl, str, len) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n        }\n        UNLOCK(cl->sendMutex);\n        rfbStatRecordMessageSent(cl, rfbServerCutText, sz_rfbServerCutTextMsg+len, sz_rfbServerCutTextMsg+len);\n    }\n    rfbReleaseClientIterator(iterator);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,8 @@\n     rfbClientPtr cl;\n     rfbServerCutTextMsg sct;\n     rfbClientIteratorPtr iterator;\n+\n+    memset((char *)&sct, 0, sizeof(sct));\n \n     iterator = rfbGetClientIterator(rfbScreen);\n     while ((cl = rfbClientIteratorNext(iterator)) != NULL) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    memset((char *)&sct, 0, sizeof(sct));"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-4087",
        "func_name": "torvalds/linux/br_parse_ip_options",
        "description": "The br_parse_ip_options function in net/bridge/br_netfilter.c in the Linux kernel before 2.6.39 does not properly initialize a certain data structure, which allows remote attackers to cause a denial of service by leveraging connectivity to a network interface that uses an Ethernet bridge device.",
        "git_url": "https://github.com/torvalds/linux/commit/f8e9881c2aef1e982e5abc25c046820cd0b7cf64",
        "commit_title": "bridge: reset IPCB in br_parse_ip_options",
        "commit_text": " Commit 462fb2af9788a82 (bridge : Sanitize skb before it enters the IP stack), missed one IPCB init before calling ip_options_compile()  Thanks to Scot Doyle for his tests and bug reports.  Cc: Hiroaki SHIMODA <shimoda.hiroaki@gmail.com> Cc: Jan Lbbe <jluebbe@debian.org>",
        "func_before": "static int br_parse_ip_options(struct sk_buff *skb)\n{\n\tstruct ip_options *opt;\n\tstruct iphdr *iph;\n\tstruct net_device *dev = skb->dev;\n\tu32 len;\n\n\tiph = ip_hdr(skb);\n\topt = &(IPCB(skb)->opt);\n\n\t/* Basic sanity checks */\n\tif (iph->ihl < 5 || iph->version != 4)\n\t\tgoto inhdr_error;\n\n\tif (!pskb_may_pull(skb, iph->ihl*4))\n\t\tgoto inhdr_error;\n\n\tiph = ip_hdr(skb);\n\tif (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))\n\t\tgoto inhdr_error;\n\n\tlen = ntohs(iph->tot_len);\n\tif (skb->len < len) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INTRUNCATEDPKTS);\n\t\tgoto drop;\n\t} else if (len < (iph->ihl*4))\n\t\tgoto inhdr_error;\n\n\tif (pskb_trim_rcsum(skb, len)) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\n\t/* Zero out the CB buffer if no options present */\n\tif (iph->ihl == 5) {\n\t\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\n\t\treturn 0;\n\t}\n\n\topt->optlen = iph->ihl*4 - sizeof(struct iphdr);\n\tif (ip_options_compile(dev_net(dev), opt, skb))\n\t\tgoto inhdr_error;\n\n\t/* Check correct handling of SRR option */\n\tif (unlikely(opt->srr)) {\n\t\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\t\tif (in_dev && !IN_DEV_SOURCE_ROUTE(in_dev))\n\t\t\tgoto drop;\n\n\t\tif (ip_options_rcv_srr(skb))\n\t\t\tgoto drop;\n\t}\n\n\treturn 0;\n\ninhdr_error:\n\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INHDRERRORS);\ndrop:\n\treturn -1;\n}",
        "func": "static int br_parse_ip_options(struct sk_buff *skb)\n{\n\tstruct ip_options *opt;\n\tstruct iphdr *iph;\n\tstruct net_device *dev = skb->dev;\n\tu32 len;\n\n\tiph = ip_hdr(skb);\n\topt = &(IPCB(skb)->opt);\n\n\t/* Basic sanity checks */\n\tif (iph->ihl < 5 || iph->version != 4)\n\t\tgoto inhdr_error;\n\n\tif (!pskb_may_pull(skb, iph->ihl*4))\n\t\tgoto inhdr_error;\n\n\tiph = ip_hdr(skb);\n\tif (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))\n\t\tgoto inhdr_error;\n\n\tlen = ntohs(iph->tot_len);\n\tif (skb->len < len) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INTRUNCATEDPKTS);\n\t\tgoto drop;\n\t} else if (len < (iph->ihl*4))\n\t\tgoto inhdr_error;\n\n\tif (pskb_trim_rcsum(skb, len)) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\n\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\n\tif (iph->ihl == 5)\n\t\treturn 0;\n\n\topt->optlen = iph->ihl*4 - sizeof(struct iphdr);\n\tif (ip_options_compile(dev_net(dev), opt, skb))\n\t\tgoto inhdr_error;\n\n\t/* Check correct handling of SRR option */\n\tif (unlikely(opt->srr)) {\n\t\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\t\tif (in_dev && !IN_DEV_SOURCE_ROUTE(in_dev))\n\t\t\tgoto drop;\n\n\t\tif (ip_options_rcv_srr(skb))\n\t\t\tgoto drop;\n\t}\n\n\treturn 0;\n\ninhdr_error:\n\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INHDRERRORS);\ndrop:\n\treturn -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,11 +31,9 @@\n \t\tgoto drop;\n \t}\n \n-\t/* Zero out the CB buffer if no options present */\n-\tif (iph->ihl == 5) {\n-\t\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\n+\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\n+\tif (iph->ihl == 5)\n \t\treturn 0;\n-\t}\n \n \topt->optlen = iph->ihl*4 - sizeof(struct iphdr);\n \tif (ip_options_compile(dev_net(dev), opt, skb))",
        "diff_line_info": {
            "deleted_lines": [
                "\t/* Zero out the CB buffer if no options present */",
                "\tif (iph->ihl == 5) {",
                "\t\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));",
                "\t}"
            ],
            "added_lines": [
                "\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));",
                "\tif (iph->ihl == 5)"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-37479",
        "func_name": "openenclave/_handle_oret",
        "description": "Open Enclave is a hardware-agnostic open source library for developing applications that utilize Hardware-based Trusted Execution Environments, also known as Enclaves. There are two issues that are mitigated in version 0.19.3. First, Open Enclave SDK does not properly sanitize the `MXCSR` register on enclave entry. This makes applications vulnerable to MXCSR Configuration Dependent Timing (MCDT) attacks, where incorrect `MXCSR` values can impact instruction retirement by at most one cycle, depending on the (secret) data operand value. Please find more details in the guidance from Intel in the references. Second, Open Enclave SDK does not sanitize x86's alignment check flag `RFLAGS.AC` on enclave entry. This opens up the possibility for a side-channel attacker to be notified for every unaligned memory access performed by the enclave. The issue has been addressed in version 0.19.3 and the current master branch. Users will need to recompile their applications against the patched libraries to be protected from this vulnerability. There are no known workarounds for this vulnerability.",
        "git_url": "https://github.com/openenclave/openenclave/commit/ca54623333875b9beaad92c999a92b015c44b079",
        "commit_title": "Security fix for AC flag poisoning and MCDT",
        "commit_text": " This PR does the following - Ensuring the AC flag along with other system/control flags are always cleared upon enclave enter - Update the inital MXCSR value to 0x1FBF and put lfence after MXCSR load (via LDMXCSR, XRSTOR, or FXRSTOR)   for the MCDT mitigation ",
        "func_before": "OE_INLINE void _handle_oret(\n    oe_sgx_td_t* td,\n    uint16_t func,\n    uint16_t result,\n    uint64_t arg)\n{\n    oe_callsite_t* callsite = td->callsites;\n\n    if (!callsite)\n        return;\n\n    td->oret_func = func;\n    td->oret_result = result;\n    td->oret_arg = arg;\n\n    /* Restore the FXSTATE and flags */\n    asm volatile(\"pushq %[rflags] \\n\\t\" // Restore flags.\n                 \"popfq \\n\\t\"\n                 \"fldcw %[fcw] \\n\\t\"     // Restore x87 control word\n                 \"ldmxcsr %[mxcsr] \\n\\t\" // Restore MXCSR\n                 : [mxcsr] \"=m\"(callsite->mxcsr),\n                   [fcw] \"=m\"(callsite->fcw),\n                   [rflags] \"=m\"(callsite->rflags)\n                 :\n                 : \"cc\");\n\n    oe_longjmp(&callsite->jmpbuf, 1);\n}",
        "func": "OE_INLINE void _handle_oret(\n    oe_sgx_td_t* td,\n    uint16_t func,\n    uint16_t result,\n    uint64_t arg)\n{\n    oe_callsite_t* callsite = td->callsites;\n\n    if (!callsite)\n        return;\n\n    td->oret_func = func;\n    td->oret_result = result;\n    td->oret_arg = arg;\n\n    /* Restore the FXSTATE and flags */\n    asm volatile(\n        \"pushq %[rflags] \\n\\t\" // Restore flags.\n        \"popfq \\n\\t\"\n        \"fldcw %[fcw] \\n\\t\"     // Restore x87 control word\n        \"ldmxcsr %[mxcsr] \\n\\t\" // Restore MXCSR\n        \"lfence \\n\\t\" // MXCSR Configuration Dependent Timing (MCDT) mitigation\n        : [mxcsr] \"=m\"(callsite->mxcsr),\n          [fcw] \"=m\"(callsite->fcw),\n          [rflags] \"=m\"(callsite->rflags)\n        :\n        : \"cc\");\n\n    oe_longjmp(&callsite->jmpbuf, 1);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,15 +14,17 @@\n     td->oret_arg = arg;\n \n     /* Restore the FXSTATE and flags */\n-    asm volatile(\"pushq %[rflags] \\n\\t\" // Restore flags.\n-                 \"popfq \\n\\t\"\n-                 \"fldcw %[fcw] \\n\\t\"     // Restore x87 control word\n-                 \"ldmxcsr %[mxcsr] \\n\\t\" // Restore MXCSR\n-                 : [mxcsr] \"=m\"(callsite->mxcsr),\n-                   [fcw] \"=m\"(callsite->fcw),\n-                   [rflags] \"=m\"(callsite->rflags)\n-                 :\n-                 : \"cc\");\n+    asm volatile(\n+        \"pushq %[rflags] \\n\\t\" // Restore flags.\n+        \"popfq \\n\\t\"\n+        \"fldcw %[fcw] \\n\\t\"     // Restore x87 control word\n+        \"ldmxcsr %[mxcsr] \\n\\t\" // Restore MXCSR\n+        \"lfence \\n\\t\" // MXCSR Configuration Dependent Timing (MCDT) mitigation\n+        : [mxcsr] \"=m\"(callsite->mxcsr),\n+          [fcw] \"=m\"(callsite->fcw),\n+          [rflags] \"=m\"(callsite->rflags)\n+        :\n+        : \"cc\");\n \n     oe_longjmp(&callsite->jmpbuf, 1);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    asm volatile(\"pushq %[rflags] \\n\\t\" // Restore flags.",
                "                 \"popfq \\n\\t\"",
                "                 \"fldcw %[fcw] \\n\\t\"     // Restore x87 control word",
                "                 \"ldmxcsr %[mxcsr] \\n\\t\" // Restore MXCSR",
                "                 : [mxcsr] \"=m\"(callsite->mxcsr),",
                "                   [fcw] \"=m\"(callsite->fcw),",
                "                   [rflags] \"=m\"(callsite->rflags)",
                "                 :",
                "                 : \"cc\");"
            ],
            "added_lines": [
                "    asm volatile(",
                "        \"pushq %[rflags] \\n\\t\" // Restore flags.",
                "        \"popfq \\n\\t\"",
                "        \"fldcw %[fcw] \\n\\t\"     // Restore x87 control word",
                "        \"ldmxcsr %[mxcsr] \\n\\t\" // Restore MXCSR",
                "        \"lfence \\n\\t\" // MXCSR Configuration Dependent Timing (MCDT) mitigation",
                "        : [mxcsr] \"=m\"(callsite->mxcsr),",
                "          [fcw] \"=m\"(callsite->fcw),",
                "          [rflags] \"=m\"(callsite->rflags)",
                "        :",
                "        : \"cc\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-20317",
        "func_name": "kernel/git/tip/tip/timerqueue_getnext",
        "description": "A flaw was found in the Linux kernel. A corrupted timer tree caused the task wakeup to be missing in the timerqueue_add function in lib/timerqueue.c. This flaw allows a local attacker with special user privileges to cause a denial of service, slowing and eventually stopping the system while running OSP.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git/commit/?h=511885d7061eda3eb1faf3f57dcc936ff75863f1",
        "commit_title": "Simplify the timerqueue code by using cached rbtrees and rely on the tree",
        "commit_text": "leftmost node semantics to get the timer with earliest expiration time. This is a drop in conversion, and therefore semantics remain untouched.  The runtime overhead of cached rbtrees is be pretty much the same as the current head->next method, noting that when removing the leftmost node, a common operation for the timerqueue, the rb_next(leftmost) is O(1) as well, so the next timer will either be the right node or its parent. Therefore no extra pointer chasing. Finally, the size of the struct timerqueue_head remains the same.  Passes several hours of rcutorture.  Link: https://lkml.kernel.org/r/20190724152323.bojciei3muvfxalm@linux-r8p5 ",
        "func_before": "static inline\nstruct timerqueue_node *timerqueue_getnext(struct timerqueue_head *head)\n{\n\treturn head->next;\n}",
        "func": "static inline\nstruct timerqueue_node *timerqueue_getnext(struct timerqueue_head *head)\n{\n\tstruct rb_node *leftmost = rb_first_cached(&head->rb_root);\n\n\treturn rb_entry(leftmost, struct timerqueue_node, node);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,7 @@\n static inline\n struct timerqueue_node *timerqueue_getnext(struct timerqueue_head *head)\n {\n-\treturn head->next;\n+\tstruct rb_node *leftmost = rb_first_cached(&head->rb_root);\n+\n+\treturn rb_entry(leftmost, struct timerqueue_node, node);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn head->next;"
            ],
            "added_lines": [
                "\tstruct rb_node *leftmost = rb_first_cached(&head->rb_root);",
                "",
                "\treturn rb_entry(leftmost, struct timerqueue_node, node);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-20317",
        "func_name": "kernel/git/tip/tip/timerqueue_init_head",
        "description": "A flaw was found in the Linux kernel. A corrupted timer tree caused the task wakeup to be missing in the timerqueue_add function in lib/timerqueue.c. This flaw allows a local attacker with special user privileges to cause a denial of service, slowing and eventually stopping the system while running OSP.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git/commit/?h=511885d7061eda3eb1faf3f57dcc936ff75863f1",
        "commit_title": "Simplify the timerqueue code by using cached rbtrees and rely on the tree",
        "commit_text": "leftmost node semantics to get the timer with earliest expiration time. This is a drop in conversion, and therefore semantics remain untouched.  The runtime overhead of cached rbtrees is be pretty much the same as the current head->next method, noting that when removing the leftmost node, a common operation for the timerqueue, the rb_next(leftmost) is O(1) as well, so the next timer will either be the right node or its parent. Therefore no extra pointer chasing. Finally, the size of the struct timerqueue_head remains the same.  Passes several hours of rcutorture.  Link: https://lkml.kernel.org/r/20190724152323.bojciei3muvfxalm@linux-r8p5 ",
        "func_before": "static inline void timerqueue_init_head(struct timerqueue_head *head)\n{\n\thead->head = RB_ROOT;\n\thead->next = NULL;\n}",
        "func": "static inline void timerqueue_init_head(struct timerqueue_head *head)\n{\n\thead->rb_root = RB_ROOT_CACHED;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,4 @@\n static inline void timerqueue_init_head(struct timerqueue_head *head)\n {\n-\thead->head = RB_ROOT;\n-\thead->next = NULL;\n+\thead->rb_root = RB_ROOT_CACHED;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\thead->head = RB_ROOT;",
                "\thead->next = NULL;"
            ],
            "added_lines": [
                "\thead->rb_root = RB_ROOT_CACHED;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-20317",
        "func_name": "kernel/git/tip/tip/timerqueue_add",
        "description": "A flaw was found in the Linux kernel. A corrupted timer tree caused the task wakeup to be missing in the timerqueue_add function in lib/timerqueue.c. This flaw allows a local attacker with special user privileges to cause a denial of service, slowing and eventually stopping the system while running OSP.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git/commit/?h=511885d7061eda3eb1faf3f57dcc936ff75863f1",
        "commit_title": "Simplify the timerqueue code by using cached rbtrees and rely on the tree",
        "commit_text": "leftmost node semantics to get the timer with earliest expiration time. This is a drop in conversion, and therefore semantics remain untouched.  The runtime overhead of cached rbtrees is be pretty much the same as the current head->next method, noting that when removing the leftmost node, a common operation for the timerqueue, the rb_next(leftmost) is O(1) as well, so the next timer will either be the right node or its parent. Therefore no extra pointer chasing. Finally, the size of the struct timerqueue_head remains the same.  Passes several hours of rcutorture.  Link: https://lkml.kernel.org/r/20190724152323.bojciei3muvfxalm@linux-r8p5 ",
        "func_before": "bool timerqueue_add(struct timerqueue_head *head, struct timerqueue_node *node)\n{\n\tstruct rb_node **p = &head->head.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct timerqueue_node  *ptr;\n\n\t/* Make sure we don't add nodes that are already added */\n\tWARN_ON_ONCE(!RB_EMPTY_NODE(&node->node));\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tptr = rb_entry(parent, struct timerqueue_node, node);\n\t\tif (node->expires < ptr->expires)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\trb_link_node(&node->node, parent, p);\n\trb_insert_color(&node->node, &head->head);\n\n\tif (!head->next || node->expires < head->next->expires) {\n\t\thead->next = node;\n\t\treturn true;\n\t}\n\treturn false;\n}",
        "func": "bool timerqueue_add(struct timerqueue_head *head, struct timerqueue_node *node)\n{\n\tstruct rb_node **p = &head->rb_root.rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct timerqueue_node *ptr;\n\tbool leftmost = true;\n\n\t/* Make sure we don't add nodes that are already added */\n\tWARN_ON_ONCE(!RB_EMPTY_NODE(&node->node));\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tptr = rb_entry(parent, struct timerqueue_node, node);\n\t\tif (node->expires < ptr->expires) {\n\t\t\tp = &(*p)->rb_left;\n\t\t} else {\n\t\t\tp = &(*p)->rb_right;\n\t\t\tleftmost = false;\n\t\t}\n\t}\n\trb_link_node(&node->node, parent, p);\n\trb_insert_color_cached(&node->node, &head->rb_root, leftmost);\n\n\treturn leftmost;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,9 @@\n bool timerqueue_add(struct timerqueue_head *head, struct timerqueue_node *node)\n {\n-\tstruct rb_node **p = &head->head.rb_node;\n+\tstruct rb_node **p = &head->rb_root.rb_root.rb_node;\n \tstruct rb_node *parent = NULL;\n-\tstruct timerqueue_node  *ptr;\n+\tstruct timerqueue_node *ptr;\n+\tbool leftmost = true;\n \n \t/* Make sure we don't add nodes that are already added */\n \tWARN_ON_ONCE(!RB_EMPTY_NODE(&node->node));\n@@ -10,17 +11,15 @@\n \twhile (*p) {\n \t\tparent = *p;\n \t\tptr = rb_entry(parent, struct timerqueue_node, node);\n-\t\tif (node->expires < ptr->expires)\n+\t\tif (node->expires < ptr->expires) {\n \t\t\tp = &(*p)->rb_left;\n-\t\telse\n+\t\t} else {\n \t\t\tp = &(*p)->rb_right;\n+\t\t\tleftmost = false;\n+\t\t}\n \t}\n \trb_link_node(&node->node, parent, p);\n-\trb_insert_color(&node->node, &head->head);\n+\trb_insert_color_cached(&node->node, &head->rb_root, leftmost);\n \n-\tif (!head->next || node->expires < head->next->expires) {\n-\t\thead->next = node;\n-\t\treturn true;\n-\t}\n-\treturn false;\n+\treturn leftmost;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tstruct rb_node **p = &head->head.rb_node;",
                "\tstruct timerqueue_node  *ptr;",
                "\t\tif (node->expires < ptr->expires)",
                "\t\telse",
                "\trb_insert_color(&node->node, &head->head);",
                "\tif (!head->next || node->expires < head->next->expires) {",
                "\t\thead->next = node;",
                "\t\treturn true;",
                "\t}",
                "\treturn false;"
            ],
            "added_lines": [
                "\tstruct rb_node **p = &head->rb_root.rb_root.rb_node;",
                "\tstruct timerqueue_node *ptr;",
                "\tbool leftmost = true;",
                "\t\tif (node->expires < ptr->expires) {",
                "\t\t} else {",
                "\t\t\tleftmost = false;",
                "\t\t}",
                "\trb_insert_color_cached(&node->node, &head->rb_root, leftmost);",
                "\treturn leftmost;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-20317",
        "func_name": "kernel/git/tip/tip/timerqueue_del",
        "description": "A flaw was found in the Linux kernel. A corrupted timer tree caused the task wakeup to be missing in the timerqueue_add function in lib/timerqueue.c. This flaw allows a local attacker with special user privileges to cause a denial of service, slowing and eventually stopping the system while running OSP.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git/commit/?h=511885d7061eda3eb1faf3f57dcc936ff75863f1",
        "commit_title": "Simplify the timerqueue code by using cached rbtrees and rely on the tree",
        "commit_text": "leftmost node semantics to get the timer with earliest expiration time. This is a drop in conversion, and therefore semantics remain untouched.  The runtime overhead of cached rbtrees is be pretty much the same as the current head->next method, noting that when removing the leftmost node, a common operation for the timerqueue, the rb_next(leftmost) is O(1) as well, so the next timer will either be the right node or its parent. Therefore no extra pointer chasing. Finally, the size of the struct timerqueue_head remains the same.  Passes several hours of rcutorture.  Link: https://lkml.kernel.org/r/20190724152323.bojciei3muvfxalm@linux-r8p5 ",
        "func_before": "bool timerqueue_del(struct timerqueue_head *head, struct timerqueue_node *node)\n{\n\tWARN_ON_ONCE(RB_EMPTY_NODE(&node->node));\n\n\t/* update next pointer */\n\tif (head->next == node) {\n\t\tstruct rb_node *rbn = rb_next(&node->node);\n\n\t\thead->next = rb_entry_safe(rbn, struct timerqueue_node, node);\n\t}\n\trb_erase(&node->node, &head->head);\n\tRB_CLEAR_NODE(&node->node);\n\treturn head->next != NULL;\n}",
        "func": "bool timerqueue_del(struct timerqueue_head *head, struct timerqueue_node *node)\n{\n\tWARN_ON_ONCE(RB_EMPTY_NODE(&node->node));\n\n\trb_erase_cached(&node->node, &head->rb_root);\n\tRB_CLEAR_NODE(&node->node);\n\n\treturn !RB_EMPTY_ROOT(&head->rb_root.rb_root);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,13 +2,8 @@\n {\n \tWARN_ON_ONCE(RB_EMPTY_NODE(&node->node));\n \n-\t/* update next pointer */\n-\tif (head->next == node) {\n-\t\tstruct rb_node *rbn = rb_next(&node->node);\n+\trb_erase_cached(&node->node, &head->rb_root);\n+\tRB_CLEAR_NODE(&node->node);\n \n-\t\thead->next = rb_entry_safe(rbn, struct timerqueue_node, node);\n-\t}\n-\trb_erase(&node->node, &head->head);\n-\tRB_CLEAR_NODE(&node->node);\n-\treturn head->next != NULL;\n+\treturn !RB_EMPTY_ROOT(&head->rb_root.rb_root);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t/* update next pointer */",
                "\tif (head->next == node) {",
                "\t\tstruct rb_node *rbn = rb_next(&node->node);",
                "\t\thead->next = rb_entry_safe(rbn, struct timerqueue_node, node);",
                "\t}",
                "\trb_erase(&node->node, &head->head);",
                "\tRB_CLEAR_NODE(&node->node);",
                "\treturn head->next != NULL;"
            ],
            "added_lines": [
                "\trb_erase_cached(&node->node, &head->rb_root);",
                "\tRB_CLEAR_NODE(&node->node);",
                "\treturn !RB_EMPTY_ROOT(&head->rb_root.rb_root);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1122",
        "func_name": "uclouvain/openjpeg/main",
        "description": "A flaw was found in the opj2_decompress program in openjpeg2 2.4.0 in the way it handles an input directory with a large number of files. When it fails to allocate a buffer to store the filenames of the input directory, it calls free() on an uninitialized pointer, leading to a segmentation fault and a denial of service.",
        "git_url": "https://github.com/uclouvain/openjpeg/commit/5383e8d1e614cb4782a101999e80762e8e9b9b24",
        "commit_title": "wqfix issues 1368:exist a issues of freeing uninitialized pointer in src/bin/jp2/opj_decompress.cthat will cause a segfault",
        "commit_text": "",
        "func_before": "int main(int argc, char **argv)\n{\n    opj_decompress_parameters parameters;           /* decompression parameters */\n\n    OPJ_INT32 num_images, imageno;\n    img_fol_t img_fol;\n    dircnt_t *dirptr = NULL;\n    int failed = 0;\n    OPJ_FLOAT64 t, tCumulative = 0;\n    OPJ_UINT32 numDecompressedImages = 0;\n    OPJ_UINT32 cp_reduce;\n\n    /* set decoding parameters to default values */\n    set_default_parameters(&parameters);\n\n    /* Initialize img_fol */\n    memset(&img_fol, 0, sizeof(img_fol_t));\n\n    /* parse input and get user encoding parameters */\n    if (parse_cmdline_decoder(argc, argv, &parameters, &img_fol) == 1) {\n        failed = 1;\n        goto fin;\n    }\n\n    cp_reduce = parameters.core.cp_reduce;\n    if (getenv(\"USE_OPJ_SET_DECODED_RESOLUTION_FACTOR\") != NULL) {\n        /* For debugging/testing purposes, do not set the cp_reduce member */\n        /* if USE_OPJ_SET_DECODED_RESOLUTION_FACTOR is defined, but used */\n        /* the opj_set_decoded_resolution_factor() API instead */\n        parameters.core.cp_reduce = 0;\n    }\n\n\n    /* Initialize reading of directory */\n    if (img_fol.set_imgdir == 1) {\n        int it_image;\n        num_images = get_num_images(img_fol.imgdirpath);\n\n        dirptr = (dircnt_t*)calloc(1, sizeof(dircnt_t));\n        if (!dirptr) {\n            destroy_parameters(&parameters);\n            return EXIT_FAILURE;\n        }\n\n        memset(dirptr, 0, sizeof(dircnt_t));\n\n        /* Stores at max 10 image file names */\n        dirptr->filename_buf = (char*)malloc(sizeof(char) *\n                                             (size_t)num_images * OPJ_PATH_LEN);\n        if (!dirptr->filename_buf) {\n            failed = 1;\n            goto fin;\n        }\n\n        dirptr->filename = (char**) malloc((size_t)num_images * sizeof(char*));\n\n        if (!dirptr->filename) {\n            failed = 1;\n            goto fin;\n        }\n        for (it_image = 0; it_image < num_images; it_image++) {\n            dirptr->filename[it_image] = dirptr->filename_buf + it_image * OPJ_PATH_LEN;\n        }\n\n        if (load_images(dirptr, img_fol.imgdirpath) == 1) {\n            failed = 1;\n            goto fin;\n        }\n        if (num_images == 0) {\n            fprintf(stderr, \"Folder is empty\\n\");\n            failed = 1;\n            goto fin;\n        }\n    } else {\n        num_images = 1;\n    }\n\n    /*Decoding image one by one*/\n    for (imageno = 0; imageno < num_images ; imageno++)  {\n        opj_image_t* image = NULL;\n        opj_stream_t *l_stream = NULL;              /* Stream */\n        opj_codec_t* l_codec = NULL;                /* Handle to a decompressor */\n        opj_codestream_index_t* cstr_index = NULL;\n\n        if (!parameters.quiet) {\n            fprintf(stderr, \"\\n\");\n        }\n\n        if (img_fol.set_imgdir == 1) {\n            if (get_next_file(imageno, dirptr, &img_fol, &parameters)) {\n                fprintf(stderr, \"skipping file...\\n\");\n                destroy_parameters(&parameters);\n                continue;\n            }\n        }\n\n        /* read the input file and put it in memory */\n        /* ---------------------------------------- */\n\n        l_stream = opj_stream_create_default_file_stream(parameters.infile, 1);\n        if (!l_stream) {\n            fprintf(stderr, \"ERROR -> failed to create the stream from the file %s\\n\",\n                    parameters.infile);\n            failed = 1;\n            goto fin;\n        }\n\n        /* decode the JPEG2000 stream */\n        /* ---------------------- */\n\n        switch (parameters.decod_format) {\n        case J2K_CFMT: { /* JPEG-2000 codestream */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_J2K);\n            break;\n        }\n        case JP2_CFMT: { /* JPEG 2000 compressed image data */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_JP2);\n            break;\n        }\n        case JPT_CFMT: { /* JPEG 2000, JPIP */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_JPT);\n            break;\n        }\n        default:\n            fprintf(stderr, \"skipping file..\\n\");\n            destroy_parameters(&parameters);\n            opj_stream_destroy(l_stream);\n            continue;\n        }\n\n        if (parameters.quiet) {\n            /* Set all callbacks to quiet */\n            opj_set_info_handler(l_codec, quiet_callback, 00);\n            opj_set_warning_handler(l_codec, quiet_callback, 00);\n            opj_set_error_handler(l_codec, quiet_callback, 00);\n        } else {\n            /* catch events using our callbacks and give a local context */\n            opj_set_info_handler(l_codec, info_callback, 00);\n            opj_set_warning_handler(l_codec, warning_callback, 00);\n            opj_set_error_handler(l_codec, error_callback, 00);\n        }\n\n\n        t = opj_clock();\n\n        /* Setup the decoder decoding parameters using user parameters */\n        if (!opj_setup_decoder(l_codec, &(parameters.core))) {\n            fprintf(stderr, \"ERROR -> opj_decompress: failed to setup the decoder\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            failed = 1;\n            goto fin;\n        }\n\n        if (parameters.num_threads >= 1 &&\n                !opj_codec_set_threads(l_codec, parameters.num_threads)) {\n            fprintf(stderr, \"ERROR -> opj_decompress: failed to set number of threads\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            failed = 1;\n            goto fin;\n        }\n\n        /* Read the main header of the codestream and if necessary the JP2 boxes*/\n        if (! opj_read_header(l_stream, l_codec, &image)) {\n            fprintf(stderr, \"ERROR -> opj_decompress: failed to read the header\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            opj_image_destroy(image);\n            failed = 1;\n            goto fin;\n        }\n\n        if (parameters.numcomps) {\n            if (! opj_set_decoded_components(l_codec,\n                                             parameters.numcomps,\n                                             parameters.comps_indices,\n                                             OPJ_FALSE)) {\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: failed to set the component indices!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        if (getenv(\"USE_OPJ_SET_DECODED_RESOLUTION_FACTOR\") != NULL) {\n            /* For debugging/testing purposes, and also an illustration on how to */\n            /* use the alternative API opj_set_decoded_resolution_factor() instead */\n            /* of setting parameters.cp_reduce */\n            if (! opj_set_decoded_resolution_factor(l_codec, cp_reduce)) {\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: failed to set the resolution factor tile!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        if (!parameters.nb_tile_to_decode) {\n            if (getenv(\"SKIP_OPJ_SET_DECODE_AREA\") != NULL &&\n                    parameters.DA_x0 == 0 &&\n                    parameters.DA_y0 == 0 &&\n                    parameters.DA_x1 == 0 &&\n                    parameters.DA_y1 == 0) {\n                /* For debugging/testing purposes, */\n                /* do nothing if SKIP_OPJ_SET_DECODE_AREA env variable */\n                /* is defined and no decoded area has been set */\n            }\n            /* Optional if you want decode the entire image */\n            else if (!opj_set_decode_area(l_codec, image, (OPJ_INT32)parameters.DA_x0,\n                                          (OPJ_INT32)parameters.DA_y0, (OPJ_INT32)parameters.DA_x1,\n                                          (OPJ_INT32)parameters.DA_y1)) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to set the decoded area\\n\");\n                opj_stream_destroy(l_stream);\n                opj_destroy_codec(l_codec);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n\n            /* Get the decoded image */\n            if (!(opj_decode(l_codec, l_stream, image) &&\n                    opj_end_decompress(l_codec,   l_stream))) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to decode image!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n        } else {\n            if (!(parameters.DA_x0 == 0 &&\n                    parameters.DA_y0 == 0 &&\n                    parameters.DA_x1 == 0 &&\n                    parameters.DA_y1 == 0)) {\n                if (!(parameters.quiet)) {\n                    fprintf(stderr, \"WARNING: -d option ignored when used together with -t\\n\");\n                }\n            }\n\n            if (!opj_get_decoded_tile(l_codec, l_stream, image, parameters.tile_index)) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to decode tile!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n            if (!(parameters.quiet)) {\n                fprintf(stdout, \"tile %d is decoded!\\n\\n\", parameters.tile_index);\n            }\n        }\n\n        tCumulative += opj_clock() - t;\n        numDecompressedImages++;\n\n        /* Close the byte stream */\n        opj_stream_destroy(l_stream);\n\n        if (image->color_space != OPJ_CLRSPC_SYCC\n                && image->numcomps == 3 && image->comps[0].dx == image->comps[0].dy\n                && image->comps[1].dx != 1) {\n            image->color_space = OPJ_CLRSPC_SYCC;\n        } else if (image->numcomps <= 2) {\n            image->color_space = OPJ_CLRSPC_GRAY;\n        }\n\n        if (image->color_space == OPJ_CLRSPC_SYCC) {\n            color_sycc_to_rgb(image);\n        } else if ((image->color_space == OPJ_CLRSPC_CMYK) &&\n                   (parameters.cod_format != TIF_DFMT)) {\n            color_cmyk_to_rgb(image);\n        } else if (image->color_space == OPJ_CLRSPC_EYCC) {\n            color_esycc_to_rgb(image);\n        }\n\n        if (image->icc_profile_buf) {\n#if defined(OPJ_HAVE_LIBLCMS1) || defined(OPJ_HAVE_LIBLCMS2)\n            if (image->icc_profile_len) {\n                color_apply_icc_profile(image);\n            } else {\n                color_cielab_to_rgb(image);\n            }\n#endif\n            free(image->icc_profile_buf);\n            image->icc_profile_buf = NULL;\n            image->icc_profile_len = 0;\n        }\n\n        /* Force output precision */\n        /* ---------------------- */\n        if (parameters.precision != NULL) {\n            OPJ_UINT32 compno;\n            for (compno = 0; compno < image->numcomps; ++compno) {\n                OPJ_UINT32 precno = compno;\n                OPJ_UINT32 prec;\n\n                if (precno >= parameters.nb_precision) {\n                    precno = parameters.nb_precision - 1U;\n                }\n\n                prec = parameters.precision[precno].prec;\n                if (prec == 0) {\n                    prec = image->comps[compno].prec;\n                }\n\n                switch (parameters.precision[precno].mode) {\n                case OPJ_PREC_MODE_CLIP:\n                    clip_component(&(image->comps[compno]), prec);\n                    break;\n                case OPJ_PREC_MODE_SCALE:\n                    scale_component(&(image->comps[compno]), prec);\n                    break;\n                default:\n                    break;\n                }\n\n            }\n        }\n\n        /* Upsample components */\n        /* ------------------- */\n        if (parameters.upsample) {\n            image = upsample_image_components(image);\n            if (image == NULL) {\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: failed to upsample image components!\\n\");\n                opj_destroy_codec(l_codec);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        /* Force RGB output */\n        /* ---------------- */\n        if (parameters.force_rgb) {\n            switch (image->color_space) {\n            case OPJ_CLRSPC_SRGB:\n                break;\n            case OPJ_CLRSPC_GRAY:\n                image = convert_gray_to_rgb(image);\n                break;\n            default:\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: don't know how to convert image to RGB colorspace!\\n\");\n                opj_image_destroy(image);\n                image = NULL;\n                break;\n            }\n            if (image == NULL) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to convert to RGB image!\\n\");\n                opj_destroy_codec(l_codec);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        /* create output image */\n        /* ------------------- */\n        switch (parameters.cod_format) {\n        case PXM_DFMT:          /* PNM PGM PPM */\n            if (imagetopnm(image, parameters.outfile, parameters.split_pnm)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case PGX_DFMT:          /* PGX */\n            if (imagetopgx(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case BMP_DFMT:          /* BMP */\n            if (imagetobmp(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#ifdef OPJ_HAVE_LIBTIFF\n        case TIF_DFMT:          /* TIF(F) */\n            if (imagetotif(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#endif /* OPJ_HAVE_LIBTIFF */\n        case RAW_DFMT:          /* RAW */\n            if (imagetoraw(image, parameters.outfile)) {\n                fprintf(stderr,\n                        \"[ERROR] Error generating raw or yuv file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case RAWL_DFMT:         /* RAWL */\n            if (imagetorawl(image, parameters.outfile)) {\n                fprintf(stderr,\n                        \"[ERROR] Error generating rawl file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case TGA_DFMT:          /* TGA */\n            if (imagetotga(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Error generating tga file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#ifdef OPJ_HAVE_LIBPNG\n        case PNG_DFMT:          /* PNG */\n            if (imagetopng(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Error generating png file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#endif /* OPJ_HAVE_LIBPNG */\n        /* Can happen if output file is TIF(F) or PNG\n         * and OPJ_HAVE_LIBTIF or OPJ_HAVE_LIBPNG is undefined\n        */\n        default:\n            fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n            failed = 1;\n        }\n\n        /* free remaining structures */\n        if (l_codec) {\n            opj_destroy_codec(l_codec);\n        }\n\n\n        /* free image data structure */\n        opj_image_destroy(image);\n\n        /* destroy the codestream index */\n        opj_destroy_cstr_index(&cstr_index);\n\n        if (failed) {\n            (void)remove(parameters.outfile);    /* ignore return value */\n        }\n    }\nfin:\n    destroy_parameters(&parameters);\n    if (failed && img_fol.imgdirpath) {\n        free(img_fol.imgdirpath);\n    }\n    if (dirptr) {\n        if (dirptr->filename) {\n            free(dirptr->filename);\n        }\n        if (dirptr->filename_buf) {\n            free(dirptr->filename_buf);\n        }\n        free(dirptr);\n    }\n    if (numDecompressedImages && !failed && !(parameters.quiet)) {\n        fprintf(stdout, \"decode time: %d ms\\n\",\n                (int)((tCumulative * 1000.0) / (OPJ_FLOAT64)numDecompressedImages));\n    }\n    return failed ? EXIT_FAILURE : EXIT_SUCCESS;\n}",
        "func": "int main(int argc, char **argv)\n{\n    opj_decompress_parameters parameters;           /* decompression parameters */\n\n    OPJ_INT32 num_images, imageno;\n    img_fol_t img_fol;\n    dircnt_t *dirptr = NULL;\n    int failed = 0;\n    OPJ_FLOAT64 t, tCumulative = 0;\n    OPJ_UINT32 numDecompressedImages = 0;\n    OPJ_UINT32 cp_reduce;\n\n    /* set decoding parameters to default values */\n    set_default_parameters(&parameters);\n\n    /* Initialize img_fol */\n    memset(&img_fol, 0, sizeof(img_fol_t));\n\n    /* parse input and get user encoding parameters */\n    if (parse_cmdline_decoder(argc, argv, &parameters, &img_fol) == 1) {\n        failed = 1;\n        goto fin;\n    }\n\n    cp_reduce = parameters.core.cp_reduce;\n    if (getenv(\"USE_OPJ_SET_DECODED_RESOLUTION_FACTOR\") != NULL) {\n        /* For debugging/testing purposes, do not set the cp_reduce member */\n        /* if USE_OPJ_SET_DECODED_RESOLUTION_FACTOR is defined, but used */\n        /* the opj_set_decoded_resolution_factor() API instead */\n        parameters.core.cp_reduce = 0;\n    }\n\n\n    /* Initialize reading of directory */\n    if (img_fol.set_imgdir == 1) {\n        int it_image;\n        num_images = get_num_images(img_fol.imgdirpath);\n\n        dirptr = (dircnt_t*)calloc(1, sizeof(dircnt_t));\n        if (!dirptr) {\n            destroy_parameters(&parameters);\n            return EXIT_FAILURE;\n        }\n        /* Stores at max 10 image file names */\n        dirptr->filename_buf = (char*)malloc(sizeof(char) *\n                                             (size_t)num_images * OPJ_PATH_LEN);\n        if (!dirptr->filename_buf) {\n            failed = 1;\n            goto fin;\n        }\n\n        dirptr->filename = (char**) malloc((size_t)num_images * sizeof(char*));\n\n        if (!dirptr->filename) {\n            failed = 1;\n            goto fin;\n        }\n        for (it_image = 0; it_image < num_images; it_image++) {\n            dirptr->filename[it_image] = dirptr->filename_buf + it_image * OPJ_PATH_LEN;\n        }\n\n        if (load_images(dirptr, img_fol.imgdirpath) == 1) {\n            failed = 1;\n            goto fin;\n        }\n        if (num_images == 0) {\n            fprintf(stderr, \"Folder is empty\\n\");\n            failed = 1;\n            goto fin;\n        }\n    } else {\n        num_images = 1;\n    }\n\n    /*Decoding image one by one*/\n    for (imageno = 0; imageno < num_images ; imageno++)  {\n        opj_image_t* image = NULL;\n        opj_stream_t *l_stream = NULL;              /* Stream */\n        opj_codec_t* l_codec = NULL;                /* Handle to a decompressor */\n        opj_codestream_index_t* cstr_index = NULL;\n\n        if (!parameters.quiet) {\n            fprintf(stderr, \"\\n\");\n        }\n\n        if (img_fol.set_imgdir == 1) {\n            if (get_next_file(imageno, dirptr, &img_fol, &parameters)) {\n                fprintf(stderr, \"skipping file...\\n\");\n                destroy_parameters(&parameters);\n                continue;\n            }\n        }\n\n        /* read the input file and put it in memory */\n        /* ---------------------------------------- */\n\n        l_stream = opj_stream_create_default_file_stream(parameters.infile, 1);\n        if (!l_stream) {\n            fprintf(stderr, \"ERROR -> failed to create the stream from the file %s\\n\",\n                    parameters.infile);\n            failed = 1;\n            goto fin;\n        }\n\n        /* decode the JPEG2000 stream */\n        /* ---------------------- */\n\n        switch (parameters.decod_format) {\n        case J2K_CFMT: { /* JPEG-2000 codestream */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_J2K);\n            break;\n        }\n        case JP2_CFMT: { /* JPEG 2000 compressed image data */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_JP2);\n            break;\n        }\n        case JPT_CFMT: { /* JPEG 2000, JPIP */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_JPT);\n            break;\n        }\n        default:\n            fprintf(stderr, \"skipping file..\\n\");\n            destroy_parameters(&parameters);\n            opj_stream_destroy(l_stream);\n            continue;\n        }\n\n        if (parameters.quiet) {\n            /* Set all callbacks to quiet */\n            opj_set_info_handler(l_codec, quiet_callback, 00);\n            opj_set_warning_handler(l_codec, quiet_callback, 00);\n            opj_set_error_handler(l_codec, quiet_callback, 00);\n        } else {\n            /* catch events using our callbacks and give a local context */\n            opj_set_info_handler(l_codec, info_callback, 00);\n            opj_set_warning_handler(l_codec, warning_callback, 00);\n            opj_set_error_handler(l_codec, error_callback, 00);\n        }\n\n\n        t = opj_clock();\n\n        /* Setup the decoder decoding parameters using user parameters */\n        if (!opj_setup_decoder(l_codec, &(parameters.core))) {\n            fprintf(stderr, \"ERROR -> opj_decompress: failed to setup the decoder\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            failed = 1;\n            goto fin;\n        }\n\n        if (parameters.num_threads >= 1 &&\n                !opj_codec_set_threads(l_codec, parameters.num_threads)) {\n            fprintf(stderr, \"ERROR -> opj_decompress: failed to set number of threads\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            failed = 1;\n            goto fin;\n        }\n\n        /* Read the main header of the codestream and if necessary the JP2 boxes*/\n        if (! opj_read_header(l_stream, l_codec, &image)) {\n            fprintf(stderr, \"ERROR -> opj_decompress: failed to read the header\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            opj_image_destroy(image);\n            failed = 1;\n            goto fin;\n        }\n\n        if (parameters.numcomps) {\n            if (! opj_set_decoded_components(l_codec,\n                                             parameters.numcomps,\n                                             parameters.comps_indices,\n                                             OPJ_FALSE)) {\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: failed to set the component indices!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        if (getenv(\"USE_OPJ_SET_DECODED_RESOLUTION_FACTOR\") != NULL) {\n            /* For debugging/testing purposes, and also an illustration on how to */\n            /* use the alternative API opj_set_decoded_resolution_factor() instead */\n            /* of setting parameters.cp_reduce */\n            if (! opj_set_decoded_resolution_factor(l_codec, cp_reduce)) {\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: failed to set the resolution factor tile!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        if (!parameters.nb_tile_to_decode) {\n            if (getenv(\"SKIP_OPJ_SET_DECODE_AREA\") != NULL &&\n                    parameters.DA_x0 == 0 &&\n                    parameters.DA_y0 == 0 &&\n                    parameters.DA_x1 == 0 &&\n                    parameters.DA_y1 == 0) {\n                /* For debugging/testing purposes, */\n                /* do nothing if SKIP_OPJ_SET_DECODE_AREA env variable */\n                /* is defined and no decoded area has been set */\n            }\n            /* Optional if you want decode the entire image */\n            else if (!opj_set_decode_area(l_codec, image, (OPJ_INT32)parameters.DA_x0,\n                                          (OPJ_INT32)parameters.DA_y0, (OPJ_INT32)parameters.DA_x1,\n                                          (OPJ_INT32)parameters.DA_y1)) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to set the decoded area\\n\");\n                opj_stream_destroy(l_stream);\n                opj_destroy_codec(l_codec);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n\n            /* Get the decoded image */\n            if (!(opj_decode(l_codec, l_stream, image) &&\n                    opj_end_decompress(l_codec,   l_stream))) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to decode image!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n        } else {\n            if (!(parameters.DA_x0 == 0 &&\n                    parameters.DA_y0 == 0 &&\n                    parameters.DA_x1 == 0 &&\n                    parameters.DA_y1 == 0)) {\n                if (!(parameters.quiet)) {\n                    fprintf(stderr, \"WARNING: -d option ignored when used together with -t\\n\");\n                }\n            }\n\n            if (!opj_get_decoded_tile(l_codec, l_stream, image, parameters.tile_index)) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to decode tile!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n            if (!(parameters.quiet)) {\n                fprintf(stdout, \"tile %d is decoded!\\n\\n\", parameters.tile_index);\n            }\n        }\n\n        tCumulative += opj_clock() - t;\n        numDecompressedImages++;\n\n        /* Close the byte stream */\n        opj_stream_destroy(l_stream);\n\n        if (image->color_space != OPJ_CLRSPC_SYCC\n                && image->numcomps == 3 && image->comps[0].dx == image->comps[0].dy\n                && image->comps[1].dx != 1) {\n            image->color_space = OPJ_CLRSPC_SYCC;\n        } else if (image->numcomps <= 2) {\n            image->color_space = OPJ_CLRSPC_GRAY;\n        }\n\n        if (image->color_space == OPJ_CLRSPC_SYCC) {\n            color_sycc_to_rgb(image);\n        } else if ((image->color_space == OPJ_CLRSPC_CMYK) &&\n                   (parameters.cod_format != TIF_DFMT)) {\n            color_cmyk_to_rgb(image);\n        } else if (image->color_space == OPJ_CLRSPC_EYCC) {\n            color_esycc_to_rgb(image);\n        }\n\n        if (image->icc_profile_buf) {\n#if defined(OPJ_HAVE_LIBLCMS1) || defined(OPJ_HAVE_LIBLCMS2)\n            if (image->icc_profile_len) {\n                color_apply_icc_profile(image);\n            } else {\n                color_cielab_to_rgb(image);\n            }\n#endif\n            free(image->icc_profile_buf);\n            image->icc_profile_buf = NULL;\n            image->icc_profile_len = 0;\n        }\n\n        /* Force output precision */\n        /* ---------------------- */\n        if (parameters.precision != NULL) {\n            OPJ_UINT32 compno;\n            for (compno = 0; compno < image->numcomps; ++compno) {\n                OPJ_UINT32 precno = compno;\n                OPJ_UINT32 prec;\n\n                if (precno >= parameters.nb_precision) {\n                    precno = parameters.nb_precision - 1U;\n                }\n\n                prec = parameters.precision[precno].prec;\n                if (prec == 0) {\n                    prec = image->comps[compno].prec;\n                }\n\n                switch (parameters.precision[precno].mode) {\n                case OPJ_PREC_MODE_CLIP:\n                    clip_component(&(image->comps[compno]), prec);\n                    break;\n                case OPJ_PREC_MODE_SCALE:\n                    scale_component(&(image->comps[compno]), prec);\n                    break;\n                default:\n                    break;\n                }\n\n            }\n        }\n\n        /* Upsample components */\n        /* ------------------- */\n        if (parameters.upsample) {\n            image = upsample_image_components(image);\n            if (image == NULL) {\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: failed to upsample image components!\\n\");\n                opj_destroy_codec(l_codec);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        /* Force RGB output */\n        /* ---------------- */\n        if (parameters.force_rgb) {\n            switch (image->color_space) {\n            case OPJ_CLRSPC_SRGB:\n                break;\n            case OPJ_CLRSPC_GRAY:\n                image = convert_gray_to_rgb(image);\n                break;\n            default:\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: don't know how to convert image to RGB colorspace!\\n\");\n                opj_image_destroy(image);\n                image = NULL;\n                break;\n            }\n            if (image == NULL) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to convert to RGB image!\\n\");\n                opj_destroy_codec(l_codec);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        /* create output image */\n        /* ------------------- */\n        switch (parameters.cod_format) {\n        case PXM_DFMT:          /* PNM PGM PPM */\n            if (imagetopnm(image, parameters.outfile, parameters.split_pnm)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case PGX_DFMT:          /* PGX */\n            if (imagetopgx(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case BMP_DFMT:          /* BMP */\n            if (imagetobmp(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#ifdef OPJ_HAVE_LIBTIFF\n        case TIF_DFMT:          /* TIF(F) */\n            if (imagetotif(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#endif /* OPJ_HAVE_LIBTIFF */\n        case RAW_DFMT:          /* RAW */\n            if (imagetoraw(image, parameters.outfile)) {\n                fprintf(stderr,\n                        \"[ERROR] Error generating raw or yuv file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case RAWL_DFMT:         /* RAWL */\n            if (imagetorawl(image, parameters.outfile)) {\n                fprintf(stderr,\n                        \"[ERROR] Error generating rawl file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case TGA_DFMT:          /* TGA */\n            if (imagetotga(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Error generating tga file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#ifdef OPJ_HAVE_LIBPNG\n        case PNG_DFMT:          /* PNG */\n            if (imagetopng(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Error generating png file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#endif /* OPJ_HAVE_LIBPNG */\n        /* Can happen if output file is TIF(F) or PNG\n         * and OPJ_HAVE_LIBTIF or OPJ_HAVE_LIBPNG is undefined\n        */\n        default:\n            fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n            failed = 1;\n        }\n\n        /* free remaining structures */\n        if (l_codec) {\n            opj_destroy_codec(l_codec);\n        }\n\n\n        /* free image data structure */\n        opj_image_destroy(image);\n\n        /* destroy the codestream index */\n        opj_destroy_cstr_index(&cstr_index);\n\n        if (failed) {\n            (void)remove(parameters.outfile);    /* ignore return value */\n        }\n    }\nfin:\n    destroy_parameters(&parameters);\n    if (failed && img_fol.imgdirpath) {\n        free(img_fol.imgdirpath);\n    }\n    if (dirptr) {\n        if (dirptr->filename) {\n            free(dirptr->filename);\n        }\n        if (dirptr->filename_buf) {\n            free(dirptr->filename_buf);\n        }\n        free(dirptr);\n    }\n    if (numDecompressedImages && !failed && !(parameters.quiet)) {\n        fprintf(stdout, \"decode time: %d ms\\n\",\n                (int)((tCumulative * 1000.0) / (OPJ_FLOAT64)numDecompressedImages));\n    }\n    return failed ? EXIT_FAILURE : EXIT_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -41,9 +41,6 @@\n             destroy_parameters(&parameters);\n             return EXIT_FAILURE;\n         }\n-\n-        memset(dirptr, 0, sizeof(dircnt_t));\n-\n         /* Stores at max 10 image file names */\n         dirptr->filename_buf = (char*)malloc(sizeof(char) *\n                                              (size_t)num_images * OPJ_PATH_LEN);",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "        memset(dirptr, 0, sizeof(dircnt_t));",
                ""
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2022-1122",
        "func_name": "uclouvain/openjpeg/main",
        "description": "A flaw was found in the opj2_decompress program in openjpeg2 2.4.0 in the way it handles an input directory with a large number of files. When it fails to allocate a buffer to store the filenames of the input directory, it calls free() on an uninitialized pointer, leading to a segmentation fault and a denial of service.",
        "git_url": "https://github.com/uclouvain/openjpeg/commit/660f440092dea57d4cf665331ae42bb9d8c90275",
        "commit_title": "fix issues 1368:exist a issues of freeing uninitialized pointer in src/bin/jp2/opj_decompress.cthat will cause a segfault",
        "commit_text": "",
        "func_before": "int main(int argc, char **argv)\n{\n    opj_decompress_parameters parameters;           /* decompression parameters */\n\n    OPJ_INT32 num_images, imageno;\n    img_fol_t img_fol;\n    dircnt_t *dirptr = NULL;\n    int failed = 0;\n    OPJ_FLOAT64 t, tCumulative = 0;\n    OPJ_UINT32 numDecompressedImages = 0;\n    OPJ_UINT32 cp_reduce;\n\n    /* set decoding parameters to default values */\n    set_default_parameters(&parameters);\n\n    /* Initialize img_fol */\n    memset(&img_fol, 0, sizeof(img_fol_t));\n\n    /* parse input and get user encoding parameters */\n    if (parse_cmdline_decoder(argc, argv, &parameters, &img_fol) == 1) {\n        failed = 1;\n        goto fin;\n    }\n\n    cp_reduce = parameters.core.cp_reduce;\n    if (getenv(\"USE_OPJ_SET_DECODED_RESOLUTION_FACTOR\") != NULL) {\n        /* For debugging/testing purposes, do not set the cp_reduce member */\n        /* if USE_OPJ_SET_DECODED_RESOLUTION_FACTOR is defined, but used */\n        /* the opj_set_decoded_resolution_factor() API instead */\n        parameters.core.cp_reduce = 0;\n    }\n\n\n    /* Initialize reading of directory */\n    if (img_fol.set_imgdir == 1) {\n        int it_image;\n        num_images = get_num_images(img_fol.imgdirpath);\n\n        dirptr = (dircnt_t*)malloc(sizeof(dircnt_t));\n        if (!dirptr) {\n            destroy_parameters(&parameters);\n            return EXIT_FAILURE;\n        }\n        /* Stores at max 10 image file names */\n        dirptr->filename_buf = (char*)malloc(sizeof(char) *\n                                             (size_t)num_images * OPJ_PATH_LEN);\n        if (!dirptr->filename_buf) {\n            failed = 1;\n            goto fin;\n        }\n\n        dirptr->filename = (char**) malloc((size_t)num_images * sizeof(char*));\n\n        if (!dirptr->filename) {\n            failed = 1;\n            goto fin;\n        }\n        for (it_image = 0; it_image < num_images; it_image++) {\n            dirptr->filename[it_image] = dirptr->filename_buf + it_image * OPJ_PATH_LEN;\n        }\n\n        if (load_images(dirptr, img_fol.imgdirpath) == 1) {\n            failed = 1;\n            goto fin;\n        }\n        if (num_images == 0) {\n            fprintf(stderr, \"Folder is empty\\n\");\n            failed = 1;\n            goto fin;\n        }\n    } else {\n        num_images = 1;\n    }\n\n    /*Decoding image one by one*/\n    for (imageno = 0; imageno < num_images ; imageno++)  {\n        opj_image_t* image = NULL;\n        opj_stream_t *l_stream = NULL;              /* Stream */\n        opj_codec_t* l_codec = NULL;                /* Handle to a decompressor */\n        opj_codestream_index_t* cstr_index = NULL;\n\n        if (!parameters.quiet) {\n            fprintf(stderr, \"\\n\");\n        }\n\n        if (img_fol.set_imgdir == 1) {\n            if (get_next_file(imageno, dirptr, &img_fol, &parameters)) {\n                fprintf(stderr, \"skipping file...\\n\");\n                destroy_parameters(&parameters);\n                continue;\n            }\n        }\n\n        /* read the input file and put it in memory */\n        /* ---------------------------------------- */\n\n        l_stream = opj_stream_create_default_file_stream(parameters.infile, 1);\n        if (!l_stream) {\n            fprintf(stderr, \"ERROR -> failed to create the stream from the file %s\\n\",\n                    parameters.infile);\n            failed = 1;\n            goto fin;\n        }\n\n        /* decode the JPEG2000 stream */\n        /* ---------------------- */\n\n        switch (parameters.decod_format) {\n        case J2K_CFMT: { /* JPEG-2000 codestream */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_J2K);\n            break;\n        }\n        case JP2_CFMT: { /* JPEG 2000 compressed image data */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_JP2);\n            break;\n        }\n        case JPT_CFMT: { /* JPEG 2000, JPIP */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_JPT);\n            break;\n        }\n        default:\n            fprintf(stderr, \"skipping file..\\n\");\n            destroy_parameters(&parameters);\n            opj_stream_destroy(l_stream);\n            continue;\n        }\n\n        if (parameters.quiet) {\n            /* Set all callbacks to quiet */\n            opj_set_info_handler(l_codec, quiet_callback, 00);\n            opj_set_warning_handler(l_codec, quiet_callback, 00);\n            opj_set_error_handler(l_codec, quiet_callback, 00);\n        } else {\n            /* catch events using our callbacks and give a local context */\n            opj_set_info_handler(l_codec, info_callback, 00);\n            opj_set_warning_handler(l_codec, warning_callback, 00);\n            opj_set_error_handler(l_codec, error_callback, 00);\n        }\n\n\n        t = opj_clock();\n\n        /* Setup the decoder decoding parameters using user parameters */\n        if (!opj_setup_decoder(l_codec, &(parameters.core))) {\n            fprintf(stderr, \"ERROR -> opj_decompress: failed to setup the decoder\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            failed = 1;\n            goto fin;\n        }\n\n        if (parameters.num_threads >= 1 &&\n                !opj_codec_set_threads(l_codec, parameters.num_threads)) {\n            fprintf(stderr, \"ERROR -> opj_decompress: failed to set number of threads\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            failed = 1;\n            goto fin;\n        }\n\n        /* Read the main header of the codestream and if necessary the JP2 boxes*/\n        if (! opj_read_header(l_stream, l_codec, &image)) {\n            fprintf(stderr, \"ERROR -> opj_decompress: failed to read the header\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            opj_image_destroy(image);\n            failed = 1;\n            goto fin;\n        }\n\n        if (parameters.numcomps) {\n            if (! opj_set_decoded_components(l_codec,\n                                             parameters.numcomps,\n                                             parameters.comps_indices,\n                                             OPJ_FALSE)) {\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: failed to set the component indices!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        if (getenv(\"USE_OPJ_SET_DECODED_RESOLUTION_FACTOR\") != NULL) {\n            /* For debugging/testing purposes, and also an illustration on how to */\n            /* use the alternative API opj_set_decoded_resolution_factor() instead */\n            /* of setting parameters.cp_reduce */\n            if (! opj_set_decoded_resolution_factor(l_codec, cp_reduce)) {\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: failed to set the resolution factor tile!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        if (!parameters.nb_tile_to_decode) {\n            if (getenv(\"SKIP_OPJ_SET_DECODE_AREA\") != NULL &&\n                    parameters.DA_x0 == 0 &&\n                    parameters.DA_y0 == 0 &&\n                    parameters.DA_x1 == 0 &&\n                    parameters.DA_y1 == 0) {\n                /* For debugging/testing purposes, */\n                /* do nothing if SKIP_OPJ_SET_DECODE_AREA env variable */\n                /* is defined and no decoded area has been set */\n            }\n            /* Optional if you want decode the entire image */\n            else if (!opj_set_decode_area(l_codec, image, (OPJ_INT32)parameters.DA_x0,\n                                          (OPJ_INT32)parameters.DA_y0, (OPJ_INT32)parameters.DA_x1,\n                                          (OPJ_INT32)parameters.DA_y1)) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to set the decoded area\\n\");\n                opj_stream_destroy(l_stream);\n                opj_destroy_codec(l_codec);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n\n            /* Get the decoded image */\n            if (!(opj_decode(l_codec, l_stream, image) &&\n                    opj_end_decompress(l_codec,   l_stream))) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to decode image!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n        } else {\n            if (!(parameters.DA_x0 == 0 &&\n                    parameters.DA_y0 == 0 &&\n                    parameters.DA_x1 == 0 &&\n                    parameters.DA_y1 == 0)) {\n                if (!(parameters.quiet)) {\n                    fprintf(stderr, \"WARNING: -d option ignored when used together with -t\\n\");\n                }\n            }\n\n            if (!opj_get_decoded_tile(l_codec, l_stream, image, parameters.tile_index)) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to decode tile!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n            if (!(parameters.quiet)) {\n                fprintf(stdout, \"tile %d is decoded!\\n\\n\", parameters.tile_index);\n            }\n        }\n\n        tCumulative += opj_clock() - t;\n        numDecompressedImages++;\n\n        /* Close the byte stream */\n        opj_stream_destroy(l_stream);\n\n        if (image->color_space != OPJ_CLRSPC_SYCC\n                && image->numcomps == 3 && image->comps[0].dx == image->comps[0].dy\n                && image->comps[1].dx != 1) {\n            image->color_space = OPJ_CLRSPC_SYCC;\n        } else if (image->numcomps <= 2) {\n            image->color_space = OPJ_CLRSPC_GRAY;\n        }\n\n        if (image->color_space == OPJ_CLRSPC_SYCC) {\n            color_sycc_to_rgb(image);\n        } else if ((image->color_space == OPJ_CLRSPC_CMYK) &&\n                   (parameters.cod_format != TIF_DFMT)) {\n            color_cmyk_to_rgb(image);\n        } else if (image->color_space == OPJ_CLRSPC_EYCC) {\n            color_esycc_to_rgb(image);\n        }\n\n        if (image->icc_profile_buf) {\n#if defined(OPJ_HAVE_LIBLCMS1) || defined(OPJ_HAVE_LIBLCMS2)\n            if (image->icc_profile_len) {\n                color_apply_icc_profile(image);\n            } else {\n                color_cielab_to_rgb(image);\n            }\n#endif\n            free(image->icc_profile_buf);\n            image->icc_profile_buf = NULL;\n            image->icc_profile_len = 0;\n        }\n\n        /* Force output precision */\n        /* ---------------------- */\n        if (parameters.precision != NULL) {\n            OPJ_UINT32 compno;\n            for (compno = 0; compno < image->numcomps; ++compno) {\n                OPJ_UINT32 precno = compno;\n                OPJ_UINT32 prec;\n\n                if (precno >= parameters.nb_precision) {\n                    precno = parameters.nb_precision - 1U;\n                }\n\n                prec = parameters.precision[precno].prec;\n                if (prec == 0) {\n                    prec = image->comps[compno].prec;\n                }\n\n                switch (parameters.precision[precno].mode) {\n                case OPJ_PREC_MODE_CLIP:\n                    clip_component(&(image->comps[compno]), prec);\n                    break;\n                case OPJ_PREC_MODE_SCALE:\n                    scale_component(&(image->comps[compno]), prec);\n                    break;\n                default:\n                    break;\n                }\n\n            }\n        }\n\n        /* Upsample components */\n        /* ------------------- */\n        if (parameters.upsample) {\n            image = upsample_image_components(image);\n            if (image == NULL) {\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: failed to upsample image components!\\n\");\n                opj_destroy_codec(l_codec);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        /* Force RGB output */\n        /* ---------------- */\n        if (parameters.force_rgb) {\n            switch (image->color_space) {\n            case OPJ_CLRSPC_SRGB:\n                break;\n            case OPJ_CLRSPC_GRAY:\n                image = convert_gray_to_rgb(image);\n                break;\n            default:\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: don't know how to convert image to RGB colorspace!\\n\");\n                opj_image_destroy(image);\n                image = NULL;\n                break;\n            }\n            if (image == NULL) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to convert to RGB image!\\n\");\n                opj_destroy_codec(l_codec);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        /* create output image */\n        /* ------------------- */\n        switch (parameters.cod_format) {\n        case PXM_DFMT:          /* PNM PGM PPM */\n            if (imagetopnm(image, parameters.outfile, parameters.split_pnm)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case PGX_DFMT:          /* PGX */\n            if (imagetopgx(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case BMP_DFMT:          /* BMP */\n            if (imagetobmp(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#ifdef OPJ_HAVE_LIBTIFF\n        case TIF_DFMT:          /* TIF(F) */\n            if (imagetotif(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#endif /* OPJ_HAVE_LIBTIFF */\n        case RAW_DFMT:          /* RAW */\n            if (imagetoraw(image, parameters.outfile)) {\n                fprintf(stderr,\n                        \"[ERROR] Error generating raw or yuv file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case RAWL_DFMT:         /* RAWL */\n            if (imagetorawl(image, parameters.outfile)) {\n                fprintf(stderr,\n                        \"[ERROR] Error generating rawl file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case TGA_DFMT:          /* TGA */\n            if (imagetotga(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Error generating tga file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#ifdef OPJ_HAVE_LIBPNG\n        case PNG_DFMT:          /* PNG */\n            if (imagetopng(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Error generating png file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#endif /* OPJ_HAVE_LIBPNG */\n        /* Can happen if output file is TIF(F) or PNG\n         * and OPJ_HAVE_LIBTIF or OPJ_HAVE_LIBPNG is undefined\n        */\n        default:\n            fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n            failed = 1;\n        }\n\n        /* free remaining structures */\n        if (l_codec) {\n            opj_destroy_codec(l_codec);\n        }\n\n\n        /* free image data structure */\n        opj_image_destroy(image);\n\n        /* destroy the codestream index */\n        opj_destroy_cstr_index(&cstr_index);\n\n        if (failed) {\n            (void)remove(parameters.outfile);    /* ignore return value */\n        }\n    }\nfin:\n    destroy_parameters(&parameters);\n    if (failed && img_fol.imgdirpath) {\n        free(img_fol.imgdirpath);\n    }\n    if (dirptr) {\n        if (dirptr->filename) {\n            free(dirptr->filename);\n        }\n        if (dirptr->filename_buf) {\n            free(dirptr->filename_buf);\n        }\n        free(dirptr);\n    }\n    if (numDecompressedImages && !failed && !(parameters.quiet)) {\n        fprintf(stdout, \"decode time: %d ms\\n\",\n                (int)((tCumulative * 1000.0) / (OPJ_FLOAT64)numDecompressedImages));\n    }\n    return failed ? EXIT_FAILURE : EXIT_SUCCESS;\n}",
        "func": "int main(int argc, char **argv)\n{\n    opj_decompress_parameters parameters;           /* decompression parameters */\n\n    OPJ_INT32 num_images, imageno;\n    img_fol_t img_fol;\n    dircnt_t *dirptr = NULL;\n    int failed = 0;\n    OPJ_FLOAT64 t, tCumulative = 0;\n    OPJ_UINT32 numDecompressedImages = 0;\n    OPJ_UINT32 cp_reduce;\n\n    /* set decoding parameters to default values */\n    set_default_parameters(&parameters);\n\n    /* Initialize img_fol */\n    memset(&img_fol, 0, sizeof(img_fol_t));\n\n    /* parse input and get user encoding parameters */\n    if (parse_cmdline_decoder(argc, argv, &parameters, &img_fol) == 1) {\n        failed = 1;\n        goto fin;\n    }\n\n    cp_reduce = parameters.core.cp_reduce;\n    if (getenv(\"USE_OPJ_SET_DECODED_RESOLUTION_FACTOR\") != NULL) {\n        /* For debugging/testing purposes, do not set the cp_reduce member */\n        /* if USE_OPJ_SET_DECODED_RESOLUTION_FACTOR is defined, but used */\n        /* the opj_set_decoded_resolution_factor() API instead */\n        parameters.core.cp_reduce = 0;\n    }\n\n\n    /* Initialize reading of directory */\n    if (img_fol.set_imgdir == 1) {\n        int it_image;\n        num_images = get_num_images(img_fol.imgdirpath);\n\n        dirptr = (dircnt_t*)malloc(sizeof(dircnt_t));\n        if (!dirptr) {\n            destroy_parameters(&parameters);\n            return EXIT_FAILURE;\n        }\n\n        memset(dirptr, 0, sizeof(dircnt_t));\n\n        /* Stores at max 10 image file names */\n        dirptr->filename_buf = (char*)malloc(sizeof(char) *\n                                             (size_t)num_images * OPJ_PATH_LEN);\n        if (!dirptr->filename_buf) {\n            failed = 1;\n            goto fin;\n        }\n\n        dirptr->filename = (char**) malloc((size_t)num_images * sizeof(char*));\n\n        if (!dirptr->filename) {\n            failed = 1;\n            goto fin;\n        }\n        for (it_image = 0; it_image < num_images; it_image++) {\n            dirptr->filename[it_image] = dirptr->filename_buf + it_image * OPJ_PATH_LEN;\n        }\n\n        if (load_images(dirptr, img_fol.imgdirpath) == 1) {\n            failed = 1;\n            goto fin;\n        }\n        if (num_images == 0) {\n            fprintf(stderr, \"Folder is empty\\n\");\n            failed = 1;\n            goto fin;\n        }\n    } else {\n        num_images = 1;\n    }\n\n    /*Decoding image one by one*/\n    for (imageno = 0; imageno < num_images ; imageno++)  {\n        opj_image_t* image = NULL;\n        opj_stream_t *l_stream = NULL;              /* Stream */\n        opj_codec_t* l_codec = NULL;                /* Handle to a decompressor */\n        opj_codestream_index_t* cstr_index = NULL;\n\n        if (!parameters.quiet) {\n            fprintf(stderr, \"\\n\");\n        }\n\n        if (img_fol.set_imgdir == 1) {\n            if (get_next_file(imageno, dirptr, &img_fol, &parameters)) {\n                fprintf(stderr, \"skipping file...\\n\");\n                destroy_parameters(&parameters);\n                continue;\n            }\n        }\n\n        /* read the input file and put it in memory */\n        /* ---------------------------------------- */\n\n        l_stream = opj_stream_create_default_file_stream(parameters.infile, 1);\n        if (!l_stream) {\n            fprintf(stderr, \"ERROR -> failed to create the stream from the file %s\\n\",\n                    parameters.infile);\n            failed = 1;\n            goto fin;\n        }\n\n        /* decode the JPEG2000 stream */\n        /* ---------------------- */\n\n        switch (parameters.decod_format) {\n        case J2K_CFMT: { /* JPEG-2000 codestream */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_J2K);\n            break;\n        }\n        case JP2_CFMT: { /* JPEG 2000 compressed image data */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_JP2);\n            break;\n        }\n        case JPT_CFMT: { /* JPEG 2000, JPIP */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_JPT);\n            break;\n        }\n        default:\n            fprintf(stderr, \"skipping file..\\n\");\n            destroy_parameters(&parameters);\n            opj_stream_destroy(l_stream);\n            continue;\n        }\n\n        if (parameters.quiet) {\n            /* Set all callbacks to quiet */\n            opj_set_info_handler(l_codec, quiet_callback, 00);\n            opj_set_warning_handler(l_codec, quiet_callback, 00);\n            opj_set_error_handler(l_codec, quiet_callback, 00);\n        } else {\n            /* catch events using our callbacks and give a local context */\n            opj_set_info_handler(l_codec, info_callback, 00);\n            opj_set_warning_handler(l_codec, warning_callback, 00);\n            opj_set_error_handler(l_codec, error_callback, 00);\n        }\n\n\n        t = opj_clock();\n\n        /* Setup the decoder decoding parameters using user parameters */\n        if (!opj_setup_decoder(l_codec, &(parameters.core))) {\n            fprintf(stderr, \"ERROR -> opj_decompress: failed to setup the decoder\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            failed = 1;\n            goto fin;\n        }\n\n        if (parameters.num_threads >= 1 &&\n                !opj_codec_set_threads(l_codec, parameters.num_threads)) {\n            fprintf(stderr, \"ERROR -> opj_decompress: failed to set number of threads\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            failed = 1;\n            goto fin;\n        }\n\n        /* Read the main header of the codestream and if necessary the JP2 boxes*/\n        if (! opj_read_header(l_stream, l_codec, &image)) {\n            fprintf(stderr, \"ERROR -> opj_decompress: failed to read the header\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            opj_image_destroy(image);\n            failed = 1;\n            goto fin;\n        }\n\n        if (parameters.numcomps) {\n            if (! opj_set_decoded_components(l_codec,\n                                             parameters.numcomps,\n                                             parameters.comps_indices,\n                                             OPJ_FALSE)) {\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: failed to set the component indices!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        if (getenv(\"USE_OPJ_SET_DECODED_RESOLUTION_FACTOR\") != NULL) {\n            /* For debugging/testing purposes, and also an illustration on how to */\n            /* use the alternative API opj_set_decoded_resolution_factor() instead */\n            /* of setting parameters.cp_reduce */\n            if (! opj_set_decoded_resolution_factor(l_codec, cp_reduce)) {\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: failed to set the resolution factor tile!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        if (!parameters.nb_tile_to_decode) {\n            if (getenv(\"SKIP_OPJ_SET_DECODE_AREA\") != NULL &&\n                    parameters.DA_x0 == 0 &&\n                    parameters.DA_y0 == 0 &&\n                    parameters.DA_x1 == 0 &&\n                    parameters.DA_y1 == 0) {\n                /* For debugging/testing purposes, */\n                /* do nothing if SKIP_OPJ_SET_DECODE_AREA env variable */\n                /* is defined and no decoded area has been set */\n            }\n            /* Optional if you want decode the entire image */\n            else if (!opj_set_decode_area(l_codec, image, (OPJ_INT32)parameters.DA_x0,\n                                          (OPJ_INT32)parameters.DA_y0, (OPJ_INT32)parameters.DA_x1,\n                                          (OPJ_INT32)parameters.DA_y1)) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to set the decoded area\\n\");\n                opj_stream_destroy(l_stream);\n                opj_destroy_codec(l_codec);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n\n            /* Get the decoded image */\n            if (!(opj_decode(l_codec, l_stream, image) &&\n                    opj_end_decompress(l_codec,   l_stream))) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to decode image!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n        } else {\n            if (!(parameters.DA_x0 == 0 &&\n                    parameters.DA_y0 == 0 &&\n                    parameters.DA_x1 == 0 &&\n                    parameters.DA_y1 == 0)) {\n                if (!(parameters.quiet)) {\n                    fprintf(stderr, \"WARNING: -d option ignored when used together with -t\\n\");\n                }\n            }\n\n            if (!opj_get_decoded_tile(l_codec, l_stream, image, parameters.tile_index)) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to decode tile!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n            if (!(parameters.quiet)) {\n                fprintf(stdout, \"tile %d is decoded!\\n\\n\", parameters.tile_index);\n            }\n        }\n\n        tCumulative += opj_clock() - t;\n        numDecompressedImages++;\n\n        /* Close the byte stream */\n        opj_stream_destroy(l_stream);\n\n        if (image->color_space != OPJ_CLRSPC_SYCC\n                && image->numcomps == 3 && image->comps[0].dx == image->comps[0].dy\n                && image->comps[1].dx != 1) {\n            image->color_space = OPJ_CLRSPC_SYCC;\n        } else if (image->numcomps <= 2) {\n            image->color_space = OPJ_CLRSPC_GRAY;\n        }\n\n        if (image->color_space == OPJ_CLRSPC_SYCC) {\n            color_sycc_to_rgb(image);\n        } else if ((image->color_space == OPJ_CLRSPC_CMYK) &&\n                   (parameters.cod_format != TIF_DFMT)) {\n            color_cmyk_to_rgb(image);\n        } else if (image->color_space == OPJ_CLRSPC_EYCC) {\n            color_esycc_to_rgb(image);\n        }\n\n        if (image->icc_profile_buf) {\n#if defined(OPJ_HAVE_LIBLCMS1) || defined(OPJ_HAVE_LIBLCMS2)\n            if (image->icc_profile_len) {\n                color_apply_icc_profile(image);\n            } else {\n                color_cielab_to_rgb(image);\n            }\n#endif\n            free(image->icc_profile_buf);\n            image->icc_profile_buf = NULL;\n            image->icc_profile_len = 0;\n        }\n\n        /* Force output precision */\n        /* ---------------------- */\n        if (parameters.precision != NULL) {\n            OPJ_UINT32 compno;\n            for (compno = 0; compno < image->numcomps; ++compno) {\n                OPJ_UINT32 precno = compno;\n                OPJ_UINT32 prec;\n\n                if (precno >= parameters.nb_precision) {\n                    precno = parameters.nb_precision - 1U;\n                }\n\n                prec = parameters.precision[precno].prec;\n                if (prec == 0) {\n                    prec = image->comps[compno].prec;\n                }\n\n                switch (parameters.precision[precno].mode) {\n                case OPJ_PREC_MODE_CLIP:\n                    clip_component(&(image->comps[compno]), prec);\n                    break;\n                case OPJ_PREC_MODE_SCALE:\n                    scale_component(&(image->comps[compno]), prec);\n                    break;\n                default:\n                    break;\n                }\n\n            }\n        }\n\n        /* Upsample components */\n        /* ------------------- */\n        if (parameters.upsample) {\n            image = upsample_image_components(image);\n            if (image == NULL) {\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: failed to upsample image components!\\n\");\n                opj_destroy_codec(l_codec);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        /* Force RGB output */\n        /* ---------------- */\n        if (parameters.force_rgb) {\n            switch (image->color_space) {\n            case OPJ_CLRSPC_SRGB:\n                break;\n            case OPJ_CLRSPC_GRAY:\n                image = convert_gray_to_rgb(image);\n                break;\n            default:\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: don't know how to convert image to RGB colorspace!\\n\");\n                opj_image_destroy(image);\n                image = NULL;\n                break;\n            }\n            if (image == NULL) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to convert to RGB image!\\n\");\n                opj_destroy_codec(l_codec);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        /* create output image */\n        /* ------------------- */\n        switch (parameters.cod_format) {\n        case PXM_DFMT:          /* PNM PGM PPM */\n            if (imagetopnm(image, parameters.outfile, parameters.split_pnm)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case PGX_DFMT:          /* PGX */\n            if (imagetopgx(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case BMP_DFMT:          /* BMP */\n            if (imagetobmp(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#ifdef OPJ_HAVE_LIBTIFF\n        case TIF_DFMT:          /* TIF(F) */\n            if (imagetotif(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#endif /* OPJ_HAVE_LIBTIFF */\n        case RAW_DFMT:          /* RAW */\n            if (imagetoraw(image, parameters.outfile)) {\n                fprintf(stderr,\n                        \"[ERROR] Error generating raw or yuv file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case RAWL_DFMT:         /* RAWL */\n            if (imagetorawl(image, parameters.outfile)) {\n                fprintf(stderr,\n                        \"[ERROR] Error generating rawl file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case TGA_DFMT:          /* TGA */\n            if (imagetotga(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Error generating tga file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#ifdef OPJ_HAVE_LIBPNG\n        case PNG_DFMT:          /* PNG */\n            if (imagetopng(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Error generating png file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#endif /* OPJ_HAVE_LIBPNG */\n        /* Can happen if output file is TIF(F) or PNG\n         * and OPJ_HAVE_LIBTIF or OPJ_HAVE_LIBPNG is undefined\n        */\n        default:\n            fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n            failed = 1;\n        }\n\n        /* free remaining structures */\n        if (l_codec) {\n            opj_destroy_codec(l_codec);\n        }\n\n\n        /* free image data structure */\n        opj_image_destroy(image);\n\n        /* destroy the codestream index */\n        opj_destroy_cstr_index(&cstr_index);\n\n        if (failed) {\n            (void)remove(parameters.outfile);    /* ignore return value */\n        }\n    }\nfin:\n    destroy_parameters(&parameters);\n    if (failed && img_fol.imgdirpath) {\n        free(img_fol.imgdirpath);\n    }\n    if (dirptr) {\n        if (dirptr->filename) {\n            free(dirptr->filename);\n        }\n        if (dirptr->filename_buf) {\n            free(dirptr->filename_buf);\n        }\n        free(dirptr);\n    }\n    if (numDecompressedImages && !failed && !(parameters.quiet)) {\n        fprintf(stdout, \"decode time: %d ms\\n\",\n                (int)((tCumulative * 1000.0) / (OPJ_FLOAT64)numDecompressedImages));\n    }\n    return failed ? EXIT_FAILURE : EXIT_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -41,6 +41,9 @@\n             destroy_parameters(&parameters);\n             return EXIT_FAILURE;\n         }\n+\n+        memset(dirptr, 0, sizeof(dircnt_t));\n+\n         /* Stores at max 10 image file names */\n         dirptr->filename_buf = (char*)malloc(sizeof(char) *\n                                              (size_t)num_images * OPJ_PATH_LEN);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "        memset(dirptr, 0, sizeof(dircnt_t));",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1122",
        "func_name": "uclouvain/openjpeg/main",
        "description": "A flaw was found in the opj2_decompress program in openjpeg2 2.4.0 in the way it handles an input directory with a large number of files. When it fails to allocate a buffer to store the filenames of the input directory, it calls free() on an uninitialized pointer, leading to a segmentation fault and a denial of service.",
        "git_url": "https://github.com/uclouvain/openjpeg/commit/3c7d42ed766b5f07a5cec47f83cadb9510e5ec8a",
        "commit_title": "wqfix issues 1368:exist a issues of freeing uninitialized pointer in src/bin/jp2/opj_decompress.cthat will cause a segfault",
        "commit_text": "",
        "func_before": "int main(int argc, char **argv)\n{\n    opj_decompress_parameters parameters;           /* decompression parameters */\n\n    OPJ_INT32 num_images, imageno;\n    img_fol_t img_fol;\n    dircnt_t *dirptr = NULL;\n    int failed = 0;\n    OPJ_FLOAT64 t, tCumulative = 0;\n    OPJ_UINT32 numDecompressedImages = 0;\n    OPJ_UINT32 cp_reduce;\n\n    /* set decoding parameters to default values */\n    set_default_parameters(&parameters);\n\n    /* Initialize img_fol */\n    memset(&img_fol, 0, sizeof(img_fol_t));\n\n    /* parse input and get user encoding parameters */\n    if (parse_cmdline_decoder(argc, argv, &parameters, &img_fol) == 1) {\n        failed = 1;\n        goto fin;\n    }\n\n    cp_reduce = parameters.core.cp_reduce;\n    if (getenv(\"USE_OPJ_SET_DECODED_RESOLUTION_FACTOR\") != NULL) {\n        /* For debugging/testing purposes, do not set the cp_reduce member */\n        /* if USE_OPJ_SET_DECODED_RESOLUTION_FACTOR is defined, but used */\n        /* the opj_set_decoded_resolution_factor() API instead */\n        parameters.core.cp_reduce = 0;\n    }\n\n\n    /* Initialize reading of directory */\n    if (img_fol.set_imgdir == 1) {\n        int it_image;\n        num_images = get_num_images(img_fol.imgdirpath);\n\n        dirptr = (dircnt_t*)malloc(sizeof(dircnt_t));\n        if (!dirptr) {\n            destroy_parameters(&parameters);\n            return EXIT_FAILURE;\n        }\n\n        memset(dirptr, 0, sizeof(dircnt_t));\n\n        /* Stores at max 10 image file names */\n        dirptr->filename_buf = (char*)malloc(sizeof(char) *\n                                             (size_t)num_images * OPJ_PATH_LEN);\n        if (!dirptr->filename_buf) {\n            failed = 1;\n            goto fin;\n        }\n\n        dirptr->filename = (char**) malloc((size_t)num_images * sizeof(char*));\n\n        if (!dirptr->filename) {\n            failed = 1;\n            goto fin;\n        }\n        for (it_image = 0; it_image < num_images; it_image++) {\n            dirptr->filename[it_image] = dirptr->filename_buf + it_image * OPJ_PATH_LEN;\n        }\n\n        if (load_images(dirptr, img_fol.imgdirpath) == 1) {\n            failed = 1;\n            goto fin;\n        }\n        if (num_images == 0) {\n            fprintf(stderr, \"Folder is empty\\n\");\n            failed = 1;\n            goto fin;\n        }\n    } else {\n        num_images = 1;\n    }\n\n    /*Decoding image one by one*/\n    for (imageno = 0; imageno < num_images ; imageno++)  {\n        opj_image_t* image = NULL;\n        opj_stream_t *l_stream = NULL;              /* Stream */\n        opj_codec_t* l_codec = NULL;                /* Handle to a decompressor */\n        opj_codestream_index_t* cstr_index = NULL;\n\n        if (!parameters.quiet) {\n            fprintf(stderr, \"\\n\");\n        }\n\n        if (img_fol.set_imgdir == 1) {\n            if (get_next_file(imageno, dirptr, &img_fol, &parameters)) {\n                fprintf(stderr, \"skipping file...\\n\");\n                destroy_parameters(&parameters);\n                continue;\n            }\n        }\n\n        /* read the input file and put it in memory */\n        /* ---------------------------------------- */\n\n        l_stream = opj_stream_create_default_file_stream(parameters.infile, 1);\n        if (!l_stream) {\n            fprintf(stderr, \"ERROR -> failed to create the stream from the file %s\\n\",\n                    parameters.infile);\n            failed = 1;\n            goto fin;\n        }\n\n        /* decode the JPEG2000 stream */\n        /* ---------------------- */\n\n        switch (parameters.decod_format) {\n        case J2K_CFMT: { /* JPEG-2000 codestream */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_J2K);\n            break;\n        }\n        case JP2_CFMT: { /* JPEG 2000 compressed image data */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_JP2);\n            break;\n        }\n        case JPT_CFMT: { /* JPEG 2000, JPIP */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_JPT);\n            break;\n        }\n        default:\n            fprintf(stderr, \"skipping file..\\n\");\n            destroy_parameters(&parameters);\n            opj_stream_destroy(l_stream);\n            continue;\n        }\n\n        if (parameters.quiet) {\n            /* Set all callbacks to quiet */\n            opj_set_info_handler(l_codec, quiet_callback, 00);\n            opj_set_warning_handler(l_codec, quiet_callback, 00);\n            opj_set_error_handler(l_codec, quiet_callback, 00);\n        } else {\n            /* catch events using our callbacks and give a local context */\n            opj_set_info_handler(l_codec, info_callback, 00);\n            opj_set_warning_handler(l_codec, warning_callback, 00);\n            opj_set_error_handler(l_codec, error_callback, 00);\n        }\n\n\n        t = opj_clock();\n\n        /* Setup the decoder decoding parameters using user parameters */\n        if (!opj_setup_decoder(l_codec, &(parameters.core))) {\n            fprintf(stderr, \"ERROR -> opj_decompress: failed to setup the decoder\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            failed = 1;\n            goto fin;\n        }\n\n        if (parameters.num_threads >= 1 &&\n                !opj_codec_set_threads(l_codec, parameters.num_threads)) {\n            fprintf(stderr, \"ERROR -> opj_decompress: failed to set number of threads\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            failed = 1;\n            goto fin;\n        }\n\n        /* Read the main header of the codestream and if necessary the JP2 boxes*/\n        if (! opj_read_header(l_stream, l_codec, &image)) {\n            fprintf(stderr, \"ERROR -> opj_decompress: failed to read the header\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            opj_image_destroy(image);\n            failed = 1;\n            goto fin;\n        }\n\n        if (parameters.numcomps) {\n            if (! opj_set_decoded_components(l_codec,\n                                             parameters.numcomps,\n                                             parameters.comps_indices,\n                                             OPJ_FALSE)) {\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: failed to set the component indices!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        if (getenv(\"USE_OPJ_SET_DECODED_RESOLUTION_FACTOR\") != NULL) {\n            /* For debugging/testing purposes, and also an illustration on how to */\n            /* use the alternative API opj_set_decoded_resolution_factor() instead */\n            /* of setting parameters.cp_reduce */\n            if (! opj_set_decoded_resolution_factor(l_codec, cp_reduce)) {\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: failed to set the resolution factor tile!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        if (!parameters.nb_tile_to_decode) {\n            if (getenv(\"SKIP_OPJ_SET_DECODE_AREA\") != NULL &&\n                    parameters.DA_x0 == 0 &&\n                    parameters.DA_y0 == 0 &&\n                    parameters.DA_x1 == 0 &&\n                    parameters.DA_y1 == 0) {\n                /* For debugging/testing purposes, */\n                /* do nothing if SKIP_OPJ_SET_DECODE_AREA env variable */\n                /* is defined and no decoded area has been set */\n            }\n            /* Optional if you want decode the entire image */\n            else if (!opj_set_decode_area(l_codec, image, (OPJ_INT32)parameters.DA_x0,\n                                          (OPJ_INT32)parameters.DA_y0, (OPJ_INT32)parameters.DA_x1,\n                                          (OPJ_INT32)parameters.DA_y1)) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to set the decoded area\\n\");\n                opj_stream_destroy(l_stream);\n                opj_destroy_codec(l_codec);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n\n            /* Get the decoded image */\n            if (!(opj_decode(l_codec, l_stream, image) &&\n                    opj_end_decompress(l_codec,   l_stream))) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to decode image!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n        } else {\n            if (!(parameters.DA_x0 == 0 &&\n                    parameters.DA_y0 == 0 &&\n                    parameters.DA_x1 == 0 &&\n                    parameters.DA_y1 == 0)) {\n                if (!(parameters.quiet)) {\n                    fprintf(stderr, \"WARNING: -d option ignored when used together with -t\\n\");\n                }\n            }\n\n            if (!opj_get_decoded_tile(l_codec, l_stream, image, parameters.tile_index)) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to decode tile!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n            if (!(parameters.quiet)) {\n                fprintf(stdout, \"tile %d is decoded!\\n\\n\", parameters.tile_index);\n            }\n        }\n\n        tCumulative += opj_clock() - t;\n        numDecompressedImages++;\n\n        /* Close the byte stream */\n        opj_stream_destroy(l_stream);\n\n        if (image->color_space != OPJ_CLRSPC_SYCC\n                && image->numcomps == 3 && image->comps[0].dx == image->comps[0].dy\n                && image->comps[1].dx != 1) {\n            image->color_space = OPJ_CLRSPC_SYCC;\n        } else if (image->numcomps <= 2) {\n            image->color_space = OPJ_CLRSPC_GRAY;\n        }\n\n        if (image->color_space == OPJ_CLRSPC_SYCC) {\n            color_sycc_to_rgb(image);\n        } else if ((image->color_space == OPJ_CLRSPC_CMYK) &&\n                   (parameters.cod_format != TIF_DFMT)) {\n            color_cmyk_to_rgb(image);\n        } else if (image->color_space == OPJ_CLRSPC_EYCC) {\n            color_esycc_to_rgb(image);\n        }\n\n        if (image->icc_profile_buf) {\n#if defined(OPJ_HAVE_LIBLCMS1) || defined(OPJ_HAVE_LIBLCMS2)\n            if (image->icc_profile_len) {\n                color_apply_icc_profile(image);\n            } else {\n                color_cielab_to_rgb(image);\n            }\n#endif\n            free(image->icc_profile_buf);\n            image->icc_profile_buf = NULL;\n            image->icc_profile_len = 0;\n        }\n\n        /* Force output precision */\n        /* ---------------------- */\n        if (parameters.precision != NULL) {\n            OPJ_UINT32 compno;\n            for (compno = 0; compno < image->numcomps; ++compno) {\n                OPJ_UINT32 precno = compno;\n                OPJ_UINT32 prec;\n\n                if (precno >= parameters.nb_precision) {\n                    precno = parameters.nb_precision - 1U;\n                }\n\n                prec = parameters.precision[precno].prec;\n                if (prec == 0) {\n                    prec = image->comps[compno].prec;\n                }\n\n                switch (parameters.precision[precno].mode) {\n                case OPJ_PREC_MODE_CLIP:\n                    clip_component(&(image->comps[compno]), prec);\n                    break;\n                case OPJ_PREC_MODE_SCALE:\n                    scale_component(&(image->comps[compno]), prec);\n                    break;\n                default:\n                    break;\n                }\n\n            }\n        }\n\n        /* Upsample components */\n        /* ------------------- */\n        if (parameters.upsample) {\n            image = upsample_image_components(image);\n            if (image == NULL) {\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: failed to upsample image components!\\n\");\n                opj_destroy_codec(l_codec);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        /* Force RGB output */\n        /* ---------------- */\n        if (parameters.force_rgb) {\n            switch (image->color_space) {\n            case OPJ_CLRSPC_SRGB:\n                break;\n            case OPJ_CLRSPC_GRAY:\n                image = convert_gray_to_rgb(image);\n                break;\n            default:\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: don't know how to convert image to RGB colorspace!\\n\");\n                opj_image_destroy(image);\n                image = NULL;\n                break;\n            }\n            if (image == NULL) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to convert to RGB image!\\n\");\n                opj_destroy_codec(l_codec);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        /* create output image */\n        /* ------------------- */\n        switch (parameters.cod_format) {\n        case PXM_DFMT:          /* PNM PGM PPM */\n            if (imagetopnm(image, parameters.outfile, parameters.split_pnm)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case PGX_DFMT:          /* PGX */\n            if (imagetopgx(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case BMP_DFMT:          /* BMP */\n            if (imagetobmp(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#ifdef OPJ_HAVE_LIBTIFF\n        case TIF_DFMT:          /* TIF(F) */\n            if (imagetotif(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#endif /* OPJ_HAVE_LIBTIFF */\n        case RAW_DFMT:          /* RAW */\n            if (imagetoraw(image, parameters.outfile)) {\n                fprintf(stderr,\n                        \"[ERROR] Error generating raw or yuv file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case RAWL_DFMT:         /* RAWL */\n            if (imagetorawl(image, parameters.outfile)) {\n                fprintf(stderr,\n                        \"[ERROR] Error generating rawl file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case TGA_DFMT:          /* TGA */\n            if (imagetotga(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Error generating tga file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#ifdef OPJ_HAVE_LIBPNG\n        case PNG_DFMT:          /* PNG */\n            if (imagetopng(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Error generating png file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#endif /* OPJ_HAVE_LIBPNG */\n        /* Can happen if output file is TIF(F) or PNG\n         * and OPJ_HAVE_LIBTIF or OPJ_HAVE_LIBPNG is undefined\n        */\n        default:\n            fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n            failed = 1;\n        }\n\n        /* free remaining structures */\n        if (l_codec) {\n            opj_destroy_codec(l_codec);\n        }\n\n\n        /* free image data structure */\n        opj_image_destroy(image);\n\n        /* destroy the codestream index */\n        opj_destroy_cstr_index(&cstr_index);\n\n        if (failed) {\n            (void)remove(parameters.outfile);    /* ignore return value */\n        }\n    }\nfin:\n    destroy_parameters(&parameters);\n    if (failed && img_fol.imgdirpath) {\n        free(img_fol.imgdirpath);\n    }\n    if (dirptr) {\n        if (dirptr->filename) {\n            free(dirptr->filename);\n        }\n        if (dirptr->filename_buf) {\n            free(dirptr->filename_buf);\n        }\n        free(dirptr);\n    }\n    if (numDecompressedImages && !failed && !(parameters.quiet)) {\n        fprintf(stdout, \"decode time: %d ms\\n\",\n                (int)((tCumulative * 1000.0) / (OPJ_FLOAT64)numDecompressedImages));\n    }\n    return failed ? EXIT_FAILURE : EXIT_SUCCESS;\n}",
        "func": "int main(int argc, char **argv)\n{\n    opj_decompress_parameters parameters;           /* decompression parameters */\n\n    OPJ_INT32 num_images, imageno;\n    img_fol_t img_fol;\n    dircnt_t *dirptr = NULL;\n    int failed = 0;\n    OPJ_FLOAT64 t, tCumulative = 0;\n    OPJ_UINT32 numDecompressedImages = 0;\n    OPJ_UINT32 cp_reduce;\n\n    /* set decoding parameters to default values */\n    set_default_parameters(&parameters);\n\n    /* Initialize img_fol */\n    memset(&img_fol, 0, sizeof(img_fol_t));\n\n    /* parse input and get user encoding parameters */\n    if (parse_cmdline_decoder(argc, argv, &parameters, &img_fol) == 1) {\n        failed = 1;\n        goto fin;\n    }\n\n    cp_reduce = parameters.core.cp_reduce;\n    if (getenv(\"USE_OPJ_SET_DECODED_RESOLUTION_FACTOR\") != NULL) {\n        /* For debugging/testing purposes, do not set the cp_reduce member */\n        /* if USE_OPJ_SET_DECODED_RESOLUTION_FACTOR is defined, but used */\n        /* the opj_set_decoded_resolution_factor() API instead */\n        parameters.core.cp_reduce = 0;\n    }\n\n\n    /* Initialize reading of directory */\n    if (img_fol.set_imgdir == 1) {\n        int it_image;\n        num_images = get_num_images(img_fol.imgdirpath);\n\n        dirptr = (dircnt_t*)calloc(1, sizeof(dircnt_t));\n        if (!dirptr) {\n            destroy_parameters(&parameters);\n            return EXIT_FAILURE;\n        }\n\n        memset(dirptr, 0, sizeof(dircnt_t));\n\n        /* Stores at max 10 image file names */\n        dirptr->filename_buf = (char*)malloc(sizeof(char) *\n                                             (size_t)num_images * OPJ_PATH_LEN);\n        if (!dirptr->filename_buf) {\n            failed = 1;\n            goto fin;\n        }\n\n        dirptr->filename = (char**) malloc((size_t)num_images * sizeof(char*));\n\n        if (!dirptr->filename) {\n            failed = 1;\n            goto fin;\n        }\n        for (it_image = 0; it_image < num_images; it_image++) {\n            dirptr->filename[it_image] = dirptr->filename_buf + it_image * OPJ_PATH_LEN;\n        }\n\n        if (load_images(dirptr, img_fol.imgdirpath) == 1) {\n            failed = 1;\n            goto fin;\n        }\n        if (num_images == 0) {\n            fprintf(stderr, \"Folder is empty\\n\");\n            failed = 1;\n            goto fin;\n        }\n    } else {\n        num_images = 1;\n    }\n\n    /*Decoding image one by one*/\n    for (imageno = 0; imageno < num_images ; imageno++)  {\n        opj_image_t* image = NULL;\n        opj_stream_t *l_stream = NULL;              /* Stream */\n        opj_codec_t* l_codec = NULL;                /* Handle to a decompressor */\n        opj_codestream_index_t* cstr_index = NULL;\n\n        if (!parameters.quiet) {\n            fprintf(stderr, \"\\n\");\n        }\n\n        if (img_fol.set_imgdir == 1) {\n            if (get_next_file(imageno, dirptr, &img_fol, &parameters)) {\n                fprintf(stderr, \"skipping file...\\n\");\n                destroy_parameters(&parameters);\n                continue;\n            }\n        }\n\n        /* read the input file and put it in memory */\n        /* ---------------------------------------- */\n\n        l_stream = opj_stream_create_default_file_stream(parameters.infile, 1);\n        if (!l_stream) {\n            fprintf(stderr, \"ERROR -> failed to create the stream from the file %s\\n\",\n                    parameters.infile);\n            failed = 1;\n            goto fin;\n        }\n\n        /* decode the JPEG2000 stream */\n        /* ---------------------- */\n\n        switch (parameters.decod_format) {\n        case J2K_CFMT: { /* JPEG-2000 codestream */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_J2K);\n            break;\n        }\n        case JP2_CFMT: { /* JPEG 2000 compressed image data */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_JP2);\n            break;\n        }\n        case JPT_CFMT: { /* JPEG 2000, JPIP */\n            /* Get a decoder handle */\n            l_codec = opj_create_decompress(OPJ_CODEC_JPT);\n            break;\n        }\n        default:\n            fprintf(stderr, \"skipping file..\\n\");\n            destroy_parameters(&parameters);\n            opj_stream_destroy(l_stream);\n            continue;\n        }\n\n        if (parameters.quiet) {\n            /* Set all callbacks to quiet */\n            opj_set_info_handler(l_codec, quiet_callback, 00);\n            opj_set_warning_handler(l_codec, quiet_callback, 00);\n            opj_set_error_handler(l_codec, quiet_callback, 00);\n        } else {\n            /* catch events using our callbacks and give a local context */\n            opj_set_info_handler(l_codec, info_callback, 00);\n            opj_set_warning_handler(l_codec, warning_callback, 00);\n            opj_set_error_handler(l_codec, error_callback, 00);\n        }\n\n\n        t = opj_clock();\n\n        /* Setup the decoder decoding parameters using user parameters */\n        if (!opj_setup_decoder(l_codec, &(parameters.core))) {\n            fprintf(stderr, \"ERROR -> opj_decompress: failed to setup the decoder\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            failed = 1;\n            goto fin;\n        }\n\n        if (parameters.num_threads >= 1 &&\n                !opj_codec_set_threads(l_codec, parameters.num_threads)) {\n            fprintf(stderr, \"ERROR -> opj_decompress: failed to set number of threads\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            failed = 1;\n            goto fin;\n        }\n\n        /* Read the main header of the codestream and if necessary the JP2 boxes*/\n        if (! opj_read_header(l_stream, l_codec, &image)) {\n            fprintf(stderr, \"ERROR -> opj_decompress: failed to read the header\\n\");\n            opj_stream_destroy(l_stream);\n            opj_destroy_codec(l_codec);\n            opj_image_destroy(image);\n            failed = 1;\n            goto fin;\n        }\n\n        if (parameters.numcomps) {\n            if (! opj_set_decoded_components(l_codec,\n                                             parameters.numcomps,\n                                             parameters.comps_indices,\n                                             OPJ_FALSE)) {\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: failed to set the component indices!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        if (getenv(\"USE_OPJ_SET_DECODED_RESOLUTION_FACTOR\") != NULL) {\n            /* For debugging/testing purposes, and also an illustration on how to */\n            /* use the alternative API opj_set_decoded_resolution_factor() instead */\n            /* of setting parameters.cp_reduce */\n            if (! opj_set_decoded_resolution_factor(l_codec, cp_reduce)) {\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: failed to set the resolution factor tile!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        if (!parameters.nb_tile_to_decode) {\n            if (getenv(\"SKIP_OPJ_SET_DECODE_AREA\") != NULL &&\n                    parameters.DA_x0 == 0 &&\n                    parameters.DA_y0 == 0 &&\n                    parameters.DA_x1 == 0 &&\n                    parameters.DA_y1 == 0) {\n                /* For debugging/testing purposes, */\n                /* do nothing if SKIP_OPJ_SET_DECODE_AREA env variable */\n                /* is defined and no decoded area has been set */\n            }\n            /* Optional if you want decode the entire image */\n            else if (!opj_set_decode_area(l_codec, image, (OPJ_INT32)parameters.DA_x0,\n                                          (OPJ_INT32)parameters.DA_y0, (OPJ_INT32)parameters.DA_x1,\n                                          (OPJ_INT32)parameters.DA_y1)) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to set the decoded area\\n\");\n                opj_stream_destroy(l_stream);\n                opj_destroy_codec(l_codec);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n\n            /* Get the decoded image */\n            if (!(opj_decode(l_codec, l_stream, image) &&\n                    opj_end_decompress(l_codec,   l_stream))) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to decode image!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n        } else {\n            if (!(parameters.DA_x0 == 0 &&\n                    parameters.DA_y0 == 0 &&\n                    parameters.DA_x1 == 0 &&\n                    parameters.DA_y1 == 0)) {\n                if (!(parameters.quiet)) {\n                    fprintf(stderr, \"WARNING: -d option ignored when used together with -t\\n\");\n                }\n            }\n\n            if (!opj_get_decoded_tile(l_codec, l_stream, image, parameters.tile_index)) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to decode tile!\\n\");\n                opj_destroy_codec(l_codec);\n                opj_stream_destroy(l_stream);\n                opj_image_destroy(image);\n                failed = 1;\n                goto fin;\n            }\n            if (!(parameters.quiet)) {\n                fprintf(stdout, \"tile %d is decoded!\\n\\n\", parameters.tile_index);\n            }\n        }\n\n        tCumulative += opj_clock() - t;\n        numDecompressedImages++;\n\n        /* Close the byte stream */\n        opj_stream_destroy(l_stream);\n\n        if (image->color_space != OPJ_CLRSPC_SYCC\n                && image->numcomps == 3 && image->comps[0].dx == image->comps[0].dy\n                && image->comps[1].dx != 1) {\n            image->color_space = OPJ_CLRSPC_SYCC;\n        } else if (image->numcomps <= 2) {\n            image->color_space = OPJ_CLRSPC_GRAY;\n        }\n\n        if (image->color_space == OPJ_CLRSPC_SYCC) {\n            color_sycc_to_rgb(image);\n        } else if ((image->color_space == OPJ_CLRSPC_CMYK) &&\n                   (parameters.cod_format != TIF_DFMT)) {\n            color_cmyk_to_rgb(image);\n        } else if (image->color_space == OPJ_CLRSPC_EYCC) {\n            color_esycc_to_rgb(image);\n        }\n\n        if (image->icc_profile_buf) {\n#if defined(OPJ_HAVE_LIBLCMS1) || defined(OPJ_HAVE_LIBLCMS2)\n            if (image->icc_profile_len) {\n                color_apply_icc_profile(image);\n            } else {\n                color_cielab_to_rgb(image);\n            }\n#endif\n            free(image->icc_profile_buf);\n            image->icc_profile_buf = NULL;\n            image->icc_profile_len = 0;\n        }\n\n        /* Force output precision */\n        /* ---------------------- */\n        if (parameters.precision != NULL) {\n            OPJ_UINT32 compno;\n            for (compno = 0; compno < image->numcomps; ++compno) {\n                OPJ_UINT32 precno = compno;\n                OPJ_UINT32 prec;\n\n                if (precno >= parameters.nb_precision) {\n                    precno = parameters.nb_precision - 1U;\n                }\n\n                prec = parameters.precision[precno].prec;\n                if (prec == 0) {\n                    prec = image->comps[compno].prec;\n                }\n\n                switch (parameters.precision[precno].mode) {\n                case OPJ_PREC_MODE_CLIP:\n                    clip_component(&(image->comps[compno]), prec);\n                    break;\n                case OPJ_PREC_MODE_SCALE:\n                    scale_component(&(image->comps[compno]), prec);\n                    break;\n                default:\n                    break;\n                }\n\n            }\n        }\n\n        /* Upsample components */\n        /* ------------------- */\n        if (parameters.upsample) {\n            image = upsample_image_components(image);\n            if (image == NULL) {\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: failed to upsample image components!\\n\");\n                opj_destroy_codec(l_codec);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        /* Force RGB output */\n        /* ---------------- */\n        if (parameters.force_rgb) {\n            switch (image->color_space) {\n            case OPJ_CLRSPC_SRGB:\n                break;\n            case OPJ_CLRSPC_GRAY:\n                image = convert_gray_to_rgb(image);\n                break;\n            default:\n                fprintf(stderr,\n                        \"ERROR -> opj_decompress: don't know how to convert image to RGB colorspace!\\n\");\n                opj_image_destroy(image);\n                image = NULL;\n                break;\n            }\n            if (image == NULL) {\n                fprintf(stderr, \"ERROR -> opj_decompress: failed to convert to RGB image!\\n\");\n                opj_destroy_codec(l_codec);\n                failed = 1;\n                goto fin;\n            }\n        }\n\n        /* create output image */\n        /* ------------------- */\n        switch (parameters.cod_format) {\n        case PXM_DFMT:          /* PNM PGM PPM */\n            if (imagetopnm(image, parameters.outfile, parameters.split_pnm)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case PGX_DFMT:          /* PGX */\n            if (imagetopgx(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case BMP_DFMT:          /* BMP */\n            if (imagetobmp(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#ifdef OPJ_HAVE_LIBTIFF\n        case TIF_DFMT:          /* TIF(F) */\n            if (imagetotif(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#endif /* OPJ_HAVE_LIBTIFF */\n        case RAW_DFMT:          /* RAW */\n            if (imagetoraw(image, parameters.outfile)) {\n                fprintf(stderr,\n                        \"[ERROR] Error generating raw or yuv file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case RAWL_DFMT:         /* RAWL */\n            if (imagetorawl(image, parameters.outfile)) {\n                fprintf(stderr,\n                        \"[ERROR] Error generating rawl file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n\n        case TGA_DFMT:          /* TGA */\n            if (imagetotga(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Error generating tga file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#ifdef OPJ_HAVE_LIBPNG\n        case PNG_DFMT:          /* PNG */\n            if (imagetopng(image, parameters.outfile)) {\n                fprintf(stderr, \"[ERROR] Error generating png file. Outfile %s not generated\\n\",\n                        parameters.outfile);\n                failed = 1;\n            } else if (!(parameters.quiet)) {\n                fprintf(stdout, \"[INFO] Generated Outfile %s\\n\", parameters.outfile);\n            }\n            break;\n#endif /* OPJ_HAVE_LIBPNG */\n        /* Can happen if output file is TIF(F) or PNG\n         * and OPJ_HAVE_LIBTIF or OPJ_HAVE_LIBPNG is undefined\n        */\n        default:\n            fprintf(stderr, \"[ERROR] Outfile %s not generated\\n\", parameters.outfile);\n            failed = 1;\n        }\n\n        /* free remaining structures */\n        if (l_codec) {\n            opj_destroy_codec(l_codec);\n        }\n\n\n        /* free image data structure */\n        opj_image_destroy(image);\n\n        /* destroy the codestream index */\n        opj_destroy_cstr_index(&cstr_index);\n\n        if (failed) {\n            (void)remove(parameters.outfile);    /* ignore return value */\n        }\n    }\nfin:\n    destroy_parameters(&parameters);\n    if (failed && img_fol.imgdirpath) {\n        free(img_fol.imgdirpath);\n    }\n    if (dirptr) {\n        if (dirptr->filename) {\n            free(dirptr->filename);\n        }\n        if (dirptr->filename_buf) {\n            free(dirptr->filename_buf);\n        }\n        free(dirptr);\n    }\n    if (numDecompressedImages && !failed && !(parameters.quiet)) {\n        fprintf(stdout, \"decode time: %d ms\\n\",\n                (int)((tCumulative * 1000.0) / (OPJ_FLOAT64)numDecompressedImages));\n    }\n    return failed ? EXIT_FAILURE : EXIT_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -36,7 +36,7 @@\n         int it_image;\n         num_images = get_num_images(img_fol.imgdirpath);\n \n-        dirptr = (dircnt_t*)malloc(sizeof(dircnt_t));\n+        dirptr = (dircnt_t*)calloc(1, sizeof(dircnt_t));\n         if (!dirptr) {\n             destroy_parameters(&parameters);\n             return EXIT_FAILURE;",
        "diff_line_info": {
            "deleted_lines": [
                "        dirptr = (dircnt_t*)malloc(sizeof(dircnt_t));"
            ],
            "added_lines": [
                "        dirptr = (dircnt_t*)calloc(1, sizeof(dircnt_t));"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-6836",
        "func_name": "qemu/vmxnet3_complete_packet",
        "description": "The vmxnet3_complete_packet function in hw/net/vmxnet3.c in QEMU (aka Quick Emulator) allows local guest OS administrators to obtain sensitive host memory information by leveraging failure to initialize the txcq_descr object.",
        "git_url": "https://github.com/qemu/qemu/commit/fdda170e50b8af062cf5741e12c4fb5e57a2eacf",
        "commit_title": "net: vmxnet: initialise local tx descriptor",
        "commit_text": " In Vmxnet3 device emulator while processing transmit(tx) queue, when it reaches end of packet, it calls vmxnet3_complete_packet. In that local 'txcq_descr' object is not initialised, which could leak host memory bytes a guest. ",
        "func_before": "static void vmxnet3_complete_packet(VMXNET3State *s, int qidx, uint32_t tx_ridx)\n{\n    struct Vmxnet3_TxCompDesc txcq_descr;\n    PCIDevice *d = PCI_DEVICE(s);\n\n    VMXNET3_RING_DUMP(VMW_RIPRN, \"TXC\", qidx, &s->txq_descr[qidx].comp_ring);\n\n    txcq_descr.txdIdx = tx_ridx;\n    txcq_descr.gen = vmxnet3_ring_curr_gen(&s->txq_descr[qidx].comp_ring);\n\n    vmxnet3_ring_write_curr_cell(d, &s->txq_descr[qidx].comp_ring, &txcq_descr);\n\n    /* Flush changes in TX descriptor before changing the counter value */\n    smp_wmb();\n\n    vmxnet3_inc_tx_completion_counter(s, qidx);\n    vmxnet3_trigger_interrupt(s, s->txq_descr[qidx].intr_idx);\n}",
        "func": "static void vmxnet3_complete_packet(VMXNET3State *s, int qidx, uint32_t tx_ridx)\n{\n    struct Vmxnet3_TxCompDesc txcq_descr;\n    PCIDevice *d = PCI_DEVICE(s);\n\n    VMXNET3_RING_DUMP(VMW_RIPRN, \"TXC\", qidx, &s->txq_descr[qidx].comp_ring);\n\n    memset(&txcq_descr, 0, sizeof(txcq_descr));\n    txcq_descr.txdIdx = tx_ridx;\n    txcq_descr.gen = vmxnet3_ring_curr_gen(&s->txq_descr[qidx].comp_ring);\n\n    vmxnet3_ring_write_curr_cell(d, &s->txq_descr[qidx].comp_ring, &txcq_descr);\n\n    /* Flush changes in TX descriptor before changing the counter value */\n    smp_wmb();\n\n    vmxnet3_inc_tx_completion_counter(s, qidx);\n    vmxnet3_trigger_interrupt(s, s->txq_descr[qidx].intr_idx);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,6 +5,7 @@\n \n     VMXNET3_RING_DUMP(VMW_RIPRN, \"TXC\", qidx, &s->txq_descr[qidx].comp_ring);\n \n+    memset(&txcq_descr, 0, sizeof(txcq_descr));\n     txcq_descr.txdIdx = tx_ridx;\n     txcq_descr.gen = vmxnet3_ring_curr_gen(&s->txq_descr[qidx].comp_ring);\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    memset(&txcq_descr, 0, sizeof(txcq_descr));"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-9445",
        "func_name": "gstreamer/gst-plugins-bad/vmnc_handle_packet",
        "description": "Integer overflow in the vmnc decoder in the gstreamer allows remote attackers to cause a denial of service (crash) via large width and height values, which triggers a buffer overflow.",
        "git_url": "https://cgit.freedesktop.org/gstreamer/gst-plugins-bad/commit/gst/vmnc/vmncdec.c?id=4cb1bcf1422bbcd79c0f683edb7ee85e3f7a31fe",
        "commit_title": "We will allocate a screen area of width*height*bpp bytes, however this",
        "commit_text": "calculation can easily overflow if too high width or height are given inside the stream. Nonetheless we would just assume that enough memory was allocated, try to fill it and overwrite as much memory as wanted.  Also allocate the screen area filled with zeroes to ensure that we start with full-black and not any random (or not so random) data.  https://scarybeastsecurity.blogspot.gr/2016/11/0day-poc-risky-design-decisions-in.html  Ideally we should just remove this plugin in favour of the one in gst-libav, which generally seems to be of better code quality.  https://bugzilla.gnome.org/show_bug.cgi?id=774533 ",
        "func_before": "static int\nvmnc_handle_packet (GstVMncDec * dec, const guint8 * data, int len,\n    gboolean decode)\n{\n  int type;\n  int offset = 0;\n\n  if (len < 4) {\n    GST_LOG_OBJECT (dec, \"Packet too short\");\n    return ERROR_INSUFFICIENT_DATA;\n  }\n\n  type = data[0];\n\n  switch (type) {\n    case 0:\n    {\n      int numrect = RFB_GET_UINT16 (data + 2);\n      int i;\n      int read;\n\n      offset = 4;\n\n      for (i = 0; i < numrect; i++) {\n        struct RfbRectangle r;\n        rectangle_handler handler;\n\n        if (len < offset + 12) {\n          GST_LOG_OBJECT (dec,\n              \"Packet too short for rectangle header: %d < %d\",\n              len, offset + 12);\n          return ERROR_INSUFFICIENT_DATA;\n        }\n        GST_LOG_OBJECT (dec, \"Reading rectangle %d\", i);\n        r.x = RFB_GET_UINT16 (data + offset);\n        r.y = RFB_GET_UINT16 (data + offset + 2);\n        r.width = RFB_GET_UINT16 (data + offset + 4);\n        r.height = RFB_GET_UINT16 (data + offset + 6);\n        r.type = RFB_GET_UINT32 (data + offset + 8);\n\n        if (r.type != TYPE_WMVi) {\n          /* We must have a WMVi packet to initialise things before we can \n           * continue */\n          if (!dec->have_format) {\n            GST_WARNING_OBJECT (dec, \"Received packet without WMVi: %d\",\n                r.type);\n            return ERROR_INVALID;\n          }\n          if (r.x + r.width > dec->format.width ||\n              r.y + r.height > dec->format.height) {\n            GST_WARNING_OBJECT (dec, \"Rectangle out of range, type %d\", r.type);\n            return ERROR_INVALID;\n          }\n        }\n\n        switch (r.type) {\n          case TYPE_WMVd:\n            handler = vmnc_handle_wmvd_rectangle;\n            break;\n          case TYPE_WMVe:\n            handler = vmnc_handle_wmve_rectangle;\n            break;\n          case TYPE_WMVf:\n            handler = vmnc_handle_wmvf_rectangle;\n            break;\n          case TYPE_WMVg:\n            handler = vmnc_handle_wmvg_rectangle;\n            break;\n          case TYPE_WMVh:\n            handler = vmnc_handle_wmvh_rectangle;\n            break;\n          case TYPE_WMVi:\n            handler = vmnc_handle_wmvi_rectangle;\n            break;\n          case TYPE_WMVj:\n            handler = vmnc_handle_wmvj_rectangle;\n            break;\n          case TYPE_RAW:\n            handler = vmnc_handle_raw_rectangle;\n            break;\n          case TYPE_COPY:\n            handler = vmnc_handle_copy_rectangle;\n            break;\n          case TYPE_HEXTILE:\n            handler = vmnc_handle_hextile_rectangle;\n            break;\n          default:\n            GST_WARNING_OBJECT (dec, \"Unknown rectangle type\");\n            return ERROR_INVALID;\n        }\n\n        read = handler (dec, &r, data + offset + 12, len - offset - 12, decode);\n        if (read < 0) {\n          GST_DEBUG_OBJECT (dec, \"Error calling rectangle handler\\n\");\n          return read;\n        }\n        offset += 12 + read;\n      }\n      break;\n    }\n    default:\n      GST_WARNING_OBJECT (dec, \"Packet type unknown: %d\", type);\n      return ERROR_INVALID;\n  }\n\n  return offset;\n}",
        "func": "static int\nvmnc_handle_packet (GstVMncDec * dec, const guint8 * data, int len,\n    gboolean decode)\n{\n  int type;\n  int offset = 0;\n\n  if (len < 4) {\n    GST_LOG_OBJECT (dec, \"Packet too short\");\n    return ERROR_INSUFFICIENT_DATA;\n  }\n\n  type = data[0];\n\n  switch (type) {\n    case 0:\n    {\n      int numrect = RFB_GET_UINT16 (data + 2);\n      int i;\n      int read;\n\n      offset = 4;\n\n      for (i = 0; i < numrect; i++) {\n        struct RfbRectangle r;\n        rectangle_handler handler;\n\n        if (len < offset + 12) {\n          GST_LOG_OBJECT (dec,\n              \"Packet too short for rectangle header: %d < %d\",\n              len, offset + 12);\n          return ERROR_INSUFFICIENT_DATA;\n        }\n        GST_LOG_OBJECT (dec, \"Reading rectangle %d\", i);\n        r.x = RFB_GET_UINT16 (data + offset);\n        r.y = RFB_GET_UINT16 (data + offset + 2);\n        r.width = RFB_GET_UINT16 (data + offset + 4);\n        r.height = RFB_GET_UINT16 (data + offset + 6);\n        r.type = RFB_GET_UINT32 (data + offset + 8);\n\n        if (r.type != TYPE_WMVi) {\n          /* We must have a WMVi packet to initialise things before we can \n           * continue */\n          if (!dec->have_format) {\n            GST_WARNING_OBJECT (dec, \"Received packet without WMVi: %d\",\n                r.type);\n            return ERROR_INVALID;\n          }\n          if (r.x + r.width > dec->format.width ||\n              r.y + r.height > dec->format.height) {\n            GST_WARNING_OBJECT (dec, \"Rectangle out of range, type %d\", r.type);\n            return ERROR_INVALID;\n          }\n        } else if (r.width > 16384 || r.height > 16384) {\n          GST_WARNING_OBJECT (dec, \"Width or height too high: %ux%u\", r.width,\n              r.height);\n          return ERROR_INVALID;\n        }\n\n        switch (r.type) {\n          case TYPE_WMVd:\n            handler = vmnc_handle_wmvd_rectangle;\n            break;\n          case TYPE_WMVe:\n            handler = vmnc_handle_wmve_rectangle;\n            break;\n          case TYPE_WMVf:\n            handler = vmnc_handle_wmvf_rectangle;\n            break;\n          case TYPE_WMVg:\n            handler = vmnc_handle_wmvg_rectangle;\n            break;\n          case TYPE_WMVh:\n            handler = vmnc_handle_wmvh_rectangle;\n            break;\n          case TYPE_WMVi:\n            handler = vmnc_handle_wmvi_rectangle;\n            break;\n          case TYPE_WMVj:\n            handler = vmnc_handle_wmvj_rectangle;\n            break;\n          case TYPE_RAW:\n            handler = vmnc_handle_raw_rectangle;\n            break;\n          case TYPE_COPY:\n            handler = vmnc_handle_copy_rectangle;\n            break;\n          case TYPE_HEXTILE:\n            handler = vmnc_handle_hextile_rectangle;\n            break;\n          default:\n            GST_WARNING_OBJECT (dec, \"Unknown rectangle type\");\n            return ERROR_INVALID;\n        }\n\n        read = handler (dec, &r, data + offset + 12, len - offset - 12, decode);\n        if (read < 0) {\n          GST_DEBUG_OBJECT (dec, \"Error calling rectangle handler\\n\");\n          return read;\n        }\n        offset += 12 + read;\n      }\n      break;\n    }\n    default:\n      GST_WARNING_OBJECT (dec, \"Packet type unknown: %d\", type);\n      return ERROR_INVALID;\n  }\n\n  return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -51,6 +51,10 @@\n             GST_WARNING_OBJECT (dec, \"Rectangle out of range, type %d\", r.type);\n             return ERROR_INVALID;\n           }\n+        } else if (r.width > 16384 || r.height > 16384) {\n+          GST_WARNING_OBJECT (dec, \"Width or height too high: %ux%u\", r.width,\n+              r.height);\n+          return ERROR_INVALID;\n         }\n \n         switch (r.type) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        } else if (r.width > 16384 || r.height > 16384) {",
                "          GST_WARNING_OBJECT (dec, \"Width or height too high: %ux%u\", r.width,",
                "              r.height);",
                "          return ERROR_INVALID;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-9445",
        "func_name": "gstreamer/gst-plugins-bad/vmnc_handle_wmvi_rectangle",
        "description": "Integer overflow in the vmnc decoder in the gstreamer allows remote attackers to cause a denial of service (crash) via large width and height values, which triggers a buffer overflow.",
        "git_url": "https://cgit.freedesktop.org/gstreamer/gst-plugins-bad/commit/gst/vmnc/vmncdec.c?id=4cb1bcf1422bbcd79c0f683edb7ee85e3f7a31fe",
        "commit_title": "We will allocate a screen area of width*height*bpp bytes, however this",
        "commit_text": "calculation can easily overflow if too high width or height are given inside the stream. Nonetheless we would just assume that enough memory was allocated, try to fill it and overwrite as much memory as wanted.  Also allocate the screen area filled with zeroes to ensure that we start with full-black and not any random (or not so random) data.  https://scarybeastsecurity.blogspot.gr/2016/11/0day-poc-risky-design-decisions-in.html  Ideally we should just remove this plugin in favour of the one in gst-libav, which generally seems to be of better code quality.  https://bugzilla.gnome.org/show_bug.cgi?id=774533 ",
        "func_before": "static int\nvmnc_handle_wmvi_rectangle (GstVMncDec * dec, struct RfbRectangle *rect,\n    const guint8 * data, int len, gboolean decode)\n{\n  GstVideoFormat format;\n  gint bpp, tc;\n  guint32 redmask, greenmask, bluemask;\n  guint32 endianness, dataendianness;\n  GstVideoCodecState *state;\n\n  /* A WMVi rectangle has a 16byte payload */\n  if (len < 16) {\n    GST_DEBUG_OBJECT (dec, \"Bad WMVi rect: too short\");\n    return ERROR_INSUFFICIENT_DATA;\n  }\n\n  /* We only compare 13 bytes; ignoring the 3 padding bytes at the end */\n  if (dec->have_format && memcmp (data, dec->format.descriptor, 13) == 0) {\n    /* Nothing changed, so just exit */\n    return 16;\n  }\n\n  /* Store the whole block for simple comparison later */\n  memcpy (dec->format.descriptor, data, 16);\n\n  if (rect->x != 0 || rect->y != 0) {\n    GST_WARNING_OBJECT (dec, \"Bad WMVi rect: wrong coordinates\");\n    return ERROR_INVALID;\n  }\n\n  bpp = data[0];\n  dec->format.depth = data[1];\n  dec->format.big_endian = data[2];\n  dataendianness = data[2] ? G_BIG_ENDIAN : G_LITTLE_ENDIAN;\n  tc = data[3];\n\n  if (bpp != 8 && bpp != 16 && bpp != 32) {\n    GST_WARNING_OBJECT (dec, \"Bad bpp value: %d\", bpp);\n    return ERROR_INVALID;\n  }\n\n  if (!tc) {\n    GST_WARNING_OBJECT (dec, \"Paletted video not supported\");\n    return ERROR_INVALID;\n  }\n\n  dec->format.bytes_per_pixel = bpp / 8;\n  dec->format.width = rect->width;\n  dec->format.height = rect->height;\n\n  redmask = (guint32) (RFB_GET_UINT16 (data + 4)) << data[10];\n  greenmask = (guint32) (RFB_GET_UINT16 (data + 6)) << data[11];\n  bluemask = (guint32) (RFB_GET_UINT16 (data + 8)) << data[12];\n\n  GST_DEBUG_OBJECT (dec, \"Red: mask %d, shift %d\",\n      RFB_GET_UINT16 (data + 4), data[10]);\n  GST_DEBUG_OBJECT (dec, \"Green: mask %d, shift %d\",\n      RFB_GET_UINT16 (data + 6), data[11]);\n  GST_DEBUG_OBJECT (dec, \"Blue: mask %d, shift %d\",\n      RFB_GET_UINT16 (data + 8), data[12]);\n  GST_DEBUG_OBJECT (dec, \"BPP: %d. endianness: %s\", bpp,\n      data[2] ? \"big\" : \"little\");\n\n  /* GStreamer's RGB caps are a bit weird. */\n  if (bpp == 8) {\n    endianness = G_BYTE_ORDER;  /* Doesn't matter */\n  } else if (bpp == 16) {\n    /* We require host-endian. */\n    endianness = G_BYTE_ORDER;\n  } else {                      /* bpp == 32 */\n    /* We require big endian */\n    endianness = G_BIG_ENDIAN;\n    if (endianness != dataendianness) {\n      redmask = GUINT32_SWAP_LE_BE (redmask);\n      greenmask = GUINT32_SWAP_LE_BE (greenmask);\n      bluemask = GUINT32_SWAP_LE_BE (bluemask);\n    }\n  }\n\n  format = gst_video_format_from_masks (dec->format.depth, bpp, endianness,\n      redmask, greenmask, bluemask, 0);\n\n  GST_DEBUG_OBJECT (dec, \"From depth: %d bpp: %u endianess: %s redmask: %X \"\n      \"greenmask: %X bluemask: %X got format %s\",\n      dec->format.depth, bpp, endianness == G_BIG_ENDIAN ? \"BE\" : \"LE\",\n      GUINT32_FROM_BE (redmask), GUINT32_FROM_BE (greenmask),\n      GUINT32_FROM_BE (bluemask),\n      format == GST_VIDEO_FORMAT_UNKNOWN ? \"UNKOWN\" :\n      gst_video_format_to_string (format));\n\n  if (format == GST_VIDEO_FORMAT_UNKNOWN) {\n    GST_WARNING_OBJECT (dec, \"Video format unknown to GStreamer\");\n    return ERROR_INVALID;\n  }\n\n  dec->have_format = TRUE;\n  if (!decode) {\n    GST_LOG_OBJECT (dec, \"Parsing, not setting caps\");\n    return 16;\n  }\n\n\n  state = gst_video_decoder_set_output_state (GST_VIDEO_DECODER (dec), format,\n      rect->width, rect->height, dec->input_state);\n  gst_video_codec_state_unref (state);\n\n  g_free (dec->imagedata);\n  dec->imagedata = g_malloc (dec->format.width * dec->format.height *\n      dec->format.bytes_per_pixel);\n  GST_DEBUG_OBJECT (dec, \"Allocated image data at %p\", dec->imagedata);\n\n  dec->format.stride = dec->format.width * dec->format.bytes_per_pixel;\n\n  return 16;\n}",
        "func": "static int\nvmnc_handle_wmvi_rectangle (GstVMncDec * dec, struct RfbRectangle *rect,\n    const guint8 * data, int len, gboolean decode)\n{\n  GstVideoFormat format;\n  gint bpp, tc;\n  guint32 redmask, greenmask, bluemask;\n  guint32 endianness, dataendianness;\n  GstVideoCodecState *state;\n\n  /* A WMVi rectangle has a 16byte payload */\n  if (len < 16) {\n    GST_DEBUG_OBJECT (dec, \"Bad WMVi rect: too short\");\n    return ERROR_INSUFFICIENT_DATA;\n  }\n\n  /* We only compare 13 bytes; ignoring the 3 padding bytes at the end */\n  if (dec->have_format && memcmp (data, dec->format.descriptor, 13) == 0) {\n    /* Nothing changed, so just exit */\n    return 16;\n  }\n\n  /* Store the whole block for simple comparison later */\n  memcpy (dec->format.descriptor, data, 16);\n\n  if (rect->x != 0 || rect->y != 0) {\n    GST_WARNING_OBJECT (dec, \"Bad WMVi rect: wrong coordinates\");\n    return ERROR_INVALID;\n  }\n\n  bpp = data[0];\n  dec->format.depth = data[1];\n  dec->format.big_endian = data[2];\n  dataendianness = data[2] ? G_BIG_ENDIAN : G_LITTLE_ENDIAN;\n  tc = data[3];\n\n  if (bpp != 8 && bpp != 16 && bpp != 32) {\n    GST_WARNING_OBJECT (dec, \"Bad bpp value: %d\", bpp);\n    return ERROR_INVALID;\n  }\n\n  if (!tc) {\n    GST_WARNING_OBJECT (dec, \"Paletted video not supported\");\n    return ERROR_INVALID;\n  }\n\n  dec->format.bytes_per_pixel = bpp / 8;\n  dec->format.width = rect->width;\n  dec->format.height = rect->height;\n\n  redmask = (guint32) (RFB_GET_UINT16 (data + 4)) << data[10];\n  greenmask = (guint32) (RFB_GET_UINT16 (data + 6)) << data[11];\n  bluemask = (guint32) (RFB_GET_UINT16 (data + 8)) << data[12];\n\n  GST_DEBUG_OBJECT (dec, \"Red: mask %d, shift %d\",\n      RFB_GET_UINT16 (data + 4), data[10]);\n  GST_DEBUG_OBJECT (dec, \"Green: mask %d, shift %d\",\n      RFB_GET_UINT16 (data + 6), data[11]);\n  GST_DEBUG_OBJECT (dec, \"Blue: mask %d, shift %d\",\n      RFB_GET_UINT16 (data + 8), data[12]);\n  GST_DEBUG_OBJECT (dec, \"BPP: %d. endianness: %s\", bpp,\n      data[2] ? \"big\" : \"little\");\n\n  /* GStreamer's RGB caps are a bit weird. */\n  if (bpp == 8) {\n    endianness = G_BYTE_ORDER;  /* Doesn't matter */\n  } else if (bpp == 16) {\n    /* We require host-endian. */\n    endianness = G_BYTE_ORDER;\n  } else {                      /* bpp == 32 */\n    /* We require big endian */\n    endianness = G_BIG_ENDIAN;\n    if (endianness != dataendianness) {\n      redmask = GUINT32_SWAP_LE_BE (redmask);\n      greenmask = GUINT32_SWAP_LE_BE (greenmask);\n      bluemask = GUINT32_SWAP_LE_BE (bluemask);\n    }\n  }\n\n  format = gst_video_format_from_masks (dec->format.depth, bpp, endianness,\n      redmask, greenmask, bluemask, 0);\n\n  GST_DEBUG_OBJECT (dec, \"From depth: %d bpp: %u endianess: %s redmask: %X \"\n      \"greenmask: %X bluemask: %X got format %s\",\n      dec->format.depth, bpp, endianness == G_BIG_ENDIAN ? \"BE\" : \"LE\",\n      GUINT32_FROM_BE (redmask), GUINT32_FROM_BE (greenmask),\n      GUINT32_FROM_BE (bluemask),\n      format == GST_VIDEO_FORMAT_UNKNOWN ? \"UNKOWN\" :\n      gst_video_format_to_string (format));\n\n  if (format == GST_VIDEO_FORMAT_UNKNOWN) {\n    GST_WARNING_OBJECT (dec, \"Video format unknown to GStreamer\");\n    return ERROR_INVALID;\n  }\n\n  dec->have_format = TRUE;\n  if (!decode) {\n    GST_LOG_OBJECT (dec, \"Parsing, not setting caps\");\n    return 16;\n  }\n\n\n  state = gst_video_decoder_set_output_state (GST_VIDEO_DECODER (dec), format,\n      rect->width, rect->height, dec->input_state);\n  gst_video_codec_state_unref (state);\n\n  g_free (dec->imagedata);\n  dec->imagedata = g_malloc0 (dec->format.width * dec->format.height *\n      dec->format.bytes_per_pixel);\n  GST_DEBUG_OBJECT (dec, \"Allocated image data at %p\", dec->imagedata);\n\n  dec->format.stride = dec->format.width * dec->format.bytes_per_pixel;\n\n  return 16;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -105,7 +105,7 @@\n   gst_video_codec_state_unref (state);\n \n   g_free (dec->imagedata);\n-  dec->imagedata = g_malloc (dec->format.width * dec->format.height *\n+  dec->imagedata = g_malloc0 (dec->format.width * dec->format.height *\n       dec->format.bytes_per_pixel);\n   GST_DEBUG_OBJECT (dec, \"Allocated image data at %p\", dec->imagedata);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "  dec->imagedata = g_malloc (dec->format.width * dec->format.height *"
            ],
            "added_lines": [
                "  dec->imagedata = g_malloc0 (dec->format.width * dec->format.height *"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-4343",
        "func_name": "torvalds/linux/bfa_attach",
        "description": "drivers/scsi/bfa/bfa_core.c in the Linux kernel before 2.6.35 does not initialize a certain port data structure, which allows local users to cause a denial of service (system crash) via read operations on an fc_host statistics file.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=7873ca4e4401f0ecd8868bf1543113467e6bae61",
        "commit_title": "The port data structure related to fc_host statistics collection is",
        "commit_text": "not initialized. This causes system crash when reading the fc_host statistics. The fix is to initialize port structure during driver attach.  ",
        "func_before": "void\nbfa_attach(struct bfa_s *bfa, void *bfad, struct bfa_iocfc_cfg_s *cfg,\n\t       struct bfa_meminfo_s *meminfo, struct bfa_pcidev_s *pcidev)\n{\n\tint             i;\n\tstruct bfa_mem_elem_s *melem;\n\n\tbfa->fcs = BFA_FALSE;\n\n\tbfa_assert((cfg != NULL) && (meminfo != NULL));\n\n\t/**\n\t * initialize all memory pointers for iterative allocation\n\t */\n\tfor (i = 0; i < BFA_MEM_TYPE_MAX; i++) {\n\t\tmelem = meminfo->meminfo + i;\n\t\tmelem->kva_curp = melem->kva;\n\t\tmelem->dma_curp = melem->dma;\n\t}\n\n\tbfa_iocfc_attach(bfa, bfad, cfg, meminfo, pcidev);\n\n\tfor (i = 0; hal_mods[i]; i++)\n\t\thal_mods[i]->attach(bfa, bfad, cfg, meminfo, pcidev);\n\n}",
        "func": "void\nbfa_attach(struct bfa_s *bfa, void *bfad, struct bfa_iocfc_cfg_s *cfg,\n\t       struct bfa_meminfo_s *meminfo, struct bfa_pcidev_s *pcidev)\n{\n\tint             i;\n\tstruct bfa_mem_elem_s *melem;\n\n\tbfa->fcs = BFA_FALSE;\n\n\tbfa_assert((cfg != NULL) && (meminfo != NULL));\n\n\t/**\n\t * initialize all memory pointers for iterative allocation\n\t */\n\tfor (i = 0; i < BFA_MEM_TYPE_MAX; i++) {\n\t\tmelem = meminfo->meminfo + i;\n\t\tmelem->kva_curp = melem->kva;\n\t\tmelem->dma_curp = melem->dma;\n\t}\n\n\tbfa_iocfc_attach(bfa, bfad, cfg, meminfo, pcidev);\n\n\tfor (i = 0; hal_mods[i]; i++)\n\t\thal_mods[i]->attach(bfa, bfad, cfg, meminfo, pcidev);\n\n\tbfa_com_port_attach(bfa, meminfo);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,4 +23,5 @@\n \tfor (i = 0; hal_mods[i]; i++)\n \t\thal_mods[i]->attach(bfa, bfad, cfg, meminfo, pcidev);\n \n+\tbfa_com_port_attach(bfa, meminfo);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tbfa_com_port_attach(bfa, meminfo);"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-4343",
        "func_name": "torvalds/linux/bfa_cfg_get_meminfo",
        "description": "drivers/scsi/bfa/bfa_core.c in the Linux kernel before 2.6.35 does not initialize a certain port data structure, which allows local users to cause a denial of service (system crash) via read operations on an fc_host statistics file.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=7873ca4e4401f0ecd8868bf1543113467e6bae61",
        "commit_title": "The port data structure related to fc_host statistics collection is",
        "commit_text": "not initialized. This causes system crash when reading the fc_host statistics. The fix is to initialize port structure during driver attach.  ",
        "func_before": "void\nbfa_cfg_get_meminfo(struct bfa_iocfc_cfg_s *cfg, struct bfa_meminfo_s *meminfo)\n{\n\tint             i;\n\tu32        km_len = 0, dm_len = 0;\n\n\tbfa_assert((cfg != NULL) && (meminfo != NULL));\n\n\tbfa_os_memset((void *)meminfo, 0, sizeof(struct bfa_meminfo_s));\n\tmeminfo->meminfo[BFA_MEM_TYPE_KVA - 1].mem_type =\n\t\tBFA_MEM_TYPE_KVA;\n\tmeminfo->meminfo[BFA_MEM_TYPE_DMA - 1].mem_type =\n\t\tBFA_MEM_TYPE_DMA;\n\n\tbfa_iocfc_meminfo(cfg, &km_len, &dm_len);\n\n\tfor (i = 0; hal_mods[i]; i++)\n\t\thal_mods[i]->meminfo(cfg, &km_len, &dm_len);\n\n\n\tmeminfo->meminfo[BFA_MEM_TYPE_KVA - 1].mem_len = km_len;\n\tmeminfo->meminfo[BFA_MEM_TYPE_DMA - 1].mem_len = dm_len;\n}",
        "func": "void\nbfa_cfg_get_meminfo(struct bfa_iocfc_cfg_s *cfg, struct bfa_meminfo_s *meminfo)\n{\n\tint             i;\n\tu32        km_len = 0, dm_len = 0;\n\n\tbfa_assert((cfg != NULL) && (meminfo != NULL));\n\n\tbfa_os_memset((void *)meminfo, 0, sizeof(struct bfa_meminfo_s));\n\tmeminfo->meminfo[BFA_MEM_TYPE_KVA - 1].mem_type =\n\t\tBFA_MEM_TYPE_KVA;\n\tmeminfo->meminfo[BFA_MEM_TYPE_DMA - 1].mem_type =\n\t\tBFA_MEM_TYPE_DMA;\n\n\tbfa_iocfc_meminfo(cfg, &km_len, &dm_len);\n\n\tfor (i = 0; hal_mods[i]; i++)\n\t\thal_mods[i]->meminfo(cfg, &km_len, &dm_len);\n\n\tdm_len += bfa_port_meminfo();\n\n\tmeminfo->meminfo[BFA_MEM_TYPE_KVA - 1].mem_len = km_len;\n\tmeminfo->meminfo[BFA_MEM_TYPE_DMA - 1].mem_len = dm_len;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,7 @@\n \tfor (i = 0; hal_mods[i]; i++)\n \t\thal_mods[i]->meminfo(cfg, &km_len, &dm_len);\n \n+\tdm_len += bfa_port_meminfo();\n \n \tmeminfo->meminfo[BFA_MEM_TYPE_KVA - 1].mem_len = km_len;\n \tmeminfo->meminfo[BFA_MEM_TYPE_DMA - 1].mem_len = dm_len;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tdm_len += bfa_port_meminfo();"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-4655",
        "func_name": "torvalds/linux/ethtool_get_rx_ntuple",
        "description": "net/core/ethtool.c in the Linux kernel before 2.6.36 does not initialize certain data structures, which allows local users to obtain potentially sensitive information from kernel heap memory by leveraging the CAP_NET_ADMIN capability for an ethtool ioctl call.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=b00916b189d13a615ff05c9242201135992fcda3",
        "commit_title": "Several other ethtool functions leave heap uncleared (potentially) by",
        "commit_text": "drivers. Some interfaces appear safe (eeprom, etc), in that the sizes are well controlled. In some situations (e.g. unchecked error conditions), the heap will remain unchanged in areas before copying back to userspace. Note that these are less of an issue since these all require CAP_NET_ADMIN.  Cc: stable@kernel.org ",
        "func_before": "static int ethtool_get_rx_ntuple(struct net_device *dev, void __user *useraddr)\n{\n\tstruct ethtool_gstrings gstrings;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tstruct ethtool_rx_ntuple_flow_spec_container *fsc;\n\tu8 *data;\n\tchar *p;\n\tint ret, i, num_strings = 0;\n\n\tif (!ops->get_sset_count)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&gstrings, useraddr, sizeof(gstrings)))\n\t\treturn -EFAULT;\n\n\tret = ops->get_sset_count(dev, gstrings.string_set);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tgstrings.len = ret;\n\n\tdata = kmalloc(gstrings.len * ETH_GSTRING_LEN, GFP_USER);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tif (ops->get_rx_ntuple) {\n\t\t/* driver-specific filter grab */\n\t\tret = ops->get_rx_ntuple(dev, gstrings.string_set, data);\n\t\tgoto copy;\n\t}\n\n\t/* default ethtool filter grab */\n\ti = 0;\n\tp = (char *)data;\n\tlist_for_each_entry(fsc, &dev->ethtool_ntuple_list.list, list) {\n\t\tsprintf(p, \"Filter %d:\\n\", i);\n\t\tp += ETH_GSTRING_LEN;\n\t\tnum_strings++;\n\n\t\tswitch (fsc->fs.flow_type) {\n\t\tcase TCP_V4_FLOW:\n\t\t\tsprintf(p, \"\\tFlow Type: TCP\\n\");\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tbreak;\n\t\tcase UDP_V4_FLOW:\n\t\t\tsprintf(p, \"\\tFlow Type: UDP\\n\");\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tbreak;\n\t\tcase SCTP_V4_FLOW:\n\t\t\tsprintf(p, \"\\tFlow Type: SCTP\\n\");\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tbreak;\n\t\tcase AH_ESP_V4_FLOW:\n\t\t\tsprintf(p, \"\\tFlow Type: AH ESP\\n\");\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tbreak;\n\t\tcase ESP_V4_FLOW:\n\t\t\tsprintf(p, \"\\tFlow Type: ESP\\n\");\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tbreak;\n\t\tcase IP_USER_FLOW:\n\t\t\tsprintf(p, \"\\tFlow Type: Raw IP\\n\");\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tbreak;\n\t\tcase IPV4_FLOW:\n\t\t\tsprintf(p, \"\\tFlow Type: IPv4\\n\");\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf(p, \"\\tFlow Type: Unknown\\n\");\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tgoto unknown_filter;\n\t\t}\n\n\t\t/* now the rest of the filters */\n\t\tswitch (fsc->fs.flow_type) {\n\t\tcase TCP_V4_FLOW:\n\t\tcase UDP_V4_FLOW:\n\t\tcase SCTP_V4_FLOW:\n\t\t\tsprintf(p, \"\\tSrc IP addr: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.tcp_ip4_spec.ip4src);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tSrc IP mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.m_u.tcp_ip4_spec.ip4src);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tDest IP addr: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.tcp_ip4_spec.ip4dst);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tDest IP mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.m_u.tcp_ip4_spec.ip4dst);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tSrc Port: %d, mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.tcp_ip4_spec.psrc,\n\t\t\t\tfsc->fs.m_u.tcp_ip4_spec.psrc);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tDest Port: %d, mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.tcp_ip4_spec.pdst,\n\t\t\t\tfsc->fs.m_u.tcp_ip4_spec.pdst);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tTOS: %d, mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.tcp_ip4_spec.tos,\n\t\t\t\tfsc->fs.m_u.tcp_ip4_spec.tos);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tbreak;\n\t\tcase AH_ESP_V4_FLOW:\n\t\tcase ESP_V4_FLOW:\n\t\t\tsprintf(p, \"\\tSrc IP addr: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.ah_ip4_spec.ip4src);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tSrc IP mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.m_u.ah_ip4_spec.ip4src);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tDest IP addr: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.ah_ip4_spec.ip4dst);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tDest IP mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.m_u.ah_ip4_spec.ip4dst);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tSPI: %d, mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.ah_ip4_spec.spi,\n\t\t\t\tfsc->fs.m_u.ah_ip4_spec.spi);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tTOS: %d, mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.ah_ip4_spec.tos,\n\t\t\t\tfsc->fs.m_u.ah_ip4_spec.tos);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tbreak;\n\t\tcase IP_USER_FLOW:\n\t\t\tsprintf(p, \"\\tSrc IP addr: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.raw_ip4_spec.ip4src);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tSrc IP mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.m_u.raw_ip4_spec.ip4src);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tDest IP addr: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.raw_ip4_spec.ip4dst);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tDest IP mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.m_u.raw_ip4_spec.ip4dst);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tbreak;\n\t\tcase IPV4_FLOW:\n\t\t\tsprintf(p, \"\\tSrc IP addr: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.usr_ip4_spec.ip4src);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tSrc IP mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.m_u.usr_ip4_spec.ip4src);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tDest IP addr: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.usr_ip4_spec.ip4dst);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tDest IP mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.m_u.usr_ip4_spec.ip4dst);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tL4 bytes: 0x%x, mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.usr_ip4_spec.l4_4_bytes,\n\t\t\t\tfsc->fs.m_u.usr_ip4_spec.l4_4_bytes);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tTOS: %d, mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.usr_ip4_spec.tos,\n\t\t\t\tfsc->fs.m_u.usr_ip4_spec.tos);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tIP Version: %d, mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.usr_ip4_spec.ip_ver,\n\t\t\t\tfsc->fs.m_u.usr_ip4_spec.ip_ver);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tProtocol: %d, mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.usr_ip4_spec.proto,\n\t\t\t\tfsc->fs.m_u.usr_ip4_spec.proto);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tbreak;\n\t\t}\n\t\tsprintf(p, \"\\tVLAN: %d, mask: 0x%x\\n\",\n\t\t\tfsc->fs.vlan_tag, fsc->fs.vlan_tag_mask);\n\t\tp += ETH_GSTRING_LEN;\n\t\tnum_strings++;\n\t\tsprintf(p, \"\\tUser-defined: 0x%Lx\\n\", fsc->fs.data);\n\t\tp += ETH_GSTRING_LEN;\n\t\tnum_strings++;\n\t\tsprintf(p, \"\\tUser-defined mask: 0x%Lx\\n\", fsc->fs.data_mask);\n\t\tp += ETH_GSTRING_LEN;\n\t\tnum_strings++;\n\t\tif (fsc->fs.action == ETHTOOL_RXNTUPLE_ACTION_DROP)\n\t\t\tsprintf(p, \"\\tAction: Drop\\n\");\n\t\telse\n\t\t\tsprintf(p, \"\\tAction: Direct to queue %d\\n\",\n\t\t\t\tfsc->fs.action);\n\t\tp += ETH_GSTRING_LEN;\n\t\tnum_strings++;\nunknown_filter:\n\t\ti++;\n\t}\ncopy:\n\t/* indicate to userspace how many strings we actually have */\n\tgstrings.len = num_strings;\n\tret = -EFAULT;\n\tif (copy_to_user(useraddr, &gstrings, sizeof(gstrings)))\n\t\tgoto out;\n\tuseraddr += sizeof(gstrings);\n\tif (copy_to_user(useraddr, data, gstrings.len * ETH_GSTRING_LEN))\n\t\tgoto out;\n\tret = 0;\n\nout:\n\tkfree(data);\n\treturn ret;\n}",
        "func": "static int ethtool_get_rx_ntuple(struct net_device *dev, void __user *useraddr)\n{\n\tstruct ethtool_gstrings gstrings;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tstruct ethtool_rx_ntuple_flow_spec_container *fsc;\n\tu8 *data;\n\tchar *p;\n\tint ret, i, num_strings = 0;\n\n\tif (!ops->get_sset_count)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&gstrings, useraddr, sizeof(gstrings)))\n\t\treturn -EFAULT;\n\n\tret = ops->get_sset_count(dev, gstrings.string_set);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tgstrings.len = ret;\n\n\tdata = kzalloc(gstrings.len * ETH_GSTRING_LEN, GFP_USER);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tif (ops->get_rx_ntuple) {\n\t\t/* driver-specific filter grab */\n\t\tret = ops->get_rx_ntuple(dev, gstrings.string_set, data);\n\t\tgoto copy;\n\t}\n\n\t/* default ethtool filter grab */\n\ti = 0;\n\tp = (char *)data;\n\tlist_for_each_entry(fsc, &dev->ethtool_ntuple_list.list, list) {\n\t\tsprintf(p, \"Filter %d:\\n\", i);\n\t\tp += ETH_GSTRING_LEN;\n\t\tnum_strings++;\n\n\t\tswitch (fsc->fs.flow_type) {\n\t\tcase TCP_V4_FLOW:\n\t\t\tsprintf(p, \"\\tFlow Type: TCP\\n\");\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tbreak;\n\t\tcase UDP_V4_FLOW:\n\t\t\tsprintf(p, \"\\tFlow Type: UDP\\n\");\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tbreak;\n\t\tcase SCTP_V4_FLOW:\n\t\t\tsprintf(p, \"\\tFlow Type: SCTP\\n\");\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tbreak;\n\t\tcase AH_ESP_V4_FLOW:\n\t\t\tsprintf(p, \"\\tFlow Type: AH ESP\\n\");\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tbreak;\n\t\tcase ESP_V4_FLOW:\n\t\t\tsprintf(p, \"\\tFlow Type: ESP\\n\");\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tbreak;\n\t\tcase IP_USER_FLOW:\n\t\t\tsprintf(p, \"\\tFlow Type: Raw IP\\n\");\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tbreak;\n\t\tcase IPV4_FLOW:\n\t\t\tsprintf(p, \"\\tFlow Type: IPv4\\n\");\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsprintf(p, \"\\tFlow Type: Unknown\\n\");\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tgoto unknown_filter;\n\t\t}\n\n\t\t/* now the rest of the filters */\n\t\tswitch (fsc->fs.flow_type) {\n\t\tcase TCP_V4_FLOW:\n\t\tcase UDP_V4_FLOW:\n\t\tcase SCTP_V4_FLOW:\n\t\t\tsprintf(p, \"\\tSrc IP addr: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.tcp_ip4_spec.ip4src);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tSrc IP mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.m_u.tcp_ip4_spec.ip4src);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tDest IP addr: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.tcp_ip4_spec.ip4dst);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tDest IP mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.m_u.tcp_ip4_spec.ip4dst);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tSrc Port: %d, mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.tcp_ip4_spec.psrc,\n\t\t\t\tfsc->fs.m_u.tcp_ip4_spec.psrc);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tDest Port: %d, mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.tcp_ip4_spec.pdst,\n\t\t\t\tfsc->fs.m_u.tcp_ip4_spec.pdst);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tTOS: %d, mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.tcp_ip4_spec.tos,\n\t\t\t\tfsc->fs.m_u.tcp_ip4_spec.tos);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tbreak;\n\t\tcase AH_ESP_V4_FLOW:\n\t\tcase ESP_V4_FLOW:\n\t\t\tsprintf(p, \"\\tSrc IP addr: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.ah_ip4_spec.ip4src);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tSrc IP mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.m_u.ah_ip4_spec.ip4src);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tDest IP addr: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.ah_ip4_spec.ip4dst);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tDest IP mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.m_u.ah_ip4_spec.ip4dst);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tSPI: %d, mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.ah_ip4_spec.spi,\n\t\t\t\tfsc->fs.m_u.ah_ip4_spec.spi);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tTOS: %d, mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.ah_ip4_spec.tos,\n\t\t\t\tfsc->fs.m_u.ah_ip4_spec.tos);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tbreak;\n\t\tcase IP_USER_FLOW:\n\t\t\tsprintf(p, \"\\tSrc IP addr: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.raw_ip4_spec.ip4src);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tSrc IP mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.m_u.raw_ip4_spec.ip4src);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tDest IP addr: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.raw_ip4_spec.ip4dst);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tDest IP mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.m_u.raw_ip4_spec.ip4dst);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tbreak;\n\t\tcase IPV4_FLOW:\n\t\t\tsprintf(p, \"\\tSrc IP addr: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.usr_ip4_spec.ip4src);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tSrc IP mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.m_u.usr_ip4_spec.ip4src);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tDest IP addr: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.usr_ip4_spec.ip4dst);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tDest IP mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.m_u.usr_ip4_spec.ip4dst);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tL4 bytes: 0x%x, mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.usr_ip4_spec.l4_4_bytes,\n\t\t\t\tfsc->fs.m_u.usr_ip4_spec.l4_4_bytes);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tTOS: %d, mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.usr_ip4_spec.tos,\n\t\t\t\tfsc->fs.m_u.usr_ip4_spec.tos);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tIP Version: %d, mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.usr_ip4_spec.ip_ver,\n\t\t\t\tfsc->fs.m_u.usr_ip4_spec.ip_ver);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tsprintf(p, \"\\tProtocol: %d, mask: 0x%x\\n\",\n\t\t\t\tfsc->fs.h_u.usr_ip4_spec.proto,\n\t\t\t\tfsc->fs.m_u.usr_ip4_spec.proto);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tnum_strings++;\n\t\t\tbreak;\n\t\t}\n\t\tsprintf(p, \"\\tVLAN: %d, mask: 0x%x\\n\",\n\t\t\tfsc->fs.vlan_tag, fsc->fs.vlan_tag_mask);\n\t\tp += ETH_GSTRING_LEN;\n\t\tnum_strings++;\n\t\tsprintf(p, \"\\tUser-defined: 0x%Lx\\n\", fsc->fs.data);\n\t\tp += ETH_GSTRING_LEN;\n\t\tnum_strings++;\n\t\tsprintf(p, \"\\tUser-defined mask: 0x%Lx\\n\", fsc->fs.data_mask);\n\t\tp += ETH_GSTRING_LEN;\n\t\tnum_strings++;\n\t\tif (fsc->fs.action == ETHTOOL_RXNTUPLE_ACTION_DROP)\n\t\t\tsprintf(p, \"\\tAction: Drop\\n\");\n\t\telse\n\t\t\tsprintf(p, \"\\tAction: Direct to queue %d\\n\",\n\t\t\t\tfsc->fs.action);\n\t\tp += ETH_GSTRING_LEN;\n\t\tnum_strings++;\nunknown_filter:\n\t\ti++;\n\t}\ncopy:\n\t/* indicate to userspace how many strings we actually have */\n\tgstrings.len = num_strings;\n\tret = -EFAULT;\n\tif (copy_to_user(useraddr, &gstrings, sizeof(gstrings)))\n\t\tgoto out;\n\tuseraddr += sizeof(gstrings);\n\tif (copy_to_user(useraddr, data, gstrings.len * ETH_GSTRING_LEN))\n\t\tgoto out;\n\tret = 0;\n\nout:\n\tkfree(data);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,7 +19,7 @@\n \n \tgstrings.len = ret;\n \n-\tdata = kmalloc(gstrings.len * ETH_GSTRING_LEN, GFP_USER);\n+\tdata = kzalloc(gstrings.len * ETH_GSTRING_LEN, GFP_USER);\n \tif (!data)\n \t\treturn -ENOMEM;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tdata = kmalloc(gstrings.len * ETH_GSTRING_LEN, GFP_USER);"
            ],
            "added_lines": [
                "\tdata = kzalloc(gstrings.len * ETH_GSTRING_LEN, GFP_USER);"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-4655",
        "func_name": "torvalds/linux/ethtool_get_regs",
        "description": "net/core/ethtool.c in the Linux kernel before 2.6.36 does not initialize certain data structures, which allows local users to obtain potentially sensitive information from kernel heap memory by leveraging the CAP_NET_ADMIN capability for an ethtool ioctl call.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=b00916b189d13a615ff05c9242201135992fcda3",
        "commit_title": "Several other ethtool functions leave heap uncleared (potentially) by",
        "commit_text": "drivers. Some interfaces appear safe (eeprom, etc), in that the sizes are well controlled. In some situations (e.g. unchecked error conditions), the heap will remain unchanged in areas before copying back to userspace. Note that these are less of an issue since these all require CAP_NET_ADMIN.  Cc: stable@kernel.org ",
        "func_before": "static int ethtool_get_regs(struct net_device *dev, char __user *useraddr)\n{\n\tstruct ethtool_regs regs;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tvoid *regbuf;\n\tint reglen, ret;\n\n\tif (!ops->get_regs || !ops->get_regs_len)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&regs, useraddr, sizeof(regs)))\n\t\treturn -EFAULT;\n\n\treglen = ops->get_regs_len(dev);\n\tif (regs.len > reglen)\n\t\tregs.len = reglen;\n\n\tregbuf = kmalloc(reglen, GFP_USER);\n\tif (!regbuf)\n\t\treturn -ENOMEM;\n\n\tops->get_regs(dev, &regs, regbuf);\n\n\tret = -EFAULT;\n\tif (copy_to_user(useraddr, &regs, sizeof(regs)))\n\t\tgoto out;\n\tuseraddr += offsetof(struct ethtool_regs, data);\n\tif (copy_to_user(useraddr, regbuf, regs.len))\n\t\tgoto out;\n\tret = 0;\n\n out:\n\tkfree(regbuf);\n\treturn ret;\n}",
        "func": "static int ethtool_get_regs(struct net_device *dev, char __user *useraddr)\n{\n\tstruct ethtool_regs regs;\n\tconst struct ethtool_ops *ops = dev->ethtool_ops;\n\tvoid *regbuf;\n\tint reglen, ret;\n\n\tif (!ops->get_regs || !ops->get_regs_len)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&regs, useraddr, sizeof(regs)))\n\t\treturn -EFAULT;\n\n\treglen = ops->get_regs_len(dev);\n\tif (regs.len > reglen)\n\t\tregs.len = reglen;\n\n\tregbuf = kzalloc(reglen, GFP_USER);\n\tif (!regbuf)\n\t\treturn -ENOMEM;\n\n\tops->get_regs(dev, &regs, regbuf);\n\n\tret = -EFAULT;\n\tif (copy_to_user(useraddr, &regs, sizeof(regs)))\n\t\tgoto out;\n\tuseraddr += offsetof(struct ethtool_regs, data);\n\tif (copy_to_user(useraddr, regbuf, regs.len))\n\t\tgoto out;\n\tret = 0;\n\n out:\n\tkfree(regbuf);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,7 @@\n \tif (regs.len > reglen)\n \t\tregs.len = reglen;\n \n-\tregbuf = kmalloc(reglen, GFP_USER);\n+\tregbuf = kzalloc(reglen, GFP_USER);\n \tif (!regbuf)\n \t\treturn -ENOMEM;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tregbuf = kmalloc(reglen, GFP_USER);"
            ],
            "added_lines": [
                "\tregbuf = kzalloc(reglen, GFP_USER);"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-4655",
        "func_name": "torvalds/linux/ethtool_get_rxfh_indir",
        "description": "net/core/ethtool.c in the Linux kernel before 2.6.36 does not initialize certain data structures, which allows local users to obtain potentially sensitive information from kernel heap memory by leveraging the CAP_NET_ADMIN capability for an ethtool ioctl call.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=b00916b189d13a615ff05c9242201135992fcda3",
        "commit_title": "Several other ethtool functions leave heap uncleared (potentially) by",
        "commit_text": "drivers. Some interfaces appear safe (eeprom, etc), in that the sizes are well controlled. In some situations (e.g. unchecked error conditions), the heap will remain unchanged in areas before copying back to userspace. Note that these are less of an issue since these all require CAP_NET_ADMIN.  Cc: stable@kernel.org ",
        "func_before": "static noinline_for_stack int ethtool_get_rxfh_indir(struct net_device *dev,\n\t\t\t\t\t\t     void __user *useraddr)\n{\n\tstruct ethtool_rxfh_indir *indir;\n\tu32 table_size;\n\tsize_t full_size;\n\tint ret;\n\n\tif (!dev->ethtool_ops->get_rxfh_indir)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&table_size,\n\t\t\t   useraddr + offsetof(struct ethtool_rxfh_indir, size),\n\t\t\t   sizeof(table_size)))\n\t\treturn -EFAULT;\n\n\tif (table_size >\n\t    (KMALLOC_MAX_SIZE - sizeof(*indir)) / sizeof(*indir->ring_index))\n\t\treturn -ENOMEM;\n\tfull_size = sizeof(*indir) + sizeof(*indir->ring_index) * table_size;\n\tindir = kmalloc(full_size, GFP_USER);\n\tif (!indir)\n\t\treturn -ENOMEM;\n\n\tindir->cmd = ETHTOOL_GRXFHINDIR;\n\tindir->size = table_size;\n\tret = dev->ethtool_ops->get_rxfh_indir(dev, indir);\n\tif (ret)\n\t\tgoto out;\n\n\tif (copy_to_user(useraddr, indir, full_size))\n\t\tret = -EFAULT;\n\nout:\n\tkfree(indir);\n\treturn ret;\n}",
        "func": "static noinline_for_stack int ethtool_get_rxfh_indir(struct net_device *dev,\n\t\t\t\t\t\t     void __user *useraddr)\n{\n\tstruct ethtool_rxfh_indir *indir;\n\tu32 table_size;\n\tsize_t full_size;\n\tint ret;\n\n\tif (!dev->ethtool_ops->get_rxfh_indir)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&table_size,\n\t\t\t   useraddr + offsetof(struct ethtool_rxfh_indir, size),\n\t\t\t   sizeof(table_size)))\n\t\treturn -EFAULT;\n\n\tif (table_size >\n\t    (KMALLOC_MAX_SIZE - sizeof(*indir)) / sizeof(*indir->ring_index))\n\t\treturn -ENOMEM;\n\tfull_size = sizeof(*indir) + sizeof(*indir->ring_index) * table_size;\n\tindir = kzalloc(full_size, GFP_USER);\n\tif (!indir)\n\t\treturn -ENOMEM;\n\n\tindir->cmd = ETHTOOL_GRXFHINDIR;\n\tindir->size = table_size;\n\tret = dev->ethtool_ops->get_rxfh_indir(dev, indir);\n\tif (ret)\n\t\tgoto out;\n\n\tif (copy_to_user(useraddr, indir, full_size))\n\t\tret = -EFAULT;\n\nout:\n\tkfree(indir);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,7 +18,7 @@\n \t    (KMALLOC_MAX_SIZE - sizeof(*indir)) / sizeof(*indir->ring_index))\n \t\treturn -ENOMEM;\n \tfull_size = sizeof(*indir) + sizeof(*indir->ring_index) * table_size;\n-\tindir = kmalloc(full_size, GFP_USER);\n+\tindir = kzalloc(full_size, GFP_USER);\n \tif (!indir)\n \t\treturn -ENOMEM;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tindir = kmalloc(full_size, GFP_USER);"
            ],
            "added_lines": [
                "\tindir = kzalloc(full_size, GFP_USER);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-10972",
        "func_name": "xorg/xserver/SProcXSendExtensionEvent",
        "description": "Uninitialized data in endianness conversion in the XEvent handling of the X.Org X Server before 2017-06-19 allowed authenticated malicious users to access potentially privileged data from the X server.",
        "git_url": "https://cgit.freedesktop.org/xorg/xserver/commit/?id=05442de962d3dc624f79fc1a00eca3ffc5489ced",
        "commit_title": "Make sure that the xEvent eventT is initialized with zeros, the same way as",
        "commit_text": "in SProcSendEvent.  Some event swapping functions do not overwrite all 32 bytes of xEvent structure, for example XSecurityAuthorizationRevoked. Two cooperating clients, one swapped and the other not, can send XSecurityAuthorizationRevoked event to each other to retrieve old stack data from X server. This can be potentialy misused to go around ASLR or stack-protector.  ",
        "func_before": "int _X_COLD\nSProcXSendExtensionEvent(ClientPtr client)\n{\n    CARD32 *p;\n    int i;\n    xEvent eventT;\n    xEvent *eventP;\n    EventSwapPtr proc;\n\n    REQUEST(xSendExtensionEventReq);\n    swaps(&stuff->length);\n    REQUEST_AT_LEAST_SIZE(xSendExtensionEventReq);\n    swapl(&stuff->destination);\n    swaps(&stuff->count);\n\n    if (stuff->length !=\n        bytes_to_int32(sizeof(xSendExtensionEventReq)) + stuff->count +\n        bytes_to_int32(stuff->num_events * sizeof(xEvent)))\n        return BadLength;\n\n    eventP = (xEvent *) &stuff[1];\n    for (i = 0; i < stuff->num_events; i++, eventP++) {\n        proc = EventSwapVector[eventP->u.u.type & 0177];\n        if (proc == NotImplemented)     /* no swapping proc; invalid event type? */\n            return BadValue;\n        (*proc) (eventP, &eventT);\n        *eventP = eventT;\n    }\n\n    p = (CARD32 *) (((xEvent *) &stuff[1]) + stuff->num_events);\n    SwapLongs(p, stuff->count);\n    return (ProcXSendExtensionEvent(client));\n}",
        "func": "int _X_COLD\nSProcXSendExtensionEvent(ClientPtr client)\n{\n    CARD32 *p;\n    int i;\n    xEvent eventT = { .u.u.type = 0 };\n    xEvent *eventP;\n    EventSwapPtr proc;\n\n    REQUEST(xSendExtensionEventReq);\n    swaps(&stuff->length);\n    REQUEST_AT_LEAST_SIZE(xSendExtensionEventReq);\n    swapl(&stuff->destination);\n    swaps(&stuff->count);\n\n    if (stuff->length !=\n        bytes_to_int32(sizeof(xSendExtensionEventReq)) + stuff->count +\n        bytes_to_int32(stuff->num_events * sizeof(xEvent)))\n        return BadLength;\n\n    eventP = (xEvent *) &stuff[1];\n    for (i = 0; i < stuff->num_events; i++, eventP++) {\n        proc = EventSwapVector[eventP->u.u.type & 0177];\n        if (proc == NotImplemented)     /* no swapping proc; invalid event type? */\n            return BadValue;\n        (*proc) (eventP, &eventT);\n        *eventP = eventT;\n    }\n\n    p = (CARD32 *) (((xEvent *) &stuff[1]) + stuff->num_events);\n    SwapLongs(p, stuff->count);\n    return (ProcXSendExtensionEvent(client));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n {\n     CARD32 *p;\n     int i;\n-    xEvent eventT;\n+    xEvent eventT = { .u.u.type = 0 };\n     xEvent *eventP;\n     EventSwapPtr proc;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    xEvent eventT;"
            ],
            "added_lines": [
                "    xEvent eventT = { .u.u.type = 0 };"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12164",
        "func_name": "GNOME/gdm/on_display_status_changed",
        "description": "A flaw was discovered in gdm 3.24.1 where gdm greeter was no longer setting the ran_once boolean during autologin. If autologin was enabled for a victim, an attacker could simply select 'login as another user' to unlock their screen.",
        "git_url": "https://github.com/GNOME/gdm/commit/ff98b2817014684ae1acec78ff06f0f461a56a9f",
        "commit_title": "manager: if falling back to X11 retry autologin",
        "commit_text": " Right now, we get one shot to autologin. If it fails, we fall back to the greeter.  We should give it another go if the reason for the failure was wayland fallback to X.  https://bugzilla.gnome.org/show_bug.cgi?id=780520",
        "func_before": "static void\non_display_status_changed (GdmDisplay *display,\n                           GParamSpec *arg1,\n                           GdmManager *manager)\n{\n        int         status;\n        int         display_number = -1;\n#ifdef WITH_PLYMOUTH\n        gboolean    display_is_local = FALSE;\n        gboolean    quit_plymouth = FALSE;\n\n        g_object_get (display,\n                      \"is-local\", &display_is_local,\n                      NULL);\n        quit_plymouth = display_is_local && manager->priv->plymouth_is_running;\n#endif\n\n        g_object_get (display, \"x11-display-number\", &display_number, NULL);\n\n        status = gdm_display_get_status (display);\n\n        switch (status) {\n                case GDM_DISPLAY_PREPARED:\n                case GDM_DISPLAY_MANAGED:\n                        if ((display_number == -1 && status == GDM_DISPLAY_PREPARED) ||\n                            (display_number != -1 && status == GDM_DISPLAY_MANAGED)) {\n                                char *session_class;\n\n                                g_object_get (display,\n                                              \"session-class\", &session_class,\n                                              NULL);\n                                if (g_strcmp0 (session_class, \"greeter\") == 0)\n                                        set_up_session (manager, display);\n                                g_free (session_class);\n                        }\n\n                        if (status == GDM_DISPLAY_MANAGED) {\n                                greeter_display_started (manager, display);\n                        }\n                        break;\n                case GDM_DISPLAY_FAILED:\n                case GDM_DISPLAY_UNMANAGED:\n                case GDM_DISPLAY_FINISHED:\n#ifdef WITH_PLYMOUTH\n                        if (quit_plymouth) {\n                                plymouth_quit_without_transition ();\n                                manager->priv->plymouth_is_running = FALSE;\n                        }\n#endif\n\n                        maybe_start_pending_initial_login (manager, display);\n                        break;\n                default:\n                        break;\n        }\n\n}",
        "func": "static void\non_display_status_changed (GdmDisplay *display,\n                           GParamSpec *arg1,\n                           GdmManager *manager)\n{\n        int         status;\n        int         display_number = -1;\n        char       *session_type = NULL;\n#ifdef WITH_PLYMOUTH\n        gboolean    display_is_local = FALSE;\n        gboolean    quit_plymouth = FALSE;\n\n        g_object_get (display,\n                      \"is-local\", &display_is_local,\n                      NULL);\n        quit_plymouth = display_is_local && manager->priv->plymouth_is_running;\n#endif\n\n        g_object_get (display,\n                      \"x11-display-number\", &display_number,\n                      \"session-type\", &session_type,\n                      NULL);\n\n        status = gdm_display_get_status (display);\n\n        switch (status) {\n                case GDM_DISPLAY_PREPARED:\n                case GDM_DISPLAY_MANAGED:\n                        if ((display_number == -1 && status == GDM_DISPLAY_PREPARED) ||\n                            (display_number != -1 && status == GDM_DISPLAY_MANAGED)) {\n                                char *session_class;\n\n                                g_object_get (display,\n                                              \"session-class\", &session_class,\n                                              NULL);\n                                if (g_strcmp0 (session_class, \"greeter\") == 0)\n                                        set_up_session (manager, display);\n                                g_free (session_class);\n                        }\n\n                        if (status == GDM_DISPLAY_MANAGED) {\n                                greeter_display_started (manager, display);\n                        }\n                        break;\n                case GDM_DISPLAY_FAILED:\n                case GDM_DISPLAY_UNMANAGED:\n                case GDM_DISPLAY_FINISHED:\n#ifdef WITH_PLYMOUTH\n                        if (quit_plymouth) {\n                                plymouth_quit_without_transition ();\n                                manager->priv->plymouth_is_running = FALSE;\n                        }\n#endif\n\n                        if (status == GDM_DISPLAY_FINISHED || g_strcmp0 (session_type, \"x11\") == 0) {\n                                manager->priv->ran_once = TRUE;\n                        }\n                        maybe_start_pending_initial_login (manager, display);\n                        break;\n                default:\n                        break;\n        }\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,6 +5,7 @@\n {\n         int         status;\n         int         display_number = -1;\n+        char       *session_type = NULL;\n #ifdef WITH_PLYMOUTH\n         gboolean    display_is_local = FALSE;\n         gboolean    quit_plymouth = FALSE;\n@@ -15,7 +16,10 @@\n         quit_plymouth = display_is_local && manager->priv->plymouth_is_running;\n #endif\n \n-        g_object_get (display, \"x11-display-number\", &display_number, NULL);\n+        g_object_get (display,\n+                      \"x11-display-number\", &display_number,\n+                      \"session-type\", &session_type,\n+                      NULL);\n \n         status = gdm_display_get_status (display);\n \n@@ -48,6 +52,9 @@\n                         }\n #endif\n \n+                        if (status == GDM_DISPLAY_FINISHED || g_strcmp0 (session_type, \"x11\") == 0) {\n+                                manager->priv->ran_once = TRUE;\n+                        }\n                         maybe_start_pending_initial_login (manager, display);\n                         break;\n                 default:",
        "diff_line_info": {
            "deleted_lines": [
                "        g_object_get (display, \"x11-display-number\", &display_number, NULL);"
            ],
            "added_lines": [
                "        char       *session_type = NULL;",
                "        g_object_get (display,",
                "                      \"x11-display-number\", &display_number,",
                "                      \"session-type\", &session_type,",
                "                      NULL);",
                "                        if (status == GDM_DISPLAY_FINISHED || g_strcmp0 (session_type, \"x11\") == 0) {",
                "                                manager->priv->ran_once = TRUE;",
                "                        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12164",
        "func_name": "GNOME/gdm/greeter_display_started",
        "description": "A flaw was discovered in gdm 3.24.1 where gdm greeter was no longer setting the ran_once boolean during autologin. If autologin was enabled for a victim, an attacker could simply select 'login as another user' to unlock their screen.",
        "git_url": "https://github.com/GNOME/gdm/commit/ff98b2817014684ae1acec78ff06f0f461a56a9f",
        "commit_title": "manager: if falling back to X11 retry autologin",
        "commit_text": " Right now, we get one shot to autologin. If it fails, we fall back to the greeter.  We should give it another go if the reason for the failure was wayland fallback to X.  https://bugzilla.gnome.org/show_bug.cgi?id=780520",
        "func_before": "static void\ngreeter_display_started (GdmManager *manager,\n                         GdmDisplay *display)\n{\n        if (manager->priv->ran_once) {\n                return;\n        }\n\n        maybe_start_pending_initial_login (manager, display);\n\n        manager->priv->ran_once = TRUE;\n}",
        "func": "static void\ngreeter_display_started (GdmManager *manager,\n                         GdmDisplay *display)\n{\n        if (manager->priv->ran_once) {\n                return;\n        }\n\n        maybe_start_pending_initial_login (manager, display);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,4 @@\n         }\n \n         maybe_start_pending_initial_login (manager, display);\n-\n-        manager->priv->ran_once = TRUE;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "        manager->priv->ran_once = TRUE;"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2018-10901",
        "func_name": "torvalds/linux/__vmx_load_host_state",
        "description": "A flaw was found in Linux kernel's KVM virtualization subsystem. The VMX code does not restore the GDT.LIMIT to the previous host value, but instead sets it to 64KB. With a corrupted GDT limit a host's userspace code has an ability to place malicious entries in the GDT, particularly to the per-cpu variables. An attacker can use this to escalate their privileges.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=3444d7da1839b851eefedd372978d8a982316c36",
        "commit_title": "vmx does not restore GDT.LIMIT to the host value, instead it sets it to 64KB.",
        "commit_text": "This means host userspace can learn a few bits of host memory.  Fix by reloading GDTR when we load other host state.  ",
        "func_before": "static void __vmx_load_host_state(struct vcpu_vmx *vmx)\n{\n\tunsigned long flags;\n\n\tif (!vmx->host_state.loaded)\n\t\treturn;\n\n\t++vmx->vcpu.stat.host_state_reload;\n\tvmx->host_state.loaded = 0;\n\tif (vmx->host_state.fs_reload_needed)\n\t\tkvm_load_fs(vmx->host_state.fs_sel);\n\tif (vmx->host_state.gs_ldt_reload_needed) {\n\t\tkvm_load_ldt(vmx->host_state.ldt_sel);\n\t\t/*\n\t\t * If we have to reload gs, we must take care to\n\t\t * preserve our gs base.\n\t\t */\n\t\tlocal_irq_save(flags);\n\t\tkvm_load_gs(vmx->host_state.gs_sel);\n#ifdef CONFIG_X86_64\n\t\twrmsrl(MSR_GS_BASE, vmcs_readl(HOST_GS_BASE));\n#endif\n\t\tlocal_irq_restore(flags);\n\t}\n\treload_tss();\n#ifdef CONFIG_X86_64\n\tif (is_long_mode(&vmx->vcpu)) {\n\t\trdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n\t\twrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);\n\t}\n#endif\n\tif (current_thread_info()->status & TS_USEDFPU)\n\t\tclts();\n}",
        "func": "static void __vmx_load_host_state(struct vcpu_vmx *vmx)\n{\n\tunsigned long flags;\n\n\tif (!vmx->host_state.loaded)\n\t\treturn;\n\n\t++vmx->vcpu.stat.host_state_reload;\n\tvmx->host_state.loaded = 0;\n\tif (vmx->host_state.fs_reload_needed)\n\t\tkvm_load_fs(vmx->host_state.fs_sel);\n\tif (vmx->host_state.gs_ldt_reload_needed) {\n\t\tkvm_load_ldt(vmx->host_state.ldt_sel);\n\t\t/*\n\t\t * If we have to reload gs, we must take care to\n\t\t * preserve our gs base.\n\t\t */\n\t\tlocal_irq_save(flags);\n\t\tkvm_load_gs(vmx->host_state.gs_sel);\n#ifdef CONFIG_X86_64\n\t\twrmsrl(MSR_GS_BASE, vmcs_readl(HOST_GS_BASE));\n#endif\n\t\tlocal_irq_restore(flags);\n\t}\n\treload_tss();\n#ifdef CONFIG_X86_64\n\tif (is_long_mode(&vmx->vcpu)) {\n\t\trdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n\t\twrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);\n\t}\n#endif\n\tif (current_thread_info()->status & TS_USEDFPU)\n\t\tclts();\n\tload_gdt(&__get_cpu_var(host_gdt));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,4 +31,5 @@\n #endif\n \tif (current_thread_info()->status & TS_USEDFPU)\n \t\tclts();\n+\tload_gdt(&__get_cpu_var(host_gdt));\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tload_gdt(&__get_cpu_var(host_gdt));"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-10901",
        "func_name": "torvalds/linux/hardware_enable",
        "description": "A flaw was found in Linux kernel's KVM virtualization subsystem. The VMX code does not restore the GDT.LIMIT to the previous host value, but instead sets it to 64KB. With a corrupted GDT limit a host's userspace code has an ability to place malicious entries in the GDT, particularly to the per-cpu variables. An attacker can use this to escalate their privileges.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=3444d7da1839b851eefedd372978d8a982316c36",
        "commit_title": "vmx does not restore GDT.LIMIT to the host value, instead it sets it to 64KB.",
        "commit_text": "This means host userspace can learn a few bits of host memory.  Fix by reloading GDTR when we load other host state.  ",
        "func_before": "static int hardware_enable(void *garbage)\n{\n\tint cpu = raw_smp_processor_id();\n\tu64 phys_addr = __pa(per_cpu(vmxarea, cpu));\n\tu64 old, test_bits;\n\n\tif (read_cr4() & X86_CR4_VMXE)\n\t\treturn -EBUSY;\n\n\tINIT_LIST_HEAD(&per_cpu(vcpus_on_cpu, cpu));\n\trdmsrl(MSR_IA32_FEATURE_CONTROL, old);\n\n\ttest_bits = FEATURE_CONTROL_LOCKED;\n\ttest_bits |= FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;\n\tif (tboot_enabled())\n\t\ttest_bits |= FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX;\n\n\tif ((old & test_bits) != test_bits) {\n\t\t/* enable and lock */\n\t\twrmsrl(MSR_IA32_FEATURE_CONTROL, old | test_bits);\n\t}\n\twrite_cr4(read_cr4() | X86_CR4_VMXE); /* FIXME: not cpu hotplug safe */\n\n\tif (vmm_exclusive) {\n\t\tkvm_cpu_vmxon(phys_addr);\n\t\tept_sync_global();\n\t}\n\n\treturn 0;\n}",
        "func": "static int hardware_enable(void *garbage)\n{\n\tint cpu = raw_smp_processor_id();\n\tu64 phys_addr = __pa(per_cpu(vmxarea, cpu));\n\tu64 old, test_bits;\n\n\tif (read_cr4() & X86_CR4_VMXE)\n\t\treturn -EBUSY;\n\n\tINIT_LIST_HEAD(&per_cpu(vcpus_on_cpu, cpu));\n\trdmsrl(MSR_IA32_FEATURE_CONTROL, old);\n\n\ttest_bits = FEATURE_CONTROL_LOCKED;\n\ttest_bits |= FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;\n\tif (tboot_enabled())\n\t\ttest_bits |= FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX;\n\n\tif ((old & test_bits) != test_bits) {\n\t\t/* enable and lock */\n\t\twrmsrl(MSR_IA32_FEATURE_CONTROL, old | test_bits);\n\t}\n\twrite_cr4(read_cr4() | X86_CR4_VMXE); /* FIXME: not cpu hotplug safe */\n\n\tif (vmm_exclusive) {\n\t\tkvm_cpu_vmxon(phys_addr);\n\t\tept_sync_global();\n\t}\n\n\tstore_gdt(&__get_cpu_var(host_gdt));\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,5 +26,7 @@\n \t\tept_sync_global();\n \t}\n \n+\tstore_gdt(&__get_cpu_var(host_gdt));\n+\n \treturn 0;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tstore_gdt(&__get_cpu_var(host_gdt));",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2018-16058",
        "func_name": "wireshark/dissect_sep",
        "description": "In Wireshark 2.6.0 to 2.6.2, 2.4.0 to 2.4.8, and 2.2.0 to 2.2.16, the Bluetooth AVDTP dissector could crash. This was addressed in epan/dissectors/packet-btavdtp.c by properly initializing a data structure.",
        "git_url": "https://github.com/wireshark/wireshark/commit/c48d6a6d60c5c9111838a945966b6cb8750777be",
        "commit_title": "BT A2DP: fully initialize sep_entry_t structure",
        "commit_text": " Bug: 14884",
        "func_before": "static gint\ndissect_sep(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint offset,\n    guint32 interface_id, guint32 adapter_id, guint32 chandle)\n{\n    proto_tree       *sep_tree;\n    proto_item       *sep_item;\n    guint            i_sep  = 1;\n    guint            media_type;\n    guint            type;\n    guint            seid;\n    guint            in_use;\n    guint            items;\n    guint32          direction;\n\n    /* Reverse direction to avoid mass reversing it, because this is only case\n       when SEP is provided in ACP role, otherwise INT frequently asking for it\n    */\n    direction = (pinfo->p2p_dir == P2P_DIR_SENT) ? P2P_DIR_RECV : P2P_DIR_SENT;\n    items = tvb_reported_length_remaining(tvb, offset) / 2;\n    while (tvb_reported_length_remaining(tvb, offset) > 0) {\n        seid = tvb_get_guint8(tvb, offset);\n        in_use = seid & 0x02;\n        seid = seid >> 2;\n        media_type = tvb_get_guint8(tvb, offset + 1) >> 4;\n        type = (tvb_get_guint8(tvb, offset + 1) & 0x08) >> 3;\n        sep_item = proto_tree_add_none_format(tree, hf_btavdtp_acp_sep, tvb, offset, 2, \"ACP SEP [%u - %s %s] item %u/%u\",\n                seid, val_to_str_const(media_type, media_type_vals, \"unknown\"),\n                val_to_str_const(type, sep_type_vals, \"unknown\"), i_sep, items);\n        sep_tree = proto_item_add_subtree(sep_item, ett_btavdtp_sep);\n\n        proto_tree_add_item(sep_tree, hf_btavdtp_sep_seid , tvb, offset, 1, ENC_NA);\n        proto_tree_add_item(sep_tree, hf_btavdtp_sep_inuse, tvb, offset, 1, ENC_NA);\n        proto_tree_add_item(sep_tree, hf_btavdtp_sep_rfa0 , tvb, offset, 1, ENC_NA);\n        offset+=1;\n\n        proto_tree_add_item(sep_tree, hf_btavdtp_sep_media_type, tvb, offset, 1, ENC_NA);\n        proto_tree_add_item(sep_tree, hf_btavdtp_sep_type      , tvb, offset, 1, ENC_NA);\n        proto_tree_add_item(sep_tree, hf_btavdtp_sep_rfa1      , tvb, offset, 1, ENC_NA);\n\n        if (!pinfo->fd->flags.visited) {\n            sep_entry_t     *sep_data;\n            wmem_tree_key_t  key[7];\n            guint32          frame_number = pinfo->num;\n\n            key[0].length = 1;\n            key[0].key    = &interface_id;\n            key[1].length = 1;\n            key[1].key    = &adapter_id;\n            key[2].length = 1;\n            key[2].key    = &chandle;\n            key[3].length = 1;\n            key[3].key    = &direction;\n            key[4].length = 1;\n            key[4].key    = &seid;\n            key[5].length = 1;\n            key[5].key    = &frame_number;\n            key[6].length = 0;\n            key[6].key    = NULL;\n\n            sep_data = wmem_new(wmem_file_scope(), sep_entry_t);\n            sep_data->seid = seid;\n            sep_data->type = type;\n            sep_data->media_type = media_type;\n            sep_data->int_seid = 0;\n            sep_data->codec = -1;\n            sep_data->content_protection_type = 0;\n            if (in_use) {\n                sep_data->state = SEP_STATE_IN_USE;\n            } else {\n                sep_data->state = SEP_STATE_FREE;\n            }\n\n            wmem_tree_insert32_array(sep_list, key, sep_data);\n        }\n\n        offset += 1;\n        i_sep += 1;\n    }\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" - items: %u\", items);\n    return offset;\n}",
        "func": "static gint\ndissect_sep(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint offset,\n    guint32 interface_id, guint32 adapter_id, guint32 chandle)\n{\n    proto_tree       *sep_tree;\n    proto_item       *sep_item;\n    guint            i_sep  = 1;\n    guint            media_type;\n    guint            type;\n    guint            seid;\n    guint            in_use;\n    guint            items;\n    guint32          direction;\n\n    /* Reverse direction to avoid mass reversing it, because this is only case\n       when SEP is provided in ACP role, otherwise INT frequently asking for it\n    */\n    direction = (pinfo->p2p_dir == P2P_DIR_SENT) ? P2P_DIR_RECV : P2P_DIR_SENT;\n    items = tvb_reported_length_remaining(tvb, offset) / 2;\n    while (tvb_reported_length_remaining(tvb, offset) > 0) {\n        seid = tvb_get_guint8(tvb, offset);\n        in_use = seid & 0x02;\n        seid = seid >> 2;\n        media_type = tvb_get_guint8(tvb, offset + 1) >> 4;\n        type = (tvb_get_guint8(tvb, offset + 1) & 0x08) >> 3;\n        sep_item = proto_tree_add_none_format(tree, hf_btavdtp_acp_sep, tvb, offset, 2, \"ACP SEP [%u - %s %s] item %u/%u\",\n                seid, val_to_str_const(media_type, media_type_vals, \"unknown\"),\n                val_to_str_const(type, sep_type_vals, \"unknown\"), i_sep, items);\n        sep_tree = proto_item_add_subtree(sep_item, ett_btavdtp_sep);\n\n        proto_tree_add_item(sep_tree, hf_btavdtp_sep_seid , tvb, offset, 1, ENC_NA);\n        proto_tree_add_item(sep_tree, hf_btavdtp_sep_inuse, tvb, offset, 1, ENC_NA);\n        proto_tree_add_item(sep_tree, hf_btavdtp_sep_rfa0 , tvb, offset, 1, ENC_NA);\n        offset+=1;\n\n        proto_tree_add_item(sep_tree, hf_btavdtp_sep_media_type, tvb, offset, 1, ENC_NA);\n        proto_tree_add_item(sep_tree, hf_btavdtp_sep_type      , tvb, offset, 1, ENC_NA);\n        proto_tree_add_item(sep_tree, hf_btavdtp_sep_rfa1      , tvb, offset, 1, ENC_NA);\n\n        if (!pinfo->fd->flags.visited) {\n            sep_entry_t     *sep_data;\n            wmem_tree_key_t  key[7];\n            guint32          frame_number = pinfo->num;\n\n            key[0].length = 1;\n            key[0].key    = &interface_id;\n            key[1].length = 1;\n            key[1].key    = &adapter_id;\n            key[2].length = 1;\n            key[2].key    = &chandle;\n            key[3].length = 1;\n            key[3].key    = &direction;\n            key[4].length = 1;\n            key[4].key    = &seid;\n            key[5].length = 1;\n            key[5].key    = &frame_number;\n            key[6].length = 0;\n            key[6].key    = NULL;\n\n            sep_data = wmem_new0(wmem_file_scope(), sep_entry_t);\n            sep_data->seid = seid;\n            sep_data->type = type;\n            sep_data->media_type = media_type;\n            sep_data->codec = -1;\n            if (in_use) {\n                sep_data->state = SEP_STATE_IN_USE;\n            } else {\n                sep_data->state = SEP_STATE_FREE;\n            }\n\n            wmem_tree_insert32_array(sep_list, key, sep_data);\n        }\n\n        offset += 1;\n        i_sep += 1;\n    }\n\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" - items: %u\", items);\n    return offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -57,13 +57,11 @@\n             key[6].length = 0;\n             key[6].key    = NULL;\n \n-            sep_data = wmem_new(wmem_file_scope(), sep_entry_t);\n+            sep_data = wmem_new0(wmem_file_scope(), sep_entry_t);\n             sep_data->seid = seid;\n             sep_data->type = type;\n             sep_data->media_type = media_type;\n-            sep_data->int_seid = 0;\n             sep_data->codec = -1;\n-            sep_data->content_protection_type = 0;\n             if (in_use) {\n                 sep_data->state = SEP_STATE_IN_USE;\n             } else {",
        "diff_line_info": {
            "deleted_lines": [
                "            sep_data = wmem_new(wmem_file_scope(), sep_entry_t);",
                "            sep_data->int_seid = 0;",
                "            sep_data->content_protection_type = 0;"
            ],
            "added_lines": [
                "            sep_data = wmem_new0(wmem_file_scope(), sep_entry_t);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-49062",
        "func_name": "facebookincubator/katran/create_v4_hdr",
        "description": "Katran could disclose non-initialized kernel memory as part of an IP header. The issue was present for IPv4 encapsulation and ICMP (v4) Too Big packet generation. After a bpf_xdp_adjust_head call, Katran code didnt initialize the Identification field for the IPv4 header, resulting in writing content of kernel memory in that field of IP header. The issue affected all Katran versions prior to commit 6a03106ac1eab39d0303662963589ecb2374c97f",
        "git_url": "https://github.com/facebookincubator/katran/commit/6a03106ac1eab39d0303662963589ecb2374c97f",
        "commit_title": "initialize all iphdr/icmphdr fields when generating iphdr/icmphdr",
        "commit_text": " Summary: as per title  Reviewed By: avasylev  Differential Revision: D51366550  fbshipit-source-id: 3a5ccf0ba21c2f53c4f336cd6df72c64d62b9cc7",
        "func_before": "__attribute__((__always_inline__)) static inline void create_v4_hdr(\n    struct iphdr* iph,\n    __u8 tos,\n    __u32 saddr,\n    __u32 daddr,\n    __u16 pkt_bytes,\n    __u8 proto) {\n  __u64 csum = 0;\n  iph->version = 4;\n  iph->ihl = 5;\n  iph->frag_off = 0;\n  iph->protocol = proto;\n  iph->check = 0;\n#ifdef COPY_INNER_PACKET_TOS\n  iph->tos = tos;\n#else\n  iph->tos = DEFAULT_TOS;\n#endif\n  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));\n  iph->daddr = daddr;\n  iph->saddr = saddr;\n  iph->ttl = DEFAULT_TTL;\n  ipv4_csum_inline(iph, &csum);\n  iph->check = csum;\n}",
        "func": "__attribute__((__always_inline__)) static inline void create_v4_hdr(\n    struct iphdr* iph,\n    __u8 tos,\n    __u32 saddr,\n    __u32 daddr,\n    __u16 pkt_bytes,\n    __u8 proto) {\n  __u64 csum = 0;\n  iph->version = 4;\n  iph->ihl = 5;\n  iph->frag_off = 0;\n  iph->protocol = proto;\n  iph->check = 0;\n#ifdef COPY_INNER_PACKET_TOS\n  iph->tos = tos;\n#else\n  iph->tos = DEFAULT_TOS;\n#endif\n  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));\n  iph->id = 0;\n  iph->daddr = daddr;\n  iph->saddr = saddr;\n  iph->ttl = DEFAULT_TTL;\n  ipv4_csum_inline(iph, &csum);\n  iph->check = csum;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,7 @@\n   iph->tos = DEFAULT_TOS;\n #endif\n   iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));\n+  iph->id = 0;\n   iph->daddr = daddr;\n   iph->saddr = saddr;\n   iph->ttl = DEFAULT_TTL;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  iph->id = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-49062",
        "func_name": "facebookincubator/katran/send_icmp4_too_big",
        "description": "Katran could disclose non-initialized kernel memory as part of an IP header. The issue was present for IPv4 encapsulation and ICMP (v4) Too Big packet generation. After a bpf_xdp_adjust_head call, Katran code didnt initialize the Identification field for the IPv4 header, resulting in writing content of kernel memory in that field of IP header. The issue affected all Katran versions prior to commit 6a03106ac1eab39d0303662963589ecb2374c97f",
        "git_url": "https://github.com/facebookincubator/katran/commit/6a03106ac1eab39d0303662963589ecb2374c97f",
        "commit_title": "initialize all iphdr/icmphdr fields when generating iphdr/icmphdr",
        "commit_text": " Summary: as per title  Reviewed By: avasylev  Differential Revision: D51366550  fbshipit-source-id: 3a5ccf0ba21c2f53c4f336cd6df72c64d62b9cc7",
        "func_before": "__attribute__((__always_inline__)) static inline int send_icmp4_too_big(\n    struct xdp_md* xdp) {\n  int headroom = (int)sizeof(struct iphdr) + (int)sizeof(struct icmphdr);\n  if (bpf_xdp_adjust_head(xdp, 0 - headroom)) {\n    return XDP_DROP;\n  }\n  void* data = (void*)(long)xdp->data;\n  void* data_end = (void*)(long)xdp->data_end;\n  if (data + (ICMP_TOOBIG_SIZE + headroom) > data_end) {\n    return XDP_DROP;\n  }\n  struct iphdr *iph, *orig_iph;\n  struct ethhdr* orig_eth;\n  struct icmphdr* icmp_hdr;\n  __u64 csum = 0;\n  __u64 off = 0;\n  orig_eth = data + headroom;\n  swap_mac(data, orig_eth);\n  off += sizeof(struct ethhdr);\n  iph = data + off;\n  off += sizeof(struct iphdr);\n  icmp_hdr = data + off;\n  off += sizeof(struct icmphdr);\n  orig_iph = data + off;\n  icmp_hdr->type = ICMP_DEST_UNREACH;\n  icmp_hdr->code = ICMP_FRAG_NEEDED;\n  icmp_hdr->un.frag.mtu = bpf_htons(MAX_PCKT_SIZE - sizeof(struct ethhdr));\n  icmp_hdr->checksum = 0;\n  ipv4_csum(icmp_hdr, ICMP_TOOBIG_PAYLOAD_SIZE, &csum);\n  icmp_hdr->checksum = csum;\n  iph->ttl = DEFAULT_TTL;\n  iph->daddr = orig_iph->saddr;\n  iph->saddr = orig_iph->daddr;\n  iph->frag_off = 0;\n  iph->version = 4;\n  iph->ihl = 5;\n  iph->protocol = IPPROTO_ICMP;\n  iph->tos = 0;\n  iph->tot_len = bpf_htons(ICMP_TOOBIG_SIZE + headroom - sizeof(struct ethhdr));\n  iph->check = 0;\n  csum = 0;\n  ipv4_csum(iph, sizeof(struct iphdr), &csum);\n  iph->check = csum;\n  return XDP_TX;\n}",
        "func": "__attribute__((__always_inline__)) static inline int send_icmp4_too_big(\n    struct xdp_md* xdp) {\n  int headroom = (int)sizeof(struct iphdr) + (int)sizeof(struct icmphdr);\n  if (bpf_xdp_adjust_head(xdp, 0 - headroom)) {\n    return XDP_DROP;\n  }\n  void* data = (void*)(long)xdp->data;\n  void* data_end = (void*)(long)xdp->data_end;\n  if (data + (ICMP_TOOBIG_SIZE + headroom) > data_end) {\n    return XDP_DROP;\n  }\n  struct iphdr *iph, *orig_iph;\n  struct ethhdr* orig_eth;\n  struct icmphdr* icmp_hdr;\n  __u64 csum = 0;\n  __u64 off = 0;\n  orig_eth = data + headroom;\n  swap_mac(data, orig_eth);\n  off += sizeof(struct ethhdr);\n  iph = data + off;\n  off += sizeof(struct iphdr);\n  icmp_hdr = data + off;\n  off += sizeof(struct icmphdr);\n  orig_iph = data + off;\n  icmp_hdr->type = ICMP_DEST_UNREACH;\n  icmp_hdr->code = ICMP_FRAG_NEEDED;\n  icmp_hdr->un.frag.mtu = bpf_htons(MAX_PCKT_SIZE - sizeof(struct ethhdr));\n  icmp_hdr->un.frag.__unused = 0;\n  icmp_hdr->checksum = 0;\n  ipv4_csum(icmp_hdr, ICMP_TOOBIG_PAYLOAD_SIZE, &csum);\n  icmp_hdr->checksum = csum;\n  iph->ttl = DEFAULT_TTL;\n  iph->daddr = orig_iph->saddr;\n  iph->saddr = orig_iph->daddr;\n  iph->frag_off = 0;\n  iph->version = 4;\n  iph->ihl = 5;\n  iph->protocol = IPPROTO_ICMP;\n  iph->tos = 0;\n  iph->tot_len = bpf_htons(ICMP_TOOBIG_SIZE + headroom - sizeof(struct ethhdr));\n  iph->id = 0;\n  iph->check = 0;\n  csum = 0;\n  ipv4_csum(iph, sizeof(struct iphdr), &csum);\n  iph->check = csum;\n  return XDP_TX;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,6 +25,7 @@\n   icmp_hdr->type = ICMP_DEST_UNREACH;\n   icmp_hdr->code = ICMP_FRAG_NEEDED;\n   icmp_hdr->un.frag.mtu = bpf_htons(MAX_PCKT_SIZE - sizeof(struct ethhdr));\n+  icmp_hdr->un.frag.__unused = 0;\n   icmp_hdr->checksum = 0;\n   ipv4_csum(icmp_hdr, ICMP_TOOBIG_PAYLOAD_SIZE, &csum);\n   icmp_hdr->checksum = csum;\n@@ -37,6 +38,7 @@\n   iph->protocol = IPPROTO_ICMP;\n   iph->tos = 0;\n   iph->tot_len = bpf_htons(ICMP_TOOBIG_SIZE + headroom - sizeof(struct ethhdr));\n+  iph->id = 0;\n   iph->check = 0;\n   csum = 0;\n   ipv4_csum(iph, sizeof(struct iphdr), &csum);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  icmp_hdr->un.frag.__unused = 0;",
                "  iph->id = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-1513",
        "func_name": "torvalds/linux/kvm_vcpu_ioctl_x86_get_debugregs",
        "description": "A flaw was found in KVM. When calling the KVM_GET_DEBUGREGS ioctl, on 32-bit systems, there might be some uninitialized portions of the kvm_debugregs structure that could be copied to userspace, causing an information leak.",
        "git_url": "https://github.com/torvalds/linux/commit/2c10b61421a28e95a46ab489fd56c0f442ff6952",
        "commit_title": "kvm: initialize all of the kvm_debugregs structure before sending it to userspace",
        "commit_text": " When calling the KVM_GET_DEBUGREGS ioctl, on some configurations, there might be some unitialized portions of the kvm_debugregs structure that could be copied to userspace.  Prevent this as is done in the other kvm ioctls, by setting the whole structure to 0 before copying anything into it.  Bonus is that this reduces the lines of code as the explicit flag setting and reserved space zeroing out can be removed.  Cc: Sean Christopherson <seanjc@google.com> Cc: Paolo Bonzini <pbonzini@redhat.com> Cc: Thomas Gleixner <tglx@linutronix.de> Cc: Ingo Molnar <mingo@redhat.com> Cc: Borislav Petkov <bp@alien8.de> Cc: Dave Hansen <dave.hansen@linux.intel.com> Cc: <x86@kernel.org> Cc: \"H. Peter Anvin\" <hpa@zytor.com> Cc: stable <stable@kernel.org> Message-Id: <20230214103304.3689213-1-gregkh@linuxfoundation.org>",
        "func_before": "static void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct kvm_debugregs *dbgregs)\n{\n\tunsigned long val;\n\n\tmemcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));\n\tkvm_get_dr(vcpu, 6, &val);\n\tdbgregs->dr6 = val;\n\tdbgregs->dr7 = vcpu->arch.dr7;\n\tdbgregs->flags = 0;\n\tmemset(&dbgregs->reserved, 0, sizeof(dbgregs->reserved));\n}",
        "func": "static void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct kvm_debugregs *dbgregs)\n{\n\tunsigned long val;\n\n\tmemset(dbgregs, 0, sizeof(*dbgregs));\n\tmemcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));\n\tkvm_get_dr(vcpu, 6, &val);\n\tdbgregs->dr6 = val;\n\tdbgregs->dr7 = vcpu->arch.dr7;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,10 +3,9 @@\n {\n \tunsigned long val;\n \n+\tmemset(dbgregs, 0, sizeof(*dbgregs));\n \tmemcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));\n \tkvm_get_dr(vcpu, 6, &val);\n \tdbgregs->dr6 = val;\n \tdbgregs->dr7 = vcpu->arch.dr7;\n-\tdbgregs->flags = 0;\n-\tmemset(&dbgregs->reserved, 0, sizeof(dbgregs->reserved));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tdbgregs->flags = 0;",
                "\tmemset(&dbgregs->reserved, 0, sizeof(dbgregs->reserved));"
            ],
            "added_lines": [
                "\tmemset(dbgregs, 0, sizeof(*dbgregs));"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12847",
        "func_name": "NagiosEnterprises/nagioscore/main",
        "description": "Nagios Core before 4.3.3 creates a nagios.lock PID file after dropping privileges to a non-root account, which might allow local users to kill arbitrary processes by leveraging access to this non-root account for nagios.lock modification before a root script executes a \"kill `cat /pathname/nagios.lock`\" command.",
        "git_url": "https://github.com/NagiosEnterprises/nagioscore/commit/1b197346d490df2e2d3b1dcce5ac6134ad0c8752",
        "commit_title": "halfway revert hack/configure changes - switch order of daemon_init/drop_privileges",
        "commit_text": "",
        "func_before": "int main(int argc, char **argv) {\n\tint result;\n\tint error = FALSE;\n\tint display_license = FALSE;\n\tint display_help = FALSE;\n\tint c = 0;\n\tstruct tm *tm, tm_s;\n\ttime_t now;\n\tchar datestring[256];\n\tnagios_macros *mac;\n\tconst char *worker_socket = NULL;\n\tint i;\n#ifdef HAVE_SIGACTION\n\tstruct sigaction sig_action;\n#endif\n\n#ifdef HAVE_GETOPT_H\n\tint option_index = 0;\n\tstatic struct option long_options[] = {\n\t\t\t{\"help\", no_argument, 0, 'h'},\n\t\t\t{\"version\", no_argument, 0, 'V'},\n\t\t\t{\"license\", no_argument, 0, 'V'},\n\t\t\t{\"verify-config\", no_argument, 0, 'v'},\n\t\t\t{\"daemon\", no_argument, 0, 'd'},\n\t\t\t{\"test-scheduling\", no_argument, 0, 's'},\n\t\t\t{\"precache-objects\", no_argument, 0, 'p'},\n\t\t\t{\"use-precached-objects\", no_argument, 0, 'u'},\n\t\t\t{\"enable-timing-point\", no_argument, 0, 'T'},\n\t\t\t{\"worker\", required_argument, 0, 'W'},\n\t\t\t{0, 0, 0, 0}\n\t\t};\n#define getopt(argc, argv, o) getopt_long(argc, argv, o, long_options, &option_index)\n#endif\n\n\tmemset(&loadctl, 0, sizeof(loadctl));\n\tmac = get_global_macros();\n\n\t/* make sure we have the correct number of command line arguments */\n\tif(argc < 2)\n\t\terror = TRUE;\n\n\t/* get all command line arguments */\n\twhile(1) {\n\t\tc = getopt(argc, argv, \"+hVvdspuxTW\");\n\n\t\tif(c == -1 || c == EOF)\n\t\t\tbreak;\n\n\t\tswitch(c) {\n\n\t\t\tcase '?': /* usage */\n\t\t\tcase 'h':\n\t\t\t\tdisplay_help = TRUE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'V': /* version */\n\t\t\t\tdisplay_license = TRUE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'v': /* verify */\n\t\t\t\tverify_config++;\n\t\t\t\tbreak;\n\n\t\t\tcase 's': /* scheduling check */\n\t\t\t\ttest_scheduling = TRUE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'd': /* daemon mode */\n\t\t\t\tdaemon_mode = TRUE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'p': /* precache object config */\n\t\t\t\tprecache_objects = TRUE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'u': /* use precached object config */\n\t\t\t\tuse_precached_objects = TRUE;\n\t\t\t\tbreak;\n\t\t\tcase 'T':\n\t\t\t\tenable_timing_point = TRUE;\n\t\t\t\tbreak;\n\t\t\tcase 'W':\n\t\t\t\tworker_socket = optarg;\n\t\t\t\tbreak;\n\n\t\t\tcase 'x':\n\t\t\t\tprintf(\"Warning: -x is deprecated and will be removed\\n\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n#ifdef DEBUG_MEMORY\n\tmtrace();\n#endif\n\t/* if we're a worker we can skip everything below */\n\tif(worker_socket) {\n\t\texit(nagios_core_worker(worker_socket));\n\t}\n\n\t/* Initialize configuration variables */                             \n\tinit_main_cfg_vars(1);\n\tinit_shared_cfg_vars(1);\n\n\tif(daemon_mode == FALSE) {\n\t\tprintf(\"\\nNagios Core %s\\n\", PROGRAM_VERSION);\n\t\tprintf(\"Copyright (c) 2009-present Nagios Core Development Team and Community Contributors\\n\");\n\t\tprintf(\"Copyright (c) 1999-2009 Ethan Galstad\\n\");\n\t\tprintf(\"Last Modified: %s\\n\", PROGRAM_MODIFICATION_DATE);\n\t\tprintf(\"License: GPL\\n\\n\");\n\t\tprintf(\"Website: https://www.nagios.org\\n\");\n\t\t}\n\n\t/* just display the license */\n\tif(display_license == TRUE) {\n\n\t\tprintf(\"This program is free software; you can redistribute it and/or modify\\n\");\n\t\tprintf(\"it under the terms of the GNU General Public License version 2 as\\n\");\n\t\tprintf(\"published by the Free Software Foundation.\\n\\n\");\n\t\tprintf(\"This program is distributed in the hope that it will be useful,\\n\");\n\t\tprintf(\"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\");\n\t\tprintf(\"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\");\n\t\tprintf(\"GNU General Public License for more details.\\n\\n\");\n\t\tprintf(\"You should have received a copy of the GNU General Public License\\n\");\n\t\tprintf(\"along with this program; if not, write to the Free Software\\n\");\n\t\tprintf(\"Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\\n\\n\");\n\n\t\texit(OK);\n\t\t}\n\n\t/* make sure we got the main config file on the command line... */\n\tif(optind >= argc)\n\t\terror = TRUE;\n\n\t/* if there are no command line options (or if we encountered an error), print usage */\n\tif(error == TRUE || display_help == TRUE) {\n\n\t\tprintf(\"Usage: %s [options] <main_config_file>\\n\", argv[0]);\n\t\tprintf(\"\\n\");\n\t\tprintf(\"Options:\\n\");\n\t\tprintf(\"\\n\");\n\t\tprintf(\"  -v, --verify-config          Verify all configuration data (-v -v for more info)\\n\");\n\t\tprintf(\"  -s, --test-scheduling        Shows projected/recommended check scheduling and other\\n\");\n\t\tprintf(\"                               diagnostic info based on the current configuration files.\\n\");\n\t\tprintf(\"  -T, --enable-timing-point    Enable timed commentary on initialization\\n\");\n\t\tprintf(\"  -x, --dont-verify-paths      Deprecated (Don't check for circular object paths)\\n\");\n\t\tprintf(\"  -p, --precache-objects       Precache object configuration\\n\");\n\t\tprintf(\"  -u, --use-precached-objects  Use precached object config file\\n\");\n\t\tprintf(\"  -d, --daemon                 Starts Nagios in daemon mode, instead of as a foreground process\\n\");\n\t\tprintf(\"  -W, --worker /path/to/socket Act as a worker for an already running daemon\\n\");\n\t\tprintf(\"\\n\");\n\t\tprintf(\"Visit the Nagios website at https://www.nagios.org/ for bug fixes, new\\n\");\n\t\tprintf(\"releases, online documentation, FAQs, information on subscribing to\\n\");\n\t\tprintf(\"the mailing lists, and commercial support options for Nagios.\\n\");\n\t\tprintf(\"\\n\");\n\n\t\texit(ERROR);\n\t\t}\n\n\n\t/*\n\t * config file is last argument specified.\n\t * Make sure it uses an absolute path\n\t */\n\tconfig_file = nspath_absolute(argv[optind], NULL);\n\tif(config_file == NULL) {\n\t\tprintf(\"Error allocating memory.\\n\");\n\t\texit(ERROR);\n\t\t}\n\n\tconfig_file_dir = nspath_absolute_dirname(config_file, NULL);\n\n\t/* \n\t * Set the signal handler for the SIGXFSZ signal here because\n\t * we may encounter this signal before the other signal handlers\n\t * are set.\n\t */\n#ifdef HAVE_SIGACTION\n\tsig_action.sa_sigaction = NULL;\n\tsig_action.sa_handler = handle_sigxfsz;\n\tsigfillset(&sig_action.sa_mask);\n\tsig_action.sa_flags = SA_NODEFER|SA_RESTART;\n\tsigaction(SIGXFSZ, &sig_action, NULL);\n#else\n\tsignal(SIGXFSZ, handle_sigxfsz);\n#endif\n\n\t/*\n\t * let's go to town. We'll be noisy if we're verifying config\n\t * or running scheduling tests.\n\t */\n\tif(verify_config || test_scheduling || precache_objects) {\n\t\treset_variables();\n\t\t/*\n\t\t * if we don't beef up our resource limits as much as\n\t\t * we can, it's quite possible we'll run headlong into\n\t\t * EAGAIN due to too many processes when we try to\n\t\t * drop privileges later.\n\t\t */\n\t\tset_loadctl_defaults();\n\n\t\tif(verify_config)\n\t\t\tprintf(\"Reading configuration data...\\n\");\n\n\t\t/* read our config file */\n\t\tresult = read_main_config_file(config_file);\n\t\tif(result != OK) {\n\t\t\tprintf(\"   Error processing main config file!\\n\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\tif(verify_config)\n\t\t\tprintf(\"   Read main config file okay...\\n\");\n\n\t\t/* drop privileges */\n\t\tif((result = drop_privileges(nagios_user, nagios_group)) == ERROR) {\n\t\t\tprintf(\"   Failed to drop privileges.  Aborting.\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\t/*\n\t\t * this must come after dropping privileges, so we make\n\t\t * sure to test access permissions as the right user.\n\t\t */\n\t\tif (!verify_config && test_configured_paths() == ERROR) {\n\t\t\tprintf(\"   One or more path problems detected. Aborting.\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\t/* read object config files */\n\t\tresult = read_all_object_data(config_file);\n\t\tif(result != OK) {\n\t\t\tprintf(\"   Error processing object config files!\\n\\n\");\n\t\t\t/* if the config filename looks fishy, warn the user */\n\t\t\tif(!strstr(config_file, \"nagios.cfg\")) {\n\t\t\t\tprintf(\"\\n***> The name of the main configuration file looks suspicious...\\n\");\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tprintf(\"     Make sure you are specifying the name of the MAIN configuration file on\\n\");\n\t\t\t\tprintf(\"     the command line and not the name of another configuration file.  The\\n\");\n\t\t\t\tprintf(\"     main configuration file is typically '%s'\\n\", DEFAULT_CONFIG_FILE);\n\t\t\t\t}\n\n\t\t\tprintf(\"\\n***> One or more problems was encountered while processing the config files...\\n\");\n\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"     Check your configuration file(s) to ensure that they contain valid\\n\");\n\t\t\tprintf(\"     directives and data definitions.  If you are upgrading from a previous\\n\");\n\t\t\tprintf(\"     version of Nagios, you should be aware that some variables/definitions\\n\");\n\t\t\tprintf(\"     may have been removed or modified in this version.  Make sure to read\\n\");\n\t\t\tprintf(\"     the HTML documentation regarding the config files, as well as the\\n\");\n\t\t\tprintf(\"     'Whats New' section to find out what has changed.\\n\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\tif(verify_config) {\n\t\t\tprintf(\"   Read object config files okay...\\n\\n\");\n\t\t\tprintf(\"Running pre-flight check on configuration data...\\n\\n\");\n\t\t\t}\n\n\t\t/* run the pre-flight check to make sure things look okay... */\n\t\tresult = pre_flight_check();\n\n\t\tif(result != OK) {\n\t\t\tprintf(\"\\n***> One or more problems was encountered while running the pre-flight check...\\n\");\n\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"     Check your configuration file(s) to ensure that they contain valid\\n\");\n\t\t\tprintf(\"     directives and data definitions.  If you are upgrading from a previous\\n\");\n\t\t\tprintf(\"     version of Nagios, you should be aware that some variables/definitions\\n\");\n\t\t\tprintf(\"     may have been removed or modified in this version.  Make sure to read\\n\");\n\t\t\tprintf(\"     the HTML documentation regarding the config files, as well as the\\n\");\n\t\t\tprintf(\"     'Whats New' section to find out what has changed.\\n\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\tif(verify_config) {\n\t\t\tprintf(\"\\nThings look okay - No serious problems were detected during the pre-flight check\\n\");\n\t\t\t}\n\n\t\t/* scheduling tests need a bit more than config verifications */\n\t\tif(test_scheduling == TRUE) {\n\n\t\t\t/* we'll need the event queue here so we can time insertions */\n\t\t\tinit_event_queue();\n\t\t\ttiming_point(\"Done initializing event queue\\n\");\n\n\t\t\t/* read initial service and host state information */\n\t\t\tinitialize_retention_data(config_file);\n\t\t\tread_initial_state_information();\n\t\t\ttiming_point(\"Retention data and initial state parsed\\n\");\n\n\t\t\t/* initialize the event timing loop */\n\t\t\tinit_timing_loop();\n\t\t\ttiming_point(\"Timing loop initialized\\n\");\n\n\t\t\t/* display scheduling information */\n\t\t\tdisplay_scheduling_info();\n\t\t\t}\n\n\t\tif(precache_objects) {\n\t\t\tresult = fcache_objects(object_precache_file);\n\t\t\ttiming_point(\"Done precaching objects\\n\");\n\t\t\tif(result == OK) {\n\t\t\t\tprintf(\"Object precache file created:\\n%s\\n\", object_precache_file);\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"Failed to precache objects to '%s': %s\\n\", object_precache_file, strerror(errno));\n\t\t\t\t}\n\t\t\t}\n\n\t\t/* clean up after ourselves */\n\t\tcleanup();\n\n\t\t/* exit */\n\t\ttiming_point(\"Exiting\\n\");\n\n\t\t/* make valgrind shut up about still reachable memory */\n\t\tneb_free_module_list();\n\t\tfree(config_file_dir);\n\t\tfree(config_file);\n\n\t\texit(result);\n\t\t}\n\n\n\t/* else start to monitor things... */\n\telse {\n\n\t\t/*\n\t\t * if we're called with a relative path we must make\n\t\t * it absolute so we can launch our workers.\n\t\t * If not, we needn't bother, as we're using execvp()\n\t\t */\n\t\tif (strchr(argv[0], '/'))\n\t\t\tnagios_binary_path = nspath_absolute(argv[0], NULL);\n\t\telse\n\t\t\tnagios_binary_path = strdup(argv[0]);\n\n\t\tif (!nagios_binary_path) {\n\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Unable to allocate memory for nagios_binary_path\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\tif (!(nagios_iobs = iobroker_create())) {\n\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Failed to create IO broker set: %s\\n\",\n\t\t\t\t  strerror(errno));\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\t/* keep monitoring things until we get a shutdown command */\n\t\tdo {\n\t\t\t/* reset internal book-keeping (in case we're restarting) */\n\t\t\twproc_num_workers_spawned = wproc_num_workers_online = 0;\n\t\t\tcaught_signal = sigshutdown = FALSE;\n\t\t\tsig_id = 0;\n\n\t\t\t/* reset program variables */\n\t\t\treset_variables();\n\t\t\ttiming_point(\"Variables reset\\n\");\n\n\t\t\t/* get PID */\n\t\t\tnagios_pid = (int)getpid();\n\n\t\t\t/* read in the configuration files (main and resource config files) */\n\t\t\tresult = read_main_config_file(config_file);\n\t\t\tif (result != OK) {\n\t\t\t\tlogit(NSLOG_CONFIG_ERROR, TRUE, \"Error: Failed to process config file '%s'. Aborting\\n\", config_file);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\ttiming_point(\"Main config file read\\n\");\n\n\t\t\t/* NOTE 11/06/07 EG moved to after we read config files, as user may have overridden timezone offset */\n\t\t\t/* get program (re)start time and save as macro */\n\t\t\tprogram_start = time(NULL);\n\t\t\tmy_free(mac->x[MACRO_PROCESSSTARTTIME]);\n\t\t\tasprintf(&mac->x[MACRO_PROCESSSTARTTIME], \"%llu\", (unsigned long long)program_start);\n\n\t\t\t/* drop privileges */\n\t\t\tif(drop_privileges(nagios_user, nagios_group) == ERROR) {\n\n\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, \"Failed to drop privileges.  Aborting.\");\n\n\t\t\t\tcleanup();\n\t\t\t\texit(ERROR);\n\t\t\t\t}\n\n\t\t\tif (test_path_access(nagios_binary_path, X_OK)) {\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: failed to access() %s: %s\\n\", nagios_binary_path, strerror(errno));\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Spawning workers will be impossible. Aborting.\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\n\t\t\tif (test_configured_paths() == ERROR) {\n\t\t\t\t/* error has already been logged */\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t/* enter daemon mode (unless we're restarting...) */\n\t\t\tif(daemon_mode == TRUE && sigrestart == FALSE) {\n\n\t\t\t\tresult = daemon_init();\n\n\t\t\t\t/* we had an error daemonizing, so bail... */\n\t\t\t\tif(result == ERROR) {\n\t\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR, TRUE, \"Bailing out due to failure to daemonize. (PID=%d)\", (int)getpid());\n\t\t\t\t\tcleanup();\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t\t}\n\n\t\t\t\t/* get new PID */\n\t\t\t\tnagios_pid = (int)getpid();\n\t\t\t\t}\n\n\t\t\t/* this must be logged after we read config data, as user may have changed location of main log file */\n\t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Nagios %s starting... (PID=%d)\\n\", PROGRAM_VERSION, (int)getpid());\n\n\t\t\t/* log the local time - may be different than clock time due to timezone offset */\n\t\t\tnow = time(NULL);\n\t\t\ttm = localtime_r(&now, &tm_s);\n\t\t\tstrftime(datestring, sizeof(datestring), \"%a %b %d %H:%M:%S %Z %Y\", tm);\n\t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Local time is %s\", datestring);\n\n\t\t\t/* write log version/info */\n\t\t\twrite_log_file_info(NULL);\n\n\t\t\t/* open debug log now that we're the right user */\n\t\t\topen_debug_log();\n\n#ifdef USE_EVENT_BROKER\n\t\t\t/* initialize modules */\n\t\t\tneb_init_modules();\n\t\t\tneb_init_callback_list();\n#endif\n\t\t\ttiming_point(\"NEB module API initialized\\n\");\n\n\t\t\t/* handle signals (interrupts) before we do any socket I/O */\n\t\t\tsetup_sighandler();\n\n\t\t\t/*\n\t\t\t * Initialize query handler and event subscription service.\n\t\t\t * This must be done before modules are initialized, so\n\t\t\t * the modules can use our in-core stuff properly\n\t\t\t */\n\t\t\tif (qh_init(qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET) != OK) {\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Failed to initialize query handler. Aborting\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\ttiming_point(\"Query handler initialized\\n\");\n\t\t\tnerd_init();\n\t\t\ttiming_point(\"NERD initialized\\n\");\n\n\t\t\t/* initialize check workers */\n\t\t\tif(init_workers(num_check_workers) < 0) {\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Failed to spawn workers. Aborting\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\ttiming_point(\"%u workers spawned\\n\", wproc_num_workers_spawned);\n\t\t\ti = 0;\n\t\t\twhile (i < 50 && wproc_num_workers_online < wproc_num_workers_spawned) {\n\t\t\t\tiobroker_poll(nagios_iobs, 50);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\ttiming_point(\"%u workers connected\\n\", wproc_num_workers_online);\n\n\t\t\t/* now that workers have arrived we can set the defaults */\n\t\t\tset_loadctl_defaults();\n\n#ifdef USE_EVENT_BROKER\n\t\t\t/* load modules */\n\t\t\tif (neb_load_all_modules() != OK) {\n\t\t\t\tlogit(NSLOG_CONFIG_ERROR, ERROR, \"Error: Module loading failed. Aborting.\\n\");\n\t\t\t\t/* if we're dumping core, we must remove all dl-files */\n\t\t\t\tif (daemon_dumps_core)\n\t\t\t\t\tneb_unload_all_modules(NEBMODULE_FORCE_UNLOAD, NEBMODULE_NEB_SHUTDOWN);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\ttiming_point(\"Modules loaded\\n\");\n\n\t\t\t/* send program data to broker */\n\t\t\tbroker_program_state(NEBTYPE_PROCESS_PRELAUNCH, NEBFLAG_NONE, NEBATTR_NONE, NULL);\n\t\t\ttiming_point(\"First callback made\\n\");\n#endif\n\n\t\t\t/* read in all object config data */\n\t\t\tif(result == OK)\n\t\t\t\tresult = read_all_object_data(config_file);\n\n\t\t\t/* there was a problem reading the config files */\n\t\t\tif(result != OK)\n\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, \"Bailing out due to one or more errors encountered in the configuration files. Run Nagios from the command line with the -v option to verify your config before restarting. (PID=%d)\", (int)getpid());\n\n\t\t\telse {\n\n\t\t\t\t/* run the pre-flight check to make sure everything looks okay*/\n\t\t\t\tif((result = pre_flight_check()) != OK)\n\t\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_VERIFICATION_ERROR, TRUE, \"Bailing out due to errors encountered while running the pre-flight check.  Run Nagios from the command line with the -v option to verify your config before restarting. (PID=%d)\\n\", (int)getpid());\n\t\t\t\t}\n\n\t\t\t/* an error occurred that prevented us from (re)starting */\n\t\t\tif(result != OK) {\n\n\t\t\t\t/* if we were restarting, we need to cleanup from the previous run */\n\t\t\t\tif(sigrestart == TRUE) {\n\n\t\t\t\t\t/* clean up the status data */\n\t\t\t\t\tcleanup_status_data(TRUE);\n\t\t\t\t\t}\n\n#ifdef USE_EVENT_BROKER\n\t\t\t\t/* send program data to broker */\n\t\t\t\tbroker_program_state(NEBTYPE_PROCESS_SHUTDOWN, NEBFLAG_PROCESS_INITIATED, NEBATTR_SHUTDOWN_ABNORMAL, NULL);\n#endif\n\t\t\t\tcleanup();\n\t\t\t\texit(ERROR);\n\t\t\t\t}\n\n\t\t\ttiming_point(\"Object configuration parsed and understood\\n\");\n\n\t\t\t/* write the objects.cache file */\n\t\t\tfcache_objects(object_cache_file);\n\t\t\ttiming_point(\"Objects cached\\n\");\n\n\t\t\tinit_event_queue();\n\t\t\ttiming_point(\"Event queue initialized\\n\");\n\n\n#ifdef USE_EVENT_BROKER\n\t\t\t/* send program data to broker */\n\t\t\tbroker_program_state(NEBTYPE_PROCESS_START, NEBFLAG_NONE, NEBATTR_NONE, NULL);\n#endif\n\n\t\t\t/* initialize status data unless we're starting */\n\t\t\tif(sigrestart == FALSE) {\n\t\t\t\tinitialize_status_data(config_file);\n\t\t\t\ttiming_point(\"Status data initialized\\n\");\n\t\t\t\t}\n\n\t\t\t/* initialize scheduled downtime data */\n\t\t\tinitialize_downtime_data();\n\t\t\ttiming_point(\"Downtime data initialized\\n\");\n\n\t\t\t/* read initial service and host state information  */\n\t\t\tinitialize_retention_data(config_file);\n\t\t\ttiming_point(\"Retention data initialized\\n\");\n\t\t\tread_initial_state_information();\n\t\t\ttiming_point(\"Initial state information read\\n\");\n\n\t\t\t/* initialize comment data */\n\t\t\tinitialize_comment_data();\n\t\t\ttiming_point(\"Comment data initialized\\n\");\n\n\t\t\t/* initialize performance data */\n\t\t\tinitialize_performance_data(config_file);\n\t\t\ttiming_point(\"Performance data initialized\\n\");\n\n\t\t\t/* initialize the event timing loop */\n\t\t\tinit_timing_loop();\n\t\t\ttiming_point(\"Event timing loop initialized\\n\");\n\n\t\t\t/* initialize check statistics */\n\t\t\tinit_check_stats();\n\t\t\ttiming_point(\"check stats initialized\\n\");\n\n\t\t\t/* check for updates */\n\t\t\tcheck_for_nagios_updates(FALSE, TRUE);\n\t\t\ttiming_point(\"Update check concluded\\n\");\n\n\t\t\t/* update all status data (with retained information) */\n\t\t\tupdate_all_status_data();\n\t\t\ttiming_point(\"Status data updated\\n\");\n\n\t\t\t/* log initial host and service state */\n\t\t\tlog_host_states(INITIAL_STATES, NULL);\n\t\t\tlog_service_states(INITIAL_STATES, NULL);\n\t\t\ttiming_point(\"Initial states logged\\n\");\n\n\t\t\t/* reset the restart flag */\n\t\t\tsigrestart = FALSE;\n\n\t\t\t/* fire up command file worker */\n\t\t\tlaunch_command_file_worker();\n\t\t\ttiming_point(\"Command file worker launched\\n\");\n\n#ifdef USE_EVENT_BROKER\n\t\t\t/* send program data to broker */\n\t\t\tbroker_program_state(NEBTYPE_PROCESS_EVENTLOOPSTART, NEBFLAG_NONE, NEBATTR_NONE, NULL);\n#endif\n\n\t\t\t/* get event start time and save as macro */\n\t\t\tevent_start = time(NULL);\n\t\t\tmy_free(mac->x[MACRO_EVENTSTARTTIME]);\n\t\t\tasprintf(&mac->x[MACRO_EVENTSTARTTIME], \"%llu\", (unsigned long long)event_start);\n\n\t\t\ttiming_point(\"Entering event execution loop\\n\");\n\t\t\t/***** start monitoring all services *****/\n\t\t\t/* (doesn't return until a restart or shutdown signal is encountered) */\n\t\t\tevent_execution_loop();\n\n\t\t\t/*\n\t\t\t * immediately deinitialize the query handler so it\n\t\t\t * can remove modules that have stashed data with it\n\t\t\t */\n\t\t\tqh_deinit(qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET);\n\n\t\t\t/* 03/01/2007 EG Moved from sighandler() to prevent FUTEX locking problems under NPTL */\n\t\t\t/* 03/21/2007 EG SIGSEGV signals are still logged in sighandler() so we don't loose them */\n\t\t\t/* did we catch a signal? */\n\t\t\tif(caught_signal == TRUE) {\n\n\t\t\t\tif(sig_id == SIGHUP)\n\t\t\t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Caught SIGHUP, restarting...\\n\");\n\n\t\t\t\t}\n\n#ifdef USE_EVENT_BROKER\n\t\t\t/* send program data to broker */\n\t\t\tbroker_program_state(NEBTYPE_PROCESS_EVENTLOOPEND, NEBFLAG_NONE, NEBATTR_NONE, NULL);\n\t\t\tif(sigshutdown == TRUE)\n\t\t\t\tbroker_program_state(NEBTYPE_PROCESS_SHUTDOWN, NEBFLAG_USER_INITIATED, NEBATTR_SHUTDOWN_NORMAL, NULL);\n\t\t\telse if(sigrestart == TRUE)\n\t\t\t\tbroker_program_state(NEBTYPE_PROCESS_RESTART, NEBFLAG_USER_INITIATED, NEBATTR_RESTART_NORMAL, NULL);\n#endif\n\n\t\t\t/* save service and host state information */\n\t\t\tsave_state_information(FALSE);\n\t\t\tcleanup_retention_data();\n\n\t\t\t/* clean up performance data */\n\t\t\tcleanup_performance_data();\n\n\t\t\t/* clean up the scheduled downtime data */\n\t\t\tcleanup_downtime_data();\n\n\t\t\t/* clean up the status data unless we're restarting */\n\t\t\tif(sigrestart == FALSE) {\n\t\t\t\tcleanup_status_data(TRUE);\n\t\t\t\t}\n\n\t\t\tfree_worker_memory(WPROC_FORCE);\n\t\t\t/* shutdown stuff... */\n\t\t\tif(sigshutdown == TRUE) {\n\t\t\t\tiobroker_destroy(nagios_iobs, IOBROKER_CLOSE_SOCKETS);\n\t\t\t\tnagios_iobs = NULL;\n\n\t\t\t\t/* log a shutdown message */\n\t\t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Successfully shutdown... (PID=%d)\\n\", (int)getpid());\n\t\t\t\t}\n\n\t\t\t/* clean up after ourselves */\n\t\t\tcleanup();\n\n\t\t\t/* close debug log */\n\t\t\tclose_debug_log();\n\n\t\t\t}\n\t\twhile(sigrestart == TRUE && sigshutdown == FALSE);\n\n\t\tif(daemon_mode == TRUE)\n\t\t\tunlink(lock_file);\n\n\t\t/* free misc memory */\n\t\tmy_free(lock_file);\n\t\tmy_free(config_file);\n\t\tmy_free(config_file_dir);\n\t\tmy_free(nagios_binary_path);\n\t\t}\n\n\treturn OK;\n\t}",
        "func": "int main(int argc, char **argv) {\n\tint result;\n\tint error = FALSE;\n\tint display_license = FALSE;\n\tint display_help = FALSE;\n\tint c = 0;\n\tstruct tm *tm, tm_s;\n\ttime_t now;\n\tchar datestring[256];\n\tnagios_macros *mac;\n\tconst char *worker_socket = NULL;\n\tint i;\n#ifdef HAVE_SIGACTION\n\tstruct sigaction sig_action;\n#endif\n\n#ifdef HAVE_GETOPT_H\n\tint option_index = 0;\n\tstatic struct option long_options[] = {\n\t\t\t{\"help\", no_argument, 0, 'h'},\n\t\t\t{\"version\", no_argument, 0, 'V'},\n\t\t\t{\"license\", no_argument, 0, 'V'},\n\t\t\t{\"verify-config\", no_argument, 0, 'v'},\n\t\t\t{\"daemon\", no_argument, 0, 'd'},\n\t\t\t{\"test-scheduling\", no_argument, 0, 's'},\n\t\t\t{\"precache-objects\", no_argument, 0, 'p'},\n\t\t\t{\"use-precached-objects\", no_argument, 0, 'u'},\n\t\t\t{\"enable-timing-point\", no_argument, 0, 'T'},\n\t\t\t{\"worker\", required_argument, 0, 'W'},\n\t\t\t{0, 0, 0, 0}\n\t\t};\n#define getopt(argc, argv, o) getopt_long(argc, argv, o, long_options, &option_index)\n#endif\n\n\tmemset(&loadctl, 0, sizeof(loadctl));\n\tmac = get_global_macros();\n\n\t/* make sure we have the correct number of command line arguments */\n\tif(argc < 2)\n\t\terror = TRUE;\n\n\t/* get all command line arguments */\n\twhile(1) {\n\t\tc = getopt(argc, argv, \"+hVvdspuxTW\");\n\n\t\tif(c == -1 || c == EOF)\n\t\t\tbreak;\n\n\t\tswitch(c) {\n\n\t\t\tcase '?': /* usage */\n\t\t\tcase 'h':\n\t\t\t\tdisplay_help = TRUE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'V': /* version */\n\t\t\t\tdisplay_license = TRUE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'v': /* verify */\n\t\t\t\tverify_config++;\n\t\t\t\tbreak;\n\n\t\t\tcase 's': /* scheduling check */\n\t\t\t\ttest_scheduling = TRUE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'd': /* daemon mode */\n\t\t\t\tdaemon_mode = TRUE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'p': /* precache object config */\n\t\t\t\tprecache_objects = TRUE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'u': /* use precached object config */\n\t\t\t\tuse_precached_objects = TRUE;\n\t\t\t\tbreak;\n\t\t\tcase 'T':\n\t\t\t\tenable_timing_point = TRUE;\n\t\t\t\tbreak;\n\t\t\tcase 'W':\n\t\t\t\tworker_socket = optarg;\n\t\t\t\tbreak;\n\n\t\t\tcase 'x':\n\t\t\t\tprintf(\"Warning: -x is deprecated and will be removed\\n\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n#ifdef DEBUG_MEMORY\n\tmtrace();\n#endif\n\t/* if we're a worker we can skip everything below */\n\tif(worker_socket) {\n\t\texit(nagios_core_worker(worker_socket));\n\t}\n\n\t/* Initialize configuration variables */                             \n\tinit_main_cfg_vars(1);\n\tinit_shared_cfg_vars(1);\n\n\tif(daemon_mode == FALSE) {\n\t\tprintf(\"\\nNagios Core %s\\n\", PROGRAM_VERSION);\n\t\tprintf(\"Copyright (c) 2009-present Nagios Core Development Team and Community Contributors\\n\");\n\t\tprintf(\"Copyright (c) 1999-2009 Ethan Galstad\\n\");\n\t\tprintf(\"Last Modified: %s\\n\", PROGRAM_MODIFICATION_DATE);\n\t\tprintf(\"License: GPL\\n\\n\");\n\t\tprintf(\"Website: https://www.nagios.org\\n\");\n\t\t}\n\n\t/* just display the license */\n\tif(display_license == TRUE) {\n\n\t\tprintf(\"This program is free software; you can redistribute it and/or modify\\n\");\n\t\tprintf(\"it under the terms of the GNU General Public License version 2 as\\n\");\n\t\tprintf(\"published by the Free Software Foundation.\\n\\n\");\n\t\tprintf(\"This program is distributed in the hope that it will be useful,\\n\");\n\t\tprintf(\"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\");\n\t\tprintf(\"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\");\n\t\tprintf(\"GNU General Public License for more details.\\n\\n\");\n\t\tprintf(\"You should have received a copy of the GNU General Public License\\n\");\n\t\tprintf(\"along with this program; if not, write to the Free Software\\n\");\n\t\tprintf(\"Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\\n\\n\");\n\n\t\texit(OK);\n\t\t}\n\n\t/* make sure we got the main config file on the command line... */\n\tif(optind >= argc)\n\t\terror = TRUE;\n\n\t/* if there are no command line options (or if we encountered an error), print usage */\n\tif(error == TRUE || display_help == TRUE) {\n\n\t\tprintf(\"Usage: %s [options] <main_config_file>\\n\", argv[0]);\n\t\tprintf(\"\\n\");\n\t\tprintf(\"Options:\\n\");\n\t\tprintf(\"\\n\");\n\t\tprintf(\"  -v, --verify-config          Verify all configuration data (-v -v for more info)\\n\");\n\t\tprintf(\"  -s, --test-scheduling        Shows projected/recommended check scheduling and other\\n\");\n\t\tprintf(\"                               diagnostic info based on the current configuration files.\\n\");\n\t\tprintf(\"  -T, --enable-timing-point    Enable timed commentary on initialization\\n\");\n\t\tprintf(\"  -x, --dont-verify-paths      Deprecated (Don't check for circular object paths)\\n\");\n\t\tprintf(\"  -p, --precache-objects       Precache object configuration\\n\");\n\t\tprintf(\"  -u, --use-precached-objects  Use precached object config file\\n\");\n\t\tprintf(\"  -d, --daemon                 Starts Nagios in daemon mode, instead of as a foreground process\\n\");\n\t\tprintf(\"  -W, --worker /path/to/socket Act as a worker for an already running daemon\\n\");\n\t\tprintf(\"\\n\");\n\t\tprintf(\"Visit the Nagios website at https://www.nagios.org/ for bug fixes, new\\n\");\n\t\tprintf(\"releases, online documentation, FAQs, information on subscribing to\\n\");\n\t\tprintf(\"the mailing lists, and commercial support options for Nagios.\\n\");\n\t\tprintf(\"\\n\");\n\n\t\texit(ERROR);\n\t\t}\n\n\n\t/*\n\t * config file is last argument specified.\n\t * Make sure it uses an absolute path\n\t */\n\tconfig_file = nspath_absolute(argv[optind], NULL);\n\tif(config_file == NULL) {\n\t\tprintf(\"Error allocating memory.\\n\");\n\t\texit(ERROR);\n\t\t}\n\n\tconfig_file_dir = nspath_absolute_dirname(config_file, NULL);\n\n\t/* \n\t * Set the signal handler for the SIGXFSZ signal here because\n\t * we may encounter this signal before the other signal handlers\n\t * are set.\n\t */\n#ifdef HAVE_SIGACTION\n\tsig_action.sa_sigaction = NULL;\n\tsig_action.sa_handler = handle_sigxfsz;\n\tsigfillset(&sig_action.sa_mask);\n\tsig_action.sa_flags = SA_NODEFER|SA_RESTART;\n\tsigaction(SIGXFSZ, &sig_action, NULL);\n#else\n\tsignal(SIGXFSZ, handle_sigxfsz);\n#endif\n\n\t/*\n\t * let's go to town. We'll be noisy if we're verifying config\n\t * or running scheduling tests.\n\t */\n\tif(verify_config || test_scheduling || precache_objects) {\n\t\treset_variables();\n\t\t/*\n\t\t * if we don't beef up our resource limits as much as\n\t\t * we can, it's quite possible we'll run headlong into\n\t\t * EAGAIN due to too many processes when we try to\n\t\t * drop privileges later.\n\t\t */\n\t\tset_loadctl_defaults();\n\n\t\tif(verify_config)\n\t\t\tprintf(\"Reading configuration data...\\n\");\n\n\t\t/* read our config file */\n\t\tresult = read_main_config_file(config_file);\n\t\tif(result != OK) {\n\t\t\tprintf(\"   Error processing main config file!\\n\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\tif(verify_config)\n\t\t\tprintf(\"   Read main config file okay...\\n\");\n\n\t\t/* drop privileges */\n\t\tif((result = drop_privileges(nagios_user, nagios_group)) == ERROR) {\n\t\t\tprintf(\"   Failed to drop privileges.  Aborting.\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\t/*\n\t\t * this must come after dropping privileges, so we make\n\t\t * sure to test access permissions as the right user.\n\t\t */\n\t\tif (!verify_config && test_configured_paths() == ERROR) {\n\t\t\tprintf(\"   One or more path problems detected. Aborting.\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\t/* read object config files */\n\t\tresult = read_all_object_data(config_file);\n\t\tif(result != OK) {\n\t\t\tprintf(\"   Error processing object config files!\\n\\n\");\n\t\t\t/* if the config filename looks fishy, warn the user */\n\t\t\tif(!strstr(config_file, \"nagios.cfg\")) {\n\t\t\t\tprintf(\"\\n***> The name of the main configuration file looks suspicious...\\n\");\n\t\t\t\tprintf(\"\\n\");\n\t\t\t\tprintf(\"     Make sure you are specifying the name of the MAIN configuration file on\\n\");\n\t\t\t\tprintf(\"     the command line and not the name of another configuration file.  The\\n\");\n\t\t\t\tprintf(\"     main configuration file is typically '%s'\\n\", DEFAULT_CONFIG_FILE);\n\t\t\t\t}\n\n\t\t\tprintf(\"\\n***> One or more problems was encountered while processing the config files...\\n\");\n\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"     Check your configuration file(s) to ensure that they contain valid\\n\");\n\t\t\tprintf(\"     directives and data definitions.  If you are upgrading from a previous\\n\");\n\t\t\tprintf(\"     version of Nagios, you should be aware that some variables/definitions\\n\");\n\t\t\tprintf(\"     may have been removed or modified in this version.  Make sure to read\\n\");\n\t\t\tprintf(\"     the HTML documentation regarding the config files, as well as the\\n\");\n\t\t\tprintf(\"     'Whats New' section to find out what has changed.\\n\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\tif(verify_config) {\n\t\t\tprintf(\"   Read object config files okay...\\n\\n\");\n\t\t\tprintf(\"Running pre-flight check on configuration data...\\n\\n\");\n\t\t\t}\n\n\t\t/* run the pre-flight check to make sure things look okay... */\n\t\tresult = pre_flight_check();\n\n\t\tif(result != OK) {\n\t\t\tprintf(\"\\n***> One or more problems was encountered while running the pre-flight check...\\n\");\n\t\t\tprintf(\"\\n\");\n\t\t\tprintf(\"     Check your configuration file(s) to ensure that they contain valid\\n\");\n\t\t\tprintf(\"     directives and data definitions.  If you are upgrading from a previous\\n\");\n\t\t\tprintf(\"     version of Nagios, you should be aware that some variables/definitions\\n\");\n\t\t\tprintf(\"     may have been removed or modified in this version.  Make sure to read\\n\");\n\t\t\tprintf(\"     the HTML documentation regarding the config files, as well as the\\n\");\n\t\t\tprintf(\"     'Whats New' section to find out what has changed.\\n\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\tif(verify_config) {\n\t\t\tprintf(\"\\nThings look okay - No serious problems were detected during the pre-flight check\\n\");\n\t\t\t}\n\n\t\t/* scheduling tests need a bit more than config verifications */\n\t\tif(test_scheduling == TRUE) {\n\n\t\t\t/* we'll need the event queue here so we can time insertions */\n\t\t\tinit_event_queue();\n\t\t\ttiming_point(\"Done initializing event queue\\n\");\n\n\t\t\t/* read initial service and host state information */\n\t\t\tinitialize_retention_data(config_file);\n\t\t\tread_initial_state_information();\n\t\t\ttiming_point(\"Retention data and initial state parsed\\n\");\n\n\t\t\t/* initialize the event timing loop */\n\t\t\tinit_timing_loop();\n\t\t\ttiming_point(\"Timing loop initialized\\n\");\n\n\t\t\t/* display scheduling information */\n\t\t\tdisplay_scheduling_info();\n\t\t\t}\n\n\t\tif(precache_objects) {\n\t\t\tresult = fcache_objects(object_precache_file);\n\t\t\ttiming_point(\"Done precaching objects\\n\");\n\t\t\tif(result == OK) {\n\t\t\t\tprintf(\"Object precache file created:\\n%s\\n\", object_precache_file);\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"Failed to precache objects to '%s': %s\\n\", object_precache_file, strerror(errno));\n\t\t\t\t}\n\t\t\t}\n\n\t\t/* clean up after ourselves */\n\t\tcleanup();\n\n\t\t/* exit */\n\t\ttiming_point(\"Exiting\\n\");\n\n\t\t/* make valgrind shut up about still reachable memory */\n\t\tneb_free_module_list();\n\t\tfree(config_file_dir);\n\t\tfree(config_file);\n\n\t\texit(result);\n\t\t}\n\n\n\t/* else start to monitor things... */\n\telse {\n\n\t\t/*\n\t\t * if we're called with a relative path we must make\n\t\t * it absolute so we can launch our workers.\n\t\t * If not, we needn't bother, as we're using execvp()\n\t\t */\n\t\tif (strchr(argv[0], '/'))\n\t\t\tnagios_binary_path = nspath_absolute(argv[0], NULL);\n\t\telse\n\t\t\tnagios_binary_path = strdup(argv[0]);\n\n\t\tif (!nagios_binary_path) {\n\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Unable to allocate memory for nagios_binary_path\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\tif (!(nagios_iobs = iobroker_create())) {\n\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Failed to create IO broker set: %s\\n\",\n\t\t\t\t  strerror(errno));\n\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\n\t\t/* keep monitoring things until we get a shutdown command */\n\t\tdo {\n\t\t\t/* reset internal book-keeping (in case we're restarting) */\n\t\t\twproc_num_workers_spawned = wproc_num_workers_online = 0;\n\t\t\tcaught_signal = sigshutdown = FALSE;\n\t\t\tsig_id = 0;\n\n\t\t\t/* reset program variables */\n\t\t\treset_variables();\n\t\t\ttiming_point(\"Variables reset\\n\");\n\n\t\t\t/* get PID */\n\t\t\tnagios_pid = (int)getpid();\n\n\t\t\t/* read in the configuration files (main and resource config files) */\n\t\t\tresult = read_main_config_file(config_file);\n\t\t\tif (result != OK) {\n\t\t\t\tlogit(NSLOG_CONFIG_ERROR, TRUE, \"Error: Failed to process config file '%s'. Aborting\\n\", config_file);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\ttiming_point(\"Main config file read\\n\");\n\n\t\t\t/* NOTE 11/06/07 EG moved to after we read config files, as user may have overridden timezone offset */\n\t\t\t/* get program (re)start time and save as macro */\n\t\t\tprogram_start = time(NULL);\n\t\t\tmy_free(mac->x[MACRO_PROCESSSTARTTIME]);\n\t\t\tasprintf(&mac->x[MACRO_PROCESSSTARTTIME], \"%llu\", (unsigned long long)program_start);\n\t\t\t\n\t\t\t/* enter daemon mode (unless we're restarting...) */\n\t\t\tif(daemon_mode == TRUE && sigrestart == FALSE) {\n\n\t\t\t\tresult = daemon_init();\n\n\t\t\t\t/* we had an error daemonizing, so bail... */\n\t\t\t\tif(result == ERROR) {\n\t\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR, TRUE, \"Bailing out due to failure to daemonize. (PID=%d)\", (int)getpid());\n\t\t\t\t\tcleanup();\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t\t}\n\n\t\t\t\t/* get new PID */\n\t\t\t\tnagios_pid = (int)getpid();\n\t\t\t\t}\n\n\t\t\t/* drop privileges */\n\t\t\tif(drop_privileges(nagios_user, nagios_group) == ERROR) {\n\n\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, \"Failed to drop privileges.  Aborting.\");\n\n\t\t\t\tcleanup();\n\t\t\t\texit(ERROR);\n\t\t\t\t}\n\n\t\t\tif (test_path_access(nagios_binary_path, X_OK)) {\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: failed to access() %s: %s\\n\", nagios_binary_path, strerror(errno));\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Spawning workers will be impossible. Aborting.\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\n\t\t\tif (test_configured_paths() == ERROR) {\n\t\t\t\t/* error has already been logged */\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\n\t\t\t/* this must be logged after we read config data, as user may have changed location of main log file */\n\t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Nagios %s starting... (PID=%d)\\n\", PROGRAM_VERSION, (int)getpid());\n\n\t\t\t/* log the local time - may be different than clock time due to timezone offset */\n\t\t\tnow = time(NULL);\n\t\t\ttm = localtime_r(&now, &tm_s);\n\t\t\tstrftime(datestring, sizeof(datestring), \"%a %b %d %H:%M:%S %Z %Y\", tm);\n\t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Local time is %s\", datestring);\n\n\t\t\t/* write log version/info */\n\t\t\twrite_log_file_info(NULL);\n\n\t\t\t/* open debug log now that we're the right user */\n\t\t\topen_debug_log();\n\n#ifdef USE_EVENT_BROKER\n\t\t\t/* initialize modules */\n\t\t\tneb_init_modules();\n\t\t\tneb_init_callback_list();\n#endif\n\t\t\ttiming_point(\"NEB module API initialized\\n\");\n\n\t\t\t/* handle signals (interrupts) before we do any socket I/O */\n\t\t\tsetup_sighandler();\n\n\t\t\t/*\n\t\t\t * Initialize query handler and event subscription service.\n\t\t\t * This must be done before modules are initialized, so\n\t\t\t * the modules can use our in-core stuff properly\n\t\t\t */\n\t\t\tif (qh_init(qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET) != OK) {\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Failed to initialize query handler. Aborting\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\ttiming_point(\"Query handler initialized\\n\");\n\t\t\tnerd_init();\n\t\t\ttiming_point(\"NERD initialized\\n\");\n\n\t\t\t/* initialize check workers */\n\t\t\tif(init_workers(num_check_workers) < 0) {\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Failed to spawn workers. Aborting\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\ttiming_point(\"%u workers spawned\\n\", wproc_num_workers_spawned);\n\t\t\ti = 0;\n\t\t\twhile (i < 50 && wproc_num_workers_online < wproc_num_workers_spawned) {\n\t\t\t\tiobroker_poll(nagios_iobs, 50);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\ttiming_point(\"%u workers connected\\n\", wproc_num_workers_online);\n\n\t\t\t/* now that workers have arrived we can set the defaults */\n\t\t\tset_loadctl_defaults();\n\n#ifdef USE_EVENT_BROKER\n\t\t\t/* load modules */\n\t\t\tif (neb_load_all_modules() != OK) {\n\t\t\t\tlogit(NSLOG_CONFIG_ERROR, ERROR, \"Error: Module loading failed. Aborting.\\n\");\n\t\t\t\t/* if we're dumping core, we must remove all dl-files */\n\t\t\t\tif (daemon_dumps_core)\n\t\t\t\t\tneb_unload_all_modules(NEBMODULE_FORCE_UNLOAD, NEBMODULE_NEB_SHUTDOWN);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\ttiming_point(\"Modules loaded\\n\");\n\n\t\t\t/* send program data to broker */\n\t\t\tbroker_program_state(NEBTYPE_PROCESS_PRELAUNCH, NEBFLAG_NONE, NEBATTR_NONE, NULL);\n\t\t\ttiming_point(\"First callback made\\n\");\n#endif\n\n\t\t\t/* read in all object config data */\n\t\t\tif(result == OK)\n\t\t\t\tresult = read_all_object_data(config_file);\n\n\t\t\t/* there was a problem reading the config files */\n\t\t\tif(result != OK)\n\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, \"Bailing out due to one or more errors encountered in the configuration files. Run Nagios from the command line with the -v option to verify your config before restarting. (PID=%d)\", (int)getpid());\n\n\t\t\telse {\n\n\t\t\t\t/* run the pre-flight check to make sure everything looks okay*/\n\t\t\t\tif((result = pre_flight_check()) != OK)\n\t\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_VERIFICATION_ERROR, TRUE, \"Bailing out due to errors encountered while running the pre-flight check.  Run Nagios from the command line with the -v option to verify your config before restarting. (PID=%d)\\n\", (int)getpid());\n\t\t\t\t}\n\n\t\t\t/* an error occurred that prevented us from (re)starting */\n\t\t\tif(result != OK) {\n\n\t\t\t\t/* if we were restarting, we need to cleanup from the previous run */\n\t\t\t\tif(sigrestart == TRUE) {\n\n\t\t\t\t\t/* clean up the status data */\n\t\t\t\t\tcleanup_status_data(TRUE);\n\t\t\t\t\t}\n\n#ifdef USE_EVENT_BROKER\n\t\t\t\t/* send program data to broker */\n\t\t\t\tbroker_program_state(NEBTYPE_PROCESS_SHUTDOWN, NEBFLAG_PROCESS_INITIATED, NEBATTR_SHUTDOWN_ABNORMAL, NULL);\n#endif\n\t\t\t\tcleanup();\n\t\t\t\texit(ERROR);\n\t\t\t\t}\n\n\t\t\ttiming_point(\"Object configuration parsed and understood\\n\");\n\n\t\t\t/* write the objects.cache file */\n\t\t\tfcache_objects(object_cache_file);\n\t\t\ttiming_point(\"Objects cached\\n\");\n\n\t\t\tinit_event_queue();\n\t\t\ttiming_point(\"Event queue initialized\\n\");\n\n\n#ifdef USE_EVENT_BROKER\n\t\t\t/* send program data to broker */\n\t\t\tbroker_program_state(NEBTYPE_PROCESS_START, NEBFLAG_NONE, NEBATTR_NONE, NULL);\n#endif\n\n\t\t\t/* initialize status data unless we're starting */\n\t\t\tif(sigrestart == FALSE) {\n\t\t\t\tinitialize_status_data(config_file);\n\t\t\t\ttiming_point(\"Status data initialized\\n\");\n\t\t\t\t}\n\n\t\t\t/* initialize scheduled downtime data */\n\t\t\tinitialize_downtime_data();\n\t\t\ttiming_point(\"Downtime data initialized\\n\");\n\n\t\t\t/* read initial service and host state information  */\n\t\t\tinitialize_retention_data(config_file);\n\t\t\ttiming_point(\"Retention data initialized\\n\");\n\t\t\tread_initial_state_information();\n\t\t\ttiming_point(\"Initial state information read\\n\");\n\n\t\t\t/* initialize comment data */\n\t\t\tinitialize_comment_data();\n\t\t\ttiming_point(\"Comment data initialized\\n\");\n\n\t\t\t/* initialize performance data */\n\t\t\tinitialize_performance_data(config_file);\n\t\t\ttiming_point(\"Performance data initialized\\n\");\n\n\t\t\t/* initialize the event timing loop */\n\t\t\tinit_timing_loop();\n\t\t\ttiming_point(\"Event timing loop initialized\\n\");\n\n\t\t\t/* initialize check statistics */\n\t\t\tinit_check_stats();\n\t\t\ttiming_point(\"check stats initialized\\n\");\n\n\t\t\t/* check for updates */\n\t\t\tcheck_for_nagios_updates(FALSE, TRUE);\n\t\t\ttiming_point(\"Update check concluded\\n\");\n\n\t\t\t/* update all status data (with retained information) */\n\t\t\tupdate_all_status_data();\n\t\t\ttiming_point(\"Status data updated\\n\");\n\n\t\t\t/* log initial host and service state */\n\t\t\tlog_host_states(INITIAL_STATES, NULL);\n\t\t\tlog_service_states(INITIAL_STATES, NULL);\n\t\t\ttiming_point(\"Initial states logged\\n\");\n\n\t\t\t/* reset the restart flag */\n\t\t\tsigrestart = FALSE;\n\n\t\t\t/* fire up command file worker */\n\t\t\tlaunch_command_file_worker();\n\t\t\ttiming_point(\"Command file worker launched\\n\");\n\n#ifdef USE_EVENT_BROKER\n\t\t\t/* send program data to broker */\n\t\t\tbroker_program_state(NEBTYPE_PROCESS_EVENTLOOPSTART, NEBFLAG_NONE, NEBATTR_NONE, NULL);\n#endif\n\n\t\t\t/* get event start time and save as macro */\n\t\t\tevent_start = time(NULL);\n\t\t\tmy_free(mac->x[MACRO_EVENTSTARTTIME]);\n\t\t\tasprintf(&mac->x[MACRO_EVENTSTARTTIME], \"%llu\", (unsigned long long)event_start);\n\n\t\t\ttiming_point(\"Entering event execution loop\\n\");\n\t\t\t/***** start monitoring all services *****/\n\t\t\t/* (doesn't return until a restart or shutdown signal is encountered) */\n\t\t\tevent_execution_loop();\n\n\t\t\t/*\n\t\t\t * immediately deinitialize the query handler so it\n\t\t\t * can remove modules that have stashed data with it\n\t\t\t */\n\t\t\tqh_deinit(qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET);\n\n\t\t\t/* 03/01/2007 EG Moved from sighandler() to prevent FUTEX locking problems under NPTL */\n\t\t\t/* 03/21/2007 EG SIGSEGV signals are still logged in sighandler() so we don't loose them */\n\t\t\t/* did we catch a signal? */\n\t\t\tif(caught_signal == TRUE) {\n\n\t\t\t\tif(sig_id == SIGHUP)\n\t\t\t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Caught SIGHUP, restarting...\\n\");\n\n\t\t\t\t}\n\n#ifdef USE_EVENT_BROKER\n\t\t\t/* send program data to broker */\n\t\t\tbroker_program_state(NEBTYPE_PROCESS_EVENTLOOPEND, NEBFLAG_NONE, NEBATTR_NONE, NULL);\n\t\t\tif(sigshutdown == TRUE)\n\t\t\t\tbroker_program_state(NEBTYPE_PROCESS_SHUTDOWN, NEBFLAG_USER_INITIATED, NEBATTR_SHUTDOWN_NORMAL, NULL);\n\t\t\telse if(sigrestart == TRUE)\n\t\t\t\tbroker_program_state(NEBTYPE_PROCESS_RESTART, NEBFLAG_USER_INITIATED, NEBATTR_RESTART_NORMAL, NULL);\n#endif\n\n\t\t\t/* save service and host state information */\n\t\t\tsave_state_information(FALSE);\n\t\t\tcleanup_retention_data();\n\n\t\t\t/* clean up performance data */\n\t\t\tcleanup_performance_data();\n\n\t\t\t/* clean up the scheduled downtime data */\n\t\t\tcleanup_downtime_data();\n\n\t\t\t/* clean up the status data unless we're restarting */\n\t\t\tif(sigrestart == FALSE) {\n\t\t\t\tcleanup_status_data(TRUE);\n\t\t\t\t}\n\n\t\t\tfree_worker_memory(WPROC_FORCE);\n\t\t\t/* shutdown stuff... */\n\t\t\tif(sigshutdown == TRUE) {\n\t\t\t\tiobroker_destroy(nagios_iobs, IOBROKER_CLOSE_SOCKETS);\n\t\t\t\tnagios_iobs = NULL;\n\n\t\t\t\t/* log a shutdown message */\n\t\t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Successfully shutdown... (PID=%d)\\n\", (int)getpid());\n\t\t\t\t}\n\n\t\t\t/* clean up after ourselves */\n\t\t\tcleanup();\n\n\t\t\t/* close debug log */\n\t\t\tclose_debug_log();\n\n\t\t\t}\n\t\twhile(sigrestart == TRUE && sigshutdown == FALSE);\n\n\t\tif(daemon_mode == TRUE)\n\t\t\tunlink(lock_file);\n\n\t\t/* free misc memory */\n\t\tmy_free(lock_file);\n\t\tmy_free(config_file);\n\t\tmy_free(config_file_dir);\n\t\tmy_free(nagios_binary_path);\n\t\t}\n\n\treturn OK;\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -375,26 +375,7 @@\n \t\t\tprogram_start = time(NULL);\n \t\t\tmy_free(mac->x[MACRO_PROCESSSTARTTIME]);\n \t\t\tasprintf(&mac->x[MACRO_PROCESSSTARTTIME], \"%llu\", (unsigned long long)program_start);\n-\n-\t\t\t/* drop privileges */\n-\t\t\tif(drop_privileges(nagios_user, nagios_group) == ERROR) {\n-\n-\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, \"Failed to drop privileges.  Aborting.\");\n-\n-\t\t\t\tcleanup();\n-\t\t\t\texit(ERROR);\n-\t\t\t\t}\n-\n-\t\t\tif (test_path_access(nagios_binary_path, X_OK)) {\n-\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: failed to access() %s: %s\\n\", nagios_binary_path, strerror(errno));\n-\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Spawning workers will be impossible. Aborting.\\n\");\n-\t\t\t\texit(EXIT_FAILURE);\n-\t\t\t\t}\n-\n-\t\t\tif (test_configured_paths() == ERROR) {\n-\t\t\t\t/* error has already been logged */\n-\t\t\t\texit(EXIT_FAILURE);\n-\t\t\t\t}\n+\t\t\t\n \t\t\t/* enter daemon mode (unless we're restarting...) */\n \t\t\tif(daemon_mode == TRUE && sigrestart == FALSE) {\n \n@@ -409,6 +390,26 @@\n \n \t\t\t\t/* get new PID */\n \t\t\t\tnagios_pid = (int)getpid();\n+\t\t\t\t}\n+\n+\t\t\t/* drop privileges */\n+\t\t\tif(drop_privileges(nagios_user, nagios_group) == ERROR) {\n+\n+\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, \"Failed to drop privileges.  Aborting.\");\n+\n+\t\t\t\tcleanup();\n+\t\t\t\texit(ERROR);\n+\t\t\t\t}\n+\n+\t\t\tif (test_path_access(nagios_binary_path, X_OK)) {\n+\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: failed to access() %s: %s\\n\", nagios_binary_path, strerror(errno));\n+\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Spawning workers will be impossible. Aborting.\\n\");\n+\t\t\t\texit(EXIT_FAILURE);\n+\t\t\t\t}\n+\n+\t\t\tif (test_configured_paths() == ERROR) {\n+\t\t\t\t/* error has already been logged */\n+\t\t\t\texit(EXIT_FAILURE);\n \t\t\t\t}\n \n \t\t\t/* this must be logged after we read config data, as user may have changed location of main log file */",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "\t\t\t/* drop privileges */",
                "\t\t\tif(drop_privileges(nagios_user, nagios_group) == ERROR) {",
                "",
                "\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, \"Failed to drop privileges.  Aborting.\");",
                "",
                "\t\t\t\tcleanup();",
                "\t\t\t\texit(ERROR);",
                "\t\t\t\t}",
                "",
                "\t\t\tif (test_path_access(nagios_binary_path, X_OK)) {",
                "\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: failed to access() %s: %s\\n\", nagios_binary_path, strerror(errno));",
                "\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Spawning workers will be impossible. Aborting.\\n\");",
                "\t\t\t\texit(EXIT_FAILURE);",
                "\t\t\t\t}",
                "",
                "\t\t\tif (test_configured_paths() == ERROR) {",
                "\t\t\t\t/* error has already been logged */",
                "\t\t\t\texit(EXIT_FAILURE);",
                "\t\t\t\t}"
            ],
            "added_lines": [
                "\t\t\t",
                "\t\t\t\t}",
                "",
                "\t\t\t/* drop privileges */",
                "\t\t\tif(drop_privileges(nagios_user, nagios_group) == ERROR) {",
                "",
                "\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, \"Failed to drop privileges.  Aborting.\");",
                "",
                "\t\t\t\tcleanup();",
                "\t\t\t\texit(ERROR);",
                "\t\t\t\t}",
                "",
                "\t\t\tif (test_path_access(nagios_binary_path, X_OK)) {",
                "\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: failed to access() %s: %s\\n\", nagios_binary_path, strerror(errno));",
                "\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Spawning workers will be impossible. Aborting.\\n\");",
                "\t\t\t\texit(EXIT_FAILURE);",
                "\t\t\t\t}",
                "",
                "\t\t\tif (test_configured_paths() == ERROR) {",
                "\t\t\t\t/* error has already been logged */",
                "\t\t\t\texit(EXIT_FAILURE);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-13715",
        "func_name": "torvalds/linux/__skb_flow_dissect",
        "description": "The __skb_flow_dissect function in net/core/flow_dissector.c in the Linux kernel before 4.3 does not ensure that n_proto, ip_proto, and thoff are initialized, which allows remote attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a single crafted MPLS packet.",
        "git_url": "https://github.com/torvalds/linux/commit/a6e544b0a88b53114bfa5a57e21b7be7a8dfc9d0",
        "commit_title": "flow_dissector: Jump to exit code in __skb_flow_dissect",
        "commit_text": " Instead of returning immediately (on a parsing failure for instance) we jump to cleanup code. This always sets protocol values in key_control (even on a failure there is still valid information in the key_tags that was set before the problem was hit). ",
        "func_before": "bool __skb_flow_dissect(const struct sk_buff *skb,\n\t\t\tstruct flow_dissector *flow_dissector,\n\t\t\tvoid *target_container,\n\t\t\tvoid *data, __be16 proto, int nhoff, int hlen)\n{\n\tstruct flow_dissector_key_control *key_control;\n\tstruct flow_dissector_key_basic *key_basic;\n\tstruct flow_dissector_key_addrs *key_addrs;\n\tstruct flow_dissector_key_ports *key_ports;\n\tstruct flow_dissector_key_tags *key_tags;\n\tstruct flow_dissector_key_keyid *key_keyid;\n\tu8 ip_proto = 0;\n\n\tif (!data) {\n\t\tdata = skb->data;\n\t\tproto = skb->protocol;\n\t\tnhoff = skb_network_offset(skb);\n\t\thlen = skb_headlen(skb);\n\t}\n\n\t/* It is ensured by skb_flow_dissector_init() that control key will\n\t * be always present.\n\t */\n\tkey_control = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_CONTROL,\n\t\t\t\t\t\ttarget_container);\n\n\t/* It is ensured by skb_flow_dissector_init() that basic key will\n\t * be always present.\n\t */\n\tkey_basic = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t      FLOW_DISSECTOR_KEY_BASIC,\n\t\t\t\t\t      target_container);\n\n\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\tFLOW_DISSECTOR_KEY_ETH_ADDRS)) {\n\t\tstruct ethhdr *eth = eth_hdr(skb);\n\t\tstruct flow_dissector_key_eth_addrs *key_eth_addrs;\n\n\t\tkey_eth_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t  FLOW_DISSECTOR_KEY_ETH_ADDRS,\n\t\t\t\t\t\t\t  target_container);\n\t\tmemcpy(key_eth_addrs, &eth->h_dest, sizeof(*key_eth_addrs));\n\t}\n\nagain:\n\tswitch (proto) {\n\tcase htons(ETH_P_IP): {\n\t\tconst struct iphdr *iph;\n\t\tstruct iphdr _iph;\nip:\n\t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n\t\tif (!iph || iph->ihl < 5)\n\t\t\treturn false;\n\t\tnhoff += iph->ihl * 4;\n\n\t\tip_proto = iph->protocol;\n\t\tif (ip_is_fragment(iph))\n\t\t\tip_proto = 0;\n\n\t\tif (!skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t FLOW_DISSECTOR_KEY_IPV4_ADDRS))\n\t\t\tbreak;\n\n\t\tkey_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t      FLOW_DISSECTOR_KEY_IPV4_ADDRS, target_container);\n\t\tmemcpy(&key_addrs->v4addrs, &iph->saddr,\n\t\t       sizeof(key_addrs->v4addrs));\n\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_IPV6): {\n\t\tconst struct ipv6hdr *iph;\n\t\tstruct ipv6hdr _iph;\n\t\t__be32 flow_label;\n\nipv6:\n\t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n\t\tif (!iph)\n\t\t\treturn false;\n\n\t\tip_proto = iph->nexthdr;\n\t\tnhoff += sizeof(struct ipv6hdr);\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_IPV6_ADDRS)) {\n\t\t\tstruct flow_dissector_key_ipv6_addrs *key_ipv6_addrs;\n\n\t\t\tkey_ipv6_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t   FLOW_DISSECTOR_KEY_IPV6_ADDRS,\n\t\t\t\t\t\t\t\t   target_container);\n\n\t\t\tmemcpy(key_ipv6_addrs, &iph->saddr, sizeof(*key_ipv6_addrs));\n\t\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\t}\n\n\t\tflow_label = ip6_flowlabel(iph);\n\t\tif (flow_label) {\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\tFLOW_DISSECTOR_KEY_FLOW_LABEL)) {\n\t\t\t\tkey_tags = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t     FLOW_DISSECTOR_KEY_FLOW_LABEL,\n\t\t\t\t\t\t\t\t     target_container);\n\t\t\t\tkey_tags->flow_label = ntohl(flow_label);\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_8021AD):\n\tcase htons(ETH_P_8021Q): {\n\t\tconst struct vlan_hdr *vlan;\n\t\tstruct vlan_hdr _vlan;\n\n\t\tvlan = __skb_header_pointer(skb, nhoff, sizeof(_vlan), data, hlen, &_vlan);\n\t\tif (!vlan)\n\t\t\treturn false;\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_VLANID)) {\n\t\t\tkey_tags = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t     FLOW_DISSECTOR_KEY_VLANID,\n\t\t\t\t\t\t\t     target_container);\n\n\t\t\tkey_tags->vlan_id = skb_vlan_tag_get_id(skb);\n\t\t}\n\n\t\tproto = vlan->h_vlan_encapsulated_proto;\n\t\tnhoff += sizeof(*vlan);\n\t\tgoto again;\n\t}\n\tcase htons(ETH_P_PPP_SES): {\n\t\tstruct {\n\t\t\tstruct pppoe_hdr hdr;\n\t\t\t__be16 proto;\n\t\t} *hdr, _hdr;\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\treturn false;\n\t\tproto = hdr->proto;\n\t\tnhoff += PPPOE_SES_HLEN;\n\t\tswitch (proto) {\n\t\tcase htons(PPP_IP):\n\t\t\tgoto ip;\n\t\tcase htons(PPP_IPV6):\n\t\t\tgoto ipv6;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\tcase htons(ETH_P_TIPC): {\n\t\tstruct {\n\t\t\t__be32 pre[3];\n\t\t\t__be32 srcnode;\n\t\t} *hdr, _hdr;\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\treturn false;\n\t\tkey_basic->n_proto = proto;\n\t\tkey_control->thoff = (u16)nhoff;\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_TIPC_ADDRS)) {\n\t\t\tkey_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_TIPC_ADDRS,\n\t\t\t\t\t\t\t      target_container);\n\t\t\tkey_addrs->tipcaddrs.srcnode = hdr->srcnode;\n\t\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS;\n\t\t}\n\t\treturn true;\n\t}\n\n\tcase htons(ETH_P_MPLS_UC):\n\tcase htons(ETH_P_MPLS_MC): {\n\t\tstruct mpls_label *hdr, _hdr[2];\nmpls:\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data,\n\t\t\t\t\t   hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\treturn false;\n\n\t\tif ((ntohl(hdr[0].entry) & MPLS_LS_LABEL_MASK) >>\n\t\t     MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY) {\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t\tFLOW_DISSECTOR_KEY_MPLS_ENTROPY)) {\n\t\t\t\tkey_keyid = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_MPLS_ENTROPY,\n\t\t\t\t\t\t\t\t      target_container);\n\t\t\t\tkey_keyid->keyid = hdr[1].entry &\n\t\t\t\t\thtonl(MPLS_LS_LABEL_MASK);\n\t\t\t}\n\n\t\t\tkey_basic->n_proto = proto;\n\t\t\tkey_basic->ip_proto = ip_proto;\n\t\t\tkey_control->thoff = (u16)nhoff;\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tcase htons(ETH_P_FCOE):\n\t\tkey_control->thoff = (u16)(nhoff + FCOE_HEADER_LEN);\n\t\t/* fall through */\n\tdefault:\n\t\treturn false;\n\t}\n\nip_proto_again:\n\tswitch (ip_proto) {\n\tcase IPPROTO_GRE: {\n\t\tstruct gre_hdr {\n\t\t\t__be16 flags;\n\t\t\t__be16 proto;\n\t\t} *hdr, _hdr;\n\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\treturn false;\n\t\t/*\n\t\t * Only look inside GRE if version zero and no\n\t\t * routing\n\t\t */\n\t\tif (hdr->flags & (GRE_VERSION | GRE_ROUTING))\n\t\t\tbreak;\n\n\t\tproto = hdr->proto;\n\t\tnhoff += 4;\n\t\tif (hdr->flags & GRE_CSUM)\n\t\t\tnhoff += 4;\n\t\tif (hdr->flags & GRE_KEY) {\n\t\t\tconst __be32 *keyid;\n\t\t\t__be32 _keyid;\n\n\t\t\tkeyid = __skb_header_pointer(skb, nhoff, sizeof(_keyid),\n\t\t\t\t\t\t     data, hlen, &_keyid);\n\n\t\t\tif (!keyid)\n\t\t\t\treturn false;\n\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t\tFLOW_DISSECTOR_KEY_GRE_KEYID)) {\n\t\t\t\tkey_keyid = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_GRE_KEYID,\n\t\t\t\t\t\t\t\t      target_container);\n\t\t\t\tkey_keyid->keyid = *keyid;\n\t\t\t}\n\t\t\tnhoff += 4;\n\t\t}\n\t\tif (hdr->flags & GRE_SEQ)\n\t\t\tnhoff += 4;\n\t\tif (proto == htons(ETH_P_TEB)) {\n\t\t\tconst struct ethhdr *eth;\n\t\t\tstruct ethhdr _eth;\n\n\t\t\teth = __skb_header_pointer(skb, nhoff,\n\t\t\t\t\t\t   sizeof(_eth),\n\t\t\t\t\t\t   data, hlen, &_eth);\n\t\t\tif (!eth)\n\t\t\t\treturn false;\n\t\t\tproto = eth->h_proto;\n\t\t\tnhoff += sizeof(*eth);\n\t\t}\n\t\tgoto again;\n\t}\n\tcase NEXTHDR_HOP:\n\tcase NEXTHDR_ROUTING:\n\tcase NEXTHDR_DEST: {\n\t\tu8 _opthdr[2], *opthdr;\n\n\t\tif (proto != htons(ETH_P_IPV6))\n\t\t\tbreak;\n\n\t\topthdr = __skb_header_pointer(skb, nhoff, sizeof(_opthdr),\n\t\t\t\t\t      data, hlen, &_opthdr);\n\t\tif (!opthdr)\n\t\t\treturn false;\n\n\t\tip_proto = opthdr[0];\n\t\tnhoff += (opthdr[1] + 1) << 3;\n\n\t\tgoto ip_proto_again;\n\t}\n\tcase IPPROTO_IPIP:\n\t\tproto = htons(ETH_P_IP);\n\t\tgoto ip;\n\tcase IPPROTO_IPV6:\n\t\tproto = htons(ETH_P_IPV6);\n\t\tgoto ipv6;\n\tcase IPPROTO_MPLS:\n\t\tproto = htons(ETH_P_MPLS_UC);\n\t\tgoto mpls;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tkey_basic->n_proto = proto;\n\tkey_basic->ip_proto = ip_proto;\n\tkey_control->thoff = (u16)nhoff;\n\n\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\tFLOW_DISSECTOR_KEY_PORTS)) {\n\t\tkey_ports = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_PORTS,\n\t\t\t\t\t\t      target_container);\n\t\tkey_ports->ports = __skb_flow_get_ports(skb, nhoff, ip_proto,\n\t\t\t\t\t\t\tdata, hlen);\n\t}\n\n\treturn true;\n}",
        "func": "bool __skb_flow_dissect(const struct sk_buff *skb,\n\t\t\tstruct flow_dissector *flow_dissector,\n\t\t\tvoid *target_container,\n\t\t\tvoid *data, __be16 proto, int nhoff, int hlen)\n{\n\tstruct flow_dissector_key_control *key_control;\n\tstruct flow_dissector_key_basic *key_basic;\n\tstruct flow_dissector_key_addrs *key_addrs;\n\tstruct flow_dissector_key_ports *key_ports;\n\tstruct flow_dissector_key_tags *key_tags;\n\tstruct flow_dissector_key_keyid *key_keyid;\n\tu8 ip_proto = 0;\n\tbool ret = false;\n\n\tif (!data) {\n\t\tdata = skb->data;\n\t\tproto = skb->protocol;\n\t\tnhoff = skb_network_offset(skb);\n\t\thlen = skb_headlen(skb);\n\t}\n\n\t/* It is ensured by skb_flow_dissector_init() that control key will\n\t * be always present.\n\t */\n\tkey_control = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_CONTROL,\n\t\t\t\t\t\ttarget_container);\n\n\t/* It is ensured by skb_flow_dissector_init() that basic key will\n\t * be always present.\n\t */\n\tkey_basic = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t      FLOW_DISSECTOR_KEY_BASIC,\n\t\t\t\t\t      target_container);\n\n\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\tFLOW_DISSECTOR_KEY_ETH_ADDRS)) {\n\t\tstruct ethhdr *eth = eth_hdr(skb);\n\t\tstruct flow_dissector_key_eth_addrs *key_eth_addrs;\n\n\t\tkey_eth_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t  FLOW_DISSECTOR_KEY_ETH_ADDRS,\n\t\t\t\t\t\t\t  target_container);\n\t\tmemcpy(key_eth_addrs, &eth->h_dest, sizeof(*key_eth_addrs));\n\t}\n\nagain:\n\tswitch (proto) {\n\tcase htons(ETH_P_IP): {\n\t\tconst struct iphdr *iph;\n\t\tstruct iphdr _iph;\nip:\n\t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n\t\tif (!iph || iph->ihl < 5)\n\t\t\tgoto out_bad;\n\t\tnhoff += iph->ihl * 4;\n\n\t\tip_proto = iph->protocol;\n\t\tif (ip_is_fragment(iph))\n\t\t\tip_proto = 0;\n\n\t\tif (!skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t FLOW_DISSECTOR_KEY_IPV4_ADDRS))\n\t\t\tbreak;\n\n\t\tkey_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t      FLOW_DISSECTOR_KEY_IPV4_ADDRS, target_container);\n\t\tmemcpy(&key_addrs->v4addrs, &iph->saddr,\n\t\t       sizeof(key_addrs->v4addrs));\n\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_IPV6): {\n\t\tconst struct ipv6hdr *iph;\n\t\tstruct ipv6hdr _iph;\n\t\t__be32 flow_label;\n\nipv6:\n\t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n\t\tif (!iph)\n\t\t\tgoto out_bad;\n\n\t\tip_proto = iph->nexthdr;\n\t\tnhoff += sizeof(struct ipv6hdr);\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_IPV6_ADDRS)) {\n\t\t\tstruct flow_dissector_key_ipv6_addrs *key_ipv6_addrs;\n\n\t\t\tkey_ipv6_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t   FLOW_DISSECTOR_KEY_IPV6_ADDRS,\n\t\t\t\t\t\t\t\t   target_container);\n\n\t\t\tmemcpy(key_ipv6_addrs, &iph->saddr, sizeof(*key_ipv6_addrs));\n\t\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_IPV6_ADDRS;\n\t\t}\n\n\t\tflow_label = ip6_flowlabel(iph);\n\t\tif (flow_label) {\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\tFLOW_DISSECTOR_KEY_FLOW_LABEL)) {\n\t\t\t\tkey_tags = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t     FLOW_DISSECTOR_KEY_FLOW_LABEL,\n\t\t\t\t\t\t\t\t     target_container);\n\t\t\t\tkey_tags->flow_label = ntohl(flow_label);\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_8021AD):\n\tcase htons(ETH_P_8021Q): {\n\t\tconst struct vlan_hdr *vlan;\n\t\tstruct vlan_hdr _vlan;\n\n\t\tvlan = __skb_header_pointer(skb, nhoff, sizeof(_vlan), data, hlen, &_vlan);\n\t\tif (!vlan)\n\t\t\tgoto out_bad;\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_VLANID)) {\n\t\t\tkey_tags = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t     FLOW_DISSECTOR_KEY_VLANID,\n\t\t\t\t\t\t\t     target_container);\n\n\t\t\tkey_tags->vlan_id = skb_vlan_tag_get_id(skb);\n\t\t}\n\n\t\tproto = vlan->h_vlan_encapsulated_proto;\n\t\tnhoff += sizeof(*vlan);\n\t\tgoto again;\n\t}\n\tcase htons(ETH_P_PPP_SES): {\n\t\tstruct {\n\t\t\tstruct pppoe_hdr hdr;\n\t\t\t__be16 proto;\n\t\t} *hdr, _hdr;\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\tgoto out_bad;\n\t\tproto = hdr->proto;\n\t\tnhoff += PPPOE_SES_HLEN;\n\t\tswitch (proto) {\n\t\tcase htons(PPP_IP):\n\t\t\tgoto ip;\n\t\tcase htons(PPP_IPV6):\n\t\t\tgoto ipv6;\n\t\tdefault:\n\t\t\tgoto out_bad;\n\t\t}\n\t}\n\tcase htons(ETH_P_TIPC): {\n\t\tstruct {\n\t\t\t__be32 pre[3];\n\t\t\t__be32 srcnode;\n\t\t} *hdr, _hdr;\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\tgoto out_bad;\n\n\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\tFLOW_DISSECTOR_KEY_TIPC_ADDRS)) {\n\t\t\tkey_addrs = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_TIPC_ADDRS,\n\t\t\t\t\t\t\t      target_container);\n\t\t\tkey_addrs->tipcaddrs.srcnode = hdr->srcnode;\n\t\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS;\n\t\t}\n\t\tgoto out_good;\n\t}\n\n\tcase htons(ETH_P_MPLS_UC):\n\tcase htons(ETH_P_MPLS_MC): {\n\t\tstruct mpls_label *hdr, _hdr[2];\nmpls:\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data,\n\t\t\t\t\t   hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\tgoto out_bad;\n\n\t\tif ((ntohl(hdr[0].entry) & MPLS_LS_LABEL_MASK) >>\n\t\t     MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY) {\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t\tFLOW_DISSECTOR_KEY_MPLS_ENTROPY)) {\n\t\t\t\tkey_keyid = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_MPLS_ENTROPY,\n\t\t\t\t\t\t\t\t      target_container);\n\t\t\t\tkey_keyid->keyid = hdr[1].entry &\n\t\t\t\t\thtonl(MPLS_LS_LABEL_MASK);\n\t\t\t}\n\n\t\t\tgoto out_good;\n\t\t}\n\n\t\tgoto out_good;\n\t}\n\n\tcase htons(ETH_P_FCOE):\n\t\tkey_control->thoff = (u16)(nhoff + FCOE_HEADER_LEN);\n\t\t/* fall through */\n\tdefault:\n\t\tgoto out_bad;\n\t}\n\nip_proto_again:\n\tswitch (ip_proto) {\n\tcase IPPROTO_GRE: {\n\t\tstruct gre_hdr {\n\t\t\t__be16 flags;\n\t\t\t__be16 proto;\n\t\t} *hdr, _hdr;\n\n\t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n\t\tif (!hdr)\n\t\t\tgoto out_bad;\n\t\t/*\n\t\t * Only look inside GRE if version zero and no\n\t\t * routing\n\t\t */\n\t\tif (hdr->flags & (GRE_VERSION | GRE_ROUTING))\n\t\t\tbreak;\n\n\t\tproto = hdr->proto;\n\t\tnhoff += 4;\n\t\tif (hdr->flags & GRE_CSUM)\n\t\t\tnhoff += 4;\n\t\tif (hdr->flags & GRE_KEY) {\n\t\t\tconst __be32 *keyid;\n\t\t\t__be32 _keyid;\n\n\t\t\tkeyid = __skb_header_pointer(skb, nhoff, sizeof(_keyid),\n\t\t\t\t\t\t     data, hlen, &_keyid);\n\n\t\t\tif (!keyid)\n\t\t\t\tgoto out_bad;\n\n\t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\t\t\tFLOW_DISSECTOR_KEY_GRE_KEYID)) {\n\t\t\t\tkey_keyid = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_GRE_KEYID,\n\t\t\t\t\t\t\t\t      target_container);\n\t\t\t\tkey_keyid->keyid = *keyid;\n\t\t\t}\n\t\t\tnhoff += 4;\n\t\t}\n\t\tif (hdr->flags & GRE_SEQ)\n\t\t\tnhoff += 4;\n\t\tif (proto == htons(ETH_P_TEB)) {\n\t\t\tconst struct ethhdr *eth;\n\t\t\tstruct ethhdr _eth;\n\n\t\t\teth = __skb_header_pointer(skb, nhoff,\n\t\t\t\t\t\t   sizeof(_eth),\n\t\t\t\t\t\t   data, hlen, &_eth);\n\t\t\tif (!eth)\n\t\t\t\tgoto out_bad;\n\t\t\tproto = eth->h_proto;\n\t\t\tnhoff += sizeof(*eth);\n\t\t}\n\t\tgoto again;\n\t}\n\tcase NEXTHDR_HOP:\n\tcase NEXTHDR_ROUTING:\n\tcase NEXTHDR_DEST: {\n\t\tu8 _opthdr[2], *opthdr;\n\n\t\tif (proto != htons(ETH_P_IPV6))\n\t\t\tbreak;\n\n\t\topthdr = __skb_header_pointer(skb, nhoff, sizeof(_opthdr),\n\t\t\t\t\t      data, hlen, &_opthdr);\n\t\tif (!opthdr)\n\t\t\tgoto out_bad;\n\n\t\tip_proto = opthdr[0];\n\t\tnhoff += (opthdr[1] + 1) << 3;\n\n\t\tgoto ip_proto_again;\n\t}\n\tcase IPPROTO_IPIP:\n\t\tproto = htons(ETH_P_IP);\n\t\tgoto ip;\n\tcase IPPROTO_IPV6:\n\t\tproto = htons(ETH_P_IPV6);\n\t\tgoto ipv6;\n\tcase IPPROTO_MPLS:\n\t\tproto = htons(ETH_P_MPLS_UC);\n\t\tgoto mpls;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (skb_flow_dissector_uses_key(flow_dissector,\n\t\t\t\t\tFLOW_DISSECTOR_KEY_PORTS)) {\n\t\tkey_ports = skb_flow_dissector_target(flow_dissector,\n\t\t\t\t\t\t      FLOW_DISSECTOR_KEY_PORTS,\n\t\t\t\t\t\t      target_container);\n\t\tkey_ports->ports = __skb_flow_get_ports(skb, nhoff, ip_proto,\n\t\t\t\t\t\t\tdata, hlen);\n\t}\n\nout_good:\n\tret = true;\n\nout_bad:\n\tkey_basic->n_proto = proto;\n\tkey_basic->ip_proto = ip_proto;\n\tkey_control->thoff = (u16)nhoff;\n\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,7 @@\n \tstruct flow_dissector_key_tags *key_tags;\n \tstruct flow_dissector_key_keyid *key_keyid;\n \tu8 ip_proto = 0;\n+\tbool ret = false;\n \n \tif (!data) {\n \t\tdata = skb->data;\n@@ -51,7 +52,7 @@\n ip:\n \t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n \t\tif (!iph || iph->ihl < 5)\n-\t\t\treturn false;\n+\t\t\tgoto out_bad;\n \t\tnhoff += iph->ihl * 4;\n \n \t\tip_proto = iph->protocol;\n@@ -77,7 +78,7 @@\n ipv6:\n \t\tiph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);\n \t\tif (!iph)\n-\t\t\treturn false;\n+\t\t\tgoto out_bad;\n \n \t\tip_proto = iph->nexthdr;\n \t\tnhoff += sizeof(struct ipv6hdr);\n@@ -114,7 +115,7 @@\n \n \t\tvlan = __skb_header_pointer(skb, nhoff, sizeof(_vlan), data, hlen, &_vlan);\n \t\tif (!vlan)\n-\t\t\treturn false;\n+\t\t\tgoto out_bad;\n \n \t\tif (skb_flow_dissector_uses_key(flow_dissector,\n \t\t\t\t\t\tFLOW_DISSECTOR_KEY_VLANID)) {\n@@ -136,7 +137,7 @@\n \t\t} *hdr, _hdr;\n \t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n \t\tif (!hdr)\n-\t\t\treturn false;\n+\t\t\tgoto out_bad;\n \t\tproto = hdr->proto;\n \t\tnhoff += PPPOE_SES_HLEN;\n \t\tswitch (proto) {\n@@ -145,7 +146,7 @@\n \t\tcase htons(PPP_IPV6):\n \t\t\tgoto ipv6;\n \t\tdefault:\n-\t\t\treturn false;\n+\t\t\tgoto out_bad;\n \t\t}\n \t}\n \tcase htons(ETH_P_TIPC): {\n@@ -155,9 +156,7 @@\n \t\t} *hdr, _hdr;\n \t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n \t\tif (!hdr)\n-\t\t\treturn false;\n-\t\tkey_basic->n_proto = proto;\n-\t\tkey_control->thoff = (u16)nhoff;\n+\t\t\tgoto out_bad;\n \n \t\tif (skb_flow_dissector_uses_key(flow_dissector,\n \t\t\t\t\t\tFLOW_DISSECTOR_KEY_TIPC_ADDRS)) {\n@@ -167,7 +166,7 @@\n \t\t\tkey_addrs->tipcaddrs.srcnode = hdr->srcnode;\n \t\t\tkey_control->addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS;\n \t\t}\n-\t\treturn true;\n+\t\tgoto out_good;\n \t}\n \n \tcase htons(ETH_P_MPLS_UC):\n@@ -177,7 +176,7 @@\n \t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data,\n \t\t\t\t\t   hlen, &_hdr);\n \t\tif (!hdr)\n-\t\t\treturn false;\n+\t\t\tgoto out_bad;\n \n \t\tif ((ntohl(hdr[0].entry) & MPLS_LS_LABEL_MASK) >>\n \t\t     MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY) {\n@@ -190,21 +189,17 @@\n \t\t\t\t\thtonl(MPLS_LS_LABEL_MASK);\n \t\t\t}\n \n-\t\t\tkey_basic->n_proto = proto;\n-\t\t\tkey_basic->ip_proto = ip_proto;\n-\t\t\tkey_control->thoff = (u16)nhoff;\n-\n-\t\t\treturn true;\n-\t\t}\n-\n-\t\treturn true;\n+\t\t\tgoto out_good;\n+\t\t}\n+\n+\t\tgoto out_good;\n \t}\n \n \tcase htons(ETH_P_FCOE):\n \t\tkey_control->thoff = (u16)(nhoff + FCOE_HEADER_LEN);\n \t\t/* fall through */\n \tdefault:\n-\t\treturn false;\n+\t\tgoto out_bad;\n \t}\n \n ip_proto_again:\n@@ -217,7 +212,7 @@\n \n \t\thdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);\n \t\tif (!hdr)\n-\t\t\treturn false;\n+\t\t\tgoto out_bad;\n \t\t/*\n \t\t * Only look inside GRE if version zero and no\n \t\t * routing\n@@ -237,7 +232,7 @@\n \t\t\t\t\t\t     data, hlen, &_keyid);\n \n \t\t\tif (!keyid)\n-\t\t\t\treturn false;\n+\t\t\t\tgoto out_bad;\n \n \t\t\tif (skb_flow_dissector_uses_key(flow_dissector,\n \t\t\t\t\t\t\tFLOW_DISSECTOR_KEY_GRE_KEYID)) {\n@@ -258,7 +253,7 @@\n \t\t\t\t\t\t   sizeof(_eth),\n \t\t\t\t\t\t   data, hlen, &_eth);\n \t\t\tif (!eth)\n-\t\t\t\treturn false;\n+\t\t\t\tgoto out_bad;\n \t\t\tproto = eth->h_proto;\n \t\t\tnhoff += sizeof(*eth);\n \t\t}\n@@ -275,7 +270,7 @@\n \t\topthdr = __skb_header_pointer(skb, nhoff, sizeof(_opthdr),\n \t\t\t\t\t      data, hlen, &_opthdr);\n \t\tif (!opthdr)\n-\t\t\treturn false;\n+\t\t\tgoto out_bad;\n \n \t\tip_proto = opthdr[0];\n \t\tnhoff += (opthdr[1] + 1) << 3;\n@@ -295,10 +290,6 @@\n \t\tbreak;\n \t}\n \n-\tkey_basic->n_proto = proto;\n-\tkey_basic->ip_proto = ip_proto;\n-\tkey_control->thoff = (u16)nhoff;\n-\n \tif (skb_flow_dissector_uses_key(flow_dissector,\n \t\t\t\t\tFLOW_DISSECTOR_KEY_PORTS)) {\n \t\tkey_ports = skb_flow_dissector_target(flow_dissector,\n@@ -308,5 +299,13 @@\n \t\t\t\t\t\t\tdata, hlen);\n \t}\n \n-\treturn true;\n+out_good:\n+\tret = true;\n+\n+out_bad:\n+\tkey_basic->n_proto = proto;\n+\tkey_basic->ip_proto = ip_proto;\n+\tkey_control->thoff = (u16)nhoff;\n+\n+\treturn ret;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\treturn false;",
                "\t\t\treturn false;",
                "\t\t\treturn false;",
                "\t\t\treturn false;",
                "\t\t\treturn false;",
                "\t\t\treturn false;",
                "\t\tkey_basic->n_proto = proto;",
                "\t\tkey_control->thoff = (u16)nhoff;",
                "\t\treturn true;",
                "\t\t\treturn false;",
                "\t\t\tkey_basic->n_proto = proto;",
                "\t\t\tkey_basic->ip_proto = ip_proto;",
                "\t\t\tkey_control->thoff = (u16)nhoff;",
                "",
                "\t\t\treturn true;",
                "\t\t}",
                "",
                "\t\treturn true;",
                "\t\treturn false;",
                "\t\t\treturn false;",
                "\t\t\t\treturn false;",
                "\t\t\t\treturn false;",
                "\t\t\treturn false;",
                "\tkey_basic->n_proto = proto;",
                "\tkey_basic->ip_proto = ip_proto;",
                "\tkey_control->thoff = (u16)nhoff;",
                "",
                "\treturn true;"
            ],
            "added_lines": [
                "\tbool ret = false;",
                "\t\t\tgoto out_bad;",
                "\t\t\tgoto out_bad;",
                "\t\t\tgoto out_bad;",
                "\t\t\tgoto out_bad;",
                "\t\t\tgoto out_bad;",
                "\t\t\tgoto out_bad;",
                "\t\tgoto out_good;",
                "\t\t\tgoto out_bad;",
                "\t\t\tgoto out_good;",
                "\t\t}",
                "",
                "\t\tgoto out_good;",
                "\t\tgoto out_bad;",
                "\t\t\tgoto out_bad;",
                "\t\t\t\tgoto out_bad;",
                "\t\t\t\tgoto out_bad;",
                "\t\t\tgoto out_bad;",
                "out_good:",
                "\tret = true;",
                "",
                "out_bad:",
                "\tkey_basic->n_proto = proto;",
                "\tkey_basic->ip_proto = ip_proto;",
                "\tkey_control->thoff = (u16)nhoff;",
                "",
                "\treturn ret;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-46283",
        "func_name": "torvalds/linux/nf_tables_newset",
        "description": "nf_tables_newset in net/netfilter/nf_tables_api.c in the Linux kernel before 5.12.13 allows local users to cause a denial of service (NULL pointer dereference and general protection fault) because of the missing initialization for nft_set_elem_expr_alloc. A local user can set a netfilter table expression in their own namespace.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=ad9f151e560b016b6ad3280b48e42fa11e1a5440",
        "commit_title": "nft_set_elem_expr_alloc() needs an initialized set if expression sets on",
        "commit_text": "the NFT_EXPR_GC flag. Move set fields initialization before expression setup.  [4512935.019450] ================================================================== [4512935.019456] BUG: KASAN: null-ptr-deref in nft_set_elem_expr_alloc+0x84/0xd0 [nf_tables] [4512935.019487] Read of size 8 at addr 0000000000000070 by task nft/23532 [4512935.019494] CPU: 1 PID: 23532 Comm: nft Not tainted 5.12.0-rc4+ #48 [...] [4512935.019502] Call Trace: [4512935.019505]  dump_stack+0x89/0xb4 [4512935.019512]  ? nft_set_elem_expr_alloc+0x84/0xd0 [nf_tables] [4512935.019536]  ? nft_set_elem_expr_alloc+0x84/0xd0 [nf_tables] [4512935.019560]  kasan_report.cold.12+0x5f/0xd8 [4512935.019566]  ? nft_set_elem_expr_alloc+0x84/0xd0 [nf_tables] [4512935.019590]  nft_set_elem_expr_alloc+0x84/0xd0 [nf_tables] [4512935.019615]  nf_tables_newset+0xc7f/0x1460 [nf_tables]  ",
        "func_before": "static int nf_tables_newset(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t    const struct nlattr * const nla[])\n{\n\tconst struct nfgenmsg *nfmsg = nlmsg_data(info->nlh);\n\tu32 ktype, dtype, flags, policy, gc_int, objtype;\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tint family = nfmsg->nfgen_family;\n\tconst struct nft_set_ops *ops;\n\tstruct nft_expr *expr = NULL;\n\tstruct net *net = info->net;\n\tstruct nft_set_desc desc;\n\tstruct nft_table *table;\n\tunsigned char *udata;\n\tstruct nft_set *set;\n\tstruct nft_ctx ctx;\n\tsize_t alloc_size;\n\tu64 timeout;\n\tchar *name;\n\tint err, i;\n\tu16 udlen;\n\tu64 size;\n\n\tif (nla[NFTA_SET_TABLE] == NULL ||\n\t    nla[NFTA_SET_NAME] == NULL ||\n\t    nla[NFTA_SET_KEY_LEN] == NULL ||\n\t    nla[NFTA_SET_ID] == NULL)\n\t\treturn -EINVAL;\n\n\tmemset(&desc, 0, sizeof(desc));\n\n\tktype = NFT_DATA_VALUE;\n\tif (nla[NFTA_SET_KEY_TYPE] != NULL) {\n\t\tktype = ntohl(nla_get_be32(nla[NFTA_SET_KEY_TYPE]));\n\t\tif ((ktype & NFT_DATA_RESERVED_MASK) == NFT_DATA_RESERVED_MASK)\n\t\t\treturn -EINVAL;\n\t}\n\n\tdesc.klen = ntohl(nla_get_be32(nla[NFTA_SET_KEY_LEN]));\n\tif (desc.klen == 0 || desc.klen > NFT_DATA_VALUE_MAXLEN)\n\t\treturn -EINVAL;\n\n\tflags = 0;\n\tif (nla[NFTA_SET_FLAGS] != NULL) {\n\t\tflags = ntohl(nla_get_be32(nla[NFTA_SET_FLAGS]));\n\t\tif (flags & ~(NFT_SET_ANONYMOUS | NFT_SET_CONSTANT |\n\t\t\t      NFT_SET_INTERVAL | NFT_SET_TIMEOUT |\n\t\t\t      NFT_SET_MAP | NFT_SET_EVAL |\n\t\t\t      NFT_SET_OBJECT | NFT_SET_CONCAT | NFT_SET_EXPR))\n\t\t\treturn -EOPNOTSUPP;\n\t\t/* Only one of these operations is supported */\n\t\tif ((flags & (NFT_SET_MAP | NFT_SET_OBJECT)) ==\n\t\t\t     (NFT_SET_MAP | NFT_SET_OBJECT))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif ((flags & (NFT_SET_EVAL | NFT_SET_OBJECT)) ==\n\t\t\t     (NFT_SET_EVAL | NFT_SET_OBJECT))\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tdtype = 0;\n\tif (nla[NFTA_SET_DATA_TYPE] != NULL) {\n\t\tif (!(flags & NFT_SET_MAP))\n\t\t\treturn -EINVAL;\n\n\t\tdtype = ntohl(nla_get_be32(nla[NFTA_SET_DATA_TYPE]));\n\t\tif ((dtype & NFT_DATA_RESERVED_MASK) == NFT_DATA_RESERVED_MASK &&\n\t\t    dtype != NFT_DATA_VERDICT)\n\t\t\treturn -EINVAL;\n\n\t\tif (dtype != NFT_DATA_VERDICT) {\n\t\t\tif (nla[NFTA_SET_DATA_LEN] == NULL)\n\t\t\t\treturn -EINVAL;\n\t\t\tdesc.dlen = ntohl(nla_get_be32(nla[NFTA_SET_DATA_LEN]));\n\t\t\tif (desc.dlen == 0 || desc.dlen > NFT_DATA_VALUE_MAXLEN)\n\t\t\t\treturn -EINVAL;\n\t\t} else\n\t\t\tdesc.dlen = sizeof(struct nft_verdict);\n\t} else if (flags & NFT_SET_MAP)\n\t\treturn -EINVAL;\n\n\tif (nla[NFTA_SET_OBJ_TYPE] != NULL) {\n\t\tif (!(flags & NFT_SET_OBJECT))\n\t\t\treturn -EINVAL;\n\n\t\tobjtype = ntohl(nla_get_be32(nla[NFTA_SET_OBJ_TYPE]));\n\t\tif (objtype == NFT_OBJECT_UNSPEC ||\n\t\t    objtype > NFT_OBJECT_MAX)\n\t\t\treturn -EOPNOTSUPP;\n\t} else if (flags & NFT_SET_OBJECT)\n\t\treturn -EINVAL;\n\telse\n\t\tobjtype = NFT_OBJECT_UNSPEC;\n\n\ttimeout = 0;\n\tif (nla[NFTA_SET_TIMEOUT] != NULL) {\n\t\tif (!(flags & NFT_SET_TIMEOUT))\n\t\t\treturn -EINVAL;\n\n\t\terr = nf_msecs_to_jiffies64(nla[NFTA_SET_TIMEOUT], &timeout);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tgc_int = 0;\n\tif (nla[NFTA_SET_GC_INTERVAL] != NULL) {\n\t\tif (!(flags & NFT_SET_TIMEOUT))\n\t\t\treturn -EINVAL;\n\t\tgc_int = ntohl(nla_get_be32(nla[NFTA_SET_GC_INTERVAL]));\n\t}\n\n\tpolicy = NFT_SET_POL_PERFORMANCE;\n\tif (nla[NFTA_SET_POLICY] != NULL)\n\t\tpolicy = ntohl(nla_get_be32(nla[NFTA_SET_POLICY]));\n\n\tif (nla[NFTA_SET_DESC] != NULL) {\n\t\terr = nf_tables_set_desc_parse(&desc, nla[NFTA_SET_DESC]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (nla[NFTA_SET_EXPR] || nla[NFTA_SET_EXPRESSIONS])\n\t\tdesc.expr = true;\n\n\ttable = nft_table_lookup(net, nla[NFTA_SET_TABLE], family, genmask,\n\t\t\t\t NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_SET_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\tset = nft_set_lookup(table, nla[NFTA_SET_NAME], genmask);\n\tif (IS_ERR(set)) {\n\t\tif (PTR_ERR(set) != -ENOENT) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_SET_NAME]);\n\t\t\treturn PTR_ERR(set);\n\t\t}\n\t} else {\n\t\tif (info->nlh->nlmsg_flags & NLM_F_EXCL) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_SET_NAME]);\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\treturn 0;\n\t}\n\n\tif (!(info->nlh->nlmsg_flags & NLM_F_CREATE))\n\t\treturn -ENOENT;\n\n\tops = nft_select_set_ops(&ctx, nla, &desc, policy);\n\tif (IS_ERR(ops))\n\t\treturn PTR_ERR(ops);\n\n\tudlen = 0;\n\tif (nla[NFTA_SET_USERDATA])\n\t\tudlen = nla_len(nla[NFTA_SET_USERDATA]);\n\n\tsize = 0;\n\tif (ops->privsize != NULL)\n\t\tsize = ops->privsize(nla, &desc);\n\talloc_size = sizeof(*set) + size + udlen;\n\tif (alloc_size < size)\n\t\treturn -ENOMEM;\n\tset = kvzalloc(alloc_size, GFP_KERNEL);\n\tif (!set)\n\t\treturn -ENOMEM;\n\n\tname = nla_strdup(nla[NFTA_SET_NAME], GFP_KERNEL);\n\tif (!name) {\n\t\terr = -ENOMEM;\n\t\tgoto err_set_name;\n\t}\n\n\terr = nf_tables_set_alloc_name(&ctx, set, name);\n\tkfree(name);\n\tif (err < 0)\n\t\tgoto err_set_alloc_name;\n\n\tif (nla[NFTA_SET_EXPR]) {\n\t\texpr = nft_set_elem_expr_alloc(&ctx, set, nla[NFTA_SET_EXPR]);\n\t\tif (IS_ERR(expr)) {\n\t\t\terr = PTR_ERR(expr);\n\t\t\tgoto err_set_alloc_name;\n\t\t}\n\t\tset->exprs[0] = expr;\n\t\tset->num_exprs++;\n\t} else if (nla[NFTA_SET_EXPRESSIONS]) {\n\t\tstruct nft_expr *expr;\n\t\tstruct nlattr *tmp;\n\t\tint left;\n\n\t\tif (!(flags & NFT_SET_EXPR)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_set_alloc_name;\n\t\t}\n\t\ti = 0;\n\t\tnla_for_each_nested(tmp, nla[NFTA_SET_EXPRESSIONS], left) {\n\t\t\tif (i == NFT_SET_EXPR_MAX) {\n\t\t\t\terr = -E2BIG;\n\t\t\t\tgoto err_set_init;\n\t\t\t}\n\t\t\tif (nla_type(tmp) != NFTA_LIST_ELEM) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_set_init;\n\t\t\t}\n\t\t\texpr = nft_set_elem_expr_alloc(&ctx, set, tmp);\n\t\t\tif (IS_ERR(expr)) {\n\t\t\t\terr = PTR_ERR(expr);\n\t\t\t\tgoto err_set_init;\n\t\t\t}\n\t\t\tset->exprs[i++] = expr;\n\t\t\tset->num_exprs++;\n\t\t}\n\t}\n\n\tudata = NULL;\n\tif (udlen) {\n\t\tudata = set->data + size;\n\t\tnla_memcpy(udata, nla[NFTA_SET_USERDATA], udlen);\n\t}\n\n\tINIT_LIST_HEAD(&set->bindings);\n\tINIT_LIST_HEAD(&set->catchall_list);\n\tset->table = table;\n\twrite_pnet(&set->net, net);\n\tset->ops   = ops;\n\tset->ktype = ktype;\n\tset->klen  = desc.klen;\n\tset->dtype = dtype;\n\tset->objtype = objtype;\n\tset->dlen  = desc.dlen;\n\tset->flags = flags;\n\tset->size  = desc.size;\n\tset->policy = policy;\n\tset->udlen  = udlen;\n\tset->udata  = udata;\n\tset->timeout = timeout;\n\tset->gc_int = gc_int;\n\tset->handle = nf_tables_alloc_handle(table);\n\n\tset->field_count = desc.field_count;\n\tfor (i = 0; i < desc.field_count; i++)\n\t\tset->field_len[i] = desc.field_len[i];\n\n\terr = ops->init(set, &desc, nla);\n\tif (err < 0)\n\t\tgoto err_set_init;\n\n\terr = nft_trans_set_add(&ctx, NFT_MSG_NEWSET, set);\n\tif (err < 0)\n\t\tgoto err_set_trans;\n\n\tlist_add_tail_rcu(&set->list, &table->sets);\n\ttable->use++;\n\treturn 0;\n\nerr_set_trans:\n\tops->destroy(set);\nerr_set_init:\n\tfor (i = 0; i < set->num_exprs; i++)\n\t\tnft_expr_destroy(&ctx, set->exprs[i]);\nerr_set_alloc_name:\n\tkfree(set->name);\nerr_set_name:\n\tkvfree(set);\n\treturn err;\n}",
        "func": "static int nf_tables_newset(struct sk_buff *skb, const struct nfnl_info *info,\n\t\t\t    const struct nlattr * const nla[])\n{\n\tconst struct nfgenmsg *nfmsg = nlmsg_data(info->nlh);\n\tu32 ktype, dtype, flags, policy, gc_int, objtype;\n\tstruct netlink_ext_ack *extack = info->extack;\n\tu8 genmask = nft_genmask_next(info->net);\n\tint family = nfmsg->nfgen_family;\n\tconst struct nft_set_ops *ops;\n\tstruct nft_expr *expr = NULL;\n\tstruct net *net = info->net;\n\tstruct nft_set_desc desc;\n\tstruct nft_table *table;\n\tunsigned char *udata;\n\tstruct nft_set *set;\n\tstruct nft_ctx ctx;\n\tsize_t alloc_size;\n\tu64 timeout;\n\tchar *name;\n\tint err, i;\n\tu16 udlen;\n\tu64 size;\n\n\tif (nla[NFTA_SET_TABLE] == NULL ||\n\t    nla[NFTA_SET_NAME] == NULL ||\n\t    nla[NFTA_SET_KEY_LEN] == NULL ||\n\t    nla[NFTA_SET_ID] == NULL)\n\t\treturn -EINVAL;\n\n\tmemset(&desc, 0, sizeof(desc));\n\n\tktype = NFT_DATA_VALUE;\n\tif (nla[NFTA_SET_KEY_TYPE] != NULL) {\n\t\tktype = ntohl(nla_get_be32(nla[NFTA_SET_KEY_TYPE]));\n\t\tif ((ktype & NFT_DATA_RESERVED_MASK) == NFT_DATA_RESERVED_MASK)\n\t\t\treturn -EINVAL;\n\t}\n\n\tdesc.klen = ntohl(nla_get_be32(nla[NFTA_SET_KEY_LEN]));\n\tif (desc.klen == 0 || desc.klen > NFT_DATA_VALUE_MAXLEN)\n\t\treturn -EINVAL;\n\n\tflags = 0;\n\tif (nla[NFTA_SET_FLAGS] != NULL) {\n\t\tflags = ntohl(nla_get_be32(nla[NFTA_SET_FLAGS]));\n\t\tif (flags & ~(NFT_SET_ANONYMOUS | NFT_SET_CONSTANT |\n\t\t\t      NFT_SET_INTERVAL | NFT_SET_TIMEOUT |\n\t\t\t      NFT_SET_MAP | NFT_SET_EVAL |\n\t\t\t      NFT_SET_OBJECT | NFT_SET_CONCAT | NFT_SET_EXPR))\n\t\t\treturn -EOPNOTSUPP;\n\t\t/* Only one of these operations is supported */\n\t\tif ((flags & (NFT_SET_MAP | NFT_SET_OBJECT)) ==\n\t\t\t     (NFT_SET_MAP | NFT_SET_OBJECT))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif ((flags & (NFT_SET_EVAL | NFT_SET_OBJECT)) ==\n\t\t\t     (NFT_SET_EVAL | NFT_SET_OBJECT))\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tdtype = 0;\n\tif (nla[NFTA_SET_DATA_TYPE] != NULL) {\n\t\tif (!(flags & NFT_SET_MAP))\n\t\t\treturn -EINVAL;\n\n\t\tdtype = ntohl(nla_get_be32(nla[NFTA_SET_DATA_TYPE]));\n\t\tif ((dtype & NFT_DATA_RESERVED_MASK) == NFT_DATA_RESERVED_MASK &&\n\t\t    dtype != NFT_DATA_VERDICT)\n\t\t\treturn -EINVAL;\n\n\t\tif (dtype != NFT_DATA_VERDICT) {\n\t\t\tif (nla[NFTA_SET_DATA_LEN] == NULL)\n\t\t\t\treturn -EINVAL;\n\t\t\tdesc.dlen = ntohl(nla_get_be32(nla[NFTA_SET_DATA_LEN]));\n\t\t\tif (desc.dlen == 0 || desc.dlen > NFT_DATA_VALUE_MAXLEN)\n\t\t\t\treturn -EINVAL;\n\t\t} else\n\t\t\tdesc.dlen = sizeof(struct nft_verdict);\n\t} else if (flags & NFT_SET_MAP)\n\t\treturn -EINVAL;\n\n\tif (nla[NFTA_SET_OBJ_TYPE] != NULL) {\n\t\tif (!(flags & NFT_SET_OBJECT))\n\t\t\treturn -EINVAL;\n\n\t\tobjtype = ntohl(nla_get_be32(nla[NFTA_SET_OBJ_TYPE]));\n\t\tif (objtype == NFT_OBJECT_UNSPEC ||\n\t\t    objtype > NFT_OBJECT_MAX)\n\t\t\treturn -EOPNOTSUPP;\n\t} else if (flags & NFT_SET_OBJECT)\n\t\treturn -EINVAL;\n\telse\n\t\tobjtype = NFT_OBJECT_UNSPEC;\n\n\ttimeout = 0;\n\tif (nla[NFTA_SET_TIMEOUT] != NULL) {\n\t\tif (!(flags & NFT_SET_TIMEOUT))\n\t\t\treturn -EINVAL;\n\n\t\terr = nf_msecs_to_jiffies64(nla[NFTA_SET_TIMEOUT], &timeout);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tgc_int = 0;\n\tif (nla[NFTA_SET_GC_INTERVAL] != NULL) {\n\t\tif (!(flags & NFT_SET_TIMEOUT))\n\t\t\treturn -EINVAL;\n\t\tgc_int = ntohl(nla_get_be32(nla[NFTA_SET_GC_INTERVAL]));\n\t}\n\n\tpolicy = NFT_SET_POL_PERFORMANCE;\n\tif (nla[NFTA_SET_POLICY] != NULL)\n\t\tpolicy = ntohl(nla_get_be32(nla[NFTA_SET_POLICY]));\n\n\tif (nla[NFTA_SET_DESC] != NULL) {\n\t\terr = nf_tables_set_desc_parse(&desc, nla[NFTA_SET_DESC]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (nla[NFTA_SET_EXPR] || nla[NFTA_SET_EXPRESSIONS])\n\t\tdesc.expr = true;\n\n\ttable = nft_table_lookup(net, nla[NFTA_SET_TABLE], family, genmask,\n\t\t\t\t NETLINK_CB(skb).portid);\n\tif (IS_ERR(table)) {\n\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_SET_TABLE]);\n\t\treturn PTR_ERR(table);\n\t}\n\n\tnft_ctx_init(&ctx, net, skb, info->nlh, family, table, NULL, nla);\n\n\tset = nft_set_lookup(table, nla[NFTA_SET_NAME], genmask);\n\tif (IS_ERR(set)) {\n\t\tif (PTR_ERR(set) != -ENOENT) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_SET_NAME]);\n\t\t\treturn PTR_ERR(set);\n\t\t}\n\t} else {\n\t\tif (info->nlh->nlmsg_flags & NLM_F_EXCL) {\n\t\t\tNL_SET_BAD_ATTR(extack, nla[NFTA_SET_NAME]);\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (info->nlh->nlmsg_flags & NLM_F_REPLACE)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\treturn 0;\n\t}\n\n\tif (!(info->nlh->nlmsg_flags & NLM_F_CREATE))\n\t\treturn -ENOENT;\n\n\tops = nft_select_set_ops(&ctx, nla, &desc, policy);\n\tif (IS_ERR(ops))\n\t\treturn PTR_ERR(ops);\n\n\tudlen = 0;\n\tif (nla[NFTA_SET_USERDATA])\n\t\tudlen = nla_len(nla[NFTA_SET_USERDATA]);\n\n\tsize = 0;\n\tif (ops->privsize != NULL)\n\t\tsize = ops->privsize(nla, &desc);\n\talloc_size = sizeof(*set) + size + udlen;\n\tif (alloc_size < size)\n\t\treturn -ENOMEM;\n\tset = kvzalloc(alloc_size, GFP_KERNEL);\n\tif (!set)\n\t\treturn -ENOMEM;\n\n\tname = nla_strdup(nla[NFTA_SET_NAME], GFP_KERNEL);\n\tif (!name) {\n\t\terr = -ENOMEM;\n\t\tgoto err_set_name;\n\t}\n\n\terr = nf_tables_set_alloc_name(&ctx, set, name);\n\tkfree(name);\n\tif (err < 0)\n\t\tgoto err_set_name;\n\n\tudata = NULL;\n\tif (udlen) {\n\t\tudata = set->data + size;\n\t\tnla_memcpy(udata, nla[NFTA_SET_USERDATA], udlen);\n\t}\n\n\tINIT_LIST_HEAD(&set->bindings);\n\tINIT_LIST_HEAD(&set->catchall_list);\n\tset->table = table;\n\twrite_pnet(&set->net, net);\n\tset->ops = ops;\n\tset->ktype = ktype;\n\tset->klen = desc.klen;\n\tset->dtype = dtype;\n\tset->objtype = objtype;\n\tset->dlen = desc.dlen;\n\tset->flags = flags;\n\tset->size = desc.size;\n\tset->policy = policy;\n\tset->udlen = udlen;\n\tset->udata = udata;\n\tset->timeout = timeout;\n\tset->gc_int = gc_int;\n\n\tset->field_count = desc.field_count;\n\tfor (i = 0; i < desc.field_count; i++)\n\t\tset->field_len[i] = desc.field_len[i];\n\n\terr = ops->init(set, &desc, nla);\n\tif (err < 0)\n\t\tgoto err_set_init;\n\n\tif (nla[NFTA_SET_EXPR]) {\n\t\texpr = nft_set_elem_expr_alloc(&ctx, set, nla[NFTA_SET_EXPR]);\n\t\tif (IS_ERR(expr)) {\n\t\t\terr = PTR_ERR(expr);\n\t\t\tgoto err_set_expr_alloc;\n\t\t}\n\t\tset->exprs[0] = expr;\n\t\tset->num_exprs++;\n\t} else if (nla[NFTA_SET_EXPRESSIONS]) {\n\t\tstruct nft_expr *expr;\n\t\tstruct nlattr *tmp;\n\t\tint left;\n\n\t\tif (!(flags & NFT_SET_EXPR)) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_set_expr_alloc;\n\t\t}\n\t\ti = 0;\n\t\tnla_for_each_nested(tmp, nla[NFTA_SET_EXPRESSIONS], left) {\n\t\t\tif (i == NFT_SET_EXPR_MAX) {\n\t\t\t\terr = -E2BIG;\n\t\t\t\tgoto err_set_expr_alloc;\n\t\t\t}\n\t\t\tif (nla_type(tmp) != NFTA_LIST_ELEM) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_set_expr_alloc;\n\t\t\t}\n\t\t\texpr = nft_set_elem_expr_alloc(&ctx, set, tmp);\n\t\t\tif (IS_ERR(expr)) {\n\t\t\t\terr = PTR_ERR(expr);\n\t\t\t\tgoto err_set_expr_alloc;\n\t\t\t}\n\t\t\tset->exprs[i++] = expr;\n\t\t\tset->num_exprs++;\n\t\t}\n\t}\n\n\tset->handle = nf_tables_alloc_handle(table);\n\n\terr = nft_trans_set_add(&ctx, NFT_MSG_NEWSET, set);\n\tif (err < 0)\n\t\tgoto err_set_expr_alloc;\n\n\tlist_add_tail_rcu(&set->list, &table->sets);\n\ttable->use++;\n\treturn 0;\n\nerr_set_expr_alloc:\n\tfor (i = 0; i < set->num_exprs; i++)\n\t\tnft_expr_destroy(&ctx, set->exprs[i]);\n\n\tops->destroy(set);\nerr_set_init:\n\tkfree(set->name);\nerr_set_name:\n\tkvfree(set);\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -176,13 +176,45 @@\n \terr = nf_tables_set_alloc_name(&ctx, set, name);\n \tkfree(name);\n \tif (err < 0)\n-\t\tgoto err_set_alloc_name;\n+\t\tgoto err_set_name;\n+\n+\tudata = NULL;\n+\tif (udlen) {\n+\t\tudata = set->data + size;\n+\t\tnla_memcpy(udata, nla[NFTA_SET_USERDATA], udlen);\n+\t}\n+\n+\tINIT_LIST_HEAD(&set->bindings);\n+\tINIT_LIST_HEAD(&set->catchall_list);\n+\tset->table = table;\n+\twrite_pnet(&set->net, net);\n+\tset->ops = ops;\n+\tset->ktype = ktype;\n+\tset->klen = desc.klen;\n+\tset->dtype = dtype;\n+\tset->objtype = objtype;\n+\tset->dlen = desc.dlen;\n+\tset->flags = flags;\n+\tset->size = desc.size;\n+\tset->policy = policy;\n+\tset->udlen = udlen;\n+\tset->udata = udata;\n+\tset->timeout = timeout;\n+\tset->gc_int = gc_int;\n+\n+\tset->field_count = desc.field_count;\n+\tfor (i = 0; i < desc.field_count; i++)\n+\t\tset->field_len[i] = desc.field_len[i];\n+\n+\terr = ops->init(set, &desc, nla);\n+\tif (err < 0)\n+\t\tgoto err_set_init;\n \n \tif (nla[NFTA_SET_EXPR]) {\n \t\texpr = nft_set_elem_expr_alloc(&ctx, set, nla[NFTA_SET_EXPR]);\n \t\tif (IS_ERR(expr)) {\n \t\t\terr = PTR_ERR(expr);\n-\t\t\tgoto err_set_alloc_name;\n+\t\t\tgoto err_set_expr_alloc;\n \t\t}\n \t\tset->exprs[0] = expr;\n \t\tset->num_exprs++;\n@@ -193,75 +225,44 @@\n \n \t\tif (!(flags & NFT_SET_EXPR)) {\n \t\t\terr = -EINVAL;\n-\t\t\tgoto err_set_alloc_name;\n+\t\t\tgoto err_set_expr_alloc;\n \t\t}\n \t\ti = 0;\n \t\tnla_for_each_nested(tmp, nla[NFTA_SET_EXPRESSIONS], left) {\n \t\t\tif (i == NFT_SET_EXPR_MAX) {\n \t\t\t\terr = -E2BIG;\n-\t\t\t\tgoto err_set_init;\n+\t\t\t\tgoto err_set_expr_alloc;\n \t\t\t}\n \t\t\tif (nla_type(tmp) != NFTA_LIST_ELEM) {\n \t\t\t\terr = -EINVAL;\n-\t\t\t\tgoto err_set_init;\n+\t\t\t\tgoto err_set_expr_alloc;\n \t\t\t}\n \t\t\texpr = nft_set_elem_expr_alloc(&ctx, set, tmp);\n \t\t\tif (IS_ERR(expr)) {\n \t\t\t\terr = PTR_ERR(expr);\n-\t\t\t\tgoto err_set_init;\n+\t\t\t\tgoto err_set_expr_alloc;\n \t\t\t}\n \t\t\tset->exprs[i++] = expr;\n \t\t\tset->num_exprs++;\n \t\t}\n \t}\n \n-\tudata = NULL;\n-\tif (udlen) {\n-\t\tudata = set->data + size;\n-\t\tnla_memcpy(udata, nla[NFTA_SET_USERDATA], udlen);\n-\t}\n-\n-\tINIT_LIST_HEAD(&set->bindings);\n-\tINIT_LIST_HEAD(&set->catchall_list);\n-\tset->table = table;\n-\twrite_pnet(&set->net, net);\n-\tset->ops   = ops;\n-\tset->ktype = ktype;\n-\tset->klen  = desc.klen;\n-\tset->dtype = dtype;\n-\tset->objtype = objtype;\n-\tset->dlen  = desc.dlen;\n-\tset->flags = flags;\n-\tset->size  = desc.size;\n-\tset->policy = policy;\n-\tset->udlen  = udlen;\n-\tset->udata  = udata;\n-\tset->timeout = timeout;\n-\tset->gc_int = gc_int;\n \tset->handle = nf_tables_alloc_handle(table);\n-\n-\tset->field_count = desc.field_count;\n-\tfor (i = 0; i < desc.field_count; i++)\n-\t\tset->field_len[i] = desc.field_len[i];\n-\n-\terr = ops->init(set, &desc, nla);\n-\tif (err < 0)\n-\t\tgoto err_set_init;\n \n \terr = nft_trans_set_add(&ctx, NFT_MSG_NEWSET, set);\n \tif (err < 0)\n-\t\tgoto err_set_trans;\n+\t\tgoto err_set_expr_alloc;\n \n \tlist_add_tail_rcu(&set->list, &table->sets);\n \ttable->use++;\n \treturn 0;\n \n-err_set_trans:\n+err_set_expr_alloc:\n+\tfor (i = 0; i < set->num_exprs; i++)\n+\t\tnft_expr_destroy(&ctx, set->exprs[i]);\n+\n \tops->destroy(set);\n err_set_init:\n-\tfor (i = 0; i < set->num_exprs; i++)\n-\t\tnft_expr_destroy(&ctx, set->exprs[i]);\n-err_set_alloc_name:\n \tkfree(set->name);\n err_set_name:\n \tkvfree(set);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tgoto err_set_alloc_name;",
                "\t\t\tgoto err_set_alloc_name;",
                "\t\t\tgoto err_set_alloc_name;",
                "\t\t\t\tgoto err_set_init;",
                "\t\t\t\tgoto err_set_init;",
                "\t\t\t\tgoto err_set_init;",
                "\tudata = NULL;",
                "\tif (udlen) {",
                "\t\tudata = set->data + size;",
                "\t\tnla_memcpy(udata, nla[NFTA_SET_USERDATA], udlen);",
                "\t}",
                "",
                "\tINIT_LIST_HEAD(&set->bindings);",
                "\tINIT_LIST_HEAD(&set->catchall_list);",
                "\tset->table = table;",
                "\twrite_pnet(&set->net, net);",
                "\tset->ops   = ops;",
                "\tset->ktype = ktype;",
                "\tset->klen  = desc.klen;",
                "\tset->dtype = dtype;",
                "\tset->objtype = objtype;",
                "\tset->dlen  = desc.dlen;",
                "\tset->flags = flags;",
                "\tset->size  = desc.size;",
                "\tset->policy = policy;",
                "\tset->udlen  = udlen;",
                "\tset->udata  = udata;",
                "\tset->timeout = timeout;",
                "\tset->gc_int = gc_int;",
                "",
                "\tset->field_count = desc.field_count;",
                "\tfor (i = 0; i < desc.field_count; i++)",
                "\t\tset->field_len[i] = desc.field_len[i];",
                "",
                "\terr = ops->init(set, &desc, nla);",
                "\tif (err < 0)",
                "\t\tgoto err_set_init;",
                "\t\tgoto err_set_trans;",
                "err_set_trans:",
                "\tfor (i = 0; i < set->num_exprs; i++)",
                "\t\tnft_expr_destroy(&ctx, set->exprs[i]);",
                "err_set_alloc_name:"
            ],
            "added_lines": [
                "\t\tgoto err_set_name;",
                "",
                "\tudata = NULL;",
                "\tif (udlen) {",
                "\t\tudata = set->data + size;",
                "\t\tnla_memcpy(udata, nla[NFTA_SET_USERDATA], udlen);",
                "\t}",
                "",
                "\tINIT_LIST_HEAD(&set->bindings);",
                "\tINIT_LIST_HEAD(&set->catchall_list);",
                "\tset->table = table;",
                "\twrite_pnet(&set->net, net);",
                "\tset->ops = ops;",
                "\tset->ktype = ktype;",
                "\tset->klen = desc.klen;",
                "\tset->dtype = dtype;",
                "\tset->objtype = objtype;",
                "\tset->dlen = desc.dlen;",
                "\tset->flags = flags;",
                "\tset->size = desc.size;",
                "\tset->policy = policy;",
                "\tset->udlen = udlen;",
                "\tset->udata = udata;",
                "\tset->timeout = timeout;",
                "\tset->gc_int = gc_int;",
                "",
                "\tset->field_count = desc.field_count;",
                "\tfor (i = 0; i < desc.field_count; i++)",
                "\t\tset->field_len[i] = desc.field_len[i];",
                "",
                "\terr = ops->init(set, &desc, nla);",
                "\tif (err < 0)",
                "\t\tgoto err_set_init;",
                "\t\t\tgoto err_set_expr_alloc;",
                "\t\t\tgoto err_set_expr_alloc;",
                "\t\t\t\tgoto err_set_expr_alloc;",
                "\t\t\t\tgoto err_set_expr_alloc;",
                "\t\t\t\tgoto err_set_expr_alloc;",
                "\t\tgoto err_set_expr_alloc;",
                "err_set_expr_alloc:",
                "\tfor (i = 0; i < set->num_exprs; i++)",
                "\t\tnft_expr_destroy(&ctx, set->exprs[i]);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-52452",
        "func_name": "torvalds/linux/check_stack_write_fixed_off",
        "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix accesses to uninit stack slots\n\nPrivileged programs are supposed to be able to read uninitialized stack\nmemory (ever since 6715df8d5) but, before this patch, these accesses\nwere permitted inconsistently. In particular, accesses were permitted\nabove state->allocated_stack, but not below it. In other words, if the\nstack was already \"large enough\", the access was permitted, but\notherwise the access was rejected instead of being allowed to \"grow the\nstack\". This undesired rejection was happening in two places:\n- in check_stack_slot_within_bounds()\n- in check_stack_range_initialized()\nThis patch arranges for these accesses to be permitted. A bunch of tests\nthat were relying on the old rejection had to change; all of them were\nchanged to add also run unprivileged, in which case the old behavior\npersists. One tests couldn't be updated - global_func16 - because it\ncan't run unprivileged for other reasons.\n\nThis patch also fixes the tracking of the stack size for variable-offset\nreads. This second fix is bundled in the same commit as the first one\nbecause they're inter-related. Before this patch, writes to the stack\nusing registers containing a variable offset (as opposed to registers\nwith fixed, known values) were not properly contributing to the\nfunction's needed stack size. As a result, it was possible for a program\nto verify, but then to attempt to read out-of-bounds data at runtime\nbecause a too small stack had been allocated for it.\n\nEach function tracks the size of the stack it needs in\nbpf_subprog_info.stack_depth, which is maintained by\nupdate_stack_depth(). For regular memory accesses, check_mem_access()\nwas calling update_state_depth() but it was passing in only the fixed\npart of the offset register, ignoring the variable offset. This was\nincorrect; the minimum possible value of that register should be used\ninstead.\n\nThis tracking is now fixed by centralizing the tracking of stack size in\ngrow_stack_state(), and by lifting the calls to grow_stack_state() to\ncheck_stack_access_within_bounds() as suggested by Andrii. The code is\nnow simpler and more convincingly tracks the correct maximum stack size.\ncheck_stack_range_initialized() can now rely on enough stack having been\nallocated for the access; this helps with the fix for the first issue.\n\nA few tests were changed to also check the stack depth computation. The\none that fails without this patch is verifier_var_off:stack_write_priv_vs_unpriv.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=6b4a64bafd107e521c01eec3453ce94a3fb38529",
        "commit_title": "Privileged programs are supposed to be able to read uninitialized stack",
        "commit_text": "memory (ever since 6715df8d5) but, before this patch, these accesses were permitted inconsistently. In particular, accesses were permitted above state->allocated_stack, but not below it. In other words, if the stack was already \"large enough\", the access was permitted, but otherwise the access was rejected instead of being allowed to \"grow the stack\". This undesired rejection was happening in two places: - in check_stack_slot_within_bounds() - in check_stack_range_initialized() This patch arranges for these accesses to be permitted. A bunch of tests that were relying on the old rejection had to change; all of them were changed to add also run unprivileged, in which case the old behavior persists. One tests couldn't be updated - global_func16 - because it can't run unprivileged for other reasons.  This patch also fixes the tracking of the stack size for variable-offset reads. This second fix is bundled in the same commit as the first one because they're inter-related. Before this patch, writes to the stack using registers containing a variable offset (as opposed to registers with fixed, known values) were not properly contributing to the function's needed stack size. As a result, it was possible for a program to verify, but then to attempt to read out-of-bounds data at runtime because a too small stack had been allocated for it.  Each function tracks the size of the stack it needs in bpf_subprog_info.stack_depth, which is maintained by update_stack_depth(). For regular memory accesses, check_mem_access() was calling update_state_depth() but it was passing in only the fixed part of the offset register, ignoring the variable offset. This was incorrect; the minimum possible value of that register should be used instead.  This tracking is now fixed by centralizing the tracking of stack size in grow_stack_state(), and by lifting the calls to grow_stack_state() to check_stack_access_within_bounds() as suggested by Andrii. The code is now simpler and more convincingly tracks the correct maximum stack size. check_stack_range_initialized() can now rely on enough stack having been allocated for the access; this helps with the fix for the first issue.  A few tests were changed to also check the stack depth computation. The one that fails without this patch is verifier_var_off:stack_write_priv_vs_unpriv.  Link: https://lore.kernel.org/bpf/20231208032519.260451-3-andreimatei1@gmail.com  Closes: https://lore.kernel.org/bpf/CABWLsev9g8UP_c3a=1qbuZUi20tGoUXoU07FPf-5FLvhOKOY+Q@mail.gmail.com/ ",
        "func_before": "static int check_stack_write_fixed_off(struct bpf_verifier_env *env,\n\t\t\t\t       /* stack frame we're writing to */\n\t\t\t\t       struct bpf_func_state *state,\n\t\t\t\t       int off, int size, int value_regno,\n\t\t\t\t       int insn_idx)\n{\n\tstruct bpf_func_state *cur; /* state of the current function */\n\tint i, slot = -off - 1, spi = slot / BPF_REG_SIZE, err;\n\tstruct bpf_insn *insn = &env->prog->insnsi[insn_idx];\n\tstruct bpf_reg_state *reg = NULL;\n\tint insn_flags = insn_stack_access_flags(state->frameno, spi);\n\n\terr = grow_stack_state(state, round_up(slot + 1, BPF_REG_SIZE));\n\tif (err)\n\t\treturn err;\n\t/* caller checked that off % size == 0 and -MAX_BPF_STACK <= off < 0,\n\t * so it's aligned access and [off, off + size) are within stack limits\n\t */\n\tif (!env->allow_ptr_leaks &&\n\t    is_spilled_reg(&state->stack[spi]) &&\n\t    size != BPF_REG_SIZE) {\n\t\tverbose(env, \"attempt to corrupt spilled pointer on stack\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tcur = env->cur_state->frame[env->cur_state->curframe];\n\tif (value_regno >= 0)\n\t\treg = &cur->regs[value_regno];\n\tif (!env->bypass_spec_v4) {\n\t\tbool sanitize = reg && is_spillable_regtype(reg->type);\n\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tu8 type = state->stack[spi].slot_type[i];\n\n\t\t\tif (type != STACK_MISC && type != STACK_ZERO) {\n\t\t\t\tsanitize = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (sanitize)\n\t\t\tenv->insn_aux_data[insn_idx].sanitize_stack_spill = true;\n\t}\n\n\terr = destroy_if_dynptr_stack_slot(env, state, spi);\n\tif (err)\n\t\treturn err;\n\n\tmark_stack_slot_scratched(env, spi);\n\tif (reg && !(off % BPF_REG_SIZE) && register_is_bounded(reg) && env->bpf_capable) {\n\t\tsave_register_state(env, state, spi, reg, size);\n\t\t/* Break the relation on a narrowing spill. */\n\t\tif (fls64(reg->umax_value) > BITS_PER_BYTE * size)\n\t\t\tstate->stack[spi].spilled_ptr.id = 0;\n\t} else if (!reg && !(off % BPF_REG_SIZE) && is_bpf_st_mem(insn) &&\n\t\t   insn->imm != 0 && env->bpf_capable) {\n\t\tstruct bpf_reg_state fake_reg = {};\n\n\t\t__mark_reg_known(&fake_reg, insn->imm);\n\t\tfake_reg.type = SCALAR_VALUE;\n\t\tsave_register_state(env, state, spi, &fake_reg, size);\n\t\tinsn_flags = 0; /* not a register spill */\n\t} else if (reg && is_spillable_regtype(reg->type)) {\n\t\t/* register containing pointer is being spilled into stack */\n\t\tif (size != BPF_REG_SIZE) {\n\t\t\tverbose_linfo(env, insn_idx, \"; \");\n\t\t\tverbose(env, \"invalid size of register spill\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (state != cur && reg->type == PTR_TO_STACK) {\n\t\t\tverbose(env, \"cannot spill pointers to stack into stack frame of the caller\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsave_register_state(env, state, spi, reg, size);\n\t} else {\n\t\tu8 type = STACK_MISC;\n\n\t\t/* regular write of data into stack destroys any spilled ptr */\n\t\tstate->stack[spi].spilled_ptr.type = NOT_INIT;\n\t\t/* Mark slots as STACK_MISC if they belonged to spilled ptr/dynptr/iter. */\n\t\tif (is_stack_slot_special(&state->stack[spi]))\n\t\t\tfor (i = 0; i < BPF_REG_SIZE; i++)\n\t\t\t\tscrub_spilled_slot(&state->stack[spi].slot_type[i]);\n\n\t\t/* only mark the slot as written if all 8 bytes were written\n\t\t * otherwise read propagation may incorrectly stop too soon\n\t\t * when stack slots are partially written.\n\t\t * This heuristic means that read propagation will be\n\t\t * conservative, since it will add reg_live_read marks\n\t\t * to stack slots all the way to first state when programs\n\t\t * writes+reads less than 8 bytes\n\t\t */\n\t\tif (size == BPF_REG_SIZE)\n\t\t\tstate->stack[spi].spilled_ptr.live |= REG_LIVE_WRITTEN;\n\n\t\t/* when we zero initialize stack slots mark them as such */\n\t\tif ((reg && register_is_null(reg)) ||\n\t\t    (!reg && is_bpf_st_mem(insn) && insn->imm == 0)) {\n\t\t\t/* STACK_ZERO case happened because register spill\n\t\t\t * wasn't properly aligned at the stack slot boundary,\n\t\t\t * so it's not a register spill anymore; force\n\t\t\t * originating register to be precise to make\n\t\t\t * STACK_ZERO correct for subsequent states\n\t\t\t */\n\t\t\terr = mark_chain_precision(env, value_regno);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\ttype = STACK_ZERO;\n\t\t}\n\n\t\t/* Mark slots affected by this stack write. */\n\t\tfor (i = 0; i < size; i++)\n\t\t\tstate->stack[spi].slot_type[(slot - i) % BPF_REG_SIZE] = type;\n\t\tinsn_flags = 0; /* not a register spill */\n\t}\n\n\tif (insn_flags)\n\t\treturn push_jmp_history(env, env->cur_state, insn_flags);\n\treturn 0;\n}",
        "func": "static int check_stack_write_fixed_off(struct bpf_verifier_env *env,\n\t\t\t\t       /* stack frame we're writing to */\n\t\t\t\t       struct bpf_func_state *state,\n\t\t\t\t       int off, int size, int value_regno,\n\t\t\t\t       int insn_idx)\n{\n\tstruct bpf_func_state *cur; /* state of the current function */\n\tint i, slot = -off - 1, spi = slot / BPF_REG_SIZE, err;\n\tstruct bpf_insn *insn = &env->prog->insnsi[insn_idx];\n\tstruct bpf_reg_state *reg = NULL;\n\tint insn_flags = insn_stack_access_flags(state->frameno, spi);\n\n\t/* caller checked that off % size == 0 and -MAX_BPF_STACK <= off < 0,\n\t * so it's aligned access and [off, off + size) are within stack limits\n\t */\n\tif (!env->allow_ptr_leaks &&\n\t    is_spilled_reg(&state->stack[spi]) &&\n\t    size != BPF_REG_SIZE) {\n\t\tverbose(env, \"attempt to corrupt spilled pointer on stack\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tcur = env->cur_state->frame[env->cur_state->curframe];\n\tif (value_regno >= 0)\n\t\treg = &cur->regs[value_regno];\n\tif (!env->bypass_spec_v4) {\n\t\tbool sanitize = reg && is_spillable_regtype(reg->type);\n\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tu8 type = state->stack[spi].slot_type[i];\n\n\t\t\tif (type != STACK_MISC && type != STACK_ZERO) {\n\t\t\t\tsanitize = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (sanitize)\n\t\t\tenv->insn_aux_data[insn_idx].sanitize_stack_spill = true;\n\t}\n\n\terr = destroy_if_dynptr_stack_slot(env, state, spi);\n\tif (err)\n\t\treturn err;\n\n\tmark_stack_slot_scratched(env, spi);\n\tif (reg && !(off % BPF_REG_SIZE) && register_is_bounded(reg) && env->bpf_capable) {\n\t\tsave_register_state(env, state, spi, reg, size);\n\t\t/* Break the relation on a narrowing spill. */\n\t\tif (fls64(reg->umax_value) > BITS_PER_BYTE * size)\n\t\t\tstate->stack[spi].spilled_ptr.id = 0;\n\t} else if (!reg && !(off % BPF_REG_SIZE) && is_bpf_st_mem(insn) &&\n\t\t   insn->imm != 0 && env->bpf_capable) {\n\t\tstruct bpf_reg_state fake_reg = {};\n\n\t\t__mark_reg_known(&fake_reg, insn->imm);\n\t\tfake_reg.type = SCALAR_VALUE;\n\t\tsave_register_state(env, state, spi, &fake_reg, size);\n\t\tinsn_flags = 0; /* not a register spill */\n\t} else if (reg && is_spillable_regtype(reg->type)) {\n\t\t/* register containing pointer is being spilled into stack */\n\t\tif (size != BPF_REG_SIZE) {\n\t\t\tverbose_linfo(env, insn_idx, \"; \");\n\t\t\tverbose(env, \"invalid size of register spill\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (state != cur && reg->type == PTR_TO_STACK) {\n\t\t\tverbose(env, \"cannot spill pointers to stack into stack frame of the caller\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsave_register_state(env, state, spi, reg, size);\n\t} else {\n\t\tu8 type = STACK_MISC;\n\n\t\t/* regular write of data into stack destroys any spilled ptr */\n\t\tstate->stack[spi].spilled_ptr.type = NOT_INIT;\n\t\t/* Mark slots as STACK_MISC if they belonged to spilled ptr/dynptr/iter. */\n\t\tif (is_stack_slot_special(&state->stack[spi]))\n\t\t\tfor (i = 0; i < BPF_REG_SIZE; i++)\n\t\t\t\tscrub_spilled_slot(&state->stack[spi].slot_type[i]);\n\n\t\t/* only mark the slot as written if all 8 bytes were written\n\t\t * otherwise read propagation may incorrectly stop too soon\n\t\t * when stack slots are partially written.\n\t\t * This heuristic means that read propagation will be\n\t\t * conservative, since it will add reg_live_read marks\n\t\t * to stack slots all the way to first state when programs\n\t\t * writes+reads less than 8 bytes\n\t\t */\n\t\tif (size == BPF_REG_SIZE)\n\t\t\tstate->stack[spi].spilled_ptr.live |= REG_LIVE_WRITTEN;\n\n\t\t/* when we zero initialize stack slots mark them as such */\n\t\tif ((reg && register_is_null(reg)) ||\n\t\t    (!reg && is_bpf_st_mem(insn) && insn->imm == 0)) {\n\t\t\t/* STACK_ZERO case happened because register spill\n\t\t\t * wasn't properly aligned at the stack slot boundary,\n\t\t\t * so it's not a register spill anymore; force\n\t\t\t * originating register to be precise to make\n\t\t\t * STACK_ZERO correct for subsequent states\n\t\t\t */\n\t\t\terr = mark_chain_precision(env, value_regno);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\ttype = STACK_ZERO;\n\t\t}\n\n\t\t/* Mark slots affected by this stack write. */\n\t\tfor (i = 0; i < size; i++)\n\t\t\tstate->stack[spi].slot_type[(slot - i) % BPF_REG_SIZE] = type;\n\t\tinsn_flags = 0; /* not a register spill */\n\t}\n\n\tif (insn_flags)\n\t\treturn push_jmp_history(env, env->cur_state, insn_flags);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,9 +10,6 @@\n \tstruct bpf_reg_state *reg = NULL;\n \tint insn_flags = insn_stack_access_flags(state->frameno, spi);\n \n-\terr = grow_stack_state(state, round_up(slot + 1, BPF_REG_SIZE));\n-\tif (err)\n-\t\treturn err;\n \t/* caller checked that off % size == 0 and -MAX_BPF_STACK <= off < 0,\n \t * so it's aligned access and [off, off + size) are within stack limits\n \t */",
        "diff_line_info": {
            "deleted_lines": [
                "\terr = grow_stack_state(state, round_up(slot + 1, BPF_REG_SIZE));",
                "\tif (err)",
                "\t\treturn err;"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2023-52452",
        "func_name": "torvalds/linux/check_stack_access_within_bounds",
        "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix accesses to uninit stack slots\n\nPrivileged programs are supposed to be able to read uninitialized stack\nmemory (ever since 6715df8d5) but, before this patch, these accesses\nwere permitted inconsistently. In particular, accesses were permitted\nabove state->allocated_stack, but not below it. In other words, if the\nstack was already \"large enough\", the access was permitted, but\notherwise the access was rejected instead of being allowed to \"grow the\nstack\". This undesired rejection was happening in two places:\n- in check_stack_slot_within_bounds()\n- in check_stack_range_initialized()\nThis patch arranges for these accesses to be permitted. A bunch of tests\nthat were relying on the old rejection had to change; all of them were\nchanged to add also run unprivileged, in which case the old behavior\npersists. One tests couldn't be updated - global_func16 - because it\ncan't run unprivileged for other reasons.\n\nThis patch also fixes the tracking of the stack size for variable-offset\nreads. This second fix is bundled in the same commit as the first one\nbecause they're inter-related. Before this patch, writes to the stack\nusing registers containing a variable offset (as opposed to registers\nwith fixed, known values) were not properly contributing to the\nfunction's needed stack size. As a result, it was possible for a program\nto verify, but then to attempt to read out-of-bounds data at runtime\nbecause a too small stack had been allocated for it.\n\nEach function tracks the size of the stack it needs in\nbpf_subprog_info.stack_depth, which is maintained by\nupdate_stack_depth(). For regular memory accesses, check_mem_access()\nwas calling update_state_depth() but it was passing in only the fixed\npart of the offset register, ignoring the variable offset. This was\nincorrect; the minimum possible value of that register should be used\ninstead.\n\nThis tracking is now fixed by centralizing the tracking of stack size in\ngrow_stack_state(), and by lifting the calls to grow_stack_state() to\ncheck_stack_access_within_bounds() as suggested by Andrii. The code is\nnow simpler and more convincingly tracks the correct maximum stack size.\ncheck_stack_range_initialized() can now rely on enough stack having been\nallocated for the access; this helps with the fix for the first issue.\n\nA few tests were changed to also check the stack depth computation. The\none that fails without this patch is verifier_var_off:stack_write_priv_vs_unpriv.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=6b4a64bafd107e521c01eec3453ce94a3fb38529",
        "commit_title": "Privileged programs are supposed to be able to read uninitialized stack",
        "commit_text": "memory (ever since 6715df8d5) but, before this patch, these accesses were permitted inconsistently. In particular, accesses were permitted above state->allocated_stack, but not below it. In other words, if the stack was already \"large enough\", the access was permitted, but otherwise the access was rejected instead of being allowed to \"grow the stack\". This undesired rejection was happening in two places: - in check_stack_slot_within_bounds() - in check_stack_range_initialized() This patch arranges for these accesses to be permitted. A bunch of tests that were relying on the old rejection had to change; all of them were changed to add also run unprivileged, in which case the old behavior persists. One tests couldn't be updated - global_func16 - because it can't run unprivileged for other reasons.  This patch also fixes the tracking of the stack size for variable-offset reads. This second fix is bundled in the same commit as the first one because they're inter-related. Before this patch, writes to the stack using registers containing a variable offset (as opposed to registers with fixed, known values) were not properly contributing to the function's needed stack size. As a result, it was possible for a program to verify, but then to attempt to read out-of-bounds data at runtime because a too small stack had been allocated for it.  Each function tracks the size of the stack it needs in bpf_subprog_info.stack_depth, which is maintained by update_stack_depth(). For regular memory accesses, check_mem_access() was calling update_state_depth() but it was passing in only the fixed part of the offset register, ignoring the variable offset. This was incorrect; the minimum possible value of that register should be used instead.  This tracking is now fixed by centralizing the tracking of stack size in grow_stack_state(), and by lifting the calls to grow_stack_state() to check_stack_access_within_bounds() as suggested by Andrii. The code is now simpler and more convincingly tracks the correct maximum stack size. check_stack_range_initialized() can now rely on enough stack having been allocated for the access; this helps with the fix for the first issue.  A few tests were changed to also check the stack depth computation. The one that fails without this patch is verifier_var_off:stack_write_priv_vs_unpriv.  Link: https://lore.kernel.org/bpf/20231208032519.260451-3-andreimatei1@gmail.com  Closes: https://lore.kernel.org/bpf/CABWLsev9g8UP_c3a=1qbuZUi20tGoUXoU07FPf-5FLvhOKOY+Q@mail.gmail.com/ ",
        "func_before": "static int check_stack_access_within_bounds(\n\t\tstruct bpf_verifier_env *env,\n\t\tint regno, int off, int access_size,\n\t\tenum bpf_access_src src, enum bpf_access_type type)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tstruct bpf_reg_state *reg = regs + regno;\n\tstruct bpf_func_state *state = func(env, reg);\n\ts64 min_off, max_off;\n\tint err;\n\tchar *err_extra;\n\n\tif (src == ACCESS_HELPER)\n\t\t/* We don't know if helpers are reading or writing (or both). */\n\t\terr_extra = \" indirect access to\";\n\telse if (type == BPF_READ)\n\t\terr_extra = \" read from\";\n\telse\n\t\terr_extra = \" write to\";\n\n\tif (tnum_is_const(reg->var_off)) {\n\t\tmin_off = (s64)reg->var_off.value + off;\n\t\tmax_off = min_off + access_size;\n\t} else {\n\t\tif (reg->smax_value >= BPF_MAX_VAR_OFF ||\n\t\t    reg->smin_value <= -BPF_MAX_VAR_OFF) {\n\t\t\tverbose(env, \"invalid unbounded variable-offset%s stack R%d\\n\",\n\t\t\t\terr_extra, regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tmin_off = reg->smin_value + off;\n\t\tmax_off = reg->smax_value + off + access_size;\n\t}\n\n\terr = check_stack_slot_within_bounds(min_off, state, type);\n\tif (!err && max_off > 0)\n\t\terr = -EINVAL; /* out of stack access into non-negative offsets */\n\n\tif (err) {\n\t\tif (tnum_is_const(reg->var_off)) {\n\t\t\tverbose(env, \"invalid%s stack R%d off=%d size=%d\\n\",\n\t\t\t\terr_extra, regno, off, access_size);\n\t\t} else {\n\t\t\tchar tn_buf[48];\n\n\t\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\t\tverbose(env, \"invalid variable-offset%s stack R%d var_off=%s off=%d size=%d\\n\",\n\t\t\t\terr_extra, regno, tn_buf, off, access_size);\n\t\t}\n\t}\n\treturn err;\n}",
        "func": "static int check_stack_access_within_bounds(\n\t\tstruct bpf_verifier_env *env,\n\t\tint regno, int off, int access_size,\n\t\tenum bpf_access_src src, enum bpf_access_type type)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tstruct bpf_reg_state *reg = regs + regno;\n\tstruct bpf_func_state *state = func(env, reg);\n\ts64 min_off, max_off;\n\tint err;\n\tchar *err_extra;\n\n\tif (src == ACCESS_HELPER)\n\t\t/* We don't know if helpers are reading or writing (or both). */\n\t\terr_extra = \" indirect access to\";\n\telse if (type == BPF_READ)\n\t\terr_extra = \" read from\";\n\telse\n\t\terr_extra = \" write to\";\n\n\tif (tnum_is_const(reg->var_off)) {\n\t\tmin_off = (s64)reg->var_off.value + off;\n\t\tmax_off = min_off + access_size;\n\t} else {\n\t\tif (reg->smax_value >= BPF_MAX_VAR_OFF ||\n\t\t    reg->smin_value <= -BPF_MAX_VAR_OFF) {\n\t\t\tverbose(env, \"invalid unbounded variable-offset%s stack R%d\\n\",\n\t\t\t\terr_extra, regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tmin_off = reg->smin_value + off;\n\t\tmax_off = reg->smax_value + off + access_size;\n\t}\n\n\terr = check_stack_slot_within_bounds(env, min_off, state, type);\n\tif (!err && max_off > 0)\n\t\terr = -EINVAL; /* out of stack access into non-negative offsets */\n\n\tif (err) {\n\t\tif (tnum_is_const(reg->var_off)) {\n\t\t\tverbose(env, \"invalid%s stack R%d off=%d size=%d\\n\",\n\t\t\t\terr_extra, regno, off, access_size);\n\t\t} else {\n\t\t\tchar tn_buf[48];\n\n\t\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\t\tverbose(env, \"invalid variable-offset%s stack R%d var_off=%s off=%d size=%d\\n\",\n\t\t\t\terr_extra, regno, tn_buf, off, access_size);\n\t\t}\n\t\treturn err;\n\t}\n\n\treturn grow_stack_state(env, state, round_up(-min_off, BPF_REG_SIZE));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,7 +32,7 @@\n \t\tmax_off = reg->smax_value + off + access_size;\n \t}\n \n-\terr = check_stack_slot_within_bounds(min_off, state, type);\n+\terr = check_stack_slot_within_bounds(env, min_off, state, type);\n \tif (!err && max_off > 0)\n \t\terr = -EINVAL; /* out of stack access into non-negative offsets */\n \n@@ -47,6 +47,8 @@\n \t\t\tverbose(env, \"invalid variable-offset%s stack R%d var_off=%s off=%d size=%d\\n\",\n \t\t\t\terr_extra, regno, tn_buf, off, access_size);\n \t\t}\n+\t\treturn err;\n \t}\n-\treturn err;\n+\n+\treturn grow_stack_state(env, state, round_up(-min_off, BPF_REG_SIZE));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\terr = check_stack_slot_within_bounds(min_off, state, type);",
                "\treturn err;"
            ],
            "added_lines": [
                "\terr = check_stack_slot_within_bounds(env, min_off, state, type);",
                "\t\treturn err;",
                "",
                "\treturn grow_stack_state(env, state, round_up(-min_off, BPF_REG_SIZE));"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-52452",
        "func_name": "torvalds/linux/grow_stack_state",
        "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix accesses to uninit stack slots\n\nPrivileged programs are supposed to be able to read uninitialized stack\nmemory (ever since 6715df8d5) but, before this patch, these accesses\nwere permitted inconsistently. In particular, accesses were permitted\nabove state->allocated_stack, but not below it. In other words, if the\nstack was already \"large enough\", the access was permitted, but\notherwise the access was rejected instead of being allowed to \"grow the\nstack\". This undesired rejection was happening in two places:\n- in check_stack_slot_within_bounds()\n- in check_stack_range_initialized()\nThis patch arranges for these accesses to be permitted. A bunch of tests\nthat were relying on the old rejection had to change; all of them were\nchanged to add also run unprivileged, in which case the old behavior\npersists. One tests couldn't be updated - global_func16 - because it\ncan't run unprivileged for other reasons.\n\nThis patch also fixes the tracking of the stack size for variable-offset\nreads. This second fix is bundled in the same commit as the first one\nbecause they're inter-related. Before this patch, writes to the stack\nusing registers containing a variable offset (as opposed to registers\nwith fixed, known values) were not properly contributing to the\nfunction's needed stack size. As a result, it was possible for a program\nto verify, but then to attempt to read out-of-bounds data at runtime\nbecause a too small stack had been allocated for it.\n\nEach function tracks the size of the stack it needs in\nbpf_subprog_info.stack_depth, which is maintained by\nupdate_stack_depth(). For regular memory accesses, check_mem_access()\nwas calling update_state_depth() but it was passing in only the fixed\npart of the offset register, ignoring the variable offset. This was\nincorrect; the minimum possible value of that register should be used\ninstead.\n\nThis tracking is now fixed by centralizing the tracking of stack size in\ngrow_stack_state(), and by lifting the calls to grow_stack_state() to\ncheck_stack_access_within_bounds() as suggested by Andrii. The code is\nnow simpler and more convincingly tracks the correct maximum stack size.\ncheck_stack_range_initialized() can now rely on enough stack having been\nallocated for the access; this helps with the fix for the first issue.\n\nA few tests were changed to also check the stack depth computation. The\none that fails without this patch is verifier_var_off:stack_write_priv_vs_unpriv.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=6b4a64bafd107e521c01eec3453ce94a3fb38529",
        "commit_title": "Privileged programs are supposed to be able to read uninitialized stack",
        "commit_text": "memory (ever since 6715df8d5) but, before this patch, these accesses were permitted inconsistently. In particular, accesses were permitted above state->allocated_stack, but not below it. In other words, if the stack was already \"large enough\", the access was permitted, but otherwise the access was rejected instead of being allowed to \"grow the stack\". This undesired rejection was happening in two places: - in check_stack_slot_within_bounds() - in check_stack_range_initialized() This patch arranges for these accesses to be permitted. A bunch of tests that were relying on the old rejection had to change; all of them were changed to add also run unprivileged, in which case the old behavior persists. One tests couldn't be updated - global_func16 - because it can't run unprivileged for other reasons.  This patch also fixes the tracking of the stack size for variable-offset reads. This second fix is bundled in the same commit as the first one because they're inter-related. Before this patch, writes to the stack using registers containing a variable offset (as opposed to registers with fixed, known values) were not properly contributing to the function's needed stack size. As a result, it was possible for a program to verify, but then to attempt to read out-of-bounds data at runtime because a too small stack had been allocated for it.  Each function tracks the size of the stack it needs in bpf_subprog_info.stack_depth, which is maintained by update_stack_depth(). For regular memory accesses, check_mem_access() was calling update_state_depth() but it was passing in only the fixed part of the offset register, ignoring the variable offset. This was incorrect; the minimum possible value of that register should be used instead.  This tracking is now fixed by centralizing the tracking of stack size in grow_stack_state(), and by lifting the calls to grow_stack_state() to check_stack_access_within_bounds() as suggested by Andrii. The code is now simpler and more convincingly tracks the correct maximum stack size. check_stack_range_initialized() can now rely on enough stack having been allocated for the access; this helps with the fix for the first issue.  A few tests were changed to also check the stack depth computation. The one that fails without this patch is verifier_var_off:stack_write_priv_vs_unpriv.  Link: https://lore.kernel.org/bpf/20231208032519.260451-3-andreimatei1@gmail.com  Closes: https://lore.kernel.org/bpf/CABWLsev9g8UP_c3a=1qbuZUi20tGoUXoU07FPf-5FLvhOKOY+Q@mail.gmail.com/ ",
        "func_before": "static int grow_stack_state(struct bpf_func_state *state, int size)\n{\n\tsize_t old_n = state->allocated_stack / BPF_REG_SIZE, n = size / BPF_REG_SIZE;\n\n\tif (old_n >= n)\n\t\treturn 0;\n\n\tstate->stack = realloc_array(state->stack, old_n, n, sizeof(struct bpf_stack_state));\n\tif (!state->stack)\n\t\treturn -ENOMEM;\n\n\tstate->allocated_stack = size;\n\treturn 0;\n}",
        "func": "static int grow_stack_state(struct bpf_verifier_env *env, struct bpf_func_state *state, int size)\n{\n\tsize_t old_n = state->allocated_stack / BPF_REG_SIZE, n = size / BPF_REG_SIZE;\n\n\tif (old_n >= n)\n\t\treturn 0;\n\n\tstate->stack = realloc_array(state->stack, old_n, n, sizeof(struct bpf_stack_state));\n\tif (!state->stack)\n\t\treturn -ENOMEM;\n\n\tstate->allocated_stack = size;\n\n\t/* update known max for given subprogram */\n\tif (env->subprog_info[state->subprogno].stack_depth < size)\n\t\tenv->subprog_info[state->subprogno].stack_depth = size;\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int grow_stack_state(struct bpf_func_state *state, int size)\n+static int grow_stack_state(struct bpf_verifier_env *env, struct bpf_func_state *state, int size)\n {\n \tsize_t old_n = state->allocated_stack / BPF_REG_SIZE, n = size / BPF_REG_SIZE;\n \n@@ -10,5 +10,10 @@\n \t\treturn -ENOMEM;\n \n \tstate->allocated_stack = size;\n+\n+\t/* update known max for given subprogram */\n+\tif (env->subprog_info[state->subprogno].stack_depth < size)\n+\t\tenv->subprog_info[state->subprogno].stack_depth = size;\n+\n \treturn 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static int grow_stack_state(struct bpf_func_state *state, int size)"
            ],
            "added_lines": [
                "static int grow_stack_state(struct bpf_verifier_env *env, struct bpf_func_state *state, int size)",
                "",
                "\t/* update known max for given subprogram */",
                "\tif (env->subprog_info[state->subprogno].stack_depth < size)",
                "\t\tenv->subprog_info[state->subprogno].stack_depth = size;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-52452",
        "func_name": "torvalds/linux/check_stack_range_initialized",
        "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix accesses to uninit stack slots\n\nPrivileged programs are supposed to be able to read uninitialized stack\nmemory (ever since 6715df8d5) but, before this patch, these accesses\nwere permitted inconsistently. In particular, accesses were permitted\nabove state->allocated_stack, but not below it. In other words, if the\nstack was already \"large enough\", the access was permitted, but\notherwise the access was rejected instead of being allowed to \"grow the\nstack\". This undesired rejection was happening in two places:\n- in check_stack_slot_within_bounds()\n- in check_stack_range_initialized()\nThis patch arranges for these accesses to be permitted. A bunch of tests\nthat were relying on the old rejection had to change; all of them were\nchanged to add also run unprivileged, in which case the old behavior\npersists. One tests couldn't be updated - global_func16 - because it\ncan't run unprivileged for other reasons.\n\nThis patch also fixes the tracking of the stack size for variable-offset\nreads. This second fix is bundled in the same commit as the first one\nbecause they're inter-related. Before this patch, writes to the stack\nusing registers containing a variable offset (as opposed to registers\nwith fixed, known values) were not properly contributing to the\nfunction's needed stack size. As a result, it was possible for a program\nto verify, but then to attempt to read out-of-bounds data at runtime\nbecause a too small stack had been allocated for it.\n\nEach function tracks the size of the stack it needs in\nbpf_subprog_info.stack_depth, which is maintained by\nupdate_stack_depth(). For regular memory accesses, check_mem_access()\nwas calling update_state_depth() but it was passing in only the fixed\npart of the offset register, ignoring the variable offset. This was\nincorrect; the minimum possible value of that register should be used\ninstead.\n\nThis tracking is now fixed by centralizing the tracking of stack size in\ngrow_stack_state(), and by lifting the calls to grow_stack_state() to\ncheck_stack_access_within_bounds() as suggested by Andrii. The code is\nnow simpler and more convincingly tracks the correct maximum stack size.\ncheck_stack_range_initialized() can now rely on enough stack having been\nallocated for the access; this helps with the fix for the first issue.\n\nA few tests were changed to also check the stack depth computation. The\none that fails without this patch is verifier_var_off:stack_write_priv_vs_unpriv.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=6b4a64bafd107e521c01eec3453ce94a3fb38529",
        "commit_title": "Privileged programs are supposed to be able to read uninitialized stack",
        "commit_text": "memory (ever since 6715df8d5) but, before this patch, these accesses were permitted inconsistently. In particular, accesses were permitted above state->allocated_stack, but not below it. In other words, if the stack was already \"large enough\", the access was permitted, but otherwise the access was rejected instead of being allowed to \"grow the stack\". This undesired rejection was happening in two places: - in check_stack_slot_within_bounds() - in check_stack_range_initialized() This patch arranges for these accesses to be permitted. A bunch of tests that were relying on the old rejection had to change; all of them were changed to add also run unprivileged, in which case the old behavior persists. One tests couldn't be updated - global_func16 - because it can't run unprivileged for other reasons.  This patch also fixes the tracking of the stack size for variable-offset reads. This second fix is bundled in the same commit as the first one because they're inter-related. Before this patch, writes to the stack using registers containing a variable offset (as opposed to registers with fixed, known values) were not properly contributing to the function's needed stack size. As a result, it was possible for a program to verify, but then to attempt to read out-of-bounds data at runtime because a too small stack had been allocated for it.  Each function tracks the size of the stack it needs in bpf_subprog_info.stack_depth, which is maintained by update_stack_depth(). For regular memory accesses, check_mem_access() was calling update_state_depth() but it was passing in only the fixed part of the offset register, ignoring the variable offset. This was incorrect; the minimum possible value of that register should be used instead.  This tracking is now fixed by centralizing the tracking of stack size in grow_stack_state(), and by lifting the calls to grow_stack_state() to check_stack_access_within_bounds() as suggested by Andrii. The code is now simpler and more convincingly tracks the correct maximum stack size. check_stack_range_initialized() can now rely on enough stack having been allocated for the access; this helps with the fix for the first issue.  A few tests were changed to also check the stack depth computation. The one that fails without this patch is verifier_var_off:stack_write_priv_vs_unpriv.  Link: https://lore.kernel.org/bpf/20231208032519.260451-3-andreimatei1@gmail.com  Closes: https://lore.kernel.org/bpf/CABWLsev9g8UP_c3a=1qbuZUi20tGoUXoU07FPf-5FLvhOKOY+Q@mail.gmail.com/ ",
        "func_before": "static int check_stack_range_initialized(\n\t\tstruct bpf_verifier_env *env, int regno, int off,\n\t\tint access_size, bool zero_size_allowed,\n\t\tenum bpf_access_src type, struct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_reg_state *reg = reg_state(env, regno);\n\tstruct bpf_func_state *state = func(env, reg);\n\tint err, min_off, max_off, i, j, slot, spi;\n\tchar *err_extra = type == ACCESS_HELPER ? \" indirect\" : \"\";\n\tenum bpf_access_type bounds_check_type;\n\t/* Some accesses can write anything into the stack, others are\n\t * read-only.\n\t */\n\tbool clobber = false;\n\n\tif (access_size == 0 && !zero_size_allowed) {\n\t\tverbose(env, \"invalid zero-sized read\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tif (type == ACCESS_HELPER) {\n\t\t/* The bounds checks for writes are more permissive than for\n\t\t * reads. However, if raw_mode is not set, we'll do extra\n\t\t * checks below.\n\t\t */\n\t\tbounds_check_type = BPF_WRITE;\n\t\tclobber = true;\n\t} else {\n\t\tbounds_check_type = BPF_READ;\n\t}\n\terr = check_stack_access_within_bounds(env, regno, off, access_size,\n\t\t\t\t\t       type, bounds_check_type);\n\tif (err)\n\t\treturn err;\n\n\n\tif (tnum_is_const(reg->var_off)) {\n\t\tmin_off = max_off = reg->var_off.value + off;\n\t} else {\n\t\t/* Variable offset is prohibited for unprivileged mode for\n\t\t * simplicity since it requires corresponding support in\n\t\t * Spectre masking for stack ALU.\n\t\t * See also retrieve_ptr_limit().\n\t\t */\n\t\tif (!env->bypass_spec_v1) {\n\t\t\tchar tn_buf[48];\n\n\t\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\t\tverbose(env, \"R%d%s variable offset stack access prohibited for !root, var_off=%s\\n\",\n\t\t\t\tregno, err_extra, tn_buf);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/* Only initialized buffer on stack is allowed to be accessed\n\t\t * with variable offset. With uninitialized buffer it's hard to\n\t\t * guarantee that whole memory is marked as initialized on\n\t\t * helper return since specific bounds are unknown what may\n\t\t * cause uninitialized stack leaking.\n\t\t */\n\t\tif (meta && meta->raw_mode)\n\t\t\tmeta = NULL;\n\n\t\tmin_off = reg->smin_value + off;\n\t\tmax_off = reg->smax_value + off;\n\t}\n\n\tif (meta && meta->raw_mode) {\n\t\t/* Ensure we won't be overwriting dynptrs when simulating byte\n\t\t * by byte access in check_helper_call using meta.access_size.\n\t\t * This would be a problem if we have a helper in the future\n\t\t * which takes:\n\t\t *\n\t\t *\thelper(uninit_mem, len, dynptr)\n\t\t *\n\t\t * Now, uninint_mem may overlap with dynptr pointer. Hence, it\n\t\t * may end up writing to dynptr itself when touching memory from\n\t\t * arg 1. This can be relaxed on a case by case basis for known\n\t\t * safe cases, but reject due to the possibilitiy of aliasing by\n\t\t * default.\n\t\t */\n\t\tfor (i = min_off; i < max_off + access_size; i++) {\n\t\t\tint stack_off = -i - 1;\n\n\t\t\tspi = __get_spi(i);\n\t\t\t/* raw_mode may write past allocated_stack */\n\t\t\tif (state->allocated_stack <= stack_off)\n\t\t\t\tcontinue;\n\t\t\tif (state->stack[spi].slot_type[stack_off % BPF_REG_SIZE] == STACK_DYNPTR) {\n\t\t\t\tverbose(env, \"potential write to dynptr at off=%d disallowed\\n\", i);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t}\n\t\tmeta->access_size = access_size;\n\t\tmeta->regno = regno;\n\t\treturn 0;\n\t}\n\n\tfor (i = min_off; i < max_off + access_size; i++) {\n\t\tu8 *stype;\n\n\t\tslot = -i - 1;\n\t\tspi = slot / BPF_REG_SIZE;\n\t\tif (state->allocated_stack <= slot)\n\t\t\tgoto err;\n\t\tstype = &state->stack[spi].slot_type[slot % BPF_REG_SIZE];\n\t\tif (*stype == STACK_MISC)\n\t\t\tgoto mark;\n\t\tif ((*stype == STACK_ZERO) ||\n\t\t    (*stype == STACK_INVALID && env->allow_uninit_stack)) {\n\t\t\tif (clobber) {\n\t\t\t\t/* helper can write anything into the stack */\n\t\t\t\t*stype = STACK_MISC;\n\t\t\t}\n\t\t\tgoto mark;\n\t\t}\n\n\t\tif (is_spilled_reg(&state->stack[spi]) &&\n\t\t    (state->stack[spi].spilled_ptr.type == SCALAR_VALUE ||\n\t\t     env->allow_ptr_leaks)) {\n\t\t\tif (clobber) {\n\t\t\t\t__mark_reg_unknown(env, &state->stack[spi].spilled_ptr);\n\t\t\t\tfor (j = 0; j < BPF_REG_SIZE; j++)\n\t\t\t\t\tscrub_spilled_slot(&state->stack[spi].slot_type[j]);\n\t\t\t}\n\t\t\tgoto mark;\n\t\t}\n\nerr:\n\t\tif (tnum_is_const(reg->var_off)) {\n\t\t\tverbose(env, \"invalid%s read from stack R%d off %d+%d size %d\\n\",\n\t\t\t\terr_extra, regno, min_off, i - min_off, access_size);\n\t\t} else {\n\t\t\tchar tn_buf[48];\n\n\t\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\t\tverbose(env, \"invalid%s read from stack R%d var_off %s+%d size %d\\n\",\n\t\t\t\terr_extra, regno, tn_buf, i - min_off, access_size);\n\t\t}\n\t\treturn -EACCES;\nmark:\n\t\t/* reading any byte out of 8-byte 'spill_slot' will cause\n\t\t * the whole slot to be marked as 'read'\n\t\t */\n\t\tmark_reg_read(env, &state->stack[spi].spilled_ptr,\n\t\t\t      state->stack[spi].spilled_ptr.parent,\n\t\t\t      REG_LIVE_READ64);\n\t\t/* We do not set REG_LIVE_WRITTEN for stack slot, as we can not\n\t\t * be sure that whether stack slot is written to or not. Hence,\n\t\t * we must still conservatively propagate reads upwards even if\n\t\t * helper may write to the entire memory range.\n\t\t */\n\t}\n\treturn update_stack_depth(env, state, min_off);\n}",
        "func": "static int check_stack_range_initialized(\n\t\tstruct bpf_verifier_env *env, int regno, int off,\n\t\tint access_size, bool zero_size_allowed,\n\t\tenum bpf_access_src type, struct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_reg_state *reg = reg_state(env, regno);\n\tstruct bpf_func_state *state = func(env, reg);\n\tint err, min_off, max_off, i, j, slot, spi;\n\tchar *err_extra = type == ACCESS_HELPER ? \" indirect\" : \"\";\n\tenum bpf_access_type bounds_check_type;\n\t/* Some accesses can write anything into the stack, others are\n\t * read-only.\n\t */\n\tbool clobber = false;\n\n\tif (access_size == 0 && !zero_size_allowed) {\n\t\tverbose(env, \"invalid zero-sized read\\n\");\n\t\treturn -EACCES;\n\t}\n\n\tif (type == ACCESS_HELPER) {\n\t\t/* The bounds checks for writes are more permissive than for\n\t\t * reads. However, if raw_mode is not set, we'll do extra\n\t\t * checks below.\n\t\t */\n\t\tbounds_check_type = BPF_WRITE;\n\t\tclobber = true;\n\t} else {\n\t\tbounds_check_type = BPF_READ;\n\t}\n\terr = check_stack_access_within_bounds(env, regno, off, access_size,\n\t\t\t\t\t       type, bounds_check_type);\n\tif (err)\n\t\treturn err;\n\n\n\tif (tnum_is_const(reg->var_off)) {\n\t\tmin_off = max_off = reg->var_off.value + off;\n\t} else {\n\t\t/* Variable offset is prohibited for unprivileged mode for\n\t\t * simplicity since it requires corresponding support in\n\t\t * Spectre masking for stack ALU.\n\t\t * See also retrieve_ptr_limit().\n\t\t */\n\t\tif (!env->bypass_spec_v1) {\n\t\t\tchar tn_buf[48];\n\n\t\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\t\tverbose(env, \"R%d%s variable offset stack access prohibited for !root, var_off=%s\\n\",\n\t\t\t\tregno, err_extra, tn_buf);\n\t\t\treturn -EACCES;\n\t\t}\n\t\t/* Only initialized buffer on stack is allowed to be accessed\n\t\t * with variable offset. With uninitialized buffer it's hard to\n\t\t * guarantee that whole memory is marked as initialized on\n\t\t * helper return since specific bounds are unknown what may\n\t\t * cause uninitialized stack leaking.\n\t\t */\n\t\tif (meta && meta->raw_mode)\n\t\t\tmeta = NULL;\n\n\t\tmin_off = reg->smin_value + off;\n\t\tmax_off = reg->smax_value + off;\n\t}\n\n\tif (meta && meta->raw_mode) {\n\t\t/* Ensure we won't be overwriting dynptrs when simulating byte\n\t\t * by byte access in check_helper_call using meta.access_size.\n\t\t * This would be a problem if we have a helper in the future\n\t\t * which takes:\n\t\t *\n\t\t *\thelper(uninit_mem, len, dynptr)\n\t\t *\n\t\t * Now, uninint_mem may overlap with dynptr pointer. Hence, it\n\t\t * may end up writing to dynptr itself when touching memory from\n\t\t * arg 1. This can be relaxed on a case by case basis for known\n\t\t * safe cases, but reject due to the possibilitiy of aliasing by\n\t\t * default.\n\t\t */\n\t\tfor (i = min_off; i < max_off + access_size; i++) {\n\t\t\tint stack_off = -i - 1;\n\n\t\t\tspi = __get_spi(i);\n\t\t\t/* raw_mode may write past allocated_stack */\n\t\t\tif (state->allocated_stack <= stack_off)\n\t\t\t\tcontinue;\n\t\t\tif (state->stack[spi].slot_type[stack_off % BPF_REG_SIZE] == STACK_DYNPTR) {\n\t\t\t\tverbose(env, \"potential write to dynptr at off=%d disallowed\\n\", i);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t}\n\t\tmeta->access_size = access_size;\n\t\tmeta->regno = regno;\n\t\treturn 0;\n\t}\n\n\tfor (i = min_off; i < max_off + access_size; i++) {\n\t\tu8 *stype;\n\n\t\tslot = -i - 1;\n\t\tspi = slot / BPF_REG_SIZE;\n\t\tif (state->allocated_stack <= slot) {\n\t\t\tverbose(env, \"verifier bug: allocated_stack too small\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tstype = &state->stack[spi].slot_type[slot % BPF_REG_SIZE];\n\t\tif (*stype == STACK_MISC)\n\t\t\tgoto mark;\n\t\tif ((*stype == STACK_ZERO) ||\n\t\t    (*stype == STACK_INVALID && env->allow_uninit_stack)) {\n\t\t\tif (clobber) {\n\t\t\t\t/* helper can write anything into the stack */\n\t\t\t\t*stype = STACK_MISC;\n\t\t\t}\n\t\t\tgoto mark;\n\t\t}\n\n\t\tif (is_spilled_reg(&state->stack[spi]) &&\n\t\t    (state->stack[spi].spilled_ptr.type == SCALAR_VALUE ||\n\t\t     env->allow_ptr_leaks)) {\n\t\t\tif (clobber) {\n\t\t\t\t__mark_reg_unknown(env, &state->stack[spi].spilled_ptr);\n\t\t\t\tfor (j = 0; j < BPF_REG_SIZE; j++)\n\t\t\t\t\tscrub_spilled_slot(&state->stack[spi].slot_type[j]);\n\t\t\t}\n\t\t\tgoto mark;\n\t\t}\n\n\t\tif (tnum_is_const(reg->var_off)) {\n\t\t\tverbose(env, \"invalid%s read from stack R%d off %d+%d size %d\\n\",\n\t\t\t\terr_extra, regno, min_off, i - min_off, access_size);\n\t\t} else {\n\t\t\tchar tn_buf[48];\n\n\t\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\t\tverbose(env, \"invalid%s read from stack R%d var_off %s+%d size %d\\n\",\n\t\t\t\terr_extra, regno, tn_buf, i - min_off, access_size);\n\t\t}\n\t\treturn -EACCES;\nmark:\n\t\t/* reading any byte out of 8-byte 'spill_slot' will cause\n\t\t * the whole slot to be marked as 'read'\n\t\t */\n\t\tmark_reg_read(env, &state->stack[spi].spilled_ptr,\n\t\t\t      state->stack[spi].spilled_ptr.parent,\n\t\t\t      REG_LIVE_READ64);\n\t\t/* We do not set REG_LIVE_WRITTEN for stack slot, as we can not\n\t\t * be sure that whether stack slot is written to or not. Hence,\n\t\t * we must still conservatively propagate reads upwards even if\n\t\t * helper may write to the entire memory range.\n\t\t */\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -99,8 +99,11 @@\n \n \t\tslot = -i - 1;\n \t\tspi = slot / BPF_REG_SIZE;\n-\t\tif (state->allocated_stack <= slot)\n-\t\t\tgoto err;\n+\t\tif (state->allocated_stack <= slot) {\n+\t\t\tverbose(env, \"verifier bug: allocated_stack too small\");\n+\t\t\treturn -EFAULT;\n+\t\t}\n+\n \t\tstype = &state->stack[spi].slot_type[slot % BPF_REG_SIZE];\n \t\tif (*stype == STACK_MISC)\n \t\t\tgoto mark;\n@@ -124,7 +127,6 @@\n \t\t\tgoto mark;\n \t\t}\n \n-err:\n \t\tif (tnum_is_const(reg->var_off)) {\n \t\t\tverbose(env, \"invalid%s read from stack R%d off %d+%d size %d\\n\",\n \t\t\t\terr_extra, regno, min_off, i - min_off, access_size);\n@@ -149,5 +151,5 @@\n \t\t * helper may write to the entire memory range.\n \t\t */\n \t}\n-\treturn update_stack_depth(env, state, min_off);\n+\treturn 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (state->allocated_stack <= slot)",
                "\t\t\tgoto err;",
                "err:",
                "\treturn update_stack_depth(env, state, min_off);"
            ],
            "added_lines": [
                "\t\tif (state->allocated_stack <= slot) {",
                "\t\t\tverbose(env, \"verifier bug: allocated_stack too small\");",
                "\t\t\treturn -EFAULT;",
                "\t\t}",
                "",
                "\treturn 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-52452",
        "func_name": "torvalds/linux/check_stack_slot_within_bounds",
        "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix accesses to uninit stack slots\n\nPrivileged programs are supposed to be able to read uninitialized stack\nmemory (ever since 6715df8d5) but, before this patch, these accesses\nwere permitted inconsistently. In particular, accesses were permitted\nabove state->allocated_stack, but not below it. In other words, if the\nstack was already \"large enough\", the access was permitted, but\notherwise the access was rejected instead of being allowed to \"grow the\nstack\". This undesired rejection was happening in two places:\n- in check_stack_slot_within_bounds()\n- in check_stack_range_initialized()\nThis patch arranges for these accesses to be permitted. A bunch of tests\nthat were relying on the old rejection had to change; all of them were\nchanged to add also run unprivileged, in which case the old behavior\npersists. One tests couldn't be updated - global_func16 - because it\ncan't run unprivileged for other reasons.\n\nThis patch also fixes the tracking of the stack size for variable-offset\nreads. This second fix is bundled in the same commit as the first one\nbecause they're inter-related. Before this patch, writes to the stack\nusing registers containing a variable offset (as opposed to registers\nwith fixed, known values) were not properly contributing to the\nfunction's needed stack size. As a result, it was possible for a program\nto verify, but then to attempt to read out-of-bounds data at runtime\nbecause a too small stack had been allocated for it.\n\nEach function tracks the size of the stack it needs in\nbpf_subprog_info.stack_depth, which is maintained by\nupdate_stack_depth(). For regular memory accesses, check_mem_access()\nwas calling update_state_depth() but it was passing in only the fixed\npart of the offset register, ignoring the variable offset. This was\nincorrect; the minimum possible value of that register should be used\ninstead.\n\nThis tracking is now fixed by centralizing the tracking of stack size in\ngrow_stack_state(), and by lifting the calls to grow_stack_state() to\ncheck_stack_access_within_bounds() as suggested by Andrii. The code is\nnow simpler and more convincingly tracks the correct maximum stack size.\ncheck_stack_range_initialized() can now rely on enough stack having been\nallocated for the access; this helps with the fix for the first issue.\n\nA few tests were changed to also check the stack depth computation. The\none that fails without this patch is verifier_var_off:stack_write_priv_vs_unpriv.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=6b4a64bafd107e521c01eec3453ce94a3fb38529",
        "commit_title": "Privileged programs are supposed to be able to read uninitialized stack",
        "commit_text": "memory (ever since 6715df8d5) but, before this patch, these accesses were permitted inconsistently. In particular, accesses were permitted above state->allocated_stack, but not below it. In other words, if the stack was already \"large enough\", the access was permitted, but otherwise the access was rejected instead of being allowed to \"grow the stack\". This undesired rejection was happening in two places: - in check_stack_slot_within_bounds() - in check_stack_range_initialized() This patch arranges for these accesses to be permitted. A bunch of tests that were relying on the old rejection had to change; all of them were changed to add also run unprivileged, in which case the old behavior persists. One tests couldn't be updated - global_func16 - because it can't run unprivileged for other reasons.  This patch also fixes the tracking of the stack size for variable-offset reads. This second fix is bundled in the same commit as the first one because they're inter-related. Before this patch, writes to the stack using registers containing a variable offset (as opposed to registers with fixed, known values) were not properly contributing to the function's needed stack size. As a result, it was possible for a program to verify, but then to attempt to read out-of-bounds data at runtime because a too small stack had been allocated for it.  Each function tracks the size of the stack it needs in bpf_subprog_info.stack_depth, which is maintained by update_stack_depth(). For regular memory accesses, check_mem_access() was calling update_state_depth() but it was passing in only the fixed part of the offset register, ignoring the variable offset. This was incorrect; the minimum possible value of that register should be used instead.  This tracking is now fixed by centralizing the tracking of stack size in grow_stack_state(), and by lifting the calls to grow_stack_state() to check_stack_access_within_bounds() as suggested by Andrii. The code is now simpler and more convincingly tracks the correct maximum stack size. check_stack_range_initialized() can now rely on enough stack having been allocated for the access; this helps with the fix for the first issue.  A few tests were changed to also check the stack depth computation. The one that fails without this patch is verifier_var_off:stack_write_priv_vs_unpriv.  Link: https://lore.kernel.org/bpf/20231208032519.260451-3-andreimatei1@gmail.com  Closes: https://lore.kernel.org/bpf/CABWLsev9g8UP_c3a=1qbuZUi20tGoUXoU07FPf-5FLvhOKOY+Q@mail.gmail.com/ ",
        "func_before": "static int check_stack_slot_within_bounds(s64 off,\n\t\t\t\t\t  struct bpf_func_state *state,\n\t\t\t\t\t  enum bpf_access_type t)\n{\n\tint min_valid_off;\n\n\tif (t == BPF_WRITE)\n\t\tmin_valid_off = -MAX_BPF_STACK;\n\telse\n\t\tmin_valid_off = -state->allocated_stack;\n\n\tif (off < min_valid_off || off > -1)\n\t\treturn -EACCES;\n\treturn 0;\n}",
        "func": "static int check_stack_slot_within_bounds(struct bpf_verifier_env *env,\n                                          s64 off,\n                                          struct bpf_func_state *state,\n                                          enum bpf_access_type t)\n{\n\tint min_valid_off;\n\n\tif (t == BPF_WRITE || env->allow_uninit_stack)\n\t\tmin_valid_off = -MAX_BPF_STACK;\n\telse\n\t\tmin_valid_off = -state->allocated_stack;\n\n\tif (off < min_valid_off || off > -1)\n\t\treturn -EACCES;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,11 @@\n-static int check_stack_slot_within_bounds(s64 off,\n-\t\t\t\t\t  struct bpf_func_state *state,\n-\t\t\t\t\t  enum bpf_access_type t)\n+static int check_stack_slot_within_bounds(struct bpf_verifier_env *env,\n+                                          s64 off,\n+                                          struct bpf_func_state *state,\n+                                          enum bpf_access_type t)\n {\n \tint min_valid_off;\n \n-\tif (t == BPF_WRITE)\n+\tif (t == BPF_WRITE || env->allow_uninit_stack)\n \t\tmin_valid_off = -MAX_BPF_STACK;\n \telse\n \t\tmin_valid_off = -state->allocated_stack;",
        "diff_line_info": {
            "deleted_lines": [
                "static int check_stack_slot_within_bounds(s64 off,",
                "\t\t\t\t\t  struct bpf_func_state *state,",
                "\t\t\t\t\t  enum bpf_access_type t)",
                "\tif (t == BPF_WRITE)"
            ],
            "added_lines": [
                "static int check_stack_slot_within_bounds(struct bpf_verifier_env *env,",
                "                                          s64 off,",
                "                                          struct bpf_func_state *state,",
                "                                          enum bpf_access_type t)",
                "\tif (t == BPF_WRITE || env->allow_uninit_stack)"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-52452",
        "func_name": "torvalds/linux/check_mem_access",
        "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix accesses to uninit stack slots\n\nPrivileged programs are supposed to be able to read uninitialized stack\nmemory (ever since 6715df8d5) but, before this patch, these accesses\nwere permitted inconsistently. In particular, accesses were permitted\nabove state->allocated_stack, but not below it. In other words, if the\nstack was already \"large enough\", the access was permitted, but\notherwise the access was rejected instead of being allowed to \"grow the\nstack\". This undesired rejection was happening in two places:\n- in check_stack_slot_within_bounds()\n- in check_stack_range_initialized()\nThis patch arranges for these accesses to be permitted. A bunch of tests\nthat were relying on the old rejection had to change; all of them were\nchanged to add also run unprivileged, in which case the old behavior\npersists. One tests couldn't be updated - global_func16 - because it\ncan't run unprivileged for other reasons.\n\nThis patch also fixes the tracking of the stack size for variable-offset\nreads. This second fix is bundled in the same commit as the first one\nbecause they're inter-related. Before this patch, writes to the stack\nusing registers containing a variable offset (as opposed to registers\nwith fixed, known values) were not properly contributing to the\nfunction's needed stack size. As a result, it was possible for a program\nto verify, but then to attempt to read out-of-bounds data at runtime\nbecause a too small stack had been allocated for it.\n\nEach function tracks the size of the stack it needs in\nbpf_subprog_info.stack_depth, which is maintained by\nupdate_stack_depth(). For regular memory accesses, check_mem_access()\nwas calling update_state_depth() but it was passing in only the fixed\npart of the offset register, ignoring the variable offset. This was\nincorrect; the minimum possible value of that register should be used\ninstead.\n\nThis tracking is now fixed by centralizing the tracking of stack size in\ngrow_stack_state(), and by lifting the calls to grow_stack_state() to\ncheck_stack_access_within_bounds() as suggested by Andrii. The code is\nnow simpler and more convincingly tracks the correct maximum stack size.\ncheck_stack_range_initialized() can now rely on enough stack having been\nallocated for the access; this helps with the fix for the first issue.\n\nA few tests were changed to also check the stack depth computation. The\none that fails without this patch is verifier_var_off:stack_write_priv_vs_unpriv.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=6b4a64bafd107e521c01eec3453ce94a3fb38529",
        "commit_title": "Privileged programs are supposed to be able to read uninitialized stack",
        "commit_text": "memory (ever since 6715df8d5) but, before this patch, these accesses were permitted inconsistently. In particular, accesses were permitted above state->allocated_stack, but not below it. In other words, if the stack was already \"large enough\", the access was permitted, but otherwise the access was rejected instead of being allowed to \"grow the stack\". This undesired rejection was happening in two places: - in check_stack_slot_within_bounds() - in check_stack_range_initialized() This patch arranges for these accesses to be permitted. A bunch of tests that were relying on the old rejection had to change; all of them were changed to add also run unprivileged, in which case the old behavior persists. One tests couldn't be updated - global_func16 - because it can't run unprivileged for other reasons.  This patch also fixes the tracking of the stack size for variable-offset reads. This second fix is bundled in the same commit as the first one because they're inter-related. Before this patch, writes to the stack using registers containing a variable offset (as opposed to registers with fixed, known values) were not properly contributing to the function's needed stack size. As a result, it was possible for a program to verify, but then to attempt to read out-of-bounds data at runtime because a too small stack had been allocated for it.  Each function tracks the size of the stack it needs in bpf_subprog_info.stack_depth, which is maintained by update_stack_depth(). For regular memory accesses, check_mem_access() was calling update_state_depth() but it was passing in only the fixed part of the offset register, ignoring the variable offset. This was incorrect; the minimum possible value of that register should be used instead.  This tracking is now fixed by centralizing the tracking of stack size in grow_stack_state(), and by lifting the calls to grow_stack_state() to check_stack_access_within_bounds() as suggested by Andrii. The code is now simpler and more convincingly tracks the correct maximum stack size. check_stack_range_initialized() can now rely on enough stack having been allocated for the access; this helps with the fix for the first issue.  A few tests were changed to also check the stack depth computation. The one that fails without this patch is verifier_var_off:stack_write_priv_vs_unpriv.  Link: https://lore.kernel.org/bpf/20231208032519.260451-3-andreimatei1@gmail.com  Closes: https://lore.kernel.org/bpf/CABWLsev9g8UP_c3a=1qbuZUi20tGoUXoU07FPf-5FLvhOKOY+Q@mail.gmail.com/ ",
        "func_before": "static int check_mem_access(struct bpf_verifier_env *env, int insn_idx, u32 regno,\n\t\t\t    int off, int bpf_size, enum bpf_access_type t,\n\t\t\t    int value_regno, bool strict_alignment_once, bool is_ldsx)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tstruct bpf_reg_state *reg = regs + regno;\n\tstruct bpf_func_state *state;\n\tint size, err = 0;\n\n\tsize = bpf_size_to_bytes(bpf_size);\n\tif (size < 0)\n\t\treturn size;\n\n\t/* alignment checks will add in reg->off themselves */\n\terr = check_ptr_alignment(env, reg, off, size, strict_alignment_once);\n\tif (err)\n\t\treturn err;\n\n\t/* for access checks, reg->off is just part of off */\n\toff += reg->off;\n\n\tif (reg->type == PTR_TO_MAP_KEY) {\n\t\tif (t == BPF_WRITE) {\n\t\t\tverbose(env, \"write to change key R%d not allowed\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_mem_region_access(env, regno, off, size,\n\t\t\t\t\t      reg->map_ptr->key_size, false);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_MAP_VALUE) {\n\t\tstruct btf_field *kptr_field = NULL;\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into map\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_map_access_type(env, regno, off, size, t);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = check_map_access(env, regno, off, size, false, ACCESS_DIRECT);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (tnum_is_const(reg->var_off))\n\t\t\tkptr_field = btf_record_find(reg->map_ptr->record,\n\t\t\t\t\t\t     off + reg->var_off.value, BPF_KPTR);\n\t\tif (kptr_field) {\n\t\t\terr = check_map_kptr_access(env, regno, value_regno, insn_idx, kptr_field);\n\t\t} else if (t == BPF_READ && value_regno >= 0) {\n\t\t\tstruct bpf_map *map = reg->map_ptr;\n\n\t\t\t/* if map is read-only, track its contents as scalars */\n\t\t\tif (tnum_is_const(reg->var_off) &&\n\t\t\t    bpf_map_is_rdonly(map) &&\n\t\t\t    map->ops->map_direct_value_addr) {\n\t\t\t\tint map_off = off + reg->var_off.value;\n\t\t\t\tu64 val = 0;\n\n\t\t\t\terr = bpf_map_direct_read(map, map_off, size,\n\t\t\t\t\t\t\t  &val, is_ldsx);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tregs[value_regno].type = SCALAR_VALUE;\n\t\t\t\t__mark_reg_known(&regs[value_regno], val);\n\t\t\t} else {\n\t\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t\t\t}\n\t\t}\n\t} else if (base_type(reg->type) == PTR_TO_MEM) {\n\t\tbool rdonly_mem = type_is_rdonly_mem(reg->type);\n\n\t\tif (type_may_be_null(reg->type)) {\n\t\t\tverbose(env, \"R%d invalid mem access '%s'\\n\", regno,\n\t\t\t\treg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (t == BPF_WRITE && rdonly_mem) {\n\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into mem\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_mem_region_access(env, regno, off, size,\n\t\t\t\t\t      reg->mem_size, false);\n\t\tif (!err && value_regno >= 0 && (t == BPF_READ || rdonly_mem))\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_CTX) {\n\t\tenum bpf_reg_type reg_type = SCALAR_VALUE;\n\t\tstruct btf *btf = NULL;\n\t\tu32 btf_id = 0;\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into ctx\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_ptr_off_reg(env, reg, regno);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = check_ctx_access(env, insn_idx, off, size, t, &reg_type, &btf,\n\t\t\t\t       &btf_id);\n\t\tif (err)\n\t\t\tverbose_linfo(env, insn_idx, \"; \");\n\t\tif (!err && t == BPF_READ && value_regno >= 0) {\n\t\t\t/* ctx access returns either a scalar, or a\n\t\t\t * PTR_TO_PACKET[_META,_END]. In the latter\n\t\t\t * case, we know the offset is zero.\n\t\t\t */\n\t\t\tif (reg_type == SCALAR_VALUE) {\n\t\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t\t\t} else {\n\t\t\t\tmark_reg_known_zero(env, regs,\n\t\t\t\t\t\t    value_regno);\n\t\t\t\tif (type_may_be_null(reg_type))\n\t\t\t\t\tregs[value_regno].id = ++env->id_gen;\n\t\t\t\t/* A load of ctx field could have different\n\t\t\t\t * actual load size with the one encoded in the\n\t\t\t\t * insn. When the dst is PTR, it is for sure not\n\t\t\t\t * a sub-register.\n\t\t\t\t */\n\t\t\t\tregs[value_regno].subreg_def = DEF_NOT_SUBREG;\n\t\t\t\tif (base_type(reg_type) == PTR_TO_BTF_ID) {\n\t\t\t\t\tregs[value_regno].btf = btf;\n\t\t\t\t\tregs[value_regno].btf_id = btf_id;\n\t\t\t\t}\n\t\t\t}\n\t\t\tregs[value_regno].type = reg_type;\n\t\t}\n\n\t} else if (reg->type == PTR_TO_STACK) {\n\t\t/* Basic bounds checks. */\n\t\terr = check_stack_access_within_bounds(env, regno, off, size, ACCESS_DIRECT, t);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tstate = func(env, reg);\n\t\terr = update_stack_depth(env, state, off);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (t == BPF_READ)\n\t\t\terr = check_stack_read(env, regno, off, size,\n\t\t\t\t\t       value_regno);\n\t\telse\n\t\t\terr = check_stack_write(env, regno, off, size,\n\t\t\t\t\t\tvalue_regno, insn_idx);\n\t} else if (reg_is_pkt_pointer(reg)) {\n\t\tif (t == BPF_WRITE && !may_access_direct_pkt_data(env, NULL, t)) {\n\t\t\tverbose(env, \"cannot write into packet\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into packet\\n\",\n\t\t\t\tvalue_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_packet_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_FLOW_KEYS) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into flow keys\\n\",\n\t\t\t\tvalue_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_flow_keys_access(env, off, size);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (type_is_sk_pointer(reg->type)) {\n\t\tif (t == BPF_WRITE) {\n\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_sock_access(env, insn_idx, regno, off, size, t);\n\t\tif (!err && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_TP_BUFFER) {\n\t\terr = check_tp_buffer_access(env, reg, regno, off, size);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (base_type(reg->type) == PTR_TO_BTF_ID &&\n\t\t   !type_may_be_null(reg->type)) {\n\t\terr = check_ptr_to_btf_access(env, regs, regno, off, size, t,\n\t\t\t\t\t      value_regno);\n\t} else if (reg->type == CONST_PTR_TO_MAP) {\n\t\terr = check_ptr_to_map_access(env, regs, regno, off, size, t,\n\t\t\t\t\t      value_regno);\n\t} else if (base_type(reg->type) == PTR_TO_BUF) {\n\t\tbool rdonly_mem = type_is_rdonly_mem(reg->type);\n\t\tu32 *max_access;\n\n\t\tif (rdonly_mem) {\n\t\t\tif (t == BPF_WRITE) {\n\t\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t\tmax_access = &env->prog->aux->max_rdonly_access;\n\t\t} else {\n\t\t\tmax_access = &env->prog->aux->max_rdwr_access;\n\t\t}\n\n\t\terr = check_buffer_access(env, reg, regno, off, size, false,\n\t\t\t\t\t  max_access);\n\n\t\tif (!err && value_regno >= 0 && (rdonly_mem || t == BPF_READ))\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else {\n\t\tverbose(env, \"R%d invalid mem access '%s'\\n\", regno,\n\t\t\treg_type_str(env, reg->type));\n\t\treturn -EACCES;\n\t}\n\n\tif (!err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ &&\n\t    regs[value_regno].type == SCALAR_VALUE) {\n\t\tif (!is_ldsx)\n\t\t\t/* b/h/w load zero-extends, mark upper bits as known 0 */\n\t\t\tcoerce_reg_to_size(&regs[value_regno], size);\n\t\telse\n\t\t\tcoerce_reg_to_size_sx(&regs[value_regno], size);\n\t}\n\treturn err;\n}",
        "func": "static int check_mem_access(struct bpf_verifier_env *env, int insn_idx, u32 regno,\n\t\t\t    int off, int bpf_size, enum bpf_access_type t,\n\t\t\t    int value_regno, bool strict_alignment_once, bool is_ldsx)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tstruct bpf_reg_state *reg = regs + regno;\n\tint size, err = 0;\n\n\tsize = bpf_size_to_bytes(bpf_size);\n\tif (size < 0)\n\t\treturn size;\n\n\t/* alignment checks will add in reg->off themselves */\n\terr = check_ptr_alignment(env, reg, off, size, strict_alignment_once);\n\tif (err)\n\t\treturn err;\n\n\t/* for access checks, reg->off is just part of off */\n\toff += reg->off;\n\n\tif (reg->type == PTR_TO_MAP_KEY) {\n\t\tif (t == BPF_WRITE) {\n\t\t\tverbose(env, \"write to change key R%d not allowed\\n\", regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_mem_region_access(env, regno, off, size,\n\t\t\t\t\t      reg->map_ptr->key_size, false);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_MAP_VALUE) {\n\t\tstruct btf_field *kptr_field = NULL;\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into map\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_map_access_type(env, regno, off, size, t);\n\t\tif (err)\n\t\t\treturn err;\n\t\terr = check_map_access(env, regno, off, size, false, ACCESS_DIRECT);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (tnum_is_const(reg->var_off))\n\t\t\tkptr_field = btf_record_find(reg->map_ptr->record,\n\t\t\t\t\t\t     off + reg->var_off.value, BPF_KPTR);\n\t\tif (kptr_field) {\n\t\t\terr = check_map_kptr_access(env, regno, value_regno, insn_idx, kptr_field);\n\t\t} else if (t == BPF_READ && value_regno >= 0) {\n\t\t\tstruct bpf_map *map = reg->map_ptr;\n\n\t\t\t/* if map is read-only, track its contents as scalars */\n\t\t\tif (tnum_is_const(reg->var_off) &&\n\t\t\t    bpf_map_is_rdonly(map) &&\n\t\t\t    map->ops->map_direct_value_addr) {\n\t\t\t\tint map_off = off + reg->var_off.value;\n\t\t\t\tu64 val = 0;\n\n\t\t\t\terr = bpf_map_direct_read(map, map_off, size,\n\t\t\t\t\t\t\t  &val, is_ldsx);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\n\t\t\t\tregs[value_regno].type = SCALAR_VALUE;\n\t\t\t\t__mark_reg_known(&regs[value_regno], val);\n\t\t\t} else {\n\t\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t\t\t}\n\t\t}\n\t} else if (base_type(reg->type) == PTR_TO_MEM) {\n\t\tbool rdonly_mem = type_is_rdonly_mem(reg->type);\n\n\t\tif (type_may_be_null(reg->type)) {\n\t\t\tverbose(env, \"R%d invalid mem access '%s'\\n\", regno,\n\t\t\t\treg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (t == BPF_WRITE && rdonly_mem) {\n\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into mem\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_mem_region_access(env, regno, off, size,\n\t\t\t\t\t      reg->mem_size, false);\n\t\tif (!err && value_regno >= 0 && (t == BPF_READ || rdonly_mem))\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_CTX) {\n\t\tenum bpf_reg_type reg_type = SCALAR_VALUE;\n\t\tstruct btf *btf = NULL;\n\t\tu32 btf_id = 0;\n\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into ctx\\n\", value_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_ptr_off_reg(env, reg, regno);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = check_ctx_access(env, insn_idx, off, size, t, &reg_type, &btf,\n\t\t\t\t       &btf_id);\n\t\tif (err)\n\t\t\tverbose_linfo(env, insn_idx, \"; \");\n\t\tif (!err && t == BPF_READ && value_regno >= 0) {\n\t\t\t/* ctx access returns either a scalar, or a\n\t\t\t * PTR_TO_PACKET[_META,_END]. In the latter\n\t\t\t * case, we know the offset is zero.\n\t\t\t */\n\t\t\tif (reg_type == SCALAR_VALUE) {\n\t\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t\t\t} else {\n\t\t\t\tmark_reg_known_zero(env, regs,\n\t\t\t\t\t\t    value_regno);\n\t\t\t\tif (type_may_be_null(reg_type))\n\t\t\t\t\tregs[value_regno].id = ++env->id_gen;\n\t\t\t\t/* A load of ctx field could have different\n\t\t\t\t * actual load size with the one encoded in the\n\t\t\t\t * insn. When the dst is PTR, it is for sure not\n\t\t\t\t * a sub-register.\n\t\t\t\t */\n\t\t\t\tregs[value_regno].subreg_def = DEF_NOT_SUBREG;\n\t\t\t\tif (base_type(reg_type) == PTR_TO_BTF_ID) {\n\t\t\t\t\tregs[value_regno].btf = btf;\n\t\t\t\t\tregs[value_regno].btf_id = btf_id;\n\t\t\t\t}\n\t\t\t}\n\t\t\tregs[value_regno].type = reg_type;\n\t\t}\n\n\t} else if (reg->type == PTR_TO_STACK) {\n\t\t/* Basic bounds checks. */\n\t\terr = check_stack_access_within_bounds(env, regno, off, size, ACCESS_DIRECT, t);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (t == BPF_READ)\n\t\t\terr = check_stack_read(env, regno, off, size,\n\t\t\t\t\t       value_regno);\n\t\telse\n\t\t\terr = check_stack_write(env, regno, off, size,\n\t\t\t\t\t\tvalue_regno, insn_idx);\n\t} else if (reg_is_pkt_pointer(reg)) {\n\t\tif (t == BPF_WRITE && !may_access_direct_pkt_data(env, NULL, t)) {\n\t\t\tverbose(env, \"cannot write into packet\\n\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into packet\\n\",\n\t\t\t\tvalue_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_packet_access(env, regno, off, size, false);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_FLOW_KEYS) {\n\t\tif (t == BPF_WRITE && value_regno >= 0 &&\n\t\t    is_pointer_value(env, value_regno)) {\n\t\t\tverbose(env, \"R%d leaks addr into flow keys\\n\",\n\t\t\t\tvalue_regno);\n\t\t\treturn -EACCES;\n\t\t}\n\n\t\terr = check_flow_keys_access(env, off, size);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (type_is_sk_pointer(reg->type)) {\n\t\tif (t == BPF_WRITE) {\n\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\treturn -EACCES;\n\t\t}\n\t\terr = check_sock_access(env, insn_idx, regno, off, size, t);\n\t\tif (!err && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (reg->type == PTR_TO_TP_BUFFER) {\n\t\terr = check_tp_buffer_access(env, reg, regno, off, size);\n\t\tif (!err && t == BPF_READ && value_regno >= 0)\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else if (base_type(reg->type) == PTR_TO_BTF_ID &&\n\t\t   !type_may_be_null(reg->type)) {\n\t\terr = check_ptr_to_btf_access(env, regs, regno, off, size, t,\n\t\t\t\t\t      value_regno);\n\t} else if (reg->type == CONST_PTR_TO_MAP) {\n\t\terr = check_ptr_to_map_access(env, regs, regno, off, size, t,\n\t\t\t\t\t      value_regno);\n\t} else if (base_type(reg->type) == PTR_TO_BUF) {\n\t\tbool rdonly_mem = type_is_rdonly_mem(reg->type);\n\t\tu32 *max_access;\n\n\t\tif (rdonly_mem) {\n\t\t\tif (t == BPF_WRITE) {\n\t\t\t\tverbose(env, \"R%d cannot write into %s\\n\",\n\t\t\t\t\tregno, reg_type_str(env, reg->type));\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t\tmax_access = &env->prog->aux->max_rdonly_access;\n\t\t} else {\n\t\t\tmax_access = &env->prog->aux->max_rdwr_access;\n\t\t}\n\n\t\terr = check_buffer_access(env, reg, regno, off, size, false,\n\t\t\t\t\t  max_access);\n\n\t\tif (!err && value_regno >= 0 && (rdonly_mem || t == BPF_READ))\n\t\t\tmark_reg_unknown(env, regs, value_regno);\n\t} else {\n\t\tverbose(env, \"R%d invalid mem access '%s'\\n\", regno,\n\t\t\treg_type_str(env, reg->type));\n\t\treturn -EACCES;\n\t}\n\n\tif (!err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ &&\n\t    regs[value_regno].type == SCALAR_VALUE) {\n\t\tif (!is_ldsx)\n\t\t\t/* b/h/w load zero-extends, mark upper bits as known 0 */\n\t\t\tcoerce_reg_to_size(&regs[value_regno], size);\n\t\telse\n\t\t\tcoerce_reg_to_size_sx(&regs[value_regno], size);\n\t}\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,6 @@\n {\n \tstruct bpf_reg_state *regs = cur_regs(env);\n \tstruct bpf_reg_state *reg = regs + regno;\n-\tstruct bpf_func_state *state;\n \tint size, err = 0;\n \n \tsize = bpf_size_to_bytes(bpf_size);\n@@ -147,11 +146,6 @@\n \t\tif (err)\n \t\t\treturn err;\n \n-\t\tstate = func(env, reg);\n-\t\terr = update_stack_depth(env, state, off);\n-\t\tif (err)\n-\t\t\treturn err;\n-\n \t\tif (t == BPF_READ)\n \t\t\terr = check_stack_read(env, regno, off, size,\n \t\t\t\t\t       value_regno);",
        "diff_line_info": {
            "deleted_lines": [
                "\tstruct bpf_func_state *state;",
                "\t\tstate = func(env, reg);",
                "\t\terr = update_stack_depth(env, state, off);",
                "\t\tif (err)",
                "\t\t\treturn err;",
                ""
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2023-52452",
        "func_name": "torvalds/linux/check_stack_write_var_off",
        "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix accesses to uninit stack slots\n\nPrivileged programs are supposed to be able to read uninitialized stack\nmemory (ever since 6715df8d5) but, before this patch, these accesses\nwere permitted inconsistently. In particular, accesses were permitted\nabove state->allocated_stack, but not below it. In other words, if the\nstack was already \"large enough\", the access was permitted, but\notherwise the access was rejected instead of being allowed to \"grow the\nstack\". This undesired rejection was happening in two places:\n- in check_stack_slot_within_bounds()\n- in check_stack_range_initialized()\nThis patch arranges for these accesses to be permitted. A bunch of tests\nthat were relying on the old rejection had to change; all of them were\nchanged to add also run unprivileged, in which case the old behavior\npersists. One tests couldn't be updated - global_func16 - because it\ncan't run unprivileged for other reasons.\n\nThis patch also fixes the tracking of the stack size for variable-offset\nreads. This second fix is bundled in the same commit as the first one\nbecause they're inter-related. Before this patch, writes to the stack\nusing registers containing a variable offset (as opposed to registers\nwith fixed, known values) were not properly contributing to the\nfunction's needed stack size. As a result, it was possible for a program\nto verify, but then to attempt to read out-of-bounds data at runtime\nbecause a too small stack had been allocated for it.\n\nEach function tracks the size of the stack it needs in\nbpf_subprog_info.stack_depth, which is maintained by\nupdate_stack_depth(). For regular memory accesses, check_mem_access()\nwas calling update_state_depth() but it was passing in only the fixed\npart of the offset register, ignoring the variable offset. This was\nincorrect; the minimum possible value of that register should be used\ninstead.\n\nThis tracking is now fixed by centralizing the tracking of stack size in\ngrow_stack_state(), and by lifting the calls to grow_stack_state() to\ncheck_stack_access_within_bounds() as suggested by Andrii. The code is\nnow simpler and more convincingly tracks the correct maximum stack size.\ncheck_stack_range_initialized() can now rely on enough stack having been\nallocated for the access; this helps with the fix for the first issue.\n\nA few tests were changed to also check the stack depth computation. The\none that fails without this patch is verifier_var_off:stack_write_priv_vs_unpriv.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=6b4a64bafd107e521c01eec3453ce94a3fb38529",
        "commit_title": "Privileged programs are supposed to be able to read uninitialized stack",
        "commit_text": "memory (ever since 6715df8d5) but, before this patch, these accesses were permitted inconsistently. In particular, accesses were permitted above state->allocated_stack, but not below it. In other words, if the stack was already \"large enough\", the access was permitted, but otherwise the access was rejected instead of being allowed to \"grow the stack\". This undesired rejection was happening in two places: - in check_stack_slot_within_bounds() - in check_stack_range_initialized() This patch arranges for these accesses to be permitted. A bunch of tests that were relying on the old rejection had to change; all of them were changed to add also run unprivileged, in which case the old behavior persists. One tests couldn't be updated - global_func16 - because it can't run unprivileged for other reasons.  This patch also fixes the tracking of the stack size for variable-offset reads. This second fix is bundled in the same commit as the first one because they're inter-related. Before this patch, writes to the stack using registers containing a variable offset (as opposed to registers with fixed, known values) were not properly contributing to the function's needed stack size. As a result, it was possible for a program to verify, but then to attempt to read out-of-bounds data at runtime because a too small stack had been allocated for it.  Each function tracks the size of the stack it needs in bpf_subprog_info.stack_depth, which is maintained by update_stack_depth(). For regular memory accesses, check_mem_access() was calling update_state_depth() but it was passing in only the fixed part of the offset register, ignoring the variable offset. This was incorrect; the minimum possible value of that register should be used instead.  This tracking is now fixed by centralizing the tracking of stack size in grow_stack_state(), and by lifting the calls to grow_stack_state() to check_stack_access_within_bounds() as suggested by Andrii. The code is now simpler and more convincingly tracks the correct maximum stack size. check_stack_range_initialized() can now rely on enough stack having been allocated for the access; this helps with the fix for the first issue.  A few tests were changed to also check the stack depth computation. The one that fails without this patch is verifier_var_off:stack_write_priv_vs_unpriv.  Link: https://lore.kernel.org/bpf/20231208032519.260451-3-andreimatei1@gmail.com  Closes: https://lore.kernel.org/bpf/CABWLsev9g8UP_c3a=1qbuZUi20tGoUXoU07FPf-5FLvhOKOY+Q@mail.gmail.com/ ",
        "func_before": "static int check_stack_write_var_off(struct bpf_verifier_env *env,\n\t\t\t\t     /* func where register points to */\n\t\t\t\t     struct bpf_func_state *state,\n\t\t\t\t     int ptr_regno, int off, int size,\n\t\t\t\t     int value_regno, int insn_idx)\n{\n\tstruct bpf_func_state *cur; /* state of the current function */\n\tint min_off, max_off;\n\tint i, err;\n\tstruct bpf_reg_state *ptr_reg = NULL, *value_reg = NULL;\n\tstruct bpf_insn *insn = &env->prog->insnsi[insn_idx];\n\tbool writing_zero = false;\n\t/* set if the fact that we're writing a zero is used to let any\n\t * stack slots remain STACK_ZERO\n\t */\n\tbool zero_used = false;\n\n\tcur = env->cur_state->frame[env->cur_state->curframe];\n\tptr_reg = &cur->regs[ptr_regno];\n\tmin_off = ptr_reg->smin_value + off;\n\tmax_off = ptr_reg->smax_value + off + size;\n\tif (value_regno >= 0)\n\t\tvalue_reg = &cur->regs[value_regno];\n\tif ((value_reg && register_is_null(value_reg)) ||\n\t    (!value_reg && is_bpf_st_mem(insn) && insn->imm == 0))\n\t\twriting_zero = true;\n\n\terr = grow_stack_state(state, round_up(-min_off, BPF_REG_SIZE));\n\tif (err)\n\t\treturn err;\n\n\tfor (i = min_off; i < max_off; i++) {\n\t\tint spi;\n\n\t\tspi = __get_spi(i);\n\t\terr = destroy_if_dynptr_stack_slot(env, state, spi);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* Variable offset writes destroy any spilled pointers in range. */\n\tfor (i = min_off; i < max_off; i++) {\n\t\tu8 new_type, *stype;\n\t\tint slot, spi;\n\n\t\tslot = -i - 1;\n\t\tspi = slot / BPF_REG_SIZE;\n\t\tstype = &state->stack[spi].slot_type[slot % BPF_REG_SIZE];\n\t\tmark_stack_slot_scratched(env, spi);\n\n\t\tif (!env->allow_ptr_leaks && *stype != STACK_MISC && *stype != STACK_ZERO) {\n\t\t\t/* Reject the write if range we may write to has not\n\t\t\t * been initialized beforehand. If we didn't reject\n\t\t\t * here, the ptr status would be erased below (even\n\t\t\t * though not all slots are actually overwritten),\n\t\t\t * possibly opening the door to leaks.\n\t\t\t *\n\t\t\t * We do however catch STACK_INVALID case below, and\n\t\t\t * only allow reading possibly uninitialized memory\n\t\t\t * later for CAP_PERFMON, as the write may not happen to\n\t\t\t * that slot.\n\t\t\t */\n\t\t\tverbose(env, \"spilled ptr in range of var-offset stack write; insn %d, ptr off: %d\",\n\t\t\t\tinsn_idx, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Erase all spilled pointers. */\n\t\tstate->stack[spi].spilled_ptr.type = NOT_INIT;\n\n\t\t/* Update the slot type. */\n\t\tnew_type = STACK_MISC;\n\t\tif (writing_zero && *stype == STACK_ZERO) {\n\t\t\tnew_type = STACK_ZERO;\n\t\t\tzero_used = true;\n\t\t}\n\t\t/* If the slot is STACK_INVALID, we check whether it's OK to\n\t\t * pretend that it will be initialized by this write. The slot\n\t\t * might not actually be written to, and so if we mark it as\n\t\t * initialized future reads might leak uninitialized memory.\n\t\t * For privileged programs, we will accept such reads to slots\n\t\t * that may or may not be written because, if we're reject\n\t\t * them, the error would be too confusing.\n\t\t */\n\t\tif (*stype == STACK_INVALID && !env->allow_uninit_stack) {\n\t\t\tverbose(env, \"uninit stack in range of var-offset write prohibited for !root; insn %d, off: %d\",\n\t\t\t\t\tinsn_idx, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*stype = new_type;\n\t}\n\tif (zero_used) {\n\t\t/* backtracking doesn't work for STACK_ZERO yet. */\n\t\terr = mark_chain_precision(env, value_regno);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}",
        "func": "static int check_stack_write_var_off(struct bpf_verifier_env *env,\n\t\t\t\t     /* func where register points to */\n\t\t\t\t     struct bpf_func_state *state,\n\t\t\t\t     int ptr_regno, int off, int size,\n\t\t\t\t     int value_regno, int insn_idx)\n{\n\tstruct bpf_func_state *cur; /* state of the current function */\n\tint min_off, max_off;\n\tint i, err;\n\tstruct bpf_reg_state *ptr_reg = NULL, *value_reg = NULL;\n\tstruct bpf_insn *insn = &env->prog->insnsi[insn_idx];\n\tbool writing_zero = false;\n\t/* set if the fact that we're writing a zero is used to let any\n\t * stack slots remain STACK_ZERO\n\t */\n\tbool zero_used = false;\n\n\tcur = env->cur_state->frame[env->cur_state->curframe];\n\tptr_reg = &cur->regs[ptr_regno];\n\tmin_off = ptr_reg->smin_value + off;\n\tmax_off = ptr_reg->smax_value + off + size;\n\tif (value_regno >= 0)\n\t\tvalue_reg = &cur->regs[value_regno];\n\tif ((value_reg && register_is_null(value_reg)) ||\n\t    (!value_reg && is_bpf_st_mem(insn) && insn->imm == 0))\n\t\twriting_zero = true;\n\n\tfor (i = min_off; i < max_off; i++) {\n\t\tint spi;\n\n\t\tspi = __get_spi(i);\n\t\terr = destroy_if_dynptr_stack_slot(env, state, spi);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* Variable offset writes destroy any spilled pointers in range. */\n\tfor (i = min_off; i < max_off; i++) {\n\t\tu8 new_type, *stype;\n\t\tint slot, spi;\n\n\t\tslot = -i - 1;\n\t\tspi = slot / BPF_REG_SIZE;\n\t\tstype = &state->stack[spi].slot_type[slot % BPF_REG_SIZE];\n\t\tmark_stack_slot_scratched(env, spi);\n\n\t\tif (!env->allow_ptr_leaks && *stype != STACK_MISC && *stype != STACK_ZERO) {\n\t\t\t/* Reject the write if range we may write to has not\n\t\t\t * been initialized beforehand. If we didn't reject\n\t\t\t * here, the ptr status would be erased below (even\n\t\t\t * though not all slots are actually overwritten),\n\t\t\t * possibly opening the door to leaks.\n\t\t\t *\n\t\t\t * We do however catch STACK_INVALID case below, and\n\t\t\t * only allow reading possibly uninitialized memory\n\t\t\t * later for CAP_PERFMON, as the write may not happen to\n\t\t\t * that slot.\n\t\t\t */\n\t\t\tverbose(env, \"spilled ptr in range of var-offset stack write; insn %d, ptr off: %d\",\n\t\t\t\tinsn_idx, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Erase all spilled pointers. */\n\t\tstate->stack[spi].spilled_ptr.type = NOT_INIT;\n\n\t\t/* Update the slot type. */\n\t\tnew_type = STACK_MISC;\n\t\tif (writing_zero && *stype == STACK_ZERO) {\n\t\t\tnew_type = STACK_ZERO;\n\t\t\tzero_used = true;\n\t\t}\n\t\t/* If the slot is STACK_INVALID, we check whether it's OK to\n\t\t * pretend that it will be initialized by this write. The slot\n\t\t * might not actually be written to, and so if we mark it as\n\t\t * initialized future reads might leak uninitialized memory.\n\t\t * For privileged programs, we will accept such reads to slots\n\t\t * that may or may not be written because, if we're reject\n\t\t * them, the error would be too confusing.\n\t\t */\n\t\tif (*stype == STACK_INVALID && !env->allow_uninit_stack) {\n\t\t\tverbose(env, \"uninit stack in range of var-offset write prohibited for !root; insn %d, off: %d\",\n\t\t\t\t\tinsn_idx, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*stype = new_type;\n\t}\n\tif (zero_used) {\n\t\t/* backtracking doesn't work for STACK_ZERO yet. */\n\t\terr = mark_chain_precision(env, value_regno);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,10 +24,6 @@\n \tif ((value_reg && register_is_null(value_reg)) ||\n \t    (!value_reg && is_bpf_st_mem(insn) && insn->imm == 0))\n \t\twriting_zero = true;\n-\n-\terr = grow_stack_state(state, round_up(-min_off, BPF_REG_SIZE));\n-\tif (err)\n-\t\treturn err;\n \n \tfor (i = min_off; i < max_off; i++) {\n \t\tint spi;",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "\terr = grow_stack_state(state, round_up(-min_off, BPF_REG_SIZE));",
                "\tif (err)",
                "\t\treturn err;"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2016-1000109",
        "func_name": "facebook/hhvm/FastCGITransport::onHeader",
        "description": "HHVM does not attempt to address RFC 3875 section 4.1.18 namespace conflicts and therefore does not protect CGI applications from the presence of untrusted client data in the HTTP_PROXY environment variable, which might allow remote attackers to redirect a CGI application's outbound HTTP traffic to an arbitrary proxy server via a crafted Proxy header in an HTTP request, aka an \"httpoxy\" issue. This issue affects HHVM versions prior to 3.9.6, all versions between 3.10.0 and 3.12.4 (inclusive), and all versions between 3.13.0 and 3.14.2 (inclusive).",
        "git_url": "https://github.com/facebook/hhvm/commit/423b4b719afd5ef4e6e19d8447fbf7b6bc0d0a25",
        "commit_title": "CVE-2016-1000109: Ignore Proxy HTTP header from fastcgi requests",
        "commit_text": " Summary: The default PHP behavior is to transform a Proxy header from requests into the HTTP_PROXY environment variable in the PHP environment running the request. Some scripts may use this env var to decide which HTTP proxy to connect to, and we don't want requests to have that kind of control over scripts' behavior.  Reviewed By: alexmalyshev, Orvid  Differential Revision: D3579221  fbshipit-source-id: 18a405fd73aee65283aea99ff995f8082b3fc3b5",
        "func_before": "void FastCGITransport::onHeader(std::unique_ptr<folly::IOBuf> key_chain,\n                                std::unique_ptr<folly::IOBuf> value_chain) {\n  Cursor keyCur(key_chain.get());\n  auto key = keyCur.readFixedString(key_chain->computeChainDataLength());\n\n  Cursor valCur(value_chain.get());\n  auto value = valCur.readFixedString(value_chain->computeChainDataLength());\n\n  m_requestParams[key] = value;\n}",
        "func": "void FastCGITransport::onHeader(std::unique_ptr<folly::IOBuf> key_chain,\n                                std::unique_ptr<folly::IOBuf> value_chain) {\n  Cursor keyCur(key_chain.get());\n  auto key = keyCur.readFixedString(key_chain->computeChainDataLength());\n\n  // Don't allow requests to inject an HTTP_PROXY environment variable by\n  // sending a Proxy header.\n  if (strcasecmp(key.c_str(), \"HTTP_PROXY\") == 0) return;\n\n  Cursor valCur(value_chain.get());\n  auto value = valCur.readFixedString(value_chain->computeChainDataLength());\n\n  m_requestParams[key] = value;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,10 @@\n                                 std::unique_ptr<folly::IOBuf> value_chain) {\n   Cursor keyCur(key_chain.get());\n   auto key = keyCur.readFixedString(key_chain->computeChainDataLength());\n+\n+  // Don't allow requests to inject an HTTP_PROXY environment variable by\n+  // sending a Proxy header.\n+  if (strcasecmp(key.c_str(), \"HTTP_PROXY\") == 0) return;\n \n   Cursor valCur(value_chain.get());\n   auto value = valCur.readFixedString(value_chain->computeChainDataLength());",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  // Don't allow requests to inject an HTTP_PROXY environment variable by",
                "  // sending a Proxy header.",
                "  if (strcasecmp(key.c_str(), \"HTTP_PROXY\") == 0) return;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-35508",
        "func_name": "torvalds/linux/copy_process",
        "description": "A flaw possibility of race condition and incorrect initialization of the process id was found in the Linux kernel child/parent process identification handling while filtering signal handlers. A local attacker is able to abuse this flaw to bypass checks to send any signal to a privileged process.",
        "git_url": "https://github.com/torvalds/linux/commit/b4e00444cab4c3f3fec876dc0cccc8cbb0d1a948",
        "commit_title": "fork: fix copy_process(CLONE_PARENT) race with the exiting ->real_parent",
        "commit_text": " current->group_leader->exit_signal may change during copy_process() if current->real_parent exits.  Move the assignment inside tasklist_lock to avoid the race. ",
        "func_before": "task_struct *copy_process(\n\t\t\t\t\tstruct pid *pid,\n\t\t\t\t\tint trace,\n\t\t\t\t\tint node,\n\t\t\t\t\tstruct kernel_clone_args *args)\n{\n\tint pidfd = -1, retval;\n\tstruct task_struct *p;\n\tstruct multiprocess_signals delayed;\n\tstruct file *pidfile = NULL;\n\tu64 clone_flags = args->flags;\n\tstruct nsproxy *nsp = current->nsproxy;\n\n\t/*\n\t * Don't allow sharing the root directory with processes in a different\n\t * namespace\n\t */\n\tif ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif ((clone_flags & (CLONE_NEWUSER|CLONE_FS)) == (CLONE_NEWUSER|CLONE_FS))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Thread groups must share signals as well, and detached threads\n\t * can only be started up within the thread group.\n\t */\n\tif ((clone_flags & CLONE_THREAD) && !(clone_flags & CLONE_SIGHAND))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Shared signal handlers imply shared VM. By way of the above,\n\t * thread groups also imply shared VM. Blocking this case allows\n\t * for various simplifications in other code.\n\t */\n\tif ((clone_flags & CLONE_SIGHAND) && !(clone_flags & CLONE_VM))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Siblings of global init remain as zombies on exit since they are\n\t * not reaped by their parent (swapper). To solve this and to avoid\n\t * multi-rooted process trees, prevent global and container-inits\n\t * from creating siblings.\n\t */\n\tif ((clone_flags & CLONE_PARENT) &&\n\t\t\t\tcurrent->signal->flags & SIGNAL_UNKILLABLE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * If the new process will be in a different pid or user namespace\n\t * do not allow it to share a thread group with the forking task.\n\t */\n\tif (clone_flags & CLONE_THREAD) {\n\t\tif ((clone_flags & (CLONE_NEWUSER | CLONE_NEWPID)) ||\n\t\t    (task_active_pid_ns(current) != nsp->pid_ns_for_children))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/*\n\t * If the new process will be in a different time namespace\n\t * do not allow it to share VM or a thread group with the forking task.\n\t */\n\tif (clone_flags & (CLONE_THREAD | CLONE_VM)) {\n\t\tif (nsp->time_ns != nsp->time_ns_for_children)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (clone_flags & CLONE_PIDFD) {\n\t\t/*\n\t\t * - CLONE_DETACHED is blocked so that we can potentially\n\t\t *   reuse it later for CLONE_PIDFD.\n\t\t * - CLONE_THREAD is blocked until someone really needs it.\n\t\t */\n\t\tif (clone_flags & (CLONE_DETACHED | CLONE_THREAD))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/*\n\t * Force any signals received before this point to be delivered\n\t * before the fork happens.  Collect up signals sent to multiple\n\t * processes that happen during the fork and delay them so that\n\t * they appear to happen after the fork.\n\t */\n\tsigemptyset(&delayed.signal);\n\tINIT_HLIST_NODE(&delayed.node);\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (!(clone_flags & CLONE_THREAD))\n\t\thlist_add_head(&delayed.node, &current->signal->multiprocess);\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n\tretval = -ERESTARTNOINTR;\n\tif (signal_pending(current))\n\t\tgoto fork_out;\n\n\tretval = -ENOMEM;\n\tp = dup_task_struct(current, node);\n\tif (!p)\n\t\tgoto fork_out;\n\n\t/*\n\t * This _must_ happen before we call free_task(), i.e. before we jump\n\t * to any of the bad_fork_* labels. This is to avoid freeing\n\t * p->set_child_tid which is (ab)used as a kthread's data pointer for\n\t * kernel threads (PF_KTHREAD).\n\t */\n\tp->set_child_tid = (clone_flags & CLONE_CHILD_SETTID) ? args->child_tid : NULL;\n\t/*\n\t * Clear TID on mm_release()?\n\t */\n\tp->clear_child_tid = (clone_flags & CLONE_CHILD_CLEARTID) ? args->child_tid : NULL;\n\n\tftrace_graph_init_task(p);\n\n\trt_mutex_init_task(p);\n\n\tlockdep_assert_irqs_enabled();\n#ifdef CONFIG_PROVE_LOCKING\n\tDEBUG_LOCKS_WARN_ON(!p->softirqs_enabled);\n#endif\n\tretval = -EAGAIN;\n\tif (atomic_read(&p->real_cred->user->processes) >=\n\t\t\ttask_rlimit(p, RLIMIT_NPROC)) {\n\t\tif (p->real_cred->user != INIT_USER &&\n\t\t    !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN))\n\t\t\tgoto bad_fork_free;\n\t}\n\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\tretval = copy_creds(p, clone_flags);\n\tif (retval < 0)\n\t\tgoto bad_fork_free;\n\n\t/*\n\t * If multiple threads are within copy_process(), then this check\n\t * triggers too late. This doesn't hurt, the check is only there\n\t * to stop root fork bombs.\n\t */\n\tretval = -EAGAIN;\n\tif (data_race(nr_threads >= max_threads))\n\t\tgoto bad_fork_cleanup_count;\n\n\tdelayacct_tsk_init(p);\t/* Must remain after dup_task_struct() */\n\tp->flags &= ~(PF_SUPERPRIV | PF_WQ_WORKER | PF_IDLE);\n\tp->flags |= PF_FORKNOEXEC;\n\tINIT_LIST_HEAD(&p->children);\n\tINIT_LIST_HEAD(&p->sibling);\n\trcu_copy_process(p);\n\tp->vfork_done = NULL;\n\tspin_lock_init(&p->alloc_lock);\n\n\tinit_sigpending(&p->pending);\n\n\tp->utime = p->stime = p->gtime = 0;\n#ifdef CONFIG_ARCH_HAS_SCALED_CPUTIME\n\tp->utimescaled = p->stimescaled = 0;\n#endif\n\tprev_cputime_init(&p->prev_cputime);\n\n#ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN\n\tseqcount_init(&p->vtime.seqcount);\n\tp->vtime.starttime = 0;\n\tp->vtime.state = VTIME_INACTIVE;\n#endif\n\n#ifdef CONFIG_IO_URING\n\tp->io_uring = NULL;\n#endif\n\n#if defined(SPLIT_RSS_COUNTING)\n\tmemset(&p->rss_stat, 0, sizeof(p->rss_stat));\n#endif\n\n\tp->default_timer_slack_ns = current->timer_slack_ns;\n\n#ifdef CONFIG_PSI\n\tp->psi_flags = 0;\n#endif\n\n\ttask_io_accounting_init(&p->ioac);\n\tacct_clear_integrals(p);\n\n\tposix_cputimers_init(&p->posix_cputimers);\n\n\tp->io_context = NULL;\n\taudit_set_context(p, NULL);\n\tcgroup_fork(p);\n#ifdef CONFIG_NUMA\n\tp->mempolicy = mpol_dup(p->mempolicy);\n\tif (IS_ERR(p->mempolicy)) {\n\t\tretval = PTR_ERR(p->mempolicy);\n\t\tp->mempolicy = NULL;\n\t\tgoto bad_fork_cleanup_threadgroup_lock;\n\t}\n#endif\n#ifdef CONFIG_CPUSETS\n\tp->cpuset_mem_spread_rotor = NUMA_NO_NODE;\n\tp->cpuset_slab_spread_rotor = NUMA_NO_NODE;\n\tseqcount_spinlock_init(&p->mems_allowed_seq, &p->alloc_lock);\n#endif\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tmemset(&p->irqtrace, 0, sizeof(p->irqtrace));\n\tp->irqtrace.hardirq_disable_ip\t= _THIS_IP_;\n\tp->irqtrace.softirq_enable_ip\t= _THIS_IP_;\n\tp->softirqs_enabled\t\t= 1;\n\tp->softirq_context\t\t= 0;\n#endif\n\n\tp->pagefault_disabled = 0;\n\n#ifdef CONFIG_LOCKDEP\n\tlockdep_init_task(p);\n#endif\n\n#ifdef CONFIG_DEBUG_MUTEXES\n\tp->blocked_on = NULL; /* not blocked yet */\n#endif\n#ifdef CONFIG_BCACHE\n\tp->sequential_io\t= 0;\n\tp->sequential_io_avg\t= 0;\n#endif\n\n\t/* Perform scheduler related setup. Assign this task to a CPU. */\n\tretval = sched_fork(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_policy;\n\n\tretval = perf_event_init_task(p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_policy;\n\tretval = audit_alloc(p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_perf;\n\t/* copy all the process information */\n\tshm_init_task(p);\n\tretval = security_task_alloc(p, clone_flags);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_audit;\n\tretval = copy_semundo(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_security;\n\tretval = copy_files(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_semundo;\n\tretval = copy_fs(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_files;\n\tretval = copy_sighand(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_fs;\n\tretval = copy_signal(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_sighand;\n\tretval = copy_mm(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_signal;\n\tretval = copy_namespaces(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_mm;\n\tretval = copy_io(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_namespaces;\n\tretval = copy_thread(clone_flags, args->stack, args->stack_size, p, args->tls);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_io;\n\n\tstackleak_task_init(p);\n\n\tif (pid != &init_struct_pid) {\n\t\tpid = alloc_pid(p->nsproxy->pid_ns_for_children, args->set_tid,\n\t\t\t\targs->set_tid_size);\n\t\tif (IS_ERR(pid)) {\n\t\t\tretval = PTR_ERR(pid);\n\t\t\tgoto bad_fork_cleanup_thread;\n\t\t}\n\t}\n\n\t/*\n\t * This has to happen after we've potentially unshared the file\n\t * descriptor table (so that the pidfd doesn't leak into the child\n\t * if the fd table isn't shared).\n\t */\n\tif (clone_flags & CLONE_PIDFD) {\n\t\tretval = get_unused_fd_flags(O_RDWR | O_CLOEXEC);\n\t\tif (retval < 0)\n\t\t\tgoto bad_fork_free_pid;\n\n\t\tpidfd = retval;\n\n\t\tpidfile = anon_inode_getfile(\"[pidfd]\", &pidfd_fops, pid,\n\t\t\t\t\t      O_RDWR | O_CLOEXEC);\n\t\tif (IS_ERR(pidfile)) {\n\t\t\tput_unused_fd(pidfd);\n\t\t\tretval = PTR_ERR(pidfile);\n\t\t\tgoto bad_fork_free_pid;\n\t\t}\n\t\tget_pid(pid);\t/* held by pidfile now */\n\n\t\tretval = put_user(pidfd, args->pidfd);\n\t\tif (retval)\n\t\t\tgoto bad_fork_put_pidfd;\n\t}\n\n#ifdef CONFIG_BLOCK\n\tp->plug = NULL;\n#endif\n\tfutex_init_task(p);\n\n\t/*\n\t * sigaltstack should be cleared when sharing the same VM\n\t */\n\tif ((clone_flags & (CLONE_VM|CLONE_VFORK)) == CLONE_VM)\n\t\tsas_ss_reset(p);\n\n\t/*\n\t * Syscall tracing and stepping should be turned off in the\n\t * child regardless of CLONE_PTRACE.\n\t */\n\tuser_disable_single_step(p);\n\tclear_tsk_thread_flag(p, TIF_SYSCALL_TRACE);\n#ifdef TIF_SYSCALL_EMU\n\tclear_tsk_thread_flag(p, TIF_SYSCALL_EMU);\n#endif\n\tclear_tsk_latency_tracing(p);\n\n\t/* ok, now we should be set up.. */\n\tp->pid = pid_nr(pid);\n\tif (clone_flags & CLONE_THREAD) {\n\t\tp->exit_signal = -1;\n\t\tp->group_leader = current->group_leader;\n\t\tp->tgid = current->tgid;\n\t} else {\n\t\tif (clone_flags & CLONE_PARENT)\n\t\t\tp->exit_signal = current->group_leader->exit_signal;\n\t\telse\n\t\t\tp->exit_signal = args->exit_signal;\n\t\tp->group_leader = p;\n\t\tp->tgid = p->pid;\n\t}\n\n\tp->nr_dirtied = 0;\n\tp->nr_dirtied_pause = 128 >> (PAGE_SHIFT - 10);\n\tp->dirty_paused_when = 0;\n\n\tp->pdeath_signal = 0;\n\tINIT_LIST_HEAD(&p->thread_group);\n\tp->task_works = NULL;\n\n\t/*\n\t * Ensure that the cgroup subsystem policies allow the new process to be\n\t * forked. It should be noted that the new process's css_set can be changed\n\t * between here and cgroup_post_fork() if an organisation operation is in\n\t * progress.\n\t */\n\tretval = cgroup_can_fork(p, args);\n\tif (retval)\n\t\tgoto bad_fork_put_pidfd;\n\n\t/*\n\t * From this point on we must avoid any synchronous user-space\n\t * communication until we take the tasklist-lock. In particular, we do\n\t * not want user-space to be able to predict the process start-time by\n\t * stalling fork(2) after we recorded the start_time but before it is\n\t * visible to the system.\n\t */\n\n\tp->start_time = ktime_get_ns();\n\tp->start_boottime = ktime_get_boottime_ns();\n\n\t/*\n\t * Make it visible to the rest of the system, but dont wake it up yet.\n\t * Need tasklist lock for parent etc handling!\n\t */\n\twrite_lock_irq(&tasklist_lock);\n\n\t/* CLONE_PARENT re-uses the old parent */\n\tif (clone_flags & (CLONE_PARENT|CLONE_THREAD)) {\n\t\tp->real_parent = current->real_parent;\n\t\tp->parent_exec_id = current->parent_exec_id;\n\t} else {\n\t\tp->real_parent = current;\n\t\tp->parent_exec_id = current->self_exec_id;\n\t}\n\n\tklp_copy_process(p);\n\n\tspin_lock(&current->sighand->siglock);\n\n\t/*\n\t * Copy seccomp details explicitly here, in case they were changed\n\t * before holding sighand lock.\n\t */\n\tcopy_seccomp(p);\n\n\trseq_fork(p, clone_flags);\n\n\t/* Don't start children in a dying pid namespace */\n\tif (unlikely(!(ns_of_pid(pid)->pid_allocated & PIDNS_ADDING))) {\n\t\tretval = -ENOMEM;\n\t\tgoto bad_fork_cancel_cgroup;\n\t}\n\n\t/* Let kill terminate clone/fork in the middle */\n\tif (fatal_signal_pending(current)) {\n\t\tretval = -EINTR;\n\t\tgoto bad_fork_cancel_cgroup;\n\t}\n\n\t/* past the last point of failure */\n\tif (pidfile)\n\t\tfd_install(pidfd, pidfile);\n\n\tinit_task_pid_links(p);\n\tif (likely(p->pid)) {\n\t\tptrace_init_task(p, (clone_flags & CLONE_PTRACE) || trace);\n\n\t\tinit_task_pid(p, PIDTYPE_PID, pid);\n\t\tif (thread_group_leader(p)) {\n\t\t\tinit_task_pid(p, PIDTYPE_TGID, pid);\n\t\t\tinit_task_pid(p, PIDTYPE_PGID, task_pgrp(current));\n\t\t\tinit_task_pid(p, PIDTYPE_SID, task_session(current));\n\n\t\t\tif (is_child_reaper(pid)) {\n\t\t\t\tns_of_pid(pid)->child_reaper = p;\n\t\t\t\tp->signal->flags |= SIGNAL_UNKILLABLE;\n\t\t\t}\n\t\t\tp->signal->shared_pending.signal = delayed.signal;\n\t\t\tp->signal->tty = tty_kref_get(current->signal->tty);\n\t\t\t/*\n\t\t\t * Inherit has_child_subreaper flag under the same\n\t\t\t * tasklist_lock with adding child to the process tree\n\t\t\t * for propagate_has_child_subreaper optimization.\n\t\t\t */\n\t\t\tp->signal->has_child_subreaper = p->real_parent->signal->has_child_subreaper ||\n\t\t\t\t\t\t\t p->real_parent->signal->is_child_subreaper;\n\t\t\tlist_add_tail(&p->sibling, &p->real_parent->children);\n\t\t\tlist_add_tail_rcu(&p->tasks, &init_task.tasks);\n\t\t\tattach_pid(p, PIDTYPE_TGID);\n\t\t\tattach_pid(p, PIDTYPE_PGID);\n\t\t\tattach_pid(p, PIDTYPE_SID);\n\t\t\t__this_cpu_inc(process_counts);\n\t\t} else {\n\t\t\tcurrent->signal->nr_threads++;\n\t\t\tatomic_inc(&current->signal->live);\n\t\t\trefcount_inc(&current->signal->sigcnt);\n\t\t\ttask_join_group_stop(p);\n\t\t\tlist_add_tail_rcu(&p->thread_group,\n\t\t\t\t\t  &p->group_leader->thread_group);\n\t\t\tlist_add_tail_rcu(&p->thread_node,\n\t\t\t\t\t  &p->signal->thread_head);\n\t\t}\n\t\tattach_pid(p, PIDTYPE_PID);\n\t\tnr_threads++;\n\t}\n\ttotal_forks++;\n\thlist_del_init(&delayed.node);\n\tspin_unlock(&current->sighand->siglock);\n\tsyscall_tracepoint_update(p);\n\twrite_unlock_irq(&tasklist_lock);\n\n\tproc_fork_connector(p);\n\tsched_post_fork(p);\n\tcgroup_post_fork(p, args);\n\tperf_event_fork(p);\n\n\ttrace_task_newtask(p, clone_flags);\n\tuprobe_copy_process(p, clone_flags);\n\n\tcopy_oom_score_adj(clone_flags, p);\n\n\treturn p;\n\nbad_fork_cancel_cgroup:\n\tspin_unlock(&current->sighand->siglock);\n\twrite_unlock_irq(&tasklist_lock);\n\tcgroup_cancel_fork(p, args);\nbad_fork_put_pidfd:\n\tif (clone_flags & CLONE_PIDFD) {\n\t\tfput(pidfile);\n\t\tput_unused_fd(pidfd);\n\t}\nbad_fork_free_pid:\n\tif (pid != &init_struct_pid)\n\t\tfree_pid(pid);\nbad_fork_cleanup_thread:\n\texit_thread(p);\nbad_fork_cleanup_io:\n\tif (p->io_context)\n\t\texit_io_context(p);\nbad_fork_cleanup_namespaces:\n\texit_task_namespaces(p);\nbad_fork_cleanup_mm:\n\tif (p->mm) {\n\t\tmm_clear_owner(p->mm, p);\n\t\tmmput(p->mm);\n\t}\nbad_fork_cleanup_signal:\n\tif (!(clone_flags & CLONE_THREAD))\n\t\tfree_signal_struct(p->signal);\nbad_fork_cleanup_sighand:\n\t__cleanup_sighand(p->sighand);\nbad_fork_cleanup_fs:\n\texit_fs(p); /* blocking */\nbad_fork_cleanup_files:\n\texit_files(p); /* blocking */\nbad_fork_cleanup_semundo:\n\texit_sem(p);\nbad_fork_cleanup_security:\n\tsecurity_task_free(p);\nbad_fork_cleanup_audit:\n\taudit_free(p);\nbad_fork_cleanup_perf:\n\tperf_event_free_task(p);\nbad_fork_cleanup_policy:\n\tlockdep_free_task(p);\n#ifdef CONFIG_NUMA\n\tmpol_put(p->mempolicy);\nbad_fork_cleanup_threadgroup_lock:\n#endif\n\tdelayacct_tsk_free(p);\nbad_fork_cleanup_count:\n\tatomic_dec(&p->cred->user->processes);\n\texit_creds(p);\nbad_fork_free:\n\tp->state = TASK_DEAD;\n\tput_task_stack(p);\n\tdelayed_free_task(p);\nfork_out:\n\tspin_lock_irq(&current->sighand->siglock);\n\thlist_del_init(&delayed.node);\n\tspin_unlock_irq(&current->sighand->siglock);\n\treturn ERR_PTR(retval);\n}",
        "func": "task_struct *copy_process(\n\t\t\t\t\tstruct pid *pid,\n\t\t\t\t\tint trace,\n\t\t\t\t\tint node,\n\t\t\t\t\tstruct kernel_clone_args *args)\n{\n\tint pidfd = -1, retval;\n\tstruct task_struct *p;\n\tstruct multiprocess_signals delayed;\n\tstruct file *pidfile = NULL;\n\tu64 clone_flags = args->flags;\n\tstruct nsproxy *nsp = current->nsproxy;\n\n\t/*\n\t * Don't allow sharing the root directory with processes in a different\n\t * namespace\n\t */\n\tif ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif ((clone_flags & (CLONE_NEWUSER|CLONE_FS)) == (CLONE_NEWUSER|CLONE_FS))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Thread groups must share signals as well, and detached threads\n\t * can only be started up within the thread group.\n\t */\n\tif ((clone_flags & CLONE_THREAD) && !(clone_flags & CLONE_SIGHAND))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Shared signal handlers imply shared VM. By way of the above,\n\t * thread groups also imply shared VM. Blocking this case allows\n\t * for various simplifications in other code.\n\t */\n\tif ((clone_flags & CLONE_SIGHAND) && !(clone_flags & CLONE_VM))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * Siblings of global init remain as zombies on exit since they are\n\t * not reaped by their parent (swapper). To solve this and to avoid\n\t * multi-rooted process trees, prevent global and container-inits\n\t * from creating siblings.\n\t */\n\tif ((clone_flags & CLONE_PARENT) &&\n\t\t\t\tcurrent->signal->flags & SIGNAL_UNKILLABLE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/*\n\t * If the new process will be in a different pid or user namespace\n\t * do not allow it to share a thread group with the forking task.\n\t */\n\tif (clone_flags & CLONE_THREAD) {\n\t\tif ((clone_flags & (CLONE_NEWUSER | CLONE_NEWPID)) ||\n\t\t    (task_active_pid_ns(current) != nsp->pid_ns_for_children))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/*\n\t * If the new process will be in a different time namespace\n\t * do not allow it to share VM or a thread group with the forking task.\n\t */\n\tif (clone_flags & (CLONE_THREAD | CLONE_VM)) {\n\t\tif (nsp->time_ns != nsp->time_ns_for_children)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (clone_flags & CLONE_PIDFD) {\n\t\t/*\n\t\t * - CLONE_DETACHED is blocked so that we can potentially\n\t\t *   reuse it later for CLONE_PIDFD.\n\t\t * - CLONE_THREAD is blocked until someone really needs it.\n\t\t */\n\t\tif (clone_flags & (CLONE_DETACHED | CLONE_THREAD))\n\t\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/*\n\t * Force any signals received before this point to be delivered\n\t * before the fork happens.  Collect up signals sent to multiple\n\t * processes that happen during the fork and delay them so that\n\t * they appear to happen after the fork.\n\t */\n\tsigemptyset(&delayed.signal);\n\tINIT_HLIST_NODE(&delayed.node);\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (!(clone_flags & CLONE_THREAD))\n\t\thlist_add_head(&delayed.node, &current->signal->multiprocess);\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n\tretval = -ERESTARTNOINTR;\n\tif (signal_pending(current))\n\t\tgoto fork_out;\n\n\tretval = -ENOMEM;\n\tp = dup_task_struct(current, node);\n\tif (!p)\n\t\tgoto fork_out;\n\n\t/*\n\t * This _must_ happen before we call free_task(), i.e. before we jump\n\t * to any of the bad_fork_* labels. This is to avoid freeing\n\t * p->set_child_tid which is (ab)used as a kthread's data pointer for\n\t * kernel threads (PF_KTHREAD).\n\t */\n\tp->set_child_tid = (clone_flags & CLONE_CHILD_SETTID) ? args->child_tid : NULL;\n\t/*\n\t * Clear TID on mm_release()?\n\t */\n\tp->clear_child_tid = (clone_flags & CLONE_CHILD_CLEARTID) ? args->child_tid : NULL;\n\n\tftrace_graph_init_task(p);\n\n\trt_mutex_init_task(p);\n\n\tlockdep_assert_irqs_enabled();\n#ifdef CONFIG_PROVE_LOCKING\n\tDEBUG_LOCKS_WARN_ON(!p->softirqs_enabled);\n#endif\n\tretval = -EAGAIN;\n\tif (atomic_read(&p->real_cred->user->processes) >=\n\t\t\ttask_rlimit(p, RLIMIT_NPROC)) {\n\t\tif (p->real_cred->user != INIT_USER &&\n\t\t    !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN))\n\t\t\tgoto bad_fork_free;\n\t}\n\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\tretval = copy_creds(p, clone_flags);\n\tif (retval < 0)\n\t\tgoto bad_fork_free;\n\n\t/*\n\t * If multiple threads are within copy_process(), then this check\n\t * triggers too late. This doesn't hurt, the check is only there\n\t * to stop root fork bombs.\n\t */\n\tretval = -EAGAIN;\n\tif (data_race(nr_threads >= max_threads))\n\t\tgoto bad_fork_cleanup_count;\n\n\tdelayacct_tsk_init(p);\t/* Must remain after dup_task_struct() */\n\tp->flags &= ~(PF_SUPERPRIV | PF_WQ_WORKER | PF_IDLE);\n\tp->flags |= PF_FORKNOEXEC;\n\tINIT_LIST_HEAD(&p->children);\n\tINIT_LIST_HEAD(&p->sibling);\n\trcu_copy_process(p);\n\tp->vfork_done = NULL;\n\tspin_lock_init(&p->alloc_lock);\n\n\tinit_sigpending(&p->pending);\n\n\tp->utime = p->stime = p->gtime = 0;\n#ifdef CONFIG_ARCH_HAS_SCALED_CPUTIME\n\tp->utimescaled = p->stimescaled = 0;\n#endif\n\tprev_cputime_init(&p->prev_cputime);\n\n#ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN\n\tseqcount_init(&p->vtime.seqcount);\n\tp->vtime.starttime = 0;\n\tp->vtime.state = VTIME_INACTIVE;\n#endif\n\n#ifdef CONFIG_IO_URING\n\tp->io_uring = NULL;\n#endif\n\n#if defined(SPLIT_RSS_COUNTING)\n\tmemset(&p->rss_stat, 0, sizeof(p->rss_stat));\n#endif\n\n\tp->default_timer_slack_ns = current->timer_slack_ns;\n\n#ifdef CONFIG_PSI\n\tp->psi_flags = 0;\n#endif\n\n\ttask_io_accounting_init(&p->ioac);\n\tacct_clear_integrals(p);\n\n\tposix_cputimers_init(&p->posix_cputimers);\n\n\tp->io_context = NULL;\n\taudit_set_context(p, NULL);\n\tcgroup_fork(p);\n#ifdef CONFIG_NUMA\n\tp->mempolicy = mpol_dup(p->mempolicy);\n\tif (IS_ERR(p->mempolicy)) {\n\t\tretval = PTR_ERR(p->mempolicy);\n\t\tp->mempolicy = NULL;\n\t\tgoto bad_fork_cleanup_threadgroup_lock;\n\t}\n#endif\n#ifdef CONFIG_CPUSETS\n\tp->cpuset_mem_spread_rotor = NUMA_NO_NODE;\n\tp->cpuset_slab_spread_rotor = NUMA_NO_NODE;\n\tseqcount_spinlock_init(&p->mems_allowed_seq, &p->alloc_lock);\n#endif\n#ifdef CONFIG_TRACE_IRQFLAGS\n\tmemset(&p->irqtrace, 0, sizeof(p->irqtrace));\n\tp->irqtrace.hardirq_disable_ip\t= _THIS_IP_;\n\tp->irqtrace.softirq_enable_ip\t= _THIS_IP_;\n\tp->softirqs_enabled\t\t= 1;\n\tp->softirq_context\t\t= 0;\n#endif\n\n\tp->pagefault_disabled = 0;\n\n#ifdef CONFIG_LOCKDEP\n\tlockdep_init_task(p);\n#endif\n\n#ifdef CONFIG_DEBUG_MUTEXES\n\tp->blocked_on = NULL; /* not blocked yet */\n#endif\n#ifdef CONFIG_BCACHE\n\tp->sequential_io\t= 0;\n\tp->sequential_io_avg\t= 0;\n#endif\n\n\t/* Perform scheduler related setup. Assign this task to a CPU. */\n\tretval = sched_fork(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_policy;\n\n\tretval = perf_event_init_task(p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_policy;\n\tretval = audit_alloc(p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_perf;\n\t/* copy all the process information */\n\tshm_init_task(p);\n\tretval = security_task_alloc(p, clone_flags);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_audit;\n\tretval = copy_semundo(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_security;\n\tretval = copy_files(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_semundo;\n\tretval = copy_fs(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_files;\n\tretval = copy_sighand(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_fs;\n\tretval = copy_signal(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_sighand;\n\tretval = copy_mm(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_signal;\n\tretval = copy_namespaces(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_mm;\n\tretval = copy_io(clone_flags, p);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_namespaces;\n\tretval = copy_thread(clone_flags, args->stack, args->stack_size, p, args->tls);\n\tif (retval)\n\t\tgoto bad_fork_cleanup_io;\n\n\tstackleak_task_init(p);\n\n\tif (pid != &init_struct_pid) {\n\t\tpid = alloc_pid(p->nsproxy->pid_ns_for_children, args->set_tid,\n\t\t\t\targs->set_tid_size);\n\t\tif (IS_ERR(pid)) {\n\t\t\tretval = PTR_ERR(pid);\n\t\t\tgoto bad_fork_cleanup_thread;\n\t\t}\n\t}\n\n\t/*\n\t * This has to happen after we've potentially unshared the file\n\t * descriptor table (so that the pidfd doesn't leak into the child\n\t * if the fd table isn't shared).\n\t */\n\tif (clone_flags & CLONE_PIDFD) {\n\t\tretval = get_unused_fd_flags(O_RDWR | O_CLOEXEC);\n\t\tif (retval < 0)\n\t\t\tgoto bad_fork_free_pid;\n\n\t\tpidfd = retval;\n\n\t\tpidfile = anon_inode_getfile(\"[pidfd]\", &pidfd_fops, pid,\n\t\t\t\t\t      O_RDWR | O_CLOEXEC);\n\t\tif (IS_ERR(pidfile)) {\n\t\t\tput_unused_fd(pidfd);\n\t\t\tretval = PTR_ERR(pidfile);\n\t\t\tgoto bad_fork_free_pid;\n\t\t}\n\t\tget_pid(pid);\t/* held by pidfile now */\n\n\t\tretval = put_user(pidfd, args->pidfd);\n\t\tif (retval)\n\t\t\tgoto bad_fork_put_pidfd;\n\t}\n\n#ifdef CONFIG_BLOCK\n\tp->plug = NULL;\n#endif\n\tfutex_init_task(p);\n\n\t/*\n\t * sigaltstack should be cleared when sharing the same VM\n\t */\n\tif ((clone_flags & (CLONE_VM|CLONE_VFORK)) == CLONE_VM)\n\t\tsas_ss_reset(p);\n\n\t/*\n\t * Syscall tracing and stepping should be turned off in the\n\t * child regardless of CLONE_PTRACE.\n\t */\n\tuser_disable_single_step(p);\n\tclear_tsk_thread_flag(p, TIF_SYSCALL_TRACE);\n#ifdef TIF_SYSCALL_EMU\n\tclear_tsk_thread_flag(p, TIF_SYSCALL_EMU);\n#endif\n\tclear_tsk_latency_tracing(p);\n\n\t/* ok, now we should be set up.. */\n\tp->pid = pid_nr(pid);\n\tif (clone_flags & CLONE_THREAD) {\n\t\tp->group_leader = current->group_leader;\n\t\tp->tgid = current->tgid;\n\t} else {\n\t\tp->group_leader = p;\n\t\tp->tgid = p->pid;\n\t}\n\n\tp->nr_dirtied = 0;\n\tp->nr_dirtied_pause = 128 >> (PAGE_SHIFT - 10);\n\tp->dirty_paused_when = 0;\n\n\tp->pdeath_signal = 0;\n\tINIT_LIST_HEAD(&p->thread_group);\n\tp->task_works = NULL;\n\n\t/*\n\t * Ensure that the cgroup subsystem policies allow the new process to be\n\t * forked. It should be noted that the new process's css_set can be changed\n\t * between here and cgroup_post_fork() if an organisation operation is in\n\t * progress.\n\t */\n\tretval = cgroup_can_fork(p, args);\n\tif (retval)\n\t\tgoto bad_fork_put_pidfd;\n\n\t/*\n\t * From this point on we must avoid any synchronous user-space\n\t * communication until we take the tasklist-lock. In particular, we do\n\t * not want user-space to be able to predict the process start-time by\n\t * stalling fork(2) after we recorded the start_time but before it is\n\t * visible to the system.\n\t */\n\n\tp->start_time = ktime_get_ns();\n\tp->start_boottime = ktime_get_boottime_ns();\n\n\t/*\n\t * Make it visible to the rest of the system, but dont wake it up yet.\n\t * Need tasklist lock for parent etc handling!\n\t */\n\twrite_lock_irq(&tasklist_lock);\n\n\t/* CLONE_PARENT re-uses the old parent */\n\tif (clone_flags & (CLONE_PARENT|CLONE_THREAD)) {\n\t\tp->real_parent = current->real_parent;\n\t\tp->parent_exec_id = current->parent_exec_id;\n\t\tif (clone_flags & CLONE_THREAD)\n\t\t\tp->exit_signal = -1;\n\t\telse\n\t\t\tp->exit_signal = current->group_leader->exit_signal;\n\t} else {\n\t\tp->real_parent = current;\n\t\tp->parent_exec_id = current->self_exec_id;\n\t\tp->exit_signal = args->exit_signal;\n\t}\n\n\tklp_copy_process(p);\n\n\tspin_lock(&current->sighand->siglock);\n\n\t/*\n\t * Copy seccomp details explicitly here, in case they were changed\n\t * before holding sighand lock.\n\t */\n\tcopy_seccomp(p);\n\n\trseq_fork(p, clone_flags);\n\n\t/* Don't start children in a dying pid namespace */\n\tif (unlikely(!(ns_of_pid(pid)->pid_allocated & PIDNS_ADDING))) {\n\t\tretval = -ENOMEM;\n\t\tgoto bad_fork_cancel_cgroup;\n\t}\n\n\t/* Let kill terminate clone/fork in the middle */\n\tif (fatal_signal_pending(current)) {\n\t\tretval = -EINTR;\n\t\tgoto bad_fork_cancel_cgroup;\n\t}\n\n\t/* past the last point of failure */\n\tif (pidfile)\n\t\tfd_install(pidfd, pidfile);\n\n\tinit_task_pid_links(p);\n\tif (likely(p->pid)) {\n\t\tptrace_init_task(p, (clone_flags & CLONE_PTRACE) || trace);\n\n\t\tinit_task_pid(p, PIDTYPE_PID, pid);\n\t\tif (thread_group_leader(p)) {\n\t\t\tinit_task_pid(p, PIDTYPE_TGID, pid);\n\t\t\tinit_task_pid(p, PIDTYPE_PGID, task_pgrp(current));\n\t\t\tinit_task_pid(p, PIDTYPE_SID, task_session(current));\n\n\t\t\tif (is_child_reaper(pid)) {\n\t\t\t\tns_of_pid(pid)->child_reaper = p;\n\t\t\t\tp->signal->flags |= SIGNAL_UNKILLABLE;\n\t\t\t}\n\t\t\tp->signal->shared_pending.signal = delayed.signal;\n\t\t\tp->signal->tty = tty_kref_get(current->signal->tty);\n\t\t\t/*\n\t\t\t * Inherit has_child_subreaper flag under the same\n\t\t\t * tasklist_lock with adding child to the process tree\n\t\t\t * for propagate_has_child_subreaper optimization.\n\t\t\t */\n\t\t\tp->signal->has_child_subreaper = p->real_parent->signal->has_child_subreaper ||\n\t\t\t\t\t\t\t p->real_parent->signal->is_child_subreaper;\n\t\t\tlist_add_tail(&p->sibling, &p->real_parent->children);\n\t\t\tlist_add_tail_rcu(&p->tasks, &init_task.tasks);\n\t\t\tattach_pid(p, PIDTYPE_TGID);\n\t\t\tattach_pid(p, PIDTYPE_PGID);\n\t\t\tattach_pid(p, PIDTYPE_SID);\n\t\t\t__this_cpu_inc(process_counts);\n\t\t} else {\n\t\t\tcurrent->signal->nr_threads++;\n\t\t\tatomic_inc(&current->signal->live);\n\t\t\trefcount_inc(&current->signal->sigcnt);\n\t\t\ttask_join_group_stop(p);\n\t\t\tlist_add_tail_rcu(&p->thread_group,\n\t\t\t\t\t  &p->group_leader->thread_group);\n\t\t\tlist_add_tail_rcu(&p->thread_node,\n\t\t\t\t\t  &p->signal->thread_head);\n\t\t}\n\t\tattach_pid(p, PIDTYPE_PID);\n\t\tnr_threads++;\n\t}\n\ttotal_forks++;\n\thlist_del_init(&delayed.node);\n\tspin_unlock(&current->sighand->siglock);\n\tsyscall_tracepoint_update(p);\n\twrite_unlock_irq(&tasklist_lock);\n\n\tproc_fork_connector(p);\n\tsched_post_fork(p);\n\tcgroup_post_fork(p, args);\n\tperf_event_fork(p);\n\n\ttrace_task_newtask(p, clone_flags);\n\tuprobe_copy_process(p, clone_flags);\n\n\tcopy_oom_score_adj(clone_flags, p);\n\n\treturn p;\n\nbad_fork_cancel_cgroup:\n\tspin_unlock(&current->sighand->siglock);\n\twrite_unlock_irq(&tasklist_lock);\n\tcgroup_cancel_fork(p, args);\nbad_fork_put_pidfd:\n\tif (clone_flags & CLONE_PIDFD) {\n\t\tfput(pidfile);\n\t\tput_unused_fd(pidfd);\n\t}\nbad_fork_free_pid:\n\tif (pid != &init_struct_pid)\n\t\tfree_pid(pid);\nbad_fork_cleanup_thread:\n\texit_thread(p);\nbad_fork_cleanup_io:\n\tif (p->io_context)\n\t\texit_io_context(p);\nbad_fork_cleanup_namespaces:\n\texit_task_namespaces(p);\nbad_fork_cleanup_mm:\n\tif (p->mm) {\n\t\tmm_clear_owner(p->mm, p);\n\t\tmmput(p->mm);\n\t}\nbad_fork_cleanup_signal:\n\tif (!(clone_flags & CLONE_THREAD))\n\t\tfree_signal_struct(p->signal);\nbad_fork_cleanup_sighand:\n\t__cleanup_sighand(p->sighand);\nbad_fork_cleanup_fs:\n\texit_fs(p); /* blocking */\nbad_fork_cleanup_files:\n\texit_files(p); /* blocking */\nbad_fork_cleanup_semundo:\n\texit_sem(p);\nbad_fork_cleanup_security:\n\tsecurity_task_free(p);\nbad_fork_cleanup_audit:\n\taudit_free(p);\nbad_fork_cleanup_perf:\n\tperf_event_free_task(p);\nbad_fork_cleanup_policy:\n\tlockdep_free_task(p);\n#ifdef CONFIG_NUMA\n\tmpol_put(p->mempolicy);\nbad_fork_cleanup_threadgroup_lock:\n#endif\n\tdelayacct_tsk_free(p);\nbad_fork_cleanup_count:\n\tatomic_dec(&p->cred->user->processes);\n\texit_creds(p);\nbad_fork_free:\n\tp->state = TASK_DEAD;\n\tput_task_stack(p);\n\tdelayed_free_task(p);\nfork_out:\n\tspin_lock_irq(&current->sighand->siglock);\n\thlist_del_init(&delayed.node);\n\tspin_unlock_irq(&current->sighand->siglock);\n\treturn ERR_PTR(retval);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -326,14 +326,9 @@\n \t/* ok, now we should be set up.. */\n \tp->pid = pid_nr(pid);\n \tif (clone_flags & CLONE_THREAD) {\n-\t\tp->exit_signal = -1;\n \t\tp->group_leader = current->group_leader;\n \t\tp->tgid = current->tgid;\n \t} else {\n-\t\tif (clone_flags & CLONE_PARENT)\n-\t\t\tp->exit_signal = current->group_leader->exit_signal;\n-\t\telse\n-\t\t\tp->exit_signal = args->exit_signal;\n \t\tp->group_leader = p;\n \t\tp->tgid = p->pid;\n \t}\n@@ -377,9 +372,14 @@\n \tif (clone_flags & (CLONE_PARENT|CLONE_THREAD)) {\n \t\tp->real_parent = current->real_parent;\n \t\tp->parent_exec_id = current->parent_exec_id;\n+\t\tif (clone_flags & CLONE_THREAD)\n+\t\t\tp->exit_signal = -1;\n+\t\telse\n+\t\t\tp->exit_signal = current->group_leader->exit_signal;\n \t} else {\n \t\tp->real_parent = current;\n \t\tp->parent_exec_id = current->self_exec_id;\n+\t\tp->exit_signal = args->exit_signal;\n \t}\n \n \tklp_copy_process(p);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tp->exit_signal = -1;",
                "\t\tif (clone_flags & CLONE_PARENT)",
                "\t\t\tp->exit_signal = current->group_leader->exit_signal;",
                "\t\telse",
                "\t\t\tp->exit_signal = args->exit_signal;"
            ],
            "added_lines": [
                "\t\tif (clone_flags & CLONE_THREAD)",
                "\t\t\tp->exit_signal = -1;",
                "\t\telse",
                "\t\t\tp->exit_signal = current->group_leader->exit_signal;",
                "\t\tp->exit_signal = args->exit_signal;"
            ]
        }
    }
]