[
    {
        "cve_id": "CVE-2019-18420",
        "func_name": "xen-project/xen/hypercall_create_continuation",
        "description": "An issue was discovered in Xen through 4.12.x allowing x86 PV guest OS users to cause a denial of service via a VCPUOP_initialise hypercall. hypercall_create_continuation() is a variadic function which uses a printf-like format string to interpret its parameters. Error handling for a bad format character was done using BUG(), which crashes Xen. One path, via the VCPUOP_initialise hypercall, has a bad format character. The BUG() can be hit if VCPUOP_initialise executes for a sufficiently long period of time for a continuation to be created. Malicious guests may cause a hypervisor crash, resulting in a Denial of Service (DoS). Xen versions 4.6 and newer are vulnerable. Xen versions 4.5 and earlier are not vulnerable. Only x86 PV guests can exploit the vulnerability. HVM and PVH guests, and guests on ARM systems, cannot exploit the vulnerability.",
        "git_url": "https://github.com/xen-project/xen/commit/0bf9f8d3e399a0e1d2b717f71b4776172446184b",
        "commit_title": "xen/hypercall: Don't use BUG() for parameter checking in hypercall_create_continuation()",
        "commit_text": " Since c/s 1d429034 \"hypercall: update vcpu_op to take an unsigned vcpuid\", which incorrectly swapped 'i' for 'u' in the parameter type list, guests have been able to hit the BUG() in next_args()'s default case.  Correct these back to 'i'.  In addition, make adjustments to prevent this class of issue from occurring in the future - crashing Xen is not an appropriate form of parameter checking.  Capitalise NEXT_ARG() to catch all uses, to highlight that it is a macro doing non-function-like things behind the scenes, and undef it when appropriate. Implement a bad_fmt: block which prints an error, asserts unreachable, and crashes the guest.  On the ARM side, drop all parameter checking of p.  It is asymmetric with the x86 side, and akin to expecting memcpy() or sprintf() to check their src/fmt parameter before use.  A caller passing \"\" or something other than a string literal will be obvious during code review.  This is XSA-296. ",
        "func_before": "unsigned long hypercall_create_continuation(\n    unsigned int op, const char *format, ...)\n{\n    struct vcpu *curr = current;\n    struct mc_state *mcs = &curr->mc_state;\n    const char *p = format;\n    unsigned long arg;\n    unsigned int i;\n    va_list args;\n\n    curr->hcall_preempted = true;\n\n    va_start(args, format);\n\n    if ( mcs->flags & MCSF_in_multicall )\n    {\n        for ( i = 0; *p != '\\0'; i++ )\n            mcs->call.args[i] = next_arg(p, args);\n    }\n    else\n    {\n        struct cpu_user_regs *regs = guest_cpu_user_regs();\n\n        regs->rax = op;\n\n        if ( !curr->hcall_compat )\n        {\n            for ( i = 0; *p != '\\0'; i++ )\n            {\n                arg = next_arg(p, args);\n                switch ( i )\n                {\n                case 0: regs->rdi = arg; break;\n                case 1: regs->rsi = arg; break;\n                case 2: regs->rdx = arg; break;\n                case 3: regs->r10 = arg; break;\n                case 4: regs->r8  = arg; break;\n                case 5: regs->r9  = arg; break;\n                }\n            }\n        }\n        else\n        {\n            for ( i = 0; *p != '\\0'; i++ )\n            {\n                arg = next_arg(p, args);\n                switch ( i )\n                {\n                case 0: regs->rbx = arg; break;\n                case 1: regs->rcx = arg; break;\n                case 2: regs->rdx = arg; break;\n                case 3: regs->rsi = arg; break;\n                case 4: regs->rdi = arg; break;\n                case 5: regs->rbp = arg; break;\n                }\n            }\n        }\n    }\n\n    va_end(args);\n\n    return op;\n}",
        "func": "unsigned long hypercall_create_continuation(\n    unsigned int op, const char *format, ...)\n{\n    struct vcpu *curr = current;\n    struct mc_state *mcs = &curr->mc_state;\n    const char *p = format;\n    unsigned long arg;\n    unsigned int i;\n    va_list args;\n\n    curr->hcall_preempted = true;\n\n    va_start(args, format);\n\n    if ( mcs->flags & MCSF_in_multicall )\n    {\n        for ( i = 0; *p != '\\0'; i++ )\n            mcs->call.args[i] = NEXT_ARG(p, args);\n    }\n    else\n    {\n        struct cpu_user_regs *regs = guest_cpu_user_regs();\n\n        regs->rax = op;\n\n        if ( !curr->hcall_compat )\n        {\n            for ( i = 0; *p != '\\0'; i++ )\n            {\n                arg = NEXT_ARG(p, args);\n                switch ( i )\n                {\n                case 0: regs->rdi = arg; break;\n                case 1: regs->rsi = arg; break;\n                case 2: regs->rdx = arg; break;\n                case 3: regs->r10 = arg; break;\n                case 4: regs->r8  = arg; break;\n                case 5: regs->r9  = arg; break;\n                }\n            }\n        }\n        else\n        {\n            for ( i = 0; *p != '\\0'; i++ )\n            {\n                arg = NEXT_ARG(p, args);\n                switch ( i )\n                {\n                case 0: regs->rbx = arg; break;\n                case 1: regs->rcx = arg; break;\n                case 2: regs->rdx = arg; break;\n                case 3: regs->rsi = arg; break;\n                case 4: regs->rdi = arg; break;\n                case 5: regs->rbp = arg; break;\n                }\n            }\n        }\n    }\n\n    va_end(args);\n\n    return op;\n\n bad_fmt:\n    gprintk(XENLOG_ERR, \"Bad hypercall continuation format '%c'\\n\", *p);\n    ASSERT_UNREACHABLE();\n    domain_crash(curr->domain);\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,7 @@\n     if ( mcs->flags & MCSF_in_multicall )\n     {\n         for ( i = 0; *p != '\\0'; i++ )\n-            mcs->call.args[i] = next_arg(p, args);\n+            mcs->call.args[i] = NEXT_ARG(p, args);\n     }\n     else\n     {\n@@ -27,7 +27,7 @@\n         {\n             for ( i = 0; *p != '\\0'; i++ )\n             {\n-                arg = next_arg(p, args);\n+                arg = NEXT_ARG(p, args);\n                 switch ( i )\n                 {\n                 case 0: regs->rdi = arg; break;\n@@ -43,7 +43,7 @@\n         {\n             for ( i = 0; *p != '\\0'; i++ )\n             {\n-                arg = next_arg(p, args);\n+                arg = NEXT_ARG(p, args);\n                 switch ( i )\n                 {\n                 case 0: regs->rbx = arg; break;\n@@ -60,4 +60,10 @@\n     va_end(args);\n \n     return op;\n+\n+ bad_fmt:\n+    gprintk(XENLOG_ERR, \"Bad hypercall continuation format '%c'\\n\", *p);\n+    ASSERT_UNREACHABLE();\n+    domain_crash(curr->domain);\n+    return 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "            mcs->call.args[i] = next_arg(p, args);",
                "                arg = next_arg(p, args);",
                "                arg = next_arg(p, args);"
            ],
            "added_lines": [
                "            mcs->call.args[i] = NEXT_ARG(p, args);",
                "                arg = NEXT_ARG(p, args);",
                "                arg = NEXT_ARG(p, args);",
                "",
                " bad_fmt:",
                "    gprintk(XENLOG_ERR, \"Bad hypercall continuation format '%c'\\n\", *p);",
                "    ASSERT_UNREACHABLE();",
                "    domain_crash(curr->domain);",
                "    return 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18420",
        "func_name": "xen-project/xen/hypercall_create_continuation",
        "description": "An issue was discovered in Xen through 4.12.x allowing x86 PV guest OS users to cause a denial of service via a VCPUOP_initialise hypercall. hypercall_create_continuation() is a variadic function which uses a printf-like format string to interpret its parameters. Error handling for a bad format character was done using BUG(), which crashes Xen. One path, via the VCPUOP_initialise hypercall, has a bad format character. The BUG() can be hit if VCPUOP_initialise executes for a sufficiently long period of time for a continuation to be created. Malicious guests may cause a hypervisor crash, resulting in a Denial of Service (DoS). Xen versions 4.6 and newer are vulnerable. Xen versions 4.5 and earlier are not vulnerable. Only x86 PV guests can exploit the vulnerability. HVM and PVH guests, and guests on ARM systems, cannot exploit the vulnerability.",
        "git_url": "https://github.com/xen-project/xen/commit/0bf9f8d3e399a0e1d2b717f71b4776172446184b",
        "commit_title": "xen/hypercall: Don't use BUG() for parameter checking in hypercall_create_continuation()",
        "commit_text": " Since c/s 1d429034 \"hypercall: update vcpu_op to take an unsigned vcpuid\", which incorrectly swapped 'i' for 'u' in the parameter type list, guests have been able to hit the BUG() in next_args()'s default case.  Correct these back to 'i'.  In addition, make adjustments to prevent this class of issue from occurring in the future - crashing Xen is not an appropriate form of parameter checking.  Capitalise NEXT_ARG() to catch all uses, to highlight that it is a macro doing non-function-like things behind the scenes, and undef it when appropriate. Implement a bad_fmt: block which prints an error, asserts unreachable, and crashes the guest.  On the ARM side, drop all parameter checking of p.  It is asymmetric with the x86 side, and akin to expecting memcpy() or sprintf() to check their src/fmt parameter before use.  A caller passing \"\" or something other than a string literal will be obvious during code review.  This is XSA-296. ",
        "func_before": "unsigned long hypercall_create_continuation(\n    unsigned int op, const char *format, ...)\n{\n    struct mc_state *mcs = &current->mc_state;\n    struct cpu_user_regs *regs;\n    const char *p = format;\n    unsigned long arg, rc;\n    unsigned int i;\n    va_list args;\n\n    /* All hypercalls take at least one argument */\n    BUG_ON( !p || *p == '\\0' );\n\n    current->hcall_preempted = true;\n\n    va_start(args, format);\n\n    if ( mcs->flags & MCSF_in_multicall )\n    {\n        for ( i = 0; *p != '\\0'; i++ )\n            mcs->call.args[i] = next_arg(p, args);\n\n        /* Return value gets written back to mcs->call.result */\n        rc = mcs->call.result;\n    }\n    else\n    {\n        regs = guest_cpu_user_regs();\n\n#ifdef CONFIG_ARM_64\n        if ( !is_32bit_domain(current->domain) )\n        {\n            regs->x16 = op;\n\n            for ( i = 0; *p != '\\0'; i++ )\n            {\n                arg = next_arg(p, args);\n\n                switch ( i )\n                {\n                case 0: regs->x0 = arg; break;\n                case 1: regs->x1 = arg; break;\n                case 2: regs->x2 = arg; break;\n                case 3: regs->x3 = arg; break;\n                case 4: regs->x4 = arg; break;\n                case 5: regs->x5 = arg; break;\n                }\n            }\n\n            /* Return value gets written back to x0 */\n            rc = regs->x0;\n        }\n        else\n#endif\n        {\n            regs->r12 = op;\n\n            for ( i = 0; *p != '\\0'; i++ )\n            {\n                arg = next_arg(p, args);\n\n                switch ( i )\n                {\n                case 0: regs->r0 = arg; break;\n                case 1: regs->r1 = arg; break;\n                case 2: regs->r2 = arg; break;\n                case 3: regs->r3 = arg; break;\n                case 4: regs->r4 = arg; break;\n                case 5: regs->r5 = arg; break;\n                }\n            }\n\n            /* Return value gets written back to r0 */\n            rc = regs->r0;\n        }\n    }\n\n    va_end(args);\n\n    return rc;\n}",
        "func": "unsigned long hypercall_create_continuation(\n    unsigned int op, const char *format, ...)\n{\n    struct mc_state *mcs = &current->mc_state;\n    struct cpu_user_regs *regs;\n    const char *p = format;\n    unsigned long arg, rc;\n    unsigned int i;\n    va_list args;\n\n    current->hcall_preempted = true;\n\n    va_start(args, format);\n\n    if ( mcs->flags & MCSF_in_multicall )\n    {\n        for ( i = 0; *p != '\\0'; i++ )\n            mcs->call.args[i] = NEXT_ARG(p, args);\n\n        /* Return value gets written back to mcs->call.result */\n        rc = mcs->call.result;\n    }\n    else\n    {\n        regs = guest_cpu_user_regs();\n\n#ifdef CONFIG_ARM_64\n        if ( !is_32bit_domain(current->domain) )\n        {\n            regs->x16 = op;\n\n            for ( i = 0; *p != '\\0'; i++ )\n            {\n                arg = NEXT_ARG(p, args);\n\n                switch ( i )\n                {\n                case 0: regs->x0 = arg; break;\n                case 1: regs->x1 = arg; break;\n                case 2: regs->x2 = arg; break;\n                case 3: regs->x3 = arg; break;\n                case 4: regs->x4 = arg; break;\n                case 5: regs->x5 = arg; break;\n                }\n            }\n\n            /* Return value gets written back to x0 */\n            rc = regs->x0;\n        }\n        else\n#endif\n        {\n            regs->r12 = op;\n\n            for ( i = 0; *p != '\\0'; i++ )\n            {\n                arg = NEXT_ARG(p, args);\n\n                switch ( i )\n                {\n                case 0: regs->r0 = arg; break;\n                case 1: regs->r1 = arg; break;\n                case 2: regs->r2 = arg; break;\n                case 3: regs->r3 = arg; break;\n                case 4: regs->r4 = arg; break;\n                case 5: regs->r5 = arg; break;\n                }\n            }\n\n            /* Return value gets written back to r0 */\n            rc = regs->r0;\n        }\n    }\n\n    va_end(args);\n\n    return rc;\n\n bad_fmt:\n    gprintk(XENLOG_ERR, \"Bad hypercall continuation format '%c'\\n\", *p);\n    ASSERT_UNREACHABLE();\n    domain_crash(current->domain);\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,9 +8,6 @@\n     unsigned int i;\n     va_list args;\n \n-    /* All hypercalls take at least one argument */\n-    BUG_ON( !p || *p == '\\0' );\n-\n     current->hcall_preempted = true;\n \n     va_start(args, format);\n@@ -18,7 +15,7 @@\n     if ( mcs->flags & MCSF_in_multicall )\n     {\n         for ( i = 0; *p != '\\0'; i++ )\n-            mcs->call.args[i] = next_arg(p, args);\n+            mcs->call.args[i] = NEXT_ARG(p, args);\n \n         /* Return value gets written back to mcs->call.result */\n         rc = mcs->call.result;\n@@ -34,7 +31,7 @@\n \n             for ( i = 0; *p != '\\0'; i++ )\n             {\n-                arg = next_arg(p, args);\n+                arg = NEXT_ARG(p, args);\n \n                 switch ( i )\n                 {\n@@ -57,7 +54,7 @@\n \n             for ( i = 0; *p != '\\0'; i++ )\n             {\n-                arg = next_arg(p, args);\n+                arg = NEXT_ARG(p, args);\n \n                 switch ( i )\n                 {\n@@ -78,4 +75,10 @@\n     va_end(args);\n \n     return rc;\n+\n+ bad_fmt:\n+    gprintk(XENLOG_ERR, \"Bad hypercall continuation format '%c'\\n\", *p);\n+    ASSERT_UNREACHABLE();\n+    domain_crash(current->domain);\n+    return 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    /* All hypercalls take at least one argument */",
                "    BUG_ON( !p || *p == '\\0' );",
                "",
                "            mcs->call.args[i] = next_arg(p, args);",
                "                arg = next_arg(p, args);",
                "                arg = next_arg(p, args);"
            ],
            "added_lines": [
                "            mcs->call.args[i] = NEXT_ARG(p, args);",
                "                arg = NEXT_ARG(p, args);",
                "                arg = NEXT_ARG(p, args);",
                "",
                " bad_fmt:",
                "    gprintk(XENLOG_ERR, \"Bad hypercall continuation format '%c'\\n\", *p);",
                "    ASSERT_UNREACHABLE();",
                "    domain_crash(current->domain);",
                "    return 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18420",
        "func_name": "xen-project/xen/hypercall_create_continuation",
        "description": "An issue was discovered in Xen through 4.12.x allowing x86 PV guest OS users to cause a denial of service via a VCPUOP_initialise hypercall. hypercall_create_continuation() is a variadic function which uses a printf-like format string to interpret its parameters. Error handling for a bad format character was done using BUG(), which crashes Xen. One path, via the VCPUOP_initialise hypercall, has a bad format character. The BUG() can be hit if VCPUOP_initialise executes for a sufficiently long period of time for a continuation to be created. Malicious guests may cause a hypervisor crash, resulting in a Denial of Service (DoS). Xen versions 4.6 and newer are vulnerable. Xen versions 4.5 and earlier are not vulnerable. Only x86 PV guests can exploit the vulnerability. HVM and PVH guests, and guests on ARM systems, cannot exploit the vulnerability.",
        "git_url": "https://github.com/xen-project/xen/commit/0bf9f8d3e399a0e1d2b717f71b4776172446184b",
        "commit_title": "xen/hypercall: Don't use BUG() for parameter checking in hypercall_create_continuation()",
        "commit_text": " Since c/s 1d429034 \"hypercall: update vcpu_op to take an unsigned vcpuid\", which incorrectly swapped 'i' for 'u' in the parameter type list, guests have been able to hit the BUG() in next_args()'s default case.  Correct these back to 'i'.  In addition, make adjustments to prevent this class of issue from occurring in the future - crashing Xen is not an appropriate form of parameter checking.  Capitalise NEXT_ARG() to catch all uses, to highlight that it is a macro doing non-function-like things behind the scenes, and undef it when appropriate. Implement a bad_fmt: block which prints an error, asserts unreachable, and crashes the guest.  On the ARM side, drop all parameter checking of p.  It is asymmetric with the x86 side, and akin to expecting memcpy() or sprintf() to check their src/fmt parameter before use.  A caller passing \"\" or something other than a string literal will be obvious during code review.  This is XSA-296. ",
        "func_before": "unsigned long hypercall_create_continuation(\n    unsigned int op, const char *format, ...)\n{\n    struct mc_state *mcs = &current->mc_state;\n    struct cpu_user_regs *regs;\n    const char *p = format;\n    unsigned long arg, rc;\n    unsigned int i;\n    va_list args;\n\n    /* All hypercalls take at least one argument */\n    BUG_ON( !p || *p == '\\0' );\n\n    current->hcall_preempted = true;\n\n    va_start(args, format);\n\n    if ( mcs->flags & MCSF_in_multicall )\n    {\n        for ( i = 0; *p != '\\0'; i++ )\n            mcs->call.args[i] = next_arg(p, args);\n\n        /* Return value gets written back to mcs->call.result */\n        rc = mcs->call.result;\n    }\n    else\n    {\n        regs = guest_cpu_user_regs();\n\n#ifdef CONFIG_ARM_64\n        if ( !is_32bit_domain(current->domain) )\n        {\n            regs->x16 = op;\n\n            for ( i = 0; *p != '\\0'; i++ )\n            {\n                arg = next_arg(p, args);\n\n                switch ( i )\n                {\n                case 0: regs->x0 = arg; break;\n                case 1: regs->x1 = arg; break;\n                case 2: regs->x2 = arg; break;\n                case 3: regs->x3 = arg; break;\n                case 4: regs->x4 = arg; break;\n                case 5: regs->x5 = arg; break;\n                }\n            }\n\n            /* Return value gets written back to x0 */\n            rc = regs->x0;\n        }\n        else\n#endif\n        {\n            regs->r12 = op;\n\n            for ( i = 0; *p != '\\0'; i++ )\n            {\n                arg = next_arg(p, args);\n\n                switch ( i )\n                {\n                case 0: regs->r0 = arg; break;\n                case 1: regs->r1 = arg; break;\n                case 2: regs->r2 = arg; break;\n                case 3: regs->r3 = arg; break;\n                case 4: regs->r4 = arg; break;\n                case 5: regs->r5 = arg; break;\n                }\n            }\n\n            /* Return value gets written back to r0 */\n            rc = regs->r0;\n        }\n    }\n\n    va_end(args);\n\n    return rc;\n}",
        "func": "unsigned long hypercall_create_continuation(\n    unsigned int op, const char *format, ...)\n{\n    struct mc_state *mcs = &current->mc_state;\n    struct cpu_user_regs *regs;\n    const char *p = format;\n    unsigned long arg, rc;\n    unsigned int i;\n    va_list args;\n\n    current->hcall_preempted = true;\n\n    va_start(args, format);\n\n    if ( mcs->flags & MCSF_in_multicall )\n    {\n        for ( i = 0; *p != '\\0'; i++ )\n            mcs->call.args[i] = NEXT_ARG(p, args);\n\n        /* Return value gets written back to mcs->call.result */\n        rc = mcs->call.result;\n    }\n    else\n    {\n        regs = guest_cpu_user_regs();\n\n#ifdef CONFIG_ARM_64\n        if ( !is_32bit_domain(current->domain) )\n        {\n            regs->x16 = op;\n\n            for ( i = 0; *p != '\\0'; i++ )\n            {\n                arg = NEXT_ARG(p, args);\n\n                switch ( i )\n                {\n                case 0: regs->x0 = arg; break;\n                case 1: regs->x1 = arg; break;\n                case 2: regs->x2 = arg; break;\n                case 3: regs->x3 = arg; break;\n                case 4: regs->x4 = arg; break;\n                case 5: regs->x5 = arg; break;\n                }\n            }\n\n            /* Return value gets written back to x0 */\n            rc = regs->x0;\n        }\n        else\n#endif\n        {\n            regs->r12 = op;\n\n            for ( i = 0; *p != '\\0'; i++ )\n            {\n                arg = NEXT_ARG(p, args);\n\n                switch ( i )\n                {\n                case 0: regs->r0 = arg; break;\n                case 1: regs->r1 = arg; break;\n                case 2: regs->r2 = arg; break;\n                case 3: regs->r3 = arg; break;\n                case 4: regs->r4 = arg; break;\n                case 5: regs->r5 = arg; break;\n                }\n            }\n\n            /* Return value gets written back to r0 */\n            rc = regs->r0;\n        }\n    }\n\n    va_end(args);\n\n    return rc;\n\n bad_fmt:\n    gprintk(XENLOG_ERR, \"Bad hypercall continuation format '%c'\\n\", *p);\n    ASSERT_UNREACHABLE();\n    domain_crash(current->domain);\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,9 +8,6 @@\n     unsigned int i;\n     va_list args;\n \n-    /* All hypercalls take at least one argument */\n-    BUG_ON( !p || *p == '\\0' );\n-\n     current->hcall_preempted = true;\n \n     va_start(args, format);\n@@ -18,7 +15,7 @@\n     if ( mcs->flags & MCSF_in_multicall )\n     {\n         for ( i = 0; *p != '\\0'; i++ )\n-            mcs->call.args[i] = next_arg(p, args);\n+            mcs->call.args[i] = NEXT_ARG(p, args);\n \n         /* Return value gets written back to mcs->call.result */\n         rc = mcs->call.result;\n@@ -34,7 +31,7 @@\n \n             for ( i = 0; *p != '\\0'; i++ )\n             {\n-                arg = next_arg(p, args);\n+                arg = NEXT_ARG(p, args);\n \n                 switch ( i )\n                 {\n@@ -57,7 +54,7 @@\n \n             for ( i = 0; *p != '\\0'; i++ )\n             {\n-                arg = next_arg(p, args);\n+                arg = NEXT_ARG(p, args);\n \n                 switch ( i )\n                 {\n@@ -78,4 +75,10 @@\n     va_end(args);\n \n     return rc;\n+\n+ bad_fmt:\n+    gprintk(XENLOG_ERR, \"Bad hypercall continuation format '%c'\\n\", *p);\n+    ASSERT_UNREACHABLE();\n+    domain_crash(current->domain);\n+    return 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    /* All hypercalls take at least one argument */",
                "    BUG_ON( !p || *p == '\\0' );",
                "",
                "            mcs->call.args[i] = next_arg(p, args);",
                "                arg = next_arg(p, args);",
                "                arg = next_arg(p, args);"
            ],
            "added_lines": [
                "            mcs->call.args[i] = NEXT_ARG(p, args);",
                "                arg = NEXT_ARG(p, args);",
                "                arg = NEXT_ARG(p, args);",
                "",
                " bad_fmt:",
                "    gprintk(XENLOG_ERR, \"Bad hypercall continuation format '%c'\\n\", *p);",
                "    ASSERT_UNREACHABLE();",
                "    domain_crash(current->domain);",
                "    return 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18420",
        "func_name": "xen-project/xen/hypercall_create_continuation",
        "description": "An issue was discovered in Xen through 4.12.x allowing x86 PV guest OS users to cause a denial of service via a VCPUOP_initialise hypercall. hypercall_create_continuation() is a variadic function which uses a printf-like format string to interpret its parameters. Error handling for a bad format character was done using BUG(), which crashes Xen. One path, via the VCPUOP_initialise hypercall, has a bad format character. The BUG() can be hit if VCPUOP_initialise executes for a sufficiently long period of time for a continuation to be created. Malicious guests may cause a hypervisor crash, resulting in a Denial of Service (DoS). Xen versions 4.6 and newer are vulnerable. Xen versions 4.5 and earlier are not vulnerable. Only x86 PV guests can exploit the vulnerability. HVM and PVH guests, and guests on ARM systems, cannot exploit the vulnerability.",
        "git_url": "https://github.com/xen-project/xen/commit/0bf9f8d3e399a0e1d2b717f71b4776172446184b",
        "commit_title": "xen/hypercall: Don't use BUG() for parameter checking in hypercall_create_continuation()",
        "commit_text": " Since c/s 1d429034 \"hypercall: update vcpu_op to take an unsigned vcpuid\", which incorrectly swapped 'i' for 'u' in the parameter type list, guests have been able to hit the BUG() in next_args()'s default case.  Correct these back to 'i'.  In addition, make adjustments to prevent this class of issue from occurring in the future - crashing Xen is not an appropriate form of parameter checking.  Capitalise NEXT_ARG() to catch all uses, to highlight that it is a macro doing non-function-like things behind the scenes, and undef it when appropriate. Implement a bad_fmt: block which prints an error, asserts unreachable, and crashes the guest.  On the ARM side, drop all parameter checking of p.  It is asymmetric with the x86 side, and akin to expecting memcpy() or sprintf() to check their src/fmt parameter before use.  A caller passing \"\" or something other than a string literal will be obvious during code review.  This is XSA-296. ",
        "func_before": "unsigned long hypercall_create_continuation(\n    unsigned int op, const char *format, ...)\n{\n    struct mc_state *mcs = &current->mc_state;\n    struct cpu_user_regs *regs;\n    const char *p = format;\n    unsigned long arg, rc;\n    unsigned int i;\n    va_list args;\n\n    /* All hypercalls take at least one argument */\n    BUG_ON( !p || *p == '\\0' );\n\n    current->hcall_preempted = true;\n\n    va_start(args, format);\n\n    if ( mcs->flags & MCSF_in_multicall )\n    {\n        for ( i = 0; *p != '\\0'; i++ )\n            mcs->call.args[i] = next_arg(p, args);\n\n        /* Return value gets written back to mcs->call.result */\n        rc = mcs->call.result;\n    }\n    else\n    {\n        regs = guest_cpu_user_regs();\n\n#ifdef CONFIG_ARM_64\n        if ( !is_32bit_domain(current->domain) )\n        {\n            regs->x16 = op;\n\n            for ( i = 0; *p != '\\0'; i++ )\n            {\n                arg = next_arg(p, args);\n\n                switch ( i )\n                {\n                case 0: regs->x0 = arg; break;\n                case 1: regs->x1 = arg; break;\n                case 2: regs->x2 = arg; break;\n                case 3: regs->x3 = arg; break;\n                case 4: regs->x4 = arg; break;\n                case 5: regs->x5 = arg; break;\n                }\n            }\n\n            /* Return value gets written back to x0 */\n            rc = regs->x0;\n        }\n        else\n#endif\n        {\n            regs->r12 = op;\n\n            for ( i = 0; *p != '\\0'; i++ )\n            {\n                arg = next_arg(p, args);\n\n                switch ( i )\n                {\n                case 0: regs->r0 = arg; break;\n                case 1: regs->r1 = arg; break;\n                case 2: regs->r2 = arg; break;\n                case 3: regs->r3 = arg; break;\n                case 4: regs->r4 = arg; break;\n                case 5: regs->r5 = arg; break;\n                }\n            }\n\n            /* Return value gets written back to r0 */\n            rc = regs->r0;\n        }\n    }\n\n    va_end(args);\n\n    return rc;\n}",
        "func": "unsigned long hypercall_create_continuation(\n    unsigned int op, const char *format, ...)\n{\n    struct mc_state *mcs = &current->mc_state;\n    struct cpu_user_regs *regs;\n    const char *p = format;\n    unsigned long arg, rc;\n    unsigned int i;\n    va_list args;\n\n    current->hcall_preempted = true;\n\n    va_start(args, format);\n\n    if ( mcs->flags & MCSF_in_multicall )\n    {\n        for ( i = 0; *p != '\\0'; i++ )\n            mcs->call.args[i] = NEXT_ARG(p, args);\n\n        /* Return value gets written back to mcs->call.result */\n        rc = mcs->call.result;\n    }\n    else\n    {\n        regs = guest_cpu_user_regs();\n\n#ifdef CONFIG_ARM_64\n        if ( !is_32bit_domain(current->domain) )\n        {\n            regs->x16 = op;\n\n            for ( i = 0; *p != '\\0'; i++ )\n            {\n                arg = NEXT_ARG(p, args);\n\n                switch ( i )\n                {\n                case 0: regs->x0 = arg; break;\n                case 1: regs->x1 = arg; break;\n                case 2: regs->x2 = arg; break;\n                case 3: regs->x3 = arg; break;\n                case 4: regs->x4 = arg; break;\n                case 5: regs->x5 = arg; break;\n                }\n            }\n\n            /* Return value gets written back to x0 */\n            rc = regs->x0;\n        }\n        else\n#endif\n        {\n            regs->r12 = op;\n\n            for ( i = 0; *p != '\\0'; i++ )\n            {\n                arg = NEXT_ARG(p, args);\n\n                switch ( i )\n                {\n                case 0: regs->r0 = arg; break;\n                case 1: regs->r1 = arg; break;\n                case 2: regs->r2 = arg; break;\n                case 3: regs->r3 = arg; break;\n                case 4: regs->r4 = arg; break;\n                case 5: regs->r5 = arg; break;\n                }\n            }\n\n            /* Return value gets written back to r0 */\n            rc = regs->r0;\n        }\n    }\n\n    va_end(args);\n\n    return rc;\n\n bad_fmt:\n    gprintk(XENLOG_ERR, \"Bad hypercall continuation format '%c'\\n\", *p);\n    ASSERT_UNREACHABLE();\n    domain_crash(current->domain);\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,9 +8,6 @@\n     unsigned int i;\n     va_list args;\n \n-    /* All hypercalls take at least one argument */\n-    BUG_ON( !p || *p == '\\0' );\n-\n     current->hcall_preempted = true;\n \n     va_start(args, format);\n@@ -18,7 +15,7 @@\n     if ( mcs->flags & MCSF_in_multicall )\n     {\n         for ( i = 0; *p != '\\0'; i++ )\n-            mcs->call.args[i] = next_arg(p, args);\n+            mcs->call.args[i] = NEXT_ARG(p, args);\n \n         /* Return value gets written back to mcs->call.result */\n         rc = mcs->call.result;\n@@ -34,7 +31,7 @@\n \n             for ( i = 0; *p != '\\0'; i++ )\n             {\n-                arg = next_arg(p, args);\n+                arg = NEXT_ARG(p, args);\n \n                 switch ( i )\n                 {\n@@ -57,7 +54,7 @@\n \n             for ( i = 0; *p != '\\0'; i++ )\n             {\n-                arg = next_arg(p, args);\n+                arg = NEXT_ARG(p, args);\n \n                 switch ( i )\n                 {\n@@ -78,4 +75,10 @@\n     va_end(args);\n \n     return rc;\n+\n+ bad_fmt:\n+    gprintk(XENLOG_ERR, \"Bad hypercall continuation format '%c'\\n\", *p);\n+    ASSERT_UNREACHABLE();\n+    domain_crash(current->domain);\n+    return 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    /* All hypercalls take at least one argument */",
                "    BUG_ON( !p || *p == '\\0' );",
                "",
                "            mcs->call.args[i] = next_arg(p, args);",
                "                arg = next_arg(p, args);",
                "                arg = next_arg(p, args);"
            ],
            "added_lines": [
                "            mcs->call.args[i] = NEXT_ARG(p, args);",
                "                arg = NEXT_ARG(p, args);",
                "                arg = NEXT_ARG(p, args);",
                "",
                " bad_fmt:",
                "    gprintk(XENLOG_ERR, \"Bad hypercall continuation format '%c'\\n\", *p);",
                "    ASSERT_UNREACHABLE();",
                "    domain_crash(current->domain);",
                "    return 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-2652",
        "func_name": "umlaeute/v4l2loopback/v4l2_loopback_add",
        "description": "Depending on the way the format strings in the card label are crafted it's possible to leak kernel stack memory. There is also the possibility for DoS due to the v4l2loopback kernel module crashing when providing the card label on request (reproduce e.g. with many %s modifiers in a row).",
        "git_url": "https://github.com/umlaeute/v4l2loopback/commit/e4cd225557486c420f6a34411f98c575effd43dd",
        "commit_title": "add explicit format specifier to printf() invocations",
        "commit_text": " CWE-134",
        "func_before": "static int v4l2_loopback_add(struct v4l2_loopback_config *conf, int *ret_nr)\n{\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_ctrl_handler *hdl;\n\tstruct v4l2loopback_private *vdev_priv = NULL;\n\n\tint err = -ENOMEM;\n\n\tint _max_width = DEFAULT_FROM_CONF(\n\t\tmax_width, < V4L2LOOPBACK_SIZE_MIN_WIDTH, max_width);\n\tint _max_height = DEFAULT_FROM_CONF(\n\t\tmax_height, < V4L2LOOPBACK_SIZE_MIN_HEIGHT, max_height);\n\tbool _announce_all_caps = (conf && conf->announce_all_caps >= 0) ?\n\t\t\t\t\t  (conf->announce_all_caps) :\n\t\t\t\t\t\tV4L2LOOPBACK_DEFAULT_EXCLUSIVECAPS;\n\tint _max_buffers = DEFAULT_FROM_CONF(max_buffers, <= 0, max_buffers);\n\tint _max_openers = DEFAULT_FROM_CONF(max_openers, <= 0, max_openers);\n\n\tint nr = -1;\n\n\t_announce_all_caps = (!!_announce_all_caps);\n\n\tif (conf) {\n\t\tif (conf->capture_nr >= 0 &&\n\t\t    conf->output_nr == conf->capture_nr) {\n\t\t\tnr = conf->capture_nr;\n\t\t} else if (conf->capture_nr < 0 && conf->output_nr < 0) {\n\t\t\tnr = -1;\n\t\t} else if (conf->capture_nr < 0) {\n\t\t\tnr = conf->output_nr;\n\t\t} else if (conf->output_nr < 0) {\n\t\t\tnr = conf->capture_nr;\n\t\t} else {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"split OUTPUT and CAPTURE devices not yet supported.\");\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"both devices must have the same number (%d != %d).\",\n\t\t\t       conf->output_nr, conf->capture_nr);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (idr_find(&v4l2loopback_index_idr, nr))\n\t\treturn -EEXIST;\n\n\tdprintk(\"creating v4l2loopback-device #%d\\n\", nr);\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\t/* allocate id, if @id >= 0, we're requesting that specific id */\n\tif (nr >= 0) {\n\t\terr = idr_alloc(&v4l2loopback_index_idr, dev, nr, nr + 1,\n\t\t\t\tGFP_KERNEL);\n\t\tif (err == -ENOSPC)\n\t\t\terr = -EEXIST;\n\t} else {\n\t\terr = idr_alloc(&v4l2loopback_index_idr, dev, 0, 0, GFP_KERNEL);\n\t}\n\tif (err < 0)\n\t\tgoto out_free_dev;\n\tnr = err;\n\terr = -ENOMEM;\n\n\tif (conf && conf->card_label && *(conf->card_label)) {\n\t\tsnprintf(dev->card_label, sizeof(dev->card_label), \"%s\",\n\t\t\t conf->card_label);\n\t} else {\n\t\tsnprintf(dev->card_label, sizeof(dev->card_label),\n\t\t\t \"Dummy video device (0x%04X)\", nr);\n\t}\n\tsnprintf(dev->v4l2_dev.name, sizeof(dev->v4l2_dev.name),\n\t\t \"v4l2loopback-%03d\", nr);\n\n\terr = v4l2_device_register(NULL, &dev->v4l2_dev);\n\tif (err)\n\t\tgoto out_free_idr;\n\tMARK();\n\n\tdev->vdev = video_device_alloc();\n\tif (dev->vdev == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unregister;\n\t}\n\n\tvdev_priv = kzalloc(sizeof(struct v4l2loopback_private), GFP_KERNEL);\n\tif (vdev_priv == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unregister;\n\t}\n\n\tvideo_set_drvdata(dev->vdev, vdev_priv);\n\tif (video_get_drvdata(dev->vdev) == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unregister;\n\t}\n\n\tMARK();\n\tsnprintf(dev->vdev->name, sizeof(dev->vdev->name), dev->card_label);\n\n\tvdev_priv->device_nr = nr;\n\n\tinit_vdev(dev->vdev, nr);\n\tdev->vdev->v4l2_dev = &dev->v4l2_dev;\n\tinit_capture_param(&dev->capture_param);\n\terr = set_timeperframe(dev, &dev->capture_param.timeperframe);\n\tif (err)\n\t\tgoto out_unregister;\n\tdev->keep_format = 0;\n\tdev->sustain_framerate = 0;\n\n\tdev->announce_all_caps = _announce_all_caps;\n\tdev->max_width = _max_width;\n\tdev->max_height = _max_height;\n\tdev->max_openers = _max_openers;\n\tdev->buffers_number = dev->used_buffers = _max_buffers;\n\n\tdev->write_position = 0;\n\n\tMARK();\n\tspin_lock_init(&dev->lock);\n\tINIT_LIST_HEAD(&dev->outbufs_list);\n\tif (list_empty(&dev->outbufs_list)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < dev->used_buffers; ++i)\n\t\t\tlist_add_tail(&dev->buffers[i].list_head,\n\t\t\t\t      &dev->outbufs_list);\n\t}\n\tmemset(dev->bufpos2index, 0, sizeof(dev->bufpos2index));\n\tatomic_set(&dev->open_count, 0);\n\tdev->ready_for_capture = 0;\n\tdev->ready_for_output = 1;\n\n\tdev->buffer_size = 0;\n\tdev->image = NULL;\n\tdev->imagesize = 0;\n#ifdef HAVE_TIMER_SETUP\n\ttimer_setup(&dev->sustain_timer, sustain_timer_clb, 0);\n\ttimer_setup(&dev->timeout_timer, timeout_timer_clb, 0);\n#else\n\tsetup_timer(&dev->sustain_timer, sustain_timer_clb, nr);\n\tsetup_timer(&dev->timeout_timer, timeout_timer_clb, nr);\n#endif\n\tdev->reread_count = 0;\n\tdev->timeout_jiffies = 0;\n\tdev->timeout_image = NULL;\n\tdev->timeout_happened = 0;\n\n\thdl = &dev->ctrl_handler;\n\terr = v4l2_ctrl_handler_init(hdl, 4);\n\tif (err)\n\t\tgoto out_unregister;\n\tv4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_keepformat, NULL);\n\tv4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_sustainframerate, NULL);\n\tv4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_timeout, NULL);\n\tv4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_timeoutimageio, NULL);\n\tif (hdl->error) {\n\t\terr = hdl->error;\n\t\tgoto out_free_handler;\n\t}\n\tdev->v4l2_dev.ctrl_handler = hdl;\n\n\terr = v4l2_ctrl_handler_setup(hdl);\n\tif (err)\n\t\tgoto out_free_handler;\n\n\t/* FIXME set buffers to 0 */\n\n\t/* Set initial format */\n\tdev->pix_format.width = 0; /* V4L2LOOPBACK_SIZE_DEFAULT_WIDTH; */\n\tdev->pix_format.height = 0; /* V4L2LOOPBACK_SIZE_DEFAULT_HEIGHT; */\n\tdev->pix_format.pixelformat = formats[0].fourcc;\n\tdev->pix_format.colorspace =\n\t\tV4L2_COLORSPACE_SRGB; /* do we need to set this ? */\n\tdev->pix_format.field = V4L2_FIELD_NONE;\n\n\tdev->buffer_size = PAGE_ALIGN(dev->pix_format.sizeimage);\n\tdprintk(\"buffer_size = %ld (=%d)\\n\", dev->buffer_size,\n\t\tdev->pix_format.sizeimage);\n\n\tif (dev->buffer_size && ((err = allocate_buffers(dev)) < 0))\n\t\tgoto out_free_handler;\n\n\tinit_waitqueue_head(&dev->read_event);\n\n\t/* register the device -> it creates /dev/video* */\n\tif (video_register_device(dev->vdev, VFL_TYPE_VIDEO, nr) < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"v4l2loopback: failed video_register_device()\\n\");\n\t\terr = -EFAULT;\n\t\tgoto out_free_device;\n\t}\n\tv4l2loopback_create_sysfs(dev->vdev);\n\n\tMARK();\n\tif (ret_nr)\n\t\t*ret_nr = dev->vdev->num;\n\treturn 0;\n\nout_free_device:\n\tvideo_device_release(dev->vdev);\nout_free_handler:\n\tv4l2_ctrl_handler_free(&dev->ctrl_handler);\nout_unregister:\n\tvideo_set_drvdata(dev->vdev, NULL);\n\tif (vdev_priv != NULL)\n\t\tkfree(vdev_priv);\n\tv4l2_device_unregister(&dev->v4l2_dev);\nout_free_idr:\n\tidr_remove(&v4l2loopback_index_idr, nr);\nout_free_dev:\n\tkfree(dev);\n\treturn err;\n}",
        "func": "static int v4l2_loopback_add(struct v4l2_loopback_config *conf, int *ret_nr)\n{\n\tstruct v4l2_loopback_device *dev;\n\tstruct v4l2_ctrl_handler *hdl;\n\tstruct v4l2loopback_private *vdev_priv = NULL;\n\n\tint err = -ENOMEM;\n\n\tint _max_width = DEFAULT_FROM_CONF(\n\t\tmax_width, < V4L2LOOPBACK_SIZE_MIN_WIDTH, max_width);\n\tint _max_height = DEFAULT_FROM_CONF(\n\t\tmax_height, < V4L2LOOPBACK_SIZE_MIN_HEIGHT, max_height);\n\tbool _announce_all_caps = (conf && conf->announce_all_caps >= 0) ?\n\t\t\t\t\t  (conf->announce_all_caps) :\n\t\t\t\t\t\tV4L2LOOPBACK_DEFAULT_EXCLUSIVECAPS;\n\tint _max_buffers = DEFAULT_FROM_CONF(max_buffers, <= 0, max_buffers);\n\tint _max_openers = DEFAULT_FROM_CONF(max_openers, <= 0, max_openers);\n\n\tint nr = -1;\n\n\t_announce_all_caps = (!!_announce_all_caps);\n\n\tif (conf) {\n\t\tif (conf->capture_nr >= 0 &&\n\t\t    conf->output_nr == conf->capture_nr) {\n\t\t\tnr = conf->capture_nr;\n\t\t} else if (conf->capture_nr < 0 && conf->output_nr < 0) {\n\t\t\tnr = -1;\n\t\t} else if (conf->capture_nr < 0) {\n\t\t\tnr = conf->output_nr;\n\t\t} else if (conf->output_nr < 0) {\n\t\t\tnr = conf->capture_nr;\n\t\t} else {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"split OUTPUT and CAPTURE devices not yet supported.\");\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"both devices must have the same number (%d != %d).\",\n\t\t\t       conf->output_nr, conf->capture_nr);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (idr_find(&v4l2loopback_index_idr, nr))\n\t\treturn -EEXIST;\n\n\tdprintk(\"creating v4l2loopback-device #%d\\n\", nr);\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\t/* allocate id, if @id >= 0, we're requesting that specific id */\n\tif (nr >= 0) {\n\t\terr = idr_alloc(&v4l2loopback_index_idr, dev, nr, nr + 1,\n\t\t\t\tGFP_KERNEL);\n\t\tif (err == -ENOSPC)\n\t\t\terr = -EEXIST;\n\t} else {\n\t\terr = idr_alloc(&v4l2loopback_index_idr, dev, 0, 0, GFP_KERNEL);\n\t}\n\tif (err < 0)\n\t\tgoto out_free_dev;\n\tnr = err;\n\terr = -ENOMEM;\n\n\tif (conf && conf->card_label && *(conf->card_label)) {\n\t\tsnprintf(dev->card_label, sizeof(dev->card_label), \"%s\",\n\t\t\t conf->card_label);\n\t} else {\n\t\tsnprintf(dev->card_label, sizeof(dev->card_label),\n\t\t\t \"Dummy video device (0x%04X)\", nr);\n\t}\n\tsnprintf(dev->v4l2_dev.name, sizeof(dev->v4l2_dev.name),\n\t\t \"v4l2loopback-%03d\", nr);\n\n\terr = v4l2_device_register(NULL, &dev->v4l2_dev);\n\tif (err)\n\t\tgoto out_free_idr;\n\tMARK();\n\n\tdev->vdev = video_device_alloc();\n\tif (dev->vdev == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unregister;\n\t}\n\n\tvdev_priv = kzalloc(sizeof(struct v4l2loopback_private), GFP_KERNEL);\n\tif (vdev_priv == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unregister;\n\t}\n\n\tvideo_set_drvdata(dev->vdev, vdev_priv);\n\tif (video_get_drvdata(dev->vdev) == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unregister;\n\t}\n\n\tMARK();\n\tsnprintf(dev->vdev->name, sizeof(dev->vdev->name), \"%s\", dev->card_label);\n\n\tvdev_priv->device_nr = nr;\n\n\tinit_vdev(dev->vdev, nr);\n\tdev->vdev->v4l2_dev = &dev->v4l2_dev;\n\tinit_capture_param(&dev->capture_param);\n\terr = set_timeperframe(dev, &dev->capture_param.timeperframe);\n\tif (err)\n\t\tgoto out_unregister;\n\tdev->keep_format = 0;\n\tdev->sustain_framerate = 0;\n\n\tdev->announce_all_caps = _announce_all_caps;\n\tdev->max_width = _max_width;\n\tdev->max_height = _max_height;\n\tdev->max_openers = _max_openers;\n\tdev->buffers_number = dev->used_buffers = _max_buffers;\n\n\tdev->write_position = 0;\n\n\tMARK();\n\tspin_lock_init(&dev->lock);\n\tINIT_LIST_HEAD(&dev->outbufs_list);\n\tif (list_empty(&dev->outbufs_list)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < dev->used_buffers; ++i)\n\t\t\tlist_add_tail(&dev->buffers[i].list_head,\n\t\t\t\t      &dev->outbufs_list);\n\t}\n\tmemset(dev->bufpos2index, 0, sizeof(dev->bufpos2index));\n\tatomic_set(&dev->open_count, 0);\n\tdev->ready_for_capture = 0;\n\tdev->ready_for_output = 1;\n\n\tdev->buffer_size = 0;\n\tdev->image = NULL;\n\tdev->imagesize = 0;\n#ifdef HAVE_TIMER_SETUP\n\ttimer_setup(&dev->sustain_timer, sustain_timer_clb, 0);\n\ttimer_setup(&dev->timeout_timer, timeout_timer_clb, 0);\n#else\n\tsetup_timer(&dev->sustain_timer, sustain_timer_clb, nr);\n\tsetup_timer(&dev->timeout_timer, timeout_timer_clb, nr);\n#endif\n\tdev->reread_count = 0;\n\tdev->timeout_jiffies = 0;\n\tdev->timeout_image = NULL;\n\tdev->timeout_happened = 0;\n\n\thdl = &dev->ctrl_handler;\n\terr = v4l2_ctrl_handler_init(hdl, 4);\n\tif (err)\n\t\tgoto out_unregister;\n\tv4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_keepformat, NULL);\n\tv4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_sustainframerate, NULL);\n\tv4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_timeout, NULL);\n\tv4l2_ctrl_new_custom(hdl, &v4l2loopback_ctrl_timeoutimageio, NULL);\n\tif (hdl->error) {\n\t\terr = hdl->error;\n\t\tgoto out_free_handler;\n\t}\n\tdev->v4l2_dev.ctrl_handler = hdl;\n\n\terr = v4l2_ctrl_handler_setup(hdl);\n\tif (err)\n\t\tgoto out_free_handler;\n\n\t/* FIXME set buffers to 0 */\n\n\t/* Set initial format */\n\tdev->pix_format.width = 0; /* V4L2LOOPBACK_SIZE_DEFAULT_WIDTH; */\n\tdev->pix_format.height = 0; /* V4L2LOOPBACK_SIZE_DEFAULT_HEIGHT; */\n\tdev->pix_format.pixelformat = formats[0].fourcc;\n\tdev->pix_format.colorspace =\n\t\tV4L2_COLORSPACE_SRGB; /* do we need to set this ? */\n\tdev->pix_format.field = V4L2_FIELD_NONE;\n\n\tdev->buffer_size = PAGE_ALIGN(dev->pix_format.sizeimage);\n\tdprintk(\"buffer_size = %ld (=%d)\\n\", dev->buffer_size,\n\t\tdev->pix_format.sizeimage);\n\n\tif (dev->buffer_size && ((err = allocate_buffers(dev)) < 0))\n\t\tgoto out_free_handler;\n\n\tinit_waitqueue_head(&dev->read_event);\n\n\t/* register the device -> it creates /dev/video* */\n\tif (video_register_device(dev->vdev, VFL_TYPE_VIDEO, nr) < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"v4l2loopback: failed video_register_device()\\n\");\n\t\terr = -EFAULT;\n\t\tgoto out_free_device;\n\t}\n\tv4l2loopback_create_sysfs(dev->vdev);\n\n\tMARK();\n\tif (ret_nr)\n\t\t*ret_nr = dev->vdev->num;\n\treturn 0;\n\nout_free_device:\n\tvideo_device_release(dev->vdev);\nout_free_handler:\n\tv4l2_ctrl_handler_free(&dev->ctrl_handler);\nout_unregister:\n\tvideo_set_drvdata(dev->vdev, NULL);\n\tif (vdev_priv != NULL)\n\t\tkfree(vdev_priv);\n\tv4l2_device_unregister(&dev->v4l2_dev);\nout_free_idr:\n\tidr_remove(&v4l2loopback_index_idr, nr);\nout_free_dev:\n\tkfree(dev);\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -96,7 +96,7 @@\n \t}\n \n \tMARK();\n-\tsnprintf(dev->vdev->name, sizeof(dev->vdev->name), dev->card_label);\n+\tsnprintf(dev->vdev->name, sizeof(dev->vdev->name), \"%s\", dev->card_label);\n \n \tvdev_priv->device_nr = nr;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tsnprintf(dev->vdev->name, sizeof(dev->vdev->name), dev->card_label);"
            ],
            "added_lines": [
                "\tsnprintf(dev->vdev->name, sizeof(dev->vdev->name), \"%s\", dev->card_label);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-2652",
        "func_name": "umlaeute/v4l2loopback/vidioc_querycap",
        "description": "Depending on the way the format strings in the card label are crafted it's possible to leak kernel stack memory. There is also the possibility for DoS due to the v4l2loopback kernel module crashing when providing the card label on request (reproduce e.g. with many %s modifiers in a row).",
        "git_url": "https://github.com/umlaeute/v4l2loopback/commit/e4cd225557486c420f6a34411f98c575effd43dd",
        "commit_title": "add explicit format specifier to printf() invocations",
        "commit_text": " CWE-134",
        "func_before": "static int vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tint labellen = (sizeof(cap->card) < sizeof(dev->card_label)) ?\n\t\t\t       sizeof(cap->card) :\n\t\t\t\t     sizeof(dev->card_label);\n\tint device_nr =\n\t\t((struct v4l2loopback_private *)video_get_drvdata(dev->vdev))\n\t\t\t->device_nr;\n\t__u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\n\tstrlcpy(cap->driver, \"v4l2 loopback\", sizeof(cap->driver));\n\tsnprintf(cap->card, labellen, dev->card_label);\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"platform:v4l2loopback-%03d\", device_nr);\n\n#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 1, 0)\n\t/* since 3.1.0, the v4l2-core system is supposed to set the version */\n\tcap->version = V4L2LOOPBACK_VERSION_CODE;\n#endif\n\n#ifdef V4L2_CAP_VIDEO_M2M\n\tcapabilities |= V4L2_CAP_VIDEO_M2M;\n#endif /* V4L2_CAP_VIDEO_M2M */\n\n\tif (dev->announce_all_caps) {\n\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT;\n\t} else {\n\t\tif (dev->ready_for_capture) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE;\n\t\t}\n\t\tif (dev->ready_for_output) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_OUTPUT;\n\t\t}\n\t}\n\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)\n\tdev->vdev->device_caps =\n#endif /* >=linux-4.7.0 */\n\t\tcap->device_caps = cap->capabilities = capabilities;\n\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)\n\tcap->capabilities |= V4L2_CAP_DEVICE_CAPS;\n#endif\n\n\tmemset(cap->reserved, 0, sizeof(cap->reserved));\n\treturn 0;\n}",
        "func": "static int vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tint labellen = (sizeof(cap->card) < sizeof(dev->card_label)) ?\n\t\t\t       sizeof(cap->card) :\n\t\t\t\t     sizeof(dev->card_label);\n\tint device_nr =\n\t\t((struct v4l2loopback_private *)video_get_drvdata(dev->vdev))\n\t\t\t->device_nr;\n\t__u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\n\tstrlcpy(cap->driver, \"v4l2 loopback\", sizeof(cap->driver));\n\tsnprintf(cap->card, labellen, \"%s\", dev->card_label);\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"platform:v4l2loopback-%03d\", device_nr);\n\n#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 1, 0)\n\t/* since 3.1.0, the v4l2-core system is supposed to set the version */\n\tcap->version = V4L2LOOPBACK_VERSION_CODE;\n#endif\n\n#ifdef V4L2_CAP_VIDEO_M2M\n\tcapabilities |= V4L2_CAP_VIDEO_M2M;\n#endif /* V4L2_CAP_VIDEO_M2M */\n\n\tif (dev->announce_all_caps) {\n\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT;\n\t} else {\n\t\tif (dev->ready_for_capture) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE;\n\t\t}\n\t\tif (dev->ready_for_output) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_OUTPUT;\n\t\t}\n\t}\n\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)\n\tdev->vdev->device_caps =\n#endif /* >=linux-4.7.0 */\n\t\tcap->device_caps = cap->capabilities = capabilities;\n\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)\n\tcap->capabilities |= V4L2_CAP_DEVICE_CAPS;\n#endif\n\n\tmemset(cap->reserved, 0, sizeof(cap->reserved));\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,7 +11,7 @@\n \t__u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n \n \tstrlcpy(cap->driver, \"v4l2 loopback\", sizeof(cap->driver));\n-\tsnprintf(cap->card, labellen, dev->card_label);\n+\tsnprintf(cap->card, labellen, \"%s\", dev->card_label);\n \tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n \t\t \"platform:v4l2loopback-%03d\", device_nr);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tsnprintf(cap->card, labellen, dev->card_label);"
            ],
            "added_lines": [
                "\tsnprintf(cap->card, labellen, \"%s\", dev->card_label);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-15191",
        "func_name": "wireshark/dissect_7bit_string",
        "description": "In Wireshark 2.4.0 to 2.4.1, 2.2.0 to 2.2.9, and 2.0.0 to 2.0.15, the DMP dissector could crash. This was addressed in epan/dissectors/packet-dmp.c by validating a string length.",
        "git_url": "https://github.com/wireshark/wireshark/commit/8dbb21dfde14221dab09b6b9c7719b9067c1f06e",
        "commit_title": "DMP: check 7bit string length before decoding it",
        "commit_text": " Bug: 14068 Link: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=3372",
        "func_before": "static gchar *dissect_7bit_string (tvbuff_t *tvb, gint offset, gint length, guchar *byte_rest)\n{\n  guchar *encoded = (guchar *)tvb_memdup (wmem_packet_scope(), tvb, offset, length);\n  guchar *decoded = (guchar *)wmem_alloc0 (wmem_packet_scope(), (size_t)(length * 1.2) + 1);\n  guchar  rest = 0, bits = 1;\n  gint    len = 0, i;\n\n  for (i = 0; i < length; i++) {\n    decoded[len++] = encoded[i] >> bits | rest;\n    rest = (encoded[i] << (7 - bits) & 0x7F);\n    if (bits == 7) {\n      decoded[len++] = rest;\n      bits = 1;\n      rest = 0;\n    } else {\n      bits++;\n    }\n  }\n\n  if (byte_rest) {\n    *byte_rest = rest;\n  }\n\n  return (gchar *) decoded;\n}",
        "func": "static gchar *dissect_7bit_string (tvbuff_t *tvb, gint offset, gint length, guchar *byte_rest)\n{\n  guchar *encoded, *decoded;\n  guchar  rest = 0, bits = 1;\n  gint    len = 0, i;\n\n  if (length <= 0) {\n    decoded = \"\";\n  } else {\n    encoded = (guchar *)tvb_memdup (wmem_packet_scope(), tvb, offset, length);\n    decoded = (guchar *)wmem_alloc0 (wmem_packet_scope(), (size_t)(length * 1.2) + 1);\n    for (i = 0; i < length; i++) {\n      decoded[len++] = encoded[i] >> bits | rest;\n      rest = (encoded[i] << (7 - bits) & 0x7F);\n      if (bits == 7) {\n        decoded[len++] = rest;\n        bits = 1;\n        rest = 0;\n      } else {\n        bits++;\n      }\n    }\n  }\n\n  if (byte_rest) {\n    *byte_rest = rest;\n  }\n\n  return (gchar *) decoded;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,19 +1,24 @@\n static gchar *dissect_7bit_string (tvbuff_t *tvb, gint offset, gint length, guchar *byte_rest)\n {\n-  guchar *encoded = (guchar *)tvb_memdup (wmem_packet_scope(), tvb, offset, length);\n-  guchar *decoded = (guchar *)wmem_alloc0 (wmem_packet_scope(), (size_t)(length * 1.2) + 1);\n+  guchar *encoded, *decoded;\n   guchar  rest = 0, bits = 1;\n   gint    len = 0, i;\n \n-  for (i = 0; i < length; i++) {\n-    decoded[len++] = encoded[i] >> bits | rest;\n-    rest = (encoded[i] << (7 - bits) & 0x7F);\n-    if (bits == 7) {\n-      decoded[len++] = rest;\n-      bits = 1;\n-      rest = 0;\n-    } else {\n-      bits++;\n+  if (length <= 0) {\n+    decoded = \"\";\n+  } else {\n+    encoded = (guchar *)tvb_memdup (wmem_packet_scope(), tvb, offset, length);\n+    decoded = (guchar *)wmem_alloc0 (wmem_packet_scope(), (size_t)(length * 1.2) + 1);\n+    for (i = 0; i < length; i++) {\n+      decoded[len++] = encoded[i] >> bits | rest;\n+      rest = (encoded[i] << (7 - bits) & 0x7F);\n+      if (bits == 7) {\n+        decoded[len++] = rest;\n+        bits = 1;\n+        rest = 0;\n+      } else {\n+        bits++;\n+      }\n     }\n   }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "  guchar *encoded = (guchar *)tvb_memdup (wmem_packet_scope(), tvb, offset, length);",
                "  guchar *decoded = (guchar *)wmem_alloc0 (wmem_packet_scope(), (size_t)(length * 1.2) + 1);",
                "  for (i = 0; i < length; i++) {",
                "    decoded[len++] = encoded[i] >> bits | rest;",
                "    rest = (encoded[i] << (7 - bits) & 0x7F);",
                "    if (bits == 7) {",
                "      decoded[len++] = rest;",
                "      bits = 1;",
                "      rest = 0;",
                "    } else {",
                "      bits++;"
            ],
            "added_lines": [
                "  guchar *encoded, *decoded;",
                "  if (length <= 0) {",
                "    decoded = \"\";",
                "  } else {",
                "    encoded = (guchar *)tvb_memdup (wmem_packet_scope(), tvb, offset, length);",
                "    decoded = (guchar *)wmem_alloc0 (wmem_packet_scope(), (size_t)(length * 1.2) + 1);",
                "    for (i = 0; i < length; i++) {",
                "      decoded[len++] = encoded[i] >> bits | rest;",
                "      rest = (encoded[i] << (7 - bits) & 0x7F);",
                "      if (bits == 7) {",
                "        decoded[len++] = rest;",
                "        bits = 1;",
                "        rest = 0;",
                "      } else {",
                "        bits++;",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-16516",
        "func_name": "brianmario/yajl-ruby/yajl_string_decode",
        "description": "In the yajl-ruby gem 1.3.0 for Ruby, when a crafted JSON file is supplied to Yajl::Parser.new.parse, the whole ruby process crashes with a SIGABRT in the yajl_string_decode function in yajl_encode.c. This results in the whole ruby process terminating and potentially a denial of service.",
        "git_url": "https://github.com/brianmario/yajl-ruby/commit/a8ca8f476655adaa187eedc60bdc770fff3c51ce",
        "commit_title": "Don't advance our end pointer until we've checked we have enough",
        "commit_text": "buffer left and have peeked ahead to see that a unicode escape is approaching.  Thanks @kivikakk for helping me track down the actual bug here!",
        "func_before": "void yajl_string_decode(yajl_buf buf, const unsigned char * str,\n                        unsigned int len)\n{\n    unsigned int beg = 0;\n    unsigned int end = 0;    \n\n    while (end < len) {\n        if (str[end] == '\\\\') {\n            char utf8Buf[5];\n            const char * unescaped = \"?\";\n            yajl_buf_append(buf, str + beg, end - beg);\n            switch (str[++end]) {\n                case 'r': unescaped = \"\\r\"; break;\n                case 'n': unescaped = \"\\n\"; break;\n                case '\\\\': unescaped = \"\\\\\"; break;\n                case '/': unescaped = \"/\"; break;\n                case '\"': unescaped = \"\\\"\"; break;\n                case 'f': unescaped = \"\\f\"; break;\n                case 'b': unescaped = \"\\b\"; break;\n                case 't': unescaped = \"\\t\"; break;\n                case 'u': {\n                    unsigned int codepoint = 0;\n                    hexToDigit(&codepoint, str + ++end);\n                    end+=3;\n                    /* check if this is a surrogate */\n                    if ((codepoint & 0xFC00) == 0xD800) {\n                        end++;\n                        if (str[end] == '\\\\' && str[end + 1] == 'u') {\n                            unsigned int surrogate = 0;\n                            hexToDigit(&surrogate, str + end + 2);\n                            codepoint =\n                                (((codepoint & 0x3F) << 10) | \n                                 ((((codepoint >> 6) & 0xF) + 1) << 16) | \n                                 (surrogate & 0x3FF));\n                            end += 5;\n                        } else {\n                            unescaped = \"?\";\n                            break;\n                        }\n                    }\n                    \n                    Utf32toUtf8(codepoint, utf8Buf);\n                    unescaped = utf8Buf;\n\n                    if (codepoint == 0) {\n                        yajl_buf_append(buf, unescaped, 1);\n                        beg = ++end;\n                        continue;\n                    }\n\n                    break;\n                }\n                default:\n                    assert(\"this should never happen\" == NULL);\n            }\n            yajl_buf_append(buf, unescaped, (unsigned int)strlen(unescaped));\n            beg = ++end;\n        } else {\n            end++;\n        }\n    }\n    yajl_buf_append(buf, str + beg, end - beg);\n}",
        "func": "void yajl_string_decode(yajl_buf buf, const unsigned char * str,\n                        unsigned int len)\n{\n    unsigned int beg = 0;\n    unsigned int end = 0;    \n\n    while (end < len) {\n        if (str[end] == '\\\\') {\n            char utf8Buf[5];\n            const char * unescaped = \"?\";\n            yajl_buf_append(buf, str + beg, end - beg);\n            switch (str[++end]) {\n                case 'r': unescaped = \"\\r\"; break;\n                case 'n': unescaped = \"\\n\"; break;\n                case '\\\\': unescaped = \"\\\\\"; break;\n                case '/': unescaped = \"/\"; break;\n                case '\"': unescaped = \"\\\"\"; break;\n                case 'f': unescaped = \"\\f\"; break;\n                case 'b': unescaped = \"\\b\"; break;\n                case 't': unescaped = \"\\t\"; break;\n                case 'u': {\n                    unsigned int codepoint = 0;\n                    hexToDigit(&codepoint, str + ++end);\n                    end+=3;\n                    /* check if this is a surrogate */\n                    if ((codepoint & 0xFC00) == 0xD800) {\n                        if (end + 2 < len && str[end + 1] == '\\\\' && str[end + 2] == 'u') {\n                            end++;\n                            unsigned int surrogate = 0;\n                            hexToDigit(&surrogate, str + end + 2);\n                            codepoint =\n                                (((codepoint & 0x3F) << 10) | \n                                 ((((codepoint >> 6) & 0xF) + 1) << 16) | \n                                 (surrogate & 0x3FF));\n                            end += 5;\n                        } else {\n                            unescaped = \"?\";\n                            break;\n                        }\n                    }\n                    \n                    Utf32toUtf8(codepoint, utf8Buf);\n                    unescaped = utf8Buf;\n\n                    if (codepoint == 0) {\n                        yajl_buf_append(buf, unescaped, 1);\n                        beg = ++end;\n                        continue;\n                    }\n\n                    break;\n                }\n                default:\n                    assert(\"this should never happen\" == NULL);\n            }\n            yajl_buf_append(buf, unescaped, (unsigned int)strlen(unescaped));\n            beg = ++end;\n        } else {\n            end++;\n        }\n    }\n    yajl_buf_append(buf, str + beg, end - beg);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,8 +24,8 @@\n                     end+=3;\n                     /* check if this is a surrogate */\n                     if ((codepoint & 0xFC00) == 0xD800) {\n-                        end++;\n-                        if (str[end] == '\\\\' && str[end + 1] == 'u') {\n+                        if (end + 2 < len && str[end + 1] == '\\\\' && str[end + 2] == 'u') {\n+                            end++;\n                             unsigned int surrogate = 0;\n                             hexToDigit(&surrogate, str + end + 2);\n                             codepoint =",
        "diff_line_info": {
            "deleted_lines": [
                "                        end++;",
                "                        if (str[end] == '\\\\' && str[end + 1] == 'u') {"
            ],
            "added_lines": [
                "                        if (end + 2 < len && str[end + 1] == '\\\\' && str[end + 2] == 'u') {",
                "                            end++;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-0898",
        "func_name": "mruby/mrb_get_args",
        "description": "Ruby before 2.4.2, 2.3.5, and 2.2.8 is vulnerable to a malicious format string which contains a precious specifier (*) with a huge minus value. Such situation can lead to a buffer overrun, resulting in a heap memory corruption or an information disclosure from the heap.",
        "git_url": "https://github.com/mruby/mruby/commit/1a3b32343ed9ebf287ae5a0f241877728e62bea5",
        "commit_title": "Copy argv from VM stack to avoid use-after-free; fix #3722",
        "commit_text": "",
        "func_before": "MRB_API mrb_int\nmrb_get_args(mrb_state *mrb, const char *format, ...)\n{\n  char c;\n  int i = 0;\n  va_list ap;\n  int argc = mrb->c->ci->argc;\n  int arg_i = 0;\n  mrb_bool array_argv;\n  mrb_bool opt = FALSE;\n  mrb_bool given = TRUE;\n\n  va_start(ap, format);\n  if (argc < 0) {\n    struct RArray *a = mrb_ary_ptr(mrb->c->stack[1]);\n\n    argc = a->len;\n    array_argv = TRUE;\n  }\n  else {\n    array_argv = FALSE;\n  }\n\n#define ARGV \\\n  (array_argv ? mrb_ary_ptr(mrb->c->stack[1])->ptr : (mrb->c->stack + 1))\n\n  while ((c = *format++)) {\n    switch (c) {\n    case '|': case '*': case '&': case '?':\n      break;\n    default:\n      if (argc <= i) {\n        if (opt) {\n          given = FALSE;\n        }\n        else {\n          mrb_raise(mrb, E_ARGUMENT_ERROR, \"wrong number of arguments\");\n        }\n      }\n      break;\n    }\n\n    switch (c) {\n    case 'o':\n      {\n        mrb_value *p;\n\n        p = va_arg(ap, mrb_value*);\n        if (i < argc) {\n          *p = ARGV[arg_i++];\n          i++;\n        }\n      }\n      break;\n    case 'C':\n      {\n        mrb_value *p;\n\n        p = va_arg(ap, mrb_value*);\n        if (i < argc) {\n          mrb_value ss;\n\n          ss = ARGV[arg_i++];\n          if (!class_ptr_p(ss)) {\n            mrb_raisef(mrb, E_TYPE_ERROR, \"%S is not class/module\", ss);\n          }\n          *p = ss;\n          i++;\n        }\n      }\n      break;\n    case 'S':\n      {\n        mrb_value *p;\n\n        p = va_arg(ap, mrb_value*);\n        if (*format == '!') {\n          format++;\n          if (i < argc && mrb_nil_p(ARGV[arg_i])) {\n            *p = ARGV[arg_i++];\n            i++;\n            break;\n          }\n        }\n        if (i < argc) {\n          *p = to_str(mrb, ARGV[arg_i++]);\n          i++;\n        }\n      }\n      break;\n    case 'A':\n      {\n        mrb_value *p;\n\n        p = va_arg(ap, mrb_value*);\n        if (*format == '!') {\n          format++;\n          if (i < argc && mrb_nil_p(ARGV[arg_i])) {\n            *p = ARGV[arg_i++];\n            i++;\n            break;\n          }\n        }\n        if (i < argc) {\n          *p = to_ary(mrb, ARGV[arg_i++]);\n          i++;\n        }\n      }\n      break;\n    case 'H':\n      {\n        mrb_value *p;\n\n        p = va_arg(ap, mrb_value*);\n        if (*format == '!') {\n          format++;\n          if (i < argc && mrb_nil_p(ARGV[arg_i])) {\n            *p = ARGV[arg_i++];\n            i++;\n            break;\n          }\n        }\n        if (i < argc) {\n          *p = to_hash(mrb, ARGV[arg_i++]);\n          i++;\n        }\n      }\n      break;\n    case 's':\n      {\n        mrb_value ss;\n        char **ps = 0;\n        mrb_int *pl = 0;\n\n        ps = va_arg(ap, char**);\n        pl = va_arg(ap, mrb_int*);\n        if (*format == '!') {\n          format++;\n          if (i < argc && mrb_nil_p(ARGV[arg_i])) {\n            *ps = NULL;\n            *pl = 0;\n            i++; arg_i++;\n            break;\n          }\n        }\n        if (i < argc) {\n          ss = to_str(mrb, ARGV[arg_i++]);\n          *ps = RSTRING_PTR(ss);\n          *pl = RSTRING_LEN(ss);\n          i++;\n        }\n      }\n      break;\n    case 'z':\n      {\n        mrb_value ss;\n        const char **ps;\n\n        ps = va_arg(ap, const char**);\n        if (*format == '!') {\n          format++;\n          if (i < argc && mrb_nil_p(ARGV[arg_i])) {\n            *ps = NULL;\n            i++; arg_i++;\n            break;\n          }\n        }\n        if (i < argc) {\n          ss = to_str(mrb, ARGV[arg_i++]);\n          *ps = mrb_string_value_cstr(mrb, &ss);\n          i++;\n        }\n      }\n      break;\n    case 'a':\n      {\n        mrb_value aa;\n        struct RArray *a;\n        mrb_value **pb;\n        mrb_int *pl;\n\n        pb = va_arg(ap, mrb_value**);\n        pl = va_arg(ap, mrb_int*);\n        if (*format == '!') {\n          format++;\n          if (i < argc && mrb_nil_p(ARGV[arg_i])) {\n            *pb = 0;\n            *pl = 0;\n            i++; arg_i++;\n            break;\n          }\n        }\n        if (i < argc) {\n          aa = to_ary(mrb, ARGV[arg_i++]);\n          a = mrb_ary_ptr(aa);\n          *pb = a->ptr;\n          *pl = a->len;\n          i++;\n        }\n      }\n      break;\n    case 'I':\n      {\n        void* *p;\n        mrb_value ss;\n\n        p = va_arg(ap, void**);\n        if (i < argc) {\n          ss = ARGV[arg_i];\n          if (mrb_type(ss) != MRB_TT_ISTRUCT)\n          {\n            mrb_raisef(mrb, E_TYPE_ERROR, \"%S is not inline struct\", ss);\n          }\n          *p = mrb_istruct_ptr(ss);\n          arg_i++;\n          i++;\n        }\n      }\n      break;\n    case 'f':\n      {\n        mrb_float *p;\n\n        p = va_arg(ap, mrb_float*);\n        if (i < argc) {\n          *p = mrb_to_flo(mrb, ARGV[arg_i]);\n          arg_i++;\n          i++;\n        }\n      }\n      break;\n    case 'i':\n      {\n        mrb_int *p;\n\n        p = va_arg(ap, mrb_int*);\n        if (i < argc) {\n          switch (mrb_type(ARGV[arg_i])) {\n            case MRB_TT_FIXNUM:\n              *p = mrb_fixnum(ARGV[arg_i]);\n              break;\n            case MRB_TT_FLOAT:\n              {\n                mrb_float f = mrb_float(ARGV[arg_i]);\n\n                if (!FIXABLE_FLOAT(f)) {\n                  mrb_raise(mrb, E_RANGE_ERROR, \"float too big for int\");\n                }\n                *p = (mrb_int)f;\n              }\n              break;\n            case MRB_TT_STRING:\n              mrb_raise(mrb, E_TYPE_ERROR, \"no implicit conversion of String into Integer\");\n              break;\n            default:\n              *p = mrb_fixnum(mrb_Integer(mrb, ARGV[arg_i]));\n              break;\n          }\n          arg_i++;\n          i++;\n        }\n      }\n      break;\n    case 'b':\n      {\n        mrb_bool *boolp = va_arg(ap, mrb_bool*);\n\n        if (i < argc) {\n          mrb_value b = ARGV[arg_i++];\n          *boolp = mrb_test(b);\n          i++;\n        }\n      }\n      break;\n    case 'n':\n      {\n        mrb_sym *symp;\n\n        symp = va_arg(ap, mrb_sym*);\n        if (i < argc) {\n          mrb_value ss;\n\n          ss = ARGV[arg_i++];\n          *symp = to_sym(mrb, ss);\n          i++;\n        }\n      }\n      break;\n    case 'd':\n      {\n        void** datap;\n        struct mrb_data_type const* type;\n\n        datap = va_arg(ap, void**);\n        type = va_arg(ap, struct mrb_data_type const*);\n        if (*format == '!') {\n          format++;\n          if (i < argc && mrb_nil_p(ARGV[arg_i])) {\n            *datap = 0;\n            i++; arg_i++;\n            break;\n          }\n        }\n        if (i < argc) {\n          *datap = mrb_data_get_ptr(mrb, ARGV[arg_i++], type);\n          ++i;\n        }\n      }\n      break;\n\n    case '&':\n      {\n        mrb_value *p, *bp;\n\n        p = va_arg(ap, mrb_value*);\n        if (mrb->c->ci->argc < 0) {\n          bp = mrb->c->stack + 2;\n        }\n        else {\n          bp = mrb->c->stack + mrb->c->ci->argc + 1;\n        }\n        *p = *bp;\n      }\n      break;\n    case '|':\n      opt = TRUE;\n      break;\n    case '?':\n      {\n        mrb_bool *p;\n\n        p = va_arg(ap, mrb_bool*);\n        *p = given;\n      }\n      break;\n\n    case '*':\n      {\n        mrb_value **var;\n        mrb_int *pl;\n\n        var = va_arg(ap, mrb_value**);\n        pl = va_arg(ap, mrb_int*);\n        if (argc > i) {\n          *pl = argc-i;\n          if (*pl > 0) {\n            *var = ARGV + arg_i;\n          }\n          i = argc;\n          arg_i += *pl;\n        }\n        else {\n          *pl = 0;\n          *var = NULL;\n        }\n      }\n      break;\n    default:\n      mrb_raisef(mrb, E_ARGUMENT_ERROR, \"invalid argument specifier %S\", mrb_str_new(mrb, &c, 1));\n      break;\n    }\n  }\n\n#undef ARGV\n\n  if (!c && argc > i) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"wrong number of arguments\");\n  }\n  va_end(ap);\n  return i;\n}",
        "func": "MRB_API mrb_int\nmrb_get_args(mrb_state *mrb, const char *format, ...)\n{\n  char c;\n  int i = 0;\n  va_list ap;\n  int argc = mrb->c->ci->argc;\n  int arg_i = 0;\n  mrb_bool array_argv;\n  mrb_bool opt = FALSE;\n  mrb_bool given = TRUE;\n\n  va_start(ap, format);\n  if (argc < 0) {\n    struct RArray *a = mrb_ary_ptr(mrb->c->stack[1]);\n\n    argc = a->len;\n    array_argv = TRUE;\n  }\n  else {\n    array_argv = FALSE;\n  }\n\n#define ARGV \\\n  (array_argv ? mrb_ary_ptr(mrb->c->stack[1])->ptr : (mrb->c->stack + 1))\n\n  while ((c = *format++)) {\n    switch (c) {\n    case '|': case '*': case '&': case '?':\n      break;\n    default:\n      if (argc <= i) {\n        if (opt) {\n          given = FALSE;\n        }\n        else {\n          mrb_raise(mrb, E_ARGUMENT_ERROR, \"wrong number of arguments\");\n        }\n      }\n      break;\n    }\n\n    switch (c) {\n    case 'o':\n      {\n        mrb_value *p;\n\n        p = va_arg(ap, mrb_value*);\n        if (i < argc) {\n          *p = ARGV[arg_i++];\n          i++;\n        }\n      }\n      break;\n    case 'C':\n      {\n        mrb_value *p;\n\n        p = va_arg(ap, mrb_value*);\n        if (i < argc) {\n          mrb_value ss;\n\n          ss = ARGV[arg_i++];\n          if (!class_ptr_p(ss)) {\n            mrb_raisef(mrb, E_TYPE_ERROR, \"%S is not class/module\", ss);\n          }\n          *p = ss;\n          i++;\n        }\n      }\n      break;\n    case 'S':\n      {\n        mrb_value *p;\n\n        p = va_arg(ap, mrb_value*);\n        if (*format == '!') {\n          format++;\n          if (i < argc && mrb_nil_p(ARGV[arg_i])) {\n            *p = ARGV[arg_i++];\n            i++;\n            break;\n          }\n        }\n        if (i < argc) {\n          *p = to_str(mrb, ARGV[arg_i++]);\n          i++;\n        }\n      }\n      break;\n    case 'A':\n      {\n        mrb_value *p;\n\n        p = va_arg(ap, mrb_value*);\n        if (*format == '!') {\n          format++;\n          if (i < argc && mrb_nil_p(ARGV[arg_i])) {\n            *p = ARGV[arg_i++];\n            i++;\n            break;\n          }\n        }\n        if (i < argc) {\n          *p = to_ary(mrb, ARGV[arg_i++]);\n          i++;\n        }\n      }\n      break;\n    case 'H':\n      {\n        mrb_value *p;\n\n        p = va_arg(ap, mrb_value*);\n        if (*format == '!') {\n          format++;\n          if (i < argc && mrb_nil_p(ARGV[arg_i])) {\n            *p = ARGV[arg_i++];\n            i++;\n            break;\n          }\n        }\n        if (i < argc) {\n          *p = to_hash(mrb, ARGV[arg_i++]);\n          i++;\n        }\n      }\n      break;\n    case 's':\n      {\n        mrb_value ss;\n        char **ps = 0;\n        mrb_int *pl = 0;\n\n        ps = va_arg(ap, char**);\n        pl = va_arg(ap, mrb_int*);\n        if (*format == '!') {\n          format++;\n          if (i < argc && mrb_nil_p(ARGV[arg_i])) {\n            *ps = NULL;\n            *pl = 0;\n            i++; arg_i++;\n            break;\n          }\n        }\n        if (i < argc) {\n          ss = to_str(mrb, ARGV[arg_i++]);\n          *ps = RSTRING_PTR(ss);\n          *pl = RSTRING_LEN(ss);\n          i++;\n        }\n      }\n      break;\n    case 'z':\n      {\n        mrb_value ss;\n        const char **ps;\n\n        ps = va_arg(ap, const char**);\n        if (*format == '!') {\n          format++;\n          if (i < argc && mrb_nil_p(ARGV[arg_i])) {\n            *ps = NULL;\n            i++; arg_i++;\n            break;\n          }\n        }\n        if (i < argc) {\n          ss = to_str(mrb, ARGV[arg_i++]);\n          *ps = mrb_string_value_cstr(mrb, &ss);\n          i++;\n        }\n      }\n      break;\n    case 'a':\n      {\n        mrb_value aa;\n        struct RArray *a;\n        mrb_value **pb;\n        mrb_int *pl;\n\n        pb = va_arg(ap, mrb_value**);\n        pl = va_arg(ap, mrb_int*);\n        if (*format == '!') {\n          format++;\n          if (i < argc && mrb_nil_p(ARGV[arg_i])) {\n            *pb = 0;\n            *pl = 0;\n            i++; arg_i++;\n            break;\n          }\n        }\n        if (i < argc) {\n          aa = to_ary(mrb, ARGV[arg_i++]);\n          a = mrb_ary_ptr(aa);\n          *pb = a->ptr;\n          *pl = a->len;\n          i++;\n        }\n      }\n      break;\n    case 'I':\n      {\n        void* *p;\n        mrb_value ss;\n\n        p = va_arg(ap, void**);\n        if (i < argc) {\n          ss = ARGV[arg_i];\n          if (mrb_type(ss) != MRB_TT_ISTRUCT)\n          {\n            mrb_raisef(mrb, E_TYPE_ERROR, \"%S is not inline struct\", ss);\n          }\n          *p = mrb_istruct_ptr(ss);\n          arg_i++;\n          i++;\n        }\n      }\n      break;\n    case 'f':\n      {\n        mrb_float *p;\n\n        p = va_arg(ap, mrb_float*);\n        if (i < argc) {\n          *p = mrb_to_flo(mrb, ARGV[arg_i]);\n          arg_i++;\n          i++;\n        }\n      }\n      break;\n    case 'i':\n      {\n        mrb_int *p;\n\n        p = va_arg(ap, mrb_int*);\n        if (i < argc) {\n          switch (mrb_type(ARGV[arg_i])) {\n            case MRB_TT_FIXNUM:\n              *p = mrb_fixnum(ARGV[arg_i]);\n              break;\n            case MRB_TT_FLOAT:\n              {\n                mrb_float f = mrb_float(ARGV[arg_i]);\n\n                if (!FIXABLE_FLOAT(f)) {\n                  mrb_raise(mrb, E_RANGE_ERROR, \"float too big for int\");\n                }\n                *p = (mrb_int)f;\n              }\n              break;\n            case MRB_TT_STRING:\n              mrb_raise(mrb, E_TYPE_ERROR, \"no implicit conversion of String into Integer\");\n              break;\n            default:\n              *p = mrb_fixnum(mrb_Integer(mrb, ARGV[arg_i]));\n              break;\n          }\n          arg_i++;\n          i++;\n        }\n      }\n      break;\n    case 'b':\n      {\n        mrb_bool *boolp = va_arg(ap, mrb_bool*);\n\n        if (i < argc) {\n          mrb_value b = ARGV[arg_i++];\n          *boolp = mrb_test(b);\n          i++;\n        }\n      }\n      break;\n    case 'n':\n      {\n        mrb_sym *symp;\n\n        symp = va_arg(ap, mrb_sym*);\n        if (i < argc) {\n          mrb_value ss;\n\n          ss = ARGV[arg_i++];\n          *symp = to_sym(mrb, ss);\n          i++;\n        }\n      }\n      break;\n    case 'd':\n      {\n        void** datap;\n        struct mrb_data_type const* type;\n\n        datap = va_arg(ap, void**);\n        type = va_arg(ap, struct mrb_data_type const*);\n        if (*format == '!') {\n          format++;\n          if (i < argc && mrb_nil_p(ARGV[arg_i])) {\n            *datap = 0;\n            i++; arg_i++;\n            break;\n          }\n        }\n        if (i < argc) {\n          *datap = mrb_data_get_ptr(mrb, ARGV[arg_i++], type);\n          ++i;\n        }\n      }\n      break;\n\n    case '&':\n      {\n        mrb_value *p, *bp;\n\n        p = va_arg(ap, mrb_value*);\n        if (mrb->c->ci->argc < 0) {\n          bp = mrb->c->stack + 2;\n        }\n        else {\n          bp = mrb->c->stack + mrb->c->ci->argc + 1;\n        }\n        *p = *bp;\n      }\n      break;\n    case '|':\n      opt = TRUE;\n      break;\n    case '?':\n      {\n        mrb_bool *p;\n\n        p = va_arg(ap, mrb_bool*);\n        *p = given;\n      }\n      break;\n\n    case '*':\n      {\n        mrb_value **var;\n        mrb_int *pl;\n\n        var = va_arg(ap, mrb_value**);\n        pl = va_arg(ap, mrb_int*);\n        if (argc > i) {\n          *pl = argc-i;\n          if (*pl > 0) {\n            mrb_value args = mrb_ary_new_from_values(mrb, *pl, ARGV+arg_i);\n            RARRAY(args)->c = NULL;\n            *var = (mrb_value*)RARRAY_PTR(args);\n          }\n          i = argc;\n          arg_i += *pl;\n        }\n        else {\n          *pl = 0;\n          *var = NULL;\n        }\n      }\n      break;\n    default:\n      mrb_raisef(mrb, E_ARGUMENT_ERROR, \"invalid argument specifier %S\", mrb_str_new(mrb, &c, 1));\n      break;\n    }\n  }\n\n#undef ARGV\n\n  if (!c && argc > i) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"wrong number of arguments\");\n  }\n  va_end(ap);\n  return i;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -344,7 +344,9 @@\n         if (argc > i) {\n           *pl = argc-i;\n           if (*pl > 0) {\n-            *var = ARGV + arg_i;\n+            mrb_value args = mrb_ary_new_from_values(mrb, *pl, ARGV+arg_i);\n+            RARRAY(args)->c = NULL;\n+            *var = (mrb_value*)RARRAY_PTR(args);\n           }\n           i = argc;\n           arg_i += *pl;",
        "diff_line_info": {
            "deleted_lines": [
                "            *var = ARGV + arg_i;"
            ],
            "added_lines": [
                "            mrb_value args = mrb_ary_new_from_values(mrb, *pl, ARGV+arg_i);",
                "            RARRAY(args)->c = NULL;",
                "            *var = (mrb_value*)RARRAY_PTR(args);"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-2852",
        "func_name": "kernel/git/linville/wireless/b43_request_firmware",
        "description": "Format string vulnerability in the b43_request_firmware function in drivers/net/wireless/b43/main.c in the Broadcom B43 wireless driver in the Linux kernel through 3.9.4 allows local users to gain privileges by leveraging root access and including format string specifiers in an fwpostfix modprobe parameter, leading to improper construction of an error message.",
        "git_url": "http://git.kernel.org/cgit/linux/kernel/git/linville/wireless.git/commit/?h=9538cbaab6e8b8046039b4b2eb6c9d614dc782bd",
        "commit_title": "The module parameter \"fwpostfix\" is userspace controllable, unfiltered,",
        "commit_text": "and is used to define the firmware filename. b43_do_request_fw() populates ctx->errors[] on error, containing the firmware filename. b43err() parses its arguments as a format string. For systems with b43 hardware, this could lead to a uid-0 to ring-0 escalation.  CVE-2013-2852  Cc: stable@vger.kernel.org ",
        "func_before": "static void b43_request_firmware(struct work_struct *work)\n{\n\tstruct b43_wl *wl = container_of(work,\n\t\t\t    struct b43_wl, firmware_load);\n\tstruct b43_wldev *dev = wl->current_dev;\n\tstruct b43_request_fw_context *ctx;\n\tunsigned int i;\n\tint err;\n\tconst char *errmsg;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn;\n\tctx->dev = dev;\n\n\tctx->req_type = B43_FWTYPE_PROPRIETARY;\n\terr = b43_try_request_fw(ctx);\n\tif (!err)\n\t\tgoto start_ieee80211; /* Successfully loaded it. */\n\t/* Was fw version known? */\n\tif (ctx->fatal_failure)\n\t\tgoto out;\n\n\t/* proprietary fw not found, try open source */\n\tctx->req_type = B43_FWTYPE_OPENSOURCE;\n\terr = b43_try_request_fw(ctx);\n\tif (!err)\n\t\tgoto start_ieee80211; /* Successfully loaded it. */\n\tif(ctx->fatal_failure)\n\t\tgoto out;\n\n\t/* Could not find a usable firmware. Print the errors. */\n\tfor (i = 0; i < B43_NR_FWTYPES; i++) {\n\t\terrmsg = ctx->errors[i];\n\t\tif (strlen(errmsg))\n\t\t\tb43err(dev->wl, errmsg);\n\t}\n\tb43_print_fw_helptext(dev->wl, 1);\n\tgoto out;\n\nstart_ieee80211:\n\twl->hw->queues = B43_QOS_QUEUE_NUM;\n\tif (!modparam_qos || dev->fw.opensource)\n\t\twl->hw->queues = 1;\n\n\terr = ieee80211_register_hw(wl->hw);\n\tif (err)\n\t\tgoto err_one_core_detach;\n\twl->hw_registred = true;\n\tb43_leds_register(wl->current_dev);\n\tgoto out;\n\nerr_one_core_detach:\n\tb43_one_core_detach(dev->dev);\n\nout:\n\tkfree(ctx);\n}",
        "func": "static void b43_request_firmware(struct work_struct *work)\n{\n\tstruct b43_wl *wl = container_of(work,\n\t\t\t    struct b43_wl, firmware_load);\n\tstruct b43_wldev *dev = wl->current_dev;\n\tstruct b43_request_fw_context *ctx;\n\tunsigned int i;\n\tint err;\n\tconst char *errmsg;\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn;\n\tctx->dev = dev;\n\n\tctx->req_type = B43_FWTYPE_PROPRIETARY;\n\terr = b43_try_request_fw(ctx);\n\tif (!err)\n\t\tgoto start_ieee80211; /* Successfully loaded it. */\n\t/* Was fw version known? */\n\tif (ctx->fatal_failure)\n\t\tgoto out;\n\n\t/* proprietary fw not found, try open source */\n\tctx->req_type = B43_FWTYPE_OPENSOURCE;\n\terr = b43_try_request_fw(ctx);\n\tif (!err)\n\t\tgoto start_ieee80211; /* Successfully loaded it. */\n\tif(ctx->fatal_failure)\n\t\tgoto out;\n\n\t/* Could not find a usable firmware. Print the errors. */\n\tfor (i = 0; i < B43_NR_FWTYPES; i++) {\n\t\terrmsg = ctx->errors[i];\n\t\tif (strlen(errmsg))\n\t\t\tb43err(dev->wl, \"%s\", errmsg);\n\t}\n\tb43_print_fw_helptext(dev->wl, 1);\n\tgoto out;\n\nstart_ieee80211:\n\twl->hw->queues = B43_QOS_QUEUE_NUM;\n\tif (!modparam_qos || dev->fw.opensource)\n\t\twl->hw->queues = 1;\n\n\terr = ieee80211_register_hw(wl->hw);\n\tif (err)\n\t\tgoto err_one_core_detach;\n\twl->hw_registred = true;\n\tb43_leds_register(wl->current_dev);\n\tgoto out;\n\nerr_one_core_detach:\n\tb43_one_core_detach(dev->dev);\n\nout:\n\tkfree(ctx);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -33,7 +33,7 @@\n \tfor (i = 0; i < B43_NR_FWTYPES; i++) {\n \t\terrmsg = ctx->errors[i];\n \t\tif (strlen(errmsg))\n-\t\t\tb43err(dev->wl, errmsg);\n+\t\t\tb43err(dev->wl, \"%s\", errmsg);\n \t}\n \tb43_print_fw_helptext(dev->wl, 1);\n \tgoto out;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tb43err(dev->wl, errmsg);"
            ],
            "added_lines": [
                "\t\t\tb43err(dev->wl, \"%s\", errmsg);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-35331",
        "func_name": "tcltk/tcl/SubstituteFile",
        "description": "In Tcl 8.6.11, a format string vulnerability in nmakehlp.c might allow code execution via a crafted file. NOTE: multiple third parties dispute the significance of this finding",
        "git_url": "https://github.com/tcltk/tcl/commit/4705dbdde2f32ff90420765cd93e7ac71d81a222",
        "commit_title": "Fix [bad6cc213d]: A format string vulnerability in Tcl nmakehelp.c allows code execution via a crated file.",
        "commit_text": "Also change a memcpy() to a memmove(), because the range could be overlapping",
        "func_before": "static int\nSubstituteFile(\n    const char *substitutions,\n    const char *filename)\n{\n    size_t cbBuffer = 1024;\n    static char szBuffer[1024], szCopy[1024];\n    char *szResult = NULL;\n    list_item_t *substPtr = NULL;\n    FILE *fp, *sp;\n\n    fp = fopen(filename, \"rt\");\n    if (fp != NULL) {\n\n\t/*\n\t * Build a list of substutitions from the first filename\n\t */\n\n\tsp = fopen(substitutions, \"rt\");\n\tif (sp != NULL) {\n\t    while (fgets(szBuffer, cbBuffer, sp) != NULL) {\n\t\tunsigned char *ks, *ke, *vs, *ve;\n\t\tks = (unsigned char*)szBuffer;\n\t\twhile (ks && *ks && isspace(*ks)) ++ks;\n\t\tke = ks;\n\t\twhile (ke && *ke && !isspace(*ke)) ++ke;\n\t\tvs = ke;\n\t\twhile (vs && *vs && isspace(*vs)) ++vs;\n\t\tve = vs;\n\t\twhile (ve && *ve && !(*ve == '\\r' || *ve == '\\n')) ++ve;\n\t\t*ke = 0, *ve = 0;\n\t\tlist_insert(&substPtr, (char*)ks, (char*)vs);\n\t    }\n\t    fclose(sp);\n\t}\n\n\t/* debug: dump the list */\n#ifndef NDEBUG\n\t{\n\t    int n = 0;\n\t    list_item_t *p = NULL;\n\t    for (p = substPtr; p != NULL; p = p->nextPtr, ++n) {\n\t\tfprintf(stderr, \"% 3d '%s' => '%s'\\n\", n, p->key, p->value);\n\t    }\n\t}\n#endif\n\n\t/*\n\t * Run the substitutions over each line of the input\n\t */\n\n\twhile (fgets(szBuffer, cbBuffer, fp) != NULL) {\n\t    list_item_t *p = NULL;\n\t    for (p = substPtr; p != NULL; p = p->nextPtr) {\n\t\tchar *m = strstr(szBuffer, p->key);\n\t\tif (m) {\n\t\t    char *cp, *op, *sp;\n\t\t    cp = szCopy;\n\t\t    op = szBuffer;\n\t\t    while (op != m) *cp++ = *op++;\n\t\t    sp = p->value;\n\t\t    while (sp && *sp) *cp++ = *sp++;\n\t\t    op += strlen(p->key);\n\t\t    while (*op) *cp++ = *op++;\n\t\t    *cp = 0;\n\t\t    memcpy(szBuffer, szCopy, sizeof(szCopy));\n\t\t}\n\t    }\n\t    printf(szBuffer);\n\t}\n\n\tlist_free(&substPtr);\n    }\n    fclose(fp);\n    return 0;\n}",
        "func": "static int\nSubstituteFile(\n    const char *substitutions,\n    const char *filename)\n{\n    size_t cbBuffer = 1024;\n    static char szBuffer[1024], szCopy[1024];\n    char *szResult = NULL;\n    list_item_t *substPtr = NULL;\n    FILE *fp, *sp;\n\n    fp = fopen(filename, \"rt\");\n    if (fp != NULL) {\n\n\t/*\n\t * Build a list of substutitions from the first filename\n\t */\n\n\tsp = fopen(substitutions, \"rt\");\n\tif (sp != NULL) {\n\t    while (fgets(szBuffer, cbBuffer, sp) != NULL) {\n\t\tunsigned char *ks, *ke, *vs, *ve;\n\t\tks = (unsigned char*)szBuffer;\n\t\twhile (ks && *ks && isspace(*ks)) ++ks;\n\t\tke = ks;\n\t\twhile (ke && *ke && !isspace(*ke)) ++ke;\n\t\tvs = ke;\n\t\twhile (vs && *vs && isspace(*vs)) ++vs;\n\t\tve = vs;\n\t\twhile (ve && *ve && !(*ve == '\\r' || *ve == '\\n')) ++ve;\n\t\t*ke = 0, *ve = 0;\n\t\tlist_insert(&substPtr, (char*)ks, (char*)vs);\n\t    }\n\t    fclose(sp);\n\t}\n\n\t/* debug: dump the list */\n#ifndef NDEBUG\n\t{\n\t    int n = 0;\n\t    list_item_t *p = NULL;\n\t    for (p = substPtr; p != NULL; p = p->nextPtr, ++n) {\n\t\tfprintf(stderr, \"% 3d '%s' => '%s'\\n\", n, p->key, p->value);\n\t    }\n\t}\n#endif\n\n\t/*\n\t * Run the substitutions over each line of the input\n\t */\n\n\twhile (fgets(szBuffer, cbBuffer, fp) != NULL) {\n\t    list_item_t *p = NULL;\n\t    for (p = substPtr; p != NULL; p = p->nextPtr) {\n\t\tchar *m = strstr(szBuffer, p->key);\n\t\tif (m) {\n\t\t    char *cp, *op, *sp;\n\t\t    cp = szCopy;\n\t\t    op = szBuffer;\n\t\t    while (op != m) *cp++ = *op++;\n\t\t    sp = p->value;\n\t\t    while (sp && *sp) *cp++ = *sp++;\n\t\t    op += strlen(p->key);\n\t\t    while (*op) *cp++ = *op++;\n\t\t    *cp = 0;\n\t\t    memcpy(szBuffer, szCopy, sizeof(szCopy));\n\t\t}\n\t    }\n\t    printf(\"%s\", szBuffer);\n\t}\n\n\tlist_free(&substPtr);\n    }\n    fclose(fp);\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -66,7 +66,7 @@\n \t\t    memcpy(szBuffer, szCopy, sizeof(szCopy));\n \t\t}\n \t    }\n-\t    printf(szBuffer);\n+\t    printf(\"%s\", szBuffer);\n \t}\n \n \tlist_free(&substPtr);",
        "diff_line_info": {
            "deleted_lines": [
                "\t    printf(szBuffer);"
            ],
            "added_lines": [
                "\t    printf(\"%s\", szBuffer);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-35331",
        "func_name": "tcltk/tcl/GetVersionFromFile",
        "description": "In Tcl 8.6.11, a format string vulnerability in nmakehlp.c might allow code execution via a crafted file. NOTE: multiple third parties dispute the significance of this finding",
        "git_url": "https://github.com/tcltk/tcl/commit/4705dbdde2f32ff90420765cd93e7ac71d81a222",
        "commit_title": "Fix [bad6cc213d]: A format string vulnerability in Tcl nmakehelp.c allows code execution via a crated file.",
        "commit_text": "Also change a memcpy() to a memmove(), because the range could be overlapping",
        "func_before": "static const char *\nGetVersionFromFile(\n    const char *filename,\n    const char *match,\n    int numdots)\n{\n    size_t cbBuffer = 100;\n    static char szBuffer[100];\n    char *szResult = NULL;\n    FILE *fp = fopen(filename, \"rt\");\n\n    if (fp != NULL) {\n\t/*\n\t * Read data until we see our match string.\n\t */\n\n\twhile (fgets(szBuffer, cbBuffer, fp) != NULL) {\n\t    LPSTR p, q;\n\n\t    p = strstr(szBuffer, match);\n\t    if (p != NULL) {\n\t\t/*\n\t\t * Skip to first digit after the match.\n\t\t */\n\n\t\tp += strlen(match);\n\t\twhile (*p && !isdigit(*p)) {\n\t\t    ++p;\n\t\t}\n\n\t\t/*\n\t\t * Find ending whitespace.\n\t\t */\n\n\t\tq = p;\n\t\twhile (*q && (strchr(\"0123456789.ab\", *q)) && ((!strchr(\".ab\", *q)\n\t\t\t    && (!strchr(\"ab\", q[-1])) || --numdots))) {\n\t\t    ++q;\n\t\t}\n\n\t\tmemcpy(szBuffer, p, q - p);\n\t\tszBuffer[q-p] = 0;\n\t\tszResult = szBuffer;\n\t\tbreak;\n\t    }\n\t}\n\tfclose(fp);\n    }\n    return szResult;\n}",
        "func": "static const char *\nGetVersionFromFile(\n    const char *filename,\n    const char *match,\n    int numdots)\n{\n    size_t cbBuffer = 100;\n    static char szBuffer[100];\n    char *szResult = NULL;\n    FILE *fp = fopen(filename, \"rt\");\n\n    if (fp != NULL) {\n\t/*\n\t * Read data until we see our match string.\n\t */\n\n\twhile (fgets(szBuffer, cbBuffer, fp) != NULL) {\n\t    LPSTR p, q;\n\n\t    p = strstr(szBuffer, match);\n\t    if (p != NULL) {\n\t\t/*\n\t\t * Skip to first digit after the match.\n\t\t */\n\n\t\tp += strlen(match);\n\t\twhile (*p && !isdigit(*p)) {\n\t\t    ++p;\n\t\t}\n\n\t\t/*\n\t\t * Find ending whitespace.\n\t\t */\n\n\t\tq = p;\n\t\twhile (*q && (strchr(\"0123456789.ab\", *q)) && ((!strchr(\".ab\", *q)\n\t\t\t    && (!strchr(\"ab\", q[-1])) || --numdots))) {\n\t\t    ++q;\n\t\t}\n\n\t\tmemmove(szBuffer, p, q - p);\n\t\tszBuffer[q-p] = 0;\n\t\tszResult = szBuffer;\n\t\tbreak;\n\t    }\n\t}\n\tfclose(fp);\n    }\n    return szResult;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -38,7 +38,7 @@\n \t\t    ++q;\n \t\t}\n \n-\t\tmemcpy(szBuffer, p, q - p);\n+\t\tmemmove(szBuffer, p, q - p);\n \t\tszBuffer[q-p] = 0;\n \t\tszResult = szBuffer;\n \t\tbreak;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tmemcpy(szBuffer, p, q - p);"
            ],
            "added_lines": [
                "\t\tmemmove(szBuffer, p, q - p);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-1000052",
        "func_name": "fmtlib/fmt/BasicWriter<Char>::prepare_int_buffer",
        "description": "fmtlib version prior to version 4.1.0 (before commit 0555cea5fc0bf890afe0071a558e44625a34ba85) contains a Memory corruption (SIGSEGV), CWE-134 vulnerability in fmt::print() library function that can result in Denial of Service. This attack appear to be exploitable via Specifying an invalid format specifier in the fmt::print() function results in a SIGSEGV (memory corruption, invalid write). This vulnerability appears to have been fixed in after commit 8cf30aa2be256eba07bb1cefb998c52326e846e7.",
        "git_url": "https://github.com/fmtlib/fmt/commit/8cf30aa2be256eba07bb1cefb998c52326e846e7",
        "commit_title": "Fix segfault on complex pointer formatting (#642)",
        "commit_text": "",
        "func_before": "typename BasicWriter<Char>::CharPtr\n  BasicWriter<Char>::prepare_int_buffer(\n    unsigned num_digits, const Spec &spec,\n    const char *prefix, unsigned prefix_size) {\n  unsigned width = spec.width();\n  Alignment align = spec.align();\n  Char fill = internal::CharTraits<Char>::cast(spec.fill());\n  if (spec.precision() > static_cast<int>(num_digits)) {\n    // Octal prefix '0' is counted as a digit, so ignore it if precision\n    // is specified.\n    if (prefix_size > 0 && prefix[prefix_size - 1] == '0')\n      --prefix_size;\n    unsigned number_size =\n        prefix_size + internal::to_unsigned(spec.precision());\n    AlignSpec subspec(number_size, '0', ALIGN_NUMERIC);\n    if (number_size >= width)\n      return prepare_int_buffer(num_digits, subspec, prefix, prefix_size);\n    buffer_.reserve(width);\n    unsigned fill_size = width - number_size;\n    if (align != ALIGN_LEFT) {\n      CharPtr p = grow_buffer(fill_size);\n      std::uninitialized_fill(p, p + fill_size, fill);\n    }\n    CharPtr result = prepare_int_buffer(\n        num_digits, subspec, prefix, prefix_size);\n    if (align == ALIGN_LEFT) {\n      CharPtr p = grow_buffer(fill_size);\n      std::uninitialized_fill(p, p + fill_size, fill);\n    }\n    return result;\n  }\n  unsigned size = prefix_size + num_digits;\n  if (width <= size) {\n    CharPtr p = grow_buffer(size);\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    return p + size - 1;\n  }\n  CharPtr p = grow_buffer(width);\n  CharPtr end = p + width;\n  if (align == ALIGN_LEFT) {\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    p += size;\n    std::uninitialized_fill(p, end, fill);\n  } else if (align == ALIGN_CENTER) {\n    p = fill_padding(p, width, size, fill);\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    p += size;\n  } else {\n    if (align == ALIGN_NUMERIC) {\n      if (prefix_size != 0) {\n        p = std::uninitialized_copy(prefix, prefix + prefix_size, p);\n        size -= prefix_size;\n      }\n    } else {\n      std::uninitialized_copy(prefix, prefix + prefix_size, end - size);\n    }\n    std::uninitialized_fill(p, end - size, fill);\n    p = end;\n  }\n  return p - 1;\n}",
        "func": "typename BasicWriter<Char>::CharPtr\n  BasicWriter<Char>::prepare_int_buffer(\n    unsigned num_digits, const Spec &spec,\n    const char *prefix, unsigned prefix_size) {\n  unsigned width = spec.width();\n  Alignment align = spec.align();\n  Char fill = internal::CharTraits<Char>::cast(spec.fill());\n  if (spec.precision() > static_cast<int>(num_digits)) {\n    // Octal prefix '0' is counted as a digit, so ignore it if precision\n    // is specified.\n    if (prefix_size > 0 && prefix[prefix_size - 1] == '0')\n      --prefix_size;\n    unsigned number_size =\n        prefix_size + internal::to_unsigned(spec.precision());\n    AlignSpec subspec(number_size, '0', ALIGN_NUMERIC);\n    if (number_size >= width)\n      return prepare_int_buffer(num_digits, subspec, prefix, prefix_size);\n    buffer_.reserve(width);\n    unsigned fill_size = width - number_size;\n    if (align != ALIGN_LEFT) {\n      CharPtr p = grow_buffer(fill_size);\n      std::uninitialized_fill(p, p + fill_size, fill);\n    }\n    std::ptrdiff_t offset = get(prepare_int_buffer(\n        num_digits, subspec, prefix, prefix_size)) - &buffer_[0];\n    if (align == ALIGN_LEFT) {\n      CharPtr p = grow_buffer(fill_size);\n      std::uninitialized_fill(p, p + fill_size, fill);\n    }\n    return internal::make_ptr(&buffer_[0], buffer_.size()) + offset;\n  }\n  unsigned size = prefix_size + num_digits;\n  if (width <= size) {\n    CharPtr p = grow_buffer(size);\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    return p + size - 1;\n  }\n  CharPtr p = grow_buffer(width);\n  CharPtr end = p + width;\n  if (align == ALIGN_LEFT) {\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    p += size;\n    std::uninitialized_fill(p, end, fill);\n  } else if (align == ALIGN_CENTER) {\n    p = fill_padding(p, width, size, fill);\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    p += size;\n  } else {\n    if (align == ALIGN_NUMERIC) {\n      if (prefix_size != 0) {\n        p = std::uninitialized_copy(prefix, prefix + prefix_size, p);\n        size -= prefix_size;\n      }\n    } else {\n      std::uninitialized_copy(prefix, prefix + prefix_size, end - size);\n    }\n    std::uninitialized_fill(p, end - size, fill);\n    p = end;\n  }\n  return p - 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,13 +21,13 @@\n       CharPtr p = grow_buffer(fill_size);\n       std::uninitialized_fill(p, p + fill_size, fill);\n     }\n-    CharPtr result = prepare_int_buffer(\n-        num_digits, subspec, prefix, prefix_size);\n+    std::ptrdiff_t offset = get(prepare_int_buffer(\n+        num_digits, subspec, prefix, prefix_size)) - &buffer_[0];\n     if (align == ALIGN_LEFT) {\n       CharPtr p = grow_buffer(fill_size);\n       std::uninitialized_fill(p, p + fill_size, fill);\n     }\n-    return result;\n+    return internal::make_ptr(&buffer_[0], buffer_.size()) + offset;\n   }\n   unsigned size = prefix_size + num_digits;\n   if (width <= size) {",
        "diff_line_info": {
            "deleted_lines": [
                "    CharPtr result = prepare_int_buffer(",
                "        num_digits, subspec, prefix, prefix_size);",
                "    return result;"
            ],
            "added_lines": [
                "    std::ptrdiff_t offset = get(prepare_int_buffer(",
                "        num_digits, subspec, prefix, prefix_size)) - &buffer_[0];",
                "    return internal::make_ptr(&buffer_[0], buffer_.size()) + offset;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-36619",
        "func_name": "EliasOenal/multimon-ng/add_ch",
        "description": "A vulnerability was found in multimon-ng. It has been rated as critical. This issue affects the function add_ch of the file demod_flex.c. The manipulation of the argument ch leads to format string. Upgrading to version 1.2.0 is able to address this issue. The name of the patch is e5a51c508ef952e81a6da25b43034dd1ed023c07. It is recommended to upgrade the affected component. The identifier VDB-216269 was assigned to this vulnerability.",
        "git_url": "https://github.com/EliasOenal/multimon-ng/commit/e5a51c508ef952e81a6da25b43034dd1ed023c07",
        "commit_title": "Remove uncontrolled format string vulnerability",
        "commit_text": "",
        "func_before": "unsigned int add_ch(unsigned char ch, unsigned char* buf, unsigned int idx) {\n    // avoid buffer overflow that has been happening\n    if (idx >= MAX_ALN) {\n        verbprintf(3, \"FLEX: idx %u >= MAX_ALN %u\\n\", idx, MAX_ALN);\n        return 0;\n    }\n    // TODO sanitize % or you will have uncontrolled format string vuln\n    // Originally, this only avoided storing ETX (end of text, 0x03).\n    // At minimum you'll also want to avoid storing NULL (str term, 0x00),\n    // otherwise verbprintf will truncate the message.\n    //   ex: if (ch != 0x03 && ch != 0x00) { buf[idx] = ch; return 1; }\n    // But while we are here, make it print friendly and get it onto a single line\n    //   * remove awkward ctrl chars (del, bs, bell, vertical tab, etc)\n    //   * encode valuable ctrl chars (new line/line feed, carriage ret, tab)\n    // NOTE: if you post process FLEX ALN output by sed/grep/awk etc on non-printables\n    //   then double check this doesn't mess with your pipeline\n    if (ch == 0x09 && idx < (MAX_ALN - 2)) {  // '\\t'\n        buf[idx] = '\\\\';\n        buf[idx + 1] = 't';\n        return 2;\n    }\n    if (ch == 0x0a && idx < (MAX_ALN - 2)) {  // '\\n'\n        buf[idx] = '\\\\';\n        buf[idx + 1] = 'n';\n        return 2;\n    }\n    if (ch == 0x0d && idx < (MAX_ALN - 2)) {  // '\\r'\n        buf[idx] = '\\\\';\n        buf[idx + 1] = 'r';\n        return 2;\n    }\n    // only store ASCII printable\n    if (ch >= 32 && ch <= 126) {\n        buf[idx] = ch;\n        return 1;\n    }\n    // if you want all non-printables, show as hex, but also make MAX_ALN 1024\n    /* if (idx < (MAX_ALN - 4)) {\n        sprintf(buf + idx, \"\\\\x%02x\", ch);\n        return 4;\n    }*/\n    return 0;\n}",
        "func": "unsigned int add_ch(unsigned char ch, unsigned char* buf, unsigned int idx) {\n    // avoid buffer overflow that has been happening\n    if (idx >= MAX_ALN) {\n        verbprintf(3, \"FLEX: idx %u >= MAX_ALN %u\\n\", idx, MAX_ALN);\n        return 0;\n    }\n    // TODO sanitize % or you will have uncontrolled format string vuln\n    // Originally, this only avoided storing ETX (end of text, 0x03).\n    // At minimum you'll also want to avoid storing NULL (str term, 0x00),\n    // otherwise verbprintf will truncate the message.\n    //   ex: if (ch != 0x03 && ch != 0x00) { buf[idx] = ch; return 1; }\n    // But while we are here, make it print friendly and get it onto a single line\n    //   * remove awkward ctrl chars (del, bs, bell, vertical tab, etc)\n    //   * encode valuable ctrl chars (new line/line feed, carriage ret, tab)\n    // NOTE: if you post process FLEX ALN output by sed/grep/awk etc on non-printables\n    //   then double check this doesn't mess with your pipeline\n    if (ch == 0x09 && idx < (MAX_ALN - 2)) {  // '\\t'\n        buf[idx] = '\\\\';\n        buf[idx + 1] = 't';\n        return 2;\n    }\n    if (ch == 0x0a && idx < (MAX_ALN - 2)) {  // '\\n'\n        buf[idx] = '\\\\';\n        buf[idx + 1] = 'n';\n        return 2;\n    }\n    if (ch == 0x0d && idx < (MAX_ALN - 2)) {  // '\\r'\n        buf[idx] = '\\\\';\n        buf[idx + 1] = 'r';\n        return 2;\n    }\n    // unixinput.c::_verbprintf uses this output as a format string\n    // which introduces an uncontrolled format string vulnerability\n    // and also, generally, risks stack corruption\n    if (ch == '%') {\n        if (idx < (MAX_ALN - 2)) {\n            buf[idx] = '%';\n            buf[idx + 1] = '%';\n            return 2;\n        }\n        return 0;\n    }\n    // only store ASCII printable\n    if (ch >= 32 && ch <= 126) {\n        buf[idx] = ch;\n        return 1;\n    }\n    // if you want all non-printables, show as hex, but also make MAX_ALN 1024\n    /* if (idx < (MAX_ALN - 4)) {\n        sprintf(buf + idx, \"\\\\x%02x\", ch);\n        return 4;\n    }*/\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -29,6 +29,17 @@\n         buf[idx + 1] = 'r';\n         return 2;\n     }\n+    // unixinput.c::_verbprintf uses this output as a format string\n+    // which introduces an uncontrolled format string vulnerability\n+    // and also, generally, risks stack corruption\n+    if (ch == '%') {\n+        if (idx < (MAX_ALN - 2)) {\n+            buf[idx] = '%';\n+            buf[idx + 1] = '%';\n+            return 2;\n+        }\n+        return 0;\n+    }\n     // only store ASCII printable\n     if (ch >= 32 && ch <= 126) {\n         buf[idx] = ch;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    // unixinput.c::_verbprintf uses this output as a format string",
                "    // which introduces an uncontrolled format string vulnerability",
                "    // and also, generally, risks stack corruption",
                "    if (ch == '%') {",
                "        if (idx < (MAX_ALN - 2)) {",
                "            buf[idx] = '%';",
                "            buf[idx + 1] = '%';",
                "            return 2;",
                "        }",
                "        return 0;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-4639",
        "func_name": "yrutschle/sslh/hexdump",
        "description": "A vulnerability, which was classified as critical, has been found in sslh. This issue affects the function hexdump of the file probe.c of the component Packet Dumping Handler. The manipulation of the argument msg_info leads to format string. The attack may be initiated remotely. The name of the patch is b19f8a6046b080e4c2e28354a58556bb26040c6f. It is recommended to apply a patch to fix this issue. The identifier VDB-216497 was assigned to this vulnerability.",
        "git_url": "https://github.com/yrutschle/sslh/commit/b19f8a6046b080e4c2e28354a58556bb26040c6f",
        "commit_title": "fix possible format string exploit if packet dumping enabled",
        "commit_text": "",
        "func_before": "void hexdump(msg_info msg_info, const char *mem, unsigned int len)\n{\n    unsigned int i, j;\n    char str[10 + HEXDUMP_COLS * 4 + 2];\n    int c = 0; /* index in str */\n\n    for(i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++)\n    {\n        /* print offset */\n        if(i % HEXDUMP_COLS == 0)\n            c += sprintf(&str[c], \"0x%06x: \", i);\n\n        /* print hex data */\n        if(i < len)\n            c += sprintf(&str[c], \"%02x \", 0xFF & mem[i]);\n        else /* end of block, just aligning for ASCII dump */\n            c+= sprintf(&str[c], \"   \");\n\n        /* print ASCII dump */\n        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {\n            for(j = i - (HEXDUMP_COLS - 1); j <= i; j++) {\n                if(j >= len) /* end of block, not really printing */\n                    str[c++] = ' ';\n                else if(isprint(mem[j])) /* printable char */\n                    str[c++] = 0xFF & mem[j];\n                else /* other char */\n                    str[c++] = '.';\n            }\n            str[c++] = '\\n';\n            str[c++] = 0;\n            print_message(msg_info, str);\n            c = 0;\n        }\n    }\n}",
        "func": "void hexdump(msg_info msg_info, const char *mem, unsigned int len)\n{\n    unsigned int i, j;\n    char str[10 + HEXDUMP_COLS * 4 + 2];\n    int c = 0; /* index in str */\n\n    for(i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++)\n    {\n        /* print offset */\n        if(i % HEXDUMP_COLS == 0)\n            c += sprintf(&str[c], \"0x%06x: \", i);\n\n        /* print hex data */\n        if(i < len)\n            c += sprintf(&str[c], \"%02x \", 0xFF & mem[i]);\n        else /* end of block, just aligning for ASCII dump */\n            c+= sprintf(&str[c], \"   \");\n\n        /* print ASCII dump */\n        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {\n            for(j = i - (HEXDUMP_COLS - 1); j <= i; j++) {\n                if(j >= len) /* end of block, not really printing */\n                    str[c++] = ' ';\n                else if(isprint(mem[j])) /* printable char */\n                    str[c++] = 0xFF & mem[j];\n                else /* other char */\n                    str[c++] = '.';\n            }\n            str[c++] = '\\n';\n            str[c++] = 0;\n            print_message(msg_info, \"%s\", str);\n            c = 0;\n        }\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,7 +28,7 @@\n             }\n             str[c++] = '\\n';\n             str[c++] = 0;\n-            print_message(msg_info, str);\n+            print_message(msg_info, \"%s\", str);\n             c = 0;\n         }\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "            print_message(msg_info, str);"
            ],
            "added_lines": [
                "            print_message(msg_info, \"%s\", str);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41193",
        "func_name": "wireapp/wire-avs/audio_level_json",
        "description": "wire-avs is the audio visual signaling (AVS) component of Wire, an open-source messenger. A remote format string vulnerability in versions prior to 7.1.12 allows an attacker to cause a denial of service or possibly execute arbitrary code. The issue has been fixed in wire-avs 7.1.12. There are currently no known workarounds.",
        "git_url": "https://github.com/wireapp/wire-avs/commit/40d373ede795443ae6f2f756e9fb1f4f4ae90bbe",
        "commit_title": "Import latest release-7.1 files from old repo",
        "commit_text": "",
        "func_before": "int audio_level_json(struct list *levell,\n\t\t     const char *userid_self, const char *clientid_self,\n\t\t     char **json_str, char **anon_str)\n{\n\tstruct json_object *jobj;\n\tstruct json_object *jarr;\n\tchar uid_anon[ANON_ID_LEN];\n\tchar cid_anon[ANON_CLIENT_LEN];\n\tstruct mbuf *pmb = NULL;\n\tint err = 0;\n\tstruct le *le;\n\n\tif (!levell || !json_str)\n\t\treturn EINVAL;\n\t\n\tjobj = jzon_alloc_object();\n\tif (!jobj)\n\t\treturn ENOMEM;\n\n\tjarr = jzon_alloc_array();\n\tif (!jarr) {\n\t\terr = ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (anon_str) {\n\t\tpmb = mbuf_alloc(512);\n\t\tmbuf_printf(pmb, \"%zu levels: \", list_count(levell));\n\t}\n\t\n\tLIST_FOREACH(levell, le) {\n\t\tstruct audio_level *a = le->data;\n\t\tstruct json_object *ja;\n\t\tconst char *userid = a->userid;\n\t\tconst char *clientid = a->clientid;\n\n\t\tif (a->is_self) {\n\t\t\tif (userid_self)\n\t\t\t\tuserid = userid_self;\n\t\t\tif (clientid_self)\n\t\t\t\tclientid = clientid_self;\n\t\t}\n\n\t\tja = jzon_alloc_object();\n\t\tif (ja) {\n\t\t\tjzon_add_str(ja, \"userid\", userid);\n\t\t\tjzon_add_str(ja, \"clientid\", clientid);\n\t\t\tjzon_add_int(ja, \"audio_level\",\n\t\t\t\t     (int32_t)a->aulevel_smooth);\n\t\t\tjzon_add_int(ja, \"audio_level_now\",\n\t\t\t\t     (int32_t)a->aulevel);\n\t\t}\n\t\tjson_object_array_add(jarr, ja);\n\n\t\t/* add to info string */\n\t\tif (pmb) {\n\t\t\tanon_id(uid_anon, userid);\n\t\t\tanon_client(cid_anon, clientid);\n\t\t\tmbuf_printf(pmb, \"{[%s.%s] audio_level: %d/%d}\",\n\t\t\t\t    uid_anon, cid_anon,\n\t\t\t\t    a->aulevel_smooth, a->aulevel);\n\t\t\tif (le != levell->tail)\n\t\t\t\tmbuf_printf(pmb, \",\");\n\t\t}\t\t\n\t}\n\tjson_object_object_add(jobj, \"audio_levels\", jarr);\n\n\tif (pmb) {\n\t\tpmb->pos = 0;\n\t\tmbuf_strdup(pmb, anon_str, pmb->end);\n\t\tmem_deref(pmb);\n\t}\n\n\tjzon_encode(json_str, jobj);\n out:\t\n\tmem_deref(jobj);\n\n\treturn err;\n}",
        "func": "int audio_level_json(struct list *levell,\n\t\t     const char *userid_self, const char *clientid_self,\n\t\t     char **json_str, char **anon_str)\n{\n\tstruct json_object *jobj;\n\tstruct json_object *jarr;\n\tchar uid_anon[ANON_ID_LEN];\n\tchar cid_anon[ANON_CLIENT_LEN];\n\tstruct mbuf *pmb = NULL;\n\tint err = 0;\n\tstruct le *le;\n\n\tif (!levell || !json_str)\n\t\treturn EINVAL;\n\t\n\tjobj = jzon_alloc_object();\n\tif (!jobj)\n\t\treturn ENOMEM;\n\n\tjarr = jzon_alloc_array();\n\tif (!jarr) {\n\t\terr = ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (anon_str) {\n\t\tpmb = mbuf_alloc(512);\n\t\tmbuf_printf(pmb, \"%zu levels: \", list_count(levell));\n\t}\n\t\n\tLIST_FOREACH(levell, le) {\n\t\tstruct audio_level *a = le->data;\n\t\tstruct json_object *ja;\n\t\tconst char *userid = a->userid;\n\t\tconst char *clientid = a->clientid;\n\n\t\tif (a->is_self) {\n\t\t\tif (userid_self)\n\t\t\t\tuserid = userid_self;\n\t\t\tif (clientid_self)\n\t\t\t\tclientid = clientid_self;\n\t\t}\n\n\t\tja = jzon_alloc_object();\n\t\tif (ja) {\n\t\t\tjzon_add_str(ja, \"userid\", \"%s\", userid);\n\t\t\tjzon_add_str(ja, \"clientid\", \"%s\", clientid);\n\t\t\tjzon_add_int(ja, \"audio_level\",\n\t\t\t\t     (int32_t)a->aulevel_smooth);\n\t\t\tjzon_add_int(ja, \"audio_level_now\",\n\t\t\t\t     (int32_t)a->aulevel);\n\t\t}\n\t\tjson_object_array_add(jarr, ja);\n\n\t\t/* add to info string */\n\t\tif (pmb) {\n\t\t\tanon_id(uid_anon, userid);\n\t\t\tanon_client(cid_anon, clientid);\n\t\t\tmbuf_printf(pmb, \"{[%s.%s] audio_level: %d/%d}\",\n\t\t\t\t    uid_anon, cid_anon,\n\t\t\t\t    a->aulevel_smooth, a->aulevel);\n\t\t\tif (le != levell->tail)\n\t\t\t\tmbuf_printf(pmb, \",\");\n\t\t}\t\t\n\t}\n\tjson_object_object_add(jobj, \"audio_levels\", jarr);\n\n\tif (pmb) {\n\t\tpmb->pos = 0;\n\t\tmbuf_strdup(pmb, anon_str, pmb->end);\n\t\tmem_deref(pmb);\n\t}\n\n\tjzon_encode(json_str, jobj);\n out:\t\n\tmem_deref(jobj);\n\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -43,8 +43,8 @@\n \n \t\tja = jzon_alloc_object();\n \t\tif (ja) {\n-\t\t\tjzon_add_str(ja, \"userid\", userid);\n-\t\t\tjzon_add_str(ja, \"clientid\", clientid);\n+\t\t\tjzon_add_str(ja, \"userid\", \"%s\", userid);\n+\t\t\tjzon_add_str(ja, \"clientid\", \"%s\", clientid);\n \t\t\tjzon_add_int(ja, \"audio_level\",\n \t\t\t\t     (int32_t)a->aulevel_smooth);\n \t\t\tjzon_add_int(ja, \"audio_level_now\",",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tjzon_add_str(ja, \"userid\", userid);",
                "\t\t\tjzon_add_str(ja, \"clientid\", clientid);"
            ],
            "added_lines": [
                "\t\t\tjzon_add_str(ja, \"userid\", \"%s\", userid);",
                "\t\t\tjzon_add_str(ja, \"clientid\", \"%s\", clientid);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41193",
        "func_name": "wireapp/wire-avs/econn_message_encode",
        "description": "wire-avs is the audio visual signaling (AVS) component of Wire, an open-source messenger. A remote format string vulnerability in versions prior to 7.1.12 allows an attacker to cause a denial of service or possibly execute arbitrary code. The issue has been fixed in wire-avs 7.1.12. There are currently no known workarounds.",
        "git_url": "https://github.com/wireapp/wire-avs/commit/40d373ede795443ae6f2f756e9fb1f4f4ae90bbe",
        "commit_title": "Import latest release-7.1 files from old repo",
        "commit_text": "",
        "func_before": "int econn_message_encode(char **strp, const struct econn_message *msg)\n{\n\tstruct json_object *jobj = NULL;\n\tchar *str = NULL;\n\tint err;\n\n\tif (!strp || !msg)\n\t\treturn EINVAL;\n\n\terr = jzon_creatf(&jobj, \"sss\",\n\t\t\t  \"version\", econn_proto_version,\n\t\t\t  \"type\",   econn_msg_name(msg->msg_type),\n\t\t\t  \"sessid\", msg->sessid_sender);\n\tif (err)\n\t\treturn err;\n\n\tif (str_isset(msg->src_userid)) {\n\t\terr = jzon_add_str(jobj, \"src_userid\", \"%s\", msg->src_userid);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (str_isset(msg->src_clientid)) {\n\t\terr = jzon_add_str(jobj, \"src_clientid\",\n\t\t\t\t   \"%s\", msg->src_clientid);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (str_isset(msg->dest_userid)) {\n\t\terr = jzon_add_str(jobj, \"dest_userid\",\n\t\t\t\t   \"%s\", msg->dest_userid);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (str_isset(msg->dest_clientid)) {\n\t\terr = jzon_add_str(jobj, \"dest_clientid\",\n\t\t\t\t   \"%s\", msg->dest_clientid);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = jzon_add_bool(jobj, \"resp\", msg->resp);\n\tif (err)\n\t\tgoto out;\n\n\tswitch (msg->msg_type) {\n\n\tcase ECONN_SETUP:\n\tcase ECONN_GROUP_SETUP:\n\tcase ECONN_UPDATE:\n\t\terr = jzon_add_str(jobj, \"sdp\", \"%s\", msg->u.setup.sdp_msg);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t/* props is optional for SETUP */\n\t\tif (msg->u.setup.props) {\n\t\t\terr = econn_props_encode(jobj, msg->u.setup.props);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (msg->u.setup.url) {\n\t\t\terr = jzon_add_str(jobj, \"url\", \"%s\", msg->u.setup.url);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\n\tcase ECONN_CANCEL:\n\t\tbreak;\n\n\tcase ECONN_HANGUP:\n\t\tbreak;\n\n\tcase ECONN_REJECT:\n\t\tbreak;\n\n\tcase ECONN_PROPSYNC:\n\n\t\t/* props is mandatory for PROPSYNC */\n\t\tif (!msg->u.propsync.props) {\n\t\t\twarning(\"propsync: missing props\\n\");\n\t\t\terr = EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = econn_props_encode(jobj, msg->u.propsync.props);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase ECONN_GROUP_START:\n\t\t/* props is optional for GROUPSTART */\n\t\tif (msg->u.groupstart.props) {\n\t\t\terr = econn_props_encode(jobj, msg->u.groupstart.props);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\n\tcase ECONN_GROUP_LEAVE:\n\tcase ECONN_GROUP_CHECK:\n\t\tbreak;\n\n\tcase ECONN_CONF_CONN:\n\t\tif (msg->u.confconn.turnc > 0) {\n\t\t\terr = zapi_iceservers_encode(jobj,\n\t\t\t\t\t\t     msg->u.confconn.turnv,\n\t\t\t\t\t\t     msg->u.confconn.turnc);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tjzon_add_bool(jobj, \"update\",\n\t\t\t      msg->u.confconn.update);\n\t\tjzon_add_str(jobj, \"tool\",\n\t\t\t      msg->u.confconn.tool);\n\t\tjzon_add_str(jobj, \"toolver\",\n\t\t\t      msg->u.confconn.toolver);\n\t\tjzon_add_int(jobj, \"status\",\n\t\t\t      msg->u.confconn.status);\n\t\tjzon_add_bool(jobj, \"selective_audio\",\n\t\t\t      msg->u.confconn.selective_audio);\n\t\tjzon_add_bool(jobj, \"selective_video\",\n\t\t\t      msg->u.confconn.selective_video);\n\t\tjzon_add_int(jobj, \"vstreams\",\n\t\t\t      msg->u.confconn.vstreams);\n\t\tbreak;\n\n\tcase ECONN_CONF_START:\n\t\tjzon_add_str(jobj, \"sft_url\", \"%s\", msg->u.confstart.sft_url);\n\t\tjzon_add_base64(jobj, \"secret\",\n\t\t\t\tmsg->u.confstart.secret, msg->u.confstart.secretlen);\n\t\tjzon_add_str(jobj, \"timestamp\", \"%llu\", msg->u.confstart.timestamp);\n\t\tjzon_add_str(jobj, \"seqno\", \"%u\", msg->u.confstart.seqno);\n\t\t/* props is optional for CONFSTART */\n\t\tif (msg->u.confstart.props) {\n\t\t\terr = econn_props_encode(jobj, msg->u.confstart.props);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\n\tcase ECONN_CONF_CHECK:\n\t\tjzon_add_str(jobj, \"sft_url\", \"%s\", msg->u.confcheck.sft_url);\n\t\tjzon_add_base64(jobj, \"secret\",\n\t\t\t\tmsg->u.confcheck.secret, msg->u.confcheck.secretlen);\n\t\tjzon_add_str(jobj, \"timestamp\", \"%llu\", msg->u.confcheck.timestamp);\n\t\tjzon_add_str(jobj, \"seqno\", \"%u\", msg->u.confcheck.seqno);\n\t\tbreak;\n\n\tcase ECONN_CONF_END:\n\t\tbreak;\n\n\tcase ECONN_CONF_PART:\n\t\tjzon_add_bool(jobj, \"should_start\",\n\t\t\t      msg->u.confpart.should_start);\n\t\tjzon_add_str(jobj, \"timestamp\", \"%llu\", msg->u.confpart.timestamp);\n\t\tjzon_add_str(jobj, \"seqno\", \"%u\", msg->u.confpart.seqno);\n\t\tjzon_add_base64(jobj, \"entropy\",\n\t\t\t\tmsg->u.confpart.entropy, msg->u.confpart.entropylen);\n\t\teconn_parts_encode(jobj, &msg->u.confpart.partl);\n\t\tbreak;\n\n\tcase ECONN_CONF_KEY:\n\t\teconn_keys_encode(jobj, &msg->u.confkey.keyl);\n\t\tbreak;\n\n\tcase ECONN_DEVPAIR_PUBLISH:\n\t\terr = zapi_iceservers_encode(jobj,\n\t\t\t\t\t     msg->u.devpair_publish.turnv,\n\t\t\t\t\t     msg->u.devpair_publish.turnc);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = jzon_add_str(jobj, \"sdp\",\n\t\t\t\t   \"%s\", msg->u.devpair_publish.sdp);\n\t\terr |= jzon_add_str(jobj, \"username\",\n\t\t\t\t    \"%s\", msg->u.devpair_publish.username);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase ECONN_DEVPAIR_ACCEPT:\n\t\terr = jzon_add_str(jobj, \"sdp\",\n\t\t\t\t   \"%s\", msg->u.devpair_accept.sdp);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase ECONN_ALERT:\n\t\terr  = jzon_add_int(jobj, \"level\", msg->u.alert.level);\n\t\terr |= jzon_add_str(jobj, \"descr\", \"%s\", msg->u.alert.descr);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase ECONN_PING:\n\t\tbreak;\n\n\tdefault:\n\t\twarning(\"econn: dont know how to encode %d\\n\", msg->msg_type);\n\t\terr = EBADMSG;\n\t\tbreak;\n\t}\n\tif (err)\n\t\tgoto out;\n\n\terr = jzon_encode(&str, jobj);\n\tif (err)\n\t\tgoto out;\n\n out:\n\tmem_deref(jobj);\n\tif (err)\n\t\tmem_deref(str);\n\telse\n\t\t*strp = str;\n\n\treturn err;\n}",
        "func": "int econn_message_encode(char **strp, const struct econn_message *msg)\n{\n\tstruct json_object *jobj = NULL;\n\tchar *str = NULL;\n\tint err;\n\n\tif (!strp || !msg)\n\t\treturn EINVAL;\n\n\terr = jzon_creatf(&jobj, \"sss\",\n\t\t\t  \"version\", econn_proto_version,\n\t\t\t  \"type\",   econn_msg_name(msg->msg_type),\n\t\t\t  \"sessid\", msg->sessid_sender);\n\tif (err)\n\t\treturn err;\n\n\tif (str_isset(msg->src_userid)) {\n\t\terr = jzon_add_str(jobj, \"src_userid\", \"%s\", msg->src_userid);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (str_isset(msg->src_clientid)) {\n\t\terr = jzon_add_str(jobj, \"src_clientid\",\n\t\t\t\t   \"%s\", msg->src_clientid);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (str_isset(msg->dest_userid)) {\n\t\terr = jzon_add_str(jobj, \"dest_userid\",\n\t\t\t\t   \"%s\", msg->dest_userid);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (str_isset(msg->dest_clientid)) {\n\t\terr = jzon_add_str(jobj, \"dest_clientid\",\n\t\t\t\t   \"%s\", msg->dest_clientid);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = jzon_add_bool(jobj, \"resp\", msg->resp);\n\tif (err)\n\t\tgoto out;\n\n\tswitch (msg->msg_type) {\n\n\tcase ECONN_SETUP:\n\tcase ECONN_GROUP_SETUP:\n\tcase ECONN_UPDATE:\n\t\terr = jzon_add_str(jobj, \"sdp\", \"%s\", msg->u.setup.sdp_msg);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t/* props is optional for SETUP */\n\t\tif (msg->u.setup.props) {\n\t\t\terr = econn_props_encode(jobj, msg->u.setup.props);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tif (msg->u.setup.url) {\n\t\t\terr = jzon_add_str(jobj, \"url\", \"%s\", msg->u.setup.url);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\n\tcase ECONN_CANCEL:\n\t\tbreak;\n\n\tcase ECONN_HANGUP:\n\t\tbreak;\n\n\tcase ECONN_REJECT:\n\t\tbreak;\n\n\tcase ECONN_PROPSYNC:\n\n\t\t/* props is mandatory for PROPSYNC */\n\t\tif (!msg->u.propsync.props) {\n\t\t\twarning(\"propsync: missing props\\n\");\n\t\t\terr = EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = econn_props_encode(jobj, msg->u.propsync.props);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase ECONN_GROUP_START:\n\t\t/* props is optional for GROUPSTART */\n\t\tif (msg->u.groupstart.props) {\n\t\t\terr = econn_props_encode(jobj, msg->u.groupstart.props);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\n\tcase ECONN_GROUP_LEAVE:\n\tcase ECONN_GROUP_CHECK:\n\t\tbreak;\n\n\tcase ECONN_CONF_CONN:\n\t\tif (msg->u.confconn.turnc > 0) {\n\t\t\terr = zapi_iceservers_encode(jobj,\n\t\t\t\t\t\t     msg->u.confconn.turnv,\n\t\t\t\t\t\t     msg->u.confconn.turnc);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tjzon_add_bool(jobj, \"update\",\n\t\t\t      msg->u.confconn.update);\n\t\tjzon_add_str(jobj, \"tool\", \n\t\t\t     \"%s\", msg->u.confconn.tool);\n\t\tjzon_add_str(jobj, \"toolver\",\n\t\t\t     \"%s\", msg->u.confconn.toolver);\n\t\tjzon_add_int(jobj, \"status\",\n\t\t\t      msg->u.confconn.status);\n\t\tjzon_add_bool(jobj, \"selective_audio\",\n\t\t\t      msg->u.confconn.selective_audio);\n\t\tjzon_add_bool(jobj, \"selective_video\",\n\t\t\t      msg->u.confconn.selective_video);\n\t\tjzon_add_int(jobj, \"vstreams\",\n\t\t\t      msg->u.confconn.vstreams);\n\t\tbreak;\n\n\tcase ECONN_CONF_START:\n\t\tjzon_add_str(jobj, \"sft_url\", \"%s\", msg->u.confstart.sft_url);\n\t\tjzon_add_base64(jobj, \"secret\",\n\t\t\t\tmsg->u.confstart.secret, msg->u.confstart.secretlen);\n\t\tjzon_add_str(jobj, \"timestamp\", \"%llu\", msg->u.confstart.timestamp);\n\t\tjzon_add_str(jobj, \"seqno\", \"%u\", msg->u.confstart.seqno);\n\t\t/* props is optional for CONFSTART */\n\t\tif (msg->u.confstart.props) {\n\t\t\terr = econn_props_encode(jobj, msg->u.confstart.props);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\n\tcase ECONN_CONF_CHECK:\n\t\tjzon_add_str(jobj, \"sft_url\", \"%s\", msg->u.confcheck.sft_url);\n\t\tjzon_add_base64(jobj, \"secret\",\n\t\t\t\tmsg->u.confcheck.secret, msg->u.confcheck.secretlen);\n\t\tjzon_add_str(jobj, \"timestamp\", \"%llu\", msg->u.confcheck.timestamp);\n\t\tjzon_add_str(jobj, \"seqno\", \"%u\", msg->u.confcheck.seqno);\n\t\tbreak;\n\n\tcase ECONN_CONF_END:\n\t\tbreak;\n\n\tcase ECONN_CONF_PART:\n\t\tjzon_add_bool(jobj, \"should_start\",\n\t\t\t      msg->u.confpart.should_start);\n\t\tjzon_add_str(jobj, \"timestamp\", \"%llu\", msg->u.confpart.timestamp);\n\t\tjzon_add_str(jobj, \"seqno\", \"%u\", msg->u.confpart.seqno);\n\t\tjzon_add_base64(jobj, \"entropy\",\n\t\t\t\tmsg->u.confpart.entropy, msg->u.confpart.entropylen);\n\t\teconn_parts_encode(jobj, &msg->u.confpart.partl);\n\t\tbreak;\n\n\tcase ECONN_CONF_KEY:\n\t\teconn_keys_encode(jobj, &msg->u.confkey.keyl);\n\t\tbreak;\n\n\tcase ECONN_DEVPAIR_PUBLISH:\n\t\terr = zapi_iceservers_encode(jobj,\n\t\t\t\t\t     msg->u.devpair_publish.turnv,\n\t\t\t\t\t     msg->u.devpair_publish.turnc);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = jzon_add_str(jobj, \"sdp\",\n\t\t\t\t   \"%s\", msg->u.devpair_publish.sdp);\n\t\terr |= jzon_add_str(jobj, \"username\",\n\t\t\t\t    \"%s\", msg->u.devpair_publish.username);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase ECONN_DEVPAIR_ACCEPT:\n\t\terr = jzon_add_str(jobj, \"sdp\",\n\t\t\t\t   \"%s\", msg->u.devpair_accept.sdp);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase ECONN_ALERT:\n\t\terr  = jzon_add_int(jobj, \"level\", msg->u.alert.level);\n\t\terr |= jzon_add_str(jobj, \"descr\", \"%s\", msg->u.alert.descr);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase ECONN_PING:\n\t\tbreak;\n\n\tdefault:\n\t\twarning(\"econn: dont know how to encode %d\\n\", msg->msg_type);\n\t\terr = EBADMSG;\n\t\tbreak;\n\t}\n\tif (err)\n\t\tgoto out;\n\n\terr = jzon_encode(&str, jobj);\n\tif (err)\n\t\tgoto out;\n\n out:\n\tmem_deref(jobj);\n\tif (err)\n\t\tmem_deref(str);\n\telse\n\t\t*strp = str;\n\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -114,10 +114,10 @@\n \n \t\tjzon_add_bool(jobj, \"update\",\n \t\t\t      msg->u.confconn.update);\n-\t\tjzon_add_str(jobj, \"tool\",\n-\t\t\t      msg->u.confconn.tool);\n+\t\tjzon_add_str(jobj, \"tool\", \n+\t\t\t     \"%s\", msg->u.confconn.tool);\n \t\tjzon_add_str(jobj, \"toolver\",\n-\t\t\t      msg->u.confconn.toolver);\n+\t\t\t     \"%s\", msg->u.confconn.toolver);\n \t\tjzon_add_int(jobj, \"status\",\n \t\t\t      msg->u.confconn.status);\n \t\tjzon_add_bool(jobj, \"selective_audio\",",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tjzon_add_str(jobj, \"tool\",",
                "\t\t\t      msg->u.confconn.tool);",
                "\t\t\t      msg->u.confconn.toolver);"
            ],
            "added_lines": [
                "\t\tjzon_add_str(jobj, \"tool\", ",
                "\t\t\t     \"%s\", msg->u.confconn.tool);",
                "\t\t\t     \"%s\", msg->u.confconn.toolver);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41193",
        "func_name": "wireapp/wire-avs/CbrDetectorRemote::Decrypt",
        "description": "wire-avs is the audio visual signaling (AVS) component of Wire, an open-source messenger. A remote format string vulnerability in versions prior to 7.1.12 allows an attacker to cause a denial of service or possibly execute arbitrary code. The issue has been fixed in wire-avs 7.1.12. There are currently no known workarounds.",
        "git_url": "https://github.com/wireapp/wire-avs/commit/40d373ede795443ae6f2f756e9fb1f4f4ae90bbe",
        "commit_title": "Import latest release-7.1 files from old repo",
        "commit_text": "",
        "func_before": "CbrDetectorRemote::Result CbrDetectorRemote::Decrypt(cricket::MediaType media_type,\n\t\t\t\t\t\tconst std::vector<uint32_t>& csrcs,\n\t\t\t\t\t\trtc::ArrayView<const uint8_t> additional_data,\n\t\t\t\t\t\trtc::ArrayView<const uint8_t> encrypted_frame,\n\t\t\t\t\t\trtc::ArrayView<uint8_t> frame)\n{\n\tconst uint8_t *src = encrypted_frame.data();\n\tuint8_t *dst = frame.data();\n\tuint32_t data_len = encrypted_frame.size();\n\n\tif (media_type == cricket::MEDIA_TYPE_AUDIO) {\n\t\tif (data_len == frame_size && frame_size >= 40) {\n\t\t\tframe_count++;\n\t\t\tif (frame_count > 200 && !detected) {\n\t\t\t\tinfo(\"CBR detector: remote cbr detected\\n\");\n\t\t\t\tdetected = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tframe_count = 0;\n\t\t\tframe_size = data_len;\n\t\t\tif (detected) {\n\t\t\t\tinfo(\"CBR detector: remote cbr detected disabled\\n\");\n\t\t\t\tdetected = false;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tmemcpy(dst, src, data_len);\n\nout:\n\treturn CbrDetectorRemote::Result(CbrDetectorRemote::Status::kOk, data_len);\n}",
        "func": "CbrDetectorRemote::Result CbrDetectorRemote::Decrypt(cricket::MediaType media_type,\n\t\t\t\t\t\tconst std::vector<uint32_t>& csrcs,\n\t\t\t\t\t\trtc::ArrayView<const uint8_t> additional_data,\n\t\t\t\t\t\trtc::ArrayView<const uint8_t> encrypted_frame,\n\t\t\t\t\t\trtc::ArrayView<uint8_t> frame)\n{\n\tconst uint8_t *src = encrypted_frame.data();\n\tuint8_t *dst = frame.data();\n\tuint32_t data_len = encrypted_frame.size();\n\n\tif (media_type == cricket::MEDIA_TYPE_AUDIO) {\n\t\tif (data_len == frame_size && frame_size >= 40) {\n\t\t\tmissmatch_count = 0;\n\t\t\tframe_count++;\n\t\t\tif (frame_count > MIN_MATCH && !detected) {\n\t\t\t\tinfo(\"CBR detector: remote cbr detected\\n\");\n\t\t\t\tdetected = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmissmatch_count++;\n\t\t\tif (!detected\n\t\t\t    || (detected && missmatch_count > MAX_MISSMATCH)) {\n\t\t\t\tframe_count = 0;\n\t\t\t\tframe_size = data_len;\n\t\t\t\tmissmatch_count = 0;\n\t\t\t\tif (detected) {\n\t\t\t\t\tinfo(\"CBR detector: remote cbr detected disabled\\n\");\n\t\t\t\t\tdetected = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmemcpy(dst, src, data_len);\n\nout:\n\treturn CbrDetectorRemote::Result(CbrDetectorRemote::Status::kOk, data_len);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,21 +10,26 @@\n \n \tif (media_type == cricket::MEDIA_TYPE_AUDIO) {\n \t\tif (data_len == frame_size && frame_size >= 40) {\n+\t\t\tmissmatch_count = 0;\n \t\t\tframe_count++;\n-\t\t\tif (frame_count > 200 && !detected) {\n+\t\t\tif (frame_count > MIN_MATCH && !detected) {\n \t\t\t\tinfo(\"CBR detector: remote cbr detected\\n\");\n \t\t\t\tdetected = true;\n \t\t\t}\n \t\t}\n \t\telse {\n-\t\t\tframe_count = 0;\n-\t\t\tframe_size = data_len;\n-\t\t\tif (detected) {\n-\t\t\t\tinfo(\"CBR detector: remote cbr detected disabled\\n\");\n-\t\t\t\tdetected = false;\n+\t\t\tmissmatch_count++;\n+\t\t\tif (!detected\n+\t\t\t    || (detected && missmatch_count > MAX_MISSMATCH)) {\n+\t\t\t\tframe_count = 0;\n+\t\t\t\tframe_size = data_len;\n+\t\t\t\tmissmatch_count = 0;\n+\t\t\t\tif (detected) {\n+\t\t\t\t\tinfo(\"CBR detector: remote cbr detected disabled\\n\");\n+\t\t\t\t\tdetected = false;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n-\n \t}\n \n \tmemcpy(dst, src, data_len);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tif (frame_count > 200 && !detected) {",
                "\t\t\tframe_count = 0;",
                "\t\t\tframe_size = data_len;",
                "\t\t\tif (detected) {",
                "\t\t\t\tinfo(\"CBR detector: remote cbr detected disabled\\n\");",
                "\t\t\t\tdetected = false;",
                ""
            ],
            "added_lines": [
                "\t\t\tmissmatch_count = 0;",
                "\t\t\tif (frame_count > MIN_MATCH && !detected) {",
                "\t\t\tmissmatch_count++;",
                "\t\t\tif (!detected",
                "\t\t\t    || (detected && missmatch_count > MAX_MISSMATCH)) {",
                "\t\t\t\tframe_count = 0;",
                "\t\t\t\tframe_size = data_len;",
                "\t\t\t\tmissmatch_count = 0;",
                "\t\t\t\tif (detected) {",
                "\t\t\t\t\tinfo(\"CBR detector: remote cbr detected disabled\\n\");",
                "\t\t\t\t\tdetected = false;",
                "\t\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41193",
        "func_name": "wireapp/wire-avs/wcall_i_answer",
        "description": "wire-avs is the audio visual signaling (AVS) component of Wire, an open-source messenger. A remote format string vulnerability in versions prior to 7.1.12 allows an attacker to cause a denial of service or possibly execute arbitrary code. The issue has been fixed in wire-avs 7.1.12. There are currently no known workarounds.",
        "git_url": "https://github.com/wireapp/wire-avs/commit/40d373ede795443ae6f2f756e9fb1f4f4ae90bbe",
        "commit_title": "Import latest release-7.1 files from old repo",
        "commit_text": "",
        "func_before": "int wcall_i_answer(struct wcall *wcall,\n\t\t   int call_type, int audio_cbr)\n{\n\tint err = 0;\n\tbool cbr = audio_cbr != 0;\n\n\tif (!wcall) {\n\t\twarning(\"wcall; answer: no wcall\\n\");\n\t\treturn EINVAL;\n\t}\n\n\tcall_type = (call_type == WCALL_CALL_TYPE_FORCED_AUDIO) ?\n\t\t    WCALL_CALL_TYPE_NORMAL : call_type;\n\n\tinfo(APITAG \"wcall(%p): answer calltype=%s\\n\",\n\t     wcall, wcall_call_type_name(call_type));\n\n\tif (wcall->disable_audio)\n\t\twcall->disable_audio = false;\n\t\n\tif (!wcall->icall) {\n\t\twarning(\"wcall(%p): answer: no call object found\\n\", wcall);\n\t\treturn ENOTSUP;\n\t}\n\tset_state(wcall, WCALL_STATE_ANSWERED);\n\n\tif (call_type == WCALL_CALL_TYPE_VIDEO) {\n\t\tICALL_CALL(wcall->icall,\n\t\t\t   set_video_send_state,\n\t\t\t   ICALL_VIDEO_STATE_STARTED);\n\t}\n\telse {\n\t\tICALL_CALL(wcall->icall,\n\t\t\t   set_video_send_state,\n\t\t\t   ICALL_VIDEO_STATE_STOPPED);\n\t}\n\t\n\terr = ICALL_CALLE(wcall->icall, answer,\n\t\t\t  call_type, cbr);\n\n\treturn err;\n}",
        "func": "int wcall_i_answer(struct wcall *wcall,\n\t\t   int call_type, int audio_cbr)\n{\n\tint err = 0;\n\tbool cbr = audio_cbr != 0;\n\n\tif (!wcall) {\n\t\twarning(\"wcall; answer: no wcall\\n\");\n\t\treturn EINVAL;\n\t}\n\n\tcall_type = (call_type == WCALL_CALL_TYPE_FORCED_AUDIO) ?\n\t\t    WCALL_CALL_TYPE_NORMAL : call_type;\n\n\tinfo(APITAG \"wcall(%p): answer calltype=%s cbr=%d\\n\",\n\t     wcall, wcall_call_type_name(call_type), audio_cbr);\n\n\tif (wcall->disable_audio)\n\t\twcall->disable_audio = false;\n\t\n\tif (!wcall->icall) {\n\t\twarning(\"wcall(%p): answer: no call object found\\n\", wcall);\n\t\treturn ENOTSUP;\n\t}\n\tset_state(wcall, WCALL_STATE_ANSWERED);\n\n\tif (call_type == WCALL_CALL_TYPE_VIDEO) {\n\t\tICALL_CALL(wcall->icall,\n\t\t\t   set_video_send_state,\n\t\t\t   ICALL_VIDEO_STATE_STARTED);\n\t}\n\telse {\n\t\tICALL_CALL(wcall->icall,\n\t\t\t   set_video_send_state,\n\t\t\t   ICALL_VIDEO_STATE_STOPPED);\n\t}\n\t\n\terr = ICALL_CALLE(wcall->icall, answer,\n\t\t\t  call_type, cbr);\n\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,8 +12,8 @@\n \tcall_type = (call_type == WCALL_CALL_TYPE_FORCED_AUDIO) ?\n \t\t    WCALL_CALL_TYPE_NORMAL : call_type;\n \n-\tinfo(APITAG \"wcall(%p): answer calltype=%s\\n\",\n-\t     wcall, wcall_call_type_name(call_type));\n+\tinfo(APITAG \"wcall(%p): answer calltype=%s cbr=%d\\n\",\n+\t     wcall, wcall_call_type_name(call_type), audio_cbr);\n \n \tif (wcall->disable_audio)\n \t\twcall->disable_audio = false;",
        "diff_line_info": {
            "deleted_lines": [
                "\tinfo(APITAG \"wcall(%p): answer calltype=%s\\n\",",
                "\t     wcall, wcall_call_type_name(call_type));"
            ],
            "added_lines": [
                "\tinfo(APITAG \"wcall(%p): answer calltype=%s cbr=%d\\n\",",
                "\t     wcall, wcall_call_type_name(call_type), audio_cbr);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41193",
        "func_name": "wireapp/wire-avs/ecall_start",
        "description": "wire-avs is the audio visual signaling (AVS) component of Wire, an open-source messenger. A remote format string vulnerability in versions prior to 7.1.12 allows an attacker to cause a denial of service or possibly execute arbitrary code. The issue has been fixed in wire-avs 7.1.12. There are currently no known workarounds.",
        "git_url": "https://github.com/wireapp/wire-avs/commit/40d373ede795443ae6f2f756e9fb1f4f4ae90bbe",
        "commit_title": "Import latest release-7.1 files from old repo",
        "commit_text": "",
        "func_before": "int ecall_start(struct ecall *ecall, enum icall_call_type call_type,\n\t\tbool audio_cbr)\n{\n\tint err;\n\n\tinfo(\"ecall(%p): start\\n\", ecall);\n\n\tif (!ecall)\n\t\treturn EINVAL;\n\n#ifdef ECALL_CBR_ALWAYS_ON\n\taudio_cbr = true;\n#endif\n\n\tif (ecall->econn) {\n\t\tif (ECONN_PENDING_INCOMING == econn_current_state(ecall->econn)) {\n\t\t\treturn ecall_answer(ecall, call_type, audio_cbr);\n\t\t}\n\t\telse {\n\t\t\twarning(\"ecall: start: already in progress (econn=%s)\\n\",\n\t\t\t\teconn_state_name(econn_current_state(ecall->econn)));\n\t\t\treturn EALREADY;\n\t\t}\n\t}\n\n#if 0\n\tif (ecall->turnc == 0) {\n\t\twarning(\"ecall: start: no TURN servers -- cannot start\\n\");\n\t\treturn EINTR;\n\t}\n#endif\n\n\tecall->call_type = call_type;\n\t\n\terr = ecall_create_econn(ecall);\n\tif (err) {\n\t\twarning(\"ecall: start: create_econn failed: %m\\n\", err);\n\t\treturn err;\n\t}\n\n\teconn_set_state(ecall_get_econn(ecall), ECONN_PENDING_OUTGOING);\n\n\terr = alloc_flow(ecall, ASYNC_OFFER, ecall->call_type, audio_cbr);\n\tif (err) {\n\t\twarning(\"ecall: start: alloc_flow failed: %m\\n\", err);\n\t\tgoto out;\n\t}\n\n\tIFLOW_CALL(ecall->flow, set_audio_cbr, audio_cbr);\n\t\n\tif (ecall->props_local &&\n\t    (call_type == ICALL_CALL_TYPE_VIDEO\n\t     && ecall->vstate == ICALL_VIDEO_STATE_STARTED)) {\n\t\tconst char *vstate_string = \"true\";\n\n\t\tint err2 = econn_props_update(ecall->props_local,\n\t\t\t\t\t      \"videosend\", vstate_string);\n\t\tif (err2) {\n\t\t\twarning(\"ecall(%p): econn_props_update(videosend)\",\n\t\t\t\t\" failed (%m)\\n\", ecall, err2);\n\t\t\t/* Non fatal, carry on */\n\t\t}\n\t}\n\n\tecall->sdp.async = ASYNC_NONE;\n\terr = generate_offer(ecall);\n\tif (err) {\n\t\twarning(\"ecall(%p): start: generate_offer\"\n\t\t\t\" failed (%m)\\n\", ecall, err);\n\t\tgoto out;\n\t}\n\n\tecall->ts_started = tmr_jiffies();\n\tecall->call_setup_time = -1;\n\n out:\n\t/* err handling */\n\treturn err;\n}",
        "func": "int ecall_start(struct ecall *ecall, enum icall_call_type call_type,\n\t\tbool audio_cbr)\n{\n\tint err;\n\n\tinfo(\"ecall(%p): start call_type=%d cbr=%d\\n\",\n\t     ecall, call_type, audio_cbr);\n\n\tif (!ecall)\n\t\treturn EINVAL;\n\n#ifdef ECALL_CBR_ALWAYS_ON\n\taudio_cbr = true;\n#endif\n\n\tif (ecall->econn) {\n\t\tif (ECONN_PENDING_INCOMING == econn_current_state(ecall->econn)) {\n\t\t\treturn ecall_answer(ecall, call_type, audio_cbr);\n\t\t}\n\t\telse {\n\t\t\twarning(\"ecall: start: already in progress (econn=%s)\\n\",\n\t\t\t\teconn_state_name(econn_current_state(ecall->econn)));\n\t\t\treturn EALREADY;\n\t\t}\n\t}\n\n#if 0\n\tif (ecall->turnc == 0) {\n\t\twarning(\"ecall: start: no TURN servers -- cannot start\\n\");\n\t\treturn EINTR;\n\t}\n#endif\n\n\tecall->call_type = call_type;\n\t\n\terr = ecall_create_econn(ecall);\n\tif (err) {\n\t\twarning(\"ecall: start: create_econn failed: %m\\n\", err);\n\t\treturn err;\n\t}\n\n\teconn_set_state(ecall_get_econn(ecall), ECONN_PENDING_OUTGOING);\n\n\terr = alloc_flow(ecall, ASYNC_OFFER, ecall->call_type, audio_cbr);\n\tif (err) {\n\t\twarning(\"ecall: start: alloc_flow failed: %m\\n\", err);\n\t\tgoto out;\n\t}\n\n\tIFLOW_CALL(ecall->flow, set_audio_cbr, audio_cbr);\n\t\n\tif (ecall->props_local &&\n\t    (call_type == ICALL_CALL_TYPE_VIDEO\n\t     && ecall->vstate == ICALL_VIDEO_STATE_STARTED)) {\n\t\tconst char *vstate_string = \"true\";\n\n\t\tint err2 = econn_props_update(ecall->props_local,\n\t\t\t\t\t      \"videosend\", vstate_string);\n\t\tif (err2) {\n\t\t\twarning(\"ecall(%p): econn_props_update(videosend)\",\n\t\t\t\t\" failed (%m)\\n\", ecall, err2);\n\t\t\t/* Non fatal, carry on */\n\t\t}\n\t}\n\n\tecall->sdp.async = ASYNC_NONE;\n\terr = generate_offer(ecall);\n\tif (err) {\n\t\twarning(\"ecall(%p): start: generate_offer\"\n\t\t\t\" failed (%m)\\n\", ecall, err);\n\t\tgoto out;\n\t}\n\n\tecall->ts_started = tmr_jiffies();\n\tecall->call_setup_time = -1;\n\n out:\n\t/* err handling */\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,8 @@\n {\n \tint err;\n \n-\tinfo(\"ecall(%p): start\\n\", ecall);\n+\tinfo(\"ecall(%p): start call_type=%d cbr=%d\\n\",\n+\t     ecall, call_type, audio_cbr);\n \n \tif (!ecall)\n \t\treturn EINVAL;",
        "diff_line_info": {
            "deleted_lines": [
                "\tinfo(\"ecall(%p): start\\n\", ecall);"
            ],
            "added_lines": [
                "\tinfo(\"ecall(%p): start call_type=%d cbr=%d\\n\",",
                "\t     ecall, call_type, audio_cbr);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41193",
        "func_name": "wireapp/wire-avs/ecall_answer",
        "description": "wire-avs is the audio visual signaling (AVS) component of Wire, an open-source messenger. A remote format string vulnerability in versions prior to 7.1.12 allows an attacker to cause a denial of service or possibly execute arbitrary code. The issue has been fixed in wire-avs 7.1.12. There are currently no known workarounds.",
        "git_url": "https://github.com/wireapp/wire-avs/commit/40d373ede795443ae6f2f756e9fb1f4f4ae90bbe",
        "commit_title": "Import latest release-7.1 files from old repo",
        "commit_text": "",
        "func_before": "int ecall_answer(struct ecall *ecall, enum icall_call_type call_type,\n\t\t bool audio_cbr)\n{\n\tint err = 0;\n\n\tif (!ecall)\n\t\treturn EINVAL;\n\n#ifdef ECALL_CBR_ALWAYS_ON\n\taudio_cbr = true;\n#endif\n\t\n\n\tinfo(\"ecall(%p): answer on pending econn %p call_type=%d\\n\", ecall, ecall->econn, call_type);\n\n\tif (!ecall->econn) {\n\t\twarning(\"ecall: answer: econn does not exist!\\n\");\n\t\treturn ENOENT;\n\t}\n\n\tif (ECONN_PENDING_INCOMING != econn_current_state(ecall->econn)) {\n\t\tinfo(\"ecall(%p): answer: invalid state (%s)\\n\", ecall,\n\t\t     econn_state_name(econn_current_state(ecall->econn)));\n\t\treturn EPROTO;\n\t}\n\n\tif (!ecall->flow) {\n\t\twarning(\"ecall: answer: no mediaflow\\n\");\n\t\treturn EPROTO;\n\t}\n\n\tecall->call_type = call_type;\n\tIFLOW_CALL(ecall->flow, set_call_type, call_type);\n\n\tecall->audio_cbr = audio_cbr;\n\tIFLOW_CALL(ecall->flow, set_audio_cbr, audio_cbr);\n\n#if 0\n\tif (ecall->props_local) {\n\t\tconst char *vstate_string =\n\t\t\tcall_type == ICALL_CALL_TYPE_VIDEO ? \"true\" : \"false\";\n\t\tint err2 = econn_props_update(ecall->props_local, \"videosend\", vstate_string);\n\t\tif (err2) {\n\t\t\twarning(\"ecall(%p): econn_props_update(videosend)\",\n\t\t\t\t\" failed (%m)\\n\", ecall, err2);\n\t\t\t/* Non fatal, carry on */\n\t\t}\n\t}\n#endif\n\n\terr = generate_or_gather_answer(ecall, ecall->econn);\n\tif (err) {\n\t\twarning(\"ecall: answer: failed to gather_or_answer\\n\");\n\t\tgoto out;\n\t}\n\n\tecall->answered = true;\n\tecall->audio_setup_time = -1;\n\tecall->call_estab_time = -1;\n\tecall->ts_answered = tmr_jiffies();\n\n out:\n\treturn err;\n}",
        "func": "int ecall_answer(struct ecall *ecall, enum icall_call_type call_type,\n\t\t bool audio_cbr)\n{\n\tint err = 0;\n\n\tif (!ecall)\n\t\treturn EINVAL;\n\n#ifdef ECALL_CBR_ALWAYS_ON\n\taudio_cbr = true;\n#endif\n\t\n\n\tinfo(\"ecall(%p): answer on pending econn %p call_type=%d cbr=%d\\n\", ecall, ecall->econn, call_type, audio_cbr);\n\n\tif (!ecall->econn) {\n\t\twarning(\"ecall: answer: econn does not exist!\\n\");\n\t\treturn ENOENT;\n\t}\n\n\tif (ECONN_PENDING_INCOMING != econn_current_state(ecall->econn)) {\n\t\tinfo(\"ecall(%p): answer: invalid state (%s)\\n\", ecall,\n\t\t     econn_state_name(econn_current_state(ecall->econn)));\n\t\treturn EPROTO;\n\t}\n\n\tif (!ecall->flow) {\n\t\twarning(\"ecall: answer: no mediaflow\\n\");\n\t\treturn EPROTO;\n\t}\n\n\tecall->call_type = call_type;\n\tIFLOW_CALL(ecall->flow, set_call_type, call_type);\n\n\tecall->audio_cbr = audio_cbr;\n\tIFLOW_CALL(ecall->flow, set_audio_cbr, audio_cbr);\n\n#if 0\n\tif (ecall->props_local) {\n\t\tconst char *vstate_string =\n\t\t\tcall_type == ICALL_CALL_TYPE_VIDEO ? \"true\" : \"false\";\n\t\tint err2 = econn_props_update(ecall->props_local, \"videosend\", vstate_string);\n\t\tif (err2) {\n\t\t\twarning(\"ecall(%p): econn_props_update(videosend)\",\n\t\t\t\t\" failed (%m)\\n\", ecall, err2);\n\t\t\t/* Non fatal, carry on */\n\t\t}\n\t}\n#endif\n\n\terr = generate_or_gather_answer(ecall, ecall->econn);\n\tif (err) {\n\t\twarning(\"ecall: answer: failed to gather_or_answer\\n\");\n\t\tgoto out;\n\t}\n\n\tecall->answered = true;\n\tecall->audio_setup_time = -1;\n\tecall->call_estab_time = -1;\n\tecall->ts_answered = tmr_jiffies();\n\n out:\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,7 +11,7 @@\n #endif\n \t\n \n-\tinfo(\"ecall(%p): answer on pending econn %p call_type=%d\\n\", ecall, ecall->econn, call_type);\n+\tinfo(\"ecall(%p): answer on pending econn %p call_type=%d cbr=%d\\n\", ecall, ecall->econn, call_type, audio_cbr);\n \n \tif (!ecall->econn) {\n \t\twarning(\"ecall: answer: econn does not exist!\\n\");",
        "diff_line_info": {
            "deleted_lines": [
                "\tinfo(\"ecall(%p): answer on pending econn %p call_type=%d\\n\", ecall, ecall->econn, call_type);"
            ],
            "added_lines": [
                "\tinfo(\"ecall(%p): answer on pending econn %p call_type=%d cbr=%d\\n\", ecall, ecall->econn, call_type, audio_cbr);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41193",
        "func_name": "wireapp/wire-avs/audio_io_osx::shutdown_audio_unit",
        "description": "wire-avs is the audio visual signaling (AVS) component of Wire, an open-source messenger. A remote format string vulnerability in versions prior to 7.1.12 allows an attacker to cause a denial of service or possibly execute arbitrary code. The issue has been fixed in wire-avs 7.1.12. There are currently no known workarounds.",
        "git_url": "https://github.com/wireapp/wire-avs/commit/40d373ede795443ae6f2f756e9fb1f4f4ae90bbe",
        "commit_title": "Import latest release-7.1 files from old repo",
        "commit_text": "",
        "func_before": "int32_t audio_io_osx::shutdown_audio_unit() {\n        // Close and delete AU\n        OSStatus result = -1;\n        if (NULL != au_rec_) {\n            result = AudioOutputUnitStop(au_rec_);\n            if (0 != result) {\n                error(\"audio_io_osx: Error stopping Audio Unit (result=%d) \\n\", result);\n            }\n            result = AudioComponentInstanceDispose(au_rec_);\n            if (0 != result) {\n                error(\"audio_io_osx: Error disposing Audio Unit (result=%d) \\n\", result);\n            }\n            au_rec_ = NULL;\n        }\n        if (NULL != au_play_) {\n            result = AudioOutputUnitStop(au_play_);\n            if (0 != result) {\n                error(\"audio_io_osx: Error stopping Audio Unit (result=%d) \\n\", result);\n            }\n            result = AudioComponentInstanceDispose(au_play_);\n            if (0 != result) {\n                error(\"audio_io_osx: Error disposing Audio Unit (result=%d) \\n\", result);\n            }\n            au_play_ = NULL;\n        }\n        return 0;\n    }",
        "func": "int32_t audio_io_osx::shutdown_audio_unit() {\n        // Close and delete AU\n        OSStatus result = -1;\n        if (NULL != au_rec_) {\n            result = AudioOutputUnitStop(au_rec_);\n            if (0 != result) {\n                error(\"audio_io_osx: Error stopping Audio Unit (result=%d) \\n\", result);\n            }\n            result = AudioComponentInstanceDispose(au_rec_);\n            if (0 != result) {\n                error(\"audio_io_osx: Error disposing Audio Unit (result=%d) \\n\", result);\n            }\n            au_rec_ = NULL;\n        }\n        if (NULL != au_play_) {\n            result = AudioOutputUnitStop(au_play_);\n            if (0 != result) {\n                error(\"audio_io_osx: Error stopping Audio Unit (result=%d) \\n\", result);\n            }\n            result = AudioComponentInstanceDispose(au_play_);\n            if (0 != result) {\n                error(\"audio_io_osx: Error disposing Audio Unit (result=%d) \\n\", result);\n            }\n            au_play_ = NULL;\n        }\n\n        return 0;\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,5 +23,6 @@\n             }\n             au_play_ = NULL;\n         }\n+\n         return 0;\n     }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41193",
        "func_name": "wireapp/wire-avs/prekey_handler",
        "description": "wire-avs is the audio visual signaling (AVS) component of Wire, an open-source messenger. A remote format string vulnerability in versions prior to 7.1.12 allows an attacker to cause a denial of service or possibly execute arbitrary code. The issue has been fixed in wire-avs 7.1.12. There are currently no known workarounds.",
        "git_url": "https://github.com/wireapp/wire-avs/commit/40d373ede795443ae6f2f756e9fb1f4f4ae90bbe",
        "commit_title": "Import latest release-7.1 files from old repo",
        "commit_text": "",
        "func_before": "static void prekey_handler(const char *userid,\n\t\t\t   const uint8_t *key, size_t key_len,\n\t\t\t   uint16_t id, const char *clientid,\n\t\t\t   bool last, void *arg)\n{\n\tstruct session *sess;\n\tchar lclientid[64];\n\tint err;\n\n\toutput(\"prekey_handler: %zu bytes, user:%s[%u] -> %s\\n\",\n\t       key_len, userid, id, clientid);\n\n\n\terr = client_id_load(lclientid, sizeof(lclientid));\n\tif (err) {\n\t\tdebug(\"my clientid not set -- cannot store prekeys\\n\");\n\t\treturn;\n\t}\n\n\tsess = cryptobox_session_find(g_cryptobox, userid, clientid, lclientid);\n\tif (sess) {\n\t\toutput(\"prekey: session found\\n\");\n\t}\n\telse {\n\t\tinfo(\"conv: adding key to cryptobox for clientid=%s\\n\",\n\t\t     clientid);\n\n\t\terr = cryptobox_session_add_send(g_cryptobox, userid, clientid, lclientid,\n\t\t\t\t\t\t key, key_len);\n\t\tif (err) {\n\t\t\twarning(\"cryptobox_session_add_send failed (%m)\\n\",\n\t\t\t\terr);\n\t\t}\n\t}\n}",
        "func": "static void prekey_handler(const char *userid,\n\t\t\t   const uint8_t *key, size_t key_len,\n\t\t\t   uint16_t id, const char *clientid,\n\t\t\t   bool last, void *arg)\n{\n\tstruct session *sess;\n\tchar lclientid[64];\n\tint err;\n\n\toutput(\"prekey_handler: %zu bytes, user:%s[%u] -> %s\\n\",\n\t       key_len, userid, id, clientid);\n\n\terr = client_id_load(lclientid, sizeof(lclientid));\n\tif (err) {\n\t\tdebug(\"my clientid not set -- cannot store prekeys\\n\");\n\t\treturn;\n\t}\n\n\tsess = cryptobox_session_find(g_cryptobox, userid, clientid, lclientid);\n\tif (sess) {\n\t\toutput(\"prekey: session found\\n\");\n\t}\n\telse {\n\t\tinfo(\"conv: adding key to cryptobox for clientid=%s\\n\",\n\t\t     clientid);\n\n\t\terr = cryptobox_session_add_send(g_cryptobox, userid, clientid, lclientid,\n\t\t\t\t\t\t key, key_len);\n\t\tif (err) {\n\t\t\twarning(\"cryptobox_session_add_send failed (%m)\\n\",\n\t\t\t\terr);\n\t\t}\n\t}\n\n\tif (last) {\n\t\toutput(\"prekey_handler: all prekeys fetched\\n\");\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,6 @@\n \n \toutput(\"prekey_handler: %zu bytes, user:%s[%u] -> %s\\n\",\n \t       key_len, userid, id, clientid);\n-\n \n \terr = client_id_load(lclientid, sizeof(lclientid));\n \tif (err) {\n@@ -32,4 +31,8 @@\n \t\t\t\terr);\n \t\t}\n \t}\n+\n+\tif (last) {\n+\t\toutput(\"prekey_handler: all prekeys fetched\\n\");\n+\t}\n }",
        "diff_line_info": {
            "deleted_lines": [
                ""
            ],
            "added_lines": [
                "",
                "\tif (last) {",
                "\t\toutput(\"prekey_handler: all prekeys fetched\\n\");",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-8617",
        "func_name": "php/php-src/zend_throw_or_error",
        "description": "Format string vulnerability in the zend_throw_or_error function in Zend/zend_execute_API.c in PHP 7.x before 7.0.1 allows remote attackers to execute arbitrary code via format string specifiers in a string that is misused as a class name, leading to incorrect error handling.",
        "git_url": "https://github.com/php/php-src/commit/b101a6bbd4f2181c360bd38e7683df4a03cba83e",
        "commit_title": "Use format string",
        "commit_text": "",
        "func_before": "static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce, const char *format, ...) /* {{{ */\n{\n\tva_list va;\n\tchar *message = NULL;\n\n\tva_start(va, format);\n\tzend_vspprintf(&message, 0, format, va);\n\n\tif (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) {\n\t\tzend_throw_error(exception_ce, message);\n\t} else {\n\t\tzend_error(E_ERROR, \"%s\", message);\n\t}\n\n\tefree(message);\n\tva_end(va);\n}",
        "func": "static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce, const char *format, ...) /* {{{ */\n{\n\tva_list va;\n\tchar *message = NULL;\n\n\tva_start(va, format);\n\tzend_vspprintf(&message, 0, format, va);\n\n\tif (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) {\n\t\tzend_throw_error(exception_ce, \"%s\", message);\n\t} else {\n\t\tzend_error(E_ERROR, \"%s\", message);\n\t}\n\n\tefree(message);\n\tva_end(va);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,7 @@\n \tzend_vspprintf(&message, 0, format, va);\n \n \tif (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) {\n-\t\tzend_throw_error(exception_ce, message);\n+\t\tzend_throw_error(exception_ce, \"%s\", message);\n \t} else {\n \t\tzend_error(E_ERROR, \"%s\", message);\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tzend_throw_error(exception_ce, message);"
            ],
            "added_lines": [
                "\t\tzend_throw_error(exception_ce, \"%s\", message);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-17336",
        "func_name": "storaged-project/udisks/udisks_log",
        "description": "UDisks 2.8.0 has a format string vulnerability in udisks_log in udiskslogging.c, allowing attackers to obtain sensitive information (stack contents), cause a denial of service (memory corruption), or possibly have unspecified other impact via a malformed filesystem label, as demonstrated by %d or %n substrings.",
        "git_url": "https://github.com/storaged-project/udisks/commit/c9e12257a0fd195b16359ae98cf7b8ad7c596005",
        "commit_title": "Fix string format vulnerability",
        "commit_text": " If the message in g_log_structured itself contained format sequences like %d or %n they were applied again, leading to leaked stack contents and possibly memory corruption. It can be triggered e.g. by a volume label containing format sequences.  Print the message argument itself into a \"%s\" string to avoid intepreting format sequences.  https://github.com/storaged-project/udisks/issues/578",
        "func_before": "void\nudisks_log (UDisksLogLevel     level,\n            const gchar       *function,\n            const gchar       *location,\n            const gchar       *format,\n            ...)\n{\n  va_list var_args;\n  gchar *message;\n\n  va_start (var_args, format);\n  message = g_strdup_vprintf (format, var_args);\n  va_end (var_args);\n\n#if GLIB_CHECK_VERSION(2, 50, 0)\n  g_log_structured (\"udisks\", (GLogLevelFlags) level,\n                    \"MESSAGE\", message, \"THREAD_ID\", \"%d\", (gint) syscall (SYS_gettid),\n                    \"CODE_FUNC\", function, \"CODE_FILE\", location);\n#else\n  g_log (\"udisks\", level, \"[%d]: %s [%s, %s()]\", (gint) syscall (SYS_gettid), message, location, function);\n#endif\n\n  g_free (message);\n}",
        "func": "void\nudisks_log (UDisksLogLevel     level,\n            const gchar       *function,\n            const gchar       *location,\n            const gchar       *format,\n            ...)\n{\n  va_list var_args;\n  gchar *message;\n\n  va_start (var_args, format);\n  message = g_strdup_vprintf (format, var_args);\n  va_end (var_args);\n\n#if GLIB_CHECK_VERSION(2, 50, 0)\n  g_log_structured (\"udisks\", (GLogLevelFlags) level,\n                    \"MESSAGE\", \"%s\", message, \"THREAD_ID\", \"%d\", (gint) syscall (SYS_gettid),\n                    \"CODE_FUNC\", function, \"CODE_FILE\", location);\n#else\n  g_log (\"udisks\", level, \"[%d]: %s [%s, %s()]\", (gint) syscall (SYS_gettid), message, location, function);\n#endif\n\n  g_free (message);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,7 @@\n \n #if GLIB_CHECK_VERSION(2, 50, 0)\n   g_log_structured (\"udisks\", (GLogLevelFlags) level,\n-                    \"MESSAGE\", message, \"THREAD_ID\", \"%d\", (gint) syscall (SYS_gettid),\n+                    \"MESSAGE\", \"%s\", message, \"THREAD_ID\", \"%d\", (gint) syscall (SYS_gettid),\n                     \"CODE_FUNC\", function, \"CODE_FILE\", location);\n #else\n   g_log (\"udisks\", level, \"[%d]: %s [%s, %s()]\", (gint) syscall (SYS_gettid), message, location, function);",
        "diff_line_info": {
            "deleted_lines": [
                "                    \"MESSAGE\", message, \"THREAD_ID\", \"%d\", (gint) syscall (SYS_gettid),"
            ],
            "added_lines": [
                "                    \"MESSAGE\", \"%s\", message, \"THREAD_ID\", \"%d\", (gint) syscall (SYS_gettid),"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-30145",
        "func_name": "mpv-player/mpv/open_mf_pattern",
        "description": "A format string vulnerability in mpv through 0.33.0 allows user-assisted remote attackers to achieve code execution via a crafted m3u playlist file.",
        "git_url": "https://github.com/mpv-player/mpv/commit/d0c530919d8cd4d7a774e38ab064e0fabdae34e6",
        "commit_title": "demux_mf: improve format string processing",
        "commit_text": " Before this commit, the user could specify a printf format string which wasn't verified, and could result in: - Undefined behavior due to missing or non-matching arguments. - Buffer overflow due to untested result length.  The offending code was added at commit 103a9609 (2002, mplayer svn):  It moved around but was not modified meaningfully until now.  Now we reject all conversion specifiers at the format except %% and a simple subset of the valid specifiers. Also, we now use snprintf to avoid buffer overflow.  The format string is provided by the user as part of mf:// URI.  Report and initial patch by Stefan Schiller. Patch reviewed by @jeeb, @sfan5, Stefan Schiller.",
        "func_before": "static mf_t *open_mf_pattern(void *talloc_ctx, struct demuxer *d, char *filename)\n{\n    struct mp_log *log = d->log;\n    int error_count = 0;\n    int count = 0;\n\n    mf_t *mf = talloc_zero(talloc_ctx, mf_t);\n    mf->log = log;\n\n    if (filename[0] == '@') {\n        struct stream *s = stream_create(filename + 1,\n                            d->stream_origin | STREAM_READ, d->cancel, d->global);\n        if (s) {\n            while (1) {\n                char buf[512];\n                int len = stream_read_peek(s, buf, sizeof(buf));\n                if (!len)\n                    break;\n                bstr data = (bstr){buf, len};\n                int pos = bstrchr(data, '\\n');\n                data = bstr_splice(data, 0, pos < 0 ? data.len : pos + 1);\n                bstr fname = bstr_strip(data);\n                if (fname.len) {\n                    if (bstrchr(fname, '\\0') >= 0) {\n                        mp_err(log, \"invalid filename\\n\");\n                        break;\n                    }\n                    char *entry = bstrto0(mf, fname);\n                    if (!mp_path_exists(entry)) {\n                        mp_verbose(log, \"file not found: '%s'\\n\", entry);\n                    } else {\n                        MP_TARRAY_APPEND(mf, mf->names, mf->nr_of_files, entry);\n                    }\n                }\n                stream_seek_skip(s, stream_tell(s) + data.len);\n            }\n            free_stream(s);\n\n            mp_info(log, \"number of files: %d\\n\", mf->nr_of_files);\n            goto exit_mf;\n        }\n        mp_info(log, \"%s is not indirect filelist\\n\", filename + 1);\n    }\n\n    if (strchr(filename, ',')) {\n        mp_info(log, \"filelist: %s\\n\", filename);\n        bstr bfilename = bstr0(filename);\n\n        while (bfilename.len) {\n            bstr bfname;\n            bstr_split_tok(bfilename, \",\", &bfname, &bfilename);\n            char *fname2 = bstrdup0(mf, bfname);\n\n            if (!mp_path_exists(fname2))\n                mp_verbose(log, \"file not found: '%s'\\n\", fname2);\n            else {\n                mf_add(mf, fname2);\n            }\n            talloc_free(fname2);\n        }\n        mp_info(log, \"number of files: %d\\n\", mf->nr_of_files);\n\n        goto exit_mf;\n    }\n\n    char *fname = talloc_size(mf, strlen(filename) + 32);\n\n#if HAVE_GLOB\n    if (!strchr(filename, '%')) {\n        strcpy(fname, filename);\n        if (!strchr(filename, '*'))\n            strcat(fname, \"*\");\n\n        mp_info(log, \"search expr: %s\\n\", fname);\n\n        glob_t gg;\n        if (glob(fname, 0, NULL, &gg)) {\n            talloc_free(mf);\n            return NULL;\n        }\n\n        for (int i = 0; i < gg.gl_pathc; i++) {\n            if (mp_path_isdir(gg.gl_pathv[i]))\n                continue;\n            mf_add(mf, gg.gl_pathv[i]);\n        }\n        mp_info(log, \"number of files: %d\\n\", mf->nr_of_files);\n        globfree(&gg);\n        goto exit_mf;\n    }\n#endif\n\n    mp_info(log, \"search expr: %s\\n\", filename);\n\n    while (error_count < 5) {\n        sprintf(fname, filename, count++);\n        if (!mp_path_exists(fname)) {\n            error_count++;\n            mp_verbose(log, \"file not found: '%s'\\n\", fname);\n        } else {\n            mf_add(mf, fname);\n        }\n    }\n\n    mp_info(log, \"number of files: %d\\n\", mf->nr_of_files);\n\nexit_mf:\n    return mf;\n}",
        "func": "static mf_t *open_mf_pattern(void *talloc_ctx, struct demuxer *d, char *filename)\n{\n    struct mp_log *log = d->log;\n    int error_count = 0;\n    int count = 0;\n\n    mf_t *mf = talloc_zero(talloc_ctx, mf_t);\n    mf->log = log;\n\n    if (filename[0] == '@') {\n        struct stream *s = stream_create(filename + 1,\n                            d->stream_origin | STREAM_READ, d->cancel, d->global);\n        if (s) {\n            while (1) {\n                char buf[512];\n                int len = stream_read_peek(s, buf, sizeof(buf));\n                if (!len)\n                    break;\n                bstr data = (bstr){buf, len};\n                int pos = bstrchr(data, '\\n');\n                data = bstr_splice(data, 0, pos < 0 ? data.len : pos + 1);\n                bstr fname = bstr_strip(data);\n                if (fname.len) {\n                    if (bstrchr(fname, '\\0') >= 0) {\n                        mp_err(log, \"invalid filename\\n\");\n                        break;\n                    }\n                    char *entry = bstrto0(mf, fname);\n                    if (!mp_path_exists(entry)) {\n                        mp_verbose(log, \"file not found: '%s'\\n\", entry);\n                    } else {\n                        MP_TARRAY_APPEND(mf, mf->names, mf->nr_of_files, entry);\n                    }\n                }\n                stream_seek_skip(s, stream_tell(s) + data.len);\n            }\n            free_stream(s);\n\n            mp_info(log, \"number of files: %d\\n\", mf->nr_of_files);\n            goto exit_mf;\n        }\n        mp_info(log, \"%s is not indirect filelist\\n\", filename + 1);\n    }\n\n    if (strchr(filename, ',')) {\n        mp_info(log, \"filelist: %s\\n\", filename);\n        bstr bfilename = bstr0(filename);\n\n        while (bfilename.len) {\n            bstr bfname;\n            bstr_split_tok(bfilename, \",\", &bfname, &bfilename);\n            char *fname2 = bstrdup0(mf, bfname);\n\n            if (!mp_path_exists(fname2))\n                mp_verbose(log, \"file not found: '%s'\\n\", fname2);\n            else {\n                mf_add(mf, fname2);\n            }\n            talloc_free(fname2);\n        }\n        mp_info(log, \"number of files: %d\\n\", mf->nr_of_files);\n\n        goto exit_mf;\n    }\n\n    size_t fname_avail = strlen(filename) + 32;\n    char *fname = talloc_size(mf, fname_avail);\n\n#if HAVE_GLOB\n    if (!strchr(filename, '%')) {\n        strcpy(fname, filename);\n        if (!strchr(filename, '*'))\n            strcat(fname, \"*\");\n\n        mp_info(log, \"search expr: %s\\n\", fname);\n\n        glob_t gg;\n        if (glob(fname, 0, NULL, &gg)) {\n            talloc_free(mf);\n            return NULL;\n        }\n\n        for (int i = 0; i < gg.gl_pathc; i++) {\n            if (mp_path_isdir(gg.gl_pathv[i]))\n                continue;\n            mf_add(mf, gg.gl_pathv[i]);\n        }\n        mp_info(log, \"number of files: %d\\n\", mf->nr_of_files);\n        globfree(&gg);\n        goto exit_mf;\n    }\n#endif\n\n    // We're using arbitrary user input as printf format with 1 int argument.\n    // Any format which uses exactly 1 int argument would be valid, but for\n    // simplicity we reject all conversion specifiers except %% and simple\n    // integer specifier: %[.][NUM]d where NUM is 1-3 digits (%.d is valid)\n    const char *f = filename;\n    int MAXDIGS = 3, nspec = 0, bad_spec = 0, c;\n\n    while (nspec < 2 && (c = *f++)) {\n        if (c != '%')\n            continue;\n        if (*f != '%') {\n            nspec++;  // conversion specifier which isn't %%\n            if (*f == '.')\n                f++;\n            for (int ndig = 0; mp_isdigit(*f) && ndig < MAXDIGS; ndig++, f++)\n                /* no-op */;\n            if (*f != 'd') {\n                bad_spec++;  // not int, or beyond our validation capacity\n                break;\n            }\n        }\n        // *f is '%' or 'd'\n        f++;\n    }\n\n    // nspec==0 (zero specifiers) is rejected because fname wouldn't advance.\n    if (bad_spec || nspec != 1) {\n        mp_err(log, \"unsupported expr format: '%s'\\n\", filename);\n        goto exit_mf;\n    }\n\n    mp_info(log, \"search expr: %s\\n\", filename);\n\n    while (error_count < 5) {\n        if (snprintf(fname, fname_avail, filename, count++) >= fname_avail) {\n            mp_err(log, \"format result too long: '%s'\\n\", filename);\n            goto exit_mf;\n        }\n        if (!mp_path_exists(fname)) {\n            error_count++;\n            mp_verbose(log, \"file not found: '%s'\\n\", fname);\n        } else {\n            mf_add(mf, fname);\n        }\n    }\n\n    mp_info(log, \"number of files: %d\\n\", mf->nr_of_files);\n\nexit_mf:\n    return mf;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -63,7 +63,8 @@\n         goto exit_mf;\n     }\n \n-    char *fname = talloc_size(mf, strlen(filename) + 32);\n+    size_t fname_avail = strlen(filename) + 32;\n+    char *fname = talloc_size(mf, fname_avail);\n \n #if HAVE_GLOB\n     if (!strchr(filename, '%')) {\n@@ -90,10 +91,44 @@\n     }\n #endif\n \n+    // We're using arbitrary user input as printf format with 1 int argument.\n+    // Any format which uses exactly 1 int argument would be valid, but for\n+    // simplicity we reject all conversion specifiers except %% and simple\n+    // integer specifier: %[.][NUM]d where NUM is 1-3 digits (%.d is valid)\n+    const char *f = filename;\n+    int MAXDIGS = 3, nspec = 0, bad_spec = 0, c;\n+\n+    while (nspec < 2 && (c = *f++)) {\n+        if (c != '%')\n+            continue;\n+        if (*f != '%') {\n+            nspec++;  // conversion specifier which isn't %%\n+            if (*f == '.')\n+                f++;\n+            for (int ndig = 0; mp_isdigit(*f) && ndig < MAXDIGS; ndig++, f++)\n+                /* no-op */;\n+            if (*f != 'd') {\n+                bad_spec++;  // not int, or beyond our validation capacity\n+                break;\n+            }\n+        }\n+        // *f is '%' or 'd'\n+        f++;\n+    }\n+\n+    // nspec==0 (zero specifiers) is rejected because fname wouldn't advance.\n+    if (bad_spec || nspec != 1) {\n+        mp_err(log, \"unsupported expr format: '%s'\\n\", filename);\n+        goto exit_mf;\n+    }\n+\n     mp_info(log, \"search expr: %s\\n\", filename);\n \n     while (error_count < 5) {\n-        sprintf(fname, filename, count++);\n+        if (snprintf(fname, fname_avail, filename, count++) >= fname_avail) {\n+            mp_err(log, \"format result too long: '%s'\\n\", filename);\n+            goto exit_mf;\n+        }\n         if (!mp_path_exists(fname)) {\n             error_count++;\n             mp_verbose(log, \"file not found: '%s'\\n\", fname);",
        "diff_line_info": {
            "deleted_lines": [
                "    char *fname = talloc_size(mf, strlen(filename) + 32);",
                "        sprintf(fname, filename, count++);"
            ],
            "added_lines": [
                "    size_t fname_avail = strlen(filename) + 32;",
                "    char *fname = talloc_size(mf, fname_avail);",
                "    // We're using arbitrary user input as printf format with 1 int argument.",
                "    // Any format which uses exactly 1 int argument would be valid, but for",
                "    // simplicity we reject all conversion specifiers except %% and simple",
                "    // integer specifier: %[.][NUM]d where NUM is 1-3 digits (%.d is valid)",
                "    const char *f = filename;",
                "    int MAXDIGS = 3, nspec = 0, bad_spec = 0, c;",
                "",
                "    while (nspec < 2 && (c = *f++)) {",
                "        if (c != '%')",
                "            continue;",
                "        if (*f != '%') {",
                "            nspec++;  // conversion specifier which isn't %%",
                "            if (*f == '.')",
                "                f++;",
                "            for (int ndig = 0; mp_isdigit(*f) && ndig < MAXDIGS; ndig++, f++)",
                "                /* no-op */;",
                "            if (*f != 'd') {",
                "                bad_spec++;  // not int, or beyond our validation capacity",
                "                break;",
                "            }",
                "        }",
                "        // *f is '%' or 'd'",
                "        f++;",
                "    }",
                "",
                "    // nspec==0 (zero specifiers) is rejected because fname wouldn't advance.",
                "    if (bad_spec || nspec != 1) {",
                "        mp_err(log, \"unsupported expr format: '%s'\\n\", filename);",
                "        goto exit_mf;",
                "    }",
                "",
                "        if (snprintf(fname, fname_avail, filename, count++) >= fname_avail) {",
                "            mp_err(log, \"format result too long: '%s'\\n\", filename);",
                "            goto exit_mf;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-10088",
        "func_name": "ayttm/http_connect",
        "description": "A vulnerability, which was classified as critical, was found in ayttm up to 0.5.0.89. This affects the function http_connect in the library libproxy/proxy.c. The manipulation leads to format string. It is possible to initiate the attack remotely. The complexity of an attack is rather high. The exploitability is told to be difficult. The patch is named 40e04680018614a7d2b68566b261b061a0597046. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-222267.",
        "git_url": "https://github.com/ayttm/ayttm/commit/40e04680018614a7d2b68566b261b061a0597046",
        "commit_title": "Fix format string vulnerability",
        "commit_text": " Reported by Kapil Anand on ayttm-users: https://sourceforge.net/p/ayttm/mailman/message/34397158/  This patch does the following two things:  1. Makes sure debug_print is only used in DEBUG mode and not in non-DEBUG mode 2. Since debug_print is basically printf, we don't really need to first    snprintf into a buffer and then print the buffer. 3. We no longer need debug_buff",
        "func_before": "int http_connect(int sockfd, const char *host, int port, AyProxyData *proxy)\n{\n\t/* step two : do  proxy tunneling init */\n\tchar cmd[512];\n\tchar *inputline = NULL;\n\tchar *proxy_auth = NULL;\n\tchar debug_buff[512];\n\tint remaining = sizeof(cmd) - 1;\n\n\tremaining -= snprintf(cmd, sizeof(cmd), \"CONNECT %s:%d HTTP/1.1\\r\\n\", host, port);\n\tif (proxy->username && proxy->username[0]) {\n\t\tproxy_auth = encode_proxy_auth_str(proxy);\n\n\t\tstrncat(cmd, \"Proxy-Authorization: Basic \", remaining);\n\t\tremaining -= 27;\n\t\tstrncat(cmd, proxy_auth, remaining);\n\t\tremaining -= strlen(proxy_auth);\n\t\tstrncat(cmd, \"\\r\\n\", remaining);\n\t\tremaining -= 2;\n\t}\n\tstrncat(cmd, \"\\r\\n\", remaining);\n#ifndef DEBUG\n\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", cmd);\n\tdebug_print(debug_buff);\n#endif\n\tif (send(sockfd, cmd, strlen(cmd), 0) < 0)\n\t\treturn AY_CONNECTION_REFUSED;\n\tif (ay_recv_line(sockfd, &inputline) < 0)\n\t\treturn AY_CONNECTION_REFUSED;\n#ifndef DEBUG\n\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", inputline);\n\tdebug_print(debug_buff);\n#endif\n\tif (!strstr(inputline, \"200\")) {\n\t\t/* Check if proxy authorization needed */\n\t\tif (strstr(inputline, \"407\")) {\n\t\t\twhile (ay_recv_line(sockfd, &inputline) > 0) {\n\t\t\t\tfree(inputline);\n\t\t\t}\n\t\t\treturn AY_PROXY_AUTH_REQUIRED;\n\t\t}\n\t\tif (strstr(inputline, \"403\")) {\n\t\t\twhile (ay_recv_line(sockfd, &inputline) > 0) {\n\t\t\t\tfree(inputline);\n\t\t\t}\n\t\t\treturn AY_PROXY_PERMISSION_DENIED;\n\t\t}\n\t\tfree(inputline);\n\t\treturn AY_CONNECTION_REFUSED;\n\t}\n\n\twhile (strlen(inputline) > 1) {\n\t\tfree(inputline);\n\t\tif (ay_recv_line(sockfd, &inputline) < 0) {\n\t\t\treturn AY_CONNECTION_REFUSED;\n\t\t}\n#ifndef DEBUG\n\t\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", inputline);\n\t\tdebug_print(debug_buff);\n#endif\n\t}\n\tfree(inputline);\n\n\tg_free(proxy_auth);\n\n\treturn 0;\n}",
        "func": "int http_connect(int sockfd, const char *host, int port, AyProxyData *proxy)\n{\n\t/* step two : do  proxy tunneling init */\n\tchar cmd[512];\n\tchar *inputline = NULL;\n\tchar *proxy_auth = NULL;\n\tint remaining = sizeof(cmd) - 1;\n\n\tremaining -= snprintf(cmd, sizeof(cmd), \"CONNECT %s:%d HTTP/1.1\\r\\n\", host, port);\n\tif (proxy->username && proxy->username[0]) {\n\t\tproxy_auth = encode_proxy_auth_str(proxy);\n\n\t\tstrncat(cmd, \"Proxy-Authorization: Basic \", remaining);\n\t\tremaining -= 27;\n\t\tstrncat(cmd, proxy_auth, remaining);\n\t\tremaining -= strlen(proxy_auth);\n\t\tstrncat(cmd, \"\\r\\n\", remaining);\n\t\tremaining -= 2;\n\t}\n\tstrncat(cmd, \"\\r\\n\", remaining);\n#ifdef DEBUG\n\tdebug_print(\"<%s>\\n\", cmd);\n#endif\n\tif (send(sockfd, cmd, strlen(cmd), 0) < 0)\n\t\treturn AY_CONNECTION_REFUSED;\n\tif (ay_recv_line(sockfd, &inputline) < 0)\n\t\treturn AY_CONNECTION_REFUSED;\n#ifdef DEBUG\n\tdebug_print(\"<%s>\\n\", inputline);\n#endif\n\tif (!strstr(inputline, \"200\")) {\n\t\t/* Check if proxy authorization needed */\n\t\tif (strstr(inputline, \"407\")) {\n\t\t\twhile (ay_recv_line(sockfd, &inputline) > 0) {\n\t\t\t\tfree(inputline);\n\t\t\t}\n\t\t\treturn AY_PROXY_AUTH_REQUIRED;\n\t\t}\n\t\tif (strstr(inputline, \"403\")) {\n\t\t\twhile (ay_recv_line(sockfd, &inputline) > 0) {\n\t\t\t\tfree(inputline);\n\t\t\t}\n\t\t\treturn AY_PROXY_PERMISSION_DENIED;\n\t\t}\n\t\tfree(inputline);\n\t\treturn AY_CONNECTION_REFUSED;\n\t}\n\n\twhile (strlen(inputline) > 1) {\n\t\tfree(inputline);\n\t\tif (ay_recv_line(sockfd, &inputline) < 0) {\n\t\t\treturn AY_CONNECTION_REFUSED;\n\t\t}\n#ifdef DEBUG\n\t\tdebug_print(\"<%s>\\n\", inputline);\n#endif\n\t}\n\tfree(inputline);\n\n\tg_free(proxy_auth);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,6 @@\n \tchar cmd[512];\n \tchar *inputline = NULL;\n \tchar *proxy_auth = NULL;\n-\tchar debug_buff[512];\n \tint remaining = sizeof(cmd) - 1;\n \n \tremaining -= snprintf(cmd, sizeof(cmd), \"CONNECT %s:%d HTTP/1.1\\r\\n\", host, port);\n@@ -19,17 +18,15 @@\n \t\tremaining -= 2;\n \t}\n \tstrncat(cmd, \"\\r\\n\", remaining);\n-#ifndef DEBUG\n-\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", cmd);\n-\tdebug_print(debug_buff);\n+#ifdef DEBUG\n+\tdebug_print(\"<%s>\\n\", cmd);\n #endif\n \tif (send(sockfd, cmd, strlen(cmd), 0) < 0)\n \t\treturn AY_CONNECTION_REFUSED;\n \tif (ay_recv_line(sockfd, &inputline) < 0)\n \t\treturn AY_CONNECTION_REFUSED;\n-#ifndef DEBUG\n-\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", inputline);\n-\tdebug_print(debug_buff);\n+#ifdef DEBUG\n+\tdebug_print(\"<%s>\\n\", inputline);\n #endif\n \tif (!strstr(inputline, \"200\")) {\n \t\t/* Check if proxy authorization needed */\n@@ -54,9 +51,8 @@\n \t\tif (ay_recv_line(sockfd, &inputline) < 0) {\n \t\t\treturn AY_CONNECTION_REFUSED;\n \t\t}\n-#ifndef DEBUG\n-\t\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", inputline);\n-\t\tdebug_print(debug_buff);\n+#ifdef DEBUG\n+\t\tdebug_print(\"<%s>\\n\", inputline);\n #endif\n \t}\n \tfree(inputline);",
        "diff_line_info": {
            "deleted_lines": [
                "\tchar debug_buff[512];",
                "#ifndef DEBUG",
                "\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", cmd);",
                "\tdebug_print(debug_buff);",
                "#ifndef DEBUG",
                "\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", inputline);",
                "\tdebug_print(debug_buff);",
                "#ifndef DEBUG",
                "\t\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", inputline);",
                "\t\tdebug_print(debug_buff);"
            ],
            "added_lines": [
                "#ifdef DEBUG",
                "\tdebug_print(\"<%s>\\n\", cmd);",
                "#ifdef DEBUG",
                "\tdebug_print(\"<%s>\\n\", inputline);",
                "#ifdef DEBUG",
                "\t\tdebug_print(\"<%s>\\n\", inputline);"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-1588",
        "func_name": "xfce-mirror/thunar/thunar_transfer_job_copy_node",
        "description": "Thunar before 1.3.1 could crash when copy and pasting a file name with % format characters due to a format string error.",
        "git_url": "https://github.com/xfce-mirror/thunar/commit/03dd312e157d4fa8a11d5fa402706ae5b05806fa",
        "commit_title": "Don't interpret file display names as format strings",
        "commit_text": " This avoids a segfault when copying/moving files containing \"%\" formatters in their name. ",
        "func_before": "static void\nthunar_transfer_job_copy_node (ThunarTransferJob  *job,\n                               ThunarTransferNode *node,\n                               GFile              *target_file,\n                               GFile              *target_parent_file,\n                               GList             **target_file_list_return,\n                               GError            **error)\n{\n  ThunarThumbnailCache *thumbnail_cache;\n  ThunarApplication    *application;\n  ThunarJobResponse     response;\n  GFileInfo            *info;\n  GError               *err = NULL;\n  GFile                *real_target_file = NULL;\n  gchar                *base_name;\n\n  _thunar_return_if_fail (THUNAR_IS_TRANSFER_JOB (job));\n  _thunar_return_if_fail (node != NULL && G_IS_FILE (node->source_file));\n  _thunar_return_if_fail (target_file == NULL || node->next == NULL);\n  _thunar_return_if_fail ((target_file == NULL && target_parent_file != NULL) || (target_file != NULL && target_parent_file == NULL));\n  _thunar_return_if_fail (error == NULL || *error == NULL);\n\n  /* The caller can either provide a target_file or a target_parent_file, but not both. The toplevel\n   * transfer_nodes (for which next is NULL) should be called with target_file, to get proper behavior\n   * wrt restoring files from the trash. Other transfer_nodes will be called with target_parent_file.\n   */\n\n  /* take a reference on the thumbnail cache */\n  application = thunar_application_get ();\n  thumbnail_cache = thunar_application_get_thumbnail_cache (application);\n  g_object_unref (application);\n\n  for (; err == NULL && node != NULL; node = node->next)\n    {\n      /* guess the target file for this node (unless already provided) */\n      if (G_LIKELY (target_file == NULL))\n        {\n          base_name = g_file_get_basename (node->source_file);\n          target_file = g_file_get_child (target_parent_file, base_name);\n          g_free (base_name);\n        }\n      else\n        target_file = g_object_ref (target_file);\n\n      /* query file info */\n      info = g_file_query_info (node->source_file,\n                                G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,\n                                G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                exo_job_get_cancellable (EXO_JOB (job)),\n                                &err);\n\n      /* abort on error or cancellation */\n      if (info == NULL)\n        {\n          g_object_unref (target_file);\n          break;\n        }\n\n      /* update progress information */\n      exo_job_info_message (EXO_JOB (job), g_file_info_get_display_name (info));\n\nretry_copy:\n      /* copy the item specified by this node (not recursively) */\n      real_target_file = thunar_transfer_job_copy_file (job, node->source_file, \n                                                        target_file, &err);\n      if (G_LIKELY (real_target_file != NULL))\n        {\n          /* node->source_file == real_target_file means to skip the file */\n          if (G_LIKELY (node->source_file != real_target_file))\n            {\n              /* notify the thumbnail cache of the copy operation */\n              thunar_thumbnail_cache_copy_file (thumbnail_cache, \n                                                node->source_file, \n                                                real_target_file);\n\n              /* check if we have children to copy */\n              if (node->children != NULL)\n                {\n                  /* copy all children of this node */\n                  thunar_transfer_job_copy_node (job, node->children, NULL, real_target_file, NULL, &err);\n\n                  /* free resources allocted for the children */\n                  thunar_transfer_node_free (node->children);\n                  node->children = NULL;\n                }\n\n              /* check if the child copy failed */\n              if (G_UNLIKELY (err != NULL))\n                {\n                  /* outa here, freeing the target paths */\n                  g_object_unref (real_target_file);\n                  g_object_unref (target_file);\n                  break;\n                }\n\n              /* add the real target file to the return list */\n              if (G_LIKELY (target_file_list_return != NULL))\n                {\n                  *target_file_list_return = \n                    thunar_g_file_list_prepend (*target_file_list_return, \n                                                real_target_file);\n                }\n\nretry_remove:\n              /* try to remove the source directory if we are on copy+remove fallback for move */\n              if (job->type == THUNAR_TRANSFER_JOB_MOVE)\n                {\n                  if (g_file_delete (node->source_file, \n                                     exo_job_get_cancellable (EXO_JOB (job)), \n                                     &err))\n                    {\n                      /* notify the thumbnail cache of the delete operation */\n                      thunar_thumbnail_cache_delete_file (thumbnail_cache, \n                                                          node->source_file);\n                    }\n                  else\n                    {\n                      /* ask the user to retry */\n                      response = thunar_job_ask_skip (THUNAR_JOB (job), \"%s\", \n                                                      err->message);\n\n                      /* reset the error */\n                      g_clear_error (&err);\n\n                      /* check whether to retry */\n                      if (G_UNLIKELY (response == THUNAR_JOB_RESPONSE_RETRY))\n                        goto retry_remove;\n                    }\n                }\n            }\n\n          g_object_unref (real_target_file);\n        }\n      else if (err != NULL)\n        { \n          /* we can only skip if there is space left on the device */\n          if (err->domain != G_IO_ERROR || err->code != G_IO_ERROR_NO_SPACE) \n            {\n              /* ask the user to skip this node and all subnodes */\n              response = thunar_job_ask_skip (THUNAR_JOB (job), \"%s\", err->message);\n\n              /* reset the error */\n              g_clear_error (&err);\n\n              /* check whether to retry */\n              if (G_UNLIKELY (response == THUNAR_JOB_RESPONSE_RETRY))\n                goto retry_copy;\n            }\n        }\n\n      /* release the guessed target file */\n      g_object_unref (target_file);\n      target_file = NULL;\n\n      /* release file info */\n      g_object_unref (info);\n    }\n\n  /* release the thumbnail cache */\n  g_object_unref (thumbnail_cache);\n\n  /* propagate error if we failed or the job was cancelled */\n  if (G_UNLIKELY (err != NULL))\n    g_propagate_error (error, err);\n}",
        "func": "static void\nthunar_transfer_job_copy_node (ThunarTransferJob  *job,\n                               ThunarTransferNode *node,\n                               GFile              *target_file,\n                               GFile              *target_parent_file,\n                               GList             **target_file_list_return,\n                               GError            **error)\n{\n  ThunarThumbnailCache *thumbnail_cache;\n  ThunarApplication    *application;\n  ThunarJobResponse     response;\n  GFileInfo            *info;\n  GError               *err = NULL;\n  GFile                *real_target_file = NULL;\n  gchar                *base_name;\n\n  _thunar_return_if_fail (THUNAR_IS_TRANSFER_JOB (job));\n  _thunar_return_if_fail (node != NULL && G_IS_FILE (node->source_file));\n  _thunar_return_if_fail (target_file == NULL || node->next == NULL);\n  _thunar_return_if_fail ((target_file == NULL && target_parent_file != NULL) || (target_file != NULL && target_parent_file == NULL));\n  _thunar_return_if_fail (error == NULL || *error == NULL);\n\n  /* The caller can either provide a target_file or a target_parent_file, but not both. The toplevel\n   * transfer_nodes (for which next is NULL) should be called with target_file, to get proper behavior\n   * wrt restoring files from the trash. Other transfer_nodes will be called with target_parent_file.\n   */\n\n  /* take a reference on the thumbnail cache */\n  application = thunar_application_get ();\n  thumbnail_cache = thunar_application_get_thumbnail_cache (application);\n  g_object_unref (application);\n\n  for (; err == NULL && node != NULL; node = node->next)\n    {\n      /* guess the target file for this node (unless already provided) */\n      if (G_LIKELY (target_file == NULL))\n        {\n          base_name = g_file_get_basename (node->source_file);\n          target_file = g_file_get_child (target_parent_file, base_name);\n          g_free (base_name);\n        }\n      else\n        target_file = g_object_ref (target_file);\n\n      /* query file info */\n      info = g_file_query_info (node->source_file,\n                                G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,\n                                G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                exo_job_get_cancellable (EXO_JOB (job)),\n                                &err);\n\n      /* abort on error or cancellation */\n      if (info == NULL)\n        {\n          g_object_unref (target_file);\n          break;\n        }\n\n      /* update progress information */\n      exo_job_info_message (EXO_JOB (job), \"%s\", g_file_info_get_display_name (info));\n\nretry_copy:\n      /* copy the item specified by this node (not recursively) */\n      real_target_file = thunar_transfer_job_copy_file (job, node->source_file, \n                                                        target_file, &err);\n      if (G_LIKELY (real_target_file != NULL))\n        {\n          /* node->source_file == real_target_file means to skip the file */\n          if (G_LIKELY (node->source_file != real_target_file))\n            {\n              /* notify the thumbnail cache of the copy operation */\n              thunar_thumbnail_cache_copy_file (thumbnail_cache, \n                                                node->source_file, \n                                                real_target_file);\n\n              /* check if we have children to copy */\n              if (node->children != NULL)\n                {\n                  /* copy all children of this node */\n                  thunar_transfer_job_copy_node (job, node->children, NULL, real_target_file, NULL, &err);\n\n                  /* free resources allocted for the children */\n                  thunar_transfer_node_free (node->children);\n                  node->children = NULL;\n                }\n\n              /* check if the child copy failed */\n              if (G_UNLIKELY (err != NULL))\n                {\n                  /* outa here, freeing the target paths */\n                  g_object_unref (real_target_file);\n                  g_object_unref (target_file);\n                  break;\n                }\n\n              /* add the real target file to the return list */\n              if (G_LIKELY (target_file_list_return != NULL))\n                {\n                  *target_file_list_return = \n                    thunar_g_file_list_prepend (*target_file_list_return, \n                                                real_target_file);\n                }\n\nretry_remove:\n              /* try to remove the source directory if we are on copy+remove fallback for move */\n              if (job->type == THUNAR_TRANSFER_JOB_MOVE)\n                {\n                  if (g_file_delete (node->source_file, \n                                     exo_job_get_cancellable (EXO_JOB (job)), \n                                     &err))\n                    {\n                      /* notify the thumbnail cache of the delete operation */\n                      thunar_thumbnail_cache_delete_file (thumbnail_cache, \n                                                          node->source_file);\n                    }\n                  else\n                    {\n                      /* ask the user to retry */\n                      response = thunar_job_ask_skip (THUNAR_JOB (job), \"%s\", \n                                                      err->message);\n\n                      /* reset the error */\n                      g_clear_error (&err);\n\n                      /* check whether to retry */\n                      if (G_UNLIKELY (response == THUNAR_JOB_RESPONSE_RETRY))\n                        goto retry_remove;\n                    }\n                }\n            }\n\n          g_object_unref (real_target_file);\n        }\n      else if (err != NULL)\n        { \n          /* we can only skip if there is space left on the device */\n          if (err->domain != G_IO_ERROR || err->code != G_IO_ERROR_NO_SPACE) \n            {\n              /* ask the user to skip this node and all subnodes */\n              response = thunar_job_ask_skip (THUNAR_JOB (job), \"%s\", err->message);\n\n              /* reset the error */\n              g_clear_error (&err);\n\n              /* check whether to retry */\n              if (G_UNLIKELY (response == THUNAR_JOB_RESPONSE_RETRY))\n                goto retry_copy;\n            }\n        }\n\n      /* release the guessed target file */\n      g_object_unref (target_file);\n      target_file = NULL;\n\n      /* release file info */\n      g_object_unref (info);\n    }\n\n  /* release the thumbnail cache */\n  g_object_unref (thumbnail_cache);\n\n  /* propagate error if we failed or the job was cancelled */\n  if (G_UNLIKELY (err != NULL))\n    g_propagate_error (error, err);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -57,7 +57,7 @@\n         }\n \n       /* update progress information */\n-      exo_job_info_message (EXO_JOB (job), g_file_info_get_display_name (info));\n+      exo_job_info_message (EXO_JOB (job), \"%s\", g_file_info_get_display_name (info));\n \n retry_copy:\n       /* copy the item specified by this node (not recursively) */",
        "diff_line_info": {
            "deleted_lines": [
                "      exo_job_info_message (EXO_JOB (job), g_file_info_get_display_name (info));"
            ],
            "added_lines": [
                "      exo_job_info_message (EXO_JOB (job), \"%s\", g_file_info_get_display_name (info));"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-15203",
        "func_name": "tensorflow/AsStringOp",
        "description": "In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, by controlling the `fill` argument of tf.strings.as_string, a malicious attacker is able to trigger a format string vulnerability due to the way the internal format use in a `printf` call is constructed. This may result in segmentation fault. The issue is patched in commit 33be22c65d86256e6826666662e40dbdfe70ee83, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.",
        "git_url": "https://github.com/tensorflow/tensorflow/commit/33be22c65d86256e6826666662e40dbdfe70ee83",
        "commit_title": "Prevent format string vulnerability in `tf.strings.as_string`.",
        "commit_text": " The `printf` format specifier only allows `#`, `0`, `-`, `+` and space as flag characters. Others are interpreted as width/precision/length modifier or conversion specifiers. If a character does not fit into any of these sets `printf` just displays it.  Also add a test suite for `tf.strings.as_string`. Also fix the issue where the flag character was used only if width was specified.  PiperOrigin-RevId: 332553548",
        "func_before": "explicit AsStringOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    int32 precision;\n    bool scientific;\n    bool shortest;\n    int32 width;\n    string fill_string;\n    DataType dtype;\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"T\", &dtype));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"precision\", &precision));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"scientific\", &scientific));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"shortest\", &shortest));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"width\", &width));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"fill\", &fill_string));\n    switch (dtype) {\n      case DT_FLOAT:\n      case DT_DOUBLE:\n      case DT_COMPLEX64:\n      case DT_COMPLEX128:\n        break;\n      default:\n        OP_REQUIRES(ctx, !(scientific || shortest),\n                    errors::InvalidArgument(\"scientific and shortest format \"\n                                            \"not supported for datatype \",\n                                            DataTypeString(dtype)));\n        OP_REQUIRES(ctx, precision < 0,\n                    errors::InvalidArgument(\"precision not supported \"\n                                            \"for datatype \",\n                                            DataTypeString(dtype)));\n    }\n    OP_REQUIRES(\n        ctx, fill_string.size() <= 1,\n        errors::InvalidArgument(\"Fill string must be one or fewer characters\"));\n    OP_REQUIRES(ctx, !(scientific && shortest),\n                errors::InvalidArgument(\n                    \"Cannot select both scientific and shortest notation\"));\n    format_ = \"%\";\n    if (width > -1) {\n      strings::Appendf(&format_, \"%s%d\", fill_string.c_str(), width);\n    }\n    if (precision > -1) {\n      strings::Appendf(&format_, \".%d\", precision);\n    }\n    switch (dtype) {\n      case DT_INT8:\n      case DT_INT16:\n      case DT_INT32:\n        strings::Appendf(&format_, \"d\");\n        break;\n      case DT_INT64:\n        strings::Appendf(&format_, \"lld\");\n        break;\n      case DT_FLOAT:\n      case DT_DOUBLE:\n      case DT_COMPLEX64:\n      case DT_COMPLEX128:\n        if (shortest) {\n          strings::Appendf(&format_, \"g\");\n        } else if (scientific) {\n          strings::Appendf(&format_, \"e\");\n        } else {\n          strings::Appendf(&format_, \"f\");\n        }\n        break;\n      case DT_BOOL:\n        break;\n      default:\n        bool type_not_supported = true;\n        OP_REQUIRES(ctx, !type_not_supported,\n                    errors::InvalidArgument(\"Type not supported: \",\n                                            DataTypeString(dtype)));\n    }\n\n    if (dtype == DT_COMPLEX64 || dtype == DT_COMPLEX128) {\n      format_ = strings::Printf(\"(%s,%s)\", format_.c_str(), format_.c_str());\n    }\n  }",
        "func": "explicit AsStringOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    int32 precision;\n    bool scientific;\n    bool shortest;\n    int32 width;\n    string fill_string;\n    DataType dtype;\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"T\", &dtype));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"precision\", &precision));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"scientific\", &scientific));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"shortest\", &shortest));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"width\", &width));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"fill\", &fill_string));\n    switch (dtype) {\n      case DT_FLOAT:\n      case DT_DOUBLE:\n      case DT_COMPLEX64:\n      case DT_COMPLEX128:\n        break;\n      default:\n        OP_REQUIRES(ctx, !(scientific || shortest),\n                    errors::InvalidArgument(\"scientific and shortest format \"\n                                            \"not supported for datatype \",\n                                            DataTypeString(dtype)));\n        OP_REQUIRES(ctx, precision < 0,\n                    errors::InvalidArgument(\"precision not supported \"\n                                            \"for datatype \",\n                                            DataTypeString(dtype)));\n    }\n    OP_REQUIRES(\n        ctx, fill_string.size() <= 1,\n        errors::InvalidArgument(\"Fill string must be one or fewer characters\"));\n    OP_REQUIRES(ctx, !(scientific && shortest),\n                errors::InvalidArgument(\n                    \"Cannot select both scientific and shortest notation\"));\n\n    format_ = \"%\";\n    if (!fill_string.empty()) {\n      switch (fill_string[0]) {\n        case ' ':\n        case '+':\n        case '-':\n        case '0':\n        case '#':\n          strings::Appendf(&format_, \"%s\", fill_string.c_str());\n          break;\n        default:\n          bool fill_not_supported = true;\n          OP_REQUIRES(ctx, !fill_not_supported,\n                      errors::InvalidArgument(\"Fill argument not supported: \\\"\",\n                                              fill_string, \"\\\"\"));\n      }\n    }\n    if (width > -1) {\n      strings::Appendf(&format_, \"%d\", width);\n    }\n    if (precision > -1) {\n      strings::Appendf(&format_, \".%d\", precision);\n    }\n    switch (dtype) {\n      case DT_INT8:\n      case DT_INT16:\n      case DT_INT32:\n        strings::Appendf(&format_, \"d\");\n        break;\n      case DT_INT64:\n        strings::Appendf(&format_, \"lld\");\n        break;\n      case DT_FLOAT:\n      case DT_DOUBLE:\n      case DT_COMPLEX64:\n      case DT_COMPLEX128:\n        if (shortest) {\n          strings::Appendf(&format_, \"g\");\n        } else if (scientific) {\n          strings::Appendf(&format_, \"e\");\n        } else {\n          strings::Appendf(&format_, \"f\");\n        }\n        break;\n      case DT_BOOL:\n        break;\n      default:\n        bool type_not_supported = true;\n        OP_REQUIRES(ctx, !type_not_supported,\n                    errors::InvalidArgument(\"Type not supported: \",\n                                            DataTypeString(dtype)));\n    }\n\n    if (dtype == DT_COMPLEX64 || dtype == DT_COMPLEX128) {\n      format_ = strings::Printf(\"(%s,%s)\", format_.c_str(), format_.c_str());\n    }\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -33,9 +33,26 @@\n     OP_REQUIRES(ctx, !(scientific && shortest),\n                 errors::InvalidArgument(\n                     \"Cannot select both scientific and shortest notation\"));\n+\n     format_ = \"%\";\n+    if (!fill_string.empty()) {\n+      switch (fill_string[0]) {\n+        case ' ':\n+        case '+':\n+        case '-':\n+        case '0':\n+        case '#':\n+          strings::Appendf(&format_, \"%s\", fill_string.c_str());\n+          break;\n+        default:\n+          bool fill_not_supported = true;\n+          OP_REQUIRES(ctx, !fill_not_supported,\n+                      errors::InvalidArgument(\"Fill argument not supported: \\\"\",\n+                                              fill_string, \"\\\"\"));\n+      }\n+    }\n     if (width > -1) {\n-      strings::Appendf(&format_, \"%s%d\", fill_string.c_str(), width);\n+      strings::Appendf(&format_, \"%d\", width);\n     }\n     if (precision > -1) {\n       strings::Appendf(&format_, \".%d\", precision);",
        "diff_line_info": {
            "deleted_lines": [
                "      strings::Appendf(&format_, \"%s%d\", fill_string.c_str(), width);"
            ],
            "added_lines": [
                "",
                "    if (!fill_string.empty()) {",
                "      switch (fill_string[0]) {",
                "        case ' ':",
                "        case '+':",
                "        case '-':",
                "        case '0':",
                "        case '#':",
                "          strings::Appendf(&format_, \"%s\", fill_string.c_str());",
                "          break;",
                "        default:",
                "          bool fill_not_supported = true;",
                "          OP_REQUIRES(ctx, !fill_not_supported,",
                "                      errors::InvalidArgument(\"Fill argument not supported: \\\"\",",
                "                                              fill_string, \"\\\"\"));",
                "      }",
                "    }",
                "      strings::Appendf(&format_, \"%d\", width);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3724",
        "func_name": "wireshark/get_usage_page_item_string",
        "description": "Crash in the USB HID protocol dissector in Wireshark 3.6.0 to 3.6.8 allows denial of service via packet injection or crafted capture file on Windows",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/402bb0ee81d89c3effa55baadf682a2e0ed1813b",
        "commit_title": "USB HID: Always use a format string.",
        "commit_text": " Ensure that the second argument to wmem_strdup_printf is always a format string. Fixes #18384. ",
        "func_before": "static gchar*\nget_usage_page_item_string(wmem_allocator_t *pool, guint32 usage_page, guint32 id)\n{\n    const char *str = NULL;\n\n    switch (usage_page)\n    {\n    case GENERIC_DESKTOP_CONTROLS_PAGE:\n        str = try_val_to_str(id, usb_hid_generic_desktop_controls_usage_page_vals);\n        break;\n    case SIMULATION_CONTROLS_PAGE:\n        str = try_val_to_str(id, usb_hid_simulation_control_usage_page_vals);\n        break;\n    case VR_CONTROLS_PAGE:\n        str = try_val_to_str(id, usb_hid_vr_controls_usage_page_vals);\n        break;\n    case SPORT_CONTROLS_PAGE:\n        str = try_val_to_str(id, usb_hid_sport_controls_usage_page_vals);\n        break;\n    case GAME_CONTROLS_PAGE:\n        str = try_val_to_str(id, usb_hid_game_controls_usage_page_vals);\n        break;\n    case GENERIC_DEVICE_CONTROLS_PAGE:\n        str = try_val_to_str(id, usb_hid_generic_device_controls_usage_page_vals);\n        break;\n    case KEYBOARD_KEYPAD_PAGE:\n        str = try_val_to_str(id, usb_hid_keyboard_keypad_usage_page_vals);\n        break;\n    case LED_PAGE:\n        str = try_val_to_str(id, usb_hid_led_usage_page_vals);\n        break;\n    case BUTTON_PAGE:\n        str = try_val_to_str(id, usb_hid_button_usage_page_vals);\n        if (!str)\n            str = \"Button %u\";\n        break;\n    case ORDINAL_PAGE:\n        str = try_val_to_str(id, usb_hid_ordinal_usage_page_vals);\n        break;\n    case TELEPHONY_PAGE:\n        str = try_val_to_str(id, usb_hid_telephony_device_usage_page_vals);\n        break;\n    case CONSUMER_PAGE:\n        str = try_val_to_str(id, usb_hid_consumer_usage_page_vals);\n        if (!str)\n            str = \"Instance %u\";\n        break;\n    case DIGITIZER_PAGE:\n        str = try_val_to_str(id, usb_hid_digitizers_usage_page_vals);\n        break;\n    case HAPTICS_PAGE:\n        str = try_val_to_str(id, usb_hid_haptic_usage_page_vals);\n        if (id >= 0x2001 && id <= 0x2FFF)\n            str = \"Vendor Waveforms\";\n        break;\n    case PID_PAGE:\n        str = try_val_to_str(id, usb_hid_physical_input_device_usage_page_vals);\n        break;\n    case UNICODE_PAGE:\n        str = \"Character U+%04X\";\n        break;\n    case EYE_AND_HEAD_TRACKER_PAGE:\n        str = try_val_to_str(id, usb_hid_eye_and_head_tracker_usage_page_vals);\n        break;\n    case ALPHANUMERIC_DISPLAY_PAGE:\n        str = try_val_to_str(id, usb_hid_alphanumeric_display_usage_page_vals);\n        break;\n    case SENSOR_PAGE:\n        str = try_val_to_str(id, usb_hid_sensor_usage_page_vals);\n        if (!str)\n            str = try_rval_to_str(id, usb_hid_sensor_usage_page_ranges);\n        break;\n    case MEDICAL_INSTRUMENTS_PAGE:\n        str = try_val_to_str(id, usb_hid_medical_instrument_usage_page_vals);\n        break;\n    case BRAILLE_DISPLAY_PAGE:\n        str = try_val_to_str(id, usb_hid_braille_dispaly_usage_page_vals);\n        break;\n    case LIGHTING_AND_ILLUMINATION_PAGE:\n        str = try_val_to_str(id, usb_hid_lighting_and_illumination_usage_page_vals);\n        break;\n    case USB_MONITOR_PAGE:\n        str = try_val_to_str(id, usb_hid_monitor_usage_page_vals);\n        break;\n    case USB_ENUMERATED_VALUES_PAGE:\n        str = \"ENUM_%u\";\n        break;\n    case VESA_VIRTUAL_CONTROLS_PAGE:\n        str = try_val_to_str(id, usb_hid_vesa_virtual_control_usage_page_vals);\n        break;\n    case POWER_DEVICE_PAGE:\n        str = try_val_to_str(id, usb_hid_power_device_usage_page_vals);\n        break;\n    case BATTERY_SYSTEM_PAGE:\n        str = try_val_to_str(id, usb_hid_battery_system_usage_page_vals);\n        break;\n    case BARCODE_SCANNER_PAGE:\n        str = try_val_to_str(id, usb_hid_barcode_scanner_usage_page_vals);\n        break;\n    case WEIGHING_PAGE:\n        str = try_val_to_str(id, usb_hid_weighing_devices_usage_page_vals);\n        break;\n    case MSR_PAGE:\n        str = try_val_to_str(id, usb_hid_magnetic_stripe_reader_usage_page_vals);\n        break;\n    case CAMERA_CONTROL_PAGE:\n        str = try_val_to_str(id, usb_hid_camera_control_usage_page_vals);\n        break;\n    case ARCADE_PAGE:\n        str = try_val_to_str(id, usb_hid_arcade_usage_page_vals);\n        break;\n    case FIDO_ALLIANCE_PAGE:\n        str = try_val_to_str(id, usb_hid_fido_alliance_usage_page_vals);\n        break;\n    default:\n        if ((usage_page & VENDOR_PAGE_HBYTE) == VENDOR_PAGE_HBYTE)\n            str = \"Vendor\";\n        break;\n    }\n\n    if (!str)\n        str = \"Reserved\";\n\n    return wmem_strdup_printf(pool, str, id);\n}",
        "func": "static gchar*\nget_usage_page_item_string(wmem_allocator_t *pool, guint32 usage_page, guint32 id)\n{\n    const char *str = NULL;\n    const char *fmt_str = NULL;\n\n    switch (usage_page)\n    {\n    case GENERIC_DESKTOP_CONTROLS_PAGE:\n        str = try_val_to_str(id, usb_hid_generic_desktop_controls_usage_page_vals);\n        break;\n    case SIMULATION_CONTROLS_PAGE:\n        str = try_val_to_str(id, usb_hid_simulation_control_usage_page_vals);\n        break;\n    case VR_CONTROLS_PAGE:\n        str = try_val_to_str(id, usb_hid_vr_controls_usage_page_vals);\n        break;\n    case SPORT_CONTROLS_PAGE:\n        str = try_val_to_str(id, usb_hid_sport_controls_usage_page_vals);\n        break;\n    case GAME_CONTROLS_PAGE:\n        str = try_val_to_str(id, usb_hid_game_controls_usage_page_vals);\n        break;\n    case GENERIC_DEVICE_CONTROLS_PAGE:\n        str = try_val_to_str(id, usb_hid_generic_device_controls_usage_page_vals);\n        break;\n    case KEYBOARD_KEYPAD_PAGE:\n        str = try_val_to_str(id, usb_hid_keyboard_keypad_usage_page_vals);\n        break;\n    case LED_PAGE:\n        str = try_val_to_str(id, usb_hid_led_usage_page_vals);\n        break;\n    case BUTTON_PAGE:\n        str = try_val_to_str(id, usb_hid_button_usage_page_vals);\n        if (!str)\n            fmt_str = \"Button %u\";\n        break;\n    case ORDINAL_PAGE:\n        str = try_val_to_str(id, usb_hid_ordinal_usage_page_vals);\n        break;\n    case TELEPHONY_PAGE:\n        str = try_val_to_str(id, usb_hid_telephony_device_usage_page_vals);\n        break;\n    case CONSUMER_PAGE:\n        str = try_val_to_str(id, usb_hid_consumer_usage_page_vals);\n        if (!str)\n            fmt_str = \"Instance %u\";\n        break;\n    case DIGITIZER_PAGE:\n        str = try_val_to_str(id, usb_hid_digitizers_usage_page_vals);\n        break;\n    case HAPTICS_PAGE:\n        str = try_val_to_str(id, usb_hid_haptic_usage_page_vals);\n        if (id >= 0x2001 && id <= 0x2FFF)\n            str = \"Vendor Waveforms\";\n        break;\n    case PID_PAGE:\n        str = try_val_to_str(id, usb_hid_physical_input_device_usage_page_vals);\n        break;\n    case UNICODE_PAGE:\n        fmt_str = \"Character U+%04X\";\n        break;\n    case EYE_AND_HEAD_TRACKER_PAGE:\n        str = try_val_to_str(id, usb_hid_eye_and_head_tracker_usage_page_vals);\n        break;\n    case ALPHANUMERIC_DISPLAY_PAGE:\n        str = try_val_to_str(id, usb_hid_alphanumeric_display_usage_page_vals);\n        break;\n    case SENSOR_PAGE:\n        str = try_val_to_str(id, usb_hid_sensor_usage_page_vals);\n        if (!str)\n            str = try_rval_to_str(id, usb_hid_sensor_usage_page_ranges);\n        break;\n    case MEDICAL_INSTRUMENTS_PAGE:\n        str = try_val_to_str(id, usb_hid_medical_instrument_usage_page_vals);\n        break;\n    case BRAILLE_DISPLAY_PAGE:\n        str = try_val_to_str(id, usb_hid_braille_dispaly_usage_page_vals);\n        break;\n    case LIGHTING_AND_ILLUMINATION_PAGE:\n        str = try_val_to_str(id, usb_hid_lighting_and_illumination_usage_page_vals);\n        break;\n    case USB_MONITOR_PAGE:\n        str = try_val_to_str(id, usb_hid_monitor_usage_page_vals);\n        break;\n    case USB_ENUMERATED_VALUES_PAGE:\n        fmt_str = \"ENUM_%u\";\n        break;\n    case VESA_VIRTUAL_CONTROLS_PAGE:\n        str = try_val_to_str(id, usb_hid_vesa_virtual_control_usage_page_vals);\n        break;\n    case POWER_DEVICE_PAGE:\n        str = try_val_to_str(id, usb_hid_power_device_usage_page_vals);\n        break;\n    case BATTERY_SYSTEM_PAGE:\n        str = try_val_to_str(id, usb_hid_battery_system_usage_page_vals);\n        break;\n    case BARCODE_SCANNER_PAGE:\n        str = try_val_to_str(id, usb_hid_barcode_scanner_usage_page_vals);\n        break;\n    case WEIGHING_PAGE:\n        str = try_val_to_str(id, usb_hid_weighing_devices_usage_page_vals);\n        break;\n    case MSR_PAGE:\n        str = try_val_to_str(id, usb_hid_magnetic_stripe_reader_usage_page_vals);\n        break;\n    case CAMERA_CONTROL_PAGE:\n        str = try_val_to_str(id, usb_hid_camera_control_usage_page_vals);\n        break;\n    case ARCADE_PAGE:\n        str = try_val_to_str(id, usb_hid_arcade_usage_page_vals);\n        break;\n    case FIDO_ALLIANCE_PAGE:\n        str = try_val_to_str(id, usb_hid_fido_alliance_usage_page_vals);\n        break;\n    default:\n        if ((usage_page & VENDOR_PAGE_HBYTE) == VENDOR_PAGE_HBYTE)\n            str = \"Vendor\";\n        break;\n    }\n\n    if (fmt_str) {\n        return wmem_strdup_printf(pool, fmt_str, id);\n    }\n    if (!str) {\n        str = \"Reserved\";\n    }\n    return wmem_strdup_printf(pool, \"%s\", str);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,7 @@\n get_usage_page_item_string(wmem_allocator_t *pool, guint32 usage_page, guint32 id)\n {\n     const char *str = NULL;\n+    const char *fmt_str = NULL;\n \n     switch (usage_page)\n     {\n@@ -32,7 +33,7 @@\n     case BUTTON_PAGE:\n         str = try_val_to_str(id, usb_hid_button_usage_page_vals);\n         if (!str)\n-            str = \"Button %u\";\n+            fmt_str = \"Button %u\";\n         break;\n     case ORDINAL_PAGE:\n         str = try_val_to_str(id, usb_hid_ordinal_usage_page_vals);\n@@ -43,7 +44,7 @@\n     case CONSUMER_PAGE:\n         str = try_val_to_str(id, usb_hid_consumer_usage_page_vals);\n         if (!str)\n-            str = \"Instance %u\";\n+            fmt_str = \"Instance %u\";\n         break;\n     case DIGITIZER_PAGE:\n         str = try_val_to_str(id, usb_hid_digitizers_usage_page_vals);\n@@ -57,7 +58,7 @@\n         str = try_val_to_str(id, usb_hid_physical_input_device_usage_page_vals);\n         break;\n     case UNICODE_PAGE:\n-        str = \"Character U+%04X\";\n+        fmt_str = \"Character U+%04X\";\n         break;\n     case EYE_AND_HEAD_TRACKER_PAGE:\n         str = try_val_to_str(id, usb_hid_eye_and_head_tracker_usage_page_vals);\n@@ -83,7 +84,7 @@\n         str = try_val_to_str(id, usb_hid_monitor_usage_page_vals);\n         break;\n     case USB_ENUMERATED_VALUES_PAGE:\n-        str = \"ENUM_%u\";\n+        fmt_str = \"ENUM_%u\";\n         break;\n     case VESA_VIRTUAL_CONTROLS_PAGE:\n         str = try_val_to_str(id, usb_hid_vesa_virtual_control_usage_page_vals);\n@@ -118,8 +119,11 @@\n         break;\n     }\n \n-    if (!str)\n+    if (fmt_str) {\n+        return wmem_strdup_printf(pool, fmt_str, id);\n+    }\n+    if (!str) {\n         str = \"Reserved\";\n-\n-    return wmem_strdup_printf(pool, str, id);\n+    }\n+    return wmem_strdup_printf(pool, \"%s\", str);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "            str = \"Button %u\";",
                "            str = \"Instance %u\";",
                "        str = \"Character U+%04X\";",
                "        str = \"ENUM_%u\";",
                "    if (!str)",
                "",
                "    return wmem_strdup_printf(pool, str, id);"
            ],
            "added_lines": [
                "    const char *fmt_str = NULL;",
                "            fmt_str = \"Button %u\";",
                "            fmt_str = \"Instance %u\";",
                "        fmt_str = \"Character U+%04X\";",
                "        fmt_str = \"ENUM_%u\";",
                "    if (fmt_str) {",
                "        return wmem_strdup_printf(pool, fmt_str, id);",
                "    }",
                "    if (!str) {",
                "    }",
                "    return wmem_strdup_printf(pool, \"%s\", str);"
            ]
        }
    }
]