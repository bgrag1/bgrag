[
    {
        "cve_id": "CVE-2022-35978",
        "func_name": "minetest/checkSettingSecurity",
        "description": "Minetest is a free open-source voxel game engine with easy modding and game creation. In **single player**, a mod can set a global setting that controls the Lua script loaded to display the main menu. The script is then loaded as soon as the game session is exited. The Lua environment the menu runs in is not sandboxed and can directly interfere with the user's system. There are currently no known workarounds.",
        "git_url": "https://github.com/minetest/minetest/commit/da71e86633d0b27cd02d7aac9fdac625d141ca13",
        "commit_title": "Protect a few more settings from being set from mods",
        "commit_text": " Of those settings main_menu_script has concrete security impact, the rest are added out of abundance of caution.",
        "func_before": "static inline int checkSettingSecurity(lua_State* L, const std::string &name)\n{\n\tif (ScriptApiSecurity::isSecure(L) && name.compare(0, 7, \"secure.\") == 0)\n\t\tthrow LuaError(\"Attempt to set secure setting.\");\n\n\tbool is_mainmenu = false;\n#ifndef SERVER\n\tis_mainmenu = ModApiBase::getGuiEngine(L) != nullptr;\n#endif\n\tif (!is_mainmenu && (name == \"mg_name\" || name == \"mg_flags\")) {\n\t\terrorstream << \"Tried to set global setting \" << name << \", ignoring. \"\n\t\t\t\"minetest.set_mapgen_setting() should be used instead.\" << std::endl;\n\t\tinfostream << script_get_backtrace(L) << std::endl;\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
        "func": "static inline int checkSettingSecurity(lua_State* L, const std::string &name)\n{\n\tif (ScriptApiSecurity::isSecure(L) && name.compare(0, 7, \"secure.\") == 0)\n\t\tthrow LuaError(\"Attempted to set secure setting.\");\n\n\tbool is_mainmenu = false;\n#ifndef SERVER\n\tis_mainmenu = ModApiBase::getGuiEngine(L) != nullptr;\n#endif\n\tif (!is_mainmenu && (name == \"mg_name\" || name == \"mg_flags\")) {\n\t\terrorstream << \"Tried to set global setting \" << name << \", ignoring. \"\n\t\t\t\"minetest.set_mapgen_setting() should be used instead.\" << std::endl;\n\t\tinfostream << script_get_backtrace(L) << std::endl;\n\t\treturn -1;\n\t}\n\n\tconst char *disallowed[] = {\n\t\t\"main_menu_script\", \"shader_path\", \"texture_path\", \"screenshot_path\",\n\t\t\"serverlist_file\", \"serverlist_url\", \"map-dir\", \"contentdb_url\",\n\t};\n\tif (!is_mainmenu) {\n\t\tfor (const char *name2 : disallowed) {\n\t\t\tif (name == name2)\n\t\t\t\tthrow LuaError(\"Attempted to set disallowed setting.\");\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n static inline int checkSettingSecurity(lua_State* L, const std::string &name)\n {\n \tif (ScriptApiSecurity::isSecure(L) && name.compare(0, 7, \"secure.\") == 0)\n-\t\tthrow LuaError(\"Attempt to set secure setting.\");\n+\t\tthrow LuaError(\"Attempted to set secure setting.\");\n \n \tbool is_mainmenu = false;\n #ifndef SERVER\n@@ -14,5 +14,16 @@\n \t\treturn -1;\n \t}\n \n+\tconst char *disallowed[] = {\n+\t\t\"main_menu_script\", \"shader_path\", \"texture_path\", \"screenshot_path\",\n+\t\t\"serverlist_file\", \"serverlist_url\", \"map-dir\", \"contentdb_url\",\n+\t};\n+\tif (!is_mainmenu) {\n+\t\tfor (const char *name2 : disallowed) {\n+\t\t\tif (name == name2)\n+\t\t\t\tthrow LuaError(\"Attempted to set disallowed setting.\");\n+\t\t}\n+\t}\n+\n \treturn 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tthrow LuaError(\"Attempt to set secure setting.\");"
            ],
            "added_lines": [
                "\t\tthrow LuaError(\"Attempted to set secure setting.\");",
                "\tconst char *disallowed[] = {",
                "\t\t\"main_menu_script\", \"shader_path\", \"texture_path\", \"screenshot_path\",",
                "\t\t\"serverlist_file\", \"serverlist_url\", \"map-dir\", \"contentdb_url\",",
                "\t};",
                "\tif (!is_mainmenu) {",
                "\t\tfor (const char *name2 : disallowed) {",
                "\t\t\tif (name == name2)",
                "\t\t\t\tthrow LuaError(\"Attempted to set disallowed setting.\");",
                "\t\t}",
                "\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2018-6794",
        "func_name": "OISF/suricata/DetectFlow",
        "description": "Suricata before 4.0.4 is prone to an HTTP detection bypass vulnerability in detect.c and stream-tcp.c. If a malicious server breaks a normal TCP flow and sends data before the 3-way handshake is complete, then the data sent by the malicious server will be accepted by web clients such as a web browser or Linux CLI utilities, but ignored by Suricata IDS signatures. This mostly affects IDS signatures for the HTTP protocol and TCP stream content; signatures for TCP packets will inspect such network traffic as usual.",
        "git_url": "https://github.com/OISF/suricata/commit/e1ef57c848bbe4e567d5d4b66d346a742e3f77a1",
        "commit_title": "stream: still inspect packets dropped by stream",
        "commit_text": " The detect engine would bypass packets that are set as dropped. This seems sane, as these packets are going to be dropped anyway.  However, it lead to the following corner case: stream events that triggered the drop could not be matched on the rules. The packet with the event wouldn't make it to the detect engine due to the bypass.  This patch changes the logic to not bypass DROP packets anymore. Packets that are dropped by the stream engine will set the no payload inspection flag, so avoid needless cost.",
        "func_before": "static void DetectFlow(ThreadVars *tv,\n                       DetectEngineCtx *de_ctx, DetectEngineThreadCtx *det_ctx,\n                       Packet *p)\n{\n    /* No need to perform any detection on this packet, if the the given flag is set.*/\n    if ((p->flags & PKT_NOPACKET_INSPECTION) ||\n        (PACKET_TEST_ACTION(p, ACTION_DROP)))\n    {\n        /* hack: if we are in pass the entire flow mode, we need to still\n         * update the inspect_id forward. So test for the condition here,\n         * and call the update code if necessary. */\n        const int pass = ((p->flow->flags & FLOW_NOPACKET_INSPECTION));\n        const AppProto alproto = FlowGetAppProtocol(p->flow);\n        if (pass && AppLayerParserProtocolSupportsTxs(p->proto, alproto)) {\n            uint8_t flags;\n            if (p->flowflags & FLOW_PKT_TOSERVER) {\n                flags = STREAM_TOSERVER;\n            } else {\n                flags = STREAM_TOCLIENT;\n            }\n            flags = FlowGetDisruptionFlags(p->flow, flags);\n            DeStateUpdateInspectTransactionId(p->flow, flags, true);\n        }\n        return;\n    }\n\n    /* see if the packet matches one or more of the sigs */\n    (void)DetectRun(tv, de_ctx, det_ctx, p);\n}",
        "func": "static void DetectFlow(ThreadVars *tv,\n                       DetectEngineCtx *de_ctx, DetectEngineThreadCtx *det_ctx,\n                       Packet *p)\n{\n    if (p->flags & PKT_NOPACKET_INSPECTION) {\n        /* hack: if we are in pass the entire flow mode, we need to still\n         * update the inspect_id forward. So test for the condition here,\n         * and call the update code if necessary. */\n        const int pass = ((p->flow->flags & FLOW_NOPACKET_INSPECTION));\n        const AppProto alproto = FlowGetAppProtocol(p->flow);\n        if (pass && AppLayerParserProtocolSupportsTxs(p->proto, alproto)) {\n            uint8_t flags;\n            if (p->flowflags & FLOW_PKT_TOSERVER) {\n                flags = STREAM_TOSERVER;\n            } else {\n                flags = STREAM_TOCLIENT;\n            }\n            flags = FlowGetDisruptionFlags(p->flow, flags);\n            DeStateUpdateInspectTransactionId(p->flow, flags, true);\n        }\n        SCLogDebug(\"p->pcap %\"PRIu64\": no detection on packet, \"\n                \"PKT_NOPACKET_INSPECTION is set\", p->pcap_cnt);\n        return;\n    }\n\n    /* see if the packet matches one or more of the sigs */\n    (void)DetectRun(tv, de_ctx, det_ctx, p);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,10 +2,7 @@\n                        DetectEngineCtx *de_ctx, DetectEngineThreadCtx *det_ctx,\n                        Packet *p)\n {\n-    /* No need to perform any detection on this packet, if the the given flag is set.*/\n-    if ((p->flags & PKT_NOPACKET_INSPECTION) ||\n-        (PACKET_TEST_ACTION(p, ACTION_DROP)))\n-    {\n+    if (p->flags & PKT_NOPACKET_INSPECTION) {\n         /* hack: if we are in pass the entire flow mode, we need to still\n          * update the inspect_id forward. So test for the condition here,\n          * and call the update code if necessary. */\n@@ -21,6 +18,8 @@\n             flags = FlowGetDisruptionFlags(p->flow, flags);\n             DeStateUpdateInspectTransactionId(p->flow, flags, true);\n         }\n+        SCLogDebug(\"p->pcap %\"PRIu64\": no detection on packet, \"\n+                \"PKT_NOPACKET_INSPECTION is set\", p->pcap_cnt);\n         return;\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    /* No need to perform any detection on this packet, if the the given flag is set.*/",
                "    if ((p->flags & PKT_NOPACKET_INSPECTION) ||",
                "        (PACKET_TEST_ACTION(p, ACTION_DROP)))",
                "    {"
            ],
            "added_lines": [
                "    if (p->flags & PKT_NOPACKET_INSPECTION) {",
                "        SCLogDebug(\"p->pcap %\"PRIu64\": no detection on packet, \"",
                "                \"PKT_NOPACKET_INSPECTION is set\", p->pcap_cnt);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-6794",
        "func_name": "OISF/suricata/StreamTcpPacket",
        "description": "Suricata before 4.0.4 is prone to an HTTP detection bypass vulnerability in detect.c and stream-tcp.c. If a malicious server breaks a normal TCP flow and sends data before the 3-way handshake is complete, then the data sent by the malicious server will be accepted by web clients such as a web browser or Linux CLI utilities, but ignored by Suricata IDS signatures. This mostly affects IDS signatures for the HTTP protocol and TCP stream content; signatures for TCP packets will inspect such network traffic as usual.",
        "git_url": "https://github.com/OISF/suricata/commit/e1ef57c848bbe4e567d5d4b66d346a742e3f77a1",
        "commit_title": "stream: still inspect packets dropped by stream",
        "commit_text": " The detect engine would bypass packets that are set as dropped. This seems sane, as these packets are going to be dropped anyway.  However, it lead to the following corner case: stream events that triggered the drop could not be matched on the rules. The packet with the event wouldn't make it to the detect engine due to the bypass.  This patch changes the logic to not bypass DROP packets anymore. Packets that are dropped by the stream engine will set the no payload inspection flag, so avoid needless cost.",
        "func_before": "int StreamTcpPacket (ThreadVars *tv, Packet *p, StreamTcpThread *stt,\n                     PacketQueue *pq)\n{\n    SCEnter();\n\n    DEBUG_ASSERT_FLOW_LOCKED(p->flow);\n\n    SCLogDebug(\"p->pcap_cnt %\"PRIu64, p->pcap_cnt);\n\n    /* assign the thread id to the flow */\n    if (unlikely(p->flow->thread_id == 0)) {\n        p->flow->thread_id = (FlowThreadId)tv->id;\n#ifdef DEBUG\n    } else if (unlikely((FlowThreadId)tv->id != p->flow->thread_id)) {\n        SCLogDebug(\"wrong thread: flow has %u, we are %d\", p->flow->thread_id, tv->id);\n#endif\n    }\n\n    TcpSession *ssn = (TcpSession *)p->flow->protoctx;\n\n    /* track TCP flags */\n    if (ssn != NULL) {\n        ssn->tcp_packet_flags |= p->tcph->th_flags;\n        if (PKT_IS_TOSERVER(p))\n            ssn->client.tcp_flags |= p->tcph->th_flags;\n        else if (PKT_IS_TOCLIENT(p))\n            ssn->server.tcp_flags |= p->tcph->th_flags;\n\n        /* check if we need to unset the ASYNC flag */\n        if (ssn->flags & STREAMTCP_FLAG_ASYNC &&\n            ssn->client.tcp_flags != 0 &&\n            ssn->server.tcp_flags != 0)\n        {\n            SCLogDebug(\"ssn %p: removing ASYNC flag as we have packets on both sides\", ssn);\n            ssn->flags &= ~STREAMTCP_FLAG_ASYNC;\n        }\n    }\n\n    /* update counters */\n    if ((p->tcph->th_flags & (TH_SYN|TH_ACK)) == (TH_SYN|TH_ACK)) {\n        StatsIncr(tv, stt->counter_tcp_synack);\n    } else if (p->tcph->th_flags & (TH_SYN)) {\n        StatsIncr(tv, stt->counter_tcp_syn);\n    }\n    if (p->tcph->th_flags & (TH_RST)) {\n        StatsIncr(tv, stt->counter_tcp_rst);\n    }\n\n    /* broken TCP http://ask.wireshark.org/questions/3183/acknowledgment-number-broken-tcp-the-acknowledge-field-is-nonzero-while-the-ack-flag-is-not-set */\n    if (!(p->tcph->th_flags & TH_ACK) && TCP_GET_ACK(p) != 0) {\n        StreamTcpSetEvent(p, STREAM_PKT_BROKEN_ACK);\n    }\n\n    /* If we are on IPS mode, and got a drop action triggered from\n     * the IP only module, or from a reassembled msg and/or from an\n     * applayer detection, then drop the rest of the packets of the\n     * same stream and avoid inspecting it any further */\n    if (StreamTcpCheckFlowDrops(p) == 1) {\n        SCLogDebug(\"This flow/stream triggered a drop rule\");\n        FlowSetNoPacketInspectionFlag(p->flow);\n        DecodeSetNoPacketInspectionFlag(p);\n        StreamTcpDisableAppLayer(p->flow);\n        PACKET_DROP(p);\n        /* return the segments to the pool */\n        StreamTcpSessionPktFree(p);\n        SCReturnInt(0);\n    }\n\n    if (ssn == NULL || ssn->state == TCP_NONE) {\n        if (StreamTcpPacketStateNone(tv, p, stt, ssn, &stt->pseudo_queue) == -1) {\n            goto error;\n        }\n\n        if (ssn != NULL)\n            SCLogDebug(\"ssn->alproto %\"PRIu16\"\", p->flow->alproto);\n    } else {\n        /* special case for PKT_PSEUDO_STREAM_END packets:\n         * bypass the state handling and various packet checks,\n         * we care about reassembly here. */\n        if (p->flags & PKT_PSEUDO_STREAM_END) {\n            if (PKT_IS_TOCLIENT(p)) {\n                ssn->client.last_ack = TCP_GET_ACK(p);\n                StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                        &ssn->server, p, pq);\n            } else {\n                ssn->server.last_ack = TCP_GET_ACK(p);\n                StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                        &ssn->client, p, pq);\n            }\n            /* straight to 'skip' as we already handled reassembly */\n            goto skip;\n        }\n\n        /* check if the packet is in right direction, when we missed the\n           SYN packet and picked up midstream session. */\n        if (ssn->flags & STREAMTCP_FLAG_MIDSTREAM_SYNACK)\n            StreamTcpPacketSwitchDir(ssn, p);\n\n        if (StreamTcpPacketIsKeepAlive(ssn, p) == 1) {\n            goto skip;\n        }\n        if (StreamTcpPacketIsKeepAliveACK(ssn, p) == 1) {\n            StreamTcpClearKeepAliveFlag(ssn, p);\n            goto skip;\n        }\n        StreamTcpClearKeepAliveFlag(ssn, p);\n\n        /* if packet is not a valid window update, check if it is perhaps\n         * a bad window update that we should ignore (and alert on) */\n        if (StreamTcpPacketIsFinShutdownAck(ssn, p) == 0)\n            if (StreamTcpPacketIsWindowUpdate(ssn, p) == 0)\n                if (StreamTcpPacketIsBadWindowUpdate(ssn,p))\n                    goto skip;\n\n        switch (ssn->state) {\n            case TCP_SYN_SENT:\n                if(StreamTcpPacketStateSynSent(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_SYN_RECV:\n                if(StreamTcpPacketStateSynRecv(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_ESTABLISHED:\n                if(StreamTcpPacketStateEstablished(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_FIN_WAIT1:\n                if(StreamTcpPacketStateFinWait1(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_FIN_WAIT2:\n                if(StreamTcpPacketStateFinWait2(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_CLOSING:\n                if(StreamTcpPacketStateClosing(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_CLOSE_WAIT:\n                if(StreamTcpPacketStateCloseWait(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_LAST_ACK:\n                if(StreamTcpPacketStateLastAck(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_TIME_WAIT:\n                if(StreamTcpPacketStateTimeWait(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_CLOSED:\n                /* TCP session memory is not returned to pool until timeout. */\n                SCLogDebug(\"packet received on closed state\");\n                break;\n            default:\n                SCLogDebug(\"packet received on default state\");\n                break;\n        }\n    skip:\n\n        if (ssn->state >= TCP_ESTABLISHED) {\n            p->flags |= PKT_STREAM_EST;\n        }\n    }\n\n    /* deal with a pseudo packet that is created upon receiving a RST\n     * segment. To be sure we process both sides of the connection, we\n     * inject a fake packet into the system, forcing reassembly of the\n     * opposing direction.\n     * There should be only one, but to be sure we do a while loop. */\n    if (ssn != NULL) {\n        while (stt->pseudo_queue.len > 0) {\n            SCLogDebug(\"processing pseudo packet / stream end\");\n            Packet *np = PacketDequeue(&stt->pseudo_queue);\n            if (np != NULL) {\n                /* process the opposing direction of the original packet */\n                if (PKT_IS_TOSERVER(np)) {\n                    SCLogDebug(\"pseudo packet is to server\");\n                    StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                            &ssn->client, np, NULL);\n                } else {\n                    SCLogDebug(\"pseudo packet is to client\");\n                    StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                            &ssn->server, np, NULL);\n                }\n\n                /* enqueue this packet so we inspect it in detect etc */\n                PacketEnqueue(pq, np);\n            }\n            SCLogDebug(\"processing pseudo packet / stream end done\");\n        }\n\n        /* recalc the csum on the packet if it was modified */\n        if (p->flags & PKT_STREAM_MODIFIED) {\n            ReCalculateChecksum(p);\n        }\n\n        /* check for conditions that may make us not want to log this packet */\n\n        /* streams that hit depth */\n        if ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) &&\n             (ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED))\n        {\n            /* we can call bypass callback, if enabled */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(p);\n            }\n        }\n\n        if ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) ||\n             (ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED))\n        {\n            p->flags |= PKT_STREAM_NOPCAPLOG;\n        }\n\n        /* encrypted packets */\n        if ((PKT_IS_TOSERVER(p) && (ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)) ||\n            (PKT_IS_TOCLIENT(p) && (ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)))\n        {\n            p->flags |= PKT_STREAM_NOPCAPLOG;\n        }\n\n        if (ssn->flags & STREAMTCP_FLAG_BYPASS) {\n            /* we can call bypass callback, if enabled */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(p);\n            }\n\n        /* if stream is dead and we have no detect engine at all, bypass. */\n        } else if (g_detect_disabled &&\n                (ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) &&\n                (ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) &&\n                StreamTcpBypassEnabled())\n        {\n            SCLogDebug(\"bypass as stream is dead and we have no rules\");\n            PacketBypassCallback(p);\n        }\n    }\n\n    SCReturnInt(0);\n\nerror:\n    /* make sure we don't leave packets in our pseudo queue */\n    while (stt->pseudo_queue.len > 0) {\n        Packet *np = PacketDequeue(&stt->pseudo_queue);\n        if (np != NULL) {\n            PacketEnqueue(pq, np);\n        }\n    }\n\n    /* recalc the csum on the packet if it was modified */\n    if (p->flags & PKT_STREAM_MODIFIED) {\n        ReCalculateChecksum(p);\n    }\n\n    if (StreamTcpInlineDropInvalid()) {\n        PACKET_DROP(p);\n    }\n    SCReturnInt(-1);\n}",
        "func": "int StreamTcpPacket (ThreadVars *tv, Packet *p, StreamTcpThread *stt,\n                     PacketQueue *pq)\n{\n    SCEnter();\n\n    DEBUG_ASSERT_FLOW_LOCKED(p->flow);\n\n    SCLogDebug(\"p->pcap_cnt %\"PRIu64, p->pcap_cnt);\n\n    /* assign the thread id to the flow */\n    if (unlikely(p->flow->thread_id == 0)) {\n        p->flow->thread_id = (FlowThreadId)tv->id;\n#ifdef DEBUG\n    } else if (unlikely((FlowThreadId)tv->id != p->flow->thread_id)) {\n        SCLogDebug(\"wrong thread: flow has %u, we are %d\", p->flow->thread_id, tv->id);\n#endif\n    }\n\n    TcpSession *ssn = (TcpSession *)p->flow->protoctx;\n\n    /* track TCP flags */\n    if (ssn != NULL) {\n        ssn->tcp_packet_flags |= p->tcph->th_flags;\n        if (PKT_IS_TOSERVER(p))\n            ssn->client.tcp_flags |= p->tcph->th_flags;\n        else if (PKT_IS_TOCLIENT(p))\n            ssn->server.tcp_flags |= p->tcph->th_flags;\n\n        /* check if we need to unset the ASYNC flag */\n        if (ssn->flags & STREAMTCP_FLAG_ASYNC &&\n            ssn->client.tcp_flags != 0 &&\n            ssn->server.tcp_flags != 0)\n        {\n            SCLogDebug(\"ssn %p: removing ASYNC flag as we have packets on both sides\", ssn);\n            ssn->flags &= ~STREAMTCP_FLAG_ASYNC;\n        }\n    }\n\n    /* update counters */\n    if ((p->tcph->th_flags & (TH_SYN|TH_ACK)) == (TH_SYN|TH_ACK)) {\n        StatsIncr(tv, stt->counter_tcp_synack);\n    } else if (p->tcph->th_flags & (TH_SYN)) {\n        StatsIncr(tv, stt->counter_tcp_syn);\n    }\n    if (p->tcph->th_flags & (TH_RST)) {\n        StatsIncr(tv, stt->counter_tcp_rst);\n    }\n\n    /* broken TCP http://ask.wireshark.org/questions/3183/acknowledgment-number-broken-tcp-the-acknowledge-field-is-nonzero-while-the-ack-flag-is-not-set */\n    if (!(p->tcph->th_flags & TH_ACK) && TCP_GET_ACK(p) != 0) {\n        StreamTcpSetEvent(p, STREAM_PKT_BROKEN_ACK);\n    }\n\n    /* If we are on IPS mode, and got a drop action triggered from\n     * the IP only module, or from a reassembled msg and/or from an\n     * applayer detection, then drop the rest of the packets of the\n     * same stream and avoid inspecting it any further */\n    if (StreamTcpCheckFlowDrops(p) == 1) {\n        SCLogDebug(\"This flow/stream triggered a drop rule\");\n        FlowSetNoPacketInspectionFlag(p->flow);\n        DecodeSetNoPacketInspectionFlag(p);\n        StreamTcpDisableAppLayer(p->flow);\n        PACKET_DROP(p);\n        /* return the segments to the pool */\n        StreamTcpSessionPktFree(p);\n        SCReturnInt(0);\n    }\n\n    if (ssn == NULL || ssn->state == TCP_NONE) {\n        if (StreamTcpPacketStateNone(tv, p, stt, ssn, &stt->pseudo_queue) == -1) {\n            goto error;\n        }\n\n        if (ssn != NULL)\n            SCLogDebug(\"ssn->alproto %\"PRIu16\"\", p->flow->alproto);\n    } else {\n        /* special case for PKT_PSEUDO_STREAM_END packets:\n         * bypass the state handling and various packet checks,\n         * we care about reassembly here. */\n        if (p->flags & PKT_PSEUDO_STREAM_END) {\n            if (PKT_IS_TOCLIENT(p)) {\n                ssn->client.last_ack = TCP_GET_ACK(p);\n                StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                        &ssn->server, p, pq);\n            } else {\n                ssn->server.last_ack = TCP_GET_ACK(p);\n                StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                        &ssn->client, p, pq);\n            }\n            /* straight to 'skip' as we already handled reassembly */\n            goto skip;\n        }\n\n        /* check if the packet is in right direction, when we missed the\n           SYN packet and picked up midstream session. */\n        if (ssn->flags & STREAMTCP_FLAG_MIDSTREAM_SYNACK)\n            StreamTcpPacketSwitchDir(ssn, p);\n\n        if (StreamTcpPacketIsKeepAlive(ssn, p) == 1) {\n            goto skip;\n        }\n        if (StreamTcpPacketIsKeepAliveACK(ssn, p) == 1) {\n            StreamTcpClearKeepAliveFlag(ssn, p);\n            goto skip;\n        }\n        StreamTcpClearKeepAliveFlag(ssn, p);\n\n        /* if packet is not a valid window update, check if it is perhaps\n         * a bad window update that we should ignore (and alert on) */\n        if (StreamTcpPacketIsFinShutdownAck(ssn, p) == 0)\n            if (StreamTcpPacketIsWindowUpdate(ssn, p) == 0)\n                if (StreamTcpPacketIsBadWindowUpdate(ssn,p))\n                    goto skip;\n\n        switch (ssn->state) {\n            case TCP_SYN_SENT:\n                if(StreamTcpPacketStateSynSent(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_SYN_RECV:\n                if(StreamTcpPacketStateSynRecv(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_ESTABLISHED:\n                if(StreamTcpPacketStateEstablished(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_FIN_WAIT1:\n                if(StreamTcpPacketStateFinWait1(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_FIN_WAIT2:\n                if(StreamTcpPacketStateFinWait2(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_CLOSING:\n                if(StreamTcpPacketStateClosing(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_CLOSE_WAIT:\n                if(StreamTcpPacketStateCloseWait(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_LAST_ACK:\n                if(StreamTcpPacketStateLastAck(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_TIME_WAIT:\n                if(StreamTcpPacketStateTimeWait(tv, p, stt, ssn, &stt->pseudo_queue)) {\n                    goto error;\n                }\n                break;\n            case TCP_CLOSED:\n                /* TCP session memory is not returned to pool until timeout. */\n                SCLogDebug(\"packet received on closed state\");\n                break;\n            default:\n                SCLogDebug(\"packet received on default state\");\n                break;\n        }\n    skip:\n\n        if (ssn->state >= TCP_ESTABLISHED) {\n            p->flags |= PKT_STREAM_EST;\n        }\n    }\n\n    /* deal with a pseudo packet that is created upon receiving a RST\n     * segment. To be sure we process both sides of the connection, we\n     * inject a fake packet into the system, forcing reassembly of the\n     * opposing direction.\n     * There should be only one, but to be sure we do a while loop. */\n    if (ssn != NULL) {\n        while (stt->pseudo_queue.len > 0) {\n            SCLogDebug(\"processing pseudo packet / stream end\");\n            Packet *np = PacketDequeue(&stt->pseudo_queue);\n            if (np != NULL) {\n                /* process the opposing direction of the original packet */\n                if (PKT_IS_TOSERVER(np)) {\n                    SCLogDebug(\"pseudo packet is to server\");\n                    StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                            &ssn->client, np, NULL);\n                } else {\n                    SCLogDebug(\"pseudo packet is to client\");\n                    StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn,\n                            &ssn->server, np, NULL);\n                }\n\n                /* enqueue this packet so we inspect it in detect etc */\n                PacketEnqueue(pq, np);\n            }\n            SCLogDebug(\"processing pseudo packet / stream end done\");\n        }\n\n        /* recalc the csum on the packet if it was modified */\n        if (p->flags & PKT_STREAM_MODIFIED) {\n            ReCalculateChecksum(p);\n        }\n\n        /* check for conditions that may make us not want to log this packet */\n\n        /* streams that hit depth */\n        if ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) &&\n             (ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED))\n        {\n            /* we can call bypass callback, if enabled */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(p);\n            }\n        }\n\n        if ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) ||\n             (ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED))\n        {\n            p->flags |= PKT_STREAM_NOPCAPLOG;\n        }\n\n        /* encrypted packets */\n        if ((PKT_IS_TOSERVER(p) && (ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)) ||\n            (PKT_IS_TOCLIENT(p) && (ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)))\n        {\n            p->flags |= PKT_STREAM_NOPCAPLOG;\n        }\n\n        if (ssn->flags & STREAMTCP_FLAG_BYPASS) {\n            /* we can call bypass callback, if enabled */\n            if (StreamTcpBypassEnabled()) {\n                PacketBypassCallback(p);\n            }\n\n        /* if stream is dead and we have no detect engine at all, bypass. */\n        } else if (g_detect_disabled &&\n                (ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) &&\n                (ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) &&\n                StreamTcpBypassEnabled())\n        {\n            SCLogDebug(\"bypass as stream is dead and we have no rules\");\n            PacketBypassCallback(p);\n        }\n    }\n\n    SCReturnInt(0);\n\nerror:\n    /* make sure we don't leave packets in our pseudo queue */\n    while (stt->pseudo_queue.len > 0) {\n        Packet *np = PacketDequeue(&stt->pseudo_queue);\n        if (np != NULL) {\n            PacketEnqueue(pq, np);\n        }\n    }\n\n    /* recalc the csum on the packet if it was modified */\n    if (p->flags & PKT_STREAM_MODIFIED) {\n        ReCalculateChecksum(p);\n    }\n\n    if (StreamTcpInlineDropInvalid()) {\n        /* disable payload inspection as we're dropping this packet\n         * anyway. Doesn't disable all detection, so we can still\n         * match on the stream event that was set. */\n        DecodeSetNoPayloadInspectionFlag(p);\n        PACKET_DROP(p);\n    }\n    SCReturnInt(-1);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -264,6 +264,10 @@\n     }\n \n     if (StreamTcpInlineDropInvalid()) {\n+        /* disable payload inspection as we're dropping this packet\n+         * anyway. Doesn't disable all detection, so we can still\n+         * match on the stream event that was set. */\n+        DecodeSetNoPayloadInspectionFlag(p);\n         PACKET_DROP(p);\n     }\n     SCReturnInt(-1);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        /* disable payload inspection as we're dropping this packet",
                "         * anyway. Doesn't disable all detection, so we can still",
                "         * match on the stream event that was set. */",
                "        DecodeSetNoPayloadInspectionFlag(p);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-45132",
        "func_name": "wargio/naxsi/ngx_http_naxsi_update_current_ctx_status",
        "description": "NAXSI is an open-source maintenance web application firewall (WAF) for NGINX. An issue present starting in version 1.3 and prior to version 1.6 allows someone to bypass the WAF when a malicious `X-Forwarded-For` IP matches `IgnoreIP` `IgnoreCIDR` rules. This old code was arranged to allow older NGINX versions to also support `IgnoreIP` `IgnoreCIDR` when multiple reverse proxies were present. The issue is patched in version 1.6. As a workaround, do not set any `IgnoreIP` `IgnoreCIDR` for older versions.\n",
        "git_url": "https://github.com/wargio/naxsi/commit/1b712526ed3314dd6be7e8b0259eabda63c19537",
        "commit_title": "Remove X-Forwarded-For header special processing (#103)",
        "commit_text": " * Change tests IgnoreCIDR/IgnoreIP with/without real_ip support\r * Remove X-Forwarding-For header special processing\r * Change tests IgnoreCIDR/IgnoreIP set_real_ip_from 127.0.0.1 for IPv6 (for IPv4 machine only)\r * Change tests IgnoreCIDR/IgnoreIP set_real_ip_from 127.0.0.1 and ::1/128 for IPv6",
        "func_before": "void\nngx_http_naxsi_update_current_ctx_status(ngx_http_request_ctx_t*    ctx,\n                                         ngx_http_naxsi_loc_conf_t* cf,\n                                         ngx_http_request_t*        r)\n{\n  unsigned int              i, z;\n  unsigned int              matched;\n  ngx_http_check_rule_t*    cr;\n  ngx_http_special_score_t* sc;\n\n  NX_DEBUG(_debug_custom_score, NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"XX-custom check rules\");\n\n  if (!ctx->ignore && (cf->ignore_ips || cf->ignore_cidrs)) {\n#if (NGX_HTTP_X_FORWARDED_FOR)\n#if (nginx_version < 1023000)\n    ngx_table_elt_t** h;\n    if (r->headers_in.x_forwarded_for.nelts >= 1) {\n      h = r->headers_in.x_forwarded_for.elts;\n      NX_DEBUG(_debug_whitelist_ignore,\n               NGX_LOG_DEBUG_HTTP,\n               r->connection->log,\n               0,\n               \"XX- lookup ignore X-Forwarded-For: %V\",\n               h[0]->value);\n      ngx_str_t* ip = &h[0]->value;\n      ctx->ignore   = naxsi_can_ignore_ip(ip, cf) || naxsi_can_ignore_cidr(ip, cf);\n    } else\n#else\n    ngx_table_elt_t* xff;\n    if (r->headers_in.x_forwarded_for != NULL) {\n      xff = r->headers_in.x_forwarded_for;\n      NX_DEBUG(_debug_whitelist_ignore,\n               NGX_LOG_DEBUG_HTTP,\n               r->connection->log,\n               0,\n               \"XX- lookup ignore X-Forwarded-For: %V\",\n               xff->value);\n      ngx_str_t* ip = &xff->value;\n      ctx->ignore   = naxsi_can_ignore_ip(ip, cf) || naxsi_can_ignore_cidr(ip, cf);\n    } else\n#endif\n#endif\n    {\n      ngx_str_t* ip = &r->connection->addr_text;\n      NX_DEBUG(_debug_whitelist_ignore,\n               NGX_LOG_DEBUG_HTTP,\n               r->connection->log,\n               0,\n               \"XX- lookup ignore client ip: %V\",\n               ip);\n      ctx->ignore = naxsi_can_ignore_ip(ip, cf) || naxsi_can_ignore_cidr(ip, cf);\n    }\n  }\n\n  if (cf->check_rules && ctx->special_scores) {\n    NX_DEBUG(_debug_custom_score,\n             NGX_LOG_DEBUG_HTTP,\n             r->connection->log,\n             0,\n             \"XX-we have custom check rules and CTX got special score :)\");\n\n    cr = cf->check_rules->elts;\n    sc = ctx->special_scores->elts;\n    for (z = 0; z < ctx->special_scores->nelts; z++)\n      for (i = 0; i < cf->check_rules->nelts; i++) {\n        NX_DEBUG(_debug_custom_score,\n                 NGX_LOG_DEBUG_HTTP,\n                 r->connection->log,\n                 0,\n                 \"XX- rule says :(%s:%d) vs current context:(%s:%d) (flag=%d)\",\n                 cr[i].sc_tag.data,\n                 cr[i].sc_score,\n                 sc[z].sc_tag->data,\n                 sc[z].sc_score,\n                 cr[i].cmp);\n\n        if (!ngx_strcmp(sc[z].sc_tag->data, cr[i].sc_tag.data)) {\n          NX_DEBUG(_debug_custom_score,\n                   NGX_LOG_DEBUG_HTTP,\n                   r->connection->log,\n                   0,\n                   \"XX- rule says :(%s:%d) vs current context:(%s:%d) (flag=%d)\",\n                   cr[i].sc_tag.data,\n                   cr[i].sc_score,\n                   sc[z].sc_tag->data,\n                   sc[z].sc_score,\n                   cr[i].cmp);\n\n          matched = 0;\n          // huglier than your mom :)\n          switch (cr[i].cmp) {\n            case SUP:\n              matched = sc[z].sc_score > cr[i].sc_score ? 1 : 0;\n              break;\n            case SUP_OR_EQUAL:\n              matched = sc[z].sc_score >= cr[i].sc_score ? 1 : 0;\n              break;\n            case INF:\n              matched = sc[z].sc_score < cr[i].sc_score ? 1 : 0;\n              break;\n            case INF_OR_EQUAL:\n              matched = sc[z].sc_score <= cr[i].sc_score ? 1 : 0;\n              break;\n          }\n          if (matched) {\n            NX_DEBUG(_debug_custom_score,\n                     NGX_LOG_DEBUG_HTTP,\n                     r->connection->log,\n                     0,\n                     \"XX- custom score rule triggered ..\");\n            if (cr[i].block) {\n              ctx->block = 1;\n            }\n            if (cr[i].drop) {\n              ctx->drop = 1;\n            }\n            if (cr[i].allow) {\n              ctx->allow = 1;\n            }\n            if (cr[i].log) {\n              ctx->log = 1;\n            }\n          }\n        }\n      }\n  }\n  if (ctx->ignore) {\n    ctx->block = 0;\n    ctx->drop  = 0;\n  }\n}",
        "func": "void\nngx_http_naxsi_update_current_ctx_status(ngx_http_request_ctx_t*    ctx,\n                                         ngx_http_naxsi_loc_conf_t* cf,\n                                         ngx_http_request_t*        r)\n{\n  unsigned int              i, z;\n  unsigned int              matched;\n  ngx_http_check_rule_t*    cr;\n  ngx_http_special_score_t* sc;\n\n  NX_DEBUG(_debug_custom_score, NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"XX-custom check rules\");\n\n  if (!ctx->ignore && (cf->ignore_ips || cf->ignore_cidrs)) {\n      ngx_str_t* ip = &r->connection->addr_text;\n      NX_DEBUG(_debug_whitelist_ignore,\n               NGX_LOG_DEBUG_HTTP,\n               r->connection->log,\n               0,\n               \"XX- lookup ignore client ip: %V\",\n               ip);\n      ctx->ignore = naxsi_can_ignore_ip(ip, cf) || naxsi_can_ignore_cidr(ip, cf);\n  }\n\n  if (cf->check_rules && ctx->special_scores) {\n    NX_DEBUG(_debug_custom_score,\n             NGX_LOG_DEBUG_HTTP,\n             r->connection->log,\n             0,\n             \"XX-we have custom check rules and CTX got special score :)\");\n\n    cr = cf->check_rules->elts;\n    sc = ctx->special_scores->elts;\n    for (z = 0; z < ctx->special_scores->nelts; z++)\n      for (i = 0; i < cf->check_rules->nelts; i++) {\n        NX_DEBUG(_debug_custom_score,\n                 NGX_LOG_DEBUG_HTTP,\n                 r->connection->log,\n                 0,\n                 \"XX- rule says :(%s:%d) vs current context:(%s:%d) (flag=%d)\",\n                 cr[i].sc_tag.data,\n                 cr[i].sc_score,\n                 sc[z].sc_tag->data,\n                 sc[z].sc_score,\n                 cr[i].cmp);\n\n        if (!ngx_strcmp(sc[z].sc_tag->data, cr[i].sc_tag.data)) {\n          NX_DEBUG(_debug_custom_score,\n                   NGX_LOG_DEBUG_HTTP,\n                   r->connection->log,\n                   0,\n                   \"XX- rule says :(%s:%d) vs current context:(%s:%d) (flag=%d)\",\n                   cr[i].sc_tag.data,\n                   cr[i].sc_score,\n                   sc[z].sc_tag->data,\n                   sc[z].sc_score,\n                   cr[i].cmp);\n\n          matched = 0;\n          // huglier than your mom :)\n          switch (cr[i].cmp) {\n            case SUP:\n              matched = sc[z].sc_score > cr[i].sc_score ? 1 : 0;\n              break;\n            case SUP_OR_EQUAL:\n              matched = sc[z].sc_score >= cr[i].sc_score ? 1 : 0;\n              break;\n            case INF:\n              matched = sc[z].sc_score < cr[i].sc_score ? 1 : 0;\n              break;\n            case INF_OR_EQUAL:\n              matched = sc[z].sc_score <= cr[i].sc_score ? 1 : 0;\n              break;\n          }\n          if (matched) {\n            NX_DEBUG(_debug_custom_score,\n                     NGX_LOG_DEBUG_HTTP,\n                     r->connection->log,\n                     0,\n                     \"XX- custom score rule triggered ..\");\n            if (cr[i].block) {\n              ctx->block = 1;\n            }\n            if (cr[i].drop) {\n              ctx->drop = 1;\n            }\n            if (cr[i].allow) {\n              ctx->allow = 1;\n            }\n            if (cr[i].log) {\n              ctx->log = 1;\n            }\n          }\n        }\n      }\n  }\n  if (ctx->ignore) {\n    ctx->block = 0;\n    ctx->drop  = 0;\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,36 +11,6 @@\n   NX_DEBUG(_debug_custom_score, NGX_LOG_DEBUG_HTTP, r->connection->log, 0, \"XX-custom check rules\");\n \n   if (!ctx->ignore && (cf->ignore_ips || cf->ignore_cidrs)) {\n-#if (NGX_HTTP_X_FORWARDED_FOR)\n-#if (nginx_version < 1023000)\n-    ngx_table_elt_t** h;\n-    if (r->headers_in.x_forwarded_for.nelts >= 1) {\n-      h = r->headers_in.x_forwarded_for.elts;\n-      NX_DEBUG(_debug_whitelist_ignore,\n-               NGX_LOG_DEBUG_HTTP,\n-               r->connection->log,\n-               0,\n-               \"XX- lookup ignore X-Forwarded-For: %V\",\n-               h[0]->value);\n-      ngx_str_t* ip = &h[0]->value;\n-      ctx->ignore   = naxsi_can_ignore_ip(ip, cf) || naxsi_can_ignore_cidr(ip, cf);\n-    } else\n-#else\n-    ngx_table_elt_t* xff;\n-    if (r->headers_in.x_forwarded_for != NULL) {\n-      xff = r->headers_in.x_forwarded_for;\n-      NX_DEBUG(_debug_whitelist_ignore,\n-               NGX_LOG_DEBUG_HTTP,\n-               r->connection->log,\n-               0,\n-               \"XX- lookup ignore X-Forwarded-For: %V\",\n-               xff->value);\n-      ngx_str_t* ip = &xff->value;\n-      ctx->ignore   = naxsi_can_ignore_ip(ip, cf) || naxsi_can_ignore_cidr(ip, cf);\n-    } else\n-#endif\n-#endif\n-    {\n       ngx_str_t* ip = &r->connection->addr_text;\n       NX_DEBUG(_debug_whitelist_ignore,\n                NGX_LOG_DEBUG_HTTP,\n@@ -49,7 +19,6 @@\n                \"XX- lookup ignore client ip: %V\",\n                ip);\n       ctx->ignore = naxsi_can_ignore_ip(ip, cf) || naxsi_can_ignore_cidr(ip, cf);\n-    }\n   }\n \n   if (cf->check_rules && ctx->special_scores) {",
        "diff_line_info": {
            "deleted_lines": [
                "#if (NGX_HTTP_X_FORWARDED_FOR)",
                "#if (nginx_version < 1023000)",
                "    ngx_table_elt_t** h;",
                "    if (r->headers_in.x_forwarded_for.nelts >= 1) {",
                "      h = r->headers_in.x_forwarded_for.elts;",
                "      NX_DEBUG(_debug_whitelist_ignore,",
                "               NGX_LOG_DEBUG_HTTP,",
                "               r->connection->log,",
                "               0,",
                "               \"XX- lookup ignore X-Forwarded-For: %V\",",
                "               h[0]->value);",
                "      ngx_str_t* ip = &h[0]->value;",
                "      ctx->ignore   = naxsi_can_ignore_ip(ip, cf) || naxsi_can_ignore_cidr(ip, cf);",
                "    } else",
                "#else",
                "    ngx_table_elt_t* xff;",
                "    if (r->headers_in.x_forwarded_for != NULL) {",
                "      xff = r->headers_in.x_forwarded_for;",
                "      NX_DEBUG(_debug_whitelist_ignore,",
                "               NGX_LOG_DEBUG_HTTP,",
                "               r->connection->log,",
                "               0,",
                "               \"XX- lookup ignore X-Forwarded-For: %V\",",
                "               xff->value);",
                "      ngx_str_t* ip = &xff->value;",
                "      ctx->ignore   = naxsi_can_ignore_ip(ip, cf) || naxsi_can_ignore_cidr(ip, cf);",
                "    } else",
                "#endif",
                "#endif",
                "    {",
                "    }"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2020-15174",
        "func_name": "electron/WebContents::OpenURLFromTab",
        "description": "In Electron before versions 11.0.0-beta.1, 10.0.1, 9.3.0 or 8.5.1 the `will-navigate` event that apps use to prevent navigations to unexpected destinations as per our security recommendations can be bypassed when a sub-frame performs a top-frame navigation across sites. The issue is patched in versions 11.0.0-beta.1, 10.0.1, 9.3.0 or 8.5.1 As a workaround sandbox all your iframes using the sandbox attribute. This will prevent them creating top-frame navigations and is good practice anyway.",
        "git_url": "https://github.com/electron/electron/commit/18613925610ba319da7f497b6deed85ad712c59b",
        "commit_title": "refactor: wire will-navigate up to a navigation throttle instead of OpenURL (#25108)",
        "commit_text": " * refactor: wire will-navigate up to a navigation throttle instead of OpenURL (#25065)\r \r * refactor: wire will-navigate up to a navigation throttle instead of OpenURL\r \r * spec: add test for x-site _top navigation\r \r * chore: old code be old",
        "func_before": "content::WebContents* WebContents::OpenURLFromTab(\n    content::WebContents* source,\n    const content::OpenURLParams& params) {\n  if (params.disposition != WindowOpenDisposition::CURRENT_TAB) {\n    Emit(\"-new-window\", params.url, \"\", params.disposition, \"\", params.referrer,\n         params.post_data);\n    return nullptr;\n  }\n\n  // Give user a chance to cancel navigation.\n  if (Emit(\"will-navigate\", params.url))\n    return nullptr;\n\n  // Don't load the URL if the web contents was marked as destroyed from a\n  // will-navigate event listener\n  if (IsDestroyed())\n    return nullptr;\n\n  return CommonWebContentsDelegate::OpenURLFromTab(source, params);\n}",
        "func": "content::WebContents* WebContents::OpenURLFromTab(\n    content::WebContents* source,\n    const content::OpenURLParams& params) {\n  if (params.disposition != WindowOpenDisposition::CURRENT_TAB) {\n    Emit(\"-new-window\", params.url, \"\", params.disposition, \"\", params.referrer,\n         params.post_data);\n    return nullptr;\n  }\n\n  if (IsDestroyed())\n    return nullptr;\n\n  return CommonWebContentsDelegate::OpenURLFromTab(source, params);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,12 +7,6 @@\n     return nullptr;\n   }\n \n-  // Give user a chance to cancel navigation.\n-  if (Emit(\"will-navigate\", params.url))\n-    return nullptr;\n-\n-  // Don't load the URL if the web contents was marked as destroyed from a\n-  // will-navigate event listener\n   if (IsDestroyed())\n     return nullptr;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "  // Give user a chance to cancel navigation.",
                "  if (Emit(\"will-navigate\", params.url))",
                "    return nullptr;",
                "",
                "  // Don't load the URL if the web contents was marked as destroyed from a",
                "  // will-navigate event listener"
            ],
            "added_lines": []
        }
    }
]