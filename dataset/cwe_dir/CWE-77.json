[
    {
        "cve_id": "CVE-2019-14745",
        "func_name": "radareorg/radare2/bin_symbols",
        "description": "In radare2 before 3.7.0, a command injection vulnerability exists in bin_symbols() in libr/core/cbin.c. By using a crafted executable file, it's possible to execute arbitrary shell commands with the permissions of the victim. This vulnerability is due to improper handling of symbol names embedded in executables.",
        "git_url": "https://github.com/radareorg/radare2/commit/f0c6dfa7a3eaad6a4a684ebfac0b2d282266adf9",
        "commit_title": "bin_symbols: Add quoting",
        "commit_text": "",
        "func_before": "static int bin_symbols(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, bool exponly, const char *args) {\n\tRBinInfo *info = r_bin_get_info (r->bin);\n\tRList *entries = r_bin_get_entries (r->bin);\n\tRBinSymbol *symbol;\n\tRBinAddr *entry;\n\tRListIter *iter;\n\tbool firstexp = true;\n\tbool printHere = false;\n\tint i = 0, lastfs = 's';\n\tbool bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tif (!info) {\n\t\treturn 0;\n\t}\n\n\tif (args && *args == '.') {\n\t\tprintHere = true;\n\t}\n\n\tbool is_arm = info && info->arch && !strncmp (info->arch, \"arm\", 3);\n\tconst char *lang = bin_demangle ? r_config_get (r->config, \"bin.lang\") : NULL;\n\n\tRList *symbols = r_bin_get_symbols (r->bin);\n\tr_spaces_push (&r->anal->meta_spaces, \"bin\");\n\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"[\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, R_FLAGS_FS_SYMBOLS);\n\t} else if (!at && exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs exports\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Exports]\\n\");\n\t\t}\n\t} else if (!at && !exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs symbols\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Symbols]\\n\");\n\t\t}\n\t}\n\tif (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"Num Paddr      Vaddr      Bind     Type Size Name\\n\");\n\t}\n\n\n\tsize_t count = 0;\n\tr_list_foreach (symbols, iter, symbol) {\n\t\tif (!symbol->name) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *r_symbol_name = r_str_escape_utf8 (symbol->name, false, true);\n\t\tut64 addr = compute_addr (r->bin, symbol->paddr, symbol->vaddr, va);\n\t\tint len = symbol->size ? symbol->size : 32;\n\t\tSymName sn = {0};\n\n\t\tif (exponly && !isAnExport (symbol)) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (name && strcmp (r_symbol_name, name)) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (at && (!symbol->size || !is_in_range (at, addr, symbol->size))) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((printHere && !is_in_range (r->offset, symbol->paddr, len))\n\t\t\t\t&& (printHere && !is_in_range (r->offset, addr, len))) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tcount ++;\n\t\tsnInit (r, &sn, symbol, lang);\n\n\t\tif (IS_MODE_SET (mode) && (is_section_symbol (symbol) || is_file_symbol (symbol))) {\n\t\t\t/*\n\t\t\t * Skip section symbols because they will have their own flag.\n\t\t\t * Skip also file symbols because not useful for now.\n\t\t\t */\n\t\t} else if (IS_MODE_SET (mode) && is_special_symbol (symbol)) {\n\t\t\tif (is_arm) {\n\t\t\t\thandle_arm_special_symbol (r, symbol, va);\n\t\t\t}\n\t\t} else if (IS_MODE_SET (mode)) {\n\t\t\t// TODO: provide separate API in RBinPlugin to let plugins handle anal hints/metadata\n\t\t\tif (is_arm) {\n\t\t\t\thandle_arm_symbol (r, symbol, info, va);\n\t\t\t}\n\t\t\tselect_flag_space (r, symbol);\n\t\t\t/* If that's a Classed symbol (method or so) */\n\t\t\tif (sn.classname) {\n\t\t\t\tRFlagItem *fi = r_flag_get (r->flags, sn.methflag);\n\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\tchar *prname = r_str_newf (\"%s.%s\", r->bin->prefix, sn.methflag);\n\t\t\t\t\tr_name_filter (sn.methflag, -1);\n\t\t\t\t\tfree (sn.methflag);\n\t\t\t\t\tsn.methflag = prname;\n\t\t\t\t}\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, sn.methname);\n\t\t\t\t\tif ((fi->offset - r->flags->base) == addr) {\n\t\t\t\t//\t\tchar *comment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\t\tr_flag_unset (r->flags, fi);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfi = r_flag_set (r->flags, sn.methflag, addr, symbol->size);\n\t\t\t\t\tchar *comment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\tif (comment) {\n\t\t\t\t\t\tr_flag_item_set_comment (fi, comment);\n\t\t\t\t\t\tR_FREE (comment);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst char *n = sn.demname ? sn.demname : sn.name;\n\t\t\t\tconst char *fn = sn.demflag ? sn.demflag : sn.nameflag;\n\t\t\t\tchar *fnp = (r->bin->prefix) ?\n\t\t\t\t\tr_str_newf (\"%s.%s\", r->bin->prefix, fn):\n\t\t\t\t\tstrdup (fn);\n\t\t\t\tRFlagItem *fi = r_flag_set (r->flags, fnp, addr, symbol->size);\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, n);\n\t\t\t\t\tfi->demangled = (bool)(size_t)sn.demname;\n\t\t\t\t} else {\n\t\t\t\t\tif (fn) {\n\t\t\t\t\t\teprintf (\"[Warning] Can't find flag (%s)\\n\", fn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (fnp);\n\t\t\t}\n\t\t\tif (sn.demname) {\n\t\t\t\tr_meta_add (r->anal, R_META_TYPE_COMMENT,\n\t\t\t\t\taddr, symbol->size, sn.demname);\n\t\t\t}\n\t\t\tr_flag_space_pop (r->flags);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tchar *str = r_str_escape_utf8_for_json (r_symbol_name, -1);\n\t\t\t// str = r_str_replace (str, \"\\\"\", \"\\\\\\\"\", 1);\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"demname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"flagname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"ordinal\\\":%d,\"\n\t\t\t\t\"\\\"bind\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"size\\\":%d,\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d\"}\",\n\t\t\t\t((exponly && firstexp) || printHere) ? \"\" : (iter->p ? \",\" : \"\"),\n\t\t\t\tstr,\n\t\t\t\tsn.demname? sn.demname: \"\",\n\t\t\t\tsn.nameflag,\n\t\t\t\tsymbol->ordinal,\n\t\t\t\tsymbol->bind,\n\t\t\t\t(int)symbol->size,\n\t\t\t\tsymbol->type,\n\t\t\t\t(ut64)addr, (ut64)symbol->paddr);\n\t\t\tfree (str);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" %d %s\\n\",\n\t\t\t\taddr, (int)symbol->size, name);\n\t\t} else if (IS_MODE_SIMPLEST (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tr_cons_printf (\"%s\\n\", name);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\t/* Skip special symbols because we do not flag them and\n\t\t\t * they shouldn't be printed in the rad format either */\n\t\t\tif (!is_special_symbol (symbol)) {\n\t\t\t\tRBinFile *binfile;\n\t\t\t\tRBinPlugin *plugin;\n\t\t\t\tchar *name = strdup (sn.demname? sn.demname: r_symbol_name);\n\t\t\t\tr_name_filter (name, -1);\n\t\t\t\tif (!strncmp (name, \"imp.\", 4)) {\n\t\t\t\t\tif (lastfs != 'i') {\n\t\t\t\t\t\tr_cons_printf (\"fs imports\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tlastfs = 'i';\n\t\t\t\t} else {\n\t\t\t\t\tif (lastfs != 's') {\n\t\t\t\t\t\tr_cons_printf (\"fs %s\\n\",\n\t\t\t\t\t\t\texponly? \"exports\": \"symbols\");\n\t\t\t\t\t}\n\t\t\t\t\tlastfs = 's';\n\t\t\t\t}\n\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\tr_cons_printf (\"f %s.sym.%s %u 0x%08\" PFMT64x \"\\n\",\n\t\t\t\t\t\tr->bin->prefix, r_bin_symbol_name (symbol), symbol->size, addr);\n\t\t\t\t} else {\n\t\t\t\t\tif (*name) {\n\t\t\t\t\t\tr_cons_printf (\"f sym.%s %u 0x%08\" PFMT64x \"\\n\",\n\t\t\t\t\t\t\tr_bin_symbol_name (symbol), symbol->size, addr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// we don't want unnamed symbol flags\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbinfile = r_bin_cur (r->bin);\n\t\t\t\tplugin = r_bin_file_cur_plugin (binfile);\n\t\t\t\tif (plugin && plugin->name) {\n\t\t\t\t\tif (r_str_startswith (plugin->name, \"pe\")) {\n\t\t\t\t\t\tchar *module = strdup (r_symbol_name);\n\t\t\t\t\t\tchar *p = strstr (module, \".dll_\");\n\t\t\t\t\t\tif (p && strstr (module, \"imp.\")) {\n\t\t\t\t\t\t\tconst char *symname = p + 5;\n\t\t\t\t\t\t\t*p = 0;\n\t\t\t\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s.%s\\n\",\n\t\t\t\t\t\t\t\t\tmodule, symbol->ordinal, r->bin->prefix, symname);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s\\n\",\n\t\t\t\t\t\t\t\t\tmodule, symbol->ordinal, symname);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (module);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *bind = symbol->bind? symbol->bind: \"NONE\";\n\t\t\tconst char *type = symbol->type? symbol->type: \"NONE\";\n\t\t\tconst char *name = r_str_get (sn.demname? sn.demname: r_symbol_name);\n\t\t\t// const char *fwd = r_str_get (symbol->forwarder);\n\t\t\tr_cons_printf (\"%03u\", symbol->ordinal);\n\t\t\tif (symbol->paddr == UT64_MAX) {\n\t\t\t\tr_cons_printf (\" ----------\");\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, symbol->paddr);\n\t\t\t}\n\t\t\tr_cons_printf (\" 0x%08\"PFMT64x\" %6s %6s %4d%s%s\\n\",\n\t\t\t               addr, bind, type, symbol->size, *name? \" \": \"\", name);\n\t\t}\n\t\tsnFini (&sn);\n\t\ti++;\n\t\tfree (r_symbol_name);\n\t\tif (exponly && firstexp) {\n\t\t\tfirstexp = false;\n\t\t}\n\t\tif (printHere) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (count == 0 && IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"{}\");\n\t}\n\n\n\t//handle thumb and arm for entry point since they are not present in symbols\n\tif (is_arm) {\n\t\tr_list_foreach (entries, iter, entry) {\n\t\t\tif (IS_MODE_SET (mode)) {\n\t\t\t\thandle_arm_entry (r, entry, info, va);\n\t\t\t}\n\t\t}\n\t}\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"]\");\n\t}\n\n\tr_spaces_pop (&r->anal->meta_spaces);\n\treturn true;\n}",
        "func": "static int bin_symbols(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, bool exponly, const char *args) {\n\tRBinInfo *info = r_bin_get_info (r->bin);\n\tRList *entries = r_bin_get_entries (r->bin);\n\tRBinSymbol *symbol;\n\tRBinAddr *entry;\n\tRListIter *iter;\n\tbool firstexp = true;\n\tbool printHere = false;\n\tint i = 0, lastfs = 's';\n\tbool bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tif (!info) {\n\t\treturn 0;\n\t}\n\n\tif (args && *args == '.') {\n\t\tprintHere = true;\n\t}\n\n\tbool is_arm = info && info->arch && !strncmp (info->arch, \"arm\", 3);\n\tconst char *lang = bin_demangle ? r_config_get (r->config, \"bin.lang\") : NULL;\n\n\tRList *symbols = r_bin_get_symbols (r->bin);\n\tr_spaces_push (&r->anal->meta_spaces, \"bin\");\n\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"[\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, R_FLAGS_FS_SYMBOLS);\n\t} else if (!at && exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs exports\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Exports]\\n\");\n\t\t}\n\t} else if (!at && !exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs symbols\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Symbols]\\n\");\n\t\t}\n\t}\n\tif (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"Num Paddr      Vaddr      Bind     Type Size Name\\n\");\n\t}\n\n\n\tsize_t count = 0;\n\tr_list_foreach (symbols, iter, symbol) {\n\t\tif (!symbol->name) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *r_symbol_name = r_str_escape_utf8 (symbol->name, false, true);\n\t\tut64 addr = compute_addr (r->bin, symbol->paddr, symbol->vaddr, va);\n\t\tint len = symbol->size ? symbol->size : 32;\n\t\tSymName sn = {0};\n\n\t\tif (exponly && !isAnExport (symbol)) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (name && strcmp (r_symbol_name, name)) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (at && (!symbol->size || !is_in_range (at, addr, symbol->size))) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((printHere && !is_in_range (r->offset, symbol->paddr, len))\n\t\t\t\t&& (printHere && !is_in_range (r->offset, addr, len))) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tcount ++;\n\t\tsnInit (r, &sn, symbol, lang);\n\n\t\tif (IS_MODE_SET (mode) && (is_section_symbol (symbol) || is_file_symbol (symbol))) {\n\t\t\t/*\n\t\t\t * Skip section symbols because they will have their own flag.\n\t\t\t * Skip also file symbols because not useful for now.\n\t\t\t */\n\t\t} else if (IS_MODE_SET (mode) && is_special_symbol (symbol)) {\n\t\t\tif (is_arm) {\n\t\t\t\thandle_arm_special_symbol (r, symbol, va);\n\t\t\t}\n\t\t} else if (IS_MODE_SET (mode)) {\n\t\t\t// TODO: provide separate API in RBinPlugin to let plugins handle anal hints/metadata\n\t\t\tif (is_arm) {\n\t\t\t\thandle_arm_symbol (r, symbol, info, va);\n\t\t\t}\n\t\t\tselect_flag_space (r, symbol);\n\t\t\t/* If that's a Classed symbol (method or so) */\n\t\t\tif (sn.classname) {\n\t\t\t\tRFlagItem *fi = r_flag_get (r->flags, sn.methflag);\n\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\tchar *prname = r_str_newf (\"%s.%s\", r->bin->prefix, sn.methflag);\n\t\t\t\t\tr_name_filter (sn.methflag, -1);\n\t\t\t\t\tfree (sn.methflag);\n\t\t\t\t\tsn.methflag = prname;\n\t\t\t\t}\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, sn.methname);\n\t\t\t\t\tif ((fi->offset - r->flags->base) == addr) {\n\t\t\t\t//\t\tchar *comment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\t\tr_flag_unset (r->flags, fi);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfi = r_flag_set (r->flags, sn.methflag, addr, symbol->size);\n\t\t\t\t\tchar *comment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\tif (comment) {\n\t\t\t\t\t\tr_flag_item_set_comment (fi, comment);\n\t\t\t\t\t\tR_FREE (comment);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst char *n = sn.demname ? sn.demname : sn.name;\n\t\t\t\tconst char *fn = sn.demflag ? sn.demflag : sn.nameflag;\n\t\t\t\tchar *fnp = (r->bin->prefix) ?\n\t\t\t\t\tr_str_newf (\"%s.%s\", r->bin->prefix, fn):\n\t\t\t\t\tstrdup (fn);\n\t\t\t\tRFlagItem *fi = r_flag_set (r->flags, fnp, addr, symbol->size);\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, n);\n\t\t\t\t\tfi->demangled = (bool)(size_t)sn.demname;\n\t\t\t\t} else {\n\t\t\t\t\tif (fn) {\n\t\t\t\t\t\teprintf (\"[Warning] Can't find flag (%s)\\n\", fn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (fnp);\n\t\t\t}\n\t\t\tif (sn.demname) {\n\t\t\t\tr_meta_add (r->anal, R_META_TYPE_COMMENT,\n\t\t\t\t\taddr, symbol->size, sn.demname);\n\t\t\t}\n\t\t\tr_flag_space_pop (r->flags);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tchar *str = r_str_escape_utf8_for_json (r_symbol_name, -1);\n\t\t\t// str = r_str_replace (str, \"\\\"\", \"\\\\\\\"\", 1);\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"demname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"flagname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"ordinal\\\":%d,\"\n\t\t\t\t\"\\\"bind\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"size\\\":%d,\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d\"}\",\n\t\t\t\t((exponly && firstexp) || printHere) ? \"\" : (iter->p ? \",\" : \"\"),\n\t\t\t\tstr,\n\t\t\t\tsn.demname? sn.demname: \"\",\n\t\t\t\tsn.nameflag,\n\t\t\t\tsymbol->ordinal,\n\t\t\t\tsymbol->bind,\n\t\t\t\t(int)symbol->size,\n\t\t\t\tsymbol->type,\n\t\t\t\t(ut64)addr, (ut64)symbol->paddr);\n\t\t\tfree (str);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" %d %s\\n\",\n\t\t\t\taddr, (int)symbol->size, name);\n\t\t} else if (IS_MODE_SIMPLEST (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tr_cons_printf (\"%s\\n\", name);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\t/* Skip special symbols because we do not flag them and\n\t\t\t * they shouldn't be printed in the rad format either */\n\t\t\tif (!is_special_symbol (symbol)) {\n\t\t\t\tRBinFile *binfile;\n\t\t\t\tRBinPlugin *plugin;\n\t\t\t\tchar *name = strdup (sn.demname? sn.demname: r_symbol_name);\n\t\t\t\tr_name_filter (name, -1);\n\t\t\t\tif (!strncmp (name, \"imp.\", 4)) {\n\t\t\t\t\tif (lastfs != 'i') {\n\t\t\t\t\t\tr_cons_printf (\"fs imports\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tlastfs = 'i';\n\t\t\t\t} else {\n\t\t\t\t\tif (lastfs != 's') {\n\t\t\t\t\t\tr_cons_printf (\"fs %s\\n\",\n\t\t\t\t\t\t\texponly? \"exports\": \"symbols\");\n\t\t\t\t\t}\n\t\t\t\t\tlastfs = 's';\n\t\t\t\t}\n\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\tr_cons_printf (\"\\\"f %s.sym.%s %u 0x%08\" PFMT64x \"\\\"\\n\",\n\t\t\t\t\t\tr->bin->prefix, r_bin_symbol_name (symbol), symbol->size, addr);\n\t\t\t\t} else {\n\t\t\t\t\tif (*name) {\n\t\t\t\t\t\tr_cons_printf (\"\\\"f sym.%s %u 0x%08\" PFMT64x \"\\\"\\n\",\n\t\t\t\t\t\t\tr_bin_symbol_name (symbol), symbol->size, addr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// we don't want unnamed symbol flags\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbinfile = r_bin_cur (r->bin);\n\t\t\t\tplugin = r_bin_file_cur_plugin (binfile);\n\t\t\t\tif (plugin && plugin->name) {\n\t\t\t\t\tif (r_str_startswith (plugin->name, \"pe\")) {\n\t\t\t\t\t\tchar *module = strdup (r_symbol_name);\n\t\t\t\t\t\tchar *p = strstr (module, \".dll_\");\n\t\t\t\t\t\tif (p && strstr (module, \"imp.\")) {\n\t\t\t\t\t\t\tconst char *symname = p + 5;\n\t\t\t\t\t\t\t*p = 0;\n\t\t\t\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s.%s\\n\",\n\t\t\t\t\t\t\t\t\tmodule, symbol->ordinal, r->bin->prefix, symname);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s\\n\",\n\t\t\t\t\t\t\t\t\tmodule, symbol->ordinal, symname);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (module);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *bind = symbol->bind? symbol->bind: \"NONE\";\n\t\t\tconst char *type = symbol->type? symbol->type: \"NONE\";\n\t\t\tconst char *name = r_str_get (sn.demname? sn.demname: r_symbol_name);\n\t\t\t// const char *fwd = r_str_get (symbol->forwarder);\n\t\t\tr_cons_printf (\"%03u\", symbol->ordinal);\n\t\t\tif (symbol->paddr == UT64_MAX) {\n\t\t\t\tr_cons_printf (\" ----------\");\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, symbol->paddr);\n\t\t\t}\n\t\t\tr_cons_printf (\" 0x%08\"PFMT64x\" %6s %6s %4d%s%s\\n\",\n\t\t\t               addr, bind, type, symbol->size, *name? \" \": \"\", name);\n\t\t}\n\t\tsnFini (&sn);\n\t\ti++;\n\t\tfree (r_symbol_name);\n\t\tif (exponly && firstexp) {\n\t\t\tfirstexp = false;\n\t\t}\n\t\tif (printHere) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (count == 0 && IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"{}\");\n\t}\n\n\n\t//handle thumb and arm for entry point since they are not present in symbols\n\tif (is_arm) {\n\t\tr_list_foreach (entries, iter, entry) {\n\t\t\tif (IS_MODE_SET (mode)) {\n\t\t\t\thandle_arm_entry (r, entry, info, va);\n\t\t\t}\n\t\t}\n\t}\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"]\");\n\t}\n\n\tr_spaces_pop (&r->anal->meta_spaces);\n\treturn true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -184,11 +184,11 @@\n \t\t\t\t\tlastfs = 's';\n \t\t\t\t}\n \t\t\t\tif (r->bin->prefix) {\n-\t\t\t\t\tr_cons_printf (\"f %s.sym.%s %u 0x%08\" PFMT64x \"\\n\",\n+\t\t\t\t\tr_cons_printf (\"\\\"f %s.sym.%s %u 0x%08\" PFMT64x \"\\\"\\n\",\n \t\t\t\t\t\tr->bin->prefix, r_bin_symbol_name (symbol), symbol->size, addr);\n \t\t\t\t} else {\n \t\t\t\t\tif (*name) {\n-\t\t\t\t\t\tr_cons_printf (\"f sym.%s %u 0x%08\" PFMT64x \"\\n\",\n+\t\t\t\t\t\tr_cons_printf (\"\\\"f sym.%s %u 0x%08\" PFMT64x \"\\\"\\n\",\n \t\t\t\t\t\t\tr_bin_symbol_name (symbol), symbol->size, addr);\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// we don't want unnamed symbol flags",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t\tr_cons_printf (\"f %s.sym.%s %u 0x%08\" PFMT64x \"\\n\",",
                "\t\t\t\t\t\tr_cons_printf (\"f sym.%s %u 0x%08\" PFMT64x \"\\n\","
            ],
            "added_lines": [
                "\t\t\t\t\tr_cons_printf (\"\\\"f %s.sym.%s %u 0x%08\" PFMT64x \"\\\"\\n\",",
                "\t\t\t\t\t\tr_cons_printf (\"\\\"f sym.%s %u 0x%08\" PFMT64x \"\\\"\\n\","
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3008",
        "func_name": "syoyo/tinygltf/SerializeGltfSampler",
        "description": "The tinygltf library uses the C library function wordexp() to perform file path expansion on untrusted paths that are provided from the input file. This function allows for command injection by using backticks. An attacker could craft an untrusted path input that would result in a path expansion. We recommend upgrading to 2.6.0 or past commit 52ff00a38447f06a17eab1caa2cf0730a119c751",
        "git_url": "https://github.com/syoyo/tinygltf/commit/52ff00a38447f06a17eab1caa2cf0730a119c751",
        "commit_title": "Do not expand file path since its not necessary for glTF asset path(URI) and for security reason(`wordexp`).",
        "commit_text": "",
        "func_before": "static void SerializeGltfSampler(Sampler &sampler, json &o) {\n  if (sampler.magFilter != -1) {\n    SerializeNumberProperty(\"magFilter\", sampler.magFilter, o);\n  }\n  if (sampler.minFilter != -1) {\n    SerializeNumberProperty(\"minFilter\", sampler.minFilter, o);\n  }\n  //SerializeNumberProperty(\"wrapR\", sampler.wrapR, o);\n  SerializeNumberProperty(\"wrapS\", sampler.wrapS, o);\n  SerializeNumberProperty(\"wrapT\", sampler.wrapT, o);\n\n  if (sampler.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", sampler.extras, o);\n  }\n}",
        "func": "static void SerializeGltfSampler(Sampler &sampler, json &o) {\n  if (sampler.magFilter != -1) {\n    SerializeNumberProperty(\"magFilter\", sampler.magFilter, o);\n  }\n  if (sampler.minFilter != -1) {\n    SerializeNumberProperty(\"minFilter\", sampler.minFilter, o);\n  }\n  // SerializeNumberProperty(\"wrapR\", sampler.wrapR, o);\n  SerializeNumberProperty(\"wrapS\", sampler.wrapS, o);\n  SerializeNumberProperty(\"wrapT\", sampler.wrapT, o);\n\n  if (sampler.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", sampler.extras, o);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n   if (sampler.minFilter != -1) {\n     SerializeNumberProperty(\"minFilter\", sampler.minFilter, o);\n   }\n-  //SerializeNumberProperty(\"wrapR\", sampler.wrapR, o);\n+  // SerializeNumberProperty(\"wrapR\", sampler.wrapR, o);\n   SerializeNumberProperty(\"wrapS\", sampler.wrapS, o);\n   SerializeNumberProperty(\"wrapT\", sampler.wrapT, o);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "  //SerializeNumberProperty(\"wrapR\", sampler.wrapR, o);"
            ],
            "added_lines": [
                "  // SerializeNumberProperty(\"wrapR\", sampler.wrapR, o);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3008",
        "func_name": "syoyo/tinygltf/WriteBinaryGltfStream",
        "description": "The tinygltf library uses the C library function wordexp() to perform file path expansion on untrusted paths that are provided from the input file. This function allows for command injection by using backticks. An attacker could craft an untrusted path input that would result in a path expansion. We recommend upgrading to 2.6.0 or past commit 52ff00a38447f06a17eab1caa2cf0730a119c751",
        "git_url": "https://github.com/syoyo/tinygltf/commit/52ff00a38447f06a17eab1caa2cf0730a119c751",
        "commit_title": "Do not expand file path since its not necessary for glTF asset path(URI) and for security reason(`wordexp`).",
        "commit_text": "",
        "func_before": "static void WriteBinaryGltfStream(std::ostream &stream,\n                                  const std::string &content,\n                                  const std::vector<unsigned char> &binBuffer) {\n  const std::string header = \"glTF\";\n  const int version = 2;\n\n  const uint32_t content_size = uint32_t(content.size());\n  const uint32_t binBuffer_size = uint32_t(binBuffer.size());\n  // determine number of padding bytes required to ensure 4 byte alignment\n  const uint32_t content_padding_size = content_size % 4 == 0 ? 0 : 4 - content_size % 4;\n  const uint32_t bin_padding_size = binBuffer_size % 4 == 0 ? 0 : 4 - binBuffer_size % 4;\n\n  // 12 bytes for header, JSON content length, 8 bytes for JSON chunk info.\n  // Chunk data must be located at 4-byte boundary, which may require padding\n  const uint32_t length =\n      12 + 8 + content_size + content_padding_size +\n      (binBuffer_size ? (8 + binBuffer_size + bin_padding_size) : 0);\n\n  stream.write(header.c_str(), std::streamsize(header.size()));\n  stream.write(reinterpret_cast<const char *>(&version), sizeof(version));\n  stream.write(reinterpret_cast<const char *>(&length), sizeof(length));\n\n  // JSON chunk info, then JSON data\n  const uint32_t model_length = uint32_t(content.size()) + content_padding_size;\n  const uint32_t model_format = 0x4E4F534A;\n  stream.write(reinterpret_cast<const char *>(&model_length),\n               sizeof(model_length));\n  stream.write(reinterpret_cast<const char *>(&model_format),\n               sizeof(model_format));\n  stream.write(content.c_str(), std::streamsize(content.size()));\n\n  // Chunk must be multiplies of 4, so pad with spaces\n  if (content_padding_size > 0) {\n    const std::string padding = std::string(size_t(content_padding_size), ' ');\n    stream.write(padding.c_str(), std::streamsize(padding.size()));\n  }\n  if (binBuffer.size() > 0) {\n    // BIN chunk info, then BIN data\n    const uint32_t bin_length = uint32_t(binBuffer.size()) + bin_padding_size;\n    const uint32_t bin_format = 0x004e4942;\n    stream.write(reinterpret_cast<const char *>(&bin_length),\n                 sizeof(bin_length));\n    stream.write(reinterpret_cast<const char *>(&bin_format),\n                 sizeof(bin_format));\n    stream.write(reinterpret_cast<const char *>(binBuffer.data()),\n                 std::streamsize(binBuffer.size()));\n    // Chunksize must be multiplies of 4, so pad with zeroes\n    if (bin_padding_size > 0) {\n      const std::vector<unsigned char> padding =\n          std::vector<unsigned char>(size_t(bin_padding_size), 0);\n      stream.write(reinterpret_cast<const char *>(padding.data()),\n                   std::streamsize(padding.size()));\n    }\n  }\n}",
        "func": "static void WriteBinaryGltfStream(std::ostream &stream,\n                                  const std::string &content,\n                                  const std::vector<unsigned char> &binBuffer) {\n  const std::string header = \"glTF\";\n  const int version = 2;\n\n  const uint32_t content_size = uint32_t(content.size());\n  const uint32_t binBuffer_size = uint32_t(binBuffer.size());\n  // determine number of padding bytes required to ensure 4 byte alignment\n  const uint32_t content_padding_size =\n      content_size % 4 == 0 ? 0 : 4 - content_size % 4;\n  const uint32_t bin_padding_size =\n      binBuffer_size % 4 == 0 ? 0 : 4 - binBuffer_size % 4;\n\n  // 12 bytes for header, JSON content length, 8 bytes for JSON chunk info.\n  // Chunk data must be located at 4-byte boundary, which may require padding\n  const uint32_t length =\n      12 + 8 + content_size + content_padding_size +\n      (binBuffer_size ? (8 + binBuffer_size + bin_padding_size) : 0);\n\n  stream.write(header.c_str(), std::streamsize(header.size()));\n  stream.write(reinterpret_cast<const char *>(&version), sizeof(version));\n  stream.write(reinterpret_cast<const char *>(&length), sizeof(length));\n\n  // JSON chunk info, then JSON data\n  const uint32_t model_length = uint32_t(content.size()) + content_padding_size;\n  const uint32_t model_format = 0x4E4F534A;\n  stream.write(reinterpret_cast<const char *>(&model_length),\n               sizeof(model_length));\n  stream.write(reinterpret_cast<const char *>(&model_format),\n               sizeof(model_format));\n  stream.write(content.c_str(), std::streamsize(content.size()));\n\n  // Chunk must be multiplies of 4, so pad with spaces\n  if (content_padding_size > 0) {\n    const std::string padding = std::string(size_t(content_padding_size), ' ');\n    stream.write(padding.c_str(), std::streamsize(padding.size()));\n  }\n  if (binBuffer.size() > 0) {\n    // BIN chunk info, then BIN data\n    const uint32_t bin_length = uint32_t(binBuffer.size()) + bin_padding_size;\n    const uint32_t bin_format = 0x004e4942;\n    stream.write(reinterpret_cast<const char *>(&bin_length),\n                 sizeof(bin_length));\n    stream.write(reinterpret_cast<const char *>(&bin_format),\n                 sizeof(bin_format));\n    stream.write(reinterpret_cast<const char *>(binBuffer.data()),\n                 std::streamsize(binBuffer.size()));\n    // Chunksize must be multiplies of 4, so pad with zeroes\n    if (bin_padding_size > 0) {\n      const std::vector<unsigned char> padding =\n          std::vector<unsigned char>(size_t(bin_padding_size), 0);\n      stream.write(reinterpret_cast<const char *>(padding.data()),\n                   std::streamsize(padding.size()));\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,8 +7,10 @@\n   const uint32_t content_size = uint32_t(content.size());\n   const uint32_t binBuffer_size = uint32_t(binBuffer.size());\n   // determine number of padding bytes required to ensure 4 byte alignment\n-  const uint32_t content_padding_size = content_size % 4 == 0 ? 0 : 4 - content_size % 4;\n-  const uint32_t bin_padding_size = binBuffer_size % 4 == 0 ? 0 : 4 - binBuffer_size % 4;\n+  const uint32_t content_padding_size =\n+      content_size % 4 == 0 ? 0 : 4 - content_size % 4;\n+  const uint32_t bin_padding_size =\n+      binBuffer_size % 4 == 0 ? 0 : 4 - binBuffer_size % 4;\n \n   // 12 bytes for header, JSON content length, 8 bytes for JSON chunk info.\n   // Chunk data must be located at 4-byte boundary, which may require padding",
        "diff_line_info": {
            "deleted_lines": [
                "  const uint32_t content_padding_size = content_size % 4 == 0 ? 0 : 4 - content_size % 4;",
                "  const uint32_t bin_padding_size = binBuffer_size % 4 == 0 ? 0 : 4 - binBuffer_size % 4;"
            ],
            "added_lines": [
                "  const uint32_t content_padding_size =",
                "      content_size % 4 == 0 ? 0 : 4 - content_size % 4;",
                "  const uint32_t bin_padding_size =",
                "      binBuffer_size % 4 == 0 ? 0 : 4 - binBuffer_size % 4;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3008",
        "func_name": "syoyo/tinygltf/ParseSparseAccessor",
        "description": "The tinygltf library uses the C library function wordexp() to perform file path expansion on untrusted paths that are provided from the input file. This function allows for command injection by using backticks. An attacker could craft an untrusted path input that would result in a path expansion. We recommend upgrading to 2.6.0 or past commit 52ff00a38447f06a17eab1caa2cf0730a119c751",
        "git_url": "https://github.com/syoyo/tinygltf/commit/52ff00a38447f06a17eab1caa2cf0730a119c751",
        "commit_title": "Do not expand file path since its not necessary for glTF asset path(URI) and for security reason(`wordexp`).",
        "commit_text": "",
        "func_before": "static bool ParseSparseAccessor(Accessor *accessor, std::string *err,\n                                const json &o) {\n  accessor->sparse.isSparse = true;\n\n  int count = 0;\n  if (!ParseIntegerProperty(&count, err, o, \"count\", true, \"SparseAccessor\")) {\n    return false;\n  }\n\n  json_const_iterator indices_iterator;\n  json_const_iterator values_iterator;\n  if (!FindMember(o, \"indices\", indices_iterator)) {\n    (*err) = \"the sparse object of this accessor doesn't have indices\";\n    return false;\n  }\n\n  if (!FindMember(o, \"values\", values_iterator)) {\n    (*err) = \"the sparse object ob ths accessor doesn't have values\";\n    return false;\n  }\n\n  const json &indices_obj = GetValue(indices_iterator);\n  const json &values_obj = GetValue(values_iterator);\n\n  int indices_buffer_view = 0, indices_byte_offset = 0, component_type = 0;\n  if (!ParseIntegerProperty(&indices_buffer_view, err, indices_obj, \"bufferView\",\n                       true, \"SparseAccessor\")) {\n    return false;\n  }\n  ParseIntegerProperty(&indices_byte_offset, err, indices_obj, \"byteOffset\",\n                       false);\n  if (!ParseIntegerProperty(&component_type, err, indices_obj, \"componentType\",\n                       true, \"SparseAccessor\")) {\n    return false;\n  }\n\n  int values_buffer_view = 0, values_byte_offset = 0;\n  if (!ParseIntegerProperty(&values_buffer_view, err, values_obj, \"bufferView\",\n                       true, \"SparseAccessor\")) {\n    return false;\n  }\n  ParseIntegerProperty(&values_byte_offset, err, values_obj, \"byteOffset\",\n                       false);\n\n  accessor->sparse.count = count;\n  accessor->sparse.indices.bufferView = indices_buffer_view;\n  accessor->sparse.indices.byteOffset = indices_byte_offset;\n  accessor->sparse.indices.componentType = component_type;\n  accessor->sparse.values.bufferView = values_buffer_view;\n  accessor->sparse.values.byteOffset = values_byte_offset;\n\n  return true;\n}",
        "func": "static bool ParseSparseAccessor(Accessor *accessor, std::string *err,\n                                const json &o) {\n  accessor->sparse.isSparse = true;\n\n  int count = 0;\n  if (!ParseIntegerProperty(&count, err, o, \"count\", true, \"SparseAccessor\")) {\n    return false;\n  }\n\n  json_const_iterator indices_iterator;\n  json_const_iterator values_iterator;\n  if (!FindMember(o, \"indices\", indices_iterator)) {\n    (*err) = \"the sparse object of this accessor doesn't have indices\";\n    return false;\n  }\n\n  if (!FindMember(o, \"values\", values_iterator)) {\n    (*err) = \"the sparse object ob ths accessor doesn't have values\";\n    return false;\n  }\n\n  const json &indices_obj = GetValue(indices_iterator);\n  const json &values_obj = GetValue(values_iterator);\n\n  int indices_buffer_view = 0, indices_byte_offset = 0, component_type = 0;\n  if (!ParseIntegerProperty(&indices_buffer_view, err, indices_obj,\n                            \"bufferView\", true, \"SparseAccessor\")) {\n    return false;\n  }\n  ParseIntegerProperty(&indices_byte_offset, err, indices_obj, \"byteOffset\",\n                       false);\n  if (!ParseIntegerProperty(&component_type, err, indices_obj, \"componentType\",\n                            true, \"SparseAccessor\")) {\n    return false;\n  }\n\n  int values_buffer_view = 0, values_byte_offset = 0;\n  if (!ParseIntegerProperty(&values_buffer_view, err, values_obj, \"bufferView\",\n                            true, \"SparseAccessor\")) {\n    return false;\n  }\n  ParseIntegerProperty(&values_byte_offset, err, values_obj, \"byteOffset\",\n                       false);\n\n  accessor->sparse.count = count;\n  accessor->sparse.indices.bufferView = indices_buffer_view;\n  accessor->sparse.indices.byteOffset = indices_byte_offset;\n  accessor->sparse.indices.componentType = component_type;\n  accessor->sparse.values.bufferView = values_buffer_view;\n  accessor->sparse.values.byteOffset = values_byte_offset;\n\n  return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,20 +23,20 @@\n   const json &values_obj = GetValue(values_iterator);\n \n   int indices_buffer_view = 0, indices_byte_offset = 0, component_type = 0;\n-  if (!ParseIntegerProperty(&indices_buffer_view, err, indices_obj, \"bufferView\",\n-                       true, \"SparseAccessor\")) {\n+  if (!ParseIntegerProperty(&indices_buffer_view, err, indices_obj,\n+                            \"bufferView\", true, \"SparseAccessor\")) {\n     return false;\n   }\n   ParseIntegerProperty(&indices_byte_offset, err, indices_obj, \"byteOffset\",\n                        false);\n   if (!ParseIntegerProperty(&component_type, err, indices_obj, \"componentType\",\n-                       true, \"SparseAccessor\")) {\n+                            true, \"SparseAccessor\")) {\n     return false;\n   }\n \n   int values_buffer_view = 0, values_byte_offset = 0;\n   if (!ParseIntegerProperty(&values_buffer_view, err, values_obj, \"bufferView\",\n-                       true, \"SparseAccessor\")) {\n+                            true, \"SparseAccessor\")) {\n     return false;\n   }\n   ParseIntegerProperty(&values_byte_offset, err, values_obj, \"byteOffset\",",
        "diff_line_info": {
            "deleted_lines": [
                "  if (!ParseIntegerProperty(&indices_buffer_view, err, indices_obj, \"bufferView\",",
                "                       true, \"SparseAccessor\")) {",
                "                       true, \"SparseAccessor\")) {",
                "                       true, \"SparseAccessor\")) {"
            ],
            "added_lines": [
                "  if (!ParseIntegerProperty(&indices_buffer_view, err, indices_obj,",
                "                            \"bufferView\", true, \"SparseAccessor\")) {",
                "                            true, \"SparseAccessor\")) {",
                "                            true, \"SparseAccessor\")) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3008",
        "func_name": "syoyo/tinygltf/Sampler::operator==",
        "description": "The tinygltf library uses the C library function wordexp() to perform file path expansion on untrusted paths that are provided from the input file. This function allows for command injection by using backticks. An attacker could craft an untrusted path input that would result in a path expansion. We recommend upgrading to 2.6.0 or past commit 52ff00a38447f06a17eab1caa2cf0730a119c751",
        "git_url": "https://github.com/syoyo/tinygltf/commit/52ff00a38447f06a17eab1caa2cf0730a119c751",
        "commit_title": "Do not expand file path since its not necessary for glTF asset path(URI) and for security reason(`wordexp`).",
        "commit_text": "",
        "func_before": "bool Sampler::operator==(const Sampler &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->magFilter == other.magFilter &&\n         this->minFilter == other.minFilter && this->name == other.name &&\n         this->wrapS == other.wrapS &&\n         this->wrapT == other.wrapT;\n\n         //this->wrapR == other.wrapR\n}",
        "func": "bool Sampler::operator==(const Sampler &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->magFilter == other.magFilter &&\n         this->minFilter == other.minFilter && this->name == other.name &&\n         this->wrapS == other.wrapS && this->wrapT == other.wrapT;\n\n  // this->wrapR == other.wrapR\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,8 +2,7 @@\n   return this->extensions == other.extensions && this->extras == other.extras &&\n          this->magFilter == other.magFilter &&\n          this->minFilter == other.minFilter && this->name == other.name &&\n-         this->wrapS == other.wrapS &&\n-         this->wrapT == other.wrapT;\n+         this->wrapS == other.wrapS && this->wrapT == other.wrapT;\n \n-         //this->wrapR == other.wrapR\n+  // this->wrapR == other.wrapR\n }",
        "diff_line_info": {
            "deleted_lines": [
                "         this->wrapS == other.wrapS &&",
                "         this->wrapT == other.wrapT;",
                "         //this->wrapR == other.wrapR"
            ],
            "added_lines": [
                "         this->wrapS == other.wrapS && this->wrapT == other.wrapT;",
                "  // this->wrapR == other.wrapR"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3008",
        "func_name": "syoyo/tinygltf/ParseSampler",
        "description": "The tinygltf library uses the C library function wordexp() to perform file path expansion on untrusted paths that are provided from the input file. This function allows for command injection by using backticks. An attacker could craft an untrusted path input that would result in a path expansion. We recommend upgrading to 2.6.0 or past commit 52ff00a38447f06a17eab1caa2cf0730a119c751",
        "git_url": "https://github.com/syoyo/tinygltf/commit/52ff00a38447f06a17eab1caa2cf0730a119c751",
        "commit_title": "Do not expand file path since its not necessary for glTF asset path(URI) and for security reason(`wordexp`).",
        "commit_text": "",
        "func_before": "static bool ParseSampler(Sampler *sampler, std::string *err, const json &o,\n                         bool store_original_json_for_extras_and_extensions) {\n  ParseStringProperty(&sampler->name, err, o, \"name\", false);\n\n  int minFilter = -1;\n  int magFilter = -1;\n  int wrapS = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  int wrapT = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  //int wrapR = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  ParseIntegerProperty(&minFilter, err, o, \"minFilter\", false);\n  ParseIntegerProperty(&magFilter, err, o, \"magFilter\", false);\n  ParseIntegerProperty(&wrapS, err, o, \"wrapS\", false);\n  ParseIntegerProperty(&wrapT, err, o, \"wrapT\", false);\n  //ParseIntegerProperty(&wrapR, err, o, \"wrapR\", false);  // tinygltf extension\n\n  // TODO(syoyo): Check the value is alloed one.\n  // (e.g. we allow 9728(NEAREST), but don't allow 9727)\n\n  sampler->minFilter = minFilter;\n  sampler->magFilter = magFilter;\n  sampler->wrapS = wrapS;\n  sampler->wrapT = wrapT;\n  //sampler->wrapR = wrapR;\n\n  ParseExtensionsProperty(&(sampler->extensions), err, o);\n  ParseExtrasProperty(&(sampler->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        sampler->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        sampler->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}",
        "func": "static bool ParseSampler(Sampler *sampler, std::string *err, const json &o,\n                         bool store_original_json_for_extras_and_extensions) {\n  ParseStringProperty(&sampler->name, err, o, \"name\", false);\n\n  int minFilter = -1;\n  int magFilter = -1;\n  int wrapS = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  int wrapT = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  // int wrapR = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  ParseIntegerProperty(&minFilter, err, o, \"minFilter\", false);\n  ParseIntegerProperty(&magFilter, err, o, \"magFilter\", false);\n  ParseIntegerProperty(&wrapS, err, o, \"wrapS\", false);\n  ParseIntegerProperty(&wrapT, err, o, \"wrapT\", false);\n  // ParseIntegerProperty(&wrapR, err, o, \"wrapR\", false);  // tinygltf\n  // extension\n\n  // TODO(syoyo): Check the value is alloed one.\n  // (e.g. we allow 9728(NEAREST), but don't allow 9727)\n\n  sampler->minFilter = minFilter;\n  sampler->magFilter = magFilter;\n  sampler->wrapS = wrapS;\n  sampler->wrapT = wrapT;\n  // sampler->wrapR = wrapR;\n\n  ParseExtensionsProperty(&(sampler->extensions), err, o);\n  ParseExtrasProperty(&(sampler->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        sampler->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        sampler->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,12 +6,13 @@\n   int magFilter = -1;\n   int wrapS = TINYGLTF_TEXTURE_WRAP_REPEAT;\n   int wrapT = TINYGLTF_TEXTURE_WRAP_REPEAT;\n-  //int wrapR = TINYGLTF_TEXTURE_WRAP_REPEAT;\n+  // int wrapR = TINYGLTF_TEXTURE_WRAP_REPEAT;\n   ParseIntegerProperty(&minFilter, err, o, \"minFilter\", false);\n   ParseIntegerProperty(&magFilter, err, o, \"magFilter\", false);\n   ParseIntegerProperty(&wrapS, err, o, \"wrapS\", false);\n   ParseIntegerProperty(&wrapT, err, o, \"wrapT\", false);\n-  //ParseIntegerProperty(&wrapR, err, o, \"wrapR\", false);  // tinygltf extension\n+  // ParseIntegerProperty(&wrapR, err, o, \"wrapR\", false);  // tinygltf\n+  // extension\n \n   // TODO(syoyo): Check the value is alloed one.\n   // (e.g. we allow 9728(NEAREST), but don't allow 9727)\n@@ -20,7 +21,7 @@\n   sampler->magFilter = magFilter;\n   sampler->wrapS = wrapS;\n   sampler->wrapT = wrapT;\n-  //sampler->wrapR = wrapR;\n+  // sampler->wrapR = wrapR;\n \n   ParseExtensionsProperty(&(sampler->extensions), err, o);\n   ParseExtrasProperty(&(sampler->extras), o);",
        "diff_line_info": {
            "deleted_lines": [
                "  //int wrapR = TINYGLTF_TEXTURE_WRAP_REPEAT;",
                "  //ParseIntegerProperty(&wrapR, err, o, \"wrapR\", false);  // tinygltf extension",
                "  //sampler->wrapR = wrapR;"
            ],
            "added_lines": [
                "  // int wrapR = TINYGLTF_TEXTURE_WRAP_REPEAT;",
                "  // ParseIntegerProperty(&wrapR, err, o, \"wrapR\", false);  // tinygltf",
                "  // extension",
                "  // sampler->wrapR = wrapR;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3008",
        "func_name": "syoyo/tinygltf/ExpandFilePath",
        "description": "The tinygltf library uses the C library function wordexp() to perform file path expansion on untrusted paths that are provided from the input file. This function allows for command injection by using backticks. An attacker could craft an untrusted path input that would result in a path expansion. We recommend upgrading to 2.6.0 or past commit 52ff00a38447f06a17eab1caa2cf0730a119c751",
        "git_url": "https://github.com/syoyo/tinygltf/commit/52ff00a38447f06a17eab1caa2cf0730a119c751",
        "commit_title": "Do not expand file path since its not necessary for glTF asset path(URI) and for security reason(`wordexp`).",
        "commit_text": "",
        "func_before": "std::string ExpandFilePath(const std::string &filepath, void *) {\n#ifdef _WIN32\n  // Assume input `filepath` is encoded in UTF-8\n  std::wstring wfilepath = UTF8ToWchar(filepath);\n  DWORD wlen = ExpandEnvironmentStringsW(wfilepath.c_str(), nullptr, 0);\n  wchar_t *wstr = new wchar_t[wlen];\n  ExpandEnvironmentStringsW(wfilepath.c_str(), wstr, wlen);\n\n  std::wstring ws(wstr);\n  delete[] wstr;\n  return WcharToUTF8(ws);\n\n#else\n\n#if defined(TARGET_OS_IPHONE) || defined(TARGET_IPHONE_SIMULATOR) || \\\n    defined(__ANDROID__) || defined(__EMSCRIPTEN__) || defined(__OpenBSD__)\n  // no expansion\n  std::string s = filepath;\n#else\n  std::string s;\n  wordexp_t p;\n\n  if (filepath.empty()) {\n    return \"\";\n  }\n\n  // Quote the string to keep any spaces in filepath intact.\n  std::string quoted_path = \"\\\"\" + filepath + \"\\\"\";\n  // char** w;\n  int ret = wordexp(quoted_path.c_str(), &p, 0);\n  if (ret) {\n    // err\n    s = filepath;\n    return s;\n  }\n\n  // Use first element only.\n  if (p.we_wordv) {\n    s = std::string(p.we_wordv[0]);\n    wordfree(&p);\n  } else {\n    s = filepath;\n  }\n\n#endif\n\n  return s;\n#endif\n}",
        "func": "std::string ExpandFilePath(const std::string &filepath, void *) {\n  // https://github.com/syoyo/tinygltf/issues/368\n  //\n  // No file path expansion in built-in FS function anymore, since glTF URI\n  // should not contain tilde('~') and environment variables, and for security\n  // reason(`wordexp`).\n  //\n  // Users need to supply `base_dir`(in `LoadASCIIFromString`,\n  // `LoadBinaryFromMemory`) in expanded absolute path.\n\n  return filepath;\n\n#if 0\n#ifdef _WIN32\n  // Assume input `filepath` is encoded in UTF-8\n  std::wstring wfilepath = UTF8ToWchar(filepath);\n  DWORD wlen = ExpandEnvironmentStringsW(wfilepath.c_str(), nullptr, 0);\n  wchar_t *wstr = new wchar_t[wlen];\n  ExpandEnvironmentStringsW(wfilepath.c_str(), wstr, wlen);\n\n  std::wstring ws(wstr);\n  delete[] wstr;\n  return WcharToUTF8(ws);\n\n#else\n\n#if defined(TARGET_OS_IPHONE) || defined(TARGET_IPHONE_SIMULATOR) || \\\n    defined(__ANDROID__) || defined(__EMSCRIPTEN__) || defined(__OpenBSD__)\n  // no expansion\n  std::string s = filepath;\n#else\n  std::string s;\n  wordexp_t p;\n\n  if (filepath.empty()) {\n    return \"\";\n  }\n\n  // Quote the string to keep any spaces in filepath intact.\n  std::string quoted_path = \"\\\"\" + filepath + \"\\\"\";\n  // char** w;\n  int ret = wordexp(quoted_path.c_str(), &p, 0);\n  if (ret) {\n    // err\n    s = filepath;\n    return s;\n  }\n\n  // Use first element only.\n  if (p.we_wordv) {\n    s = std::string(p.we_wordv[0]);\n    wordfree(&p);\n  } else {\n    s = filepath;\n  }\n\n#endif\n\n  return s;\n#endif\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,16 @@\n std::string ExpandFilePath(const std::string &filepath, void *) {\n+  // https://github.com/syoyo/tinygltf/issues/368\n+  //\n+  // No file path expansion in built-in FS function anymore, since glTF URI\n+  // should not contain tilde('~') and environment variables, and for security\n+  // reason(`wordexp`).\n+  //\n+  // Users need to supply `base_dir`(in `LoadASCIIFromString`,\n+  // `LoadBinaryFromMemory`) in expanded absolute path.\n+\n+  return filepath;\n+\n+#if 0\n #ifdef _WIN32\n   // Assume input `filepath` is encoded in UTF-8\n   std::wstring wfilepath = UTF8ToWchar(filepath);\n@@ -46,4 +58,5 @@\n \n   return s;\n #endif\n+#endif\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  // https://github.com/syoyo/tinygltf/issues/368",
                "  //",
                "  // No file path expansion in built-in FS function anymore, since glTF URI",
                "  // should not contain tilde('~') and environment variables, and for security",
                "  // reason(`wordexp`).",
                "  //",
                "  // Users need to supply `base_dir`(in `LoadASCIIFromString`,",
                "  // `LoadBinaryFromMemory`) in expanded absolute path.",
                "",
                "  return filepath;",
                "",
                "#if 0",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3008",
        "func_name": "syoyo/tinygltf/GetBaseFilename",
        "description": "The tinygltf library uses the C library function wordexp() to perform file path expansion on untrusted paths that are provided from the input file. This function allows for command injection by using backticks. An attacker could craft an untrusted path input that would result in a path expansion. We recommend upgrading to 2.6.0 or past commit 52ff00a38447f06a17eab1caa2cf0730a119c751",
        "git_url": "https://github.com/syoyo/tinygltf/commit/52ff00a38447f06a17eab1caa2cf0730a119c751",
        "commit_title": "Do not expand file path since its not necessary for glTF asset path(URI) and for security reason(`wordexp`).",
        "commit_text": "",
        "func_before": "static std::string GetBaseFilename(const std::string &filepath) {\n  auto idx = filepath.find_last_of(\"/\\\\\");\n  if (idx != std::string::npos)\n    return filepath.substr(idx + 1);\n  return filepath;\n}",
        "func": "static std::string GetBaseFilename(const std::string &filepath) {\n  auto idx = filepath.find_last_of(\"/\\\\\");\n  if (idx != std::string::npos) return filepath.substr(idx + 1);\n  return filepath;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,5 @@\n static std::string GetBaseFilename(const std::string &filepath) {\n   auto idx = filepath.find_last_of(\"/\\\\\");\n-  if (idx != std::string::npos)\n-    return filepath.substr(idx + 1);\n+  if (idx != std::string::npos) return filepath.substr(idx + 1);\n   return filepath;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  if (idx != std::string::npos)",
                "    return filepath.substr(idx + 1);"
            ],
            "added_lines": [
                "  if (idx != std::string::npos) return filepath.substr(idx + 1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9114",
        "func_name": "util-linux/parse_token",
        "description": "Blkid in util-linux before 2.26rc-1 allows local users to execute arbitrary code.",
        "git_url": "https://github.com/util-linux/util-linux/commit/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc",
        "commit_title": "libblkid: care about unsafe chars in cache",
        "commit_text": " The high-level libblkid API uses /run/blkid/blkid.tab cache to store probing results. The cache format is     <device NAME=\"value\" ...>devname</device>  and unfortunately the cache code does not escape quotation marks:     # mkfs.ext4 -L 'AAA\"BBB'     # cat /run/blkid/blkid.tab    ...    <device ... LABEL=\"AAA\"BBB\" ...>/dev/sdb1</device>  such string is later incorrectly parsed and blkid(8) returns nonsenses. And for use-cases like     # eval $(blkid -o export /dev/sdb1)  it's also insecure.  Note that mount, udevd and blkid -p are based on low-level libblkid API, it bypass the cache and directly read data from the devices.  The current udevd upstream does not depend on blkid(8) output at all, it's directly linked with the library and all unsafe chars are encoded by \\x<hex> notation.     # mkfs.ext4 -L 'X\"`/tmp/foo` \"' /dev/sdb1    # udevadm info --export-db | grep LABEL    ...    E: ID_FS_LABEL=X__/tmp/foo___    E: ID_FS_LABEL_ENC=X\\x22\\x60\\x2ftmp\\x2ffoo\\x60\\x20\\x22 ",
        "func_before": "static int parse_token(char **name, char **value, char **cp)\n{\n\tchar *end;\n\n\tif (!name || !value || !cp)\n\t\treturn -BLKID_ERR_PARAM;\n\n\tif (!(*value = strchr(*cp, '=')))\n\t\treturn 0;\n\n\t**value = '\\0';\n\t*name = strip_line(*cp);\n\t*value = skip_over_blank(*value + 1);\n\n\tif (**value == '\"') {\n\t\tend = strchr(*value + 1, '\"');\n\t\tif (!end) {\n\t\t\tDBG(READ, ul_debug(\"unbalanced quotes at: %s\", *value));\n\t\t\t*cp = *value;\n\t\t\treturn -BLKID_ERR_CACHE;\n\t\t}\n\t\t(*value)++;\n\t\t*end = '\\0';\n\t\tend++;\n\t} else {\n\t\tend = skip_over_word(*value);\n\t\tif (*end) {\n\t\t\t*end = '\\0';\n\t\t\tend++;\n\t\t}\n\t}\n\t*cp = end;\n\n\treturn 1;\n}",
        "func": "static int parse_token(char **name, char **value, char **cp)\n{\n\tchar *end;\n\n\tif (!name || !value || !cp)\n\t\treturn -BLKID_ERR_PARAM;\n\n\tif (!(*value = strchr(*cp, '=')))\n\t\treturn 0;\n\n\t**value = '\\0';\n\t*name = strip_line(*cp);\n\t*value = skip_over_blank(*value + 1);\n\n\tif (**value == '\"') {\n\t\tchar *p = end = *value + 1;\n\n\t\t/* convert 'foo\\\"bar'  to 'foo\"bar' */\n\t\twhile (*p) {\n\t\t\tif (*p == '\\\\') {\n\t\t\t\tp++;\n\t\t\t\t*end = *p;\n\t\t\t} else {\n\t\t\t\t*end = *p;\n\t\t\t\tif (*p == '\"')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp++;\n\t\t\tend++;\n\t\t}\n\n\t\tif (*end != '\"') {\n\t\t\tDBG(READ, ul_debug(\"unbalanced quotes at: %s\", *value));\n\t\t\t*cp = *value;\n\t\t\treturn -BLKID_ERR_CACHE;\n\t\t}\n\t\t(*value)++;\n\t\t*end = '\\0';\n\t\tend = ++p;\n\t} else {\n\t\tend = skip_over_word(*value);\n\t\tif (*end) {\n\t\t\t*end = '\\0';\n\t\t\tend++;\n\t\t}\n\t}\n\t*cp = end;\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,15 +13,30 @@\n \t*value = skip_over_blank(*value + 1);\n \n \tif (**value == '\"') {\n-\t\tend = strchr(*value + 1, '\"');\n-\t\tif (!end) {\n+\t\tchar *p = end = *value + 1;\n+\n+\t\t/* convert 'foo\\\"bar'  to 'foo\"bar' */\n+\t\twhile (*p) {\n+\t\t\tif (*p == '\\\\') {\n+\t\t\t\tp++;\n+\t\t\t\t*end = *p;\n+\t\t\t} else {\n+\t\t\t\t*end = *p;\n+\t\t\t\tif (*p == '\"')\n+\t\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tp++;\n+\t\t\tend++;\n+\t\t}\n+\n+\t\tif (*end != '\"') {\n \t\t\tDBG(READ, ul_debug(\"unbalanced quotes at: %s\", *value));\n \t\t\t*cp = *value;\n \t\t\treturn -BLKID_ERR_CACHE;\n \t\t}\n \t\t(*value)++;\n \t\t*end = '\\0';\n-\t\tend++;\n+\t\tend = ++p;\n \t} else {\n \t\tend = skip_over_word(*value);\n \t\tif (*end) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tend = strchr(*value + 1, '\"');",
                "\t\tif (!end) {",
                "\t\tend++;"
            ],
            "added_lines": [
                "\t\tchar *p = end = *value + 1;",
                "",
                "\t\t/* convert 'foo\\\"bar'  to 'foo\"bar' */",
                "\t\twhile (*p) {",
                "\t\t\tif (*p == '\\\\') {",
                "\t\t\t\tp++;",
                "\t\t\t\t*end = *p;",
                "\t\t\t} else {",
                "\t\t\t\t*end = *p;",
                "\t\t\t\tif (*p == '\"')",
                "\t\t\t\t\tbreak;",
                "\t\t\t}",
                "\t\t\tp++;",
                "\t\t\tend++;",
                "\t\t}",
                "",
                "\t\tif (*end != '\"') {",
                "\t\tend = ++p;"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9114",
        "func_name": "util-linux/print_value",
        "description": "Blkid in util-linux before 2.26rc-1 allows local users to execute arbitrary code.",
        "git_url": "https://github.com/util-linux/util-linux/commit/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc",
        "commit_title": "libblkid: care about unsafe chars in cache",
        "commit_text": " The high-level libblkid API uses /run/blkid/blkid.tab cache to store probing results. The cache format is     <device NAME=\"value\" ...>devname</device>  and unfortunately the cache code does not escape quotation marks:     # mkfs.ext4 -L 'AAA\"BBB'     # cat /run/blkid/blkid.tab    ...    <device ... LABEL=\"AAA\"BBB\" ...>/dev/sdb1</device>  such string is later incorrectly parsed and blkid(8) returns nonsenses. And for use-cases like     # eval $(blkid -o export /dev/sdb1)  it's also insecure.  Note that mount, udevd and blkid -p are based on low-level libblkid API, it bypass the cache and directly read data from the devices.  The current udevd upstream does not depend on blkid(8) output at all, it's directly linked with the library and all unsafe chars are encoded by \\x<hex> notation.     # mkfs.ext4 -L 'X\"`/tmp/foo` \"' /dev/sdb1    # udevadm info --export-db | grep LABEL    ...    E: ID_FS_LABEL=X__/tmp/foo___    E: ID_FS_LABEL_ENC=X\\x22\\x60\\x2ftmp\\x2ffoo\\x60\\x20\\x22 ",
        "func_before": "static void print_value(int output, int num, const char *devname,\n\t\t\tconst char *value, const char *name, size_t valsz)\n{\n\tif (output & OUTPUT_VALUE_ONLY) {\n\t\tfputs(value, stdout);\n\t\tfputc('\\n', stdout);\n\n\t} else if (output & OUTPUT_UDEV_LIST) {\n\t\tprint_udev_format(name, value);\n\n\t} else if (output & OUTPUT_EXPORT_LIST) {\n\t\tif (num == 1 && devname)\n\t\t\tprintf(\"DEVNAME=%s\\n\", devname);\n\t\tfputs(name, stdout);\n\t\tfputs(\"=\", stdout);\n\t\tsafe_print(value, valsz, NULL);\n\t\tfputs(\"\\n\", stdout);\n\n\t} else {\n\t\tif (num == 1 && devname)\n\t\t\tprintf(\"%s:\", devname);\n\t\tfputs(\" \", stdout);\n\t\tfputs(name, stdout);\n\t\tfputs(\"=\\\"\", stdout);\n\t\tsafe_print(value, valsz, \"\\\"\");\n\t\tfputs(\"\\\"\", stdout);\n\t}\n}",
        "func": "static void print_value(int output, int num, const char *devname,\n\t\t\tconst char *value, const char *name, size_t valsz)\n{\n\tif (output & OUTPUT_VALUE_ONLY) {\n\t\tfputs(value, stdout);\n\t\tfputc('\\n', stdout);\n\n\t} else if (output & OUTPUT_UDEV_LIST) {\n\t\tprint_udev_format(name, value);\n\n\t} else if (output & OUTPUT_EXPORT_LIST) {\n\t\tif (num == 1 && devname)\n\t\t\tprintf(\"DEVNAME=%s\\n\", devname);\n\t\tfputs(name, stdout);\n\t\tfputs(\"=\", stdout);\n\t\tsafe_print(value, valsz, \" \\\\\\\"'$`<>\");\n\t\tfputs(\"\\n\", stdout);\n\n\t} else {\n\t\tif (num == 1 && devname)\n\t\t\tprintf(\"%s:\", devname);\n\t\tfputs(\" \", stdout);\n\t\tfputs(name, stdout);\n\t\tfputs(\"=\\\"\", stdout);\n\t\tsafe_print(value, valsz, \"\\\"\\\\\");\n\t\tfputs(\"\\\"\", stdout);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,7 @@\n \t\t\tprintf(\"DEVNAME=%s\\n\", devname);\n \t\tfputs(name, stdout);\n \t\tfputs(\"=\", stdout);\n-\t\tsafe_print(value, valsz, NULL);\n+\t\tsafe_print(value, valsz, \" \\\\\\\"'$`<>\");\n \t\tfputs(\"\\n\", stdout);\n \n \t} else {\n@@ -22,7 +22,7 @@\n \t\tfputs(\" \", stdout);\n \t\tfputs(name, stdout);\n \t\tfputs(\"=\\\"\", stdout);\n-\t\tsafe_print(value, valsz, \"\\\"\");\n+\t\tsafe_print(value, valsz, \"\\\"\\\\\");\n \t\tfputs(\"\\\"\", stdout);\n \t}\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tsafe_print(value, valsz, NULL);",
                "\t\tsafe_print(value, valsz, \"\\\"\");"
            ],
            "added_lines": [
                "\t\tsafe_print(value, valsz, \" \\\\\\\"'$`<>\");",
                "\t\tsafe_print(value, valsz, \"\\\"\\\\\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9114",
        "func_name": "util-linux/save_dev",
        "description": "Blkid in util-linux before 2.26rc-1 allows local users to execute arbitrary code.",
        "git_url": "https://github.com/util-linux/util-linux/commit/89e90ae7b2826110ea28c1c0eb8e7c56c3907bdc",
        "commit_title": "libblkid: care about unsafe chars in cache",
        "commit_text": " The high-level libblkid API uses /run/blkid/blkid.tab cache to store probing results. The cache format is     <device NAME=\"value\" ...>devname</device>  and unfortunately the cache code does not escape quotation marks:     # mkfs.ext4 -L 'AAA\"BBB'     # cat /run/blkid/blkid.tab    ...    <device ... LABEL=\"AAA\"BBB\" ...>/dev/sdb1</device>  such string is later incorrectly parsed and blkid(8) returns nonsenses. And for use-cases like     # eval $(blkid -o export /dev/sdb1)  it's also insecure.  Note that mount, udevd and blkid -p are based on low-level libblkid API, it bypass the cache and directly read data from the devices.  The current udevd upstream does not depend on blkid(8) output at all, it's directly linked with the library and all unsafe chars are encoded by \\x<hex> notation.     # mkfs.ext4 -L 'X\"`/tmp/foo` \"' /dev/sdb1    # udevadm info --export-db | grep LABEL    ...    E: ID_FS_LABEL=X__/tmp/foo___    E: ID_FS_LABEL_ENC=X\\x22\\x60\\x2ftmp\\x2ffoo\\x60\\x20\\x22 ",
        "func_before": "static int save_dev(blkid_dev dev, FILE *file)\n{\n\tstruct list_head *p;\n\n\tif (!dev || dev->bid_name[0] != '/')\n\t\treturn 0;\n\n\tDBG(SAVE, ul_debug(\"device %s, type %s\", dev->bid_name, dev->bid_type ?\n\t\t   dev->bid_type : \"(null)\"));\n\n\tfprintf(file, \"<device DEVNO=\\\"0x%04lx\\\" TIME=\\\"%ld.%ld\\\"\",\n\t\t\t(unsigned long) dev->bid_devno,\n\t\t\t(long) dev->bid_time,\n\t\t\t(long) dev->bid_utime);\n\n\tif (dev->bid_pri)\n\t\tfprintf(file, \" PRI=\\\"%d\\\"\", dev->bid_pri);\n\tlist_for_each(p, &dev->bid_tags) {\n\t\tblkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);\n\t\tfprintf(file, \" %s=\\\"%s\\\"\", tag->bit_name,tag->bit_val);\n\t}\n\tfprintf(file, \">%s</device>\\n\", dev->bid_name);\n\n\treturn 0;\n}",
        "func": "static int save_dev(blkid_dev dev, FILE *file)\n{\n\tstruct list_head *p;\n\n\tif (!dev || dev->bid_name[0] != '/')\n\t\treturn 0;\n\n\tDBG(SAVE, ul_debug(\"device %s, type %s\", dev->bid_name, dev->bid_type ?\n\t\t   dev->bid_type : \"(null)\"));\n\n\tfprintf(file, \"<device DEVNO=\\\"0x%04lx\\\" TIME=\\\"%ld.%ld\\\"\",\n\t\t\t(unsigned long) dev->bid_devno,\n\t\t\t(long) dev->bid_time,\n\t\t\t(long) dev->bid_utime);\n\n\tif (dev->bid_pri)\n\t\tfprintf(file, \" PRI=\\\"%d\\\"\", dev->bid_pri);\n\n\tlist_for_each(p, &dev->bid_tags) {\n\t\tblkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);\n\n\t\tfputc(' ', file);\t\t\t/* space between tags */\n\t\tfputs(tag->bit_name, file);\t\t/* tag NAME */\n\t\tfputc('=', file);\t\t\t/* separator between NAME and VALUE */\n\t\tsave_quoted(tag->bit_val, file);\t/* tag \"VALUE\" */\n\t}\n\tfprintf(file, \">%s</device>\\n\", dev->bid_name);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,9 +15,14 @@\n \n \tif (dev->bid_pri)\n \t\tfprintf(file, \" PRI=\\\"%d\\\"\", dev->bid_pri);\n+\n \tlist_for_each(p, &dev->bid_tags) {\n \t\tblkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);\n-\t\tfprintf(file, \" %s=\\\"%s\\\"\", tag->bit_name,tag->bit_val);\n+\n+\t\tfputc(' ', file);\t\t\t/* space between tags */\n+\t\tfputs(tag->bit_name, file);\t\t/* tag NAME */\n+\t\tfputc('=', file);\t\t\t/* separator between NAME and VALUE */\n+\t\tsave_quoted(tag->bit_val, file);\t/* tag \"VALUE\" */\n \t}\n \tfprintf(file, \">%s</device>\\n\", dev->bid_name);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tfprintf(file, \" %s=\\\"%s\\\"\", tag->bit_name,tag->bit_val);"
            ],
            "added_lines": [
                "",
                "",
                "\t\tfputc(' ', file);\t\t\t/* space between tags */",
                "\t\tfputs(tag->bit_name, file);\t\t/* tag NAME */",
                "\t\tfputc('=', file);\t\t\t/* separator between NAME and VALUE */",
                "\t\tsave_quoted(tag->bit_val, file);\t/* tag \"VALUE\" */"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-9059",
        "func_name": "npat-efault/picocom/do_command",
        "description": "picocom before 2.0 has a command injection vulnerability in the 'send and receive file' command because the command line is executed by /bin/sh unsafely.",
        "git_url": "https://github.com/npat-efault/picocom/commit/1ebc60b20fbe9a02436d5cbbf8951714e749ddb1",
        "commit_title": "Do not use \"/bin/sh\" to run external commands.",
        "commit_text": " Picocom no longer uses /bin/sh to run external commands for file-transfer operations. Parsing the command line and spliting it into arguments is now performed internally by picocom, using quoting rules very similar to those of the Unix shell. Hopefully, this makes it impossible to inject shell-commands when supplying filenames or extra arguments to the send- and receive-file commands.",
        "func_before": "int\ndo_command (unsigned char c)\n{\n\tstatic int dtr_up = 0;\n\tint newbaud, newflow, newparity, newbits;\n\tconst char *xfr_cmd;\n\tchar *fname;\n\tint r;\n\n\tswitch (c) {\n\tcase KEY_EXIT:\n\t\treturn 1;\n\tcase KEY_QUIT:\n\t\tterm_set_hupcl(tty_fd, 0);\n\t\tterm_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tterm_erase(tty_fd);\n\t\treturn 1;\n\tcase KEY_STATUS:\n\t\tshow_status(dtr_up);\n\t\tbreak;\n\tcase KEY_PULSE:\n\t\tfd_printf(STO, \"\\r\\n*** pulse DTR ***\\r\\n\");\n\t\tif ( term_pulse_dtr(tty_fd) < 0 )\n\t\t\tfd_printf(STO, \"*** FAILED\\r\\n\");\n\t\tbreak;\n\tcase KEY_TOGGLE:\n\t\tif ( dtr_up )\n\t\t\tr = term_lower_dtr(tty_fd);\n\t\telse\n\t\t\tr = term_raise_dtr(tty_fd);\n\t\tif ( r >= 0 ) dtr_up = ! dtr_up;\n\t\tfd_printf(STO, \"\\r\\n*** DTR: %s ***\\r\\n\", \n\t\t\t\t  dtr_up ? \"up\" : \"down\");\n\t\tbreak;\n\tcase KEY_BAUD_UP:\n\tcase KEY_BAUD_DN:\n\t\tif (c == KEY_BAUD_UP)\n\t\t\topts.baud = baud_up(opts.baud);\n\t\telse \n\t\t\topts.baud = baud_down(opts.baud);\n\t\tterm_set_baudrate(tty_fd, opts.baud);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewbaud = term_get_baudrate(tty_fd, NULL);\n\t\tif ( opts.baud != newbaud ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** baud: %d (%d) ***\\r\\n\", \n\t\t\t\t\t  opts.baud, newbaud);\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** baud: %d ***\\r\\n\", opts.baud);\n\t\t}\n\t\tset_tty_write_sz(newbaud);\n\t\tbreak;\n\tcase KEY_FLOW:\n\t\topts.flow = flow_next(opts.flow);\n\t\tterm_set_flowcntrl(tty_fd, opts.flow);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewflow = term_get_flowcntrl(tty_fd);\n\t\tif ( opts.flow != newflow ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** flow: %s (%s) ***\\r\\n\", \n\t\t\t\t\t  flow_str[opts.flow], flow_str[newflow]);\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** flow: %s ***\\r\\n\", \n\t\t\t\t\t  flow_str[opts.flow]);\n\t\t}\n\t\tbreak;\n\tcase KEY_PARITY:\n\t\topts.parity = parity_next(opts.parity);\n\t\tterm_set_parity(tty_fd, opts.parity);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewparity = term_get_parity(tty_fd);\n\t\tif (opts.parity != newparity ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** parity: %s (%s) ***\\r\\n\",\n\t\t\t\t\t  parity_str[opts.parity], \n\t\t\t\t\t  parity_str[newparity]);\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** parity: %s ***\\r\\n\", \n\t\t\t\t\t  parity_str[opts.parity]);\n\t\t}\n\t\tbreak;\n\tcase KEY_BITS:\n\t\topts.databits = bits_next(opts.databits);\n\t\tterm_set_databits(tty_fd, opts.databits);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewbits = term_get_databits(tty_fd);\n\t\tif (opts.databits != newbits ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** databits: %d (%d) ***\\r\\n\",\n\t\t\t\t\t  opts.databits, newbits);\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** databits: %d ***\\r\\n\", \n\t\t\t\t\t  opts.databits);\n\t\t}\n\t\tbreak;\n\tcase KEY_LECHO:\n\t\topts.lecho = ! opts.lecho;\n\t\tfd_printf(STO, \"\\r\\n*** local echo: %s ***\\r\\n\", \n\t\t\t\t  opts.lecho ? \"yes\" : \"no\");\n\t\tbreak;\n\tcase KEY_SEND:\n\tcase KEY_RECEIVE:\n\t\txfr_cmd = (c == KEY_SEND) ? opts.send_cmd : opts.receive_cmd;\n\t\tif ( xfr_cmd[0] == '\\0' ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** command disabled ***\\r\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tfname = read_filename();\n\t\tif (fname == NULL) {\n\t\t\tfd_printf(STO, \"*** cannot read filename ***\\r\\n\");\n\t\t\tbreak;\n\t\t}\n\t\trun_cmd(tty_fd, xfr_cmd, fname, NULL);\n\t\tfree(fname);\n\t\tbreak;\n\tcase KEY_BREAK:\n\t\tterm_break(tty_fd);\n\t\tfd_printf(STO, \"\\r\\n*** break sent ***\\r\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
        "func": "int\ndo_command (unsigned char c)\n{\n\tstatic int dtr_up = 0;\n\tint newbaud, newflow, newparity, newbits;\n\tconst char *xfr_cmd;\n\tchar *fname;\n\tint r;\n\n\tswitch (c) {\n\tcase KEY_EXIT:\n\t\treturn 1;\n\tcase KEY_QUIT:\n\t\tterm_set_hupcl(tty_fd, 0);\n\t\tterm_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tterm_erase(tty_fd);\n\t\treturn 1;\n\tcase KEY_STATUS:\n\t\tshow_status(dtr_up);\n\t\tbreak;\n\tcase KEY_PULSE:\n\t\tfd_printf(STO, \"\\r\\n*** pulse DTR ***\\r\\n\");\n\t\tif ( term_pulse_dtr(tty_fd) < 0 )\n\t\t\tfd_printf(STO, \"*** FAILED\\r\\n\");\n\t\tbreak;\n\tcase KEY_TOGGLE:\n\t\tif ( dtr_up )\n\t\t\tr = term_lower_dtr(tty_fd);\n\t\telse\n\t\t\tr = term_raise_dtr(tty_fd);\n\t\tif ( r >= 0 ) dtr_up = ! dtr_up;\n\t\tfd_printf(STO, \"\\r\\n*** DTR: %s ***\\r\\n\", \n\t\t\t\t  dtr_up ? \"up\" : \"down\");\n\t\tbreak;\n\tcase KEY_BAUD_UP:\n\tcase KEY_BAUD_DN:\n\t\tif (c == KEY_BAUD_UP)\n\t\t\topts.baud = baud_up(opts.baud);\n\t\telse \n\t\t\topts.baud = baud_down(opts.baud);\n\t\tterm_set_baudrate(tty_fd, opts.baud);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewbaud = term_get_baudrate(tty_fd, NULL);\n\t\tif ( opts.baud != newbaud ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** baud: %d (%d) ***\\r\\n\", \n\t\t\t\t\t  opts.baud, newbaud);\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** baud: %d ***\\r\\n\", opts.baud);\n\t\t}\n\t\tset_tty_write_sz(newbaud);\n\t\tbreak;\n\tcase KEY_FLOW:\n\t\topts.flow = flow_next(opts.flow);\n\t\tterm_set_flowcntrl(tty_fd, opts.flow);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewflow = term_get_flowcntrl(tty_fd);\n\t\tif ( opts.flow != newflow ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** flow: %s (%s) ***\\r\\n\", \n\t\t\t\t\t  flow_str[opts.flow], flow_str[newflow]);\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** flow: %s ***\\r\\n\", \n\t\t\t\t\t  flow_str[opts.flow]);\n\t\t}\n\t\tbreak;\n\tcase KEY_PARITY:\n\t\topts.parity = parity_next(opts.parity);\n\t\tterm_set_parity(tty_fd, opts.parity);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewparity = term_get_parity(tty_fd);\n\t\tif (opts.parity != newparity ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** parity: %s (%s) ***\\r\\n\",\n\t\t\t\t\t  parity_str[opts.parity], \n\t\t\t\t\t  parity_str[newparity]);\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** parity: %s ***\\r\\n\", \n\t\t\t\t\t  parity_str[opts.parity]);\n\t\t}\n\t\tbreak;\n\tcase KEY_BITS:\n\t\topts.databits = bits_next(opts.databits);\n\t\tterm_set_databits(tty_fd, opts.databits);\n\t\ttty_q.len = 0; term_flush(tty_fd);\n\t\tterm_apply(tty_fd);\n\t\tnewbits = term_get_databits(tty_fd);\n\t\tif (opts.databits != newbits ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** databits: %d (%d) ***\\r\\n\",\n\t\t\t\t\t  opts.databits, newbits);\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** databits: %d ***\\r\\n\", \n\t\t\t\t\t  opts.databits);\n\t\t}\n\t\tbreak;\n\tcase KEY_LECHO:\n\t\topts.lecho = ! opts.lecho;\n\t\tfd_printf(STO, \"\\r\\n*** local echo: %s ***\\r\\n\", \n\t\t\t\t  opts.lecho ? \"yes\" : \"no\");\n\t\tbreak;\n\tcase KEY_SEND:\n\tcase KEY_RECEIVE:\n\t\txfr_cmd = (c == KEY_SEND) ? opts.send_cmd : opts.receive_cmd;\n\t\tif ( xfr_cmd[0] == '\\0' ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** command disabled ***\\r\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tfname = read_filename();\n\t\tif (fname == NULL) {\n\t\t\tfd_printf(STO, \"*** cannot read filename ***\\r\\n\");\n\t\t\tbreak;\n\t\t}\n\t\trun_cmd(tty_fd, xfr_cmd, fname);\n\t\tfree(fname);\n\t\tbreak;\n\tcase KEY_BREAK:\n\t\tterm_break(tty_fd);\n\t\tfd_printf(STO, \"\\r\\n*** break sent ***\\r\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -111,7 +111,7 @@\n \t\t\tfd_printf(STO, \"*** cannot read filename ***\\r\\n\");\n \t\t\tbreak;\n \t\t}\n-\t\trun_cmd(tty_fd, xfr_cmd, fname, NULL);\n+\t\trun_cmd(tty_fd, xfr_cmd, fname);\n \t\tfree(fname);\n \t\tbreak;\n \tcase KEY_BREAK:",
        "diff_line_info": {
            "deleted_lines": [
                "\t\trun_cmd(tty_fd, xfr_cmd, fname, NULL);"
            ],
            "added_lines": [
                "\t\trun_cmd(tty_fd, xfr_cmd, fname);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-9059",
        "func_name": "npat-efault/picocom/run_cmd",
        "description": "picocom before 2.0 has a command injection vulnerability in the 'send and receive file' command because the command line is executed by /bin/sh unsafely.",
        "git_url": "https://github.com/npat-efault/picocom/commit/1ebc60b20fbe9a02436d5cbbf8951714e749ddb1",
        "commit_title": "Do not use \"/bin/sh\" to run external commands.",
        "commit_text": " Picocom no longer uses /bin/sh to run external commands for file-transfer operations. Parsing the command line and spliting it into arguments is now performed internally by picocom, using quoting rules very similar to those of the Unix shell. Hopefully, this makes it impossible to inject shell-commands when supplying filenames or extra arguments to the send- and receive-file commands.",
        "func_before": "int\nrun_cmd(int fd, ...)\n{\n\tpid_t pid;\n\tsigset_t sigm, sigm_old;\n\n\t/* block signals, let child establish its own handlers */\n\tsigemptyset(&sigm);\n\tsigaddset(&sigm, SIGTERM);\n\tsigprocmask(SIG_BLOCK, &sigm, &sigm_old);\n\n\tpid = fork();\n\tif ( pid < 0 ) {\n\t\tsigprocmask(SIG_SETMASK, &sigm_old, NULL);\n\t\tfd_printf(STO, \"*** cannot fork: %s ***\\r\\n\", strerror(errno));\n\t\treturn -1;\n\t} else if ( pid ) {\n\t\t/* father: picocom */\n\t\tint status, r;\n\n\t\t/* reset the mask */\n\t\tsigprocmask(SIG_SETMASK, &sigm_old, NULL);\n\t\t/* wait for child to finish */\n\t\tdo {\n\t\t\tr = waitpid(pid, &status, 0);\n\t\t} while ( r < 0 && errno == EINTR );\n\t\t/* reset terminal (back to raw mode) */\n\t\tterm_apply(STI);\n\t\t/* check and report child return status */\n\t\tif ( WIFEXITED(status) ) { \n\t\t\tfd_printf(STO, \"\\r\\n*** exit status: %d ***\\r\\n\", \n\t\t\t\t\t  WEXITSTATUS(status));\n\t\t\treturn WEXITSTATUS(status);\n\t\t} else if ( WIFSIGNALED(status) ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** killed by signal: %d ***\\r\\n\", \n\t\t\t\t\t  WTERMSIG(status));\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** abnormal termination: 0x%x ***\\r\\n\", r);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\t/* child: external program */\n\t\tlong fl;\n\t\tchar cmd[512];\n\n\t\t/* unmanage terminal, and reset it to canonical mode */\n\t\tterm_remove(STI);\n\t\t/* unmanage serial port fd, without reset */\n\t\tterm_erase(fd);\n\t\t/* set serial port fd to blocking mode */\n\t\tfl = fcntl(fd, F_GETFL); \n\t\tfl &= ~O_NONBLOCK;\n\t\tfcntl(fd, F_SETFL, fl);\n\t\t/* connect stdin and stdout to serial port */\n\t\tclose(STI);\n\t\tclose(STO);\n\t\tdup2(fd, STI);\n\t\tdup2(fd, STO);\n\t\t{\n\t\t\t/* build command-line */\n\t\t\tchar *c, *ce;\n\t\t\tconst char *s;\n\t\t\tint n;\n\t\t\tva_list vls;\n\t\t\t\n\t\t\tstrcpy(cmd, EXEC);\n\t\t\tc = &cmd[sizeof(EXEC)- 1];\n\t\t\tce = cmd + sizeof(cmd) - 1;\n\t\t\tva_start(vls, fd);\n\t\t\twhile ( (s = va_arg(vls, const char *)) ) {\n\t\t\t\tn = strlen(s);\n\t\t\t\tif ( c + n + 1 >= ce ) break;\n\t\t\t\tmemcpy(c, s, n); c += n;\n\t\t\t\t*c++ = ' ';\n\t\t\t}\n\t\t\tva_end(vls);\n\t\t\t*c = '\\0';\n\t\t}\n\t\t/* run extenral command */\n\t\tfd_printf(STDERR_FILENO, \"%s\\n\", &cmd[sizeof(EXEC) - 1]);\n\t\testablish_child_signal_handlers();\n\t\tsigprocmask(SIG_SETMASK, &sigm_old, NULL);\n\t\texecl(\"/bin/sh\", \"sh\", \"-c\", cmd, NULL);\n\t\texit(42);\n\t}\n}",
        "func": "int\nrun_cmd(int fd, const char *cmd, const char *args_extra)\n{\n\tpid_t pid;\n\tsigset_t sigm, sigm_old;\n\n\t/* block signals, let child establish its own handlers */\n\tsigemptyset(&sigm);\n\tsigaddset(&sigm, SIGTERM);\n\tsigprocmask(SIG_BLOCK, &sigm, &sigm_old);\n\n\tpid = fork();\n\tif ( pid < 0 ) {\n\t\tsigprocmask(SIG_SETMASK, &sigm_old, NULL);\n\t\tfd_printf(STO, \"*** cannot fork: %s ***\\r\\n\", strerror(errno));\n\t\treturn -1;\n\t} else if ( pid ) {\n\t\t/* father: picocom */\n\t\tint status, r;\n\n\t\t/* reset the mask */\n\t\tsigprocmask(SIG_SETMASK, &sigm_old, NULL);\n\t\t/* wait for child to finish */\n\t\tdo {\n\t\t\tr = waitpid(pid, &status, 0);\n\t\t} while ( r < 0 && errno == EINTR );\n\t\t/* reset terminal (back to raw mode) */\n\t\tterm_apply(STI);\n\t\t/* check and report child return status */\n\t\tif ( WIFEXITED(status) ) { \n\t\t\tfd_printf(STO, \"\\r\\n*** exit status: %d ***\\r\\n\", \n\t\t\t\t\t  WEXITSTATUS(status));\n\t\t\treturn WEXITSTATUS(status);\n\t\t} else if ( WIFSIGNALED(status) ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** killed by signal: %d ***\\r\\n\", \n\t\t\t\t\t  WTERMSIG(status));\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tfd_printf(STO, \"\\r\\n*** abnormal termination: 0x%x ***\\r\\n\", r);\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\t/* child: external program */\n\t\tlong fl;\n\t\tint argc;\n\t\tchar *argv[RUNCMD_ARGS_MAX + 1];\n\t\tint r;\n\t\t\t\n\t\t/* unmanage terminal, and reset it to canonical mode */\n\t\tterm_remove(STI);\n\t\t/* unmanage serial port fd, without reset */\n\t\tterm_erase(fd);\n\t\t/* set serial port fd to blocking mode */\n\t\tfl = fcntl(fd, F_GETFL); \n\t\tfl &= ~O_NONBLOCK;\n\t\tfcntl(fd, F_SETFL, fl);\n\t\t/* connect stdin and stdout to serial port */\n\t\tclose(STI);\n\t\tclose(STO);\n\t\tdup2(fd, STI);\n\t\tdup2(fd, STO);\n\t\t\n\t\t/* build command arguments vector */\n\t\targc = 0;\n\t\tr = split_quoted(cmd, &argc, argv, RUNCMD_ARGS_MAX);\n\t\tif ( r < 0 ) {\n\t\t\tfd_printf(STDERR_FILENO, \"Cannot parse command\\n\");\n\t\t\texit(RUNCMD_EXEC_FAIL);\n\t\t}\n\t\tr = split_quoted(args_extra, &argc, argv, RUNCMD_ARGS_MAX);\n\t\tif ( r < 0 ) {\n\t\t\tfd_printf(STDERR_FILENO, \"Cannot parse extra args\\n\");\n\t\t\texit(RUNCMD_EXEC_FAIL);\n\t\t}\n\t\tif ( argc < 1 ) {\n\t\t\tfd_printf(STDERR_FILENO, \"No command given\\n\");\n\t\t\texit(RUNCMD_EXEC_FAIL);\n\t\t}\t\n\t\targv[argc] = NULL;\n\t\t\t\n\t\t/* run extenral command */\n\t\tfd_printf(STDERR_FILENO, \"$ %s %s\\n\", cmd, args_extra);\n\t\testablish_child_signal_handlers();\n\t\tsigprocmask(SIG_SETMASK, &sigm_old, NULL);\n\t\texecvp(argv[0], argv);\n\n\t\tfd_printf(STDERR_FILENO, \"exec: %s\\n\", strerror(errno));\n\t\texit(RUNCMD_EXEC_FAIL);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n int\n-run_cmd(int fd, ...)\n+run_cmd(int fd, const char *cmd, const char *args_extra)\n {\n \tpid_t pid;\n \tsigset_t sigm, sigm_old;\n@@ -42,8 +42,10 @@\n \t} else {\n \t\t/* child: external program */\n \t\tlong fl;\n-\t\tchar cmd[512];\n-\n+\t\tint argc;\n+\t\tchar *argv[RUNCMD_ARGS_MAX + 1];\n+\t\tint r;\n+\t\t\t\n \t\t/* unmanage terminal, and reset it to canonical mode */\n \t\tterm_remove(STI);\n \t\t/* unmanage serial port fd, without reset */\n@@ -57,31 +59,32 @@\n \t\tclose(STO);\n \t\tdup2(fd, STI);\n \t\tdup2(fd, STO);\n-\t\t{\n-\t\t\t/* build command-line */\n-\t\t\tchar *c, *ce;\n-\t\t\tconst char *s;\n-\t\t\tint n;\n-\t\t\tva_list vls;\n+\t\t\n+\t\t/* build command arguments vector */\n+\t\targc = 0;\n+\t\tr = split_quoted(cmd, &argc, argv, RUNCMD_ARGS_MAX);\n+\t\tif ( r < 0 ) {\n+\t\t\tfd_printf(STDERR_FILENO, \"Cannot parse command\\n\");\n+\t\t\texit(RUNCMD_EXEC_FAIL);\n+\t\t}\n+\t\tr = split_quoted(args_extra, &argc, argv, RUNCMD_ARGS_MAX);\n+\t\tif ( r < 0 ) {\n+\t\t\tfd_printf(STDERR_FILENO, \"Cannot parse extra args\\n\");\n+\t\t\texit(RUNCMD_EXEC_FAIL);\n+\t\t}\n+\t\tif ( argc < 1 ) {\n+\t\t\tfd_printf(STDERR_FILENO, \"No command given\\n\");\n+\t\t\texit(RUNCMD_EXEC_FAIL);\n+\t\t}\t\n+\t\targv[argc] = NULL;\n \t\t\t\n-\t\t\tstrcpy(cmd, EXEC);\n-\t\t\tc = &cmd[sizeof(EXEC)- 1];\n-\t\t\tce = cmd + sizeof(cmd) - 1;\n-\t\t\tva_start(vls, fd);\n-\t\t\twhile ( (s = va_arg(vls, const char *)) ) {\n-\t\t\t\tn = strlen(s);\n-\t\t\t\tif ( c + n + 1 >= ce ) break;\n-\t\t\t\tmemcpy(c, s, n); c += n;\n-\t\t\t\t*c++ = ' ';\n-\t\t\t}\n-\t\t\tva_end(vls);\n-\t\t\t*c = '\\0';\n-\t\t}\n \t\t/* run extenral command */\n-\t\tfd_printf(STDERR_FILENO, \"%s\\n\", &cmd[sizeof(EXEC) - 1]);\n+\t\tfd_printf(STDERR_FILENO, \"$ %s %s\\n\", cmd, args_extra);\n \t\testablish_child_signal_handlers();\n \t\tsigprocmask(SIG_SETMASK, &sigm_old, NULL);\n-\t\texecl(\"/bin/sh\", \"sh\", \"-c\", cmd, NULL);\n-\t\texit(42);\n+\t\texecvp(argv[0], argv);\n+\n+\t\tfd_printf(STDERR_FILENO, \"exec: %s\\n\", strerror(errno));\n+\t\texit(RUNCMD_EXEC_FAIL);\n \t}\n }",
        "diff_line_info": {
            "deleted_lines": [
                "run_cmd(int fd, ...)",
                "\t\tchar cmd[512];",
                "",
                "\t\t{",
                "\t\t\t/* build command-line */",
                "\t\t\tchar *c, *ce;",
                "\t\t\tconst char *s;",
                "\t\t\tint n;",
                "\t\t\tva_list vls;",
                "\t\t\tstrcpy(cmd, EXEC);",
                "\t\t\tc = &cmd[sizeof(EXEC)- 1];",
                "\t\t\tce = cmd + sizeof(cmd) - 1;",
                "\t\t\tva_start(vls, fd);",
                "\t\t\twhile ( (s = va_arg(vls, const char *)) ) {",
                "\t\t\t\tn = strlen(s);",
                "\t\t\t\tif ( c + n + 1 >= ce ) break;",
                "\t\t\t\tmemcpy(c, s, n); c += n;",
                "\t\t\t\t*c++ = ' ';",
                "\t\t\t}",
                "\t\t\tva_end(vls);",
                "\t\t\t*c = '\\0';",
                "\t\t}",
                "\t\tfd_printf(STDERR_FILENO, \"%s\\n\", &cmd[sizeof(EXEC) - 1]);",
                "\t\texecl(\"/bin/sh\", \"sh\", \"-c\", cmd, NULL);",
                "\t\texit(42);"
            ],
            "added_lines": [
                "run_cmd(int fd, const char *cmd, const char *args_extra)",
                "\t\tint argc;",
                "\t\tchar *argv[RUNCMD_ARGS_MAX + 1];",
                "\t\tint r;",
                "\t\t\t",
                "\t\t",
                "\t\t/* build command arguments vector */",
                "\t\targc = 0;",
                "\t\tr = split_quoted(cmd, &argc, argv, RUNCMD_ARGS_MAX);",
                "\t\tif ( r < 0 ) {",
                "\t\t\tfd_printf(STDERR_FILENO, \"Cannot parse command\\n\");",
                "\t\t\texit(RUNCMD_EXEC_FAIL);",
                "\t\t}",
                "\t\tr = split_quoted(args_extra, &argc, argv, RUNCMD_ARGS_MAX);",
                "\t\tif ( r < 0 ) {",
                "\t\t\tfd_printf(STDERR_FILENO, \"Cannot parse extra args\\n\");",
                "\t\t\texit(RUNCMD_EXEC_FAIL);",
                "\t\t}",
                "\t\tif ( argc < 1 ) {",
                "\t\t\tfd_printf(STDERR_FILENO, \"No command given\\n\");",
                "\t\t\texit(RUNCMD_EXEC_FAIL);",
                "\t\t}\t",
                "\t\targv[argc] = NULL;",
                "\t\tfd_printf(STDERR_FILENO, \"$ %s %s\\n\", cmd, args_extra);",
                "\t\texecvp(argv[0], argv);",
                "",
                "\t\tfd_printf(STDERR_FILENO, \"exec: %s\\n\", strerror(errno));",
                "\t\texit(RUNCMD_EXEC_FAIL);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-28425",
        "func_name": "redis/msetGenericCommand",
        "description": "Redis is an in-memory database that persists on disk. Starting in version 7.0.8 and prior to version 7.0.10, authenticated users can use the MSETNX command to trigger a runtime assertion and termination of the Redis server process. The problem is fixed in Redis version 7.0.10.",
        "git_url": "https://github.com/redis/redis/commit/48e0d4788434833b47892fe9f3d91be7687f25c9",
        "commit_title": "Avoid assertion when MSETNX is used with the same key twice (CVE-2023-28425) (#11940)",
        "commit_text": " Using the same key twice in MSETNX command would trigger an assertion.\r \r This reverts #11594 (introduced in Redis 7.0.8)",
        "func_before": "void msetGenericCommand(client *c, int nx) {\n    int j;\n    int setkey_flags = 0;\n\n    if ((c->argc % 2) == 0) {\n        addReplyErrorArity(c);\n        return;\n    }\n\n    /* Handle the NX flag. The MSETNX semantic is to return zero and don't\n     * set anything if at least one key already exists. */\n    if (nx) {\n        for (j = 1; j < c->argc; j += 2) {\n            if (lookupKeyWrite(c->db,c->argv[j]) != NULL) {\n                addReply(c, shared.czero);\n                return;\n            }\n        }\n        setkey_flags |= SETKEY_DOESNT_EXIST;\n    }\n\n    for (j = 1; j < c->argc; j += 2) {\n        c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);\n        setKey(c, c->db, c->argv[j], c->argv[j + 1], setkey_flags);\n        notifyKeyspaceEvent(NOTIFY_STRING,\"set\",c->argv[j],c->db->id);\n    }\n    server.dirty += (c->argc-1)/2;\n    addReply(c, nx ? shared.cone : shared.ok);\n}",
        "func": "void msetGenericCommand(client *c, int nx) {\n    int j;\n\n    if ((c->argc % 2) == 0) {\n        addReplyErrorArity(c);\n        return;\n    }\n\n    /* Handle the NX flag. The MSETNX semantic is to return zero and don't\n     * set anything if at least one key already exists. */\n    if (nx) {\n        for (j = 1; j < c->argc; j += 2) {\n            if (lookupKeyWrite(c->db,c->argv[j]) != NULL) {\n                addReply(c, shared.czero);\n                return;\n            }\n        }\n    }\n\n    for (j = 1; j < c->argc; j += 2) {\n        c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);\n        setKey(c, c->db, c->argv[j], c->argv[j + 1], 0);\n        notifyKeyspaceEvent(NOTIFY_STRING,\"set\",c->argv[j],c->db->id);\n    }\n    server.dirty += (c->argc-1)/2;\n    addReply(c, nx ? shared.cone : shared.ok);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,5 @@\n void msetGenericCommand(client *c, int nx) {\n     int j;\n-    int setkey_flags = 0;\n \n     if ((c->argc % 2) == 0) {\n         addReplyErrorArity(c);\n@@ -16,12 +15,11 @@\n                 return;\n             }\n         }\n-        setkey_flags |= SETKEY_DOESNT_EXIST;\n     }\n \n     for (j = 1; j < c->argc; j += 2) {\n         c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);\n-        setKey(c, c->db, c->argv[j], c->argv[j + 1], setkey_flags);\n+        setKey(c, c->db, c->argv[j], c->argv[j + 1], 0);\n         notifyKeyspaceEvent(NOTIFY_STRING,\"set\",c->argv[j],c->db->id);\n     }\n     server.dirty += (c->argc-1)/2;",
        "diff_line_info": {
            "deleted_lines": [
                "    int setkey_flags = 0;",
                "        setkey_flags |= SETKEY_DOESNT_EXIST;",
                "        setKey(c, c->db, c->argv[j], c->argv[j + 1], setkey_flags);"
            ],
            "added_lines": [
                "        setKey(c, c->db, c->argv[j], c->argv[j + 1], 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-37704",
        "func_name": "zmanda/amanda/main",
        "description": "Amanda 3.5.1 allows privilege escalation from the regular user backup to root. The SUID binary located at /lib/amanda/rundump will execute /usr/sbin/dump as root with controlled arguments from the attacker which may lead to escalation of privileges, denial of service, and information disclosure.",
        "git_url": "https://github.com/zmanda/amanda/commit/43c5b32f46186f3ed78fe6c7503096fa9ad1236c",
        "commit_title": "fix : fix increment logic for good_option",
        "commit_text": " - for arguements of type --file=x or --file x, fixed logic while incrementing value.",
        "func_before": "int\nmain(\n    int\t\targc,\n    char **\targv)\n{\n#ifdef GNUTAR\n    int i;\n    char *e;\n    char *dbf;\n    char *cmdline;\n    GPtrArray *array = g_ptr_array_new();\n    gchar **strings;\n    char **new_argv;\n    char **env;\n    char *my_realpath = NULL;\n#endif\n    int good_option;\n\n    glib_init();\n\n    if (argc > 1 && argv[1] && g_str_equal(argv[1], \"--version\")) {\n\tprintf(\"runtar-%s\\n\", VERSION);\n\treturn (0);\n    }\n\n    /*\n     * Configure program for internationalization:\n     *   1) Only set the message locale for now.\n     *   2) Set textdomain for all amanda related programs to \"amanda\"\n     *      We don't want to be forced to support dozens of message catalogs.\n     */\n    setlocale(LC_MESSAGES, \"C\");\n    textdomain(\"amanda\"); \n\n    safe_fd(-1, 0);\n    safe_cd();\n\n    set_pname(\"runtar\");\n\n    /* Don't die when child closes pipe */\n    signal(SIGPIPE, SIG_IGN);\n\n    dbopen(DBG_SUBDIR_CLIENT);\n    config_init(CONFIG_INIT_CLIENT|CONFIG_INIT_GLOBAL, NULL);\n\n    if (argc < 3) {\n\terror(_(\"Need at least 3 arguments\\n\"));\n\t/*NOTREACHED*/\n    }\n\n    dbprintf(_(\"version %s\\n\"), VERSION);\n\n    if (!g_str_equal(argv[3], \"--create\")) {\n\terror(_(\"Can only be used to create tar archives\\n\"));\n\t/*NOTREACHED*/\n    }\n\n#ifndef GNUTAR\n\n    g_fprintf(stderr,_(\"gnutar not available on this system.\\n\"));\n    dbprintf(_(\"%s: gnutar not available on this system.\\n\"), argv[0]);\n    dbclose();\n    return 1;\n\n#else\n\n    /*\n     * Print out version information for tar.\n     */\n    do {\n\tFILE *\tversion_file;\n\tchar\tversion_buf[80];\n\n\tif ((version_file = popen(GNUTAR \" --version 2>&1\", \"r\")) != NULL) {\n\t    if (fgets(version_buf, (int)sizeof(version_buf), version_file) != NULL) {\n\t\tdbprintf(_(GNUTAR \" version: %s\\n\"), version_buf);\n\t    } else {\n\t\tif (ferror(version_file)) {\n\t\t    dbprintf(_(GNUTAR \" version: Read failure: %s\\n\"), strerror(errno));\n\t\t} else {\n\t\t    dbprintf(_(GNUTAR \" version: Read failure; EOF\\n\"));\n\t\t}\n\t    }\n\t} else {\n\t    dbprintf(_(GNUTAR \" version: unavailable: %s\\n\"), strerror(errno));\n\t}\n    } while(0);\n\n#ifdef WANT_SETUID_CLIENT\n    check_running_as(RUNNING_AS_CLIENT_LOGIN | RUNNING_AS_UID_ONLY);\n    if (!become_root()) {\n\terror(_(\"error [%s could not become root (is the setuid bit set?)]\\n\"), get_pname());\n\t/*NOTREACHED*/\n    }\n#else\n    check_running_as(RUNNING_AS_CLIENT_LOGIN);\n#endif\n\n    /* skip argv[0] */\n    argc--;\n    argv++;\n\n    dbprintf(_(\"config: %s\\n\"), argv[0]);\n    if (!g_str_equal(argv[0], \"NOCONFIG\"))\n\tdbrename(argv[0], DBG_SUBDIR_CLIENT);\n    argc--;\n    argv++;\n\n    new_argv = g_new0(char *, argc+1);\n\n    if (!check_exec_for_suid(\"GNUTAR_PATH\", GNUTAR, stderr, &my_realpath)) {\n\tdbclose();\n\texit(1);\n    }\n    new_argv[0] = g_strdup_printf(\"%s\", argv[0]);\n    g_ptr_array_add(array, g_strdup(my_realpath));\n    good_option = 0;\n    for (i = 1; argv[i]; i++) {\n\tif (good_option <= 0) {\n\t    if (g_str_has_prefix(argv[i],\"--rsh-command\") ||\n\t\tg_str_has_prefix(argv[i],\"--to-command\") ||\n\t\tg_str_has_prefix(argv[i],\"--info-script\") ||\n\t\tg_str_has_prefix(argv[i],\"--new-volume-script\") ||\n\t\tg_str_has_prefix(argv[i],\"--rmt-command\") ||\n\t\tg_str_has_prefix(argv[i],\"--use-compress-program\")) {\n\t\t/* Filter potential malicious option */\n\t\tgood_option = 0;\n\t    } else if (g_str_has_prefix(argv[i],\"--create\") ||\n\t\tg_str_has_prefix(argv[i],\"--totals\") ||\n\t\tg_str_has_prefix(argv[i],\"--dereference\") ||\n\t\tg_str_has_prefix(argv[i],\"--no-recursion\") ||\n\t\tg_str_has_prefix(argv[i],\"--one-file-system\") ||\n\t\tg_str_has_prefix(argv[i],\"--incremental\") ||\n\t\tg_str_has_prefix(argv[i],\"--atime-preserve\") ||\n\t\tg_str_has_prefix(argv[i],\"--sparse\") ||\n\t\tg_str_has_prefix(argv[i],\"--ignore-failed-read\") ||\n\t\tg_str_has_prefix(argv[i],\"--numeric-owner\") ||\n\t\tg_str_has_prefix(argv[i],\"--verbose\")) {\n\t\t/* Accept theses options */\n\t\tgood_option++;\n\t    } else if (g_str_has_prefix(argv[i],\"--blocking-factor\") ||\n\t\tg_str_has_prefix(argv[i],\"--file\") ||\n\t\tg_str_has_prefix(argv[i],\"--directory\") ||\n\t\tg_str_has_prefix(argv[i],\"--exclude\") ||\n\t\tg_str_has_prefix(argv[i],\"--transform\") ||\n\t\tg_str_has_prefix(argv[i],\"--listed-incremental\") ||\n\t\tg_str_has_prefix(argv[i],\"--newer\") ||\n\t\tg_str_has_prefix(argv[i],\"--exclude-from\") ||\n\t\tg_str_has_prefix(argv[i],\"--files-from\")) {\n\t\t/* Accept theses options with the following argument */\n\t\tgood_option += 2;\n\t    } else if (argv[i][0] != '-') {\n\t\tgood_option++;\n\t    }\n\t}\n\tif (good_option <= 0) {\n\t    error(\"error [%s invalid option: %s]\", get_pname(), argv[i]);\n\t}\n        g_ptr_array_add(array, quote_string(argv[i]));\n\tnew_argv[i] = g_strdup_printf(\"%s\", argv[i]);\n\tgood_option--;\n    }\n\n    g_ptr_array_add(array, NULL);\n    strings = (gchar **)g_ptr_array_free(array, FALSE);\n\n    cmdline = g_strjoinv(\" \", strings);\n    g_strfreev(strings);\n\n    dbprintf(_(\"running: %s\\n\"), cmdline);\n    amfree(cmdline);\n\n    dbf = dbfn();\n    if (dbf) {\n\tdbf = g_strdup(dbf);\n    }\n    dbclose();\n\n    env = safe_env();\n    execve(my_realpath, new_argv, env);\n    free_env(env);\n    free_env(new_argv);\n\n    e = strerror(errno);\n    dbreopen(dbf, \"more\");\n    amfree(dbf);\n    dbprintf(_(\"execve of %s failed (%s)\\n\"), my_realpath, e);\n    dbclose();\n\n    g_fprintf(stderr, _(\"runtar: could not exec %s: %s\\n\"), my_realpath, e);\n    g_free(my_realpath);\n    return 1;\n#endif\n}",
        "func": "int\nmain(\n    int\t\targc,\n    char **\targv)\n{\n#ifdef GNUTAR\n    int i;\n    char *e;\n    char *dbf;\n    char *cmdline;\n    GPtrArray *array = g_ptr_array_new();\n    gchar **strings;\n    char **new_argv;\n    char **env;\n    char *my_realpath = NULL;\n#endif\n    int good_option;\n\n    glib_init();\n\n    if (argc > 1 && argv[1] && g_str_equal(argv[1], \"--version\")) {\n\tprintf(\"runtar-%s\\n\", VERSION);\n\treturn (0);\n    }\n\n    /*\n     * Configure program for internationalization:\n     *   1) Only set the message locale for now.\n     *   2) Set textdomain for all amanda related programs to \"amanda\"\n     *      We don't want to be forced to support dozens of message catalogs.\n     */\n    setlocale(LC_MESSAGES, \"C\");\n    textdomain(\"amanda\"); \n\n    safe_fd(-1, 0);\n    safe_cd();\n\n    set_pname(\"runtar\");\n\n    /* Don't die when child closes pipe */\n    signal(SIGPIPE, SIG_IGN);\n\n    dbopen(DBG_SUBDIR_CLIENT);\n    config_init(CONFIG_INIT_CLIENT|CONFIG_INIT_GLOBAL, NULL);\n\n    if (argc < 3) {\n\terror(_(\"Need at least 3 arguments\\n\"));\n\t/*NOTREACHED*/\n    }\n\n    dbprintf(_(\"version %s\\n\"), VERSION);\n\n    if (!g_str_equal(argv[3], \"--create\")) {\n\terror(_(\"Can only be used to create tar archives\\n\"));\n\t/*NOTREACHED*/\n    }\n\n#ifndef GNUTAR\n\n    g_fprintf(stderr,_(\"gnutar not available on this system.\\n\"));\n    dbprintf(_(\"%s: gnutar not available on this system.\\n\"), argv[0]);\n    dbclose();\n    return 1;\n\n#else\n\n    /*\n     * Print out version information for tar.\n     */\n    do {\n\tFILE *\tversion_file;\n\tchar\tversion_buf[80];\n\n\tif ((version_file = popen(GNUTAR \" --version 2>&1\", \"r\")) != NULL) {\n\t    if (fgets(version_buf, (int)sizeof(version_buf), version_file) != NULL) {\n\t\tdbprintf(_(GNUTAR \" version: %s\\n\"), version_buf);\n\t    } else {\n\t\tif (ferror(version_file)) {\n\t\t    dbprintf(_(GNUTAR \" version: Read failure: %s\\n\"), strerror(errno));\n\t\t} else {\n\t\t    dbprintf(_(GNUTAR \" version: Read failure; EOF\\n\"));\n\t\t}\n\t    }\n\t} else {\n\t    dbprintf(_(GNUTAR \" version: unavailable: %s\\n\"), strerror(errno));\n\t}\n    } while(0);\n\n#ifdef WANT_SETUID_CLIENT\n    check_running_as(RUNNING_AS_CLIENT_LOGIN | RUNNING_AS_UID_ONLY);\n    if (!become_root()) {\n\terror(_(\"error [%s could not become root (is the setuid bit set?)]\\n\"), get_pname());\n\t/*NOTREACHED*/\n    }\n#else\n    check_running_as(RUNNING_AS_CLIENT_LOGIN);\n#endif\n\n    /* skip argv[0] */\n    argc--;\n    argv++;\n\n    dbprintf(_(\"config: %s\\n\"), argv[0]);\n    if (!g_str_equal(argv[0], \"NOCONFIG\"))\n\tdbrename(argv[0], DBG_SUBDIR_CLIENT);\n    argc--;\n    argv++;\n\n    new_argv = g_new0(char *, argc+1);\n\n    if (!check_exec_for_suid(\"GNUTAR_PATH\", GNUTAR, stderr, &my_realpath)) {\n\tdbclose();\n\texit(1);\n    }\n    new_argv[0] = g_strdup_printf(\"%s\", argv[0]);\n    g_ptr_array_add(array, g_strdup(my_realpath));\n    good_option = 0;\n    for (i = 1; argv[i]; i++) {\n\tif (good_option <= 0) {\n\t    if (g_str_has_prefix(argv[i],\"--rsh-command\") ||\n\t\tg_str_has_prefix(argv[i],\"--to-command\") ||\n\t\tg_str_has_prefix(argv[i],\"--info-script\") ||\n\t\tg_str_has_prefix(argv[i],\"--new-volume-script\") ||\n\t\tg_str_has_prefix(argv[i],\"--rmt-command\") ||\n\t\tg_str_has_prefix(argv[i],\"--use-compress-program\")) {\n\t\t/* Filter potential malicious option */\n\t\tgood_option = 0;\n\t    } else if (g_str_has_prefix(argv[i],\"--create\") ||\n\t\tg_str_has_prefix(argv[i],\"--totals\") ||\n\t\tg_str_has_prefix(argv[i],\"--dereference\") ||\n\t\tg_str_has_prefix(argv[i],\"--no-recursion\") ||\n\t\tg_str_has_prefix(argv[i],\"--one-file-system\") ||\n\t\tg_str_has_prefix(argv[i],\"--incremental\") ||\n\t\tg_str_has_prefix(argv[i],\"--atime-preserve\") ||\n\t\tg_str_has_prefix(argv[i],\"--sparse\") ||\n\t\tg_str_has_prefix(argv[i],\"--ignore-failed-read\") ||\n\t\tg_str_has_prefix(argv[i],\"--numeric-owner\") ||\n\t\tg_str_has_prefix(argv[i],\"--verbose\")) {\n\t\t/* Accept theses options */\n\t\tgood_option++;\n\t    } else if (g_str_has_prefix(argv[i],\"--blocking-factor\") ||\n\t\tg_str_has_prefix(argv[i],\"--file\") ||\n\t\tg_str_has_prefix(argv[i],\"--directory\") ||\n\t\tg_str_has_prefix(argv[i],\"--exclude\") ||\n\t\tg_str_has_prefix(argv[i],\"--transform\") ||\n\t\tg_str_has_prefix(argv[i],\"--listed-incremental\") ||\n\t\tg_str_has_prefix(argv[i],\"--newer\") ||\n\t\tg_str_has_prefix(argv[i],\"--exclude-from\") ||\n\t\tg_str_has_prefix(argv[i],\"--files-from\")) {\n\t\tgood_option++;\n\t    } else if (argv[i][0] != '-') {\n\t\t/* argument values are accounted for here */\n\t\tgood_option++;\n\t    }\n\t}\n\tif (good_option <= 0) {\n\t    error(\"error [%s invalid option: %s]\", get_pname(), argv[i]);\n\t}\n        g_ptr_array_add(array, quote_string(argv[i]));\n\tnew_argv[i] = g_strdup_printf(\"%s\", argv[i]);\n\tgood_option--;\n    }\n\n    g_ptr_array_add(array, NULL);\n    strings = (gchar **)g_ptr_array_free(array, FALSE);\n\n    cmdline = g_strjoinv(\" \", strings);\n    g_strfreev(strings);\n\n    dbprintf(_(\"running: %s\\n\"), cmdline);\n    amfree(cmdline);\n\n    dbf = dbfn();\n    if (dbf) {\n\tdbf = g_strdup(dbf);\n    }\n    dbclose();\n\n    env = safe_env();\n    execve(my_realpath, new_argv, env);\n    free_env(env);\n    free_env(new_argv);\n\n    e = strerror(errno);\n    dbreopen(dbf, \"more\");\n    amfree(dbf);\n    dbprintf(_(\"execve of %s failed (%s)\\n\"), my_realpath, e);\n    dbclose();\n\n    g_fprintf(stderr, _(\"runtar: could not exec %s: %s\\n\"), my_realpath, e);\n    g_free(my_realpath);\n    return 1;\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -147,9 +147,9 @@\n \t\tg_str_has_prefix(argv[i],\"--newer\") ||\n \t\tg_str_has_prefix(argv[i],\"--exclude-from\") ||\n \t\tg_str_has_prefix(argv[i],\"--files-from\")) {\n-\t\t/* Accept theses options with the following argument */\n-\t\tgood_option += 2;\n+\t\tgood_option++;\n \t    } else if (argv[i][0] != '-') {\n+\t\t/* argument values are accounted for here */\n \t\tgood_option++;\n \t    }\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t/* Accept theses options with the following argument */",
                "\t\tgood_option += 2;"
            ],
            "added_lines": [
                "\t\tgood_option++;",
                "\t\t/* argument values are accounted for here */"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-37704",
        "func_name": "zmanda/amanda/main",
        "description": "Amanda 3.5.1 allows privilege escalation from the regular user backup to root. The SUID binary located at /lib/amanda/rundump will execute /usr/sbin/dump as root with controlled arguments from the attacker which may lead to escalation of privileges, denial of service, and information disclosure.",
        "git_url": "https://github.com/zmanda/amanda/commit/e890d08e16ea0621966a7ae35cce53ccb44a472e",
        "commit_title": "CVE-2022-37704 - privilege escaltion form amandabackup user to root -fix",
        "commit_text": "",
        "func_before": "int\nmain(\n    int\t\targc,\n    char **\targv)\n{\n#ifndef ERRMSG\n    char *dump_program;\n    int i;\n    char *e;\n    char *cmdline;\n    GPtrArray *array = g_ptr_array_new();\n    gchar **strings;\n    char  **env;\n#endif /* ERRMSG */\n\n    glib_init();\n\n    if (argc > 1 && argv[1] && g_str_equal(argv[1], \"--version\")) {\n\tprintf(\"rundump-%s\\n\", VERSION);\n\treturn (0);\n    }\n\n    /*\n     * Configure program for internationalization:\n     *   1) Only set the message locale for now.\n     *   2) Set textdomain for all amanda related programs to \"amanda\"\n     *      We don't want to be forced to support dozens of message catalogs.\n     */  \n    setlocale(LC_MESSAGES, \"C\");\n    textdomain(\"amanda\"); \n\n    safe_fd(-1, 0);\n    safe_cd();\n\n    set_pname(\"rundump\");\n\n    /* Don't die when child closes pipe */\n    signal(SIGPIPE, SIG_IGN);\n\n    dbopen(DBG_SUBDIR_CLIENT);\n    config_init(CONFIG_INIT_CLIENT|CONFIG_INIT_GLOBAL, NULL);\n\n    if (argc < 3) {\n\terror(_(\"Need at least 3 arguments\\n\"));\n\t/*NOTREACHED*/\n    }\n\n    dbprintf(_(\"version %s\\n\"), VERSION);\n\n#ifdef ERRMSG\t\t\t\t\t\t\t/* { */\n\n    g_fprintf(stderr, ERRMSG);\n    dbprintf(\"%s: %s\", argv[0], ERRMSG);\n    dbclose();\n    return 1;\n\n#else\t\t\t\t\t\t\t\t/* } { */\n\n#ifdef WANT_SETUID_CLIENT\n    check_running_as(RUNNING_AS_CLIENT_LOGIN | RUNNING_AS_UID_ONLY);\n    if (!become_root()) {\n\terror(_(\"error [%s could not become root (is the setuid bit set?)]\\n\"), get_pname());\n\t/*NOTREACHED*/\n    }\n#else\n    check_running_as(RUNNING_AS_CLIENT_LOGIN);\n#endif\n\n    /* skip argv[0] */\n    argc--;\n    argv++;\n\n    dbprintf(_(\"config: %s\\n\"), argv[0]);\n    if (!g_str_equal(argv[0], \"NOCONFIG\"))\n\tdbrename(argv[0], DBG_SUBDIR_CLIENT);\n    argc--;\n    argv++;\n\n#ifdef XFSDUMP\n\n    if (g_str_equal(argv[0], \"xfsdump\"))\n        dump_program = XFSDUMP;\n    else /* strcmp(argv[0], \"xfsdump\") != 0 */\n\n#endif\n\n#ifdef VXDUMP\n\n    if (g_str_equal(argv[0], \"vxdump\"))\n        dump_program = VXDUMP;\n    else /* strcmp(argv[0], \"vxdump\") != 0 */\n\n#endif\n\n#ifdef VDUMP\n\n    if (g_str_equal(argv[0], \"vdump\"))\n\tdump_program = VDUMP;\n    else /* strcmp(argv[0], \"vdump\") != 0 */\n\n#endif\n\n#if defined(DUMP)\n        dump_program = DUMP;\n#else\n# if defined(XFSDUMP)\n        dump_program = XFSDUMP;\n# else\n#  if defined(VXDUMP)\n\tdump_program = VXDUMP;\n#  else\n        dump_program = \"dump\";\n#  endif\n# endif\n#endif\n\n\n    /*\n     * Build the array\n     */\n\n    g_ptr_array_add(array, g_strdup(dump_program));\n\n    for (i = 1; argv[i]; i++)\n        g_ptr_array_add(array, quote_string(argv[i]));\n\n    g_ptr_array_add(array, NULL);\n    strings = (gchar **)g_ptr_array_free(array, FALSE);\n\n    cmdline = g_strjoinv(\" \", strings);\n    g_strfreev(strings);\n\n    dbprintf(_(\"running: %s\\n\"), cmdline);\n    amfree(cmdline);\n\n    env = safe_env();\n    execve(dump_program, argv, env);\n    free_env(env);\n\n    e = strerror(errno);\n    dbprintf(_(\"failed (%s)\\n\"), e);\n    dbclose();\n\n    g_fprintf(stderr, _(\"rundump: could not exec %s: %s\\n\"), dump_program, e);\n    return 1;\n#endif\t\t\t\t\t\t\t\t/* } */\n}",
        "func": "int\nmain(\n    int\t\targc,\n    char **\targv)\n{\n#ifndef ERRMSG\n    char *dump_program;\n    int i;\n    char *e;\n    char *cmdline;\n    GPtrArray *array = g_ptr_array_new();\n    gchar **strings;\n    char  **env;\n#endif /* ERRMSG */\n\n    glib_init();\n\n    if (argc > 1 && argv[1] && g_str_equal(argv[1], \"--version\")) {\n\tprintf(\"rundump-%s\\n\", VERSION);\n\treturn (0);\n    }\n\n    /*\n     * Configure program for internationalization:\n     *   1) Only set the message locale for now.\n     *   2) Set textdomain for all amanda related programs to \"amanda\"\n     *      We don't want to be forced to support dozens of message catalogs.\n     */  \n    setlocale(LC_MESSAGES, \"C\");\n    textdomain(\"amanda\"); \n\n    safe_fd(-1, 0);\n    safe_cd();\n\n    set_pname(\"rundump\");\n\n    /* Don't die when child closes pipe */\n    signal(SIGPIPE, SIG_IGN);\n\n    dbopen(DBG_SUBDIR_CLIENT);\n    config_init(CONFIG_INIT_CLIENT|CONFIG_INIT_GLOBAL, NULL);\n\n    if (argc < 3) {\n\terror(_(\"Need at least 3 arguments\\n\"));\n\t/*NOTREACHED*/\n    }\n\n    dbprintf(_(\"version %s\\n\"), VERSION);\n\n#ifdef ERRMSG\t\t\t\t\t\t\t/* { */\n\n    g_fprintf(stderr, ERRMSG);\n    dbprintf(\"%s: %s\", argv[0], ERRMSG);\n    dbclose();\n    return 1;\n\n#else\t\t\t\t\t\t\t\t/* } { */\n\n#ifdef WANT_SETUID_CLIENT\n    check_running_as(RUNNING_AS_CLIENT_LOGIN | RUNNING_AS_UID_ONLY);\n    if (!become_root()) {\n\terror(_(\"error [%s could not become root (is the setuid bit set?)]\\n\"), get_pname());\n\t/*NOTREACHED*/\n    }\n#else\n    check_running_as(RUNNING_AS_CLIENT_LOGIN);\n#endif\n\n    /* skip argv[0] */\n    argc--;\n    argv++;\n\n    dbprintf(_(\"config: %s\\n\"), argv[0]);\n    if (!g_str_equal(argv[0], \"NOCONFIG\"))\n\tdbrename(argv[0], DBG_SUBDIR_CLIENT);\n    argc--;\n    argv++;\n\n#ifdef XFSDUMP\n\n    if (g_str_equal(argv[0], \"xfsdump\"))\n        dump_program = XFSDUMP;\n    else /* strcmp(argv[0], \"xfsdump\") != 0 */\n\n#endif\n\n#ifdef VXDUMP\n\n    if (g_str_equal(argv[0], \"vxdump\"))\n        dump_program = VXDUMP;\n    else /* strcmp(argv[0], \"vxdump\") != 0 */\n\n#endif\n\n#ifdef VDUMP\n\n    if (g_str_equal(argv[0], \"vdump\"))\n\tdump_program = VDUMP;\n    else /* strcmp(argv[0], \"vdump\") != 0 */\n\n#endif\n\n#if defined(DUMP)\n        dump_program = DUMP;\n        validate_dump_option(argc, argv);\n#else\n# if defined(XFSDUMP)\n        dump_program = XFSDUMP;\n        validate_xfsdump_options(argc, argv);\n# else\n#  if defined(VXDUMP)\n\tdump_program = VXDUMP;\n#  else\n        dump_program = \"dump\";\n        validate_dump_option(argc, argv);\n#  endif\n# endif\n#endif\n\n\n    /*\n     * Build the array\n     */\n\n    g_ptr_array_add(array, g_strdup(dump_program));\n\n    for (i = 1; argv[i]; i++)\n        g_ptr_array_add(array, quote_string(argv[i]));\n\n    g_ptr_array_add(array, NULL);\n    strings = (gchar **)g_ptr_array_free(array, FALSE);\n\n    cmdline = g_strjoinv(\" \", strings);\n    g_strfreev(strings);\n\n    dbprintf(_(\"running: %s\\n\"), cmdline);\n    amfree(cmdline);\n\n    env = safe_env();\n    execve(dump_program, argv, env);\n    free_env(env);\n\n    e = strerror(errno);\n    dbprintf(_(\"failed (%s)\\n\"), e);\n    dbclose();\n\n    g_fprintf(stderr, _(\"rundump: could not exec %s: %s\\n\"), dump_program, e);\n    return 1;\n#endif\t\t\t\t\t\t\t\t/* } */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -102,14 +102,17 @@\n \n #if defined(DUMP)\n         dump_program = DUMP;\n+        validate_dump_option(argc, argv);\n #else\n # if defined(XFSDUMP)\n         dump_program = XFSDUMP;\n+        validate_xfsdump_options(argc, argv);\n # else\n #  if defined(VXDUMP)\n \tdump_program = VXDUMP;\n #  else\n         dump_program = \"dump\";\n+        validate_dump_option(argc, argv);\n #  endif\n # endif\n #endif",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        validate_dump_option(argc, argv);",
                "        validate_xfsdump_options(argc, argv);",
                "        validate_dump_option(argc, argv);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-37704",
        "func_name": "zmanda/amanda/main",
        "description": "Amanda 3.5.1 allows privilege escalation from the regular user backup to root. The SUID binary located at /lib/amanda/rundump will execute /usr/sbin/dump as root with controlled arguments from the attacker which may lead to escalation of privileges, denial of service, and information disclosure.",
        "git_url": "https://github.com/zmanda/amanda/commit/b930189c06290a23aba177687b2f123590323be1",
        "commit_title": "Update the fix for CVE-2022-37704",
        "commit_text": " In the case of xfsdump(8), the check for dump(8) options was invoked instead of the check for the xfsdump(8). This broke legitimate use of xfsdump, while leaving the vulnerability open.",
        "func_before": "int\nmain(\n    int\t\targc,\n    char **\targv)\n{\n#ifndef ERRMSG\n    char *dump_program;\n    int i;\n    char *e;\n    char *cmdline;\n    GPtrArray *array = g_ptr_array_new();\n    gchar **strings;\n    char  **env;\n#endif /* ERRMSG */\n\n    glib_init();\n\n    if (argc > 1 && argv[1] && g_str_equal(argv[1], \"--version\")) {\n\tprintf(\"rundump-%s\\n\", VERSION);\n\treturn (0);\n    }\n\n    /*\n     * Configure program for internationalization:\n     *   1) Only set the message locale for now.\n     *   2) Set textdomain for all amanda related programs to \"amanda\"\n     *      We don't want to be forced to support dozens of message catalogs.\n     */  \n    setlocale(LC_MESSAGES, \"C\");\n    textdomain(\"amanda\"); \n\n    safe_fd(-1, 0);\n    safe_cd();\n\n    set_pname(\"rundump\");\n\n    /* Don't die when child closes pipe */\n    signal(SIGPIPE, SIG_IGN);\n\n    dbopen(DBG_SUBDIR_CLIENT);\n    config_init(CONFIG_INIT_CLIENT|CONFIG_INIT_GLOBAL, NULL);\n\n    if (argc < 3) {\n\terror(_(\"Need at least 3 arguments\\n\"));\n\t/*NOTREACHED*/\n    }\n\n    dbprintf(_(\"version %s\\n\"), VERSION);\n\n#ifdef ERRMSG\t\t\t\t\t\t\t/* { */\n\n    g_fprintf(stderr, ERRMSG);\n    dbprintf(\"%s: %s\", argv[0], ERRMSG);\n    dbclose();\n    return 1;\n\n#else\t\t\t\t\t\t\t\t/* } { */\n\n#ifdef WANT_SETUID_CLIENT\n    check_running_as(RUNNING_AS_CLIENT_LOGIN | RUNNING_AS_UID_ONLY);\n    if (!become_root()) {\n\terror(_(\"error [%s could not become root (is the setuid bit set?)]\\n\"), get_pname());\n\t/*NOTREACHED*/\n    }\n#else\n    check_running_as(RUNNING_AS_CLIENT_LOGIN);\n#endif\n\n    /* skip argv[0] */\n    argc--;\n    argv++;\n\n    dbprintf(_(\"config: %s\\n\"), argv[0]);\n    if (!g_str_equal(argv[0], \"NOCONFIG\"))\n\tdbrename(argv[0], DBG_SUBDIR_CLIENT);\n    argc--;\n    argv++;\n\n#ifdef XFSDUMP\n\n    if (g_str_equal(argv[0], \"xfsdump\"))\n        dump_program = XFSDUMP;\n    else /* strcmp(argv[0], \"xfsdump\") != 0 */\n\n#endif\n\n#ifdef VXDUMP\n\n    if (g_str_equal(argv[0], \"vxdump\"))\n        dump_program = VXDUMP;\n    else /* strcmp(argv[0], \"vxdump\") != 0 */\n\n#endif\n\n#ifdef VDUMP\n\n    if (g_str_equal(argv[0], \"vdump\"))\n\tdump_program = VDUMP;\n    else /* strcmp(argv[0], \"vdump\") != 0 */\n\n#endif\n\n#if defined(DUMP)\n        dump_program = DUMP;\n        validate_dump_option(argc, argv);\n#else\n# if defined(XFSDUMP)\n        dump_program = XFSDUMP;\n        validate_xfsdump_options(argc, argv);\n# else\n#  if defined(VXDUMP)\n\tdump_program = VXDUMP;\n#  else\n        dump_program = \"dump\";\n        validate_dump_option(argc, argv);\n#  endif\n# endif\n#endif\n\n\n    /*\n     * Build the array\n     */\n\n    g_ptr_array_add(array, g_strdup(dump_program));\n\n    for (i = 1; argv[i]; i++)\n        g_ptr_array_add(array, quote_string(argv[i]));\n\n    g_ptr_array_add(array, NULL);\n    strings = (gchar **)g_ptr_array_free(array, FALSE);\n\n    cmdline = g_strjoinv(\" \", strings);\n    g_strfreev(strings);\n\n    dbprintf(_(\"running: %s\\n\"), cmdline);\n    amfree(cmdline);\n\n    env = safe_env();\n    //Filter or Discard RSH Environmental variable\n    int env_count = 0;\n    for (int i = 0; env[i] != NULL; i++){\n        env_count++;\n    }\n    for (int i = 0; i < env_count; i++){\n        if (strncmp(env[i], \"RSH=\", 4) == 0){\n            // Remove RSH\n            g_free(env[i]);\n            // move array elements one step left - which are after \"RSH\"\n            for (int j = i; j < env_count; j++){\n                env[j] = env[j + 1];\n            }\n            //decrease the variable count\n            env[env_count-1] = NULL;\n            break;\n        }\n    }\n    execve(dump_program, argv, env);\n    free_env(env);\n\n    e = strerror(errno);\n    dbprintf(_(\"failed (%s)\\n\"), e);\n    dbclose();\n\n    g_fprintf(stderr, _(\"rundump: could not exec %s: %s\\n\"), dump_program, e);\n    return 1;\n#endif\t\t\t\t\t\t\t\t/* } */\n}",
        "func": "int\nmain(\n    int\t\targc,\n    char **\targv)\n{\n#ifndef ERRMSG\n    char *dump_program;\n    int i;\n    char *e;\n    char *cmdline;\n    GPtrArray *array = g_ptr_array_new();\n    gchar **strings;\n    char  **env;\n#endif /* ERRMSG */\n\n    glib_init();\n\n    if (argc > 1 && argv[1] && g_str_equal(argv[1], \"--version\")) {\n\tprintf(\"rundump-%s\\n\", VERSION);\n\treturn (0);\n    }\n\n    /*\n     * Configure program for internationalization:\n     *   1) Only set the message locale for now.\n     *   2) Set textdomain for all amanda related programs to \"amanda\"\n     *      We don't want to be forced to support dozens of message catalogs.\n     */  \n    setlocale(LC_MESSAGES, \"C\");\n    textdomain(\"amanda\"); \n\n    safe_fd(-1, 0);\n    safe_cd();\n\n    set_pname(\"rundump\");\n\n    /* Don't die when child closes pipe */\n    signal(SIGPIPE, SIG_IGN);\n\n    dbopen(DBG_SUBDIR_CLIENT);\n    config_init(CONFIG_INIT_CLIENT|CONFIG_INIT_GLOBAL, NULL);\n\n    if (argc < 3) {\n\terror(_(\"Need at least 3 arguments\\n\"));\n\t/*NOTREACHED*/\n    }\n\n    dbprintf(_(\"version %s\\n\"), VERSION);\n\n#ifdef ERRMSG\t\t\t\t\t\t\t/* { */\n\n    g_fprintf(stderr, ERRMSG);\n    dbprintf(\"%s: %s\", argv[0], ERRMSG);\n    dbclose();\n    return 1;\n\n#else\t\t\t\t\t\t\t\t/* } { */\n\n#ifdef WANT_SETUID_CLIENT\n    check_running_as(RUNNING_AS_CLIENT_LOGIN | RUNNING_AS_UID_ONLY);\n    if (!become_root()) {\n\terror(_(\"error [%s could not become root (is the setuid bit set?)]\\n\"), get_pname());\n\t/*NOTREACHED*/\n    }\n#else\n    check_running_as(RUNNING_AS_CLIENT_LOGIN);\n#endif\n\n    /* skip argv[0] */\n    argc--;\n    argv++;\n\n    dbprintf(_(\"config: %s\\n\"), argv[0]);\n    if (!g_str_equal(argv[0], \"NOCONFIG\"))\n\tdbrename(argv[0], DBG_SUBDIR_CLIENT);\n    argc--;\n    argv++;\n\n#ifdef XFSDUMP\n\n    if (g_str_equal(argv[0], \"xfsdump\")) {\n        dump_program = XFSDUMP;\n        validate_xfsdump_options(argc, argv);\n    } else /* strcmp(argv[0], \"xfsdump\") != 0 */\n\n#endif\n\n#ifdef VXDUMP\n\n    if (g_str_equal(argv[0], \"vxdump\"))\n        dump_program = VXDUMP;\n    else /* strcmp(argv[0], \"vxdump\") != 0 */\n\n#endif\n\n#ifdef VDUMP\n\n    if (g_str_equal(argv[0], \"vdump\"))\n\tdump_program = VDUMP;\n    else /* strcmp(argv[0], \"vdump\") != 0 */\n\n#endif\n\n      {\n#if defined(DUMP)\n        dump_program = DUMP;\n        validate_dump_option(argc, argv);\n#else\n# if defined(XFSDUMP)\n        dump_program = XFSDUMP;\n        validate_xfsdump_options(argc, argv);\n# else\n#  if defined(VXDUMP)\n\tdump_program = VXDUMP;\n#  else\n        dump_program = \"dump\";\n        validate_dump_option(argc, argv);\n#  endif\n# endif\n#endif\n      }\n\n\n    /*\n     * Build the array\n     */\n\n    g_ptr_array_add(array, g_strdup(dump_program));\n\n    for (i = 1; argv[i]; i++)\n        g_ptr_array_add(array, quote_string(argv[i]));\n\n    g_ptr_array_add(array, NULL);\n    strings = (gchar **)g_ptr_array_free(array, FALSE);\n\n    cmdline = g_strjoinv(\" \", strings);\n    g_strfreev(strings);\n\n    dbprintf(_(\"running: %s\\n\"), cmdline);\n    amfree(cmdline);\n\n    env = safe_env();\n    //Filter or Discard RSH Environmental variable\n    int env_count = 0;\n    for (int i = 0; env[i] != NULL; i++){\n        env_count++;\n    }\n    for (int i = 0; i < env_count; i++){\n        if (strncmp(env[i], \"RSH=\", 4) == 0){\n            // Remove RSH\n            g_free(env[i]);\n            // move array elements one step left - which are after \"RSH\"\n            for (int j = i; j < env_count; j++){\n                env[j] = env[j + 1];\n            }\n            //decrease the variable count\n            env[env_count-1] = NULL;\n            break;\n        }\n    }\n    execve(dump_program, argv, env);\n    free_env(env);\n\n    e = strerror(errno);\n    dbprintf(_(\"failed (%s)\\n\"), e);\n    dbclose();\n\n    g_fprintf(stderr, _(\"rundump: could not exec %s: %s\\n\"), dump_program, e);\n    return 1;\n#endif\t\t\t\t\t\t\t\t/* } */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -78,9 +78,10 @@\n \n #ifdef XFSDUMP\n \n-    if (g_str_equal(argv[0], \"xfsdump\"))\n+    if (g_str_equal(argv[0], \"xfsdump\")) {\n         dump_program = XFSDUMP;\n-    else /* strcmp(argv[0], \"xfsdump\") != 0 */\n+        validate_xfsdump_options(argc, argv);\n+    } else /* strcmp(argv[0], \"xfsdump\") != 0 */\n \n #endif\n \n@@ -100,6 +101,7 @@\n \n #endif\n \n+      {\n #if defined(DUMP)\n         dump_program = DUMP;\n         validate_dump_option(argc, argv);\n@@ -116,6 +118,7 @@\n #  endif\n # endif\n #endif\n+      }\n \n \n     /*",
        "diff_line_info": {
            "deleted_lines": [
                "    if (g_str_equal(argv[0], \"xfsdump\"))",
                "    else /* strcmp(argv[0], \"xfsdump\") != 0 */"
            ],
            "added_lines": [
                "    if (g_str_equal(argv[0], \"xfsdump\")) {",
                "        validate_xfsdump_options(argc, argv);",
                "    } else /* strcmp(argv[0], \"xfsdump\") != 0 */",
                "      {",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-34153",
        "func_name": "ImageMagick/WriteVIDEOImage",
        "description": "A vulnerability was found in ImageMagick. This security flaw causes a shell command injection vulnerability via video:vsync or video:pixel-format options in VIDEO encoding/decoding.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/d31c80d15a2c82fc1dd8e889e0f97b0219079a57",
        "commit_title": "Make sure options are properly quoted to resolve the issue reported in #6338.",
        "commit_text": "",
        "func_before": "static MagickBooleanType WriteVIDEOImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    basename[MagickPathExtent],\n    filename[MagickPathExtent];\n\n  const char\n    *intermediate_format;\n\n  const DelegateInfo\n    *delegate_info;\n\n  double\n    delay;\n\n  Image\n    *clone_images;\n\n  ImageInfo\n    *write_info;\n\n  int\n    file;\n\n  MagickBooleanType\n    status;\n\n  Image\n    *p;\n\n  ssize_t\n    i;\n\n  size_t\n    count,\n    length,\n    scene;\n\n  unsigned char\n    *blob;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  /*\n    Write intermediate files.\n  */\n  clone_images=CloneImageList(image,exception);\n  if (clone_images == (Image *) NULL)\n    return(MagickFalse);\n  file=AcquireUniqueFileResource(basename);\n  if (file != -1)\n    file=close(file)-1;\n  (void) FormatLocaleString(clone_images->filename,MagickPathExtent,\"%s\",\n    basename);\n  count=0;\n  write_info=CloneImageInfo(image_info);\n  write_info->file=(FILE *) NULL;\n  *write_info->magick='\\0';\n  status=MagickTrue;\n  intermediate_format=GetIntermediateFormat(image_info);\n  for (p=clone_images; p != (Image *) NULL; p=GetNextImageInList(p))\n  {\n    char\n      previous_image[MagickPathExtent];\n\n    blob=(unsigned char *) NULL;\n    length=0;\n    scene=p->scene;\n    delay=100.0*p->delay/MagickMax(1.0*p->ticks_per_second,1.0);\n    for (i=0; i < (ssize_t) MagickMax((1.0*delay+1.0)/3.0,1.0); i++)\n    {\n      p->scene=count;\n      count++;\n      status=MagickFalse;\n      switch (i)\n      {\n        case 0:\n        {\n          Image\n            *frame;\n\n          (void) FormatLocaleString(p->filename,MagickPathExtent,\"%s%.20g.%s\",\n            basename,(double) p->scene,intermediate_format);\n          (void) FormatLocaleString(filename,MagickPathExtent,\"%s%.20g.%s\",\n            basename,(double) p->scene,intermediate_format);\n          (void) FormatLocaleString(previous_image,MagickPathExtent,\n            \"%s%.20g.%s\",basename,(double) p->scene,intermediate_format);\n          frame=CloneImage(p,0,0,MagickTrue,exception);\n          if (frame == (Image *) NULL)\n            break;\n          status=WriteImage(write_info,frame,exception);\n          frame=DestroyImage(frame);\n          break;\n        }\n        case 1:\n        {\n          blob=(unsigned char *) FileToBlob(previous_image,~0UL,&length,\n            exception);\n          magick_fallthrough;\n        }\n        default:\n        {\n          (void) FormatLocaleString(filename,MagickPathExtent,\"%s%.20g.%s\",\n            basename,(double) p->scene,intermediate_format);\n          if (length > 0)\n            status=BlobToFile(filename,blob,length,exception);\n          break;\n        }\n      }\n      if (image->debug != MagickFalse)\n        {\n          if (status != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"%.20g. Wrote %s file for scene %.20g:\",(double) i,\n              intermediate_format,(double) p->scene);\n          else\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"%.20g. Failed to write %s file for scene %.20g:\",(double) i,\n              intermediate_format,(double) p->scene);\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"%s\",filename);\n        }\n    }\n    p->scene=scene;\n    if (blob != (unsigned char *) NULL)\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n    if (status == MagickFalse)\n      break;\n  }\n  /*\n    Convert PAM to VIDEO.\n  */\n  delegate_info=GetDelegateInfo((char *) NULL,\"video:encode\",exception);\n  if (delegate_info != (const DelegateInfo *) NULL)\n    {\n      char\n        command[MagickPathExtent],\n        message[MagickPathExtent];\n\n      char\n        *options,\n        *sanitized_option;\n\n      const char\n        *option;\n\n      int\n        exit_code;\n\n      options=AcquireString(\"\");\n      (void) FormatLocaleString(options,MagickPathExtent,\"-plays %i\",\n        (int) clone_images->iterations);\n      option=GetImageOption(image_info,\"video:pixel-format\");\n      if (option != (const char *) NULL)\n        {\n          sanitized_option=SanitizeDelegateString(option);\n          (void) FormatLocaleString(command,MagickPathExtent,\" -pix_fmt %s\",\n            sanitized_option);\n          DestroyString(sanitized_option);\n          (void) ConcatenateMagickString(options,command,MagickPathExtent);\n        }\n      AcquireUniqueFilename(write_info->unique);\n      (void) FormatLocaleString(command,MagickPathExtent,\n        GetDelegateCommands(delegate_info),basename,intermediate_format,\n        options,write_info->unique,image_info->magick);\n      options=DestroyString(options);\n      exit_code=ExternalDelegateCommand(MagickFalse,image_info->verbose,\n        command,message,exception);\n      status=exit_code == 0 ? MagickTrue : MagickFalse;\n      if (status != MagickFalse)\n        {\n          (void) FormatLocaleString(filename,MagickPathExtent,\"%s.%s\",\n            write_info->unique,image_info->magick);\n          status=CopyDelegateFile(filename,image->filename);\n          (void) RelinquishUniqueFileResource(filename);\n        }\n      else if (*message != '\\0')\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            DelegateError,\"VideoDelegateFailed\",\"`%s'\",message);\n        }\n      (void) RelinquishUniqueFileResource(write_info->unique);\n  }\n  write_info=DestroyImageInfo(write_info);\n  /*\n    Relinquish resources.\n  */\n  count=0;\n  for (p=clone_images; p != (Image *) NULL; p=GetNextImageInList(p))\n  {\n    delay=100.0*p->delay/MagickMax(1.0*p->ticks_per_second,1.0);\n    for (i=0; i < (ssize_t) MagickMax((1.0*delay+1.0)/3.0,1.0); i++)\n    {\n      (void) FormatLocaleString(p->filename,MagickPathExtent,\"%s%.20g.%s\",\n        basename,(double) count++,intermediate_format);\n      (void) RelinquishUniqueFileResource(p->filename);\n    }\n    (void) CopyMagickString(p->filename,image_info->filename,MagickPathExtent);\n  }\n  (void) RelinquishUniqueFileResource(basename);\n  clone_images=DestroyImageList(clone_images);\n  return(status);\n}",
        "func": "static MagickBooleanType WriteVIDEOImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    basename[MagickPathExtent],\n    filename[MagickPathExtent];\n\n  const char\n    *intermediate_format;\n\n  const DelegateInfo\n    *delegate_info;\n\n  double\n    delay;\n\n  Image\n    *clone_images;\n\n  ImageInfo\n    *write_info;\n\n  int\n    file;\n\n  MagickBooleanType\n    status;\n\n  Image\n    *p;\n\n  ssize_t\n    i;\n\n  size_t\n    count,\n    length,\n    scene;\n\n  unsigned char\n    *blob;\n\n  /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  /*\n    Write intermediate files.\n  */\n  clone_images=CloneImageList(image,exception);\n  if (clone_images == (Image *) NULL)\n    return(MagickFalse);\n  file=AcquireUniqueFileResource(basename);\n  if (file != -1)\n    file=close(file)-1;\n  (void) FormatLocaleString(clone_images->filename,MagickPathExtent,\"%s\",\n    basename);\n  count=0;\n  write_info=CloneImageInfo(image_info);\n  write_info->file=(FILE *) NULL;\n  *write_info->magick='\\0';\n  status=MagickTrue;\n  intermediate_format=GetIntermediateFormat(image_info);\n  for (p=clone_images; p != (Image *) NULL; p=GetNextImageInList(p))\n  {\n    char\n      previous_image[MagickPathExtent];\n\n    blob=(unsigned char *) NULL;\n    length=0;\n    scene=p->scene;\n    delay=100.0*p->delay/MagickMax(1.0*p->ticks_per_second,1.0);\n    for (i=0; i < (ssize_t) MagickMax((1.0*delay+1.0)/3.0,1.0); i++)\n    {\n      p->scene=count;\n      count++;\n      status=MagickFalse;\n      switch (i)\n      {\n        case 0:\n        {\n          Image\n            *frame;\n\n          (void) FormatLocaleString(p->filename,MagickPathExtent,\"%s%.20g.%s\",\n            basename,(double) p->scene,intermediate_format);\n          (void) FormatLocaleString(filename,MagickPathExtent,\"%s%.20g.%s\",\n            basename,(double) p->scene,intermediate_format);\n          (void) FormatLocaleString(previous_image,MagickPathExtent,\n            \"%s%.20g.%s\",basename,(double) p->scene,intermediate_format);\n          frame=CloneImage(p,0,0,MagickTrue,exception);\n          if (frame == (Image *) NULL)\n            break;\n          status=WriteImage(write_info,frame,exception);\n          frame=DestroyImage(frame);\n          break;\n        }\n        case 1:\n        {\n          blob=(unsigned char *) FileToBlob(previous_image,~0UL,&length,\n            exception);\n          magick_fallthrough;\n        }\n        default:\n        {\n          (void) FormatLocaleString(filename,MagickPathExtent,\"%s%.20g.%s\",\n            basename,(double) p->scene,intermediate_format);\n          if (length > 0)\n            status=BlobToFile(filename,blob,length,exception);\n          break;\n        }\n      }\n      if (image->debug != MagickFalse)\n        {\n          if (status != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"%.20g. Wrote %s file for scene %.20g:\",(double) i,\n              intermediate_format,(double) p->scene);\n          else\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"%.20g. Failed to write %s file for scene %.20g:\",(double) i,\n              intermediate_format,(double) p->scene);\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"%s\",filename);\n        }\n    }\n    p->scene=scene;\n    if (blob != (unsigned char *) NULL)\n      blob=(unsigned char *) RelinquishMagickMemory(blob);\n    if (status == MagickFalse)\n      break;\n  }\n  /*\n    Convert PAM to VIDEO.\n  */\n  delegate_info=GetDelegateInfo((char *) NULL,\"video:encode\",exception);\n  if (delegate_info != (const DelegateInfo *) NULL)\n    {\n      char\n        command[MagickPathExtent],\n        message[MagickPathExtent];\n\n      char\n        *options;\n\n      const char\n        *option;\n\n      int\n        exit_code;\n\n      options=AcquireString(\"\");\n      (void) FormatLocaleString(options,MagickPathExtent,\"-plays %i\",\n        (int) clone_images->iterations);\n      option=GetImageOption(image_info,\"video:pixel-format\");\n      if (option != (const char *) NULL)\n        {\n          FormatSanitizedDelegateOption(command,MagickPathExtent,\n            \" -pix_fmt \\\"%s\\\"\",\" -pix_fmt '%s'\",option);\n          (void) ConcatenateMagickString(options,command,MagickPathExtent);\n        }\n      AcquireUniqueFilename(write_info->unique);\n      (void) FormatLocaleString(command,MagickPathExtent,\n        GetDelegateCommands(delegate_info),basename,intermediate_format,\n        options,write_info->unique,image_info->magick);\n      options=DestroyString(options);\n      exit_code=ExternalDelegateCommand(MagickFalse,image_info->verbose,\n        command,message,exception);\n      status=exit_code == 0 ? MagickTrue : MagickFalse;\n      if (status != MagickFalse)\n        {\n          (void) FormatLocaleString(filename,MagickPathExtent,\"%s.%s\",\n            write_info->unique,image_info->magick);\n          status=CopyDelegateFile(filename,image->filename);\n          (void) RelinquishUniqueFileResource(filename);\n        }\n      else if (*message != '\\0')\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            DelegateError,\"VideoDelegateFailed\",\"`%s'\",message);\n        }\n      (void) RelinquishUniqueFileResource(write_info->unique);\n  }\n  write_info=DestroyImageInfo(write_info);\n  /*\n    Relinquish resources.\n  */\n  count=0;\n  for (p=clone_images; p != (Image *) NULL; p=GetNextImageInList(p))\n  {\n    delay=100.0*p->delay/MagickMax(1.0*p->ticks_per_second,1.0);\n    for (i=0; i < (ssize_t) MagickMax((1.0*delay+1.0)/3.0,1.0); i++)\n    {\n      (void) FormatLocaleString(p->filename,MagickPathExtent,\"%s%.20g.%s\",\n        basename,(double) count++,intermediate_format);\n      (void) RelinquishUniqueFileResource(p->filename);\n    }\n    (void) CopyMagickString(p->filename,image_info->filename,MagickPathExtent);\n  }\n  (void) RelinquishUniqueFileResource(basename);\n  clone_images=DestroyImageList(clone_images);\n  return(status);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -147,8 +147,7 @@\n         message[MagickPathExtent];\n \n       char\n-        *options,\n-        *sanitized_option;\n+        *options;\n \n       const char\n         *option;\n@@ -162,10 +161,8 @@\n       option=GetImageOption(image_info,\"video:pixel-format\");\n       if (option != (const char *) NULL)\n         {\n-          sanitized_option=SanitizeDelegateString(option);\n-          (void) FormatLocaleString(command,MagickPathExtent,\" -pix_fmt %s\",\n-            sanitized_option);\n-          DestroyString(sanitized_option);\n+          FormatSanitizedDelegateOption(command,MagickPathExtent,\n+            \" -pix_fmt \\\"%s\\\"\",\" -pix_fmt '%s'\",option);\n           (void) ConcatenateMagickString(options,command,MagickPathExtent);\n         }\n       AcquireUniqueFilename(write_info->unique);",
        "diff_line_info": {
            "deleted_lines": [
                "        *options,",
                "        *sanitized_option;",
                "          sanitized_option=SanitizeDelegateString(option);",
                "          (void) FormatLocaleString(command,MagickPathExtent,\" -pix_fmt %s\",",
                "            sanitized_option);",
                "          DestroyString(sanitized_option);"
            ],
            "added_lines": [
                "        *options;",
                "          FormatSanitizedDelegateOption(command,MagickPathExtent,",
                "            \" -pix_fmt \\\"%s\\\"\",\" -pix_fmt '%s'\",option);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-34153",
        "func_name": "ImageMagick/ReadVIDEOImage",
        "description": "A vulnerability was found in ImageMagick. This security flaw causes a shell command injection vulnerability via video:vsync or video:pixel-format options in VIDEO encoding/decoding.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/d31c80d15a2c82fc1dd8e889e0f97b0219079a57",
        "commit_title": "Make sure options are properly quoted to resolve the issue reported in #6338.",
        "commit_text": "",
        "func_before": "static Image *ReadVIDEOImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const DelegateInfo\n    *delegate_info;\n\n  Image\n    *image,\n    *images,\n    *next;\n\n  ImageInfo\n    *read_info;\n\n  MagickBooleanType\n    status;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) CloseBlob(image);\n  (void) DestroyImageList(image);\n  /*\n    Convert VIDEO to PAM with delegate.\n  */\n  images=(Image *) NULL;\n  read_info=CloneImageInfo(image_info);\n  delegate_info=GetDelegateInfo(\"video:decode\",(char *) NULL,exception);\n  if (delegate_info != (const DelegateInfo *) NULL)\n    {\n      char\n        command[MagickPathExtent],\n        message[MagickPathExtent];\n\n      char\n        *options,\n        *sanitized_option;\n\n      const char\n        *intermediate_format,\n        *option;\n\n      int\n        exit_code;\n\n      options=AcquireString(\"\");\n      if (image_info->number_scenes > 0)\n        (void) FormatLocaleString(options,MagickPathExtent,\"-vframes %i\",\n          (int) image_info->number_scenes);\n      option=GetImageOption(image_info,\"video:vsync\");\n      if (option != (const char *) NULL)\n        {\n          sanitized_option=SanitizeDelegateString(option);\n          (void) FormatLocaleString(command,MagickPathExtent,\" -vsync %s\",\n            sanitized_option);\n          DestroyString(sanitized_option);\n          (void) ConcatenateMagickString(options,command,MagickPathExtent);\n        }\n      option=GetImageOption(image_info,\"video:pixel-format\");\n      if (option != (const char *) NULL)\n        {\n          sanitized_option=SanitizeDelegateString(option);\n          (void) FormatLocaleString(command,MagickPathExtent,\" -pix_fmt %s\",\n            sanitized_option);\n          DestroyString(sanitized_option);\n          (void) ConcatenateMagickString(options,command,MagickPathExtent);\n        }\n      else\n        if (LocaleNCompare(image_info->magick,\"APNG\",MagickPathExtent) == 0)\n          (void) ConcatenateMagickString(options,\" -pix_fmt rgba\",\n            MagickPathExtent);\n      intermediate_format=GetIntermediateFormat(image_info);\n      (void) FormatLocaleString(command,MagickPathExtent,\" -vcodec %s\",\n        intermediate_format);\n      (void) ConcatenateMagickString(options,command,MagickPathExtent);\n      AcquireUniqueFilename(read_info->unique);\n      (void) AcquireUniqueSymbolicLink(image_info->filename,\n        read_info->filename);\n      (void) FormatLocaleString(command,MagickPathExtent,\n        GetDelegateCommands(delegate_info),read_info->filename,options,\n        read_info->unique);\n      options=DestroyString(options);\n      (void) CopyMagickString(read_info->magick,intermediate_format,\n        MagickPathExtent);\n      (void) CopyMagickString(read_info->filename,read_info->unique,\n        MagickPathExtent);\n      exit_code=ExternalDelegateCommand(MagickFalse,image_info->verbose,\n        command,message,exception);\n      if (exit_code == 0)\n        images=ReadImage(read_info,exception);\n      else\n        if (*message != '\\0')\n          (void) ThrowMagickException(exception,GetMagickModule(),DelegateError,\n            \"VideoDelegateFailed\",\"`%s'\",message);\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      (void) RelinquishUniqueFileResource(read_info->unique);\n      if (images != (Image *) NULL)\n        for (next=images; next != (Image *) NULL; next=next->next)\n        {\n          (void) CopyMagickString(next->filename,image_info->filename,\n            MagickPathExtent);\n          (void) CopyMagickString(next->magick,image_info->magick,\n            MagickPathExtent);\n        }\n    }\n  read_info=DestroyImageInfo(read_info);\n  return(images);\n}",
        "func": "static Image *ReadVIDEOImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  const DelegateInfo\n    *delegate_info;\n\n  Image\n    *image,\n    *images,\n    *next;\n\n  ImageInfo\n    *read_info;\n\n  MagickBooleanType\n    status;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  (void) CloseBlob(image);\n  (void) DestroyImageList(image);\n  /*\n    Convert VIDEO to PAM with delegate.\n  */\n  images=(Image *) NULL;\n  read_info=CloneImageInfo(image_info);\n  delegate_info=GetDelegateInfo(\"video:decode\",(char *) NULL,exception);\n  if (delegate_info != (const DelegateInfo *) NULL)\n    {\n      char\n        command[MagickPathExtent],\n        message[MagickPathExtent];\n\n      char\n        *options;\n\n      const char\n        *intermediate_format,\n        *option;\n\n      int\n        exit_code;\n\n      options=AcquireString(\"\");\n      if (image_info->number_scenes > 0)\n        (void) FormatLocaleString(options,MagickPathExtent,\"-vframes %i\",\n          (int) image_info->number_scenes);\n      option=GetImageOption(image_info,\"video:vsync\");\n      if (option != (const char *) NULL)\n        {\n          FormatSanitizedDelegateOption(command,MagickPathExtent,\n            \" -vsync \\\"%s\\\"\",\" -vsync '%s'\",option);\n          (void) ConcatenateMagickString(options,command,MagickPathExtent);\n        }\n      option=GetImageOption(image_info,\"video:pixel-format\");\n      if (option != (const char *) NULL)\n        {\n          FormatSanitizedDelegateOption(command,MagickPathExtent,\n            \" -pix_fmt \\\"%s\\\"\",\" -pix_fmt '%s'\",option);\n          (void) ConcatenateMagickString(options,command,MagickPathExtent);\n        }\n      else\n        if (LocaleNCompare(image_info->magick,\"APNG\",MagickPathExtent) == 0)\n          (void) ConcatenateMagickString(options,\" -pix_fmt rgba\",\n            MagickPathExtent);\n      intermediate_format=GetIntermediateFormat(image_info);\n      (void) FormatLocaleString(command,MagickPathExtent,\" -vcodec %s\",\n        intermediate_format);\n      (void) ConcatenateMagickString(options,command,MagickPathExtent);\n      AcquireUniqueFilename(read_info->unique);\n      (void) AcquireUniqueSymbolicLink(image_info->filename,\n        read_info->filename);\n      (void) FormatLocaleString(command,MagickPathExtent,\n        GetDelegateCommands(delegate_info),read_info->filename,options,\n        read_info->unique);\n      options=DestroyString(options);\n      (void) CopyMagickString(read_info->magick,intermediate_format,\n        MagickPathExtent);\n      (void) CopyMagickString(read_info->filename,read_info->unique,\n        MagickPathExtent);\n      exit_code=ExternalDelegateCommand(MagickFalse,image_info->verbose,\n        command,message,exception);\n      if (exit_code == 0)\n        images=ReadImage(read_info,exception);\n      else\n        if (*message != '\\0')\n          (void) ThrowMagickException(exception,GetMagickModule(),DelegateError,\n            \"VideoDelegateFailed\",\"`%s'\",message);\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      (void) RelinquishUniqueFileResource(read_info->unique);\n      if (images != (Image *) NULL)\n        for (next=images; next != (Image *) NULL; next=next->next)\n        {\n          (void) CopyMagickString(next->filename,image_info->filename,\n            MagickPathExtent);\n          (void) CopyMagickString(next->magick,image_info->magick,\n            MagickPathExtent);\n        }\n    }\n  read_info=DestroyImageInfo(read_info);\n  return(images);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -47,8 +47,7 @@\n         message[MagickPathExtent];\n \n       char\n-        *options,\n-        *sanitized_option;\n+        *options;\n \n       const char\n         *intermediate_format,\n@@ -64,19 +63,15 @@\n       option=GetImageOption(image_info,\"video:vsync\");\n       if (option != (const char *) NULL)\n         {\n-          sanitized_option=SanitizeDelegateString(option);\n-          (void) FormatLocaleString(command,MagickPathExtent,\" -vsync %s\",\n-            sanitized_option);\n-          DestroyString(sanitized_option);\n+          FormatSanitizedDelegateOption(command,MagickPathExtent,\n+            \" -vsync \\\"%s\\\"\",\" -vsync '%s'\",option);\n           (void) ConcatenateMagickString(options,command,MagickPathExtent);\n         }\n       option=GetImageOption(image_info,\"video:pixel-format\");\n       if (option != (const char *) NULL)\n         {\n-          sanitized_option=SanitizeDelegateString(option);\n-          (void) FormatLocaleString(command,MagickPathExtent,\" -pix_fmt %s\",\n-            sanitized_option);\n-          DestroyString(sanitized_option);\n+          FormatSanitizedDelegateOption(command,MagickPathExtent,\n+            \" -pix_fmt \\\"%s\\\"\",\" -pix_fmt '%s'\",option);\n           (void) ConcatenateMagickString(options,command,MagickPathExtent);\n         }\n       else",
        "diff_line_info": {
            "deleted_lines": [
                "        *options,",
                "        *sanitized_option;",
                "          sanitized_option=SanitizeDelegateString(option);",
                "          (void) FormatLocaleString(command,MagickPathExtent,\" -vsync %s\",",
                "            sanitized_option);",
                "          DestroyString(sanitized_option);",
                "          sanitized_option=SanitizeDelegateString(option);",
                "          (void) FormatLocaleString(command,MagickPathExtent,\" -pix_fmt %s\",",
                "            sanitized_option);",
                "          DestroyString(sanitized_option);"
            ],
            "added_lines": [
                "        *options;",
                "          FormatSanitizedDelegateOption(command,MagickPathExtent,",
                "            \" -vsync \\\"%s\\\"\",\" -vsync '%s'\",option);",
                "          FormatSanitizedDelegateOption(command,MagickPathExtent,",
                "            \" -pix_fmt \\\"%s\\\"\",\" -pix_fmt '%s'\",option);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-34153",
        "func_name": "ImageMagick/ReadPDFImage",
        "description": "A vulnerability was found in ImageMagick. This security flaw causes a shell command injection vulnerability via video:vsync or video:pixel-format options in VIDEO encoding/decoding.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/d31c80d15a2c82fc1dd8e889e0f97b0219079a57",
        "commit_title": "Make sure options are properly quoted to resolve the issue reported in #6338.",
        "commit_text": "",
        "func_before": "static Image *ReadPDFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    command[MagickPathExtent],\n    *density,\n    filename[MagickPathExtent],\n    input_filename[MagickPathExtent],\n    message[MagickPathExtent],\n    *options,\n    postscript_filename[MagickPathExtent];\n\n  const char\n    *option;\n\n  const DelegateInfo\n    *delegate_info;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *image,\n    *next,\n    *pdf_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    file;\n\n  MagickBooleanType\n    fitPage,\n    status;\n\n  MagickStatusType\n    flags;\n\n  PDFInfo\n    pdf_info;\n\n  PointInfo\n    delta;\n\n  RectangleInfo\n    page;\n\n  ssize_t\n    i;\n\n  size_t\n    scene;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  /*\n    Open image file.\n  */\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Set the page density.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  (void) memset(&page,0,sizeof(page));\n  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))\n    {\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      if ((flags & RhoValue) != 0)\n        image->resolution.x=geometry_info.rho;\n      image->resolution.y=image->resolution.x;\n      if ((flags & SigmaValue) != 0)\n        image->resolution.y=geometry_info.sigma;\n    }\n  if (image_info->density != (char *) NULL)\n    {\n      flags=ParseGeometry(image_info->density,&geometry_info);\n      if ((flags & RhoValue) != 0)\n        image->resolution.x=geometry_info.rho;\n      image->resolution.y=image->resolution.x;\n      if ((flags & SigmaValue) != 0)\n        image->resolution.y=geometry_info.sigma;\n    }\n  (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  page.width=(size_t) ((ssize_t) ceil((double) (page.width*\n    image->resolution.x/delta.x)-0.5));\n  page.height=(size_t) ((ssize_t) ceil((double) (page.height*\n    image->resolution.y/delta.y)-0.5));\n  /*\n    Determine page geometry from the PDF media box.\n  */\n  ReadPDFInfo(image_info,image,&pdf_info,exception);\n  (void) CloseBlob(image);\n  /*\n    Set PDF render geometry.\n  */\n  if ((fabs(pdf_info.bounds.x2-pdf_info.bounds.x1) >= MagickEpsilon) &&\n      (fabs(pdf_info.bounds.y2-pdf_info.bounds.y1) >= MagickEpsilon))\n    {\n      (void) FormatImageProperty(image,\"pdf:HiResBoundingBox\",\n        \"%gx%g%+.15g%+.15g\",pdf_info.bounds.x2-pdf_info.bounds.x1,\n        pdf_info.bounds.y2-pdf_info.bounds.y1,pdf_info.bounds.x1,\n        pdf_info.bounds.y1);\n      page.width=(size_t) ((ssize_t) ceil((double) ((pdf_info.bounds.x2-\n        pdf_info.bounds.x1)*image->resolution.x/delta.x)-0.5));\n      page.height=(size_t) ((ssize_t) ceil((double) ((pdf_info.bounds.y2-\n        pdf_info.bounds.y1)*image->resolution.y/delta.y)-0.5));\n    }\n  fitPage=MagickFalse;\n  option=GetImageOption(image_info,\"pdf:fit-page\");\n  if (option != (char *) NULL)\n    {\n      char\n        *page_geometry;\n\n      page_geometry=GetPageGeometry(option);\n      flags=ParseMetaGeometry(page_geometry,&page.x,&page.y,&page.width,\n        &page.height);\n      page_geometry=DestroyString(page_geometry);\n      if (flags == NoValue)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"InvalidGeometry\",\"`%s'\",option);\n          CleanupPDFInfo(&pdf_info);\n          image=DestroyImage(image);\n          return((Image *) NULL);\n        }\n      page.width=(size_t) ((ssize_t) ceil((double) (page.width*\n        image->resolution.x/delta.x)-0.5));\n      page.height=(size_t) ((ssize_t) ceil((double) (page.height*\n        image->resolution.y/delta.y)-0.5));\n      fitPage=MagickTrue;\n    }\n  if ((fabs(pdf_info.angle) == 90.0) || (fabs(pdf_info.angle) == 270.0))\n    {\n      size_t\n        swap;\n\n      swap=page.width;\n      page.width=page.height;\n      page.height=swap;\n    }\n  if (IssRGBCompatibleColorspace(image_info->colorspace) != MagickFalse)\n    pdf_info.cmyk=MagickFalse;\n  /*\n    Create Ghostscript control file.\n  */\n  file=AcquireUniqueFileResource(postscript_filename);\n  if (file == -1)\n    {\n      (void) RelinquishUniqueFileResource(input_filename);\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image_info->filename);\n      CleanupPDFInfo(&pdf_info);\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  if (write(file,\" \",1) != 1)\n    {\n      file=close(file)-1;\n      (void) RelinquishUniqueFileResource(input_filename);\n      (void) RelinquishUniqueFileResource(postscript_filename);\n      CleanupPDFInfo(&pdf_info);\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  file=close(file)-1;\n  /*\n    Render Postscript with the Ghostscript delegate.\n  */\n  if (image_info->monochrome != MagickFalse)\n    delegate_info=GetDelegateInfo(\"ps:mono\",(char *) NULL,exception);\n  else\n     if (pdf_info.cmyk != MagickFalse)\n       delegate_info=GetDelegateInfo(\"ps:cmyk\",(char *) NULL,exception);\n     else\n       delegate_info=GetDelegateInfo(\"ps:alpha\",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(input_filename);\n      (void) RelinquishUniqueFileResource(postscript_filename);\n      CleanupPDFInfo(&pdf_info);\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  density=AcquireString(\"\");\n  options=AcquireString(\"\");\n  (void) FormatLocaleString(density,MagickPathExtent,\"%gx%g\",\n    image->resolution.x,image->resolution.y);\n  if (image_info->ping != MagickFalse)\n    (void) FormatLocaleString(density,MagickPathExtent,\"2.0x2.0\");\n  else\n    if ((image_info->page != (char *) NULL) || (fitPage != MagickFalse))\n      (void) FormatLocaleString(options,MagickPathExtent,\"-g%.20gx%.20g \",\n        (double) page.width,(double) page.height);\n  option=GetImageOption(image_info,\"pdf:printed\");\n  if (IsStringTrue(option) != MagickFalse)\n    (void) ConcatenateMagickString(options,\"-dPrinted=true \",MagickPathExtent);\n  else\n    (void) ConcatenateMagickString(options,\"-dPrinted=false \",MagickPathExtent);\n  if (fitPage != MagickFalse)\n    (void) ConcatenateMagickString(options,\"-dPSFitPage \",MagickPathExtent);\n  if (pdf_info.cropbox != MagickFalse)\n    (void) ConcatenateMagickString(options,\"-dUseCropBox \",MagickPathExtent);\n  if (pdf_info.trimbox != MagickFalse)\n    (void) ConcatenateMagickString(options,\"-dUseTrimBox \",MagickPathExtent);\n  option=GetImageOption(image_info,\"pdf:stop-on-error\");\n  if (IsStringTrue(option) != MagickFalse)\n    (void) ConcatenateMagickString(options,\"-dPDFSTOPONERROR \",\n      MagickPathExtent);\n  option=GetImageOption(image_info,\"pdf:interpolate\");\n  if (IsStringTrue(option) != MagickFalse)\n    (void) ConcatenateMagickString(options,\"-dInterpolateControl=-1 \",\n      MagickPathExtent);\n  option=GetImageOption(image_info,\"pdf:hide-annotations\");\n  if (IsStringTrue(option) != MagickFalse)\n    (void) ConcatenateMagickString(options,\"-dShowAnnots=false \",\n      MagickPathExtent);\n  option=GetImageOption(image_info,\"authenticate\");\n  if (option != (char *) NULL)\n    {\n      char\n        passphrase[MagickPathExtent],\n        *sanitize_passphrase;\n\n      sanitize_passphrase=SanitizeDelegateString(option);\n#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n      (void) FormatLocaleString(passphrase,MagickPathExtent,\n        \"\\\"-sPDFPassword=%s\\\" \",sanitize_passphrase);\n#else\n      (void) FormatLocaleString(passphrase,MagickPathExtent,\n        \"-sPDFPassword='%s' \",sanitize_passphrase);\n#endif\n      sanitize_passphrase=DestroyString(sanitize_passphrase);\n      (void) ConcatenateMagickString(options,passphrase,MagickPathExtent);\n    }\n  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  if (read_info->number_scenes != 0)\n    {\n      char\n        pages[MagickPathExtent];\n\n      (void) FormatLocaleString(pages,MagickPathExtent,\"-dFirstPage=%.20g \"\n        \"-dLastPage=%.20g\",(double) read_info->scene+1,(double)\n        (read_info->scene+read_info->number_scenes));\n      (void) ConcatenateMagickString(options,pages,MagickPathExtent);\n      read_info->number_scenes=0;\n      if (read_info->scenes != (char *) NULL)\n        *read_info->scenes='\\0';\n    }\n  (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);\n  (void) AcquireUniqueFilename(filename);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) ConcatenateMagickString(filename,\"%d\",MagickPathExtent);\n  (void) FormatLocaleString(command,MagickPathExtent,\n    GetDelegateCommands(delegate_info),\n    read_info->antialias != MagickFalse ? 4 : 1,\n    read_info->antialias != MagickFalse ? 4 : 1,density,options,filename,\n    postscript_filename,input_filename);\n  options=DestroyString(options);\n  density=DestroyString(density);\n  *message='\\0';\n  status=InvokeGhostscriptDelegate(read_info->verbose,command,message,\n    exception);\n  (void) RelinquishUniqueFileResource(postscript_filename);\n  (void) RelinquishUniqueFileResource(input_filename);\n  pdf_image=(Image *) NULL;\n  if (status == MagickFalse)\n    for (i=1; ; i++)\n    {\n      (void) InterpretImageFilename(image_info,image,filename,(int) i,\n        read_info->filename,exception);\n      if (IsGhostscriptRendered(read_info->filename) == MagickFalse)\n        break;\n      (void) RelinquishUniqueFileResource(read_info->filename);\n    }\n  else\n    {\n      next=(Image *) NULL;\n      for (i=1; ; i++)\n      {\n        (void) InterpretImageFilename(image_info,image,filename,(int) i,\n          read_info->filename,exception);\n        if (IsGhostscriptRendered(read_info->filename) == MagickFalse)\n          break;\n        read_info->blob=NULL;\n        read_info->length=0;\n        next=ReadImage(read_info,exception);\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        if (next == (Image *) NULL)\n          break;\n        AppendImageToList(&pdf_image,next);\n      }\n      /* Clean up remaining files */\n      if (next == (Image *) NULL)\n        {\n          ssize_t\n            j;\n\n          for (j=i+1; ; j++)\n            {\n              (void) InterpretImageFilename(image_info,image,filename,(int) j,\n                read_info->filename,exception);\n              if (IsGhostscriptRendered(read_info->filename) == MagickFalse)\n                break;\n              (void) RelinquishUniqueFileResource(read_info->filename);\n            }\n        }\n    }\n  read_info=DestroyImageInfo(read_info);\n  if (pdf_image == (Image *) NULL)\n    {\n      if (*message != '\\0')\n        (void) ThrowMagickException(exception,GetMagickModule(),DelegateError,\n          \"PDFDelegateFailed\",\"`%s'\",message);\n      CleanupPDFInfo(&pdf_info);\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  if (LocaleCompare(pdf_image->magick,\"BMP\") == 0)\n    {\n      Image\n        *cmyk_image;\n\n      cmyk_image=ConsolidateCMYKImages(pdf_image,exception);\n      if (cmyk_image != (Image *) NULL)\n        {\n          pdf_image=DestroyImageList(pdf_image);\n          pdf_image=cmyk_image;\n        }\n    }\n  if (pdf_info.profile != (StringInfo *) NULL)\n    {\n      char\n        *profile;\n\n      (void) SetImageProfile(image,\"xmp\",pdf_info.profile,exception);\n      profile=(char *) GetStringInfoDatum(pdf_info.profile);\n      if (strstr(profile,\"Adobe Illustrator\") != (char *) NULL)\n        (void) CopyMagickString(image->magick,\"AI\",MagickPathExtent);\n    }\n  CleanupPDFInfo(&pdf_info);\n  if (image_info->number_scenes != 0)\n    {\n      Image\n        *clone_image;\n\n      /*\n        Add place holder images to meet the subimage specification requirement.\n      */\n      for (i=0; i < (ssize_t) image_info->scene; i++)\n      {\n        clone_image=CloneImage(pdf_image,1,1,MagickTrue,exception);\n        if (clone_image != (Image *) NULL)\n          PrependImageToList(&pdf_image,clone_image);\n      }\n    }\n  do\n  {\n    (void) CopyMagickString(pdf_image->filename,filename,MagickPathExtent);\n    (void) CopyMagickString(pdf_image->magick,image->magick,MagickPathExtent);\n    pdf_image->page=page;\n    if (image_info->ping != MagickFalse)\n      {\n        pdf_image->magick_columns=page.width;\n        pdf_image->magick_rows=page.height;\n        pdf_image->columns=page.width;\n        pdf_image->rows=page.height;\n      }\n    (void) CloneImageProfiles(pdf_image,image);\n    (void) CloneImageProperties(pdf_image,image);\n    next=SyncNextImageInList(pdf_image);\n    if (next != (Image *) NULL)\n      pdf_image=next;\n  } while (next != (Image *) NULL);\n  image=DestroyImage(image);\n  scene=0;\n  for (next=GetFirstImageInList(pdf_image); next != (Image *) NULL; )\n  {\n    next->scene=scene++;\n    next=GetNextImageInList(next);\n  }\n  return(GetFirstImageInList(pdf_image));\n}",
        "func": "static Image *ReadPDFImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    command[MagickPathExtent],\n    *density,\n    filename[MagickPathExtent],\n    input_filename[MagickPathExtent],\n    message[MagickPathExtent],\n    *options,\n    postscript_filename[MagickPathExtent];\n\n  const char\n    *option;\n\n  const DelegateInfo\n    *delegate_info;\n\n  GeometryInfo\n    geometry_info;\n\n  Image\n    *image,\n    *next,\n    *pdf_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    file;\n\n  MagickBooleanType\n    fitPage,\n    status;\n\n  MagickStatusType\n    flags;\n\n  PDFInfo\n    pdf_info;\n\n  PointInfo\n    delta;\n\n  RectangleInfo\n    page;\n\n  ssize_t\n    i;\n\n  size_t\n    scene;\n\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  /*\n    Open image file.\n  */\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image_info->filename);\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Set the page density.\n  */\n  delta.x=DefaultResolution;\n  delta.y=DefaultResolution;\n  (void) memset(&page,0,sizeof(page));\n  if ((image->resolution.x == 0.0) || (image->resolution.y == 0.0))\n    {\n      flags=ParseGeometry(PSDensityGeometry,&geometry_info);\n      if ((flags & RhoValue) != 0)\n        image->resolution.x=geometry_info.rho;\n      image->resolution.y=image->resolution.x;\n      if ((flags & SigmaValue) != 0)\n        image->resolution.y=geometry_info.sigma;\n    }\n  if (image_info->density != (char *) NULL)\n    {\n      flags=ParseGeometry(image_info->density,&geometry_info);\n      if ((flags & RhoValue) != 0)\n        image->resolution.x=geometry_info.rho;\n      image->resolution.y=image->resolution.x;\n      if ((flags & SigmaValue) != 0)\n        image->resolution.y=geometry_info.sigma;\n    }\n  (void) ParseAbsoluteGeometry(PSPageGeometry,&page);\n  if (image_info->page != (char *) NULL)\n    (void) ParseAbsoluteGeometry(image_info->page,&page);\n  page.width=(size_t) ((ssize_t) ceil((double) (page.width*\n    image->resolution.x/delta.x)-0.5));\n  page.height=(size_t) ((ssize_t) ceil((double) (page.height*\n    image->resolution.y/delta.y)-0.5));\n  /*\n    Determine page geometry from the PDF media box.\n  */\n  ReadPDFInfo(image_info,image,&pdf_info,exception);\n  (void) CloseBlob(image);\n  /*\n    Set PDF render geometry.\n  */\n  if ((fabs(pdf_info.bounds.x2-pdf_info.bounds.x1) >= MagickEpsilon) &&\n      (fabs(pdf_info.bounds.y2-pdf_info.bounds.y1) >= MagickEpsilon))\n    {\n      (void) FormatImageProperty(image,\"pdf:HiResBoundingBox\",\n        \"%gx%g%+.15g%+.15g\",pdf_info.bounds.x2-pdf_info.bounds.x1,\n        pdf_info.bounds.y2-pdf_info.bounds.y1,pdf_info.bounds.x1,\n        pdf_info.bounds.y1);\n      page.width=(size_t) ((ssize_t) ceil((double) ((pdf_info.bounds.x2-\n        pdf_info.bounds.x1)*image->resolution.x/delta.x)-0.5));\n      page.height=(size_t) ((ssize_t) ceil((double) ((pdf_info.bounds.y2-\n        pdf_info.bounds.y1)*image->resolution.y/delta.y)-0.5));\n    }\n  fitPage=MagickFalse;\n  option=GetImageOption(image_info,\"pdf:fit-page\");\n  if (option != (char *) NULL)\n    {\n      char\n        *page_geometry;\n\n      page_geometry=GetPageGeometry(option);\n      flags=ParseMetaGeometry(page_geometry,&page.x,&page.y,&page.width,\n        &page.height);\n      page_geometry=DestroyString(page_geometry);\n      if (flags == NoValue)\n        {\n          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,\n            \"InvalidGeometry\",\"`%s'\",option);\n          CleanupPDFInfo(&pdf_info);\n          image=DestroyImage(image);\n          return((Image *) NULL);\n        }\n      page.width=(size_t) ((ssize_t) ceil((double) (page.width*\n        image->resolution.x/delta.x)-0.5));\n      page.height=(size_t) ((ssize_t) ceil((double) (page.height*\n        image->resolution.y/delta.y)-0.5));\n      fitPage=MagickTrue;\n    }\n  if ((fabs(pdf_info.angle) == 90.0) || (fabs(pdf_info.angle) == 270.0))\n    {\n      size_t\n        swap;\n\n      swap=page.width;\n      page.width=page.height;\n      page.height=swap;\n    }\n  if (IssRGBCompatibleColorspace(image_info->colorspace) != MagickFalse)\n    pdf_info.cmyk=MagickFalse;\n  /*\n    Create Ghostscript control file.\n  */\n  file=AcquireUniqueFileResource(postscript_filename);\n  if (file == -1)\n    {\n      (void) RelinquishUniqueFileResource(input_filename);\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        image_info->filename);\n      CleanupPDFInfo(&pdf_info);\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  if (write(file,\" \",1) != 1)\n    {\n      file=close(file)-1;\n      (void) RelinquishUniqueFileResource(input_filename);\n      (void) RelinquishUniqueFileResource(postscript_filename);\n      CleanupPDFInfo(&pdf_info);\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  file=close(file)-1;\n  /*\n    Render Postscript with the Ghostscript delegate.\n  */\n  if (image_info->monochrome != MagickFalse)\n    delegate_info=GetDelegateInfo(\"ps:mono\",(char *) NULL,exception);\n  else\n     if (pdf_info.cmyk != MagickFalse)\n       delegate_info=GetDelegateInfo(\"ps:cmyk\",(char *) NULL,exception);\n     else\n       delegate_info=GetDelegateInfo(\"ps:alpha\",(char *) NULL,exception);\n  if (delegate_info == (const DelegateInfo *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(input_filename);\n      (void) RelinquishUniqueFileResource(postscript_filename);\n      CleanupPDFInfo(&pdf_info);\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  density=AcquireString(\"\");\n  options=AcquireString(\"\");\n  (void) FormatLocaleString(density,MagickPathExtent,\"%gx%g\",\n    image->resolution.x,image->resolution.y);\n  if (image_info->ping != MagickFalse)\n    (void) FormatLocaleString(density,MagickPathExtent,\"2.0x2.0\");\n  else\n    if ((image_info->page != (char *) NULL) || (fitPage != MagickFalse))\n      (void) FormatLocaleString(options,MagickPathExtent,\"-g%.20gx%.20g \",\n        (double) page.width,(double) page.height);\n  option=GetImageOption(image_info,\"pdf:printed\");\n  if (IsStringTrue(option) != MagickFalse)\n    (void) ConcatenateMagickString(options,\"-dPrinted=true \",MagickPathExtent);\n  else\n    (void) ConcatenateMagickString(options,\"-dPrinted=false \",MagickPathExtent);\n  if (fitPage != MagickFalse)\n    (void) ConcatenateMagickString(options,\"-dPSFitPage \",MagickPathExtent);\n  if (pdf_info.cropbox != MagickFalse)\n    (void) ConcatenateMagickString(options,\"-dUseCropBox \",MagickPathExtent);\n  if (pdf_info.trimbox != MagickFalse)\n    (void) ConcatenateMagickString(options,\"-dUseTrimBox \",MagickPathExtent);\n  option=GetImageOption(image_info,\"pdf:stop-on-error\");\n  if (IsStringTrue(option) != MagickFalse)\n    (void) ConcatenateMagickString(options,\"-dPDFSTOPONERROR \",\n      MagickPathExtent);\n  option=GetImageOption(image_info,\"pdf:interpolate\");\n  if (IsStringTrue(option) != MagickFalse)\n    (void) ConcatenateMagickString(options,\"-dInterpolateControl=-1 \",\n      MagickPathExtent);\n  option=GetImageOption(image_info,\"pdf:hide-annotations\");\n  if (IsStringTrue(option) != MagickFalse)\n    (void) ConcatenateMagickString(options,\"-dShowAnnots=false \",\n      MagickPathExtent);\n  option=GetImageOption(image_info,\"authenticate\");\n  if (option != (char *) NULL)\n    {\n      char\n        passphrase[MagickPathExtent];\n\n      FormatSanitizedDelegateOption(passphrase,MagickPathExtent,\n        \"\\\"-sPDFPassword=%s\\\" \",\"-sPDFPassword='%s' \",option);\n      (void) ConcatenateMagickString(options,passphrase,MagickPathExtent);\n    }\n  read_info=CloneImageInfo(image_info);\n  *read_info->magick='\\0';\n  if (read_info->number_scenes != 0)\n    {\n      char\n        pages[MagickPathExtent];\n\n      (void) FormatLocaleString(pages,MagickPathExtent,\"-dFirstPage=%.20g \"\n        \"-dLastPage=%.20g\",(double) read_info->scene+1,(double)\n        (read_info->scene+read_info->number_scenes));\n      (void) ConcatenateMagickString(options,pages,MagickPathExtent);\n      read_info->number_scenes=0;\n      if (read_info->scenes != (char *) NULL)\n        *read_info->scenes='\\0';\n    }\n  (void) CopyMagickString(filename,read_info->filename,MagickPathExtent);\n  (void) AcquireUniqueFilename(filename);\n  (void) RelinquishUniqueFileResource(filename);\n  (void) ConcatenateMagickString(filename,\"%d\",MagickPathExtent);\n  (void) FormatLocaleString(command,MagickPathExtent,\n    GetDelegateCommands(delegate_info),\n    read_info->antialias != MagickFalse ? 4 : 1,\n    read_info->antialias != MagickFalse ? 4 : 1,density,options,filename,\n    postscript_filename,input_filename);\n  options=DestroyString(options);\n  density=DestroyString(density);\n  *message='\\0';\n  status=InvokeGhostscriptDelegate(read_info->verbose,command,message,\n    exception);\n  (void) RelinquishUniqueFileResource(postscript_filename);\n  (void) RelinquishUniqueFileResource(input_filename);\n  pdf_image=(Image *) NULL;\n  if (status == MagickFalse)\n    for (i=1; ; i++)\n    {\n      (void) InterpretImageFilename(image_info,image,filename,(int) i,\n        read_info->filename,exception);\n      if (IsGhostscriptRendered(read_info->filename) == MagickFalse)\n        break;\n      (void) RelinquishUniqueFileResource(read_info->filename);\n    }\n  else\n    {\n      next=(Image *) NULL;\n      for (i=1; ; i++)\n      {\n        (void) InterpretImageFilename(image_info,image,filename,(int) i,\n          read_info->filename,exception);\n        if (IsGhostscriptRendered(read_info->filename) == MagickFalse)\n          break;\n        read_info->blob=NULL;\n        read_info->length=0;\n        next=ReadImage(read_info,exception);\n        (void) RelinquishUniqueFileResource(read_info->filename);\n        if (next == (Image *) NULL)\n          break;\n        AppendImageToList(&pdf_image,next);\n      }\n      /* Clean up remaining files */\n      if (next == (Image *) NULL)\n        {\n          ssize_t\n            j;\n\n          for (j=i+1; ; j++)\n            {\n              (void) InterpretImageFilename(image_info,image,filename,(int) j,\n                read_info->filename,exception);\n              if (IsGhostscriptRendered(read_info->filename) == MagickFalse)\n                break;\n              (void) RelinquishUniqueFileResource(read_info->filename);\n            }\n        }\n    }\n  read_info=DestroyImageInfo(read_info);\n  if (pdf_image == (Image *) NULL)\n    {\n      if (*message != '\\0')\n        (void) ThrowMagickException(exception,GetMagickModule(),DelegateError,\n          \"PDFDelegateFailed\",\"`%s'\",message);\n      CleanupPDFInfo(&pdf_info);\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  if (LocaleCompare(pdf_image->magick,\"BMP\") == 0)\n    {\n      Image\n        *cmyk_image;\n\n      cmyk_image=ConsolidateCMYKImages(pdf_image,exception);\n      if (cmyk_image != (Image *) NULL)\n        {\n          pdf_image=DestroyImageList(pdf_image);\n          pdf_image=cmyk_image;\n        }\n    }\n  if (pdf_info.profile != (StringInfo *) NULL)\n    {\n      char\n        *profile;\n\n      (void) SetImageProfile(image,\"xmp\",pdf_info.profile,exception);\n      profile=(char *) GetStringInfoDatum(pdf_info.profile);\n      if (strstr(profile,\"Adobe Illustrator\") != (char *) NULL)\n        (void) CopyMagickString(image->magick,\"AI\",MagickPathExtent);\n    }\n  CleanupPDFInfo(&pdf_info);\n  if (image_info->number_scenes != 0)\n    {\n      Image\n        *clone_image;\n\n      /*\n        Add place holder images to meet the subimage specification requirement.\n      */\n      for (i=0; i < (ssize_t) image_info->scene; i++)\n      {\n        clone_image=CloneImage(pdf_image,1,1,MagickTrue,exception);\n        if (clone_image != (Image *) NULL)\n          PrependImageToList(&pdf_image,clone_image);\n      }\n    }\n  do\n  {\n    (void) CopyMagickString(pdf_image->filename,filename,MagickPathExtent);\n    (void) CopyMagickString(pdf_image->magick,image->magick,MagickPathExtent);\n    pdf_image->page=page;\n    if (image_info->ping != MagickFalse)\n      {\n        pdf_image->magick_columns=page.width;\n        pdf_image->magick_rows=page.height;\n        pdf_image->columns=page.width;\n        pdf_image->rows=page.height;\n      }\n    (void) CloneImageProfiles(pdf_image,image);\n    (void) CloneImageProperties(pdf_image,image);\n    next=SyncNextImageInList(pdf_image);\n    if (next != (Image *) NULL)\n      pdf_image=next;\n  } while (next != (Image *) NULL);\n  image=DestroyImage(image);\n  scene=0;\n  for (next=GetFirstImageInList(pdf_image); next != (Image *) NULL; )\n  {\n    next->scene=scene++;\n    next=GetNextImageInList(next);\n  }\n  return(GetFirstImageInList(pdf_image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -241,18 +241,10 @@\n   if (option != (char *) NULL)\n     {\n       char\n-        passphrase[MagickPathExtent],\n-        *sanitize_passphrase;\n-\n-      sanitize_passphrase=SanitizeDelegateString(option);\n-#if defined(MAGICKCORE_WINDOWS_SUPPORT)\n-      (void) FormatLocaleString(passphrase,MagickPathExtent,\n-        \"\\\"-sPDFPassword=%s\\\" \",sanitize_passphrase);\n-#else\n-      (void) FormatLocaleString(passphrase,MagickPathExtent,\n-        \"-sPDFPassword='%s' \",sanitize_passphrase);\n-#endif\n-      sanitize_passphrase=DestroyString(sanitize_passphrase);\n+        passphrase[MagickPathExtent];\n+\n+      FormatSanitizedDelegateOption(passphrase,MagickPathExtent,\n+        \"\\\"-sPDFPassword=%s\\\" \",\"-sPDFPassword='%s' \",option);\n       (void) ConcatenateMagickString(options,passphrase,MagickPathExtent);\n     }\n   read_info=CloneImageInfo(image_info);",
        "diff_line_info": {
            "deleted_lines": [
                "        passphrase[MagickPathExtent],",
                "        *sanitize_passphrase;",
                "",
                "      sanitize_passphrase=SanitizeDelegateString(option);",
                "#if defined(MAGICKCORE_WINDOWS_SUPPORT)",
                "      (void) FormatLocaleString(passphrase,MagickPathExtent,",
                "        \"\\\"-sPDFPassword=%s\\\" \",sanitize_passphrase);",
                "#else",
                "      (void) FormatLocaleString(passphrase,MagickPathExtent,",
                "        \"-sPDFPassword='%s' \",sanitize_passphrase);",
                "#endif",
                "      sanitize_passphrase=DestroyString(sanitize_passphrase);"
            ],
            "added_lines": [
                "        passphrase[MagickPathExtent];",
                "",
                "      FormatSanitizedDelegateOption(passphrase,MagickPathExtent,",
                "        \"\\\"-sPDFPassword=%s\\\" \",\"-sPDFPassword='%s' \",option);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26273",
        "func_name": "osquery/SQLiteDBManager::getConnection",
        "description": "osquery is a SQL powered operating system instrumentation, monitoring, and analytics framework. In osquery before version 4.6.0, by using sqlite's ATTACH verb, someone with administrative access to osquery can cause reads and writes to arbitrary sqlite databases on disk. This _does_ allow arbitrary files to be created, but they will be sqlite databases. It does not appear to allow existing non-sqlite files to be overwritten. This has been patched in osquery 4.6.0. There are several mitigating factors and possible workarounds. In some deployments, the people with access to these interfaces may be considered administrators. In some deployments, configuration is managed by a central tool. This tool can filter for the `ATTACH` keyword. osquery can be run as non-root user. Because this also limits the desired access levels, this requires deployment specific testing and configuration.",
        "git_url": "https://github.com/osquery/osquery/commit/c3f9a3dae22d43ed3b4f6a403cbf89da4cba7c3c",
        "commit_title": "Merge pull request from GHSA-4g56-2482-x7q8",
        "commit_text": " * Proposed fix for attach tables vulnerability  * Add authorizer to ATC tables and cleanups  - Add unit test for authorizer function",
        "func_before": "SQLiteDBInstanceRef SQLiteDBManager::getConnection(bool primary) {\n  auto& self = instance();\n  WriteLock lock(self.create_mutex_);\n\n  if (self.db_ == nullptr) {\n    // Create primary SQLite DB instance.\n    openOptimized(self.db_);\n    self.connection_ = SQLiteDBInstanceRef(new SQLiteDBInstance(self.db_));\n    attachVirtualTables(self.connection_);\n  }\n\n  // Internal usage may request the primary connection explicitly.\n  if (primary) {\n    return self.connection_;\n  }\n\n  // Create a 'database connection' for the managed database instance.\n  auto instance = std::make_shared<SQLiteDBInstance>(self.db_, self.mutex_);\n  if (!instance->isPrimary()) {\n    attachVirtualTables(instance);\n  }\n  return instance;\n}",
        "func": "SQLiteDBInstanceRef SQLiteDBManager::getConnection(bool primary) {\n  auto& self = instance();\n  WriteLock lock(self.create_mutex_);\n\n  if (self.db_ == nullptr) {\n    // Create primary SQLite DB instance.\n    openOptimized(self.db_);\n    self.connection_ = SQLiteDBInstanceRef(new SQLiteDBInstance(self.db_));\n    attachVirtualTables(self.connection_);\n  }\n\n  // Internal usage may request the primary connection explicitly.\n  if (primary) {\n    return self.connection_;\n  }\n\n  // Create a 'database connection' for the managed database instance.\n  auto instance = std::make_shared<SQLiteDBInstance>(self.db_, self.mutex_);\n  if (!instance->isPrimary()) {\n    attachVirtualTables(instance);\n  }\n\n  return instance;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,5 +19,6 @@\n   if (!instance->isPrimary()) {\n     attachVirtualTables(instance);\n   }\n+\n   return instance;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26273",
        "func_name": "osquery/openOptimized",
        "description": "osquery is a SQL powered operating system instrumentation, monitoring, and analytics framework. In osquery before version 4.6.0, by using sqlite's ATTACH verb, someone with administrative access to osquery can cause reads and writes to arbitrary sqlite databases on disk. This _does_ allow arbitrary files to be created, but they will be sqlite databases. It does not appear to allow existing non-sqlite files to be overwritten. This has been patched in osquery 4.6.0. There are several mitigating factors and possible workarounds. In some deployments, the people with access to these interfaces may be considered administrators. In some deployments, configuration is managed by a central tool. This tool can filter for the `ATTACH` keyword. osquery can be run as non-root user. Because this also limits the desired access levels, this requires deployment specific testing and configuration.",
        "git_url": "https://github.com/osquery/osquery/commit/c3f9a3dae22d43ed3b4f6a403cbf89da4cba7c3c",
        "commit_title": "Merge pull request from GHSA-4g56-2482-x7q8",
        "commit_text": " * Proposed fix for attach tables vulnerability  * Add authorizer to ATC tables and cleanups  - Add unit test for authorizer function",
        "func_before": "static inline void openOptimized(sqlite3*& db) {\n  sqlite3_open(\":memory:\", &db);\n\n  std::string settings;\n  for (const auto& setting : kMemoryDBSettings) {\n    settings += \"PRAGMA \" + setting.first + \"=\" + setting.second + \"; \";\n  }\n  sqlite3_exec(db, settings.c_str(), nullptr, nullptr, nullptr);\n\n  // Register function extensions.\n  registerMathExtensions(db);\n#if !defined(FREEBSD)\n  registerStringExtensions(db);\n#endif\n#if !defined(SKIP_CARVER)\n  registerOperationExtensions(db);\n#endif\n  registerFilesystemExtensions(db);\n  registerHashingExtensions(db);\n  registerEncodingExtensions(db);\n}",
        "func": "static inline void openOptimized(sqlite3*& db) {\n  sqlite3_open(\":memory:\", &db);\n\n  std::string settings;\n  for (const auto& setting : kMemoryDBSettings) {\n    settings += \"PRAGMA \" + setting.first + \"=\" + setting.second + \"; \";\n  }\n  sqlite3_exec(db, settings.c_str(), nullptr, nullptr, nullptr);\n\n  // Register function extensions.\n  registerMathExtensions(db);\n#if !defined(FREEBSD)\n  registerStringExtensions(db);\n#endif\n#if !defined(SKIP_CARVER)\n  registerOperationExtensions(db);\n#endif\n  registerFilesystemExtensions(db);\n  registerHashingExtensions(db);\n  registerEncodingExtensions(db);\n\n  auto rc = sqlite3_set_authorizer(db, &sqliteAuthorizer, nullptr);\n  if (rc != SQLITE_OK) {\n    LOG(ERROR) << \"Failed to set sqlite authorizer: \" << sqlite3_errmsg(db);\n    requestShutdown(rc);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,4 +18,10 @@\n   registerFilesystemExtensions(db);\n   registerHashingExtensions(db);\n   registerEncodingExtensions(db);\n+\n+  auto rc = sqlite3_set_authorizer(db, &sqliteAuthorizer, nullptr);\n+  if (rc != SQLITE_OK) {\n+    LOG(ERROR) << \"Failed to set sqlite authorizer: \" << sqlite3_errmsg(db);\n+    requestShutdown(rc);\n+  }\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  auto rc = sqlite3_set_authorizer(db, &sqliteAuthorizer, nullptr);",
                "  if (rc != SQLITE_OK) {",
                "    LOG(ERROR) << \"Failed to set sqlite authorizer: \" << sqlite3_errmsg(db);",
                "    requestShutdown(rc);",
                "  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26273",
        "func_name": "osquery/genTableRowsForSqliteTable",
        "description": "osquery is a SQL powered operating system instrumentation, monitoring, and analytics framework. In osquery before version 4.6.0, by using sqlite's ATTACH verb, someone with administrative access to osquery can cause reads and writes to arbitrary sqlite databases on disk. This _does_ allow arbitrary files to be created, but they will be sqlite databases. It does not appear to allow existing non-sqlite files to be overwritten. This has been patched in osquery 4.6.0. There are several mitigating factors and possible workarounds. In some deployments, the people with access to these interfaces may be considered administrators. In some deployments, configuration is managed by a central tool. This tool can filter for the `ATTACH` keyword. osquery can be run as non-root user. Because this also limits the desired access levels, this requires deployment specific testing and configuration.",
        "git_url": "https://github.com/osquery/osquery/commit/c3f9a3dae22d43ed3b4f6a403cbf89da4cba7c3c",
        "commit_title": "Merge pull request from GHSA-4g56-2482-x7q8",
        "commit_text": " * Proposed fix for attach tables vulnerability  * Add authorizer to ATC tables and cleanups  - Add unit test for authorizer function",
        "func_before": "Status genTableRowsForSqliteTable(const fs::path& sqlite_db,\n                                  const std::string& sqlite_query,\n                                  TableRows& results,\n                                  bool respect_locking) {\n  sqlite3* db = nullptr;\n  if (!pathExists(sqlite_db).ok()) {\n    return Status(1, \"Database path does not exist\");\n  }\n\n  auto rc = sqlite3_open_v2(\n      sqlite_db.string().c_str(),\n      &db,\n      (SQLITE_OPEN_READONLY | SQLITE_OPEN_PRIVATECACHE | SQLITE_OPEN_NOMUTEX),\n      getSystemVFS(respect_locking));\n  if (rc != SQLITE_OK || db == nullptr) {\n    VLOG(1) << \"Cannot open specified database: \"\n            << getStringForSQLiteReturnCode(rc);\n    if (db != nullptr) {\n      sqlite3_close(db);\n    }\n    return Status(1, \"Could not open database\");\n  }\n\n  sqlite3_stmt* stmt = nullptr;\n  rc = sqlite3_prepare_v2(db, sqlite_query.c_str(), -1, &stmt, nullptr);\n  if (rc != SQLITE_OK) {\n    sqlite3_close(db);\n    VLOG(1) << \"ATC table: Could not prepare database at path: \" << sqlite_db;\n    return Status(rc, \"Could not prepare database\");\n  }\n\n  while ((sqlite3_step(stmt)) == SQLITE_ROW) {\n    auto s = genSqliteTableRow(stmt, results, sqlite_db);\n    if (!s.ok()) {\n      break;\n    }\n  }\n\n  // Close handles and free memory\n  sqlite3_finalize(stmt);\n  sqlite3_close(db);\n\n  return Status{};\n}",
        "func": "Status genTableRowsForSqliteTable(const fs::path& sqlite_db,\n                                  const std::string& sqlite_query,\n                                  TableRows& results,\n                                  bool respect_locking) {\n  sqlite3* db = nullptr;\n  if (!pathExists(sqlite_db).ok()) {\n    return Status(1, \"Database path does not exist\");\n  }\n\n  auto rc = sqlite3_open_v2(\n      sqlite_db.string().c_str(),\n      &db,\n      (SQLITE_OPEN_READONLY | SQLITE_OPEN_PRIVATECACHE | SQLITE_OPEN_NOMUTEX),\n      getSystemVFS(respect_locking));\n  if (rc != SQLITE_OK || db == nullptr) {\n    VLOG(1) << \"Cannot open specified database: \"\n            << getStringForSQLiteReturnCode(rc);\n    if (db != nullptr) {\n      sqlite3_close(db);\n    }\n    return Status(1, \"Could not open database\");\n  }\n\n  rc = sqlite3_set_authorizer(db, &sqliteAuthorizer, nullptr);\n  if (rc != SQLITE_OK) {\n    sqlite3_close(db);\n    auto errMsg =\n        std::string(\"Failed to set sqlite authorizer: \") + sqlite3_errmsg(db);\n    return Status(1, errMsg);\n  }\n\n  sqlite3_stmt* stmt = nullptr;\n  rc = sqlite3_prepare_v2(db, sqlite_query.c_str(), -1, &stmt, nullptr);\n  if (rc != SQLITE_OK) {\n    sqlite3_close(db);\n    VLOG(1) << \"ATC table: Could not prepare database at path: \" << sqlite_db;\n    return Status(rc, \"Could not prepare database\");\n  }\n\n  while ((sqlite3_step(stmt)) == SQLITE_ROW) {\n    auto s = genSqliteTableRow(stmt, results, sqlite_db);\n    if (!s.ok()) {\n      break;\n    }\n  }\n\n  // Close handles and free memory\n  sqlite3_finalize(stmt);\n  sqlite3_close(db);\n\n  return Status{};\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,6 +21,14 @@\n     return Status(1, \"Could not open database\");\n   }\n \n+  rc = sqlite3_set_authorizer(db, &sqliteAuthorizer, nullptr);\n+  if (rc != SQLITE_OK) {\n+    sqlite3_close(db);\n+    auto errMsg =\n+        std::string(\"Failed to set sqlite authorizer: \") + sqlite3_errmsg(db);\n+    return Status(1, errMsg);\n+  }\n+\n   sqlite3_stmt* stmt = nullptr;\n   rc = sqlite3_prepare_v2(db, sqlite_query.c_str(), -1, &stmt, nullptr);\n   if (rc != SQLITE_OK) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  rc = sqlite3_set_authorizer(db, &sqliteAuthorizer, nullptr);",
                "  if (rc != SQLITE_OK) {",
                "    sqlite3_close(db);",
                "    auto errMsg =",
                "        std::string(\"Failed to set sqlite authorizer: \") + sqlite3_errmsg(db);",
                "    return Status(1, errMsg);",
                "  }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-14868",
        "func_name": "att/ast/sh_strnum",
        "description": "In ksh version 20120801, a flaw was found in the way it evaluates certain environment variables. An attacker could use this flaw to override or bypass environment restrictions to execute shell commands. Services and applications that allow remote unauthenticated attackers to provide one of those environment variables could allow them to exploit this issue remotely.",
        "git_url": "https://github.com/att/ast/commit/c7de8b641266bac7c77942239ac659edfee9ecd2",
        "commit_title": "Harden env var imports",
        "commit_text": "",
        "func_before": "Sfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {\n    Sfdouble_t d;\n    char *last;\n\n    if (*str == 0) {\n        if (ptr) *ptr = (char *)str;\n        return 0;\n    }\n    errno = 0;\n    d = number(str, &last, shp->inarith ? 0 : 10, NULL);\n    if (*last) {\n        if (*last != '.' || last[1] != '.') {\n            d = strval(shp, str, &last, arith, mode);\n            Varsubscript = true;\n        }\n        if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);\n    } else if (!d && *str == '-') {\n        d = -0.0;\n    }\n    if (ptr) *ptr = last;\n    return d;\n}",
        "func": "Sfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {\n    Sfdouble_t d;\n    char *last;\n\n    if (*str == 0) {\n        d = 0.0;\n        last = (char *)str;\n    } else {\n        d = number(str, &last, shp->inarith ? 0 : 10, NULL);\n        if (*last && !shp->inarith && sh_isstate(shp, SH_INIT)) {\n            // This call is to handle \"base#value\" literals if we're importing untrusted env vars.\n            d = number(str, &last, 0, NULL);\n        }\n        if (*last) {\n            if (sh_isstate(shp, SH_INIT)) {\n                // Initializing means importing untrusted env vars. Since the string does not appear\n                // to be a recognized numeric literal give up. We can't safely call strval() since\n                // that allows arbitrary expressions which would create a security vulnerability.\n                d = 0.0;\n            } else {\n                if (*last != '.' || last[1] != '.') {\n                    d = strval(shp, str, &last, arith, mode);\n                    Varsubscript = true;\n                }\n                if (!ptr && *last && mode > 0) {\n                    errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);\n                }\n            }\n        } else if (d == 0.0 && *str == '-') {\n            d = -0.0;\n        }\n    }\n    if (ptr) *ptr = last;\n    return d;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,19 +3,32 @@\n     char *last;\n \n     if (*str == 0) {\n-        if (ptr) *ptr = (char *)str;\n-        return 0;\n-    }\n-    errno = 0;\n-    d = number(str, &last, shp->inarith ? 0 : 10, NULL);\n-    if (*last) {\n-        if (*last != '.' || last[1] != '.') {\n-            d = strval(shp, str, &last, arith, mode);\n-            Varsubscript = true;\n+        d = 0.0;\n+        last = (char *)str;\n+    } else {\n+        d = number(str, &last, shp->inarith ? 0 : 10, NULL);\n+        if (*last && !shp->inarith && sh_isstate(shp, SH_INIT)) {\n+            // This call is to handle \"base#value\" literals if we're importing untrusted env vars.\n+            d = number(str, &last, 0, NULL);\n         }\n-        if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);\n-    } else if (!d && *str == '-') {\n-        d = -0.0;\n+        if (*last) {\n+            if (sh_isstate(shp, SH_INIT)) {\n+                // Initializing means importing untrusted env vars. Since the string does not appear\n+                // to be a recognized numeric literal give up. We can't safely call strval() since\n+                // that allows arbitrary expressions which would create a security vulnerability.\n+                d = 0.0;\n+            } else {\n+                if (*last != '.' || last[1] != '.') {\n+                    d = strval(shp, str, &last, arith, mode);\n+                    Varsubscript = true;\n+                }\n+                if (!ptr && *last && mode > 0) {\n+                    errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);\n+                }\n+            }\n+        } else if (d == 0.0 && *str == '-') {\n+            d = -0.0;\n+        }\n     }\n     if (ptr) *ptr = last;\n     return d;",
        "diff_line_info": {
            "deleted_lines": [
                "        if (ptr) *ptr = (char *)str;",
                "        return 0;",
                "    }",
                "    errno = 0;",
                "    d = number(str, &last, shp->inarith ? 0 : 10, NULL);",
                "    if (*last) {",
                "        if (*last != '.' || last[1] != '.') {",
                "            d = strval(shp, str, &last, arith, mode);",
                "            Varsubscript = true;",
                "        if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);",
                "    } else if (!d && *str == '-') {",
                "        d = -0.0;"
            ],
            "added_lines": [
                "        d = 0.0;",
                "        last = (char *)str;",
                "    } else {",
                "        d = number(str, &last, shp->inarith ? 0 : 10, NULL);",
                "        if (*last && !shp->inarith && sh_isstate(shp, SH_INIT)) {",
                "            // This call is to handle \"base#value\" literals if we're importing untrusted env vars.",
                "            d = number(str, &last, 0, NULL);",
                "        if (*last) {",
                "            if (sh_isstate(shp, SH_INIT)) {",
                "                // Initializing means importing untrusted env vars. Since the string does not appear",
                "                // to be a recognized numeric literal give up. We can't safely call strval() since",
                "                // that allows arbitrary expressions which would create a security vulnerability.",
                "                d = 0.0;",
                "            } else {",
                "                if (*last != '.' || last[1] != '.') {",
                "                    d = strval(shp, str, &last, arith, mode);",
                "                    Varsubscript = true;",
                "                }",
                "                if (!ptr && *last && mode > 0) {",
                "                    errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);",
                "                }",
                "            }",
                "        } else if (d == 0.0 && *str == '-') {",
                "            d = -0.0;",
                "        }"
            ]
        }
    }
]