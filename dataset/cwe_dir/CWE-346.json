[
    {
        "cve_id": "CVE-2017-6519",
        "func_name": "avahi/dispatch_packet",
        "description": "avahi-daemon in Avahi through 0.6.32 and 0.7 inadvertently responds to IPv6 unicast queries with source addresses that are not on-link, which allows remote attackers to cause a denial of service (traffic amplification) and may cause information leakage by obtaining potentially sensitive  information from the responding device via port-5353 UDP packets.  NOTE: this may overlap CVE-2015-2809.",
        "git_url": "https://github.com/avahi/avahi/commit/e111def44a7df4624a4aa3f85fe98054bffb6b4f",
        "commit_title": "Drop legacy unicast queries from address not on local link",
        "commit_text": " When handling legacy unicast queries, ensure that the source IP is inside a subnet on the local link, otherwise drop the packet.  Fixes #145 Fixes #203 CVE-2017-6519 CVE-2018-100084",
        "func_before": "static void dispatch_packet(AvahiServer *s, AvahiDnsPacket *p, const AvahiAddress *src_address, uint16_t port, const AvahiAddress *dst_address, AvahiIfIndex iface, int ttl) {\n    AvahiInterface *i;\n    int from_local_iface = 0;\n\n    assert(s);\n    assert(p);\n    assert(src_address);\n    assert(dst_address);\n    assert(iface > 0);\n    assert(src_address->proto == dst_address->proto);\n\n    if (!(i = avahi_interface_monitor_get_interface(s->monitor, iface, src_address->proto)) ||\n        !i->announcing) {\n        avahi_log_debug(\"Received packet from invalid interface.\");\n        return;\n    }\n\n    if (port <= 0) {\n        /* This fixes RHBZ #475394 */\n        avahi_log_debug(\"Received packet from invalid source port %u.\", (unsigned) port);\n        return;\n    }\n\n    if (avahi_address_is_ipv4_in_ipv6(src_address))\n        /* This is an IPv4 address encapsulated in IPv6, so let's ignore it. */\n        return;\n\n    if (originates_from_local_legacy_unicast_socket(s, src_address, port))\n        /* This originates from our local reflector, so let's ignore it */\n        return;\n\n    /* We don't want to reflect local traffic, so we check if this packet is generated locally. */\n    if (s->config.enable_reflector)\n        from_local_iface = originates_from_local_iface(s, iface, src_address, port);\n\n    if (avahi_dns_packet_check_valid_multicast(p) < 0) {\n        avahi_log_debug(\"Received invalid packet.\");\n        return;\n    }\n\n    if (avahi_dns_packet_is_query(p)) {\n        int legacy_unicast = 0;\n\n        /* For queries EDNS0 might allow ARCOUNT != 0. We ignore the\n         * AR section completely here, so far. Until the day we add\n         * EDNS0 support. */\n\n        if (port != AVAHI_MDNS_PORT) {\n            /* Legacy Unicast */\n\n            if ((avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_ANCOUNT) != 0 ||\n                 avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_NSCOUNT) != 0)) {\n                avahi_log_debug(\"Invalid legacy unicast query packet.\");\n                return;\n            }\n\n            legacy_unicast = 1;\n        }\n\n        if (legacy_unicast)\n            reflect_legacy_unicast_query_packet(s, p, i, src_address, port);\n\n        handle_query_packet(s, p, i, src_address, port, legacy_unicast, from_local_iface);\n\n    } else {\n        char t[AVAHI_ADDRESS_STR_MAX];\n\n        if (port != AVAHI_MDNS_PORT) {\n            avahi_log_debug(\"Received response from host %s with invalid source port %u on interface '%s.%i'\", avahi_address_snprint(t, sizeof(t), src_address), port, i->hardware->name, i->protocol);\n            return;\n        }\n\n        if (ttl != 255 && s->config.check_response_ttl) {\n            avahi_log_debug(\"Received response from host %s with invalid TTL %u on interface '%s.%i'.\", avahi_address_snprint(t, sizeof(t), src_address), ttl, i->hardware->name, i->protocol);\n            return;\n        }\n\n        if (!is_mdns_mcast_address(dst_address) &&\n            !avahi_interface_address_on_link(i, src_address)) {\n\n            avahi_log_debug(\"Received non-local response from host %s on interface '%s.%i'.\", avahi_address_snprint(t, sizeof(t), src_address), i->hardware->name, i->protocol);\n            return;\n        }\n\n        if (avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_QDCOUNT) != 0 ||\n            avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_ANCOUNT) == 0 ||\n            avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_NSCOUNT) != 0) {\n\n            avahi_log_debug(\"Invalid response packet from host %s.\", avahi_address_snprint(t, sizeof(t), src_address));\n            return;\n        }\n\n        handle_response_packet(s, p, i, src_address, from_local_iface);\n    }\n}",
        "func": "static void dispatch_packet(AvahiServer *s, AvahiDnsPacket *p, const AvahiAddress *src_address, uint16_t port, const AvahiAddress *dst_address, AvahiIfIndex iface, int ttl) {\n    AvahiInterface *i;\n    int from_local_iface = 0;\n\n    assert(s);\n    assert(p);\n    assert(src_address);\n    assert(dst_address);\n    assert(iface > 0);\n    assert(src_address->proto == dst_address->proto);\n\n    if (!(i = avahi_interface_monitor_get_interface(s->monitor, iface, src_address->proto)) ||\n        !i->announcing) {\n        avahi_log_debug(\"Received packet from invalid interface.\");\n        return;\n    }\n\n    if (port <= 0) {\n        /* This fixes RHBZ #475394 */\n        avahi_log_debug(\"Received packet from invalid source port %u.\", (unsigned) port);\n        return;\n    }\n\n    if (avahi_address_is_ipv4_in_ipv6(src_address))\n        /* This is an IPv4 address encapsulated in IPv6, so let's ignore it. */\n        return;\n\n    if (originates_from_local_legacy_unicast_socket(s, src_address, port))\n        /* This originates from our local reflector, so let's ignore it */\n        return;\n\n    /* We don't want to reflect local traffic, so we check if this packet is generated locally. */\n    if (s->config.enable_reflector)\n        from_local_iface = originates_from_local_iface(s, iface, src_address, port);\n\n    if (avahi_dns_packet_check_valid_multicast(p) < 0) {\n        avahi_log_debug(\"Received invalid packet.\");\n        return;\n    }\n\n    if (avahi_dns_packet_is_query(p)) {\n        int legacy_unicast = 0;\n        char t[AVAHI_ADDRESS_STR_MAX];\n\n        /* For queries EDNS0 might allow ARCOUNT != 0. We ignore the\n         * AR section completely here, so far. Until the day we add\n         * EDNS0 support. */\n\n        if (port != AVAHI_MDNS_PORT) {\n            /* Legacy Unicast */\n\n            if ((avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_ANCOUNT) != 0 ||\n                 avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_NSCOUNT) != 0)) {\n                avahi_log_debug(\"Invalid legacy unicast query packet.\");\n                return;\n            }\n\n            legacy_unicast = 1;\n        }\n\n        if (!is_mdns_mcast_address(dst_address) &&\n            !avahi_interface_address_on_link(i, src_address)) {\n\n            avahi_log_debug(\"Received non-local unicast query from host %s on interface '%s.%i'.\", avahi_address_snprint(t, sizeof(t), src_address), i->hardware->name, i->protocol);\n            return;\n        }\n\n        if (legacy_unicast)\n            reflect_legacy_unicast_query_packet(s, p, i, src_address, port);\n\n        handle_query_packet(s, p, i, src_address, port, legacy_unicast, from_local_iface);\n\n    } else {\n        char t[AVAHI_ADDRESS_STR_MAX];\n\n        if (port != AVAHI_MDNS_PORT) {\n            avahi_log_debug(\"Received response from host %s with invalid source port %u on interface '%s.%i'\", avahi_address_snprint(t, sizeof(t), src_address), port, i->hardware->name, i->protocol);\n            return;\n        }\n\n        if (ttl != 255 && s->config.check_response_ttl) {\n            avahi_log_debug(\"Received response from host %s with invalid TTL %u on interface '%s.%i'.\", avahi_address_snprint(t, sizeof(t), src_address), ttl, i->hardware->name, i->protocol);\n            return;\n        }\n\n        if (!is_mdns_mcast_address(dst_address) &&\n            !avahi_interface_address_on_link(i, src_address)) {\n\n            avahi_log_debug(\"Received non-local response from host %s on interface '%s.%i'.\", avahi_address_snprint(t, sizeof(t), src_address), i->hardware->name, i->protocol);\n            return;\n        }\n\n        if (avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_QDCOUNT) != 0 ||\n            avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_ANCOUNT) == 0 ||\n            avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_NSCOUNT) != 0) {\n\n            avahi_log_debug(\"Invalid response packet from host %s.\", avahi_address_snprint(t, sizeof(t), src_address));\n            return;\n        }\n\n        handle_response_packet(s, p, i, src_address, from_local_iface);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -40,6 +40,7 @@\n \n     if (avahi_dns_packet_is_query(p)) {\n         int legacy_unicast = 0;\n+        char t[AVAHI_ADDRESS_STR_MAX];\n \n         /* For queries EDNS0 might allow ARCOUNT != 0. We ignore the\n          * AR section completely here, so far. Until the day we add\n@@ -55,6 +56,13 @@\n             }\n \n             legacy_unicast = 1;\n+        }\n+\n+        if (!is_mdns_mcast_address(dst_address) &&\n+            !avahi_interface_address_on_link(i, src_address)) {\n+\n+            avahi_log_debug(\"Received non-local unicast query from host %s on interface '%s.%i'.\", avahi_address_snprint(t, sizeof(t), src_address), i->hardware->name, i->protocol);\n+            return;\n         }\n \n         if (legacy_unicast)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        char t[AVAHI_ADDRESS_STR_MAX];",
                "        }",
                "",
                "        if (!is_mdns_mcast_address(dst_address) &&",
                "            !avahi_interface_address_on_link(i, src_address)) {",
                "",
                "            avahi_log_debug(\"Received non-local unicast query from host %s on interface '%s.%i'.\", avahi_address_snprint(t, sizeof(t), src_address), i->hardware->name, i->protocol);",
                "            return;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-5592",
        "func_name": "profanity-im/profanity/_handle_carbons",
        "description": "An incorrect implementation of \"XEP-0280: Message Carbons\" in multiple XMPP clients allows a remote attacker to impersonate any user, including contacts, in the vulnerable application's display. This allows for various kinds of social engineering attacks. This CVE is for profanity (0.4.7 - 0.5.0).",
        "git_url": "https://github.com/profanity-im/profanity/commit/8e75437a7e43d4c55e861691f74892e666e29b0b",
        "commit_title": "Add carbons from check",
        "commit_text": "",
        "func_before": "static gboolean\n_handle_carbons(xmpp_stanza_t *const stanza)\n{\n    xmpp_stanza_t *carbons = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CARBONS);\n    if (!carbons) {\n        return FALSE;\n    }\n\n    const char *name = xmpp_stanza_get_name(carbons);\n    if (!name) {\n        log_error(\"Unable to retrieve stanza name for Carbon\");\n        return TRUE;\n    }\n\n    if (g_strcmp0(name, \"private\") == 0) {\n        log_info(\"Carbon received with private element.\");\n        return FALSE;\n    }\n\n    if ((g_strcmp0(name, \"received\") != 0) && (g_strcmp0(name, \"sent\") != 0)) {\n        log_warning(\"Carbon received with unrecognised stanza name: %s\", name);\n        return TRUE;\n    }\n\n    xmpp_stanza_t *forwarded = xmpp_stanza_get_child_by_ns(carbons, STANZA_NS_FORWARD);\n    if (!forwarded) {\n        log_warning(\"Carbon received with no forwarded element\");\n        return TRUE;\n    }\n\n    xmpp_stanza_t *message = xmpp_stanza_get_child_by_name(forwarded, STANZA_NAME_MESSAGE);\n    if (!message) {\n        log_warning(\"Carbon received with no message element\");\n        return TRUE;\n    }\n\n    char *message_txt = xmpp_message_get_body(message);\n    if (!message_txt) {\n        log_warning(\"Carbon received with no message.\");\n        return TRUE;\n    }\n\n    const gchar *to = xmpp_stanza_get_to(message);\n    const gchar *from = xmpp_stanza_get_from(message);\n\n    // happens when receive a carbon of a self sent message\n    if (!to) to = from;\n\n    Jid *jid_from = jid_create(from);\n    Jid *jid_to = jid_create(to);\n    Jid *my_jid = jid_create(connection_get_fulljid());\n\n    // check for pgp encrypted message\n    char *enc_message = NULL;\n    xmpp_stanza_t *x = xmpp_stanza_get_child_by_ns(message, STANZA_NS_ENCRYPTED);\n    if (x) {\n        enc_message = xmpp_stanza_get_text(x);\n    }\n\n    // if we are the recipient, treat as standard incoming message\n    if (g_strcmp0(my_jid->barejid, jid_to->barejid) == 0) {\n        sv_ev_incoming_carbon(jid_from->barejid, jid_from->resourcepart, message_txt, enc_message);\n\n    // else treat as a sent message\n    } else {\n        sv_ev_outgoing_carbon(jid_to->barejid, message_txt, enc_message);\n    }\n\n    xmpp_ctx_t *ctx = connection_get_ctx();\n    xmpp_free(ctx, message_txt);\n    xmpp_free(ctx, enc_message);\n\n    jid_destroy(jid_from);\n    jid_destroy(jid_to);\n    jid_destroy(my_jid);\n\n    return TRUE;\n}",
        "func": "static gboolean\n_handle_carbons(xmpp_stanza_t *const stanza)\n{\n    xmpp_stanza_t *carbons = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CARBONS);\n    if (!carbons) {\n        return FALSE;\n    }\n\n    const char *name = xmpp_stanza_get_name(carbons);\n    if (!name) {\n        log_error(\"Unable to retrieve stanza name for Carbon\");\n        return TRUE;\n    }\n\n    if (g_strcmp0(name, \"private\") == 0) {\n        log_info(\"Carbon received with private element.\");\n        return FALSE;\n    }\n\n    if ((g_strcmp0(name, \"received\") != 0) && (g_strcmp0(name, \"sent\") != 0)) {\n        log_warning(\"Carbon received with unrecognised stanza name: %s\", name);\n        return TRUE;\n    }\n\n    xmpp_stanza_t *forwarded = xmpp_stanza_get_child_by_ns(carbons, STANZA_NS_FORWARD);\n    if (!forwarded) {\n        log_warning(\"Carbon received with no forwarded element\");\n        return TRUE;\n    }\n\n    xmpp_stanza_t *message = xmpp_stanza_get_child_by_name(forwarded, STANZA_NAME_MESSAGE);\n    if (!message) {\n        log_warning(\"Carbon received with no message element\");\n        return TRUE;\n    }\n\n    char *message_txt = xmpp_message_get_body(message);\n    if (!message_txt) {\n        log_warning(\"Carbon received with no message.\");\n        return TRUE;\n    }\n\n    Jid *my_jid = jid_create(connection_get_fulljid());\n    const char *const stanza_from = xmpp_stanza_get_from(stanza);\n    Jid *msg_jid = jid_create(stanza_from);\n    if (g_strcmp0(my_jid->barejid, msg_jid->barejid) != 0) {\n        log_warning(\"Invalid carbon received, from: %s\", stanza_from);\n        return TRUE;\n    }\n\n    const gchar *to = xmpp_stanza_get_to(message);\n    const gchar *from = xmpp_stanza_get_from(message);\n\n    // happens when receive a carbon of a self sent message\n    if (!to) to = from;\n\n    Jid *jid_from = jid_create(from);\n    Jid *jid_to = jid_create(to);\n\n    // check for pgp encrypted message\n    char *enc_message = NULL;\n    xmpp_stanza_t *x = xmpp_stanza_get_child_by_ns(message, STANZA_NS_ENCRYPTED);\n    if (x) {\n        enc_message = xmpp_stanza_get_text(x);\n    }\n\n    // if we are the recipient, treat as standard incoming message\n    if (g_strcmp0(my_jid->barejid, jid_to->barejid) == 0) {\n        sv_ev_incoming_carbon(jid_from->barejid, jid_from->resourcepart, message_txt, enc_message);\n\n    // else treat as a sent message\n    } else {\n        sv_ev_outgoing_carbon(jid_to->barejid, message_txt, enc_message);\n    }\n\n    xmpp_ctx_t *ctx = connection_get_ctx();\n    xmpp_free(ctx, message_txt);\n    xmpp_free(ctx, enc_message);\n\n    jid_destroy(jid_from);\n    jid_destroy(jid_to);\n    jid_destroy(my_jid);\n\n    return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -40,6 +40,14 @@\n         return TRUE;\n     }\n \n+    Jid *my_jid = jid_create(connection_get_fulljid());\n+    const char *const stanza_from = xmpp_stanza_get_from(stanza);\n+    Jid *msg_jid = jid_create(stanza_from);\n+    if (g_strcmp0(my_jid->barejid, msg_jid->barejid) != 0) {\n+        log_warning(\"Invalid carbon received, from: %s\", stanza_from);\n+        return TRUE;\n+    }\n+\n     const gchar *to = xmpp_stanza_get_to(message);\n     const gchar *from = xmpp_stanza_get_from(message);\n \n@@ -48,7 +56,6 @@\n \n     Jid *jid_from = jid_create(from);\n     Jid *jid_to = jid_create(to);\n-    Jid *my_jid = jid_create(connection_get_fulljid());\n \n     // check for pgp encrypted message\n     char *enc_message = NULL;",
        "diff_line_info": {
            "deleted_lines": [
                "    Jid *my_jid = jid_create(connection_get_fulljid());"
            ],
            "added_lines": [
                "    Jid *my_jid = jid_create(connection_get_fulljid());",
                "    const char *const stanza_from = xmpp_stanza_get_from(stanza);",
                "    Jid *msg_jid = jid_create(stanza_from);",
                "    if (g_strcmp0(my_jid->barejid, msg_jid->barejid) != 0) {",
                "        log_warning(\"Invalid carbon received, from: %s\", stanza_from);",
                "        return TRUE;",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2017-5593",
        "func_name": "psi-im/iris/JT_PushMessage::take",
        "description": "An incorrect implementation of \"XEP-0280: Message Carbons\" in multiple XMPP clients allows a remote attacker to impersonate any user, including contacts, in the vulnerable application's display. This allows for various kinds of social engineering attacks. This CVE is for Psi+ (0.16.563.580 - 0.16.571.627).",
        "git_url": "https://github.com/psi-im/iris/commit/02e976d4426a1319a7af7d26d7aba9d8c6077570",
        "commit_title": "Try to fix XMPP Client User Impersonation Vulnerability",
        "commit_text": "",
        "func_before": "bool JT_PushMessage::take(const QDomElement &e)\n{\n\tif(e.tagName() != \"message\")\n\t\treturn false;\n\n\tQDomElement e1 = e;\n\tQDomElement forward;\n\tMessage::CarbonDir cd = Message::NoCarbon;\n\n\t// Check for Carbon\n\tQDomNodeList list = e1.childNodes();\n\tfor (int i = 0; i < list.size(); ++i) {\n\t\tQDomElement el = list.at(i).toElement();\n\n\t\tif (el.attribute(\"xmlns\") == QLatin1String(\"urn:xmpp:carbons:2\") && (el.tagName() == QLatin1String(\"received\") || el.tagName() == QLatin1String(\"sent\"))) {\n\t\t\tQDomElement el1 = el.firstChildElement();\n\t\t\tif (el1.tagName() == QLatin1String(\"forwarded\") && el1.attribute(QLatin1String(\"xmlns\")) == QLatin1String(\"urn:xmpp:forward:0\")) {\n\t\t\t\tQDomElement el2 = el1.firstChildElement(QLatin1String(\"message\"));\n\t\t\t\tif (!el2.isNull()) {\n\t\t\t\t\tforward = el2;\n\t\t\t\t\tcd = el.tagName() == QLatin1String(\"received\")? Message::Received : Message::Sent;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (el.tagName() == QLatin1String(\"forwarded\") && el.attribute(QLatin1String(\"xmlns\")) == QLatin1String(\"urn:xmpp:forward:0\")) {\n\t\t\tforward = el.firstChildElement(QLatin1String(\"message\")); // currently only messages are supportted\n\t\t\t// TODO <delay> element support\n\t\t\tif (!forward.isNull()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tQString from = e1.attribute(QLatin1String(\"from\"));\n\tStanza s = client()->stream().createStanza(addCorrectNS(forward.isNull()? e1 : forward));\n\tif(s.isNull()) {\n\t\t//printf(\"take: bad stanza??\\n\");\n\t\treturn false;\n\t}\n\n\tMessage m;\n\tif(!m.fromStanza(s, client()->manualTimeZoneOffset(), client()->timeZoneOffset())) {\n\t\t//printf(\"bad message\\n\");\n\t\treturn false;\n\t}\n\tif (!forward.isNull()) {\n\t\tm.setForwardedFrom(Jid(from));\n\t\tm.setCarbonDirection(cd);\n\t}\n\n\temit message(m);\n\treturn true;\n}",
        "func": "bool JT_PushMessage::take(const QDomElement &e)\n{\n\tif(e.tagName() != \"message\")\n\t\treturn false;\n\n\tQDomElement e1 = e;\n\tQDomElement forward;\n\tMessage::CarbonDir cd = Message::NoCarbon;\n\n\tJid fromJid = Jid(e1.attribute(QLatin1String(\"from\")));\n\t// Check for Carbon\n\tQDomNodeList list = e1.childNodes();\n\tfor (int i = 0; i < list.size(); ++i) {\n\t\tQDomElement el = list.at(i).toElement();\n\n\t\tif (el.attribute(\"xmlns\") == QLatin1String(\"urn:xmpp:carbons:2\")\n\t\t    && (el.tagName() == QLatin1String(\"received\") || el.tagName() == QLatin1String(\"sent\"))\n\t\t    && fromJid.compare(Jid(e1.attribute(QLatin1String(\"to\"))), false)) {\n\t\t\tQDomElement el1 = el.firstChildElement();\n\t\t\tif (el1.tagName() == QLatin1String(\"forwarded\")\n\t\t\t    && el1.attribute(QLatin1String(\"xmlns\")) == QLatin1String(\"urn:xmpp:forward:0\")) {\n\t\t\t\tQDomElement el2 = el1.firstChildElement(QLatin1String(\"message\"));\n\t\t\t\tif (!el2.isNull()) {\n\t\t\t\t\tforward = el2;\n\t\t\t\t\tcd = el.tagName() == QLatin1String(\"received\")? Message::Received : Message::Sent;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (el.tagName() == QLatin1String(\"forwarded\")\n\t\t\t && el.attribute(QLatin1String(\"xmlns\")) == QLatin1String(\"urn:xmpp:forward:0\")) {\n\t\t\tforward = el.firstChildElement(QLatin1String(\"message\")); // currently only messages are supportted\n\t\t\t// TODO <delay> element support\n\t\t\tif (!forward.isNull()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tStanza s = client()->stream().createStanza(addCorrectNS(forward.isNull()? e1 : forward));\n\tif(s.isNull()) {\n\t\t//printf(\"take: bad stanza??\\n\");\n\t\treturn false;\n\t}\n\n\tMessage m;\n\tif(!m.fromStanza(s, client()->manualTimeZoneOffset(), client()->timeZoneOffset())) {\n\t\t//printf(\"bad message\\n\");\n\t\treturn false;\n\t}\n\tif (!forward.isNull()) {\n\t\tm.setForwardedFrom(fromJid);\n\t\tm.setCarbonDirection(cd);\n\t}\n\n\temit message(m);\n\treturn true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,14 +7,18 @@\n \tQDomElement forward;\n \tMessage::CarbonDir cd = Message::NoCarbon;\n \n+\tJid fromJid = Jid(e1.attribute(QLatin1String(\"from\")));\n \t// Check for Carbon\n \tQDomNodeList list = e1.childNodes();\n \tfor (int i = 0; i < list.size(); ++i) {\n \t\tQDomElement el = list.at(i).toElement();\n \n-\t\tif (el.attribute(\"xmlns\") == QLatin1String(\"urn:xmpp:carbons:2\") && (el.tagName() == QLatin1String(\"received\") || el.tagName() == QLatin1String(\"sent\"))) {\n+\t\tif (el.attribute(\"xmlns\") == QLatin1String(\"urn:xmpp:carbons:2\")\n+\t\t    && (el.tagName() == QLatin1String(\"received\") || el.tagName() == QLatin1String(\"sent\"))\n+\t\t    && fromJid.compare(Jid(e1.attribute(QLatin1String(\"to\"))), false)) {\n \t\t\tQDomElement el1 = el.firstChildElement();\n-\t\t\tif (el1.tagName() == QLatin1String(\"forwarded\") && el1.attribute(QLatin1String(\"xmlns\")) == QLatin1String(\"urn:xmpp:forward:0\")) {\n+\t\t\tif (el1.tagName() == QLatin1String(\"forwarded\")\n+\t\t\t    && el1.attribute(QLatin1String(\"xmlns\")) == QLatin1String(\"urn:xmpp:forward:0\")) {\n \t\t\t\tQDomElement el2 = el1.firstChildElement(QLatin1String(\"message\"));\n \t\t\t\tif (!el2.isNull()) {\n \t\t\t\t\tforward = el2;\n@@ -23,7 +27,8 @@\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\telse if (el.tagName() == QLatin1String(\"forwarded\") && el.attribute(QLatin1String(\"xmlns\")) == QLatin1String(\"urn:xmpp:forward:0\")) {\n+\t\telse if (el.tagName() == QLatin1String(\"forwarded\")\n+\t\t\t && el.attribute(QLatin1String(\"xmlns\")) == QLatin1String(\"urn:xmpp:forward:0\")) {\n \t\t\tforward = el.firstChildElement(QLatin1String(\"message\")); // currently only messages are supportted\n \t\t\t// TODO <delay> element support\n \t\t\tif (!forward.isNull()) {\n@@ -32,7 +37,6 @@\n \t\t}\n \t}\n \n-\tQString from = e1.attribute(QLatin1String(\"from\"));\n \tStanza s = client()->stream().createStanza(addCorrectNS(forward.isNull()? e1 : forward));\n \tif(s.isNull()) {\n \t\t//printf(\"take: bad stanza??\\n\");\n@@ -45,7 +49,7 @@\n \t\treturn false;\n \t}\n \tif (!forward.isNull()) {\n-\t\tm.setForwardedFrom(Jid(from));\n+\t\tm.setForwardedFrom(fromJid);\n \t\tm.setCarbonDirection(cd);\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (el.attribute(\"xmlns\") == QLatin1String(\"urn:xmpp:carbons:2\") && (el.tagName() == QLatin1String(\"received\") || el.tagName() == QLatin1String(\"sent\"))) {",
                "\t\t\tif (el1.tagName() == QLatin1String(\"forwarded\") && el1.attribute(QLatin1String(\"xmlns\")) == QLatin1String(\"urn:xmpp:forward:0\")) {",
                "\t\telse if (el.tagName() == QLatin1String(\"forwarded\") && el.attribute(QLatin1String(\"xmlns\")) == QLatin1String(\"urn:xmpp:forward:0\")) {",
                "\tQString from = e1.attribute(QLatin1String(\"from\"));",
                "\t\tm.setForwardedFrom(Jid(from));"
            ],
            "added_lines": [
                "\tJid fromJid = Jid(e1.attribute(QLatin1String(\"from\")));",
                "\t\tif (el.attribute(\"xmlns\") == QLatin1String(\"urn:xmpp:carbons:2\")",
                "\t\t    && (el.tagName() == QLatin1String(\"received\") || el.tagName() == QLatin1String(\"sent\"))",
                "\t\t    && fromJid.compare(Jid(e1.attribute(QLatin1String(\"to\"))), false)) {",
                "\t\t\tif (el1.tagName() == QLatin1String(\"forwarded\")",
                "\t\t\t    && el1.attribute(QLatin1String(\"xmlns\")) == QLatin1String(\"urn:xmpp:forward:0\")) {",
                "\t\telse if (el.tagName() == QLatin1String(\"forwarded\")",
                "\t\t\t && el.attribute(QLatin1String(\"xmlns\")) == QLatin1String(\"urn:xmpp:forward:0\")) {",
                "\t\tm.setForwardedFrom(fromJid);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-1185",
        "func_name": "hotplug/udev/udev_monitor_send_device",
        "description": "udev before 1.4.1 does not verify whether a NETLINK message originates from kernel space, which allows local users to gain privileges by sending a NETLINK message from user space.",
        "git_url": "http://git.kernel.org/?p=linux/hotplug/udev.git;a=commitdiff;h=e86a923d508c2aed371cdd958ce82489cf2ab615",
        "commit_title": "For added protection, ignore any unicast message received on the",
        "commit_text": "netlink socket or any multicast message on the kernel group not received from the kernel.  ",
        "func_before": "int udev_monitor_send_device(struct udev_monitor *udev_monitor, struct udev_device *udev_device)\n{\n\tconst char *buf;\n\tssize_t len;\n\tssize_t count;\n\n\tlen = udev_device_get_properties_monitor_buf(udev_device, &buf);\n\tif (len < 32)\n\t\treturn -1;\n\tif (udev_monitor->sun.sun_family != 0)\n\t\tcount = sendto(udev_monitor->sock,\n\t\t\t       buf, len, 0,\n\t\t\t       (struct sockaddr *)&udev_monitor->sun,\n\t\t\t       udev_monitor->addrlen);\n\telse if (udev_monitor->snl.nl_family != 0)\n\t\t/* no destination besides the muticast group, we will always get ECONNREFUSED */\n\t\tcount = sendto(udev_monitor->sock,\n\t\t\t       buf, len, 0,\n\t\t\t       (struct sockaddr *)&udev_monitor->snl_peer,\n\t\t\t       sizeof(struct sockaddr_nl));\n\telse\n\t\treturn -1;\n\n\tinfo(udev_monitor->udev, \"passed %zi bytes to monitor %p, \\n\", count, udev_monitor);\n\treturn count;\n}",
        "func": "int udev_monitor_send_device(struct udev_monitor *udev_monitor, struct udev_device *udev_device)\n{\n\tconst char *buf;\n\tssize_t len;\n\tssize_t count;\n\n\tlen = udev_device_get_properties_monitor_buf(udev_device, &buf);\n\tif (len < 32)\n\t\treturn -1;\n\tif (udev_monitor->sun.sun_family != 0)\n\t\tcount = sendto(udev_monitor->sock,\n\t\t\t       buf, len, 0,\n\t\t\t       (struct sockaddr *)&udev_monitor->sun,\n\t\t\t       udev_monitor->addrlen);\n\telse if (udev_monitor->snl.nl_family != 0)\n\t\t/* no destination besides the muticast group, we will always get ECONNREFUSED */\n\t\tcount = sendto(udev_monitor->sock,\n\t\t\t       buf, len, 0,\n\t\t\t       (struct sockaddr *)&udev_monitor->snl_peer,\n\t\t\t       sizeof(struct sockaddr_nl));\n\telse\n\t\treturn -1;\n\n\tinfo(udev_monitor->udev, \"passed %zi bytes to monitor %p\\n\", count, udev_monitor);\n\treturn count;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,6 +21,6 @@\n \telse\n \t\treturn -1;\n \n-\tinfo(udev_monitor->udev, \"passed %zi bytes to monitor %p, \\n\", count, udev_monitor);\n+\tinfo(udev_monitor->udev, \"passed %zi bytes to monitor %p\\n\", count, udev_monitor);\n \treturn count;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tinfo(udev_monitor->udev, \"passed %zi bytes to monitor %p, \\n\", count, udev_monitor);"
            ],
            "added_lines": [
                "\tinfo(udev_monitor->udev, \"passed %zi bytes to monitor %p\\n\", count, udev_monitor);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-1185",
        "func_name": "hotplug/udev/udev_monitor_receive_device",
        "description": "udev before 1.4.1 does not verify whether a NETLINK message originates from kernel space, which allows local users to gain privileges by sending a NETLINK message from user space.",
        "git_url": "http://git.kernel.org/?p=linux/hotplug/udev.git;a=commitdiff;h=e86a923d508c2aed371cdd958ce82489cf2ab615",
        "commit_title": "For added protection, ignore any unicast message received on the",
        "commit_text": "netlink socket or any multicast message on the kernel group not received from the kernel.  ",
        "func_before": "struct udev_device *udev_monitor_receive_device(struct udev_monitor *udev_monitor)\n{\n\tstruct udev_device *udev_device;\n\tstruct msghdr smsg;\n\tstruct iovec iov;\n\tchar cred_msg[CMSG_SPACE(sizeof(struct ucred))];\n\tstruct cmsghdr *cmsg;\n\tstruct ucred *cred;\n\tchar buf[4096];\n\tsize_t bufpos;\n\tint devpath_set = 0;\n\tint subsystem_set = 0;\n\tint action_set = 0;\n\tint maj = 0;\n\tint min = 0;\n\n\tif (udev_monitor == NULL)\n\t\treturn NULL;\n\tmemset(buf, 0x00, sizeof(buf));\n\tiov.iov_base = &buf;\n\tiov.iov_len = sizeof(buf);\n\tmemset (&smsg, 0x00, sizeof(struct msghdr));\n\tsmsg.msg_iov = &iov;\n\tsmsg.msg_iovlen = 1;\n\tsmsg.msg_control = cred_msg;\n\tsmsg.msg_controllen = sizeof(cred_msg);\n\n\tif (recvmsg(udev_monitor->sock, &smsg, 0) < 0) {\n\t\tif (errno != EINTR)\n\t\t\tinfo(udev_monitor->udev, \"unable to receive message\");\n\t\treturn NULL;\n\t}\n\n\tcmsg = CMSG_FIRSTHDR(&smsg);\n\tif (cmsg == NULL || cmsg->cmsg_type != SCM_CREDENTIALS) {\n\t\tinfo(udev_monitor->udev, \"no sender credentials received, message ignored\");\n\t\treturn NULL;\n\t}\n\n\tcred = (struct ucred *)CMSG_DATA(cmsg);\n\tif (cred->uid != 0) {\n\t\tinfo(udev_monitor->udev, \"sender uid=%d, message ignored\", cred->uid);\n\t\treturn NULL;\n\t}\n\n\t/* skip header */\n\tbufpos = strlen(buf) + 1;\n\tif (bufpos < sizeof(\"a@/d\") || bufpos >= sizeof(buf)) {\n\t\tinfo(udev_monitor->udev, \"invalid message length\");\n\t\treturn NULL;\n\t}\n\n\t/* check message header */\n\tif (strstr(buf, \"@/\") == NULL) {\n\t\tinfo(udev_monitor->udev, \"unrecognized message header\");\n\t\treturn NULL;\n\t}\n\n\tudev_device = device_new(udev_monitor->udev);\n\tif (udev_device == NULL) {\n\t\treturn NULL;\n\t}\n\n\twhile (bufpos < sizeof(buf)) {\n\t\tchar *key;\n\t\tsize_t keylen;\n\n\t\tkey = &buf[bufpos];\n\t\tkeylen = strlen(key);\n\t\tif (keylen == 0)\n\t\t\tbreak;\n\t\tbufpos += keylen + 1;\n\n\t\tif (strncmp(key, \"DEVPATH=\", 8) == 0) {\n\t\t\tchar path[UTIL_PATH_SIZE];\n\n\t\t\tutil_strlcpy(path, udev_get_sys_path(udev_monitor->udev), sizeof(path));\n\t\t\tutil_strlcat(path, &key[8], sizeof(path));\n\t\t\tudev_device_set_syspath(udev_device, path);\n\t\t\tdevpath_set = 1;\n\t\t} else if (strncmp(key, \"SUBSYSTEM=\", 10) == 0) {\n\t\t\tudev_device_set_subsystem(udev_device, &key[10]);\n\t\t\tsubsystem_set = 1;\n\t\t} else if (strncmp(key, \"DEVTYPE=\", 8) == 0) {\n\t\t\tudev_device_set_devtype(udev_device, &key[8]);\n\t\t} else if (strncmp(key, \"DEVNAME=\", 8) == 0) {\n\t\t\tudev_device_set_devnode(udev_device, &key[8]);\n\t\t} else if (strncmp(key, \"DEVLINKS=\", 9) == 0) {\n\t\t\tchar devlinks[UTIL_PATH_SIZE];\n\t\t\tchar *slink;\n\t\t\tchar *next;\n\n\t\t\tutil_strlcpy(devlinks, &key[9], sizeof(devlinks));\n\t\t\tslink = devlinks;\n\t\t\tnext = strchr(slink, ' ');\n\t\t\twhile (next != NULL) {\n\t\t\t\tnext[0] = '\\0';\n\t\t\t\tudev_device_add_devlink(udev_device, slink);\n\t\t\t\tslink = &next[1];\n\t\t\t\tnext = strchr(slink, ' ');\n\t\t\t}\n\t\t\tif (slink[0] != '\\0')\n\t\t\t\tudev_device_add_devlink(udev_device, slink);\n\t\t} else if (strncmp(key, \"DRIVER=\", 7) == 0) {\n\t\t\tudev_device_set_driver(udev_device, &key[7]);\n\t\t} else if (strncmp(key, \"ACTION=\", 7) == 0) {\n\t\t\tudev_device_set_action(udev_device, &key[7]);\n\t\t\taction_set = 1;\n\t\t} else if (strncmp(key, \"MAJOR=\", 6) == 0) {\n\t\t\tmaj = strtoull(&key[6], NULL, 10);\n\t\t} else if (strncmp(key, \"MINOR=\", 6) == 0) {\n\t\t\tmin = strtoull(&key[6], NULL, 10);\n\t\t} else if (strncmp(key, \"DEVPATH_OLD=\", 12) == 0) {\n\t\t\tudev_device_set_devpath_old(udev_device, &key[12]);\n\t\t} else if (strncmp(key, \"PHYSDEVPATH=\", 12) == 0) {\n\t\t\tudev_device_set_physdevpath(udev_device, &key[12]);\n\t\t} else if (strncmp(key, \"SEQNUM=\", 7) == 0) {\n\t\t\tudev_device_set_seqnum(udev_device, strtoull(&key[7], NULL, 10));\n\t\t} else if (strncmp(key, \"TIMEOUT=\", 8) == 0) {\n\t\t\tudev_device_set_timeout(udev_device, strtoull(&key[8], NULL, 10));\n\t\t} else if (strncmp(key, \"PHYSDEV\", 7) == 0) {\n\t\t\t/* skip deprecated values */\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tudev_device_add_property_from_string(udev_device, key);\n\t\t}\n\t}\n\tif (!devpath_set || !subsystem_set || !action_set) {\n\t\tinfo(udev_monitor->udev, \"missing values, skip\\n\");\n\t\tudev_device_unref(udev_device);\n\t\treturn NULL;\n\t}\n\tif (maj > 0)\n\t\tudev_device_set_devnum(udev_device, makedev(maj, min));\n\tudev_device_set_info_loaded(udev_device);\n\treturn udev_device;\n}",
        "func": "struct udev_device *udev_monitor_receive_device(struct udev_monitor *udev_monitor)\n{\n\tstruct udev_device *udev_device;\n\tstruct msghdr smsg;\n\tstruct iovec iov;\n\tchar cred_msg[CMSG_SPACE(sizeof(struct ucred))];\n\tstruct cmsghdr *cmsg;\n\tstruct sockaddr_nl snl;\n\tstruct ucred *cred;\n\tchar buf[4096];\n\tsize_t bufpos;\n\tint devpath_set = 0;\n\tint subsystem_set = 0;\n\tint action_set = 0;\n\tint maj = 0;\n\tint min = 0;\n\n\tif (udev_monitor == NULL)\n\t\treturn NULL;\n\tmemset(buf, 0x00, sizeof(buf));\n\tiov.iov_base = &buf;\n\tiov.iov_len = sizeof(buf);\n\tmemset (&smsg, 0x00, sizeof(struct msghdr));\n\tsmsg.msg_iov = &iov;\n\tsmsg.msg_iovlen = 1;\n\tsmsg.msg_control = cred_msg;\n\tsmsg.msg_controllen = sizeof(cred_msg);\n\n\tif (udev_monitor->snl.nl_family != 0) {\n\t\tsmsg.msg_name = &snl;\n\t\tsmsg.msg_namelen = sizeof snl;\n\t}\n\n\tif (recvmsg(udev_monitor->sock, &smsg, 0) < 0) {\n\t\tif (errno != EINTR)\n\t\t\tinfo(udev_monitor->udev, \"unable to receive message\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (udev_monitor->snl.nl_family != 0) {\n\t\tif (snl.nl_groups == 0) {\n\t\t\tinfo(udev_monitor->udev, \"unicast netlink message ignored\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif ((snl.nl_groups == UDEV_MONITOR_KERNEL) && (snl.nl_pid > 0)) {\n\t\t\tinfo(udev_monitor->udev, \"multicast kernel netlink message from pid %d ignored\\n\", snl.nl_pid);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tcmsg = CMSG_FIRSTHDR(&smsg);\n\tif (cmsg == NULL || cmsg->cmsg_type != SCM_CREDENTIALS) {\n\t\tinfo(udev_monitor->udev, \"no sender credentials received, message ignored\\n\");\n\t\treturn NULL;\n\t}\n\n\tcred = (struct ucred *)CMSG_DATA(cmsg);\n\tif (cred->uid != 0) {\n\t\tinfo(udev_monitor->udev, \"sender uid=%d, message ignored\\n\", cred->uid);\n\t\treturn NULL;\n\t}\n\n\t/* skip header */\n\tbufpos = strlen(buf) + 1;\n\tif (bufpos < sizeof(\"a@/d\") || bufpos >= sizeof(buf)) {\n\t\tinfo(udev_monitor->udev, \"invalid message length\\n\");\n\t\treturn NULL;\n\t}\n\n\t/* check message header */\n\tif (strstr(buf, \"@/\") == NULL) {\n\t\tinfo(udev_monitor->udev, \"unrecognized message header\\n\");\n\t\treturn NULL;\n\t}\n\n\tudev_device = device_new(udev_monitor->udev);\n\tif (udev_device == NULL) {\n\t\treturn NULL;\n\t}\n\n\twhile (bufpos < sizeof(buf)) {\n\t\tchar *key;\n\t\tsize_t keylen;\n\n\t\tkey = &buf[bufpos];\n\t\tkeylen = strlen(key);\n\t\tif (keylen == 0)\n\t\t\tbreak;\n\t\tbufpos += keylen + 1;\n\n\t\tif (strncmp(key, \"DEVPATH=\", 8) == 0) {\n\t\t\tchar path[UTIL_PATH_SIZE];\n\n\t\t\tutil_strlcpy(path, udev_get_sys_path(udev_monitor->udev), sizeof(path));\n\t\t\tutil_strlcat(path, &key[8], sizeof(path));\n\t\t\tudev_device_set_syspath(udev_device, path);\n\t\t\tdevpath_set = 1;\n\t\t} else if (strncmp(key, \"SUBSYSTEM=\", 10) == 0) {\n\t\t\tudev_device_set_subsystem(udev_device, &key[10]);\n\t\t\tsubsystem_set = 1;\n\t\t} else if (strncmp(key, \"DEVTYPE=\", 8) == 0) {\n\t\t\tudev_device_set_devtype(udev_device, &key[8]);\n\t\t} else if (strncmp(key, \"DEVNAME=\", 8) == 0) {\n\t\t\tudev_device_set_devnode(udev_device, &key[8]);\n\t\t} else if (strncmp(key, \"DEVLINKS=\", 9) == 0) {\n\t\t\tchar devlinks[UTIL_PATH_SIZE];\n\t\t\tchar *slink;\n\t\t\tchar *next;\n\n\t\t\tutil_strlcpy(devlinks, &key[9], sizeof(devlinks));\n\t\t\tslink = devlinks;\n\t\t\tnext = strchr(slink, ' ');\n\t\t\twhile (next != NULL) {\n\t\t\t\tnext[0] = '\\0';\n\t\t\t\tudev_device_add_devlink(udev_device, slink);\n\t\t\t\tslink = &next[1];\n\t\t\t\tnext = strchr(slink, ' ');\n\t\t\t}\n\t\t\tif (slink[0] != '\\0')\n\t\t\t\tudev_device_add_devlink(udev_device, slink);\n\t\t} else if (strncmp(key, \"DRIVER=\", 7) == 0) {\n\t\t\tudev_device_set_driver(udev_device, &key[7]);\n\t\t} else if (strncmp(key, \"ACTION=\", 7) == 0) {\n\t\t\tudev_device_set_action(udev_device, &key[7]);\n\t\t\taction_set = 1;\n\t\t} else if (strncmp(key, \"MAJOR=\", 6) == 0) {\n\t\t\tmaj = strtoull(&key[6], NULL, 10);\n\t\t} else if (strncmp(key, \"MINOR=\", 6) == 0) {\n\t\t\tmin = strtoull(&key[6], NULL, 10);\n\t\t} else if (strncmp(key, \"DEVPATH_OLD=\", 12) == 0) {\n\t\t\tudev_device_set_devpath_old(udev_device, &key[12]);\n\t\t} else if (strncmp(key, \"PHYSDEVPATH=\", 12) == 0) {\n\t\t\tudev_device_set_physdevpath(udev_device, &key[12]);\n\t\t} else if (strncmp(key, \"SEQNUM=\", 7) == 0) {\n\t\t\tudev_device_set_seqnum(udev_device, strtoull(&key[7], NULL, 10));\n\t\t} else if (strncmp(key, \"TIMEOUT=\", 8) == 0) {\n\t\t\tudev_device_set_timeout(udev_device, strtoull(&key[8], NULL, 10));\n\t\t} else if (strncmp(key, \"PHYSDEV\", 7) == 0) {\n\t\t\t/* skip deprecated values */\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tudev_device_add_property_from_string(udev_device, key);\n\t\t}\n\t}\n\tif (!devpath_set || !subsystem_set || !action_set) {\n\t\tinfo(udev_monitor->udev, \"missing values, skip\\n\");\n\t\tudev_device_unref(udev_device);\n\t\treturn NULL;\n\t}\n\tif (maj > 0)\n\t\tudev_device_set_devnum(udev_device, makedev(maj, min));\n\tudev_device_set_info_loaded(udev_device);\n\treturn udev_device;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,6 +5,7 @@\n \tstruct iovec iov;\n \tchar cred_msg[CMSG_SPACE(sizeof(struct ucred))];\n \tstruct cmsghdr *cmsg;\n+\tstruct sockaddr_nl snl;\n \tstruct ucred *cred;\n \tchar buf[4096];\n \tsize_t bufpos;\n@@ -25,34 +26,50 @@\n \tsmsg.msg_control = cred_msg;\n \tsmsg.msg_controllen = sizeof(cred_msg);\n \n+\tif (udev_monitor->snl.nl_family != 0) {\n+\t\tsmsg.msg_name = &snl;\n+\t\tsmsg.msg_namelen = sizeof snl;\n+\t}\n+\n \tif (recvmsg(udev_monitor->sock, &smsg, 0) < 0) {\n \t\tif (errno != EINTR)\n-\t\t\tinfo(udev_monitor->udev, \"unable to receive message\");\n+\t\t\tinfo(udev_monitor->udev, \"unable to receive message\\n\");\n \t\treturn NULL;\n+\t}\n+\n+\tif (udev_monitor->snl.nl_family != 0) {\n+\t\tif (snl.nl_groups == 0) {\n+\t\t\tinfo(udev_monitor->udev, \"unicast netlink message ignored\\n\");\n+\t\t\treturn NULL;\n+\t\t}\n+\t\tif ((snl.nl_groups == UDEV_MONITOR_KERNEL) && (snl.nl_pid > 0)) {\n+\t\t\tinfo(udev_monitor->udev, \"multicast kernel netlink message from pid %d ignored\\n\", snl.nl_pid);\n+\t\t\treturn NULL;\n+\t\t}\n \t}\n \n \tcmsg = CMSG_FIRSTHDR(&smsg);\n \tif (cmsg == NULL || cmsg->cmsg_type != SCM_CREDENTIALS) {\n-\t\tinfo(udev_monitor->udev, \"no sender credentials received, message ignored\");\n+\t\tinfo(udev_monitor->udev, \"no sender credentials received, message ignored\\n\");\n \t\treturn NULL;\n \t}\n \n \tcred = (struct ucred *)CMSG_DATA(cmsg);\n \tif (cred->uid != 0) {\n-\t\tinfo(udev_monitor->udev, \"sender uid=%d, message ignored\", cred->uid);\n+\t\tinfo(udev_monitor->udev, \"sender uid=%d, message ignored\\n\", cred->uid);\n \t\treturn NULL;\n \t}\n \n \t/* skip header */\n \tbufpos = strlen(buf) + 1;\n \tif (bufpos < sizeof(\"a@/d\") || bufpos >= sizeof(buf)) {\n-\t\tinfo(udev_monitor->udev, \"invalid message length\");\n+\t\tinfo(udev_monitor->udev, \"invalid message length\\n\");\n \t\treturn NULL;\n \t}\n \n \t/* check message header */\n \tif (strstr(buf, \"@/\") == NULL) {\n-\t\tinfo(udev_monitor->udev, \"unrecognized message header\");\n+\t\tinfo(udev_monitor->udev, \"unrecognized message header\\n\");\n \t\treturn NULL;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tinfo(udev_monitor->udev, \"unable to receive message\");",
                "\t\tinfo(udev_monitor->udev, \"no sender credentials received, message ignored\");",
                "\t\tinfo(udev_monitor->udev, \"sender uid=%d, message ignored\", cred->uid);",
                "\t\tinfo(udev_monitor->udev, \"invalid message length\");",
                "\t\tinfo(udev_monitor->udev, \"unrecognized message header\");"
            ],
            "added_lines": [
                "\tstruct sockaddr_nl snl;",
                "\tif (udev_monitor->snl.nl_family != 0) {",
                "\t\tsmsg.msg_name = &snl;",
                "\t\tsmsg.msg_namelen = sizeof snl;",
                "\t}",
                "",
                "\t\t\tinfo(udev_monitor->udev, \"unable to receive message\\n\");",
                "\t}",
                "",
                "\tif (udev_monitor->snl.nl_family != 0) {",
                "\t\tif (snl.nl_groups == 0) {",
                "\t\t\tinfo(udev_monitor->udev, \"unicast netlink message ignored\\n\");",
                "\t\t\treturn NULL;",
                "\t\t}",
                "\t\tif ((snl.nl_groups == UDEV_MONITOR_KERNEL) && (snl.nl_pid > 0)) {",
                "\t\t\tinfo(udev_monitor->udev, \"multicast kernel netlink message from pid %d ignored\\n\", snl.nl_pid);",
                "\t\t\treturn NULL;",
                "\t\t}",
                "\t\tinfo(udev_monitor->udev, \"no sender credentials received, message ignored\\n\");",
                "\t\tinfo(udev_monitor->udev, \"sender uid=%d, message ignored\\n\", cred->uid);",
                "\t\tinfo(udev_monitor->udev, \"invalid message length\\n\");",
                "\t\tinfo(udev_monitor->udev, \"unrecognized message header\\n\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-1185",
        "func_name": "hotplug/udev/udev_monitor_send_device",
        "description": "udev before 1.4.1 does not verify whether a NETLINK message originates from kernel space, which allows local users to gain privileges by sending a NETLINK message from user space.",
        "git_url": "http://git.kernel.org/?p=linux/hotplug/udev.git;a=commitdiff;h=e2b362d9f23d4c63018709ab5f81a02f72b91e75",
        "commit_title": "",
        "commit_text": "",
        "func_before": "int udev_monitor_send_device(struct udev_monitor *udev_monitor, struct udev_device *udev_device)\n{\n\tconst char *buf;\n\tssize_t len;\n\tssize_t count;\n\n\tlen = udev_device_get_properties_monitor_buf(udev_device, &buf);\n\tif (len < 32)\n\t\treturn -1;\n\tif (udev_monitor->sun.sun_family != 0) {\n\t\tcount = sendto(udev_monitor->sock,\n\t\t\t       buf, len, 0,\n\t\t\t       (struct sockaddr *)&udev_monitor->sun,\n\t\t\t       udev_monitor->addrlen);\n\t} else {\n\t\t/* no destination besides the muticast group, we will always get -1 ECONNREFUSED */\n\t\tcount = sendto(udev_monitor->sock,\n\t\t\t       buf, len, 0,\n\t\t\t       (struct sockaddr *)&udev_monitor->snl_peer,\n\t\t\t       sizeof(struct sockaddr_nl));\n\t}\n\tinfo(udev_monitor->udev, \"passed %zi bytes to monitor %p, \\n\", count, udev_monitor);\n\treturn count;\n}",
        "func": "int udev_monitor_send_device(struct udev_monitor *udev_monitor, struct udev_device *udev_device)\n{\n\tconst char *buf;\n\tssize_t len;\n\tssize_t count;\n\n\tlen = udev_device_get_properties_monitor_buf(udev_device, &buf);\n\tif (len < 32)\n\t\treturn -1;\n\tif (udev_monitor->sun.sun_family != 0)\n\t\tcount = sendto(udev_monitor->sock,\n\t\t\t       buf, len, 0,\n\t\t\t       (struct sockaddr *)&udev_monitor->sun,\n\t\t\t       udev_monitor->addrlen);\n\telse if (udev_monitor->snl.nl_family != 0)\n\t\t/* no destination besides the muticast group, we will always get ECONNREFUSED */\n\t\tcount = sendto(udev_monitor->sock,\n\t\t\t       buf, len, 0,\n\t\t\t       (struct sockaddr *)&udev_monitor->snl_peer,\n\t\t\t       sizeof(struct sockaddr_nl));\n\telse\n\t\treturn -1;\n\n\tinfo(udev_monitor->udev, \"passed %zi bytes to monitor %p, \\n\", count, udev_monitor);\n\treturn count;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,18 +7,20 @@\n \tlen = udev_device_get_properties_monitor_buf(udev_device, &buf);\n \tif (len < 32)\n \t\treturn -1;\n-\tif (udev_monitor->sun.sun_family != 0) {\n+\tif (udev_monitor->sun.sun_family != 0)\n \t\tcount = sendto(udev_monitor->sock,\n \t\t\t       buf, len, 0,\n \t\t\t       (struct sockaddr *)&udev_monitor->sun,\n \t\t\t       udev_monitor->addrlen);\n-\t} else {\n-\t\t/* no destination besides the muticast group, we will always get -1 ECONNREFUSED */\n+\telse if (udev_monitor->snl.nl_family != 0)\n+\t\t/* no destination besides the muticast group, we will always get ECONNREFUSED */\n \t\tcount = sendto(udev_monitor->sock,\n \t\t\t       buf, len, 0,\n \t\t\t       (struct sockaddr *)&udev_monitor->snl_peer,\n \t\t\t       sizeof(struct sockaddr_nl));\n-\t}\n+\telse\n+\t\treturn -1;\n+\n \tinfo(udev_monitor->udev, \"passed %zi bytes to monitor %p, \\n\", count, udev_monitor);\n \treturn count;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (udev_monitor->sun.sun_family != 0) {",
                "\t} else {",
                "\t\t/* no destination besides the muticast group, we will always get -1 ECONNREFUSED */",
                "\t}"
            ],
            "added_lines": [
                "\tif (udev_monitor->sun.sun_family != 0)",
                "\telse if (udev_monitor->snl.nl_family != 0)",
                "\t\t/* no destination besides the muticast group, we will always get ECONNREFUSED */",
                "\telse",
                "\t\treturn -1;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2009-1185",
        "func_name": "hotplug/udev/udev_monitor_enable_receiving",
        "description": "udev before 1.4.1 does not verify whether a NETLINK message originates from kernel space, which allows local users to gain privileges by sending a NETLINK message from user space.",
        "git_url": "http://git.kernel.org/?p=linux/hotplug/udev.git;a=commitdiff;h=e2b362d9f23d4c63018709ab5f81a02f72b91e75",
        "commit_title": "",
        "commit_text": "",
        "func_before": "int udev_monitor_enable_receiving(struct udev_monitor *udev_monitor)\n{\n\tint err;\n\tconst int on = 1;\n\n\tif (udev_monitor->snl.nl_family != 0) {\n\t\terr = bind(udev_monitor->sock,\n\t\t\t   (struct sockaddr *)&udev_monitor->snl, sizeof(struct sockaddr_nl));\n\t\tif (err < 0) {\n\t\t\terr(udev_monitor->udev, \"bind failed: %m\\n\");\n\t\t\treturn err;\n\t\t}\n\t\tdbg(udev_monitor->udev, \"monitor %p listening on netlink\\n\", udev_monitor);\n\t} else if (udev_monitor->sun.sun_family != 0) {\n\t\terr = bind(udev_monitor->sock,\n\t\t\t   (struct sockaddr *)&udev_monitor->sun, udev_monitor->addrlen);\n\t\tif (err < 0) {\n\t\t\terr(udev_monitor->udev, \"bind failed: %m\\n\");\n\t\t\treturn err;\n\t\t}\n\t\t/* enable receiving of the sender credentials */\n\t\tsetsockopt(udev_monitor->sock, SOL_SOCKET, SO_PASSCRED, &on, sizeof(on));\n\t\tdbg(udev_monitor->udev, \"monitor %p listening on socket\\n\", udev_monitor);\n\t}\n\treturn 0;\n}",
        "func": "int udev_monitor_enable_receiving(struct udev_monitor *udev_monitor)\n{\n\tint err;\n\tconst int on = 1;\n\n\tif (udev_monitor->sun.sun_family != 0)\n\t\terr = bind(udev_monitor->sock,\n\t\t\t   (struct sockaddr *)&udev_monitor->sun, udev_monitor->addrlen);\n\telse if (udev_monitor->snl.nl_family != 0)\n\t\terr = bind(udev_monitor->sock,\n\t\t\t   (struct sockaddr *)&udev_monitor->snl, sizeof(struct sockaddr_nl));\n\telse\n\t\treturn -EINVAL;\n\n\tif (err < 0) {\n\t\terr(udev_monitor->udev, \"bind failed: %m\\n\");\n\t\treturn err;\n\t}\n\n\t/* enable receiving of sender credentials */\n\tsetsockopt(udev_monitor->sock, SOL_SOCKET, SO_PASSCRED, &on, sizeof(on));\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,24 +3,21 @@\n \tint err;\n \tconst int on = 1;\n \n-\tif (udev_monitor->snl.nl_family != 0) {\n+\tif (udev_monitor->sun.sun_family != 0)\n+\t\terr = bind(udev_monitor->sock,\n+\t\t\t   (struct sockaddr *)&udev_monitor->sun, udev_monitor->addrlen);\n+\telse if (udev_monitor->snl.nl_family != 0)\n \t\terr = bind(udev_monitor->sock,\n \t\t\t   (struct sockaddr *)&udev_monitor->snl, sizeof(struct sockaddr_nl));\n-\t\tif (err < 0) {\n-\t\t\terr(udev_monitor->udev, \"bind failed: %m\\n\");\n-\t\t\treturn err;\n-\t\t}\n-\t\tdbg(udev_monitor->udev, \"monitor %p listening on netlink\\n\", udev_monitor);\n-\t} else if (udev_monitor->sun.sun_family != 0) {\n-\t\terr = bind(udev_monitor->sock,\n-\t\t\t   (struct sockaddr *)&udev_monitor->sun, udev_monitor->addrlen);\n-\t\tif (err < 0) {\n-\t\t\terr(udev_monitor->udev, \"bind failed: %m\\n\");\n-\t\t\treturn err;\n-\t\t}\n-\t\t/* enable receiving of the sender credentials */\n-\t\tsetsockopt(udev_monitor->sock, SOL_SOCKET, SO_PASSCRED, &on, sizeof(on));\n-\t\tdbg(udev_monitor->udev, \"monitor %p listening on socket\\n\", udev_monitor);\n+\telse\n+\t\treturn -EINVAL;\n+\n+\tif (err < 0) {\n+\t\terr(udev_monitor->udev, \"bind failed: %m\\n\");\n+\t\treturn err;\n \t}\n+\n+\t/* enable receiving of sender credentials */\n+\tsetsockopt(udev_monitor->sock, SOL_SOCKET, SO_PASSCRED, &on, sizeof(on));\n \treturn 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (udev_monitor->snl.nl_family != 0) {",
                "\t\tif (err < 0) {",
                "\t\t\terr(udev_monitor->udev, \"bind failed: %m\\n\");",
                "\t\t\treturn err;",
                "\t\t}",
                "\t\tdbg(udev_monitor->udev, \"monitor %p listening on netlink\\n\", udev_monitor);",
                "\t} else if (udev_monitor->sun.sun_family != 0) {",
                "\t\terr = bind(udev_monitor->sock,",
                "\t\t\t   (struct sockaddr *)&udev_monitor->sun, udev_monitor->addrlen);",
                "\t\tif (err < 0) {",
                "\t\t\terr(udev_monitor->udev, \"bind failed: %m\\n\");",
                "\t\t\treturn err;",
                "\t\t}",
                "\t\t/* enable receiving of the sender credentials */",
                "\t\tsetsockopt(udev_monitor->sock, SOL_SOCKET, SO_PASSCRED, &on, sizeof(on));",
                "\t\tdbg(udev_monitor->udev, \"monitor %p listening on socket\\n\", udev_monitor);"
            ],
            "added_lines": [
                "\tif (udev_monitor->sun.sun_family != 0)",
                "\t\terr = bind(udev_monitor->sock,",
                "\t\t\t   (struct sockaddr *)&udev_monitor->sun, udev_monitor->addrlen);",
                "\telse if (udev_monitor->snl.nl_family != 0)",
                "\telse",
                "\t\treturn -EINVAL;",
                "",
                "\tif (err < 0) {",
                "\t\terr(udev_monitor->udev, \"bind failed: %m\\n\");",
                "\t\treturn err;",
                "",
                "\t/* enable receiving of sender credentials */",
                "\tsetsockopt(udev_monitor->sock, SOL_SOCKET, SO_PASSCRED, &on, sizeof(on));"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-1185",
        "func_name": "hotplug/udev/udev_monitor_receive_device",
        "description": "udev before 1.4.1 does not verify whether a NETLINK message originates from kernel space, which allows local users to gain privileges by sending a NETLINK message from user space.",
        "git_url": "http://git.kernel.org/?p=linux/hotplug/udev.git;a=commitdiff;h=e2b362d9f23d4c63018709ab5f81a02f72b91e75",
        "commit_title": "",
        "commit_text": "",
        "func_before": "struct udev_device *udev_monitor_receive_device(struct udev_monitor *udev_monitor)\n{\n\tstruct udev_device *udev_device;\n\tstruct msghdr smsg;\n\tstruct iovec iov;\n\tchar cred_msg[CMSG_SPACE(sizeof(struct ucred))];\n\tchar buf[4096];\n\tsize_t bufpos;\n\tint devpath_set = 0;\n\tint subsystem_set = 0;\n\tint action_set = 0;\n\tint maj = 0;\n\tint min = 0;\n\n\tif (udev_monitor == NULL)\n\t\treturn NULL;\n\tmemset(buf, 0x00, sizeof(buf));\n\tiov.iov_base = &buf;\n\tiov.iov_len = sizeof(buf);\n\tmemset (&smsg, 0x00, sizeof(struct msghdr));\n\tsmsg.msg_iov = &iov;\n\tsmsg.msg_iovlen = 1;\n\tsmsg.msg_control = cred_msg;\n\tsmsg.msg_controllen = sizeof(cred_msg);\n\n\tif (recvmsg(udev_monitor->sock, &smsg, 0) < 0) {\n\t\tif (errno != EINTR)\n\t\t\tinfo(udev_monitor->udev, \"unable to receive message\");\n\t\treturn NULL;\n\t}\n\n\tif (udev_monitor->sun.sun_family != 0) {\n\t\tstruct cmsghdr *cmsg = CMSG_FIRSTHDR(&smsg);\n\t\tstruct ucred *cred = (struct ucred *)CMSG_DATA (cmsg);\n\n\t\tif (cmsg == NULL || cmsg->cmsg_type != SCM_CREDENTIALS) {\n\t\t\tinfo(udev_monitor->udev, \"no sender credentials received, message ignored\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (cred->uid != 0) {\n\t\t\tinfo(udev_monitor->udev, \"sender uid=%d, message ignored\", cred->uid);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\t/* skip header */\n\tbufpos = strlen(buf) + 1;\n\tif (bufpos < sizeof(\"a@/d\") || bufpos >= sizeof(buf)) {\n\t\tinfo(udev_monitor->udev, \"invalid message length\");\n\t\treturn NULL;\n\t}\n\n\t/* check message header */\n\tif (strstr(buf, \"@/\") == NULL) {\n\t\tinfo(udev_monitor->udev, \"unrecognized message header\");\n\t\treturn NULL;\n\t}\n\n\tudev_device = device_new(udev_monitor->udev);\n\tif (udev_device == NULL) {\n\t\treturn NULL;\n\t}\n\n\twhile (bufpos < sizeof(buf)) {\n\t\tchar *key;\n\t\tsize_t keylen;\n\n\t\tkey = &buf[bufpos];\n\t\tkeylen = strlen(key);\n\t\tif (keylen == 0)\n\t\t\tbreak;\n\t\tbufpos += keylen + 1;\n\n\t\tif (strncmp(key, \"DEVPATH=\", 8) == 0) {\n\t\t\tchar path[UTIL_PATH_SIZE];\n\n\t\t\tutil_strlcpy(path, udev_get_sys_path(udev_monitor->udev), sizeof(path));\n\t\t\tutil_strlcat(path, &key[8], sizeof(path));\n\t\t\tudev_device_set_syspath(udev_device, path);\n\t\t\tdevpath_set = 1;\n\t\t} else if (strncmp(key, \"SUBSYSTEM=\", 10) == 0) {\n\t\t\tudev_device_set_subsystem(udev_device, &key[10]);\n\t\t\tsubsystem_set = 1;\n\t\t} else if (strncmp(key, \"DEVTYPE=\", 8) == 0) {\n\t\t\tudev_device_set_devtype(udev_device, &key[8]);\n\t\t} else if (strncmp(key, \"DEVNAME=\", 8) == 0) {\n\t\t\tudev_device_set_devnode(udev_device, &key[8]);\n\t\t} else if (strncmp(key, \"DEVLINKS=\", 9) == 0) {\n\t\t\tchar devlinks[UTIL_PATH_SIZE];\n\t\t\tchar *slink;\n\t\t\tchar *next;\n\n\t\t\tutil_strlcpy(devlinks, &key[9], sizeof(devlinks));\n\t\t\tslink = devlinks;\n\t\t\tnext = strchr(slink, ' ');\n\t\t\twhile (next != NULL) {\n\t\t\t\tnext[0] = '\\0';\n\t\t\t\tudev_device_add_devlink(udev_device, slink);\n\t\t\t\tslink = &next[1];\n\t\t\t\tnext = strchr(slink, ' ');\n\t\t\t}\n\t\t\tif (slink[0] != '\\0')\n\t\t\t\tudev_device_add_devlink(udev_device, slink);\n\t\t} else if (strncmp(key, \"DRIVER=\", 7) == 0) {\n\t\t\tudev_device_set_driver(udev_device, &key[7]);\n\t\t} else if (strncmp(key, \"ACTION=\", 7) == 0) {\n\t\t\tudev_device_set_action(udev_device, &key[7]);\n\t\t\taction_set = 1;\n\t\t} else if (strncmp(key, \"MAJOR=\", 6) == 0) {\n\t\t\tmaj = strtoull(&key[6], NULL, 10);\n\t\t} else if (strncmp(key, \"MINOR=\", 6) == 0) {\n\t\t\tmin = strtoull(&key[6], NULL, 10);\n\t\t} else if (strncmp(key, \"DEVPATH_OLD=\", 12) == 0) {\n\t\t\tudev_device_set_devpath_old(udev_device, &key[12]);\n\t\t} else if (strncmp(key, \"PHYSDEVPATH=\", 12) == 0) {\n\t\t\tudev_device_set_physdevpath(udev_device, &key[12]);\n\t\t} else if (strncmp(key, \"SEQNUM=\", 7) == 0) {\n\t\t\tudev_device_set_seqnum(udev_device, strtoull(&key[7], NULL, 10));\n\t\t} else if (strncmp(key, \"TIMEOUT=\", 8) == 0) {\n\t\t\tudev_device_set_timeout(udev_device, strtoull(&key[8], NULL, 10));\n\t\t} else if (strncmp(key, \"PHYSDEV\", 7) == 0) {\n\t\t\t/* skip deprecated values */\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tudev_device_add_property_from_string(udev_device, key);\n\t\t}\n\t}\n\tif (!devpath_set || !subsystem_set || !action_set) {\n\t\tinfo(udev_monitor->udev, \"missing values, skip\\n\");\n\t\tudev_device_unref(udev_device);\n\t\treturn NULL;\n\t}\n\tif (maj > 0)\n\t\tudev_device_set_devnum(udev_device, makedev(maj, min));\n\tudev_device_set_info_loaded(udev_device);\n\treturn udev_device;\n}",
        "func": "struct udev_device *udev_monitor_receive_device(struct udev_monitor *udev_monitor)\n{\n\tstruct udev_device *udev_device;\n\tstruct msghdr smsg;\n\tstruct iovec iov;\n\tchar cred_msg[CMSG_SPACE(sizeof(struct ucred))];\n\tstruct cmsghdr *cmsg;\n\tstruct ucred *cred;\n\tchar buf[4096];\n\tsize_t bufpos;\n\tint devpath_set = 0;\n\tint subsystem_set = 0;\n\tint action_set = 0;\n\tint maj = 0;\n\tint min = 0;\n\n\tif (udev_monitor == NULL)\n\t\treturn NULL;\n\tmemset(buf, 0x00, sizeof(buf));\n\tiov.iov_base = &buf;\n\tiov.iov_len = sizeof(buf);\n\tmemset (&smsg, 0x00, sizeof(struct msghdr));\n\tsmsg.msg_iov = &iov;\n\tsmsg.msg_iovlen = 1;\n\tsmsg.msg_control = cred_msg;\n\tsmsg.msg_controllen = sizeof(cred_msg);\n\n\tif (recvmsg(udev_monitor->sock, &smsg, 0) < 0) {\n\t\tif (errno != EINTR)\n\t\t\tinfo(udev_monitor->udev, \"unable to receive message\");\n\t\treturn NULL;\n\t}\n\n\tcmsg = CMSG_FIRSTHDR(&smsg);\n\tif (cmsg == NULL || cmsg->cmsg_type != SCM_CREDENTIALS) {\n\t\tinfo(udev_monitor->udev, \"no sender credentials received, message ignored\");\n\t\treturn NULL;\n\t}\n\n\tcred = (struct ucred *)CMSG_DATA(cmsg);\n\tif (cred->uid != 0) {\n\t\tinfo(udev_monitor->udev, \"sender uid=%d, message ignored\", cred->uid);\n\t\treturn NULL;\n\t}\n\n\t/* skip header */\n\tbufpos = strlen(buf) + 1;\n\tif (bufpos < sizeof(\"a@/d\") || bufpos >= sizeof(buf)) {\n\t\tinfo(udev_monitor->udev, \"invalid message length\");\n\t\treturn NULL;\n\t}\n\n\t/* check message header */\n\tif (strstr(buf, \"@/\") == NULL) {\n\t\tinfo(udev_monitor->udev, \"unrecognized message header\");\n\t\treturn NULL;\n\t}\n\n\tudev_device = device_new(udev_monitor->udev);\n\tif (udev_device == NULL) {\n\t\treturn NULL;\n\t}\n\n\twhile (bufpos < sizeof(buf)) {\n\t\tchar *key;\n\t\tsize_t keylen;\n\n\t\tkey = &buf[bufpos];\n\t\tkeylen = strlen(key);\n\t\tif (keylen == 0)\n\t\t\tbreak;\n\t\tbufpos += keylen + 1;\n\n\t\tif (strncmp(key, \"DEVPATH=\", 8) == 0) {\n\t\t\tchar path[UTIL_PATH_SIZE];\n\n\t\t\tutil_strlcpy(path, udev_get_sys_path(udev_monitor->udev), sizeof(path));\n\t\t\tutil_strlcat(path, &key[8], sizeof(path));\n\t\t\tudev_device_set_syspath(udev_device, path);\n\t\t\tdevpath_set = 1;\n\t\t} else if (strncmp(key, \"SUBSYSTEM=\", 10) == 0) {\n\t\t\tudev_device_set_subsystem(udev_device, &key[10]);\n\t\t\tsubsystem_set = 1;\n\t\t} else if (strncmp(key, \"DEVTYPE=\", 8) == 0) {\n\t\t\tudev_device_set_devtype(udev_device, &key[8]);\n\t\t} else if (strncmp(key, \"DEVNAME=\", 8) == 0) {\n\t\t\tudev_device_set_devnode(udev_device, &key[8]);\n\t\t} else if (strncmp(key, \"DEVLINKS=\", 9) == 0) {\n\t\t\tchar devlinks[UTIL_PATH_SIZE];\n\t\t\tchar *slink;\n\t\t\tchar *next;\n\n\t\t\tutil_strlcpy(devlinks, &key[9], sizeof(devlinks));\n\t\t\tslink = devlinks;\n\t\t\tnext = strchr(slink, ' ');\n\t\t\twhile (next != NULL) {\n\t\t\t\tnext[0] = '\\0';\n\t\t\t\tudev_device_add_devlink(udev_device, slink);\n\t\t\t\tslink = &next[1];\n\t\t\t\tnext = strchr(slink, ' ');\n\t\t\t}\n\t\t\tif (slink[0] != '\\0')\n\t\t\t\tudev_device_add_devlink(udev_device, slink);\n\t\t} else if (strncmp(key, \"DRIVER=\", 7) == 0) {\n\t\t\tudev_device_set_driver(udev_device, &key[7]);\n\t\t} else if (strncmp(key, \"ACTION=\", 7) == 0) {\n\t\t\tudev_device_set_action(udev_device, &key[7]);\n\t\t\taction_set = 1;\n\t\t} else if (strncmp(key, \"MAJOR=\", 6) == 0) {\n\t\t\tmaj = strtoull(&key[6], NULL, 10);\n\t\t} else if (strncmp(key, \"MINOR=\", 6) == 0) {\n\t\t\tmin = strtoull(&key[6], NULL, 10);\n\t\t} else if (strncmp(key, \"DEVPATH_OLD=\", 12) == 0) {\n\t\t\tudev_device_set_devpath_old(udev_device, &key[12]);\n\t\t} else if (strncmp(key, \"PHYSDEVPATH=\", 12) == 0) {\n\t\t\tudev_device_set_physdevpath(udev_device, &key[12]);\n\t\t} else if (strncmp(key, \"SEQNUM=\", 7) == 0) {\n\t\t\tudev_device_set_seqnum(udev_device, strtoull(&key[7], NULL, 10));\n\t\t} else if (strncmp(key, \"TIMEOUT=\", 8) == 0) {\n\t\t\tudev_device_set_timeout(udev_device, strtoull(&key[8], NULL, 10));\n\t\t} else if (strncmp(key, \"PHYSDEV\", 7) == 0) {\n\t\t\t/* skip deprecated values */\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tudev_device_add_property_from_string(udev_device, key);\n\t\t}\n\t}\n\tif (!devpath_set || !subsystem_set || !action_set) {\n\t\tinfo(udev_monitor->udev, \"missing values, skip\\n\");\n\t\tudev_device_unref(udev_device);\n\t\treturn NULL;\n\t}\n\tif (maj > 0)\n\t\tudev_device_set_devnum(udev_device, makedev(maj, min));\n\tudev_device_set_info_loaded(udev_device);\n\treturn udev_device;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,8 @@\n \tstruct msghdr smsg;\n \tstruct iovec iov;\n \tchar cred_msg[CMSG_SPACE(sizeof(struct ucred))];\n+\tstruct cmsghdr *cmsg;\n+\tstruct ucred *cred;\n \tchar buf[4096];\n \tsize_t bufpos;\n \tint devpath_set = 0;\n@@ -29,19 +31,16 @@\n \t\treturn NULL;\n \t}\n \n-\tif (udev_monitor->sun.sun_family != 0) {\n-\t\tstruct cmsghdr *cmsg = CMSG_FIRSTHDR(&smsg);\n-\t\tstruct ucred *cred = (struct ucred *)CMSG_DATA (cmsg);\n+\tcmsg = CMSG_FIRSTHDR(&smsg);\n+\tif (cmsg == NULL || cmsg->cmsg_type != SCM_CREDENTIALS) {\n+\t\tinfo(udev_monitor->udev, \"no sender credentials received, message ignored\");\n+\t\treturn NULL;\n+\t}\n \n-\t\tif (cmsg == NULL || cmsg->cmsg_type != SCM_CREDENTIALS) {\n-\t\t\tinfo(udev_monitor->udev, \"no sender credentials received, message ignored\");\n-\t\t\treturn NULL;\n-\t\t}\n-\n-\t\tif (cred->uid != 0) {\n-\t\t\tinfo(udev_monitor->udev, \"sender uid=%d, message ignored\", cred->uid);\n-\t\t\treturn NULL;\n-\t\t}\n+\tcred = (struct ucred *)CMSG_DATA(cmsg);\n+\tif (cred->uid != 0) {\n+\t\tinfo(udev_monitor->udev, \"sender uid=%d, message ignored\", cred->uid);\n+\t\treturn NULL;\n \t}\n \n \t/* skip header */",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (udev_monitor->sun.sun_family != 0) {",
                "\t\tstruct cmsghdr *cmsg = CMSG_FIRSTHDR(&smsg);",
                "\t\tstruct ucred *cred = (struct ucred *)CMSG_DATA (cmsg);",
                "\t\tif (cmsg == NULL || cmsg->cmsg_type != SCM_CREDENTIALS) {",
                "\t\t\tinfo(udev_monitor->udev, \"no sender credentials received, message ignored\");",
                "\t\t\treturn NULL;",
                "\t\t}",
                "",
                "\t\tif (cred->uid != 0) {",
                "\t\t\tinfo(udev_monitor->udev, \"sender uid=%d, message ignored\", cred->uid);",
                "\t\t\treturn NULL;",
                "\t\t}"
            ],
            "added_lines": [
                "\tstruct cmsghdr *cmsg;",
                "\tstruct ucred *cred;",
                "\tcmsg = CMSG_FIRSTHDR(&smsg);",
                "\tif (cmsg == NULL || cmsg->cmsg_type != SCM_CREDENTIALS) {",
                "\t\tinfo(udev_monitor->udev, \"no sender credentials received, message ignored\");",
                "\t\treturn NULL;",
                "\t}",
                "\tcred = (struct ucred *)CMSG_DATA(cmsg);",
                "\tif (cred->uid != 0) {",
                "\t\tinfo(udev_monitor->udev, \"sender uid=%d, message ignored\", cred->uid);",
                "\t\treturn NULL;"
            ]
        }
    }
]