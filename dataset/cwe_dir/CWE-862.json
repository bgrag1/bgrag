[
    {
        "cve_id": "CVE-2019-15030",
        "func_name": "torvalds/linux/giveup_all",
        "description": "In the Linux kernel through 5.2.14 on the powerpc platform, a local user can read vector registers of other users' processes via a Facility Unavailable exception. To exploit the venerability, a local user starts a transaction (via the hardware transactional memory instruction tbegin) and then accesses vector registers. At some point, the vector registers will be corrupted with the values from a different local Linux process because of a missing arch/powerpc/kernel/process.c check.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=8205d5d98ef7f155de211f5e2eb6ca03d95a5a60",
        "commit_title": "When we take an FP unavailable exception in a transaction we have to",
        "commit_text": "account for the hardware FP TM checkpointed registers being incorrect. In this case for this process we know the current and checkpointed FP registers must be the same (since FP wasn't used inside the transaction) hence in the thread_struct we copy the current FP registers to the checkpointed ones.  This copy is done in tm_reclaim_thread(). We use thread->ckpt_regs.msr to determine if FP was on when in userspace. thread->ckpt_regs.msr represents the state of the MSR when exiting userspace. This is setup by check_if_tm_restore_required().  Unfortunatley there is an optimisation in giveup_all() which returns early if tsk->thread.regs->msr (via local variable `usermsr`) has FP=VEC=VSX=SPE=0. This optimisation means that check_if_tm_restore_required() is not called and hence thread->ckpt_regs.msr is not updated and will contain an old value.  This can happen if due to load_fp=255 we start a userspace process with MSR FP=1 and then we are context switched out. In this case thread->ckpt_regs.msr will contain FP=1. If that same process is then context switched in and load_fp overflows, MSR will have FP=0. If that process now enters a transaction and does an FP instruction, the FP unavailable will not update thread->ckpt_regs.msr (the bug) and MSR FP=1 will be retained in thread->ckpt_regs.msr.  tm_reclaim_thread() will then not perform the required memcpy and the checkpointed FP regs in the thread struct will contain the wrong values.  The code path for this happening is:         Userspace:                      Kernel                    Start userspace                     with MSR FP/VEC/VSX/SPE=0 TM=1                       < -----        ...        tbegin        bne        fp instruction                    FP unavailable                        ---- >                                         fp_unavailable_tm() \t\t\t\t\t  tm_reclaim_current() \t\t\t\t\t    tm_reclaim_thread() \t\t\t\t\t      giveup_all() \t\t\t\t\t        return early since FP/VMX/VSX=0 \t\t\t\t\t\t/* ckpt MSR not updated (Incorrect) */ \t\t\t\t\t      tm_reclaim() \t\t\t\t\t        /* thread_struct ckpt FP regs contain junk (OK) */                                               /* Sees ckpt MSR FP=1 (Incorrect) */ \t\t\t\t\t      no memcpy() performed \t\t\t\t\t        /* thread_struct ckpt FP regs not fixed (Incorrect) */ \t\t\t\t\t  tm_recheckpoint() \t\t\t\t\t     /* Put junk in hardware checkpoint FP regs */                                          ....                       < -----                    Return to userspace                      with MSR TM=1 FP=1                      with junk in the FP TM checkpoint        TM rollback        reads FP junk  This is a data integrity problem for the current process as the FP registers are corrupted. It's also a security problem as the FP registers from one process may be leaked to another.  This patch moves up check_if_tm_restore_required() in giveup_all() to ensure thread->ckpt_regs.msr is updated correctly.  A simple testcase to replicate this will be posted to tools/testing/selftests/powerpc/tm/tm-poison.c  Similarly for VMX.  This fixes CVE-2019-15030.  Cc: stable@vger.kernel.org # 4.12+ Link: https://lore.kernel.org/r/20190904045529.23002-1-gromero@linux.vnet.ibm.com ",
        "func_before": "void giveup_all(struct task_struct *tsk)\n{\n\tunsigned long usermsr;\n\n\tif (!tsk->thread.regs)\n\t\treturn;\n\n\tusermsr = tsk->thread.regs->msr;\n\n\tif ((usermsr & msr_all_available) == 0)\n\t\treturn;\n\n\tmsr_check_and_set(msr_all_available);\n\tcheck_if_tm_restore_required(tsk);\n\n\tWARN_ON((usermsr & MSR_VSX) && !((usermsr & MSR_FP) && (usermsr & MSR_VEC)));\n\n#ifdef CONFIG_PPC_FPU\n\tif (usermsr & MSR_FP)\n\t\t__giveup_fpu(tsk);\n#endif\n#ifdef CONFIG_ALTIVEC\n\tif (usermsr & MSR_VEC)\n\t\t__giveup_altivec(tsk);\n#endif\n#ifdef CONFIG_SPE\n\tif (usermsr & MSR_SPE)\n\t\t__giveup_spe(tsk);\n#endif\n\n\tmsr_check_and_clear(msr_all_available);\n}",
        "func": "void giveup_all(struct task_struct *tsk)\n{\n\tunsigned long usermsr;\n\n\tif (!tsk->thread.regs)\n\t\treturn;\n\n\tcheck_if_tm_restore_required(tsk);\n\n\tusermsr = tsk->thread.regs->msr;\n\n\tif ((usermsr & msr_all_available) == 0)\n\t\treturn;\n\n\tmsr_check_and_set(msr_all_available);\n\n\tWARN_ON((usermsr & MSR_VSX) && !((usermsr & MSR_FP) && (usermsr & MSR_VEC)));\n\n#ifdef CONFIG_PPC_FPU\n\tif (usermsr & MSR_FP)\n\t\t__giveup_fpu(tsk);\n#endif\n#ifdef CONFIG_ALTIVEC\n\tif (usermsr & MSR_VEC)\n\t\t__giveup_altivec(tsk);\n#endif\n#ifdef CONFIG_SPE\n\tif (usermsr & MSR_SPE)\n\t\t__giveup_spe(tsk);\n#endif\n\n\tmsr_check_and_clear(msr_all_available);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,13 +5,14 @@\n \tif (!tsk->thread.regs)\n \t\treturn;\n \n+\tcheck_if_tm_restore_required(tsk);\n+\n \tusermsr = tsk->thread.regs->msr;\n \n \tif ((usermsr & msr_all_available) == 0)\n \t\treturn;\n \n \tmsr_check_and_set(msr_all_available);\n-\tcheck_if_tm_restore_required(tsk);\n \n \tWARN_ON((usermsr & MSR_VSX) && !((usermsr & MSR_FP) && (usermsr & MSR_VEC)));\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tcheck_if_tm_restore_required(tsk);"
            ],
            "added_lines": [
                "\tcheck_if_tm_restore_required(tsk);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17052",
        "func_name": "torvalds/linux/ax25_create",
        "description": "ax25_create in net/ax25/af_ax25.c in the AF_AX25 network module in the Linux kernel 3.16 through 5.3.2 does not enforce CAP_NET_RAW, which means that unprivileged users can create a raw socket, aka CID-0614e2b73768.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=0614e2b73768b502fc32a75349823356d98aae2c",
        "commit_title": "When creating a raw AF_AX25 socket, CAP_NET_RAW needs to be checked",
        "commit_text": "first.  ",
        "func_before": "static int ax25_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tax25_cb *ax25;\n\n\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n\t\treturn -EINVAL;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tif (protocol == 0 || protocol == PF_AX25)\n\t\t\tprotocol = AX25_P_TEXT;\n\t\tbreak;\n\n\tcase SOCK_SEQPACKET:\n\t\tswitch (protocol) {\n\t\tcase 0:\n\t\tcase PF_AX25:\t/* For CLX */\n\t\t\tprotocol = AX25_P_TEXT;\n\t\t\tbreak;\n\t\tcase AX25_P_SEGMENT:\n#ifdef CONFIG_INET\n\t\tcase AX25_P_ARP:\n\t\tcase AX25_P_IP:\n#endif\n#ifdef CONFIG_NETROM\n\t\tcase AX25_P_NETROM:\n#endif\n#ifdef CONFIG_ROSE\n\t\tcase AX25_P_ROSE:\n#endif\n\t\t\treturn -ESOCKTNOSUPPORT;\n#ifdef CONFIG_NETROM_MODULE\n\t\tcase AX25_P_NETROM:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_NETROM))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_ROSE_MODULE\n\t\tcase AX25_P_ROSE:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_ROSE))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SOCK_RAW:\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\tsk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\tax25 = ax25_sk(sk)->cb = ax25_create_cb();\n\tif (!ax25) {\n\t\tsk_free(sk);\n\t\treturn -ENOMEM;\n\t}\n\n\tsock_init_data(sock, sk);\n\n\tsk->sk_destruct = ax25_free_sock;\n\tsock->ops    = &ax25_proto_ops;\n\tsk->sk_protocol = protocol;\n\n\tax25->sk    = sk;\n\n\treturn 0;\n}",
        "func": "static int ax25_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tax25_cb *ax25;\n\n\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n\t\treturn -EINVAL;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tif (protocol == 0 || protocol == PF_AX25)\n\t\t\tprotocol = AX25_P_TEXT;\n\t\tbreak;\n\n\tcase SOCK_SEQPACKET:\n\t\tswitch (protocol) {\n\t\tcase 0:\n\t\tcase PF_AX25:\t/* For CLX */\n\t\t\tprotocol = AX25_P_TEXT;\n\t\t\tbreak;\n\t\tcase AX25_P_SEGMENT:\n#ifdef CONFIG_INET\n\t\tcase AX25_P_ARP:\n\t\tcase AX25_P_IP:\n#endif\n#ifdef CONFIG_NETROM\n\t\tcase AX25_P_NETROM:\n#endif\n#ifdef CONFIG_ROSE\n\t\tcase AX25_P_ROSE:\n#endif\n\t\t\treturn -ESOCKTNOSUPPORT;\n#ifdef CONFIG_NETROM_MODULE\n\t\tcase AX25_P_NETROM:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_NETROM))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_ROSE_MODULE\n\t\tcase AX25_P_ROSE:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_ROSE))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SOCK_RAW:\n\t\tif (!capable(CAP_NET_RAW))\n\t\t\treturn -EPERM;\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\tsk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\tax25 = ax25_sk(sk)->cb = ax25_create_cb();\n\tif (!ax25) {\n\t\tsk_free(sk);\n\t\treturn -ENOMEM;\n\t}\n\n\tsock_init_data(sock, sk);\n\n\tsk->sk_destruct = ax25_free_sock;\n\tsock->ops    = &ax25_proto_ops;\n\tsk->sk_protocol = protocol;\n\n\tax25->sk    = sk;\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -51,6 +51,8 @@\n \t\tbreak;\n \n \tcase SOCK_RAW:\n+\t\tif (!capable(CAP_NET_RAW))\n+\t\t\treturn -EPERM;\n \t\tbreak;\n \tdefault:\n \t\treturn -ESOCKTNOSUPPORT;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif (!capable(CAP_NET_RAW))",
                "\t\t\treturn -EPERM;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17052",
        "func_name": "kernel/git/tip/tip/ax25_create",
        "description": "ax25_create in net/ax25/af_ax25.c in the AF_AX25 network module in the Linux kernel 3.16 through 5.3.2 does not enforce CAP_NET_RAW, which means that unprivileged users can create a raw socket, aka CID-0614e2b73768.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git/commit/?h=2c675dab816278a1724c1e93b384c2f05a11cb31",
        "commit_title": "commit 0614e2b73768b502fc32a75349823356d98aae2c upstream.",
        "commit_text": " When creating a raw AF_AX25 socket, CAP_NET_RAW needs to be checked first.  ",
        "func_before": "static int ax25_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tax25_cb *ax25;\n\n\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n\t\treturn -EINVAL;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tif (protocol == 0 || protocol == PF_AX25)\n\t\t\tprotocol = AX25_P_TEXT;\n\t\tbreak;\n\n\tcase SOCK_SEQPACKET:\n\t\tswitch (protocol) {\n\t\tcase 0:\n\t\tcase PF_AX25:\t/* For CLX */\n\t\t\tprotocol = AX25_P_TEXT;\n\t\t\tbreak;\n\t\tcase AX25_P_SEGMENT:\n#ifdef CONFIG_INET\n\t\tcase AX25_P_ARP:\n\t\tcase AX25_P_IP:\n#endif\n#ifdef CONFIG_NETROM\n\t\tcase AX25_P_NETROM:\n#endif\n#ifdef CONFIG_ROSE\n\t\tcase AX25_P_ROSE:\n#endif\n\t\t\treturn -ESOCKTNOSUPPORT;\n#ifdef CONFIG_NETROM_MODULE\n\t\tcase AX25_P_NETROM:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_NETROM))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_ROSE_MODULE\n\t\tcase AX25_P_ROSE:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_ROSE))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SOCK_RAW:\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\tsk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\tax25 = sk->sk_protinfo = ax25_create_cb();\n\tif (!ax25) {\n\t\tsk_free(sk);\n\t\treturn -ENOMEM;\n\t}\n\n\tsock_init_data(sock, sk);\n\n\tsk->sk_destruct = ax25_free_sock;\n\tsock->ops    = &ax25_proto_ops;\n\tsk->sk_protocol = protocol;\n\n\tax25->sk    = sk;\n\n\treturn 0;\n}",
        "func": "static int ax25_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tax25_cb *ax25;\n\n\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n\t\treturn -EINVAL;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tif (protocol == 0 || protocol == PF_AX25)\n\t\t\tprotocol = AX25_P_TEXT;\n\t\tbreak;\n\n\tcase SOCK_SEQPACKET:\n\t\tswitch (protocol) {\n\t\tcase 0:\n\t\tcase PF_AX25:\t/* For CLX */\n\t\t\tprotocol = AX25_P_TEXT;\n\t\t\tbreak;\n\t\tcase AX25_P_SEGMENT:\n#ifdef CONFIG_INET\n\t\tcase AX25_P_ARP:\n\t\tcase AX25_P_IP:\n#endif\n#ifdef CONFIG_NETROM\n\t\tcase AX25_P_NETROM:\n#endif\n#ifdef CONFIG_ROSE\n\t\tcase AX25_P_ROSE:\n#endif\n\t\t\treturn -ESOCKTNOSUPPORT;\n#ifdef CONFIG_NETROM_MODULE\n\t\tcase AX25_P_NETROM:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_NETROM))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_ROSE_MODULE\n\t\tcase AX25_P_ROSE:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_ROSE))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SOCK_RAW:\n\t\tif (!capable(CAP_NET_RAW))\n\t\t\treturn -EPERM;\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\tsk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\tax25 = sk->sk_protinfo = ax25_create_cb();\n\tif (!ax25) {\n\t\tsk_free(sk);\n\t\treturn -ENOMEM;\n\t}\n\n\tsock_init_data(sock, sk);\n\n\tsk->sk_destruct = ax25_free_sock;\n\tsock->ops    = &ax25_proto_ops;\n\tsk->sk_protocol = protocol;\n\n\tax25->sk    = sk;\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -51,6 +51,8 @@\n \t\tbreak;\n \n \tcase SOCK_RAW:\n+\t\tif (!capable(CAP_NET_RAW))\n+\t\t\treturn -EPERM;\n \t\tbreak;\n \tdefault:\n \t\treturn -ESOCKTNOSUPPORT;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif (!capable(CAP_NET_RAW))",
                "\t\t\treturn -EPERM;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17052",
        "func_name": "torvalds/linux/ax25_create",
        "description": "ax25_create in net/ax25/af_ax25.c in the AF_AX25 network module in the Linux kernel 3.16 through 5.3.2 does not enforce CAP_NET_RAW, which means that unprivileged users can create a raw socket, aka CID-0614e2b73768.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=0edc3f703f7bcaf550774b5d43ab727bcd0fe06b",
        "commit_title": "Greg Kroah-Hartman says:",
        "commit_text": " ==================== Raw socket cleanups  Ori Nimron pointed out that there are a number of places in the kernel where you can create a raw socket, without having to have the CAP_NET_RAW permission.  To resolve this, here's a short patch series to test these odd and old protocols for this permission before allowing the creation to succeed  All patches are currently against the net tree. ====================  ",
        "func_before": "static int ax25_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tax25_cb *ax25;\n\n\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n\t\treturn -EINVAL;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tif (protocol == 0 || protocol == PF_AX25)\n\t\t\tprotocol = AX25_P_TEXT;\n\t\tbreak;\n\n\tcase SOCK_SEQPACKET:\n\t\tswitch (protocol) {\n\t\tcase 0:\n\t\tcase PF_AX25:\t/* For CLX */\n\t\t\tprotocol = AX25_P_TEXT;\n\t\t\tbreak;\n\t\tcase AX25_P_SEGMENT:\n#ifdef CONFIG_INET\n\t\tcase AX25_P_ARP:\n\t\tcase AX25_P_IP:\n#endif\n#ifdef CONFIG_NETROM\n\t\tcase AX25_P_NETROM:\n#endif\n#ifdef CONFIG_ROSE\n\t\tcase AX25_P_ROSE:\n#endif\n\t\t\treturn -ESOCKTNOSUPPORT;\n#ifdef CONFIG_NETROM_MODULE\n\t\tcase AX25_P_NETROM:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_NETROM))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_ROSE_MODULE\n\t\tcase AX25_P_ROSE:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_ROSE))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SOCK_RAW:\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\tsk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\tax25 = ax25_sk(sk)->cb = ax25_create_cb();\n\tif (!ax25) {\n\t\tsk_free(sk);\n\t\treturn -ENOMEM;\n\t}\n\n\tsock_init_data(sock, sk);\n\n\tsk->sk_destruct = ax25_free_sock;\n\tsock->ops    = &ax25_proto_ops;\n\tsk->sk_protocol = protocol;\n\n\tax25->sk    = sk;\n\n\treturn 0;\n}",
        "func": "static int ax25_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tax25_cb *ax25;\n\n\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n\t\treturn -EINVAL;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tif (protocol == 0 || protocol == PF_AX25)\n\t\t\tprotocol = AX25_P_TEXT;\n\t\tbreak;\n\n\tcase SOCK_SEQPACKET:\n\t\tswitch (protocol) {\n\t\tcase 0:\n\t\tcase PF_AX25:\t/* For CLX */\n\t\t\tprotocol = AX25_P_TEXT;\n\t\t\tbreak;\n\t\tcase AX25_P_SEGMENT:\n#ifdef CONFIG_INET\n\t\tcase AX25_P_ARP:\n\t\tcase AX25_P_IP:\n#endif\n#ifdef CONFIG_NETROM\n\t\tcase AX25_P_NETROM:\n#endif\n#ifdef CONFIG_ROSE\n\t\tcase AX25_P_ROSE:\n#endif\n\t\t\treturn -ESOCKTNOSUPPORT;\n#ifdef CONFIG_NETROM_MODULE\n\t\tcase AX25_P_NETROM:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_NETROM))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_ROSE_MODULE\n\t\tcase AX25_P_ROSE:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_ROSE))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase SOCK_RAW:\n\t\tif (!capable(CAP_NET_RAW))\n\t\t\treturn -EPERM;\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\tsk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\tax25 = ax25_sk(sk)->cb = ax25_create_cb();\n\tif (!ax25) {\n\t\tsk_free(sk);\n\t\treturn -ENOMEM;\n\t}\n\n\tsock_init_data(sock, sk);\n\n\tsk->sk_destruct = ax25_free_sock;\n\tsock->ops    = &ax25_proto_ops;\n\tsk->sk_protocol = protocol;\n\n\tax25->sk    = sk;\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -51,6 +51,8 @@\n \t\tbreak;\n \n \tcase SOCK_RAW:\n+\t\tif (!capable(CAP_NET_RAW))\n+\t\t\treturn -EPERM;\n \t\tbreak;\n \tdefault:\n \t\treturn -ESOCKTNOSUPPORT;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif (!capable(CAP_NET_RAW))",
                "\t\t\treturn -EPERM;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17052",
        "func_name": "torvalds/linux/base_sock_create",
        "description": "ax25_create in net/ax25/af_ax25.c in the AF_AX25 network module in the Linux kernel 3.16 through 5.3.2 does not enforce CAP_NET_RAW, which means that unprivileged users can create a raw socket, aka CID-0614e2b73768.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=0edc3f703f7bcaf550774b5d43ab727bcd0fe06b",
        "commit_title": "Greg Kroah-Hartman says:",
        "commit_text": " ==================== Raw socket cleanups  Ori Nimron pointed out that there are a number of places in the kernel where you can create a raw socket, without having to have the CAP_NET_RAW permission.  To resolve this, here's a short patch series to test these odd and old protocols for this permission before allowing the creation to succeed  All patches are currently against the net tree. ====================  ",
        "func_before": "static int\nbase_sock_create(struct net *net, struct socket *sock, int protocol, int kern)\n{\n\tstruct sock *sk;\n\n\tif (sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsk = sk_alloc(net, PF_ISDN, GFP_KERNEL, &mISDN_proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\tsock->ops = &base_sock_ops;\n\tsock->state = SS_UNCONNECTED;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\tsk->sk_protocol = protocol;\n\tsk->sk_state    = MISDN_OPEN;\n\tmISDN_sock_link(&base_sockets, sk);\n\n\treturn 0;\n}",
        "func": "static int\nbase_sock_create(struct net *net, struct socket *sock, int protocol, int kern)\n{\n\tstruct sock *sk;\n\n\tif (sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (!capable(CAP_NET_RAW))\n\t\treturn -EPERM;\n\n\tsk = sk_alloc(net, PF_ISDN, GFP_KERNEL, &mISDN_proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\tsock->ops = &base_sock_ops;\n\tsock->state = SS_UNCONNECTED;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\tsk->sk_protocol = protocol;\n\tsk->sk_state    = MISDN_OPEN;\n\tmISDN_sock_link(&base_sockets, sk);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,6 +5,8 @@\n \n \tif (sock->type != SOCK_RAW)\n \t\treturn -ESOCKTNOSUPPORT;\n+\tif (!capable(CAP_NET_RAW))\n+\t\treturn -EPERM;\n \n \tsk = sk_alloc(net, PF_ISDN, GFP_KERNEL, &mISDN_proto, kern);\n \tif (!sk)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (!capable(CAP_NET_RAW))",
                "\t\treturn -EPERM;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17052",
        "func_name": "torvalds/linux/llcp_sock_create",
        "description": "ax25_create in net/ax25/af_ax25.c in the AF_AX25 network module in the Linux kernel 3.16 through 5.3.2 does not enforce CAP_NET_RAW, which means that unprivileged users can create a raw socket, aka CID-0614e2b73768.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=0edc3f703f7bcaf550774b5d43ab727bcd0fe06b",
        "commit_title": "Greg Kroah-Hartman says:",
        "commit_text": " ==================== Raw socket cleanups  Ori Nimron pointed out that there are a number of places in the kernel where you can create a raw socket, without having to have the CAP_NET_RAW permission.  To resolve this, here's a short patch series to test these odd and old protocols for this permission before allowing the creation to succeed  All patches are currently against the net tree. ====================  ",
        "func_before": "static int llcp_sock_create(struct net *net, struct socket *sock,\n\t\t\t    const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\n\tpr_debug(\"%p\\n\", sock);\n\n\tif (sock->type != SOCK_STREAM &&\n\t    sock->type != SOCK_DGRAM &&\n\t    sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW)\n\t\tsock->ops = &llcp_rawsock_ops;\n\telse\n\t\tsock->ops = &llcp_sock_ops;\n\n\tsk = nfc_llcp_sock_alloc(sock, sock->type, GFP_ATOMIC, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
        "func": "static int llcp_sock_create(struct net *net, struct socket *sock,\n\t\t\t    const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\n\tpr_debug(\"%p\\n\", sock);\n\n\tif (sock->type != SOCK_STREAM &&\n\t    sock->type != SOCK_DGRAM &&\n\t    sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW) {\n\t\tif (!capable(CAP_NET_RAW))\n\t\t\treturn -EPERM;\n\t\tsock->ops = &llcp_rawsock_ops;\n\t} else {\n\t\tsock->ops = &llcp_sock_ops;\n\t}\n\n\tsk = nfc_llcp_sock_alloc(sock, sock->type, GFP_ATOMIC, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,10 +10,13 @@\n \t    sock->type != SOCK_RAW)\n \t\treturn -ESOCKTNOSUPPORT;\n \n-\tif (sock->type == SOCK_RAW)\n+\tif (sock->type == SOCK_RAW) {\n+\t\tif (!capable(CAP_NET_RAW))\n+\t\t\treturn -EPERM;\n \t\tsock->ops = &llcp_rawsock_ops;\n-\telse\n+\t} else {\n \t\tsock->ops = &llcp_sock_ops;\n+\t}\n \n \tsk = nfc_llcp_sock_alloc(sock, sock->type, GFP_ATOMIC, kern);\n \tif (sk == NULL)",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (sock->type == SOCK_RAW)",
                "\telse"
            ],
            "added_lines": [
                "\tif (sock->type == SOCK_RAW) {",
                "\t\tif (!capable(CAP_NET_RAW))",
                "\t\t\treturn -EPERM;",
                "\t} else {",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17052",
        "func_name": "torvalds/linux/atalk_create",
        "description": "ax25_create in net/ax25/af_ax25.c in the AF_AX25 network module in the Linux kernel 3.16 through 5.3.2 does not enforce CAP_NET_RAW, which means that unprivileged users can create a raw socket, aka CID-0614e2b73768.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=0edc3f703f7bcaf550774b5d43ab727bcd0fe06b",
        "commit_title": "Greg Kroah-Hartman says:",
        "commit_text": " ==================== Raw socket cleanups  Ori Nimron pointed out that there are a number of places in the kernel where you can create a raw socket, without having to have the CAP_NET_RAW permission.  To resolve this, here's a short patch series to test these odd and old protocols for this permission before allowing the creation to succeed  All patches are currently against the net tree. ====================  ",
        "func_before": "static int atalk_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tstruct sock *sk;\n\tint rc = -ESOCKTNOSUPPORT;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\t/*\n\t * We permit SOCK_DGRAM and RAW is an extension. It is trivial to do\n\t * and gives you the full ELAP frame. Should be handy for CAP 8)\n\t */\n\tif (sock->type != SOCK_RAW && sock->type != SOCK_DGRAM)\n\t\tgoto out;\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_APPLETALK, GFP_KERNEL, &ddp_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\tsock->ops = &atalk_dgram_ops;\n\tsock_init_data(sock, sk);\n\n\t/* Checksums on by default */\n\tsock_set_flag(sk, SOCK_ZAPPED);\nout:\n\treturn rc;\n}",
        "func": "static int atalk_create(struct net *net, struct socket *sock, int protocol,\n\t\t\tint kern)\n{\n\tstruct sock *sk;\n\tint rc = -ESOCKTNOSUPPORT;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\t/*\n\t * We permit SOCK_DGRAM and RAW is an extension. It is trivial to do\n\t * and gives you the full ELAP frame. Should be handy for CAP 8)\n\t */\n\tif (sock->type != SOCK_RAW && sock->type != SOCK_DGRAM)\n\t\tgoto out;\n\n\trc = -EPERM;\n\tif (sock->type == SOCK_RAW && !kern && !capable(CAP_NET_RAW))\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_APPLETALK, GFP_KERNEL, &ddp_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\tsock->ops = &atalk_dgram_ops;\n\tsock_init_data(sock, sk);\n\n\t/* Checksums on by default */\n\tsock_set_flag(sk, SOCK_ZAPPED);\nout:\n\treturn rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,11 @@\n \t */\n \tif (sock->type != SOCK_RAW && sock->type != SOCK_DGRAM)\n \t\tgoto out;\n+\n+\trc = -EPERM;\n+\tif (sock->type == SOCK_RAW && !kern && !capable(CAP_NET_RAW))\n+\t\tgoto out;\n+\n \trc = -ENOMEM;\n \tsk = sk_alloc(net, PF_APPLETALK, GFP_KERNEL, &ddp_proto, kern);\n \tif (!sk)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\trc = -EPERM;",
                "\tif (sock->type == SOCK_RAW && !kern && !capable(CAP_NET_RAW))",
                "\t\tgoto out;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17052",
        "func_name": "torvalds/linux/base_sock_create",
        "description": "ax25_create in net/ax25/af_ax25.c in the AF_AX25 network module in the Linux kernel 3.16 through 5.3.2 does not enforce CAP_NET_RAW, which means that unprivileged users can create a raw socket, aka CID-0614e2b73768.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=0edc3f703f7bcaf550774b5d43ab727bcd0fe06b",
        "commit_title": "Greg Kroah-Hartman says:",
        "commit_text": " ==================== Raw socket cleanups  Ori Nimron pointed out that there are a number of places in the kernel where you can create a raw socket, without having to have the CAP_NET_RAW permission.  To resolve this, here's a short patch series to test these odd and old protocols for this permission before allowing the creation to succeed  All patches are currently against the net tree. ====================  ",
        "func_before": "static int\nbase_sock_create(struct net *net, struct socket *sock, int protocol, int kern)\n{\n\tstruct sock *sk;\n\n\tif (sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsk = sk_alloc(net, PF_ISDN, GFP_KERNEL, &mISDN_proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\tsock->ops = &base_sock_ops;\n\tsock->state = SS_UNCONNECTED;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\tsk->sk_protocol = protocol;\n\tsk->sk_state    = MISDN_OPEN;\n\tmISDN_sock_link(&base_sockets, sk);\n\n\treturn 0;\n}",
        "func": "static int\nbase_sock_create(struct net *net, struct socket *sock, int protocol, int kern)\n{\n\tstruct sock *sk;\n\n\tif (sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (!capable(CAP_NET_RAW))\n\t\treturn -EPERM;\n\n\tsk = sk_alloc(net, PF_ISDN, GFP_KERNEL, &mISDN_proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\tsock->ops = &base_sock_ops;\n\tsock->state = SS_UNCONNECTED;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\tsk->sk_protocol = protocol;\n\tsk->sk_state    = MISDN_OPEN;\n\tmISDN_sock_link(&base_sockets, sk);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,6 +5,8 @@\n \n \tif (sock->type != SOCK_RAW)\n \t\treturn -ESOCKTNOSUPPORT;\n+\tif (!capable(CAP_NET_RAW))\n+\t\treturn -EPERM;\n \n \tsk = sk_alloc(net, PF_ISDN, GFP_KERNEL, &mISDN_proto, kern);\n \tif (!sk)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (!capable(CAP_NET_RAW))",
                "\t\treturn -EPERM;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17055",
        "func_name": "torvalds/linux/base_sock_create",
        "description": "base_sock_create in drivers/isdn/mISDN/socket.c in the AF_ISDN network module in the Linux kernel through 5.3.2 does not enforce CAP_NET_RAW, which means that unprivileged users can create a raw socket, aka CID-b91ee4aa2a21.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=b91ee4aa2a2199ba4d4650706c272985a5a32d80",
        "commit_title": "When creating a raw AF_ISDN socket, CAP_NET_RAW needs to be checked",
        "commit_text": "first.  ",
        "func_before": "static int\nbase_sock_create(struct net *net, struct socket *sock, int protocol, int kern)\n{\n\tstruct sock *sk;\n\n\tif (sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsk = sk_alloc(net, PF_ISDN, GFP_KERNEL, &mISDN_proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\tsock->ops = &base_sock_ops;\n\tsock->state = SS_UNCONNECTED;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\tsk->sk_protocol = protocol;\n\tsk->sk_state    = MISDN_OPEN;\n\tmISDN_sock_link(&base_sockets, sk);\n\n\treturn 0;\n}",
        "func": "static int\nbase_sock_create(struct net *net, struct socket *sock, int protocol, int kern)\n{\n\tstruct sock *sk;\n\n\tif (sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (!capable(CAP_NET_RAW))\n\t\treturn -EPERM;\n\n\tsk = sk_alloc(net, PF_ISDN, GFP_KERNEL, &mISDN_proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\tsock->ops = &base_sock_ops;\n\tsock->state = SS_UNCONNECTED;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\tsk->sk_protocol = protocol;\n\tsk->sk_state    = MISDN_OPEN;\n\tmISDN_sock_link(&base_sockets, sk);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,6 +5,8 @@\n \n \tif (sock->type != SOCK_RAW)\n \t\treturn -ESOCKTNOSUPPORT;\n+\tif (!capable(CAP_NET_RAW))\n+\t\treturn -EPERM;\n \n \tsk = sk_alloc(net, PF_ISDN, GFP_KERNEL, &mISDN_proto, kern);\n \tif (!sk)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (!capable(CAP_NET_RAW))",
                "\t\treturn -EPERM;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-40673",
        "func_name": "JonMagon/KDiskMark/Helper::flushPageCache",
        "description": "KDiskMark before 3.1.0 lacks authorization checking for D-Bus methods such as Helper::flushPageCache.",
        "git_url": "https://github.com/JonMagon/KDiskMark/commit/3c90083a4f5ba3f240a797e509d818221542bbdc",
        "commit_title": "Add missing authorization checking in Helper::flushPageCache()",
        "commit_text": "",
        "func_before": "QVariantMap Helper::flushPageCache()\n{\n    QVariantMap reply;\n    reply[QStringLiteral(\"success\")] = true;\n\n    if (!isCallerAuthorized()) {\n        reply[QStringLiteral(\"success\")] = false;\n        return reply;\n    }\n\n    QFile file(\"/proc/sys/vm/drop_caches\");\n\n    if (file.open(QIODevice::WriteOnly | QIODevice::Text)) {\n        file.write(\"1\");\n        file.close();\n    }\n    else {\n        reply[QStringLiteral(\"success\")] = false;\n        reply[QStringLiteral(\"error\")] = file.errorString();\n    }\n\n    return reply;\n}",
        "func": "QVariantMap Helper::flushPageCache()\n{\n    if (!isCallerAuthorized()) {\n        return {};\n    }\n\n    QVariantMap reply;\n    reply[QStringLiteral(\"success\")] = true;\n\n    if (!isCallerAuthorized()) {\n        reply[QStringLiteral(\"success\")] = false;\n        return reply;\n    }\n\n    QFile file(\"/proc/sys/vm/drop_caches\");\n\n    if (file.open(QIODevice::WriteOnly | QIODevice::Text)) {\n        file.write(\"1\");\n        file.close();\n    }\n    else {\n        reply[QStringLiteral(\"success\")] = false;\n        reply[QStringLiteral(\"error\")] = file.errorString();\n    }\n\n    return reply;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,9 @@\n QVariantMap Helper::flushPageCache()\n {\n+    if (!isCallerAuthorized()) {\n+        return {};\n+    }\n+\n     QVariantMap reply;\n     reply[QStringLiteral(\"success\")] = true;\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (!isCallerAuthorized()) {",
                "        return {};",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-15780",
        "func_name": "torvalds/linux/acpi_table_aml_write",
        "description": "An issue was discovered in drivers/acpi/acpi_configfs.c in the Linux kernel before 5.7.7. Injection of malicious ACPI tables via configfs could be used by attackers to bypass lockdown and secure boot restrictions, aka CID-75b0cea7bf30.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=75b0cea7bf307f362057cc778efe89af4c615354",
        "commit_title": "Like other vectors already patched, this one here allows the root",
        "commit_text": "user to load ACPI tables, which enables arbitrary physical address writes, which in turn makes it possible to disable lockdown.  Prevents this by checking the lockdown status before allowing a new ACPI table to be installed. The link in the trailer shows a PoC of how this might be used.  Link: https://git.zx2c4.com/american-unsigned-language/tree/american-unsigned-language-2.sh Cc: 5.4+ <stable@vger.kernel.org> # 5.4+ ",
        "func_before": "static ssize_t acpi_table_aml_write(struct config_item *cfg,\n\t\t\t\t    const void *data, size_t size)\n{\n\tconst struct acpi_table_header *header = data;\n\tstruct acpi_table *table;\n\tint ret;\n\n\ttable = container_of(cfg, struct acpi_table, cfg);\n\n\tif (table->header) {\n\t\tpr_err(\"table already loaded\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (header->length != size) {\n\t\tpr_err(\"invalid table length\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (memcmp(header->signature, ACPI_SIG_SSDT, 4)) {\n\t\tpr_err(\"invalid table signature\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttable = container_of(cfg, struct acpi_table, cfg);\n\n\ttable->header = kmemdup(header, header->length, GFP_KERNEL);\n\tif (!table->header)\n\t\treturn -ENOMEM;\n\n\tret = acpi_load_table(table->header, &table->index);\n\tif (ret) {\n\t\tkfree(table->header);\n\t\ttable->header = NULL;\n\t}\n\n\treturn ret;\n}",
        "func": "static ssize_t acpi_table_aml_write(struct config_item *cfg,\n\t\t\t\t    const void *data, size_t size)\n{\n\tconst struct acpi_table_header *header = data;\n\tstruct acpi_table *table;\n\tint ret = security_locked_down(LOCKDOWN_ACPI_TABLES);\n\n\tif (ret)\n\t\treturn ret;\n\n\ttable = container_of(cfg, struct acpi_table, cfg);\n\n\tif (table->header) {\n\t\tpr_err(\"table already loaded\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (header->length != size) {\n\t\tpr_err(\"invalid table length\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (memcmp(header->signature, ACPI_SIG_SSDT, 4)) {\n\t\tpr_err(\"invalid table signature\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttable = container_of(cfg, struct acpi_table, cfg);\n\n\ttable->header = kmemdup(header, header->length, GFP_KERNEL);\n\tif (!table->header)\n\t\treturn -ENOMEM;\n\n\tret = acpi_load_table(table->header, &table->index);\n\tif (ret) {\n\t\tkfree(table->header);\n\t\ttable->header = NULL;\n\t}\n\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,10 @@\n {\n \tconst struct acpi_table_header *header = data;\n \tstruct acpi_table *table;\n-\tint ret;\n+\tint ret = security_locked_down(LOCKDOWN_ACPI_TABLES);\n+\n+\tif (ret)\n+\t\treturn ret;\n \n \ttable = container_of(cfg, struct acpi_table, cfg);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tint ret;"
            ],
            "added_lines": [
                "\tint ret = security_locked_down(LOCKDOWN_ACPI_TABLES);",
                "",
                "\tif (ret)",
                "\t\treturn ret;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-17807",
        "func_name": "torvalds/linux/construct_get_dest_keyring",
        "description": "The KEYS subsystem in the Linux kernel before 4.14.6 omitted an access-control check when adding a key to the current task's \"default request-key keyring\" via the request_key() system call, allowing a local user to use a sequence of crafted system calls to add keys to a keyring with only Search permission (not Write permission) to that keyring, related to construct_get_dest_keyring() in security/keys/request_key.c.",
        "git_url": "https://github.com/torvalds/linux/commit/4dca6ea1d9432052afb06baf2e3ae78188a4410b",
        "commit_title": "KEYS: add missing permission check for request_key() destination",
        "commit_text": " When the request_key() syscall is not passed a destination keyring, it links the requested key (if constructed) into the \"default\" request-key keyring.  This should require Write permission to the keyring.  However, there is actually no permission check.  This can be abused to add keys to any keyring to which only Search permission is granted.  This is because Search permission allows joining the keyring.  keyctl_set_reqkey_keyring(KEY_REQKEY_DEFL_SESSION_KEYRING) then will set the default request-key keyring to the session keyring. Then, request_key() can be used to add keys to the keyring.  Both negatively and positively instantiated keys can be added using this method.  Adding negative keys is trivial.  Adding a positive key is a bit trickier.  It requires that either /sbin/request-key positively instantiates the key, or that another thread adds the key to the process keyring at just the right time, such that request_key() misses it initially but then finds it in construct_alloc_key().  Fix this bug by checking for Write permission to the keyring in construct_get_dest_keyring() when the default keyring is being used.  We don't do the permission check for non-default keyrings because that was already done by the earlier call to lookup_user_key().  Also, request_key_and_link() is currently passed a 'struct key *' rather than a key_ref_t, so the \"possessed\" bit is unavailable.  We also don't do the permission check for the \"requestor keyring\", to continue to support the use case described by commit 8bbf4976b59f (\"KEYS: Alter use of key instantiation link-to-keyring argument\") where /sbin/request-key recursively calls request_key() to add keys to the original requestor's destination keyring.  (I don't know of any users who actually do that, though...)  Cc: <stable@vger.kernel.org>\t# v2.6.13+",
        "func_before": "static void construct_get_dest_keyring(struct key **_dest_keyring)\n{\n\tstruct request_key_auth *rka;\n\tconst struct cred *cred = current_cred();\n\tstruct key *dest_keyring = *_dest_keyring, *authkey;\n\n\tkenter(\"%p\", dest_keyring);\n\n\t/* find the appropriate keyring */\n\tif (dest_keyring) {\n\t\t/* the caller supplied one */\n\t\tkey_get(dest_keyring);\n\t} else {\n\t\t/* use a default keyring; falling through the cases until we\n\t\t * find one that we actually have */\n\t\tswitch (cred->jit_keyring) {\n\t\tcase KEY_REQKEY_DEFL_DEFAULT:\n\t\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\t\tif (cred->request_key_auth) {\n\t\t\t\tauthkey = cred->request_key_auth;\n\t\t\t\tdown_read(&authkey->sem);\n\t\t\t\trka = authkey->payload.data[0];\n\t\t\t\tif (!test_bit(KEY_FLAG_REVOKED,\n\t\t\t\t\t      &authkey->flags))\n\t\t\t\t\tdest_keyring =\n\t\t\t\t\t\tkey_get(rka->dest_keyring);\n\t\t\t\tup_read(&authkey->sem);\n\t\t\t\tif (dest_keyring)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\t\tdest_keyring = key_get(cred->thread_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\t\tdest_keyring = key_get(cred->process_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\t\t\trcu_read_lock();\n\t\t\tdest_keyring = key_get(\n\t\t\t\trcu_dereference(cred->session_keyring));\n\t\t\trcu_read_unlock();\n\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\t\t\tdest_keyring =\n\t\t\t\tkey_get(cred->user->session_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\t\t\tdest_keyring = key_get(cred->user->uid_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\n\t*_dest_keyring = dest_keyring;\n\tkleave(\" [dk %d]\", key_serial(dest_keyring));\n\treturn;\n}",
        "func": "static int construct_get_dest_keyring(struct key **_dest_keyring)\n{\n\tstruct request_key_auth *rka;\n\tconst struct cred *cred = current_cred();\n\tstruct key *dest_keyring = *_dest_keyring, *authkey;\n\tint ret;\n\n\tkenter(\"%p\", dest_keyring);\n\n\t/* find the appropriate keyring */\n\tif (dest_keyring) {\n\t\t/* the caller supplied one */\n\t\tkey_get(dest_keyring);\n\t} else {\n\t\tbool do_perm_check = true;\n\n\t\t/* use a default keyring; falling through the cases until we\n\t\t * find one that we actually have */\n\t\tswitch (cred->jit_keyring) {\n\t\tcase KEY_REQKEY_DEFL_DEFAULT:\n\t\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\t\tif (cred->request_key_auth) {\n\t\t\t\tauthkey = cred->request_key_auth;\n\t\t\t\tdown_read(&authkey->sem);\n\t\t\t\trka = authkey->payload.data[0];\n\t\t\t\tif (!test_bit(KEY_FLAG_REVOKED,\n\t\t\t\t\t      &authkey->flags))\n\t\t\t\t\tdest_keyring =\n\t\t\t\t\t\tkey_get(rka->dest_keyring);\n\t\t\t\tup_read(&authkey->sem);\n\t\t\t\tif (dest_keyring) {\n\t\t\t\t\tdo_perm_check = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\t\tdest_keyring = key_get(cred->thread_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\t\tdest_keyring = key_get(cred->process_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\t\t\trcu_read_lock();\n\t\t\tdest_keyring = key_get(\n\t\t\t\trcu_dereference(cred->session_keyring));\n\t\t\trcu_read_unlock();\n\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\t\t\tdest_keyring =\n\t\t\t\tkey_get(cred->user->session_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\t\t\tdest_keyring = key_get(cred->user->uid_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\t/*\n\t\t * Require Write permission on the keyring.  This is essential\n\t\t * because the default keyring may be the session keyring, and\n\t\t * joining a keyring only requires Search permission.\n\t\t *\n\t\t * However, this check is skipped for the \"requestor keyring\" so\n\t\t * that /sbin/request-key can itself use request_key() to add\n\t\t * keys to the original requestor's destination keyring.\n\t\t */\n\t\tif (dest_keyring && do_perm_check) {\n\t\t\tret = key_permission(make_key_ref(dest_keyring, 1),\n\t\t\t\t\t     KEY_NEED_WRITE);\n\t\t\tif (ret) {\n\t\t\t\tkey_put(dest_keyring);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\t*_dest_keyring = dest_keyring;\n\tkleave(\" [dk %d]\", key_serial(dest_keyring));\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,9 @@\n-static void construct_get_dest_keyring(struct key **_dest_keyring)\n+static int construct_get_dest_keyring(struct key **_dest_keyring)\n {\n \tstruct request_key_auth *rka;\n \tconst struct cred *cred = current_cred();\n \tstruct key *dest_keyring = *_dest_keyring, *authkey;\n+\tint ret;\n \n \tkenter(\"%p\", dest_keyring);\n \n@@ -11,6 +12,8 @@\n \t\t/* the caller supplied one */\n \t\tkey_get(dest_keyring);\n \t} else {\n+\t\tbool do_perm_check = true;\n+\n \t\t/* use a default keyring; falling through the cases until we\n \t\t * find one that we actually have */\n \t\tswitch (cred->jit_keyring) {\n@@ -25,8 +28,10 @@\n \t\t\t\t\tdest_keyring =\n \t\t\t\t\t\tkey_get(rka->dest_keyring);\n \t\t\t\tup_read(&authkey->sem);\n-\t\t\t\tif (dest_keyring)\n+\t\t\t\tif (dest_keyring) {\n+\t\t\t\t\tdo_perm_check = false;\n \t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t}\n \n \t\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n@@ -61,9 +66,27 @@\n \t\tdefault:\n \t\t\tBUG();\n \t\t}\n+\n+\t\t/*\n+\t\t * Require Write permission on the keyring.  This is essential\n+\t\t * because the default keyring may be the session keyring, and\n+\t\t * joining a keyring only requires Search permission.\n+\t\t *\n+\t\t * However, this check is skipped for the \"requestor keyring\" so\n+\t\t * that /sbin/request-key can itself use request_key() to add\n+\t\t * keys to the original requestor's destination keyring.\n+\t\t */\n+\t\tif (dest_keyring && do_perm_check) {\n+\t\t\tret = key_permission(make_key_ref(dest_keyring, 1),\n+\t\t\t\t\t     KEY_NEED_WRITE);\n+\t\t\tif (ret) {\n+\t\t\t\tkey_put(dest_keyring);\n+\t\t\t\treturn ret;\n+\t\t\t}\n+\t\t}\n \t}\n \n \t*_dest_keyring = dest_keyring;\n \tkleave(\" [dk %d]\", key_serial(dest_keyring));\n-\treturn;\n+\treturn 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static void construct_get_dest_keyring(struct key **_dest_keyring)",
                "\t\t\t\tif (dest_keyring)",
                "\treturn;"
            ],
            "added_lines": [
                "static int construct_get_dest_keyring(struct key **_dest_keyring)",
                "\tint ret;",
                "\t\tbool do_perm_check = true;",
                "",
                "\t\t\t\tif (dest_keyring) {",
                "\t\t\t\t\tdo_perm_check = false;",
                "\t\t\t\t}",
                "",
                "\t\t/*",
                "\t\t * Require Write permission on the keyring.  This is essential",
                "\t\t * because the default keyring may be the session keyring, and",
                "\t\t * joining a keyring only requires Search permission.",
                "\t\t *",
                "\t\t * However, this check is skipped for the \"requestor keyring\" so",
                "\t\t * that /sbin/request-key can itself use request_key() to add",
                "\t\t * keys to the original requestor's destination keyring.",
                "\t\t */",
                "\t\tif (dest_keyring && do_perm_check) {",
                "\t\t\tret = key_permission(make_key_ref(dest_keyring, 1),",
                "\t\t\t\t\t     KEY_NEED_WRITE);",
                "\t\t\tif (ret) {",
                "\t\t\t\tkey_put(dest_keyring);",
                "\t\t\t\treturn ret;",
                "\t\t\t}",
                "\t\t}",
                "\treturn 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-17807",
        "func_name": "torvalds/linux/construct_key_and_link",
        "description": "The KEYS subsystem in the Linux kernel before 4.14.6 omitted an access-control check when adding a key to the current task's \"default request-key keyring\" via the request_key() system call, allowing a local user to use a sequence of crafted system calls to add keys to a keyring with only Search permission (not Write permission) to that keyring, related to construct_get_dest_keyring() in security/keys/request_key.c.",
        "git_url": "https://github.com/torvalds/linux/commit/4dca6ea1d9432052afb06baf2e3ae78188a4410b",
        "commit_title": "KEYS: add missing permission check for request_key() destination",
        "commit_text": " When the request_key() syscall is not passed a destination keyring, it links the requested key (if constructed) into the \"default\" request-key keyring.  This should require Write permission to the keyring.  However, there is actually no permission check.  This can be abused to add keys to any keyring to which only Search permission is granted.  This is because Search permission allows joining the keyring.  keyctl_set_reqkey_keyring(KEY_REQKEY_DEFL_SESSION_KEYRING) then will set the default request-key keyring to the session keyring. Then, request_key() can be used to add keys to the keyring.  Both negatively and positively instantiated keys can be added using this method.  Adding negative keys is trivial.  Adding a positive key is a bit trickier.  It requires that either /sbin/request-key positively instantiates the key, or that another thread adds the key to the process keyring at just the right time, such that request_key() misses it initially but then finds it in construct_alloc_key().  Fix this bug by checking for Write permission to the keyring in construct_get_dest_keyring() when the default keyring is being used.  We don't do the permission check for non-default keyrings because that was already done by the earlier call to lookup_user_key().  Also, request_key_and_link() is currently passed a 'struct key *' rather than a key_ref_t, so the \"possessed\" bit is unavailable.  We also don't do the permission check for the \"requestor keyring\", to continue to support the use case described by commit 8bbf4976b59f (\"KEYS: Alter use of key instantiation link-to-keyring argument\") where /sbin/request-key recursively calls request_key() to add keys to the original requestor's destination keyring.  (I don't know of any users who actually do that, though...)  Cc: <stable@vger.kernel.org>\t# v2.6.13+",
        "func_before": "static struct key *construct_key_and_link(struct keyring_search_context *ctx,\n\t\t\t\t\t  const char *callout_info,\n\t\t\t\t\t  size_t callout_len,\n\t\t\t\t\t  void *aux,\n\t\t\t\t\t  struct key *dest_keyring,\n\t\t\t\t\t  unsigned long flags)\n{\n\tstruct key_user *user;\n\tstruct key *key;\n\tint ret;\n\n\tkenter(\"\");\n\n\tif (ctx->index_key.type == &key_type_keyring)\n\t\treturn ERR_PTR(-EPERM);\n\n\tuser = key_user_lookup(current_fsuid());\n\tif (!user)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tconstruct_get_dest_keyring(&dest_keyring);\n\n\tret = construct_alloc_key(ctx, dest_keyring, flags, user, &key);\n\tkey_user_put(user);\n\n\tif (ret == 0) {\n\t\tret = construct_key(key, callout_info, callout_len, aux,\n\t\t\t\t    dest_keyring);\n\t\tif (ret < 0) {\n\t\t\tkdebug(\"cons failed\");\n\t\t\tgoto construction_failed;\n\t\t}\n\t} else if (ret == -EINPROGRESS) {\n\t\tret = 0;\n\t} else {\n\t\tgoto couldnt_alloc_key;\n\t}\n\n\tkey_put(dest_keyring);\n\tkleave(\" = key %d\", key_serial(key));\n\treturn key;\n\nconstruction_failed:\n\tkey_negate_and_link(key, key_negative_timeout, NULL, NULL);\n\tkey_put(key);\ncouldnt_alloc_key:\n\tkey_put(dest_keyring);\n\tkleave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}",
        "func": "static struct key *construct_key_and_link(struct keyring_search_context *ctx,\n\t\t\t\t\t  const char *callout_info,\n\t\t\t\t\t  size_t callout_len,\n\t\t\t\t\t  void *aux,\n\t\t\t\t\t  struct key *dest_keyring,\n\t\t\t\t\t  unsigned long flags)\n{\n\tstruct key_user *user;\n\tstruct key *key;\n\tint ret;\n\n\tkenter(\"\");\n\n\tif (ctx->index_key.type == &key_type_keyring)\n\t\treturn ERR_PTR(-EPERM);\n\n\tret = construct_get_dest_keyring(&dest_keyring);\n\tif (ret)\n\t\tgoto error;\n\n\tuser = key_user_lookup(current_fsuid());\n\tif (!user) {\n\t\tret = -ENOMEM;\n\t\tgoto error_put_dest_keyring;\n\t}\n\n\tret = construct_alloc_key(ctx, dest_keyring, flags, user, &key);\n\tkey_user_put(user);\n\n\tif (ret == 0) {\n\t\tret = construct_key(key, callout_info, callout_len, aux,\n\t\t\t\t    dest_keyring);\n\t\tif (ret < 0) {\n\t\t\tkdebug(\"cons failed\");\n\t\t\tgoto construction_failed;\n\t\t}\n\t} else if (ret == -EINPROGRESS) {\n\t\tret = 0;\n\t} else {\n\t\tgoto error_put_dest_keyring;\n\t}\n\n\tkey_put(dest_keyring);\n\tkleave(\" = key %d\", key_serial(key));\n\treturn key;\n\nconstruction_failed:\n\tkey_negate_and_link(key, key_negative_timeout, NULL, NULL);\n\tkey_put(key);\nerror_put_dest_keyring:\n\tkey_put(dest_keyring);\nerror:\n\tkleave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,11 +14,15 @@\n \tif (ctx->index_key.type == &key_type_keyring)\n \t\treturn ERR_PTR(-EPERM);\n \n+\tret = construct_get_dest_keyring(&dest_keyring);\n+\tif (ret)\n+\t\tgoto error;\n+\n \tuser = key_user_lookup(current_fsuid());\n-\tif (!user)\n-\t\treturn ERR_PTR(-ENOMEM);\n-\n-\tconstruct_get_dest_keyring(&dest_keyring);\n+\tif (!user) {\n+\t\tret = -ENOMEM;\n+\t\tgoto error_put_dest_keyring;\n+\t}\n \n \tret = construct_alloc_key(ctx, dest_keyring, flags, user, &key);\n \tkey_user_put(user);\n@@ -33,7 +37,7 @@\n \t} else if (ret == -EINPROGRESS) {\n \t\tret = 0;\n \t} else {\n-\t\tgoto couldnt_alloc_key;\n+\t\tgoto error_put_dest_keyring;\n \t}\n \n \tkey_put(dest_keyring);\n@@ -43,8 +47,9 @@\n construction_failed:\n \tkey_negate_and_link(key, key_negative_timeout, NULL, NULL);\n \tkey_put(key);\n-couldnt_alloc_key:\n+error_put_dest_keyring:\n \tkey_put(dest_keyring);\n+error:\n \tkleave(\" = %d\", ret);\n \treturn ERR_PTR(ret);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!user)",
                "\t\treturn ERR_PTR(-ENOMEM);",
                "",
                "\tconstruct_get_dest_keyring(&dest_keyring);",
                "\t\tgoto couldnt_alloc_key;",
                "couldnt_alloc_key:"
            ],
            "added_lines": [
                "\tret = construct_get_dest_keyring(&dest_keyring);",
                "\tif (ret)",
                "\t\tgoto error;",
                "",
                "\tif (!user) {",
                "\t\tret = -ENOMEM;",
                "\t\tgoto error_put_dest_keyring;",
                "\t}",
                "\t\tgoto error_put_dest_keyring;",
                "error_put_dest_keyring:",
                "error:"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0492",
        "func_name": "torvalds/linux/cgroup_release_agent_write",
        "description": "A vulnerability was found in the Linux kernels cgroup_release_agent_write in the kernel/cgroup/cgroup-v1.c function. This flaw, under certain circumstances, allows the use of the cgroups v1 release_agent feature to escalate privileges and bypass the namespace isolation unexpectedly.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=24f6008564183aa120d07c03d9289519c2fe02af",
        "commit_title": "The cgroup release_agent is called with call_usermodehelper.  The function",
        "commit_text": "call_usermodehelper starts the release_agent with a full set fo capabilities. Therefore require capabilities when setting the release_agaent.  Cc: stable@vger.kernel.org # v2.6.24+ ",
        "func_before": "static ssize_t cgroup_release_agent_write(struct kernfs_open_file *of,\n\t\t\t\t\t  char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\n\tBUILD_BUG_ON(sizeof(cgrp->root->release_agent_path) < PATH_MAX);\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\tspin_lock(&release_agent_path_lock);\n\tstrlcpy(cgrp->root->release_agent_path, strstrip(buf),\n\t\tsizeof(cgrp->root->release_agent_path));\n\tspin_unlock(&release_agent_path_lock);\n\tcgroup_kn_unlock(of->kn);\n\treturn nbytes;\n}",
        "func": "static ssize_t cgroup_release_agent_write(struct kernfs_open_file *of,\n\t\t\t\t\t  char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\n\tBUILD_BUG_ON(sizeof(cgrp->root->release_agent_path) < PATH_MAX);\n\n\t/*\n\t * Release agent gets called with all capabilities,\n\t * require capabilities to set release agent.\n\t */\n\tif ((of->file->f_cred->user_ns != &init_user_ns) ||\n\t    !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\tspin_lock(&release_agent_path_lock);\n\tstrlcpy(cgrp->root->release_agent_path, strstrip(buf),\n\t\tsizeof(cgrp->root->release_agent_path));\n\tspin_unlock(&release_agent_path_lock);\n\tcgroup_kn_unlock(of->kn);\n\treturn nbytes;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,14 @@\n \tstruct cgroup *cgrp;\n \n \tBUILD_BUG_ON(sizeof(cgrp->root->release_agent_path) < PATH_MAX);\n+\n+\t/*\n+\t * Release agent gets called with all capabilities,\n+\t * require capabilities to set release agent.\n+\t */\n+\tif ((of->file->f_cred->user_ns != &init_user_ns) ||\n+\t    !capable(CAP_SYS_ADMIN))\n+\t\treturn -EPERM;\n \n \tcgrp = cgroup_kn_lock_live(of->kn, false);\n \tif (!cgrp)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\t/*",
                "\t * Release agent gets called with all capabilities,",
                "\t * require capabilities to set release agent.",
                "\t */",
                "\tif ((of->file->f_cred->user_ns != &init_user_ns) ||",
                "\t    !capable(CAP_SYS_ADMIN))",
                "\t\treturn -EPERM;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0492",
        "func_name": "torvalds/linux/cgroup1_parse_param",
        "description": "A vulnerability was found in the Linux kernels cgroup_release_agent_write in the kernel/cgroup/cgroup-v1.c function. This flaw, under certain circumstances, allows the use of the cgroups v1 release_agent feature to escalate privileges and bypass the namespace isolation unexpectedly.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=24f6008564183aa120d07c03d9289519c2fe02af",
        "commit_title": "The cgroup release_agent is called with call_usermodehelper.  The function",
        "commit_text": "call_usermodehelper starts the release_agent with a full set fo capabilities. Therefore require capabilities when setting the release_agaent.  Cc: stable@vger.kernel.org # v2.6.24+ ",
        "func_before": "int cgroup1_parse_param(struct fs_context *fc, struct fs_parameter *param)\n{\n\tstruct cgroup_fs_context *ctx = cgroup_fc2context(fc);\n\tstruct cgroup_subsys *ss;\n\tstruct fs_parse_result result;\n\tint opt, i;\n\n\topt = fs_parse(fc, cgroup1_fs_parameters, param, &result);\n\tif (opt == -ENOPARAM) {\n\t\tint ret;\n\n\t\tret = vfs_parse_fs_param_source(fc, param);\n\t\tif (ret != -ENOPARAM)\n\t\t\treturn ret;\n\t\tfor_each_subsys(ss, i) {\n\t\t\tif (strcmp(param->key, ss->legacy_name))\n\t\t\t\tcontinue;\n\t\t\tif (!cgroup_ssid_enabled(i) || cgroup1_ssid_disabled(i))\n\t\t\t\treturn invalfc(fc, \"Disabled controller '%s'\",\n\t\t\t\t\t       param->key);\n\t\t\tctx->subsys_mask |= (1 << i);\n\t\t\treturn 0;\n\t\t}\n\t\treturn invalfc(fc, \"Unknown subsys name '%s'\", param->key);\n\t}\n\tif (opt < 0)\n\t\treturn opt;\n\n\tswitch (opt) {\n\tcase Opt_none:\n\t\t/* Explicitly have no subsystems */\n\t\tctx->none = true;\n\t\tbreak;\n\tcase Opt_all:\n\t\tctx->all_ss = true;\n\t\tbreak;\n\tcase Opt_noprefix:\n\t\tctx->flags |= CGRP_ROOT_NOPREFIX;\n\t\tbreak;\n\tcase Opt_clone_children:\n\t\tctx->cpuset_clone_children = true;\n\t\tbreak;\n\tcase Opt_cpuset_v2_mode:\n\t\tctx->flags |= CGRP_ROOT_CPUSET_V2_MODE;\n\t\tbreak;\n\tcase Opt_xattr:\n\t\tctx->flags |= CGRP_ROOT_XATTR;\n\t\tbreak;\n\tcase Opt_release_agent:\n\t\t/* Specifying two release agents is forbidden */\n\t\tif (ctx->release_agent)\n\t\t\treturn invalfc(fc, \"release_agent respecified\");\n\t\tctx->release_agent = param->string;\n\t\tparam->string = NULL;\n\t\tbreak;\n\tcase Opt_name:\n\t\t/* blocked by boot param? */\n\t\tif (cgroup_no_v1_named)\n\t\t\treturn -ENOENT;\n\t\t/* Can't specify an empty name */\n\t\tif (!param->size)\n\t\t\treturn invalfc(fc, \"Empty name\");\n\t\tif (param->size > MAX_CGROUP_ROOT_NAMELEN - 1)\n\t\t\treturn invalfc(fc, \"Name too long\");\n\t\t/* Must match [\\w.-]+ */\n\t\tfor (i = 0; i < param->size; i++) {\n\t\t\tchar c = param->string[i];\n\t\t\tif (isalnum(c))\n\t\t\t\tcontinue;\n\t\t\tif ((c == '.') || (c == '-') || (c == '_'))\n\t\t\t\tcontinue;\n\t\t\treturn invalfc(fc, \"Invalid name\");\n\t\t}\n\t\t/* Specifying two names is forbidden */\n\t\tif (ctx->name)\n\t\t\treturn invalfc(fc, \"name respecified\");\n\t\tctx->name = param->string;\n\t\tparam->string = NULL;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
        "func": "int cgroup1_parse_param(struct fs_context *fc, struct fs_parameter *param)\n{\n\tstruct cgroup_fs_context *ctx = cgroup_fc2context(fc);\n\tstruct cgroup_subsys *ss;\n\tstruct fs_parse_result result;\n\tint opt, i;\n\n\topt = fs_parse(fc, cgroup1_fs_parameters, param, &result);\n\tif (opt == -ENOPARAM) {\n\t\tint ret;\n\n\t\tret = vfs_parse_fs_param_source(fc, param);\n\t\tif (ret != -ENOPARAM)\n\t\t\treturn ret;\n\t\tfor_each_subsys(ss, i) {\n\t\t\tif (strcmp(param->key, ss->legacy_name))\n\t\t\t\tcontinue;\n\t\t\tif (!cgroup_ssid_enabled(i) || cgroup1_ssid_disabled(i))\n\t\t\t\treturn invalfc(fc, \"Disabled controller '%s'\",\n\t\t\t\t\t       param->key);\n\t\t\tctx->subsys_mask |= (1 << i);\n\t\t\treturn 0;\n\t\t}\n\t\treturn invalfc(fc, \"Unknown subsys name '%s'\", param->key);\n\t}\n\tif (opt < 0)\n\t\treturn opt;\n\n\tswitch (opt) {\n\tcase Opt_none:\n\t\t/* Explicitly have no subsystems */\n\t\tctx->none = true;\n\t\tbreak;\n\tcase Opt_all:\n\t\tctx->all_ss = true;\n\t\tbreak;\n\tcase Opt_noprefix:\n\t\tctx->flags |= CGRP_ROOT_NOPREFIX;\n\t\tbreak;\n\tcase Opt_clone_children:\n\t\tctx->cpuset_clone_children = true;\n\t\tbreak;\n\tcase Opt_cpuset_v2_mode:\n\t\tctx->flags |= CGRP_ROOT_CPUSET_V2_MODE;\n\t\tbreak;\n\tcase Opt_xattr:\n\t\tctx->flags |= CGRP_ROOT_XATTR;\n\t\tbreak;\n\tcase Opt_release_agent:\n\t\t/* Specifying two release agents is forbidden */\n\t\tif (ctx->release_agent)\n\t\t\treturn invalfc(fc, \"release_agent respecified\");\n\t\t/*\n\t\t * Release agent gets called with all capabilities,\n\t\t * require capabilities to set release agent.\n\t\t */\n\t\tif ((fc->user_ns != &init_user_ns) || !capable(CAP_SYS_ADMIN))\n\t\t\treturn invalfc(fc, \"Setting release_agent not allowed\");\n\t\tctx->release_agent = param->string;\n\t\tparam->string = NULL;\n\t\tbreak;\n\tcase Opt_name:\n\t\t/* blocked by boot param? */\n\t\tif (cgroup_no_v1_named)\n\t\t\treturn -ENOENT;\n\t\t/* Can't specify an empty name */\n\t\tif (!param->size)\n\t\t\treturn invalfc(fc, \"Empty name\");\n\t\tif (param->size > MAX_CGROUP_ROOT_NAMELEN - 1)\n\t\t\treturn invalfc(fc, \"Name too long\");\n\t\t/* Must match [\\w.-]+ */\n\t\tfor (i = 0; i < param->size; i++) {\n\t\t\tchar c = param->string[i];\n\t\t\tif (isalnum(c))\n\t\t\t\tcontinue;\n\t\t\tif ((c == '.') || (c == '-') || (c == '_'))\n\t\t\t\tcontinue;\n\t\t\treturn invalfc(fc, \"Invalid name\");\n\t\t}\n\t\t/* Specifying two names is forbidden */\n\t\tif (ctx->name)\n\t\t\treturn invalfc(fc, \"name respecified\");\n\t\tctx->name = param->string;\n\t\tparam->string = NULL;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -50,6 +50,12 @@\n \t\t/* Specifying two release agents is forbidden */\n \t\tif (ctx->release_agent)\n \t\t\treturn invalfc(fc, \"release_agent respecified\");\n+\t\t/*\n+\t\t * Release agent gets called with all capabilities,\n+\t\t * require capabilities to set release agent.\n+\t\t */\n+\t\tif ((fc->user_ns != &init_user_ns) || !capable(CAP_SYS_ADMIN))\n+\t\t\treturn invalfc(fc, \"Setting release_agent not allowed\");\n \t\tctx->release_agent = param->string;\n \t\tparam->string = NULL;\n \t\tbreak;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t/*",
                "\t\t * Release agent gets called with all capabilities,",
                "\t\t * require capabilities to set release agent.",
                "\t\t */",
                "\t\tif ((fc->user_ns != &init_user_ns) || !capable(CAP_SYS_ADMIN))",
                "\t\t\treturn invalfc(fc, \"Setting release_agent not allowed\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3656",
        "func_name": "kvm/recalc_intercepts",
        "description": "A flaw was found in the KVM's AMD code for supporting SVM nested virtualization. The flaw occurs when processing the VMCB (virtual machine control block) provided by the L1 guest to spawn/handle a nested guest (L2). Due to improper validation of the \"virt_ext\" field, this issue could allow a malicious L1 to disable both VMLOAD/VMSAVE intercepts and VLS (Virtual VMLOAD/VMSAVE) for the L2 guest. As a result, the L2 guest would be allowed to read/write physical pages of the host, resulting in a crash of the entire system, leak of sensitive data or potential guest-to-host escape.",
        "git_url": "https://git.kernel.org/pub/scm/virt/kvm/kvm.git/commit/?h=c7dfa4009965a9b2d7b329ee970eb8da0d32f0bc",
        "commit_title": "If L1 disables VMLOAD/VMSAVE intercepts, and doesn't enable",
        "commit_text": "Virtual VMLOAD/VMSAVE (currently not supported for the nested hypervisor), then VMLOAD/VMSAVE must operate on the L1 physical memory, which is only possible by making L0 intercept these instructions.  Failure to do so allowed the nested guest to run VMLOAD/VMSAVE unintercepted, and thus read/write portions of the host physical memory.   Suggested-by: Paolo Bonzini <pbonzini@redhat.com> ",
        "func_before": "void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h, *g;\n\tunsigned int i;\n\n\tvmcb_mark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->vmcb01.ptr->control;\n\tg = &svm->nested.ctl;\n\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] = h->intercepts[i];\n\n\tif (g->int_ctl & V_INTR_MASKING_MASK) {\n\t\t/* We only want the cr8 intercept bits of L1 */\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_READ);\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_WRITE);\n\n\t\t/*\n\t\t * Once running L2 with HF_VINTR_MASK, EFLAGS.IF does not\n\t\t * affect any interrupt we may want to inject; therefore,\n\t\t * interrupt window vmexits are irrelevant to L0.\n\t\t */\n\t\tvmcb_clr_intercept(c, INTERCEPT_VINTR);\n\t}\n\n\t/* We don't want to see VMMCALLs from a nested guest */\n\tvmcb_clr_intercept(c, INTERCEPT_VMMCALL);\n\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] |= g->intercepts[i];\n\n\t/* If SMI is not intercepted, ignore guest SMI intercept as well  */\n\tif (!intercept_smi)\n\t\tvmcb_clr_intercept(c, INTERCEPT_SMI);\n}",
        "func": "void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h, *g;\n\tunsigned int i;\n\n\tvmcb_mark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->vmcb01.ptr->control;\n\tg = &svm->nested.ctl;\n\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] = h->intercepts[i];\n\n\tif (g->int_ctl & V_INTR_MASKING_MASK) {\n\t\t/* We only want the cr8 intercept bits of L1 */\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_READ);\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_WRITE);\n\n\t\t/*\n\t\t * Once running L2 with HF_VINTR_MASK, EFLAGS.IF does not\n\t\t * affect any interrupt we may want to inject; therefore,\n\t\t * interrupt window vmexits are irrelevant to L0.\n\t\t */\n\t\tvmcb_clr_intercept(c, INTERCEPT_VINTR);\n\t}\n\n\t/* We don't want to see VMMCALLs from a nested guest */\n\tvmcb_clr_intercept(c, INTERCEPT_VMMCALL);\n\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] |= g->intercepts[i];\n\n\t/* If SMI is not intercepted, ignore guest SMI intercept as well  */\n\tif (!intercept_smi)\n\t\tvmcb_clr_intercept(c, INTERCEPT_SMI);\n\n\tvmcb_set_intercept(c, INTERCEPT_VMLOAD);\n\tvmcb_set_intercept(c, INTERCEPT_VMSAVE);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -37,4 +37,7 @@\n \t/* If SMI is not intercepted, ignore guest SMI intercept as well  */\n \tif (!intercept_smi)\n \t\tvmcb_clr_intercept(c, INTERCEPT_SMI);\n+\n+\tvmcb_set_intercept(c, INTERCEPT_VMLOAD);\n+\tvmcb_set_intercept(c, INTERCEPT_VMSAVE);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tvmcb_set_intercept(c, INTERCEPT_VMLOAD);",
                "\tvmcb_set_intercept(c, INTERCEPT_VMSAVE);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-30594",
        "func_name": "torvalds/linux/ptrace_setoptions",
        "description": "The Linux kernel before 5.17.2 mishandles seccomp permissions. The PTRACE_SEIZE code path allows attackers to bypass intended restrictions on setting the PT_SUSPEND_SECCOMP flag.",
        "git_url": "https://github.com/torvalds/linux/commit/ee1fee900537b5d9560e9f937402de5ddc8412f3",
        "commit_title": "ptrace: Check PTRACE_O_SUSPEND_SECCOMP permission on PTRACE_SEIZE",
        "commit_text": " Setting PTRACE_O_SUSPEND_SECCOMP is supposed to be a highly privileged operation because it allows the tracee to completely bypass all seccomp filters on kernels with CONFIG_CHECKPOINT_RESTORE=y. It is only supposed to be settable by a process with global CAP_SYS_ADMIN, and only if that process is not subject to any seccomp filters at all.  However, while these permission checks were done on the PTRACE_SETOPTIONS path, they were missing on the PTRACE_SEIZE path, which also sets user-specified ptrace flags.  Move the permissions checks out into a helper function and let both ptrace_attach() and ptrace_setoptions() call it.  Cc: stable@kernel.org Link: https://lkml.kernel.org/r/20220319010838.1386861-1-jannh@google.com",
        "func_before": "static int ptrace_setoptions(struct task_struct *child, unsigned long data)\n{\n\tunsigned flags;\n\n\tif (data & ~(unsigned long)PTRACE_O_MASK)\n\t\treturn -EINVAL;\n\n\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {\n\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||\n\t\t    !IS_ENABLED(CONFIG_SECCOMP))\n\t\t\treturn -EINVAL;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||\n\t\t    current->ptrace & PT_SUSPEND_SECCOMP)\n\t\t\treturn -EPERM;\n\t}\n\n\t/* Avoid intermediate state when all opts are cleared */\n\tflags = child->ptrace;\n\tflags &= ~(PTRACE_O_MASK << PT_OPT_FLAG_SHIFT);\n\tflags |= (data << PT_OPT_FLAG_SHIFT);\n\tchild->ptrace = flags;\n\n\treturn 0;\n}",
        "func": "static int ptrace_setoptions(struct task_struct *child, unsigned long data)\n{\n\tunsigned flags;\n\tint ret;\n\n\tret = check_ptrace_options(data);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Avoid intermediate state when all opts are cleared */\n\tflags = child->ptrace;\n\tflags &= ~(PTRACE_O_MASK << PT_OPT_FLAG_SHIFT);\n\tflags |= (data << PT_OPT_FLAG_SHIFT);\n\tchild->ptrace = flags;\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,22 +1,11 @@\n static int ptrace_setoptions(struct task_struct *child, unsigned long data)\n {\n \tunsigned flags;\n+\tint ret;\n \n-\tif (data & ~(unsigned long)PTRACE_O_MASK)\n-\t\treturn -EINVAL;\n-\n-\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {\n-\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||\n-\t\t    !IS_ENABLED(CONFIG_SECCOMP))\n-\t\t\treturn -EINVAL;\n-\n-\t\tif (!capable(CAP_SYS_ADMIN))\n-\t\t\treturn -EPERM;\n-\n-\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||\n-\t\t    current->ptrace & PT_SUSPEND_SECCOMP)\n-\t\t\treturn -EPERM;\n-\t}\n+\tret = check_ptrace_options(data);\n+\tif (ret)\n+\t\treturn ret;\n \n \t/* Avoid intermediate state when all opts are cleared */\n \tflags = child->ptrace;",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (data & ~(unsigned long)PTRACE_O_MASK)",
                "\t\treturn -EINVAL;",
                "",
                "\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {",
                "\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||",
                "\t\t    !IS_ENABLED(CONFIG_SECCOMP))",
                "\t\t\treturn -EINVAL;",
                "",
                "\t\tif (!capable(CAP_SYS_ADMIN))",
                "\t\t\treturn -EPERM;",
                "",
                "\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||",
                "\t\t    current->ptrace & PT_SUSPEND_SECCOMP)",
                "\t\t\treturn -EPERM;",
                "\t}"
            ],
            "added_lines": [
                "\tint ret;",
                "\tret = check_ptrace_options(data);",
                "\tif (ret)",
                "\t\treturn ret;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-30594",
        "func_name": "torvalds/linux/ptrace_attach",
        "description": "The Linux kernel before 5.17.2 mishandles seccomp permissions. The PTRACE_SEIZE code path allows attackers to bypass intended restrictions on setting the PT_SUSPEND_SECCOMP flag.",
        "git_url": "https://github.com/torvalds/linux/commit/ee1fee900537b5d9560e9f937402de5ddc8412f3",
        "commit_title": "ptrace: Check PTRACE_O_SUSPEND_SECCOMP permission on PTRACE_SEIZE",
        "commit_text": " Setting PTRACE_O_SUSPEND_SECCOMP is supposed to be a highly privileged operation because it allows the tracee to completely bypass all seccomp filters on kernels with CONFIG_CHECKPOINT_RESTORE=y. It is only supposed to be settable by a process with global CAP_SYS_ADMIN, and only if that process is not subject to any seccomp filters at all.  However, while these permission checks were done on the PTRACE_SETOPTIONS path, they were missing on the PTRACE_SEIZE path, which also sets user-specified ptrace flags.  Move the permissions checks out into a helper function and let both ptrace_attach() and ptrace_setoptions() call it.  Cc: stable@kernel.org Link: https://lkml.kernel.org/r/20220319010838.1386861-1-jannh@google.com",
        "func_before": "static int ptrace_attach(struct task_struct *task, long request,\n\t\t\t unsigned long addr,\n\t\t\t unsigned long flags)\n{\n\tbool seize = (request == PTRACE_SEIZE);\n\tint retval;\n\n\tretval = -EIO;\n\tif (seize) {\n\t\tif (addr != 0)\n\t\t\tgoto out;\n\t\tif (flags & ~(unsigned long)PTRACE_O_MASK)\n\t\t\tgoto out;\n\t\tflags = PT_PTRACED | PT_SEIZED | (flags << PT_OPT_FLAG_SHIFT);\n\t} else {\n\t\tflags = PT_PTRACED;\n\t}\n\n\taudit_ptrace(task);\n\n\tretval = -EPERM;\n\tif (unlikely(task->flags & PF_KTHREAD))\n\t\tgoto out;\n\tif (same_thread_group(task, current))\n\t\tgoto out;\n\n\t/*\n\t * Protect exec's credential calculations against our interference;\n\t * SUID, SGID and LSM creds get determined differently\n\t * under ptrace.\n\t */\n\tretval = -ERESTARTNOINTR;\n\tif (mutex_lock_interruptible(&task->signal->cred_guard_mutex))\n\t\tgoto out;\n\n\ttask_lock(task);\n\tretval = __ptrace_may_access(task, PTRACE_MODE_ATTACH_REALCREDS);\n\ttask_unlock(task);\n\tif (retval)\n\t\tgoto unlock_creds;\n\n\twrite_lock_irq(&tasklist_lock);\n\tretval = -EPERM;\n\tif (unlikely(task->exit_state))\n\t\tgoto unlock_tasklist;\n\tif (task->ptrace)\n\t\tgoto unlock_tasklist;\n\n\ttask->ptrace = flags;\n\n\tptrace_link(task, current);\n\n\t/* SEIZE doesn't trap tracee on attach */\n\tif (!seize)\n\t\tsend_sig_info(SIGSTOP, SEND_SIG_PRIV, task);\n\n\tspin_lock(&task->sighand->siglock);\n\n\t/*\n\t * If the task is already STOPPED, set JOBCTL_TRAP_STOP and\n\t * TRAPPING, and kick it so that it transits to TRACED.  TRAPPING\n\t * will be cleared if the child completes the transition or any\n\t * event which clears the group stop states happens.  We'll wait\n\t * for the transition to complete before returning from this\n\t * function.\n\t *\n\t * This hides STOPPED -> RUNNING -> TRACED transition from the\n\t * attaching thread but a different thread in the same group can\n\t * still observe the transient RUNNING state.  IOW, if another\n\t * thread's WNOHANG wait(2) on the stopped tracee races against\n\t * ATTACH, the wait(2) may fail due to the transient RUNNING.\n\t *\n\t * The following task_is_stopped() test is safe as both transitions\n\t * in and out of STOPPED are protected by siglock.\n\t */\n\tif (task_is_stopped(task) &&\n\t    task_set_jobctl_pending(task, JOBCTL_TRAP_STOP | JOBCTL_TRAPPING))\n\t\tsignal_wake_up_state(task, __TASK_STOPPED);\n\n\tspin_unlock(&task->sighand->siglock);\n\n\tretval = 0;\nunlock_tasklist:\n\twrite_unlock_irq(&tasklist_lock);\nunlock_creds:\n\tmutex_unlock(&task->signal->cred_guard_mutex);\nout:\n\tif (!retval) {\n\t\t/*\n\t\t * We do not bother to change retval or clear JOBCTL_TRAPPING\n\t\t * if wait_on_bit() was interrupted by SIGKILL. The tracer will\n\t\t * not return to user-mode, it will exit and clear this bit in\n\t\t * __ptrace_unlink() if it wasn't already cleared by the tracee;\n\t\t * and until then nobody can ptrace this task.\n\t\t */\n\t\twait_on_bit(&task->jobctl, JOBCTL_TRAPPING_BIT, TASK_KILLABLE);\n\t\tproc_ptrace_connector(task, PTRACE_ATTACH);\n\t}\n\n\treturn retval;\n}",
        "func": "static int ptrace_attach(struct task_struct *task, long request,\n\t\t\t unsigned long addr,\n\t\t\t unsigned long flags)\n{\n\tbool seize = (request == PTRACE_SEIZE);\n\tint retval;\n\n\tretval = -EIO;\n\tif (seize) {\n\t\tif (addr != 0)\n\t\t\tgoto out;\n\t\t/*\n\t\t * This duplicates the check in check_ptrace_options() because\n\t\t * ptrace_attach() and ptrace_setoptions() have historically\n\t\t * used different error codes for unknown ptrace options.\n\t\t */\n\t\tif (flags & ~(unsigned long)PTRACE_O_MASK)\n\t\t\tgoto out;\n\t\tretval = check_ptrace_options(flags);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tflags = PT_PTRACED | PT_SEIZED | (flags << PT_OPT_FLAG_SHIFT);\n\t} else {\n\t\tflags = PT_PTRACED;\n\t}\n\n\taudit_ptrace(task);\n\n\tretval = -EPERM;\n\tif (unlikely(task->flags & PF_KTHREAD))\n\t\tgoto out;\n\tif (same_thread_group(task, current))\n\t\tgoto out;\n\n\t/*\n\t * Protect exec's credential calculations against our interference;\n\t * SUID, SGID and LSM creds get determined differently\n\t * under ptrace.\n\t */\n\tretval = -ERESTARTNOINTR;\n\tif (mutex_lock_interruptible(&task->signal->cred_guard_mutex))\n\t\tgoto out;\n\n\ttask_lock(task);\n\tretval = __ptrace_may_access(task, PTRACE_MODE_ATTACH_REALCREDS);\n\ttask_unlock(task);\n\tif (retval)\n\t\tgoto unlock_creds;\n\n\twrite_lock_irq(&tasklist_lock);\n\tretval = -EPERM;\n\tif (unlikely(task->exit_state))\n\t\tgoto unlock_tasklist;\n\tif (task->ptrace)\n\t\tgoto unlock_tasklist;\n\n\ttask->ptrace = flags;\n\n\tptrace_link(task, current);\n\n\t/* SEIZE doesn't trap tracee on attach */\n\tif (!seize)\n\t\tsend_sig_info(SIGSTOP, SEND_SIG_PRIV, task);\n\n\tspin_lock(&task->sighand->siglock);\n\n\t/*\n\t * If the task is already STOPPED, set JOBCTL_TRAP_STOP and\n\t * TRAPPING, and kick it so that it transits to TRACED.  TRAPPING\n\t * will be cleared if the child completes the transition or any\n\t * event which clears the group stop states happens.  We'll wait\n\t * for the transition to complete before returning from this\n\t * function.\n\t *\n\t * This hides STOPPED -> RUNNING -> TRACED transition from the\n\t * attaching thread but a different thread in the same group can\n\t * still observe the transient RUNNING state.  IOW, if another\n\t * thread's WNOHANG wait(2) on the stopped tracee races against\n\t * ATTACH, the wait(2) may fail due to the transient RUNNING.\n\t *\n\t * The following task_is_stopped() test is safe as both transitions\n\t * in and out of STOPPED are protected by siglock.\n\t */\n\tif (task_is_stopped(task) &&\n\t    task_set_jobctl_pending(task, JOBCTL_TRAP_STOP | JOBCTL_TRAPPING))\n\t\tsignal_wake_up_state(task, __TASK_STOPPED);\n\n\tspin_unlock(&task->sighand->siglock);\n\n\tretval = 0;\nunlock_tasklist:\n\twrite_unlock_irq(&tasklist_lock);\nunlock_creds:\n\tmutex_unlock(&task->signal->cred_guard_mutex);\nout:\n\tif (!retval) {\n\t\t/*\n\t\t * We do not bother to change retval or clear JOBCTL_TRAPPING\n\t\t * if wait_on_bit() was interrupted by SIGKILL. The tracer will\n\t\t * not return to user-mode, it will exit and clear this bit in\n\t\t * __ptrace_unlink() if it wasn't already cleared by the tracee;\n\t\t * and until then nobody can ptrace this task.\n\t\t */\n\t\twait_on_bit(&task->jobctl, JOBCTL_TRAPPING_BIT, TASK_KILLABLE);\n\t\tproc_ptrace_connector(task, PTRACE_ATTACH);\n\t}\n\n\treturn retval;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,8 +9,16 @@\n \tif (seize) {\n \t\tif (addr != 0)\n \t\t\tgoto out;\n+\t\t/*\n+\t\t * This duplicates the check in check_ptrace_options() because\n+\t\t * ptrace_attach() and ptrace_setoptions() have historically\n+\t\t * used different error codes for unknown ptrace options.\n+\t\t */\n \t\tif (flags & ~(unsigned long)PTRACE_O_MASK)\n \t\t\tgoto out;\n+\t\tretval = check_ptrace_options(flags);\n+\t\tif (retval)\n+\t\t\treturn retval;\n \t\tflags = PT_PTRACED | PT_SEIZED | (flags << PT_OPT_FLAG_SHIFT);\n \t} else {\n \t\tflags = PT_PTRACED;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t/*",
                "\t\t * This duplicates the check in check_ptrace_options() because",
                "\t\t * ptrace_attach() and ptrace_setoptions() have historically",
                "\t\t * used different error codes for unknown ptrace options.",
                "\t\t */",
                "\t\tretval = check_ptrace_options(flags);",
                "\t\tif (retval)",
                "\t\t\treturn retval;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-1116",
        "func_name": "polkit/polkit_backend_session_monitor_get_user_for_subject",
        "description": "A flaw was found in polkit before version 0.116. The implementation of the polkit_backend_interactive_authority_check_authorization function in polkitd allows to test for authentication and trigger authentication of unrelated processes owned by other users. This may result in a local DoS and information disclosure.",
        "git_url": "https://cgit.freedesktop.org/polkit/commit/?id=bc7ffad5364",
        "commit_title": "As part of CVE-2013-4288, the D-Bus clients were allowed (and",
        "commit_text": "encouraged) to submit the UID of the subject of authorization checks to avoid races against UID changes (notably using executables set-UID to root).  However, that also allowed any client to submit an arbitrary UID, and that could be used to bypass \"can only ask about / affect the same UID\" checks in CheckAuthorization / RegisterAuthenticationAgent / UnregisterAuthenticationAgent.  This allowed an attacker:  - With CheckAuthorization, to cause the registered authentication   agent in victim's session to pop up a dialog, or to determine whether   the victim currently has a temporary authorization to perform an   operation.    (In principle, the attacker can also determine whether JavaScript   rules allow the victim process to perform an operation; however,   usually rules base their decisions on information determined from   the supplied UID, so the attacker usually won't learn anything new.)  - With RegisterAuthenticationAgent, to prevent the victim's   authentication agent to work (for a specific victim process),   or to learn about which operations requiring authorization   the victim is attempting.  To fix this, expose internal _polkit_unix_process_get_owner() / obsolete polkit_unix_process_get_owner() as a private polkit_unix_process_get_racy_uid__() (being more explicit about the dangers on relying on it), and use it in polkit_backend_session_monitor_get_user_for_subject() to return a boolean indicating whether the subject UID may be caller-chosen.  Then, in the permission checks that require the subject to be equal to the caller, fail on caller-chosen UIDs (and continue through the pre-existing code paths which allow root, or root-designated server processes, to ask about arbitrary subjects.)  ",
        "func_before": "PolkitIdentity *\npolkit_backend_session_monitor_get_user_for_subject (PolkitBackendSessionMonitor  *monitor,\n                                                     PolkitSubject                *subject,\n                                                     GError                      **error)\n{\n  PolkitIdentity *ret;\n  GError *local_error;\n  gchar *group;\n  guint32 uid;\n\n  ret = NULL;\n\n  if (POLKIT_IS_UNIX_PROCESS (subject))\n    {\n      uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (subject));\n      if ((gint) uid == -1)\n        {\n          g_set_error (error,\n                       POLKIT_ERROR,\n                       POLKIT_ERROR_FAILED,\n                       \"Unix process subject does not have uid set\");\n          goto out;\n        }\n      ret = polkit_unix_user_new (uid);\n    }\n  else if (POLKIT_IS_SYSTEM_BUS_NAME (subject))\n    {\n      ret = (PolkitIdentity*)polkit_system_bus_name_get_user_sync (POLKIT_SYSTEM_BUS_NAME (subject), NULL, error);\n    }\n  else if (POLKIT_IS_UNIX_SESSION (subject))\n    {\n      if (!ensure_database (monitor, error))\n        {\n          g_prefix_error (error, \"Error getting user for session: Error ensuring CK database at \" CKDB_PATH \": \");\n          goto out;\n        }\n\n      group = g_strdup_printf (\"Session %s\", polkit_unix_session_get_session_id (POLKIT_UNIX_SESSION (subject)));\n      local_error = NULL;\n      uid = g_key_file_get_integer (monitor->database, group, \"uid\", &local_error);\n      if (local_error != NULL)\n        {\n          g_propagate_prefixed_error (error, local_error, \"Error getting uid using \" CKDB_PATH \": \");\n          g_free (group);\n          goto out;\n        }\n      g_free (group);\n\n      ret = polkit_unix_user_new (uid);\n    }\n\n out:\n  return ret;\n}",
        "func": "PolkitIdentity *\npolkit_backend_session_monitor_get_user_for_subject (PolkitBackendSessionMonitor  *monitor,\n                                                     PolkitSubject                *subject,\n                                                     gboolean                     *result_matches,\n                                                     GError                      **error)\n{\n  PolkitIdentity *ret;\n  gboolean matches;\n  GError *local_error;\n\n  ret = NULL;\n  matches = FALSE;\n\n  if (POLKIT_IS_UNIX_PROCESS (subject))\n    {\n      gint subject_uid, current_uid;\n\n      subject_uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (subject));\n      if (subject_uid == -1)\n        {\n          g_set_error (error,\n                       POLKIT_ERROR,\n                       POLKIT_ERROR_FAILED,\n                       \"Unix process subject does not have uid set\");\n          goto out;\n        }\n      local_error = NULL;\n      current_uid = polkit_unix_process_get_racy_uid__ (POLKIT_UNIX_PROCESS (subject), &local_error);\n      if (local_error != NULL)\n\t{\n\t  g_propagate_error (error, local_error);\n\t  goto out;\n\t}\n      ret = polkit_unix_user_new (subject_uid);\n      matches = (subject_uid == current_uid);\n    }\n  else if (POLKIT_IS_SYSTEM_BUS_NAME (subject))\n    {\n      ret = (PolkitIdentity*)polkit_system_bus_name_get_user_sync (POLKIT_SYSTEM_BUS_NAME (subject), NULL, error);\n      matches = TRUE;\n    }\n  else if (POLKIT_IS_UNIX_SESSION (subject))\n    {\n      gint uid;\n      gchar *group;\n\n      if (!ensure_database (monitor, error))\n        {\n          g_prefix_error (error, \"Error getting user for session: Error ensuring CK database at \" CKDB_PATH \": \");\n          goto out;\n        }\n\n      group = g_strdup_printf (\"Session %s\", polkit_unix_session_get_session_id (POLKIT_UNIX_SESSION (subject)));\n      local_error = NULL;\n      uid = g_key_file_get_integer (monitor->database, group, \"uid\", &local_error);\n      if (local_error != NULL)\n        {\n          g_propagate_prefixed_error (error, local_error, \"Error getting uid using \" CKDB_PATH \": \");\n          g_free (group);\n          goto out;\n        }\n      g_free (group);\n\n      ret = polkit_unix_user_new (uid);\n      matches = TRUE;\n    }\n\n out:\n  if (result_matches != NULL)\n    {\n      *result_matches = matches;\n    }\n  return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,19 +1,22 @@\n PolkitIdentity *\n polkit_backend_session_monitor_get_user_for_subject (PolkitBackendSessionMonitor  *monitor,\n                                                      PolkitSubject                *subject,\n+                                                     gboolean                     *result_matches,\n                                                      GError                      **error)\n {\n   PolkitIdentity *ret;\n+  gboolean matches;\n   GError *local_error;\n-  gchar *group;\n-  guint32 uid;\n \n   ret = NULL;\n+  matches = FALSE;\n \n   if (POLKIT_IS_UNIX_PROCESS (subject))\n     {\n-      uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (subject));\n-      if ((gint) uid == -1)\n+      gint subject_uid, current_uid;\n+\n+      subject_uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (subject));\n+      if (subject_uid == -1)\n         {\n           g_set_error (error,\n                        POLKIT_ERROR,\n@@ -21,14 +24,26 @@\n                        \"Unix process subject does not have uid set\");\n           goto out;\n         }\n-      ret = polkit_unix_user_new (uid);\n+      local_error = NULL;\n+      current_uid = polkit_unix_process_get_racy_uid__ (POLKIT_UNIX_PROCESS (subject), &local_error);\n+      if (local_error != NULL)\n+\t{\n+\t  g_propagate_error (error, local_error);\n+\t  goto out;\n+\t}\n+      ret = polkit_unix_user_new (subject_uid);\n+      matches = (subject_uid == current_uid);\n     }\n   else if (POLKIT_IS_SYSTEM_BUS_NAME (subject))\n     {\n       ret = (PolkitIdentity*)polkit_system_bus_name_get_user_sync (POLKIT_SYSTEM_BUS_NAME (subject), NULL, error);\n+      matches = TRUE;\n     }\n   else if (POLKIT_IS_UNIX_SESSION (subject))\n     {\n+      gint uid;\n+      gchar *group;\n+\n       if (!ensure_database (monitor, error))\n         {\n           g_prefix_error (error, \"Error getting user for session: Error ensuring CK database at \" CKDB_PATH \": \");\n@@ -47,8 +62,13 @@\n       g_free (group);\n \n       ret = polkit_unix_user_new (uid);\n+      matches = TRUE;\n     }\n \n  out:\n+  if (result_matches != NULL)\n+    {\n+      *result_matches = matches;\n+    }\n   return ret;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  gchar *group;",
                "  guint32 uid;",
                "      uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (subject));",
                "      if ((gint) uid == -1)",
                "      ret = polkit_unix_user_new (uid);"
            ],
            "added_lines": [
                "                                                     gboolean                     *result_matches,",
                "  gboolean matches;",
                "  matches = FALSE;",
                "      gint subject_uid, current_uid;",
                "",
                "      subject_uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (subject));",
                "      if (subject_uid == -1)",
                "      local_error = NULL;",
                "      current_uid = polkit_unix_process_get_racy_uid__ (POLKIT_UNIX_PROCESS (subject), &local_error);",
                "      if (local_error != NULL)",
                "\t{",
                "\t  g_propagate_error (error, local_error);",
                "\t  goto out;",
                "\t}",
                "      ret = polkit_unix_user_new (subject_uid);",
                "      matches = (subject_uid == current_uid);",
                "      matches = TRUE;",
                "      gint uid;",
                "      gchar *group;",
                "",
                "      matches = TRUE;",
                "  if (result_matches != NULL)",
                "    {",
                "      *result_matches = matches;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-1116",
        "func_name": "polkit/polkit_backend_interactive_authority_check_authorization",
        "description": "A flaw was found in polkit before version 0.116. The implementation of the polkit_backend_interactive_authority_check_authorization function in polkitd allows to test for authentication and trigger authentication of unrelated processes owned by other users. This may result in a local DoS and information disclosure.",
        "git_url": "https://cgit.freedesktop.org/polkit/commit/?id=bc7ffad5364",
        "commit_title": "As part of CVE-2013-4288, the D-Bus clients were allowed (and",
        "commit_text": "encouraged) to submit the UID of the subject of authorization checks to avoid races against UID changes (notably using executables set-UID to root).  However, that also allowed any client to submit an arbitrary UID, and that could be used to bypass \"can only ask about / affect the same UID\" checks in CheckAuthorization / RegisterAuthenticationAgent / UnregisterAuthenticationAgent.  This allowed an attacker:  - With CheckAuthorization, to cause the registered authentication   agent in victim's session to pop up a dialog, or to determine whether   the victim currently has a temporary authorization to perform an   operation.    (In principle, the attacker can also determine whether JavaScript   rules allow the victim process to perform an operation; however,   usually rules base their decisions on information determined from   the supplied UID, so the attacker usually won't learn anything new.)  - With RegisterAuthenticationAgent, to prevent the victim's   authentication agent to work (for a specific victim process),   or to learn about which operations requiring authorization   the victim is attempting.  To fix this, expose internal _polkit_unix_process_get_owner() / obsolete polkit_unix_process_get_owner() as a private polkit_unix_process_get_racy_uid__() (being more explicit about the dangers on relying on it), and use it in polkit_backend_session_monitor_get_user_for_subject() to return a boolean indicating whether the subject UID may be caller-chosen.  Then, in the permission checks that require the subject to be equal to the caller, fail on caller-chosen UIDs (and continue through the pre-existing code paths which allow root, or root-designated server processes, to ask about arbitrary subjects.)  ",
        "func_before": "static void\npolkit_backend_interactive_authority_check_authorization (PolkitBackendAuthority         *authority,\n                                                          PolkitSubject                  *caller,\n                                                          PolkitSubject                  *subject,\n                                                          const gchar                    *action_id,\n                                                          PolkitDetails                  *details,\n                                                          PolkitCheckAuthorizationFlags   flags,\n                                                          GCancellable                   *cancellable,\n                                                          GAsyncReadyCallback             callback,\n                                                          gpointer                        user_data)\n{\n  PolkitBackendInteractiveAuthority *interactive_authority;\n  PolkitBackendInteractiveAuthorityPrivate *priv;\n  gchar *caller_str;\n  gchar *subject_str;\n  PolkitIdentity *user_of_caller;\n  PolkitIdentity *user_of_subject;\n  gchar *user_of_caller_str;\n  gchar *user_of_subject_str;\n  PolkitAuthorizationResult *result;\n  PolkitImplicitAuthorization implicit_authorization;\n  GError *error;\n  GSimpleAsyncResult *simple;\n  gboolean has_details;\n  gchar **detail_keys;\n\n  interactive_authority = POLKIT_BACKEND_INTERACTIVE_AUTHORITY (authority);\n  priv = POLKIT_BACKEND_INTERACTIVE_AUTHORITY_GET_PRIVATE (interactive_authority);\n\n  error = NULL;\n  caller_str = NULL;\n  subject_str = NULL;\n  user_of_caller = NULL;\n  user_of_subject = NULL;\n  user_of_caller_str = NULL;\n  user_of_subject_str = NULL;\n  result = NULL;\n\n  simple = g_simple_async_result_new (G_OBJECT (authority),\n                                      callback,\n                                      user_data,\n                                      polkit_backend_interactive_authority_check_authorization);\n\n  /* handle being called from ourselves */\n  if (caller == NULL)\n    {\n      /* TODO: this is kind of a hack */\n      GDBusConnection *system_bus;\n      system_bus = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, NULL);\n      caller = polkit_system_bus_name_new (g_dbus_connection_get_unique_name (system_bus));\n      g_object_unref (system_bus);\n    }\n\n  caller_str = polkit_subject_to_string (caller);\n  subject_str = polkit_subject_to_string (subject);\n\n  g_debug (\"%s is inquiring whether %s is authorized for %s\",\n           caller_str,\n           subject_str,\n           action_id);\n\n  user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,\n                                                                        caller,\n                                                                        &error);\n  if (error != NULL)\n    {\n      g_simple_async_result_set_from_error (simple, error);\n      g_simple_async_result_complete (simple);\n      g_object_unref (simple);\n      g_error_free (error);\n      goto out;\n    }\n\n  user_of_caller_str = polkit_identity_to_string (user_of_caller);\n  g_debug (\" user of caller is %s\", user_of_caller_str);\n\n  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,\n                                                                         subject,\n                                                                         &error);\n  if (error != NULL)\n    {\n      g_simple_async_result_set_from_error (simple, error);\n      g_simple_async_result_complete (simple);\n      g_object_unref (simple);\n      g_error_free (error);\n      goto out;\n    }\n\n  user_of_subject_str = polkit_identity_to_string (user_of_subject);\n  g_debug (\" user of subject is %s\", user_of_subject_str);\n\n  has_details = FALSE;\n  if (details != NULL)\n    {\n      detail_keys = polkit_details_get_keys (details);\n      if (detail_keys != NULL)\n        {\n          if (g_strv_length (detail_keys) > 0)\n            has_details = TRUE;\n          g_strfreev (detail_keys);\n        }\n    }\n\n  /* Not anyone is allowed to check that process XYZ is allowed to do ABC.\n   * We only allow this if, and only if,\n   *\n   *  - processes may check for another process owned by the *same* user but not\n   *    if details are passed (otherwise you'd be able to spoof the dialog)\n   *\n   *  - processes running as uid 0 may check anything and pass any details\n   *\n   *  - if the action_id has the \"org.freedesktop.policykit.owner\" annotation\n   *    then any uid referenced by that annotation is also allowed to check\n   *    to check anything and pass any details\n   */\n  if (!polkit_identity_equal (user_of_caller, user_of_subject) || has_details)\n    {\n      if (!may_identity_check_authorization (interactive_authority, action_id, user_of_caller))\n        {\n          if (has_details)\n            {\n              g_simple_async_result_set_error (simple,\n                                               POLKIT_ERROR,\n                                               POLKIT_ERROR_NOT_AUTHORIZED,\n                                               \"Only trusted callers (e.g. uid 0 or an action owner) can use CheckAuthorization() and \"\n                                               \"pass details\");\n            }\n          else\n            {\n              g_simple_async_result_set_error (simple,\n                                               POLKIT_ERROR,\n                                               POLKIT_ERROR_NOT_AUTHORIZED,\n                                               \"Only trusted callers (e.g. uid 0 or an action owner) can use CheckAuthorization() for \"\n                                               \"subjects belonging to other identities\");\n            }\n          g_simple_async_result_complete (simple);\n          g_object_unref (simple);\n          goto out;\n        }\n    }\n\n  implicit_authorization = POLKIT_IMPLICIT_AUTHORIZATION_NOT_AUTHORIZED;\n  result = check_authorization_sync (authority,\n                                     caller,\n                                     subject,\n                                     action_id,\n                                     details,\n                                     flags,\n                                     &implicit_authorization,\n                                     FALSE, /* checking_imply */\n                                     &error);\n  if (error != NULL)\n    {\n      g_simple_async_result_set_from_error (simple, error);\n      g_simple_async_result_complete (simple);\n      g_object_unref (simple);\n      g_error_free (error);\n      goto out;\n    }\n\n  /* Caller is up for a challenge! With light sabers! Use an authentication agent if one exists... */\n  if (polkit_authorization_result_get_is_challenge (result) &&\n      (flags & POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION))\n    {\n      AuthenticationAgent *agent;\n\n      agent = get_authentication_agent_for_subject (interactive_authority, subject);\n      if (agent != NULL)\n        {\n          g_object_unref (result);\n          result = NULL;\n\n          g_debug (\" using authentication agent for challenge\");\n\n          authentication_agent_initiate_challenge (agent,\n                                                   subject,\n                                                   user_of_subject,\n                                                   interactive_authority,\n                                                   action_id,\n                                                   details,\n                                                   caller,\n                                                   implicit_authorization,\n                                                   cancellable,\n                                                   check_authorization_challenge_cb,\n                                                   simple);\n\n          /* keep going */\n          goto out;\n        }\n    }\n\n  /* log_result (interactive_authority, action_id, subject, caller, result); */\n\n  /* Otherwise just return the result */\n  g_simple_async_result_set_op_res_gpointer (simple,\n                                             g_object_ref (result),\n                                             g_object_unref);\n  g_simple_async_result_complete (simple);\n  g_object_unref (simple);\n\n out:\n\n  if (user_of_caller != NULL)\n    g_object_unref (user_of_caller);\n\n  if (user_of_subject != NULL)\n    g_object_unref (user_of_subject);\n\n  g_free (caller_str);\n  g_free (subject_str);\n  g_free (user_of_caller_str);\n  g_free (user_of_subject_str);\n\n  if (result != NULL)\n    g_object_unref (result);\n}",
        "func": "static void\npolkit_backend_interactive_authority_check_authorization (PolkitBackendAuthority         *authority,\n                                                          PolkitSubject                  *caller,\n                                                          PolkitSubject                  *subject,\n                                                          const gchar                    *action_id,\n                                                          PolkitDetails                  *details,\n                                                          PolkitCheckAuthorizationFlags   flags,\n                                                          GCancellable                   *cancellable,\n                                                          GAsyncReadyCallback             callback,\n                                                          gpointer                        user_data)\n{\n  PolkitBackendInteractiveAuthority *interactive_authority;\n  PolkitBackendInteractiveAuthorityPrivate *priv;\n  gchar *caller_str;\n  gchar *subject_str;\n  PolkitIdentity *user_of_caller;\n  PolkitIdentity *user_of_subject;\n  gboolean user_of_subject_matches;\n  gchar *user_of_caller_str;\n  gchar *user_of_subject_str;\n  PolkitAuthorizationResult *result;\n  PolkitImplicitAuthorization implicit_authorization;\n  GError *error;\n  GSimpleAsyncResult *simple;\n  gboolean has_details;\n  gchar **detail_keys;\n\n  interactive_authority = POLKIT_BACKEND_INTERACTIVE_AUTHORITY (authority);\n  priv = POLKIT_BACKEND_INTERACTIVE_AUTHORITY_GET_PRIVATE (interactive_authority);\n\n  error = NULL;\n  caller_str = NULL;\n  subject_str = NULL;\n  user_of_caller = NULL;\n  user_of_subject = NULL;\n  user_of_caller_str = NULL;\n  user_of_subject_str = NULL;\n  result = NULL;\n\n  simple = g_simple_async_result_new (G_OBJECT (authority),\n                                      callback,\n                                      user_data,\n                                      polkit_backend_interactive_authority_check_authorization);\n\n  /* handle being called from ourselves */\n  if (caller == NULL)\n    {\n      /* TODO: this is kind of a hack */\n      GDBusConnection *system_bus;\n      system_bus = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, NULL);\n      caller = polkit_system_bus_name_new (g_dbus_connection_get_unique_name (system_bus));\n      g_object_unref (system_bus);\n    }\n\n  caller_str = polkit_subject_to_string (caller);\n  subject_str = polkit_subject_to_string (subject);\n\n  g_debug (\"%s is inquiring whether %s is authorized for %s\",\n           caller_str,\n           subject_str,\n           action_id);\n\n  user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,\n                                                                        caller, NULL,\n                                                                        &error);\n  if (error != NULL)\n    {\n      g_simple_async_result_set_from_error (simple, error);\n      g_simple_async_result_complete (simple);\n      g_object_unref (simple);\n      g_error_free (error);\n      goto out;\n    }\n\n  user_of_caller_str = polkit_identity_to_string (user_of_caller);\n  g_debug (\" user of caller is %s\", user_of_caller_str);\n\n  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,\n                                                                         subject, &user_of_subject_matches,\n                                                                         &error);\n  if (error != NULL)\n    {\n      g_simple_async_result_set_from_error (simple, error);\n      g_simple_async_result_complete (simple);\n      g_object_unref (simple);\n      g_error_free (error);\n      goto out;\n    }\n\n  user_of_subject_str = polkit_identity_to_string (user_of_subject);\n  g_debug (\" user of subject is %s\", user_of_subject_str);\n\n  has_details = FALSE;\n  if (details != NULL)\n    {\n      detail_keys = polkit_details_get_keys (details);\n      if (detail_keys != NULL)\n        {\n          if (g_strv_length (detail_keys) > 0)\n            has_details = TRUE;\n          g_strfreev (detail_keys);\n        }\n    }\n\n  /* Not anyone is allowed to check that process XYZ is allowed to do ABC.\n   * We only allow this if, and only if,\n   *\n   *  - processes may check for another process owned by the *same* user but not\n   *    if details are passed (otherwise you'd be able to spoof the dialog);\n   *    the caller supplies the user_of_subject value, so we additionally\n   *    require it to match at least at one point in time (via\n   *    user_of_subject_matches).\n   *\n   *  - processes running as uid 0 may check anything and pass any details\n   *\n   *  - if the action_id has the \"org.freedesktop.policykit.owner\" annotation\n   *    then any uid referenced by that annotation is also allowed to check\n   *    to check anything and pass any details\n   */\n  if (!user_of_subject_matches\n      || !polkit_identity_equal (user_of_caller, user_of_subject)\n      || has_details)\n    {\n      if (!may_identity_check_authorization (interactive_authority, action_id, user_of_caller))\n        {\n          if (has_details)\n            {\n              g_simple_async_result_set_error (simple,\n                                               POLKIT_ERROR,\n                                               POLKIT_ERROR_NOT_AUTHORIZED,\n                                               \"Only trusted callers (e.g. uid 0 or an action owner) can use CheckAuthorization() and \"\n                                               \"pass details\");\n            }\n          else\n            {\n              g_simple_async_result_set_error (simple,\n                                               POLKIT_ERROR,\n                                               POLKIT_ERROR_NOT_AUTHORIZED,\n                                               \"Only trusted callers (e.g. uid 0 or an action owner) can use CheckAuthorization() for \"\n                                               \"subjects belonging to other identities\");\n            }\n          g_simple_async_result_complete (simple);\n          g_object_unref (simple);\n          goto out;\n        }\n    }\n\n  implicit_authorization = POLKIT_IMPLICIT_AUTHORIZATION_NOT_AUTHORIZED;\n  result = check_authorization_sync (authority,\n                                     caller,\n                                     subject,\n                                     action_id,\n                                     details,\n                                     flags,\n                                     &implicit_authorization,\n                                     FALSE, /* checking_imply */\n                                     &error);\n  if (error != NULL)\n    {\n      g_simple_async_result_set_from_error (simple, error);\n      g_simple_async_result_complete (simple);\n      g_object_unref (simple);\n      g_error_free (error);\n      goto out;\n    }\n\n  /* Caller is up for a challenge! With light sabers! Use an authentication agent if one exists... */\n  if (polkit_authorization_result_get_is_challenge (result) &&\n      (flags & POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION))\n    {\n      AuthenticationAgent *agent;\n\n      agent = get_authentication_agent_for_subject (interactive_authority, subject);\n      if (agent != NULL)\n        {\n          g_object_unref (result);\n          result = NULL;\n\n          g_debug (\" using authentication agent for challenge\");\n\n          authentication_agent_initiate_challenge (agent,\n                                                   subject,\n                                                   user_of_subject,\n                                                   interactive_authority,\n                                                   action_id,\n                                                   details,\n                                                   caller,\n                                                   implicit_authorization,\n                                                   cancellable,\n                                                   check_authorization_challenge_cb,\n                                                   simple);\n\n          /* keep going */\n          goto out;\n        }\n    }\n\n  /* log_result (interactive_authority, action_id, subject, caller, result); */\n\n  /* Otherwise just return the result */\n  g_simple_async_result_set_op_res_gpointer (simple,\n                                             g_object_ref (result),\n                                             g_object_unref);\n  g_simple_async_result_complete (simple);\n  g_object_unref (simple);\n\n out:\n\n  if (user_of_caller != NULL)\n    g_object_unref (user_of_caller);\n\n  if (user_of_subject != NULL)\n    g_object_unref (user_of_subject);\n\n  g_free (caller_str);\n  g_free (subject_str);\n  g_free (user_of_caller_str);\n  g_free (user_of_subject_str);\n\n  if (result != NULL)\n    g_object_unref (result);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,6 +15,7 @@\n   gchar *subject_str;\n   PolkitIdentity *user_of_caller;\n   PolkitIdentity *user_of_subject;\n+  gboolean user_of_subject_matches;\n   gchar *user_of_caller_str;\n   gchar *user_of_subject_str;\n   PolkitAuthorizationResult *result;\n@@ -60,7 +61,7 @@\n            action_id);\n \n   user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,\n-                                                                        caller,\n+                                                                        caller, NULL,\n                                                                         &error);\n   if (error != NULL)\n     {\n@@ -75,7 +76,7 @@\n   g_debug (\" user of caller is %s\", user_of_caller_str);\n \n   user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,\n-                                                                         subject,\n+                                                                         subject, &user_of_subject_matches,\n                                                                          &error);\n   if (error != NULL)\n     {\n@@ -105,7 +106,10 @@\n    * We only allow this if, and only if,\n    *\n    *  - processes may check for another process owned by the *same* user but not\n-   *    if details are passed (otherwise you'd be able to spoof the dialog)\n+   *    if details are passed (otherwise you'd be able to spoof the dialog);\n+   *    the caller supplies the user_of_subject value, so we additionally\n+   *    require it to match at least at one point in time (via\n+   *    user_of_subject_matches).\n    *\n    *  - processes running as uid 0 may check anything and pass any details\n    *\n@@ -113,7 +117,9 @@\n    *    then any uid referenced by that annotation is also allowed to check\n    *    to check anything and pass any details\n    */\n-  if (!polkit_identity_equal (user_of_caller, user_of_subject) || has_details)\n+  if (!user_of_subject_matches\n+      || !polkit_identity_equal (user_of_caller, user_of_subject)\n+      || has_details)\n     {\n       if (!may_identity_check_authorization (interactive_authority, action_id, user_of_caller))\n         {",
        "diff_line_info": {
            "deleted_lines": [
                "                                                                        caller,",
                "                                                                         subject,",
                "   *    if details are passed (otherwise you'd be able to spoof the dialog)",
                "  if (!polkit_identity_equal (user_of_caller, user_of_subject) || has_details)"
            ],
            "added_lines": [
                "  gboolean user_of_subject_matches;",
                "                                                                        caller, NULL,",
                "                                                                         subject, &user_of_subject_matches,",
                "   *    if details are passed (otherwise you'd be able to spoof the dialog);",
                "   *    the caller supplies the user_of_subject value, so we additionally",
                "   *    require it to match at least at one point in time (via",
                "   *    user_of_subject_matches).",
                "  if (!user_of_subject_matches",
                "      || !polkit_identity_equal (user_of_caller, user_of_subject)",
                "      || has_details)"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-1116",
        "func_name": "polkit/polkit_backend_interactive_authority_register_authentication_agent",
        "description": "A flaw was found in polkit before version 0.116. The implementation of the polkit_backend_interactive_authority_check_authorization function in polkitd allows to test for authentication and trigger authentication of unrelated processes owned by other users. This may result in a local DoS and information disclosure.",
        "git_url": "https://cgit.freedesktop.org/polkit/commit/?id=bc7ffad5364",
        "commit_title": "As part of CVE-2013-4288, the D-Bus clients were allowed (and",
        "commit_text": "encouraged) to submit the UID of the subject of authorization checks to avoid races against UID changes (notably using executables set-UID to root).  However, that also allowed any client to submit an arbitrary UID, and that could be used to bypass \"can only ask about / affect the same UID\" checks in CheckAuthorization / RegisterAuthenticationAgent / UnregisterAuthenticationAgent.  This allowed an attacker:  - With CheckAuthorization, to cause the registered authentication   agent in victim's session to pop up a dialog, or to determine whether   the victim currently has a temporary authorization to perform an   operation.    (In principle, the attacker can also determine whether JavaScript   rules allow the victim process to perform an operation; however,   usually rules base their decisions on information determined from   the supplied UID, so the attacker usually won't learn anything new.)  - With RegisterAuthenticationAgent, to prevent the victim's   authentication agent to work (for a specific victim process),   or to learn about which operations requiring authorization   the victim is attempting.  To fix this, expose internal _polkit_unix_process_get_owner() / obsolete polkit_unix_process_get_owner() as a private polkit_unix_process_get_racy_uid__() (being more explicit about the dangers on relying on it), and use it in polkit_backend_session_monitor_get_user_for_subject() to return a boolean indicating whether the subject UID may be caller-chosen.  Then, in the permission checks that require the subject to be equal to the caller, fail on caller-chosen UIDs (and continue through the pre-existing code paths which allow root, or root-designated server processes, to ask about arbitrary subjects.)  ",
        "func_before": "static gboolean\npolkit_backend_interactive_authority_register_authentication_agent (PolkitBackendAuthority   *authority,\n                                                                    PolkitSubject            *caller,\n                                                                    PolkitSubject            *subject,\n                                                                    const gchar              *locale,\n                                                                    const gchar              *object_path,\n                                                                    GVariant                 *options,\n                                                                    GError                  **error)\n{\n  PolkitBackendInteractiveAuthority *interactive_authority;\n  PolkitBackendInteractiveAuthorityPrivate *priv;\n  PolkitSubject *session_for_caller;\n  PolkitIdentity *user_of_caller;\n  PolkitIdentity *user_of_subject;\n  AuthenticationAgent *agent;\n  gboolean ret;\n  gchar *caller_cmdline;\n  gchar *subject_as_string;\n\n  ret = FALSE;\n\n  session_for_caller = NULL;\n  user_of_caller = NULL;\n  user_of_subject = NULL;\n  subject_as_string = NULL;\n  caller_cmdline = NULL;\n  agent = NULL;\n\n  interactive_authority = POLKIT_BACKEND_INTERACTIVE_AUTHORITY (authority);\n  priv = POLKIT_BACKEND_INTERACTIVE_AUTHORITY_GET_PRIVATE (interactive_authority);\n\n  if (POLKIT_IS_UNIX_SESSION (subject))\n    {\n      session_for_caller = polkit_backend_session_monitor_get_session_for_subject (priv->session_monitor,\n                                                                                   caller,\n                                                                                   NULL);\n      if (session_for_caller == NULL)\n        {\n          g_set_error (error,\n                       POLKIT_ERROR,\n                       POLKIT_ERROR_FAILED,\n                       \"Cannot determine session the caller is in\");\n          goto out;\n        }\n      if (!polkit_subject_equal (session_for_caller, subject))\n        {\n          g_set_error (error,\n                       POLKIT_ERROR,\n                       POLKIT_ERROR_FAILED,\n                       \"Passed session and the session the caller is in differs. They must be equal for now.\");\n          goto out;\n        }\n    }\n  else if (POLKIT_IS_UNIX_PROCESS (subject))\n    {\n      /* explicitly OK */\n    }\n  else\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"Only unix-process and unix-session subjects can be used for authentication agents.\");\n      goto out;\n    }\n\n  user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, caller, NULL);\n  if (user_of_caller == NULL)\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"Cannot determine user of caller\");\n      goto out;\n    }\n  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, subject, NULL);\n  if (user_of_subject == NULL)\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"Cannot determine user of subject\");\n      goto out;\n    }\n  if (!polkit_identity_equal (user_of_caller, user_of_subject))\n    {\n      if (identity_is_root_user (user_of_caller))\n        {\n          /* explicitly allow uid 0 to register for other users */\n        }\n      else\n        {\n          g_set_error (error,\n                       POLKIT_ERROR,\n                       POLKIT_ERROR_FAILED,\n                       \"User of caller and user of subject differs.\");\n          goto out;\n        }\n    }\n\n  agent = g_hash_table_lookup (priv->hash_scope_to_authentication_agent, subject);\n  if (agent != NULL)\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"An authentication agent already exists for the given subject\");\n      goto out;\n    }\n\n  priv->agent_serial++;\n  agent = authentication_agent_new (priv->agent_serial,\n                                    subject,\n                                    user_of_caller,\n                                    polkit_system_bus_name_get_name (POLKIT_SYSTEM_BUS_NAME (caller)),\n                                    locale,\n                                    object_path,\n                                    options,\n                                    error);\n  if (!agent)\n    goto out;\n\n  g_hash_table_insert (priv->hash_scope_to_authentication_agent,\n                       g_object_ref (subject),\n                       agent);\n\n  caller_cmdline = _polkit_subject_get_cmdline (caller);\n  if (caller_cmdline == NULL)\n    caller_cmdline = g_strdup (\"<unknown>\");\n\n  subject_as_string = polkit_subject_to_string (subject);\n\n  g_debug (\"Added authentication agent for %s at name %s [%s], object path %s, locale %s\",\n           subject_as_string,\n           polkit_system_bus_name_get_name (POLKIT_SYSTEM_BUS_NAME (caller)),\n           caller_cmdline,\n           object_path,\n           locale);\n\n  polkit_backend_authority_log (POLKIT_BACKEND_AUTHORITY (authority),\n                                \"Registered Authentication Agent for %s \"\n                                \"(system bus name %s [%s], object path %s, locale %s)\",\n                                subject_as_string,\n                                polkit_system_bus_name_get_name (POLKIT_SYSTEM_BUS_NAME (caller)),\n                                caller_cmdline,\n                                object_path,\n                                locale);\n\n  g_signal_emit_by_name (authority, \"changed\");\n\n  ret = TRUE;\n\n out:\n  g_free (caller_cmdline);\n  g_free (subject_as_string);\n  if (user_of_caller != NULL)\n    g_object_unref (user_of_caller);\n  if (user_of_subject != NULL)\n    g_object_unref (user_of_subject);\n  if (session_for_caller != NULL)\n    g_object_unref (session_for_caller);\n\n  return ret;\n}",
        "func": "static gboolean\npolkit_backend_interactive_authority_register_authentication_agent (PolkitBackendAuthority   *authority,\n                                                                    PolkitSubject            *caller,\n                                                                    PolkitSubject            *subject,\n                                                                    const gchar              *locale,\n                                                                    const gchar              *object_path,\n                                                                    GVariant                 *options,\n                                                                    GError                  **error)\n{\n  PolkitBackendInteractiveAuthority *interactive_authority;\n  PolkitBackendInteractiveAuthorityPrivate *priv;\n  PolkitSubject *session_for_caller;\n  PolkitIdentity *user_of_caller;\n  PolkitIdentity *user_of_subject;\n  gboolean user_of_subject_matches;\n  AuthenticationAgent *agent;\n  gboolean ret;\n  gchar *caller_cmdline;\n  gchar *subject_as_string;\n\n  ret = FALSE;\n\n  session_for_caller = NULL;\n  user_of_caller = NULL;\n  user_of_subject = NULL;\n  subject_as_string = NULL;\n  caller_cmdline = NULL;\n  agent = NULL;\n\n  interactive_authority = POLKIT_BACKEND_INTERACTIVE_AUTHORITY (authority);\n  priv = POLKIT_BACKEND_INTERACTIVE_AUTHORITY_GET_PRIVATE (interactive_authority);\n\n  if (POLKIT_IS_UNIX_SESSION (subject))\n    {\n      session_for_caller = polkit_backend_session_monitor_get_session_for_subject (priv->session_monitor,\n                                                                                   caller,\n                                                                                   NULL);\n      if (session_for_caller == NULL)\n        {\n          g_set_error (error,\n                       POLKIT_ERROR,\n                       POLKIT_ERROR_FAILED,\n                       \"Cannot determine session the caller is in\");\n          goto out;\n        }\n      if (!polkit_subject_equal (session_for_caller, subject))\n        {\n          g_set_error (error,\n                       POLKIT_ERROR,\n                       POLKIT_ERROR_FAILED,\n                       \"Passed session and the session the caller is in differs. They must be equal for now.\");\n          goto out;\n        }\n    }\n  else if (POLKIT_IS_UNIX_PROCESS (subject))\n    {\n      /* explicitly OK */\n    }\n  else\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"Only unix-process and unix-session subjects can be used for authentication agents.\");\n      goto out;\n    }\n\n  user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, caller, NULL, NULL);\n  if (user_of_caller == NULL)\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"Cannot determine user of caller\");\n      goto out;\n    }\n  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, subject, &user_of_subject_matches, NULL);\n  if (user_of_subject == NULL)\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"Cannot determine user of subject\");\n      goto out;\n    }\n  if (!user_of_subject_matches\n      || !polkit_identity_equal (user_of_caller, user_of_subject))\n    {\n      if (identity_is_root_user (user_of_caller))\n        {\n          /* explicitly allow uid 0 to register for other users */\n        }\n      else\n        {\n          g_set_error (error,\n                       POLKIT_ERROR,\n                       POLKIT_ERROR_FAILED,\n                       \"User of caller and user of subject differs.\");\n          goto out;\n        }\n    }\n\n  agent = g_hash_table_lookup (priv->hash_scope_to_authentication_agent, subject);\n  if (agent != NULL)\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"An authentication agent already exists for the given subject\");\n      goto out;\n    }\n\n  priv->agent_serial++;\n  agent = authentication_agent_new (priv->agent_serial,\n                                    subject,\n                                    user_of_caller,\n                                    polkit_system_bus_name_get_name (POLKIT_SYSTEM_BUS_NAME (caller)),\n                                    locale,\n                                    object_path,\n                                    options,\n                                    error);\n  if (!agent)\n    goto out;\n\n  g_hash_table_insert (priv->hash_scope_to_authentication_agent,\n                       g_object_ref (subject),\n                       agent);\n\n  caller_cmdline = _polkit_subject_get_cmdline (caller);\n  if (caller_cmdline == NULL)\n    caller_cmdline = g_strdup (\"<unknown>\");\n\n  subject_as_string = polkit_subject_to_string (subject);\n\n  g_debug (\"Added authentication agent for %s at name %s [%s], object path %s, locale %s\",\n           subject_as_string,\n           polkit_system_bus_name_get_name (POLKIT_SYSTEM_BUS_NAME (caller)),\n           caller_cmdline,\n           object_path,\n           locale);\n\n  polkit_backend_authority_log (POLKIT_BACKEND_AUTHORITY (authority),\n                                \"Registered Authentication Agent for %s \"\n                                \"(system bus name %s [%s], object path %s, locale %s)\",\n                                subject_as_string,\n                                polkit_system_bus_name_get_name (POLKIT_SYSTEM_BUS_NAME (caller)),\n                                caller_cmdline,\n                                object_path,\n                                locale);\n\n  g_signal_emit_by_name (authority, \"changed\");\n\n  ret = TRUE;\n\n out:\n  g_free (caller_cmdline);\n  g_free (subject_as_string);\n  if (user_of_caller != NULL)\n    g_object_unref (user_of_caller);\n  if (user_of_subject != NULL)\n    g_object_unref (user_of_subject);\n  if (session_for_caller != NULL)\n    g_object_unref (session_for_caller);\n\n  return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,6 +12,7 @@\n   PolkitSubject *session_for_caller;\n   PolkitIdentity *user_of_caller;\n   PolkitIdentity *user_of_subject;\n+  gboolean user_of_subject_matches;\n   AuthenticationAgent *agent;\n   gboolean ret;\n   gchar *caller_cmdline;\n@@ -64,7 +65,7 @@\n       goto out;\n     }\n \n-  user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, caller, NULL);\n+  user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, caller, NULL, NULL);\n   if (user_of_caller == NULL)\n     {\n       g_set_error (error,\n@@ -73,7 +74,7 @@\n                    \"Cannot determine user of caller\");\n       goto out;\n     }\n-  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, subject, NULL);\n+  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, subject, &user_of_subject_matches, NULL);\n   if (user_of_subject == NULL)\n     {\n       g_set_error (error,\n@@ -82,7 +83,8 @@\n                    \"Cannot determine user of subject\");\n       goto out;\n     }\n-  if (!polkit_identity_equal (user_of_caller, user_of_subject))\n+  if (!user_of_subject_matches\n+      || !polkit_identity_equal (user_of_caller, user_of_subject))\n     {\n       if (identity_is_root_user (user_of_caller))\n         {",
        "diff_line_info": {
            "deleted_lines": [
                "  user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, caller, NULL);",
                "  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, subject, NULL);",
                "  if (!polkit_identity_equal (user_of_caller, user_of_subject))"
            ],
            "added_lines": [
                "  gboolean user_of_subject_matches;",
                "  user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, caller, NULL, NULL);",
                "  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, subject, &user_of_subject_matches, NULL);",
                "  if (!user_of_subject_matches",
                "      || !polkit_identity_equal (user_of_caller, user_of_subject))"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-1116",
        "func_name": "polkit/check_authorization_sync",
        "description": "A flaw was found in polkit before version 0.116. The implementation of the polkit_backend_interactive_authority_check_authorization function in polkitd allows to test for authentication and trigger authentication of unrelated processes owned by other users. This may result in a local DoS and information disclosure.",
        "git_url": "https://cgit.freedesktop.org/polkit/commit/?id=bc7ffad5364",
        "commit_title": "As part of CVE-2013-4288, the D-Bus clients were allowed (and",
        "commit_text": "encouraged) to submit the UID of the subject of authorization checks to avoid races against UID changes (notably using executables set-UID to root).  However, that also allowed any client to submit an arbitrary UID, and that could be used to bypass \"can only ask about / affect the same UID\" checks in CheckAuthorization / RegisterAuthenticationAgent / UnregisterAuthenticationAgent.  This allowed an attacker:  - With CheckAuthorization, to cause the registered authentication   agent in victim's session to pop up a dialog, or to determine whether   the victim currently has a temporary authorization to perform an   operation.    (In principle, the attacker can also determine whether JavaScript   rules allow the victim process to perform an operation; however,   usually rules base their decisions on information determined from   the supplied UID, so the attacker usually won't learn anything new.)  - With RegisterAuthenticationAgent, to prevent the victim's   authentication agent to work (for a specific victim process),   or to learn about which operations requiring authorization   the victim is attempting.  To fix this, expose internal _polkit_unix_process_get_owner() / obsolete polkit_unix_process_get_owner() as a private polkit_unix_process_get_racy_uid__() (being more explicit about the dangers on relying on it), and use it in polkit_backend_session_monitor_get_user_for_subject() to return a boolean indicating whether the subject UID may be caller-chosen.  Then, in the permission checks that require the subject to be equal to the caller, fail on caller-chosen UIDs (and continue through the pre-existing code paths which allow root, or root-designated server processes, to ask about arbitrary subjects.)  ",
        "func_before": "static PolkitAuthorizationResult *\ncheck_authorization_sync (PolkitBackendAuthority         *authority,\n                          PolkitSubject                  *caller,\n                          PolkitSubject                  *subject,\n                          const gchar                    *action_id,\n                          PolkitDetails                  *details,\n                          PolkitCheckAuthorizationFlags   flags,\n                          PolkitImplicitAuthorization    *out_implicit_authorization,\n                          gboolean                        checking_imply,\n                          GError                        **error)\n{\n  PolkitBackendInteractiveAuthority *interactive_authority;\n  PolkitBackendInteractiveAuthorityPrivate *priv;\n  PolkitAuthorizationResult *result;\n  PolkitIdentity *user_of_subject;\n  PolkitSubject *session_for_subject;\n  gchar *subject_str;\n  GList *groups_of_user;\n  PolkitActionDescription *action_desc;\n  gboolean session_is_local;\n  gboolean session_is_active;\n  PolkitImplicitAuthorization implicit_authorization;\n  const gchar *tmp_authz_id;\n  GList *actions;\n  GList *l;\n\n  interactive_authority = POLKIT_BACKEND_INTERACTIVE_AUTHORITY (authority);\n  priv = POLKIT_BACKEND_INTERACTIVE_AUTHORITY_GET_PRIVATE (interactive_authority);\n\n  result = NULL;\n\n  actions = NULL;\n  user_of_subject = NULL;\n  groups_of_user = NULL;\n  subject_str = NULL;\n  session_for_subject = NULL;\n\n  session_is_local = FALSE;\n  session_is_active = FALSE;\n\n  subject_str = polkit_subject_to_string (subject);\n\n  g_debug (\"checking whether %s is authorized for %s\",\n           subject_str,\n           action_id);\n\n  /* get the action description */\n  action_desc = polkit_backend_action_pool_get_action (priv->action_pool,\n                                                       action_id,\n                                                       NULL);\n\n  if (action_desc == NULL)\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"Action %s is not registered\",\n                   action_id);\n      goto out;\n    }\n\n  /* every subject has a user */\n  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,\n                                                                         subject,\n                                                                         error);\n  if (user_of_subject == NULL)\n      goto out;\n\n  /* special case: uid 0, root, is _always_ authorized for anything */\n  if (identity_is_root_user (user_of_subject))\n    {\n      result = polkit_authorization_result_new (TRUE, FALSE, NULL);\n      goto out;\n    }\n\n  /* a subject *may* be in a session */\n  session_for_subject = polkit_backend_session_monitor_get_session_for_subject (priv->session_monitor,\n                                                                                subject,\n                                                                                NULL);\n  g_debug (\"  %p\", session_for_subject);\n  if (session_for_subject != NULL)\n    {\n      session_is_local = polkit_backend_session_monitor_is_session_local (priv->session_monitor, session_for_subject);\n      session_is_active = polkit_backend_session_monitor_is_session_active (priv->session_monitor, session_for_subject);\n\n      g_debug (\" subject is in session %s (local=%d active=%d)\",\n               polkit_unix_session_get_session_id (POLKIT_UNIX_SESSION (session_for_subject)),\n               session_is_local,\n               session_is_active);\n    }\n\n  /* find the implicit authorization to use; it depends on is_local and is_active */\n  if (session_is_local)\n    {\n      if (session_is_active)\n        implicit_authorization = polkit_action_description_get_implicit_active (action_desc);\n      else\n        implicit_authorization = polkit_action_description_get_implicit_inactive (action_desc);\n    }\n  else\n    {\n      implicit_authorization = polkit_action_description_get_implicit_any (action_desc);\n    }\n\n  /* allow subclasses to rewrite implicit_authorization */\n  implicit_authorization = polkit_backend_interactive_authority_check_authorization_sync (interactive_authority,\n                                                                                          caller,\n                                                                                          subject,\n                                                                                          user_of_subject,\n                                                                                          session_is_local,\n                                                                                          session_is_active,\n                                                                                          action_id,\n                                                                                          details,\n                                                                                          implicit_authorization);\n  /* first see if there's an implicit authorization for subject available */\n  if (implicit_authorization == POLKIT_IMPLICIT_AUTHORIZATION_AUTHORIZED)\n    {\n      g_debug (\" is authorized (has implicit authorization local=%d active=%d)\",\n               session_is_local,\n               session_is_active);\n      result = polkit_authorization_result_new (TRUE, FALSE, details);\n      goto out;\n    }\n\n  /* then see if there's a temporary authorization for the subject */\n  if (temporary_authorization_store_has_authorization (priv->temporary_authorization_store,\n                                                       subject,\n                                                       action_id,\n                                                       &tmp_authz_id))\n    {\n\n      g_debug (\" is authorized (has temporary authorization)\");\n      polkit_details_insert (details, \"polkit.temporary_authorization_id\", tmp_authz_id);\n      result = polkit_authorization_result_new (TRUE, FALSE, details);\n      goto out;\n    }\n\n  /* then see if implied by another action that the subject is authorized for\n   * (but only one level deep to avoid infinite recursion)\n   *\n   * TODO: if this is slow, we can maintain a hash table for looking up what\n   * actions implies a given action\n   */\n  if (!checking_imply)\n    {\n      actions = polkit_backend_action_pool_get_all_actions (priv->action_pool, NULL);\n      for (l = actions; l != NULL; l = l->next)\n        {\n          PolkitActionDescription *imply_ad = POLKIT_ACTION_DESCRIPTION (l->data);\n          const gchar *imply;\n          imply = polkit_action_description_get_annotation (imply_ad, \"org.freedesktop.policykit.imply\");\n          if (imply != NULL)\n            {\n              gchar **tokens;\n              guint n;\n              tokens = g_strsplit (imply, \" \", 0);\n              for (n = 0; tokens[n] != NULL; n++)\n                {\n                  if (g_strcmp0 (tokens[n], action_id) == 0)\n                    {\n                      PolkitAuthorizationResult *implied_result = NULL;\n                      PolkitImplicitAuthorization implied_implicit_authorization;\n                      GError *implied_error = NULL;\n                      const gchar *imply_action_id;\n\n                      imply_action_id = polkit_action_description_get_action_id (imply_ad);\n\n                      /* g_debug (\"%s is implied by %s, checking\", action_id, imply_action_id); */\n                      implied_result = check_authorization_sync (authority, caller, subject,\n                                                                 imply_action_id,\n                                                                 details, flags,\n                                                                 &implied_implicit_authorization, TRUE,\n                                                                 &implied_error);\n                      if (implied_result != NULL)\n                        {\n                          if (polkit_authorization_result_get_is_authorized (implied_result))\n                            {\n                              g_debug (\" is authorized (implied by %s)\", imply_action_id);\n                              result = implied_result;\n                              /* cleanup */\n                              g_strfreev (tokens);\n                              goto out;\n                            }\n                          g_object_unref (implied_result);\n                        }\n                      if (implied_error != NULL)\n                        g_error_free (implied_error);\n                    }\n                }\n              g_strfreev (tokens);\n            }\n        }\n    }\n\n  if (implicit_authorization != POLKIT_IMPLICIT_AUTHORIZATION_NOT_AUTHORIZED)\n    {\n      if (implicit_authorization == POLKIT_IMPLICIT_AUTHORIZATION_AUTHENTICATION_REQUIRED_RETAINED ||\n          implicit_authorization == POLKIT_IMPLICIT_AUTHORIZATION_ADMINISTRATOR_AUTHENTICATION_REQUIRED_RETAINED)\n        {\n          polkit_details_insert (details, \"polkit.retains_authorization_after_challenge\", \"1\");\n        }\n\n      result = polkit_authorization_result_new (FALSE, TRUE, details);\n\n      /* return implicit_authorization so the caller can use an authentication agent if applicable */\n      if (out_implicit_authorization != NULL)\n        *out_implicit_authorization = implicit_authorization;\n\n      g_debug (\" challenge (implicit_authorization = %s)\",\n               polkit_implicit_authorization_to_string (implicit_authorization));\n    }\n  else\n    {\n      result = polkit_authorization_result_new (FALSE, FALSE, details);\n      g_debug (\" not authorized\");\n    }\n out:\n  g_list_foreach (actions, (GFunc) g_object_unref, NULL);\n  g_list_free (actions);\n\n  g_free (subject_str);\n\n  g_list_foreach (groups_of_user, (GFunc) g_object_unref, NULL);\n  g_list_free (groups_of_user);\n\n  if (user_of_subject != NULL)\n    g_object_unref (user_of_subject);\n\n  if (session_for_subject != NULL)\n    g_object_unref (session_for_subject);\n\n  if (action_desc != NULL)\n    g_object_unref (action_desc);\n\n  g_debug (\" \");\n\n  return result;\n}",
        "func": "static PolkitAuthorizationResult *\ncheck_authorization_sync (PolkitBackendAuthority         *authority,\n                          PolkitSubject                  *caller,\n                          PolkitSubject                  *subject,\n                          const gchar                    *action_id,\n                          PolkitDetails                  *details,\n                          PolkitCheckAuthorizationFlags   flags,\n                          PolkitImplicitAuthorization    *out_implicit_authorization,\n                          gboolean                        checking_imply,\n                          GError                        **error)\n{\n  PolkitBackendInteractiveAuthority *interactive_authority;\n  PolkitBackendInteractiveAuthorityPrivate *priv;\n  PolkitAuthorizationResult *result;\n  PolkitIdentity *user_of_subject;\n  PolkitSubject *session_for_subject;\n  gchar *subject_str;\n  GList *groups_of_user;\n  PolkitActionDescription *action_desc;\n  gboolean session_is_local;\n  gboolean session_is_active;\n  PolkitImplicitAuthorization implicit_authorization;\n  const gchar *tmp_authz_id;\n  GList *actions;\n  GList *l;\n\n  interactive_authority = POLKIT_BACKEND_INTERACTIVE_AUTHORITY (authority);\n  priv = POLKIT_BACKEND_INTERACTIVE_AUTHORITY_GET_PRIVATE (interactive_authority);\n\n  result = NULL;\n\n  actions = NULL;\n  user_of_subject = NULL;\n  groups_of_user = NULL;\n  subject_str = NULL;\n  session_for_subject = NULL;\n\n  session_is_local = FALSE;\n  session_is_active = FALSE;\n\n  subject_str = polkit_subject_to_string (subject);\n\n  g_debug (\"checking whether %s is authorized for %s\",\n           subject_str,\n           action_id);\n\n  /* get the action description */\n  action_desc = polkit_backend_action_pool_get_action (priv->action_pool,\n                                                       action_id,\n                                                       NULL);\n\n  if (action_desc == NULL)\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"Action %s is not registered\",\n                   action_id);\n      goto out;\n    }\n\n  /* every subject has a user; this is supplied by the client, so we rely\n   * on the caller to validate its acceptability. */\n  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,\n                                                                         subject, NULL,\n                                                                         error);\n  if (user_of_subject == NULL)\n      goto out;\n\n  /* special case: uid 0, root, is _always_ authorized for anything */\n  if (identity_is_root_user (user_of_subject))\n    {\n      result = polkit_authorization_result_new (TRUE, FALSE, NULL);\n      goto out;\n    }\n\n  /* a subject *may* be in a session */\n  session_for_subject = polkit_backend_session_monitor_get_session_for_subject (priv->session_monitor,\n                                                                                subject,\n                                                                                NULL);\n  g_debug (\"  %p\", session_for_subject);\n  if (session_for_subject != NULL)\n    {\n      session_is_local = polkit_backend_session_monitor_is_session_local (priv->session_monitor, session_for_subject);\n      session_is_active = polkit_backend_session_monitor_is_session_active (priv->session_monitor, session_for_subject);\n\n      g_debug (\" subject is in session %s (local=%d active=%d)\",\n               polkit_unix_session_get_session_id (POLKIT_UNIX_SESSION (session_for_subject)),\n               session_is_local,\n               session_is_active);\n    }\n\n  /* find the implicit authorization to use; it depends on is_local and is_active */\n  if (session_is_local)\n    {\n      if (session_is_active)\n        implicit_authorization = polkit_action_description_get_implicit_active (action_desc);\n      else\n        implicit_authorization = polkit_action_description_get_implicit_inactive (action_desc);\n    }\n  else\n    {\n      implicit_authorization = polkit_action_description_get_implicit_any (action_desc);\n    }\n\n  /* allow subclasses to rewrite implicit_authorization */\n  implicit_authorization = polkit_backend_interactive_authority_check_authorization_sync (interactive_authority,\n                                                                                          caller,\n                                                                                          subject,\n                                                                                          user_of_subject,\n                                                                                          session_is_local,\n                                                                                          session_is_active,\n                                                                                          action_id,\n                                                                                          details,\n                                                                                          implicit_authorization);\n  /* first see if there's an implicit authorization for subject available */\n  if (implicit_authorization == POLKIT_IMPLICIT_AUTHORIZATION_AUTHORIZED)\n    {\n      g_debug (\" is authorized (has implicit authorization local=%d active=%d)\",\n               session_is_local,\n               session_is_active);\n      result = polkit_authorization_result_new (TRUE, FALSE, details);\n      goto out;\n    }\n\n  /* then see if there's a temporary authorization for the subject */\n  if (temporary_authorization_store_has_authorization (priv->temporary_authorization_store,\n                                                       subject,\n                                                       action_id,\n                                                       &tmp_authz_id))\n    {\n\n      g_debug (\" is authorized (has temporary authorization)\");\n      polkit_details_insert (details, \"polkit.temporary_authorization_id\", tmp_authz_id);\n      result = polkit_authorization_result_new (TRUE, FALSE, details);\n      goto out;\n    }\n\n  /* then see if implied by another action that the subject is authorized for\n   * (but only one level deep to avoid infinite recursion)\n   *\n   * TODO: if this is slow, we can maintain a hash table for looking up what\n   * actions implies a given action\n   */\n  if (!checking_imply)\n    {\n      actions = polkit_backend_action_pool_get_all_actions (priv->action_pool, NULL);\n      for (l = actions; l != NULL; l = l->next)\n        {\n          PolkitActionDescription *imply_ad = POLKIT_ACTION_DESCRIPTION (l->data);\n          const gchar *imply;\n          imply = polkit_action_description_get_annotation (imply_ad, \"org.freedesktop.policykit.imply\");\n          if (imply != NULL)\n            {\n              gchar **tokens;\n              guint n;\n              tokens = g_strsplit (imply, \" \", 0);\n              for (n = 0; tokens[n] != NULL; n++)\n                {\n                  if (g_strcmp0 (tokens[n], action_id) == 0)\n                    {\n                      PolkitAuthorizationResult *implied_result = NULL;\n                      PolkitImplicitAuthorization implied_implicit_authorization;\n                      GError *implied_error = NULL;\n                      const gchar *imply_action_id;\n\n                      imply_action_id = polkit_action_description_get_action_id (imply_ad);\n\n                      /* g_debug (\"%s is implied by %s, checking\", action_id, imply_action_id); */\n                      implied_result = check_authorization_sync (authority, caller, subject,\n                                                                 imply_action_id,\n                                                                 details, flags,\n                                                                 &implied_implicit_authorization, TRUE,\n                                                                 &implied_error);\n                      if (implied_result != NULL)\n                        {\n                          if (polkit_authorization_result_get_is_authorized (implied_result))\n                            {\n                              g_debug (\" is authorized (implied by %s)\", imply_action_id);\n                              result = implied_result;\n                              /* cleanup */\n                              g_strfreev (tokens);\n                              goto out;\n                            }\n                          g_object_unref (implied_result);\n                        }\n                      if (implied_error != NULL)\n                        g_error_free (implied_error);\n                    }\n                }\n              g_strfreev (tokens);\n            }\n        }\n    }\n\n  if (implicit_authorization != POLKIT_IMPLICIT_AUTHORIZATION_NOT_AUTHORIZED)\n    {\n      if (implicit_authorization == POLKIT_IMPLICIT_AUTHORIZATION_AUTHENTICATION_REQUIRED_RETAINED ||\n          implicit_authorization == POLKIT_IMPLICIT_AUTHORIZATION_ADMINISTRATOR_AUTHENTICATION_REQUIRED_RETAINED)\n        {\n          polkit_details_insert (details, \"polkit.retains_authorization_after_challenge\", \"1\");\n        }\n\n      result = polkit_authorization_result_new (FALSE, TRUE, details);\n\n      /* return implicit_authorization so the caller can use an authentication agent if applicable */\n      if (out_implicit_authorization != NULL)\n        *out_implicit_authorization = implicit_authorization;\n\n      g_debug (\" challenge (implicit_authorization = %s)\",\n               polkit_implicit_authorization_to_string (implicit_authorization));\n    }\n  else\n    {\n      result = polkit_authorization_result_new (FALSE, FALSE, details);\n      g_debug (\" not authorized\");\n    }\n out:\n  g_list_foreach (actions, (GFunc) g_object_unref, NULL);\n  g_list_free (actions);\n\n  g_free (subject_str);\n\n  g_list_foreach (groups_of_user, (GFunc) g_object_unref, NULL);\n  g_list_free (groups_of_user);\n\n  if (user_of_subject != NULL)\n    g_object_unref (user_of_subject);\n\n  if (session_for_subject != NULL)\n    g_object_unref (session_for_subject);\n\n  if (action_desc != NULL)\n    g_object_unref (action_desc);\n\n  g_debug (\" \");\n\n  return result;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -59,9 +59,10 @@\n       goto out;\n     }\n \n-  /* every subject has a user */\n+  /* every subject has a user; this is supplied by the client, so we rely\n+   * on the caller to validate its acceptability. */\n   user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,\n-                                                                         subject,\n+                                                                         subject, NULL,\n                                                                          error);\n   if (user_of_subject == NULL)\n       goto out;",
        "diff_line_info": {
            "deleted_lines": [
                "  /* every subject has a user */",
                "                                                                         subject,"
            ],
            "added_lines": [
                "  /* every subject has a user; this is supplied by the client, so we rely",
                "   * on the caller to validate its acceptability. */",
                "                                                                         subject, NULL,"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-1116",
        "func_name": "polkit/polkit_backend_interactive_authority_authentication_agent_response",
        "description": "A flaw was found in polkit before version 0.116. The implementation of the polkit_backend_interactive_authority_check_authorization function in polkitd allows to test for authentication and trigger authentication of unrelated processes owned by other users. This may result in a local DoS and information disclosure.",
        "git_url": "https://cgit.freedesktop.org/polkit/commit/?id=bc7ffad5364",
        "commit_title": "As part of CVE-2013-4288, the D-Bus clients were allowed (and",
        "commit_text": "encouraged) to submit the UID of the subject of authorization checks to avoid races against UID changes (notably using executables set-UID to root).  However, that also allowed any client to submit an arbitrary UID, and that could be used to bypass \"can only ask about / affect the same UID\" checks in CheckAuthorization / RegisterAuthenticationAgent / UnregisterAuthenticationAgent.  This allowed an attacker:  - With CheckAuthorization, to cause the registered authentication   agent in victim's session to pop up a dialog, or to determine whether   the victim currently has a temporary authorization to perform an   operation.    (In principle, the attacker can also determine whether JavaScript   rules allow the victim process to perform an operation; however,   usually rules base their decisions on information determined from   the supplied UID, so the attacker usually won't learn anything new.)  - With RegisterAuthenticationAgent, to prevent the victim's   authentication agent to work (for a specific victim process),   or to learn about which operations requiring authorization   the victim is attempting.  To fix this, expose internal _polkit_unix_process_get_owner() / obsolete polkit_unix_process_get_owner() as a private polkit_unix_process_get_racy_uid__() (being more explicit about the dangers on relying on it), and use it in polkit_backend_session_monitor_get_user_for_subject() to return a boolean indicating whether the subject UID may be caller-chosen.  Then, in the permission checks that require the subject to be equal to the caller, fail on caller-chosen UIDs (and continue through the pre-existing code paths which allow root, or root-designated server processes, to ask about arbitrary subjects.)  ",
        "func_before": "static gboolean\npolkit_backend_interactive_authority_authentication_agent_response (PolkitBackendAuthority   *authority,\n                                                              PolkitSubject            *caller,\n                                                              uid_t                     uid,\n                                                              const gchar              *cookie,\n                                                              PolkitIdentity           *identity,\n                                                              GError                  **error)\n{\n  PolkitBackendInteractiveAuthority *interactive_authority;\n  PolkitBackendInteractiveAuthorityPrivate *priv;\n  PolkitIdentity *user_of_caller;\n  gchar *identity_str;\n  AuthenticationSession *session;\n  GList *l;\n  gboolean ret;\n\n  interactive_authority = POLKIT_BACKEND_INTERACTIVE_AUTHORITY (authority);\n  priv = POLKIT_BACKEND_INTERACTIVE_AUTHORITY_GET_PRIVATE (interactive_authority);\n\n  ret = FALSE;\n  user_of_caller = NULL;\n\n  identity_str = polkit_identity_to_string (identity);\n\n  g_debug (\"In authentication_agent_response for cookie '%s' and identity %s\",\n           cookie,\n           identity_str);\n\n  user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,\n                                                                        caller,\n                                                                        error);\n  if (user_of_caller == NULL)\n    goto out;\n\n  /* only uid 0 is allowed to invoke this method */\n  if (!identity_is_root_user (user_of_caller))\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"Only uid 0 may invoke this method. This incident has been logged.\");\n      /* TODO: actually log this */\n      goto out;\n    }\n\n  /* find the authentication session */\n  session = get_authentication_session_for_uid_and_cookie (interactive_authority, uid, cookie);\n  if (session == NULL)\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"No session for cookie\");\n      goto out;\n    }\n\n  /* check that the authentication identity was one of the possibilities we allowed */\n  for (l = session->identities; l != NULL; l = l->next)\n    {\n      PolkitIdentity *i = POLKIT_IDENTITY (l->data);\n\n      if (polkit_identity_equal (i, identity))\n        break;\n    }\n\n  if (l == NULL)\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"The authenticated identity is wrong\");\n      goto out;\n    }\n\n  /* checks out, mark the session as authenticated */\n  session->is_authenticated = TRUE;\n  session->authenticated_identity = g_object_ref (identity);\n\n  ret = TRUE;\n\n out:\n  g_free (identity_str);\n\n  if (user_of_caller != NULL)\n    g_object_unref (user_of_caller);\n\n  return ret;\n}",
        "func": "static gboolean\npolkit_backend_interactive_authority_authentication_agent_response (PolkitBackendAuthority   *authority,\n                                                              PolkitSubject            *caller,\n                                                              uid_t                     uid,\n                                                              const gchar              *cookie,\n                                                              PolkitIdentity           *identity,\n                                                              GError                  **error)\n{\n  PolkitBackendInteractiveAuthority *interactive_authority;\n  PolkitBackendInteractiveAuthorityPrivate *priv;\n  PolkitIdentity *user_of_caller;\n  gchar *identity_str;\n  AuthenticationSession *session;\n  GList *l;\n  gboolean ret;\n\n  interactive_authority = POLKIT_BACKEND_INTERACTIVE_AUTHORITY (authority);\n  priv = POLKIT_BACKEND_INTERACTIVE_AUTHORITY_GET_PRIVATE (interactive_authority);\n\n  ret = FALSE;\n  user_of_caller = NULL;\n\n  identity_str = polkit_identity_to_string (identity);\n\n  g_debug (\"In authentication_agent_response for cookie '%s' and identity %s\",\n           cookie,\n           identity_str);\n\n  user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,\n                                                                        caller, NULL,\n                                                                        error);\n  if (user_of_caller == NULL)\n    goto out;\n\n  /* only uid 0 is allowed to invoke this method */\n  if (!identity_is_root_user (user_of_caller))\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"Only uid 0 may invoke this method. This incident has been logged.\");\n      /* TODO: actually log this */\n      goto out;\n    }\n\n  /* find the authentication session */\n  session = get_authentication_session_for_uid_and_cookie (interactive_authority, uid, cookie);\n  if (session == NULL)\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"No session for cookie\");\n      goto out;\n    }\n\n  /* check that the authentication identity was one of the possibilities we allowed */\n  for (l = session->identities; l != NULL; l = l->next)\n    {\n      PolkitIdentity *i = POLKIT_IDENTITY (l->data);\n\n      if (polkit_identity_equal (i, identity))\n        break;\n    }\n\n  if (l == NULL)\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"The authenticated identity is wrong\");\n      goto out;\n    }\n\n  /* checks out, mark the session as authenticated */\n  session->is_authenticated = TRUE;\n  session->authenticated_identity = g_object_ref (identity);\n\n  ret = TRUE;\n\n out:\n  g_free (identity_str);\n\n  if (user_of_caller != NULL)\n    g_object_unref (user_of_caller);\n\n  return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -27,7 +27,7 @@\n            identity_str);\n \n   user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor,\n-                                                                        caller,\n+                                                                        caller, NULL,\n                                                                         error);\n   if (user_of_caller == NULL)\n     goto out;",
        "diff_line_info": {
            "deleted_lines": [
                "                                                                        caller,"
            ],
            "added_lines": [
                "                                                                        caller, NULL,"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-1116",
        "func_name": "polkit/log_result",
        "description": "A flaw was found in polkit before version 0.116. The implementation of the polkit_backend_interactive_authority_check_authorization function in polkitd allows to test for authentication and trigger authentication of unrelated processes owned by other users. This may result in a local DoS and information disclosure.",
        "git_url": "https://cgit.freedesktop.org/polkit/commit/?id=bc7ffad5364",
        "commit_title": "As part of CVE-2013-4288, the D-Bus clients were allowed (and",
        "commit_text": "encouraged) to submit the UID of the subject of authorization checks to avoid races against UID changes (notably using executables set-UID to root).  However, that also allowed any client to submit an arbitrary UID, and that could be used to bypass \"can only ask about / affect the same UID\" checks in CheckAuthorization / RegisterAuthenticationAgent / UnregisterAuthenticationAgent.  This allowed an attacker:  - With CheckAuthorization, to cause the registered authentication   agent in victim's session to pop up a dialog, or to determine whether   the victim currently has a temporary authorization to perform an   operation.    (In principle, the attacker can also determine whether JavaScript   rules allow the victim process to perform an operation; however,   usually rules base their decisions on information determined from   the supplied UID, so the attacker usually won't learn anything new.)  - With RegisterAuthenticationAgent, to prevent the victim's   authentication agent to work (for a specific victim process),   or to learn about which operations requiring authorization   the victim is attempting.  To fix this, expose internal _polkit_unix_process_get_owner() / obsolete polkit_unix_process_get_owner() as a private polkit_unix_process_get_racy_uid__() (being more explicit about the dangers on relying on it), and use it in polkit_backend_session_monitor_get_user_for_subject() to return a boolean indicating whether the subject UID may be caller-chosen.  Then, in the permission checks that require the subject to be equal to the caller, fail on caller-chosen UIDs (and continue through the pre-existing code paths which allow root, or root-designated server processes, to ask about arbitrary subjects.)  ",
        "func_before": "G_GNUC_UNUSED static void\nlog_result (PolkitBackendInteractiveAuthority    *authority,\n            const gchar                          *action_id,\n            PolkitSubject                        *subject,\n            PolkitSubject                        *caller,\n            PolkitAuthorizationResult            *result)\n{\n  PolkitBackendInteractiveAuthorityPrivate *priv;\n  PolkitIdentity *user_of_subject;\n  const gchar *log_result_str;\n  gchar *subject_str;\n  gchar *user_of_subject_str;\n  gchar *caller_str;\n  gchar *subject_cmdline;\n  gchar *caller_cmdline;\n\n  priv = POLKIT_BACKEND_INTERACTIVE_AUTHORITY_GET_PRIVATE (authority);\n\n  log_result_str = \"DENYING\";\n  if (polkit_authorization_result_get_is_authorized (result))\n    log_result_str = \"ALLOWING\";\n\n  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, subject, NULL);\n\n  subject_str = polkit_subject_to_string (subject);\n\n  if (user_of_subject != NULL)\n    user_of_subject_str = polkit_identity_to_string (user_of_subject);\n  else\n    user_of_subject_str = g_strdup (\"<unknown>\");\n  caller_str = polkit_subject_to_string (caller);\n\n  subject_cmdline = _polkit_subject_get_cmdline (subject);\n  if (subject_cmdline == NULL)\n    subject_cmdline = g_strdup (\"<unknown>\");\n\n  caller_cmdline = _polkit_subject_get_cmdline (caller);\n  if (caller_cmdline == NULL)\n    caller_cmdline = g_strdup (\"<unknown>\");\n\n  polkit_backend_authority_log (POLKIT_BACKEND_AUTHORITY (authority),\n                                \"%s action %s for %s [%s] owned by %s (check requested by %s [%s])\",\n                                log_result_str,\n                                action_id,\n                                subject_str,\n                                subject_cmdline,\n                                user_of_subject_str,\n                                caller_str,\n                                caller_cmdline);\n\n  if (user_of_subject != NULL)\n    g_object_unref (user_of_subject);\n  g_free (subject_str);\n  g_free (user_of_subject_str);\n  g_free (caller_str);\n  g_free (subject_cmdline);\n  g_free (caller_cmdline);\n}",
        "func": "G_GNUC_UNUSED static void\nlog_result (PolkitBackendInteractiveAuthority    *authority,\n            const gchar                          *action_id,\n            PolkitSubject                        *subject,\n            PolkitSubject                        *caller,\n            PolkitAuthorizationResult            *result)\n{\n  PolkitBackendInteractiveAuthorityPrivate *priv;\n  PolkitIdentity *user_of_subject;\n  const gchar *log_result_str;\n  gchar *subject_str;\n  gchar *user_of_subject_str;\n  gchar *caller_str;\n  gchar *subject_cmdline;\n  gchar *caller_cmdline;\n\n  priv = POLKIT_BACKEND_INTERACTIVE_AUTHORITY_GET_PRIVATE (authority);\n\n  log_result_str = \"DENYING\";\n  if (polkit_authorization_result_get_is_authorized (result))\n    log_result_str = \"ALLOWING\";\n\n  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, subject, NULL, NULL);\n\n  subject_str = polkit_subject_to_string (subject);\n\n  if (user_of_subject != NULL)\n    user_of_subject_str = polkit_identity_to_string (user_of_subject);\n  else\n    user_of_subject_str = g_strdup (\"<unknown>\");\n  caller_str = polkit_subject_to_string (caller);\n\n  subject_cmdline = _polkit_subject_get_cmdline (subject);\n  if (subject_cmdline == NULL)\n    subject_cmdline = g_strdup (\"<unknown>\");\n\n  caller_cmdline = _polkit_subject_get_cmdline (caller);\n  if (caller_cmdline == NULL)\n    caller_cmdline = g_strdup (\"<unknown>\");\n\n  polkit_backend_authority_log (POLKIT_BACKEND_AUTHORITY (authority),\n                                \"%s action %s for %s [%s] owned by %s (check requested by %s [%s])\",\n                                log_result_str,\n                                action_id,\n                                subject_str,\n                                subject_cmdline,\n                                user_of_subject_str,\n                                caller_str,\n                                caller_cmdline);\n\n  if (user_of_subject != NULL)\n    g_object_unref (user_of_subject);\n  g_free (subject_str);\n  g_free (user_of_subject_str);\n  g_free (caller_str);\n  g_free (subject_cmdline);\n  g_free (caller_cmdline);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,7 +20,7 @@\n   if (polkit_authorization_result_get_is_authorized (result))\n     log_result_str = \"ALLOWING\";\n \n-  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, subject, NULL);\n+  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, subject, NULL, NULL);\n \n   subject_str = polkit_subject_to_string (subject);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, subject, NULL);"
            ],
            "added_lines": [
                "  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, subject, NULL, NULL);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-1116",
        "func_name": "polkit/polkit_backend_interactive_authority_unregister_authentication_agent",
        "description": "A flaw was found in polkit before version 0.116. The implementation of the polkit_backend_interactive_authority_check_authorization function in polkitd allows to test for authentication and trigger authentication of unrelated processes owned by other users. This may result in a local DoS and information disclosure.",
        "git_url": "https://cgit.freedesktop.org/polkit/commit/?id=bc7ffad5364",
        "commit_title": "As part of CVE-2013-4288, the D-Bus clients were allowed (and",
        "commit_text": "encouraged) to submit the UID of the subject of authorization checks to avoid races against UID changes (notably using executables set-UID to root).  However, that also allowed any client to submit an arbitrary UID, and that could be used to bypass \"can only ask about / affect the same UID\" checks in CheckAuthorization / RegisterAuthenticationAgent / UnregisterAuthenticationAgent.  This allowed an attacker:  - With CheckAuthorization, to cause the registered authentication   agent in victim's session to pop up a dialog, or to determine whether   the victim currently has a temporary authorization to perform an   operation.    (In principle, the attacker can also determine whether JavaScript   rules allow the victim process to perform an operation; however,   usually rules base their decisions on information determined from   the supplied UID, so the attacker usually won't learn anything new.)  - With RegisterAuthenticationAgent, to prevent the victim's   authentication agent to work (for a specific victim process),   or to learn about which operations requiring authorization   the victim is attempting.  To fix this, expose internal _polkit_unix_process_get_owner() / obsolete polkit_unix_process_get_owner() as a private polkit_unix_process_get_racy_uid__() (being more explicit about the dangers on relying on it), and use it in polkit_backend_session_monitor_get_user_for_subject() to return a boolean indicating whether the subject UID may be caller-chosen.  Then, in the permission checks that require the subject to be equal to the caller, fail on caller-chosen UIDs (and continue through the pre-existing code paths which allow root, or root-designated server processes, to ask about arbitrary subjects.)  ",
        "func_before": "static gboolean\npolkit_backend_interactive_authority_unregister_authentication_agent (PolkitBackendAuthority   *authority,\n                                                                      PolkitSubject            *caller,\n                                                                      PolkitSubject            *subject,\n                                                                      const gchar              *object_path,\n                                                                      GError                  **error)\n{\n  PolkitBackendInteractiveAuthority *interactive_authority;\n  PolkitBackendInteractiveAuthorityPrivate *priv;\n  PolkitSubject *session_for_caller;\n  PolkitIdentity *user_of_caller;\n  PolkitIdentity *user_of_subject;\n  AuthenticationAgent *agent;\n  gboolean ret;\n  gchar *scope_str;\n\n  interactive_authority = POLKIT_BACKEND_INTERACTIVE_AUTHORITY (authority);\n  priv = POLKIT_BACKEND_INTERACTIVE_AUTHORITY_GET_PRIVATE (interactive_authority);\n\n  ret = FALSE;\n  session_for_caller = NULL;\n  user_of_caller = NULL;\n  user_of_subject = NULL;\n\n  if (POLKIT_IS_UNIX_SESSION (subject))\n    {\n      session_for_caller = polkit_backend_session_monitor_get_session_for_subject (priv->session_monitor,\n                                                                                   caller,\n                                                                                   NULL);\n      if (session_for_caller == NULL)\n        {\n          g_set_error (error,\n                       POLKIT_ERROR,\n                       POLKIT_ERROR_FAILED,\n                       \"Cannot determine session the caller is in\");\n          goto out;\n        }\n\n      if (!polkit_subject_equal (session_for_caller, subject))\n        {\n          g_set_error (error,\n                       POLKIT_ERROR,\n                       POLKIT_ERROR_FAILED,\n                       \"Passed session and the session the caller is in differs. They must be equal for now.\");\n          goto out;\n        }\n    }\n  else if (POLKIT_IS_UNIX_PROCESS (subject))\n    {\n      /* explicitly OK */\n    }\n  else\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"Only unix-process and unix-session subjects can be used for authentication agents.\");\n      goto out;\n    }\n\n  user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, caller, NULL);\n  if (user_of_caller == NULL)\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"Cannot determine user of caller\");\n      goto out;\n    }\n  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, subject, NULL);\n  if (user_of_subject == NULL)\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"Cannot determine user of subject\");\n      goto out;\n    }\n  if (!polkit_identity_equal (user_of_caller, user_of_subject))\n    {\n      if (identity_is_root_user (user_of_caller))\n        {\n          /* explicitly allow uid 0 to register for other users */\n        }\n      else\n        {\n          g_set_error (error,\n                       POLKIT_ERROR,\n                       POLKIT_ERROR_FAILED,\n                       \"User of caller and user of subject differs.\");\n          goto out;\n        }\n    }\n\n  agent = g_hash_table_lookup (priv->hash_scope_to_authentication_agent, subject);\n  if (agent == NULL)\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"No such agent registered\");\n      goto out;\n    }\n\n  if (g_strcmp0 (agent->unique_system_bus_name, polkit_system_bus_name_get_name (POLKIT_SYSTEM_BUS_NAME (caller))) != 0)\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"System bus names do not match\");\n      goto out;\n    }\n\n  if (g_strcmp0 (agent->object_path, object_path) != 0)\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"Object paths do not match\");\n      goto out;\n    }\n\n  scope_str = polkit_subject_to_string (agent->scope);\n  g_debug (\"Removing authentication agent for %s at name %s, object path %s, locale %s\",\n           scope_str,\n           agent->unique_system_bus_name,\n           agent->object_path,\n           agent->locale);\n\n  polkit_backend_authority_log (POLKIT_BACKEND_AUTHORITY (authority),\n                                \"Unregistered Authentication Agent for %s \"\n                                \"(system bus name %s, object path %s, locale %s)\",\n                                scope_str,\n                                agent->unique_system_bus_name,\n                                agent->object_path,\n                                agent->locale);\n  g_free (scope_str);\n\n  authentication_agent_cancel_all_sessions (agent);\n  /* this works because we have exactly one agent per session */\n  /* this frees agent... */\n  g_hash_table_remove (priv->hash_scope_to_authentication_agent, agent->scope);\n\n  g_signal_emit_by_name (authority, \"changed\");\n\n  ret = TRUE;\n\n out:\n  if (user_of_caller != NULL)\n    g_object_unref (user_of_caller);\n  if (user_of_subject != NULL)\n    g_object_unref (user_of_subject);\n  if (session_for_caller != NULL)\n    g_object_unref (session_for_caller);\n  return ret;\n}",
        "func": "static gboolean\npolkit_backend_interactive_authority_unregister_authentication_agent (PolkitBackendAuthority   *authority,\n                                                                      PolkitSubject            *caller,\n                                                                      PolkitSubject            *subject,\n                                                                      const gchar              *object_path,\n                                                                      GError                  **error)\n{\n  PolkitBackendInteractiveAuthority *interactive_authority;\n  PolkitBackendInteractiveAuthorityPrivate *priv;\n  PolkitSubject *session_for_caller;\n  PolkitIdentity *user_of_caller;\n  PolkitIdentity *user_of_subject;\n  gboolean user_of_subject_matches;\n  AuthenticationAgent *agent;\n  gboolean ret;\n  gchar *scope_str;\n\n  interactive_authority = POLKIT_BACKEND_INTERACTIVE_AUTHORITY (authority);\n  priv = POLKIT_BACKEND_INTERACTIVE_AUTHORITY_GET_PRIVATE (interactive_authority);\n\n  ret = FALSE;\n  session_for_caller = NULL;\n  user_of_caller = NULL;\n  user_of_subject = NULL;\n\n  if (POLKIT_IS_UNIX_SESSION (subject))\n    {\n      session_for_caller = polkit_backend_session_monitor_get_session_for_subject (priv->session_monitor,\n                                                                                   caller,\n                                                                                   NULL);\n      if (session_for_caller == NULL)\n        {\n          g_set_error (error,\n                       POLKIT_ERROR,\n                       POLKIT_ERROR_FAILED,\n                       \"Cannot determine session the caller is in\");\n          goto out;\n        }\n\n      if (!polkit_subject_equal (session_for_caller, subject))\n        {\n          g_set_error (error,\n                       POLKIT_ERROR,\n                       POLKIT_ERROR_FAILED,\n                       \"Passed session and the session the caller is in differs. They must be equal for now.\");\n          goto out;\n        }\n    }\n  else if (POLKIT_IS_UNIX_PROCESS (subject))\n    {\n      /* explicitly OK */\n    }\n  else\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"Only unix-process and unix-session subjects can be used for authentication agents.\");\n      goto out;\n    }\n\n  user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, caller, NULL, NULL);\n  if (user_of_caller == NULL)\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"Cannot determine user of caller\");\n      goto out;\n    }\n  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, subject, &user_of_subject_matches, NULL);\n  if (user_of_subject == NULL)\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"Cannot determine user of subject\");\n      goto out;\n    }\n  if (!user_of_subject_matches\n      || !polkit_identity_equal (user_of_caller, user_of_subject))\n    {\n      if (identity_is_root_user (user_of_caller))\n        {\n          /* explicitly allow uid 0 to register for other users */\n        }\n      else\n        {\n          g_set_error (error,\n                       POLKIT_ERROR,\n                       POLKIT_ERROR_FAILED,\n                       \"User of caller and user of subject differs.\");\n          goto out;\n        }\n    }\n\n  agent = g_hash_table_lookup (priv->hash_scope_to_authentication_agent, subject);\n  if (agent == NULL)\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"No such agent registered\");\n      goto out;\n    }\n\n  if (g_strcmp0 (agent->unique_system_bus_name, polkit_system_bus_name_get_name (POLKIT_SYSTEM_BUS_NAME (caller))) != 0)\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"System bus names do not match\");\n      goto out;\n    }\n\n  if (g_strcmp0 (agent->object_path, object_path) != 0)\n    {\n      g_set_error (error,\n                   POLKIT_ERROR,\n                   POLKIT_ERROR_FAILED,\n                   \"Object paths do not match\");\n      goto out;\n    }\n\n  scope_str = polkit_subject_to_string (agent->scope);\n  g_debug (\"Removing authentication agent for %s at name %s, object path %s, locale %s\",\n           scope_str,\n           agent->unique_system_bus_name,\n           agent->object_path,\n           agent->locale);\n\n  polkit_backend_authority_log (POLKIT_BACKEND_AUTHORITY (authority),\n                                \"Unregistered Authentication Agent for %s \"\n                                \"(system bus name %s, object path %s, locale %s)\",\n                                scope_str,\n                                agent->unique_system_bus_name,\n                                agent->object_path,\n                                agent->locale);\n  g_free (scope_str);\n\n  authentication_agent_cancel_all_sessions (agent);\n  /* this works because we have exactly one agent per session */\n  /* this frees agent... */\n  g_hash_table_remove (priv->hash_scope_to_authentication_agent, agent->scope);\n\n  g_signal_emit_by_name (authority, \"changed\");\n\n  ret = TRUE;\n\n out:\n  if (user_of_caller != NULL)\n    g_object_unref (user_of_caller);\n  if (user_of_subject != NULL)\n    g_object_unref (user_of_subject);\n  if (session_for_caller != NULL)\n    g_object_unref (session_for_caller);\n  return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,7 @@\n   PolkitSubject *session_for_caller;\n   PolkitIdentity *user_of_caller;\n   PolkitIdentity *user_of_subject;\n+  gboolean user_of_subject_matches;\n   AuthenticationAgent *agent;\n   gboolean ret;\n   gchar *scope_str;\n@@ -58,7 +59,7 @@\n       goto out;\n     }\n \n-  user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, caller, NULL);\n+  user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, caller, NULL, NULL);\n   if (user_of_caller == NULL)\n     {\n       g_set_error (error,\n@@ -67,7 +68,7 @@\n                    \"Cannot determine user of caller\");\n       goto out;\n     }\n-  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, subject, NULL);\n+  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, subject, &user_of_subject_matches, NULL);\n   if (user_of_subject == NULL)\n     {\n       g_set_error (error,\n@@ -76,7 +77,8 @@\n                    \"Cannot determine user of subject\");\n       goto out;\n     }\n-  if (!polkit_identity_equal (user_of_caller, user_of_subject))\n+  if (!user_of_subject_matches\n+      || !polkit_identity_equal (user_of_caller, user_of_subject))\n     {\n       if (identity_is_root_user (user_of_caller))\n         {",
        "diff_line_info": {
            "deleted_lines": [
                "  user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, caller, NULL);",
                "  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, subject, NULL);",
                "  if (!polkit_identity_equal (user_of_caller, user_of_subject))"
            ],
            "added_lines": [
                "  gboolean user_of_subject_matches;",
                "  user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, caller, NULL, NULL);",
                "  user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, subject, &user_of_subject_matches, NULL);",
                "  if (!user_of_subject_matches",
                "      || !polkit_identity_equal (user_of_caller, user_of_subject))"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-1116",
        "func_name": "polkit/polkit_backend_session_monitor_get_user_for_subject",
        "description": "A flaw was found in polkit before version 0.116. The implementation of the polkit_backend_interactive_authority_check_authorization function in polkitd allows to test for authentication and trigger authentication of unrelated processes owned by other users. This may result in a local DoS and information disclosure.",
        "git_url": "https://cgit.freedesktop.org/polkit/commit/?id=bc7ffad5364",
        "commit_title": "As part of CVE-2013-4288, the D-Bus clients were allowed (and",
        "commit_text": "encouraged) to submit the UID of the subject of authorization checks to avoid races against UID changes (notably using executables set-UID to root).  However, that also allowed any client to submit an arbitrary UID, and that could be used to bypass \"can only ask about / affect the same UID\" checks in CheckAuthorization / RegisterAuthenticationAgent / UnregisterAuthenticationAgent.  This allowed an attacker:  - With CheckAuthorization, to cause the registered authentication   agent in victim's session to pop up a dialog, or to determine whether   the victim currently has a temporary authorization to perform an   operation.    (In principle, the attacker can also determine whether JavaScript   rules allow the victim process to perform an operation; however,   usually rules base their decisions on information determined from   the supplied UID, so the attacker usually won't learn anything new.)  - With RegisterAuthenticationAgent, to prevent the victim's   authentication agent to work (for a specific victim process),   or to learn about which operations requiring authorization   the victim is attempting.  To fix this, expose internal _polkit_unix_process_get_owner() / obsolete polkit_unix_process_get_owner() as a private polkit_unix_process_get_racy_uid__() (being more explicit about the dangers on relying on it), and use it in polkit_backend_session_monitor_get_user_for_subject() to return a boolean indicating whether the subject UID may be caller-chosen.  Then, in the permission checks that require the subject to be equal to the caller, fail on caller-chosen UIDs (and continue through the pre-existing code paths which allow root, or root-designated server processes, to ask about arbitrary subjects.)  ",
        "func_before": "PolkitIdentity *\npolkit_backend_session_monitor_get_user_for_subject (PolkitBackendSessionMonitor  *monitor,\n                                                     PolkitSubject                *subject,\n                                                     GError                      **error)\n{\n  PolkitIdentity *ret;\n  guint32 uid;\n\n  ret = NULL;\n\n  if (POLKIT_IS_UNIX_PROCESS (subject))\n    {\n      uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (subject));\n      if ((gint) uid == -1)\n        {\n          g_set_error (error,\n                       POLKIT_ERROR,\n                       POLKIT_ERROR_FAILED,\n                       \"Unix process subject does not have uid set\");\n          goto out;\n        }\n      ret = polkit_unix_user_new (uid);\n    }\n  else if (POLKIT_IS_SYSTEM_BUS_NAME (subject))\n    {\n      ret = (PolkitIdentity*)polkit_system_bus_name_get_user_sync (POLKIT_SYSTEM_BUS_NAME (subject), NULL, error);\n    }\n  else if (POLKIT_IS_UNIX_SESSION (subject))\n    {\n\n      if (sd_session_get_uid (polkit_unix_session_get_session_id (POLKIT_UNIX_SESSION (subject)), &uid) < 0)\n        {\n          g_set_error (error,\n                       POLKIT_ERROR,\n                       POLKIT_ERROR_FAILED,\n                       \"Error getting uid for session\");\n          goto out;\n        }\n\n      ret = polkit_unix_user_new (uid);\n    }\n\n out:\n  return ret;\n}",
        "func": "PolkitIdentity *\npolkit_backend_session_monitor_get_user_for_subject (PolkitBackendSessionMonitor  *monitor,\n                                                     PolkitSubject                *subject,\n                                                     gboolean                     *result_matches,\n                                                     GError                      **error)\n{\n  PolkitIdentity *ret;\n  gboolean matches;\n\n  ret = NULL;\n  matches = FALSE;\n\n  if (POLKIT_IS_UNIX_PROCESS (subject))\n    {\n      gint subject_uid, current_uid;\n      GError *local_error;\n\n      subject_uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (subject));\n      if (subject_uid == -1)\n        {\n          g_set_error (error,\n                       POLKIT_ERROR,\n                       POLKIT_ERROR_FAILED,\n                       \"Unix process subject does not have uid set\");\n          goto out;\n        }\n      local_error = NULL;\n      current_uid = polkit_unix_process_get_racy_uid__ (POLKIT_UNIX_PROCESS (subject), &local_error);\n      if (local_error != NULL)\n\t{\n\t  g_propagate_error (error, local_error);\n\t  goto out;\n\t}\n      ret = polkit_unix_user_new (subject_uid);\n      matches = (subject_uid == current_uid);\n    }\n  else if (POLKIT_IS_SYSTEM_BUS_NAME (subject))\n    {\n      ret = (PolkitIdentity*)polkit_system_bus_name_get_user_sync (POLKIT_SYSTEM_BUS_NAME (subject), NULL, error);\n      matches = TRUE;\n    }\n  else if (POLKIT_IS_UNIX_SESSION (subject))\n    {\n      uid_t uid;\n\n      if (sd_session_get_uid (polkit_unix_session_get_session_id (POLKIT_UNIX_SESSION (subject)), &uid) < 0)\n        {\n          g_set_error (error,\n                       POLKIT_ERROR,\n                       POLKIT_ERROR_FAILED,\n                       \"Error getting uid for session\");\n          goto out;\n        }\n\n      ret = polkit_unix_user_new (uid);\n      matches = TRUE;\n    }\n\n out:\n  if (result_matches != NULL)\n    {\n      *result_matches = matches;\n    }\n  return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,17 +1,22 @@\n PolkitIdentity *\n polkit_backend_session_monitor_get_user_for_subject (PolkitBackendSessionMonitor  *monitor,\n                                                      PolkitSubject                *subject,\n+                                                     gboolean                     *result_matches,\n                                                      GError                      **error)\n {\n   PolkitIdentity *ret;\n-  guint32 uid;\n+  gboolean matches;\n \n   ret = NULL;\n+  matches = FALSE;\n \n   if (POLKIT_IS_UNIX_PROCESS (subject))\n     {\n-      uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (subject));\n-      if ((gint) uid == -1)\n+      gint subject_uid, current_uid;\n+      GError *local_error;\n+\n+      subject_uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (subject));\n+      if (subject_uid == -1)\n         {\n           g_set_error (error,\n                        POLKIT_ERROR,\n@@ -19,14 +24,24 @@\n                        \"Unix process subject does not have uid set\");\n           goto out;\n         }\n-      ret = polkit_unix_user_new (uid);\n+      local_error = NULL;\n+      current_uid = polkit_unix_process_get_racy_uid__ (POLKIT_UNIX_PROCESS (subject), &local_error);\n+      if (local_error != NULL)\n+\t{\n+\t  g_propagate_error (error, local_error);\n+\t  goto out;\n+\t}\n+      ret = polkit_unix_user_new (subject_uid);\n+      matches = (subject_uid == current_uid);\n     }\n   else if (POLKIT_IS_SYSTEM_BUS_NAME (subject))\n     {\n       ret = (PolkitIdentity*)polkit_system_bus_name_get_user_sync (POLKIT_SYSTEM_BUS_NAME (subject), NULL, error);\n+      matches = TRUE;\n     }\n   else if (POLKIT_IS_UNIX_SESSION (subject))\n     {\n+      uid_t uid;\n \n       if (sd_session_get_uid (polkit_unix_session_get_session_id (POLKIT_UNIX_SESSION (subject)), &uid) < 0)\n         {\n@@ -38,8 +53,13 @@\n         }\n \n       ret = polkit_unix_user_new (uid);\n+      matches = TRUE;\n     }\n \n  out:\n+  if (result_matches != NULL)\n+    {\n+      *result_matches = matches;\n+    }\n   return ret;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  guint32 uid;",
                "      uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (subject));",
                "      if ((gint) uid == -1)",
                "      ret = polkit_unix_user_new (uid);"
            ],
            "added_lines": [
                "                                                     gboolean                     *result_matches,",
                "  gboolean matches;",
                "  matches = FALSE;",
                "      gint subject_uid, current_uid;",
                "      GError *local_error;",
                "",
                "      subject_uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (subject));",
                "      if (subject_uid == -1)",
                "      local_error = NULL;",
                "      current_uid = polkit_unix_process_get_racy_uid__ (POLKIT_UNIX_PROCESS (subject), &local_error);",
                "      if (local_error != NULL)",
                "\t{",
                "\t  g_propagate_error (error, local_error);",
                "\t  goto out;",
                "\t}",
                "      ret = polkit_unix_user_new (subject_uid);",
                "      matches = (subject_uid == current_uid);",
                "      matches = TRUE;",
                "      uid_t uid;",
                "      matches = TRUE;",
                "  if (result_matches != NULL)",
                "    {",
                "      *result_matches = matches;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-1116",
        "func_name": "polkit/polkit_unix_process_get_owner",
        "description": "A flaw was found in polkit before version 0.116. The implementation of the polkit_backend_interactive_authority_check_authorization function in polkitd allows to test for authentication and trigger authentication of unrelated processes owned by other users. This may result in a local DoS and information disclosure.",
        "git_url": "https://cgit.freedesktop.org/polkit/commit/?id=bc7ffad5364",
        "commit_title": "As part of CVE-2013-4288, the D-Bus clients were allowed (and",
        "commit_text": "encouraged) to submit the UID of the subject of authorization checks to avoid races against UID changes (notably using executables set-UID to root).  However, that also allowed any client to submit an arbitrary UID, and that could be used to bypass \"can only ask about / affect the same UID\" checks in CheckAuthorization / RegisterAuthenticationAgent / UnregisterAuthenticationAgent.  This allowed an attacker:  - With CheckAuthorization, to cause the registered authentication   agent in victim's session to pop up a dialog, or to determine whether   the victim currently has a temporary authorization to perform an   operation.    (In principle, the attacker can also determine whether JavaScript   rules allow the victim process to perform an operation; however,   usually rules base their decisions on information determined from   the supplied UID, so the attacker usually won't learn anything new.)  - With RegisterAuthenticationAgent, to prevent the victim's   authentication agent to work (for a specific victim process),   or to learn about which operations requiring authorization   the victim is attempting.  To fix this, expose internal _polkit_unix_process_get_owner() / obsolete polkit_unix_process_get_owner() as a private polkit_unix_process_get_racy_uid__() (being more explicit about the dangers on relying on it), and use it in polkit_backend_session_monitor_get_user_for_subject() to return a boolean indicating whether the subject UID may be caller-chosen.  Then, in the permission checks that require the subject to be equal to the caller, fail on caller-chosen UIDs (and continue through the pre-existing code paths which allow root, or root-designated server processes, to ask about arbitrary subjects.)  ",
        "func_before": "gint\npolkit_unix_process_get_owner (PolkitUnixProcess  *process,\n                               GError            **error)\n{\n  return _polkit_unix_process_get_owner (process, error);\n}",
        "func": "gint\npolkit_unix_process_get_owner (PolkitUnixProcess  *process,\n                               GError            **error)\n{\n  return polkit_unix_process_get_racy_uid__ (process, error);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,5 +2,5 @@\n polkit_unix_process_get_owner (PolkitUnixProcess  *process,\n                                GError            **error)\n {\n-  return _polkit_unix_process_get_owner (process, error);\n+  return polkit_unix_process_get_racy_uid__ (process, error);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  return _polkit_unix_process_get_owner (process, error);"
            ],
            "added_lines": [
                "  return polkit_unix_process_get_racy_uid__ (process, error);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-1116",
        "func_name": "polkit/polkit_unix_process_constructed",
        "description": "A flaw was found in polkit before version 0.116. The implementation of the polkit_backend_interactive_authority_check_authorization function in polkitd allows to test for authentication and trigger authentication of unrelated processes owned by other users. This may result in a local DoS and information disclosure.",
        "git_url": "https://cgit.freedesktop.org/polkit/commit/?id=bc7ffad5364",
        "commit_title": "As part of CVE-2013-4288, the D-Bus clients were allowed (and",
        "commit_text": "encouraged) to submit the UID of the subject of authorization checks to avoid races against UID changes (notably using executables set-UID to root).  However, that also allowed any client to submit an arbitrary UID, and that could be used to bypass \"can only ask about / affect the same UID\" checks in CheckAuthorization / RegisterAuthenticationAgent / UnregisterAuthenticationAgent.  This allowed an attacker:  - With CheckAuthorization, to cause the registered authentication   agent in victim's session to pop up a dialog, or to determine whether   the victim currently has a temporary authorization to perform an   operation.    (In principle, the attacker can also determine whether JavaScript   rules allow the victim process to perform an operation; however,   usually rules base their decisions on information determined from   the supplied UID, so the attacker usually won't learn anything new.)  - With RegisterAuthenticationAgent, to prevent the victim's   authentication agent to work (for a specific victim process),   or to learn about which operations requiring authorization   the victim is attempting.  To fix this, expose internal _polkit_unix_process_get_owner() / obsolete polkit_unix_process_get_owner() as a private polkit_unix_process_get_racy_uid__() (being more explicit about the dangers on relying on it), and use it in polkit_backend_session_monitor_get_user_for_subject() to return a boolean indicating whether the subject UID may be caller-chosen.  Then, in the permission checks that require the subject to be equal to the caller, fail on caller-chosen UIDs (and continue through the pre-existing code paths which allow root, or root-designated server processes, to ask about arbitrary subjects.)  ",
        "func_before": "static void\npolkit_unix_process_constructed (GObject *object)\n{\n  PolkitUnixProcess *process = POLKIT_UNIX_PROCESS (object);\n\n  /* sets start_time and uid in case they are unset */\n\n  if (process->start_time == 0)\n    process->start_time = get_start_time_for_pid (process->pid, NULL);\n\n  if (process->uid == -1)\n    {\n      GError *error;\n      error = NULL;\n      process->uid = _polkit_unix_process_get_owner (process, &error);\n      if (error != NULL)\n        {\n          process->uid = -1;\n          g_error_free (error);\n        }\n    }\n\n  if (G_OBJECT_CLASS (polkit_unix_process_parent_class)->constructed != NULL)\n    G_OBJECT_CLASS (polkit_unix_process_parent_class)->constructed (object);\n}",
        "func": "static void\npolkit_unix_process_constructed (GObject *object)\n{\n  PolkitUnixProcess *process = POLKIT_UNIX_PROCESS (object);\n\n  /* sets start_time and uid in case they are unset */\n\n  if (process->start_time == 0)\n    process->start_time = get_start_time_for_pid (process->pid, NULL);\n\n  if (process->uid == -1)\n    {\n      GError *error;\n      error = NULL;\n      process->uid = polkit_unix_process_get_racy_uid__ (process, &error);\n      if (error != NULL)\n        {\n          process->uid = -1;\n          g_error_free (error);\n        }\n    }\n\n  if (G_OBJECT_CLASS (polkit_unix_process_parent_class)->constructed != NULL)\n    G_OBJECT_CLASS (polkit_unix_process_parent_class)->constructed (object);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,7 @@\n     {\n       GError *error;\n       error = NULL;\n-      process->uid = _polkit_unix_process_get_owner (process, &error);\n+      process->uid = polkit_unix_process_get_racy_uid__ (process, &error);\n       if (error != NULL)\n         {\n           process->uid = -1;",
        "diff_line_info": {
            "deleted_lines": [
                "      process->uid = _polkit_unix_process_get_owner (process, &error);"
            ],
            "added_lines": [
                "      process->uid = polkit_unix_process_get_racy_uid__ (process, &error);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-39184",
        "func_name": "electron/NativeImage::CreateThumbnailFromPath",
        "description": "Electron is a framework for writing cross-platform desktop applications using JavaScript, HTML and CSS. A vulnerability in versions prior to 11.5.0, 12.1.0, and 13.3.0 allows a sandboxed renderer to request a \"thumbnail\" image of an arbitrary file on the user's system. The thumbnail can potentially include significant parts of the original file, including textual data in many cases. Versions 15.0.0-alpha.10, 14.0.0, 13.3.0, 12.1.0, and 11.5.0 all contain a fix for the vulnerability. Two workarounds aside from upgrading are available. One may make the vulnerability significantly more difficult for an attacker to exploit by enabling `contextIsolation` in one's app. One may also disable the functionality of the `createThumbnailFromPath` API if one does not need it.",
        "git_url": "https://github.com/electron/electron/commit/225a64a3bd6d2bda8dfdbb7a39324326f79eb9b2",
        "commit_title": "ScopedCOMInitializer",
        "commit_text": "",
        "func_before": "v8::Local<v8::Promise> NativeImage::CreateThumbnailFromPath(\n    v8::Isolate* isolate,\n    const base::FilePath& path,\n    const gfx::Size& size) {\n  gin_helper::Promise<gfx::Image> promise(isolate);\n  v8::Local<v8::Promise> handle = promise.GetHandle();\n  HRESULT hr;\n\n  if (size.IsEmpty()) {\n    promise.RejectWithErrorMessage(\"size must not be empty\");\n    return handle;\n  }\n\n  // create an IShellItem\n  Microsoft::WRL::ComPtr<IShellItem> pItem;\n  std::wstring image_path = path.value();\n  hr = SHCreateItemFromParsingName(image_path.c_str(), nullptr,\n                                   IID_PPV_ARGS(&pItem));\n\n  if (FAILED(hr)) {\n    promise.RejectWithErrorMessage(\n        \"failed to create IShellItem from the given path\");\n    return handle;\n  }\n\n  // Init thumbnail cache\n  Microsoft::WRL::ComPtr<IThumbnailCache> pThumbnailCache;\n  hr = CoCreateInstance(CLSID_LocalThumbnailCache, nullptr, CLSCTX_INPROC,\n                        IID_PPV_ARGS(&pThumbnailCache));\n  if (FAILED(hr)) {\n    promise.RejectWithErrorMessage(\n        \"failed to acquire local thumbnail cache reference\");\n    return handle;\n  }\n\n  // Populate the IShellBitmap\n  Microsoft::WRL::ComPtr<ISharedBitmap> pThumbnail;\n  WTS_CACHEFLAGS flags;\n  WTS_THUMBNAILID thumbId;\n  hr = pThumbnailCache->GetThumbnail(pItem.Get(), size.width(),\n                                     WTS_FLAGS::WTS_NONE, &pThumbnail, &flags,\n                                     &thumbId);\n\n  if (FAILED(hr)) {\n    promise.RejectWithErrorMessage(\n        \"failed to get thumbnail from local thumbnail cache reference\");\n    return handle;\n  }\n\n  // Init HBITMAP\n  HBITMAP hBitmap = NULL;\n  hr = pThumbnail->GetSharedBitmap(&hBitmap);\n  if (FAILED(hr)) {\n    promise.RejectWithErrorMessage(\"failed to extract bitmap from thumbnail\");\n    return handle;\n  }\n\n  // convert HBITMAP to gfx::Image\n  BITMAP bitmap;\n  if (!GetObject(hBitmap, sizeof(bitmap), &bitmap)) {\n    promise.RejectWithErrorMessage(\"could not convert HBITMAP to BITMAP\");\n    return handle;\n  }\n\n  ICONINFO icon_info;\n  icon_info.fIcon = TRUE;\n  icon_info.hbmMask = hBitmap;\n  icon_info.hbmColor = hBitmap;\n\n  base::win::ScopedHICON icon(CreateIconIndirect(&icon_info));\n  SkBitmap skbitmap = IconUtil::CreateSkBitmapFromHICON(icon.get());\n  gfx::ImageSkia image_skia =\n      gfx::ImageSkia::CreateFromBitmap(skbitmap, 1.0 /*scale factor*/);\n  gfx::Image gfx_image = gfx::Image(image_skia);\n  promise.Resolve(gfx_image);\n  return handle;\n}",
        "func": "v8::Local<v8::Promise> NativeImage::CreateThumbnailFromPath(\n    v8::Isolate* isolate,\n    const base::FilePath& path,\n    const gfx::Size& size) {\n  base::win::ScopedCOMInitializer scoped_com_initializer;\n\n  gin_helper::Promise<gfx::Image> promise(isolate);\n  v8::Local<v8::Promise> handle = promise.GetHandle();\n  HRESULT hr;\n\n  if (size.IsEmpty()) {\n    promise.RejectWithErrorMessage(\"size must not be empty\");\n    return handle;\n  }\n\n  // create an IShellItem\n  Microsoft::WRL::ComPtr<IShellItem> pItem;\n  std::wstring image_path = path.value();\n  hr = SHCreateItemFromParsingName(image_path.c_str(), nullptr,\n                                   IID_PPV_ARGS(&pItem));\n\n  if (FAILED(hr)) {\n    promise.RejectWithErrorMessage(\n        \"failed to create IShellItem from the given path\");\n    return handle;\n  }\n\n  // Init thumbnail cache\n  Microsoft::WRL::ComPtr<IThumbnailCache> pThumbnailCache;\n  hr = CoCreateInstance(CLSID_LocalThumbnailCache, nullptr, CLSCTX_INPROC,\n                        IID_PPV_ARGS(&pThumbnailCache));\n  if (FAILED(hr)) {\n    promise.RejectWithErrorMessage(\n        \"failed to acquire local thumbnail cache reference\");\n    return handle;\n  }\n\n  // Populate the IShellBitmap\n  Microsoft::WRL::ComPtr<ISharedBitmap> pThumbnail;\n  WTS_CACHEFLAGS flags;\n  WTS_THUMBNAILID thumbId;\n  hr = pThumbnailCache->GetThumbnail(pItem.Get(), size.width(),\n                                     WTS_FLAGS::WTS_NONE, &pThumbnail, &flags,\n                                     &thumbId);\n\n  if (FAILED(hr)) {\n    promise.RejectWithErrorMessage(\n        \"failed to get thumbnail from local thumbnail cache reference\");\n    return handle;\n  }\n\n  // Init HBITMAP\n  HBITMAP hBitmap = NULL;\n  hr = pThumbnail->GetSharedBitmap(&hBitmap);\n  if (FAILED(hr)) {\n    promise.RejectWithErrorMessage(\"failed to extract bitmap from thumbnail\");\n    return handle;\n  }\n\n  // convert HBITMAP to gfx::Image\n  BITMAP bitmap;\n  if (!GetObject(hBitmap, sizeof(bitmap), &bitmap)) {\n    promise.RejectWithErrorMessage(\"could not convert HBITMAP to BITMAP\");\n    return handle;\n  }\n\n  ICONINFO icon_info;\n  icon_info.fIcon = TRUE;\n  icon_info.hbmMask = hBitmap;\n  icon_info.hbmColor = hBitmap;\n\n  base::win::ScopedHICON icon(CreateIconIndirect(&icon_info));\n  SkBitmap skbitmap = IconUtil::CreateSkBitmapFromHICON(icon.get());\n  gfx::ImageSkia image_skia =\n      gfx::ImageSkia::CreateFromBitmap(skbitmap, 1.0 /*scale factor*/);\n  gfx::Image gfx_image = gfx::Image(image_skia);\n  promise.Resolve(gfx_image);\n  return handle;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,8 @@\n     v8::Isolate* isolate,\n     const base::FilePath& path,\n     const gfx::Size& size) {\n+  base::win::ScopedCOMInitializer scoped_com_initializer;\n+\n   gin_helper::Promise<gfx::Image> promise(isolate);\n   v8::Local<v8::Promise> handle = promise.GetHandle();\n   HRESULT hr;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  base::win::ScopedCOMInitializer scoped_com_initializer;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-28368",
        "func_name": "xen-project/xen/init_traps",
        "description": "Xen through 4.14.x allows guest OS administrators to obtain sensitive information (such as AES keys from outside the guest) via a side-channel attack on a power/energy monitoring interface, aka a \"Platypus\" attack. NOTE: there is only one logically independent fix: to change the access control for each such interface in Xen.",
        "git_url": "https://github.com/xen-project/xen/commit/628e1becb6fb121475a6ce68e3f1cb4499851255",
        "commit_title": "xen/arm: Always trap AMU system registers",
        "commit_text": " The Activity Monitors Unit (AMU) has been introduced by ARMv8.4. It is considered to be unsafe to be expose to guests as they might expose information about code executed by other guests or the host.  Arm provided a way to trap all the AMU system registers by setting CPTR_EL2.TAM to 1.  Unfortunately, on older revision of the specification, the bit 30 (now CPTR_EL1.TAM) was RES0. Because of that, Xen is setting it to 0 and therefore the system registers would be exposed to the guest when it is run on processors with AMU.  As the bit is mark as UNKNOWN at boot in Armv8.4, the only safe solution for us is to always set CPTR_EL1.TAM to 1.  Guest trying to access the AMU system registers will now receive an undefined instruction. Unfortunately, this means that even well-behaved guest may fail to boot because we don't sanitize the ID registers.  This is a known issues with other Armv8.0+ features (e.g. SVE, Pointer Auth). This will taken care separately.  This is part of XSA-351 (or XSA-93 re-born). ",
        "func_before": "void init_traps(void)\n{\n    /*\n     * Setup Hyp vector base. Note they might get updated with the\n     * branch predictor hardening.\n     */\n    WRITE_SYSREG((vaddr_t)hyp_traps_vector, VBAR_EL2);\n\n    /* Trap Debug and Performance Monitor accesses */\n    WRITE_SYSREG(HDCR_TDRA|HDCR_TDOSA|HDCR_TDA|HDCR_TPM|HDCR_TPMCR,\n                 MDCR_EL2);\n\n    /* Trap CP15 c15 used for implementation defined registers */\n    WRITE_SYSREG(HSTR_T(15), HSTR_EL2);\n\n    /* Trap all coprocessor registers (0-13) except cp10 and\n     * cp11 for VFP.\n     *\n     * /!\\ All coprocessors except cp10 and cp11 cannot be used in Xen.\n     *\n     * On ARM64 the TCPx bits which we set here (0..9,12,13) are all\n     * RES1, i.e. they would trap whether we did this write or not.\n     */\n    WRITE_SYSREG((HCPTR_CP_MASK & ~(HCPTR_CP(10) | HCPTR_CP(11))) | HCPTR_TTA,\n                 CPTR_EL2);\n\n    /*\n     * Configure HCR_EL2 with the bare minimum to run Xen until a guest\n     * is scheduled. {A,I,F}MO bits are set to allow EL2 receiving\n     * interrupts.\n     */\n    WRITE_SYSREG(HCR_AMO | HCR_FMO | HCR_IMO, HCR_EL2);\n    isb();\n}",
        "func": "void init_traps(void)\n{\n    /*\n     * Setup Hyp vector base. Note they might get updated with the\n     * branch predictor hardening.\n     */\n    WRITE_SYSREG((vaddr_t)hyp_traps_vector, VBAR_EL2);\n\n    /* Trap Debug and Performance Monitor accesses */\n    WRITE_SYSREG(HDCR_TDRA|HDCR_TDOSA|HDCR_TDA|HDCR_TPM|HDCR_TPMCR,\n                 MDCR_EL2);\n\n    /* Trap CP15 c15 used for implementation defined registers */\n    WRITE_SYSREG(HSTR_T(15), HSTR_EL2);\n\n    /* Trap all coprocessor registers (0-13) except cp10 and\n     * cp11 for VFP.\n     *\n     * /!\\ All coprocessors except cp10 and cp11 cannot be used in Xen.\n     *\n     * On ARM64 the TCPx bits which we set here (0..9,12,13) are all\n     * RES1, i.e. they would trap whether we did this write or not.\n     */\n    WRITE_SYSREG((HCPTR_CP_MASK & ~(HCPTR_CP(10) | HCPTR_CP(11))) |\n                 HCPTR_TTA | HCPTR_TAM,\n                 CPTR_EL2);\n\n    /*\n     * Configure HCR_EL2 with the bare minimum to run Xen until a guest\n     * is scheduled. {A,I,F}MO bits are set to allow EL2 receiving\n     * interrupts.\n     */\n    WRITE_SYSREG(HCR_AMO | HCR_FMO | HCR_IMO, HCR_EL2);\n    isb();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,7 +21,8 @@\n      * On ARM64 the TCPx bits which we set here (0..9,12,13) are all\n      * RES1, i.e. they would trap whether we did this write or not.\n      */\n-    WRITE_SYSREG((HCPTR_CP_MASK & ~(HCPTR_CP(10) | HCPTR_CP(11))) | HCPTR_TTA,\n+    WRITE_SYSREG((HCPTR_CP_MASK & ~(HCPTR_CP(10) | HCPTR_CP(11))) |\n+                 HCPTR_TTA | HCPTR_TAM,\n                  CPTR_EL2);\n \n     /*",
        "diff_line_info": {
            "deleted_lines": [
                "    WRITE_SYSREG((HCPTR_CP_MASK & ~(HCPTR_CP(10) | HCPTR_CP(11))) | HCPTR_TTA,"
            ],
            "added_lines": [
                "    WRITE_SYSREG((HCPTR_CP_MASK & ~(HCPTR_CP(10) | HCPTR_CP(11))) |",
                "                 HCPTR_TTA | HCPTR_TAM,"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27777",
        "func_name": "kernel/git/powerpc/linux/rtas_initialize",
        "description": "A flaw was found in the way RTAS handled memory accesses in userspace to kernel communication. On a locked down (usually due to Secure Boot) guest system running on top of PowerVM or KVM hypervisors (pseries platform) a root like local user could use this flaw to further increase their privileges to that of a running kernel.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux.git/commit/?h=next&h=bd59380c5ba4147dcbaad3e582b55ccfd120b764",
        "commit_title": "A number of userspace utilities depend on making calls to RTAS to retrieve",
        "commit_text": "information and update various things.  The existing API through which we expose RTAS to userspace exposes more RTAS functionality than we actually need, through the sys_rtas syscall, which allows root (or anyone with CAP_SYS_ADMIN) to make any RTAS call they want with arbitrary arguments.  Many RTAS calls take the address of a buffer as an argument, and it's up to the caller to specify the physical address of the buffer as an argument. We allocate a buffer (the \"RMO buffer\") in the Real Memory Area that RTAS can access, and then expose the physical address and size of this buffer in /proc/powerpc/rtas/rmo_buffer. Userspace is expected to read this address, poke at the buffer using /dev/mem, and pass an address in the RMO buffer to the RTAS call.  However, there's nothing stopping the caller from specifying whatever address they want in the RTAS call, and it's easy to construct a series of RTAS calls that can overwrite arbitrary bytes (even without /dev/mem access).  Additionally, there are some RTAS calls that do potentially dangerous things and for which there are no legitimate userspace use cases.  In the past, this would not have been a particularly big deal as it was assumed that root could modify all system state freely, but with Secure Boot and lockdown we need to care about this.  We can't fundamentally change the ABI at this point, however we can address this by implementing a filter that checks RTAS calls against a list of permitted calls and forces the caller to use addresses within the RMO buffer.  The list is based off the list of calls that are used by the librtas userspace library, and has been tested with a number of existing userspace RTAS utilities. For compatibility with any applications we are not aware of that require other calls, the filter can be turned off at build time.  Cc: stable@vger.kernel.org Link: https://lore.kernel.org/r/20200820044512.7543-1-ajd@linux.ibm.com ",
        "func_before": "void __init rtas_initialize(void)\n{\n\tunsigned long rtas_region = RTAS_INSTANTIATE_MAX;\n\tu32 base, size, entry;\n\tint no_base, no_size, no_entry;\n\n\t/* Get RTAS dev node and fill up our \"rtas\" structure with infos\n\t * about it.\n\t */\n\trtas.dev = of_find_node_by_name(NULL, \"rtas\");\n\tif (!rtas.dev)\n\t\treturn;\n\n\tno_base = of_property_read_u32(rtas.dev, \"linux,rtas-base\", &base);\n\tno_size = of_property_read_u32(rtas.dev, \"rtas-size\", &size);\n\tif (no_base || no_size) {\n\t\tof_node_put(rtas.dev);\n\t\trtas.dev = NULL;\n\t\treturn;\n\t}\n\n\trtas.base = base;\n\trtas.size = size;\n\tno_entry = of_property_read_u32(rtas.dev, \"linux,rtas-entry\", &entry);\n\trtas.entry = no_entry ? rtas.base : entry;\n\n\t/* If RTAS was found, allocate the RMO buffer for it and look for\n\t * the stop-self token if any\n\t */\n#ifdef CONFIG_PPC64\n\tif (firmware_has_feature(FW_FEATURE_LPAR)) {\n\t\trtas_region = min(ppc64_rma_size, RTAS_INSTANTIATE_MAX);\n\t\tibm_suspend_me_token = rtas_token(\"ibm,suspend-me\");\n\t}\n#endif\n\trtas_rmo_buf = memblock_phys_alloc_range(RTAS_RMOBUF_MAX, PAGE_SIZE,\n\t\t\t\t\t\t 0, rtas_region);\n\tif (!rtas_rmo_buf)\n\t\tpanic(\"ERROR: RTAS: Failed to allocate %lx bytes below %pa\\n\",\n\t\t      PAGE_SIZE, &rtas_region);\n\n#ifdef CONFIG_RTAS_ERROR_LOGGING\n\trtas_last_error_token = rtas_token(\"rtas-last-error\");\n#endif\n}",
        "func": "void __init rtas_initialize(void)\n{\n\tunsigned long rtas_region = RTAS_INSTANTIATE_MAX;\n\tu32 base, size, entry;\n\tint no_base, no_size, no_entry;\n#ifdef CONFIG_PPC_RTAS_FILTER\n\tint i;\n#endif\n\n\t/* Get RTAS dev node and fill up our \"rtas\" structure with infos\n\t * about it.\n\t */\n\trtas.dev = of_find_node_by_name(NULL, \"rtas\");\n\tif (!rtas.dev)\n\t\treturn;\n\n\tno_base = of_property_read_u32(rtas.dev, \"linux,rtas-base\", &base);\n\tno_size = of_property_read_u32(rtas.dev, \"rtas-size\", &size);\n\tif (no_base || no_size) {\n\t\tof_node_put(rtas.dev);\n\t\trtas.dev = NULL;\n\t\treturn;\n\t}\n\n\trtas.base = base;\n\trtas.size = size;\n\tno_entry = of_property_read_u32(rtas.dev, \"linux,rtas-entry\", &entry);\n\trtas.entry = no_entry ? rtas.base : entry;\n\n\t/* If RTAS was found, allocate the RMO buffer for it and look for\n\t * the stop-self token if any\n\t */\n#ifdef CONFIG_PPC64\n\tif (firmware_has_feature(FW_FEATURE_LPAR)) {\n\t\trtas_region = min(ppc64_rma_size, RTAS_INSTANTIATE_MAX);\n\t\tibm_suspend_me_token = rtas_token(\"ibm,suspend-me\");\n\t}\n#endif\n\trtas_rmo_buf = memblock_phys_alloc_range(RTAS_RMOBUF_MAX, PAGE_SIZE,\n\t\t\t\t\t\t 0, rtas_region);\n\tif (!rtas_rmo_buf)\n\t\tpanic(\"ERROR: RTAS: Failed to allocate %lx bytes below %pa\\n\",\n\t\t      PAGE_SIZE, &rtas_region);\n\n#ifdef CONFIG_RTAS_ERROR_LOGGING\n\trtas_last_error_token = rtas_token(\"rtas-last-error\");\n#endif\n\n#ifdef CONFIG_PPC_RTAS_FILTER\n\tfor (i = 0; i < ARRAY_SIZE(rtas_filters); i++) {\n\t\trtas_filters[i].token = rtas_token(rtas_filters[i].name);\n\t}\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,9 @@\n \tunsigned long rtas_region = RTAS_INSTANTIATE_MAX;\n \tu32 base, size, entry;\n \tint no_base, no_size, no_entry;\n+#ifdef CONFIG_PPC_RTAS_FILTER\n+\tint i;\n+#endif\n \n \t/* Get RTAS dev node and fill up our \"rtas\" structure with infos\n \t * about it.\n@@ -42,4 +45,10 @@\n #ifdef CONFIG_RTAS_ERROR_LOGGING\n \trtas_last_error_token = rtas_token(\"rtas-last-error\");\n #endif\n+\n+#ifdef CONFIG_PPC_RTAS_FILTER\n+\tfor (i = 0; i < ARRAY_SIZE(rtas_filters); i++) {\n+\t\trtas_filters[i].token = rtas_token(rtas_filters[i].name);\n+\t}\n+#endif\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifdef CONFIG_PPC_RTAS_FILTER",
                "\tint i;",
                "#endif",
                "",
                "#ifdef CONFIG_PPC_RTAS_FILTER",
                "\tfor (i = 0; i < ARRAY_SIZE(rtas_filters); i++) {",
                "\t\trtas_filters[i].token = rtas_token(rtas_filters[i].name);",
                "\t}",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28375",
        "func_name": "torvalds/linux/fastrpc_internal_invoke",
        "description": "An issue was discovered in the Linux kernel through 5.11.6. fastrpc_internal_invoke in drivers/misc/fastrpc.c does not prevent user applications from sending kernel RPC messages, aka CID-20c40794eb85. This is a related issue to CVE-2019-2308.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=20c40794eb85ea29852d7bc37c55713802a543d6",
        "commit_title": "Verify that user applications are not using the kernel RPC message",
        "commit_text": "handle to restrict them from directly attaching to guest OS on the remote subsystem. This is a port of CVE-2019-2308 fix.  Cc: Srinivas Kandagatla <srinivas.kandagatla@linaro.org> Cc: Jonathan Marek <jonathan@marek.ca> Cc: stable@vger.kernel.org Link: https://lore.kernel.org/r/20210212192658.3476137-1-dmitry.baryshkov@linaro.org ",
        "func_before": "static int fastrpc_internal_invoke(struct fastrpc_user *fl,  u32 kernel,\n\t\t\t\t   u32 handle, u32 sc,\n\t\t\t\t   struct fastrpc_invoke_args *args)\n{\n\tstruct fastrpc_invoke_ctx *ctx = NULL;\n\tint err = 0;\n\n\tif (!fl->sctx)\n\t\treturn -EINVAL;\n\n\tif (!fl->cctx->rpdev)\n\t\treturn -EPIPE;\n\n\tctx = fastrpc_context_alloc(fl, kernel, sc, args);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tif (ctx->nscalars) {\n\t\terr = fastrpc_get_args(kernel, ctx);\n\t\tif (err)\n\t\t\tgoto bail;\n\t}\n\n\t/* make sure that all CPU memory writes are seen by DSP */\n\tdma_wmb();\n\t/* Send invoke buffer to remote dsp */\n\terr = fastrpc_invoke_send(fl->sctx, ctx, kernel, handle);\n\tif (err)\n\t\tgoto bail;\n\n\tif (kernel) {\n\t\tif (!wait_for_completion_timeout(&ctx->work, 10 * HZ))\n\t\t\terr = -ETIMEDOUT;\n\t} else {\n\t\terr = wait_for_completion_interruptible(&ctx->work);\n\t}\n\n\tif (err)\n\t\tgoto bail;\n\n\t/* Check the response from remote dsp */\n\terr = ctx->retval;\n\tif (err)\n\t\tgoto bail;\n\n\tif (ctx->nscalars) {\n\t\t/* make sure that all memory writes by DSP are seen by CPU */\n\t\tdma_rmb();\n\t\t/* populate all the output buffers with results */\n\t\terr = fastrpc_put_args(ctx, kernel);\n\t\tif (err)\n\t\t\tgoto bail;\n\t}\n\nbail:\n\tif (err != -ERESTARTSYS && err != -ETIMEDOUT) {\n\t\t/* We are done with this compute context */\n\t\tspin_lock(&fl->lock);\n\t\tlist_del(&ctx->node);\n\t\tspin_unlock(&fl->lock);\n\t\tfastrpc_context_put(ctx);\n\t}\n\tif (err)\n\t\tdev_dbg(fl->sctx->dev, \"Error: Invoke Failed %d\\n\", err);\n\n\treturn err;\n}",
        "func": "static int fastrpc_internal_invoke(struct fastrpc_user *fl,  u32 kernel,\n\t\t\t\t   u32 handle, u32 sc,\n\t\t\t\t   struct fastrpc_invoke_args *args)\n{\n\tstruct fastrpc_invoke_ctx *ctx = NULL;\n\tint err = 0;\n\n\tif (!fl->sctx)\n\t\treturn -EINVAL;\n\n\tif (!fl->cctx->rpdev)\n\t\treturn -EPIPE;\n\n\tif (handle == FASTRPC_INIT_HANDLE && !kernel) {\n\t\tdev_warn_ratelimited(fl->sctx->dev, \"user app trying to send a kernel RPC message (%d)\\n\",  handle);\n\t\treturn -EPERM;\n\t}\n\n\tctx = fastrpc_context_alloc(fl, kernel, sc, args);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\n\tif (ctx->nscalars) {\n\t\terr = fastrpc_get_args(kernel, ctx);\n\t\tif (err)\n\t\t\tgoto bail;\n\t}\n\n\t/* make sure that all CPU memory writes are seen by DSP */\n\tdma_wmb();\n\t/* Send invoke buffer to remote dsp */\n\terr = fastrpc_invoke_send(fl->sctx, ctx, kernel, handle);\n\tif (err)\n\t\tgoto bail;\n\n\tif (kernel) {\n\t\tif (!wait_for_completion_timeout(&ctx->work, 10 * HZ))\n\t\t\terr = -ETIMEDOUT;\n\t} else {\n\t\terr = wait_for_completion_interruptible(&ctx->work);\n\t}\n\n\tif (err)\n\t\tgoto bail;\n\n\t/* Check the response from remote dsp */\n\terr = ctx->retval;\n\tif (err)\n\t\tgoto bail;\n\n\tif (ctx->nscalars) {\n\t\t/* make sure that all memory writes by DSP are seen by CPU */\n\t\tdma_rmb();\n\t\t/* populate all the output buffers with results */\n\t\terr = fastrpc_put_args(ctx, kernel);\n\t\tif (err)\n\t\t\tgoto bail;\n\t}\n\nbail:\n\tif (err != -ERESTARTSYS && err != -ETIMEDOUT) {\n\t\t/* We are done with this compute context */\n\t\tspin_lock(&fl->lock);\n\t\tlist_del(&ctx->node);\n\t\tspin_unlock(&fl->lock);\n\t\tfastrpc_context_put(ctx);\n\t}\n\tif (err)\n\t\tdev_dbg(fl->sctx->dev, \"Error: Invoke Failed %d\\n\", err);\n\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,11 @@\n \n \tif (!fl->cctx->rpdev)\n \t\treturn -EPIPE;\n+\n+\tif (handle == FASTRPC_INIT_HANDLE && !kernel) {\n+\t\tdev_warn_ratelimited(fl->sctx->dev, \"user app trying to send a kernel RPC message (%d)\\n\",  handle);\n+\t\treturn -EPERM;\n+\t}\n \n \tctx = fastrpc_context_alloc(fl, kernel, sc, args);\n \tif (IS_ERR(ctx))",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tif (handle == FASTRPC_INIT_HANDLE && !kernel) {",
                "\t\tdev_warn_ratelimited(fl->sctx->dev, \"user app trying to send a kernel RPC message (%d)\\n\",  handle);",
                "\t\treturn -EPERM;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-40216",
        "func_name": "openbsd/src/wsemul_sun_output_control",
        "description": "OpenBSD 7.3 before errata 014 is missing an argument-count bounds check in console terminal emulation. This could cause incorrect memory access and a kernel crash after receiving crafted DCS or CSI terminal escape sequences.",
        "git_url": "https://github.com/openbsd/src/commit/9d3f688f46eba347e96ff0ae9506ef2061622e0c",
        "commit_title": "Make sure we do not increase the escape sequence argument count beyond usable",
        "commit_text": "bounds, in case escape sequences end up with too many semicolons. Without this, the kernel could be made to access random memory after receiving some specially crafted DCS or CSI terminal escape sequences.  Reported by David Leadbeater (dgl, dgl dot cx)",
        "func_before": "int\nwsemul_sun_output_control(struct wsemul_sun_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tint oargs;\n\tint rc;\n\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4': /* argument digit */\n\tcase '5': case '6': case '7': case '8': case '9':\n\t\t/*\n\t\t * If we receive more arguments than we are expecting,\n\t\t * discard the earliest arguments.\n\t\t */\n\t\tif (edp->nargs > SUN_EMUL_NARGS - 1) {\n\t\t\tbcopy(edp->args + 1, edp->args,\n\t\t\t    (SUN_EMUL_NARGS - 1) * sizeof(edp->args[0]));\n\t\t\tedp->args[edp->nargs = SUN_EMUL_NARGS - 1] = 0;\n\t\t}\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\n\tcase ';':\t\t/* argument terminator */\n\t\tedp->nargs++;\n\t\tbreak;\n\n\tdefault:\t\t/* end of escape sequence */\n\t\toargs = edp->nargs++;\n\t\tif (edp->nargs > SUN_EMUL_NARGS)\n\t\t\tedp->nargs = SUN_EMUL_NARGS;\n\t\trc = wsemul_sun_control(edp, instate);\n\t\tif (rc != 0) {\n\t\t\t/* undo nargs progress */\n\t\t\tedp->nargs = oargs;\n\n\t\t\treturn rc;\n\t\t}\n\t\tedp->state = SUN_EMUL_STATE_NORMAL;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
        "func": "int\nwsemul_sun_output_control(struct wsemul_sun_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tint oargs;\n\tint rc;\n\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4': /* argument digit */\n\tcase '5': case '6': case '7': case '8': case '9':\n\t\t/*\n\t\t * If we receive more arguments than we are expecting,\n\t\t * discard the earliest arguments.\n\t\t */\n\t\tif (edp->nargs > SUN_EMUL_NARGS - 1) {\n\t\t\tbcopy(edp->args + 1, edp->args,\n\t\t\t    (SUN_EMUL_NARGS - 1) * sizeof(edp->args[0]));\n\t\t\tedp->args[edp->nargs = SUN_EMUL_NARGS - 1] = 0;\n\t\t}\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\n\tcase ';':\t\t/* argument terminator */\n\t\tif (edp->nargs < SUN_EMUL_NARGS)\n\t\t\tedp->nargs++;\n\t\tbreak;\n\n\tdefault:\t\t/* end of escape sequence */\n\t\toargs = edp->nargs;\n\t\tif (edp->nargs < SUN_EMUL_NARGS)\n\t\t\tedp->nargs++;\n\t\trc = wsemul_sun_control(edp, instate);\n\t\tif (rc != 0) {\n\t\t\t/* undo nargs progress */\n\t\t\tedp->nargs = oargs;\n\n\t\t\treturn rc;\n\t\t}\n\t\tedp->state = SUN_EMUL_STATE_NORMAL;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,13 +22,14 @@\n \t\tbreak;\n \n \tcase ';':\t\t/* argument terminator */\n-\t\tedp->nargs++;\n+\t\tif (edp->nargs < SUN_EMUL_NARGS)\n+\t\t\tedp->nargs++;\n \t\tbreak;\n \n \tdefault:\t\t/* end of escape sequence */\n-\t\toargs = edp->nargs++;\n-\t\tif (edp->nargs > SUN_EMUL_NARGS)\n-\t\t\tedp->nargs = SUN_EMUL_NARGS;\n+\t\toargs = edp->nargs;\n+\t\tif (edp->nargs < SUN_EMUL_NARGS)\n+\t\t\tedp->nargs++;\n \t\trc = wsemul_sun_control(edp, instate);\n \t\tif (rc != 0) {\n \t\t\t/* undo nargs progress */",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tedp->nargs++;",
                "\t\toargs = edp->nargs++;",
                "\t\tif (edp->nargs > SUN_EMUL_NARGS)",
                "\t\t\tedp->nargs = SUN_EMUL_NARGS;"
            ],
            "added_lines": [
                "\t\tif (edp->nargs < SUN_EMUL_NARGS)",
                "\t\t\tedp->nargs++;",
                "\t\toargs = edp->nargs;",
                "\t\tif (edp->nargs < SUN_EMUL_NARGS)",
                "\t\t\tedp->nargs++;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-40216",
        "func_name": "openbsd/src/wsemul_vt100_output_dcs",
        "description": "OpenBSD 7.3 before errata 014 is missing an argument-count bounds check in console terminal emulation. This could cause incorrect memory access and a kernel crash after receiving crafted DCS or CSI terminal escape sequences.",
        "git_url": "https://github.com/openbsd/src/commit/9d3f688f46eba347e96ff0ae9506ef2061622e0c",
        "commit_title": "Make sure we do not increase the escape sequence argument count beyond usable",
        "commit_text": "bounds, in case escape sequences end up with too many semicolons. Without this, the kernel could be made to access random memory after receiving some specially crafted DCS or CSI terminal escape sequences.  Reported by David Leadbeater (dgl, dgl dot cx)",
        "func_before": "int\nwsemul_vt100_output_dcs(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int newstate = VT100_EMUL_STATE_DCS;\n\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4':\n\tcase '5': case '6': case '7': case '8': case '9':\n\t\t/* argument digit */\n\t\tif (edp->nargs > VT100_EMUL_NARGS - 1)\n\t\t\tbreak;\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\tcase ';': /* argument terminator */\n\t\tedp->nargs++;\n\t\tbreak;\n\tdefault:\n\t\tedp->nargs++;\n\t\tif (edp->nargs > VT100_EMUL_NARGS) {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"vt100: too many arguments\\n\");\n#endif\n\t\t\tedp->nargs = VT100_EMUL_NARGS;\n\t\t}\n\t\tnewstate = VT100_EMUL_STATE_STRING;\n\t\tswitch (instate->inchar) {\n\t\tcase '$':\n\t\t\tnewstate = VT100_EMUL_STATE_DCS_DOLLAR;\n\t\t\tbreak;\n\t\tcase '{': /* DECDLD soft charset */\t/* } */\n\t\tcase '!': /* DECRQUPSS user preferred supplemental set */\n\t\t\t/* 'u' must follow - need another state */\n\t\tcase '|': /* DECUDK program F6..F20 */\n#ifdef VT100_PRINTNOTIMPL\n\t\t\tprintf(\"DCS%c ignored\\n\", (char)instate->inchar);\n#endif\n\t\t\tbreak;\n\t\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"DCS %x (%d, %d) unknown\\n\", instate->inchar,\n\t\t\t    ARG(0), ARG(1));\n#endif\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tedp->state = newstate;\n\treturn 0;\n}",
        "func": "int\nwsemul_vt100_output_dcs(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int newstate = VT100_EMUL_STATE_DCS;\n\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4':\n\tcase '5': case '6': case '7': case '8': case '9':\n\t\t/* argument digit */\n\t\tif (edp->nargs > VT100_EMUL_NARGS - 1)\n\t\t\tbreak;\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\tcase ';': /* argument terminator */\n\t\tif (edp->nargs < VT100_EMUL_NARGS)\n\t\t\tedp->nargs++;\n\t\tbreak;\n\tdefault:\n\t\tif (edp->nargs < VT100_EMUL_NARGS)\n\t\t\tedp->nargs++;\n\t\tnewstate = VT100_EMUL_STATE_STRING;\n\t\tswitch (instate->inchar) {\n\t\tcase '$':\n\t\t\tnewstate = VT100_EMUL_STATE_DCS_DOLLAR;\n\t\t\tbreak;\n\t\tcase '{': /* DECDLD soft charset */\t/* } */\n\t\tcase '!': /* DECRQUPSS user preferred supplemental set */\n\t\t\t/* 'u' must follow - need another state */\n\t\tcase '|': /* DECUDK program F6..F20 */\n#ifdef VT100_PRINTNOTIMPL\n\t\t\tprintf(\"DCS%c ignored\\n\", (char)instate->inchar);\n#endif\n\t\t\tbreak;\n\t\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"DCS %x (%d, %d) unknown\\n\", instate->inchar,\n\t\t\t    ARG(0), ARG(1));\n#endif\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tedp->state = newstate;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,16 +14,12 @@\n \t\t    (instate->inchar - '0');\n \t\tbreak;\n \tcase ';': /* argument terminator */\n-\t\tedp->nargs++;\n+\t\tif (edp->nargs < VT100_EMUL_NARGS)\n+\t\t\tedp->nargs++;\n \t\tbreak;\n \tdefault:\n-\t\tedp->nargs++;\n-\t\tif (edp->nargs > VT100_EMUL_NARGS) {\n-#ifdef VT100_DEBUG\n-\t\t\tprintf(\"vt100: too many arguments\\n\");\n-#endif\n-\t\t\tedp->nargs = VT100_EMUL_NARGS;\n-\t\t}\n+\t\tif (edp->nargs < VT100_EMUL_NARGS)\n+\t\t\tedp->nargs++;\n \t\tnewstate = VT100_EMUL_STATE_STRING;\n \t\tswitch (instate->inchar) {\n \t\tcase '$':",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tedp->nargs++;",
                "\t\tedp->nargs++;",
                "\t\tif (edp->nargs > VT100_EMUL_NARGS) {",
                "#ifdef VT100_DEBUG",
                "\t\t\tprintf(\"vt100: too many arguments\\n\");",
                "#endif",
                "\t\t\tedp->nargs = VT100_EMUL_NARGS;",
                "\t\t}"
            ],
            "added_lines": [
                "\t\tif (edp->nargs < VT100_EMUL_NARGS)",
                "\t\t\tedp->nargs++;",
                "\t\tif (edp->nargs < VT100_EMUL_NARGS)",
                "\t\t\tedp->nargs++;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-40216",
        "func_name": "openbsd/src/wsemul_vt100_output_csi",
        "description": "OpenBSD 7.3 before errata 014 is missing an argument-count bounds check in console terminal emulation. This could cause incorrect memory access and a kernel crash after receiving crafted DCS or CSI terminal escape sequences.",
        "git_url": "https://github.com/openbsd/src/commit/9d3f688f46eba347e96ff0ae9506ef2061622e0c",
        "commit_title": "Make sure we do not increase the escape sequence argument count beyond usable",
        "commit_text": "bounds, in case escape sequences end up with too many semicolons. Without this, the kernel could be made to access random memory after receiving some specially crafted DCS or CSI terminal escape sequences.  Reported by David Leadbeater (dgl, dgl dot cx)",
        "func_before": "int\nwsemul_vt100_output_csi(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int newstate = VT100_EMUL_STATE_CSI;\n\tint oargs;\n\tint rc = 0;\n\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4':\n\tcase '5': case '6': case '7': case '8': case '9':\n\t\t/* argument digit */\n\t\tif (edp->nargs > VT100_EMUL_NARGS - 1)\n\t\t\tbreak;\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\tcase ';': /* argument terminator */\n\t\tedp->nargs++;\n\t\tbreak;\n\tcase '?': /* DEC specific */\n\tcase '>': /* DA query */\n\t\tedp->modif1 = (char)instate->inchar;\n\t\tbreak;\n\tcase '!':\n\tcase '\"':\n\tcase '$':\n\tcase '&':\n\t\tedp->modif2 = (char)instate->inchar;\n\t\tbreak;\n\tdefault: /* end of escape sequence */\n\t\toargs = edp->nargs++;\n\t\tif (edp->nargs > VT100_EMUL_NARGS) {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"vt100: too many arguments\\n\");\n#endif\n\t\t\tedp->nargs = VT100_EMUL_NARGS;\n\t\t}\n\t\trc = wsemul_vt100_handle_csi(edp, instate);\n\t\tif (rc != 0) {\n\t\t\tedp->nargs = oargs;\n\t\t\treturn rc;\n\t\t}\n\t\tnewstate = VT100_EMUL_STATE_NORMAL;\n\t\tbreak;\n\t}\n\n\tif (COLS_LEFT != 0)\n\t\tedp->flags &= ~VTFL_LASTCHAR;\n\n\tedp->state = newstate;\n\treturn 0;\n}",
        "func": "int\nwsemul_vt100_output_csi(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int newstate = VT100_EMUL_STATE_CSI;\n\tint oargs;\n\tint rc = 0;\n\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4':\n\tcase '5': case '6': case '7': case '8': case '9':\n\t\t/* argument digit */\n\t\tif (edp->nargs > VT100_EMUL_NARGS - 1)\n\t\t\tbreak;\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\tcase ';': /* argument terminator */\n\t\tif (edp->nargs < VT100_EMUL_NARGS)\n\t\t\tedp->nargs++;\n\t\tbreak;\n\tcase '?': /* DEC specific */\n\tcase '>': /* DA query */\n\t\tedp->modif1 = (char)instate->inchar;\n\t\tbreak;\n\tcase '!':\n\tcase '\"':\n\tcase '$':\n\tcase '&':\n\t\tedp->modif2 = (char)instate->inchar;\n\t\tbreak;\n\tdefault: /* end of escape sequence */\n\t\toargs = edp->nargs;\n\t\tif (edp->nargs < VT100_EMUL_NARGS)\n\t\t\tedp->nargs++;\n\t\trc = wsemul_vt100_handle_csi(edp, instate);\n\t\tif (rc != 0) {\n\t\t\tedp->nargs = oargs;\n\t\t\treturn rc;\n\t\t}\n\t\tnewstate = VT100_EMUL_STATE_NORMAL;\n\t\tbreak;\n\t}\n\n\tif (COLS_LEFT != 0)\n\t\tedp->flags &= ~VTFL_LASTCHAR;\n\n\tedp->state = newstate;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,7 +16,8 @@\n \t\t    (instate->inchar - '0');\n \t\tbreak;\n \tcase ';': /* argument terminator */\n-\t\tedp->nargs++;\n+\t\tif (edp->nargs < VT100_EMUL_NARGS)\n+\t\t\tedp->nargs++;\n \t\tbreak;\n \tcase '?': /* DEC specific */\n \tcase '>': /* DA query */\n@@ -29,13 +30,9 @@\n \t\tedp->modif2 = (char)instate->inchar;\n \t\tbreak;\n \tdefault: /* end of escape sequence */\n-\t\toargs = edp->nargs++;\n-\t\tif (edp->nargs > VT100_EMUL_NARGS) {\n-#ifdef VT100_DEBUG\n-\t\t\tprintf(\"vt100: too many arguments\\n\");\n-#endif\n-\t\t\tedp->nargs = VT100_EMUL_NARGS;\n-\t\t}\n+\t\toargs = edp->nargs;\n+\t\tif (edp->nargs < VT100_EMUL_NARGS)\n+\t\t\tedp->nargs++;\n \t\trc = wsemul_vt100_handle_csi(edp, instate);\n \t\tif (rc != 0) {\n \t\t\tedp->nargs = oargs;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tedp->nargs++;",
                "\t\toargs = edp->nargs++;",
                "\t\tif (edp->nargs > VT100_EMUL_NARGS) {",
                "#ifdef VT100_DEBUG",
                "\t\t\tprintf(\"vt100: too many arguments\\n\");",
                "#endif",
                "\t\t\tedp->nargs = VT100_EMUL_NARGS;",
                "\t\t}"
            ],
            "added_lines": [
                "\t\tif (edp->nargs < VT100_EMUL_NARGS)",
                "\t\t\tedp->nargs++;",
                "\t\toargs = edp->nargs;",
                "\t\tif (edp->nargs < VT100_EMUL_NARGS)",
                "\t\t\tedp->nargs++;"
            ]
        }
    }
]